--- a/src/coreclr/debug/daccess/dacdbiimpl.cpp
+++ b/src/coreclr/debug/daccess/dacdbiimpl.cpp
@@ -3155,24 +3155,20 @@
 #else
     ThrowHR(E_NOTIMPL);
 #endif
 }
 GENERICS_TYPE_TOKEN DacDbiInterfaceImpl::ResolveExactGenericArgsToken(DWORD               dwExactGenericArgsTokenIndex,
                                                                       GENERICS_TYPE_TOKEN rawToken)
 {
     DD_ENTER_MAY_THROW;
     if (dwExactGenericArgsTokenIndex == 0)
     {
-        if (rawToken == 0)
-        {
-            return rawToken;
-        }
         TADDR addrObjThis = CORDB_ADDRESS_TO_TADDR(rawToken);
         PTR_Object pObjThis = dac_cast<PTR_Object>(addrObjThis);
         PTR_MethodTable pMT = pObjThis->GetMethodTable();
         TADDR addrMT = dac_cast<TADDR>(pMT);
         GENERICS_TYPE_TOKEN realToken = (GENERICS_TYPE_TOKEN) addrMT;
         return realToken;
     }
     else if (dwExactGenericArgsTokenIndex == (DWORD)ICorDebugInfo::TYPECTXT_ILNUM)
     {
         return  rawToken;

--- a/src/coreclr/pal/src/exception/machexception.cpp
+++ b/src/coreclr/pal/src/exception/machexception.cpp
@@ -253,32 +253,35 @@
 }
 #if defined(HOST_AMD64)
 extern "C"
 void PAL_DispatchException(DWORD64 dwRDI, DWORD64 dwRSI, DWORD64 dwRDX, DWORD64 dwRCX, DWORD64 dwR8, DWORD64 dwR9, PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
 #elif defined(HOST_ARM64)
 extern "C"
 void PAL_DispatchException(PCONTEXT pContext, PEXCEPTION_RECORD pExRecord, MachExceptionInfo *pMachExceptionInfo)
 #endif
 {
     CPalThread *pThread = InternalGetCurrentThread();
-    CONTEXT *contextRecord = pContext;
-    g_hardware_exception_context_locvar_offset = (int)((char*)&contextRecord - (char*)__builtin_frame_address(0));
-    pContext->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
+    CONTEXT *contextRecord;
+    EXCEPTION_RECORD *exceptionRecord;
+    AllocateExceptionRecords(&exceptionRecord, &contextRecord);
+    *contextRecord = *pContext;
+    *exceptionRecord = *pExRecord;
+    contextRecord->ContextFlags |= CONTEXT_EXCEPTION_ACTIVE;
     bool continueExecution;
     {
-        PAL_SEHException exception(pExRecord, pContext, true);
+        PAL_SEHException exception(exceptionRecord, contextRecord);
         TRACE("PAL_DispatchException(EC %08x EA %p)\n", pExRecord->ExceptionCode, pExRecord->ExceptionAddress);
         continueExecution = SEHProcessException(&exception);
         if (continueExecution)
         {
-            *pContext = *exception.ExceptionPointers.ContextRecord;
-            *pExRecord = *exception.ExceptionPointers.ExceptionRecord;
+            *pContext = *contextRecord;
+            *pExRecord = *exceptionRecord;
         }
     }
     if (continueExecution)
     {
 #if defined(HOST_ARM64)
         MachSetThreadContext(pContext);
 #else
         RtlRestoreContext(pContext, pExRecord);
 #endif
     }

--- a/src/coreclr/pal/src/exception/seh-unwind.cpp
+++ b/src/coreclr/pal/src/exception/seh-unwind.cpp
@@ -415,33 +415,35 @@
     GetContextPointer(cursor, unwContext, UNW_S390X_R11, &contextPointers->R11);
     GetContextPointer(cursor, unwContext, UNW_S390X_R12, &contextPointers->R12);
     GetContextPointer(cursor, unwContext, UNW_S390X_R13, &contextPointers->R13);
     GetContextPointer(cursor, unwContext, UNW_S390X_R14, &contextPointers->R14);
     GetContextPointer(cursor, unwContext, UNW_S390X_R15, &contextPointers->R15);
 #else
 #error unsupported architecture
 #endif
 }
 #ifndef HOST_WINDOWS
-int g_hardware_exception_context_locvar_offset = 0;
+extern int g_common_signal_handler_context_locvar_offset;
 BOOL PAL_VirtualUnwind(CONTEXT *context, KNONVOLATILE_CONTEXT_POINTERS *contextPointers)
 {
     int st;
     unw_context_t unwContext;
     unw_cursor_t cursor;
     DWORD64 curPc = CONTEXTGetPC(context);
+#ifndef __APPLE__
     if ((void*)curPc == g_SEHProcessExceptionReturnAddress)
     {
-        CONTEXT* exceptionContext = *(CONTEXT**)(CONTEXTGetFP(context) + g_hardware_exception_context_locvar_offset);
-        memcpy_s(context, sizeof(CONTEXT), exceptionContext, sizeof(CONTEXT));
+        CONTEXT* signalContext = (CONTEXT*)(CONTEXTGetFP(context) + g_common_signal_handler_context_locvar_offset);
+        memcpy_s(context, sizeof(CONTEXT), signalContext, sizeof(CONTEXT));
         return TRUE;
     }
+#endif
     if ((context->ContextFlags & CONTEXT_EXCEPTION_ACTIVE) != 0)
     {
         CONTEXTSetPC(context, curPc + 1);
     }
 #if !UNWIND_CONTEXT_IS_UCONTEXT_T
 #if defined(__llvm__) && defined(TARGET_ARM)
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Winline-asm"
 #endif
     st = unw_getcontext(&unwContext);

--- a/src/coreclr/pal/src/exception/signal.cpp
+++ b/src/coreclr/pal/src/exception/signal.cpp
@@ -70,20 +70,21 @@
 #endif
 struct sigaction g_previous_sigill;
 struct sigaction g_previous_sigtrap;
 struct sigaction g_previous_sigfpe;
 struct sigaction g_previous_sigbus;
 struct sigaction g_previous_sigsegv;
 struct sigaction g_previous_sigint;
 struct sigaction g_previous_sigquit;
 struct sigaction g_previous_sigabrt;
 #if !HAVE_MACH_EXCEPTIONS
+int g_common_signal_handler_context_locvar_offset = 0;
 volatile void* g_stackOverflowHandlerStack = NULL;
 const int StackOverflowFlag = 0x40000000;
 #endif // !HAVE_MACH_EXCEPTIONS
 /* public function definitions ************************************************/
 /*++
 Function :
     SEHInitializeSignals
     Set up signal handlers to catch signals and translate them to exceptions
 Parameters :
     None
@@ -665,25 +666,24 @@
 Note:
     the "pointers" parameter should contain a valid exception record pointer,
     but the ContextRecord pointer will be overwritten.
 --*/
 __attribute__((noinline))
 static bool common_signal_handler(int code, siginfo_t *siginfo, void *sigcontext, int numParams, ...)
 {
 #if !HAVE_MACH_EXCEPTIONS
     sigset_t signal_set;
     CONTEXT signalContextRecord;
-    CONTEXT* signalContextRecordPtr = &signalContextRecord;
     EXCEPTION_RECORD exceptionRecord;
     native_context_t *ucontext;
     ucontext = (native_context_t *)sigcontext;
-    g_hardware_exception_context_locvar_offset = (int)((char*)&signalContextRecordPtr - (char*)__builtin_frame_address(0));
+    g_common_signal_handler_context_locvar_offset = (int)((char*)&signalContextRecord - (char*)__builtin_frame_address(0));
     if (code == (SIGSEGV | StackOverflowFlag))
     {
         exceptionRecord.ExceptionCode = EXCEPTION_STACK_OVERFLOW;
         code &= ~StackOverflowFlag;
     }
     else
     {
         exceptionRecord.ExceptionCode = CONTEXTGetExceptionCodeForSignal(siginfo, ucontext);
     }
     exceptionRecord.ExceptionFlags = EXCEPTION_IS_SIGNAL;

--- a/src/coreclr/pal/src/include/pal/seh.hpp
+++ b/src/coreclr/pal/src/include/pal/seh.hpp
@@ -90,12 +90,11 @@
     SEHDisable
     Disable SEH-related stuff on this thread
 Parameters:
     CPalThread * pthrCurrent : reference to the current thread.
 Return value :
     ERROR_SUCCESS, if enabling succeeded
     an error code, otherwise
 --*/
 CorUnix::PAL_ERROR SEHDisable(CorUnix::CPalThread *pthrCurrent);
 }
-extern int g_hardware_exception_context_locvar_offset;
 #endif /* _PAL_SEH_HPP_ */

--- a/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/ReadyToRunHashCode.cs
+++ b/src/coreclr/tools/aot/ILCompiler.ReadyToRun/Compiler/ReadyToRunHashCode.cs
@@ -11,24 +11,24 @@
         {
             if (string.IsNullOrEmpty(name))
             {
                 return 0;
             }
             int hash1 = 0x6DA3B944;
             int hash2 = 0;
             byte[] src = Encoding.UTF8.GetBytes(name);
             for (int i = 0; i < src.Length; i += 2)
             {
-                hash1 = unchecked(hash1 + RotateLeft(hash1, 5)) ^ (int)unchecked((sbyte)src[i]);
+                hash1 = unchecked(hash1 + RotateLeft(hash1, 5)) ^ src[i];
                 if (i + 1 < src.Length)
                 {
-                    hash2 = unchecked(hash2 + RotateLeft(hash2, 5)) ^ (int)unchecked((sbyte)src[i + 1]);
+                    hash2 = unchecked(hash2 + RotateLeft(hash2, 5)) ^ src[i + 1];
                 }
                 else
                 {
                     break;
                 }
             }
             hash1 = unchecked(hash1 + RotateLeft(hash1, 8));
             hash2 = unchecked(hash2 + RotateLeft(hash2, 8));
             return unchecked((int)(hash1 ^ hash2));
         }

--- a/src/coreclr/vm/proftoeeinterfaceimpl.cpp
+++ b/src/coreclr/vm/proftoeeinterfaceimpl.cpp
@@ -692,21 +692,21 @@
 {
     CONTRACTL
     {
         NOTHROW;
         GC_NOTRIGGER;
         MODE_ANY;
     }
     CONTRACTL_END;
     _ASSERTE(pv != NULL);
     {
-        BEGIN_PROFILER_CALLBACK(CORProfilerTrackGC());
+        BEGIN_PROFILER_CALLBACK(CORProfilerTrackAllocations());
         g_profControlBlock.AllocByClass(
             (ObjectID) pBO,
             SafeGetClassIDFromObject(pBO),
             pv);
         END_PROFILER_CALLBACK();
     }
     return TRUE;
 }
 #endif // PROFILING_SUPPORTED
 #if defined(GC_PROFILING) || defined(FEATURE_EVENT_TRACE)

--- a/src/coreclr/vm/syncblk.h
+++ b/src/coreclr/vm/syncblk.h
@@ -381,23 +381,20 @@
     friend class RCWHolder;
     friend class ClrDataAccess;
 public:
 #ifndef TARGET_UNIX
     static SLIST_HEADER s_InteropInfoStandbyList;
 #endif // !TARGET_UNIX
     InteropSyncBlockInfo()
     {
         LIMITED_METHOD_CONTRACT;
         ZeroMemory(this, sizeof(InteropSyncBlockInfo));
-#if defined(FEATURE_COMWRAPPERS)
-        m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
-#endif // FEATURE_COMWRAPPERS
     }
 #ifndef DACCESS_COMPILE
     ~InteropSyncBlockInfo();
 #endif
 #ifndef TARGET_UNIX
     static void FlushStandbyList();
 #endif // !TARGET_UNIX
 #ifdef FEATURE_COMINTEROP
 #ifndef DACCESS_COMPILE
     RCW* GetRawRCW()
@@ -508,20 +505,21 @@
 #ifndef DACCESS_COMPILE
     bool TrySetManagedObjectComWrapper(_In_ INT64 wrapperId, _In_ void* mocw, _In_ void* curr = NULL)
     {
         LIMITED_METHOD_CONTRACT;
         if (m_managedObjectComWrapperMap == NULL)
         {
             NewHolder<ManagedObjectComWrapperByIdMap> map = new ManagedObjectComWrapperByIdMap();
             if (FastInterlockCompareExchangePointer((ManagedObjectComWrapperByIdMap**)&m_managedObjectComWrapperMap, (ManagedObjectComWrapperByIdMap *)map, NULL) == NULL)
             {
                 map.SuppressRelease();
+                m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
             }
             _ASSERTE(m_managedObjectComWrapperMap != NULL);
         }
         CrstHolder lock(&m_managedObjectComWrapperLock);
         if (m_managedObjectComWrapperMap->LookupPtr(wrapperId) != curr)
             return false;
         m_managedObjectComWrapperMap->Add(wrapperId, mocw);
         return true;
     }
     using ClearWrappersCallback = void(void* mocw);

--- a/src/libraries/Common/src/Interop/OSX/Interop.libproc.cs
+++ b/src/libraries/Common/src/Interop/OSX/Interop.libproc.cs
@@ -7,21 +7,20 @@
 internal static partial class Interop
 {
     internal static partial class libproc
     {
         private const int MAXPATHLEN = 1024;
         private const int MAXTHREADNAMESIZE = 64;
         private const int PROC_PIDTHREADINFO = 5;
         private const int PROC_PIDLISTTHREADS = 6;
         private const int PROC_PIDPATHINFO_MAXSIZE = 4 * MAXPATHLEN;
         private const int RUSAGE_INFO_V3 = 3;
-        private const int EPERM = 1;
         internal enum ThreadRunState
         {
             TH_STATE_RUNNING            = 1,
             TH_STATE_STOPPED            = 2,
             TH_STATE_WAITING            = 3,
             TH_STATE_UNINTERRUPTIBLE    = 4,
             TH_STATE_HALTED             = 5
         }
         [Flags]
         internal enum ThreadFlags
@@ -82,25 +81,21 @@
             internal int proc_fd;
             internal uint proc_fdtype;
         }
         [DllImport(Interop.Libraries.libproc, SetLastError = true)]
         private static extern unsafe int proc_listallpids(
             int*    pBuffer,
             int     buffersize);
         internal static unsafe int[] proc_listallpids()
         {
             int numProcesses = proc_listallpids(null, 0);
-            if (numProcesses == 0 && Marshal.GetLastPInvokeError() == EPERM)
-            {
-                return new[] { Environment.ProcessId };
-            }
-            else if (numProcesses <= 0)
+            if (numProcesses <= 0)
             {
                 throw new Win32Exception(SR.CantGetAllPids);
             }
             int[] processes;
             do
             {
                 processes = new int[(int)(numProcesses * 1.10)];
                 fixed (int* pBuffer = &processes[0])
                 {
                     numProcesses = proc_listallpids(pBuffer, processes.Length * sizeof(int));

--- a/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.EvpPkey.cs
+++ b/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.EvpPkey.cs
@@ -75,39 +75,29 @@
                     (int)algorithmId);
             }
             if (handle.IsInvalid)
             {
                 handle.Dispose();
                 throw CreateOpenSslCryptographicException();
             }
             return handle;
         }
         [DllImport(Libraries.CryptoNative)]
-        private static extern int CryptoNative_GetPkcs8PrivateKeySize(IntPtr pkey, out int p8size);
+        private static extern int CryptoNative_GetPkcs8PrivateKeySize(IntPtr pkey);
         private static int GetPkcs8PrivateKeySize(IntPtr pkey)
         {
-            const int Success = 1;
-            const int Error = -1;
-            const int MissingPrivateKey = -2;
-            int ret = CryptoNative_GetPkcs8PrivateKeySize(pkey, out int p8size);
-            switch (ret)
+            int ret = CryptoNative_GetPkcs8PrivateKeySize(pkey);
+            if (ret < 0)
             {
-                case Success:
-                    return p8size;
-                case Error:
-                    throw CreateOpenSslCryptographicException();
-                case MissingPrivateKey:
-                    throw new CryptographicException(SR.Cryptography_CSP_NoPrivateKey);
-                default:
-                    Debug.Fail($"Unexpected return '{ret}' value from {nameof(CryptoNative_GetPkcs8PrivateKeySize)}.");
-                    throw new CryptographicException();
+                throw CreateOpenSslCryptographicException();
             }
+            return ret;
         }
         [DllImport(Libraries.CryptoNative)]
         private static extern unsafe int CryptoNative_EncodePkcs8PrivateKey(IntPtr pkey, byte* buf);
         internal static ArraySegment<byte> RentEncodePkcs8PrivateKey(SafeEvpPKeyHandle pkey)
         {
             bool addedRef = false;
             try
             {
                 pkey.DangerousAddRef(ref addedRef);
                 IntPtr handle = pkey.DangerousGetHandle();

--- a/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
+++ b/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.OpenSsl.cs
@@ -37,21 +37,21 @@
         }
         internal static SafeSslHandle AllocateSslContext(SslProtocols protocols, SafeX509Handle? certHandle, SafeEvpPKeyHandle? certKeyHandle, EncryptionPolicy policy, SslAuthenticationOptions sslAuthenticationOptions)
         {
             SafeSslHandle? context = null;
             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
             {
                 if (innerContext.IsInvalid)
                 {
                     throw CreateSslException(SR.net_allocate_ssl_context_failed);
                 }
-                if (!Interop.Ssl.Capabilities.Tls13Supported)
+                if (!Interop.Ssl.Tls13Supported)
                 {
                     if (protocols != SslProtocols.None &&
                         CipherSuitesPolicyPal.WantsTls13(protocols))
                     {
                         protocols = protocols & (~SslProtocols.Tls13);
                     }
                 }
                 else if (CipherSuitesPolicyPal.WantsTls13(protocols) &&
                     CipherSuitesPolicyPal.ShouldOptOutOfTls13(sslAuthenticationOptions.CipherSuitesPolicy, policy))
                 {

--- a/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
+++ b/src/libraries/Common/src/Interop/Unix/System.Security.Cryptography.Native/Interop.Ssl.cs
@@ -92,25 +92,23 @@
         internal static extern bool SslGetCurrentCipherId(SafeSslHandle ssl, out int cipherId);
         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_GetOpenSslCipherSuiteName")]
         private static extern IntPtr GetOpenSslCipherSuiteName(SafeSslHandle ssl, int cipherSuite, out int isTls12OrLower);
         internal static string? GetOpenSslCipherSuiteName(SafeSslHandle ssl, TlsCipherSuite cipherSuite, out bool isTls12OrLower)
         {
             string? ret = Marshal.PtrToStringAnsi(GetOpenSslCipherSuiteName(ssl, (int)cipherSuite, out int isTls12OrLowerInt));
             isTls12OrLower = isTls12OrLowerInt != 0;
             return ret;
         }
         [DllImport(Libraries.CryptoNative, EntryPoint = "CryptoNative_Tls13Supported")]
-        private static extern int Tls13SupportedImpl();
-        internal static class Capabilities
-        {
-            internal static readonly bool Tls13Supported = Tls13SupportedImpl() != 0;
-        }
+        [return: MarshalAs(UnmanagedType.Bool)]
+        private static extern bool Tls13SupportedImpl();
+        internal static readonly bool Tls13Supported = Tls13SupportedImpl();
         internal static SafeSharedX509NameStackHandle SslGetClientCAList(SafeSslHandle ssl)
         {
             Crypto.CheckValidOpenSslHandle(ssl);
             SafeSharedX509NameStackHandle handle = SslGetClientCAList_private(ssl);
             if (!handle.IsInvalid)
             {
                 handle.SetParent(ssl);
             }
             return handle;
         }

--- a/src/libraries/Microsoft.Extensions.Configuration/src/ConfigurationManager.cs
+++ b/src/libraries/Microsoft.Extensions.Configuration/src/ConfigurationManager.cs
@@ -3,110 +3,140 @@
 using System.Collections.Generic;
 using System.Linq;
 using System.Threading;
 using Microsoft.Extensions.Primitives;
 namespace Microsoft.Extensions.Configuration
 {
     public sealed class ConfigurationManager : IConfigurationBuilder, IConfigurationRoot, IDisposable
     {
         private readonly ConfigurationSources _sources;
         private readonly ConfigurationBuilderProperties _properties;
-        private readonly ReferenceCountedProviderManager _providerManager = new();
+        private readonly object _providerLock = new();
+        private readonly List<IConfigurationProvider> _providers = new();
         private readonly List<IDisposable> _changeTokenRegistrations = new();
         private ConfigurationReloadToken _changeToken = new();
         public ConfigurationManager()
         {
             _sources = new ConfigurationSources(this);
             _properties = new ConfigurationBuilderProperties(this);
             this.AddInMemoryCollection();
             AddSource(_sources[0]);
         }
         public string this[string key]
         {
             get
             {
-                using ReferenceCountedProviders reference = _providerManager.GetReference();
-                return ConfigurationRoot.GetConfiguration(reference.Providers, key);
+                lock (_providerLock)
+                {
+                    return ConfigurationRoot.GetConfiguration(_providers, key);
+                }
             }
             set
             {
-                using ReferenceCountedProviders reference = _providerManager.GetReference();
-                ConfigurationRoot.SetConfiguration(reference.Providers, key, value);
+                lock (_providerLock)
+                {
+                    ConfigurationRoot.SetConfiguration(_providers, key, value);
+                }
             }
         }
         public IConfigurationSection GetSection(string key) => new ConfigurationSection(this, key);
-        public IEnumerable<IConfigurationSection> GetChildren() => this.GetChildrenImplementation(null);
+        public IEnumerable<IConfigurationSection> GetChildren()
+        {
+            lock (_providerLock)
+            {
+                return this.GetChildrenImplementation(null).ToList();
+            }
+        }
         IDictionary<string, object> IConfigurationBuilder.Properties => _properties;
         IList<IConfigurationSource> IConfigurationBuilder.Sources => _sources;
-        IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers => _providerManager.NonReferenceCountedProviders;
+        IEnumerable<IConfigurationProvider> IConfigurationRoot.Providers
+        {
+            get
+            {
+                lock (_providerLock)
+                {
+                    return new List<IConfigurationProvider>(_providers);
+                }
+            }
+        }
         public void Dispose()
         {
-            DisposeRegistrations();
-            _providerManager.Dispose();
+            lock (_providerLock)
+            {
+                DisposeRegistrationsAndProvidersUnsynchronized();
+            }
         }
         IConfigurationBuilder IConfigurationBuilder.Add(IConfigurationSource source)
         {
             _sources.Add(source ?? throw new ArgumentNullException(nameof(source)));
             return this;
         }
         IConfigurationRoot IConfigurationBuilder.Build() => this;
         IChangeToken IConfiguration.GetReloadToken() => _changeToken;
         void IConfigurationRoot.Reload()
         {
-            using (ReferenceCountedProviders reference = _providerManager.GetReference())
-            {
-                foreach (IConfigurationProvider provider in reference.Providers)
+            lock (_providerLock)
+            {
+                foreach (var provider in _providers)
                 {
                     provider.Load();
                 }
             }
             RaiseChanged();
         }
-        internal ReferenceCountedProviders GetProvidersReference() => _providerManager.GetReference();
         private void RaiseChanged()
         {
             var previousToken = Interlocked.Exchange(ref _changeToken, new ConfigurationReloadToken());
             previousToken.OnReload();
         }
         private void AddSource(IConfigurationSource source)
         {
-            IConfigurationProvider provider = source.Build(this);
-            provider.Load();
-            _changeTokenRegistrations.Add(ChangeToken.OnChange(() => provider.GetReloadToken(), () => RaiseChanged()));
-            _providerManager.AddProvider(provider);
+            lock (_providerLock)
+            {
+                var provider = source.Build(this);
+                _providers.Add(provider);
+                provider.Load();
+                _changeTokenRegistrations.Add(ChangeToken.OnChange(() => provider.GetReloadToken(), () => RaiseChanged()));
+            }
             RaiseChanged();
         }
         private void ReloadSources()
         {
-            DisposeRegistrations();
-            _changeTokenRegistrations.Clear();
-            var newProvidersList = new List<IConfigurationProvider>();
-            foreach (IConfigurationSource source in _sources)
-            {
-                newProvidersList.Add(source.Build(this));
-            }
-            foreach (IConfigurationProvider p in newProvidersList)
-            {
-                p.Load();
-                _changeTokenRegistrations.Add(ChangeToken.OnChange(() => p.GetReloadToken(), () => RaiseChanged()));
-            }
-            _providerManager.ReplaceProviders(newProvidersList);
+            lock (_providerLock)
+            {
+                DisposeRegistrationsAndProvidersUnsynchronized();
+                _changeTokenRegistrations.Clear();
+                _providers.Clear();
+                foreach (var source in _sources)
+                {
+                    _providers.Add(source.Build(this));
+                }
+                foreach (var p in _providers)
+                {
+                    p.Load();
+                    _changeTokenRegistrations.Add(ChangeToken.OnChange(() => p.GetReloadToken(), () => RaiseChanged()));
+                }
+            }
             RaiseChanged();
         }
-        private void DisposeRegistrations()
-        {
-            foreach (IDisposable registration in _changeTokenRegistrations)
+        private void DisposeRegistrationsAndProvidersUnsynchronized()
+        {
+            foreach (var registration in _changeTokenRegistrations)
             {
                 registration.Dispose();
             }
-        }
-        private sealed class ConfigurationSources : IList<IConfigurationSource>
+            foreach (var provider in _providers)
+            {
+                (provider as IDisposable)?.Dispose();
+            }
+        }
+        private class ConfigurationSources : IList<IConfigurationSource>
         {
             private readonly List<IConfigurationSource> _sources = new();
             private readonly ConfigurationManager _config;
             public ConfigurationSources(ConfigurationManager config)
             {
                 _config = config;
             }
             public IConfigurationSource this[int index]
             {
                 get => _sources[index];
@@ -158,21 +188,21 @@
             public void RemoveAt(int index)
             {
                 _sources.RemoveAt(index);
                 _config.ReloadSources();
             }
             IEnumerator IEnumerable.GetEnumerator()
             {
                 return GetEnumerator();
             }
         }
-        private sealed class ConfigurationBuilderProperties : IDictionary<string, object>
+        private class ConfigurationBuilderProperties : IDictionary<string, object>
         {
             private readonly Dictionary<string, object> _properties = new();
             private readonly ConfigurationManager _config;
             public ConfigurationBuilderProperties(ConfigurationManager config)
             {
                 _config = config;
             }
             public object this[string key]
             {
                 get => _properties[key];

--- a/src/libraries/Microsoft.Extensions.Configuration/src/InternalConfigurationRootExtensions.cs
+++ b/src/libraries/Microsoft.Extensions.Configuration/src/InternalConfigurationRootExtensions.cs
@@ -1,27 +1,17 @@
 using System;
 using System.Collections.Generic;
 using System.Linq;
 namespace Microsoft.Extensions.Configuration
 {
     internal static class InternalConfigurationRootExtensions
     {
         internal static IEnumerable<IConfigurationSection> GetChildrenImplementation(this IConfigurationRoot root, string path)
         {
-            using ReferenceCountedProviders? reference = (root as ConfigurationManager)?.GetProvidersReference();
-            IEnumerable<IConfigurationProvider> providers = reference?.Providers ?? root.Providers;
-            IEnumerable<IConfigurationSection> children = providers
+            return root.Providers
                 .Aggregate(Enumerable.Empty<string>(),
                     (seed, source) => source.GetChildKeys(seed, path))
                 .Distinct(StringComparer.OrdinalIgnoreCase)
                 .Select(key => root.GetSection(path == null ? key : ConfigurationPath.Combine(path, key)));
-            if (reference is null)
-            {
-                return children;
-            }
-            else
-            {
-                return children.ToList();
-            }
         }
     }
 }

--- a/src/libraries/Microsoft.Extensions.Configuration/src/ReferenceCountedProviders.cs
+++ b//dev/null
@@ -1,66 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-using System;
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Threading;
-namespace Microsoft.Extensions.Configuration
-{
-    internal abstract class ReferenceCountedProviders : IDisposable
-    {
-        public static ReferenceCountedProviders Create(List<IConfigurationProvider> providers) => new ActiveReferenceCountedProviders(providers);
-        public static ReferenceCountedProviders CreateDisposed(List<IConfigurationProvider> providers) => new DisposedReferenceCountedProviders(providers);
-        public abstract List<IConfigurationProvider> Providers { get; set; }
-        public abstract List<IConfigurationProvider> NonReferenceCountedProviders { get; }
-        public abstract void AddReference();
-        public abstract void Dispose();
-        private sealed class ActiveReferenceCountedProviders : ReferenceCountedProviders
-        {
-            private long _refCount = 1;
-            private volatile List<IConfigurationProvider> _providers;
-            public ActiveReferenceCountedProviders(List<IConfigurationProvider> providers)
-            {
-                _providers = providers;
-            }
-            public override List<IConfigurationProvider> Providers
-            {
-                get
-                {
-                    Debug.Assert(_refCount > 0);
-                    return _providers;
-                }
-                set
-                {
-                    Debug.Assert(_refCount > 0);
-                    _providers = value;
-                }
-            }
-            public override List<IConfigurationProvider> NonReferenceCountedProviders => _providers;
-            public override void AddReference()
-            {
-                Debug.Assert(_refCount > 0);
-                Interlocked.Increment(ref _refCount);
-            }
-            public override void Dispose()
-            {
-                if (Interlocked.Decrement(ref _refCount) == 0)
-                {
-                    foreach (IConfigurationProvider provider in _providers)
-                    {
-                        (provider as IDisposable)?.Dispose();
-                    }
-                }
-            }
-        }
-        private sealed class DisposedReferenceCountedProviders : ReferenceCountedProviders
-        {
-            public DisposedReferenceCountedProviders(List<IConfigurationProvider> providers)
-            {
-                Providers = providers;
-            }
-            public override List<IConfigurationProvider> Providers { get; set; }
-            public override List<IConfigurationProvider> NonReferenceCountedProviders => Providers;
-            public override void AddReference() { }
-            public override void Dispose() { }
-        }
-    }
-}

--- a/src/libraries/Microsoft.Extensions.Configuration/src/ReferenceCountedProvidersManager.cs
+++ b//dev/null
@@ -1,61 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-using System;
-using System.Collections.Generic;
-namespace Microsoft.Extensions.Configuration
-{
-    internal sealed class ReferenceCountedProviderManager : IDisposable
-    {
-        private readonly object _replaceProvidersLock = new object();
-        private ReferenceCountedProviders _refCountedProviders = ReferenceCountedProviders.Create(new List<IConfigurationProvider>());
-        private bool _disposed;
-        public IEnumerable<IConfigurationProvider> NonReferenceCountedProviders => _refCountedProviders.NonReferenceCountedProviders;
-        public ReferenceCountedProviders GetReference()
-        {
-            lock (_replaceProvidersLock)
-            {
-                if (_disposed)
-                {
-                    return ReferenceCountedProviders.CreateDisposed(_refCountedProviders.NonReferenceCountedProviders);
-                }
-                _refCountedProviders.AddReference();
-                return _refCountedProviders;
-            }
-        }
-        public void ReplaceProviders(List<IConfigurationProvider> providers)
-        {
-            ReferenceCountedProviders oldRefCountedProviders = _refCountedProviders;
-            lock (_replaceProvidersLock)
-            {
-                if (_disposed)
-                {
-                    throw new ObjectDisposedException(nameof(ConfigurationManager));
-                }
-                _refCountedProviders = ReferenceCountedProviders.Create(providers);
-            }
-            oldRefCountedProviders.Dispose();
-        }
-        public void AddProvider(IConfigurationProvider provider)
-        {
-            lock (_replaceProvidersLock)
-            {
-                if (_disposed)
-                {
-                    throw new ObjectDisposedException(nameof(ConfigurationManager));
-                }
-                _refCountedProviders.Providers = new List<IConfigurationProvider>(_refCountedProviders.Providers)
-                {
-                    provider
-                };
-            }
-        }
-        public void Dispose()
-        {
-            ReferenceCountedProviders oldRefCountedProviders = _refCountedProviders;
-            lock (_replaceProvidersLock)
-            {
-                _disposed = true;
-            }
-            oldRefCountedProviders.Dispose();
-        }
-    }
-}

--- a/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Emitter.cs
+++ b/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Emitter.cs
@@ -54,32 +54,32 @@
                 if (!string.IsNullOrWhiteSpace(lc.Namespace))
                 {
                     _builder.Append($@"
 namespace {lc.Namespace}
 {{");
                 }
                 LoggerClass parent = lc.ParentClass;
                 var parentClasses = new List<string>();
                 while (parent != null)
                 {
-                    parentClasses.Add($"partial {parent.Keyword} {parent.Name} ");
+                    parentClasses.Add($"partial {parent.Keyword} {parent.Name} {parent.Constraints}");
                     parent = parent.ParentClass;
                 }
                 for (int i = parentClasses.Count - 1; i >= 0; i--)
                 {
                     _builder.Append($@"
     {nestedIndentation}{parentClasses[i]}
     {nestedIndentation}{{");
                     nestedIndentation += "    ";
                 }
                 _builder.Append($@"
-    {nestedIndentation}partial {lc.Keyword} {lc.Name} 
+    {nestedIndentation}partial {lc.Keyword} {lc.Name} {lc.Constraints}
     {nestedIndentation}{{");
                 foreach (LoggerMethod lm in lc.Methods)
                 {
                     if (!UseLoggerMessageDefine(lm))
                     {
                         GenStruct(lm, nestedIndentation);
                     }
                     GenLogMethod(lm, nestedIndentation);
                 }
                 _builder.Append($@"
@@ -155,21 +155,21 @@
             {
                 foreach (LoggerParameter p in lm.TemplateParameters)
                 {
                     _builder.AppendLine($"            {nestedIndentation}private readonly {p.Type} _{p.Name};");
                 }
             }
             private void GenFieldAssignments(LoggerMethod lm, string nestedIndentation)
             {
                 foreach (LoggerParameter p in lm.TemplateParameters)
                 {
-                    _builder.AppendLine($"                {nestedIndentation}this._{p.Name} = {p.CodeName};");
+                    _builder.AppendLine($"                {nestedIndentation}this._{p.Name} = {p.Name};");
                 }
             }
             private void GenVariableAssignments(LoggerMethod lm, string nestedIndentation)
             {
                 foreach (KeyValuePair<string, string> t in lm.TemplateMap)
                 {
                     int index = 0;
                     foreach (LoggerParameter p in lm.TemplateParameters)
                     {
                         if (t.Key.Equals(p.Name, System.StringComparison.OrdinalIgnoreCase))
@@ -204,21 +204,21 @@
                         name = lm.TemplateMap[name];
                     }
                     _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{name}\", this._{p.Name}),");
                 }
                 _builder.AppendLine($"                    {nestedIndentation}{index++} => new global::System.Collections.Generic.KeyValuePair<string, object?>(\"{{OriginalFormat}}\", \"{ConvertEndOfLineAndQuotationCharactersToEscapeForm(lm.Message)}\"),");
             }
             private void GenCallbackArguments(LoggerMethod lm)
             {
                 foreach (LoggerParameter p in lm.TemplateParameters)
                 {
-                    _builder.Append($"{p.CodeName}, ");
+                    _builder.Append($"{p.Name}, ");
                 }
             }
             private void GenDefineTypes(LoggerMethod lm, bool brackets)
             {
                 if (lm.TemplateParameters.Count == 0)
                 {
                     return;
                 }
                 if (brackets)
                 {
@@ -252,54 +252,50 @@
                 foreach (LoggerParameter p in lm.AllParameters)
                 {
                     if (firstItem)
                     {
                         firstItem = false;
                     }
                     else
                     {
                         _builder.Append(", ");
                     }
-                    if (p.Qualifier != null)
-                    {
-                        _builder.Append($"{p.Qualifier} ");
-                    }
-                    _builder.Append($"{p.Type} {p.CodeName}");
+                    _builder.Append($"{p.Type} {p.Name}");
                 }
             }
             private void GenArguments(LoggerMethod lm)
             {
                 bool firstItem = true;
                 foreach (LoggerParameter p in lm.TemplateParameters)
                 {
                     if (firstItem)
                     {
                         firstItem = false;
                     }
                     else
                     {
                         _builder.Append(", ");
                     }
-                    _builder.Append($"{p.Type} {p.CodeName}");
+                    _builder.Append($"{p.Type} {p.Name}");
                 }
             }
             private void GenHolder(LoggerMethod lm)
             {
                 string typeName = $"__{lm.Name}Struct";
                 _builder.Append($"new {typeName}(");
                 foreach (LoggerParameter p in lm.TemplateParameters)
                 {
                     if (p != lm.TemplateParameters[0])
                     {
                         _builder.Append(", ");
                     }
-                    _builder.Append(p.CodeName);
+                    _builder.Append(p.Name);
                 }
                 _builder.Append(')');
             }
             private void GenLogMethod(LoggerMethod lm, string nestedIndentation)
             {
                 string level = GetLogLevel(lm);
                 string extension = lm.IsExtensionMethod ? "this " : string.Empty;
                 string eventName = string.IsNullOrWhiteSpace(lm.EventName) ? $"nameof({lm.Name})" : $"\"{lm.EventName}\"";
                 string exceptionArg = GetException(lm);
                 string logger = GetLogger(lm);

--- a/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Parser.cs
+++ b/src/libraries/Microsoft.Extensions.Logging.Abstractions/gen/LoggerMessageGenerator.Parser.cs
@@ -240,58 +240,38 @@
                                             || msg.StartsWith("ERR:", StringComparison.OrdinalIgnoreCase))
                                         {
                                             Diag(DiagnosticDescriptors.RedundantQualifierInMessage, ma.GetLocation(), method.Identifier.ToString());
                                         }
                                         bool foundLogger = false;
                                         bool foundException = false;
                                         bool foundLogLevel = level != null;
                                         foreach (IParameterSymbol paramSymbol in methodSymbol.Parameters)
                                         {
                                             string paramName = paramSymbol.Name;
-                                            bool needsAtSign = false;
-                                            if (paramSymbol.DeclaringSyntaxReferences.Length > 0)
-                                            {
-                                                ParameterSyntax paramSyntax = paramSymbol.DeclaringSyntaxReferences[0].GetSyntax(_cancellationToken) as ParameterSyntax;
-                                                if (paramSyntax != null && !string.IsNullOrEmpty(paramSyntax.Identifier.Text))
-                                                {
-                                                    needsAtSign = paramSyntax.Identifier.Text[0] == '@';
-                                                }
-                                            }
                                             if (string.IsNullOrWhiteSpace(paramName))
                                             {
                                                 keepMethod = false;
                                                 break;
                                             }
                                             ITypeSymbol paramTypeSymbol = paramSymbol!.Type;
                                             if (paramTypeSymbol is IErrorTypeSymbol)
                                             {
                                                 keepMethod = false;
                                                 break;
-                                            }
-                                            string? qualifier = null;
-                                            if (paramSymbol.RefKind == RefKind.In)
-                                            {
-                                                qualifier = "in";
-                                            }
-                                            else if (paramSymbol.RefKind == RefKind.Ref)
-                                            {
-                                                qualifier = "ref";
                                             }
                                             string typeName = paramTypeSymbol.ToDisplayString(
                                                 SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(
                                                     SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                                             var lp = new LoggerParameter
                                             {
                                                 Name = paramName,
                                                 Type = typeName,
-                                                Qualifier = qualifier,
-                                                CodeName = needsAtSign ? "@" + paramName : paramName,
                                                 IsLogger = !foundLogger && IsBaseOrIdentity(paramTypeSymbol!, loggerSymbol),
                                                 IsException = !foundException && IsBaseOrIdentity(paramTypeSymbol!, exceptionSymbol),
                                                 IsLogLevel = !foundLogLevel && IsBaseOrIdentity(paramTypeSymbol!, logLevelSymbol),
                                                 IsEnumerable = IsBaseOrIdentity(paramTypeSymbol!, enumerableSymbol) && !IsBaseOrIdentity(paramTypeSymbol!, stringSymbol),
                                             };
                                             foundLogger |= lp.IsLogger;
                                             foundException |= lp.IsException;
                                             foundLogLevel |= lp.IsLogLevel;
                                             if (lp.IsLogger && lm.TemplateMap.ContainsKey(paramName))
                                             {
@@ -407,35 +387,37 @@
                                                 }
                                             }
                                         }
                                         if (keepMethod)
                                         {
                                             lc ??= new LoggerClass
                                             {
                                                 Keyword = classDec.Keyword.ValueText,
                                                 Namespace = nspace,
                                                 Name = classDec.Identifier.ToString() + classDec.TypeParameterList,
+                                                Constraints = classDec.ConstraintClauses.ToString(),
                                                 ParentClass = null,
                                             };
                                             LoggerClass currentLoggerClass = lc;
                                             var parentLoggerClass = (classDec.Parent as TypeDeclarationSyntax);
                                             bool IsAllowedKind(SyntaxKind kind) =>
                                                 kind == SyntaxKind.ClassDeclaration ||
                                                 kind == SyntaxKind.StructDeclaration ||
                                                 kind == SyntaxKind.RecordDeclaration;
                                             while (parentLoggerClass != null && IsAllowedKind(parentLoggerClass.Kind()))
                                             {
                                                 currentLoggerClass.ParentClass = new LoggerClass
                                                 {
                                                     Keyword = parentLoggerClass.Keyword.ValueText,
                                                     Namespace = nspace,
                                                     Name = parentLoggerClass.Identifier.ToString() + parentLoggerClass.TypeParameterList,
+                                                    Constraints = parentLoggerClass.ConstraintClauses.ToString(),
                                                     ParentClass = null,
                                                 };
                                                 currentLoggerClass = currentLoggerClass.ParentClass;
                                                 parentLoggerClass = (parentLoggerClass.Parent as TypeDeclarationSyntax);
                                             }
                                             lc.Methods.Add(lm);
                                         }
                                     }
                                 }
                             }
@@ -570,20 +552,21 @@
                 return string.Empty;
             }
             private static object GetItem(TypedConstant arg) => arg.Kind == TypedConstantKind.Array ? arg.Values : arg.Value;
         }
         internal class LoggerClass
         {
             public readonly List<LoggerMethod> Methods = new ();
             public string Keyword = string.Empty;
             public string Namespace = string.Empty;
             public string Name = string.Empty;
+            public string Constraints = string.Empty;
             public LoggerClass? ParentClass;
         }
         internal class LoggerMethod
         {
             public readonly List<LoggerParameter> AllParameters = new ();
             public readonly List<LoggerParameter> TemplateParameters = new ();
             public readonly Dictionary<string, string> TemplateMap = new (StringComparer.OrdinalIgnoreCase);
             public readonly List<string> TemplateList = new ();
             public string Name = string.Empty;
             public string Message = string.Empty;
@@ -592,20 +575,18 @@
             public string? EventName;
             public bool IsExtensionMethod;
             public string Modifiers = string.Empty;
             public string LoggerField = string.Empty;
             public bool SkipEnabledCheck;
         }
         internal class LoggerParameter
         {
             public string Name = string.Empty;
             public string Type = string.Empty;
-            public string CodeName = string.Empty;
-            public string? Qualifier;
             public bool IsLogger;
             public bool IsException;
             public bool IsLogLevel;
             public bool IsEnumerable;
             public bool IsTemplateParameter => !IsLogger && !IsException && !IsLogLevel;
         }
     }
 }

--- a/src/libraries/Native/AnyOS/zlib/pal_zlib.c
+++ b/src/libraries/Native/AnyOS/zlib/pal_zlib.c
@@ -1,17 +1,15 @@
 #include <assert.h>
 #include <stdlib.h>
 #include "pal_zlib.h"
 #ifdef  _WIN32
     #define c_static_assert(e) static_assert((e),"")
-#endif
-#if defined(_WIN32) || defined(__EMSCRIPTEN__)
     #include "../../Windows/System.IO.Compression.Native/zlib/zlib.h"
 #else
     #include "pal_utilities.h"
     #include <zlib.h>
 #endif
 c_static_assert(PAL_Z_NOFLUSH == Z_NO_FLUSH);
 c_static_assert(PAL_Z_FINISH == Z_FINISH);
 c_static_assert(PAL_Z_OK == Z_OK);
 c_static_assert(PAL_Z_STREAMEND == Z_STREAM_END);
 c_static_assert(PAL_Z_STREAMERROR == Z_STREAM_ERROR);

--- a/src/libraries/Native/Unix/System.Native/pal_interfaceaddresses.c
+++ b/src/libraries/Native/Unix/System.Native/pal_interfaceaddresses.c
@@ -1,26 +1,20 @@
 #include "pal_config.h"
 #include "pal_interfaceaddresses.h"
 #include "pal_maphardwaretype.h"
 #include "pal_utilities.h"
 #include "pal_safecrt.h"
 #include "pal_networking.h"
 #include <stdlib.h>
 #include <sys/types.h>
 #include <assert.h>
-#if HAVE_IFADDRS || HAVE_GETIFADDRS
 #include <ifaddrs.h>
-#endif
-#if !HAVE_GETIFADDRS && TARGET_ANDROID
-#include <dlfcn.h>
-#include <pthread.h>
-#endif
 #include <net/if.h>
 #include <netinet/in.h>
 #include <string.h>
 #include <sys/socket.h>
 #if HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
 #if HAVE_SYS_IOCTL_H
 #include <sys/ioctl.h>
 #endif
@@ -47,20 +41,21 @@
 #else
 #error System must have AF_PACKET or AF_LINK.
 #endif
 #if HAVE_RT_MSGHDR
 #if HAVE_IOS_NET_ROUTE_H
 #include "ios/net/route.h"
 #else
 #include <net/route.h>
 #endif
 #endif
+#if HAVE_GETIFADDRS
 static inline uint8_t mask2prefix(uint8_t* mask, int length)
 {
     uint8_t len = 0;
     uint8_t* end = mask + length;
     if (mask == NULL)
     {
         return (uint8_t)length * 8;
     }
     while ((mask < end) && (*mask == 0xff))
     {
@@ -74,68 +69,27 @@
             len++;
             *mask <<= 1;
         }
     }
     if (len == 0 && length == 4)
     {
         len = 32;
     }
     return len;
 }
-#if !HAVE_IFADDRS && TARGET_ANDROID
-struct ifaddrs
-{
-	struct ifaddrs *ifa_next;
-	char *ifa_name;
-	unsigned int ifa_flags;
-	struct sockaddr *ifa_addr;
-	struct sockaddr *ifa_netmask;
-	union
-	{
-		struct sockaddr *ifu_broadaddr;
-		struct sockaddr *ifu_dstaddr;
-	} ifa_ifu;
-	void *ifa_data;
-};
-#endif
-#if !HAVE_GETIFADDRS && TARGET_ANDROID
-static int (*getifaddrs)(struct ifaddrs**) = NULL;
-static void (*freeifaddrs)(struct ifaddrs*) = NULL;
-static void try_loading_getifaddrs()
-{
-    void *libc = dlopen("libc.so", RTLD_NOW);
-    if (libc)
-    {
-        getifaddrs = (int (*)(struct ifaddrs**)) dlsym(libc, "getifaddrs");
-        freeifaddrs = (void (*)(struct ifaddrs*)) dlsym(libc, "freeifaddrs");
-    }
-}
-static bool ensure_getifaddrs_is_loaded()
-{
-    static pthread_once_t getifaddrs_is_loaded = PTHREAD_ONCE_INIT;
-    pthread_once(&getifaddrs_is_loaded, try_loading_getifaddrs);
-    return getifaddrs != NULL && freeifaddrs != NULL;
-}
 #endif
 int32_t SystemNative_EnumerateInterfaceAddresses(void* context,
                                                IPv4AddressFound onIpv4Found,
                                                IPv6AddressFound onIpv6Found,
                                                LinkLayerAddressFound onLinkLayerFound)
 {
-#if !HAVE_GETIFADDRS && TARGET_ANDROID
-    if (!ensure_getifaddrs_is_loaded())
-    {
-        errno = ENOTSUP;
-        return -1;
-    }
-#endif
-#if HAVE_GETIFADDRS || TARGET_ANDROID
+#if HAVE_GETIFADDRS
     struct ifaddrs* headAddr;
     if (getifaddrs(&headAddr) == -1)
     {
         return -1;
     }
     for (struct ifaddrs* current = headAddr; current != NULL; current = current->ifa_next)
     {
         if (current->ifa_addr == NULL)
         {
             continue;
@@ -240,28 +194,21 @@
     (void)context;
     (void)onIpv4Found;
     (void)onIpv6Found;
     (void)onLinkLayerFound;
     errno = ENOTSUP;
     return -1;
 #endif
 }
 int32_t SystemNative_GetNetworkInterfaces(int32_t * interfaceCount, NetworkInterfaceInfo **interfaceList, int32_t * addressCount, IpAddressInfo **addressList )
 {
-#if !HAVE_GETIFADDRS && TARGET_ANDROID
-    if (!ensure_getifaddrs_is_loaded())
-    {
-        errno = ENOTSUP;
-        return -1;
-    }
-#endif
-#if HAVE_GETIFADDRS || TARGET_ANDROID
+#if HAVE_GETIFADDRS
     struct ifaddrs* head;   // Pointer to block allocated by getifaddrs().
     struct ifaddrs* ifaddrsEntry;
     IpAddressInfo *ai;
     int count = 0;       // Count of entries returned by getifaddrs().
     int ip4count = 0;    // Total number of IPv4 addresses.
     int ip6count = 0;    // Total number of IPv6 addresses.
     int ifcount = 0;     // Total number of unique network interface.
     int index;
     int socketfd = -1;
     NetworkInterfaceInfo *nii;

--- a/src/libraries/Native/Unix/System.Native/pal_io.c
+++ b/src/libraries/Native/Unix/System.Native/pal_io.c
@@ -258,25 +258,20 @@
     return result;
 }
 int32_t SystemNative_Unlink(const char* path)
 {
     int32_t result;
     while ((result = unlink(path)) < 0 && errno == EINTR);
     return result;
 }
 intptr_t SystemNative_ShmOpen(const char* name, int32_t flags, int32_t mode)
 {
-#if defined(SHM_NAME_MAX) // macOS
-    assert(strlen(name) <= SHM_NAME_MAX);
-#elif defined(PATH_MAX) // other Unixes
-    assert(strlen(name) <= PATH_MAX);
-#endif
 #if HAVE_SHM_OPEN_THAT_WORKS_WELL_ENOUGH_WITH_MMAP
     flags = ConvertOpenFlags(flags);
     if (flags == -1)
     {
         errno = EINVAL;
         return -1;
     }
     return shm_open(name, flags, (mode_t)mode);
 #else
     (void)name, (void)flags, (void)mode;

--- a/src/libraries/Native/Unix/System.Security.Cryptography.Native.Android/pal_sslstream.c
+++ b/src/libraries/Native/Unix/System.Security.Cryptography.Native.Android/pal_sslstream.c
@@ -428,28 +428,27 @@
         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferFlip));
         if (IsHandshaking(handshakeStatus))
         {
             ret = SSLStreamStatus_Renegotiate;
             goto cleanup;
         }
         rem = (*env)->CallIntMethod(env, sslStream->appInBuffer, g_ByteBufferRemaining);
     }
     if (rem > 0)
     {
-        int32_t bytes_to_read = rem < length ? rem : length;
-        data = make_java_byte_array(env, bytes_to_read);
+        data = make_java_byte_array(env, rem);
         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferGet, data));
         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
         IGNORE_RETURN((*env)->CallObjectMethod(env, sslStream->appInBuffer, g_ByteBufferCompact));
         ON_EXCEPTION_PRINT_AND_GOTO(cleanup);
-        (*env)->GetByteArrayRegion(env, data, 0, bytes_to_read, (jbyte*)buffer);
-        *read = bytes_to_read;
+        (*env)->GetByteArrayRegion(env, data, 0, rem, (jbyte*)buffer);
+        *read = rem;
         ret = SSLStreamStatus_OK;
     }
     else
     {
         ret = SSLStreamStatus_NeedData;
     }
 cleanup:
     ReleaseLRef(env, data);
     return ret;
 }

--- a/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.h
+++ b/src/libraries/Native/Unix/System.Security.Cryptography.Native/opensslshim.h
@@ -223,21 +223,20 @@
     REQUIRED_FUNCTION(EC_POINT_get_affine_coordinates_GFp) \
     REQUIRED_FUNCTION(EC_POINT_mul) \
     REQUIRED_FUNCTION(EC_POINT_new) \
     REQUIRED_FUNCTION(EC_POINT_set_affine_coordinates_GFp) \
     REQUIRED_FUNCTION(ERR_clear_error) \
     REQUIRED_FUNCTION(ERR_error_string_n) \
     REQUIRED_FUNCTION(ERR_get_error) \
     LEGACY_FUNCTION(ERR_load_crypto_strings) \
     LIGHTUP_FUNCTION(ERR_new) \
     REQUIRED_FUNCTION(ERR_peek_error) \
-    REQUIRED_FUNCTION(ERR_peek_error_line) \
     REQUIRED_FUNCTION(ERR_peek_last_error) \
     FALLBACK_FUNCTION(ERR_put_error) \
     REQUIRED_FUNCTION(ERR_reason_error_string) \
     LIGHTUP_FUNCTION(ERR_set_debug) \
     LIGHTUP_FUNCTION(ERR_set_error) \
     REQUIRED_FUNCTION(EVP_aes_128_cbc) \
     REQUIRED_FUNCTION(EVP_aes_128_ccm) \
     REQUIRED_FUNCTION(EVP_aes_128_cfb128) \
     REQUIRED_FUNCTION(EVP_aes_128_cfb8) \
     REQUIRED_FUNCTION(EVP_aes_128_ecb) \
@@ -668,21 +667,20 @@
 #define EC_POINT_get_affine_coordinates_GFp EC_POINT_get_affine_coordinates_GFp_ptr
 #define EC_POINT_mul EC_POINT_mul_ptr
 #define EC_POINT_new EC_POINT_new_ptr
 #define EC_POINT_set_affine_coordinates_GFp EC_POINT_set_affine_coordinates_GFp_ptr
 #define ERR_clear_error ERR_clear_error_ptr
 #define ERR_error_string_n ERR_error_string_n_ptr
 #define ERR_get_error ERR_get_error_ptr
 #define ERR_load_crypto_strings ERR_load_crypto_strings_ptr
 #define ERR_new ERR_new_ptr
 #define ERR_peek_error ERR_peek_error_ptr
-#define ERR_peek_error_line ERR_peek_error_line_ptr
 #define ERR_peek_last_error ERR_peek_last_error_ptr
 #define ERR_put_error ERR_put_error_ptr
 #define ERR_reason_error_string ERR_reason_error_string_ptr
 #define ERR_set_debug ERR_set_debug_ptr
 #define ERR_set_error ERR_set_error_ptr
 #define EVP_aes_128_cbc EVP_aes_128_cbc_ptr
 #define EVP_aes_128_cfb8 EVP_aes_128_cfb8_ptr
 #define EVP_aes_128_cfb128 EVP_aes_128_cfb128_ptr
 #define EVP_aes_128_ecb EVP_aes_128_ecb_ptr
 #define EVP_aes_128_gcm EVP_aes_128_gcm_ptr

--- a/src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.c
+++ b/src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.c
@@ -106,44 +106,31 @@
     }
     EVP_PKEY* key = EVP_PKCS82PKEY(p8info);
     PKCS8_PRIV_KEY_INFO_free(p8info);
     if (key != NULL && !CheckKey(key, algId, EVP_PKEY_check))
     {
         EVP_PKEY_free(key);
         key = NULL;
     }
     return key;
 }
-int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey, int32_t* p8size)
+int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey)
 {
     assert(pkey != NULL);
-    assert(p8size != NULL);
-    *p8size = 0;
-    ERR_clear_error();
     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
     if (p8 == NULL)
     {
-        const char* file = NULL;
-        int line = 0;
-        unsigned long error = ERR_peek_error_line(&file, &line);
-        if (ERR_GET_REASON(error) != ERR_R_MALLOC_FAILURE)
-        {
-            ERR_clear_error();
-            return -2;
-        }
-        ERR_clear_error();
-        ERR_put_error(ERR_GET_LIB(error), 0, ERR_R_MALLOC_FAILURE, file, line);
         return -1;
     }
-    *p8size = i2d_PKCS8_PRIV_KEY_INFO(p8, NULL);
+    int ret = i2d_PKCS8_PRIV_KEY_INFO(p8, NULL);
     PKCS8_PRIV_KEY_INFO_free(p8);
-    return *p8size < 0 ? -1 : 1;
+    return ret;
 }
 int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf)
 {
     assert(pkey != NULL);
     assert(buf != NULL);
     PKCS8_PRIV_KEY_INFO* p8 = EVP_PKEY2PKCS8(pkey);
     if (p8 == NULL)
     {
         return -1;
     }

--- a/src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.h
+++ b/src/libraries/Native/Unix/System.Security.Cryptography.Native/pal_evp_pkey.h
@@ -34,26 +34,23 @@
 Decodes an X.509 SubjectPublicKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
 Requres a non-null buf, and len > 0.
 */
 PALEXPORT EVP_PKEY* CryptoNative_DecodeSubjectPublicKeyInfo(const uint8_t* buf, int32_t len, int32_t algId);
 /*
 Decodes an Pkcs8PrivateKeyInfo into an EVP_PKEY*, verifying the interpreted algorithm type.
 Requres a non-null buf, and len > 0.
 */
 PALEXPORT EVP_PKEY* CryptoNative_DecodePkcs8PrivateKey(const uint8_t* buf, int32_t len, int32_t algId);
 /*
-Gets the number of bytes rqeuired to encode an EVP_PKEY* as a Pkcs8PrivateKeyInfo.
-On success, 1 is returned and p8size contains the size of the Pkcs8PrivateKeyInfo.
-On failure, -1 is used to indicate the openssl error queue contains the error.
-On failure, -2 is used to indcate that the supplied EVP_PKEY* is possibly missing a private key.
+Reports the number of bytes rqeuired to encode an EVP_PKEY* as a Pkcs8PrivateKeyInfo, or a negative value on error.
 */
-PALEXPORT int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey, int32_t* p8size);
+PALEXPORT int32_t CryptoNative_GetPkcs8PrivateKeySize(EVP_PKEY* pkey);
 /*
 Encodes the EVP_PKEY* as a Pkcs8PrivateKeyInfo, writing the encoded value to buf.
 buf must be big enough, or an out of bounds write may occur.
 Returns the number of bytes written.
 */
 PALEXPORT int32_t CryptoNative_EncodePkcs8PrivateKey(EVP_PKEY* pkey, uint8_t* buf);
 /*
 Reports the number of bytes rqeuired to encode an EVP_PKEY* as an X.509 SubjectPublicKeyInfo, or a negative value on error.
 */
 PALEXPORT int32_t CryptoNative_GetSubjectPublicKeyInfoSize(EVP_PKEY* pkey);

--- a/src/libraries/System.Diagnostics.Process/ref/System.Diagnostics.Process.cs
+++ b/src/libraries/System.Diagnostics.Process/ref/System.Diagnostics.Process.cs
@@ -30,22 +30,22 @@
         public int ExitCode { get { throw null; } }
         public System.DateTime ExitTime { get { throw null; } }
         public System.IntPtr Handle { get { throw null; } }
         public int HandleCount { get { throw null; } }
         public bool HasExited { get { throw null; } }
         public int Id { get { throw null; } }
         public string MachineName { get { throw null; } }
         public System.Diagnostics.ProcessModule? MainModule { get { throw null; } }
         public System.IntPtr MainWindowHandle { get { throw null; } }
         public string MainWindowTitle { get { throw null; } }
-        public System.IntPtr MaxWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
-        public System.IntPtr MinWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
+        public System.IntPtr MaxWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
+        public System.IntPtr MinWorkingSet { [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios"), System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("freebsd"), System.Runtime.Versioning.SupportedOSPlatformAttribute("macos"), System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
         public System.Diagnostics.ProcessModuleCollection Modules { get { throw null; } }
         [System.ObsoleteAttribute("Process.NonpagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.")]
         public int NonpagedSystemMemorySize { get { throw null; } }
         public long NonpagedSystemMemorySize64 { get { throw null; } }
         [System.ObsoleteAttribute("Process.PagedMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedMemorySize64 instead.")]
         public int PagedMemorySize { get { throw null; } }
         public long PagedMemorySize64 { get { throw null; } }
         [System.ObsoleteAttribute("Process.PagedSystemMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.PagedSystemMemorySize64 instead.")]
         public int PagedSystemMemorySize { get { throw null; } }
         public long PagedSystemMemorySize64 { get { throw null; } }
@@ -71,27 +71,21 @@
         public bool Responding { get { throw null; } }
         public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get { throw null; } }
         public int SessionId { get { throw null; } }
         public System.IO.StreamReader StandardError { get { throw null; } }
         public System.IO.StreamWriter StandardInput { get { throw null; } }
         public System.IO.StreamReader StandardOutput { get { throw null; } }
         public System.Diagnostics.ProcessStartInfo StartInfo { get { throw null; } set { } }
         public System.DateTime StartTime { get { throw null; } }
         public System.ComponentModel.ISynchronizeInvoke? SynchronizingObject { get { throw null; } set { } }
         public System.Diagnostics.ProcessThreadCollection Threads { get { throw null; } }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public System.TimeSpan TotalProcessorTime { get { throw null; } }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public System.TimeSpan UserProcessorTime { get { throw null; } }
         [System.ObsoleteAttribute("Process.VirtualMemorySize has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.VirtualMemorySize64 instead.")]
         public int VirtualMemorySize { get { throw null; } }
         public long VirtualMemorySize64 { get { throw null; } }
         [System.ObsoleteAttribute("Process.WorkingSet has been deprecated because the type of the property can't represent all valid results. Use System.Diagnostics.Process.WorkingSet64 instead.")]
         public int WorkingSet { get { throw null; } }
         public long WorkingSet64 { get { throw null; } }
         public event System.Diagnostics.DataReceivedEventHandler? ErrorDataReceived { add { } remove { } }
         public event System.EventHandler Exited { add { } remove { } }
         public event System.Diagnostics.DataReceivedEventHandler? OutputDataReceived { add { } remove { } }
@@ -99,66 +93,47 @@
         public void BeginOutputReadLine() { }
         public void CancelErrorRead() { }
         public void CancelOutputRead() { }
         public void Close() { }
         public bool CloseMainWindow() { throw null; }
         protected override void Dispose(bool disposing) { }
         public static void EnterDebugMode() { }
         public static System.Diagnostics.Process GetCurrentProcess() { throw null; }
         public static System.Diagnostics.Process GetProcessById(int processId) { throw null; }
         public static System.Diagnostics.Process GetProcessById(int processId, string machineName) { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process[] GetProcesses() { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process[] GetProcesses(string machineName) { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process[] GetProcessesByName(string? processName) { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process[] GetProcessesByName(string? processName, string machineName) { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public void Kill() { }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public void Kill(bool entireProcessTree) { }
         public static void LeaveDebugMode() { }
         protected void OnExited() { }
         public void Refresh() { }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public bool Start() { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process? Start(System.Diagnostics.ProcessStartInfo startInfo) { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process Start(string fileName) { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process Start(string fileName, string arguments) { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public static System.Diagnostics.Process Start(string fileName, System.Collections.Generic.IEnumerable<string> arguments) { throw null; }
         [System.CLSCompliantAttribute(false)]
         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
         public static System.Diagnostics.Process? Start(string fileName, string userName, System.Security.SecureString password, string domain) { throw null; }
         [System.CLSCompliantAttribute(false)]
         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
         public static System.Diagnostics.Process? Start(string fileName, string arguments, string userName, System.Security.SecureString password, string domain) { throw null; }
         public override string ToString() { throw null; }
         public void WaitForExit() { }
         public bool WaitForExit(int milliseconds) { throw null; }
@@ -245,38 +220,29 @@
     [System.ComponentModel.DesignerAttribute("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
     public partial class ProcessThread : System.ComponentModel.Component
     {
         internal ProcessThread() { }
         public int BasePriority { get { throw null; } }
         public int CurrentPriority { get { throw null; } }
         public int Id { get { throw null; } }
         public int IdealProcessor { set { } }
         public bool PriorityBoostEnabled { get { throw null; } set { } }
         public System.Diagnostics.ThreadPriorityLevel PriorityLevel { [System.Runtime.Versioning.SupportedOSPlatform("windows")] [System.Runtime.Versioning.SupportedOSPlatform("linux")] [System.Runtime.Versioning.SupportedOSPlatform("freebsd")] get { throw null; } [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")] set { } }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public System.TimeSpan PrivilegedProcessorTime { get { throw null; } }
         [System.Runtime.Versioning.SupportedOSPlatformAttribute("windows")]
         public System.IntPtr ProcessorAffinity { set { } }
         public System.IntPtr StartAddress { get { throw null; } }
         [System.Runtime.Versioning.SupportedOSPlatform("windows")]
         [System.Runtime.Versioning.SupportedOSPlatform("linux")]
         public System.DateTime StartTime { get { throw null; } }
         public System.Diagnostics.ThreadState ThreadState { get { throw null; } }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public System.TimeSpan TotalProcessorTime { get { throw null; } }
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("ios")]
-        [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("tvos")]
-        [System.Runtime.Versioning.SupportedOSPlatformAttribute("maccatalyst")]
         public System.TimeSpan UserProcessorTime { get { throw null; } }
         public System.Diagnostics.ThreadWaitReason WaitReason { get { throw null; } }
         public void ResetIdealProcessor() { }
     }
     public partial class ProcessThreadCollection : System.Collections.ReadOnlyCollectionBase
     {
         protected ProcessThreadCollection() { }
         public ProcessThreadCollection(System.Diagnostics.ProcessThread[] processThreads) { }
         public System.Diagnostics.ProcessThread this[int index] { get { throw null; } }
         public int Add(System.Diagnostics.ProcessThread thread) { throw null; }

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.BSD.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.BSD.cs
@@ -1,20 +1,16 @@
 using System.Collections.Generic;
 using System.ComponentModel;
-using System.Runtime.Versioning;
 namespace System.Diagnostics
 {
     public partial class Process
     {
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcessesByName(string? processName, string machineName)
         {
             if (processName == null)
             {
                 processName = string.Empty;
             }
             Process[] procs = GetProcesses(machineName);
             var list = new List<Process>();
             for (int i = 0; i < procs.Length; i++)
             {

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Linux.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Linux.cs
@@ -1,25 +1,21 @@
 using System;
 using System.Buffers;
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Globalization;
 using System.IO;
-using System.Runtime.Versioning;
 using System.Text;
 namespace System.Diagnostics
 {
     public partial class Process : IDisposable
     {
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcessesByName(string? processName, string machineName)
         {
             ProcessManager.ThrowIfRemoteMachine(machineName);
             if (processName == null)
             {
                 processName = string.Empty;
             }
             var processes = new List<Process>();
             foreach (int pid in ProcessManager.EnumerateProcessIds())
             {

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.NonUap.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.NonUap.cs
@@ -1,20 +1,19 @@
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Runtime.Versioning;
 namespace System.Diagnostics
 {
     public partial class Process : IDisposable
     {
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public void Kill(bool entireProcessTree)
         {
             if (!entireProcessTree)
             {
                 Kill();
             }
             else
             {
                 EnsureState(State.Associated | State.IsLocal);
                 if (IsSelfOrDescendantOf(GetCurrentProcess()))

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Unix.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Unix.cs
@@ -31,24 +31,23 @@
             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
         }
         [CLSCompliant(false)]
         [SupportedOSPlatform("windows")]
         public static Process Start(string fileName, string arguments, string userName, SecureString password, string domain)
         {
             throw new PlatformNotSupportedException(SR.ProcessStartWithPasswordAndDomainNotSupported);
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public void Kill()
         {
-            if (PlatformDoesNotSupportProcessStartAndKill)
+            if (OperatingSystem.IsIOS() || OperatingSystem.IsTvOS())
             {
                 throw new PlatformNotSupportedException();
             }
             EnsureState(State.HaveId);
             if (GetHasExited(refresh: false))
             {
                 return;
             }
             int killResult = Interop.Sys.Kill(_processId, Interop.Sys.Signals.SIGKILL);
             if (killResult != 0)
@@ -263,21 +262,21 @@
             if (_haveProcessHandle)
             {
                 ThrowIfExited(refresh: true);
                 return _processHandle!;
             }
             EnsureState(State.HaveNonExitedId | State.IsLocal);
             return new SafeProcessHandle(_processId, GetSafeWaitHandle());
         }
         private bool StartCore(ProcessStartInfo startInfo)
         {
-            if (PlatformDoesNotSupportProcessStartAndKill)
+            if (OperatingSystem.IsIOS() || OperatingSystem.IsTvOS())
             {
                 throw new PlatformNotSupportedException();
             }
             EnsureInitialized();
             string? filename;
             string[] argv;
             if (startInfo.UseShellExecute)
             {
                 if (startInfo.RedirectStandardInput || startInfo.RedirectStandardOutput || startInfo.RedirectStandardError)
                 {
@@ -778,14 +777,12 @@
                 bool childrenUsingTerminalPre = AreChildrenUsingTerminal;
                 ProcessWaitState.CheckChildren(reapAll != 0, configureConsole != 0);
                 bool childrenUsingTerminalPost = AreChildrenUsingTerminal;
                 return childrenUsingTerminalPre && !childrenUsingTerminalPost && configureConsole == 0 ? 1 : 0;
             }
             finally
             {
                 s_processStartLock.ExitWriteLock();
             }
         }
-        private static bool PlatformDoesNotSupportProcessStartAndKill
-            => (OperatingSystem.IsIOS() && !OperatingSystem.IsMacCatalyst()) || OperatingSystem.IsTvOS();
     }
 }

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.UnknownUnix.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.UnknownUnix.cs
@@ -1,18 +1,15 @@
 namespace System.Diagnostics
 {
     public partial class Process : IDisposable
     {
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
-        public static Process[] GetProcessesByName(string? processName, string machineName)
+        public static Process[] GetProcessesByName(string processName, string machineName)
         {
             throw new PlatformNotSupportedException();
         }
         public TimeSpan PrivilegedProcessorTime
         {
             get { throw new PlatformNotSupportedException(); }
         }
         internal DateTime StartTimeCore
         {
             get { throw new PlatformNotSupportedException(); }
@@ -37,13 +34,12 @@
             throw new PlatformNotSupportedException();
         }
         private void SetWorkingSetLimitsCore(IntPtr? newMin, IntPtr? newMax, out IntPtr resultingMin, out IntPtr resultingMax)
         {
             throw new PlatformNotSupportedException();
         }
         private string GetPathToOpenFile()
         {
             throw new PlatformNotSupportedException();
         }
-        private int ParentProcessId => throw new PlatformNotSupportedException();
     }
 }

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Windows.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.Windows.cs
@@ -5,23 +5,20 @@
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
 using System.Security;
 using System.Text;
 using System.Threading;
 namespace System.Diagnostics
 {
     public partial class Process : IDisposable
     {
         private static readonly object s_createProcessLock = new object();
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcessesByName(string? processName, string machineName)
         {
             if (processName == null)
             {
                 processName = string.Empty;
             }
             Process[] procs = GetProcesses(machineName);
             var list = new List<Process>();
             for (int i = 0; i < procs.Length; i++)
             {
@@ -61,21 +58,20 @@
         public static void EnterDebugMode()
         {
             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, (int)Interop.Advapi32.SEPrivileges.SE_PRIVILEGE_ENABLED);
         }
         public static void LeaveDebugMode()
         {
             SetPrivilege(Interop.Advapi32.SeDebugPrivilege, 0);
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public void Kill()
         {
             using (SafeProcessHandle handle = GetProcessHandle(Interop.Advapi32.ProcessOptions.PROCESS_TERMINATE | Interop.Advapi32.ProcessOptions.PROCESS_QUERY_LIMITED_INFORMATION, throwIfExited: false))
             {
                 if (handle.IsInvalid)
                     return;
                 if (!Interop.Kernel32.TerminateProcess(handle, -1))
                 {
                     var exception = new Win32Exception();
                     if (exception.NativeErrorCode == Interop.Errors.ERROR_ACCESS_DENIED &&

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.cs
@@ -117,23 +117,20 @@
                     EnsureState(State.Associated);
                     UpdateHasExited();
                     if (_exited)
                     {
                         RaiseOnExited();
                     }
                 }
                 return _exited;
             }
         }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public DateTime StartTime
         {
             get
             {
                 if (!_startTime.HasValue)
                 {
                     _startTime = StartTimeCore;
                 }
                 return _startTime.Value;
             }
@@ -164,49 +161,45 @@
             get
             {
                 EnsureState(State.Associated);
                 return _machineName;
             }
         }
         public IntPtr MaxWorkingSet
         {
             [UnsupportedOSPlatform("ios")]
             [UnsupportedOSPlatform("tvos")]
-            [SupportedOSPlatform("maccatalyst")]
             get
             {
                 EnsureWorkingSetLimits();
                 return _maxWorkingSet;
             }
+            [SupportedOSPlatform("windows")]
+            [SupportedOSPlatform("macos")]
             [SupportedOSPlatform("freebsd")]
-            [SupportedOSPlatform("macos")]
-            [SupportedOSPlatform("maccatalyst")]
-            [SupportedOSPlatform("windows")]
             set
             {
                 SetWorkingSetLimits(null, value);
             }
         }
         public IntPtr MinWorkingSet
         {
             [UnsupportedOSPlatform("ios")]
             [UnsupportedOSPlatform("tvos")]
-            [SupportedOSPlatform("maccatalyst")]
             get
             {
                 EnsureWorkingSetLimits();
                 return _minWorkingSet;
             }
+            [SupportedOSPlatform("windows")]
+            [SupportedOSPlatform("macos")]
             [SupportedOSPlatform("freebsd")]
-            [SupportedOSPlatform("macos")]
-            [SupportedOSPlatform("maccatalyst")]
-            [SupportedOSPlatform("windows")]
             set
             {
                 SetWorkingSetLimits(value, null);
             }
         }
         public ProcessModuleCollection Modules
         {
             get
             {
                 if (_modules == null)
@@ -757,37 +750,28 @@
             if (!ProcessManager.IsProcessRunning(processId, machineName))
             {
                 throw new ArgumentException(SR.Format(SR.MissingProccess, processId.ToString()));
             }
             return new Process(machineName, ProcessManager.IsRemoteMachine(machineName), processId, null);
         }
         public static Process GetProcessById(int processId)
         {
             return GetProcessById(processId, ".");
         }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcessesByName(string? processName)
         {
             return GetProcessesByName(processName, ".");
         }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcesses()
         {
             return GetProcesses(".");
         }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process[] GetProcesses(string machineName)
         {
             bool isRemoteMachine = ProcessManager.IsRemoteMachine(machineName);
             ProcessInfo[] processInfos = ProcessManager.GetProcessInfos(machineName);
             Process[] processes = new Process[processInfos.Length];
             for (int i = 0; i < processInfos.Length; i++)
             {
                 ProcessInfo processInfo = processInfos[i];
                 processes[i] = new Process(machineName, isRemoteMachine, processInfo.ProcessId, processInfo);
             }
@@ -861,21 +845,20 @@
         }
         private void SetProcessId(int processId)
         {
             _processId = processId;
             _haveProcessId = true;
             ConfigureAfterProcessIdSet();
         }
         partial void ConfigureAfterProcessIdSet();
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public bool Start()
         {
             Close();
             ProcessStartInfo startInfo = StartInfo;
             if (startInfo.FileName.Length == 0)
             {
                 throw new InvalidOperationException(SR.FileNameMissing);
             }
             if (startInfo.StandardInputEncoding != null && !startInfo.RedirectStandardInput)
             {
@@ -892,51 +875,47 @@
             if (!string.IsNullOrEmpty(startInfo.Arguments) && startInfo.HasArgumentList)
             {
                 throw new InvalidOperationException(SR.ArgumentAndArgumentListInitialized);
             }
             CheckDisposed();
             SerializationGuard.ThrowIfDeserializationInProgress("AllowProcessCreation", ref s_cachedSerializationSwitch);
             return StartCore(startInfo);
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process Start(string fileName)
         {
             return Start(new ProcessStartInfo(fileName))!;
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process Start(string fileName, string arguments)
         {
             return Start(new ProcessStartInfo(fileName, arguments))!;
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process Start(string fileName, IEnumerable<string> arguments)
         {
             if (fileName == null)
                 throw new ArgumentNullException(nameof(fileName));
             if (arguments == null)
                 throw new ArgumentNullException(nameof(arguments));
             var startInfo = new ProcessStartInfo(fileName);
             foreach (string argument in arguments)
             {
                 startInfo.ArgumentList.Add(argument);
             }
             return Start(startInfo)!;
         }
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static Process? Start(ProcessStartInfo startInfo)
         {
             Process process = new Process();
             if (startInfo == null)
                 throw new ArgumentNullException(nameof(startInfo));
             process.StartInfo = startInfo;
             return process.Start() ?
                 process :
                 null;
         }

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/Process.iOS.cs
+++ b//dev/null
@@ -1,73 +0,0 @@
-using System.Collections.Generic;
-using System.ComponentModel;
-using System.Runtime.Versioning;
-namespace System.Diagnostics
-{
-    public partial class Process : IDisposable
-    {
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
-        public void Kill(bool entireProcessTree)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
-        public static Process[] GetProcessesByName(string? processName, string machineName)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan PrivilegedProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        internal DateTime StartTimeCore
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan TotalProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan UserProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        private IReadOnlyList<Process> GetChildProcesses(Process[]? processes = null)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        private int GetParentProcessId =>
-            throw new PlatformNotSupportedException();
-        private IntPtr ProcessorAffinityCore
-        {
-            get { throw new PlatformNotSupportedException(); }
-            set { throw new PlatformNotSupportedException(); }
-        }
-        private void GetWorkingSetLimits(out IntPtr minWorkingSet, out IntPtr maxWorkingSet)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        private void SetWorkingSetLimitsCore(IntPtr? newMin, IntPtr? newMax, out IntPtr resultingMin, out IntPtr resultingMax)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        private string GetPathToOpenFile()
-        {
-            throw new PlatformNotSupportedException();
-        }
-        private int ParentProcessId => throw new PlatformNotSupportedException();
-        private static bool IsProcessInvalidException(Exception e) =>
-            e is InvalidOperationException || e is Win32Exception;
-    }
-}

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.Unix.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.Unix.cs
@@ -1,36 +1,32 @@
 using Microsoft.Win32.SafeHandles;
 using System.Collections.Generic;
-using System.Runtime.Versioning;
 using System.Text;
 namespace System.Diagnostics
 {
     internal static partial class ProcessManager
     {
         public static bool IsProcessRunning(int processId, string machineName)
         {
             ThrowIfRemoteMachine(machineName);
             return IsProcessRunning(processId);
         }
         public static bool IsProcessRunning(int processId)
         {
             int output = Interop.Sys.Kill(processId, Interop.Sys.Signals.None);
             return 0 == output || (-1 == output && Interop.Error.EPERM == Interop.Sys.GetLastError());
         }
         public static ProcessInfo? GetProcessInfo(int processId, string machineName)
         {
             ThrowIfRemoteMachine(machineName);
             return CreateProcessInfo(processId);
         }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        [SupportedOSPlatform("maccatalyst")]
         public static int[] GetProcessIds(string machineName)
         {
             ThrowIfRemoteMachine(machineName);
             return GetProcessIds();
         }
         public static int GetProcessIdFromHandle(SafeProcessHandle processHandle)
         {
             return processHandle.ProcessId;
         }
         private static bool IsRemoteMachineCore(string machineName)

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessManager.iOS.cs
+++ b//dev/null
@@ -1,25 +0,0 @@
-using System.Runtime.Versioning;
-namespace System.Diagnostics
-{
-    internal static partial class ProcessManager
-    {
-        public static int[] GetProcessIds()
-        {
-            throw new PlatformNotSupportedException();
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public static ProcessInfo[] GetProcessInfos(string machineName)
-        {
-            throw new PlatformNotSupportedException();
-        }
-        internal static ProcessModuleCollection GetModules(int processId)
-        {
-            return new ProcessModuleCollection(0);
-        }
-        private static ProcessInfo CreateProcessInfo(int pid)
-        {
-            throw new PlatformNotSupportedException();
-        }
-    }
-}

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ProcessThread.iOS.cs
+++ b//dev/null
@@ -1,31 +0,0 @@
-using System.Runtime.Versioning;
-namespace System.Diagnostics
-{
-    public partial class ProcessThread
-    {
-        private ThreadPriorityLevel PriorityLevelCore
-        {
-            get { throw new PlatformNotSupportedException(); }
-            set { throw new PlatformNotSupportedException(); }
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan PrivilegedProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        private DateTime GetStartTime() => throw new PlatformNotSupportedException();
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan TotalProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-        [UnsupportedOSPlatform("ios")]
-        [UnsupportedOSPlatform("tvos")]
-        public TimeSpan UserProcessorTime
-        {
-            get { throw new PlatformNotSupportedException(); }
-        }
-    }
-}

--- a/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ThreadInfo.cs
+++ b/src/libraries/System.Diagnostics.Process/src/System/Diagnostics/ThreadInfo.cs
@@ -1,15 +1,13 @@
 namespace System.Diagnostics
 {
     internal sealed class ThreadInfo
     {
-#pragma warning disable CS0649 // The fields are unused on iOS/tvOS as the respective managed logic (mostly around libproc) is excluded.
         internal ulong _threadId;
         internal int _processId;
         internal int _basePriority;
         internal int _currentPriority;
         internal IntPtr _startAddress;
         internal ThreadState _threadState;
         internal ThreadWaitReason _threadWaitReason;
-#pragma warning restore CS0649
     }
 }

--- a/src/libraries/System.IO.Compression.ZipFile/src/System/IO/Compression/ZipFileExtensions.ZipArchiveEntry.Extract.cs
+++ b/src/libraries/System.IO.Compression.ZipFile/src/System/IO/Compression/ZipFileExtensions.ZipArchiveEntry.Extract.cs
@@ -14,21 +14,21 @@
             using (FileStream fs = new FileStream(destinationFileName, fMode, FileAccess.Write, FileShare.None, bufferSize: 0x1000, useAsync: false))
             {
                 using (Stream es = source.Open())
                     es.CopyTo(fs);
                 ExtractExternalAttributes(fs, source);
             }
             try
             {
                 File.SetLastWriteTime(destinationFileName, source.LastWriteTime.DateTime);
             }
-            catch
+            catch (UnauthorizedAccessException)
             {
             }
         }
         static partial void ExtractExternalAttributes(FileStream fs, ZipArchiveEntry entry);
         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName) =>
             ExtractRelativeToDirectory(source, destinationDirectoryName, overwrite: false);
         internal static void ExtractRelativeToDirectory(this ZipArchiveEntry source, string destinationDirectoryName, bool overwrite)
         {
             if (source == null)
                 throw new ArgumentNullException(nameof(source));

--- a/src/libraries/System.IO.MemoryMappedFiles/src/System/IO/MemoryMappedFiles/MemoryMappedFile.Unix.cs
+++ b/src/libraries/System.IO.MemoryMappedFiles/src/System/IO/MemoryMappedFiles/MemoryMappedFile.Unix.cs
@@ -1,11 +1,10 @@
-using System.Diagnostics;
 using Microsoft.Win32.SafeHandles;
 namespace System.IO.MemoryMappedFiles
 {
     public partial class MemoryMappedFile
     {
         private static void VerifyMemoryMappedFileAccess(MemoryMappedFileAccess access, long capacity, FileStream? fileStream, out long fileSize)
         {
             fileSize = -1;
             if (fileStream != null)
             {
@@ -100,76 +99,57 @@
                 FileAccess.Read;
         }
         private static FileStream CreateSharedBackingObject(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
         {
             return CreateSharedBackingObjectUsingMemory(protections, capacity, inheritability)
                 ?? CreateSharedBackingObjectUsingFile(protections, capacity, inheritability);
         }
         private static FileStream? CreateSharedBackingObjectUsingMemory(
            Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
         {
+            string mapName = string.Create(null, stackalloc char[128], $"/corefx_map_{Guid.NewGuid():N}");
             Interop.Sys.OpenFlags flags = (protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0 ?
                 Interop.Sys.OpenFlags.O_RDWR :
                 Interop.Sys.OpenFlags.O_RDONLY;
             flags |= Interop.Sys.OpenFlags.O_CREAT | Interop.Sys.OpenFlags.O_EXCL; // CreateNew
             Interop.Sys.Permissions perms = default(Interop.Sys.Permissions);
             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_READ) != 0)
                 perms |= Interop.Sys.Permissions.S_IRUSR;
             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_WRITE) != 0)
                 perms |= Interop.Sys.Permissions.S_IWUSR;
             if ((protections & Interop.Sys.MemoryMappedProtections.PROT_EXEC) != 0)
                 perms |= Interop.Sys.Permissions.S_IXUSR;
-            string mapName;
-            SafeFileHandle fd;
-            do
+            SafeFileHandle fd = Interop.Sys.ShmOpen(mapName, flags, (int)perms);
+            if (fd.IsInvalid)
             {
-                mapName = GenerateMapName();
-                fd = Interop.Sys.ShmOpen(mapName, flags, (int)perms); // Create the shared memory object.
-                if (fd.IsInvalid)
+                Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
+                if (errorInfo.Error == Interop.Error.ENOTSUP)
                 {
-                    Interop.ErrorInfo errorInfo = Interop.Sys.GetLastErrorInfo();
-                    fd.Dispose();
-                    if (errorInfo.Error == Interop.Error.ENOTSUP)
-                    {
-                        return null;
-                    }
-                    else if (errorInfo.Error != Interop.Error.EEXIST) // map with same name already existed
-                    {
-                        throw Interop.GetExceptionForIoErrno(errorInfo);
-                    }
+                    return null;
                 }
-            } while (fd.IsInvalid);
+                throw Interop.GetExceptionForIoErrno(errorInfo);
+            }
             try
             {
                 Interop.CheckIo(Interop.Sys.ShmUnlink(mapName));
                 Interop.CheckIo(Interop.Sys.FTruncate(fd, capacity));
                 if (inheritability == HandleInheritability.Inheritable &&
                     Interop.Sys.Fcntl.SetFD(fd, 0) == -1)
                 {
                     throw Interop.GetExceptionForIoErrno(Interop.Sys.GetLastErrorInfo());
                 }
                 return new FileStream(fd, TranslateProtectionsToFileAccess(protections));
             }
             catch
             {
                 fd.Dispose();
                 throw;
-            }
-            static string GenerateMapName()
-            {
-                const int MaxSharedMemoryObjectNameLength = 32; // SHM_NAME_MAX on OSX ARM64, on other systems it's equal PATH_MAX (250)
-                return string.Create(MaxSharedMemoryObjectNameLength, 0, (span, state) =>
-                {
-                    Guid.NewGuid().TryFormat(span, out int charsWritten, "N");
-                    Debug.Assert(charsWritten == MaxSharedMemoryObjectNameLength);
-                    "/dotnet_".CopyTo(span);
-                });
             }
         }
         private static FileStream CreateSharedBackingObjectUsingFile(Interop.Sys.MemoryMappedProtections protections, long capacity, HandleInheritability inheritability)
         {
             string path = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
             FileShare share = inheritability == HandleInheritability.None ?
                 FileShare.ReadWrite :
                 FileShare.ReadWrite | FileShare.Inheritable;
             const int DefaultBufferSize = 0x1000;
             var fs = new FileStream(path, FileMode.CreateNew, TranslateProtectionsToFileAccess(protections), share, DefaultBufferSize);

--- a/src/libraries/System.Net.Http/src/System/Net/Http/HttpClientHandler.AnyMobile.InvokeNativeHandler.cs
+++ b/src/libraries/System.Net.Http/src/System/Net/Http/HttpClientHandler.AnyMobile.InvokeNativeHandler.cs
@@ -9,30 +9,30 @@
 {
     public partial class HttpClientHandler : HttpMessageHandler
     {
         private static MethodInfo? _nativeHandlerMethod;
 #if TARGET_ANDROID
         private const string NativeHandlerType = "Xamarin.Android.Net.AndroidMessageHandler";
         private const string AssemblyName = "Mono.Android";
         private const string GetHttpMessageHandlerType = "Android.Runtime.AndroidEnvironment, Mono.Android";
 #elif TARGET_IOS
         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
-        private const string AssemblyName = "Microsoft.iOS";
-        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.iOS";
+        private const string AssemblyName = "Xamarin.iOS";
+        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.iOS";
 #elif TARGET_MACCATALYST
         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
-        private const string AssemblyName = "Microsoft.MacCatalyst";
-        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.MacCatalyst";
+        private const string AssemblyName = "Xamarin.MacCatalyst";
+        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.MacCatalyst";
 #elif TARGET_TVOS
         private const string NativeHandlerType = "System.Net.Http.NSUrlSessionHandler";
-        private const string AssemblyName = "Microsoft.tvOS";
-        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Microsoft.tvOS";
+        private const string AssemblyName = "Xamarin.TVOS";
+        private const string GetHttpMessageHandlerType = "ObjCRuntime.RuntimeOptions, Xamarin.TVOS";
 #else
 #error Unknown target
 #endif
         [DynamicDependency("get_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
         private ICredentials? GetDefaultProxyCredentials() => (ICredentials?)InvokeNativeHandlerMethod("get_DefaultProxyCredentials");
         [DynamicDependency("set_DefaultProxyCredentials", NativeHandlerType, AssemblyName)]
         private void SetDefaultProxyCredentials(ICredentials? value) => InvokeNativeHandlerMethod("set_DefaultProxyCredentials", value);
         [DynamicDependency("get_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]
         private int GetMaxConnectionsPerServer() => (int)InvokeNativeHandlerMethod("get_MaxConnectionsPerServer");
         [DynamicDependency("set_MaxConnectionsPerServer", NativeHandlerType, AssemblyName)]

--- a/src/libraries/System.Net.NetworkInformation/ref/System.Net.NetworkInformation.cs
+++ b/src/libraries/System.Net.NetworkInformation/ref/System.Net.NetworkInformation.cs
@@ -110,121 +110,85 @@
         public virtual void Clear() { }
         public virtual bool Contains(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
         public virtual void CopyTo(System.Net.NetworkInformation.IPAddressInformation[] array, int offset) { }
         public virtual System.Collections.Generic.IEnumerator<System.Net.NetworkInformation.IPAddressInformation> GetEnumerator() { throw null; }
         public virtual bool Remove(System.Net.NetworkInformation.IPAddressInformation address) { throw null; }
         System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { throw null; }
     }
     public abstract partial class IPGlobalProperties
     {
         protected IPGlobalProperties() { }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract string DhcpScopeName { get; }
         public abstract string DomainName { get; }
         public abstract string HostName { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsWinsProxy { get; }
         public abstract System.Net.NetworkInformation.NetBiosNodeType NodeType { get; }
         public virtual System.IAsyncResult BeginGetUnicastAddresses(System.AsyncCallback? callback, object? state) { throw null; }
         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection EndGetUnicastAddresses(System.IAsyncResult asyncResult) { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.TcpConnectionInformation[] GetActiveTcpConnections();
         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.IPEndPoint[] GetActiveTcpListeners();
         [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.IPEndPoint[] GetActiveUdpListeners();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IcmpV4Statistics GetIcmpV4Statistics();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IcmpV6Statistics GetIcmpV6Statistics();
         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
         public static System.Net.NetworkInformation.IPGlobalProperties GetIPGlobalProperties() { throw null; }
         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv4GlobalStatistics();
         public abstract System.Net.NetworkInformation.IPGlobalStatistics GetIPv6GlobalStatistics();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv4Statistics();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.TcpStatistics GetTcpIPv6Statistics();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv4Statistics();
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.UdpStatistics GetUdpIPv6Statistics();
         public virtual System.Net.NetworkInformation.UnicastIPAddressInformationCollection GetUnicastAddresses() { throw null; }
         public virtual System.Threading.Tasks.Task<System.Net.NetworkInformation.UnicastIPAddressInformationCollection> GetUnicastAddressesAsync() { throw null; }
     }
     public abstract partial class IPGlobalStatistics
     {
         protected IPGlobalStatistics() { }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract int DefaultTtl { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool ForwardingEnabled { get; }
         public abstract int NumberOfInterfaces { get; }
         public abstract int NumberOfIPAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract int NumberOfRoutes { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long OutputPacketRequests { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long OutputPacketRoutingDiscards { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long OutputPacketsDiscarded { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long OutputPacketsWithNoRoute { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketFragmentFailures { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketReassembliesRequired { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketReassemblyFailures { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketReassemblyTimeout { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketsFragmented { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long PacketsReassembled { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPackets { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsDelivered { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsDiscarded { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsForwarded { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithAddressErrors { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithHeadersErrors { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
     }
     public abstract partial class IPInterfaceProperties
     {
         protected IPInterfaceProperties() { }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IPAddressInformationCollection AnycastAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IPAddressCollection DhcpServerAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IPAddressCollection DnsAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract string DnsSuffix { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.GatewayIPAddressInformationCollection GatewayAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsDnsEnabled { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsDynamicDnsEnabled { get; }
         public abstract System.Net.NetworkInformation.MulticastIPAddressInformationCollection MulticastAddresses { get; }
         public abstract System.Net.NetworkInformation.UnicastIPAddressInformationCollection UnicastAddresses { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract System.Net.NetworkInformation.IPAddressCollection WinsServersAddresses { get; }
         public abstract System.Net.NetworkInformation.IPv4InterfaceProperties GetIPv4Properties();
         public abstract System.Net.NetworkInformation.IPv6InterfaceProperties GetIPv6Properties();
     }
     public abstract partial class IPInterfaceStatistics
     {
         protected IPInterfaceStatistics() { }
         public abstract long BytesReceived { get; }
         public abstract long BytesSent { get; }
         public abstract long IncomingPacketsDiscarded { get; }
@@ -235,30 +199,25 @@
         public abstract long OutgoingPacketsDiscarded { get; }
         public abstract long OutgoingPacketsWithErrors { get; }
         public abstract long OutputQueueLength { get; }
         public abstract long UnicastPacketsReceived { get; }
         public abstract long UnicastPacketsSent { get; }
     }
     public abstract partial class IPv4InterfaceProperties
     {
         protected IPv4InterfaceProperties() { }
         public abstract int Index { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsAutomaticPrivateAddressingActive { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsDhcpEnabled { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool IsForwardingEnabled { get; }
         public abstract int Mtu { get; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public abstract bool UsesWins { get; }
     }
     public abstract partial class IPv4InterfaceStatistics
     {
         protected IPv4InterfaceStatistics() { }
         public abstract long BytesReceived { get; }
         public abstract long BytesSent { get; }
         public abstract long IncomingPacketsDiscarded { get; }
         public abstract long IncomingPacketsWithErrors { get; }
         public abstract long IncomingUnknownProtocolPackets { get; }
@@ -344,23 +303,21 @@
         public static int LoopbackInterfaceIndex { get { throw null; } }
         public virtual string Name { get { throw null; } }
         public virtual System.Net.NetworkInformation.NetworkInterfaceType NetworkInterfaceType { get { throw null; } }
         public virtual System.Net.NetworkInformation.OperationalStatus OperationalStatus { get { throw null; } }
         public virtual long Speed { get { throw null; } }
         public virtual bool SupportsMulticast { get { throw null; } }
         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
         public static System.Net.NetworkInformation.NetworkInterface[] GetAllNetworkInterfaces() { throw null; }
         public virtual System.Net.NetworkInformation.IPInterfaceProperties GetIPProperties() { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public virtual System.Net.NetworkInformation.IPInterfaceStatistics GetIPStatistics() { throw null; }
-        [System.Runtime.Versioning.UnsupportedOSPlatform("android")]
         public virtual System.Net.NetworkInformation.IPv4InterfaceStatistics GetIPv4Statistics() { throw null; }
         [System.Runtime.Versioning.UnsupportedOSPlatform("illumos")]
         [System.Runtime.Versioning.UnsupportedOSPlatform("solaris")]
         public static bool GetIsNetworkAvailable() { throw null; }
         public virtual System.Net.NetworkInformation.PhysicalAddress GetPhysicalAddress() { throw null; }
         public virtual bool Supports(System.Net.NetworkInformation.NetworkInterfaceComponent networkInterfaceComponent) { throw null; }
     }
     public enum NetworkInterfaceComponent
     {
         IPv4 = 0,

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPGlobalProperties.cs
+++ b//dev/null
@@ -1,19 +0,0 @@
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidIPGlobalProperties : UnixIPGlobalProperties
-    {
-        public override TcpConnectionInformation[] GetActiveTcpConnections() => throw new PlatformNotSupportedException();
-        public override IPEndPoint[] GetActiveTcpListeners() => throw new PlatformNotSupportedException();
-        public override IPEndPoint[] GetActiveUdpListeners() => throw new PlatformNotSupportedException();
-        public override IcmpV4Statistics GetIcmpV4Statistics() => throw new PlatformNotSupportedException();
-        public override IcmpV6Statistics GetIcmpV6Statistics() => throw new PlatformNotSupportedException();
-        public override IPGlobalStatistics GetIPv4GlobalStatistics()
-            => new AndroidIPGlobalStatistics(ipv4: true);
-        public override IPGlobalStatistics GetIPv6GlobalStatistics()
-            => new AndroidIPGlobalStatistics(ipv4: false);
-        public override TcpStatistics GetTcpIPv4Statistics() => throw new PlatformNotSupportedException();
-        public override TcpStatistics GetTcpIPv6Statistics() => throw new PlatformNotSupportedException();
-        public override UdpStatistics GetUdpIPv4Statistics() => throw new PlatformNotSupportedException();
-        public override UdpStatistics GetUdpIPv6Statistics() => throw new PlatformNotSupportedException();
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPGlobalStatistics.cs
+++ b//dev/null
@@ -1,64 +0,0 @@
-using System.Diagnostics;
-using System.IO;
-using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
-using System.Net.Sockets;
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidIPGlobalStatistics : IPGlobalStatistics
-    {
-        public AndroidIPGlobalStatistics(bool ipv4)
-        {
-            AndroidNetworkInterface[] networkInterfaces = NetworkInterfacePal.GetAndroidNetworkInterfaces();
-            foreach (var networkInterface in networkInterfaces)
-            {
-                var component = ipv4 ? NetworkInterfaceComponent.IPv4 : NetworkInterfaceComponent.IPv6;
-                if (networkInterface.Supports(component))
-                {
-                    NumberOfInterfaces++;
-                }
-                foreach (UnixUnicastIPAddressInformation addressInformation in networkInterface.UnicastAddress)
-                {
-                    bool isIPv4 = addressInformation.Address.AddressFamily == AddressFamily.InterNetwork;
-                    if (isIPv4 == ipv4)
-                    {
-                        NumberOfIPAddresses++;
-                    }
-                }
-                if (networkInterface.MulticastAddresess != null)
-                {
-                    foreach (IPAddress address in networkInterface.MulticastAddresess)
-                    {
-                        bool isIPv4 = address.AddressFamily == AddressFamily.InterNetwork;
-                        if (isIPv4 == ipv4)
-                        {
-                            NumberOfIPAddresses++;
-                        }
-                    }
-                }
-            }
-        }
-        public override int NumberOfInterfaces { get; }
-        public override int NumberOfIPAddresses { get; }
-        public override int DefaultTtl => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override bool ForwardingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override int NumberOfRoutes => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long OutputPacketRequests => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long OutputPacketRoutingDiscards => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long OutputPacketsDiscarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long OutputPacketsWithNoRoute => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketFragmentFailures => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketReassembliesRequired => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketReassemblyFailures => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketReassemblyTimeout => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketsFragmented => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long PacketsReassembled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPackets => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsDelivered => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsDiscarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsForwarded => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsWithAddressErrors => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsWithHeadersErrors => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override long ReceivedPacketsWithUnknownProtocol => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPInterfaceProperties.cs
+++ b//dev/null
@@ -1,23 +0,0 @@
-using System.Collections.Generic;
-using System.IO;
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidIPInterfaceProperties : UnixIPInterfaceProperties
-    {
-        private readonly AndroidIPv4InterfaceProperties _ipv4Properties;
-        private readonly AndroidIPv6InterfaceProperties _ipv6Properties;
-        public AndroidIPInterfaceProperties(AndroidNetworkInterface ani)
-            : base(ani, globalConfig: true)
-        {
-            _ipv4Properties = new AndroidIPv4InterfaceProperties(ani);
-            _ipv6Properties = new AndroidIPv6InterfaceProperties(ani);
-        }
-        public override IPv4InterfaceProperties GetIPv4Properties() => _ipv4Properties;
-        public override IPv6InterfaceProperties GetIPv6Properties() => _ipv6Properties;
-        public override bool IsDynamicDnsEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override IPAddressInformationCollection AnycastAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override GatewayIPAddressInformationCollection GatewayAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override IPAddressCollection DhcpServerAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override IPAddressCollection WinsServersAddresses => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPv4InterfaceProperties.cs
+++ b//dev/null
@@ -1,18 +0,0 @@
-using System.IO;
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidIPv4InterfaceProperties : UnixIPv4InterfaceProperties
-    {
-        public AndroidIPv4InterfaceProperties(AndroidNetworkInterface androidNetworkInterface)
-            : base(androidNetworkInterface)
-        {
-            Mtu = androidNetworkInterface._mtu;
-        }
-        public override int Mtu { get; }
-        public override bool IsAutomaticPrivateAddressingActive => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override bool IsAutomaticPrivateAddressingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override bool IsDhcpEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override bool IsForwardingEnabled => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override bool UsesWins => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidIPv6InterfaceProperties.cs
+++ b//dev/null
@@ -1,23 +0,0 @@
-using System.IO;
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidIPv6InterfaceProperties : UnixIPv6InterfaceProperties
-    {
-        private readonly AndroidNetworkInterface _androidNetworkInterface;
-        public AndroidIPv6InterfaceProperties(AndroidNetworkInterface androidNetworkInterface)
-            : base(androidNetworkInterface)
-        {
-            _androidNetworkInterface = androidNetworkInterface;
-        }
-        public override int Mtu => _androidNetworkInterface._mtu;
-        public override long GetScopeId(ScopeLevel scopeLevel)
-        {
-            if (scopeLevel == ScopeLevel.None || scopeLevel == ScopeLevel.Interface ||
-                scopeLevel == ScopeLevel.Link || scopeLevel == ScopeLevel.Subnet)
-            {
-                return _androidNetworkInterface.Index;
-            }
-            return 0;
-        }
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/AndroidNetworkInterface.cs
+++ b//dev/null
@@ -1,41 +0,0 @@
-using System.Net;
-namespace System.Net.NetworkInformation
-{
-    internal sealed class AndroidNetworkInterface : UnixNetworkInterface
-    {
-        internal readonly int _mtu;
-        private readonly AndroidIPInterfaceProperties _ipProperties;
-        internal unsafe AndroidNetworkInterface(string name, Interop.Sys.NetworkInterfaceInfo *networkInterfaceInfo)
-            : base(name)
-        {
-            _index = networkInterfaceInfo->InterfaceIndex;
-            if (networkInterfaceInfo->NumAddressBytes > 0)
-            {
-                _physicalAddress = new PhysicalAddress(new ReadOnlySpan<byte>(networkInterfaceInfo->AddressBytes, networkInterfaceInfo->NumAddressBytes).ToArray());
-            }
-            _mtu = networkInterfaceInfo->Mtu;
-            _ipProperties = new AndroidIPInterfaceProperties(this);
-            OperationalStatus = (OperationalStatus)networkInterfaceInfo->OperationalState;
-            Speed = networkInterfaceInfo->Speed;
-            SupportsMulticast = networkInterfaceInfo->SupportsMulticast != 0;
-            NetworkInterfaceType = (NetworkInterfaceType)networkInterfaceInfo->HardwareType;
-        }
-        internal unsafe void AddAddress(Interop.Sys.IpAddressInfo *addressInfo)
-        {
-            var address = new IPAddress(new ReadOnlySpan<byte>(addressInfo->AddressBytes, addressInfo->NumAddressBytes));
-            if (address.IsIPv6LinkLocal)
-            {
-                address.ScopeId = addressInfo->InterfaceIndex;
-            }
-            AddAddress(address, addressInfo->PrefixLength);
-        }
-        public override bool SupportsMulticast { get; }
-        public override IPInterfaceProperties GetIPProperties() => _ipProperties;
-        public override IPInterfaceStatistics GetIPStatistics() => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override IPv4InterfaceStatistics GetIPv4Statistics() => throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform);
-        public override OperationalStatus OperationalStatus { get; }
-        public override NetworkInterfaceType NetworkInterfaceType { get; }
-        public override long Speed { get; }
-        public override bool IsReceiveOnly => false;
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalProperties.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalProperties.cs
@@ -9,46 +9,38 @@
         public static IPGlobalProperties GetIPGlobalProperties()
         {
             return IPGlobalPropertiesPal.GetIPGlobalProperties();
         }
         [UnsupportedOSPlatform("android")]
         public abstract IPEndPoint[] GetActiveUdpListeners();
         [UnsupportedOSPlatform("android")]
         public abstract IPEndPoint[] GetActiveTcpListeners();
         [UnsupportedOSPlatform("android")]
         public abstract TcpConnectionInformation[] GetActiveTcpConnections();
-        [UnsupportedOSPlatform("android")]
         public abstract string DhcpScopeName { get; }
         public abstract string DomainName { get; }
         public abstract string HostName { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsWinsProxy { get; }
         public abstract NetBiosNodeType NodeType { get; }
         public virtual IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
         public virtual UnicastIPAddressInformationCollection EndGetUnicastAddresses(IAsyncResult asyncResult)
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
-        [UnsupportedOSPlatform("android")]
         public abstract TcpStatistics GetTcpIPv4Statistics();
-        [UnsupportedOSPlatform("android")]
         public abstract TcpStatistics GetTcpIPv6Statistics();
-        [UnsupportedOSPlatform("android")]
         public abstract UdpStatistics GetUdpIPv4Statistics();
-        [UnsupportedOSPlatform("android")]
         public abstract UdpStatistics GetUdpIPv6Statistics();
-        [UnsupportedOSPlatform("android")]
         public abstract IcmpV4Statistics GetIcmpV4Statistics();
-        [UnsupportedOSPlatform("android")]
         public abstract IcmpV6Statistics GetIcmpV6Statistics();
         public abstract IPGlobalStatistics GetIPv4GlobalStatistics();
         public abstract IPGlobalStatistics GetIPv6GlobalStatistics();
         public virtual UnicastIPAddressInformationCollection GetUnicastAddresses()
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
         public virtual Task<UnicastIPAddressInformationCollection> GetUnicastAddressesAsync()
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalPropertiesPal.Android.cs
+++ b//dev/null
@@ -1,10 +0,0 @@
-namespace System.Net.NetworkInformation
-{
-    internal static class IPGlobalPropertiesPal
-    {
-        public static IPGlobalProperties GetIPGlobalProperties()
-        {
-            return new AndroidIPGlobalProperties();
-        }
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalStatistics.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPGlobalStatistics.cs
@@ -1,49 +1,28 @@
-using System.Runtime.Versioning;
 namespace System.Net.NetworkInformation
 {
     public abstract class IPGlobalStatistics
     {
-        [UnsupportedOSPlatform("android")]
         public abstract int DefaultTtl { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool ForwardingEnabled { get; }
         public abstract int NumberOfInterfaces { get; }
         public abstract int NumberOfIPAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long OutputPacketRequests { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long OutputPacketRoutingDiscards { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long OutputPacketsDiscarded { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long OutputPacketsWithNoRoute { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketFragmentFailures { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketReassembliesRequired { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketReassemblyFailures { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketReassemblyTimeout { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketsFragmented { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long PacketsReassembled { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPackets { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsDelivered { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsDiscarded { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsForwarded { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithAddressErrors { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithHeadersErrors { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract long ReceivedPacketsWithUnknownProtocol { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract int NumberOfRoutes { get; }
     }
 }

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPInterfaceProperties.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPInterfaceProperties.cs
@@ -1,27 +1,18 @@
-using System.Runtime.Versioning;
 namespace System.Net.NetworkInformation
 {
     public abstract class IPInterfaceProperties
     {
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsDnsEnabled { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract string DnsSuffix { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsDynamicDnsEnabled { get; }
         public abstract UnicastIPAddressInformationCollection UnicastAddresses { get; }
         public abstract MulticastIPAddressInformationCollection MulticastAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract IPAddressInformationCollection AnycastAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract IPAddressCollection DnsAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract GatewayIPAddressInformationCollection GatewayAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract IPAddressCollection DhcpServerAddresses { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract IPAddressCollection WinsServersAddresses { get; }
         public abstract IPv4InterfaceProperties GetIPv4Properties();
         public abstract IPv6InterfaceProperties GetIPv6Properties();
     }
 }

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPv4InterfaceProperties.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/IPv4InterfaceProperties.cs
@@ -1,19 +1,13 @@
-using System.Runtime.Versioning;
 namespace System.Net.NetworkInformation
 {
     public abstract class IPv4InterfaceProperties
     {
-        [UnsupportedOSPlatform("android")]
         public abstract bool UsesWins { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsDhcpEnabled { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsAutomaticPrivateAddressingActive { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsAutomaticPrivateAddressingEnabled { get; }
         public abstract int Index { get; }
-        [UnsupportedOSPlatform("android")]
         public abstract bool IsForwardingEnabled { get; }
         public abstract int Mtu { get; }
     }
 }

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterface.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterface.cs
@@ -33,26 +33,24 @@
                 return NetworkInterfacePal.LoopbackInterfaceIndex;
             }
         }
         public virtual string Id { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual string Name { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual string Description { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual IPInterfaceProperties GetIPProperties()
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
-        [UnsupportedOSPlatform("android")]
         public virtual IPInterfaceStatistics GetIPStatistics()
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
-        [UnsupportedOSPlatform("android")]
         public virtual IPv4InterfaceStatistics GetIPv4Statistics()
         {
             throw NotImplemented.ByDesignWithMessage(SR.net_MethodNotImplementedException);
         }
         public virtual OperationalStatus OperationalStatus { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual long Speed { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual bool IsReceiveOnly { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual bool SupportsMulticast { get { throw NotImplemented.ByDesignWithMessage(SR.net_PropertyNotImplementedException); } }
         public virtual PhysicalAddress GetPhysicalAddress()
         {

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/NetworkInterfacePal.Android.cs
+++ b//dev/null
@@ -1,86 +0,0 @@
-using System.Runtime.InteropServices;
-namespace System.Net.NetworkInformation
-{
-    internal static class NetworkInterfacePal
-    {
-        public static NetworkInterface[] GetAllNetworkInterfaces() => GetAndroidNetworkInterfaces();
-        public static bool GetIsNetworkAvailable() => TransformNetworkInterfacess(IsSomeNetworkUp);
-        public static int IPv6LoopbackInterfaceIndex => LoopbackInterfaceIndex;
-        public static int LoopbackInterfaceIndex => TransformNetworkInterfacess(FindLoopbackInterfaceIndex);
-        internal static unsafe AndroidNetworkInterface[] GetAndroidNetworkInterfaces()
-            => TransformNetworkInterfacess(ToAndroidNetworkInterfaceArray);
-        private static unsafe T TransformNetworkInterfacess<T>(Func<int, IntPtr, int, IntPtr, T> transform)
-        {
-            int interfaceCount = 0;
-            int addressCount = 0;
-            Interop.Sys.NetworkInterfaceInfo *networkInterfaceInfo = null;
-            Interop.Sys.IpAddressInfo *addressInfo = null;
-            if (Interop.Sys.GetNetworkInterfaces(ref interfaceCount, ref networkInterfaceInfo, ref addressCount, ref addressInfo) != 0)
-            {
-                string message = Interop.Sys.GetLastErrorInfo().GetErrorMessage();
-                throw new NetworkInformationException(message);
-            }
-            var globalMemory = (IntPtr)networkInterfaceInfo;
-            try
-            {
-                return transform(interfaceCount, (IntPtr)networkInterfaceInfo, addressCount, (IntPtr)addressInfo);
-            }
-            finally
-            {
-                Marshal.FreeHGlobal(globalMemory);
-            }
-        }
-        private static unsafe AndroidNetworkInterface[] ToAndroidNetworkInterfaceArray(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
-        {
-            var networkInterfaces = new AndroidNetworkInterface[interfaceCount];
-            var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
-            for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
-            {
-                var name = Marshal.PtrToStringAnsi((IntPtr)networkInterfaceInfo->Name);
-                networkInterfaces[i] = new AndroidNetworkInterface(name!, networkInterfaceInfo);
-            }
-            var addressInfo = (Interop.Sys.IpAddressInfo*)addressPtr;
-            for (int i = 0; i < addressCount; i++, addressInfo++)
-            {
-                foreach (var networkInterface in networkInterfaces)
-                {
-                    if (networkInterface.Index == addressInfo->InterfaceIndex)
-                    {
-                        networkInterface.AddAddress(addressInfo);
-                        break;
-                    }
-                }
-            }
-            return networkInterfaces;
-        }
-        private static unsafe int FindLoopbackInterfaceIndex(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
-        {
-            var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
-            for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
-            {
-                if (networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Loopback)
-                {
-                    return networkInterfaceInfo->InterfaceIndex;
-                }
-            }
-            throw new NetworkInformationException(SR.net_NoLoopback);
-        }
-        private static unsafe bool IsSomeNetworkUp(int interfaceCount, IntPtr networkInterfacesPtr, int addressCount, IntPtr addressPtr)
-        {
-            var networkInterfaceInfo = (Interop.Sys.NetworkInterfaceInfo*)networkInterfacesPtr;
-            for (int i = 0; i < interfaceCount; i++, networkInterfaceInfo++)
-            {
-                if (networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Loopback
-                    || networkInterfaceInfo->HardwareType == (int)NetworkInterfaceType.Tunnel)
-                {
-                    continue;
-                }
-                if (networkInterfaceInfo->OperationalState == (int)OperationalStatus.Up)
-                {
-                    return true;
-                }
-            }
-            return false;
-        }
-    }
-}

--- a/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/UnixIPGlobalProperties.cs
+++ b/src/libraries/System.Net.NetworkInformation/src/System/Net/NetworkInformation/UnixIPGlobalProperties.cs
@@ -2,32 +2,30 @@
 using System.Runtime.CompilerServices;
 using System.Runtime.InteropServices;
 using System.Runtime.Versioning;
 using System.Threading;
 using System.Threading.Tasks;
 namespace System.Net.NetworkInformation
 {
     internal abstract class UnixIPGlobalProperties : IPGlobalProperties
     {
         [UnsupportedOSPlatform("linux")]
-        [UnsupportedOSPlatform("android")]
         [UnsupportedOSPlatform("osx")]
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
         [UnsupportedOSPlatform("freebsd")]
         [UnsupportedOSPlatform("illumos")]
         [UnsupportedOSPlatform("solaris")]
         public override string DhcpScopeName { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
         public override string DomainName { get { return HostInformation.DomainName; } }
         public override string HostName { get { return HostInformation.HostName; } }
         [UnsupportedOSPlatform("linux")]
-        [UnsupportedOSPlatform("android")]
         [UnsupportedOSPlatform("osx")]
         [UnsupportedOSPlatform("ios")]
         [UnsupportedOSPlatform("tvos")]
         [UnsupportedOSPlatform("freebsd")]
         [UnsupportedOSPlatform("illumos")]
         [UnsupportedOSPlatform("solaris")]
         public override bool IsWinsProxy { get { throw new PlatformNotSupportedException(SR.net_InformationUnavailableOnPlatform); } }
         public override NetBiosNodeType NodeType { get { return NetBiosNodeType.Unknown; } }
         public override IAsyncResult BeginGetUnicastAddresses(AsyncCallback? callback, object? state)
         {

--- a/src/libraries/System.Net.Security/src/System/Net/Security/CipherSuitesPolicyPal.Linux.cs
+++ b/src/libraries/System.Net.Security/src/System/Net/Security/CipherSuitesPolicyPal.Linux.cs
@@ -13,21 +13,21 @@
         private static readonly byte[] AllowNoEncryptionDefault =
             Encoding.ASCII.GetBytes("ALL:eNULL\0");
         private static readonly byte[] NoEncryptionDefault =
             Encoding.ASCII.GetBytes("eNULL\0");
         private byte[] _cipherSuites;
         private byte[] _tls13CipherSuites;
         private List<TlsCipherSuite> _tlsCipherSuites = new List<TlsCipherSuite>();
         internal IEnumerable<TlsCipherSuite> GetCipherSuites() => _tlsCipherSuites;
         internal CipherSuitesPolicyPal(IEnumerable<TlsCipherSuite> allowedCipherSuites)
         {
-            if (!Interop.Ssl.Capabilities.Tls13Supported)
+            if (!Interop.Ssl.Tls13Supported)
             {
                 throw new PlatformNotSupportedException(SR.net_ssl_ciphersuites_policy_not_supported);
             }
             using (SafeSslContextHandle innerContext = Ssl.SslCtxCreate(Ssl.SslMethods.SSLv23_method))
             {
                 if (innerContext.IsInvalid)
                 {
                     throw OpenSsl.CreateSslException(SR.net_allocate_ssl_context_failed);
                 }
                 using (SafeSslHandle ssl = SafeSslHandle.Create(innerContext, false))

--- a/src/libraries/System.Private.CoreLib/src/System/DateOnly.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/DateOnly.cs
@@ -353,26 +353,28 @@
                         charsWritten = 16;
                         return true;
                     case 'm':
                     case 'M':
                     case 'd':
                     case 'D':
                     case 'y':
                     case 'Y':
                         return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
                     default:
-                        throw new FormatException(SR.Argument_BadFormatSpecifier);
+                        charsWritten = 0;
+                        return false;
                 }
             }
             if (!DateTimeFormat.IsValidCustomDateFormat(format, throwOnError: false))
             {
-                throw new FormatException(SR.Format(SR.Format_DateTimeOnlyContainsNoneDateParts, format.ToString(), nameof(DateOnly)));
+                charsWritten = 0;
+                return false;
             }
             return DateTimeFormat.TryFormat(GetEquivalentDateTime(), destination, out charsWritten, format, provider);
         }
 #if FEATURE_GENERIC_MATH
         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
         static bool IComparisonOperators<DateOnly, DateOnly>.operator <(DateOnly left, DateOnly right)
             => left < right;
         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
         static bool IComparisonOperators<DateOnly, DateOnly>.operator <=(DateOnly left, DateOnly right)
             => left <= right;

--- a/src/libraries/System.Private.CoreLib/src/System/Environment.iOS.cs
+++ b//dev/null
@@ -1,8 +0,0 @@
-using System.Runtime.InteropServices;
-namespace System
-{
-    public static partial class Environment
-    {
-        public static long WorkingSet => 0;
-    }
-}

--- a/src/libraries/System.Private.CoreLib/src/System/Globalization/DateTimeFormat.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Globalization/DateTimeFormat.cs
@@ -41,22 +41,22 @@
         "tt"                AM/PM designator                      AM
         "tt*"               AM/PM designator                      PM
         "d"     "0"         day w/o leading zero                  1
         "dd"    "00"        day with leading zero                 01
         "ddd"               short weekday name (abbreviation)     Mon
         "dddd"              full weekday name                     Monday
         "dddd*"             full weekday name                     Monday
         "M"     "0"         month w/o leading zero                2
         "MM"    "00"        month with leading zero               02
         "MMM"               short month name (abbreviation)       Feb
-        "MMMM"              full month name                       February
-        "MMMM*"             full month name                       February
+        "MMMM"              full month name                       Febuary
+        "MMMM*"             full month name                       Febuary
         "y"     "0"         two digit year (year % 100) w/o leading zero           0
         "yy"    "00"        two digit year (year % 100) with leading zero          00
         "yyy"   "D3"        year                                  2000
         "yyyy"  "D4"        year                                  2000
         "yyyyy" "D5"        year                                  2000
         ...
         "z"     "+0;-0"     timezone offset w/o leading zero      -8
         "zz"    "+00;-00"   timezone offset with leading zero     -08
         "zzz"      "+00;-00" for hour offset, "00" for minute offset  full timezone offset   -07:30
         "zzz*"  "+00;-00" for hour offset, "00" for minute offset   full timezone offset   -08:00

--- a/src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Number.BigInteger.cs
@@ -6,21 +6,21 @@
 {
     internal static partial class Number
     {
         [StructLayout(LayoutKind.Sequential, Pack = 1)]
         internal unsafe ref struct BigInteger
         {
             private const int BitsForLongestBinaryMantissa = 1074;
             private const int BitsForLongestDigitSequence = 2552;
             private const int MaxBits = BitsForLongestBinaryMantissa + BitsForLongestDigitSequence + BitsPerBlock;
             private const int BitsPerBlock = sizeof(int) * 8;
-            private const int MaxBlockCount = ((MaxBits + (BitsPerBlock - 1)) / BitsPerBlock) + 1;
+            private const int MaxBlockCount = (MaxBits + (BitsPerBlock - 1)) / BitsPerBlock;
             private static readonly uint[] s_Pow10UInt32Table = new uint[]
             {
                 1,          // 10^0
                 10,         // 10^1
                 100,        // 10^2
                 1000,       // 10^3
                 10000,      // 10^4
                 100000,     // 10^5
                 1000000,    // 10^6
                 10000000,   // 10^7
@@ -266,21 +266,20 @@
                 0x00000325,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
                 0x00000000,
-                0x00000000,
             };
             private int _length;
             private fixed uint _blocks[MaxBlockCount];
             public static void Add(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
             {
                 ref BigInteger large = ref (lhs._length < rhs._length) ? ref rhs : ref lhs;
                 ref BigInteger small = ref (lhs._length < rhs._length) ? ref lhs : ref rhs;
                 int largeLength = large._length;
                 int smallLength = small._length;
                 result._length = largeLength;
@@ -298,31 +297,24 @@
                     resultIndex++;
                 }
                 while (largeIndex < largeLength)
                 {
                     ulong sum = carry + large._blocks[largeIndex];
                     carry = sum >> 32;
                     result._blocks[resultIndex] = (uint)(sum);
                     largeIndex++;
                     resultIndex++;
                 }
-                int resultLength = largeLength;
                 if (carry != 0)
                 {
                     Debug.Assert(carry == 1);
-                    Debug.Assert(resultIndex == resultLength);
-                    Debug.Assert(unchecked((uint)(resultLength)) < MaxBlockCount);
-                    if (unchecked((uint)(resultLength)) >= MaxBlockCount)
-                    {
-                        SetZero(out result);
-                        return;
-                    }
+                    Debug.Assert((resultIndex == largeLength) && (largeLength < MaxBlockCount));
                     result._blocks[resultIndex] = 1;
                     result._length++;
                 }
             }
             public static int Compare(ref BigInteger lhs, ref BigInteger rhs)
             {
                 Debug.Assert(unchecked((uint)(lhs._length)) <= MaxBlockCount);
                 Debug.Assert(unchecked((uint)(rhs._length)) <= MaxBlockCount);
                 int lhsLength = lhs._length;
                 int rhsLength = rhs._length;
@@ -563,33 +555,30 @@
                 int lhsLength = lhs._length;
                 int index = 0;
                 uint carry = 0;
                 while (index < lhsLength)
                 {
                     ulong product = ((ulong)(lhs._blocks[index]) * value) + carry;
                     result._blocks[index] = (uint)(product);
                     carry = (uint)(product >> 32);
                     index++;
                 }
-                int resultLength = lhsLength;
                 if (carry != 0)
                 {
-                    Debug.Assert(unchecked((uint)(resultLength)) < MaxBlockCount);
-                    if (unchecked((uint)(resultLength)) >= MaxBlockCount)
-                    {
-                        SetZero(out result);
-                        return;
-                    }
+                    Debug.Assert(unchecked((uint)(lhsLength)) + 1 <= MaxBlockCount);
                     result._blocks[index] = carry;
-                    resultLength += 1;
-                }
-                result._length = resultLength;
+                    result._length = (lhsLength + 1);
+                }
+                else
+                {
+                    result._length = lhsLength;
+                }
             }
             public static void Multiply(ref BigInteger lhs, ref BigInteger rhs, out BigInteger result)
             {
                 if (lhs._length <= 1)
                 {
                     Multiply(ref rhs, lhs.ToUInt32(), out result);
                     return;
                 }
                 if (rhs._length <= 1)
                 {
@@ -602,25 +591,20 @@
                 int smallLength = rhs._length;
                 if (largeLength < smallLength)
                 {
                     large = ref rhs;
                     largeLength = rhs._length;
                     small = ref lhs;
                     smallLength = lhs._length;
                 }
                 int maxResultLength = smallLength + largeLength;
                 Debug.Assert(unchecked((uint)(maxResultLength)) <= MaxBlockCount);
-                if (unchecked((uint)(maxResultLength)) > MaxBlockCount)
-                {
-                    SetZero(out result);
-                    return;
-                }
                 result._length = maxResultLength;
                 result.Clear((uint)maxResultLength);
                 int smallIndex = 0;
                 int resultStartIndex = 0;
                 while (smallIndex < smallLength)
                 {
                     if (small._blocks[smallIndex] != 0)
                     {
                         int largeIndex = 0;
                         int resultIndex = resultStartIndex;
@@ -642,25 +626,20 @@
                 if ((maxResultLength > 0) && (result._blocks[maxResultLength - 1] == 0))
                 {
                     result._length--;
                 }
             }
             public static void Pow2(uint exponent, out BigInteger result)
             {
                 uint blocksToShift = DivRem32(exponent, out uint remainingBitsToShift);
                 result._length = (int)blocksToShift + 1;
                 Debug.Assert(unchecked((uint)result._length) <= MaxBlockCount);
-                if (unchecked((uint)result._length) > MaxBlockCount)
-                {
-                    SetZero(out result);
-                    return;
-                }
                 if (blocksToShift > 0)
                 {
                     result.Clear(blocksToShift);
                 }
                 result._blocks[blocksToShift] = 1U << (int)(remainingBitsToShift);
             }
             public static void Pow10(uint exponent, out BigInteger result)
             {
                 Debug.Assert((s_Pow10BigNumTableIndices[^1] + MaxBlockCount + 2) == s_Pow10BigNumTable.Length);
                 SetUInt32(out BigInteger temp1, s_Pow10UInt32Table[exponent & 0x7]);
@@ -758,26 +737,21 @@
                     return;
                 }
                 for (int index = 1; index < length; index++)
                 {
                     _blocks[index]++;
                     if (_blocks[index] > 0)
                     {
                         return;
                     }
                 }
-                Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
-                if (unchecked((uint)(length)) >= MaxBlockCount)
-                {
-                    SetZero(out this);
-                    return;
-                }
+                Debug.Assert(unchecked((uint)(length)) + 1 <= MaxBlockCount);
                 _blocks[length] = 1;
                 _length = length + 1;
             }
             public uint GetBlock(uint index)
             {
                 Debug.Assert(index < _length);
                 return _blocks[index];
             }
             public int GetLength()
             {
@@ -815,28 +789,23 @@
                 do
                 {
                     ulong block = (ulong)(_blocks[index]);
                     ulong product = (block << 3) + (block << 1) + carry;
                     carry = product >> 32;
                     _blocks[index] = (uint)(product);
                     index++;
                 } while (index < length);
                 if (carry != 0)
                 {
-                    Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
-                    if (unchecked((uint)(length)) >= MaxBlockCount)
-                    {
-                        SetZero(out this);
-                        return;
-                    }
+                    Debug.Assert(unchecked((uint)(_length)) + 1 <= MaxBlockCount);
                     _blocks[index] = (uint)carry;
-                    _length = length + 1;
+                    _length++;
                 }
             }
             public void MultiplyPow10(uint exponent)
             {
                 if (exponent <= 9)
                 {
                     Multiply(s_Pow10UInt32Table[exponent]);
                 }
                 else if (!IsZero())
                 {
@@ -884,44 +853,34 @@
                 int length = _length;
                 if ((length == 0) || (shift == 0))
                 {
                     return;
                 }
                 uint blocksToShift = DivRem32(shift, out uint remainingBitsToShift);
                 int readIndex = (length - 1);
                 int writeIndex = readIndex + (int)(blocksToShift);
                 if (remainingBitsToShift == 0)
                 {
-                    Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
-                    if (unchecked((uint)(length)) >= MaxBlockCount)
-                    {
-                        SetZero(out this);
-                        return;
-                    }
+                    Debug.Assert(writeIndex < MaxBlockCount);
                     while (readIndex >= 0)
                     {
                         _blocks[writeIndex] = _blocks[readIndex];
                         readIndex--;
                         writeIndex--;
                     }
                     _length += (int)(blocksToShift);
                     Clear(blocksToShift);
                 }
                 else
                 {
                     writeIndex++;
-                    Debug.Assert(unchecked((uint)(length)) < MaxBlockCount);
-                    if (unchecked((uint)(length)) >= MaxBlockCount)
-                    {
-                        SetZero(out this);
-                        return;
-                    }
+                    Debug.Assert(writeIndex < MaxBlockCount);
                     _length = writeIndex + 1;
                     uint lowBitsShift = (32 - remainingBitsToShift);
                     uint highBits = 0;
                     uint block = _blocks[readIndex];
                     uint lowBits = block >> (int)(lowBitsShift);
                     while (readIndex > 0)
                     {
                         _blocks[writeIndex] = highBits | lowBits;
                         highBits = block << (int)(remainingBitsToShift);
                         --readIndex;

--- a/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NFloat.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NFloat.cs
@@ -1,262 +1,29 @@
 using System.Diagnostics.CodeAnalysis;
-using System.Globalization;
 using System.Runtime.CompilerServices;
-using System.Runtime.InteropServices;
-using System.Runtime.Versioning;
-using Internal.Runtime.CompilerServices;
 #pragma warning disable SA1121 // We use our own aliases since they differ per platform
 #if TARGET_32BIT
 using NativeType = System.Single;
 #else
 using NativeType = System.Double;
 #endif
 namespace System.Runtime.InteropServices
 {
     [Intrinsic]
-    public readonly struct NFloat
-        : IComparable,
-          IComparable<NFloat>,
-          IEquatable<NFloat>,
-          ISpanFormattable
+    public readonly struct NFloat : IEquatable<NFloat>
     {
-        private const NumberStyles DefaultNumberStyles = NumberStyles.Float | NumberStyles.AllowThousands;
         private readonly NativeType _value;
-        [NonVersionable]
         public NFloat(float value)
         {
             _value = value;
         }
-        [NonVersionable]
         public NFloat(double value)
         {
             _value = (NativeType)value;
         }
-        public static NFloat Epsilon
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.Epsilon);
-        }
-        public static NFloat MaxValue
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.MaxValue);
-        }
-        public static NFloat MinValue
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.MinValue);
-        }
-        public static NFloat NaN
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.NaN);
-        }
-        public static NFloat NegativeInfinity
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.NegativeInfinity);
-        }
-        public static NFloat PositiveInfinity
-        {
-            [NonVersionable]
-            get => new NFloat(NativeType.PositiveInfinity);
-        }
-        public static int Size
-        {
-            [NonVersionable]
-            get => sizeof(NativeType);
-        }
-        public double Value
-        {
-            [NonVersionable]
-            get => _value;
-        }
-        [NonVersionable]
-        public static NFloat operator +(NFloat value) => value;
-        [NonVersionable]
-        public static NFloat operator -(NFloat value) => new NFloat(-value._value);
-        [NonVersionable]
-        public static NFloat operator ++(NFloat value) => new NFloat(value._value + 1);
-        [NonVersionable]
-        public static NFloat operator --(NFloat value) => new NFloat(value._value - 1);
-        [NonVersionable]
-        public static NFloat operator +(NFloat left, NFloat right) => new NFloat(left._value + right._value);
-        [NonVersionable]
-        public static NFloat operator -(NFloat left, NFloat right) => new NFloat(left._value - right._value);
-        [NonVersionable]
-        public static NFloat operator *(NFloat left, NFloat right) => new NFloat(left._value * right._value);
-        [NonVersionable]
-        public static NFloat operator /(NFloat left, NFloat right) => new NFloat(left._value / right._value);
-        [NonVersionable]
-        public static NFloat operator %(NFloat left, NFloat right) => new NFloat(left._value % right._value);
-        [NonVersionable]
-        public static bool operator ==(NFloat left, NFloat right) => left._value == right._value;
-        [NonVersionable]
-        public static bool operator !=(NFloat left, NFloat right) => left._value != right._value;
-        [NonVersionable]
-        public static bool operator <(NFloat left, NFloat right) => left._value < right._value;
-        [NonVersionable]
-        public static bool operator <=(NFloat left, NFloat right) => left._value <= right._value;
-        [NonVersionable]
-        public static bool operator >(NFloat left, NFloat right) => left._value > right._value;
-        [NonVersionable]
-        public static bool operator >=(NFloat left, NFloat right) => left._value >= right._value;
-        [NonVersionable]
-        public static explicit operator NFloat(decimal value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static explicit operator NFloat(double value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static explicit operator byte(NFloat value) => (byte)(value._value);
-        [NonVersionable]
-        public static explicit operator char(NFloat value) => (char)(value._value);
-        [NonVersionable]
-        public static explicit operator decimal(NFloat value) => (decimal)(value._value);
-        [NonVersionable]
-        public static explicit operator short(NFloat value) => (short)(value._value);
-        [NonVersionable]
-        public static explicit operator int(NFloat value) => (int)(value._value);
-        [NonVersionable]
-        public static explicit operator long(NFloat value) => (long)(value._value);
-        [NonVersionable]
-        public static explicit operator nint(NFloat value) => (nint)(value._value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static explicit operator sbyte(NFloat value) => (sbyte)(value._value);
-        [NonVersionable]
-        public static explicit operator float(NFloat value) => (float)(value._value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static explicit operator ushort(NFloat value) => (ushort)(value._value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static explicit operator uint(NFloat value) => (uint)(value._value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static explicit operator ulong(NFloat value) => (ulong)(value._value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static explicit operator nuint(NFloat value) => (nuint)(value._value);
-        [NonVersionable]
-        public static implicit operator NFloat(byte value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(char value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(short value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(int value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(long value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(nint value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static implicit operator NFloat(sbyte value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        public static implicit operator NFloat(float value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static implicit operator NFloat(ushort value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static implicit operator NFloat(uint value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static implicit operator NFloat(ulong value) => new NFloat((NativeType)value);
-        [NonVersionable]
-        [CLSCompliant(false)]
-        public static implicit operator NFloat(nuint value) => new NFloat((NativeType)value);
-        public static implicit operator double(NFloat value) => (double)(value._value);
-        [NonVersionable]
-        public static bool IsFinite(NFloat value) => NativeType.IsFinite(value._value);
-        [NonVersionable]
-        public static bool IsInfinity(NFloat value) => NativeType.IsInfinity(value._value);
-        [NonVersionable]
-        public static bool IsNaN(NFloat value) => NativeType.IsNaN(value._value);
-        [NonVersionable]
-        public static bool IsNegative(NFloat value) => NativeType.IsNegative(value._value);
-        [NonVersionable]
-        public static bool IsNegativeInfinity(NFloat value) => NativeType.IsNegativeInfinity(value._value);
-        [NonVersionable]
-        public static bool IsNormal(NFloat value) => NativeType.IsNormal(value._value);
-        [NonVersionable]
-        public static bool IsPositiveInfinity(NFloat value) => NativeType.IsPositiveInfinity(value._value);
-        [NonVersionable]
-        public static bool IsSubnormal(NFloat value) => NativeType.IsSubnormal(value._value);
-        public static NFloat Parse(string s)
-        {
-            var result = NativeType.Parse(s);
-            return new NFloat(result);
-        }
-        public static NFloat Parse(string s, NumberStyles style)
-        {
-            var result = NativeType.Parse(s, style);
-            return new NFloat(result);
-        }
-        public static NFloat Parse(string s, IFormatProvider? provider)
-        {
-            var result = NativeType.Parse(s, provider);
-            return new NFloat(result);
-        }
-        public static NFloat Parse(string s, NumberStyles style, IFormatProvider? provider)
-        {
-            var result = NativeType.Parse(s, style, provider);
-            return new NFloat(result);
-        }
-        public static NFloat Parse(ReadOnlySpan<char> s, NumberStyles style = DefaultNumberStyles, IFormatProvider? provider = null)
-        {
-            var result = NativeType.Parse(s, style, provider);
-            return new NFloat(result);
-        }
-        public static bool TryParse([NotNullWhen(true)] string? s, out NFloat result)
-        {
-            Unsafe.SkipInit(out result);
-            return NativeType.TryParse(s, out Unsafe.As<NFloat, NativeType>(ref result));
-        }
-        public static bool TryParse(ReadOnlySpan<char> s, out NFloat result)
-        {
-            Unsafe.SkipInit(out result);
-            return NativeType.TryParse(s, out Unsafe.As<NFloat, NativeType>(ref result));
-        }
-        public static bool TryParse([NotNullWhen(true)] string? s, NumberStyles style, IFormatProvider? provider, out NFloat result)
-        {
-            Unsafe.SkipInit(out result);
-            return NativeType.TryParse(s, style, provider, out Unsafe.As<NFloat, NativeType>(ref result));
-        }
-        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out NFloat result)
-        {
-            Unsafe.SkipInit(out result);
-            return NativeType.TryParse(s, style, provider, out Unsafe.As<NFloat, NativeType>(ref result));
-        }
-        public int CompareTo(object? obj)
-        {
-            if (obj is NFloat other)
-            {
-                if (_value < other._value) return -1;
-                if (_value > other._value) return 1;
-                if (_value == other._value) return 0;
-                if (NativeType.IsNaN(_value))
-                {
-                    return NativeType.IsNaN(other._value) ? 0 : -1;
-                }
-                else
-                {
-                    return 1;
-                }
-            }
-            else if (obj is null)
-            {
-                return 1;
-            }
-            throw new ArgumentException(SR.Arg_MustBeNFloat);
-        }
-        public int CompareTo(NFloat other) => _value.CompareTo(other._value);
-        public override bool Equals([NotNullWhen(true)] object? obj) => (obj is NFloat other) && Equals(other);
+        public double Value => _value;
+        public override bool Equals([NotNullWhen(true)] object? o) => o is NFloat other && Equals(other);
         public bool Equals(NFloat other) => _value.Equals(other._value);
         public override int GetHashCode() => _value.GetHashCode();
         public override string ToString() => _value.ToString();
-        public string ToString(string? format) => _value.ToString(format);
-        public string ToString(IFormatProvider? provider)=> _value.ToString(provider);
-        public string ToString(string? format, IFormatProvider? provider) => _value.ToString(format, provider);
-        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null) => _value.TryFormat(destination, out charsWritten, format, provider);
     }
 }

--- a/src/libraries/System.Private.CoreLib/src/System/TimeOnly.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/TimeOnly.cs
@@ -369,26 +369,28 @@
                         {
                             charsWritten = 0;
                             return false;
                         }
                         charsWritten = 8;
                         return true;
                     case 't':
                     case 'T':
                         return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
                     default:
-                        throw new FormatException(SR.Argument_BadFormatSpecifier);
+                        charsWritten = 0;
+                        return false;
                 }
             }
             if (!DateTimeFormat.IsValidCustomTimeFormat(format, throwOnError: false))
             {
-                throw new FormatException(SR.Format(SR.Format_DateTimeOnlyContainsNoneDateParts, format.ToString(), nameof(TimeOnly)));
+                charsWritten = 0;
+                return false;
             }
             return DateTimeFormat.TryFormat(ToDateTime(), destination, out charsWritten, format, provider);
         }
 #if FEATURE_GENERIC_MATH
         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <(TimeOnly left, TimeOnly right)
             => left < right;
         [RequiresPreviewFeatures(Number.PreviewFeatureMessage, Url = Number.PreviewFeatureUrl)]
         static bool IComparisonOperators<TimeOnly, TimeOnly>.operator <=(TimeOnly left, TimeOnly right)
             => left <= right;

--- a/src/libraries/System.Private.CoreLib/src/System/TimeZoneInfo.Unix.Android.cs
+++ b/src/libraries/System.Private.CoreLib/src/System/TimeZoneInfo.Unix.Android.cs
@@ -157,21 +157,20 @@
         *
         * Android 10+ moved the up-to-date tzdata location to a module updatable via the Google Play Store and the
         * database location changed (https://source.android.com/devices/architecture/modular-system/runtime#time-zone-data-interactions)
         * The older locations still exist (at least the `/system/usr/share/zoneinfo` one) but they won't be updated.
         */
         private sealed class AndroidTzData
         {
             private string[] _ids;
             private int[] _byteOffsets;
             private int[] _lengths;
-            private bool[] _isBackwards;
             private string _tzFileDir;
             private string _tzFilePath;
             private static string GetApexTimeDataRoot()
             {
                 string? ret = Environment.GetEnvironmentVariable("ANDROID_TZDATA_ROOT");
                 if (!string.IsNullOrEmpty(ret))
                 {
                     return ret;
                 }
                 return "/apex/com.android.tzdata";
@@ -187,124 +186,93 @@
             }
             public AndroidTzData()
             {
                 string[] tzFileDirList = new string[] {GetApexTimeDataRoot() + "/etc/tz/", // Android 10+, TimeData module where the updates land
                                                        GetApexRuntimeRoot() + "/etc/tz/", // Android 10+, Fallback location if the above isn't found or corrupted
                                                        Environment.GetEnvironmentVariable("ANDROID_DATA") + "/misc/zoneinfo/",
                                                        Environment.GetEnvironmentVariable("ANDROID_ROOT") + DefaultTimeZoneDirectory};
                 foreach (var tzFileDir in tzFileDirList)
                 {
                     string tzFilePath = Path.Combine(tzFileDir, TimeZoneFileName);
-                    if (LoadData(tzFileDir, tzFilePath))
+                    if (LoadData(tzFilePath))
                     {
                         _tzFileDir = tzFileDir;
                         _tzFilePath = tzFilePath;
                         return;
                     }
                 }
                 throw new TimeZoneNotFoundException(SR.TimeZoneNotFound_ValidTimeZoneFileMissing);
             }
-            private void FilterBackwardIDs(string tzFileDir, out HashSet<string> tzLookupIDs)
-            {
-                tzLookupIDs = new HashSet<string>();
-                try
-                {
-                    using (StreamReader sr = File.OpenText(Path.Combine(tzFileDir, "tzlookup.xml")))
-                    {
-                        string? tzLookupLine;
-                        while (sr.Peek() >= 0)
-                        {
-                            if (!(tzLookupLine = sr.ReadLine())!.AsSpan().TrimStart().StartsWith("<id", StringComparison.Ordinal))
-                                continue;
-                            int idStart = tzLookupLine!.IndexOf('>') + 1;
-                            int idLength = tzLookupLine.LastIndexOf("</", StringComparison.Ordinal) - idStart;
-                            if (idStart <= 0 || idLength < 0)
-                            {
-                                continue;
-                            }
-                            string id = tzLookupLine.Substring(idStart, idLength);
-                            tzLookupIDs.Add(id);
-                        }
-                    }
-                }
-                catch {}
-            }
             [MemberNotNullWhen(true, nameof(_ids))]
             [MemberNotNullWhen(true, nameof(_byteOffsets))]
             [MemberNotNullWhen(true, nameof(_lengths))]
-            [MemberNotNullWhen(true, nameof(_isBackwards))]
-            private bool LoadData(string tzFileDir, string path)
+            private bool LoadData(string path)
             {
                 if (!File.Exists(path))
                 {
                     return false;
                 }
                 try
                 {
                     using (FileStream fs = File.OpenRead(path))
                     {
-                        LoadTzFile(tzFileDir, fs);
+                        LoadTzFile(fs);
                     }
                     return true;
                 }
                 catch {}
                 return false;
             }
             [MemberNotNull(nameof(_ids))]
             [MemberNotNull(nameof(_byteOffsets))]
             [MemberNotNull(nameof(_lengths))]
-            [MemberNotNull(nameof(_isBackwards))]
-            private void LoadTzFile(string tzFileDir, Stream fs)
+            private void LoadTzFile(Stream fs)
             {
                 const int HeaderSize = 24;
                 Span<byte> buffer = stackalloc byte[HeaderSize];
                 ReadTzDataIntoBuffer(fs, 0, buffer);
                 LoadHeader(buffer, out int indexOffset, out int dataOffset);
-                ReadIndex(tzFileDir, fs, indexOffset, dataOffset);
+                ReadIndex(fs, indexOffset, dataOffset);
             }
             private void LoadHeader(Span<byte> buffer, out int indexOffset, out int dataOffset)
             {
                 var tz = (ushort)TZif_ToInt16(buffer.Slice(0, 2));
                 var data = (uint)TZif_ToInt32(buffer.Slice(2, 4));
                 if (tz != 0x747A || data != 0x64617461 || buffer[11] != 0)
                 {
                     var b = new StringBuilder(buffer.Length);
                     for (int i = 0; i < 12; ++i)
                     {
                         b.Append(' ').Append(HexConverter.ToCharLower(buffer[i]));
                     }
                     throw new InvalidOperationException(SR.Format(SR.InvalidOperation_BadTZHeader, TimeZoneFileName, b.ToString()));
                 }
                 indexOffset = TZif_ToInt32(buffer.Slice(12, 4));
                 dataOffset = TZif_ToInt32(buffer.Slice(16, 4));
             }
             [MemberNotNull(nameof(_ids))]
             [MemberNotNull(nameof(_byteOffsets))]
             [MemberNotNull(nameof(_lengths))]
-            [MemberNotNull(nameof(_isBackwards))]
-            private void ReadIndex(string tzFileDir, Stream fs, int indexOffset, int dataOffset)
+            private void ReadIndex(Stream fs, int indexOffset, int dataOffset)
             {
                 int indexSize = dataOffset - indexOffset;
                 const int entrySize = 52; // Data entry size
                 int entryCount = indexSize / entrySize;
                 _byteOffsets = new int[entryCount];
                 _ids = new string[entryCount];
                 _lengths = new int[entryCount];
-                _isBackwards = new bool[entryCount];
-                FilterBackwardIDs(tzFileDir, out HashSet<string> tzLookupIDs);
                 for (int i = 0; i < entryCount; ++i)
                 {
                     LoadEntryAt(fs, indexOffset + (entrySize*i), out string id, out int byteOffset, out int length);
                     _byteOffsets[i] = byteOffset + dataOffset;
                     _ids[i] = id;
                     _lengths[i] = length;
-                    _isBackwards[i] = !tzLookupIDs.Contains(id);
                     if (length < 24) // Header Size
                     {
                         throw new InvalidOperationException(SR.InvalidOperation_BadIndexLength);
                     }
                 }
             }
             private void ReadTzDataIntoBuffer(Stream fs, long position, Span<byte> buffer)
             {
                 fs.Position = position;
                 int bytesRead = 0;
@@ -333,39 +301,21 @@
                 while (entryBuffer[index] != 0 && index < 40)
                 {
                     index += 1;
                 }
                 id = Encoding.UTF8.GetString(entryBuffer.Slice(0, index));
                 byteOffset = TZif_ToInt32(entryBuffer.Slice(40, 4));
                 length = TZif_ToInt32(entryBuffer.Slice(44, 4));
             }
             public string[] GetTimeZoneIds()
             {
-                int numTimeZoneIDs = 0;
-                for (int i = 0; i < _ids.Length; i++)
-                {
-                    if (!_isBackwards[i])
-                    {
-                        numTimeZoneIDs++;
-                    }
-                }
-                string[] nonBackwardsTZIDs = new string[numTimeZoneIDs];
-                var index = 0;
-                for (int i = 0; i < _ids.Length; i++)
-                {
-                    if (!_isBackwards[i])
-                    {
-                        nonBackwardsTZIDs[index] = _ids[i];
-                        index++;
-                    }
-                }
-                return nonBackwardsTZIDs;
+                return _ids;
             }
             public string GetTimeZoneDirectory()
             {
                 return _tzFilePath;
             }
             public byte[] GetTimeZoneData(string id)
             {
                 int i = Array.BinarySearch(_ids, id, StringComparer.Ordinal);
                 if (i < 0)
                 {

--- a/src/libraries/System.Reflection.Metadata/src/System/Reflection/PortableExecutable/ManagedTextSection.cs
+++ b/src/libraries/System.Reflection.Metadata/src/System/Reflection/PortableExecutable/ManagedTextSection.cs
@@ -47,39 +47,30 @@
             sizeof(uint) + // import address table RVA
             20 +           // ?
             (Is32Bit ? 3 * sizeof(uint) : 2 * sizeof(ulong)) + // import lookup table
             sizeof(ushort) + // hint
             CorEntryPointName.Length +
             1;    // NUL
         private static int SizeOfNameTable =>
             CorEntryPointDll.Length + 1 + sizeof(ushort);
         private int SizeOfRuntimeStartupStub => Is32Bit ? 8 : 16;
         public const int MappedFieldDataAlignment = 8;
-        internal int CalculateOffsetToMappedFieldDataStreamUnaligned()
+        public int CalculateOffsetToMappedFieldDataStream()
         {
             int result = ComputeOffsetToImportTable();
             if (RequiresStartupStub)
             {
                 result += SizeOfImportTable + SizeOfNameTable;
                 result = BitArithmetic.Align(result, Is32Bit ? 4 : 8); //optional padding to make startup stub's target address align on word or double word boundary
                 result += SizeOfRuntimeStartupStub;
             }
             return result;
-        }
-        public int CalculateOffsetToMappedFieldDataStream()
-        {
-             int result = CalculateOffsetToMappedFieldDataStreamUnaligned();
-             if (MappedFieldDataSize != 0)
-             {
-                 result = BitArithmetic.Align(result, MappedFieldDataAlignment);
-             }
-             return result;
         }
         internal int ComputeOffsetToDebugDirectory()
         {
             Debug.Assert(MetadataSize % 4 == 0);
             Debug.Assert(ResourceDataSize % 4 == 0);
             return
                 ComputeOffsetToMetadata() +
                 MetadataSize +
                 ResourceDataSize +
                 StrongNameSignatureSize;
@@ -109,21 +100,21 @@
             return OffsetToILStream + BitArithmetic.Align(ILStreamSize, 4);
         }
         public int ComputeSizeOfTextSection()
         {
             Debug.Assert(MappedFieldDataSize % MappedFieldDataAlignment == 0);
             return CalculateOffsetToMappedFieldDataStream() + MappedFieldDataSize;
         }
         public int GetEntryPointAddress(int rva)
         {
             return RequiresStartupStub ?
-                rva + CalculateOffsetToMappedFieldDataStreamUnaligned() - (Is32Bit ? 6 : 10) :
+                rva + CalculateOffsetToMappedFieldDataStream() - (Is32Bit ? 6 : 10) :
                 0;
         }
         public DirectoryEntry GetImportAddressTableDirectoryEntry(int rva)
         {
             return RequiresStartupStub ?
                 new DirectoryEntry(rva, SizeOfImportAddressTable) :
                 default(DirectoryEntry);
         }
         public DirectoryEntry GetImportTableDirectoryEntry(int rva)
         {
@@ -177,22 +168,20 @@
                 builder.LinkSuffix(debugDataBuilderOpt);
             }
             if (RequiresStartupStub)
             {
                 WriteImportTable(builder, importTableRva, importAddressTableRva);
                 WriteNameTable(builder);
                 WriteRuntimeStartupStub(builder, importAddressTableRva, baseAddress);
             }
             if (mappedFieldDataBuilderOpt != null)
             {
-                if (mappedFieldDataBuilderOpt.Count != 0)
-                    builder.Align(MappedFieldDataAlignment);
                 builder.LinkSuffix(mappedFieldDataBuilderOpt);
             }
             Debug.Assert(builder.Count == ComputeSizeOfTextSection());
         }
         private void WriteImportAddressTable(BlobBuilder builder, int importTableRva)
         {
             int start = builder.Count;
             int ilRva = importTableRva + 40;
             int hintRva = ilRva + (Is32Bit ? 12 : 16);
             if (Is32Bit)

--- a/src/libraries/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
+++ b/src/libraries/System.Runtime.InteropServices/ref/System.Runtime.InteropServices.cs
@@ -144,28 +144,27 @@
     {
         None = 0,
         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
         AutoDispatch = 1,
         [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
         [System.ObsoleteAttribute("Support for IDispatch may be unavailable in future releases.")]
         AutoDual = 2,
     }
     [System.CLSCompliantAttribute(false)]
-    public readonly partial struct CLong : System.IEquatable<System.Runtime.InteropServices.CLong>
-    {
-        private readonly int _dummyPrimitive;
-        public CLong(int value) { throw null; }
-        public CLong(nint value) { throw null; }
+    public readonly struct CLong : IEquatable<CLong>
+    {
+        public CLong(int value) { }
+        public CLong(nint value) { }
         public nint Value { get { throw null; } }
         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
-        public bool Equals(System.Runtime.InteropServices.CLong other) { throw null; }
+        public bool Equals(CLong other) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
     }
     [System.AttributeUsageAttribute(System.AttributeTargets.Interface, Inherited=false)]
     public sealed partial class CoClassAttribute : System.Attribute
     {
         public CoClassAttribute(System.Type coClass) { }
         public System.Type CoClass { get { throw null; } }
     }
     public static partial class CollectionsMarshal
@@ -282,28 +281,27 @@
         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3) { }
         public ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3, System.Type sourceInterface4) { }
         public string Value { get { throw null; } }
     }
     [System.AttributeUsageAttribute(System.AttributeTargets.Method, Inherited=false)]
     public sealed partial class ComUnregisterFunctionAttribute : System.Attribute
     {
         public ComUnregisterFunctionAttribute() { }
     }
     [System.CLSCompliantAttribute(false)]
-    public readonly partial struct CULong : System.IEquatable<System.Runtime.InteropServices.CULong>
-    {
-        private readonly int _dummyPrimitive;
-        public CULong(uint value) { throw null; }
-        public CULong(nuint value) { throw null; }
+    public readonly struct CULong : IEquatable<CULong>
+    {
+        public CULong(uint value) { }
+        public CULong(nuint value) { }
         public nuint Value { get { throw null; } }
         public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
-        public bool Equals(System.Runtime.InteropServices.CULong other) { throw null; }
+        public bool Equals(CULong other) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
     }
     [System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Never)]
     [System.ObsoleteAttribute("CurrencyWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
     public sealed partial class CurrencyWrapper
     {
         public CurrencyWrapper(decimal obj) { }
         public CurrencyWrapper(object obj) { }
         public decimal WrappedObject { get { throw null; } }
@@ -771,123 +769,29 @@
         public static void* Alloc(nuint elementCount, nuint elementSize) { throw null; }
         [System.CLSCompliantAttribute(false)]
         public static void* AllocZeroed(nuint byteCount) { throw null; }
         [System.CLSCompliantAttribute(false)]
         public static void* AllocZeroed(nuint elementCount, nuint elementSize) { throw null; }
         [System.CLSCompliantAttribute(false)]
         public static void Free(void* ptr) { }
         [System.CLSCompliantAttribute(false)]
         public static void* Realloc(void* ptr, nuint byteCount) { throw null; }
     }
-    public readonly partial struct NFloat : System.IEquatable<System.Runtime.InteropServices.NFloat>
-#if FEATURE_NFLOAT
-#pragma warning disable SA1001
-        , System.IComparable,
-          System.IComparable<System.Runtime.InteropServices.NFloat>,
-          System.IFormattable,
-          System.ISpanFormattable
-#pragma warning restore SA1001
-#endif // FEATURE_NFLOAT
-    {
-        private readonly int _dummyPrimitive;
-        public NFloat(double value) { throw null; }
-        public NFloat(float value) { throw null; }
+    public readonly struct NFloat : IEquatable<NFloat>
+    {
+        public NFloat(float value) { }
+        public NFloat(double value) { }
         public double Value { get { throw null; } }
-        public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? obj) { throw null; }
-        public bool Equals(System.Runtime.InteropServices.NFloat other) { throw null; }
+        public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] object? o) { throw null; }
+        public bool Equals(NFloat other) { throw null; }
         public override int GetHashCode() { throw null; }
         public override string ToString() { throw null; }
-#if FEATURE_NFLOAT
-        public static System.Runtime.InteropServices.NFloat Epsilon { get { throw null; } }
-        public static System.Runtime.InteropServices.NFloat MaxValue { get { throw null; } }
-        public static System.Runtime.InteropServices.NFloat MinValue { get { throw null; } }
-        public static System.Runtime.InteropServices.NFloat NaN { get { throw null; } }
-        public static System.Runtime.InteropServices.NFloat NegativeInfinity { get { throw null; } }
-        public static System.Runtime.InteropServices.NFloat PositiveInfinity { get { throw null; } }
-        public static int Size { get { throw null; } }
-        public int CompareTo(object? obj) { throw null; }
-        public int CompareTo(System.Runtime.InteropServices.NFloat other) { throw null; }
-        public static bool IsFinite(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsNaN(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsNegative(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsNegativeInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsNormal(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsPositiveInfinity(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool IsSubnormal(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator +(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator --(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator /(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static bool operator ==(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static explicit operator System.Runtime.InteropServices.NFloat (decimal value) { throw null; }
-        public static explicit operator System.Runtime.InteropServices.NFloat (double value) { throw null; }
-        public static explicit operator byte (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator char (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator decimal (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator short (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator int (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator long (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator nint (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static explicit operator sbyte (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static explicit operator float (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static explicit operator ushort (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static explicit operator uint (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static explicit operator ulong (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static explicit operator nuint (System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool operator >(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static bool operator >=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (byte value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (char value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (short value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (int value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (long value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (nint value) { throw null; }
-        public static implicit operator double (System.Runtime.InteropServices.NFloat value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static implicit operator System.Runtime.InteropServices.NFloat (sbyte value) { throw null; }
-        public static implicit operator System.Runtime.InteropServices.NFloat (float value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static implicit operator System.Runtime.InteropServices.NFloat (ushort value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static implicit operator System.Runtime.InteropServices.NFloat (uint value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static implicit operator System.Runtime.InteropServices.NFloat (ulong value) { throw null; }
-        [System.CLSCompliantAttribute(false)]
-        public static implicit operator System.Runtime.InteropServices.NFloat (nuint value) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator ++(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static bool operator !=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static bool operator <(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static bool operator <=(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator %(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator *(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator -(System.Runtime.InteropServices.NFloat left, System.Runtime.InteropServices.NFloat right) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator -(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static System.Runtime.InteropServices.NFloat operator +(System.Runtime.InteropServices.NFloat value) { throw null; }
-        public static System.Runtime.InteropServices.NFloat Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite, System.IFormatProvider? provider = null) { throw null; }
-        public static System.Runtime.InteropServices.NFloat Parse(string s) { throw null; }
-        public static System.Runtime.InteropServices.NFloat Parse(string s, System.Globalization.NumberStyles style) { throw null; }
-        public static System.Runtime.InteropServices.NFloat Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider? provider) { throw null; }
-        public static System.Runtime.InteropServices.NFloat Parse(string s, System.IFormatProvider? provider) { throw null; }
-        public string ToString(System.IFormatProvider? provider) { throw null; }
-        public string ToString(string? format) { throw null; }
-        public string ToString(string? format, System.IFormatProvider? provider) { throw null; }
-        public bool TryFormat(System.Span<char> destination, out int charsWritten, System.ReadOnlySpan<char> format = default(System.ReadOnlySpan<char>), System.IFormatProvider? provider = null) { throw null; }
-        public static bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider? provider, out System.Runtime.InteropServices.NFloat result) { throw null; }
-        public static bool TryParse(System.ReadOnlySpan<char> s, out System.Runtime.InteropServices.NFloat result) { throw null; }
-        public static bool TryParse([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] string? s, System.Globalization.NumberStyles style, System.IFormatProvider? provider, out System.Runtime.InteropServices.NFloat result) { throw null; }
-        public static bool TryParse([System.Diagnostics.CodeAnalysis.NotNullWhenAttribute(true)] string? s, out System.Runtime.InteropServices.NFloat result) { throw null; }
-#endif // FEATURE_NFLOAT
     }
     [System.AttributeUsageAttribute(System.AttributeTargets.Parameter, Inherited=false)]
     public sealed partial class OptionalAttribute : System.Attribute
     {
         public OptionalAttribute() { }
     }
     public enum PosixSignal
     {
         [System.Runtime.Versioning.UnsupportedOSPlatformAttribute("windows")]
         SIGTSTP = -10,

--- a/src/mono/System.Private.CoreLib/src/System/Array.Mono.cs
+++ b/src/mono/System.Private.CoreLib/src/System/Array.Mono.cs
@@ -117,21 +117,20 @@
             if (dest_pos < 0)
                 throw new ArgumentOutOfRangeException(nameof(destinationIndex), "Index was less than the array's lower bound in the first dimension.");
             if (source_pos > sourceArray.Length - length)
                 throw new ArgumentException(SR.Arg_LongerThanSrcArray, nameof(sourceArray));
             if (dest_pos > destinationArray.Length - length)
             {
                 throw new ArgumentException("Destination array was not long enough. Check destIndex and length, and the array's lower bounds", nameof(destinationArray));
             }
             Type src_type = sourceArray.GetType().GetElementType()!;
             Type dst_type = destinationArray.GetType().GetElementType()!;
-            Type dst_elem_type = dst_type;
             bool dst_type_vt = dst_type.IsValueType && Nullable.GetUnderlyingType(dst_type) == null;
             bool src_is_enum = src_type.IsEnum;
             bool dst_is_enum = dst_type.IsEnum;
             if (src_is_enum)
                 src_type = Enum.GetUnderlyingType(src_type);
             if (dst_is_enum)
                 dst_type = Enum.GetUnderlyingType(dst_type);
             if (reliable)
             {
                 if (!dst_type.Equals(src_type) &&
@@ -145,22 +144,24 @@
                 if (!CanAssignArrayElement(src_type, dst_type))
                 {
                     throw new ArrayTypeMismatchException(SR.ArrayTypeMismatch_CantAssignType);
                 }
             }
             if (!ReferenceEquals(sourceArray, destinationArray) || source_pos > dest_pos)
             {
                 for (int i = 0; i < length; i++)
                 {
                     object srcval = sourceArray.GetValueImpl(source_pos + i);
-                    if (dst_type_vt && (srcval == null || (src_type == typeof(object) && !dst_elem_type.IsAssignableFrom (srcval.GetType()))))
+                    if (!src_type.IsValueType && dst_is_enum)
                         throw new InvalidCastException(SR.InvalidCast_DownCastArrayElement);
+                    if (dst_type_vt && (srcval == null || (src_type == typeof(object) && srcval.GetType() != dst_type)))
+                        throw new InvalidCastException();
                     try
                     {
                         destinationArray.SetValueRelaxedImpl(srcval, dest_pos + i);
                     }
                     catch (ArgumentException)
                     {
                         throw CreateArrayTypeMismatchException();
                     }
                 }
             }

--- a/src/mono/mono/component/debugger-agent.c
+++ b/src/mono/mono/component/debugger-agent.c
@@ -4619,22 +4619,21 @@
 				MonoDomain *d;
 				guint8 *vtype_buf;
 				int vtype_buf_size;
 				/* This can happen when round-tripping boxed vtypes */
 				/*
 				* Obtain vtype class.
 				* Same as the beginning of the handle_vtype case above.
 				*/
 				buf2 = buf;
 				is_enum = decode_byte (buf, &buf, limit);
-				if (CHECK_PROTOCOL_VERSION(2, 61))
-					decode_byte (buf, &buf, limit); //ignore is boxed
+				decode_byte (buf, &buf, limit); //ignore is boxed
 				klass = decode_typeid (buf, &buf, limit, &d, &err);
 				if (err != ERR_NONE)
 					return err;
 				/* Decode the vtype into a temporary buffer, then box it. */
 				vtype_buf_size = mono_class_value_size (klass, NULL);
 				vtype_buf = (guint8 *)g_malloc0 (vtype_buf_size);
 				g_assert (vtype_buf);
 				buf = buf2;
 				err = decode_vtype (NULL, domain, vtype_buf, buf, &buf, limit, check_field_datatype);
 				if (err != ERR_NONE) {

--- a/src/mono/mono/eventpipe/ep-rt-mono.c
+++ b/src/mono/mono/eventpipe/ep-rt-mono.c
@@ -2436,22 +2436,20 @@
 		module_data->module_native_path = "";
 		module_data->module_native_pdb_path = "";
 		module_data->module_native_pdb_age = 0;
 		module_data->reserved_flags = 0;
 		module_data->module_flags = MODULE_FLAGS_MANIFEST_MODULE;
 		if (image && image->dynamic)
 			module_data->module_flags |= MODULE_FLAGS_DYNAMIC_MODULE;
 		if (image && image->aot_module)
 			module_data->module_flags |= MODULE_FLAGS_NATIVE_MODULE;
 		module_data->module_il_path = image && image->filename ? image->filename : "";
-		module_data->module_il_pdb_path = "";
-		module_data->module_il_pdb_age = 0;
 		if (image && image->image_info) {
 			MonoPEDirEntry *debug_dir_entry = (MonoPEDirEntry *)&image->image_info->cli_header.datadir.pe_debug;
 			if (debug_dir_entry->size) {
 				ImageDebugDirectory debug_dir;
 				memset (&debug_dir, 0, sizeof (debug_dir));
 				uint32_t offset = mono_cli_rva_image_map (image, debug_dir_entry->rva);
 				for (uint32_t idx = 0; idx < debug_dir_entry->size / sizeof (ImageDebugDirectory); ++idx) {
 					uint8_t *data = (uint8_t *) ((ImageDebugDirectory *) (image->raw_data + offset) + idx);
 					debug_dir.major_version = read16 (data + 8);
 					debug_dir.minor_version = read16 (data + 10);
@@ -2473,21 +2471,20 @@
 	}
 	return true;
 }
 bool
 ep_rt_mono_write_event_module_load (MonoImage *image)
 {
 	if (!EventEnabledModuleLoad_V2 () && !EventEnabledDomainModuleLoad_V1 ())
 		return true;
 	if (image) {
 		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
 		if (get_module_event_data (image, &module_data)) {
 			FireEtwModuleLoad_V2 (
 				module_data.module_id,
 				module_data.assembly_id,
 				module_data.module_flags,
 				module_data.reserved_flags,
 				module_data.module_il_path,
 				module_data.module_native_path,
 				clr_instance_get_id (),
 				module_data.module_il_pdb_signature,
@@ -2513,21 +2510,20 @@
 	}
 	return true;
 }
 bool
 ep_rt_mono_write_event_module_unload (MonoImage *image)
 {
 	if (!EventEnabledModuleUnload_V2())
 		return true;
 	if (image) {
 		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
 		if (get_module_event_data (image, &module_data)) {
 			FireEtwModuleUnload_V2 (
 				module_data.module_id,
 				module_data.assembly_id,
 				module_data.module_flags,
 				module_data.reserved_flags,
 				module_data.module_il_path,
 				module_data.module_native_path,
 				clr_instance_get_id (),
 				module_data.module_il_pdb_signature,
@@ -2562,21 +2558,20 @@
 	}
 	return true;
 }
 bool
 ep_rt_mono_write_event_assembly_load (MonoAssembly *assembly)
 {
 	if (!EventEnabledAssemblyLoad_V1 ())
 		return true;
 	if (assembly) {
 		AssemblyEventData assembly_data;
-		memset (&assembly_data, 0, sizeof (assembly_data));
 		if (get_assembly_event_data (assembly, &assembly_data)) {
 			FireEtwAssemblyLoad_V1 (
 				assembly_data.assembly_id,
 				assembly_data.domain_id,
 				assembly_data.binding_id,
 				assembly_data.assembly_flags,
 				assembly_data.assembly_name,
 				clr_instance_get_id (),
 				NULL,
 				NULL);
@@ -2585,21 +2580,20 @@
 	}
 	return true;
 }
 bool
 ep_rt_mono_write_event_assembly_unload (MonoAssembly *assembly)
 {
 	if (!EventEnabledAssemblyUnload_V1 ())
 		return true;
 	if (assembly) {
 		AssemblyEventData assembly_data;
-		memset (&assembly_data, 0, sizeof (assembly_data));
 		if (get_assembly_event_data (assembly, &assembly_data)) {
 			FireEtwAssemblyUnload_V1 (
 				assembly_data.assembly_id,
 				assembly_data.domain_id,
 				assembly_data.binding_id,
 				assembly_data.assembly_flags,
 				assembly_data.assembly_name,
 				clr_instance_get_id (),
 				NULL,
 				NULL);
@@ -4513,21 +4507,20 @@
 	MonoProfiler *prof,
 	MonoImage *image)
 {
 	if (!EventEnabledMonoProfilerModuleLoaded ())
 		return;
 	uint64_t module_id = (uint64_t)image;
 	const ep_char8_t *module_path = NULL;
 	const ep_char8_t *module_guid = NULL;
 	if (image) {
 		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
 		if (get_module_event_data (image, &module_data))
 			module_path = (const ep_char8_t *)module_data.module_il_path;
 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
 	}
 	mono_profiler_fire_event_enter ();
 	FireEtwMonoProfilerModuleLoaded (
 		module_id,
 		module_path ? module_path : "",
 		module_guid ? module_guid : "",
 		NULL,
@@ -4555,21 +4548,20 @@
 	MonoProfiler *prof,
 	MonoImage *image)
 {
 	if (!EventEnabledMonoProfilerModuleUnloaded ())
 		return;
 	uint64_t module_id = (uint64_t)image;
 	const ep_char8_t *module_path = NULL;
 	const ep_char8_t *module_guid = NULL;
 	if (image) {
 		ModuleEventData module_data;
-		memset (&module_data, 0, sizeof (module_data));
 		if (get_module_event_data (image, &module_data))
 			module_path = (const ep_char8_t *)module_data.module_il_path;
 		module_guid = (const ep_char8_t *)mono_image_get_guid (image);
 	}
 	mono_profiler_fire_event_enter ();
 	FireEtwMonoProfilerModuleUnloaded (
 		module_id,
 		module_path ? module_path : "",
 		module_guid ? module_guid : "",
 		NULL,

--- a/src/mono/mono/mini/image-writer.c
+++ b/src/mono/mono/mini/image-writer.c
@@ -60,21 +60,21 @@
 #endif
 #endif
 #else
 #define AS_POINTER_DIRECTIVE ".long"
 #endif
 #if defined(TARGET_ASM_APPLE)
 #define AS_INT16_DIRECTIVE ".short"
 #elif defined(TARGET_ASM_GAS) && defined(TARGET_WIN32)
 #define AS_INT16_DIRECTIVE ".word"
 #elif defined(TARGET_ASM_GAS)
-#define AS_INT16_DIRECTIVE ".short"
+#define AS_INT16_DIRECTIVE ".hword"
 #else
 #define AS_INT16_DIRECTIVE ".word"
 #endif
 #if defined(TARGET_ASM_APPLE)
 #define AS_SKIP_DIRECTIVE ".space"
 #else
 #define AS_SKIP_DIRECTIVE ".skip"
 #endif
 #if defined(TARGET_ASM_APPLE)
 #define AS_GLOBAL_PREFIX "_"

--- a/src/mono/mono/mini/interp/interp.c
+++ b/src/mono/mono/mini/interp/interp.c
@@ -4326,21 +4326,21 @@
 		MINT_IN_CASE(MINT_CONV_U4_R4)
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
 			LOCAL_VAR (ip [1], gint32) = mono_rconv_u4 (LOCAL_VAR (ip [2], float));
 #else
 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], float);
 #endif
 			ip += 3;
 			MINT_IN_BREAK;
 		MINT_IN_CASE(MINT_CONV_U4_R8)
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
-			LOCAL_VAR (ip [1], gint32) = mono_fconv_u4 (LOCAL_VAR (ip [2], double));
+			LOCAL_VAR (ip [1], gint32) = mono_fconv_u4_2 (LOCAL_VAR (ip [2], double));
 #else
 			LOCAL_VAR (ip [1], gint32) = (guint32) LOCAL_VAR (ip [2], double);
 #endif
 			ip += 3;
 			MINT_IN_BREAK;
 		MINT_IN_CASE(MINT_CONV_I8_I4)
 			LOCAL_VAR (ip [1], gint64) = LOCAL_VAR (ip [2], gint32);
 			ip += 3;
 			MINT_IN_BREAK;
 		MINT_IN_CASE(MINT_CONV_I8_U4)
@@ -4382,21 +4382,21 @@
 		MINT_IN_CASE(MINT_CONV_U8_R4)
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
 			LOCAL_VAR (ip [1], gint64) = mono_rconv_u8 (LOCAL_VAR (ip [2], float));
 #else
 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], float);
 #endif
 			ip += 3;
 			MINT_IN_BREAK;
 		MINT_IN_CASE(MINT_CONV_U8_R8)
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
-			LOCAL_VAR (ip [1], gint64) = mono_fconv_u8 (LOCAL_VAR (ip [2], double));
+			LOCAL_VAR (ip [1], gint64) = mono_fconv_u8_2 (LOCAL_VAR (ip [2], double));
 #else
 			LOCAL_VAR (ip [1], gint64) = (guint64) LOCAL_VAR (ip [2], double);
 #endif
 			ip += 3;
 			MINT_IN_BREAK;
 		MINT_IN_CASE(MINT_CPOBJ) {
 			MonoClass* const c = (MonoClass*)frame->imethod->data_items[ip [3]];
 			g_assert (m_class_is_valuetype (c));
 			/* if this assertion fails, we need to add a write barrier */
 			g_assert (!MONO_TYPE_IS_REFERENCE (m_class_get_byval_arg (c)));

--- a/src/mono/mono/mini/interp/transform.c
+++ b/src/mono/mono/mini/interp/transform.c
@@ -1243,86 +1243,87 @@
 	default:
 		g_string_append_printf (str, "unknown arg type\n");
 	}
 	return g_string_free (str, FALSE);
 }
 static void
 dump_interp_compacted_ins (const guint16 *ip, const guint16 *start)
 {
 	int opcode = *ip;
 	int ins_offset = ip - start;
-	GString *str = g_string_new ("");
-	g_string_append_printf (str, "IR_%04x: %-14s", ins_offset, mono_interp_opname (opcode));
+	g_print ("IR_%04x: %-14s", ins_offset, mono_interp_opname (opcode));
 	ip++;
         if (mono_interp_op_dregs [opcode] > 0)
-                g_string_append_printf (str, " [%d <-", *ip++);
+                g_print (" [%d <-", *ip++);
         else
-                g_string_append_printf (str, " [nil <-");
+                g_print (" [nil <-");
         if (mono_interp_op_sregs [opcode] > 0) {
                 for (int i = 0; i < mono_interp_op_sregs [opcode]; i++)
-                        g_string_append_printf (str, " %d", *ip++);
-                g_string_append_printf (str, "],");
+                        g_print (" %d", *ip++);
+                g_print ("],");
         } else {
-                g_string_append_printf (str, " nil],");
+                g_print (" nil],");
         }
-	char *ins_data = dump_interp_ins_data (NULL, ins_offset, ip, opcode);
-	g_print ("%s%s\n", str->str, ins_data);
-	g_string_free (str, TRUE);
-	g_free (ins_data);
+	char *ins = dump_interp_ins_data (NULL, ins_offset, ip, opcode);
+	g_print ("%s\n", ins);
+	g_free (ins);
 }
 static void
 dump_interp_code (const guint16 *start, const guint16* end)
 {
 	const guint16 *p = start;
 	while (p < end) {
 		dump_interp_compacted_ins (p, start);
 		p = mono_interp_dis_mintop_len (p);
 	}
 }
 static void
-dump_interp_inst (InterpInst *ins)
+dump_interp_inst_no_newline (InterpInst *ins)
 {
 	int opcode = ins->opcode;
-	GString *str = g_string_new ("");
-	g_string_append_printf (str, "IL_%04x: %-14s", ins->il_offset, mono_interp_opname (opcode));
+	g_print ("IL_%04x: %-14s", ins->il_offset, mono_interp_opname (opcode));
 	if (mono_interp_op_dregs [opcode] > 0)
-		g_string_append_printf (str, " [%d <-", ins->dreg);
+		g_print (" [%d <-", ins->dreg);
 	else
-		g_string_append_printf (str, " [nil <-");
+		g_print (" [nil <-");
 	if (mono_interp_op_sregs [opcode] > 0) {
 		for (int i = 0; i < mono_interp_op_sregs [opcode]; i++) {
 			if (ins->sregs [i] == MINT_CALL_ARGS_SREG) {
-				g_string_append_printf (str, " c:");
+				g_print (" c:");
 				int *call_args = ins->info.call_args;
 				if (call_args) {
 					while (*call_args != -1) {
-						g_string_append_printf (str, " %d", *call_args);
+						g_print (" %d", *call_args);
 						call_args++;
 					}
 				}
 			} else {
-				g_string_append_printf (str, " %d", ins->sregs [i]);
-			}
-		}
-		g_string_append_printf (str, "],");
+				g_print (" %d", ins->sregs [i]);
+			}
+		}
+		g_print ("],");
 	} else {
-		g_string_append_printf (str, " nil],");
+		g_print (" nil],");
 	}
 	if (opcode == MINT_LDLOCA_S) {
-		g_string_append_printf (str, " %d", ins->sregs [0]);
+		g_print (" %d", ins->sregs [0]);
 	} else {
 		char *descr = dump_interp_ins_data (ins, ins->il_offset, &ins->data [0], ins->opcode);
-		g_string_append_printf (str, "%s", descr);
+		g_print ("%s", descr);
 		g_free (descr);
 	}
-	g_print ("%s\n", str->str);
-	g_string_free (str, TRUE);
+}
+static void
+dump_interp_inst (InterpInst *ins)
+{
+	dump_interp_inst_no_newline (ins);
+	g_print ("\n");
 }
 static G_GNUC_UNUSED void
 dump_interp_bb (InterpBasicBlock *bb)
 {
 	g_print ("BB%d:\n", bb->index);
 	for (InterpInst *ins = bb->first_ins; ins != NULL; ins = ins->next)
 		dump_interp_inst (ins);
 }
 /* For debug use */
 void
@@ -1355,20 +1356,32 @@
 interp_method_get_header (MonoMethod* method, MonoError *error)
 {
 	/* An explanation: mono_method_get_header_internal returns an error if
 	 * called on a method with no body (e.g. an abstract method, or an
 	 * icall).  We don't want that.
 	 */
 	if (mono_method_has_no_body (method))
 		return NULL;
 	else
 		return mono_method_get_header_internal (method, error);
+}
+/* stores top of stack as local and pushes address of it on stack */
+static void
+emit_store_value_as_local (TransformData *td, MonoType *src)
+{
+	int local = create_interp_local (td, mini_native_type_replace_type (src));
+	store_local (td, local);
+	interp_add_ins (td, MINT_LDLOCA_S);
+	push_simple_type (td, STACK_TYPE_MP);
+	interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
+	interp_ins_set_sreg (td->last_ins, local);
+	td->locals [local].indirects++;
 }
 static gboolean
 interp_ip_in_cbb (TransformData *td, int il_offset)
 {
 	InterpBasicBlock *bb = td->offset_to_bb [il_offset];
 	return bb == NULL || bb == td->cbb;
 }
 static gboolean
 interp_ins_is_ldc (InterpInst *ins)
 {
@@ -1635,45 +1648,48 @@
 		td->sp -= 2;
 		interp_ins_set_sregs2 (td->last_ins, td->sp [0].local, td->sp [1].local);
 		td->ip += 5;
 		return TRUE;
 	} else if (!strcmp ("op_Implicit", tm ) || !strcmp ("op_Explicit", tm)) {
 		MonoType *src = csignature->params [0];
 		MonoType *dst = csignature->ret;
 		MonoClass *src_klass = mono_class_from_mono_type_internal (src);
 		int src_size = mini_magic_type_size (NULL, src);
 		int dst_size = mini_magic_type_size (NULL, dst);
-		gboolean managed_fallback = FALSE;
+		gboolean store_value_as_local = FALSE;
 		switch (type_index) {
 		case 0: case 1:
 			if (!mini_magic_is_int_type (src) || !mini_magic_is_int_type (dst)) {
 				if (mini_magic_is_int_type (src))
-					managed_fallback = TRUE;
+					store_value_as_local = TRUE;
 				else if (mono_class_is_magic_float (src_klass))
-					managed_fallback = TRUE;
+					store_value_as_local = TRUE;
 				else
 					return FALSE;
 			}
 			break;
 		case 2:
 			if (!mini_magic_is_float_type (src) || !mini_magic_is_float_type (dst)) {
 				if (mini_magic_is_float_type (src))
-					managed_fallback = TRUE;
+					store_value_as_local = TRUE;
 				else if (mono_class_is_magic_int (src_klass))
-					managed_fallback = TRUE;
+					store_value_as_local = TRUE;
 				else
 					return FALSE;
 			}
 			break;
 		}
-		if (managed_fallback)
+		if (store_value_as_local) {
+			emit_store_value_as_local (td, src);
+			/* emit call to managed conversion method */
 			return FALSE;
+		}
 		if (src_size > dst_size) { // 8 -> 4
 			switch (type_index) {
 			case 0: case 1:
 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_I4, MINT_MOV_8);
 				break;
 			case 2:
 				interp_add_conv (td, td->sp - 1, NULL, STACK_TYPE_R4, MINT_CONV_R4_R8);
 				break;
 			}
 		}
@@ -1713,20 +1729,27 @@
 #else
 		interp_add_ins (td, MINT_SUB1_I4);
 #endif
 		td->sp--;
 		interp_ins_set_sreg (td->last_ins, td->sp [0].local);
 		push_type (td, stack_type [mt], magic_class);
 		interp_ins_set_dreg (td->last_ins, td->sp [-1].local);
 		td->ip += 5;
 		return TRUE;
 	} else if (!strcmp ("CompareTo", tm) || !strcmp ("Equals", tm)) {
+		MonoType *arg = csignature->params [0];
+		int mt = mint_type (arg);
+		/* on 'System.n*::{CompareTo,Equals} (System.n*)' variant we need to push managed
+		 * pointer instead of value */
+		if (mt != MINT_TYPE_O)
+			emit_store_value_as_local (td, arg);
+		/* emit call to managed conversion method */
 		return FALSE;
 	} else if (!strcmp (".cctor", tm)) {
 		return FALSE;
 	} else if (!strcmp ("Parse", tm)) {
 		return FALSE;
 	} else if (!strcmp ("ToString", tm)) {
 		return FALSE;
 	} else if (!strcmp ("GetHashCode", tm)) {
 		return FALSE;
 	} else if (!strcmp ("IsNaN", tm) || !strcmp ("IsInfinity", tm) || !strcmp ("IsNegativeInfinity", tm) || !strcmp ("IsPositiveInfinity", tm)) {
@@ -2467,20 +2490,22 @@
 		if (!is_ok (error)) {
 			mono_interp_error_cleanup (error);
 			return FALSE;
 		}
 		if (!vtable->initialized)
 			return FALSE;
 	}
 	/* We currently access at runtime the wrapper data */
 	if (method->wrapper_type != MONO_WRAPPER_NONE)
 		return FALSE;
+	/* Our usage of `emit_store_value_as_local ()` for nint, nuint and nfloat
+	 * is kinda hacky, and doesn't work with the inliner */
 	if (mono_class_get_magic_index (method->klass) >= 0)
 		return FALSE;
 	if (td->prof_coverage)
 		return FALSE;
 	if (!is_metadata_update_disabled () && mono_metadata_update_no_inline (td->method, method))
 		return FALSE;
 	if (g_list_find (td->dont_inline, method))
 		return FALSE;
 	return TRUE;
 }
@@ -3823,22 +3848,20 @@
 	gboolean link_bblocks = TRUE;
 	gboolean inlining = td->method != method;
 	InterpBasicBlock *exit_bb = NULL;
 	original_bb = bb = mono_basic_block_split (method, error, header);
 	goto_if_nok (error, exit);
 	g_assert (bb);
 	td->il_code = header->code;
 	td->in_start = td->ip = header->code;
 	end = td->ip + header->code_size;
 	td->cbb = td->entry_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
-	if (td->gen_sdb_seq_points)
-		td->basic_blocks = g_list_prepend_mempool (td->mempool, td->basic_blocks, td->cbb);
 	td->cbb->index = td->bb_count++;
 	td->cbb->native_offset = -1;
 	td->cbb->stack_height = td->sp - td->stack;
 	if (inlining) {
 		exit_bb = (InterpBasicBlock*)mono_mempool_alloc0 (td->mempool, sizeof (InterpBasicBlock));
 		exit_bb->index = td->bb_count++;
 		exit_bb->native_offset = -1;
 		exit_bb->stack_height = -1;
 	}
 	get_basic_blocks (td, header, td->gen_sdb_seq_points);
@@ -5323,21 +5346,20 @@
 			MonoClass *field_klass = mono_class_from_mono_type_internal (ftype);
 			mt = mint_type (m_class_get_byval_arg (field_klass));
 			int field_size = mono_class_value_size (field_klass, NULL);
 			int obj_size = mono_class_value_size (klass, NULL);
 			obj_size = ALIGN_TO (obj_size, MINT_VT_ALIGNMENT);
 			{
 				if (is_static) {
 					td->sp--;
 					interp_emit_sfld_access (td, field, field_klass, mt, TRUE, error);
 					goto_if_nok (error, exit);
-				} else if (td->sp [-1].type != STACK_TYPE_O && td->sp [-1].type != STACK_TYPE_MP && (mono_class_is_magic_int (klass) || mono_class_is_magic_float (klass))) {
 				} else if (td->sp [-1].type == STACK_TYPE_VT) {
 					int size = 0;
 					/* First we pop the vt object from the stack. Then we push the field */
 #ifdef NO_UNALIGNED_ACCESS
 					if (field->offset % SIZEOF_VOID_P != 0) {
 						if (mt == MINT_TYPE_I8 || mt == MINT_TYPE_R8)
 							size = 8;
 					}
 #endif
 					interp_add_ins (td, MINT_MOV_OFF);

--- a/src/mono/mono/mini/intrinsics.c
+++ b/src/mono/mono/mini/intrinsics.c
@@ -1587,28 +1587,26 @@
 		MONO_ADD_INS (cfg->cbb, ins);
 		return ins;
 	} else if (cmethod->klass == mono_defaults.systemtype_class && !strcmp (cmethod->name, "op_Inequality") &&
 			args [0]->klass == mono_defaults.runtimetype_class && args [1]->klass == mono_defaults.runtimetype_class) {
 		EMIT_NEW_BIALU (cfg, ins, OP_COMPARE, -1, args [0]->dreg, args [1]->dreg);
 		MONO_INST_NEW (cfg, ins, OP_ICNEQ);
 		ins->dreg = alloc_preg (cfg);
 		ins->type = STACK_I4;
 		MONO_ADD_INS (cfg->cbb, ins);
 		return ins;
-	} else if (((!strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.iOS") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.TVOS") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.MacCatalyst") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.Mac") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.iOS") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.tvOS") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.MacCatalyst") ||
-				 !strcmp (cmethod_klass_image->assembly->aname.name, "Microsoft.macOS")) &&
+	} else if (((!strcmp (cmethod_klass_image->assembly->aname.name, "MonoMac") ||
+	            !strcmp (cmethod_klass_image->assembly->aname.name, "monotouch")) &&
+				!strcmp (cmethod_klass_name_space, "XamCore.ObjCRuntime") &&
+				!strcmp (cmethod_klass_name, "Selector")) ||
+			   ((!strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.iOS") ||
+				 !strcmp (cmethod_klass_image->assembly->aname.name, "Xamarin.Mac")) &&
 				!strcmp (cmethod_klass_name_space, "ObjCRuntime") &&
 				!strcmp (cmethod_klass_name, "Selector"))
 			   ) {
 		if ((cfg->backend->have_objc_get_selector || cfg->compile_llvm) &&
 			!strcmp (cmethod->name, "GetHandle") && fsig->param_count == 1 &&
 		    (args [0]->opcode == OP_GOT_ENTRY || args [0]->opcode == OP_AOTCONST) &&
 		    cfg->compile_aot) {
 			MonoInst *pi;
 			MonoJumpInfoToken *ji;
 			char *s;

--- a/src/mono/mono/mini/jit-icalls.c
+++ b/src/mono/mono/mini/jit-icalls.c
@@ -717,37 +717,42 @@
 	MonoGenericContext *generic_context;
 	if (sig->is_inflated) {
 		generic_context = mono_method_get_context (method);
 	} else {
 		MonoGenericContainer *generic_container = mono_method_get_generic_container (method);
 		g_assert (generic_container);
 		generic_context = &generic_container->context;
 	}
 	return mono_ldtoken_wrapper (image, token, generic_context);
 }
-#ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
 guint64
 mono_fconv_u8 (double v)
 {
 #if defined(TARGET_X86) || defined(TARGET_AMD64)
 	const double two63 = 2147483648.0 * 4294967296.0;
 	if (v < two63) {
 		return (gint64)v;
 	} else {
 		return (gint64)(v - two63) + ((guint64)1 << 63);
 	}
 #else
 	if (mono_isinf (v) || mono_isnan (v))
 		return 0;
 	return (guint64)v;
 #endif
 }
+#ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
+guint64
+mono_fconv_u8_2 (double v)
+{
+	return mono_fconv_u8 (v);
+}
 guint64
 mono_rconv_u8 (float v)
 {
 #if defined(TARGET_X86) || defined(TARGET_AMD64)
 	const float two63 = 2147483648.0 * 4294967296.0;
 	if (v < two63) {
 		return (gint64)v;
 	} else {
 		return (gint64)(v - two63) + ((guint64)1 << 63);
 	}
@@ -758,28 +763,33 @@
 #endif
 }
 #endif
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
 gint64
 mono_fconv_i8 (double v)
 {
 	return (gint64)v;
 }
 #endif
+guint32
+mono_fconv_u4 (double v)
+{
+	/* MS.NET behaves like this for some reason */
+	if (mono_isinf (v) || mono_isnan (v))
+		return 0;
+	return (guint32)v;
+}
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
 guint32
-mono_fconv_u4 (double v)
-{
-	/* MS.NET behaves like this for some reason */
-	if (mono_isinf (v) || mono_isnan (v))
-		return 0;
-	return (guint32)v;
+mono_fconv_u4_2 (double v)
+{
+	return mono_fconv_u4 (v);
 }
 guint32
 mono_rconv_u4 (float v)
 {
 	if (mono_isinf (v) || mono_isnan (v))
 		return 0;
 	return (guint32) v;
 }
 #endif
 gint64

--- a/src/mono/mono/mini/jit-icalls.h
+++ b/src/mono/mono/mini/jit-icalls.h
@@ -31,23 +31,25 @@
 ICALL_EXPORT MonoArray *mono_array_new_n_icall (MonoMethod *cm, gint32 param_count, intptr_t *params);
 ICALL_EXPORT MonoArray *mono_array_new_2_jagged (MonoMethod *cm, guint32 length1, guint32 length2);
 ICALL_EXPORT MonoArray *mono_array_new_1 (MonoMethod *cm, guint32 length);
 ICALL_EXPORT MonoArray *mono_array_new_2 (MonoMethod *cm, guint32 length1, guint32 length2);
 ICALL_EXPORT MonoArray *mono_array_new_3 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3);
 ICALL_EXPORT MonoArray *mono_array_new_4 (MonoMethod *cm, guint32 length1, guint32 length2, guint32 length3, guint32 length4);
 ICALL_EXPORT gpointer mono_class_static_field_address (MonoClassField *field);
 ICALL_EXPORT gpointer mono_ldtoken_wrapper (MonoImage *image, int token, MonoGenericContext *context);
 ICALL_EXPORT gpointer mono_ldtoken_wrapper_generic_shared (MonoImage *image, int token, MonoMethod *method);
 ICALL_EXPORT guint64 mono_fconv_u8 (double v);
+ICALL_EXPORT guint64 mono_fconv_u8_2 (double v);
 ICALL_EXPORT guint64 mono_rconv_u8 (float v);
 ICALL_EXPORT gint64 mono_fconv_i8 (double v);
 ICALL_EXPORT guint32 mono_fconv_u4 (double v);
+ICALL_EXPORT guint32 mono_fconv_u4_2 (double v);
 ICALL_EXPORT guint32 mono_rconv_u4 (float v);
 ICALL_EXPORT gint64 mono_fconv_ovf_i8 (double v);
 ICALL_EXPORT guint64 mono_fconv_ovf_u8 (double v);
 ICALL_EXPORT gint64 mono_rconv_i8 (float v);
 ICALL_EXPORT gint64 mono_rconv_ovf_i8 (float v);
 ICALL_EXPORT guint64 mono_rconv_ovf_u8 (float v);
 ICALL_EXPORT double mono_lconv_to_r8 (gint64 a);
 ICALL_EXPORT double mono_conv_to_r8 (gint32 a);
 ICALL_EXPORT double mono_conv_to_r4 (gint32 a);
 ICALL_EXPORT float mono_lconv_to_r4 (gint64 a);

--- a/src/mono/mono/mini/method-to-ir.c
+++ b/src/mono/mono/mini/method-to-ir.c
@@ -1026,24 +1026,21 @@
 #if TARGET_SIZEOF_VOID_P == 8
 			ins->opcode = OP_LCONV_TO_U;
 #else
 			ins->opcode = OP_MOVE;
 #endif
 			break;
 		case STACK_I8:
 			ins->opcode = OP_LCONV_TO_U;
 			break;
 		case STACK_R8:
-			if (TARGET_SIZEOF_VOID_P == 8)
-				ins->opcode = OP_FCONV_TO_U8;
-			else
-				ins->opcode = OP_FCONV_TO_U4;
+			ins->opcode = OP_FCONV_TO_U;
 			break;
 		case STACK_R4:
 			if (TARGET_SIZEOF_VOID_P == 8)
 				ins->opcode = OP_RCONV_TO_U8;
 			else
 				ins->opcode = OP_RCONV_TO_U4;
 			break;
 		}
 		break;
 	case MONO_CEE_CONV_I8:

--- a/src/mono/mono/mini/mini-arm.c
+++ b/src/mono/mono/mini/mini-arm.c
@@ -5087,20 +5087,21 @@
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
 			break;
 		case OP_FCONV_TO_U2:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
 			break;
 		case OP_FCONV_TO_I4:
 		case OP_FCONV_TO_I:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
 			break;
 		case OP_FCONV_TO_U4:
+		case OP_FCONV_TO_U:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
 			break;
 		case OP_FCONV_TO_I8:
 		case OP_FCONV_TO_U8:
 			g_assert_not_reached ();
 			/* Implemented as helper calls */
 			break;
 		case OP_LCONV_TO_R_UN:
 			g_assert_not_reached ();
 			/* Implemented as helper calls */

--- a/src/mono/mono/mini/mini-llvm.c
+++ b/src/mono/mono/mini/mini-llvm.c
@@ -881,20 +881,21 @@
 	case OP_RCONV_TO_I2:
 	case OP_RCONV_TO_U2:
 		return LLVMInt16Type ();
 	case OP_FCONV_TO_U4:
 	case OP_RCONV_TO_U4:
 		return LLVMInt32Type ();
 	case OP_FCONV_TO_U8:
 	case OP_RCONV_TO_U8:
 		return LLVMInt64Type ();
 	case OP_FCONV_TO_I:
+	case OP_FCONV_TO_U:
 		return TARGET_SIZEOF_VOID_P == 8 ? LLVMInt64Type () : LLVMInt32Type ();
 	case OP_IADD_OVF:
 	case OP_IADD_OVF_UN:
 	case OP_ISUB_OVF:
 	case OP_ISUB_OVF_UN:
 	case OP_IMUL_OVF:
 	case OP_IMUL_OVF_UN:
 		return LLVMInt32Type ();
 	case OP_LADD_OVF:
 	case OP_LADD_OVF_UN:

--- a/src/mono/mono/mini/mini-mips.c
+++ b/src/mono/mono/mini/mini-mips.c
@@ -3839,20 +3839,21 @@
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
 			break;
 		case OP_FCONV_TO_U2:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
 			break;
 		case OP_FCONV_TO_I4:
 		case OP_FCONV_TO_I:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
 			break;
 		case OP_FCONV_TO_U4:
+		case OP_FCONV_TO_U:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
 			break;
 		case OP_SQRT:
 			mips_fsqrtd (code, ins->dreg, ins->sreg1);
 			break;
 		case OP_FADD:
 			mips_faddd (code, ins->dreg, ins->sreg1, ins->sreg2);
 			break;
 		case OP_FSUB:
 			mips_fsubd (code, ins->dreg, ins->sreg1, ins->sreg2);

--- a/src/mono/mono/mini/mini-native-types.c
+++ b/src/mono/mono/mini/mini-native-types.c
@@ -305,28 +305,20 @@
 	if (!aname)
 		return FALSE;
 	if (!strcmp ("Xamarin.iOS", aname))
 		return TRUE;
 	if (!strcmp ("Xamarin.Mac", aname))
 		return TRUE;
 	if (!strcmp ("Xamarin.WatchOS", aname))
 		return TRUE;
 	if (!strcmp ("Xamarin.MacCatalyst", aname))
 		return TRUE;
-	if (!strcmp ("Microsoft.iOS", aname))
-		return TRUE;
-	if (!strcmp ("Microsoft.macOS", aname))
-		return TRUE;
-	if (!strcmp ("Microsoft.watchOS", aname))
-		return TRUE;
-	if (!strcmp ("Microsoft.MacCatalyst", aname))
-		return TRUE;
 	/* regression test suite */
 	if (!strcmp ("builtin-types", aname))
 		return TRUE;
 	if (!strcmp ("mini_tests", aname))
 		return TRUE;
 	return FALSE;
 }
 gboolean
 mono_class_is_magic_int (MonoClass *klass)
 {

--- a/src/mono/mono/mini/mini-ops.h
+++ b/src/mono/mono/mini/mini-ops.h
@@ -518,20 +518,21 @@
 MINI_OP(OP_FCLT,   "float_clt", IREG, FREG, FREG)
 MINI_OP(OP_FCLT_UN,"float_clt_un", IREG, FREG, FREG)
 MINI_OP(OP_FCNEQ,  "float_cneq", IREG, FREG, FREG)
 MINI_OP(OP_FCGE,   "float_cge", IREG, FREG, FREG)
 MINI_OP(OP_FCLE,   "float_cle", IREG, FREG, FREG)
 MINI_OP(OP_FCEQ_MEMBASE,   "float_ceq_membase", IREG, FREG, IREG)
 MINI_OP(OP_FCGT_MEMBASE,   "float_cgt_membase", IREG, FREG, IREG)
 MINI_OP(OP_FCGT_UN_MEMBASE,"float_cgt_un_membase", IREG, FREG, IREG)
 MINI_OP(OP_FCLT_MEMBASE,   "float_clt_membase", IREG, FREG, IREG)
 MINI_OP(OP_FCLT_UN_MEMBASE,"float_clt_un_membase", IREG, FREG, IREG)
+MINI_OP(OP_FCONV_TO_U,	"float_conv_to_u", IREG, FREG, NONE)
 MINI_OP(OP_CKFINITE, "ckfinite", FREG, FREG, NONE)
 /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
 MINI_OP(OP_RCONV_TO_U2,   "r4_conv_to_u2", IREG, FREG, NONE)
 MINI_OP(OP_RCONV_TO_U1,   "r4_conv_to_u1", IREG, FREG, NONE)
 MINI_OP(OP_RCONV_TO_I,    "r4_conv_to_i", IREG, FREG, NONE)
 MINI_OP(OP_RCONV_TO_OVF_I,"r4_conv_to_ovf_i", IREG, FREG, NONE)
 MINI_OP(OP_RCONV_TO_OVF_U,"r4_conv_to_ovd_u", IREG, FREG, NONE)
 /* r4 opcodes: must be in the same order as the matching CEE_ opcodes: ovfops_op_map */
 MINI_OP(OP_RADD_OVF,      "r4_add_ovf", FREG, FREG, FREG)
 MINI_OP(OP_RADD_OVF_UN,   "r4_add_ovf_un", FREG, FREG, FREG)

--- a/src/mono/mono/mini/mini-ppc.c
+++ b/src/mono/mono/mini/mini-ppc.c
@@ -3812,20 +3812,21 @@
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, TRUE);
 			break;
 		case OP_FCONV_TO_U2:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
 			break;
 		case OP_FCONV_TO_I4:
 		case OP_FCONV_TO_I:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, TRUE);
 			break;
 		case OP_FCONV_TO_U4:
+		case OP_FCONV_TO_U:
 			code = emit_float_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
 			break;
 		case OP_LCONV_TO_R_UN:
 			g_assert_not_reached ();
 			/* Implemented as helper calls */
 			break;
 		case OP_LCONV_TO_OVF_I4_2:
 		case OP_LCONV_TO_OVF_I: {
 #ifdef __mono_ppc64__
 			NOT_IMPLEMENTED;

--- a/src/mono/mono/mini/mini-runtime.c
+++ b/src/mono/mono/mini/mini-runtime.c
@@ -3982,25 +3982,25 @@
 	register_opcode_emulation (OP_IMUL, __emul_op_imul, mono_icall_sig_int32_int32_int32, mono_imul, TRUE);
 #endif
 #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_EMULATE_MUL_OVF)
 	register_opcode_emulation (OP_IMUL_OVF, __emul_op_imul_ovf, mono_icall_sig_int32_int32_int32, mono_imul_ovf, FALSE);
 	register_opcode_emulation (OP_IMUL_OVF_UN, __emul_op_imul_ovf_un, mono_icall_sig_int32_int32_int32, mono_imul_ovf_un, FALSE);
 #endif
 #if defined(MONO_ARCH_EMULATE_MUL_DIV) || defined(MONO_ARCH_SOFT_FLOAT_FALLBACK)
 	register_opcode_emulation (OP_FDIV, __emul_fdiv, mono_icall_sig_double_double_double, mono_fdiv, FALSE);
 #endif
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U8
-	register_opcode_emulation (OP_FCONV_TO_U8, __emul_fconv_to_u8, mono_icall_sig_ulong_double, mono_fconv_u8, FALSE);
+	register_opcode_emulation (OP_FCONV_TO_U8, __emul_fconv_to_u8, mono_icall_sig_ulong_double, mono_fconv_u8_2, FALSE);
 	register_opcode_emulation (OP_RCONV_TO_U8, __emul_rconv_to_u8, mono_icall_sig_ulong_float, mono_rconv_u8, FALSE);
 #endif
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_U4
-	register_opcode_emulation (OP_FCONV_TO_U4, __emul_fconv_to_u4, mono_icall_sig_uint32_double, mono_fconv_u4, FALSE);
+	register_opcode_emulation (OP_FCONV_TO_U4, __emul_fconv_to_u4, mono_icall_sig_uint32_double, mono_fconv_u4_2, FALSE);
 	register_opcode_emulation (OP_RCONV_TO_U4, __emul_rconv_to_u4, mono_icall_sig_uint32_float, mono_rconv_u4, FALSE);
 #endif
 	register_opcode_emulation (OP_FCONV_TO_OVF_I8, __emul_fconv_to_ovf_i8, mono_icall_sig_long_double, mono_fconv_ovf_i8, FALSE);
 	register_opcode_emulation (OP_FCONV_TO_OVF_U8, __emul_fconv_to_ovf_u8, mono_icall_sig_ulong_double, mono_fconv_ovf_u8, FALSE);
 	register_opcode_emulation (OP_RCONV_TO_OVF_I8, __emul_rconv_to_ovf_i8, mono_icall_sig_long_float, mono_rconv_ovf_i8, FALSE);
 	register_opcode_emulation (OP_RCONV_TO_OVF_U8, __emul_rconv_to_ovf_u8, mono_icall_sig_ulong_float, mono_rconv_ovf_u8, FALSE);
 #ifdef MONO_ARCH_EMULATE_FCONV_TO_I8
 	register_opcode_emulation (OP_FCONV_TO_I8, __emul_fconv_to_i8, mono_icall_sig_long_double, mono_fconv_i8, FALSE);
 	register_opcode_emulation (OP_RCONV_TO_I8, __emul_rconv_to_i8, mono_icall_sig_long_float, mono_rconv_i8, FALSE);
 #endif
@@ -4054,20 +4054,25 @@
 		register_opcode_emulation (OP_FCLT_UN, __emul_fcmp_clt_un, mono_icall_sig_uint32_double_double, mono_fclt_un, FALSE);
 		register_icall (mono_fload_r4, mono_icall_sig_double_ptr, FALSE);
 		register_icall (mono_fstore_r4, mono_icall_sig_void_double_ptr, FALSE);
 		register_icall (mono_fload_r4_arg, mono_icall_sig_uint32_double, FALSE);
 		register_icall (mono_isfinite_double, mono_icall_sig_int32_double, FALSE);
 	}
 #endif
 	register_icall (mono_ckfinite, mono_icall_sig_double_double, FALSE);
 #ifdef COMPRESSED_INTERFACE_BITMAP
 	register_icall (mono_class_interface_match, mono_icall_sig_uint32_ptr_int32, TRUE);
+#endif
+#if SIZEOF_REGISTER == 4
+	register_opcode_emulation (OP_FCONV_TO_U, __emul_fconv_to_u, mono_icall_sig_uint32_double, mono_fconv_u4, TRUE);
+#else
+	register_opcode_emulation (OP_FCONV_TO_U, __emul_fconv_to_u, mono_icall_sig_ulong_double, mono_fconv_u8, TRUE);
 #endif
 	/* other jit icalls */
 	register_icall (ves_icall_mono_delegate_ctor, mono_icall_sig_void_object_object_ptr, FALSE);
 	register_icall (ves_icall_mono_delegate_ctor_interp, mono_icall_sig_void_object_object_ptr, FALSE);
 	register_icall (mono_class_static_field_address,
 				 mono_icall_sig_ptr_ptr, FALSE);
 	register_icall (mono_ldtoken_wrapper, mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
 	register_icall (mono_ldtoken_wrapper_generic_shared,
 		mono_icall_sig_ptr_ptr_ptr_ptr, FALSE);
 	register_icall (mono_get_special_static_data, mono_icall_sig_ptr_int, FALSE);

--- a/src/mono/mono/mini/mini-s390x.c
+++ b/src/mono/mono/mini/mini-s390x.c
@@ -3938,20 +3938,21 @@
 				s390_ngr    (code, ins->dreg, s390_r0);
 			} else {
 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 2, FALSE);
 			}
 			break;
 		case OP_FCONV_TO_I4:
 		case OP_FCONV_TO_I:
 			s390_cfdbr (code, ins->dreg, 5, ins->sreg1);
 			break;
 		case OP_FCONV_TO_U4:
+		case OP_FCONV_TO_U:
 			if (mono_hwcap_s390x_has_fpe) {
 				s390_clgdbr (code, ins->dreg, 5, ins->sreg1, 0);
 			} else {
 				code = emit_double_to_int (cfg, code, ins->dreg, ins->sreg1, 4, FALSE);
 			}
 			break;
 		case OP_FCONV_TO_I8:
 			s390_cgdbr (code, ins->dreg, 5, ins->sreg1);
 			break;
 		case OP_FCONV_TO_U8:

--- a/src/mono/mono/mini/mini-sparc.c
+++ b/src/mono/mono/mini/mini-sparc.c
@@ -3070,20 +3070,21 @@
 			sparc_fitod (code, FP_SCRATCH_REG, ins->dreg);
 #endif
 			break;
 		}
 		case OP_FCONV_TO_I1:
 		case OP_FCONV_TO_U1:
 		case OP_FCONV_TO_I2:
 		case OP_FCONV_TO_U2:
 #ifndef SPARCV9
 		case OP_FCONV_TO_I:
+		case OP_FCONV_TO_U:
 #endif
 		case OP_FCONV_TO_I4:
 		case OP_FCONV_TO_U4: {
 			MonoInst *spill = cfg->arch.float_spill_slot;
 			gint32 reg = spill->inst_basereg;
 			gint32 offset = spill->inst_offset;
 			g_assert (spill->opcode == OP_REGOFFSET);
 			sparc_fdtoi (code, ins->sreg1, FP_SCRATCH_REG);
 			if (!sparc_is_imm13 (offset)) {
 				sparc_set (code, offset, sparc_o7);

--- a/src/mono/mono/sgen/sgen-cardtable.c
+++ b/src/mono/mono/sgen/sgen-cardtable.c
@@ -491,23 +491,23 @@
 }
 void
 sgen_cardtable_scan_object (GCObject *obj, mword block_obj_size, guint8 *cards, ScanCopyContext ctx)
 {
 	HEAVY_STAT (++large_objects);
 	if (sgen_client_cardtable_scan_object (obj, cards, ctx))
 		return;
 	HEAVY_STAT (++bloby_objects);
 	if (cards) {
 		if (sgen_card_table_is_range_marked (cards, (mword)obj, block_obj_size))
-			ctx.ops->scan_object (obj, sgen_obj_get_descriptor_safe (obj), ctx.queue);
+			ctx.ops->scan_object (obj, sgen_obj_get_descriptor (obj), ctx.queue);
 	} else if (sgen_card_table_region_begin_scanning ((mword)obj, block_obj_size)) {
-		ctx.ops->scan_object (obj, sgen_obj_get_descriptor_safe (obj), ctx.queue);
+		ctx.ops->scan_object (obj, sgen_obj_get_descriptor (obj), ctx.queue);
 	}
 	sgen_binary_protocol_card_scan (obj, sgen_safe_object_get_size (obj));
 }
 void
 sgen_card_table_init (SgenRememberedSet *remset)
 {
 	sgen_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "card table", MONO_MEM_ACCOUNT_SGEN_CARD_TABLE);
 #ifdef SGEN_HAVE_OVERLAPPING_CARDS
 	sgen_shadow_cardtable = (guint8 *)sgen_alloc_os_memory (CARD_COUNT_IN_BYTES, (SgenAllocFlags)(SGEN_ALLOC_INTERNAL | SGEN_ALLOC_ACTIVATE), "shadow card table", MONO_MEM_ACCOUNT_SGEN_SHADOW_CARD_TABLE);
 #endif

--- a/src/mono/mono/sgen/sgen-marksweep.c
+++ b/src/mono/mono/sgen/sgen-marksweep.c
@@ -2225,21 +2225,21 @@
 				/* FIXME: do this more efficiently */
 				int w, b;
 				MS_CALC_MARK_BIT (w, b, obj);
 				if (!MS_MARK_BIT (block, w, b))
 					goto next_object;
 			}
 			GCObject *object;
 			object = (GCObject*)obj;
 			if (small_objects) {
 				HEAVY_STAT (++scanned_objects);
-				scan_func (object, sgen_obj_get_descriptor_safe (object), queue);
+				scan_func (object, sgen_obj_get_descriptor (object), queue);
 			} else {
 				size_t offset = sgen_card_table_get_card_offset (obj, block_start);
 				sgen_cardtable_scan_object (object, block_obj_size, card_base + offset, ctx);
 			}
 		next_object:
 			obj += block_obj_size;
 			g_assert (scan_front <= obj);
 			scan_front = obj;
 		}
 		HEAVY_STAT (if (*card_data) ++remarked_cards);

--- a/src/mono/wasm/debugger/BrowserDebugProxy/DebugStore.cs
+++ b/src/mono/wasm/debugger/BrowserDebugProxy/DebugStore.cs
@@ -409,25 +409,24 @@
         private Dictionary<string, string> sourceLinkMappings = new Dictionary<string, string>();
         private readonly List<SourceFile> sources = new List<SourceFile>();
         internal string Url { get; }
         internal MetadataReader asmMetadataReader { get; }
         internal MetadataReader pdbMetadataReader { get; set; }
         internal List<MemoryStream> enCMemoryStream  = new List<MemoryStream>();
         internal List<MetadataReader> enCMetadataReader  = new List<MetadataReader>();
         internal PEReader peReader;
         internal MemoryStream asmStream;
         internal MemoryStream pdbStream;
-        private int debugId;
+        public int DebugId { get; set; }
         public bool TriedToLoadSymbolsOnDemand { get; set; }
         public unsafe AssemblyInfo(string url, byte[] assembly, byte[] pdb)
         {
-            debugId = -1;
             this.id = Interlocked.Increment(ref next_id);
             asmStream = new MemoryStream(assembly);
             peReader = new PEReader(asmStream);
             asmMetadataReader = PEReaderExtensions.GetMetadataReader(peReader);
             Name = asmMetadataReader.GetAssemblyDefinition().GetAssemblyName().Name + ".dll";
             AssemblyNameUnqualified = Name;
             if (pdb != null)
             {
                 pdbStream = new MemoryStream(pdb);
                 try
@@ -442,32 +441,20 @@
             else
             {
                 var entries = peReader.ReadDebugDirectory();
                 var embeddedPdbEntry = entries.FirstOrDefault(e => e.Type == DebugDirectoryEntryType.EmbeddedPortablePdb);
                 if (embeddedPdbEntry.DataSize != 0)
                 {
                     pdbMetadataReader = peReader.ReadEmbeddedPortablePdbDebugDirectoryData(embeddedPdbEntry).GetMetadataReader();
                 }
             }
             Populate();
-        }
-        public async Task<int> GetDebugId(SessionId sessionId, MonoSDBHelper sdbAgent, CancellationToken token)
-        {
-            if (debugId > 0)
-                return debugId;
-            debugId = await sdbAgent.GetAssemblyId(sessionId, Name, token);
-            return debugId;
-        }
-        public void SetDebugId(int id)
-        {
-            if (debugId <= 0 && debugId != id)
-                debugId = id;
         }
         public bool EnC(byte[] meta, byte[] pdb)
         {
             var asmStream = new MemoryStream(meta);
             MetadataReader asmMetadataReader = MetadataReaderProvider.FromMetadataStream(asmStream).GetMetadataReader();
             var pdbStream = new MemoryStream(pdb);
             MetadataReader pdbMetadataReader = MetadataReaderProvider.FromPortablePdbStream(pdbStream).GetMetadataReader();
             enCMemoryStream.Add(asmStream);
             enCMemoryStream.Add(pdbStream);
             enCMetadataReader.Add(asmMetadataReader);

--- a/src/mono/wasm/debugger/BrowserDebugProxy/MemberReferenceResolver.cs
+++ b/src/mono/wasm/debugger/BrowserDebugProxy/MemberReferenceResolver.cs
@@ -107,21 +107,21 @@
                         var retMethod = await sdbHelper.InvokeMethod(sessionId, commandParamsObj.ToArray(), methodId, "methodRet", token);
                         return await GetValueFromObject(retMethod, token);
                     }
                 }
                 var store = await proxy.LoadStore(sessionId, token);
                 foreach (var asm in store.assemblies)
                 {
                     var type = asm.GetTypeByName(classNameToFind);
                     if (type != null)
                     {
-                        typeId = await sdbHelper.GetTypeIdFromToken(sessionId, await asm.GetDebugId(sessionId, sdbHelper, token), type.Token, token);
+                        typeId = await sdbHelper.GetTypeIdFromToken(sessionId, asm.DebugId, type.Token, token);
                     }
                 }
             }
             return null;
         }
         public async Task<JObject> Resolve(string varName, CancellationToken token)
         {
             if (varName.Contains('('))
                 return null;
             string[] parts = varName.Split(".");

--- a/src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
+++ b/src/mono/wasm/debugger/BrowserDebugProxy/MonoProxy.cs
@@ -1017,55 +1017,39 @@
                 }
             }
         }
         internal async Task<DebugStore> LoadStore(SessionId sessionId, CancellationToken token)
         {
             ExecutionContext context = GetContext(sessionId);
             if (Interlocked.CompareExchange(ref context.store, new DebugStore(logger), null) != null)
                 return await context.Source.Task;
             try
             {
-                string[] loaded_files = await GetLoadedFiles(sessionId, context, token);
+                string[] loaded_files = context.LoadedFiles;
                 if (loaded_files == null)
                 {
-                    Console.WriteLine($"Failed to get the list of loaded files. Managed code debugging won't work due to this.");
-                }
-                else
-                {
-                    await foreach (SourceFile source in context.store.Load(sessionId, loaded_files, token).WithCancellation(token))
-                    {
-                        await OnSourceFileAdded(sessionId, source, context, token);
-                    }
+                    Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(), token);
+                    loaded_files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
+                }
+                await
+                foreach (SourceFile source in context.store.Load(sessionId, loaded_files, token).WithCancellation(token))
+                {
+                    await OnSourceFileAdded(sessionId, source, context, token);
                 }
             }
             catch (Exception e)
             {
                 context.Source.SetException(e);
             }
             if (!context.Source.Task.IsCompleted)
                 context.Source.SetResult(context.store);
             return context.store;
-            async Task<string[]> GetLoadedFiles(SessionId sessionId, ExecutionContext context, CancellationToken token)
-            {
-                if (context.LoadedFiles != null)
-                    return context.LoadedFiles;
-                Result loaded = await SendMonoCommand(sessionId, MonoCommands.GetLoadedFiles(), token);
-                if (!loaded.IsOk)
-                {
-                    Console.WriteLine($"Error on mono_wasm_get_loaded_files {loaded}");
-                    return null;
-                }
-                string[] files = loaded.Value?["result"]?["value"]?.ToObject<string[]>();
-                if (files == null)
-                    Console.WriteLine($"Error extracting the list of loaded_files from the result of mono_wasm_get_loaded_files: {loaded}");
-                return files;
-            }
         }
         private async Task<DebugStore> RuntimeReady(SessionId sessionId, CancellationToken token)
         {
             ExecutionContext context = GetContext(sessionId);
             if (Interlocked.CompareExchange(ref context.ready, new TaskCompletionSource<DebugStore>(), null) != null)
                 return await context.ready.Task;
             var commandParams = new MemoryStream();
             await SdbHelper.SendDebuggerAgentCommand<CmdEventRequest>(sessionId, CmdEventRequest.ClearAllBreakpoints, commandParams, token);
             if (context.PauseOnExceptions != PauseOnExceptionsKind.None && context.PauseOnExceptions != PauseOnExceptionsKind.Unset)
                 await SdbHelper.EnableExceptions(sessionId, context.PauseOnExceptions, token);

--- a/src/mono/wasm/debugger/BrowserDebugProxy/MonoSDBHelper.cs
+++ b/src/mono/wasm/debugger/BrowserDebugProxy/MonoSDBHelper.cs
@@ -685,21 +685,21 @@
             if (asm == null)
             {
                 assemblyName = await GetAssemblyFileNameFromId(sessionId, assemblyId, token); //maybe is a lazy loaded assembly
                 asm = store.GetAssemblyByName(assemblyName);
                 if (asm == null)
                 {
                     logger.LogDebug($"Unable to find assembly: {assemblyName}");
                     return null;
                 }
             }
-            asm.SetDebugId(assemblyId);
+            asm.DebugId = assemblyId;
             assemblies[assemblyId] = asm;
             return asm;
         }
         public async Task<MethodInfoWithDebugInformation> GetMethodInfo(SessionId sessionId, int methodId, CancellationToken token)
         {
             MethodInfoWithDebugInformation methodDebugInfo = null;
             if (methods.TryGetValue(methodId, out methodDebugInfo))
             {
                 return methodDebugInfo;
             }

--- a/src/tasks/AotCompilerTask/MonoAOTCompiler.cs
+++ b/src/tasks/AotCompilerTask/MonoAOTCompiler.cs
@@ -41,30 +41,24 @@
     public string Mode { get; set; } = nameof(MonoAotMode.Normal);
     public string OutputType { get; set; } = nameof(MonoAotOutputType.ObjectFile);
     public string? LibraryFormat { get; set; }
     public string LibraryFilePrefix { get; set; } = "";
     public string? LLVMPath { get; set; }
     public string? ToolPrefix { get; set; }
     public string? MsymPath { get; set; }
     public string? DedupAssembly { get; set; }
     public string? LLVMDebug { get; set; } = "nodebug";
     public string? CacheFilePath { get; set; }
-    public string? AotArguments { get; set; }
-    public string? TempPath { get; set; }
-    public string? LdName { get; set; }
-    public string? LdFlags { get; set; }
-    public string? WorkingDirectory { get; set; }
     [Required]
     public string IntermediateOutputPath { get; set; } = string.Empty;
     [Output]
     public string[]? FileWrites { get; private set; }
-    private static readonly Encoding s_utf8Encoding = new UTF8Encoding(false);
     private List<string> _fileWrites = new();
     private IList<ITaskItem>? _assembliesToCompile;
     private ConcurrentDictionary<string, ITaskItem> compiledAssemblies = new();
     private MonoAotMode parsedAotMode;
     private MonoAotOutputType parsedOutputType;
     private MonoAotLibraryFormat parsedLibraryFormat;
     private MonoAotModulesTableLanguage parsedAotModulesTableLanguage;
     private FileCache? _cache;
     private int _numCompiled;
     private int _totalNumAssemblies;
@@ -73,21 +67,21 @@
         if (!File.Exists(CompilerBinaryPath))
         {
             Log.LogError($"{nameof(CompilerBinaryPath)}='{CompilerBinaryPath}' doesn't exist.");
             return false;
         }
         if (Assemblies.Length == 0)
         {
             Log.LogError($"'{nameof(Assemblies)}' is required.");
             return false;
         }
-        if (string.IsNullOrEmpty(WorkingDirectory) && !Path.IsPathRooted(OutputDir))
+        if (!Path.IsPathRooted(OutputDir))
             OutputDir = Path.GetFullPath(OutputDir);
         if (!Directory.Exists(OutputDir))
         {
             Log.LogError($"OutputDir={OutputDir} doesn't exist");
             return false;
         }
         if (!Directory.Exists(IntermediateOutputPath))
             Directory.CreateDirectory(IntermediateOutputPath);
         if (AotProfilePath != null)
         {
@@ -447,68 +441,45 @@
             aotAssembly.SetMetadata("AotDataFile", aotDataFile);
         }
         if (AotProfilePath?.Length > 0)
         {
             aotArgs.Add("profile-only");
             foreach (var path in AotProfilePath)
             {
                 aotArgs.Add($"profile={path}");
             }
         }
-        if (!string.IsNullOrEmpty(AotArguments))
-        {
-            aotArgs.Add(AotArguments);
-        }
-        if (!string.IsNullOrEmpty(TempPath))
-        {
-            aotArgs.Add($"temp-path={TempPath}");
-        }
-        if (!string.IsNullOrEmpty(LdName))
-        {
-            aotArgs.Add($"ld-name={LdName}");
-        }
-        if (!string.IsNullOrEmpty(LdFlags))
-        {
-            aotArgs.Add($"ld-flags={LdFlags}");
-        }
         processArgs.Add($"\"--aot={string.Join(",", aotArgs)}\"");
         if (isDedup)
         {
             foreach (var aItem in _assembliesToCompile!)
                 processArgs.Add(aItem.ItemSpec);
         }
         else
         {
-            if (string.IsNullOrEmpty(WorkingDirectory))
-            {
-                processArgs.Add('"' + assemblyFilename + '"');
-            }
-            else
-            {
-                processArgs.Add('"' + assemblyItem.ItemSpec + '"');
-            }
+            processArgs.Add('"' + assemblyFilename + '"');
         }
         monoPaths = $"{assemblyDir}{Path.PathSeparator}{monoPaths}";
         var envVariables = new Dictionary<string, string>
         {
             {"MONO_PATH", monoPaths },
             {"MONO_ENV_OPTIONS", string.Empty} // we do not want options to be provided out of band to the cross compilers
         };
         var responseFileContent = string.Join(" ", processArgs);
         var responseFilePath = Path.GetTempFileName();
-        using (var sw = new StreamWriter(responseFilePath, append: false, encoding: s_utf8Encoding))
+        using (var sw = new StreamWriter(responseFilePath, append: false, encoding: new UTF8Encoding(false)))
         {
             sw.WriteLine(responseFileContent);
         }
         return new PrecompileArguments(ResponseFilePath: responseFilePath,
                                         EnvironmentVariables: envVariables,
-                                        WorkingDir: string.IsNullOrEmpty(WorkingDirectory) ? assemblyDir : WorkingDirectory,
+                                        WorkingDir: assemblyDir,
                                         AOTAssembly: aotAssembly,
                                         ProxyFiles: proxyFiles);
     }
     private bool PrecompileLibrary(PrecompileArguments args)
     {
         string assembly = args.AOTAssembly.GetMetadata("FullPath");
         try
         {
             string msgPrefix = $"[{Path.GetFileName(assembly)}] ";
             (int exitCode, string output) = Utils.TryRunProcess(Log,
@@ -517,21 +488,21 @@
                                                                 args.EnvironmentVariables,
                                                                 args.WorkingDir,
                                                                 silent: true,
                                                                 debugMessageImportance: MessageImportance.Low,
                                                                 label: Path.GetFileName(assembly));
             var importance = exitCode == 0 ? MessageImportance.Low : MessageImportance.High;
             {
                 StringBuilder envStr = new StringBuilder(string.Empty);
                 foreach (KeyValuePair<string, string> kvp in args.EnvironmentVariables)
                     envStr.Append($"{kvp.Key}={kvp.Value} ");
-                Log.LogMessage(importance, $"{msgPrefix}Exec (with response file contents expanded) in {args.WorkingDir}: {envStr}{CompilerBinaryPath} {File.ReadAllText(args.ResponseFilePath, s_utf8Encoding)}");
+                Log.LogMessage(importance, $"{msgPrefix}Exec (with response file contents expanded) in {args.WorkingDir}: {envStr}{CompilerBinaryPath} {File.ReadAllText(args.ResponseFilePath)}");
             }
             if (exitCode != 0)
             {
                 Log.LogError($"Precompiling failed for {assembly}.{Environment.NewLine}{output}");
                 return false;
             }
             Log.LogMessage(importance, output);
         }
         catch (Exception ex)
         {

--- a/src/tasks/AppleAppBuilder/AppleAppBuilder.cs
+++ b/src/tasks/AppleAppBuilder/AppleAppBuilder.cs
@@ -45,21 +45,20 @@
     public bool GenerateCMakeProject { get; set; }
     public ITaskItem[]? ExcludeFromAppDir { get; set; }
     public string? NativeMainSource { get; set; }
     public bool UseConsoleUITemplate { get; set; }
     public bool ForceAOT { get; set; }
     public string? RuntimeComponents { get; set; } = ""!;
     public string? DiagnosticPorts { get; set; } = ""!;
     public bool InvariantGlobalization { get; set; }
     public bool ForceInterpreter { get; set; }
     public bool EnableRuntimeLogging { get; set; }
-    public bool EnableAppSandbox { get; set; }
     public override bool Execute()
     {
         bool isDevice = (TargetOS == TargetNames.iOS || TargetOS == TargetNames.tvOS);
         if (!string.IsNullOrEmpty(MainLibraryFileName))
         {
             if (!File.Exists(Path.Combine(AppDir, MainLibraryFileName)))
             {
                 throw new ArgumentException($"MainLibraryFileName='{MainLibraryFileName}' was not found in AppDir='{AppDir}'");
             }
         }
@@ -105,39 +104,35 @@
             bool validDiagnosticsConfig = false;
             if (string.IsNullOrEmpty(RuntimeComponents))
                 validDiagnosticsConfig = false;
             else if (RuntimeComponents.Equals("*", StringComparison.OrdinalIgnoreCase))
                 validDiagnosticsConfig = true;
             else if (RuntimeComponents.Contains("diagnostics_tracing", StringComparison.OrdinalIgnoreCase))
                 validDiagnosticsConfig = true;
             if (!validDiagnosticsConfig)
                 throw new ArgumentException("Using DiagnosticPorts require diagnostics_tracing runtime component.");
         }
-        if (EnableAppSandbox && (string.IsNullOrEmpty(DevTeamProvisioning) || DevTeamProvisioning == "-"))
-        {
-            throw new ArgumentException("DevTeamProvisioning must be set to a valid value when App Sandbox is enabled, using '-' is not supported.");
-        }
         var generator = new Xcode(Log, TargetOS, Arch);
         if (GenerateXcodeProject)
         {
             XcodeProjectPath = generator.GenerateXCode(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
-                AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, EnableAppSandbox, DiagnosticPorts, RuntimeComponents, NativeMainSource);
+                AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, DiagnosticPorts, RuntimeComponents, NativeMainSource);
             if (BuildAppBundle)
             {
                 if (isDevice && string.IsNullOrEmpty(DevTeamProvisioning))
                 {
                     Log.LogMessage(MessageImportance.High, "DevTeamProvisioning is not set, BuildAppBundle step is skipped.");
                 }
                 else
                 {
                     AppBundlePath = generator.BuildAppBundle(XcodeProjectPath, Optimized, DevTeamProvisioning);
                 }
             }
         }
         else if (GenerateCMakeProject)
         {
              generator.GenerateCMake(ProjectName, MainLibraryFileName, assemblerFiles, assemblerFilesToLink,
-                AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, EnableAppSandbox, DiagnosticPorts, RuntimeComponents, NativeMainSource);
+                AppDir, binDir, MonoRuntimeHeaders, !isDevice, UseConsoleUITemplate, ForceAOT, ForceInterpreter, InvariantGlobalization, Optimized, EnableRuntimeLogging, DiagnosticPorts, RuntimeComponents, NativeMainSource);
         }
         return true;
     }
 }

--- a/src/tasks/AppleAppBuilder/Xcode.cs
+++ b/src/tasks/AppleAppBuilder/Xcode.cs
@@ -85,26 +85,25 @@
         string workspace,
         string binDir,
         string monoInclude,
         bool preferDylibs,
         bool useConsoleUiTemplate,
         bool forceAOT,
         bool forceInterpreter,
         bool invariantGlobalization,
         bool optimized,
         bool enableRuntimeLogging,
-        bool enableAppSandbox,
         string? diagnosticPorts,
         string? runtimeComponents=null,
         string? nativeMainSource = null)
     {
-        var cmakeDirectoryPath = GenerateCMake(projectName, entryPointLib, asmFiles, asmLinkFiles, workspace, binDir, monoInclude, preferDylibs, useConsoleUiTemplate, forceAOT, forceInterpreter, invariantGlobalization, optimized, enableRuntimeLogging, enableAppSandbox, diagnosticPorts, runtimeComponents, nativeMainSource);
+        var cmakeDirectoryPath = GenerateCMake(projectName, entryPointLib, asmFiles, asmLinkFiles, workspace, binDir, monoInclude, preferDylibs, useConsoleUiTemplate, forceAOT, forceInterpreter, invariantGlobalization, optimized, enableRuntimeLogging, diagnosticPorts, runtimeComponents, nativeMainSource);
         CreateXcodeProject(projectName, cmakeDirectoryPath);
         return Path.Combine(binDir, projectName, projectName + ".xcodeproj");
     }
     public void CreateXcodeProject(string projectName, string cmakeDirectoryPath)
     {
         string targetName;
         switch (Target)
         {
             case TargetNames.MacCatalyst:
                 targetName = "Darwin";
@@ -139,21 +138,20 @@
         string workspace,
         string binDir,
         string monoInclude,
         bool preferDylibs,
         bool useConsoleUiTemplate,
         bool forceAOT,
         bool forceInterpreter,
         bool invariantGlobalization,
         bool optimized,
         bool enableRuntimeLogging,
-        bool enableAppSandbox,
         string? diagnosticPorts,
         string? runtimeComponents=null,
         string? nativeMainSource = null)
     {
         var excludes = new List<string> { ".dll.o", ".dll.s", ".dwarf", ".m", ".h", ".a", ".bc", "libmonosgen-2.0.dylib", "libcoreclr.dylib" };
         if (optimized)
         {
             excludes.Add(".pdb");
         }
         string[] resources = Directory.GetFileSystemEntries(workspace, "", SearchOption.TopDirectoryOnly)
@@ -169,33 +167,26 @@
         {
             string newMainPath = Path.Combine(binDir, "main.m");
             if (nativeMainSource != newMainPath)
             {
                 File.Copy(nativeMainSource, Path.Combine(binDir, "main.m"), true);
                 nativeMainSource = newMainPath;
             }
         }
         var entitlements = new List<KeyValuePair<string, string>>();
         bool hardenedRuntime = false;
-        if (Target == TargetNames.MacCatalyst && !forceAOT)
-        {
+        if (Target == TargetNames.MacCatalyst && !forceAOT) {
             hardenedRuntime = true;
             /* for mmmap MAP_JIT */
             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.allow-jit", "<true/>"));
             /* for loading unsigned dylibs like libicu from outside the bundle or libSystem.Native.dylib from inside */
             entitlements.Add (KeyValuePair.Create ("com.apple.security.cs.disable-library-validation", "<true/>"));
-        }
-        if (enableAppSandbox)
-        {
-            hardenedRuntime = true;
-            entitlements.Add (KeyValuePair.Create ("com.apple.security.app-sandbox", "<true/>"));
-            entitlements.Add (KeyValuePair.Create ("com.apple.security.network.client", "<true/>"));
         }
         string cmakeLists = Utils.GetEmbeddedResource("CMakeLists.txt.template")
             .Replace("%ProjectName%", projectName)
             .Replace("%AppResources%", string.Join(Environment.NewLine, resources.Where(r => !r.EndsWith("-llvm.o")).Select(r => "    " + Path.GetRelativePath(binDir, r))))
             .Replace("%MainSource%", nativeMainSource)
             .Replace("%MonoInclude%", monoInclude)
             .Replace("%HardenedRuntime%", hardenedRuntime ? "TRUE" : "FALSE");
         string toLink = "";
         string[] allComponentLibs = Directory.GetFiles(workspace, "libmono-component-*-static.a");
         string[] staticComponentStubLibs = Directory.GetFiles(workspace, "libmono-component-*-stub-static.a");

--- a/src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
+++ b/src/tasks/WorkloadBuildTasks/InstallWorkloadFromArtifacts.cs
@@ -62,21 +62,21 @@
                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "sdk-manifests", dir)}");
                 foreach (var dir in Directory.EnumerateDirectories(Path.Combine(SdkDir, "packs"), "*", SearchOption.AllDirectories))
                     Log.LogMessage(MessageImportance.Low, $"\t{Path.Combine(SdkDir, "packs", dir)}");
                 return false;
             }
             return !Log.HasLoggedErrors;
         }
         private string GetNuGetConfig() => File.ReadAllText(NuGetConfigFile);
         private bool InstallWorkloadManifest(string name, string version, string nugetConfigContents, bool stopOnMissing)
         {
-            Log.LogMessage(MessageImportance.High, $"Installing workload manifest for {name}/{version} for sdk band {VersionBand}");
+            Log.LogMessage(MessageImportance.High, $"Installing workload manifest for {name}/{version}");
             string outputDir = FindSubDirIgnoringCase(Path.Combine(SdkDir, "sdk-manifests", VersionBand), name);
             PackageReference pkgRef = new(Name: $"{name}.Manifest-{VersionBand}",
                                           Version: version,
                                           OutputDir: outputDir,
                                           relativeSourceDir: "data");
             if (!PackageInstaller.Install(new[]{ pkgRef }, nugetConfigContents, Log, stopOnMissing))
                 return false;
             string manifestDir = pkgRef.OutputDir;
             string jsonPath = Path.Combine(manifestDir, "WorkloadManifest.json");
             if (!File.Exists(jsonPath))
@@ -104,29 +104,21 @@
             {
                 Log.LogError($"Failed to read from {jsonPath}: {je.Message}");
                 return false;
             }
             if (manifest.DependsOn != null)
             {
                 foreach ((string depName, string depVersion) in manifest.DependsOn)
                 {
                     if (!InstallWorkloadManifest(depName, depVersion, nugetConfigContents, stopOnMissing: false))
                     {
-                        Log.LogMessage(MessageImportance.High,
-                                                $" ***** warning ******{Environment.NewLine}" +
-                                                Environment.NewLine +
-                                                $"Could not install a dependent manifest {depName}/{depVersion} for sdk band {VersionBand}.{Environment.NewLine}" +
-                                                $"If this is because this manifest doesn't have a package for sdk band {VersionBand}, " +
-                                                $"then the workload resolver will automatically fallback to the older one, and this message can be ignored.{Environment.NewLine}" +
-                                                $"This can also be safely ignored if the workload {WorkloadId.ItemSpec} doesn't use the dependency.{Environment.NewLine}" +
-                                                Environment.NewLine +
-                                                $" ********************{Environment.NewLine}");
+                        Log.LogWarning($"Could not install manifest {depName}/{depVersion}. This can be ignored if the workload {WorkloadId.ItemSpec} doesn't depend on it.");
                         continue;
                     }
                 }
             }
             return true;
         }
         private bool HasMetadata(ITaskItem item, string itemName, string metadataName)
         {
             if (!string.IsNullOrEmpty(item.GetMetadata(metadataName)))
                 return true;

--- a/src/tasks/WorkloadBuildTasks/PackageInstaller.cs
+++ b/src/tasks/WorkloadBuildTasks/PackageInstaller.cs
@@ -40,44 +40,44 @@
             Directory.CreateDirectory(projecDir);
             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.props"), "<Project />");
             File.WriteAllText(Path.Combine(projecDir, "Directory.Build.targets"), "<Project />");
             File.WriteAllText(projectPath, GenerateProject(references));
             File.WriteAllText(Path.Combine(projecDir, "nuget.config"), _nugetConfigContents);
             _logger.LogMessage(MessageImportance.Low, $"Restoring packages: {string.Join(", ", references.Select(r => $"{r.Name}/{r.Version}"))}");
             string args = $"restore \"{projectPath}\" /p:RestorePackagesPath=\"{_packagesDir}\"";
             (int exitCode, string output) = Utils.TryRunProcess(_logger, "dotnet", args, silent: false, debugMessageImportance: MessageImportance.Low);
             if (exitCode != 0)
             {
-                LogFailure($"Restoring packages failed with exit code: {exitCode}. Output:{Environment.NewLine}{output}", stopOnMissing);
+                LogErrorOrWarning($"Restoring packages failed with exit code: {exitCode}. Output:{Environment.NewLine}{output}", stopOnMissing);
                 return false;
             }
             IList<(PackageReference, string)> failedToRestore = references
                                                              .Select(r => (r, Path.Combine(_packagesDir, r.Name.ToLower(), r.Version)))
                                                              .Where(tuple => !Directory.Exists(tuple.Item2))
                                                              .ToList();
             if (failedToRestore.Count > 0)
             {
                 _logger.LogMessage(MessageImportance.Normal, output);
                 foreach ((PackageReference pkgRef, string pkgDir) in failedToRestore)
-                    LogFailure($"Could not restore {pkgRef.Name}/{pkgRef.Version} (can't find {pkgDir})", stopOnMissing);
+                    LogErrorOrWarning($"Could not restore {pkgRef.Name}/{pkgRef.Version} (can't find {pkgDir})", stopOnMissing);
                 return false;
             }
             return LayoutPackages(references, stopOnMissing);
         }
         private bool LayoutPackages(IEnumerable<PackageReference> references, bool stopOnMissing)
         {
             foreach (var pkgRef in references)
             {
                 var source = Path.Combine(_packagesDir, pkgRef.Name.ToLower(), pkgRef.Version, pkgRef.relativeSourceDir);
                 if (!Directory.Exists(source))
                 {
-                    LogFailure($"Failed to restore {pkgRef.Name}/{pkgRef.Version} (could not find {source})", stopOnMissing);
+                    LogErrorOrWarning($"Failed to restore {pkgRef.Name}/{pkgRef.Version} (could not find {source})", stopOnMissing);
                     if (stopOnMissing)
                         return false;
                 }
                 else
                 {
                     if (!CopyDirectoryAfresh(source, pkgRef.OutputDir) && stopOnMissing)
                         return false;
                 }
             }
             return true;
@@ -114,19 +114,19 @@
                 return true;
             }
             catch (Exception ex)
             {
                 _logger.LogError($"Failed while copying {srcDir} => {destDir}: {ex.Message}");
                 if (ex is IOException)
                     return false;
                 throw;
             }
         }
-        private void LogFailure(string msg, bool asError)
+        private void LogErrorOrWarning(string msg, bool stopOnMissing)
         {
-            if (asError)
+            if (stopOnMissing)
                 _logger.LogError(msg);
             else
-                _logger.LogMessage(MessageImportance.High, $"warning: {msg}");
+                _logger.LogWarning(msg);
         }
     }
 }
