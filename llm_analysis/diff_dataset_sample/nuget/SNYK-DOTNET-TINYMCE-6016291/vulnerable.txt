# ====================================================================
# FILE: Gruntfile.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-167 ---
     1| const runsHeadless = [
     2|   '@ephox/alloy',
     3|   '@ephox/mcagar',
     4|   '@ephox/katamari',
     5|   '@ephox/katamari-test',
     6|   '@ephox/jax'
     7| ];
     8| if (!Array.prototype.flatMap) {
     9|   const concat = (x, y) => x.concat(y);
    10|   const flatMap = (f, xs) => xs.map(f).reduce(concat, []);
    11|   Array.prototype.flatMap = function (f) {
    12|     return flatMap(f, this);
    13|   };
    14| }
    15| const filterChanges = (changes, tests) => {
    16|   return changes.filter((change => tests.indexOf(change.name) > -1));
    17| };
    18| const filterChangesNot = (changes, badTests) => {
    19|   return changes.filter((change => badTests.indexOf(change.name) === -1));
    20| };
    21| /* structure of lerna output
    22| {
    23|   name: string,
    24|   version: string,
    25|   private: boolean,
    26|   location: string
    27| }
    28| */
    29| /** Note: this is optimized for speed. Turns out globbing in node.js is time-consuming.
    30|  *  Restrict tinymce to 2 arbitrary levels of test base folders.
    31|  *  All other projects need their tests in src/test/ts
    32|  */
    33| const testFolders = (tests, auto) => tests.flatMap((test) => {
    34|   const testTypes = ['atomic', 'browser', 'headless'].concat(auto ? ['webdriver'] : []);
    35|   const bases = test.name === "tinymce" ? ["src/*/test/ts", "src/*/*/test/ts"] : ["src/test/ts"];
    36|   return bases.flatMap(base => testTypes.map(tt => `${test.location}/${base}/${tt}/**/*Test.ts`));
    37| });
    38| const bedrockDefaults = {
    39|   config: 'tsconfig.json',
    40|   customRoutes: 'modules/tinymce/src/core/test/json/routes.json',
    41|   overallTimeout: 180000,
    42|   singleTimeout: 60000,
    43| };
    44| const bedrockHeadless = (tests, browser, auto) => {
    45|   if (tests.length === 0) {
    46|     return {};
    47|   } else {
    48|     return {
    49|       headless: {
    50|         ...bedrockDefaults,
    51|         name: 'headless-tests',
    52|         browser,
    53|         testfiles: testFolders(tests, auto),
    54|       }
    55|     }
    56|   }
    57| };
    58| const bedrockBrowser = (tests, browserName, osName, bucket, buckets, chunk, auto) => {
    59|   if (tests.length === 0) {
    60|     return {};
    61|   } else {
    62|     return {
    63|       browser: {
    64|         ...bedrockDefaults,
    65|         overallTimeout: 1200000,
    66|         name: `${browserName}-${osName}`,
    67|         browser: browserName,
    68|         testfiles: testFolders(tests, auto),
    69|         bucket: bucket,
    70|         buckets: buckets,
    71|         chunk: chunk,
    72|         retries: 3
    73|       }
    74|     };
    75|   }
    76| };
    77| const fetchLernaProjects = (log, runAllTests) => {
    78|   var exec = require('child_process').execSync;
    79|   const parseLernaList = (cmd) => {
    80|     try {
    81|       return JSON.parse(exec(`yarn -s lerna ${cmd} -a --json --loglevel warn 2>&1`));
    82|     } catch (e) {
    83|       if (e.status === 1) {
    84|         return [];
    85|       } else {
    86|         throw e;
    87|       }
    88|     }
    89|   };
    90|   const changes = runAllTests ? [] : parseLernaList('changed --no-ignore-changes');
    91|   if (changes.length === 0) {
    92|     log.writeln('No changes found, testing all projects');
    93|     return parseLernaList('list');
    94|   } else {
    95|     return changes;
    96|   }
    97| };
    98| module.exports = function (grunt) {
    99|   const runAllTests = grunt.option('ignore-lerna-changed') || false;
   100|   const changes = fetchLernaProjects(grunt.log, runAllTests);
   101|   const bucket = parseInt(grunt.option('bucket'), 10) || 1;
   102|   const buckets = parseInt(grunt.option('buckets'), 10) || 1;
   103|   const chunk = parseInt(grunt.option('chunk'), 10) || 100;
   104|   const headlessTests = filterChanges(changes, runsHeadless);
   105|   const browserTests = filterChangesNot(changes, runsHeadless);
   106|   const activeBrowser = grunt.option('bedrock-browser') || 'chrome-headless';
   107|   const headlessBrowser = activeBrowser.endsWith("-headless") ? activeBrowser : 'chrome-headless'
   108|   const activeOs = grunt.option('bedrock-os') || 'tests';
   109|   const gruntConfig = {
   110|     shell: {
   111|       tsc: { command: 'yarn -s tsc' },
   112|       legacy: { command: 'yarn build' },
   113|       yarn: { command: 'yarn' },
   114|       'yarn-dev': { command: 'yarn -s dev' }
   115|     },
   116|     'bedrock-auto': {
   117|       ...bedrockHeadless(headlessTests, headlessBrowser, true),
   118|       ...bedrockBrowser(browserTests, activeBrowser, activeOs, bucket, buckets, chunk, true)
   119|     },
   120|     'bedrock-manual': {
   121|       ...bedrockHeadless(headlessTests, headlessBrowser, false),
   122|       ...bedrockBrowser(browserTests, activeBrowser, activeOs, bucket, buckets, chunk, false)
   123|     }
   124|   };
   125|   grunt.initConfig(gruntConfig);
   126|   if (headlessTests.length > 0) {
   127|     grunt.registerTask('list-changed-headless', () => {
   128|       const changeList = JSON.stringify(headlessTests.reduce((acc, change) => acc.concat(change.name), []), null, 2);
   129|       grunt.log.writeln('Changed projects for headless testing:', changeList);
   130|     });
   131|     grunt.registerTask('headless-auto', ['list-changed-headless', 'shell:tsc', 'bedrock-auto:headless']);
   132|     grunt.registerTask('headless-manual', ['list-changed-headless', 'shell:tsc', 'bedrock-manual:headless']);
   133|   } else {
   134|     const noHeadless = () => {
   135|       grunt.log.writeln('no changed modules need headless testing');
   136|     };
   137|     grunt.registerTask('headless-auto', noHeadless);
   138|     grunt.registerTask('headless-manual', noHeadless);
   139|     grunt.registerTask('list-changed-headless', noHeadless);
   140|   }
   141|   if (browserTests.length > 0) {
   142|     grunt.registerTask('list-changed-browser', () => {
   143|       const changeList = JSON.stringify(browserTests.reduce((acc, change) => acc.concat(change.name), []), null, 2);
   144|       grunt.log.writeln('Changed projects for browser testing:', changeList);
   145|     });
   146|     grunt.registerTask('browser-auto', ['list-changed-browser', 'shell:tsc', 'bedrock-auto:browser']);
   147|     grunt.registerTask('browser-manual', ['list-changed-browser', 'shell:tsc', 'bedrock-manual:browser']);
   148|   } else {
   149|     const noBrowser = () => {
   150|       grunt.log.writeln('no changed modules need browser testing');
   151|     };
   152|     grunt.registerTask('browser-auto', noBrowser);
   153|     grunt.registerTask('browser-manual', noBrowser);
   154|     grunt.registerTask('list-changed-browser', noBrowser);
   155|   }
   156|   grunt.registerTask('legacy-warn', () => grunt.log.warn(`
   157| *******
   158| Top-level grunt has been replaced by 'yarn build', and the output has moved from project root to modules/tinymce
   159| *******
   160| `));
   161|   grunt.registerTask('default', ['legacy-warn', 'shell:legacy']);
   162|   require('load-grunt-tasks')(grunt, {
   163|     requireResolution: true,
   164|     config: 'package.json',
   165|     pattern: ['@ephox/bedrock-server', 'grunt-shell']
   166|   });
   167| };


# ====================================================================
# FILE: bin/build-prism.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| #!/usr/bin/env node
     2| const fs = require('fs');
     3| const path = require('path');
     4| const files = [
     5|   'components/prism-core.js',
     6|   'components/prism-clike.js',
     7|   'components/prism-markup-templating.js',
     8|   'components/prism-c.js',
     9|   'components/prism-cpp.js',
    10|   'components/prism-csharp.js',
    11|   'components/prism-css.js',
    12|   'components/prism-java.js',
    13|   'components/prism-javascript.js',
    14|   'components/prism-markup.js',
    15|   'components/prism-php.js',
    16|   'components/prism-python.js',
    17|   'components/prism-ruby.js'
    18| ];
    19| let content = `const prismjs = function(global, module, exports) {
    20| const oldprism = window.Prism;
    21| window.Prism = { manual: true };
    22| `;
    23| files.forEach((file) => {
    24|   content += fs.readFileSync(path.resolve(__dirname, '../node_modules/prismjs', file)).toString() + '\n';
    25| });
    26| content += `// restore the original Prism reference
    27| window.Prism = oldprism;
    28| return Prism;
    29| }(undefined, undefined, undefined);
    30| export default prismjs;`
    31| fs.writeFileSync(path.resolve(__dirname, '../node_modules/prismjs/prism.js'), content);


# ====================================================================
# FILE: modules/acid/src/main/ts/ephox/acid/api/colour/RgbaColour.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-111 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { Hex, Hsv, Rgba } from './ColourTypes';
     3| import * as HexColour from './HexColour';
     4| const min = Math.min;
     5| const max = Math.max;
     6| const round = Math.round;
     7| const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
     8| const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
     9| const rgbaColour = (red: number, green: number, blue: number, alpha: number): Rgba => ({
    10|   red,
    11|   green,
    12|   blue,
    13|   alpha
    14| });
    15| const isRgbaComponent = (value: string): boolean => {
    16|   const num = parseInt(value, 10);
    17|   return num.toString() === value && num >= 0 && num <= 255;
    18| };
    19| const fromHsv = (hsv: Hsv): Rgba => {
    20|   let r; let g; let b;
    21|   const hue = (hsv.hue || 0) % 360;
    22|   let saturation = hsv.saturation / 100;
    23|   let brightness = hsv.value / 100;
    24|   saturation = max(0, min(saturation, 1));
    25|   brightness = max(0, min(brightness, 1));
    26|   if (saturation === 0) {
    27|     r = g = b = round(255 * brightness);
    28|     return rgbaColour(r, g, b, 1);
    29|   }
    30|   const side = hue / 60;
    31|   const chroma = brightness * saturation;
    32|   const x = chroma * (1 - Math.abs(side % 2 - 1));
    33|   const match = brightness - chroma;
    34|   switch (Math.floor(side)) {
    35|     case 0:
    36|       r = chroma;
    37|       g = x;
    38|       b = 0;
    39|       break;
    40|     case 1:
    41|       r = x;
    42|       g = chroma;
    43|       b = 0;
    44|       break;
    45|     case 2:
    46|       r = 0;
    47|       g = chroma;
    48|       b = x;
    49|       break;
    50|     case 3:
    51|       r = 0;
    52|       g = x;
    53|       b = chroma;
    54|       break;
    55|     case 4:
    56|       r = x;
    57|       g = 0;
    58|       b = chroma;
    59|       break;
    60|     case 5:
    61|       r = chroma;
    62|       g = 0;
    63|       b = x;
    64|       break;
    65|     default:
    66|       r = g = b = 0;
    67|   }
    68|   r = round(255 * (r + match));
    69|   g = round(255 * (g + match));
    70|   b = round(255 * (b + match));
    71|   return rgbaColour(r, g, b, 1);
    72| };
    73| const fromHex = (hexColour: Hex): Rgba => {
    74|   const result = HexColour.extractValues(hexColour);
    75|   const red = parseInt(result[1], 16);
    76|   const green = parseInt(result[2], 16);
    77|   const blue = parseInt(result[3], 16);
    78|   return rgbaColour(red, green, blue, 1);
    79| };
    80| const fromStringValues = (red: string, green: string, blue: string, alpha: string): Rgba => {
    81|   const r = parseInt(red, 10);
    82|   const g = parseInt(green, 10);
    83|   const b = parseInt(blue, 10);
    84|   const a = parseFloat(alpha);
    85|   return rgbaColour(r, g, b, a);
    86| };
    87| const fromString = (rgbaString: string): Optional<Rgba> => {
    88|   if (rgbaString === 'transparent') {
    89|     return Optional.some(rgbaColour(0, 0, 0, 0));
    90|   }
    91|   const rgbMatch = rgbRegex.exec(rgbaString);
    92|   if (rgbMatch !== null) {
    93|     return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
    94|   }
    95|   const rgbaMatch = rgbaRegex.exec(rgbaString);
    96|   if (rgbaMatch !== null) {
    97|     return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
    98|   }
    99|   return Optional.none();
   100| };
   101| const toString = (rgba: Rgba): string => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;
   102| const red = rgbaColour(255, 0, 0, 1);
   103| export {
   104|   rgbaColour,
   105|   isRgbaComponent,
   106|   fromHsv,
   107|   fromHex,
   108|   fromString,
   109|   toString,
   110|   red
   111| };


# ====================================================================
# FILE: modules/acid/src/main/ts/ephox/acid/api/colour/Transformations.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| import { Hex, Hsv } from './ColourTypes';
     2| import * as HexColour from './HexColour';
     3| import * as HsvColour from './HsvColour';
     4| import * as RgbaColour from './RgbaColour';
     5| const hexToHsv = (hex: Hex): Hsv => HsvColour.fromRgb(RgbaColour.fromHex(hex));
     6| const hsvToHex = (hsv: Hsv): Hex => HexColour.fromRgba(RgbaColour.fromHsv(hsv));
     7| const anyToHex = (color: string): Hex =>
     8|   HexColour.fromString(color)
     9|     .orThunk(() => RgbaColour.fromString(color).map(HexColour.fromRgba))
    10|     .getOrThunk(() => {
    11|       const canvas = document.createElement('canvas');
    12|       canvas.height = 1;
    13|       canvas.width = 1;
    14|       const canvasContext = canvas.getContext('2d') as CanvasRenderingContext2D;
    15|       canvasContext.clearRect(0, 0, canvas.width, canvas.height);
    16|       canvasContext.fillStyle = '#FFFFFF'; // lgtm[js/useless-assignment-to-property]
    17|       canvasContext.fillStyle = color;
    18|       canvasContext.fillRect(0, 0, 1, 1);
    19|       const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
    20|       const r = rgba[0];
    21|       const g = rgba[1];
    22|       const b = rgba[2];
    23|       const a = rgba[3];
    24|       return HexColour.fromRgba(RgbaColour.rgbaColour(r, g, b, a));
    25|     });
    26| const rgbaToHexString = (color: string): string =>
    27|   RgbaColour.fromString(color)
    28|     .map(HexColour.fromRgba)
    29|     .map((h) => '#' + h.value)
    30|     .getOr(color);
    31| export {
    32|   anyToHex,
    33|   rgbaToHexString,
    34|   hexToHsv,
    35|   hsvToHex
    36| };


# ====================================================================
# FILE: modules/acid/src/main/ts/ephox/acid/gui/ColourPicker.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-144 ---
     1| import {
     2|   AddEventsBehaviour, AlloyComponent, AlloyEvents, Behaviour, Composing, Keying, Memento, RawDomSchema, SimulatedEvent, Sketcher, Slider
     3| } from '@ephox/alloy';
     4| import { FieldSchema } from '@ephox/boulder';
     5| import { Arr, Cell, Fun } from '@ephox/katamari';
     6| import { Hex } from '../api/colour/ColourTypes';
     7| import * as HsvColour from '../api/colour/HsvColour';
     8| import * as RgbaColour from '../api/colour/RgbaColour';
     9| import * as Transformations from '../api/colour/Transformations';
    10| import * as ColourEvents from './ColourEvents';
    11| import * as HueSlider from './components/HueSlider';
    12| import * as RgbForm from './components/RgbForm';
    13| import * as SaturationBrightnessPalette from './components/SaturationBrightnessPalette';
    14| export interface ColourPickerDetail extends Sketcher.SingleSketchDetail {
    15|   readonly dom: RawDomSchema;
    16|   readonly onValidHex: (component: AlloyComponent) => void;
    17|   readonly onInvalidHex: (component: AlloyComponent) => void;
    18| }
    19| export interface ColourPickerSpec extends Sketcher.SingleSketchSpec {
    20|   readonly dom: RawDomSchema;
    21|   readonly onValidHex?: (component: AlloyComponent) => void;
    22|   readonly onInvalidHex?: (component: AlloyComponent) => void;
    23| }
    24| export interface ColourPickerSketcher extends Sketcher.SingleSketch<ColourPickerSpec> {
    25| }
    26| const makeFactory = (
    27|   translate: (key: string) => string,
    28|   getClass: (key: string) => string
    29| ): ColourPickerSketcher => {
    30|   const factory = (detail: ColourPickerDetail) => {
    31|     const rgbForm = RgbForm.rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);
    32|     const sbPalette = SaturationBrightnessPalette.paletteFactory(translate, getClass);
    33|     const hueSliderToDegrees = (hue: number): number => (100 - hue) / 100 * 360;
    34|     const hueDegreesToSlider = (hue: number): number => 100 - (hue / 360) * 100;
    35|     const state = {
    36|       paletteRgba: Cell(RgbaColour.red),
    37|       paletteHue: Cell(0)
    38|     };
    39|     const memSlider = Memento.record(
    40|       HueSlider.sliderFactory(translate, getClass)
    41|     );
    42|     const memPalette = Memento.record(
    43|       sbPalette.sketch({})
    44|     );
    45|     const memRgb = Memento.record(
    46|       rgbForm.sketch({})
    47|     );
    48|     const updatePalette = (anyInSystem: AlloyComponent, _hex: Hex, hue: number) => {
    49|       memPalette.getOpt(anyInSystem).each((palette) => {
    50|         sbPalette.setHue(palette, hue);
    51|       });
    52|     };
    53|     const updateFields = (anyInSystem: AlloyComponent, hex: Hex) => {
    54|       memRgb.getOpt(anyInSystem).each((form) => {
    55|         rgbForm.updateHex(form, hex);
    56|       });
    57|     };
    58|     const updateSlider = (anyInSystem: AlloyComponent, _hex: Hex, hue: number) => {
    59|       memSlider.getOpt(anyInSystem).each((slider) => {
    60|         Slider.setValue(slider, hueDegreesToSlider(hue));
    61|       });
    62|     };
    63|     const updatePaletteThumb = (anyInSystem: AlloyComponent, hex: Hex) => {
    64|       memPalette.getOpt(anyInSystem).each((palette) => {
    65|         sbPalette.setThumb(palette, hex);
    66|       });
    67|     };
    68|     const updateState = (hex: Hex, hue: number) => {
    69|       const rgba = RgbaColour.fromHex(hex);
    70|       state.paletteRgba.set(rgba);
    71|       state.paletteHue.set(hue);
    72|     };
    73|     const runUpdates = (anyInSystem: AlloyComponent, hex: Hex, hue: number, updates: ((anyInSystem: AlloyComponent, hex: Hex, hue: number) => void)[]) => {
    74|       updateState(hex, hue);
    75|       Arr.each(updates, (update) => {
    76|         update(anyInSystem, hex, hue);
    77|       });
    78|     };
    79|     const onPaletteUpdate = () => {
    80|       const updates = [ updateFields ];
    81|       return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.PaletteUpdateEvent>) => {
    82|         const value = simulatedEvent.event.value;
    83|         const oldHue = state.paletteHue.get();
    84|         const newHsv = HsvColour.hsvColour(oldHue, value.x, (100 - value.y));
    85|         const newHex = Transformations.hsvToHex(newHsv);
    86|         runUpdates(form, newHex, oldHue, updates);
    87|       };
    88|     };
    89|     const onSliderUpdate = () => {
    90|       const updates = [ updatePalette, updateFields ];
    91|       return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.SliderUpdateEvent>) => {
    92|         const hue = hueSliderToDegrees(simulatedEvent.event.value);
    93|         const oldRgb = state.paletteRgba.get();
    94|         const oldHsv = HsvColour.fromRgb(oldRgb);
    95|         const newHsv = HsvColour.hsvColour(hue, oldHsv.saturation, oldHsv.value);
    96|         const newHex = Transformations.hsvToHex(newHsv);
    97|         runUpdates(form, newHex, hue, updates);
    98|       };
    99|     };
   100|     const onFieldsUpdate = () => {
   101|       const updates = [ updatePalette, updateSlider, updatePaletteThumb ];
   102|       return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.FieldsUpdateEvent>) => {
   103|         const hex = simulatedEvent.event.hex;
   104|         const hsv = Transformations.hexToHsv(hex);
   105|         runUpdates(form, hex, hsv.hue, updates);
   106|       };
   107|     };
   108|     return {
   109|       uid: detail.uid,
   110|       dom: detail.dom,
   111|       components: [
   112|         memPalette.asSpec(),
   113|         memSlider.asSpec(),
   114|         memRgb.asSpec()
   115|       ],
   116|       behaviours: Behaviour.derive([
   117|         AddEventsBehaviour.config('colour-picker-events', [
   118|           AlloyEvents.run(ColourEvents.fieldsUpdate, onFieldsUpdate()),
   119|           AlloyEvents.run(ColourEvents.paletteUpdate, onPaletteUpdate()),
   120|           AlloyEvents.run(ColourEvents.sliderUpdate, onSliderUpdate())
   121|         ]),
   122|         Composing.config({
   123|           find: (comp) => memRgb.getOpt(comp)
   124|         }),
   125|         Keying.config({
   126|           mode: 'acyclic'
   127|         })
   128|       ])
   129|     };
   130|   };
   131|   const colourPickerSketcher = Sketcher.single({
   132|     name: 'ColourPicker',
   133|     configFields: [
   134|       FieldSchema.required('dom'),
   135|       FieldSchema.defaulted('onValidHex', Fun.noop),
   136|       FieldSchema.defaulted('onInvalidHex', Fun.noop)
   137|     ],
   138|     factory
   139|   }) as ColourPickerSketcher;
   140|   return colourPickerSketcher;
   141| };
   142| export {
   143|   makeFactory
   144| };


# ====================================================================
# FILE: modules/acid/src/main/ts/ephox/acid/gui/components/HueSlider.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| import { AlloyComponent, AlloyTriggers, Behaviour, Focusing, SketchSpec, Slider } from '@ephox/alloy';
     2| import { Fun } from '@ephox/katamari';
     3| import { sliderUpdate } from '../ColourEvents';
     4| const sliderFactory = (translate: (key: string) => string, getClass: (key: string) => string): SketchSpec => {
     5|   const spectrum = Slider.parts.spectrum({
     6|     dom: {
     7|       tag: 'div',
     8|       classes: [ getClass('hue-slider-spectrum') ],
     9|       attributes: {
    10|         role: 'presentation'
    11|       }
    12|     }
    13|   });
    14|   const thumb = Slider.parts.thumb({
    15|     dom: {
    16|       tag: 'div',
    17|       classes: [ getClass('hue-slider-thumb') ],
    18|       attributes: {
    19|         role: 'presentation'
    20|       }
    21|     }
    22|   });
    23|   return Slider.sketch({
    24|     dom: {
    25|       tag: 'div',
    26|       classes: [ getClass('hue-slider') ],
    27|       attributes: {
    28|         role: 'presentation'
    29|       }
    30|     },
    31|     rounded: false,
    32|     model: {
    33|       mode: 'y',
    34|       getInitialValue: Fun.constant(0)
    35|     },
    36|     components: [
    37|       spectrum,
    38|       thumb
    39|     ],
    40|     sliderBehaviours: Behaviour.derive([
    41|       Focusing.config({ })
    42|     ]),
    43|     onChange: (slider: AlloyComponent, _thumb: any, value: any) => {
    44|       AlloyTriggers.emitWith(slider, sliderUpdate, {
    45|         value
    46|       });
    47|     }
    48|   });
    49| };
    50| export {
    51|   sliderFactory
    52| };


# ====================================================================
# FILE: modules/acid/src/main/ts/ephox/acid/gui/components/RgbForm.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-288 ---
     1| import {
     2|   AddEventsBehaviour, AlloyComponent, AlloyEvents, AlloyTriggers, Behaviour, EventFormat, Focusing, Form, FormField, FormTypes, GuiFactory, Input, Invalidating,
     3|   Memento, Representing, SimulatedEvent, Sketcher, SketchSpec, Tabstopping, UiSketcher
     4| } from '@ephox/alloy';
     5| import { Cell, Fun, Future, Id, Merger, Optional, Result } from '@ephox/katamari';
     6| import { Css } from '@ephox/sugar';
     7| import { Hex, Rgba } from '../../api/colour/ColourTypes';
     8| import * as HexColour from '../../api/colour/HexColour';
     9| import * as RgbaColour from '../../api/colour/RgbaColour';
    10| import * as ColourEvents from '../ColourEvents';
    11| const validInput = Id.generate('valid-input');
    12| const invalidInput = Id.generate('invalid-input');
    13| const validatingInput = Id.generate('validating-input');
    14| interface HexInputEvent extends EventFormat {
    15|   readonly type: 'hex';
    16|   readonly value: string;
    17| }
    18| interface ColorInputEvent extends EventFormat {
    19|   readonly type: 'red' | 'green' | 'blue';
    20|   readonly value: string;
    21| }
    22| type InputEvent = HexInputEvent | ColorInputEvent;
    23| const translatePrefix = 'colorcustom.rgb.';
    24| export interface RgbFormDetail extends Sketcher.SingleSketchDetail {
    25| }
    26| export interface RgbFormSpec extends Sketcher.SingleSketchSpec {
    27| }
    28| export interface RgbFormSketcher extends Sketcher.SingleSketch<RgbFormSpec> {
    29|   updateHex: (slider: AlloyComponent, colour: Hex) => void;
    30| }
    31| const rgbFormFactory = (
    32|   translate: (key: string) => string,
    33|   getClass: (key: string) => string,
    34|   onValidHexx: (component: AlloyComponent) => void,
    35|   onInvalidHexx: (component: AlloyComponent) => void
    36| ): RgbFormSketcher => {
    37|   const invalidation = (label: string, isValid: (value: string) => boolean) => Invalidating.config({
    38|     invalidClass: getClass('invalid'),
    39|     notify: {
    40|       onValidate: (comp: AlloyComponent) => {
    41|         AlloyTriggers.emitWith(comp, validatingInput, {
    42|           type: label
    43|         });
    44|       },
    45|       onValid: (comp: AlloyComponent) => {
    46|         AlloyTriggers.emitWith(comp, validInput, {
    47|           type: label,
    48|           value: Representing.getValue(comp)
    49|         });
    50|       },
    51|       onInvalid: (comp: AlloyComponent) => {
    52|         AlloyTriggers.emitWith(comp, invalidInput, {
    53|           type: label,
    54|           value: Representing.getValue(comp)
    55|         });
    56|       }
    57|     },
    58|     validator: {
    59|       validate: (comp: AlloyComponent) => {
    60|         const value = Representing.getValue(comp);
    61|         const res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));
    62|         return Future.pure(res);
    63|       },
    64|       validateOnLoad: false
    65|     }
    66|   });
    67|   const renderTextField = (
    68|     isValid: (value: string) => boolean,
    69|     name: string,
    70|     label: string,
    71|     description: string,
    72|     data: string | number
    73|   ) => {
    74|     const helptext = translate(translatePrefix + 'range');
    75|     const pLabel = FormField.parts.label({
    76|       dom: { tag: 'label', attributes: { 'aria-label': description }},
    77|       components: [ GuiFactory.text(label) ]
    78|     });
    79|     const pField = FormField.parts.field({
    80|       data,
    81|       factory: Input,
    82|       inputAttributes: {
    83|         type: 'text',
    84|         ...name === 'hex' ? { 'aria-live': 'polite' } : {}
    85|       },
    86|       inputClasses: [ getClass('textfield') ],
    87|       inputBehaviours: Behaviour.derive([
    88|         invalidation(name, isValid),
    89|         Tabstopping.config({})
    90|       ]),
    91|       onSetValue: (input: AlloyComponent) => {
    92|         if (Invalidating.isInvalid(input)) {
    93|           const run = Invalidating.run(input);
    94|           run.get(Fun.noop);
    95|         }
    96|       }
    97|     });
    98|     const comps = [ pLabel, pField ];
    99|     const concats = name !== 'hex' ? [ FormField.parts['aria-descriptor']({
   100|       text: helptext
   101|     }) ] : [];
   102|     const components = comps.concat(concats);
   103|     return {
   104|       dom: {
   105|         tag: 'div',
   106|         attributes: {
   107|           role: 'presentation'
   108|         }
   109|       },
   110|       components
   111|     };
   112|   };
   113|   const copyRgbToHex = (form: AlloyComponent, rgba: Rgba) => {
   114|     const hex = HexColour.fromRgba(rgba);
   115|     Form.getField(form, 'hex').each((hexField: AlloyComponent) => {
   116|       if (!Focusing.isFocused(hexField)) {
   117|         Representing.setValue(form, {
   118|           hex: hex.value
   119|         });
   120|       }
   121|     });
   122|     return hex;
   123|   };
   124|   const copyRgbToForm = (form: AlloyComponent, rgb: Rgba): void => {
   125|     const red = rgb.red; const green = rgb.green; const blue = rgb.blue;
   126|     Representing.setValue(form, { red, green, blue });
   127|   };
   128|   const memPreview = Memento.record(
   129|     {
   130|       dom: {
   131|         tag: 'div',
   132|         classes: [ getClass('rgba-preview') ],
   133|         styles: {
   134|           'background-color': 'white'
   135|         },
   136|         attributes: {
   137|           role: 'presentation'
   138|         }
   139|       }
   140|     }
   141|   );
   142|   const updatePreview = (anyInSystem: AlloyComponent, hex: Hex) => {
   143|     memPreview.getOpt(anyInSystem).each((preview: AlloyComponent) => {
   144|       Css.set(preview.element, 'background-color', '#' + hex.value);
   145|     });
   146|   };
   147|   const factory: UiSketcher.SingleSketchFactory<RgbFormDetail, RgbFormSpec> = (): SketchSpec => {
   148|     const state = {
   149|       red: Cell(Optional.some(255)),
   150|       green: Cell(Optional.some(255)),
   151|       blue: Cell(Optional.some(255)),
   152|       hex: Cell(Optional.some('ffffff'))
   153|     };
   154|     const copyHexToRgb = (form: AlloyComponent, hex: Hex) => {
   155|       const rgb = RgbaColour.fromHex(hex);
   156|       copyRgbToForm(form, rgb);
   157|       setValueRgb(rgb);
   158|     };
   159|     const get = (prop: keyof typeof state): Optional<any> => state[prop].get();
   160|     const set = (prop: keyof typeof state, value: Optional<any>): void => {
   161|       state[prop].set(value);
   162|     };
   163|     const getValueRgb = () => get('red').bind(
   164|       (red) => get('green').bind(
   165|         (green) => get('blue').map(
   166|           (blue) => RgbaColour.rgbaColour(red, green, blue, 1)
   167|         )
   168|       )
   169|     );
   170|     const setValueRgb = (rgb: Rgba): void => {
   171|       const red = rgb.red; const green = rgb.green; const blue = rgb.blue;
   172|       set('red', Optional.some(red));
   173|       set('green', Optional.some(green));
   174|       set('blue', Optional.some(blue));
   175|     };
   176|     const onInvalidInput = (form: AlloyComponent, simulatedEvent: SimulatedEvent<InputEvent>) => {
   177|       const data = simulatedEvent.event;
   178|       if (data.type !== 'hex') {
   179|         set(data.type, Optional.none());
   180|       } else {
   181|         onInvalidHexx(form);
   182|       }
   183|     };
   184|     const onValidHex = (form: AlloyComponent, value: string) => {
   185|       onValidHexx(form);
   186|       const hex = HexColour.hexColour(value);
   187|       set('hex', Optional.some(value));
   188|       const rgb = RgbaColour.fromHex(hex);
   189|       copyRgbToForm(form, rgb);
   190|       setValueRgb(rgb);
   191|       AlloyTriggers.emitWith(form, ColourEvents.fieldsUpdate, {
   192|         hex
   193|       });
   194|       updatePreview(form, hex);
   195|     };
   196|     const onValidRgb = (form: AlloyComponent, prop: 'red' | 'green' | 'blue', value: string) => {
   197|       const val = parseInt(value, 10);
   198|       set(prop, Optional.some(val));
   199|       getValueRgb().each((rgb) => {
   200|         const hex = copyRgbToHex(form, rgb);
   201|         AlloyTriggers.emitWith(form, ColourEvents.fieldsUpdate, {
   202|           hex
   203|         });
   204|         updatePreview(form, hex);
   205|       });
   206|     };
   207|     const isHexInputEvent = (data: InputEvent): data is HexInputEvent => data.type === 'hex';
   208|     const onValidInput = (form: AlloyComponent, simulatedEvent: SimulatedEvent<InputEvent>) => {
   209|       const data = simulatedEvent.event;
   210|       if (isHexInputEvent(data)) {
   211|         onValidHex(form, data.value);
   212|       } else {
   213|         onValidRgb(form, data.type, data.value);
   214|       }
   215|     };
   216|     const formPartStrings = (key: string) => ({
   217|       label: translate(translatePrefix + key + '.label'),
   218|       description: translate(translatePrefix + key + '.description')
   219|     });
   220|     const redStrings = formPartStrings('red');
   221|     const greenStrings = formPartStrings('green');
   222|     const blueStrings = formPartStrings('blue');
   223|     const hexStrings = formPartStrings('hex');
   224|     return Merger.deepMerge(
   225|       Form.sketch((parts: FormTypes.FormParts) => ({
   226|         dom: {
   227|           tag: 'form',
   228|           classes: [ getClass('rgb-form') ],
   229|           attributes: { 'aria-label': translate('aria.color.picker') }
   230|         },
   231|         components: [
   232|           parts.field('red', FormField.sketch(
   233|             renderTextField(RgbaColour.isRgbaComponent, 'red', redStrings.label, redStrings.description, 255)
   234|           )),
   235|           parts.field('green', FormField.sketch(
   236|             renderTextField(RgbaColour.isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255)
   237|           )),
   238|           parts.field('blue', FormField.sketch(
   239|             renderTextField(RgbaColour.isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255)
   240|           )),
   241|           parts.field('hex', FormField.sketch(
   242|             renderTextField(HexColour.isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff')
   243|           )),
   244|           memPreview.asSpec()
   245|         ],
   246|         formBehaviours: Behaviour.derive([
   247|           Invalidating.config({
   248|             invalidClass: getClass('form-invalid')
   249|           }),
   250|           AddEventsBehaviour.config('rgb-form-events', [
   251|             AlloyEvents.run(validInput, onValidInput),
   252|             AlloyEvents.run(invalidInput, onInvalidInput),
   253|             AlloyEvents.run(validatingInput, onInvalidInput)
   254|           ])
   255|         ])
   256|       })),
   257|       {
   258|         apis: {
   259|           updateHex: (form: AlloyComponent, hex: Hex) => {
   260|             Representing.setValue(form, {
   261|               hex: hex.value
   262|             });
   263|             copyHexToRgb(form, hex);
   264|             updatePreview(form, hex);
   265|           }
   266|         }
   267|       }
   268|     );
   269|   };
   270|   interface Apis {
   271|     updateHex(form: AlloyComponent, hex: Hex): void;
   272|   }
   273|   const rgbFormSketcher = Sketcher.single({
   274|     factory,
   275|     name: 'RgbForm',
   276|     configFields: [],
   277|     apis: {
   278|       updateHex: (apis: Apis, form: AlloyComponent, hex: Hex) => {
   279|         apis.updateHex(form, hex);
   280|       }
   281|     },
   282|     extraApis: {}
   283|   }) as RgbFormSketcher;
   284|   return rgbFormSketcher;
   285| };
   286| export {
   287|   rgbFormFactory
   288| };


# ====================================================================
# FILE: modules/agar/src/demo/ts/ephox/agar/demo/DemoContainer.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import { Class, Html, Insert, InsertAll, Remove, SugarElement, SugarElements } from '@ephox/sugar';
     2| export const init = (name: string, f: (success: () => void, failure: (err: any) => void) => SugarElement<Node>[]): void => {
     3|   const container = SugarElement.fromTag('div');
     4|   Class.add(container, 'demo-container');
     5|   Html.set(container, '<p>' + name + '</p>');
     6|   const outcome = SugarElement.fromTag('div');
     7|   Html.set(outcome, 'Running ....');
     8|   const success = () => {
     9|     Class.add(outcome, 'success');
    10|     Html.set(outcome, 'Success!');
    11|   };
    12|   const htmlentities = (str: string): string =>
    13|     String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    14|   const keepMarkers = (html: string): string =>
    15|     html.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>').replace(/&lt;ins&gt;/g, '<ins>').replace(/&lt;\/ins&gt;/g, '</ins>');
    16|   const failure = (err: any): void => {
    17|     Class.add(outcome, 'failure');
    18|     Remove.empty(outcome);
    19|     if (err.diff) {
    20|       InsertAll.append(outcome, SugarElements.fromHtml(keepMarkers(htmlentities(err.diff.comparison))));
    21|     } else {
    22|       Insert.append(outcome, SugarElement.fromText(err));
    23|     }
    24|   };
    25|   Insert.append(container, outcome);
    26|   const elements = f(success, failure);
    27|   InsertAll.append(container, elements);
    28|   Insert.append(SugarElement.fromDom(document.body), container);
    29| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/alien/SizzleFind.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| import { Arr, Optional } from '@ephox/katamari';
     2| import { SugarElement, SugarNode, Traverse } from '@ephox/sugar';
     3| import * as Sizzle from 'sizzle';
     4| type SizzleContext = Element | Document | DocumentFragment;
     5| const toOptionEl = <T extends Element>(output: T[]): Optional<SugarElement<T>> =>
     6|   output.length === 0 ? Optional.none() : Optional.from(output[0]).map(SugarElement.fromDom);
     7| /* Petrie makes extensive use of :visible, :has() and :contains() which are sizzle extensions */
     8| const descendant = <T extends Element>(sugarElement: SugarElement<SizzleContext>, selector: string): Optional<SugarElement<T>> => {
     9|   const siz = Sizzle(selector, sugarElement.dom) as T[];
    10|   return toOptionEl(siz);
    11| };
    12| const toArrayEl = <T extends Node | Window>(elements: T[]): SugarElement<T>[] =>
    13|   Arr.map(elements, SugarElement.fromDom);
    14| /* Petrie makes extensive use of :visible, :has() and :contains() which are sizzle extensions */
    15| const descendants = <T extends Element>(sugarElement: SugarElement<SizzleContext>, selector: string): SugarElement<T>[] =>
    16|   toArrayEl(Sizzle(selector, sugarElement.dom) as T[]);
    17| const matches = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): sugarElement is SugarElement<T> =>
    18|   SugarNode.isElement(sugarElement) && Sizzle.matchesSelector(sugarElement.dom, selector);
    19| const child = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): Optional<SugarElement<T>> => {
    20|   const children = Traverse.children(sugarElement);
    21|   return Arr.find(children, (child): child is SugarElement<T> => matches(child, selector));
    22| };
    23| const children = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): SugarElement<T>[] => {
    24|   const children = Traverse.children(sugarElement);
    25|   return Arr.filter(children, (child): child is SugarElement<T> => matches(child, selector));
    26| };
    27| export {
    28|   descendant,
    29|   descendants,
    30|   matches,
    31|   child,
    32|   children
    33| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/ApproxStructure.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| import { Arr, Obj } from '@ephox/katamari';
     2| import { Attribute, Classes, Css, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
     3| import * as ApproxComparisons from '../assertions/ApproxComparisons';
     4| import * as ApproxStructures from '../assertions/ApproxStructures';
     5| type StringAssert = ApproxStructures.StringAssert;
     6| type ArrayAssert = ApproxStructures.ArrayAssert;
     7| type StructAssert = ApproxStructures.StructAssert;
     8| type StructAssertBasic = ApproxStructures.StructAssertBasic;
     9| type StructAssertAdv = ApproxStructures.StructAssertAdv;
    10| type CombinedAssert = ApproxComparisons.CombinedAssert;
    11| export type ArrayApi = typeof arrApi;
    12| export type StringApi = typeof strApi;
    13| export type StructApi = typeof structApi;
    14| export type Builder<T> = (struct: StructApi, str: StringApi, arr: ArrayApi) => T;
    15| const structApi = {
    16|   element: ApproxStructures.element,
    17|   text: ApproxStructures.text,
    18|   anything: ApproxStructures.anything,
    19|   either: ApproxStructures.either,
    20|   repeat: ApproxStructures.repeat,
    21|   zeroOrOne: ApproxStructures.zeroOrOne,
    22|   zeroOrMore: ApproxStructures.zeroOrMore,
    23|   oneOrMore: ApproxStructures.oneOrMore,
    24|   theRest: ApproxStructures.theRest
    25| };
    26| const strApi = {
    27|   is: ApproxComparisons.is,
    28|   startsWith: ApproxComparisons.startsWith,
    29|   contains: ApproxComparisons.contains,
    30|   none: ApproxComparisons.none
    31| };
    32| const arrApi = {
    33|   not: ApproxComparisons.not,
    34|   has: ApproxComparisons.has,
    35|   hasPrefix: ApproxComparisons.hasPrefix
    36| };
    37| const build = <T>(f: Builder<T>): T =>
    38|   f(structApi, strApi, arrApi);
    39| const getAttrsExcept = (node: SugarElement<Element>, exclude: string[]): Record<string, string> =>
    40|   Obj.bifilter(Attribute.clone(node), (value, key) => !Arr.contains(exclude, key)).t;
    41| const toAssertableObj = (obj: Record<string, string>): Record<string, CombinedAssert> =>
    42|   Obj.map(obj, ApproxComparisons.is);
    43| const toAssertableArr = (arr: string[]): (StringAssert & ArrayAssert)[] =>
    44|   Arr.map(arr, ApproxComparisons.has);
    45| const fromElement = (node: SugarElement<Node>): StructAssert => {
    46|   if (SugarNode.isElement(node)) {
    47|     return ApproxStructures.element(SugarNode.name(node), {
    48|       children: Arr.map(Traverse.children(node), fromElement),
    49|       attrs: toAssertableObj(getAttrsExcept(node, [ 'style', 'class' ])),
    50|       styles: toAssertableObj(Css.getAllRaw(node)),
    51|       classes: toAssertableArr(Classes.get(node))
    52|     });
    53|   } else {
    54|     return ApproxStructures.text(ApproxComparisons.is(SugarNode.value(node)), true);
    55|   }
    56| };
    57| const fromHtml = (html: string): StructAssertBasic | StructAssertAdv =>
    58|   fromElement(SugarElement.fromHtml(html));
    59| export {
    60|   build,
    61|   fromHtml,
    62|   fromElement
    63| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Arbitraries.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { SimRange, SugarElement } from '@ephox/sugar';
     2| import * as fc from 'fast-check';
     3| import * as ArbContent from '../arbitrary/ArbContent';
     4| import { SchemaDetail } from '../arbitrary/ArbSchemaTypes';
     5| import { SelectionExclusions } from '../arbitrary/GenSelection';
     6| import * as Generators from './Generators';
     7| const scenario = (
     8|   component: string,
     9|   overrides: Record<string, Partial<SchemaDetail>>,
    10|   exclusions: SelectionExclusions
    11| ): fc.Arbitrary<{ root: SugarElement<Node>; selection: SimRange }> => {
    12|   const arbitrary = content(component, overrides);
    13|   return arbitrary.chain((root) =>
    14|     Generators.selection(root, exclusions).map((selection) => ({
    15|       root,
    16|       selection
    17|     }))
    18|   );
    19| };
    20| const content = <T extends Node>(component: string, overrides?: Record<string, Partial<SchemaDetail>>): fc.Arbitrary<SugarElement<T>> =>
    21|   ArbContent.arbOf<T>(component, overrides);
    22| export {
    23|   scenario,
    24|   content
    25| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Assertions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| import { Assert, TestError, TestLabel } from '@ephox/bedrock-client';
     2| import { Obj, Optional } from '@ephox/katamari';
     3| import { Compare, SugarElement, Truncate } from '@ephox/sugar';
     4| import { elementQueue, StructAssert } from '../assertions/ApproxStructures';
     5| import * as Differ from '../assertions/Differ';
     6| import * as ApproxStructure from './ApproxStructure';
     7| import { Chain } from './Chain';
     8| import * as Logger from './Logger';
     9| import { Step } from './Step';
    10| import * as UiFinder from './UiFinder';
    11| const toStep = <U extends any[]>(method: (...args: U) => void) =>
    12|   <T>(...args: U) => Step.sync<T>(() => {
    13|     method.apply(undefined, args);
    14|   });
    15| const toChain = <B, C>(method: (label: TestLabel, expected: B, actual: C) => void) =>
    16|   (label: string, expected: B): Chain<C, C> =>
    17|     Chain.op<C>((actual: C) => {
    18|       method.call(undefined, label, expected, actual);
    19|     });
    20| const textError = (label: string, expected: string, actual: string): TestError.HtmlDiffAssertionError => {
    21|   const err: Partial<TestError.HtmlDiffAssertionError> = new Error(label);
    22|   err.diff = {
    23|     expected,
    24|     actual,
    25|     comparison: Differ.htmlDiff(expected, actual)
    26|   };
    27|   err.label = label;
    28|   err.name = 'HtmlAssertion';
    29|   return err as TestError.HtmlDiffAssertionError;
    30| };
    31| const assertHtml = (label: TestLabel, expected: string, actual: string): void => {
    32|   if (expected !== actual) {
    33|     throw textError(TestLabel.asString(label), expected, actual);
    34|   }
    35| };
    36| const assertStructure = (label: TestLabel, expected: StructAssert, container: SugarElement<Node>): void => {
    37|   Logger.sync(label, () => {
    38|     if (expected.type === 'advanced') {
    39|       expected.doAssert(elementQueue([ container ], Optional.none()));
    40|     } else {
    41|       expected.doAssert(container);
    42|     }
    43|   });
    44| };
    45| const assertHtmlStructure = (label: TestLabel, expected: string, actual: string): void => {
    46|   assertStructure(label, ApproxStructure.fromHtml(expected), SugarElement.fromHtml(actual));
    47| };
    48| const assertHtmlStructure2 = (label: TestLabel, expected: string, actual: SugarElement<Node>): void => {
    49|   assertStructure(label, ApproxStructure.fromHtml(expected), actual);
    50| };
    51| const assertPresence = (label: TestLabel, expected: Record<string, number>, container: SugarElement<Node>): void => {
    52|   Obj.each(expected, (num: number, selector: string) => {
    53|     const actual = UiFinder.findAllIn(container, selector).length;
    54|     Assert.eq(TestLabel.concat('Did not find ' + num + ' of ' + selector + ', found: ' + actual + '. Test: ', label), num, actual);
    55|   });
    56| };
    57| const assertEq = Assert.eq;
    58| const assertDomEq = (label: TestLabel, expected: SugarElement<Node>, actual: SugarElement<Node>): void => {
    59|   Assert.eq(
    60|     TestLabel.concat(label, () => '\nExpected : ' + Truncate.getHtml(expected) + '\nActual: ' + Truncate.getHtml(actual)),
    61|     true,
    62|     Compare.eq(expected, actual)
    63|   );
    64| };
    65| const sAssertEq: <T, V> (label: TestLabel, expected: V, actual: V) => Step<T, T> = toStep(Assert.eq);
    66| const sAssertHtml = toStep(assertHtml);
    67| const sAssertPresence = toStep(assertPresence);
    68| const sAssertStructure = toStep(assertStructure);
    69| const cAssertEq: <T> (label: string, expected: T) => Chain<T, T> = toChain(Assert.eq);
    70| const cAssertDomEq = toChain(assertDomEq);
    71| const cAssertHtml = toChain(assertHtml);
    72| const cAssertPresence = toChain(assertPresence);
    73| const cAssertHtmlStructure = toChain(assertHtmlStructure2);
    74| const cAssertStructure = toChain(assertStructure);
    75| export {
    76|   assertEq,
    77|   assertDomEq,
    78|   assertHtml,
    79|   assertPresence,
    80|   assertHtmlStructure,
    81|   assertStructure,
    82|   sAssertEq,
    83|   sAssertHtml,
    84|   sAssertPresence,
    85|   sAssertStructure,
    86|   cAssertEq,
    87|   cAssertDomEq,
    88|   cAssertHtml,
    89|   cAssertPresence,
    90|   cAssertHtmlStructure,
    91|   cAssertStructure
    92| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Chain.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-213 ---
     1| import { Failure } from '@ephox/bedrock-common';
     2| import { Arr, Fun, Result } from '@ephox/katamari';
     3| import * as AsyncActions from '../pipe/AsyncActions';
     4| import * as GeneralActions from '../pipe/GeneralActions';
     5| import { DieFn, NextFn, Pipe, RunFn } from '../pipe/Pipe';
     6| import { addLogging, GuardFn } from './Guard';
     7| import { Pipeline } from './Pipeline';
     8| import { Step } from './Step';
     9| import { addLogEntry, TestLogs } from './TestLogs';
    10| export interface Chain<T, U> {
    11|   runChain: RunFn<T, U>;
    12| }
    13| export type ChainGuard<T, U, V> = GuardFn<T, U, V>;
    14| const on = <T, U>(f: (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void): Chain<T, U> => {
    15|   const runChain = Pipe((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    16|     f(input, (v: U, newLogs) => {
    17|       next(v, newLogs);
    18|     }, (err, newLogs) => die(err, newLogs), logs);
    19|   });
    20|   return {
    21|     runChain
    22|   };
    23| };
    24| const control = <T, U, V>(chain: Chain<T, U>, guard: ChainGuard<T, U, V>): Chain<T, V> =>
    25|   on((input: T, next: NextFn<V>, die: DieFn, logs: TestLogs) => {
    26|     guard(chain.runChain, input, (v: V, newLogs: TestLogs) => {
    27|       next(v, newLogs);
    28|     }, die, logs);
    29|   });
    30| const mapper = <T, U>(fx: (value: T) => U): Chain<T, U> =>
    31|   on((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    32|     next(fx(input), logs);
    33|   });
    34| const identity = mapper(Fun.identity);
    35| const binder = <T, U, E>(fx: (input: T) => Result<U, E>): Chain<T, U> =>
    36|   on((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    37|     fx(input).fold((err) => {
    38|       die(err, logs);
    39|     }, (v) => {
    40|       next(v, logs);
    41|     });
    42|   });
    43| const op = <T>(fx: (value: T) => void): Chain<T, T> =>
    44|   on((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
    45|     fx(input);
    46|     next(input, logs);
    47|   });
    48| const async = <T, U>(fx: (input: T, next: (v: U) => void, die: (err) => void) => void): Chain<T, U> =>
    49|   on<T, U>((v, n, d, logs) => fx(v, (v) => n(v, logs), (err) => d(err, logs)));
    50| const inject = <T, U>(value: U): Chain<T, U> =>
    51|   on((_input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    52|     next(value, logs);
    53|   });
    54| const injectThunked = <T, U>(f: () => U): Chain<T, U> =>
    55|   on((_input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    56|     next(f(), logs);
    57|   });
    58| const extract = <T, U>(chain: Chain<T, U>): Step<T, U> => ({
    59|   runStep: chain.runChain
    60| });
    61| const fromChains = <T = any, U = any>(chains: Chain<any, any>[]): Chain<T, U> => {
    62|   const cs = Arr.map(chains, extract);
    63|   return on<T, U>((value, next, die, initLogs) => {
    64|     Pipeline.async(value, cs, (v, newLogs) => next(v, newLogs), die, initLogs);
    65|   });
    66| };
    67| const fromChainsWith = <T, U = any, V = any>(initial: T, chains: Chain<any, any>[]): Chain<U, V> =>
    68|   fromChains<U, V>(
    69|     [ inject(initial) ].concat(chains)
    70|   );
    71| const fromIsolatedChains = <T = any>(chains: Chain<any, any>[]): Chain<T, T> => {
    72|   const cs = Arr.map(chains, extract);
    73|   return on<T, T>((value, next, die, initLogs) => {
    74|     Pipeline.async(value, cs, (_v, newLogs) => {
    75|       next(value, newLogs);
    76|     }, die, initLogs);
    77|   });
    78| };
    79| const fromIsolatedChainsWith = <T, U = any>(initial: T, chains: Chain<any, any>[]): Chain<U, U> =>
    80|   fromIsolatedChains<U>(
    81|     [ inject(initial) ].concat(chains)
    82|   );
    83| const exists = <T, U>(chains: Chain<T, U>[]): Chain<T, U> => {
    84|   const cs = Arr.map(chains, extract);
    85|   let index = 0;
    86|   const attempt = (value: T, next: NextFn<U>, die: DieFn, initLogs: TestLogs): void => {
    87|     let replacementDie = die;
    88|     if (index + 1 < cs.length) {
    89|       replacementDie = () => {
    90|         index += 1;
    91|         attempt(value, next, die, initLogs);
    92|       };
    93|     }
    94|     Pipeline.runStep(value, cs[index], next, replacementDie, initLogs);
    95|   };
    96|   return on(attempt);
    97| };
    98| const fromParent = <T, U, V>(parent: Chain<T, U>, chains: Chain<U, V>[]): Chain<T, U> =>
    99|   on((cvalue: T, cnext: NextFn<U>, cdie: DieFn, clogs: TestLogs) => {
   100|     Pipeline.async(cvalue, [ extract(parent) ], (value: U, parentLogs: TestLogs) => {
   101|       const cs = Arr.map(chains, (c) =>
   102|         Step.raw((_, next, die, logs) => {
   103|           c.runChain(value, next, die, logs);
   104|         }));
   105|       Pipeline.async(cvalue, cs, (_, finalLogs) => {
   106|         cnext(value, finalLogs);
   107|       }, cdie, parentLogs);
   108|     }, cdie, clogs);
   109|   });
   110| /**
   111|  * @deprecated Use isolate() instead
   112|  * TODO: remove
   113|  */
   114| const asStep = <T, U>(initial: U, chains: Chain<any, any>[]): Step<T, T> =>
   115|   Step.raw<T, T>((initValue, next, die, logs) => {
   116|     const cs = Arr.map(chains, extract);
   117|     Pipeline.async(
   118|       initial,
   119|       cs,
   120|       (_v, ls) => {
   121|         next(initValue, ls);
   122|       },
   123|       die,
   124|       logs
   125|     );
   126|   });
   127| /**
   128|  * Wrap a Chain into an "isolated" Step, with its own local state.
   129|  * The state of the outer Step is passed-through.
   130|  * Use the functions in ChainSequence to compose multiple Chains.
   131|  *
   132|  * @param initial
   133|  * @param chain
   134|  */
   135| const isolate = <T, U, V>(initial: U, chain: Chain<U, V>): Step<T, T> =>
   136|   Step.raw<T, T>((initValue, next, die, logs) => {
   137|     Pipeline.runStep(
   138|       initial,
   139|       extract(chain),
   140|       (_v, ls) => {
   141|         next(initValue, ls);
   142|       },
   143|       die,
   144|       logs
   145|     );
   146|   });
   147| const debugging = op(GeneralActions.debug);
   148| const log = <T>(message: string): Chain<T, T> =>
   149|   on((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
   150|     console.log(message);
   151|     next(input, addLogEntry(logs, message));
   152|   });
   153| const label = <T, U>(label: string, chain: Chain<T, U>): Chain<T, U> =>
   154|   control(chain, addLogging(label));
   155| const wait = <T>(amount: number): Chain<T, T> =>
   156|   on<T, T>((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
   157|     AsyncActions.delay(amount)(() => next(input, logs), die);
   158|   });
   159| const pipeline = (chains: Chain<any, any>[], onSuccess: NextFn<any>, onFailure: DieFn, initLogs?: TestLogs): void => {
   160|   Pipeline.async({}, Arr.map(chains, extract), (output, logs) => {
   161|     onSuccess(output, logs);
   162|   }, onFailure, TestLogs.getOrInit(initLogs));
   163| };
   164| const runStepsOnValue = <I, O>(getSteps: (value: I) => Step<I, O>[]): Chain<I, O> =>
   165|   Chain.on((input: I, next, die, initLogs) => {
   166|     const steps = getSteps(input);
   167|     Pipeline.async(input, steps, (stepsOutput, newLogs) => next(stepsOutput, newLogs), die, initLogs);
   168|   });
   169| const predicate = <T>(p: (value: T) => boolean): Chain<T, T> =>
   170|   on((input, next, die, logs) =>
   171|     p(input) ? next(input, logs) : die('predicate did not succeed', logs));
   172| const toPromise = <A, B>(c: Chain<A, B>) => (a: A): Promise<B> =>
   173|   new Promise((resolve, reject) => {
   174|     c.runChain(a,
   175|       (b, _logs) => {
   176|         resolve(b);
   177|       }, (err, logs) => {
   178|         reject(Failure.prepFailure(err, logs));
   179|       },
   180|       TestLogs.init()
   181|     );
   182|   });
   183| const fromPromise = <A, B>(f: (a: A) => Promise<B>): Chain<A, B> => Chain.async((input, next, die) => {
   184|   f(input).then(next, die);
   185| });
   186| export const Chain = {
   187|   on,
   188|   op,
   189|   async,
   190|   control,
   191|   mapper,
   192|   identity,
   193|   binder,
   194|   runStepsOnValue,
   195|   inject,
   196|   injectThunked,
   197|   fromChains,
   198|   fromChainsWith,
   199|   fromIsolatedChains,
   200|   fromIsolatedChainsWith,
   201|   exists,
   202|   fromParent,
   203|   asStep,
   204|   isolate,
   205|   wait,
   206|   debugging,
   207|   log,
   208|   label,
   209|   toPromise,
   210|   fromPromise,
   211|   pipeline,
   212|   predicate
   213| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Clipboard.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| import { Arr, Obj } from '@ephox/katamari';
     2| import { SugarBody, SugarElement } from '@ephox/sugar';
     3| import { createCopyEvent, createCutEvent, createPasteEvent } from '../clipboard/ClipboardEvents';
     4| import { createDataTransfer } from '../datatransfer/DataTransfer';
     5| import { getWindowFromElement } from '../dragndrop/DndEvents';
     6| import { Chain } from './Chain';
     7| import * as ChainSequence from './ChainSequence';
     8| import { Step } from './Step';
     9| import { cFindIn } from './UiFinder';
    10| const pasteDataTransfer = (target: SugarElement<Element>, mutator: (dataTransfer: DataTransfer) => void): void => {
    11|   const win = getWindowFromElement(target);
    12|   const dataTransfer = createDataTransfer();
    13|   const event = createPasteEvent(win, 0, 0, dataTransfer);
    14|   mutator(dataTransfer);
    15|   target.dom.dispatchEvent(event);
    16| };
    17| const pasteItems = (target: SugarElement<Element>, items: Record<string, string>): void =>
    18|   pasteDataTransfer(target, (dataTransfer) => {
    19|     Obj.each(items, (data, mime) => {
    20|       dataTransfer.setData(mime, data);
    21|     });
    22|   });
    23| const pasteFiles = (target: SugarElement<Element>, files: File[]): void =>
    24|   pasteDataTransfer(target, (dataTransfer) => {
    25|     Arr.each(files, (file) => {
    26|       dataTransfer.items.add(file);
    27|     });
    28|   });
    29| const cPasteDataTransfer = <T extends Element>(mutator: (dataTransfer: DataTransfer) => void): Chain<SugarElement<T>, SugarElement<T>> =>
    30|   Chain.op((target) => pasteDataTransfer(target, mutator));
    31| const cPasteItems = <T extends Element>(items: Record<string, string>): Chain<SugarElement<T>, SugarElement<T>> =>
    32|   Chain.op((target) => pasteItems(target, items));
    33| const cPasteFiles = <T extends Element>(files: File[]): Chain<SugarElement<T>, SugarElement<T>> =>
    34|   Chain.op((target) => pasteFiles(target, files));
    35| const sPasteDataTransfer = <T>(mutator: (dataTransfer: DataTransfer) => void, selector: string): Step<T, T> =>
    36|   Chain.isolate({}, ChainSequence.sequence([
    37|     Chain.injectThunked(SugarBody.body),
    38|     cFindIn(selector),
    39|     cPasteDataTransfer(mutator)
    40|   ]));
    41| const sPasteItems = <T>(items: Record<string, string>, selector: string): Step<T, T> =>
    42|   Chain.isolate({}, ChainSequence.sequence([
    43|     Chain.injectThunked(SugarBody.body),
    44|     cFindIn(selector),
    45|     cPasteItems(items)
    46|   ]));
    47| const sPasteFiles = <T>(files: File[], selector: string): Step<T, T> =>
    48|   Chain.isolate({}, ChainSequence.sequence([
    49|     Chain.injectThunked(SugarBody.body),
    50|     cFindIn(selector),
    51|     cPasteFiles(files)
    52|   ]));
    53| const cut = (target: SugarElement<Element>): DataTransfer => {
    54|   const win = getWindowFromElement(target);
    55|   const dataTransfer = createDataTransfer();
    56|   const event = createCutEvent(win, 0, 0, dataTransfer);
    57|   target.dom.dispatchEvent(event);
    58|   return dataTransfer;
    59| };
    60| const copy = (target: SugarElement<Element>): DataTransfer => {
    61|   const win = getWindowFromElement(target);
    62|   const dataTransfer = createDataTransfer();
    63|   const event = createCopyEvent(win, 0, 0, dataTransfer);
    64|   target.dom.dispatchEvent(event);
    65|   return dataTransfer;
    66| };
    67| const cCut: Chain<SugarElement<Element>, DataTransfer> =
    68|   Chain.mapper(cut);
    69| const cCopy: Chain<SugarElement<Element>, DataTransfer> =
    70|   Chain.mapper(copy);
    71| export {
    72|   pasteDataTransfer,
    73|   pasteItems,
    74|   pasteFiles,
    75|   cPasteDataTransfer,
    76|   cPasteItems,
    77|   cPasteFiles,
    78|   sPasteDataTransfer,
    79|   sPasteItems,
    80|   sPasteFiles,
    81|   cut,
    82|   copy,
    83|   cCut,
    84|   cCopy
    85| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Cursors.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| import { Result } from '@ephox/katamari';
     2| import { Hierarchy, SugarElement } from '@ephox/sugar';
     3| import { Chain } from './Chain';
     4| export interface CursorRange {
     5|   readonly start: SugarElement<Node>;
     6|   readonly soffset: number;
     7|   readonly finish: SugarElement<Node>;
     8|   readonly foffset: number;
     9| }
    10| export interface CursorPath {
    11|   readonly startPath: number[];
    12|   readonly soffset: number;
    13|   readonly finishPath: number[];
    14|   readonly foffset: number;
    15| }
    16| const range = (obj: { start: SugarElement<Node>; soffset: number; finish: SugarElement<Node>; foffset: number }): CursorRange => ({
    17|   start: obj.start,
    18|   soffset: obj.soffset,
    19|   finish: obj.finish,
    20|   foffset: obj.foffset
    21| });
    22| const path = (obj: { startPath: number[]; soffset: number; finishPath: number[]; foffset: number }): CursorPath => ({
    23|   startPath: obj.startPath,
    24|   soffset: obj.soffset,
    25|   finishPath: obj.finishPath,
    26|   foffset: obj.foffset
    27| });
    28| export interface CursorSpec {
    29|   readonly element: number[];
    30|   readonly offset: number;
    31| }
    32| const pathFromCollapsed = (spec: CursorSpec): CursorPath =>
    33|   path({
    34|     startPath: spec.element,
    35|     soffset: spec.offset,
    36|     finishPath: spec.element,
    37|     foffset: spec.offset
    38|   });
    39| export interface RangeSpec {
    40|   readonly start: CursorSpec;
    41|   readonly finish?: CursorSpec;
    42| }
    43| const pathFromRange = (spec: RangeSpec): CursorPath => {
    44|   const finish = spec.finish !== undefined ? spec.finish : spec.start;
    45|   return path({
    46|     startPath: spec.start.element,
    47|     soffset: spec.start.offset,
    48|     finishPath: finish.element,
    49|     foffset: finish.offset
    50|   });
    51| };
    52| const isCursorSpec = (spec: CursorSpec | RangeSpec): spec is CursorSpec =>
    53|   !('start' in spec) && 'element' in spec;
    54| const pathFrom = (spec: CursorSpec | RangeSpec): CursorPath =>
    55|   isCursorSpec(spec) ? pathFromCollapsed(spec) : pathFromRange(spec);
    56| const follow = (container: SugarElement<Node>, calcPath: number[]): Result<SugarElement<Node>, string> =>
    57|   Hierarchy.follow(container, calcPath).fold(() =>
    58|     Result.error('Could not follow path: ' + calcPath.join(',')),
    59|   Result.value
    60|   );
    61| const followPath = (container: SugarElement<Node>, calcPath: CursorPath): Result<CursorRange, string> =>
    62|   follow(container, calcPath.startPath).bind((start) =>
    63|     follow(container, calcPath.finishPath).map((finish) =>
    64|       range({
    65|         start,
    66|         soffset: calcPath.soffset,
    67|         finish,
    68|         foffset: calcPath.foffset
    69|       })));
    70| const cFollowPath = (calcPath: CursorPath): Chain<SugarElement<Node>, CursorRange> =>
    71|   Chain.binder((container) => followPath(container, calcPath));
    72| const cFollowCursor = (elementPath: number[], offset: number): Chain<SugarElement<Node>, CursorRange> =>
    73|   Chain.binder((container) =>
    74|     follow(container, elementPath).map((element) =>
    75|       range({
    76|         start: element,
    77|         soffset: offset,
    78|         finish: element,
    79|         foffset: offset
    80|       })
    81|     )
    82|   );
    83| const cFollow = (elementPath: number[]): Chain<SugarElement<Node>, SugarElement<Node>> =>
    84|   Chain.binder((container) => follow(container, elementPath));
    85| const cToRange = Chain.mapper(range);
    86| const cToPath = Chain.mapper(path);
    87| const calculate = (container: SugarElement<Node>, calcPath: CursorPath): CursorRange =>
    88|   followPath(container, calcPath).getOrDie();
    89| const calculateOne = (container: SugarElement<Node>, calcPath: number[]): SugarElement<Node> =>
    90|   follow(container, calcPath).getOrDie();
    91| export {
    92|   range,
    93|   path,
    94|   pathFrom,
    95|   follow,
    96|   followPath,
    97|   cFollow,
    98|   cFollowPath,
    99|   cFollowCursor,
   100|   cToRange,
   101|   cToPath,
   102|   calculate,
   103|   calculateOne
   104| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/DragnDrop.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-120 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { Attribute, SugarBody, SugarElement, SugarNode } from '@ephox/sugar';
     3| import { createDataTransfer, getDragImage } from '../datatransfer/DataTransfer';
     4| import {
     5|   createDragendEvent, createDragenterEvent, createDragEvent, createDragoverEvent, createDragstartEvent, createDropEvent, dispatchDndEvent,
     6|   getWindowFromElement, isDefaultPrevented
     7| } from '../dragndrop/DndEvents';
     8| import { Chain } from './Chain';
     9| import { NamedChain } from './NamedChain';
    10| import { Step } from './Step';
    11| import * as UiFinder from './UiFinder';
    12| interface Item {
    13|   data: string;
    14|   type: string;
    15| }
    16| const isDraggable = (element: SugarElement<Element>): boolean => {
    17|   const name = SugarNode.name(element);
    18|   return (
    19|     name === 'img' ||
    20|     name === 'a' && Attribute.has(element, 'href') ||
    21|     Attribute.get(element, 'draggable') === 'true'
    22|   );
    23| };
    24| const checkDefaultPrevented = (evt: DragEvent): void => {
    25|   if (isDefaultPrevented(evt) === false) {
    26|     throw new Error(`preventDefault was not called on drag event: ${evt.type}`);
    27|   }
    28| };
    29| const checkNotDefaultPrevented = (evt: DragEvent): void => {
    30|   if (isDefaultPrevented(evt) === true) {
    31|     throw new Error(`preventDefault was called on drag event: ${evt.type}`);
    32|   }
    33| };
    34| const dragnDrop = (from: SugarElement<Element>, to: SugarElement<Element>, prevented: boolean = true): void => {
    35|   const fromWin = getWindowFromElement(from);
    36|   const toWin = getWindowFromElement(to);
    37|   const fromRect = from.dom.getBoundingClientRect();
    38|   const toRect = from.dom.getBoundingClientRect();
    39|   const transfer = createDataTransfer();
    40|   if (isDraggable(from) === false) {
    41|     throw new Error('Can not drag a non draggable element.');
    42|   }
    43|   const check = prevented ? checkDefaultPrevented : checkNotDefaultPrevented;
    44|   dispatchDndEvent(createDragstartEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
    45|   dispatchDndEvent(createDragEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
    46|   check(dispatchDndEvent(createDragenterEvent(toWin, toRect.left, toRect.top, transfer), to));
    47|   check(dispatchDndEvent(createDragoverEvent(toWin, toRect.left, toRect.top, transfer), to));
    48|   check(dispatchDndEvent(createDropEvent(toWin, toRect.left, toRect.top, transfer), to));
    49|   dispatchDndEvent(createDragendEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
    50| };
    51| const drop = (to: SugarElement<Element>, prevented: boolean, addItems: (transfer: DataTransfer) => void): void => {
    52|   const toWin = getWindowFromElement(to);
    53|   const toRect = to.dom.getBoundingClientRect();
    54|   const transfer = createDataTransfer();
    55|   addItems(transfer);
    56|   const check = prevented ? checkDefaultPrevented : checkNotDefaultPrevented;
    57|   dispatchDndEvent(createDragenterEvent(toWin, toRect.left, toRect.top, transfer), to);
    58|   dispatchDndEvent(createDragoverEvent(toWin, toRect.left, toRect.top, transfer), to);
    59|   check(dispatchDndEvent(createDropEvent(toWin, toRect.left, toRect.top, transfer), to));
    60| };
    61| const dropFiles = (files: File[], to: SugarElement<Element>, prevented: boolean = true): void => {
    62|   drop(to, prevented, (transfer) => {
    63|     Arr.each(files, (file) => {
    64|       transfer.items.add(file);
    65|     });
    66|   });
    67| };
    68| const dropItems = (items: Item[], to: SugarElement<Element>, prevented: boolean = true): void => {
    69|   drop(to, prevented, (transfer) => {
    70|     Arr.each(items, (item) => {
    71|       transfer.items.add(item.data, item.type);
    72|     });
    73|   });
    74| };
    75| const cDragnDrop = <T extends Element> (fromSelector: string, toSelector: string, prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> => NamedChain.asChain([
    76|   NamedChain.direct(NamedChain.inputName(), UiFinder.cFindIn(fromSelector), 'from'),
    77|   NamedChain.direct(NamedChain.inputName(), UiFinder.cFindIn(toSelector), 'to'),
    78|   Chain.op((obj) => dragnDrop(obj.from, obj.to, prevented)),
    79|   NamedChain.output(NamedChain.inputName())
    80| ]);
    81| const sDragnDrop = <T>(fromSelector: string, toSelector: string, prevented?: boolean): Step<T, T> =>
    82|   Chain.asStep(SugarBody.body(), [ cDragnDrop(fromSelector, toSelector, prevented) ]);
    83| const pDragnDrop = (fromSelector: string, toSelector: string, prevented?: boolean): Promise<SugarElement<HTMLElement>> =>
    84|   Chain.toPromise(cDragnDrop<HTMLElement>(fromSelector, toSelector, prevented))(SugarBody.body());
    85| const sDropFiles = <T>(files: File[], toSelector: string, prevented?: boolean): Step<T, T> => Chain.asStep(SugarBody.body(), [
    86|   UiFinder.cFindIn(toSelector),
    87|   cDropFiles(files, prevented)
    88| ]);
    89| const cDropFiles = <T extends Element> (files: File[], prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> =>
    90|   Chain.op((elm) => {
    91|     dropFiles(files, elm, prevented);
    92|   });
    93| const pDropFiles = <T extends Element> (elm: SugarElement<T>, files: File[], prevented?: boolean): Promise<SugarElement<T>> =>
    94|   Chain.toPromise(cDropFiles<T>(files, prevented))(elm);
    95| const sDropItems = <T> (items: Item[], toSelector: string, prevented?: boolean): Step<T, T> => Chain.asStep(SugarBody.body(), [
    96|   UiFinder.cFindIn(toSelector),
    97|   cDropItems(items, prevented)
    98| ]);
    99| const cDropItems = <T extends Element> (items: Item[], prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> =>
   100|   Chain.op((elm) => {
   101|     dropItems(items, elm, prevented);
   102|   });
   103| const pDropItems = <T extends Element> (elm: SugarElement<T>, items: Item[], prevented?: boolean): Promise<SugarElement<T>> =>
   104|   Chain.toPromise(cDropItems<T>(items, prevented))(elm);
   105| export {
   106|   isDraggable,
   107|   dragnDrop,
   108|   dropFiles,
   109|   dropItems,
   110|   cDragnDrop,
   111|   sDragnDrop,
   112|   pDragnDrop,
   113|   sDropFiles,
   114|   cDropFiles,
   115|   pDropFiles,
   116|   sDropItems,
   117|   cDropItems,
   118|   pDropItems,
   119|   getDragImage
   120| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/FocusTools.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-117 ---
     1| import { Result } from '@ephox/katamari';
     2| import { Compare, Focus, SugarElement, SugarShadowDom, Truncate } from '@ephox/sugar';
     3| import * as SizzleFind from '../alien/SizzleFind';
     4| import { Chain } from './Chain';
     5| import * as Guard from './Guard';
     6| import * as Logger from './Logger';
     7| import { Step } from './Step';
     8| import * as UiControls from './UiControls';
     9| import * as UiFinder from './UiFinder';
    10| import * as Waiter from './Waiter';
    11| const getFocused = <T extends HTMLElement>(doc: SugarElement<Document | ShadowRoot>): Result<SugarElement<T>, string> => {
    12|   return Focus.active<T>(doc).fold(
    13|     () => Result.error('Could not find active element'),
    14|     Result.value
    15|   );
    16| };
    17| const getActiveValue = (element: SugarElement<Node>): string | undefined => {
    18|   const doc = SugarShadowDom.getRootNode(element);
    19|   const focused = getFocused(doc).getOrDie();
    20|   return UiControls.getValue(focused as SugarElement<any>);
    21| };
    22| const setFocus = <T extends HTMLElement>(container: SugarElement<Node>, selector: string): SugarElement<T> => {
    23|   const elem = UiFinder.findIn<T>(container, selector).getOrDie();
    24|   Focus.focus(elem);
    25|   return elem;
    26| };
    27| const setActiveValue = (doc: SugarElement<Document | ShadowRoot>, newValue: string): SugarElement<HTMLElement> => {
    28|   const focused = getFocused(doc).getOrDie();
    29|   UiControls.setValue(focused as SugarElement<any>, newValue);
    30|   return focused;
    31| };
    32| const isOn = (label: string, element: SugarElement<Node>): SugarElement<HTMLElement> => {
    33|   const doc = SugarShadowDom.getRootNode(element);
    34|   return getFocused(doc).bind((active) => {
    35|     return Compare.eq(element, active) ? Result.value(active) : Result.error(
    36|       label + '\nExpected focus: ' + Truncate.getHtml(element) + '\nActual focus: ' + Truncate.getHtml(active)
    37|     );
    38|   }).getOrDie();
    39| };
    40| const isOnSelector = (label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): SugarElement<HTMLElement> => {
    41|   return getFocused(doc).bind((active) => {
    42|     return SizzleFind.matches(active, selector) ? Result.value(active) : Result.error(
    43|       label + '\nExpected focus $("' + selector + '")]\nActual focus: ' + Truncate.getHtml(active)
    44|     );
    45|   }).getOrDie();
    46| };
    47| const cGetFocused: Chain<SugarElement<Document | ShadowRoot>, SugarElement<HTMLElement>> =
    48|   Chain.binder(getFocused);
    49| const cGetRootNode: Chain<SugarElement<Node>, SugarElement<Document | ShadowRoot>> =
    50|   Chain.mapper(SugarShadowDom.getRootNode);
    51| const wrapInResult = <R>(f: () => R) => (): Result<R, string> => {
    52|   try {
    53|     return Result.value(f());
    54|   } catch (e) {
    55|     return Result.error(e.message);
    56|   }
    57| };
    58| const sIsOn = <T>(label: string, element: SugarElement<Node>): Step<T, T> =>
    59|   Chain.asStep<T, SugarElement<Node>>(element, [
    60|     Chain.binder(wrapInResult(() => isOn(label, element)))
    61|   ]);
    62| const sIsOnSelector = <T>(label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Step<T, T> =>
    63|   Logger.t(
    64|     `${label}: sIsOnSelector(${selector})`,
    65|     Chain.asStep<T, SugarElement<Document | ShadowRoot>>(doc, [
    66|       Chain.binder(wrapInResult(() => isOnSelector(label, doc, selector)))
    67|     ])
    68|   );
    69| const sTryOnSelector = <T>(label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Step<T, T> =>
    70|   Logger.t<T, T>(
    71|     label + '. Focus did not match: ' + selector,
    72|     Waiter.sTryUntil(
    73|       'Waiting for focus',
    74|       sIsOnSelector(label, doc, selector),
    75|       10, 4000
    76|     )
    77|   );
    78| const pTryOnSelector = (label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Promise<SugarElement<HTMLElement>> =>
    79|   Waiter.pTryUntil(label + '. Focus did not match: ' + selector, () => isOnSelector(label, doc, selector));
    80| const cSetFocus = <T extends Node, U extends HTMLElement>(label: string, selector: string): Chain<SugarElement<T>, SugarElement<U>> =>
    81|   Chain.control(
    82|     Chain.mapper((container) => setFocus<U>(container, selector)),
    83|     Guard.addLogging(label)
    84|   );
    85| const cSetActiveValue = (newValue: string): Chain<SugarElement<Node>, SugarElement<HTMLElement>> =>
    86|   Chain.fromChains([
    87|     cGetRootNode,
    88|     Chain.mapper((root) => setActiveValue(root, newValue))
    89|   ]);
    90| const cGetActiveValue: Chain<SugarElement<Node>, string> =
    91|   Chain.fromChains([
    92|     cGetRootNode,
    93|     cGetFocused,
    94|     UiControls.cGetValue
    95|   ]);
    96| const sSetFocus = <T>(label: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
    97|   Chain.asStep<T, SugarElement<Node>>(container, [ cSetFocus(label, selector) ]);
    98| const sSetActiveValue = <T>(doc: SugarElement<Document | ShadowRoot>, newValue: string): Step<T, T> =>
    99|   Step.sync(() => setActiveValue(doc, newValue));
   100| export {
   101|   getActiveValue,
   102|   setActiveValue,
   103|   setFocus,
   104|   getFocused,
   105|   isOn,
   106|   isOnSelector,
   107|   pTryOnSelector,
   108|   sSetActiveValue,
   109|   sSetFocus,
   110|   sIsOn,
   111|   sIsOnSelector,
   112|   sTryOnSelector,
   113|   cSetFocus,
   114|   cSetActiveValue,
   115|   cGetActiveValue,
   116|   cGetFocused
   117| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Generators.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| import { Hierarchy, Html, SimRange, SugarElement, Truncate } from '@ephox/sugar';
     2| import * as fc from 'fast-check';
     3| import * as GenSelection from '../arbitrary/GenSelection';
     4| import * as TagDecorator from '../arbitrary/TagDecorator';
     5| interface DescribedSimRange {
     6|   readonly selection: {
     7|     readonly startElement: string;
     8|     readonly startElementFull: string;
     9|     readonly startPath: number[];
    10|     readonly startOffset: number;
    11|     readonly finishElement: string;
    12|     readonly finishElementFull: string;
    13|     readonly finishPath: number[];
    14|     readonly finishOffset: number;
    15|   };
    16| }
    17| const selection = (container: SugarElement<Node>, exclusions: GenSelection.SelectionExclusions): fc.Arbitrary<SimRange> =>
    18|   GenSelection.selection(container, exclusions);
    19| const describeSelection = (root: SugarElement<Node>, generated: SimRange): DescribedSimRange | SimRange =>
    20|   Hierarchy.path(root, generated.start).bind((startPath) =>
    21|     Hierarchy.path(root, generated.finish).map((finishPath) => ({
    22|       selection: {
    23|         startElement: Truncate.getHtml(generated.start),
    24|         startElementFull: Html.getOuter(generated.start),
    25|         startPath,
    26|         startOffset: generated.soffset,
    27|         finishElement: Truncate.getHtml(generated.finish),
    28|         finishElementFull: Html.getOuter(generated.finish),
    29|         finishPath,
    30|         finishOffset: generated.foffset
    31|       }
    32|     }))).getOr(generated);
    33| const chooseOne = <T>(choices: TagDecorator.Decorator<T>[]): fc.Arbitrary<Record<string, T>> =>
    34|   TagDecorator.gOne(choices);
    35| const enforce = <T extends Record<string, string | number | boolean>>(attrs: T): fc.Arbitrary<T> =>
    36|   TagDecorator.gEnforce(attrs);
    37| const hexDigit = fc.constantFrom(...'0123456789abcdef'.split(''));
    38| const hexColor = fc.tuple(
    39|   hexDigit,
    40|   hexDigit,
    41|   hexDigit,
    42|   hexDigit,
    43|   hexDigit,
    44|   hexDigit
    45| ).map((digits) => [ '#' ].concat(digits).join(''));
    46| export {
    47|   selection,
    48|   describeSelection,
    49|   chooseOne,
    50|   enforce,
    51|   hexColor
    52| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Keyboard.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { Focus, SugarElement, Traverse } from '@ephox/sugar';
     3| import { keyevent, MixedKeyModifiers } from '../keyboard/FakeKeys';
     4| import { Step } from './Step';
     5| export type KeyModifiers = MixedKeyModifiers;
     6| /*
     7|   doc - document scope
     8|   value - which keycode
     9|   modifiers - { shift: BOOL, alt: BOOL }
    10|   dispatcher - dispatch event from some element
    11| */
    12| const fakeKeys = (types: string[]) => (value: number, modifiers: KeyModifiers = {}, dispatcher: SugarElement<Node>) => {
    13|   const doc = Traverse.owner(dispatcher);
    14|   Arr.each(types, (type) => {
    15|     keyevent(type, doc, value, modifiers, dispatcher);
    16|   });
    17| };
    18| const activeFakeKeys = (types: string[]) => (doc: SugarElement<Document | ShadowRoot>, value: number, modifiers: KeyModifiers = {}) => {
    19|   const focused = Focus.active(doc).getOrDie('Could not find active element');
    20|   fakeKeys(types)(value, modifiers, focused);
    21| };
    22| const sFakeKey = (types: string[]) => <T>(doc: SugarElement<Document | ShadowRoot>, keyvalue: number, modifiers: KeyModifiers = {}): Step<T, T> => Step.sync(() => {
    23|   activeFakeKeys(types)(doc, keyvalue, modifiers);
    24| });
    25| const keydownTypes = [ 'keydown' ];
    26| const keyupTypes = [ 'keyup' ];
    27| const keypressTypes = [ 'keypress' ];
    28| const keystrokeTypes = [ 'keydown', 'keyup' ];
    29| const keydown = fakeKeys(keydownTypes);
    30| const keyup = fakeKeys(keyupTypes);
    31| const keypress = fakeKeys(keypressTypes);
    32| const keystroke = fakeKeys(keystrokeTypes);
    33| const activeKeydown = activeFakeKeys(keydownTypes);
    34| const activeKeyup = activeFakeKeys(keyupTypes);
    35| const activeKeypress = activeFakeKeys(keypressTypes);
    36| const activeKeystroke = activeFakeKeys(keystrokeTypes);
    37| const sKeydown = sFakeKey(keydownTypes);
    38| const sKeyup = sFakeKey(keyupTypes);
    39| const sKeypress = sFakeKey(keypressTypes);
    40| const sKeystroke = sFakeKey(keystrokeTypes);
    41| export {
    42|   keydown,
    43|   keyup,
    44|   keypress,
    45|   keystroke,
    46|   activeKeydown,
    47|   activeKeyup,
    48|   activeKeypress,
    49|   activeKeystroke,
    50|   sKeydown,
    51|   sKeyup,
    52|   sKeypress,
    53|   sKeystroke
    54| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Main.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-76 ---
     1| import { StructAssert, StructAssertAdv, StructAssertBasic } from '../assertions/ApproxStructures';
     2| import * as ApproxStructure from './ApproxStructure';
     3| import * as Arbitraries from './Arbitraries';
     4| import * as Assertions from './Assertions';
     5| import { Chain } from './Chain';
     6| import * as ChainSequence from './ChainSequence';
     7| import { Cleaner } from './Cleaner';
     8| import * as Clipboard from './Clipboard';
     9| import * as Cursors from './Cursors';
    10| import * as DragnDrop from './DragnDrop';
    11| import * as FileInput from './FileInput';
    12| import * as Files from './Files';
    13| import * as FocusTools from './FocusTools';
    14| import * as GeneralSteps from './GeneralSteps';
    15| import * as Generators from './Generators';
    16| import { GroupStore } from './GroupStore';
    17| import * as Guard from './Guard';
    18| import * as Keyboard from './Keyboard';
    19| import { Keys } from './Keys';
    20| import * as Log from './Log';
    21| import * as Logger from './Logger';
    22| import { Monitor } from './Monitor';
    23| import * as Mouse from './Mouse';
    24| import { NamedChain } from './NamedChain';
    25| import { Pipeline } from './Pipeline';
    26| import * as PropertySteps from './PropertySteps';
    27| import * as RealClipboard from './RealClipboard';
    28| import { RealKeys } from './RealKeys';
    29| import * as RealMouse from './RealMouse';
    30| import { Step } from './Step';
    31| import * as StepSequence from './StepSequence';
    32| import { TestLogs } from './TestLogs';
    33| import * as Touch from './Touch';
    34| import * as UiControls from './UiControls';
    35| import * as UiFinder from './UiFinder';
    36| import * as Waiter from './Waiter';
    37| export {
    38|   ApproxStructure,
    39|   Arbitraries,
    40|   Assertions,
    41|   Chain,
    42|   ChainSequence,
    43|   Cleaner,
    44|   Clipboard,
    45|   Cursors,
    46|   FocusTools,
    47|   GeneralSteps,
    48|   StepSequence,
    49|   Generators,
    50|   GroupStore,
    51|   Guard,
    52|   Keyboard,
    53|   Keys,
    54|   Log,
    55|   Logger,
    56|   Monitor,
    57|   Mouse,
    58|   NamedChain,
    59|   Pipeline,
    60|   PropertySteps,
    61|   RealClipboard,
    62|   RealKeys,
    63|   RealMouse,
    64|   Step,
    65|   TestLogs,
    66|   UiControls,
    67|   UiFinder,
    68|   Waiter,
    69|   Touch,
    70|   StructAssert,
    71|   StructAssertBasic,
    72|   StructAssertAdv,
    73|   DragnDrop,
    74|   Files,
    75|   FileInput
    76| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Mouse.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-140 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { Focus, SugarElement } from '@ephox/sugar';
     3| import * as Clicks from '../mouse/Clicks';
     4| import { Chain } from './Chain';
     5| import { Step } from './Step';
     6| import * as UiFinder from './UiFinder';
     7| const click = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.click(settings)(element);
     8| const mouseOver = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseOver(settings)(element);
     9| const mouseDown = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseDown(settings)(element);
    10| const mouseUp = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseUp(settings)(element);
    11| const mouseMove = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseMove(settings)(element);
    12| const mouseOut = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseOut(settings)(element);
    13| const mouseMoveTo = (element: SugarElement<Node>, dx: number, dy: number, settings: Omit<Clicks.Settings, 'dx' | 'dy'> = { }): void =>
    14|   Clicks.mouseMove({ ...settings, dx, dy })(element);
    15| const mouseUpTo = (element: SugarElement<Node>, dx: number, dy: number, settings: Omit<Clicks.Settings, 'dx' | 'dy'> = { }): void =>
    16|   Clicks.mouseUp({ ...settings, dx, dy })(element);
    17| const cClickWith = Fun.compose(Chain.op, Clicks.click);
    18| const cContextMenuWith = Fun.compose(Chain.op, Clicks.contextMenu);
    19| const cMouseOverWith = Fun.compose(Chain.op, Clicks.mouseOver);
    20| const cMouseDownWith = Fun.compose(Chain.op, Clicks.mouseDown);
    21| const cMouseUpWith = Fun.compose(Chain.op, Clicks.mouseUp);
    22| const cMouseMoveWith = Fun.compose(Chain.op, Clicks.mouseMove);
    23| const cMouseOutWith = Fun.compose(Chain.op, Clicks.mouseOut);
    24| /**
    25|  * @deprecated use cMouseUpWith({ dx, dy }) instead */
    26| const cMouseUpTo = (dx: number, dy: number): Chain<SugarElement<Node>, SugarElement<Node>> => cMouseUpWith({ dx, dy });
    27| /**
    28|  * @deprecated use cMouseMoveWith({ dx, dy }) instead */
    29| const cMouseMoveTo = (dx: number, dy: number): Chain<SugarElement<Node>, SugarElement<Node>> => cMouseMoveWith({ dx, dy });
    30| /**
    31|  * @deprecated use cClickWith({ }) instead*/
    32| const cClick = cClickWith({ });
    33| /**
    34|  * @deprecated use cContextMenuWith({ }) instead */
    35| const cContextMenu = cContextMenuWith({ });
    36| /**
    37|  * @deprecated use cMouseOverWith({ }) instead */
    38| const cMouseOver = cMouseOverWith({ });
    39| /**
    40|  * @deprecated use cMouseDownWith({ }) instead */
    41| const cMouseDown = cMouseDownWith({ });
    42| /**
    43|  * @deprecated use cMouseUpWith({ }) instead */
    44| const cMouseUp = cMouseUpWith({ });
    45| /**
    46|  * @deprecated use cMouseMoveWith({ }) instead */
    47| const cMouseMove = cMouseMoveWith({ });
    48| /**
    49|  * @deprecated use cMouseOutWith({ }) instead */
    50| const cMouseOut = cMouseOutWith({ });
    51| const triggerOn = <T extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<T>) => void): SugarElement<T> => {
    52|   const ele = UiFinder.findIn<T>(container, selector).getOrDie();
    53|   action(ele);
    54|   return ele;
    55| };
    56| const sTriggerOn = <T, U extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<U>) => void) =>
    57|   Step.sync<T>(() => triggerOn(container, selector, action));
    58| const clickOn = <T extends HTMLElement>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
    59|   triggerOn<T>(container, selector, Clicks.trigger);
    60| const hoverOn = <T extends Element>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
    61|   triggerOn<T>(container, selector, mouseOver);
    62| const contextMenuOn = <T extends Element>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
    63|   triggerOn<T>(container, selector, Clicks.contextMenu({ }));
    64| const sClickOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    65|   sTriggerOn<T, Element>(container, selector, Clicks.trigger);
    66| const sHoverOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    67|   sTriggerOn<T, Element>(container, selector, Clicks.mouseOver({ }));
    68| const sContextMenuOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    69|   sTriggerOn<T, Element>(container, selector, Clicks.contextMenu({ }));
    70| const cClickOn = <T>(selector: string): Chain<SugarElement<T>, SugarElement<T>> => Chain.fromIsolatedChains([
    71|   UiFinder.cFindIn(selector),
    72|   cClick
    73| ]);
    74| const trueClick = (elem: SugarElement<HTMLElement>): void => {
    75|   Focus.focus(elem);
    76|   mouseDown(elem);
    77|   mouseUp(elem);
    78|   Clicks.trigger(elem);
    79| };
    80| const trueClickOn = (container: SugarElement<Node>, selector: string): void => {
    81|   triggerOn(container, selector, trueClick);
    82| };
    83| const cTrueClick = Chain.op(trueClick);
    84| const sTrueClickOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    85|   sTriggerOn<T, HTMLElement>(container, selector, trueClick);
    86| const leftClickButton = Clicks.leftClickButton ;
    87| const middleClickButton = Clicks.middleClickButton ;
    88| const rightClickButton = Clicks.rightClickButton ;
    89| const leftClickButtons = Clicks.leftClickButtons ;
    90| const rightClickButtons = Clicks.rightClickButtons ;
    91| const middleClickButtons = Clicks.middleClickButtons ;
    92| /**
    93|  * @deprecated Use event instead */
    94| const point = Clicks.point;
    95| const event = Clicks.event;
    96| export {
    97|   cClickWith,
    98|   cContextMenuWith,
    99|   cMouseOverWith,
   100|   cMouseDownWith,
   101|   cMouseUpWith,
   102|   cMouseMoveWith,
   103|   cMouseOutWith,
   104|   cClick,
   105|   cContextMenu,
   106|   cMouseOver,
   107|   cMouseDown,
   108|   cMouseUp,
   109|   cMouseMove,
   110|   cMouseOut,
   111|   cMouseUpTo,
   112|   cMouseMoveTo,
   113|   sClickOn,
   114|   sHoverOn,
   115|   sContextMenuOn,
   116|   cClickOn,
   117|   trueClick,
   118|   trueClickOn,
   119|   cTrueClick,
   120|   sTrueClickOn,
   121|   leftClickButton,
   122|   middleClickButton,
   123|   rightClickButton,
   124|   leftClickButtons,
   125|   rightClickButtons,
   126|   middleClickButtons,
   127|   click,
   128|   mouseOver,
   129|   mouseDown,
   130|   mouseUp,
   131|   mouseUpTo,
   132|   mouseMove,
   133|   mouseMoveTo,
   134|   mouseOut,
   135|   clickOn,
   136|   contextMenuOn,
   137|   hoverOn,
   138|   point,
   139|   event
   140| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/RealClipboard.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| import { PlatformDetection } from '@ephox/sand';
     2| import { KeyModifiers } from '../keyboard/FakeKeys';
     3| import * as SeleniumAction from '../server/SeleniumAction';
     4| import { RealKeys } from './RealKeys';
     5| import { Step } from './Step';
     6| const platform = PlatformDetection.detect();
     7| const pImportToClipboard = (filename: string): Promise<{}> =>
     8|   SeleniumAction.pPerform('/clipboard', {
     9|     import: filename
    10|   });
    11| const sImportToClipboard = <T>(filename: string): Step<T, T> =>
    12|   Step.fromPromise(() => pImportToClipboard(filename));
    13| const pCopy = (selector: string): Promise<{}> => {
    14|   const modifiers: KeyModifiers = platform.os.isMacOS() ? { metaKey: true } : { ctrlKey: true };
    15|   return RealKeys.pSendKeysOn(selector, [
    16|     RealKeys.combo(modifiers, 'c')
    17|   ]);
    18| };
    19| const sCopy = <T>(selector: string): Step<T, T> =>
    20|   Step.fromPromise<T>(() => pCopy(selector));
    21| const pPaste = (selector: string): Promise<{}> => {
    22|   const modifiers: KeyModifiers = platform.os.isMacOS() ? { metaKey: true } : { ctrlKey: true };
    23|   return RealKeys.pSendKeysOn(selector, [
    24|     RealKeys.combo(modifiers, 'v')
    25|   ]);
    26| };
    27| const sPaste = <T>(selector: string): Step<T, T> =>
    28|   Step.fromPromise(() => pPaste(selector));
    29| export {
    30|   pImportToClipboard,
    31|   pCopy,
    32|   pPaste,
    33|   sImportToClipboard,
    34|   sCopy,
    35|   sPaste
    36| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Step.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| import { Failure } from '@ephox/bedrock-common';
     2| import * as AsyncActions from '../pipe/AsyncActions';
     3| import * as GeneralActions from '../pipe/GeneralActions';
     4| import { DieFn, NextFn, Pipe, RunFn } from '../pipe/Pipe';
     5| import { addLogging, GuardFn } from './Guard';
     6| import { addLogEntry, TestLogs } from './TestLogs';
     7| export interface Step<T, U> {
     8|   runStep: (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void;
     9| }
    10| const raw = <T, U>(f: RunFn<T, U>): Step<T, U> =>
    11|   ({ runStep: Pipe(f) });
    12| const stateful = <T, U>(f: (v: T, next: (v: U) => void, die: (err) => void) => void): Step<T, U> =>
    13|   raw<T, U>((value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
    14|     f(
    15|       value,
    16|       (nextValue: U) => next(nextValue, logs),
    17|       (err) => die(err, logs)
    18|     );
    19|   });
    20| const control = <T, U, V>(step: Step<T, U>, guard: GuardFn<T, U, V>): Step<T, V> =>
    21|   raw<T, V>((value: T, next: NextFn<V>, die: DieFn, logs: TestLogs) => {
    22|     guard(step.runStep, value, next, die, logs);
    23|   });
    24| const sync = <T>(f: () => void): Step<T, T> =>
    25|   raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
    26|     f();
    27|     next(value, logs);
    28|   });
    29| const async = <T>(f: (next: () => void, die: (err) => void) => void): Step<T, T> =>
    30|   raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
    31|     f(
    32|       () => next(value, logs),
    33|       (err) => die(err, logs)
    34|     );
    35|   });
    36| const debugging: Step<any, any> =
    37|   sync<any>(GeneralActions.debug);
    38| const log = <T>(message: string): Step<T, T> =>
    39|   raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
    40|     console.log(message);
    41|     next(value, addLogEntry(logs, message));
    42|   });
    43| const label = <T, U>(label: string, chain: Step<T, U>): Step<T, U> =>
    44|   control(chain, addLogging(label));
    45| const wait = <T>(amount: number): Step<T, T> =>
    46|   async(AsyncActions.delay(amount));
    47| const fail = <T>(message: string): Step<T, T> =>
    48|   async(AsyncActions.fail(message));
    49| const pass: Step<any, any> = sync<any>(GeneralActions.pass);
    50| const predicate = <T>(p: (value: T) => boolean): Step<T, T> =>
    51|   stateful((value: T, next, die) => {
    52|     p(value) ? next(value) : die('predicate did not succeed');
    53|   });
    54| const toPromise = <A, B>(step: Step<A, B>) => (a: A): Promise<B> => {
    55|   return new Promise(((resolve, reject) => {
    56|     step.runStep(a,
    57|       (b, _logs) => {
    58|         resolve(b);
    59|       }, (err, logs) => {
    60|         reject(Failure.prepFailure(err, logs));
    61|       },
    62|       TestLogs.init()
    63|     );
    64|   }));
    65| };
    66| const fromPromise = <T>(p: () => Promise<unknown>): Step<T, T> => Step.async<T>((next, die) => {
    67|   p().then(next, die);
    68| });
    69| export const Step = {
    70|   stateful,
    71|   control,
    72|   sync,
    73|   async,
    74|   debugging,
    75|   log,
    76|   label,
    77|   wait,
    78|   fail,
    79|   pass,
    80|   raw,
    81|   predicate,
    82|   toPromise,
    83|   fromPromise
    84| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/Touch.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-75 ---
     1| import { Focus, SugarElement } from '@ephox/sugar';
     2| import * as Touches from '../touch/Touches';
     3| import { Chain } from './Chain';
     4| import { Step } from './Step';
     5| import * as UiFinder from './UiFinder';
     6| const touchStart = Touches.touchstart;
     7| const touchStartAt = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchstartAt(dx, dy)(element);
     8| const touchEnd = Touches.touchend;
     9| const touchEndAt = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchendAt(dx, dy)(element);
    10| const touchMove = Touches.touchmove;
    11| const touchMoveTo = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchmoveTo(dx, dy)(element);
    12| const cTrigger = <T extends Node, U extends Element>(selector: string, action: (ele: SugarElement<U>) => void) =>
    13|   Chain.async<SugarElement<T>, SugarElement<T>>((container, next, die) => {
    14|     UiFinder.findIn<U>(container, selector).fold(
    15|       () => die('Could not find element: ' + selector),
    16|       (ele) => {
    17|         action(ele);
    18|         next(container);
    19|       }
    20|     );
    21|   });
    22| const sTriggerWith = <T, U extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<U>) => void) =>
    23|   Chain.asStep<T, SugarElement<Node>>(container, [ cTrigger<Node, U>(selector, action) ]);
    24| const trueTap = (elem: SugarElement<HTMLElement>): void => {
    25|   Focus.focus(elem);
    26|   Touches.touchstart(elem);
    27|   Touches.touchend(elem);
    28| };
    29| const tap = (elem: SugarElement<Node>): void => {
    30|   Touches.touchstart(elem);
    31|   Touches.touchend(elem);
    32| };
    33| const sTap = <T>(element: SugarElement<Node>): Step<T, T> =>
    34|   Step.sync<T>(() => tap(element));
    35| const sTrueTapOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    36|   sTriggerWith<T, HTMLElement>(container, selector, trueTap);
    37| const sTapOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    38|   sTriggerWith<T, Element>(container, selector, tap);
    39| const cTapOn = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
    40|   cTrigger(selector, tap);
    41| const cTouchStartAt = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
    42|   Chain.op<SugarElement<T>>(Touches.touchstartAt(dx, dy));
    43| const cTouchEndAt = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
    44|   Chain.op<SugarElement<T>>(Touches.touchendAt(dx, dy));
    45| const cTouchMoveTo = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
    46|   Chain.op<SugarElement<T>>(Touches.touchmoveTo(dx, dy));
    47| const point = Touches.point;
    48| const cTrueTap = Chain.op(trueTap);
    49| const cTap = Chain.op(tap);
    50| const cTouchMove = Chain.op(Touches.touchmove);
    51| const cTouchStart = Chain.op(Touches.touchstart);
    52| const cTouchEnd = Chain.op(Touches.touchend);
    53| export {
    54|   point,
    55|   tap,
    56|   trueTap,
    57|   touchStart,
    58|   touchStartAt,
    59|   touchEnd,
    60|   touchEndAt,
    61|   touchMove,
    62|   touchMoveTo,
    63|   sTap,
    64|   sTapOn,
    65|   sTrueTapOn,
    66|   cTap,
    67|   cTapOn,
    68|   cTrueTap,
    69|   cTouchStart,
    70|   cTouchStartAt,
    71|   cTouchMove,
    72|   cTouchMoveTo,
    73|   cTouchEnd,
    74|   cTouchEndAt
    75| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/UiControls.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| import { Type } from '@ephox/katamari';
     2| import { SugarElement, Value } from '@ephox/sugar';
     3| import { Chain } from './Chain';
     4| import { Step } from './Step';
     5| import * as UiFinder from './UiFinder';
     6| type TogglableElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | HTMLOptionElement | HTMLButtonElement;
     7| const fireEvent = (elem: SugarElement<Node>, event: string) => {
     8|   const evt = new Event(event, {
     9|     bubbles: true,
    10|     cancelable: true
    11|   });
    12|   elem.dom.dispatchEvent(evt);
    13| };
    14| const setValue = (element: SugarElement<TogglableElement>, newValue: string, eventName?: string): void => {
    15|   Value.set(element, newValue);
    16|   if (Type.isNonNullable(eventName)) {
    17|     fireEvent(element, eventName);
    18|   }
    19| };
    20| const setValueOn = (container: SugarElement<Node>, selector: string, newValue: string, eventName?: string): void => {
    21|   const element = UiFinder.findIn<TogglableElement>(container, selector).getOrDie();
    22|   setValue(element, newValue, eventName);
    23| };
    24| const getValue = (element: SugarElement<TogglableElement>): string => Value.get(element);
    25| const cSetValue = <T extends TogglableElement>(newValue: string): Chain<SugarElement<T>, SugarElement<T>> =>
    26|   Chain.op((element) => {
    27|     setValue(element, newValue);
    28|   });
    29| const cGetValue: Chain<SugarElement<TogglableElement>, string> =
    30|   Chain.mapper(getValue);
    31| const sSetValue = <T>(element: SugarElement<TogglableElement>, newValue: string): Step<T, T> =>
    32|   Step.sync(() => setValue(element, newValue));
    33| const sSetValueOn = <T>(container: SugarElement<Node>, selector: string, newValue: string): Step<T, T> =>
    34|   Step.sync(() => setValueOn(container, selector, newValue));
    35| export {
    36|   setValue,
    37|   setValueOn,
    38|   getValue,
    39|   sSetValueOn,
    40|   sSetValue,
    41|   cSetValue,
    42|   cGetValue
    43| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/api/UiFinder.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-96 ---
     1| import { Fun, Result } from '@ephox/katamari';
     2| import { SugarElement, Truncate, Visibility } from '@ephox/sugar';
     3| import * as UiSearcher from '../find/UiSearcher';
     4| import { Chain } from './Chain';
     5| import * as Guard from './Guard';
     6| import { Step } from './Step';
     7| const findIn = UiSearcher.findIn;
     8| const findAllIn = UiSearcher.findAllIn;
     9| const exists = (container: SugarElement<Node>, selector: string): void => {
    10|   findIn(container, selector).fold(
    11|     () => {
    12|       throw new Error('Expected ' + selector + ' to exist.');
    13|     },
    14|     Fun.noop
    15|   );
    16| };
    17| const notExists = (container: SugarElement<Node>, selector: string): void => {
    18|   return findIn(container, selector).fold(
    19|     Fun.noop,
    20|     () => {
    21|       throw new Error('Expected ' + selector + ' not to exist.');
    22|     }
    23|   );
    24| };
    25| const cWaitFor = <T extends Element>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
    26|   cWaitForState(message, selector, Fun.always);
    27| const sWaitFor = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
    28|   Chain.asStep<T, SugarElement<Node>>(container, [ cWaitFor(message, selector) ]);
    29| const cWaitForVisible = <T extends HTMLElement>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
    30|   cWaitForState<T>(message, selector, Visibility.isVisible);
    31| const cWaitForHidden = <T extends HTMLElement>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
    32|   cWaitForState<T>(message, selector, Fun.not(Visibility.isVisible));
    33| const sWaitForVisible = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
    34|   Chain.asStep<T, SugarElement<Node>>(container, [ cWaitForVisible(message, selector) ]);
    35| const sWaitForHidden = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
    36|   Chain.asStep<T, SugarElement<Node>>(container, [ cWaitForHidden(message, selector) ]);
    37| const cHasState = <T extends Node> (predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<T>, SugarElement<T>> =>
    38|   Chain.binder((element) => predicate(element) ? Result.value(element) :
    39|     Result.error(Truncate.getHtml(element) + ' did not match predicate: ' + predicate.toString()));
    40| const cFindWithState = <T extends Element>(selector: string, predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<Node>, SugarElement<T>> =>
    41|   Chain.fromChains([
    42|     cFindIn(selector),
    43|     cHasState(predicate)
    44|   ]);
    45| const cWaitForState = <T extends Element>(message: string, selector: string, predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<Node>, SugarElement<T>> =>
    46|   Chain.control(
    47|     cFindWithState(selector, predicate),
    48|     Guard.tryUntil(message, 10, 10000)
    49|   );
    50| const sExists = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    51|   Step.sync<T>(() => exists(container, selector));
    52| const sNotExists = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
    53|   Step.sync<T>(() => notExists(container, selector));
    54| const cExists = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
    55|   Chain.op((container) => exists(container, selector));
    56| const cNotExists = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
    57|   Chain.op((container) => notExists(container, selector));
    58| const cFindIn = (selector: string): Chain<SugarElement<Node>, SugarElement<Element>> =>
    59|   Chain.binder((container) =>
    60|     findIn(container, selector)
    61|   );
    62| const cFindAllIn = <T extends Element>(selector: string): Chain<SugarElement<Node>, SugarElement<T>[]> =>
    63|   Chain.mapper((container) =>
    64|     findAllIn(container, selector)
    65|   );
    66| const pWaitFor = <T extends Element>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
    67|   Chain.toPromise(cWaitFor<T>(message, selector))(container);
    68| const pWaitForVisible = <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
    69|   Chain.toPromise(cWaitForVisible<T>(message, selector))(container);
    70| const pWaitForHidden = <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
    71|   Chain.toPromise(cWaitForHidden<T>(message, selector))(container);
    72| const pWaitForState = <T extends Element>(message: string, container: SugarElement<Node>, selector: string, predicate: (element: SugarElement<T>) => boolean): Promise<SugarElement<T>> =>
    73|   Chain.toPromise(cWaitForState(message, selector, predicate))(container);
    74| export {
    75|   findIn,
    76|   findAllIn,
    77|   exists,
    78|   notExists,
    79|   sExists,
    80|   sNotExists,
    81|   sWaitFor,
    82|   sWaitForVisible,
    83|   sWaitForHidden,
    84|   cExists,
    85|   cNotExists,
    86|   cWaitFor,
    87|   cWaitForVisible,
    88|   cWaitForHidden,
    89|   cWaitForState,
    90|   cFindIn,
    91|   cFindAllIn,
    92|   pWaitFor,
    93|   pWaitForVisible,
    94|   pWaitForHidden,
    95|   pWaitForState
    96| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/ArbChildrenSchema.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| import { Arr, Fun, Merger, Obj } from '@ephox/katamari';
     2| import * as fc from 'fast-check';
     3| import * as WeightedChoice from './WeightedChoice';
     4| type WeightedItem = WeightedChoice.WeightedItem;
     5| interface ChanceItem {
     6|   readonly chance: number;
     7| }
     8| interface Detail<T> {
     9|   readonly components: Record<string, T>;
    10| }
    11| export interface CompositeDetail extends Detail<WeightedItem> {
    12|   readonly recursionDepth?: number;
    13| }
    14| export interface StructureDetail extends Detail<ChanceItem> {}
    15| type Component<T> = T & {
    16|   readonly component?: string;
    17| };
    18| export type Construct<T> = (component: string, depth: number) => fc.Arbitrary<T>;
    19| const skipChild = '_';
    20| const toComponents = <T>(detail: Detail<T>): Component<T>[] =>
    21|   Obj.mapToArray(detail.components, (v, k) =>
    22|     k !== skipChild ? Merger.deepMerge(v, { component: k }) : v
    23|   );
    24| const none = fc.constant([]);
    25| const composite = <T>(rawDepth: number | undefined, detail: CompositeDetail, construct: Construct<T>): fc.Arbitrary<T[]> => {
    26|   const components = toComponents(detail);
    27|   const depth = rawDepth ?? detail.recursionDepth;
    28|   if (depth === 0) {
    29|     return none;
    30|   } else {
    31|     const genComponent = (choice: Component<WeightedItem>, depth: number | undefined) => {
    32|       const newDepth = choice.useDepth === true ? depth - 1 : depth;
    33|       return fc.array(construct(choice.component, newDepth), { minLength: 1, maxLength: 5 });
    34|     };
    35|     const repeat = WeightedChoice.generator(components).chain((choice) =>
    36|       choice.fold(
    37|         Fun.constant(none),
    38|         (c) => genComponent(c, depth)
    39|       )
    40|     );
    41|     return fc.array(repeat, { minLength: 1, maxLength: 5 }).map(Arr.flatten);
    42|   }
    43| };
    44| const structure = <T>(rawDepth: number | undefined, detail: StructureDetail, construct: Construct<T>): fc.Arbitrary<T[]> => {
    45|   const components = toComponents(detail);
    46|   return fc.float({ min: 0, max: 1 }).chain((random) => {
    47|     const children = Arr.foldl<Component<ChanceItem>, fc.Arbitrary<T>[]>(
    48|       components,
    49|       (b, component) =>
    50|         random <= component.chance ?
    51|           b.concat([ construct(component.component, rawDepth) ]) :
    52|           b,
    53|       []
    54|     );
    55|     return fc.tuple(...children);
    56|   });
    57| };
    58| export {
    59|   none,
    60|   composite,
    61|   structure
    62| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/ArbContent.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| import { Merger, Obj } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as fc from 'fast-check';
     4| import { ArbSchema } from './ArbSchema';
     5| import { Schema, SchemaDetail } from './ArbSchemaTypes';
     6| import * as ArbSchemaTypes from './ArbSchemaTypes';
     7| interface ContentSchema {
     8|   [key: string]: <T extends Node>(rawDepth: number | undefined) => fc.Arbitrary<SugarElement<T>>;
     9| }
    10| const unknownDepth = undefined;
    11| const makeArbOf = <T extends Node>(component: string, schema: ContentSchema, depth: number | undefined): fc.Arbitrary<SugarElement<T>> => {
    12|   const arbitrary = schema[component];
    13|   if (arbitrary === undefined) {
    14|     const message =
    15|       'Did not understand arbitrary schema element: ' + JSON.stringify(component) +
    16|       '. Known schema elements were: ' + JSON.stringify(Obj.keys(schema));
    17|     console.error(message);
    18|     throw new Error(message);
    19|   }
    20|   return arbitrary(depth);
    21| };
    22| const createSchema = (factory: Schema, extras: Record<string, Partial<SchemaDetail>>): ContentSchema => {
    23|   const base = ArbSchema;
    24|   const schema = Merger.deepMerge(base, extras);
    25|   return Obj.map(schema, (s, k) => {
    26|     const type: string = s.type;
    27|     if (factory[type] === undefined && base[k] !== undefined) {
    28|       throw new Error('Component: ' + k + ' has invalid type: ' + type);
    29|     } else {
    30|       return factory[type](s);
    31|     }
    32|   });
    33| };
    34| const arbOf = <T extends Node>(component: string, extras: Record<string, Partial<SchemaDetail>> = {}): fc.Arbitrary<SugarElement<T>> => {
    35|   const constructor = (comp: string, newDepth: number) => makeArbOf(comp, schema, newDepth);
    36|   const factory = ArbSchemaTypes.create(constructor);
    37|   const schema = createSchema(factory, extras);
    38|   return makeArbOf(component, schema, unknownDepth);
    39| };
    40| export {
    41|   arbOf
    42| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/ArbNodes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import * as fc from 'fast-check';
     3| const createTag = <T extends HTMLElement>(name: string): SugarElement<T> => {
     4|   const partial = name.split('-');
     5|   const tag = partial.length > 0 ? partial[0] : name;
     6|   return SugarElement.fromTag(tag) as SugarElement<T>;
     7| };
     8| const comment = fc.string()
     9|   .map((s) => {
    10|     const raw = document.createComment(s);
    11|     return SugarElement.fromDom(raw);
    12|   });
    13| const elementOfArb = <T extends HTMLElement>(arb: fc.Arbitrary<string>): fc.Arbitrary<SugarElement<T>> =>
    14|   arb.map((name) => createTag<T>(name));
    15| const elementOf = <T extends HTMLElement>(tag: string): SugarElement<T> =>
    16|   createTag<T>(tag);
    17| const textOfArb = (arb: fc.Arbitrary<string>): fc.Arbitrary<SugarElement<Text>> =>
    18|   arb.map(SugarElement.fromText);
    19| const textOf = (s: string): SugarElement<Text> =>
    20|   SugarElement.fromText(s);
    21| export {
    22|   elementOfArb,
    23|   elementOf,
    24|   comment,
    25|   textOf,
    26|   textOfArb
    27| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/ArbSchema.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-188 ---
     1| import { Unicode } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as fc from 'fast-check';
     4| import * as ArbNodes from './ArbNodes';
     5| import { ArbitraryDetail, CompositeDetail, StructureDetail } from './ArbSchemaTypes';
     6| const formatting: CompositeDetail = {
     7|   type: 'composite',
     8|   tags: {
     9|     p: { weight: 1 },
    10|     h1: { weight: 1 }
    11|   },
    12|   components: {
    13|     anytext: { weight: 0.5 },
    14|     netext: { weight: 0.5 },
    15|     inline: { weight: 1.0 },
    16|     whitespace: { weight: 1.6 }
    17|   }
    18| };
    19| const inline: CompositeDetail = {
    20|   type: 'composite',
    21|   recursionDepth: 3,
    22|   tags: {
    23|     'span-strikethrough': { weight: 1, styles: { 'text-decoration': 'line-through' }},
    24|     'span': { weight: 1 },
    25|     'font': { weight: 0 },
    26|     'em': { weight: 1 },
    27|     'strong': { weight: 1 },
    28|     'b': { weight: 1 },
    29|     'i': { weight: 1 },
    30|     'span-underline': { weight: 1, styles: { 'text-decoration': 'underline' }}
    31|   },
    32|   components: {
    33|     anytext: { weight: 0.5 },
    34|     netext: { weight: 0.5 },
    35|     inline: { useDepth: true, weight: 1.0 },
    36|     _: { weight: 5.0 }
    37|   }
    38| };
    39| const container: CompositeDetail = {
    40|   type: 'composite',
    41|   recursionDepth: 3,
    42|   tags: {
    43|     div: { weight: 1 },
    44|     blockquote: { weight: 1 }
    45|   },
    46|   components: {
    47|     anytext: { weight: 0.5 },
    48|     netext: { weight: 0.5 },
    49|     inline: { weight: 1.0 },
    50|     container: { weight: 0.4, useDepth: true },
    51|     _: { weight: 0.5 }
    52|   }
    53| };
    54| const listitem: CompositeDetail = {
    55|   type: 'composite',
    56|   recursionDepth: 5,
    57|   tag: 'li',
    58|   components: {
    59|     whitespace: { weight: 0.1 },
    60|     anytext: { weight: 0.5 },
    61|     list: { useDepth: true, weight: 1 }
    62|   }
    63| };
    64| const list: CompositeDetail = {
    65|   type: 'composite',
    66|   recursionDepth: 5,
    67|   tags: {
    68|     ol: { weight: 1.0 },
    69|     ul: { weight: 1.0 }
    70|   },
    71|   components: {
    72|     listitem: { weight: 1, useDepth: true },
    73|     whitespace: { weight: 1 }
    74|   }
    75| };
    76| const table: StructureDetail = {
    77|   type: 'structure',
    78|   tag: 'table',
    79|   components: {
    80|     caption: { chance: 0.4 },
    81|     tbody: { chance: 1.0 },
    82|     thead: { chance: 0.2 },
    83|     tfoot: { chance: 0.2 }
    84|   }
    85| };
    86| const tbody: CompositeDetail = {
    87|   type: 'composite',
    88|   tag: 'tbody',
    89|   components: {
    90|     tr: { weight: 1.5 },
    91|     whitespace: { weight: 0.1 }
    92|   }
    93| };
    94| const thead: CompositeDetail = {
    95|   type: 'composite',
    96|   tag: 'thead',
    97|   components: {
    98|     tr: { weight: 1.5 },
    99|     whitespace: { weight: 0.1 }
   100|   }
   101| };
   102| const tfoot: CompositeDetail = {
   103|   type: 'composite',
   104|   tag: 'tfoot',
   105|   components: {
   106|     tr: { weight: 1.5 },
   107|     whitespace: { weight: 0.1 }
   108|   }
   109| };
   110| const tr: CompositeDetail = {
   111|   type: 'composite',
   112|   tag: 'tr',
   113|   components: {
   114|     whitespace: { weight: 0.5 },
   115|     tablecell: { weight: 3.5 }
   116|   }
   117| };
   118| const tablecell: CompositeDetail = {
   119|   type: 'composite',
   120|   tags: {
   121|     th: { weight: 1.0 },
   122|     td: { weight: 1.0 }
   123|   },
   124|   components: {
   125|     netext: { weight: 0.5 },
   126|     anytext: { weight: 0.5 },
   127|     whitespace: { weight: 1.0 }
   128|   }
   129| };
   130| const caption: CompositeDetail = {
   131|   type: 'composite',
   132|   tag: 'caption',
   133|   components: {
   134|     netext: { weight: 0.5 },
   135|     anytext: { weight: 0.5 },
   136|     whitespace: { weight: 1.0 }
   137|   }
   138| };
   139| const image: ArbitraryDetail<SugarElement<HTMLElement>> = {
   140|   type: 'arbitrary',
   141|   component: ArbNodes.elementOfArb(fc.constantFrom('img'))
   142| };
   143| const netext: ArbitraryDetail<SugarElement<Text>> = {
   144|   type: 'arbitrary',
   145|   component: ArbNodes.textOfArb(fc.string({ minLength: 1 }))
   146| };
   147| const anytext: ArbitraryDetail<SugarElement<Text>> = {
   148|   type: 'arbitrary',
   149|   component: ArbNodes.textOfArb(fc.string())
   150| };
   151| const whitespace: ArbitraryDetail<SugarElement<Text>> = {
   152|   type: 'arbitrary',
   153|   component: ArbNodes.textOfArb(fc.constantFrom(' ', '\n'))
   154| };
   155| const zerowidth: ArbitraryDetail<SugarElement<Text>> = {
   156|   type: 'arbitrary',
   157|   component: ArbNodes.textOfArb(fc.constant(Unicode.zeroWidth))
   158| };
   159| const zerowidths: ArbitraryDetail<SugarElement<Text>> = {
   160|   type: 'arbitrary',
   161|   component: ArbNodes.textOfArb(fc.constantFrom('\u200B', Unicode.zeroWidth))
   162| };
   163| const comment: ArbitraryDetail<SugarElement<Comment>> = {
   164|   type: 'arbitrary',
   165|   component: ArbNodes.comment
   166| };
   167| export const ArbSchema = {
   168|   whitespace,
   169|   formatting,
   170|   inline,
   171|   netext,
   172|   anytext,
   173|   container,
   174|   listitem,
   175|   list,
   176|   table,
   177|   tbody,
   178|   thead,
   179|   tfoot,
   180|   tr,
   181|   tablecell,
   182|   caption,
   183|   image,
   184|   comment,
   185|   zerowidth,
   186|   zerowidths
   187| };
   188| export type ArbSchema = typeof ArbSchema;


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/ArbSchemaTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-109 ---
     1| import { Merger, Obj } from '@ephox/katamari';
     2| import { Attribute, Css, InsertAll, SugarElement } from '@ephox/sugar';
     3| import * as fc from 'fast-check';
     4| import * as ArbChildrenSchema from './ArbChildrenSchema';
     5| import * as ArbNodes from './ArbNodes';
     6| import * as WeightedChoice from './WeightedChoice';
     7| interface Decorations {
     8|   readonly attributes?: Record<string, string | boolean | number>;
     9|   readonly styles?: Record<string, string>;
    10| }
    11| interface ArbDecorations {
    12|   readonly attributes?: fc.Arbitrary<Record<string, string | boolean | number>>;
    13|   readonly styles?: fc.Arbitrary<Record<string, string>>;
    14| }
    15| export interface TagDetail extends ArbDecorations {
    16|   readonly tag: string;
    17| }
    18| export interface TagsDetail extends ArbDecorations {
    19|   readonly tags: Record<string, WeightedChoice.WeightedItem & Decorations>;
    20| }
    21| export type CompositeDetail = (TagDetail | TagsDetail) & ArbChildrenSchema.CompositeDetail & {
    22|   readonly type: 'composite';
    23| };
    24| export interface StructureDetail extends TagDetail, ArbChildrenSchema.StructureDetail {
    25|   readonly type: 'structure';
    26| }
    27| export interface LeafDetail extends TagDetail {
    28|   readonly type: 'leaf';
    29| }
    30| export interface ArbitraryDetail<T> {
    31|   readonly type: 'arbitrary';
    32|   readonly component: fc.Arbitrary<T>;
    33| }
    34| export type SchemaDetail = ArbitraryDetail<any> | CompositeDetail | LeafDetail | StructureDetail;
    35| interface Tag extends WeightedChoice.WeightedItem, Decorations {
    36|   readonly tag: string;
    37| }
    38| export interface Schema {
    39|   readonly arbitrary: <T extends Node>(arb: ArbitraryDetail<T>) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<T>>;
    40|   readonly leaf: (detail: LeafDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
    41|   readonly structure: (detail: StructureDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
    42|   readonly composite: (detail: CompositeDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
    43| }
    44| const isTagsDetail = (detail: TagsDetail | TagDetail): detail is TagsDetail =>
    45|   (detail as TagsDetail).tags !== undefined;
    46| const toTags = (detail: TagsDetail): Tag[] =>
    47|   Obj.mapToArray(detail.tags, (v, k) => Merger.deepMerge(v, { tag: k }));
    48| const flattenTag = (tag: string): Record<string, WeightedChoice.WeightedItem & Decorations> => {
    49|   const r = {};
    50|   r[tag] = { weight: 1.0 };
    51|   return r;
    52| };
    53| const conform = (detail: TagsDetail | TagDetail): TagsDetail => {
    54|   if (isTagsDetail(detail)) {
    55|     return detail;
    56|   } else {
    57|     return Merger.deepMerge(detail, {
    58|       tags: flattenTag(detail.tag)
    59|     });
    60|   }
    61| };
    62| const addDecorations = (detail: ArbDecorations, element: SugarElement<HTMLElement>) => {
    63|   const attrDecorator = detail.attributes !== undefined ? detail.attributes : fc.constant({});
    64|   const styleDecorator = detail.styles !== undefined ? detail.styles : fc.constant({});
    65|   return attrDecorator.chain((attrs) => {
    66|     Attribute.setAll(element, attrs);
    67|     return styleDecorator.map((styles) => {
    68|       Css.setAll(element, styles);
    69|       return element;
    70|     });
    71|   });
    72| };
    73| const makeTag = (choice: Tag): SugarElement<HTMLElement> => {
    74|   const element = ArbNodes.elementOf(choice.tag);
    75|   const attributes = choice.attributes !== undefined ? choice.attributes : {};
    76|   const styles = choice.styles !== undefined ? choice.styles : {};
    77|   Attribute.setAll(element, attributes);
    78|   Css.setAll(element, styles);
    79|   return element;
    80| };
    81| export const create = (construct: ArbChildrenSchema.Construct<SugarElement<Node>>): Schema => {
    82|   const combine = (detail: LeafDetail | StructureDetail | CompositeDetail, childGenerator: fc.Arbitrary<SugarElement<Node>[]>) => {
    83|     const tags = toTags(conform(detail));
    84|     return WeightedChoice.generator(tags).chain((choiceOption) => {
    85|       const choice = choiceOption.getOrDie('Every entry in tags for: ' + JSON.stringify(detail) + ' must have a tag');
    86|       return childGenerator.chain((children) => {
    87|         const parent = makeTag(choice);
    88|         InsertAll.append(parent, children);
    89|         return addDecorations(detail, parent);
    90|       });
    91|     });
    92|   };
    93|   const composite = (detail: CompositeDetail) => (rawDepth: number | undefined) => {
    94|     const childGenerator = ArbChildrenSchema.composite(rawDepth, detail, construct);
    95|     return combine(detail, childGenerator);
    96|   };
    97|   const leaf = (detail: LeafDetail) => (_: number | undefined) => combine(detail, ArbChildrenSchema.none);
    98|   const structure = (detail: StructureDetail) => (rawDepth: number | undefined) => {
    99|     const childGenerator = ArbChildrenSchema.structure(rawDepth, detail, construct);
   100|     return combine(detail, childGenerator);
   101|   };
   102|   const arbitrary = (arb) => (_) => arb.component;
   103|   return {
   104|     arbitrary,
   105|     leaf,
   106|     structure,
   107|     composite
   108|   };
   109| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/GenSelection.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| import { Fun, Merger } from '@ephox/katamari';
     2| import { PredicateFilter, SimRange, SugarElement, SugarNode, SugarText, Traverse } from '@ephox/sugar';
     3| import * as fc from 'fast-check';
     4| export interface SelectionExclusions {
     5|   containers: (container: SugarElement<Node>) => boolean;
     6| }
     7| const defaultExclusions: SelectionExclusions = {
     8|   containers: Fun.never
     9|   /* Maybe support offsets later if it makes sense to do so */
    10| };
    11| const getEnd = (target: SugarElement<Node>): number =>
    12|   SugarNode.isText(target) ? SugarText.get(target).length : Traverse.children(target).length;
    13| const gChooseIn = <T extends Node>(target: SugarElement<T>): fc.Arbitrary<{ element: SugarElement<T>; offset: number }> => {
    14|   const offsets = getEnd(target);
    15|   return fc.integer({ min: 0, max: offsets }).map((offset) => ({ element: target, offset }));
    16| };
    17| const gChooseFrom = (root: SugarElement<Node>, exclusions: SelectionExclusions) => {
    18|   const self = exclusions.containers(root) ? [] : [ root ];
    19|   const everything = PredicateFilter.descendants(root, Fun.not(exclusions.containers)).concat(self);
    20|   return fc.constantFrom(...(everything.length > 0 ? everything : [ root ])).chain(gChooseIn);
    21| };
    22| const selection = (root: SugarElement<Node>, rawExclusions: SelectionExclusions): fc.Arbitrary<SimRange> => {
    23|   const exclusions: SelectionExclusions = Merger.deepMerge(defaultExclusions, rawExclusions);
    24|   return gChooseFrom(root, exclusions).chain((start) => gChooseFrom(root, exclusions).map((finish): SimRange => ({
    25|     start: start.element,
    26|     soffset: start.offset,
    27|     finish: finish.element,
    28|     foffset: finish.offset
    29|   })));
    30| };
    31| export {
    32|   selection
    33| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/PropertySteps.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| import * as fc from 'fast-check';
     2| import { Step } from '../api/Step';
     3| import { TestLogs } from '../api/TestLogs';
     4| const stepToPromise = <T, U>(step: Step<T, U>) => (input: T): PromiseLike<true> =>
     5|   new Promise<true>((resolve, reject) => {
     6|     step.runStep(input, () => {
     7|       resolve(true);
     8|     }, reject, TestLogs.init());
     9|   });
    10| const sAsyncProperty = <T, X>(name: string, arbitraries: fc.Arbitrary<X>[], statefulStep: Step<X, any>, options?: fc.Parameters): Step<T, T> => {
    11|   return Step.async<T>((next, die) => {
    12|     fc.assert(fc.asyncProperty.call(fc, ...arbitraries, stepToPromise(statefulStep)), options).then(next, die);
    13|   });
    14| };
    15| export {
    16|   sAsyncProperty
    17| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/TagDecorator.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| import * as fc from 'fast-check';
     2| import * as WeightedChoice from './WeightedChoice';
     3| export interface Decorator<T> extends WeightedChoice.WeightedItem{
     4|   property: string;
     5|   value: fc.Arbitrary<T>;
     6| }
     7| const gOne = <T>(wDecorations: Decorator<T>[]): fc.Arbitrary<Record<string, T>> =>
     8|   WeightedChoice.generator(wDecorations).chain((choice) =>
     9|     choice.fold(() =>
    10|       fc.constant({}),
    11|     (c) => c.value.map((v) => {
    12|       const r = {};
    13|       r[c.property] = v;
    14|       return r;
    15|     })));
    16| const gEnforce = <T>(decorations: T): fc.Arbitrary<T> =>
    17|   fc.constant(decorations);
    18| export {
    19|   gOne,
    20|   gEnforce
    21| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/arbitrary/WeightedChoice.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| import { Arr, Obj, Optional } from '@ephox/katamari';
     2| import * as fc from 'fast-check';
     3| export interface WeightedItem {
     4|   useDepth?: boolean;
     5|   weight: number;
     6| }
     7| export interface AccWeightItem {
     8|   accWeight: number;
     9| }
    10| export interface WeightedList<T extends WeightedItem> {
    11|   readonly list: (T & AccWeightItem)[];
    12|   readonly total: number;
    13| }
    14| const weighted = <T extends WeightedItem> (list: (T & AccWeightItem)[], total: number): WeightedList<T> => ({
    15|   list,
    16|   total
    17| });
    18| const choose = <T extends WeightedItem>(candidates: T[]): WeightedList<T> => {
    19|   const result = Arr.foldl(candidates, (rest, d) => {
    20|     const newTotal = rest.total + d.weight;
    21|     const merged: T & AccWeightItem = {
    22|       ...d,
    23|       accWeight: newTotal
    24|     };
    25|     return {
    26|       total: newTotal,
    27|       list: rest.list.concat([ merged ])
    28|     };
    29|   }, { list: [] as Array<T & AccWeightItem>, total: 0 });
    30|   return weighted(result.list, result.total);
    31| };
    32| const gChoose = <T extends WeightedItem>(weighted: WeightedList<T>): fc.Arbitrary<Optional<T & AccWeightItem>> =>
    33|   fc.float({ min: 0, max: weighted.total }).map((w): Optional<T & AccWeightItem> => {
    34|     const raw = Arr.find(weighted.list, (d) =>
    35|       w <= d.accWeight
    36|     );
    37|     const keys = raw.map(Obj.keys).getOr([]);
    38|     return keys.length === [ 'weight', 'accWeight' ].length ? Optional.none() : raw;
    39|   });
    40| const generator = <T extends WeightedItem>(candidates: T[]): fc.Arbitrary<Optional<T & AccWeightItem>> => {
    41|   const list = choose(candidates);
    42|   return gChoose(list);
    43| };
    44| export {
    45|   generator
    46| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/assertions/ApproxStructures.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-285 ---
     1| import { Assert, TestLabel } from '@ephox/bedrock-client';
     2| import { Arr, Fun, Obj, Optional } from '@ephox/katamari';
     3| import { Attribute, Classes, Css, Html, SugarElement, SugarNode, SugarText, Traverse, Truncate, Value } from '@ephox/sugar';
     4| import * as ApproxComparisons from './ApproxComparisons';
     5| export interface StringAssert {
     6|   show: () => string;
     7|   strAssert: (label: TestLabel, actual: string) => void;
     8| }
     9| export interface ArrayAssert {
    10|   show: () => void;
    11|   arrAssert: (label: TestLabel, array: any[]) => void;
    12| }
    13| export interface ElementQueue {
    14|   context(): string;
    15|   current(): Optional<SugarElement<Node>>;
    16|   peek(): Optional<SugarElement<Node>>;
    17|   take(): Optional<SugarElement<Node>>;
    18|   mark(): {
    19|     reset: () => void ;
    20|     atMark: () => boolean;
    21|   };
    22| }
    23| export interface StructAssertBasic {
    24|   type?: 'basic';
    25|   doAssert: (actual: SugarElement<Node>) => void;
    26| }
    27| export interface StructAssertAdv {
    28|   type: 'advanced';
    29|   doAssert: (queue: ElementQueue) => void;
    30| }
    31| export type StructAssert = StructAssertBasic | StructAssertAdv;
    32| export interface ElementFields {
    33|   attrs?: Record<string, StringAssert>;
    34|   classes?: ArrayAssert[];
    35|   styles?: Record<string, StringAssert>;
    36|   html?: StringAssert;
    37|   value?: StringAssert;
    38|   children?: StructAssert[];
    39| }
    40| const elementQueue = (items: SugarElement<Node>[], container: Optional<SugarElement<Node>>): ElementQueue => {
    41|   let i = -1;
    42|   const context = () => {
    43|     const hasItem = i >= 0 && i < items.length;
    44|     const itemHtml = hasItem ? '\n' + Truncate.getHtml(items[i]) : ' *missing*';
    45|     const itemInfo = '\nItem[' + i + ']:' + itemHtml;
    46|     return container.fold(
    47|       () => {
    48|         const structHtml = Arr.map(items, Html.getOuter).join('');
    49|         const structInfo = '\nComplete Structure:\n' + structHtml;
    50|         return itemInfo + structInfo;
    51|       },
    52|       (element) => {
    53|         const containerHtml = Truncate.getHtml(element);
    54|         const containerInfo = '\nContainer:\n' + containerHtml;
    55|         const structHtml = Html.getOuter(element);
    56|         const structInfo = '\nComplete Structure:\n' + structHtml;
    57|         return containerInfo + itemInfo + structInfo;
    58|       }
    59|     );
    60|   };
    61|   const current = () => i >= 0 && i < items.length ? Optional.some(items[i]) : Optional.none<SugarElement<Node>>();
    62|   const peek = () => i + 1 < items.length ? Optional.some(items[i + 1]) : Optional.none<SugarElement<Node>>();
    63|   const take = () => {
    64|     i += 1;
    65|     return current();
    66|   };
    67|   const mark = () => {
    68|     const x = i;
    69|     const reset = () => {
    70|       i = x;
    71|     };
    72|     const atMark = () => i === x;
    73|     return {
    74|       reset,
    75|       atMark
    76|     };
    77|   };
    78|   return {
    79|     context,
    80|     current,
    81|     peek,
    82|     take,
    83|     mark
    84|   };
    85| };
    86| const element = (tag: string, fields: ElementFields): StructAssert => {
    87|   const doAssert = (actual: SugarElement<Node>): void => {
    88|     if (SugarNode.isHTMLElement(actual)) {
    89|       Assert.eq(() => 'Incorrect node name for: ' + Truncate.getHtml(actual), tag, SugarNode.name(actual));
    90|       const attrs = fields.attrs !== undefined ? fields.attrs : {};
    91|       const classes = fields.classes !== undefined ? fields.classes : [];
    92|       const styles = fields.styles !== undefined ? fields.styles : {};
    93|       const html = fields.html !== undefined ? Optional.some(fields.html) : Optional.none<StringAssert>();
    94|       const value = fields.value !== undefined ? Optional.some(fields.value) : Optional.none<StringAssert>();
    95|       const children = fields.children !== undefined ? Optional.some(fields.children) : Optional.none<StructAssert[]>();
    96|       assertAttrs(attrs, actual);
    97|       assertClasses(classes, actual);
    98|       assertStyles(styles, actual);
    99|       assertHtml(html, actual);
   100|       assertValue(value, actual);
   101|       assertChildren(children, actual);
   102|     } else {
   103|       Assert.eq('Incorrect node type for: ' + Truncate.getHtml(actual), 1, SugarNode.type(actual));
   104|     }
   105|   };
   106|   return {
   107|     doAssert
   108|   };
   109| };
   110| const text = (s: StringAssert, combineSiblings = false): StructAssert => {
   111|   const doAssert = (queue: ElementQueue): void => {
   112|     queue.take().fold(() => {
   113|       Assert.fail('No more nodes, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
   114|     }, (actual) => {
   115|       SugarText.getOption(actual).fold(() => {
   116|         Assert.fail('Node is not a text node, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
   117|       }, (t: string) => {
   118|         let text = t;
   119|         if (combineSiblings) {
   120|           while (queue.peek().exists(SugarNode.isText)) {
   121|             text += queue.take().bind(SugarText.getOption).getOr('');
   122|           }
   123|         }
   124|         if (s.strAssert === undefined) {
   125|           throw new Error(JSON.stringify(s) + ' is not a *string assertion*');
   126|         }
   127|         s.strAssert('Checking text content', text);
   128|       });
   129|     });
   130|   };
   131|   return {
   132|     type: 'advanced',
   133|     doAssert
   134|   };
   135| };
   136| const applyAssert = (structAssert: StructAssert, queue: ElementQueue) => {
   137|   if (structAssert.type === 'advanced') {
   138|     structAssert.doAssert(queue);
   139|   } else {
   140|     queue.take().fold(() => {
   141|       Assert.fail('Expected more children to satisfy assertion for ' + queue.context());
   142|     }, (item) => {
   143|       structAssert.doAssert(item);
   144|     });
   145|   }
   146| };
   147| const either = (structAsserts: StructAssert[]): StructAssert => {
   148|   const doAssert = (queue: ElementQueue) => {
   149|     const mark = queue.mark();
   150|     for (let i = 0; i < structAsserts.length - 1; i++) {
   151|       try {
   152|         applyAssert(structAsserts[i], queue);
   153|         return;
   154|       } catch (e) {
   155|         mark.reset();
   156|       }
   157|     }
   158|     if (structAsserts.length > 0) {
   159|       applyAssert(structAsserts[structAsserts.length - 1], queue);
   160|     }
   161|   };
   162|   return {
   163|     type: 'advanced',
   164|     doAssert
   165|   };
   166| };
   167| const repeat = (min: number, max: number | true = min) => (structAssert: StructAssert): StructAssert => {
   168|   const doAssert = (queue: ElementQueue) => {
   169|     let i = 0;
   170|     for (; i < min; i++) {
   171|       applyAssert(structAssert, queue);
   172|     }
   173|     for (; (max === true || i < max) && queue.peek().isSome(); i++) {
   174|       const mark = queue.mark();
   175|       try {
   176|         applyAssert(structAssert, queue);
   177|       } catch (e) {
   178|         mark.reset();
   179|       }
   180|       if (mark.atMark()) {
   181|         break;
   182|       }
   183|     }
   184|   };
   185|   return {
   186|     type: 'advanced',
   187|     doAssert
   188|   };
   189| };
   190| const zeroOrOne = repeat(0, 1);
   191| const zeroOrMore = repeat(0, true);
   192| const oneOrMore = repeat(1, true);
   193| const anythingStruct: StructAssert = {
   194|   doAssert: Fun.noop
   195| };
   196| const assertAttrs = (expectedAttrs: Record<string, StringAssert>, actual: SugarElement<Element>) => {
   197|   Obj.each(expectedAttrs, (v, k) => {
   198|     if (v.strAssert === undefined) {
   199|       throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* attributes of ' + Truncate.getHtml(actual));
   200|     }
   201|     const actualValue = Attribute.getOpt(actual, k).getOrThunk(ApproxComparisons.missing);
   202|     v.strAssert(
   203|       () => 'Checking attribute: "' + k + '" of ' + Truncate.getHtml(actual) + '\n',
   204|       actualValue
   205|     );
   206|   });
   207| };
   208| const assertClasses = (expectedClasses: ArrayAssert[], actual: SugarElement<Element>) => {
   209|   const actualClasses = Classes.get(actual);
   210|   Arr.each(expectedClasses, (eCls) => {
   211|     if (eCls.arrAssert === undefined) {
   212|       throw new Error(JSON.stringify(eCls) + ' is not an *array assertion*.\nSpecified in *expected* classes of ' + Truncate.getHtml(actual));
   213|     }
   214|     eCls.arrAssert(() => 'Checking classes in ' + Truncate.getHtml(actual) + '\n', actualClasses);
   215|   });
   216| };
   217| const assertStyles = (expectedStyles: Record<string, StringAssert>, actual: SugarElement<Element>) => {
   218|   Obj.each(expectedStyles, (v, k) => {
   219|     const actualValue = Css.getRaw(actual, k).getOrThunk(ApproxComparisons.missing);
   220|     if (v.strAssert === undefined) {
   221|       throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* styles of ' + Truncate.getHtml(actual));
   222|     }
   223|     v.strAssert(
   224|       () => 'Checking style: "' + k + '" of ' + Truncate.getHtml(actual) + '\n',
   225|       actualValue
   226|     );
   227|   });
   228| };
   229| const assertHtml = (expectedHtml: Optional<StringAssert>, actual: SugarElement<HTMLElement>) => {
   230|   expectedHtml.each((expected) => {
   231|     const actualHtml = Html.get(actual);
   232|     if (expected.strAssert === undefined) {
   233|       throw new Error(JSON.stringify(expected) + ' is not a *string assertion*.\nSpecified in *expected* innerHTML of ' + Truncate.getHtml(actual));
   234|     }
   235|     expected.strAssert(() => 'Checking HTML of ' + Truncate.getHtml(actual), actualHtml);
   236|   });
   237| };
   238| const assertValue = (expectedValue: Optional<StringAssert>, actual: SugarElement<HTMLElement>) => {
   239|   expectedValue.each((v) => {
   240|     if (v.strAssert === undefined) {
   241|       throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* value of ' + Truncate.getHtml(actual));
   242|     }
   243|     v.strAssert(
   244|       () => 'Checking value of ' + Truncate.getHtml(actual),
   245|       Value.get(actual as SugarElement<any>)
   246|     );
   247|   });
   248| };
   249| const assertChildren = (expectedChildren: Optional<StructAssert[]>, actual: SugarElement<Node>) => {
   250|   expectedChildren.each((expected) => {
   251|     const children = elementQueue(Traverse.children(actual), Optional.some(actual));
   252|     Arr.each(expected, (structExpectation, i) => {
   253|       if (structExpectation.doAssert === undefined) {
   254|         throw new Error(JSON.stringify(structExpectation) + ' is not a *structure assertion*.\n' +
   255|           'Specified in *expected* children of ' + Truncate.getHtml(actual));
   256|       }
   257|       if (structExpectation.type === 'advanced') {
   258|         structExpectation.doAssert(children);
   259|       } else {
   260|         children.take().fold(() => {
   261|           Assert.fail('Expected more children to satisfy assertion ' + i + ' for ' + children.context());
   262|         }, (item) => {
   263|           structExpectation.doAssert(item);
   264|         });
   265|       }
   266|     });
   267|     if (children.peek().isSome()) {
   268|       Assert.fail('More children than expected for ' + children.context());
   269|     }
   270|   });
   271| };
   272| const anything = Fun.constant(anythingStruct);
   273| const theRest = Fun.constant(zeroOrMore(anythingStruct));
   274| export {
   275|   elementQueue,
   276|   anything,
   277|   element,
   278|   text,
   279|   either,
   280|   repeat,
   281|   zeroOrOne,
   282|   zeroOrMore,
   283|   oneOrMore,
   284|   theRest
   285| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/assertions/Differ.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-130 ---
     1| /*
     2|  * Javascript Diff Algorithm
     3|  *  By John Resig (http://ejohn.org/)
     4|  *  Modified by Chu Alan "sprite"
     5|  *
     6|  * Released under the MIT license.
     7|  *
     8|  * More Info:
     9|  *  http://ejohn.org/projects/javascript-diff-algorithm/
    10|  *
    11|  * Usage: QUnit.diff(expected, actual)
    12|  *
    13|  * QUnit.diff( "the quick brown fox jumped over", "the quick fox jumps over" ) == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
    14|  */
    15| const htmlDiff: (v1: string, v2: string) => string = (() => {
    16|   const hasOwn = Object.prototype.hasOwnProperty;
    17|   /* jshint eqeqeq:false, eqnull:true */
    18|   const diff = (o, n) => {
    19|     let i;
    20|     const ns = {};
    21|     const os = {};
    22|     for (i = 0; i < n.length; i++) {
    23|       if (!hasOwn.call(ns, n[i])) {
    24|         ns[n[i]] = {
    25|           rows: [],
    26|           o: null
    27|         };
    28|       }
    29|       ns[n[i]].rows.push(i);
    30|     }
    31|     for (i = 0; i < o.length; i++) {
    32|       if (!hasOwn.call(os, o[i])) {
    33|         os[o[i]] = {
    34|           rows: [],
    35|           n: null
    36|         };
    37|       }
    38|       os[o[i]].rows.push(i);
    39|     }
    40|     for (i in ns) {
    41|       if (hasOwn.call(ns, i)) {
    42|         if (ns[i].rows.length === 1 && hasOwn.call(os, i) && os[i].rows.length === 1) {
    43|           n[ns[i].rows[0]] = {
    44|             text: n[ns[i].rows[0]],
    45|             row: os[i].rows[0]
    46|           };
    47|           o[os[i].rows[0]] = {
    48|             text: o[os[i].rows[0]],
    49|             row: ns[i].rows[0]
    50|           };
    51|         }
    52|       }
    53|     }
    54|     for (i = 0; i < n.length - 1; i++) {
    55|       if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
    56|         n[i + 1] === o[n[i].row + 1]) {
    57|         n[i + 1] = {
    58|           text: n[i + 1],
    59|           row: n[i].row + 1
    60|         };
    61|         o[n[i].row + 1] = {
    62|           text: o[n[i].row + 1],
    63|           row: i + 1
    64|         };
    65|       }
    66|     }
    67|     for (i = n.length - 1; i > 0; i--) {
    68|       if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
    69|         n[i - 1] === o[n[i].row - 1]) {
    70|         n[i - 1] = {
    71|           text: n[i - 1],
    72|           row: n[i].row - 1
    73|         };
    74|         o[n[i].row - 1] = {
    75|           text: o[n[i].row - 1],
    76|           row: i - 1
    77|         };
    78|       }
    79|     }
    80|     return {
    81|       o,
    82|       n
    83|     };
    84|   };
    85|   return (o, n) => {
    86|     o = o.replace(/\s+$/, '');
    87|     n = n.replace(/\s+$/, '');
    88|     let i, pre,
    89|       str = '',
    90|       oSpace = o.match(/\s+/g),
    91|       nSpace = n.match(/\s+/g);
    92|     const out = diff(o === '' ? [] : o.split(/\s+/), n === '' ? [] : n.split(/\s+/));
    93|     if (oSpace == null) {
    94|       oSpace = [ ' ' ];
    95|     } else {
    96|       oSpace.push(' ');
    97|     }
    98|     if (nSpace == null) {
    99|       nSpace = [ ' ' ];
   100|     } else {
   101|       nSpace.push(' ');
   102|     }
   103|     if (out.n.length === 0) {
   104|       for (i = 0; i < out.o.length; i++) {
   105|         str += '<del>' + out.o[i] + oSpace[i] + '</del>';
   106|       }
   107|     } else {
   108|       if (out.n[0].text == null) {
   109|         for (let j = 0; j < out.o.length && out.o[j].text == null; j++) {
   110|           str += '<del>' + out.o[j] + oSpace[j] + '</del>';
   111|         }
   112|       }
   113|       for (i = 0; i < out.n.length; i++) {
   114|         if (out.n[i].text == null) {
   115|           str += '<ins>' + out.n[i] + nSpace[i] + '</ins>';
   116|         } else {
   117|           pre = '';
   118|           for (let j = out.n[i].row + 1; j < out.o.length && out.o[j].text == null; j++) {
   119|             pre += '<del>' + out.o[j] + oSpace[j] + '</del>';
   120|           }
   121|           str += ' ' + out.n[i].text + nSpace[i] + pre;
   122|         }
   123|       }
   124|     }
   125|     return str;
   126|   };
   127| })();
   128| export {
   129|   htmlDiff
   130| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/dragndrop/DndEvents.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import { setProtectedMode, setReadOnlyMode, setReadWriteMode } from '../datatransfer/Mode';
     3| const createDndEvent = (name: string) => (win: Window, x: number, y: number, dataTransfer: DataTransfer): DragEvent => {
     4|   const event: any = document.createEvent('CustomEvent');
     5|   event.initCustomEvent(name, true, true, null);
     6|   event.view = win;
     7|   event.ctrlKey = false;
     8|   event.altKey = false;
     9|   event.shiftKey = false;
    10|   event.metaKey = false;
    11|   event.button = 0;
    12|   event.relatedTarget = null;
    13|   event.screenX = win.screenX + x;
    14|   event.screenY = win.screenY + y;
    15|   event.dataTransfer = dataTransfer;
    16|   return event;
    17| };
    18| const createDragoverEvent = createDndEvent('dragover');
    19| const createDragendEvent = createDndEvent('dragend');
    20| const createDragstartEvent = createDndEvent('dragstart');
    21| const createDragleaveEvent = createDndEvent('dragleave');
    22| const createDragenterEvent = createDndEvent('dragenter');
    23| const createDropEvent = createDndEvent('drop');
    24| const createDragEvent = createDndEvent('drag');
    25| const isDefaultPrevented = (evt: DragEvent): boolean => evt.defaultPrevented;
    26| const dispatchDndEvent = (event: DragEvent, target: SugarElement<Node>): DragEvent => {
    27|   if (event.type === 'dragstart') {
    28|     setReadWriteMode(event.dataTransfer);
    29|   } else if (event.type === 'drop') {
    30|     setReadOnlyMode(event.dataTransfer);
    31|   } else {
    32|     setProtectedMode(event.dataTransfer);
    33|   }
    34|   target.dom.dispatchEvent(event);
    35|   return event;
    36| };
    37| const getWindowFromElement = (element: SugarElement<Element>): Window => element.dom.ownerDocument.defaultView;
    38| export {
    39|   createDndEvent,
    40|   createDragoverEvent,
    41|   createDragendEvent,
    42|   createDragstartEvent,
    43|   createDragleaveEvent,
    44|   createDragenterEvent,
    45|   createDropEvent,
    46|   createDragEvent,
    47|   isDefaultPrevented,
    48|   dispatchDndEvent,
    49|   getWindowFromElement
    50| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/find/UiSearcher.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-68 ---
     1| import { TestLabel } from '@ephox/bedrock-client';
     2| import { Adt, Optional, Result } from '@ephox/katamari';
     3| import { SugarElement, Truncate } from '@ephox/sugar';
     4| import * as SizzleFind from '../alien/SizzleFind';
     5| interface TargetAdt {
     6|   fold: <T> (
     7|     self: (element: SugarElement<Node>, selector: string) => T,
     8|     children: (element: SugarElement<Node>, selector: string) => T,
     9|     descendants: (element: SugarElement<Node>, selector: string) => T
    10|   ) => T;
    11|   match: <T>(branches: {
    12|     self: (element: SugarElement<Node>, selector: string) => T;
    13|     children: (element: SugarElement<Node>, selector: string) => T;
    14|     descendants: (element: SugarElement<Node>, selector: string) => T;
    15|   }) => T;
    16|   log: (label: string) => void;
    17| }
    18| const targets: {
    19|   self: (element: SugarElement<Node>, selector: string) => TargetAdt;
    20|   children: (element: SugarElement<Node>, selector: string) => TargetAdt;
    21|   descendants: (element: SugarElement<Node>, selector: string) => TargetAdt;
    22| } = Adt.generate([
    23|   { self: [ 'element', 'selector' ] },
    24|   { children: [ 'element', 'selector' ] },
    25|   { descendants: [ 'element', 'selector' ] }
    26| ]);
    27| const derive = (element: SugarElement<Node>, selector: string) => {
    28|   if (selector === undefined) {
    29|     throw new Error('No selector passed through');
    30|   } else if (selector.indexOf('root:') === 0) {
    31|     return targets.self(element, selector.substring('root:'.length));
    32|   } else if (selector.indexOf('root>') === 0) {
    33|     return targets.children(element, selector.substring('root>'.length));
    34|   } else {
    35|     return targets.descendants(element, selector);
    36|   }
    37| };
    38| const matchesSelf = <T extends Element>(element: SugarElement<Node>, selector: string): Optional<SugarElement<T>> =>
    39|   SizzleFind.matches<T>(element, selector) ? Optional.some(element) : Optional.none();
    40| const select = <T extends Element>(element: SugarElement<Node>, selector: string): Optional<SugarElement<T>> =>
    41|   derive(element, selector).fold<Optional<SugarElement<T>>>(
    42|     matchesSelf,
    43|     SizzleFind.child,
    44|     SizzleFind.descendant
    45|   );
    46| const selectAll = <T extends Element>(element: SugarElement<Node>, selector: string): Array<SugarElement<T>> =>
    47|   derive(element, selector).fold<Array<SugarElement<T>>>(
    48|     (element, selector) => matchesSelf<T>(element, selector).toArray(),
    49|     SizzleFind.children,
    50|     SizzleFind.descendants
    51|   );
    52| const toResult = <T>(message: TestLabel, option: Optional<T>): Result<T, TestLabel> =>
    53|   option.fold(
    54|     () => Result.error<T, TestLabel>(TestLabel.asString(message)),
    55|     Result.value
    56|   );
    57| const findIn = <T extends Element>(container: SugarElement<Node>, selector: string): Result<SugarElement<T>, TestLabel> =>
    58|   toResult(
    59|     () => 'Could not find selector: ' + selector + ' in ' + Truncate.getHtml(container),
    60|     select(container, selector)
    61|   );
    62| const findAllIn = <T extends Element>(container: SugarElement<Node>, selector: string): Array<SugarElement<T>> =>
    63|   selectAll(container, selector);
    64| export {
    65|   select,
    66|   findIn,
    67|   findAllIn
    68| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/keyboard/FakeKeys.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-76 ---
     1| import { PlatformDetection } from '@ephox/sand';
     2| import { SugarElement } from '@ephox/sugar';
     3| export interface OldKeyModifiers {
     4|   shift?: boolean;
     5|   meta?: boolean;
     6|   ctrl?: boolean;
     7|   alt?: boolean;
     8| }
     9| export interface KeyModifiers {
    10|   shiftKey?: boolean;
    11|   metaKey?: boolean;
    12|   ctrlKey?: boolean;
    13|   altKey?: boolean;
    14| }
    15| export type MixedKeyModifiers = OldKeyModifiers | KeyModifiers;
    16| const isNewKeyModifiers = (modifiers: MixedKeyModifiers): modifiers is KeyModifiers =>
    17|   'shiftKey' in modifiers || 'metaKey' in modifiers || 'ctrlKey' in modifiers || 'altKey' in modifiers;
    18| const newModifiers = (modifiers: MixedKeyModifiers): KeyModifiers => isNewKeyModifiers(modifiers) ? modifiers :
    19|   { shiftKey: modifiers.shift, metaKey: modifiers.meta, ctrlKey: modifiers.ctrl, altKey: modifiers.alt };
    20| const keyevent = (type: string, doc: SugarElement<Document>, value: number, modifiers: MixedKeyModifiers, focus?: SugarElement<Node>): void => {
    21|   const domDoc: Document = doc.dom;
    22|   const mod = newModifiers(modifiers);
    23|   const oEvent = domDoc.createEvent('KeyboardEvent');
    24|   const getter = () => value;
    25|   const defineGetter = (obj, key: string, propGetter) => {
    26|     Object.defineProperty(obj, key, { get: propGetter, enumerable: true });
    27|   };
    28|   const dispatcher = focus !== undefined ? focus : doc;
    29|   const platform = PlatformDetection.detect();
    30|   if (platform.browser.isSafari()) {
    31|     safari(type, doc, value, mod, dispatcher);
    32|   } else {
    33|     if (platform.browser.isChromium() || platform.browser.isFirefox()) {
    34|       if (type === 'keypress') {
    35|         defineGetter(oEvent, 'charCode', getter);
    36|       }
    37|       defineGetter(oEvent, 'keyCode', getter);
    38|       defineGetter(oEvent, 'which', getter);
    39|       defineGetter(oEvent, 'shiftKey', () => mod.shiftKey === true);
    40|       defineGetter(oEvent, 'metaKey', () => mod.metaKey === true);
    41|       defineGetter(oEvent, 'ctrlKey', () => mod.ctrlKey === true);
    42|       defineGetter(oEvent, 'altKey', () => mod.altKey === true);
    43|     }
    44|     const canBubble = true;
    45|     const cancellable = true;
    46|     const ctrlKey = mod.ctrlKey === true;
    47|     const altKey = mod.altKey === true;
    48|     const shiftKey = mod.shiftKey === true;
    49|     const metaKey = mod.metaKey === true;
    50|     const anyEvent = oEvent as any;
    51|     if (anyEvent.initKeyboardEvent) {
    52|       anyEvent.initKeyboardEvent(type, canBubble, cancellable, domDoc.defaultView, ctrlKey, altKey, shiftKey, metaKey, value, value);
    53|     } else {
    54|       anyEvent.initKeyEvent(type, canBubble, cancellable, domDoc.defaultView, ctrlKey, altKey, shiftKey, metaKey, value, type === 'keypress' && platform.browser.isFirefox() ? value : 0);
    55|     }
    56|     dispatcher.dom.dispatchEvent(oEvent);
    57|   }
    58| };
    59| const safari = (type: string, doc: SugarElement<Document>, value: number, modifiers: KeyModifiers, dispatcher: SugarElement<Node>): void => {
    60|   const oEvent = doc.dom.createEvent('Events');
    61|   oEvent.initEvent(type, true, true);
    62|   if (type === 'keypress') {
    63|     (oEvent as any).charCode = value;
    64|   }
    65|   (oEvent as any).which = value;
    66|   (oEvent as any).keyCode = value;
    67|   (oEvent as any).shiftKey = modifiers.shiftKey === true;
    68|   (oEvent as any).ctrlKey = modifiers.ctrlKey === true;
    69|   (oEvent as any).metaKey = modifiers.metaKey === true;
    70|   (oEvent as any).altKey = modifiers.altKey === true;
    71|   dispatcher.dom.dispatchEvent(oEvent);
    72| };
    73| export {
    74|   newModifiers,
    75|   keyevent
    76| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/mouse/Clicks.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| import { Fun, Obj } from '@ephox/katamari';
     2| import { SugarElement, SugarLocation, SugarNode, SugarPosition, Traverse } from '@ephox/sugar';
     3| const leftClickButton = 0;
     4| const middleClickButton = 1;
     5| const rightClickButton = 2;
     6| const leftClickButtons = 1;
     7| const rightClickButtons = 2;
     8| const middleClickButtons = 4;
     9| interface Settings {
    10|   dx?: number;
    11|   dy?: number;
    12|   button?: number;
    13|   buttons?: number;
    14|   ctrlKey?: boolean;
    15|   shiftKey?: boolean;
    16|   altKey?: boolean;
    17|   metaKey?: boolean;
    18|   bubbles?: boolean;
    19|   cancelable?: boolean;
    20| }
    21| type EventType = 'click' | 'mousedown' | 'mouseup' | 'mousemove' | 'mouseover' | 'mouseout' | 'contextmenu';
    22| const event = (type: EventType, { dx, dy, ...settings }: Settings) => (element: SugarElement<Node>): void => {
    23|   const location = (SugarNode.isElement(element) ? SugarLocation.absolute(element) : SugarPosition(0, 0)).translate(dx || 0, dy || 0);
    24|   const event = new MouseEvent(type, {
    25|     screenX: location.left,
    26|     screenY: location.top,
    27|     clientX: location.left,
    28|     clientY: location.top,
    29|     bubbles: true,
    30|     cancelable: true,
    31|     ...settings
    32|   });
    33|   element.dom.dispatchEvent(event);
    34| };
    35| const click = (settings: Settings) => (element: SugarElement<Node>): void => {
    36|   const dom = element.dom;
    37|   Obj.get(dom as any, 'click').fold(() => event('click', settings)(element), Fun.call);
    38| };
    39| const mouseDown = Fun.curry(event, 'mousedown');
    40| const mouseUp = Fun.curry(event, 'mouseup');
    41| const mouseMove = Fun.curry(event, 'mousemove');
    42| const mouseOver = Fun.curry(event, 'mouseover');
    43| const mouseOut = Fun.curry(event, 'mouseout');
    44| const contextMenu = (settings: Settings): (element: SugarElement<Node>) => void =>
    45|   event('contextmenu', { button: rightClickButton, ...settings });
    46| const trigger = (element: SugarElement<HTMLElement>): void => {
    47|   const ele = element.dom;
    48|   if (ele.click !== undefined) {
    49|     return ele.click();
    50|   }
    51|   point('click', leftClickButton, element, 0, 0);
    52|   return;
    53| };
    54| const point = (type: string, button: number, element: SugarElement<Node>, x: number, y: number): void => {
    55|   const ev: MouseEvent = Traverse.owner(element).dom.createEvent('MouseEvents');
    56|   ev.initMouseEvent(
    57|     type,
    58|     true /* bubble */, true /* cancelable */,
    59|     window, null,
    60|     x, y, x, y, /* coordinates */
    61|     false, false, false, false, /* modifier keys */
    62|     button, null
    63|   );
    64|   element.dom.dispatchEvent(ev);
    65| };
    66| export {
    67|   event,
    68|   Settings,
    69|   EventType,
    70|   leftClickButton,
    71|   middleClickButton,
    72|   rightClickButton,
    73|   leftClickButtons,
    74|   rightClickButtons,
    75|   middleClickButtons,
    76|   click,
    77|   mouseDown,
    78|   mouseUp,
    79|   mouseMove,
    80|   mouseOver,
    81|   mouseOut,
    82|   contextMenu,
    83|   point,
    84|   trigger
    85| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/pipe/Pipe.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| import { addStackTrace, TestLogs } from '../api/TestLogs';
     2| export type NextFn<T> = (value: T, logs: TestLogs) => void;
     3| export type DieFn = (err: any, logs: TestLogs) => void;
     4| export type RunFn<T, U> = (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void;
     5| export const Pipe = <T, U>(f: RunFn<T, U>): RunFn<T, U> => (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs): void => {
     6|   const bounceNext = (value, nextLogs) => {
     7|     Promise.resolve().then(() => {
     8|       next(value, nextLogs);
     9|     });
    10|   };
    11|   try {
    12|     f(value, bounceNext, die, logs);
    13|   } catch (err) {
    14|     const logsWithTrace = addStackTrace(logs, err);
    15|     die(err, logsWithTrace);
    16|   }
    17| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/server/SeleniumAction.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| import { DataType, Http } from '@ephox/jax';
     2| import { Chain } from '../api/Chain';
     3| import { Step } from '../api/Step';
     4| const postInfo = (path: string, info: any, die: (err: any) => void, next: (v: {}) => void): void => {
     5|   Http.post({
     6|     url: path,
     7|     body: {
     8|       type: DataType.JSON,
     9|       data: info
    10|     },
    11|     responseType: DataType.JSON
    12|   }).get((res) => {
    13|     res.fold((e) => die(JSON.stringify(e)), next);
    14|   });
    15| };
    16| const sPerform = <T> (path: string, info: any): Step<T, T> =>
    17|   Step.async<T>((next, die) => {
    18|     postInfo(path, info, die, next);
    19|   });
    20| const cPerform = <T> (path: string): Chain<T, T> =>
    21|   Chain.async((info, next, die) => {
    22|     postInfo(path, info, die, next);
    23|   });
    24| const pPerform = (path: string, info: any): Promise<{}> => {
    25|   return new Promise(((resolve, reject) => {
    26|     postInfo(path, info, reject, resolve);
    27|   }));
    28| };
    29| export {
    30|   sPerform,
    31|   cPerform,
    32|   pPerform
    33| };


# ====================================================================
# FILE: modules/agar/src/main/ts/ephox/agar/touch/Touches.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| import { SugarElement, SugarLocation, SugarNode, Traverse } from '@ephox/sugar';
     2| const point = (type: string, element: SugarElement<Node>, x: number, y: number): void => {
     3|   const touch = {
     4|     identifier: Date.now(),
     5|     target: element.dom,
     6|     clientX: x,
     7|     clientY: y,
     8|     pageX: x,
     9|     pageY: y,
    10|     radiusX: 2.5,
    11|     radiusY: 2.5,
    12|     rotationAngle: 10,
    13|     force: 0.5
    14|   };
    15|   if (typeof TouchEvent === 'function' && typeof Touch === 'function') {
    16|     const touchAction = new Touch(touch);
    17|     const ev: TouchEvent = new TouchEvent(type, {
    18|       cancelable: true,
    19|       bubbles: true,
    20|       view: window,
    21|       touches: [ touchAction ],
    22|       targetTouches: [],
    23|       changedTouches: [ touchAction ]
    24|     });
    25|     element.dom.dispatchEvent(ev);
    26|   } else {
    27|     const ev: any = new UIEvent(type, {
    28|       cancelable: true,
    29|       bubbles: true,
    30|       view: window
    31|     });
    32|     ev.touches = [ touch ];
    33|     ev.targetTouches = [];
    34|     ev.changedTouches = [ touch ];
    35|     element.dom.dispatchEvent(ev);
    36|   }
    37| };
    38| const findElement = (element: SugarElement<Node>): SugarElement<Element> =>
    39|   (SugarNode.isText(element) ? Traverse.parent(element).getOrDie() : element) as SugarElement<Element>;
    40| const touch = (eventType: string) => (element: SugarElement<Node>): void => {
    41|   const position = SugarLocation.absolute(findElement(element));
    42|   point(eventType, element, position.left, position.top);
    43| };
    44| const touchAt = (eventType: string) => (dx: number, dy: number) => (element: SugarElement<Node>): void => {
    45|   const position = SugarLocation.absolute(findElement(element));
    46|   point(eventType, element, position.left + dx, position.top + dy);
    47| };
    48| const touchstart = touch('touchstart');
    49| const touchstartAt = touchAt('touchstart');
    50| const touchend = touch('touchend');
    51| const touchendAt = touchAt('touchend');
    52| const touchmove = touch('touchmove');
    53| const touchmoveTo = touchAt('touchmove');
    54| export {
    55|   touchstart,
    56|   touchstartAt,
    57|   touchend,
    58|   touchendAt,
    59|   touchmove,
    60|   touchmoveTo,
    61|   point
    62| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/DraggableResizerDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-86 ---
     1| import { PlatformDetection } from '@ephox/sand';
     2| import { Class, Css, SugarElement, SugarPosition, Traverse } from '@ephox/sugar';
     3| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     4| import { Dragging } from 'ephox/alloy/api/behaviour/Dragging';
     5| import { Unselecting } from 'ephox/alloy/api/behaviour/Unselecting';
     6| import { AlloyComponent } from 'ephox/alloy/api/component/ComponentApi';
     7| import * as Attachment from 'ephox/alloy/api/system/Attachment';
     8| import * as Gui from 'ephox/alloy/api/system/Gui';
     9| import { Button } from 'ephox/alloy/api/ui/Button';
    10| import { Container } from 'ephox/alloy/api/ui/Container';
    11| import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
    12| export default (): void => {
    13|   const gui = Gui.create();
    14|   const body = SugarElement.fromDom(document.body);
    15|   Class.add(gui.element, 'gui-root-demo-container');
    16|   Attachment.attachSystem(body, gui);
    17|   Css.set(body, 'margin-bottom', '2000px');
    18|   const onDrag = (comp: AlloyComponent, targetElement: SugarElement<Node>, delta: SugarPosition) => {
    19|     Traverse.parent(targetElement).bind(Traverse.parent).bind(Traverse.firstChild).each((box) => {
    20|       Css.getRaw(box, 'height').each((h) => {
    21|         const parsedHeight = parseInt(h, 10);
    22|         const newHeight = parsedHeight + delta.top;
    23|         Css.set(box, 'height', newHeight + 'px');
    24|       });
    25|     });
    26|   };
    27|   HtmlDisplay.section(
    28|     gui,
    29|     'Drag the X to resize the box',
    30|     Container.sketch({
    31|       dom: {
    32|         styles: {
    33|           width: '500px'
    34|         }
    35|       },
    36|       components: [
    37|         Container.sketch({
    38|           dom: {
    39|             tag: 'div',
    40|             styles: {
    41|               background: 'blue',
    42|               height: '200px',
    43|               border: '2px solid black'
    44|             }
    45|           }
    46|         }),
    47|         Container.sketch({
    48|           dom: {
    49|             styles: {
    50|               position: 'relative'
    51|             }
    52|           },
    53|           components: [
    54|             Button.sketch({
    55|               dom: {
    56|                 tag: 'span',
    57|                 innerHtml: 'X',
    58|                 styles: {
    59|                   position: 'absolute',
    60|                   right: '0px',
    61|                   bottom: '0px',
    62|                   padding: '10px',
    63|                   display: 'inline-block',
    64|                   background: '#333',
    65|                   color: '#fff'
    66|                 }
    67|               },
    68|               buttonBehaviours: Behaviour.derive([
    69|                 Dragging.config({
    70|                   mode: PlatformDetection.detect().deviceType.isTouch() ? 'touch' : 'mouse',
    71|                   blockerClass: 'blocker',
    72|                   repositionTarget: false,
    73|                   onDrag
    74|                 }),
    75|                 Unselecting.config({ })
    76|               ]),
    77|               eventOrder: {
    78|                 mousedown: [ 'dragging', 'alloy.base.behaviour' ]
    79|               }
    80|             })
    81|           ]
    82|         })
    83|       ]
    84|     })
    85|   );
    86| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/DragnDropDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| import { Class, Css, Replication, SugarElement } from '@ephox/sugar';
     2| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     3| import { DragnDrop } from 'ephox/alloy/api/behaviour/DragnDrop';
     4| import * as Attachment from 'ephox/alloy/api/system/Attachment';
     5| import * as Gui from 'ephox/alloy/api/system/Gui';
     6| import { Button } from 'ephox/alloy/api/ui/Button';
     7| import { Container } from 'ephox/alloy/api/ui/Container';
     8| import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
     9| export default (): void => {
    10|   const gui = Gui.create();
    11|   const body = SugarElement.fromDom(document.body);
    12|   Class.add(gui.element, 'gui-root-demo-container');
    13|   Attachment.attachSystem(body, gui);
    14|   Css.set(body, 'margin-bottom', '2000px');
    15|   const createDropZone = (dropEffect: string) => Container.sketch({
    16|     dom: {
    17|       tag: 'div',
    18|       innerHtml: `Drop zone that accepts <b>${dropEffect}</b> also accepts files`,
    19|       styles: {
    20|         'margin': '10px 10px 20px 10px',
    21|         'padding': '20px',
    22|         'height': '40px',
    23|         'border': '3px dashed black',
    24|         'text-align': 'center'
    25|       }
    26|     },
    27|     containerBehaviours: Behaviour.derive([
    28|       DragnDrop.config({
    29|         mode: 'drop',
    30|         type: 'text/plain',
    31|         dropEffect,
    32|         onDrop: (_component, dropEvent) => {
    33|           console.log('onDrop', {
    34|             data: dropEvent.data,
    35|             files: dropEvent.files
    36|           });
    37|         },
    38|         onDrag: (_component, _simulatedEvent) => {
    39|         },
    40|         onDragover: (_component, _simulatedEvent) => {
    41|         },
    42|         onDragenter: (_component, _simulatedEvent) => {
    43|         },
    44|         onDragleave: (_component, _simulatedEvent) => {
    45|         }
    46|       })
    47|     ])
    48|   });
    49|   const createDraggable = (effectAllowed: string, data: string) => Button.sketch({
    50|     dom: {
    51|       tag: 'span',
    52|       innerHtml: `${effectAllowed}`,
    53|       styles: {
    54|         padding: '10px',
    55|         margin: '10px',
    56|         border: '1px solid black',
    57|         display: 'inline-block',
    58|         background: 'gray'
    59|       }
    60|     },
    61|     buttonBehaviours: Behaviour.derive([
    62|       DragnDrop.config({
    63|         mode: 'drag',
    64|         type: 'text/plain',
    65|         phoneyTypes: [ '-x-alloy/something' ],
    66|         effectAllowed,
    67|         getData: (_component) => {
    68|           return data;
    69|         },
    70|         getImage: (component) => {
    71|           const clone = Replication.deep<HTMLElement>(component.element);
    72|           Css.set(clone, 'background-color', 'blue');
    73|           return {
    74|             element: clone,
    75|             x: 0,
    76|             y: 0
    77|           };
    78|         },
    79|         canDrag: (_component, _target) =>
    80|           true,
    81|         onDragstart: (_component, _simulatedEvent) => {
    82|         },
    83|         onDragover: (_component, _simulatedEvent) => {
    84|         },
    85|         onDragend: (_component, _simulatedEvent) => {
    86|         }
    87|       })
    88|     ])
    89|   });
    90|   HtmlDisplay.section(
    91|     gui,
    92|     'Drag the gray boxes into the drop zones and check console log for messages.',
    93|     Container.sketch({
    94|       components: [
    95|         Container.sketch({
    96|           components: [
    97|             createDropZone('copy'),
    98|             createDropZone('link'),
    99|             createDropZone('move')
   100|           ]
   101|         }),
   102|         Container.sketch({
   103|           dom: {
   104|             styles: {
   105|               color: 'white'
   106|             }
   107|           },
   108|           components: [
   109|             createDraggable('copy', 'custom data for copy'),
   110|             createDraggable('link', 'custom data for link'),
   111|             createDraggable('move', 'custom data for move'),
   112|             createDraggable('all', 'custom data for all'),
   113|             createDraggable('copyLink', 'custom data for copyLink'),
   114|             createDraggable('linkMove', 'custom data for linkMove'),
   115|             createDraggable('copyMove', 'custom data for copyMove')
   116|           ]
   117|         })
   118|       ]
   119|     })
   120|   );
   121| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/ForeignGuiDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-115 ---
     1| import { Optional, Optionals } from '@ephox/katamari';
     2| import { PlatformDetection } from '@ephox/sand';
     3| import { Css, DomEvent, EventArgs, Height, Insert, InsertAll, SelectorFind, SugarElement, SugarElements, SugarNode, Width } from '@ephox/sugar';
     4| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     5| import { Dragging } from 'ephox/alloy/api/behaviour/Dragging';
     6| import { Pinching } from 'ephox/alloy/api/behaviour/Pinching';
     7| import { Toggling } from 'ephox/alloy/api/behaviour/Toggling';
     8| import * as AlloyEvents from 'ephox/alloy/api/events/AlloyEvents';
     9| import * as NativeEvents from 'ephox/alloy/api/events/NativeEvents';
    10| import * as SystemEvents from 'ephox/alloy/api/events/SystemEvents';
    11| import * as ForeignGui from 'ephox/alloy/api/system/ForeignGui';
    12| import * as Frames from './frames/Frames';
    13| const resize = (element: SugarElement<HTMLElement>, changeX: number, changeY: number): void => {
    14|   const heading = document.querySelector('h2');
    15|   if (heading === null) {
    16|     throw new Error('heading not found');
    17|   } else {
    18|     heading.innerHTML = 'resizing';
    19|     const width = Css.getRaw(element, 'width').map((w) => parseInt(w, 10)).getOrThunk(() => Width.get(element));
    20|     const height = Css.getRaw(element, 'height').map((h) => parseInt(h, 10)).getOrThunk(() => Height.get(element));
    21|     Css.set(element, 'width', (width + changeX) + 'px');
    22|     Css.set(element, 'height', (height + changeY) + 'px');
    23|   }
    24| };
    25| export default (): void => {
    26|   const ephoxUi = SelectorFind.first('#ephox-ui').getOrDie();
    27|   const platform = PlatformDetection.detect();
    28|   const onNode = (name: string) => (elem: SugarElement<Node>): Optional<SugarElement<Node>> =>
    29|     Optionals.someIf(SugarNode.name(elem) === name, elem);
    30|   const contents = '<div><strong>drag1</strong> and <code>click1</code> and <strong>drag2</strong> ' +
    31|     'and <code>click2</code> and <img style="width: 140px; height: 130px;" /></div>';
    32|   const frame = SugarElement.fromTag('iframe');
    33|   Css.set(frame, 'min-width', '80%');
    34|   const onload = DomEvent.bind(frame, 'load', () => {
    35|     onload.unbind();
    36|     Frames.write(
    37|       frame,
    38|       '<html>' +
    39|         '<head>' +
    40|           '<style>' +
    41|             '.selected { color: white; background: black; }' +
    42|             '* { font-size: bigger; }\n' +
    43|             'span { padding: 30px; display: inline-block; border: 1px solid blue; }' +
    44|           '</style>' +
    45|         '</head>' +
    46|         '<body>' +
    47|           contents +
    48|         '</body>' +
    49|       '</html>'
    50|     );
    51|     const root = SugarElement.fromDom(Frames.readDoc(frame).dom.documentElement);
    52|     addAsForeign(root);
    53|   });
    54|   const inlineContainer = SugarElement.fromHtml<HTMLDivElement>(
    55|     contents
    56|   );
    57|   const addAsForeign = (root: SugarElement<HTMLElement>) => {
    58|     const connection = ForeignGui.engage({
    59|       root,
    60|       dispatchers: [
    61|         {
    62|           getTarget: onNode('code'),
    63|           alloyConfig: {
    64|             behaviours: Behaviour.derive([
    65|               Toggling.config({
    66|                 toggleClass: 'selected'
    67|               })
    68|             ]),
    69|             events: AlloyEvents.derive([
    70|               AlloyEvents.run<EventArgs>(NativeEvents.click(), (component, simulatedEvent) => {
    71|                 connection.unproxy(component);
    72|                 connection.dispatchTo(SystemEvents.execute(), simulatedEvent.event);
    73|               })
    74|             ])
    75|           }
    76|         },
    77|         {
    78|           getTarget: onNode('strong'),
    79|           alloyConfig: {
    80|             behaviours: Behaviour.derive([
    81|               Dragging.config({
    82|                 mode: platform.deviceType.isTouch() ? 'touch' : 'mouse',
    83|                 blockerClass: 'blocker'
    84|               })
    85|             ])
    86|           }
    87|         },
    88|         {
    89|           getTarget: onNode('img'),
    90|           alloyConfig: {
    91|             behaviours: Behaviour.derive([
    92|               Pinching.config({
    93|                 onPinch: resize,
    94|                 onPunch: resize
    95|               })
    96|             ])
    97|           }
    98|         }
    99|       ]
   100|     });
   101|     return connection;
   102|   };
   103|   InsertAll.append(ephoxUi,
   104|     SugarElements.fromHtml(
   105|       '<p>This is a demo for alloy delegation. The iframe and the div editor are not alloy components' +
   106|         ' but they need to exhibit alloy behaviours. This is done through ForeignGui</p>' +
   107|       '<p>Drag the <strong>dragx</strong> elements and click on the <code>clickx</code> elements</p>'
   108|     )
   109|   );
   110|   Insert.append(ephoxUi, SugarElement.fromHtml('<h3>IFrame Editor</h3>'));
   111|   Insert.append(ephoxUi, frame);
   112|   Insert.append(ephoxUi, SugarElement.fromHtml('<h3>Div Editor</h3>'));
   113|   Insert.append(ephoxUi, inlineContainer);
   114|   addAsForeign(inlineContainer);
   115| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/InlinesDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-233 ---
     1| import { Arr, Fun, Optional, Result } from '@ephox/katamari';
     2| import { Class, EventArgs, SugarElement, Value } from '@ephox/sugar';
     3| import * as AddEventsBehaviour from 'ephox/alloy/api/behaviour/AddEventsBehaviour';
     4| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     5| import { Keying } from 'ephox/alloy/api/behaviour/Keying';
     6| import { Positioning } from 'ephox/alloy/api/behaviour/Positioning';
     7| import { Tooltipping } from 'ephox/alloy/api/behaviour/Tooltipping';
     8| import { LazySink } from 'ephox/alloy/api/component/CommonTypes';
     9| import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
    10| import * as AlloyEvents from 'ephox/alloy/api/events/AlloyEvents';
    11| import * as NativeEvents from 'ephox/alloy/api/events/NativeEvents';
    12| import * as Attachment from 'ephox/alloy/api/system/Attachment';
    13| import * as Gui from 'ephox/alloy/api/system/Gui';
    14| import { Button } from 'ephox/alloy/api/ui/Button';
    15| import { Container } from 'ephox/alloy/api/ui/Container';
    16| import { InlineView } from 'ephox/alloy/api/ui/InlineView';
    17| import { Input } from 'ephox/alloy/api/ui/Input';
    18| import { tieredMenu as TieredMenu } from 'ephox/alloy/api/ui/TieredMenu';
    19| import * as DemoSink from 'ephox/alloy/demo/DemoSink';
    20| import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
    21| import { AnchorSpec, SelectionAnchorSpec, SubmenuAnchorSpec } from 'ephox/alloy/positioning/mode/Anchoring';
    22| import * as DemoRenders from './forms/DemoRenders';
    23| /* eslint-disable no-console */
    24| export default (): void => {
    25|   const gui = Gui.create();
    26|   const body = SugarElement.fromDom(document.body);
    27|   Class.add(gui.element, 'gui-root-demo-container');
    28|   Attachment.attachSystem(body, gui);
    29|   const sink = DemoSink.make();
    30|   const lazySink: LazySink = (_) => Result.value(sink);
    31|   const inlineComp = GuiFactory.build(
    32|     InlineView.sketch({
    33|       uid: 'inline-comp',
    34|       dom: {
    35|         tag: 'div'
    36|       },
    37|       lazySink: Fun.constant(Result.value(sink))
    38|     })
    39|   );
    40|   const makeItem = (v: string, t: string, c: string): DemoRenders.DemoItem => ({
    41|     type: 'item',
    42|     data: {
    43|       value: v,
    44|       meta: {
    45|         'text': t,
    46|         'item-class': c
    47|       }
    48|     },
    49|     itemBehaviours: Behaviour.derive([
    50|       Tooltipping.config({
    51|         lazySink,
    52|         tooltipDom: {
    53|           tag: 'div',
    54|           styles: {
    55|             background: '#cadbee',
    56|             padding: '3em'
    57|           }
    58|         },
    59|         tooltipComponents: [
    60|           GuiFactory.text(t)
    61|         ],
    62|         anchor: (comp) => ({
    63|           type: 'submenu',
    64|           item: comp
    65|         }),
    66|         onShow: (component, _tooltip) => {
    67|           setTimeout(() => {
    68|             Tooltipping.setComponents(component, [
    69|               {
    70|                 dom: {
    71|                   tag: 'div',
    72|                   innerHtml: 'This lazy loaded'
    73|                 }
    74|               }
    75|             ]);
    76|           }, 2000);
    77|         },
    78|         onHide: (_component, _tooltip) => {
    79|         }
    80|       })
    81|     ])
    82|   });
    83|   const inlineMenu = TieredMenu.sketch({
    84|     dom: {
    85|       tag: 'div'
    86|     },
    87|     onEscape: () => {
    88|       console.log('inline.menu.escape');
    89|       return Optional.some<boolean>(true);
    90|     },
    91|     onExecute: () => {
    92|       console.log('inline.menu.execute');
    93|       return Optional.some<boolean>(true);
    94|     },
    95|     onOpenMenu: (_sandbox, _menu) => {
    96|     },
    97|     onOpenSubmenu: (sandbox, item, submenu) => {
    98|       const sink = lazySink(sandbox).getOrDie();
    99|       Positioning.position(sink, submenu, {
   100|         anchor: {
   101|           type: 'submenu',
   102|           item
   103|         }
   104|       });
   105|     },
   106|     data: {
   107|       expansions: {
   108|         gamma: 'gamma-menu'
   109|       },
   110|       menus: {
   111|         'dog': DemoRenders.menu({
   112|           value: 'dog',
   113|           items: Arr.map([
   114|             makeItem('alpha', 'Alpha', 'alpha'),
   115|             makeItem('beta', 'Beta', 'beta'),
   116|             makeItem('gamma', 'Gamma', 'gamma'),
   117|             makeItem('delta', 'Delta', 'delta')
   118|           ], DemoRenders.item),
   119|           textkey: 'Dog'
   120|         }),
   121|         'gamma-menu': DemoRenders.menu({
   122|           value: 'gamma-menu',
   123|           items: Arr.map([
   124|             makeItem('gamma-1', 'Gamma-1', 'gamma-1'),
   125|             makeItem('gamma-2', 'Gamma-2', 'gamma-2')
   126|           ], DemoRenders.item),
   127|           textkey: 'gamma-menu'
   128|         })
   129|       },
   130|       primary: 'dog'
   131|     },
   132|     markers: DemoRenders.tieredMarkers()
   133|   });
   134|   gui.add(sink);
   135|   HtmlDisplay.section(
   136|     gui,
   137|     'This inline menu component is a context menu. Right click inside the yellow area',
   138|     Container.sketch({
   139|       dom: {
   140|         styles: {
   141|           background: '#ffff33',
   142|           height: '100px'
   143|         }
   144|       },
   145|       events: AlloyEvents.derive([
   146|         AlloyEvents.run<EventArgs<MouseEvent>>(NativeEvents.contextmenu(), (component, simulatedEvent) => {
   147|           simulatedEvent.event.kill();
   148|           InlineView.showAt(inlineComp, inlineMenu, {
   149|             anchor: {
   150|               type: 'makeshift',
   151|               x: simulatedEvent.event.x,
   152|               y: simulatedEvent.event.y
   153|             }
   154|           });
   155|         })
   156|       ])
   157|     })
   158|   );
   159|   HtmlDisplay.section(
   160|     gui,
   161|     'This inline toolbar shows up when you click in the second input field. Note, ' +
   162|     'how when you focus an empty input, it will attach at the end of the field, and ' +
   163|     'when you focus a non-empty input, it will attach below',
   164|     Container.sketch({
   165|       containerBehaviours: Behaviour.derive([
   166|         Keying.config({
   167|           mode: 'cyclic',
   168|           selector: 'input'
   169|         })
   170|       ]),
   171|       components: [
   172|         Input.sketch({
   173|           inputStyles: { 'display': 'block', 'margin-bottom': '50px' }
   174|         }),
   175|         Input.sketch({
   176|           inputStyles: { display: 'block' },
   177|           inputBehaviours: Behaviour.derive([
   178|             AddEventsBehaviour.config('adhoc-show-popup', [
   179|               AlloyEvents.run(NativeEvents.focusin(), (input) => {
   180|                 const emptyAnchor: SubmenuAnchorSpec = {
   181|                   type: 'submenu',
   182|                   item: input
   183|                 };
   184|                 const nonEmptyAnchor: SelectionAnchorSpec = {
   185|                   type: 'selection',
   186|                   root: gui.element
   187|                 };
   188|                 const anchor: AnchorSpec = Value.get(input.element).length > 0 ? nonEmptyAnchor : emptyAnchor;
   189|                 InlineView.showAt(inlineComp, Container.sketch({
   190|                   containerBehaviours: Behaviour.derive([
   191|                     Keying.config({
   192|                       mode: 'flow',
   193|                       selector: 'button'
   194|                     })
   195|                   ]),
   196|                   components: [
   197|                     Button.sketch({
   198|                       dom: {
   199|                         tag: 'button',
   200|                         innerHtml: 'B'
   201|                       },
   202|                       action: () => {
   203|                         console.log('inline bold');
   204|                       }
   205|                     }),
   206|                     Button.sketch({
   207|                       dom: {
   208|                         tag: 'button',
   209|                         innerHtml: 'I'
   210|                       },
   211|                       action: () => {
   212|                         console.log('inline italic');
   213|                       }
   214|                     }),
   215|                     Button.sketch({
   216|                       dom: {
   217|                         tag: 'button',
   218|                         innerHtml: 'U'
   219|                       },
   220|                       action: () => {
   221|                         console.log('inline underline');
   222|                       }
   223|                     })
   224|                   ]
   225|                 }), { anchor });
   226|               })
   227|             ])
   228|           ])
   229|         })
   230|       ]
   231|     })
   232|   );
   233| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/PinchingDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| import { Css, Height, SelectorFind, SugarElement, Width } from '@ephox/sugar';
     2| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     3| import { Pinching } from 'ephox/alloy/api/behaviour/Pinching';
     4| import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
     5| import * as Attachment from 'ephox/alloy/api/system/Attachment';
     6| import * as Gui from 'ephox/alloy/api/system/Gui';
     7| export default (): void => {
     8|   const ephoxUi = SelectorFind.first('#ephox-ui').getOrDie();
     9|   const resize = (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => {
    10|     const width = Css.getRaw(element, 'width').map((w) => parseInt(w, 10)).getOrThunk(() => Width.get(element));
    11|     const height = Css.getRaw(element, 'height').map((h) => parseInt(h, 10)).getOrThunk(() => Height.get(element));
    12|     Css.set(element, 'width', (width + changeX) + 'px');
    13|     Css.set(element, 'height', (height + changeY) + 'px');
    14|   };
    15|   const box = GuiFactory.build({
    16|     dom: {
    17|       tag: 'div',
    18|       classes: [ 'demo-pinch-box' ],
    19|       styles: {
    20|         width: '200px',
    21|         height: '200px',
    22|         background: 'black'
    23|       }
    24|     },
    25|     behaviours: Behaviour.derive([
    26|       Pinching.config({
    27|         onPinch: (span, changeX, changeY) => {
    28|           resize(span, changeX, changeY);
    29|         },
    30|         onPunch: (span, changeX, changeY) => {
    31|           resize(span, changeX, changeY);
    32|         }
    33|       })
    34|     ])
    35|   });
    36|   const gui = Gui.create();
    37|   gui.add(box);
    38|   Attachment.attachSystem(ephoxUi, gui);
    39| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/SliderDemo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-222 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { PlatformDetection } from '@ephox/sand';
     3| import { Class, Css, DomEvent, Insert, SugarElement } from '@ephox/sugar';
     4| import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
     5| import { Keying } from 'ephox/alloy/api/behaviour/Keying';
     6| import { Replacing } from 'ephox/alloy/api/behaviour/Replacing';
     7| import { Toggling } from 'ephox/alloy/api/behaviour/Toggling';
     8| import { AlloyComponent } from 'ephox/alloy/api/component/ComponentApi';
     9| import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
    10| import * as Gui from 'ephox/alloy/api/system/Gui';
    11| import { Container } from 'ephox/alloy/api/ui/Container';
    12| import { Slider } from 'ephox/alloy/api/ui/Slider';
    13| import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
    14| import { SliderValue, SliderValueXY } from 'ephox/alloy/ui/types/SliderTypes';
    15| export default (): void => {
    16|   const gui = Gui.create();
    17|   const body = SugarElement.fromDom(document.body);
    18|   Class.add(gui.element, 'gui-root-demo-container');
    19|   Insert.append(body, gui.element);
    20|   const slider1 = HtmlDisplay.section(
    21|     gui,
    22|     'This is a basic slider from [20, 100] with snapping to grid at 10',
    23|     Slider.sketch({
    24|       dom: {
    25|         tag: 'div'
    26|       },
    27|       model: {
    28|         mode: 'x',
    29|         minX: 20,
    30|         maxX: 100,
    31|         getInitialValue: Fun.constant(80)
    32|       },
    33|       stepSize: 10,
    34|       snapToGrid: true,
    35|       components: [
    36|         Slider.parts.spectrum({
    37|           dom: {
    38|             tag: 'div',
    39|             styles: {
    40|               height: '20px',
    41|               background: 'blue',
    42|               outline: '4px solid green'
    43|             }
    44|           }
    45|         }),
    46|         Slider.parts.thumb({
    47|           dom: {
    48|             tag: 'div',
    49|             styles: {
    50|               'height': '30px',
    51|               'width': '10px',
    52|               'top': '0px',
    53|               'background': 'black',
    54|               'padding-top': '-5px'
    55|             }
    56|           }
    57|         })
    58|       ]
    59|     })
    60|   );
    61|   HtmlDisplay.section(
    62|     gui,
    63|     'This is a basic slider with two snapping regions [35] and [75]. The minimum value is 0',
    64|     Slider.sketch({
    65|       dom: { tag: 'div', styles: { 'margin-bottom': '40px' }},
    66|       model: {
    67|         mode: 'y',
    68|         getInitialValue: Fun.constant(35)
    69|       },
    70|       stepSize: 40,
    71|       snapStart: 35,
    72|       snapToGrid: true,
    73|       onDragStart: (_, thumb) => {
    74|         Toggling.on(thumb);
    75|       },
    76|       onDragEnd: (_, thumb) => {
    77|         Toggling.off(thumb);
    78|       },
    79|       onChange: (_slider, thumb, value: SliderValue) => {
    80|         Replacing.set(thumb, [
    81|           GuiFactory.text(value.toString())
    82|         ]);
    83|       },
    84|       onInit: (_slider, thumb, _spectrum, value: SliderValue) => {
    85|         Replacing.set(thumb, [
    86|           GuiFactory.text(value.toString())
    87|         ]);
    88|       },
    89|       components: [
    90|         Slider.parts.spectrum({
    91|           dom: {
    92|             tag: 'div',
    93|             styles: {
    94|               width: '20px', background: 'green', height: '300px'
    95|             }
    96|           }
    97|         }),
    98|         Slider.parts.thumb({
    99|           dom: {
   100|             tag: 'div',
   101|             styles: {
   102|               'border-radius': '20px',
   103|               'width': '25px',
   104|               'height': '25px',
   105|               'border': '1px solid green',
   106|               'background': 'transparent',
   107|               'display': 'flex', 'align-items': 'center', 'justify-content': 'center'
   108|             }
   109|           },
   110|           behaviours: Behaviour.derive([
   111|             Replacing.config({}),
   112|             Toggling.config({
   113|               toggleClass: 'thumb-pressed'
   114|             })
   115|           ])
   116|         })
   117|       ]
   118|     })
   119|   );
   120|   const getColor = (hue: number) => {
   121|     if (hue < 0) {
   122|       return 'black';
   123|     } else if (hue > 360) {
   124|       return 'white';
   125|     } else {
   126|       return 'hsl(' + hue + ', 100%, 50%)';
   127|     }
   128|   };
   129|   const setColor = (thumb: AlloyComponent, hue: number) => {
   130|     Css.set(thumb.element, 'background', getColor(hue));
   131|   };
   132|   HtmlDisplay.section(
   133|     gui,
   134|     'This is a basic color slider with a sliding thumb and edges',
   135|     Slider.sketch({
   136|       dom: {
   137|         tag: 'div'
   138|       },
   139|       model: {
   140|         mode: 'xy',
   141|         minX: 0,
   142|         maxX: 360,
   143|         minY: 0,
   144|         maxY: 360,
   145|         getInitialValue: Fun.constant({ x: 120, y: 120 })
   146|       },
   147|       stepSize: 10,
   148|       onChange: (_slider, thumb, value: SliderValue) => {
   149|         setColor(thumb, (value as SliderValueXY).x);
   150|       },
   151|       onInit: (_slider, thumb, _spectrum, value: SliderValue) => {
   152|         setColor(thumb, (value as SliderValueXY).x);
   153|       },
   154|       components: [
   155|         Container.sketch({
   156|           dom: {
   157|             tag: 'div',
   158|             styles: {
   159|               display: 'flex',
   160|               width: '540px',
   161|               border: '1px solid black'
   162|             }
   163|           },
   164|           components: [
   165|             Slider.parts['left-edge']({
   166|               dom: {
   167|                 tag: 'div',
   168|                 styles: {
   169|                   width: '20px',
   170|                   height: '500px',
   171|                   background: 'black'
   172|                 }
   173|               }
   174|             }),
   175|             Slider.parts.spectrum({
   176|               dom: {
   177|                 tag: 'div',
   178|                 styles: {
   179|                   height: '500px',
   180|                   background: 'linear-gradient(to right, hsl(0, 100%, 50%) 0%, hsl(60, 100%, 50%) 17%, hsl(120, 100%, 50%) 33%, hsl(180, 100%, 50%) 50%, hsl(240, 100%, 50%) 67%, hsl(300, 100%, 50%) 83%, hsl(360, 100%, 50%) 100%)',
   181|                   width: '500px'
   182|                 }
   183|               }
   184|             }),
   185|             Slider.parts['right-edge']({
   186|               dom: {
   187|                 tag: 'div',
   188|                 styles: {
   189|                   width: '20px',
   190|                   height: '500px',
   191|                   background: 'white'
   192|                 }
   193|               }
   194|             })
   195|           ]
   196|         }),
   197|         Slider.parts.thumb({
   198|           dom: {
   199|             tag: 'div',
   200|             classes: [ 'demo-sliding-thumb' ],
   201|             styles: {
   202|               'height': '30px',
   203|               'width': '10px',
   204|               'top': '0px',
   205|               'background': 'black',
   206|               'padding-top': '-5px',
   207|               'border': '1px solid black',
   208|               'outline': '1px solid white'
   209|             }
   210|           }
   211|         })
   212|       ]
   213|     })
   214|   );
   215|   const platform = PlatformDetection.detect();
   216|   const isTouch = platform.deviceType.isTouch();
   217|   DomEvent.bind(body, 'click', () => {
   218|     if (!isTouch) {
   219|       Keying.focusIn(slider1);
   220|     }
   221|   });
   222| };


# ====================================================================
# FILE: modules/alloy/src/demo/ts/ephox/alloy/demo/frames/Frames.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarBody, SugarElement, Traverse } from '@ephox/sugar';
     3| /* eslint-disable no-console */
     4| const iframeDoc = (element: SugarElement<HTMLIFrameElement>): Optional<SugarElement<Document>> => {
     5|   const dom = element.dom;
     6|   try {
     7|     const idoc = dom.contentWindow ? dom.contentWindow.document : dom.contentDocument;
     8|     return idoc !== undefined && idoc !== null ? Optional.some(SugarElement.fromDom(idoc)) : Optional.none();
     9|   } catch (err) {
    10|     console.log('Error reading iframe: ', dom);
    11|     console.log('Error was: ' + err);
    12|     return Optional.none();
    13|   }
    14| };
    15| const readDoc = (element: SugarElement<HTMLIFrameElement>): SugarElement<Document> => {
    16|   const optDoc = iframeDoc(element);
    17|   return optDoc.getOrThunk(() =>
    18|     Traverse.owner(element)
    19|   );
    20| };
    21| const write = (element: SugarElement<HTMLIFrameElement>, content: string): void => {
    22|   if (!SugarBody.inBody(element)) {
    23|     throw new Error('Internal error: attempted to write to an iframe that is not n the DOM');
    24|   }
    25|   const doc = readDoc(element);
    26|   const dom = doc.dom;
    27|   dom.open();
    28|   dom.writeln(content);
    29|   dom.close();
    30| };
    31| export {
    32|   write,
    33|   readDoc
    34| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/ComponentStructure.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { Compare, PredicateExists, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import * as AriaControls from '../aria/AriaControls';
     5| import { AnchorSpec } from '../positioning/mode/Anchoring';
     6| const isAriaPartOf = (component: AlloyComponent, queryElem: SugarElement<Node>): boolean =>
     7|   AriaControls.find(queryElem).exists((owner) => isPartOf(component, owner));
     8| const isPartOf = (component: AlloyComponent, queryElem: SugarElement<Node>): boolean =>
     9|   PredicateExists.closest(queryElem, (el) => Compare.eq(el, component.element), Fun.never) || isAriaPartOf(component, queryElem);
    10| const isPartOfAnchor = (anchor: AnchorSpec, queryElem: SugarElement<Node>): boolean =>
    11|   anchor.type === 'hotspot' && isPartOf(anchor.hotspot, queryElem);
    12| export {
    13|   isPartOf,
    14|   isPartOfAnchor
    15| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/Descend.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { SugarElement, SugarNode, SugarText, Traverse } from '@ephox/sugar';
     2| export interface ElementAndOffset<T extends Node> {
     3|   readonly element: SugarElement<T>;
     4|   readonly offset: number;
     5| }
     6| const point = <T extends Node> (element: SugarElement<T>, offset: number): ElementAndOffset<T> => ({
     7|   element,
     8|   offset
     9| });
    10| const descendOnce = (element: SugarElement<Node>, offset: number): ElementAndOffset<Node> => {
    11|   const children = Traverse.children(element);
    12|   if (children.length === 0) {
    13|     return point(element, offset);
    14|   } else if (offset < children.length) {
    15|     return point(children[offset], 0);
    16|   } else {
    17|     const last = children[children.length - 1];
    18|     const len = SugarNode.isText(last) ? SugarText.get(last).length : Traverse.children(last).length;
    19|     return point(last, len);
    20|   }
    21| };
    22| export {
    23|   point,
    24|   descendOnce
    25| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/DomState.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| import { Id, Obj } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| const attrName = Id.generate('dom-data');
     4| const getOrCreate = <A>(element: SugarElement<Node>, f: () => A): A => {
     5|   const elem = element.dom as any;
     6|   const existing = Obj.get<Record<string, A>, string>(elem, attrName);
     7|   const data = existing.getOrThunk(f);
     8|   elem[attrName] = data;
     9|   return data;
    10| };
    11| export {
    12|   getOrCreate
    13| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/EditableFields.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| import { Attribute, SugarElement, SugarNode } from '@ephox/sugar';
     2| const inside = (target: SugarElement<Node>): boolean => (
     3|   (SugarNode.isTag('input')(target) && Attribute.get(target, 'type') !== 'radio') ||
     4|   SugarNode.isTag('textarea')(target)
     5| );
     6| export {
     7|   inside
     8| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/ElementFromPoint.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement, SugarNode, Traverse } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| const insideComponent = (component: AlloyComponent, x: number, y: number): Optional<SugarElement<Element>> => {
     5|   const isInside = (node: SugarElement<Element>) => component.element.dom.contains(node.dom);
     6|   const hasValidRect = (node: SugarElement<Element>): boolean => {
     7|     const elem = SugarNode.isText(node) ? Traverse.parentElement(node) : Optional.some(node);
     8|     return elem.exists((e) => {
     9|       const rect = e.dom.getBoundingClientRect();
    10|       return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
    11|     });
    12|   };
    13|   const doc = Traverse.owner(component.element);
    14|   return SugarElement.fromPoint(doc, x, y).filter(isInside).filter(hasValidRect);
    15| };
    16| export {
    17|   insideComponent
    18| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/alien/OffsetOrigin.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { Optional, Optionals } from '@ephox/katamari';
     2| import { Css, Insert, Remove, SugarElement, SugarLocation, SugarPosition, Traverse } from '@ephox/sugar';
     3| const getOffsetParent = (element: SugarElement<HTMLElement>): Optional<SugarElement<HTMLElement>> => {
     4|   const isFixed = Optionals.is(Css.getRaw(element, 'position'), 'fixed');
     5|   const offsetParent = isFixed ? Optional.none<SugarElement<HTMLElement>>() : Traverse.offsetParent(element);
     6|   return offsetParent.orThunk(() => {
     7|     const marker = SugarElement.fromTag('span');
     8|     return Traverse.parent(element).bind((parent) => {
     9|       Insert.append(parent, marker);
    10|       const offsetParent = Traverse.offsetParent(marker);
    11|       Remove.remove(marker);
    12|       return offsetParent;
    13|     });
    14|   });
    15| };
    16| /*
    17|  * This allows the absolute coordinates to be obtained by adding the
    18|  * origin to the offset coordinates and not needing to know scroll.
    19|  */
    20| const getOrigin = (element: SugarElement<HTMLElement>): SugarPosition =>
    21|   getOffsetParent(element).map(SugarLocation.absolute).getOrThunk(() => SugarPosition(0, 0));
    22| export {
    23|   getOrigin,
    24|   getOffsetParent
    25| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/behaviour/Replacing.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-14 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import * as ReplaceApis from '../../behaviour/replacing/ReplaceApis';
     3| import { ReplacingBehaviour } from '../../behaviour/replacing/ReplacingTypes';
     4| import * as Behaviour from './Behaviour';
     5| const Replacing: ReplacingBehaviour = Behaviour.create({
     6|   fields: [
     7|     FieldSchema.defaultedBoolean('reuseDom', true)
     8|   ],
     9|   name: 'replacing',
    10|   apis: ReplaceApis
    11| });
    12| export {
    13|   Replacing
    14| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/component/Component.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-96 ---
     1| import { StructureSchema } from '@ephox/boulder';
     2| import { Arr, Cell, Optional, Type } from '@ephox/katamari';
     3| import { SugarElement, Traverse } from '@ephox/sugar';
     4| import * as BehaviourBlob from '../../behaviour/common/BehaviourBlob';
     5| import { BehaviourState } from '../../behaviour/common/BehaviourState';
     6| import * as ComponentDom from '../../construct/ComponentDom';
     7| import * as ComponentEvents from '../../construct/ComponentEvents';
     8| import * as CustomDefinition from '../../construct/CustomDefinition';
     9| import { DomDefinitionDetail } from '../../dom/DomDefinition';
    10| import * as DomModification from '../../dom/DomModification';
    11| import * as DomRender from '../../dom/DomRender';
    12| import { UncurriedHandler } from '../../events/EventRegistry';
    13| import { AlloyBehaviour } from '../behaviour/Behaviour';
    14| import { NoContextApi, singleton } from '../system/NoContextApi';
    15| import { AlloySystemApi } from '../system/SystemApi';
    16| import * as CompBehaviours from './CompBehaviours';
    17| import { AlloyComponent } from './ComponentApi';
    18| import { ComponentDetail } from './SpecTypes';
    19| const getDomDefinition = (
    20|   info: CustomDefinition.CustomDetail<any>,
    21|   bList: Array<AlloyBehaviour<any, any>>,
    22|   bData: Record<string, () => Optional<BehaviourBlob.BehaviourConfigAndState<any, BehaviourState>>>
    23| ): DomDefinitionDetail => {
    24|   const definition = CustomDefinition.toDefinition(info);
    25|   const infoModification = CustomDefinition.toModification(info);
    26|   const baseModification = {
    27|     'alloy.base.modification': infoModification
    28|   };
    29|   const modification = bList.length > 0 ? ComponentDom.combine(bData, baseModification, bList, definition) : infoModification;
    30|   return DomModification.merge(definition, modification);
    31| };
    32| const getEvents = (
    33|   info: CustomDefinition.CustomDetail<any>,
    34|   bList: Array<AlloyBehaviour<any, any>>,
    35|   bData: Record<string, () => Optional<BehaviourBlob.BehaviourConfigAndState<any, BehaviourState>>>
    36| ): Record<string, UncurriedHandler> => {
    37|   const baseEvents = {
    38|     'alloy.base.behaviour': CustomDefinition.toEvents(info)
    39|   };
    40|   return ComponentEvents.combine(bData, info.eventOrder, bList, baseEvents).getOrDie();
    41| };
    42| const build = (spec: ComponentDetail, obsoleted: Optional<SugarElement<Node>>): AlloyComponent => {
    43|   const getMe = () => me;
    44|   const systemApi = Cell(singleton);
    45|   const info: CustomDefinition.CustomDetail<any> = StructureSchema.getOrDie(CustomDefinition.toInfo(spec));
    46|   const bBlob = CompBehaviours.generate(spec);
    47|   const bList = BehaviourBlob.getBehaviours(bBlob);
    48|   const bData = BehaviourBlob.getData(bBlob);
    49|   const modDefinition = getDomDefinition(info, bList, bData);
    50|   const item = DomRender.renderToDom(modDefinition, obsoleted);
    51|   const events = getEvents(info, bList, bData);
    52|   const subcomponents = Cell(info.components);
    53|   const connect = (newApi: AlloySystemApi): void => {
    54|     systemApi.set(newApi);
    55|   };
    56|   const disconnect = (): void => {
    57|     systemApi.set(NoContextApi(getMe));
    58|   };
    59|   const syncComponents = (): void => {
    60|     const children = Traverse.children(item);
    61|     const subs = Arr.bind(children, (child) => systemApi.get().getByDom(child).fold(
    62|       () => [ ],
    63|       Arr.pure
    64|     ));
    65|     subcomponents.set(subs);
    66|   };
    67|   const config = (behaviour: AlloyBehaviour<any, any>): Optional<BehaviourBlob.BehaviourConfigAndState<any, any>> => {
    68|     const b = bData;
    69|     const f = Type.isFunction(b[behaviour.name()]) ? b[behaviour.name()] : () => {
    70|       throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));
    71|     };
    72|     return f();
    73|   };
    74|   const hasConfigured = (behaviour: AlloyBehaviour<any, any>): boolean => Type.isFunction(bData[behaviour.name()]);
    75|   const getApis = <A>(): A => info.apis;
    76|   const readState = (behaviourName: string): any => bData[behaviourName]().map((b) => b.state.readState()).getOr('not enabled');
    77|   const me: AlloyComponent = {
    78|     uid: spec.uid,
    79|     getSystem: systemApi.get,
    80|     config,
    81|     hasConfigured,
    82|     spec,
    83|     readState,
    84|     getApis,
    85|     connect,
    86|     disconnect,
    87|     element: item,
    88|     syncComponents,
    89|     components: subcomponents.get,
    90|     events
    91|   };
    92|   return me;
    93| };
    94| export {
    95|   build
    96| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/component/ComponentApi.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { BehaviourConfigAndState } from '../../behaviour/common/BehaviourBlob';
     4| import { UncurriedHandler } from '../../events/EventRegistry';
     5| import { AlloyBehaviour } from '../behaviour/Behaviour';
     6| import { AlloySystemApi } from '../system/SystemApi';
     7| type ReadonlyRecord<K extends keyof any, T> = {
     8|   readonly [P in K]: T;
     9| };
    10| export interface AlloyComponent {
    11|   readonly uid: string;
    12|   readonly getSystem: () => AlloySystemApi;
    13|   readonly config: (behaviour: AlloyBehaviour<any, any>) => Optional<BehaviourConfigAndState<any, any>>;
    14|   readonly hasConfigured: (behaviour: AlloyBehaviour<any, any>) => boolean;
    15|   readonly spec: any;
    16|   readonly readState: (behaviourName: string) => any;
    17|   readonly connect: (newApi: AlloySystemApi) => void;
    18|   readonly disconnect: () => void;
    19|   readonly getApis: <A>() => A;
    20|   readonly element: SugarElement<any>;
    21|   readonly syncComponents: () => void;
    22|   readonly components: () => AlloyComponent[];
    23|   readonly events: ReadonlyRecord<string, UncurriedHandler>;
    24| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/component/ComponentUtil.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from './ComponentApi';
     4| const toElem = (component: AlloyComponent): SugarElement<any> => component.element;
     5| const getByUid = (component: AlloyComponent, uid: string): Optional<AlloyComponent> => component.getSystem().getByUid(uid).toOptional();
     6| export {
     7|   toElem,
     8|   getByUid
     9| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/component/GuiFactory.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Arr, Cell, Fun, Obj, Optional, Result } from '@ephox/katamari';
     3| import { SugarElement, Traverse } from '@ephox/sugar';
     4| import * as DefaultEvents from '../../events/DefaultEvents';
     5| import * as Tagger from '../../registry/Tagger';
     6| import * as CustomSpec from '../../spec/CustomSpec';
     7| import { NoContextApi } from '../system/NoContextApi';
     8| import { AlloySystemApi } from '../system/SystemApi';
     9| import * as GuiTypes from '../ui/GuiTypes';
    10| import * as Component from './Component';
    11| import { AlloyComponent } from './ComponentApi';
    12| import { AlloySpec, PremadeSpec, SimpleOrSketchSpec, SketchSpec } from './SpecTypes';
    13| const buildSubcomponents = (spec: SimpleOrSketchSpec, obsoleted: Optional<SugarElement<Node>>): AlloyComponent[] => {
    14|   const components = Obj.get(spec, 'components').getOr([ ]);
    15|   return obsoleted.fold(
    16|     () => Arr.map(components, build),
    17|     (obs) => Arr.map(components, (c, i) => {
    18|       return buildOrPatch(c, Traverse.child(obs, i));
    19|     })
    20|   );
    21| };
    22| const buildFromSpec = (userSpec: SketchSpec, obsoleted: Optional<SugarElement<Node>>): Result<AlloyComponent, string> => {
    23|   const { events: specEvents, ...spec }: SketchSpec = CustomSpec.make(userSpec);
    24|   const components: AlloyComponent[] = buildSubcomponents(spec, obsoleted);
    25|   const completeSpec = {
    26|     ...spec,
    27|     events: { ...DefaultEvents, ...specEvents },
    28|     components
    29|   };
    30|   return Result.value(
    31|     Component.build(completeSpec, obsoleted)
    32|   );
    33| };
    34| const text = (textContent: string): PremadeSpec => {
    35|   const element = SugarElement.fromText(textContent);
    36|   return external({
    37|     element
    38|   });
    39| };
    40| export interface ExternalElement { uid?: string; element: SugarElement<Node> }
    41| const external = (spec: ExternalElement): PremadeSpec => {
    42|   const extSpec: { uid: Optional<string>; element: SugarElement<Node> } = StructureSchema.asRawOrDie('external.component', StructureSchema.objOfOnly([
    43|     FieldSchema.required('element'),
    44|     FieldSchema.option('uid')
    45|   ]), spec);
    46|   const systemApi = Cell(NoContextApi());
    47|   const connect = (newApi: AlloySystemApi) => {
    48|     systemApi.set(newApi);
    49|   };
    50|   const disconnect = () => {
    51|     systemApi.set(NoContextApi(() => me));
    52|   };
    53|   const uid = extSpec.uid.getOrThunk(() => Tagger.generate('external'));
    54|   Tagger.writeOnly(extSpec.element, uid);
    55|   const me: AlloyComponent = {
    56|     uid,
    57|     getSystem: systemApi.get,
    58|     config: Optional.none,
    59|     hasConfigured: Fun.never,
    60|     connect,
    61|     disconnect,
    62|     getApis: <A>(): A => ({ } as any),
    63|     element: extSpec.element,
    64|     spec,
    65|     readState: Fun.constant('No state'),
    66|     syncComponents: Fun.noop,
    67|     components: Fun.constant([ ]),
    68|     events: { }
    69|   };
    70|   return GuiTypes.premade(me);
    71| };
    72| const uids = Tagger.generate;
    73| const isSketchSpec = (spec: AlloySpec): spec is SketchSpec =>
    74|   Obj.has(spec as SimpleOrSketchSpec, 'uid');
    75| const buildOrPatch = (spec: AlloySpec, obsoleted: Optional<SugarElement<Node>>): AlloyComponent => GuiTypes.getPremade(spec).getOrThunk(() => {
    76|   const userSpecWithUid = isSketchSpec(spec) ? spec : {
    77|     uid: uids(''),
    78|     ...spec
    79|   } as SketchSpec;
    80|   return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();
    81| });
    82| const build = (spec: AlloySpec): AlloyComponent =>
    83|   buildOrPatch(spec, Optional.none());
    84| const premade = GuiTypes.premade;
    85| export {
    86|   build,
    87|   buildOrPatch,
    88|   premade,
    89|   external,
    90|   text
    91| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/events/AlloyTriggers.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import { EventFormat, SimulatedEvent } from '../../events/SimulatedEvent';
     3| import { AlloyComponent } from '../component/ComponentApi';
     4| import * as SystemEvents from './SystemEvents';
     5| const emit = (component: AlloyComponent, event: string): void => {
     6|   dispatchWith(component, component.element, event, { });
     7| };
     8| const emitWith = (component: AlloyComponent, event: string, properties: Record<string, any>): void => {
     9|   dispatchWith(component, component.element, event, properties);
    10| };
    11| const emitExecute = (component: AlloyComponent): void => {
    12|   emit(component, SystemEvents.execute());
    13| };
    14| const dispatch = (component: AlloyComponent, target: SugarElement<Node>, event: string): void => {
    15|   dispatchWith(component, target, event, { });
    16| };
    17| const dispatchWith = (component: AlloyComponent, target: SugarElement<Node>, event: string, properties: Record<string, any>): void => {
    18|   const data = {
    19|     target,
    20|     ...properties
    21|   };
    22|   component.getSystem().triggerEvent(event, target, data);
    23| };
    24| const dispatchEvent = <T extends EventFormat>(component: AlloyComponent, target: SugarElement<Node>, event: string, simulatedEvent: SimulatedEvent<T>): void => {
    25|   component.getSystem().triggerEvent(event, target, simulatedEvent.event);
    26| };
    27| const dispatchFocus = (component: AlloyComponent, target: SugarElement<HTMLElement>): void => {
    28|   component.getSystem().triggerFocus(target, component.element);
    29| };
    30| export {
    31|   emit,
    32|   emitWith,
    33|   emitExecute,
    34|   dispatch,
    35|   dispatchWith,
    36|   dispatchEvent,
    37|   dispatchFocus
    38| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/events/SystemEvents.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { PlatformDetection } from '@ephox/sand';
     3| import { SugarElement } from '@ephox/sugar';
     4| import { CustomEvent } from '../../events/SimulatedEvent';
     5| import { AlloyComponent } from '../component/ComponentApi';
     6| import * as NativeEvents from './NativeEvents';
     7| const prefixName = (name: string) => Fun.constant('alloy.' + name);
     8| const alloy = { tap: prefixName('tap') };
     9| const focus = prefixName('focus');
    10| const postBlur = prefixName('blur.post');
    11| const postPaste = prefixName('paste.post');
    12| const receive = prefixName('receive');
    13| const execute = prefixName('execute');
    14| const focusItem = prefixName('focus.item');
    15| const tap = alloy.tap;
    16| /*
    17|  * Tap event for touch device, otherwise click event
    18|  * @deprecated
    19|  */
    20| const tapOrClick = (): string => PlatformDetection.detect().deviceType.isTouch() ? alloy.tap() : NativeEvents.click();
    21| const longpress = prefixName('longpress');
    22| const sandboxClose = prefixName('sandbox.close');
    23| const typeaheadCancel = prefixName('typeahead.cancel');
    24| const systemInit = prefixName('system.init');
    25| const documentTouchmove = prefixName('system.touchmove');
    26| const documentTouchend = prefixName('system.touchend');
    27| const windowScroll = prefixName('system.scroll');
    28| const windowResize = prefixName('system.resize');
    29| const attachedToDom = prefixName('system.attached');
    30| const detachedFromDom = prefixName('system.detached');
    31| const dismissRequested = prefixName('system.dismissRequested');
    32| const repositionRequested = prefixName('system.repositionRequested');
    33| export interface AlloyFocusShiftedEvent extends CustomEvent {
    34|   readonly prevFocus: Optional<SugarElement<HTMLElement>>;
    35|   readonly newFocus: Optional<SugarElement<HTMLElement>>;
    36| }
    37| const focusShifted = prefixName('focusmanager.shifted');
    38| const slotVisibility = prefixName('slotcontainer.visibility');
    39| export interface AlloySlotVisibilityEvent extends CustomEvent {
    40|   readonly name: string;
    41|   readonly visible: boolean;
    42| }
    43| export interface AlloyChangeTabEvent extends CustomEvent {
    44|   readonly button: AlloyComponent;
    45| }
    46| export interface AlloyDismissTabEvent extends CustomEvent {
    47|   readonly button: AlloyComponent;
    48| }
    49| const changeTab = prefixName('change.tab');
    50| const dismissTab = prefixName('dismiss.tab');
    51| const highlight = prefixName('highlight');
    52| const dehighlight = prefixName('dehighlight');
    53| export {
    54|   focus,
    55|   postBlur,
    56|   postPaste,
    57|   receive,
    58|   execute,
    59|   focusItem,
    60|   tap,
    61|   tapOrClick,
    62|   longpress,
    63|   sandboxClose,
    64|   systemInit,
    65|   typeaheadCancel,
    66|   documentTouchmove,
    67|   documentTouchend,
    68|   windowScroll,
    69|   windowResize,
    70|   dismissRequested,
    71|   repositionRequested,
    72|   focusShifted,
    73|   attachedToDom,
    74|   detachedFromDom,
    75|   changeTab,
    76|   dismissTab,
    77|   slotVisibility,
    78|   highlight,
    79|   dehighlight
    80| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/focus/FocusManagers.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Compare, Focus, SugarElement } from '@ephox/sugar';
     3| import { Highlighting } from '../behaviour/Highlighting';
     4| import { AlloyComponent } from '../component/ComponentApi';
     5| import * as AlloyTriggers from '../events/AlloyTriggers';
     6| import * as SystemEvents from '../events/SystemEvents';
     7| const reportFocusShifting = (component: AlloyComponent, prevFocus: Optional<SugarElement<HTMLElement>>, newFocus: Optional<SugarElement<HTMLElement>>) => {
     8|   const noChange = prevFocus.exists((p) => newFocus.exists((n) => Compare.eq(n, p)));
     9|   if (!noChange) {
    10|     AlloyTriggers.emitWith(component, SystemEvents.focusShifted(), {
    11|       prevFocus,
    12|       newFocus
    13|     });
    14|   }
    15| };
    16| export interface FocusManager {
    17|   get: (component: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
    18|   set: (component: AlloyComponent, focusee: SugarElement<HTMLElement>) => void;
    19| }
    20| const dom = (): FocusManager => {
    21|   const get = (component: AlloyComponent) => Focus.search(component.element);
    22|   const set = (component: AlloyComponent, focusee: SugarElement<HTMLElement>) => {
    23|     const prevFocus = get(component);
    24|     component.getSystem().triggerFocus(focusee, component.element);
    25|     const newFocus = get(component);
    26|     reportFocusShifting(component, prevFocus, newFocus);
    27|   };
    28|   return {
    29|     get,
    30|     set
    31|   };
    32| };
    33| const highlights = (): FocusManager => {
    34|   const get = (component: AlloyComponent) => Highlighting.getHighlighted(component).map((item) => item.element);
    35|   const set = (component: AlloyComponent, element: SugarElement<HTMLElement>) => {
    36|     const prevFocus = get(component);
    37|     component.getSystem().getByDom(element).fold(Fun.noop, (item) => {
    38|       Highlighting.highlight(component, item);
    39|     });
    40|     const newFocus = get(component);
    41|     reportFocusShifting(component, prevFocus, newFocus);
    42|   };
    43|   return {
    44|     get,
    45|     set
    46|   };
    47| };
    48| export {
    49|   dom,
    50|   highlights
    51| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/system/Attachment.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { Insert, Remove, SugarBody, SugarElement, Traverse } from '@ephox/sugar';
     3| import * as InternalAttachment from '../../system/InternalAttachment';
     4| import { AlloyComponent } from '../component/ComponentApi';
     5| import { GuiSystem } from './Gui';
     6| const attach = (parent: AlloyComponent, child: AlloyComponent): void => {
     7|   attachWith(parent, child, Insert.append);
     8| };
     9| const attachWith = (parent: AlloyComponent, child: AlloyComponent, insertion: (parent: SugarElement<Node>, child: SugarElement<Node>) => void): void => {
    10|   parent.getSystem().addToWorld(child);
    11|   insertion(parent.element, child.element);
    12|   if (SugarBody.inBody(parent.element)) {
    13|     InternalAttachment.fireAttaching(child);
    14|   }
    15|   parent.syncComponents();
    16| };
    17| const doDetach = (component: AlloyComponent) => {
    18|   InternalAttachment.fireDetaching(component);
    19|   Remove.remove(component.element);
    20|   component.getSystem().removeFromWorld(component);
    21| };
    22| const detach = (component: AlloyComponent): void => {
    23|   const parent = Traverse.parent(component.element).bind((p) => component.getSystem().getByDom(p).toOptional());
    24|   doDetach(component);
    25|   parent.each((p) => {
    26|     p.syncComponents();
    27|   });
    28| };
    29| const detachChildren = (component: AlloyComponent): void => {
    30|   const subs = component.components();
    31|   Arr.each(subs, doDetach);
    32|   Remove.empty(component.element);
    33|   component.syncComponents();
    34| };
    35| const attachSystem = (element: SugarElement<Node>, guiSystem: GuiSystem): void => {
    36|   attachSystemWith(element, guiSystem, Insert.append);
    37| };
    38| const attachSystemAfter = (element: SugarElement<Node>, guiSystem: GuiSystem): void => {
    39|   attachSystemWith(element, guiSystem, Insert.after);
    40| };
    41| const attachSystemWith = (element: SugarElement<Node>, guiSystem: GuiSystem, inserter: (marker: SugarElement<Node>, element: SugarElement<Node>) => void): void => {
    42|   inserter(element, guiSystem.element);
    43|   const children = Traverse.children(guiSystem.element);
    44|   Arr.each(children, (child) => {
    45|     guiSystem.getByDom(child).each(InternalAttachment.fireAttaching);
    46|   });
    47| };
    48| const detachSystem = (guiSystem: GuiSystem): void => {
    49|   const children = Traverse.children(guiSystem.element);
    50|   Arr.each(children, (child) => {
    51|     guiSystem.getByDom(child).each(InternalAttachment.fireDetaching);
    52|   });
    53|   Remove.remove(guiSystem.element);
    54| };
    55| export {
    56|   attach,
    57|   attachWith,
    58|   detach,
    59|   detachChildren,
    60|   attachSystem,
    61|   attachSystemAfter,
    62|   detachSystem
    63| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/system/ForeignGui.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-159 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Arr, Obj, Optional } from '@ephox/katamari';
     3| import { DomEvent, EventArgs, Insert, SugarElement } from '@ephox/sugar';
     4| import { UncurriedHandler } from '../../events/EventRegistry';
     5| import * as SimulatedEvent from '../../events/SimulatedEvent';
     6| import ForeignCache from '../../foreign/ForeignCache';
     7| import * as Tagger from '../../registry/Tagger';
     8| import { AlloyBehaviourRecord } from '../behaviour/Behaviour';
     9| import { AlloyComponent } from '../component/ComponentApi';
    10| import * as GuiFactory from '../component/GuiFactory';
    11| import { AlloyEventRecord } from '../events/AlloyEvents';
    12| import * as Gui from './Gui';
    13| export interface ForeignGuiSpec {
    14|   readonly root: SugarElement<Node>;
    15|   readonly dispatchers: Dispatcher[];
    16|   readonly insertion?: (root: SugarElement<Node>, system: Gui.GuiSystem) => void;
    17| }
    18| export interface DispatchedAlloyConfig {
    19|   readonly events?: AlloyEventRecord;
    20|   readonly behaviours: AlloyBehaviourRecord;
    21|   readonly eventOrder?: Record<string, string[]>;
    22| }
    23| export interface Dispatcher {
    24|   readonly getTarget: (elem: SugarElement<Node>) => Optional<SugarElement<Node>>;
    25|   readonly alloyConfig: DispatchedAlloyConfig;
    26| }
    27| export interface ForeignGuiDetail {
    28|   readonly root: SugarElement<Node>;
    29|   readonly dispatchers: Dispatcher[];
    30|   readonly insertion: (root: SugarElement<Node>, system: Gui.GuiSystem) => void;
    31| }
    32| interface DispatcherMission {
    33|   readonly target: SugarElement<Node>;
    34|   readonly dispatcher: Dispatcher;
    35| }
    36| export interface ForeignGuiConnection {
    37|   readonly dispatchTo: (type: string, event: EventArgs) => void;
    38|   readonly unproxy: (component: AlloyComponent) => void;
    39|   readonly disengage: () => void;
    40| }
    41| const schema = StructureSchema.objOfOnly([
    42|   FieldSchema.required('root'),
    43|   FieldSchema.requiredArrayOfObj('dispatchers', [
    44|     FieldSchema.required('getTarget'),
    45|     FieldSchema.required('alloyConfig')
    46|   ]),
    47|   FieldSchema.defaulted('insertion', (root: SugarElement<Node>, system: AlloyComponent) => {
    48|     Insert.append(root, system.element);
    49|   })
    50| ]);
    51| /*
    52|  * ForeignGui is an experimental concept
    53|  *
    54|  * Essentially, the basic idea is that we want to be able to use alloy behaviours and events
    55|  * on elements that were not created by alloy. The common example of this is the contents inside
    56|  * an iframe of an editor. We did not create the content (it is also volatile), but we still
    57|  * want to be able to pinch it, drag it, toggle it etc. However, we don't have Component
    58|  * instances for any of these things inside the alloy root ... they are completely separate.
    59|  *
    60|  * Most behaviours (probably not all) require configuration and a connection to an alloy
    61|  * root to exist for a small amount of time to execute their actions. For this reason, we
    62|  * create an internal alloy root for this foreign object (and insert it using insertion, so
    63|  * for iframes, it would often be inserted at the document level so that it wasn't in the content),
    64|  * and connect and disconnect the external elements to that. The elements themselves store their
    65|  * configuration so that we get garbage collecting benefits (a previous version stored them in
    66|  * a separate map), and that configuration can be retrieved from the element. If it isn't there,
    67|  * it is recreated (and any state with it). The configuration is maintained on the DOM object
    68|  * itself (through DomState), and the connection to the internal alloy root (/system) is removed after
    69|  * execution of the action.
    70|  *
    71|  * The connection to the internal alloy root can be required if the behaviour needs to create additional
    72|  * components (e.g. blockers for dragging). However, because these components are already within
    73|  * the internal alloy root, they don't need to be handled in this way (they are just maintained
    74|  * like normal alloy components having been built by alloy). Therefore, we exit dispatching if the
    75|  * target is within our internal system.
    76|  *
    77|  * A ForeignGui is setup with a list of dispatchers. Dispatchers tell alloy which things should have
    78|  * alloy like behaviour. Note, that each dispatcher has a getTarget, which returns an option of element.
    79|  * The purpose of this is it means that you may choose to add the behaviour to an *ancestor* of the target
    80|  * element (e.g. table) rather than the target element itself (td). The alloyConfig lists the behaviours and
    81|  * events to proxy for this dispatcher.
    82|  */
    83| const supportedEvents = [
    84|   'click', 'mousedown', 'mousemove', 'touchstart', 'touchend', 'gesturestart', 'touchmove'
    85| ];
    86| const findDispatcher = (dispatchers: Dispatcher[], target: SugarElement<Node>): Optional<DispatcherMission> =>
    87|   Arr.findMap(dispatchers, (dispatcher: Dispatcher) => dispatcher.getTarget(target).map((newTarget) => ({
    88|     target: newTarget,
    89|     dispatcher
    90|   })));
    91| const getProxy = <T extends SimulatedEvent.EventFormat>(event: T, target: SugarElement<Node>) => {
    92|   const component = GuiFactory.build(
    93|     GuiFactory.external({ element: target })
    94|   );
    95|   const simulatedEvent = SimulatedEvent.fromTarget(event, target);
    96|   return {
    97|     component,
    98|     simulatedEvent
    99|   };
   100| };
   101| const engage = (spec: ForeignGuiSpec): ForeignGuiConnection => {
   102|   const detail: ForeignGuiDetail = StructureSchema.asRawOrDie('ForeignGui', schema, spec);
   103|   const gui = Gui.create();
   104|   detail.insertion(detail.root, gui);
   105|   const cache = ForeignCache();
   106|   const domEvents = Arr.map(supportedEvents, (type) => DomEvent.bind(detail.root, type, (event) => {
   107|     dispatchTo(type, event);
   108|   }));
   109|   const proxyFor = <T extends SimulatedEvent.EventFormat>(event: T, target: SugarElement<Node>, descHandler: UncurriedHandler) => {
   110|     const proxy = getProxy(event, target);
   111|     const component = proxy.component;
   112|     gui.addToWorld(component);
   113|     const handler = descHandler.handler;
   114|     handler(component, proxy.simulatedEvent);
   115|     unproxy(component);
   116|   };
   117|   const dispatchTo = (type: string, event: EventArgs): void => {
   118|     /*
   119|      * 1. Check that the event did not originate in our internal alloy root. If it did,
   120|      * we don't need to handle it here. The alloy root will handle it as usual.
   121|      * 2. Find the dispatcher based on the target element. It will find the first dispatcher
   122|      * that matches
   123|      * 3. Retrieve the configuration for this external element from its DOM state or create
   124|      * it if it doesn't already exist
   125|      * 4. If the event is supported:
   126|      * a) create a thin proxy wrapping for the DOM element to have component like APIs
   127|      * b) add it to the internal system
   128|      * c) execute the event handler
   129|      * d) remove it from the internal system and clear any DOM markers (alloy-ids etc)
   130|      */
   131|     if (gui.element.dom.contains(event.target.dom)) {
   132|       return;
   133|     }
   134|     findDispatcher(detail.dispatchers, event.target).each((mission) => {
   135|       const data = cache.getEvents(mission.target, mission.dispatcher.alloyConfig);
   136|       const events = data.evts;
   137|       if (Obj.hasNonNullableKey(events, type)) {
   138|         proxyFor(event, mission.target, events[type]);
   139|       }
   140|     });
   141|   };
   142|   const unproxy = (component: AlloyComponent): void => {
   143|     gui.removeFromWorld(component);
   144|     Tagger.revoke(component.element);
   145|   };
   146|   const disengage = (): void => {
   147|     Arr.each(domEvents, (e) => {
   148|       e.unbind();
   149|     });
   150|   };
   151|   return {
   152|     dispatchTo,
   153|     unproxy,
   154|     disengage
   155|   };
   156| };
   157| export {
   158|   engage
   159| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/system/Gui.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-185 ---
     1| import { Arr, Fun, Result } from '@ephox/katamari';
     2| import { Compare, EventArgs, Focus, Remove, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
     3| import * as Debugging from '../../debugging/Debugging';
     4| import * as DescribedHandler from '../../events/DescribedHandler';
     5| import * as GuiEvents from '../../events/GuiEvents';
     6| import { FocusingEvent, ReceivingInternalEvent } from '../../events/SimulatedEvent';
     7| import * as Triggers from '../../events/Triggers';
     8| import { Registry } from '../../registry/Registry';
     9| import * as Tagger from '../../registry/Tagger';
    10| import { AlloyComponent } from '../component/ComponentApi';
    11| import * as GuiFactory from '../component/GuiFactory';
    12| import * as SystemEvents from '../events/SystemEvents';
    13| import { Container } from '../ui/Container';
    14| import * as Attachment from './Attachment';
    15| import { AlloySystemApi } from './SystemApi';
    16| export interface GuiSystem {
    17|   readonly root: AlloyComponent;
    18|   readonly element: SugarElement<HTMLElement>;
    19|   readonly destroy: () => void;
    20|   readonly add: (component: AlloyComponent) => void;
    21|   readonly remove: (component: AlloyComponent) => void;
    22|   readonly getByUid: (uid: string) => Result<AlloyComponent, Error>;
    23|   readonly getByDom: (element: SugarElement<Node>) => Result<AlloyComponent, Error>;
    24|   readonly addToWorld: (comp: AlloyComponent) => void;
    25|   readonly removeFromWorld: (comp: AlloyComponent) => void;
    26|   readonly broadcast: <T>(message: T) => void;
    27|   readonly broadcastOn: <T>(channels: string[], message: T) => void;
    28|   readonly broadcastEvent: (eventName: string, event: EventArgs) => void;
    29| }
    30| export type message = Record<string, any>;
    31| const create = (): GuiSystem => {
    32|   const root = GuiFactory.build(
    33|     Container.sketch({
    34|       dom: {
    35|         tag: 'div'
    36|       }
    37|     })
    38|   );
    39|   return takeover(root);
    40| };
    41| const takeover = (root: AlloyComponent): GuiSystem => {
    42|   const isAboveRoot = (el: SugarElement<Node>): boolean => Traverse.parent(root.element).fold(
    43|     Fun.always,
    44|     (parent) => Compare.eq(el, parent)
    45|   );
    46|   const registry = Registry();
    47|   const lookup = (eventName: string, target: SugarElement<Node>) => registry.find(isAboveRoot, eventName, target);
    48|   const domEvents = GuiEvents.setup(root.element, {
    49|     triggerEvent: (eventName, event) => {
    50|       return Debugging.monitorEvent(eventName, event.target, (logger: Debugging.DebuggerLogger) => Triggers.triggerUntilStopped(lookup, eventName, event, logger));
    51|     }
    52|   });
    53|   const systemApi: AlloySystemApi = {
    54|     debugInfo: Fun.constant('real'),
    55|     triggerEvent: (eventName: string, target: SugarElement<Node>, data: any) => {
    56|       Debugging.monitorEvent(eventName, target, (logger: Debugging.DebuggerLogger) =>
    57|         Triggers.triggerOnUntilStopped(lookup, eventName, data, target, logger)
    58|       );
    59|     },
    60|     triggerFocus: (target: SugarElement<HTMLElement>, originator: SugarElement<Node>) => {
    61|       Tagger.read(target).fold(() => {
    62|         Focus.focus(target);
    63|       }, (_alloyId) => {
    64|         Debugging.monitorEvent(SystemEvents.focus(), target, (logger: Debugging.DebuggerLogger) => {
    65|           Triggers.triggerHandler<FocusingEvent>(lookup, SystemEvents.focus(), {
    66|             originator,
    67|             kill: Fun.noop,
    68|             prevent: Fun.noop,
    69|             target
    70|           }, target, logger);
    71|           return false;
    72|         });
    73|       });
    74|     },
    75|     triggerEscape: (comp, simulatedEvent) => {
    76|       systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);
    77|     },
    78|     getByUid: (uid) => {
    79|       return getByUid(uid);
    80|     },
    81|     getByDom: (elem) => {
    82|       return getByDom(elem);
    83|     },
    84|     build: GuiFactory.build,
    85|     buildOrPatch: GuiFactory.buildOrPatch,
    86|     addToGui: (c) => {
    87|       add(c);
    88|     },
    89|     removeFromGui: (c) => {
    90|       remove(c);
    91|     },
    92|     addToWorld: (c) => {
    93|       addToWorld(c);
    94|     },
    95|     removeFromWorld: (c) => {
    96|       removeFromWorld(c);
    97|     },
    98|     broadcast: (message) => {
    99|       broadcast(message);
   100|     },
   101|     broadcastOn: (channels, message) => {
   102|       broadcastOn(channels, message);
   103|     },
   104|     broadcastEvent: (eventName: string, event: EventArgs) => {
   105|       broadcastEvent(eventName, event);
   106|     },
   107|     isConnected: Fun.always
   108|   };
   109|   const addToWorld = (component: AlloyComponent) => {
   110|     component.connect(systemApi);
   111|     if (!SugarNode.isText(component.element)) {
   112|       registry.register(component);
   113|       Arr.each(component.components(), addToWorld);
   114|       systemApi.triggerEvent(SystemEvents.systemInit(), component.element, { target: component.element });
   115|     }
   116|   };
   117|   const removeFromWorld = (component: AlloyComponent) => {
   118|     if (!SugarNode.isText(component.element)) {
   119|       Arr.each(component.components(), removeFromWorld);
   120|       registry.unregister(component);
   121|     }
   122|     component.disconnect();
   123|   };
   124|   const add = (component: AlloyComponent) => {
   125|     Attachment.attach(root, component);
   126|   };
   127|   const remove = (component: AlloyComponent) => {
   128|     Attachment.detach(component);
   129|   };
   130|   const destroy = () => {
   131|     domEvents.unbind();
   132|     Remove.remove(root.element);
   133|   };
   134|   const broadcastData = (data: ReceivingInternalEvent) => {
   135|     const receivers = registry.filter(SystemEvents.receive());
   136|     Arr.each(receivers, (receiver) => {
   137|       const descHandler = receiver.descHandler;
   138|       const handler = DescribedHandler.getCurried(descHandler);
   139|       handler(data);
   140|     });
   141|   };
   142|   const broadcast = <T>(message: T) => {
   143|     broadcastData({
   144|       universal: true,
   145|       data: message
   146|     });
   147|   };
   148|   const broadcastOn = <T>(channels: string[], message: T) => {
   149|     broadcastData({
   150|       universal: false,
   151|       channels,
   152|       data: message
   153|     });
   154|   };
   155|   const broadcastEvent = (eventName: string, event: EventArgs) => {
   156|     const listeners = registry.filter(eventName);
   157|     return Triggers.broadcast(listeners, event);
   158|   };
   159|   const getByUid = (uid: string) => registry.getById(uid).fold(() => Result.error<AlloyComponent, Error>(
   160|     new Error('Could not find component with uid: "' + uid + '" in system.')
   161|   ), Result.value);
   162|   const getByDom = (elem: SugarElement<Node>): Result<AlloyComponent, Error> => {
   163|     const uid = Tagger.read(elem).getOr('not found');
   164|     return getByUid(uid);
   165|   };
   166|   addToWorld(root);
   167|   return {
   168|     root,
   169|     element: root.element,
   170|     destroy,
   171|     add,
   172|     remove,
   173|     getByUid,
   174|     getByDom,
   175|     addToWorld,
   176|     removeFromWorld,
   177|     broadcast,
   178|     broadcastOn,
   179|     broadcastEvent
   180|   };
   181| };
   182| export {
   183|   create,
   184|   takeover
   185| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/system/NoContextApi.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| import { Fun } from '@ephox/katamari';
     2| import * as AlloyLogger from '../../log/AlloyLogger';
     3| import { AlloyComponent } from '../component/ComponentApi';
     4| import { AlloySystemApi } from './SystemApi';
     5| const NoContextApi = (getComp?: () => AlloyComponent): AlloySystemApi => {
     6|   const getMessage = (event: string) => `The component must be in a context to execute: ${event}` +
     7|     (getComp ? '\n' + AlloyLogger.element(getComp().element) + ' is not in context.' : '');
     8|   const fail = (event: string) => (): never => {
     9|     throw new Error(getMessage(event));
    10|   };
    11|   const warn = (event: string) => (): void => {
    12|     console.warn(getMessage(event));
    13|   };
    14|   return {
    15|     debugInfo: Fun.constant('fake'),
    16|     triggerEvent: warn('triggerEvent'),
    17|     triggerFocus: warn('triggerFocus'),
    18|     triggerEscape: warn('triggerEscape'),
    19|     broadcast: warn('broadcast'),
    20|     broadcastOn: warn('broadcastOn'),
    21|     broadcastEvent: warn('broadcastEvent'),
    22|     build: fail('build'),
    23|     buildOrPatch: fail('buildOrPatch'),
    24|     addToWorld: fail('addToWorld'),
    25|     removeFromWorld: fail('removeFromWorld'),
    26|     addToGui: fail('addToGui'),
    27|     removeFromGui: fail('removeFromGui'),
    28|     getByUid: fail('getByUid'),
    29|     getByDom: fail('getByDom'),
    30|     isConnected: Fun.never
    31|   };
    32| };
    33| const singleton = NoContextApi();
    34| export {
    35|   singleton,
    36|   NoContextApi
    37| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/system/SystemApi.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| import { Optional, Result } from '@ephox/katamari';
     2| import { EventArgs, SugarElement } from '@ephox/sugar';
     3| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
     4| import { AlloyComponent } from '../component/ComponentApi';
     5| import { AlloySpec } from '../component/SpecTypes';
     6| export interface AlloySystemApi {
     7|   addToGui: (comp: AlloyComponent) => void;
     8|   addToWorld: (comp: AlloyComponent) => void;
     9|   broadcast: (message: any) => void;
    10|   broadcastOn: (channels: string[], message: any) => void;
    11|   broadcastEvent: (eventName: string, event: EventArgs) => void;
    12|   build: (spec: AlloySpec) => AlloyComponent;
    13|   buildOrPatch: (spec: AlloySpec, optObsoleted: Optional<SugarElement<Node>>) => AlloyComponent;
    14|   debugInfo: () => string;
    15|   getByDom: (element: SugarElement<Node>) => Result<AlloyComponent, Error>;
    16|   getByUid: (uid: string) => Result<AlloyComponent, Error>;
    17|   removeFromGui: (component: AlloyComponent) => void;
    18|   removeFromWorld: (component: AlloyComponent) => void;
    19|   isConnected: () => boolean;
    20|   triggerEscape: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    21|   triggerEvent: (eventName: string, target: SugarElement<Node>, data: {}) => void;
    22|   triggerFocus: (target: SugarElement<HTMLElement>, originator: SugarElement<Node>) => void;
    23| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/ui/FloatingToolbarButton.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-173 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import * as ComponentStructure from '../../alien/ComponentStructure';
     3| import * as AriaControls from '../../aria/AriaControls';
     4| import * as MaxWidth from '../../positioning/layout/MaxWidth';
     5| import { Layouts } from '../../positioning/mode/Anchoring';
     6| import * as Dismissal from '../../sandbox/Dismissal';
     7| import * as Reposition from '../../sandbox/Reposition';
     8| import * as FloatingToolbarButtonSchema from '../../ui/schema/FloatingToolbarButtonSchema';
     9| import {
    10|   FloatingToolbarButtonApis, FloatingToolbarButtonDetail, FloatingToolbarButtonSketcher, FloatingToolbarButtonSpec
    11| } from '../../ui/types/FloatingToolbarButtonTypes';
    12| import * as Behaviour from '../behaviour/Behaviour';
    13| import { Coupling } from '../behaviour/Coupling';
    14| import { Focusing } from '../behaviour/Focusing';
    15| import { Keying } from '../behaviour/Keying';
    16| import { Positioning } from '../behaviour/Positioning';
    17| import { Receiving } from '../behaviour/Receiving';
    18| import { Sandboxing } from '../behaviour/Sandboxing';
    19| import { Toggling } from '../behaviour/Toggling';
    20| import { AlloyComponent } from '../component/ComponentApi';
    21| import { SketchBehaviours } from '../component/SketchBehaviours';
    22| import { AlloySpec, SketchSpec } from '../component/SpecTypes';
    23| import { Button } from './Button';
    24| import * as Sketcher from './Sketcher';
    25| import { Toolbar } from './Toolbar';
    26| import { CompositeSketchFactory } from './UiSketcher';
    27| const toggle = (button: AlloyComponent, externals: Record<string, any>) => {
    28|   const toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');
    29|   if (Sandboxing.isOpen(toolbarSandbox)) {
    30|     Sandboxing.close(toolbarSandbox);
    31|   } else {
    32|     Sandboxing.open(toolbarSandbox, externals.toolbar());
    33|   }
    34| };
    35| const position = (button: AlloyComponent, toolbar: AlloyComponent, detail: FloatingToolbarButtonDetail, layouts: Layouts | undefined) => {
    36|   const bounds = detail.getBounds.map((bounder) => bounder());
    37|   const sink = detail.lazySink(button).getOrDie();
    38|   Positioning.positionWithinBounds(sink, toolbar, {
    39|     anchor: {
    40|       type: 'hotspot',
    41|       hotspot: button,
    42|       layouts,
    43|       overrides: {
    44|         maxWidthFunction: MaxWidth.expandable()
    45|       }
    46|     }
    47|   }, bounds);
    48| };
    49| const setGroups = (button: AlloyComponent, toolbar: AlloyComponent, detail: FloatingToolbarButtonDetail, layouts: Layouts | undefined, groups: AlloySpec[]) => {
    50|   Toolbar.setGroups(toolbar, groups);
    51|   position(button, toolbar, detail, layouts);
    52|   Toggling.on(button);
    53| };
    54| const makeSandbox = (button: AlloyComponent, spec: FloatingToolbarButtonSpec, detail: FloatingToolbarButtonDetail) => {
    55|   const ariaControls = AriaControls.manager();
    56|   const onOpen = (sandbox: AlloyComponent, toolbar: AlloyComponent) => {
    57|     detail.fetch().get((groups) => {
    58|       setGroups(button, toolbar, detail, spec.layouts, groups);
    59|       ariaControls.link(button.element);
    60|       Keying.focusIn(toolbar);
    61|     });
    62|   };
    63|   const onClose = () => {
    64|     Toggling.off(button);
    65|     Focusing.focus(button);
    66|     ariaControls.unlink(button.element);
    67|   };
    68|   return {
    69|     dom: {
    70|       tag: 'div',
    71|       attributes: {
    72|         id: ariaControls.id
    73|       }
    74|     },
    75|     behaviours: Behaviour.derive(
    76|       [
    77|         Keying.config({
    78|           mode: 'special',
    79|           onEscape: (comp) => {
    80|             Sandboxing.close(comp);
    81|             return Optional.some<boolean>(true);
    82|           }
    83|         }),
    84|         Sandboxing.config({
    85|           onOpen,
    86|           onClose,
    87|           isPartOf: (container, data, queryElem): boolean => {
    88|             return ComponentStructure.isPartOf(data, queryElem) || ComponentStructure.isPartOf(button, queryElem);
    89|           },
    90|           getAttachPoint: () => {
    91|             return detail.lazySink(button).getOrDie();
    92|           }
    93|         }),
    94|         Receiving.config({
    95|           channels: {
    96|             ...Dismissal.receivingChannel({
    97|               isExtraPart: Fun.never,
    98|               ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ })
    99|             }),
   100|             ...Reposition.receivingChannel({
   101|               doReposition: () => {
   102|                 Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
   103|                   position(button, toolbar, detail, spec.layouts);
   104|                 });
   105|               }
   106|             })
   107|           }
   108|         })
   109|       ]
   110|     )
   111|   };
   112| };
   113| const factory: CompositeSketchFactory<FloatingToolbarButtonDetail, FloatingToolbarButtonSpec> = (detail, components, spec, externals): SketchSpec => ({
   114|   ...Button.sketch({
   115|     ...externals.button(),
   116|     action: (button) => {
   117|       toggle(button, externals);
   118|     },
   119|     buttonBehaviours: SketchBehaviours.augment(
   120|       { dump: externals.button().buttonBehaviours },
   121|       [
   122|         Coupling.config({
   123|           others: {
   124|             toolbarSandbox: (button) => {
   125|               return makeSandbox(button, spec, detail);
   126|             }
   127|           }
   128|         })
   129|       ]
   130|     )
   131|   }),
   132|   apis: {
   133|     setGroups: (button: AlloyComponent, groups: AlloySpec[]) => {
   134|       Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
   135|         setGroups(button, toolbar, detail, spec.layouts, groups);
   136|       });
   137|     },
   138|     reposition: (button: AlloyComponent) => {
   139|       Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
   140|         position(button, toolbar, detail, spec.layouts);
   141|       });
   142|     },
   143|     toggle: (button: AlloyComponent) => {
   144|       toggle(button, externals);
   145|     },
   146|     getToolbar: (button: AlloyComponent) => {
   147|       return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));
   148|     },
   149|     isOpen: (button: AlloyComponent) => {
   150|       return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));
   151|     }
   152|   }
   153| });
   154| const FloatingToolbarButton: FloatingToolbarButtonSketcher = Sketcher.composite<FloatingToolbarButtonSpec, FloatingToolbarButtonDetail, FloatingToolbarButtonApis>({
   155|   name: 'FloatingToolbarButton',
   156|   factory,
   157|   configFields: FloatingToolbarButtonSchema.schema(),
   158|   partFields: FloatingToolbarButtonSchema.parts(),
   159|   apis: {
   160|     setGroups: (apis, button, groups) => {
   161|       apis.setGroups(button, groups);
   162|     },
   163|     reposition: (apis, button) => {
   164|       apis.reposition(button);
   165|     },
   166|     toggle: (apis, button) => {
   167|       apis.toggle(button);
   168|     },
   169|     getToolbar: (apis, button) => apis.getToolbar(button),
   170|     isOpen: (apis, button) => apis.isOpen(button)
   171|   }
   172| });
   173| export { FloatingToolbarButton };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/ui/GuiTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import { Objects } from '@ephox/boulder';
     2| import { Id, Obj, Optional } from '@ephox/katamari';
     3| import { SugarElement } from '@ephox/sugar';
     4| import * as FunctionAnnotator from '../../debugging/FunctionAnnotator';
     5| import { AlloyComponent } from '../component/ComponentApi';
     6| import { AlloySpec, PremadeSpec } from '../component/SpecTypes';
     7| const premadeTag = Id.generate('alloy-premade');
     8| const premade = (comp: AlloyComponent): PremadeSpec => {
     9|   Object.defineProperty(comp.element.dom, premadeTag, {
    10|     value: comp.uid,
    11|     writable: true
    12|   });
    13|   return Objects.wrap(premadeTag, comp);
    14| };
    15| const isPremade = (element: SugarElement<Node>): boolean =>
    16|   Obj.has(element.dom as any, premadeTag);
    17| const getPremade = (spec: AlloySpec): Optional<AlloyComponent> =>
    18|   Obj.get<any, string>(spec, premadeTag);
    19| const makeApi = <A, R>(f: (api: A, comp: AlloyComponent, ...rest: any[]) => R): FunctionAnnotator.FunctionWithAnnotation<(comp: AlloyComponent, ...rest: any[]) => R> =>
    20|   FunctionAnnotator.markAsSketchApi(
    21|     (component: AlloyComponent, ...rest: any[]) => f(component.getApis(), component, ...rest),
    22|     f
    23|   );
    24| export {
    25|   makeApi,
    26|   premade,
    27|   getPremade,
    28|   isPremade
    29| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/ui/InlineView.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-242 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Arr, Fun, Optional } from '@ephox/katamari';
     3| import { SugarElement } from '@ephox/sugar';
     4| import * as Boxes from '../../alien/Boxes';
     5| import * as ComponentStructure from '../../alien/ComponentStructure';
     6| import { PlacementSpec } from '../../behaviour/positioning/PositioningTypes';
     7| import * as Fields from '../../data/Fields';
     8| import * as Layout from '../../positioning/layout/Layout';
     9| import * as Dismissal from '../../sandbox/Dismissal';
    10| import * as Reposition from '../../sandbox/Reposition';
    11| import { InlineMenuSpec, InlineViewApis, InlineViewDetail, InlineViewSketcher, InlineViewSpec } from '../../ui/types/InlineViewTypes';
    12| import { Positioning } from '../behaviour/Positioning';
    13| import { Receiving } from '../behaviour/Receiving';
    14| import { Representing } from '../behaviour/Representing';
    15| import { Sandboxing } from '../behaviour/Sandboxing';
    16| import { LazySink } from '../component/CommonTypes';
    17| import { AlloyComponent } from '../component/ComponentApi';
    18| import * as SketchBehaviours from '../component/SketchBehaviours';
    19| import { AlloySpec, SketchSpec } from '../component/SpecTypes';
    20| import * as SystemEvents from '../events/SystemEvents';
    21| import * as Sketcher from './Sketcher';
    22| import { tieredMenu as TieredMenu } from './TieredMenu';
    23| import { SingleSketchFactory } from './UiSketcher';
    24| interface InlineViewPositionState {
    25|   mode: 'position';
    26|   config: PlacementSpec;
    27|   getBounds: () => Optional<Boxes.Bounds>;
    28| }
    29| interface InlineViewMenuState {
    30|   mode: 'menu';
    31|   menu: InlineMenuSpec;
    32| }
    33| type InlineViewState = InlineViewMenuState | InlineViewPositionState;
    34| const makeMenu = (detail: InlineViewDetail, menuSandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Boxes.Bounds>) => {
    35|   const lazySink: () => ReturnType<LazySink> = () => detail.lazySink(menuSandbox);
    36|   const layouts = menuSpec.type === 'horizontal' ? { layouts: {
    37|     onLtr: () => Layout.belowOrAbove(),
    38|     onRtl: () => Layout.belowOrAboveRtl()
    39|   }} : { };
    40|   const isFirstTierSubmenu = (triggeringPaths: string[]) => triggeringPaths.length === 2; // primary and first tier menu === 2 items
    41|   const getSubmenuLayouts = (triggeringPaths: string[]) => isFirstTierSubmenu(triggeringPaths) ? layouts : { };
    42|   return TieredMenu.sketch({
    43|     dom: {
    44|       tag: 'div'
    45|     },
    46|     data: menuSpec.data,
    47|     markers: menuSpec.menu.markers,
    48|     highlightImmediately: menuSpec.menu.highlightImmediately,
    49|     onEscape: () => {
    50|       Sandboxing.close(menuSandbox);
    51|       detail.onEscape.map((handler) => handler(menuSandbox));
    52|       return Optional.some<boolean>(true);
    53|     },
    54|     onExecute: () => {
    55|       return Optional.some<boolean>(true);
    56|     },
    57|     onOpenMenu: (tmenu, menu) => {
    58|       Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());
    59|     },
    60|     onOpenSubmenu: (tmenu, item, submenu, triggeringPaths) => {
    61|       const sink = lazySink().getOrDie();
    62|       Positioning.position(sink, submenu, {
    63|         anchor: {
    64|           type: 'submenu',
    65|           item,
    66|           ...getSubmenuLayouts(triggeringPaths)
    67|         }
    68|       });
    69|     },
    70|     onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
    71|       const sink = lazySink().getOrDie();
    72|       Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());
    73|       Arr.each(submenuTriggers, (st) => {
    74|         const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
    75|         Positioning.position(sink, st.triggeredMenu, {
    76|           anchor: { type: 'submenu', item: st.triggeringItem, ...submenuLayouts }
    77|         });
    78|       });
    79|     }
    80|   });
    81| };
    82| const factory: SingleSketchFactory<InlineViewDetail, InlineViewSpec> = (detail: InlineViewDetail, spec): SketchSpec => {
    83|   const isPartOfRelated = (sandbox: AlloyComponent, queryElem: SugarElement<Node>) => {
    84|     const related = detail.getRelated(sandbox);
    85|     return related.exists((rel) => ComponentStructure.isPartOf(rel, queryElem));
    86|   };
    87|   const setContent = (sandbox: AlloyComponent, thing: AlloySpec) => {
    88|     Sandboxing.setContent(sandbox, thing);
    89|   };
    90|   const showAt = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec) => {
    91|     showWithin(sandbox, thing, placementSpec, Optional.none());
    92|   };
    93|   const showWithin = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => {
    94|     showWithinBounds(sandbox, thing, placementSpec, () => boxElement.map((elem) => Boxes.box(elem)));
    95|   };
    96|   const showWithinBounds = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, getBounds: () => Optional<Boxes.Bounds>) => {
    97|     const sink = detail.lazySink(sandbox).getOrDie();
    98|     Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds()));
    99|     Representing.setValue(sandbox, Optional.some({
   100|       mode: 'position',
   101|       config: placementSpec,
   102|       getBounds
   103|     }));
   104|   };
   105|   const showMenuAt = (sandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec) => {
   106|     showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
   107|   };
   108|   const showMenuWithinBounds = (sandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Boxes.Bounds>) => {
   109|     const menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);
   110|     Sandboxing.open(sandbox, menu);
   111|     Representing.setValue(sandbox, Optional.some({
   112|       mode: 'menu',
   113|       menu
   114|     }));
   115|   };
   116|   const hide = (sandbox: AlloyComponent) => {
   117|     if (Sandboxing.isOpen(sandbox)) {
   118|       Representing.setValue(sandbox, Optional.none());
   119|       Sandboxing.close(sandbox);
   120|     }
   121|   };
   122|   const getContent = (sandbox: AlloyComponent): Optional<AlloyComponent> => Sandboxing.getState(sandbox);
   123|   const reposition = (sandbox: AlloyComponent) => {
   124|     if (Sandboxing.isOpen(sandbox)) {
   125|       Representing.getValue(sandbox).each((state: InlineViewState) => {
   126|         switch (state.mode) {
   127|           case 'menu':
   128|             Sandboxing.getState(sandbox).each(TieredMenu.repositionMenus);
   129|             break;
   130|           case 'position':
   131|             const sink = detail.lazySink(sandbox).getOrDie();
   132|             Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
   133|             break;
   134|         }
   135|       });
   136|     }
   137|   };
   138|   const apis = {
   139|     setContent,
   140|     showAt,
   141|     showWithin,
   142|     showWithinBounds,
   143|     showMenuAt,
   144|     showMenuWithinBounds,
   145|     hide,
   146|     getContent,
   147|     reposition,
   148|     isOpen: Sandboxing.isOpen
   149|   };
   150|   return {
   151|     uid: detail.uid,
   152|     dom: detail.dom,
   153|     behaviours: SketchBehaviours.augment(
   154|       detail.inlineBehaviours,
   155|       [
   156|         Sandboxing.config({
   157|           isPartOf: (sandbox, data, queryElem) => {
   158|             return ComponentStructure.isPartOf(data, queryElem) || isPartOfRelated(sandbox, queryElem);
   159|           },
   160|           getAttachPoint: (sandbox) => {
   161|             return detail.lazySink(sandbox).getOrDie();
   162|           },
   163|           onOpen: (sandbox) => {
   164|             detail.onShow(sandbox);
   165|           },
   166|           onClose: (sandbox) => {
   167|             detail.onHide(sandbox);
   168|           }
   169|         }),
   170|         Representing.config({
   171|           store: {
   172|             mode: 'memory',
   173|             initialValue: Optional.none()
   174|           }
   175|         }),
   176|         Receiving.config({
   177|           channels: {
   178|             ...Dismissal.receivingChannel({
   179|               isExtraPart: spec.isExtraPart,
   180|               ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ })
   181|             }),
   182|             ...Reposition.receivingChannel({
   183|               ...detail.fireRepositionEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ }),
   184|               doReposition: reposition
   185|             })
   186|           }
   187|         })
   188|       ]
   189|     ),
   190|     eventOrder: detail.eventOrder,
   191|     apis
   192|   };
   193| };
   194| const InlineView: InlineViewSketcher = Sketcher.single<InlineViewSpec, InlineViewDetail, InlineViewApis>({
   195|   name: 'InlineView',
   196|   configFields: [
   197|     FieldSchema.required('lazySink'),
   198|     Fields.onHandler('onShow'),
   199|     Fields.onHandler('onHide'),
   200|     FieldSchema.optionFunction('onEscape'),
   201|     SketchBehaviours.field('inlineBehaviours', [ Sandboxing, Representing, Receiving ]),
   202|     FieldSchema.optionObjOf('fireDismissalEventInstead', [
   203|       FieldSchema.defaulted('event', SystemEvents.dismissRequested())
   204|     ]),
   205|     FieldSchema.optionObjOf('fireRepositionEventInstead', [
   206|       FieldSchema.defaulted('event', SystemEvents.repositionRequested())
   207|     ]),
   208|     FieldSchema.defaulted('getRelated', Optional.none),
   209|     FieldSchema.defaulted('isExtraPart', Fun.never),
   210|     FieldSchema.defaulted('eventOrder', Optional.none)
   211|   ],
   212|   factory,
   213|   apis: {
   214|     showAt: (apis, component, anchor, thing) => {
   215|       apis.showAt(component, anchor, thing);
   216|     },
   217|     showWithin: (apis, component, anchor, thing, boxElement) => {
   218|       apis.showWithin(component, anchor, thing, boxElement);
   219|     },
   220|     showWithinBounds: (apis, component, anchor, thing, bounds) => {
   221|       apis.showWithinBounds(component, anchor, thing, bounds);
   222|     },
   223|     showMenuAt: (apis, component, anchor, menuSpec) => {
   224|       apis.showMenuAt(component, anchor, menuSpec);
   225|     },
   226|     showMenuWithinBounds: (apis, component, anchor, menuSpec, bounds) => {
   227|       apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
   228|     },
   229|     hide: (apis, component) => {
   230|       apis.hide(component);
   231|     },
   232|     isOpen: (apis, component) => apis.isOpen(component),
   233|     getContent: (apis, component) => apis.getContent(component),
   234|     setContent: (apis, component, thing) => {
   235|       apis.setContent(component, thing);
   236|     },
   237|     reposition: (apis, component) => {
   238|       apis.reposition(component);
   239|     }
   240|   }
   241| });
   242| export { InlineView };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/api/ui/TouchMenu.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-182 ---
     1| import { Cell, Fun, Optional } from '@ephox/katamari';
     2| import { EventArgs, Focus, SugarShadowDom } from '@ephox/sugar';
     3| import * as ElementFromPoint from '../../alien/ElementFromPoint';
     4| import { TransitionPropertiesSpec } from '../../behaviour/transitioning/TransitioningTypes';
     5| import * as DropdownUtils from '../../dropdown/DropdownUtils';
     6| import * as TouchMenuSchema from '../../ui/schema/TouchMenuSchema';
     7| import { TouchMenuDetail, TouchMenuSketcher, TouchMenuSpec } from '../../ui/types/TouchMenuTypes';
     8| import * as AddEventsBehaviour from '../behaviour/AddEventsBehaviour';
     9| import * as Behaviour from '../behaviour/Behaviour';
    10| import { Coupling } from '../behaviour/Coupling';
    11| import { Highlighting } from '../behaviour/Highlighting';
    12| import { Representing } from '../behaviour/Representing';
    13| import { Sandboxing } from '../behaviour/Sandboxing';
    14| import { Toggling } from '../behaviour/Toggling';
    15| import { Transitioning } from '../behaviour/Transitioning';
    16| import { Unselecting } from '../behaviour/Unselecting';
    17| import { AlloyComponent } from '../component/ComponentApi';
    18| import * as SketchBehaviours from '../component/SketchBehaviours';
    19| import * as AlloyEvents from '../events/AlloyEvents';
    20| import * as AlloyTriggers from '../events/AlloyTriggers';
    21| import * as NativeEvents from '../events/NativeEvents';
    22| import * as SystemEvents from '../events/SystemEvents';
    23| import { InlineView } from './InlineView';
    24| import { Menu } from './Menu';
    25| import * as Sketcher from './Sketcher';
    26| import { CompositeSketchFactory } from './UiSketcher';
    27| type TouchHoverState = (comp: AlloyComponent) => void;
    28| const factory: CompositeSketchFactory<TouchMenuDetail, TouchMenuSpec> = (detail, components, spec, externals) => {
    29|   const getMenu = (component: AlloyComponent): Optional<AlloyComponent> => {
    30|     const sandbox = Coupling.getCoupled(component, 'sandbox');
    31|     return Sandboxing.getState(sandbox);
    32|   };
    33|   const hoveredState = Cell<boolean>(false);
    34|   const hoverOn = (component: AlloyComponent): void => {
    35|     if (!hoveredState.get()) {
    36|       forceHoverOn(component);
    37|     }
    38|   };
    39|   const forceHoverOn = (component: AlloyComponent): void => {
    40|     detail.onHoverOn(component);
    41|     hoveredState.set(true);
    42|   };
    43|   const hoverOff = (component: AlloyComponent): void => {
    44|     if (hoveredState.get()) {
    45|       detail.onHoverOff(component);
    46|       hoveredState.set(false);
    47|     }
    48|   };
    49|   return {
    50|     uid: detail.uid,
    51|     dom: detail.dom,
    52|     components,
    53|     domModification: {
    54|       attributes: {
    55|         role: detail.role.getOr('button')
    56|       }
    57|     },
    58|     behaviours: SketchBehaviours.augment(
    59|       detail.touchmenuBehaviours,
    60|       [
    61|         Toggling.config({
    62|           toggleClass: detail.toggleClass,
    63|           aria: {
    64|             mode: 'pressed',
    65|             syncWithExpanded: true
    66|           }
    67|         }),
    68|         Unselecting.config({ }),
    69|         Coupling.config({
    70|           others: {
    71|             sandbox: (hotspot) => {
    72|               return InlineView.sketch({
    73|                 ...externals.view(),
    74|                 lazySink: DropdownUtils.getSink(hotspot, detail),
    75|                 inlineBehaviours: Behaviour.derive([
    76|                   AddEventsBehaviour.config('execute-for-menu', [
    77|                     AlloyEvents.runOnExecute((c, s) => {
    78|                       const target = s.event.target;
    79|                       c.getSystem().getByDom(target).each((item) => {
    80|                         detail.onExecute(hotspot, c, item, Representing.getValue(item));
    81|                       });
    82|                     })
    83|                   ]),
    84|                   Transitioning.config({
    85|                     initialState: 'closed',
    86|                     destinationAttr: 'data-longpress-destination',
    87|                     stateAttr: 'data-longpress-state',
    88|                     routes: Transitioning.createBistate(
    89|                       'open',
    90|                       'closed',
    91|                       detail.menuTransition.map((t) => ({
    92|                         transition: t
    93|                       } as TransitionPropertiesSpec)).getOr({ })
    94|                     ),
    95|                     onFinish: (view, destination) => {
    96|                       if (destination === 'closed') {
    97|                         InlineView.hide(view);
    98|                         detail.onClosed(hotspot, view);
    99|                       }
   100|                     }
   101|                   })
   102|                 ]),
   103|                 onShow: (view: AlloyComponent) => {
   104|                   Transitioning.progressTo(view, 'open');
   105|                 }
   106|               });
   107|             }
   108|           }
   109|         })
   110|       ]
   111|     ),
   112|     events: AlloyEvents.derive([
   113|       AlloyEvents.abort(NativeEvents.contextmenu(), Fun.always),
   114|       AlloyEvents.run(NativeEvents.touchstart(), (comp, _se) => {
   115|         Toggling.on(comp);
   116|       }),
   117|       AlloyEvents.run(SystemEvents.tap(), (comp, _se) => {
   118|         detail.onTap(comp);
   119|       }),
   120|       AlloyEvents.run(SystemEvents.longpress(), (component, _simulatedEvent) => {
   121|         detail.fetch(component).get((items) => {
   122|           forceHoverOn(component);
   123|           const iMenu = Menu.sketch({
   124|             ...externals.menu(),
   125|             items
   126|           });
   127|           const sandbox = Coupling.getCoupled(component, 'sandbox');
   128|           const anchor = detail.getAnchor(component);
   129|           InlineView.showAt(sandbox, iMenu, { anchor });
   130|         });
   131|       }),
   132|       AlloyEvents.run<EventArgs<TouchEvent>>(NativeEvents.touchmove(), (component, simulatedEvent) => {
   133|         const raw = simulatedEvent.event.raw;
   134|         const e = raw.touches[0];
   135|         getMenu(component).each((iMenu) => {
   136|           ElementFromPoint.insideComponent(iMenu, e.clientX, e.clientY).fold(() => {
   137|             Highlighting.dehighlightAll(iMenu);
   138|             const dos = SugarShadowDom.getRootNode(component.element);
   139|             Focus.active(dos).each(Focus.blur);
   140|             const hoverF = ElementFromPoint.insideComponent(component, e.clientX, e.clientY).fold<TouchHoverState>(
   141|               Fun.constant(hoverOff),
   142|               Fun.constant(hoverOn)
   143|             );
   144|             hoverF(component);
   145|           }, (elem) => {
   146|             AlloyTriggers.dispatchWith(component, elem, NativeEvents.mouseover(), {
   147|               x: e.clientX,
   148|               y: e.clientY
   149|             });
   150|             hoverOff(component);
   151|           });
   152|           simulatedEvent.stop();
   153|         });
   154|       }),
   155|       AlloyEvents.run(NativeEvents.touchend(), (component, _simulatedEvent) => {
   156|         getMenu(component).each((iMenu) => {
   157|           Highlighting.getHighlighted(iMenu).each(AlloyTriggers.emitExecute);
   158|         });
   159|         const sandbox = Coupling.getCoupled(component, 'sandbox');
   160|         Transitioning.progressTo(sandbox, 'closed');
   161|         Toggling.off(component);
   162|       }),
   163|       AlloyEvents.runOnDetached((component, _simulatedEvent) => {
   164|         const sandbox = Coupling.getCoupled(component, 'sandbox');
   165|         InlineView.hide(sandbox);
   166|       })
   167|     ]),
   168|     eventOrder: {
   169|       ...detail.eventOrder,
   170|       [SystemEvents.execute()]: [ 'toggling', 'alloy.base.behaviour' ]
   171|     }
   172|   };
   173| };
   174| const TouchMenu: TouchMenuSketcher = Sketcher.composite({
   175|   name: 'TouchMenu',
   176|   configFields: TouchMenuSchema.schema(),
   177|   partFields: TouchMenuSchema.parts(),
   178|   factory
   179| });
   180| export {
   181|   TouchMenu
   182| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/aria/AriaControls.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| import { Id, Optional } from '@ephox/katamari';
     2| import { Attribute, PredicateFind, SelectorFind, SugarElement, SugarNode, SugarShadowDom } from '@ephox/sugar';
     3| export interface AriaManager {
     4|   readonly id: string;
     5|   readonly link: (elem: SugarElement<Element>) => void;
     6|   readonly unlink: (elem: SugarElement<Element>) => void;
     7| }
     8| const attribute = 'aria-controls';
     9| const find = (queryElem: SugarElement<Node>): Optional<SugarElement<Element>> => {
    10|   const dependent = PredicateFind.closest(queryElem, (elem): elem is SugarElement<Element> => {
    11|     if (!SugarNode.isElement(elem)) {
    12|       return false;
    13|     }
    14|     const id = Attribute.get(elem, 'id');
    15|     return id !== undefined && id.indexOf(attribute) > -1;
    16|   });
    17|   return dependent.bind((dep) => {
    18|     const id = Attribute.get(dep, 'id');
    19|     const dos = SugarShadowDom.getRootNode(dep);
    20|     return SelectorFind.descendant(dos, `[${attribute}="${id}"]`);
    21|   });
    22| };
    23| const manager = (): AriaManager => {
    24|   const ariaId = Id.generate(attribute);
    25|   const link = (elem: SugarElement<Element>) => {
    26|     Attribute.set(elem, attribute, ariaId);
    27|   };
    28|   const unlink = (elem: SugarElement<Element>) => {
    29|     Attribute.remove(elem, attribute);
    30|   };
    31|   return {
    32|     id: ariaId,
    33|     link,
    34|     unlink,
    35|   };
    36| };
    37| export {
    38|   find,
    39|   manager
    40| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/aria/AriaDescribe.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-14 ---
     1| import { Fun, Id, Optional } from '@ephox/katamari';
     2| import { Attribute, SugarElement } from '@ephox/sugar';
     3| const describedBy = (describedElement: SugarElement<Element>, describeElement: SugarElement<Element>): void => {
     4|   const describeId = Optional.from(Attribute.get(describedElement, 'id'))
     5|     .fold(() => {
     6|       const id = Id.generate('dialog-describe');
     7|       Attribute.set(describeElement, 'id', id);
     8|       return id;
     9|     }, Fun.identity);
    10|   Attribute.set(describedElement, 'aria-describedby', describeId);
    11| };
    12| export {
    13|   describedBy
    14| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/aria/AriaFocus.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Compare, Focus, PredicateFind, SugarElement, SugarShadowDom } from '@ephox/sugar';
     3| const preserve = <T extends Node, R>(f: (e: SugarElement<T>) => R, container: SugarElement<T>): R => {
     4|   const dos = SugarShadowDom.getRootNode(container);
     5|   const refocus = Focus.active(dos).bind((focused): Optional<SugarElement<HTMLElement>> => {
     6|     const hasFocus = (elem: SugarElement<Node>): elem is SugarElement<HTMLElement> => Compare.eq(focused, elem);
     7|     return hasFocus(container) ? Optional.some(container) : PredicateFind.descendant(container, hasFocus);
     8|   });
     9|   const result = f(container);
    10|   refocus.each((oldFocus) => {
    11|     Focus.active(dos).filter((newFocus) => Compare.eq(newFocus, oldFocus)).fold(() => {
    12|       Focus.focus(oldFocus);
    13|     }, Fun.noop);
    14|   });
    15|   return result;
    16| };
    17| export {
    18|   preserve
    19| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/aria/AriaLabel.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| import { Fun, Id } from '@ephox/katamari';
     2| import { Attribute, SugarElement } from '@ephox/sugar';
     3| export const labelledBy = (labelledElement: SugarElement<Element>, labelElement: SugarElement<Element>): void => {
     4|   const labelId = Attribute.getOpt(labelledElement, 'id')
     5|     .fold(() => {
     6|       const id = Id.generate('dialog-label');
     7|       Attribute.set(labelElement, 'id', id);
     8|       return id;
     9|     }, Fun.identity);
    10|   Attribute.set(labelledElement, 'aria-labelledby', labelId);
    11| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/aria/AriaVoice.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| import { Fun, Id } from '@ephox/katamari';
     2| import { PlatformDetection } from '@ephox/sand';
     3| import { Attribute, Css, Insert, Remove, SugarElement, Traverse } from '@ephox/sugar';
     4| const offscreen = {
     5|   position: 'absolute',
     6|   left: '-9999px'
     7| };
     8| const tokenSelector = Fun.constant('span[id^="ephox-alloy-aria-voice"]');
     9| const create = (doc: SugarElement<Document>, text: string): SugarElement<HTMLSpanElement> => {
    10|   const span = SugarElement.fromTag('span', doc.dom);
    11|   Attribute.set(span, 'role', 'presentation');
    12|   const contents = SugarElement.fromText(text, doc.dom);
    13|   Insert.append(span, contents);
    14|   return span;
    15| };
    16| const linkToDescription = (item: SugarElement<Element>, token: SugarElement<Element>): void => {
    17|   const id = Id.generate('ephox-alloy-aria-voice');
    18|   Attribute.set(token, 'id', id);
    19|   Attribute.set(item, 'aria-describedby', id);
    20| };
    21| const describe = (item: SugarElement<Element>, description: string): SugarElement<HTMLSpanElement> => {
    22|   const doc = Traverse.owner(item);
    23|   const token = create(doc, description);
    24|   Css.set(token, 'display', 'none');
    25|   Attribute.set(token, 'aria-hidden', 'true'); // aria-hidden needs to be in sync with dom visibility
    26|   linkToDescription(item, token);
    27|   return token;
    28| };
    29| const base = (getAttrs: (string: string) => { }, parent: SugarElement<Element>, text: string): void => {
    30|   const doc = Traverse.owner(parent);
    31|   const token = create(doc, text);
    32|   if (PlatformDetection.detect().browser.isFirefox()) {
    33|     linkToDescription(parent, token);
    34|   }
    35|   Attribute.setAll(token, getAttrs(text));
    36|   Css.setAll(token, offscreen);
    37|   Insert.append(parent, token);
    38|   setTimeout(() => {
    39|     Attribute.remove(token, 'aria-live');
    40|     Remove.remove(token);
    41|   }, 1000);
    42| };
    43| const getSpeakAttrs = (text: string) => ({
    44|   'aria-live': 'polite',
    45|   'aria-atomic': 'true',
    46|   'aria-label': text
    47| });
    48| const getShoutAttrs = (_text: string) => ({
    49|   'aria-live': 'assertive',
    50|   'aria-atomic': 'true',
    51|   'role': 'alert'
    52| });
    53| const speak = (parent: SugarElement<Element>, text: string): void => base(getSpeakAttrs, parent, text);
    54| const shout = (parent: SugarElement<Element>, text: string): void => base(getShoutAttrs, parent, text);
    55| export {
    56|   describe,
    57|   speak,
    58|   shout,
    59|   tokenSelector
    60| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/coupling/CouplingState.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| import { Fun, Obj } from '@ephox/katamari';
     2| import { AlloyComponent } from '../../api/component/ComponentApi';
     3| import { nuState } from '../common/BehaviourState';
     4| import { CouplingConfig, CouplingState } from './CouplingTypes';
     5| const init = (): CouplingState => {
     6|   const coupled: Record<string, AlloyComponent> = { };
     7|   const getOrCreate = (component: AlloyComponent, coupleConfig: CouplingConfig, name: string): AlloyComponent => {
     8|     const available = Obj.keys(coupleConfig.others);
     9|     if (!available) {
    10|       throw new Error('Cannot find coupled component: ' + name + '. Known coupled components: ' + JSON.stringify(available, null, 2));
    11|     } else {
    12|       return Obj.get<any, string>(coupled, name).getOrThunk(() => {
    13|         const builder = Obj.get<any, string>(coupleConfig.others, name).getOrDie(
    14|           'No information found for coupled component: ' + name
    15|         );
    16|         const spec = builder(component);
    17|         const built = component.getSystem().build(spec);
    18|         coupled[name] = built;
    19|         return built;
    20|       });
    21|     }
    22|   };
    23|   const readState = Fun.constant({ });
    24|   return nuState({
    25|     readState,
    26|     getOrCreate
    27|   });
    28| };
    29| export {
    30|   init
    31| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/highlighting/HighlightApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-105 ---
     1| import { Arr, Num, Optional, Optionals, Result } from '@ephox/katamari';
     2| import { Class, SelectorFilter, SelectorFind } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import * as AlloyTriggers from '../../api/events/AlloyTriggers';
     5| import * as SystemEvents from '../../api/events/SystemEvents';
     6| import { Stateless } from '../common/BehaviourState';
     7| import { HighlightingConfig } from './HighlightingTypes';
     8| const dehighlightAllExcept = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, skip: AlloyComponent[]): void => {
     9|   const highlighted = SelectorFilter.descendants(component.element, '.' + hConfig.highlightClass);
    10|   Arr.each(highlighted, (h) => {
    11|     if (!Arr.exists(skip, (skipComp) => skipComp.element === h)) {
    12|       Class.remove(h, hConfig.highlightClass);
    13|       component.getSystem().getByDom(h).each((target) => {
    14|         hConfig.onDehighlight(component, target);
    15|         AlloyTriggers.emit(target, SystemEvents.dehighlight());
    16|       });
    17|     }
    18|   });
    19| };
    20| const dehighlightAll = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => dehighlightAllExcept(component, hConfig, hState, []);
    21| const dehighlight = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, target: AlloyComponent): void => {
    22|   if (isHighlighted(component, hConfig, hState, target)) {
    23|     Class.remove(target.element, hConfig.highlightClass);
    24|     hConfig.onDehighlight(component, target);
    25|     AlloyTriggers.emit(target, SystemEvents.dehighlight());
    26|   }
    27| };
    28| const highlight = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, target: AlloyComponent): void => {
    29|   dehighlightAllExcept(component, hConfig, hState, [ target ]);
    30|   if (!isHighlighted(component, hConfig, hState, target)) {
    31|     Class.add(target.element, hConfig.highlightClass);
    32|     hConfig.onHighlight(component, target);
    33|     AlloyTriggers.emit(target, SystemEvents.highlight());
    34|   }
    35| };
    36| const highlightFirst = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => {
    37|   getFirst(component, hConfig, hState).each((firstComp) => {
    38|     highlight(component, hConfig, hState, firstComp);
    39|   });
    40| };
    41| const highlightLast = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => {
    42|   getLast(component, hConfig, hState).each((lastComp) => {
    43|     highlight(component, hConfig, hState, lastComp);
    44|   });
    45| };
    46| const highlightAt = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, index: number): void => {
    47|   getByIndex(component, hConfig, hState, index).fold((err) => {
    48|     throw err;
    49|   }, (firstComp) => {
    50|     highlight(component, hConfig, hState, firstComp);
    51|   });
    52| };
    53| const highlightBy = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, predicate: (comp: AlloyComponent) => boolean): void => {
    54|   const candidates = getCandidates(component, hConfig, hState);
    55|   const targetComp = Arr.find(candidates, predicate);
    56|   targetComp.each((c) => {
    57|     highlight(component, hConfig, hState, c);
    58|   });
    59| };
    60| const isHighlighted = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, queryTarget: AlloyComponent): boolean => Class.has(queryTarget.element, hConfig.highlightClass);
    61| const getHighlighted = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> =>
    62|   SelectorFind.descendant(component.element, '.' + hConfig.highlightClass).bind((e) => component.getSystem().getByDom(e).toOptional());
    63| const getByIndex = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, index: number): Result<AlloyComponent, Error> => {
    64|   const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
    65|   return Optional.from(items[index]).fold(() => Result.error(new Error('No element found with index ' + index)), component.getSystem().getByDom);
    66| };
    67| const getFirst = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> =>
    68|   SelectorFind.descendant(component.element, '.' + hConfig.itemClass).bind((e) => component.getSystem().getByDom(e).toOptional());
    69| const getLast = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> => {
    70|   const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
    71|   const last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
    72|   return last.bind((c) => component.getSystem().getByDom(c).toOptional());
    73| };
    74| const getDelta = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, delta: number): Optional<AlloyComponent> => {
    75|   const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
    76|   const current = Arr.findIndex(items, (item) => Class.has(item, hConfig.highlightClass));
    77|   return current.bind((selected) => {
    78|     const dest = Num.cycleBy(selected, delta, 0, items.length - 1);
    79|     return component.getSystem().getByDom(items[dest]).toOptional();
    80|   });
    81| };
    82| const getPrevious = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): Optional<AlloyComponent> => getDelta(component, hConfig, hState, -1);
    83| const getNext = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): Optional<AlloyComponent> => getDelta(component, hConfig, hState, +1);
    84| const getCandidates = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): AlloyComponent[] => {
    85|   const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
    86|   return Optionals.cat(
    87|     Arr.map(items, (i) => component.getSystem().getByDom(i).toOptional())
    88|   );
    89| };
    90| export {
    91|   dehighlightAll,
    92|   dehighlight,
    93|   highlight,
    94|   highlightFirst,
    95|   highlightLast,
    96|   highlightAt,
    97|   highlightBy,
    98|   isHighlighted,
    99|   getHighlighted,
   100|   getFirst,
   101|   getLast,
   102|   getPrevious,
   103|   getNext,
   104|   getCandidates
   105| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/invalidating/InvalidateApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| import { Arr, Future, Result } from '@ephox/katamari';
     2| import { Attribute, Class, Html, SugarElement, SugarNode } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { Stateless } from '../common/BehaviourState';
     5| import { InvalidatingConfig } from './InvalidateTypes';
     6| const ariaElements = [
     7|   'input',
     8|   'textarea'
     9| ];
    10| const isAriaElement = (elem: SugarElement<Node>): elem is SugarElement<HTMLInputElement | HTMLTextAreaElement> => {
    11|   const name = SugarNode.name(elem);
    12|   return Arr.contains(ariaElements, name);
    13| };
    14| const markValid = (component: AlloyComponent, invalidConfig: InvalidatingConfig): void => {
    15|   const elem = invalidConfig.getRoot(component).getOr(component.element);
    16|   Class.remove(elem, invalidConfig.invalidClass);
    17|   invalidConfig.notify.each((notifyInfo) => {
    18|     if (isAriaElement(component.element)) {
    19|       Attribute.set(component.element, 'aria-invalid', false);
    20|     }
    21|     notifyInfo.getContainer(component).each((container) => {
    22|       Html.set(container, notifyInfo.validHtml);
    23|     });
    24|     notifyInfo.onValid(component);
    25|   });
    26| };
    27| const markInvalid = (component: AlloyComponent, invalidConfig: InvalidatingConfig, invalidState: Stateless, text: string): void => {
    28|   const elem = invalidConfig.getRoot(component).getOr(component.element);
    29|   Class.add(elem, invalidConfig.invalidClass);
    30|   invalidConfig.notify.each((notifyInfo) => {
    31|     if (isAriaElement(component.element)) {
    32|       Attribute.set(component.element, 'aria-invalid', true);
    33|     }
    34|     notifyInfo.getContainer(component).each((container) => {
    35|       Html.set(container, text);
    36|     });
    37|     notifyInfo.onInvalid(component, text);
    38|   });
    39| };
    40| const query = (component: AlloyComponent, invalidConfig: InvalidatingConfig, _invalidState: Stateless): Future<Result<any, string>> =>
    41|   invalidConfig.validator.fold(
    42|     () => Future.pure(Result.value(true)),
    43|     (validatorInfo) => validatorInfo.validate(component)
    44|   );
    45| const run = (component: AlloyComponent, invalidConfig: InvalidatingConfig, invalidState: Stateless): Future<Result<any, string>> => {
    46|   invalidConfig.notify.each((notifyInfo) => {
    47|     notifyInfo.onValidate(component);
    48|   });
    49|   return query(component, invalidConfig, invalidState).map((valid: Result<any, string>) => {
    50|     if (component.getSystem().isConnected()) {
    51|       return valid.fold((err) => {
    52|         markInvalid(component, invalidConfig, invalidState, err);
    53|         return Result.error(err);
    54|       }, (v) => {
    55|         markValid(component, invalidConfig);
    56|         return Result.value(v);
    57|       });
    58|     } else {
    59|       return Result.error('No longer in system');
    60|     }
    61|   });
    62| };
    63| const isInvalid = (component: AlloyComponent, invalidConfig: InvalidatingConfig): boolean => {
    64|   const elem = invalidConfig.getRoot(component).getOr(component.element);
    65|   return Class.has(elem, invalidConfig.invalidClass);
    66| };
    67| export {
    68|   markValid,
    69|   markInvalid,
    70|   query,
    71|   run,
    72|   isInvalid
    73| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/invalidating/InvalidateTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| import { Future, Optional, Result } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as Behaviour from '../../api/behaviour/Behaviour';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| export interface InvalidatingBehaviour extends Behaviour.AlloyBehaviour<InvalidatingConfigSpec, InvalidatingConfig> {
     6|   config: (config: InvalidatingConfigSpec) => Behaviour.NamedConfiguredBehaviour<InvalidatingConfigSpec, InvalidatingConfig>;
     7|   markValid: (component: AlloyComponent) => void;
     8|   isInvalid: (component: AlloyComponent) => boolean;
     9|   markInvalid: (component: AlloyComponent, text: string) => void;
    10|   query: (component: AlloyComponent) => Future<Result<any, string>>;
    11|   run: (component: AlloyComponent) => Future<Result<any, string>>;
    12|   validation: <T>(validate: (v: string) => Result<T, string>) => (component: AlloyComponent) => Future<Result<T, string>>;
    13| }
    14| export interface InvalidatingConfigSpec extends Behaviour.BehaviourConfigSpec {
    15|   invalidClass: string;
    16|   getRoot?: (comp: AlloyComponent) => Optional<SugarElement<Element>>;
    17|   notify?: {
    18|     aria?: string;
    19|     getContainer?: (input: AlloyComponent) => Optional<SugarElement<Node>>;
    20|     validHtml?: string;
    21|     onValid?: (comp: AlloyComponent) => void;
    22|     onInvalid?: (comp: AlloyComponent, err: string) => void;
    23|     onValidate?: (comp: AlloyComponent) => void;
    24|   };
    25|   validator?: {
    26|     validate: (input: AlloyComponent) => Future<Result<any, string>>;
    27|     onEvent?: string;
    28|     validateOnLoad?: boolean;
    29|   };
    30| }
    31| export interface InvalidatingConfig extends Behaviour.BehaviourConfigDetail {
    32|   invalidClass: string;
    33|   notify: Optional<{
    34|     aria: string;
    35|     getContainer: (input: AlloyComponent) => Optional<SugarElement<Node>>;
    36|     onValid: (comp: AlloyComponent) => void;
    37|     validHtml: string;
    38|     onInvalid: (comp: AlloyComponent, err: string) => void;
    39|     onValidate: (comp: AlloyComponent) => void;
    40|   }>;
    41|   getRoot: (comp: AlloyComponent) => Optional<SugarElement<Element>>;
    42|   validator: Optional<{
    43|     validate: (input: AlloyComponent) => Future<Result<any, string>>;
    44|     onEvent: string;
    45|     validateOnLoad?: boolean;
    46|   }>;
    47| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/pinching/PinchingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import * as Behaviour from '../../api/behaviour/Behaviour';
     3| import { BaseDraggingState } from '../../dragging/common/DraggingTypes';
     4| export interface PinchDragData {
     5|   readonly deltaX: number;
     6|   readonly deltaY: number;
     7|   readonly deltaDistance: number;
     8| }
     9| export interface PinchingBehaviour extends Behaviour.AlloyBehaviour<PinchingConfigSpec, PinchingConfig> {
    10|   readonly config: (config: PinchingConfigSpec) => Behaviour.NamedConfiguredBehaviour<PinchingConfigSpec, PinchingConfig>;
    11| }
    12| export interface PinchingConfig extends Behaviour.BehaviourConfigDetail {
    13|   readonly onPinch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
    14|   readonly onPunch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
    15| }
    16| export interface PinchingConfigSpec extends Behaviour.BehaviourConfigSpec {
    17|   readonly onPinch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
    18|   readonly onPunch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
    19| }
    20| export interface PinchingState extends BaseDraggingState<PinchDragData> { }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/positioning/PositionApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| import { StructureSchema } from '@ephox/boulder';
     2| import { Arr, Fun, Optional, Optionals } from '@ephox/katamari';
     3| import { Css, SugarElement, SugarLocation } from '@ephox/sugar';
     4| import { Bounds, box } from '../../alien/Boxes';
     5| import { AlloyComponent } from '../../api/component/ComponentApi';
     6| import * as AriaFocus from '../../aria/AriaFocus';
     7| import * as Anchor from '../../positioning/layout/Anchor';
     8| import { PlacerResult } from '../../positioning/layout/LayoutTypes';
     9| import * as Origins from '../../positioning/layout/Origins';
    10| import * as Placement from '../../positioning/layout/Placement';
    11| import * as SimpleLayout from '../../positioning/layout/SimpleLayout';
    12| import { Anchoring } from '../../positioning/mode/Anchoring';
    13| import { Transition } from '../../positioning/view/Transitions';
    14| import { PlacementDetail, PlacementSpec, PositioningConfig, PositioningState } from './PositioningTypes';
    15| import { PlacementSchema } from './PositionSchema';
    16| const getFixedOrigin = (): Origins.OriginAdt => {
    17|   const html = document.documentElement;
    18|   return Origins.fixed(0, 0, html.clientWidth, html.clientHeight);
    19| };
    20| const getRelativeOrigin = (component: AlloyComponent): Origins.OriginAdt => {
    21|   const position = SugarLocation.absolute(component.element);
    22|   const bounds = component.element.dom.getBoundingClientRect();
    23|   return Origins.relative(position.left, position.top, bounds.width, bounds.height);
    24| };
    25| const place = (component: AlloyComponent, origin: Origins.OriginAdt, anchoring: Anchoring, getBounds: Optional<() => Bounds>, placee: AlloyComponent, lastPlace: Optional<PlacerResult>, transition: Optional<Transition>): PlacerResult => {
    26|   const anchor = Anchor.box(anchoring.anchorBox, origin);
    27|   return SimpleLayout.simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, getBounds, anchoring.overrides, transition);
    28| };
    29| const position = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec): void => {
    30|   positionWithin(component, posConfig, posState, placee, placementSpec, Optional.none());
    31| };
    32| const positionWithin = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>): void => {
    33|   const boundsBox = boxElement.map(box);
    34|   return positionWithinBounds(component, posConfig, posState, placee, placementSpec, boundsBox);
    35| };
    36| const positionWithinBounds = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec, bounds: Optional<Bounds>): void => {
    37|   const placeeDetail: PlacementDetail = StructureSchema.asRawOrDie('placement.info', StructureSchema.objOf(PlacementSchema), placementSpec);
    38|   const anchorage = placeeDetail.anchor;
    39|   const element = placee.element;
    40|   const placeeState = posState.get(placee.uid);
    41|   AriaFocus.preserve(() => {
    42|     Css.set(element, 'position', 'fixed');
    43|     const oldVisibility = Css.getRaw(element, 'visibility');
    44|     Css.set(element, 'visibility', 'hidden');
    45|     const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
    46|     const placer = anchorage.placement;
    47|     const getBounds = bounds.map(Fun.constant).or(posConfig.getBounds);
    48|     placer(component, anchorage, origin).each((anchoring) => {
    49|       const doPlace = anchoring.placer.getOr(place);
    50|       const newState = doPlace(component, origin, anchoring, getBounds, placee, placeeState, placeeDetail.transition);
    51|       posState.set(placee.uid, newState);
    52|     });
    53|     oldVisibility.fold(() => {
    54|       Css.remove(element, 'visibility');
    55|     }, (vis) => {
    56|       Css.set(element, 'visibility', vis);
    57|     });
    58|     if (
    59|       Css.getRaw(element, 'left').isNone() &&
    60|       Css.getRaw(element, 'top').isNone() &&
    61|       Css.getRaw(element, 'right').isNone() &&
    62|       Css.getRaw(element, 'bottom').isNone() &&
    63|       Optionals.is(Css.getRaw(element, 'position'), 'fixed')
    64|     ) {
    65|       Css.remove(element, 'position');
    66|     }
    67|   }, element);
    68| };
    69| const getMode = (component: AlloyComponent, pConfig: PositioningConfig, _pState: PositioningState): string =>
    70|   pConfig.useFixed() ? 'fixed' : 'absolute';
    71| const reset = (component: AlloyComponent, pConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent): void => {
    72|   const element = placee.element;
    73|   Arr.each([ 'position', 'left', 'right', 'top', 'bottom' ], (prop) => Css.remove(element, prop));
    74|   Placement.reset(element);
    75|   posState.clear(placee.uid);
    76| };
    77| export {
    78|   position,
    79|   positionWithin,
    80|   positionWithinBounds,
    81|   getMode,
    82|   reset
    83| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/positioning/PositioningTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import * as Behaviour from '../../api/behaviour/Behaviour';
     5| import { AlloyComponent } from '../../api/component/ComponentApi';
     6| import { PlacerResult } from '../../positioning/layout/LayoutTypes';
     7| import { AnchorDetail, AnchorSpec } from '../../positioning/mode/Anchoring';
     8| import { TransitionMode } from '../../positioning/view/Transitions';
     9| import { BehaviourState } from '../common/BehaviourState';
    10| interface TransitionSpec {
    11|   readonly classes: string[];
    12|   readonly mode?: TransitionMode;
    13| }
    14| interface TransitionDetail {
    15|   readonly classes: string[];
    16|   readonly mode: TransitionMode;
    17| }
    18| export interface PlacementSpec {
    19|   readonly anchor: AnchorSpec;
    20|   readonly transition?: TransitionSpec;
    21| }
    22| export interface PlacementDetail {
    23|   readonly anchor: AnchorDetail<any>;
    24|   readonly transition: Optional<TransitionDetail>;
    25| }
    26| export interface PositioningBehaviour extends Behaviour.AlloyBehaviour<PositioningConfigSpec, PositioningConfig> {
    27|   readonly config: (config: PositioningConfigSpec) => Behaviour.NamedConfiguredBehaviour<PositioningConfigSpec, PositioningConfig>;
    28|   readonly position: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec) => void;
    29|   readonly positionWithin: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => void;
    30|   readonly positionWithinBounds: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec, bounds: Optional<Bounds>) => void;
    31|   readonly getMode: (component: AlloyComponent) => string;
    32|   readonly reset: (component: AlloyComponent, placee: AlloyComponent) => void;
    33| }
    34| export interface PositioningConfigSpec extends Behaviour.BehaviourConfigSpec {
    35|   readonly useFixed?: () => boolean;
    36|   readonly getBounds?: () => Bounds;
    37| }
    38| export interface PositioningConfig extends Behaviour.BehaviourConfigDetail {
    39|   readonly useFixed: () => boolean;
    40|   readonly getBounds: Optional<() => Bounds>;
    41| }
    42| export interface PositioningState extends BehaviourState {
    43|   readonly clear: (id?: string) => void;
    44|   readonly get: (id: string) => Optional<PlacerResult>;
    45|   readonly set: (id: string, state: PlacerResult) => void;
    46| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ActiveReflecting.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { AlloyComponent } from '../../api/component/ComponentApi';
     3| import * as AlloyEvents from '../../api/events/AlloyEvents';
     4| import * as SystemEvents from '../../api/events/SystemEvents';
     5| import { ReceivingEvent, ReceivingInternalEvent } from '../../events/SimulatedEvent';
     6| import { withoutReuse, withReuse } from '../replacing/ReplacingAll';
     7| import { ReflectingConfig, ReflectingState } from './ReflectingTypes';
     8| const events = <I, S>(reflectingConfig: ReflectingConfig<I, S>, reflectingState: ReflectingState<S>): AlloyEvents.AlloyEventRecord => {
     9|   const update = (component: AlloyComponent, data: I) => {
    10|     reflectingConfig.updateState.each((updateState) => {
    11|       const newState = updateState(component, data);
    12|       reflectingState.set(newState);
    13|     });
    14|     reflectingConfig.renderComponents.each((renderComponents) => {
    15|       const newComponents = renderComponents(data, reflectingState.get());
    16|       const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;
    17|       replacer(component, newComponents);
    18|     });
    19|   };
    20|   return AlloyEvents.derive([
    21|     AlloyEvents.run<ReceivingEvent>(SystemEvents.receive(), (component, message) => {
    22|       const receivingData = message as unknown as ReceivingInternalEvent;
    23|       if (!receivingData.universal) {
    24|         const channel = reflectingConfig.channel;
    25|         if (Arr.contains(receivingData.channels, channel)) {
    26|           update(component, receivingData.data);
    27|         }
    28|       }
    29|     }),
    30|     AlloyEvents.runOnAttached((comp, _se) => {
    31|       reflectingConfig.initialData.each((rawData) => {
    32|         update(comp, rawData);
    33|       });
    34|     })
    35|   ]);
    36| };
    37| export {
    38|   events
    39| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ReflectingSchema.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| export default [
     3|   FieldSchema.required('channel'),
     4|   FieldSchema.option('renderComponents'),
     5|   FieldSchema.option('updateState'),
     6|   FieldSchema.option('initialData'),
     7|   FieldSchema.defaultedBoolean('reuseDom', true)
     8| ];


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ReflectingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| import { Optional } from '@ephox/katamari';
     2| import * as Behaviour from '../../api/behaviour/Behaviour';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { AlloySpec } from '../../api/component/SpecTypes';
     5| import { BehaviourState } from '../common/BehaviourState';
     6| export interface ReflectingBehaviour<I, S> extends Behaviour.AlloyBehaviour<ReflectingConfigSpec<I, S>, ReflectingConfig<I, S>> {
     7|   config: (config: ReflectingConfigSpec<I, S>) => Behaviour.NamedConfiguredBehaviour<ReflectingConfigSpec<I, S>, ReflectingConfig<I, S>>;
     8|   getState: (comp: AlloyComponent) => ReflectingState<S>;
     9| }
    10| export interface ReflectingConfigSpec<I, S> extends Behaviour.BehaviourConfigSpec {
    11|   channel: string;
    12|   renderComponents?: (data: I, state: Optional<S>) => AlloySpec[ ];
    13|   updateState?: (comp: AlloyComponent, data: I) => Optional<S>;
    14|   initialData?: I;
    15|   reuseDom?: boolean;
    16| }
    17| export interface ReflectingState<S> extends BehaviourState {
    18|   get: () => Optional<S>;
    19|   set: (optS: Optional<S>) => void;
    20|   clear: () => void;
    21| }
    22| export interface ReflectingConfig<I, S> extends Behaviour.BehaviourConfigDetail {
    23|   channel: string;
    24|   renderComponents: Optional<(data: I, state: Optional<S>) => AlloySpec[ ]>;
    25|   updateState: Optional<(comp: AlloyComponent, data: I) => Optional<S>>;
    26|   initialData: Optional<any>;
    27|   reuseDom: boolean;
    28| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplaceApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| import { Arr, Optional } from '@ephox/katamari';
     2| import { Compare, Insert, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { AlloySpec } from '../../api/component/SpecTypes';
     5| import * as Attachment from '../../api/system/Attachment';
     6| import * as Patching from '../../dom/Patching';
     7| import * as InternalAttachment from '../../system/InternalAttachment';
     8| import { Stateless } from '../common/BehaviourState';
     9| import { withoutReuse, withReuse } from './ReplacingAll';
    10| import { ReplacingConfig } from './ReplacingTypes';
    11| const virtualReplace = (component: AlloyComponent, replacee: AlloyComponent, replaceeIndex: number, childSpec: AlloySpec) => {
    12|   InternalAttachment.virtualDetach(replacee);
    13|   const child = Patching.patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);
    14|   InternalAttachment.virtualAttach(component, child);
    15|   component.syncComponents();
    16| };
    17| const insert = (component: AlloyComponent, insertion: (p: SugarElement<Node>, c: SugarElement<Node>) => void, childSpec: AlloySpec): void => {
    18|   const child = component.getSystem().build(childSpec);
    19|   Attachment.attachWith(component, child, insertion);
    20| };
    21| const replace = (component: AlloyComponent, replacee: AlloyComponent, replaceeIndex: number, childSpec: AlloySpec) => {
    22|   Attachment.detach(replacee);
    23|   insert(component, (p, c) => Insert.appendAt(p, c, replaceeIndex), childSpec);
    24| };
    25| const set = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, data: AlloySpec[]): void => {
    26|   const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;
    27|   return replacer(component, data);
    28| };
    29| const append = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, appendee: AlloySpec): void => {
    30|   insert(component, Insert.append, appendee);
    31| };
    32| const prepend = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, prependee: AlloySpec): void => {
    33|   insert(component, Insert.prepend, prependee);
    34| };
    35| const remove = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, removee: AlloyComponent): void => {
    36|   const children = contents(component, replaceConfig);
    37|   const foundChild = Arr.find(children, (child) => Compare.eq(removee.element, child.element));
    38|   foundChild.each(Attachment.detach);
    39| };
    40| const contents = (component: AlloyComponent, _replaceConfig: ReplacingConfig): AlloyComponent[] => component.components();
    41| const replaceAt = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, replaceeIndex: number, replacer: Optional<AlloySpec>): Optional<AlloyComponent> => {
    42|   const children = contents(component, replaceConfig);
    43|   return Optional.from(children[replaceeIndex]).map((replacee) => {
    44|     replacer.fold(
    45|       () => Attachment.detach(replacee),
    46|       (r) => {
    47|         const replacer = replaceConfig.reuseDom ? virtualReplace : replace;
    48|         replacer(component, replacee, replaceeIndex, r);
    49|       }
    50|     );
    51|     return replacee;
    52|   });
    53| };
    54| const replaceBy = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, replaceePred: (comp: AlloyComponent) => boolean, replacer: Optional<AlloySpec>): Optional<AlloyComponent> => {
    55|   const children = contents(component, replaceConfig);
    56|   return Arr.findIndex(children, replaceePred).bind((replaceeIndex) => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));
    57| };
    58| export {
    59|   append,
    60|   prepend,
    61|   remove,
    62|   replaceAt,
    63|   replaceBy,
    64|   set,
    65|   contents
    66| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplacingAll.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { AlloyComponent } from '../../api/component/ComponentApi';
     3| import { AlloySpec } from '../../api/component/SpecTypes';
     4| import * as AriaFocus from '../../aria/AriaFocus';
     5| import { patchSpecChildren } from '../../dom/Patching';
     6| import * as InternalAttachment from '../../system/InternalAttachment';
     7| const withoutReuse = (parent: AlloyComponent, data: AlloySpec[]): void => {
     8|   AriaFocus.preserve(() => {
     9|     InternalAttachment.replaceChildren(parent, data, () => Arr.map(data, parent.getSystem().build));
    10|   }, parent.element);
    11| };
    12| const withReuse = (parent: AlloyComponent, data: AlloySpec[]): void => {
    13|   AriaFocus.preserve(() => {
    14|     InternalAttachment.virtualReplaceChildren(parent, data, () => {
    15|       return patchSpecChildren(
    16|         parent.element,
    17|         data,
    18|         parent.getSystem().buildOrPatch
    19|       );
    20|     });
    21|   }, parent.element);
    22| };
    23| export {
    24|   withoutReuse,
    25|   withReuse
    26| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplacingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { Optional } from '@ephox/katamari';
     2| import * as Behaviour from '../../api/behaviour/Behaviour';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { AlloySpec } from '../../api/component/SpecTypes';
     5| export interface ReplacingBehaviour extends Behaviour.AlloyBehaviour<ReplacingConfigSpec, ReplacingConfig> {
     6|   config: (config: ReplacingConfigSpec) => Behaviour.NamedConfiguredBehaviour<ReplacingConfigSpec, ReplacingConfig>;
     7|   append: (component: AlloyComponent, appendee: AlloySpec) => void;
     8|   prepend: (component: AlloyComponent, prependee: AlloySpec) => void;
     9|   remove: (component: AlloyComponent, removee: AlloyComponent) => void;
    10|   replaceAt: (component: AlloyComponent, replaceeIndex: number, replacer: Optional<AlloySpec>) => Optional<AlloyComponent>;
    11|   replaceBy: (component: AlloyComponent, replaceePred: (comp: AlloyComponent) => boolean, replacer: Optional<AlloySpec>) => Optional<AlloyComponent>;
    12|   set: (component: AlloyComponent, data: AlloySpec[]) => void;
    13|   contents: (component: AlloyComponent) => AlloyComponent[];
    14| }
    15| export interface ReplacingConfigSpec extends Behaviour.BehaviourConfigSpec {
    16|   reuseDom?: boolean;
    17| }
    18| export interface ReplacingConfig extends Behaviour.BehaviourConfigDetail {
    19|   reuseDom: boolean;
    20| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sandboxing/SandboxApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-87 ---
     1| import { Arr, Optional } from '@ephox/katamari';
     2| import { Attribute, Css, SugarElement } from '@ephox/sugar';
     3| import { Positioning } from '../../api/behaviour/Positioning';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import { AlloySpec } from '../../api/component/SpecTypes';
     6| import * as Attachment from '../../api/system/Attachment';
     7| import { SandboxingConfig, SandboxingState } from './SandboxingTypes';
     8| const rebuild = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): AlloyComponent => {
     9|   sState.get().each((_data) => {
    10|     Attachment.detachChildren(sandbox);
    11|   });
    12|   const point = sConfig.getAttachPoint(sandbox);
    13|   Attachment.attach(point, sandbox);
    14|   const built = sandbox.getSystem().build(data);
    15|   Attachment.attach(sandbox, built);
    16|   sState.set(built);
    17|   return built;
    18| };
    19| const open = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): AlloyComponent => {
    20|   const newState = rebuild(sandbox, sConfig, sState, data);
    21|   sConfig.onOpen(sandbox, newState);
    22|   return newState;
    23| };
    24| const setContent = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): Optional<AlloyComponent> =>
    25|   sState.get().map(() => rebuild(sandbox, sConfig, sState, data));
    26| const openWhileCloaked = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec, transaction: () => void): void => {
    27|   cloak(sandbox, sConfig, sState);
    28|   open(sandbox, sConfig, sState, data);
    29|   transaction();
    30|   decloak(sandbox, sConfig, sState);
    31| };
    32| const close = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState): void => {
    33|   sState.get().each((data) => {
    34|     Attachment.detachChildren(sandbox);
    35|     Attachment.detach(sandbox);
    36|     sConfig.onClose(sandbox, data);
    37|     sState.clear();
    38|   });
    39| };
    40| const isOpen = (_sandbox: AlloyComponent, _sConfig: SandboxingConfig, sState: SandboxingState): boolean =>
    41|   sState.isOpen();
    42| const isPartOf = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, queryElem: SugarElement<Node>): boolean =>
    43|   isOpen(sandbox, sConfig, sState) && sState.get().exists(
    44|     (data) => sConfig.isPartOf(sandbox, data, queryElem)
    45|   );
    46| const getState = (_sandbox: AlloyComponent, _sConfig: SandboxingConfig, sState: SandboxingState): Optional<AlloyComponent> =>
    47|   sState.get();
    48| const store = (sandbox: AlloyComponent, cssKey: string, attr: string, newValue: string): void => {
    49|   Css.getRaw(sandbox.element, cssKey).fold(() => {
    50|     Attribute.remove(sandbox.element, attr);
    51|   }, (v) => {
    52|     Attribute.set(sandbox.element, attr, v);
    53|   });
    54|   Css.set(sandbox.element, cssKey, newValue);
    55| };
    56| const restore = (sandbox: AlloyComponent, cssKey: string, attr: string): void => {
    57|   Attribute.getOpt(sandbox.element, attr).fold(
    58|     () => Css.remove(sandbox.element, cssKey),
    59|     (oldValue) => Css.set(sandbox.element, cssKey, oldValue)
    60|   );
    61| };
    62| const cloak = (sandbox: AlloyComponent, sConfig: SandboxingConfig, _sState: SandboxingState): void => {
    63|   const sink = sConfig.getAttachPoint(sandbox);
    64|   Css.set(sandbox.element, 'position', Positioning.getMode(sink));
    65|   store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
    66| };
    67| const hasPosition = (element: SugarElement<HTMLElement>): boolean => Arr.exists(
    68|   [ 'top', 'left', 'right', 'bottom' ],
    69|   (pos) => Css.getRaw(element, pos).isSome()
    70| );
    71| const decloak = (sandbox: AlloyComponent, sConfig: SandboxingConfig, _sState: SandboxingState): void => {
    72|   if (!hasPosition(sandbox.element)) {
    73|     Css.remove(sandbox.element, 'position');
    74|   }
    75|   restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
    76| };
    77| export {
    78|   cloak,
    79|   decloak,
    80|   open,
    81|   openWhileCloaked,
    82|   close,
    83|   isOpen,
    84|   isPartOf,
    85|   getState,
    86|   setContent
    87| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sandboxing/SandboxingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as Behaviour from '../../api/behaviour/Behaviour';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import { AlloySpec } from '../../api/component/SpecTypes';
     6| import { BehaviourState } from '../common/BehaviourState';
     7| export interface SandboxingBehaviour extends Behaviour.AlloyBehaviour<SandboxingConfigSpec, SandboxingConfig> {
     8|   config: (config: SandboxingConfigSpec) => Behaviour.NamedConfiguredBehaviour<SandboxingConfigSpec, SandboxingConfig>;
     9|   cloak: (sandbox: AlloyComponent) => void;
    10|   decloak: (sandbox: AlloyComponent) => void;
    11|   open: (sandbox: AlloyComponent, thing: AlloySpec) => AlloyComponent;
    12|   openWhileCloaked: (sandbox: AlloyComponent, thing: AlloySpec, transaction: () => void) => AlloyComponent;
    13|   close: (sandbox: AlloyComponent) => void;
    14|   isOpen: (sandbox: AlloyComponent) => boolean;
    15|   isPartOf: (sandbox: AlloyComponent, candidate: SugarElement<Node>) => boolean;
    16|   getState: (sandbox: AlloyComponent) => Optional<AlloyComponent>;
    17|   setContent: (sandbox: AlloyComponent, thing: AlloySpec) => Optional<AlloyComponent>;
    18|   closeSandbox: (sandbox: AlloyComponent) => void;
    19| }
    20| export interface SandboxingConfigSpec extends Behaviour.BehaviourConfigSpec {
    21|   getAttachPoint: (sandbox: AlloyComponent) => AlloyComponent;
    22|   isPartOf: (sandbox: AlloyComponent, data: AlloyComponent, queryElem: SugarElement<Node>) => boolean;
    23|   onOpen?: (sandbox: AlloyComponent, menu: AlloyComponent) => void;
    24|   onClose?: (sandbox: AlloyComponent, menu: AlloyComponent) => void;
    25|   cloakVisibilityAttr?: string;
    26| }
    27| export interface SandboxingConfig extends Behaviour.BehaviourConfigDetail {
    28|   cloakVisibilityAttr: string;
    29|   getAttachPoint: (sandbox: AlloyComponent) => AlloyComponent;
    30|   onOpen: (sandbox: AlloyComponent, thing: AlloyComponent) => void;
    31|   onClose: (sandbox: AlloyComponent, thing: AlloyComponent) => void;
    32|   isPartOf: (sandbox: AlloyComponent, data: AlloyComponent, queryElem: SugarElement<Node>) => boolean;
    33| }
    34| export interface SandboxingState extends BehaviourState {
    35|   get: () => Optional<AlloyComponent>;
    36|   set: (comp: AlloyComponent) => void;
    37|   isOpen: () => boolean;
    38|   clear: () => void;
    39| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-124 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { Class, Classes, Css, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { SlidingConfig, SlidingState } from './SlidingTypes';
     5| import { getAnimationRoot } from './SlidingUtils';
     6| const getDimensionProperty = (slideConfig: SlidingConfig): string =>
     7|   slideConfig.dimension.property;
     8| const getDimension = (slideConfig: SlidingConfig, elem: SugarElement<HTMLElement>): string =>
     9|   slideConfig.dimension.getDimension(elem);
    10| const disableTransitions = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
    11|   const root = getAnimationRoot(component, slideConfig);
    12|   Classes.remove(root, [ slideConfig.shrinkingClass, slideConfig.growingClass ]);
    13| };
    14| const setShrunk = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
    15|   Class.remove(component.element, slideConfig.openClass);
    16|   Class.add(component.element, slideConfig.closedClass);
    17|   Css.set(component.element, getDimensionProperty(slideConfig), '0px');
    18|   Css.reflow(component.element);
    19| };
    20| const setGrown = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
    21|   Class.remove(component.element, slideConfig.closedClass);
    22|   Class.add(component.element, slideConfig.openClass);
    23|   Css.remove(component.element, getDimensionProperty(slideConfig));
    24| };
    25| const doImmediateShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState, _calculatedSize: Optional<string>): void => {
    26|   slideState.setCollapsed();
    27|   Css.set(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
    28|   Css.reflow(component.element);
    29|   disableTransitions(component, slideConfig);
    30|   setShrunk(component, slideConfig);
    31|   slideConfig.onStartShrink(component);
    32|   slideConfig.onShrunk(component);
    33| };
    34| const doStartShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState, calculatedSize: Optional<string>): void => {
    35|   const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));
    36|   slideState.setCollapsed();
    37|   Css.set(component.element, getDimensionProperty(slideConfig), size);
    38|   Css.reflow(component.element);
    39|   const root = getAnimationRoot(component, slideConfig);
    40|   Class.remove(root, slideConfig.growingClass);
    41|   Class.add(root, slideConfig.shrinkingClass); // enable transitions
    42|   setShrunk(component, slideConfig);
    43|   slideConfig.onStartShrink(component);
    44| };
    45| const doStartSmartShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    46|   const size: string = getDimension(slideConfig, component.element);
    47|   const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
    48|   shrinker(component, slideConfig, slideState, Optional.some(size));
    49| };
    50| const doStartGrow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    51|   const root = getAnimationRoot(component, slideConfig);
    52|   const wasShrinking = Class.has(root, slideConfig.shrinkingClass);
    53|   const beforeSize = getDimension(slideConfig, component.element);
    54|   setGrown(component, slideConfig);
    55|   const fullSize = getDimension(slideConfig, component.element);
    56|   const startPartialGrow = () => {
    57|     Css.set(component.element, getDimensionProperty(slideConfig), beforeSize);
    58|     Css.reflow(component.element);
    59|   };
    60|   const startCompleteGrow = () => {
    61|     setShrunk(component, slideConfig);
    62|   };
    63|   const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
    64|   setStartSize();
    65|   Class.remove(root, slideConfig.shrinkingClass);
    66|   Class.add(root, slideConfig.growingClass);
    67|   setGrown(component, slideConfig);
    68|   Css.set(component.element, getDimensionProperty(slideConfig), fullSize);
    69|   slideState.setExpanded();
    70|   slideConfig.onStartGrow(component);
    71| };
    72| const refresh = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    73|   if (slideState.isExpanded()) {
    74|     Css.remove(component.element, getDimensionProperty(slideConfig));
    75|     const fullSize = getDimension(slideConfig, component.element);
    76|     Css.set(component.element, getDimensionProperty(slideConfig), fullSize);
    77|   }
    78| };
    79| const grow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    80|   if (!slideState.isExpanded()) {
    81|     doStartGrow(component, slideConfig, slideState);
    82|   }
    83| };
    84| const shrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    85|   if (slideState.isExpanded()) {
    86|     doStartSmartShrink(component, slideConfig, slideState);
    87|   }
    88| };
    89| const immediateShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
    90|   if (slideState.isExpanded()) {
    91|     doImmediateShrink(component, slideConfig, slideState, Optional.none());
    92|   }
    93| };
    94| const hasGrown = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
    95|   slideState.isExpanded();
    96| const hasShrunk = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
    97|   slideState.isCollapsed();
    98| const isGrowing = (component: AlloyComponent, slideConfig: SlidingConfig, _slideState: SlidingState): boolean => {
    99|   const root = getAnimationRoot(component, slideConfig);
   100|   return Class.has(root, slideConfig.growingClass) === true;
   101| };
   102| const isShrinking = (component: AlloyComponent, slideConfig: SlidingConfig, _slideState: SlidingState): boolean => {
   103|   const root = getAnimationRoot(component, slideConfig);
   104|   return Class.has(root, slideConfig.shrinkingClass) === true;
   105| };
   106| const isTransitioning = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
   107|   isGrowing(component, slideConfig, slideState) || isShrinking(component, slideConfig, slideState);
   108| const toggleGrow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
   109|   const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
   110|   f(component, slideConfig, slideState);
   111| };
   112| export {
   113|   refresh,
   114|   grow,
   115|   shrink,
   116|   immediateShrink,
   117|   hasGrown,
   118|   hasShrunk,
   119|   isGrowing,
   120|   isShrinking,
   121|   isTransitioning,
   122|   toggleGrow,
   123|   disableTransitions
   124| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingSchema.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Height, SugarElement, Width } from '@ephox/sugar';
     3| import * as Fields from '../../data/Fields';
     4| export default [
     5|   FieldSchema.required('closedClass'),
     6|   FieldSchema.required('openClass'),
     7|   FieldSchema.required('shrinkingClass'),
     8|   FieldSchema.required('growingClass'),
     9|   FieldSchema.option('getAnimationRoot'),
    10|   Fields.onHandler('onShrunk'),
    11|   Fields.onHandler('onStartShrink'),
    12|   Fields.onHandler('onGrown'),
    13|   Fields.onHandler('onStartGrow'),
    14|   FieldSchema.defaulted('expanded', false),
    15|   FieldSchema.requiredOf('dimension', StructureSchema.choose(
    16|     'property', {
    17|       width: [
    18|         Fields.output('property', 'width'),
    19|         Fields.output('getDimension', (elem: SugarElement<HTMLElement>) => Width.get(elem) + 'px')
    20|       ],
    21|       height: [
    22|         Fields.output('property', 'height'),
    23|         Fields.output('getDimension', (elem: SugarElement<HTMLElement>) => Height.get(elem) + 'px')
    24|       ]
    25|     }
    26|   ))
    27| ];


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as Behaviour from '../../api/behaviour/Behaviour';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import { BehaviourState } from '../common/BehaviourState';
     6| export interface SlidingBehaviour extends Behaviour.AlloyBehaviour<SlidingConfigSpec, SlidingConfig> {
     7|   config: (config: SlidingConfigSpec) => Behaviour.NamedConfiguredBehaviour<SlidingConfigSpec, SlidingConfig>;
     8|   refresh: (component: AlloyComponent) => void;
     9|   grow: (component: AlloyComponent) => void;
    10|   shrink: (component: AlloyComponent) => void;
    11|   immediateShrink: (component: AlloyComponent) => void;
    12|   hasGrown: (component: AlloyComponent) => boolean;
    13|   hasShrunk: (component: AlloyComponent) => boolean;
    14|   isGrowing: (component: AlloyComponent) => boolean;
    15|   isShrinking: (component: AlloyComponent) => boolean;
    16|   isTransitioning: (component: AlloyComponent) => boolean;
    17|   toggleGrow: (component: AlloyComponent) => void;
    18|   disableTransitions: (component: AlloyComponent) => void;
    19| }
    20| export interface SlidingConfig extends Behaviour.BehaviourConfigDetail {
    21|   expanded: boolean;
    22|   openClass: string;
    23|   closedClass: string;
    24|   dimension: {
    25|     property: string;
    26|     getDimension: (elem: SugarElement<HTMLElement>) => string;
    27|   };
    28|   onGrown: (comp: AlloyComponent) => void;
    29|   onShrunk: (comp: AlloyComponent) => void;
    30|   shrinkingClass: string;
    31|   growingClass: string;
    32|   onStartGrow: (comp: AlloyComponent) => void;
    33|   onStartShrink: (comp: AlloyComponent) => void;
    34|   getAnimationRoot: Optional<(comp: AlloyComponent) => SugarElement<Element>>;
    35| }
    36| export interface SlidingState extends BehaviourState {
    37|   isExpanded: () => boolean;
    38|   setExpanded: () => void;
    39|   isCollapsed: () => boolean;
    40|   setCollapsed: () => void;
    41| }
    42| export interface SlidingConfigSpec extends Behaviour.BehaviourConfigSpec {
    43|   dimension: {
    44|     property: string;
    45|   };
    46|   closedClass: string;
    47|   openClass: string;
    48|   shrinkingClass: string;
    49|   growingClass: string;
    50|   onStartGrow?: (component: AlloyComponent) => void;
    51|   getAnimationRoot?: (component: AlloyComponent) => SugarElement<Element>;
    52|   onStartShrink?: (component: AlloyComponent) => void;
    53|   onShrunk?: (component: AlloyComponent) => void;
    54|   onGrown?: (component: AlloyComponent) => void;
    55|   expanded?: boolean;
    56| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingUtils.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import { AlloyComponent } from '../../api/component/ComponentApi';
     3| import { SlidingConfig } from './SlidingTypes';
     4| export const getAnimationRoot = (component: AlloyComponent, slideConfig: SlidingConfig): SugarElement<Element> =>
     5|   slideConfig.getAnimationRoot.fold(
     6|     () => component.element,
     7|     (get) => get(component)
     8|   );


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/behaviour/swapping/SwapApis.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import { Class, SugarElement } from '@ephox/sugar';
     2| import { AlloyComponent } from '../../api/component/ComponentApi';
     3| import { Stateless } from '../common/BehaviourState';
     4| import { SwappingConfig } from './SwappingTypes';
     5| const swap = (element: SugarElement<Element>, addCls: string, removeCls: string): void => {
     6|   Class.remove(element, removeCls);
     7|   Class.add(element, addCls);
     8| };
     9| const toAlpha = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
    10|   swap(component.element, swapConfig.alpha, swapConfig.omega);
    11| };
    12| const toOmega = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
    13|   swap(component.element, swapConfig.omega, swapConfig.alpha);
    14| };
    15| const clear = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
    16|   Class.remove(component.element, swapConfig.alpha);
    17|   Class.remove(component.element, swapConfig.omega);
    18| };
    19| const isAlpha = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): boolean =>
    20|   Class.has(component.element, swapConfig.alpha);
    21| const isOmega = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): boolean =>
    22|   Class.has(component.element, swapConfig.omega);
    23| export {
    24|   toAlpha,
    25|   toOmega,
    26|   isAlpha,
    27|   isOmega,
    28|   clear
    29| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/debugging/Debugging.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-211 ---
     1| import { Objects } from '@ephox/boulder';
     2| import { Arr, Cell, Fun, Global, Obj, Optional } from '@ephox/katamari';
     3| import { SugarElement } from '@ephox/sugar';
     4| import { AlloyComponent } from '../api/component/ComponentApi';
     5| import * as SystemEvents from '../api/events/SystemEvents';
     6| import { GuiSystem } from '../api/system/Gui';
     7| import * as AlloyLogger from '../log/AlloyLogger';
     8| export interface DebuggerLogger {
     9|   logEventCut: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
    10|   logEventStopped: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
    11|   logNoParent: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
    12|   logEventNoHandlers: (eventName: string, target: SugarElement<Node>) => void;
    13|   logEventResponse: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
    14|   write: () => void;
    15| }
    16| export interface InspectorInfo {
    17|   '(original.spec)': any;
    18|   '(dom.ref)': Node;
    19|   '(element)': string;
    20|   '(initComponents)': InspectorInfo[];
    21|   '(components)': InspectorInfo[];
    22|   '(bound.events)': string;
    23|   '(behaviours)': string | Record<string, any>;
    24| }
    25| type LookupInfo = { [key: string]: InspectorInfo } | { error: string };
    26| export interface Inspector {
    27|   systems: Record<string, GuiSystem>;
    28|   lookup: (uid: string) => Optional<LookupInfo>;
    29|   events: {
    30|     setToNormal: (eventName: string) => void;
    31|     setToLogging: (eventName: string) => void;
    32|     setToStop: (eventName: string) => void;
    33|   };
    34| }
    35| interface AlloyGlobal {
    36|   __CHROME_INSPECTOR_CONNECTION_TO_ALLOY__: Inspector;
    37| }
    38| const unknown = 'unknown';
    39| /*
    40|   typescipt qwerk:
    41|   const debugging: boolean = true;
    42|   if (boolean === false) {  -> this throws a type error! // TS2365:Operator '===' cannot be applied to types 'false' and 'true'
    43|     https://www.typescriptlang.org/play/#src=const%20foo%3A%20boolean%20%3D%20true%3B%0D%0A%0D%0Aif%20(foo%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20%0D%0A%7D
    44|   }
    45| */
    46| const debugging: any = true;
    47| const CHROME_INSPECTOR_GLOBAL = '__CHROME_INSPECTOR_CONNECTION_TO_ALLOY__';
    48| enum EventConfiguration {
    49|   STOP,
    50|   NORMAL,
    51|   LOGGING
    52| }
    53| const eventConfig = Cell<Record<string, EventConfiguration>>({ });
    54| export type EventProcessor = (logger: DebuggerLogger) => boolean;
    55| const makeEventLogger = (eventName: string, initialTarget: SugarElement<Node>): DebuggerLogger => {
    56|   const sequence: Array<{ outcome: string; target: SugarElement<Node>; purpose?: string }> = [ ];
    57|   const startTime = new Date().getTime();
    58|   return {
    59|     logEventCut: (_name: string, target: SugarElement<Node>, purpose: string) => {
    60|       sequence.push({ outcome: 'cut', target, purpose });
    61|     },
    62|     logEventStopped: (_name: string, target: SugarElement<Node>, purpose: string) => {
    63|       sequence.push({ outcome: 'stopped', target, purpose });
    64|     },
    65|     logNoParent: (_name: string, target: SugarElement<Node>, purpose: string) => {
    66|       sequence.push({ outcome: 'no-parent', target, purpose });
    67|     },
    68|     logEventNoHandlers: (_name: string, target: SugarElement<Node>) => {
    69|       sequence.push({ outcome: 'no-handlers-left', target });
    70|     },
    71|     logEventResponse: (_name: string, target: SugarElement<Node>, purpose: string) => {
    72|       sequence.push({ outcome: 'response', purpose, target });
    73|     },
    74|     write: () => {
    75|       const finishTime = new Date().getTime();
    76|       if (Arr.contains([ 'mousemove', 'mouseover', 'mouseout', SystemEvents.systemInit() ], eventName)) {
    77|         return;
    78|       }
    79|       console.log(eventName, {
    80|         event: eventName,
    81|         time: finishTime - startTime,
    82|         target: initialTarget.dom,
    83|         sequence: Arr.map(sequence, (s) => {
    84|           if (!Arr.contains([ 'cut', 'stopped', 'response' ], s.outcome)) {
    85|             return s.outcome;
    86|           } else {
    87|             return '{' + s.purpose + '} ' + s.outcome + ' at (' + AlloyLogger.element(s.target) + ')';
    88|           }
    89|         })
    90|       });
    91|     }
    92|   };
    93| };
    94| const processEvent = (eventName: string, initialTarget: SugarElement<Node>, f: EventProcessor) => {
    95|   const status = Obj.get(eventConfig.get(), eventName).orThunk(() => {
    96|     const patterns = Obj.keys(eventConfig.get());
    97|     return Arr.findMap(patterns, (p) => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());
    98|   }).getOr(
    99|     EventConfiguration.NORMAL
   100|   );
   101|   switch (status) {
   102|     case EventConfiguration.NORMAL:
   103|       return f(noLogger());
   104|     case EventConfiguration.LOGGING: {
   105|       const logger = makeEventLogger(eventName, initialTarget);
   106|       const output = f(logger);
   107|       logger.write();
   108|       return output;
   109|     }
   110|     case EventConfiguration.STOP:
   111|       return true;
   112|   }
   113| };
   114| const path = [
   115|   'alloy/data/Fields',
   116|   'alloy/debugging/Debugging'
   117| ];
   118| const getTrace = (): string => {
   119|   if (debugging === false) {
   120|     return unknown;
   121|   }
   122|   const err = new Error();
   123|   if (err.stack !== undefined) {
   124|     const lines = err.stack.split('\n');
   125|     return Arr.find(lines, (line) => line.indexOf('alloy') > 0 && !Arr.exists(path, (p) => line.indexOf(p) > -1)).getOr(unknown);
   126|   } else {
   127|     return unknown;
   128|   }
   129| };
   130| const logHandler = (_label: string, _handlerName: string, _trace: any): void => {
   131| };
   132| const ignoreEvent = {
   133|   logEventCut: Fun.noop,
   134|   logEventStopped: Fun.noop,
   135|   logNoParent: Fun.noop,
   136|   logEventNoHandlers: Fun.noop,
   137|   logEventResponse: Fun.noop,
   138|   write: Fun.noop
   139| };
   140| const monitorEvent = (eventName: string, initialTarget: SugarElement<Node>, f: EventProcessor): boolean =>
   141|   processEvent(eventName, initialTarget, f);
   142| const inspectorInfo = (comp: AlloyComponent) => {
   143|   const go = (c: AlloyComponent): InspectorInfo => {
   144|     const cSpec = c.spec;
   145|     return {
   146|       '(original.spec)': cSpec,
   147|       '(dom.ref)': c.element.dom,
   148|       '(element)': AlloyLogger.element(c.element),
   149|       '(initComponents)': Arr.map(cSpec.components !== undefined ? cSpec.components : [ ], go),
   150|       '(components)': Arr.map(c.components(), go),
   151|       '(bound.events)': Obj.mapToArray(c.events, (_v, k) => [ k ]).join(', '),
   152|       '(behaviours)': cSpec.behaviours !== undefined ? Obj.map(cSpec.behaviours, (v, k) => v === undefined ? '--revoked--' : {
   153|         'config': v.configAsRaw(),
   154|         'original-config': v.initialConfig,
   155|         'state': c.readState(k)
   156|       }) : 'none'
   157|     };
   158|   };
   159|   return go(comp);
   160| };
   161| const getOrInitConnection = (): Inspector => {
   162|   const win: AlloyGlobal = Global;
   163|   if (win[CHROME_INSPECTOR_GLOBAL] !== undefined) {
   164|     return win[CHROME_INSPECTOR_GLOBAL];
   165|   } else {
   166|     const setEventStatus = (eventName: string, status: EventConfiguration) => {
   167|       const evs = eventConfig.get();
   168|       evs[eventName] = status;
   169|       eventConfig.set(evs);
   170|     };
   171|     win[CHROME_INSPECTOR_GLOBAL] = {
   172|       systems: { },
   173|       lookup: (uid: string) => {
   174|         const systems = win[CHROME_INSPECTOR_GLOBAL].systems;
   175|         const connections: string[] = Obj.keys(systems);
   176|         return Arr.findMap(connections, (conn) => {
   177|           const connGui = systems[conn];
   178|           return connGui.getByUid(uid).toOptional().map((comp): LookupInfo => Objects.wrap(AlloyLogger.element(comp.element), inspectorInfo(comp)));
   179|         }).orThunk(() => Optional.some<LookupInfo>({
   180|           error: 'Systems (' + connections.join(', ') + ') did not contain uid: ' + uid
   181|         }));
   182|       },
   183|       events: {
   184|         setToNormal: (eventName: string) => {
   185|           setEventStatus(eventName, EventConfiguration.NORMAL);
   186|         },
   187|         setToLogging: (eventName: string) => {
   188|           setEventStatus(eventName, EventConfiguration.LOGGING);
   189|         },
   190|         setToStop: (eventName: string) => {
   191|           setEventStatus(eventName, EventConfiguration.STOP);
   192|         }
   193|       }
   194|     };
   195|     return win[CHROME_INSPECTOR_GLOBAL];
   196|   }
   197| };
   198| const registerInspector = (name: string, gui: GuiSystem): void => {
   199|   const connection = getOrInitConnection();
   200|   connection.systems[name] = gui;
   201| };
   202| const noLogger = Fun.constant(ignoreEvent);
   203| const isDebugging = Fun.constant(debugging);
   204| export {
   205|   logHandler,
   206|   noLogger,
   207|   getTrace,
   208|   monitorEvent,
   209|   isDebugging,
   210|   registerInspector
   211| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dom/DomDefinition.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-44 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| export interface GeneralDefinitionSpec<EC> {
     4|   uid: string;
     5|   tag?: string;
     6|   attributes?: Record<string, any>;
     7|   classes?: string[];
     8|   styles?: Record<string, string>;
     9|   value?: any;
    10|   innerHtml?: string;
    11|   domChildren?: EC;
    12| }
    13| export interface DomDefinitionSpec extends GeneralDefinitionSpec<SugarElement<Node>> {
    14| }
    15| export interface GeneralDefinitionDetail<EC> {
    16|   uid: string;
    17|   tag: string;
    18|   attributes: Record<string, any>;
    19|   classes: string[];
    20|   styles: Record<string, string>;
    21|   value: Optional<any>;
    22|   innerHtml: Optional<string>;
    23|   domChildren: EC[];
    24| }
    25| export interface DomDefinitionDetail extends GeneralDefinitionDetail<SugarElement<Node>> {
    26| }
    27| const defToStr = <EC>(defn: GeneralDefinitionDetail<EC>): string => {
    28|   const raw = defToRaw(defn);
    29|   return JSON.stringify(raw, null, 2);
    30| };
    31| const defToRaw = <EC>(defn: GeneralDefinitionDetail<EC>): GeneralDefinitionSpec<string> => ({
    32|   uid: defn.uid,
    33|   tag: defn.tag,
    34|   classes: defn.classes,
    35|   attributes: defn.attributes,
    36|   styles: defn.styles,
    37|   value: defn.value.getOr('<none>'),
    38|   innerHtml: defn.innerHtml.getOr('<none>'),
    39|   domChildren: defn.domChildren.length === 0 ? '0 children, but still specified' : String(defn.domChildren.length)
    40| });
    41| export {
    42|   defToStr,
    43|   defToRaw
    44| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dom/DomRender.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-42 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { Attribute, Classes, Css, Html, InsertAll, SugarElement, SugarNode, Value } from '@ephox/sugar';
     3| import { isPremade } from '../api/ui/GuiTypes';
     4| import * as Tagger from '../registry/Tagger';
     5| import * as DomDefinition from './DomDefinition';
     6| import { reconcileToDom } from './Reconcile';
     7| const introduceToDom = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>): SugarElement<HTMLElement> => {
     8|   const subject = SugarElement.fromTag(definition.tag);
     9|   Attribute.setAll(subject, definition.attributes);
    10|   Classes.add(subject, definition.classes);
    11|   Css.setAll(subject, definition.styles);
    12|   definition.innerHtml.each((html) => Html.set(subject, html));
    13|   const children = definition.domChildren;
    14|   InsertAll.append(subject, children);
    15|   definition.value.each((value) => {
    16|     Value.set(subject as SugarElement<HTMLInputElement | HTMLTextAreaElement>, value);
    17|   });
    18|   return subject;
    19| };
    20| const attemptPatch = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>, obsoleted: SugarElement<Element>): Optional<SugarElement<Element>> => {
    21|   try {
    22|     const e = reconcileToDom(definition, obsoleted);
    23|     return Optional.some(e);
    24|   } catch (err) {
    25|     return Optional.none();
    26|   }
    27| };
    28| const hasMixedChildren = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>) =>
    29|   definition.innerHtml.isSome() && definition.domChildren.length > 0;
    30| const renderToDom = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>, optObsoleted: Optional<SugarElement<Node>>): SugarElement<Element> => {
    31|   const canBePatched = (candidate: SugarElement<Node>): candidate is SugarElement<Element> =>
    32|     SugarNode.name(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);
    33|   const elem = optObsoleted
    34|     .filter(canBePatched)
    35|     .bind((obsoleted) => attemptPatch(definition, obsoleted))
    36|     .getOrThunk(() => introduceToDom(definition));
    37|   Tagger.writeOnly(elem, definition.uid);
    38|   return elem;
    39| };
    40| export {
    41|   renderToDom
    42| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dom/Patching.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-59 ---
     1| import { Arr, Optional } from '@ephox/katamari';
     2| import { Compare, Insert, Remove, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import { AlloySpec } from '../api/component/SpecTypes';
     5| type SpecBuilder = (spec: AlloySpec, optObs: Optional<SugarElement<Node>>) => AlloyComponent;
     6| const determineObsoleted = (parent: SugarElement<Element>, index: number, oldObsoleted: Optional<SugarElement<Node>>): Optional<SugarElement<Node>> => {
     7|   const newObsoleted = Traverse.child(parent, index);
     8|   return newObsoleted.map((newObs) => {
     9|     const elemChanged = oldObsoleted.exists((o) => !Compare.eq(o, newObs));
    10|     if (elemChanged) {
    11|       const oldTag = oldObsoleted.map(SugarNode.name).getOr('span');
    12|       const marker = SugarElement.fromTag(oldTag);
    13|       Insert.before(newObs, marker);
    14|       return marker;
    15|     } else {
    16|       return newObs;
    17|     }
    18|   });
    19| };
    20| const ensureInDom = (parent: SugarElement<Element>, child: SugarElement<Node>, obsoleted: Optional<SugarElement<Node>>): void => {
    21|   obsoleted.fold(
    22|     () => Insert.append(parent, child),
    23|     (obs) => {
    24|       if (!Compare.eq(obs, child)) {
    25|         Insert.before(obs, child);
    26|         Remove.remove(obs);
    27|       } else {
    28|       }
    29|     }
    30|   );
    31| };
    32| const patchChildrenWith = <T, C>(parent: SugarElement<Element>, nu: T[], f: (n: T, i: number) => C) => {
    33|   const builtChildren = Arr.map(nu, f);
    34|   const currentChildren = Traverse.children(parent);
    35|   Arr.each(currentChildren.slice(builtChildren.length), Remove.remove);
    36|   return builtChildren;
    37| };
    38| const patchSpecChild = (parent: SugarElement<Element>, index: number, spec: AlloySpec, build: SpecBuilder): AlloyComponent => {
    39|   const oldObsoleted = Traverse.child(parent, index);
    40|   const childComp = build(spec, oldObsoleted);
    41|   const obsoleted = determineObsoleted(parent, index, oldObsoleted);
    42|   ensureInDom(parent, childComp.element, obsoleted);
    43|   return childComp;
    44| };
    45| const patchSpecChildren = (parent: SugarElement<Element>, specs: AlloySpec[], build: SpecBuilder): AlloyComponent[] =>
    46|   patchChildrenWith(parent, specs, (spec, index) =>
    47|     patchSpecChild(parent, index, spec, build)
    48|   );
    49| const patchDomChildren = (parent: SugarElement<Element>, nodes: SugarElement<Node>[]): SugarElement<Node>[] =>
    50|   patchChildrenWith(parent, nodes, (node, index) => {
    51|     const optObsoleted = Traverse.child(parent, index);
    52|     ensureInDom(parent, node, optObsoleted);
    53|     return node;
    54|   });
    55| export {
    56|   patchDomChildren,
    57|   patchSpecChild,
    58|   patchSpecChildren
    59| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dom/Reconcile.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| import { Arr, Obj } from '@ephox/katamari';
     2| import { Attribute, Classes, Css, Html, SugarElement, Value } from '@ephox/sugar';
     3| import { DomDefinitionDetail } from './DomDefinition';
     4| import { patchDomChildren } from './Patching';
     5| interface KeyValueDiff {
     6|   readonly toSet: Record<string, string>;
     7|   readonly toRemove: string[];
     8| }
     9| const diffKeyValueSet = (newObj: Record<string, string>, oldObj: Record<string, string>): KeyValueDiff => {
    10|   const newKeys = Obj.keys(newObj);
    11|   const oldKeys = Obj.keys(oldObj);
    12|   const toRemove = Arr.difference(oldKeys, newKeys);
    13|   const toSet = Obj.bifilter(newObj, (v, k) => {
    14|     return !Obj.has(oldObj, k) || v !== oldObj[k];
    15|   }).t;
    16|   return { toRemove, toSet };
    17| };
    18| const reconcileToDom = (definition: DomDefinitionDetail, obsoleted: SugarElement<Element>): SugarElement<Element> => {
    19|   const { class: clazz, style, ...existingAttributes } = Attribute.clone(obsoleted);
    20|   const { toSet: attrsToSet, toRemove: attrsToRemove } = diffKeyValueSet(definition.attributes, existingAttributes);
    21|   const updateAttrs = () => {
    22|     Arr.each(attrsToRemove, (a) => Attribute.remove(obsoleted, a));
    23|     Attribute.setAll(obsoleted, attrsToSet);
    24|   };
    25|   const existingStyles = Css.getAllRaw(obsoleted);
    26|   const { toSet: stylesToSet, toRemove: stylesToRemove } = diffKeyValueSet(definition.styles, existingStyles);
    27|   const updateStyles = () => {
    28|     Arr.each(stylesToRemove, (s) => Css.remove(obsoleted, s));
    29|     Css.setAll(obsoleted, stylesToSet);
    30|   };
    31|   const existingClasses = Classes.get(obsoleted);
    32|   const classesToRemove = Arr.difference(existingClasses, definition.classes);
    33|   const classesToAdd = Arr.difference(definition.classes, existingClasses);
    34|   const updateClasses = () => {
    35|     Classes.add(obsoleted, classesToAdd);
    36|     Classes.remove(obsoleted, classesToRemove);
    37|   };
    38|   const updateHtml = (html: string) => {
    39|     Html.set(obsoleted, html);
    40|   };
    41|   const updateChildren = () => {
    42|     const children = definition.domChildren;
    43|     patchDomChildren(obsoleted, children);
    44|   };
    45|   const updateValue = () => {
    46|     const valueElement = obsoleted as SugarElement<HTMLInputElement | HTMLTextAreaElement>;
    47|     definition.value
    48|       .filter((value) => value !== Value.get(valueElement))
    49|       .each((value) => Value.set(valueElement, value));
    50|   };
    51|   updateAttrs();
    52|   updateClasses();
    53|   updateStyles();
    54|   definition.innerHtml.fold(updateChildren, updateHtml);
    55|   updateValue();
    56|   return obsoleted;
    57| };
    58| export {
    59|   reconcileToDom
    60| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/common/DragMovement.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-66 ---
     1| import { Fun, Num, Optional, Optionals } from '@ephox/katamari';
     2| import { Css, Scroll, SugarElement, SugarLocation, SugarPosition, Traverse } from '@ephox/sugar';
     3| import * as OffsetOrigin from '../../alien/OffsetOrigin';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import * as DragCoord from '../../api/data/DragCoord';
     6| import * as Snappables from '../snap/Snappables';
     7| import { DraggingConfig, DragStartData, SnapsConfig } from './DraggingTypes';
     8| const getCurrentCoord = (target: SugarElement<HTMLElement>): DragCoord.CoordAdt =>
     9|   Optionals.lift3(Css.getRaw(target, 'left'), Css.getRaw(target, 'top'), Css.getRaw(target, 'position'), (left, top, position) => {
    10|     const nu = position === 'fixed' ? DragCoord.fixed : DragCoord.offset;
    11|     return nu(
    12|       parseInt(left, 10),
    13|       parseInt(top, 10)
    14|     );
    15|   }).getOrThunk(() => {
    16|     const location = SugarLocation.absolute(target);
    17|     return DragCoord.absolute(location.left, location.top);
    18|   });
    19| const clampCoords = (component: AlloyComponent, coords: DragCoord.CoordAdt, scroll: SugarPosition, origin: SugarPosition, startData: DragStartData): DragCoord.CoordAdt => {
    20|   const bounds = startData.bounds;
    21|   const absoluteCoord = DragCoord.asAbsolute(coords, scroll, origin);
    22|   const newX = Num.clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);
    23|   const newY = Num.clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);
    24|   const newCoords = DragCoord.absolute(newX, newY);
    25|   return coords.fold(
    26|     () => {
    27|       const offset = DragCoord.asOffset(newCoords, scroll, origin);
    28|       return DragCoord.offset(offset.left, offset.top);
    29|     },
    30|     Fun.constant(newCoords),
    31|     () => {
    32|       const fixed = DragCoord.asFixed(newCoords, scroll, origin);
    33|       return DragCoord.fixed(fixed.left, fixed.top);
    34|     }
    35|   );
    36| };
    37| const calcNewCoord = <E>(component: AlloyComponent, optSnaps: Optional<SnapsConfig<E>>, currentCoord: DragCoord.CoordAdt, scroll: SugarPosition, origin: SugarPosition, delta: SugarPosition, startData: DragStartData): DragCoord.CoordAdt => {
    38|   const newCoord = optSnaps.fold(() => {
    39|     const translated = DragCoord.translate(currentCoord, delta.left, delta.top);
    40|     const fixedCoord = DragCoord.asFixed(translated, scroll, origin);
    41|     return DragCoord.fixed(fixedCoord.left, fixedCoord.top);
    42|   }, (snapInfo) => {
    43|     const snapping = Snappables.moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
    44|     snapping.extra.each((extra) => {
    45|       snapInfo.onSensor(component, extra);
    46|     });
    47|     return snapping.coord;
    48|   });
    49|   return clampCoords(component, newCoord, scroll, origin, startData);
    50| };
    51| const dragBy = <E>(component: AlloyComponent, dragConfig: DraggingConfig<E>, startData: DragStartData, delta: SugarPosition): void => {
    52|   const target = dragConfig.getTarget(component.element);
    53|   if (dragConfig.repositionTarget) {
    54|     const doc = Traverse.owner(component.element);
    55|     const scroll = Scroll.get(doc);
    56|     const origin = OffsetOrigin.getOrigin(target);
    57|     const currentCoord = getCurrentCoord(target);
    58|     const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
    59|     const styles = DragCoord.toStyles(newCoord, scroll, origin);
    60|     Css.setOptions(target, styles);
    61|   }
    62|   dragConfig.onDrag(component, target, delta);
    63| };
    64| export {
    65|   dragBy
    66| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/common/DraggingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { EventArgs, SugarElement, SugarPosition } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import * as Behaviour from '../../api/behaviour/Behaviour';
     5| import { AlloyComponent } from '../../api/component/ComponentApi';
     6| import { CoordAdt } from '../../api/data/DragCoord';
     7| import * as AlloyEvents from '../../api/events/AlloyEvents';
     8| import { BehaviourState } from '../../behaviour/common/BehaviourState';
     9| import { MouseDraggingConfigSpec } from '../mouse/MouseDraggingTypes';
    10| import { MouseOrTouchDraggingConfigSpec } from '../mouseortouch/MouseOrTouchDraggingTypes';
    11| import { TouchDraggingConfigSpec } from '../touch/TouchDraggingTypes';
    12| export interface DraggingBehaviour<E> extends Behaviour.AlloyBehaviour<DraggingConfigSpec<E>, DraggingConfig<E>, DraggingState> {
    13|   config: (config: DraggingConfigSpec<E>) => Behaviour.NamedConfiguredBehaviour<DraggingConfigSpec<E>, DraggingConfig<E>, DraggingState>;
    14|   snap: (sConfig: SnapConfigSpec<E>) => SnapConfig<E>;
    15|   snapTo: (component: AlloyComponent, sConfig: SnapConfig<E>) => void;
    16| }
    17| /*
    18|  * Current dragging modes supported:
    19|  *  - mouse: Will allow dragging when using mouse events only
    20|  *  - touch: Will allow dragging when using touch events only
    21|  *  - mouseOrTouch: Will allow dragging with both mouse and touch events
    22|  */
    23| export type DraggingMode = 'touch' | 'mouse' | 'mouseOrTouch';
    24| export type SensorCoords = (x: number, y: number) => CoordAdt;
    25| export type OutputCoords = (x: Optional<number>, y: Optional<number>) => CoordAdt;
    26| export interface SnapConfig<E> {
    27|   readonly sensor: CoordAdt;
    28|   readonly range: SugarPosition;
    29|   readonly output: CoordAdt<Optional<number>>;
    30|   readonly extra: Optional<E>;
    31| }
    32| export interface SnapConfigSpec<E> {
    33|   readonly sensor: CoordAdt;
    34|   readonly range: SugarPosition;
    35|   readonly output: CoordAdt<Optional<number>>;
    36|   readonly extra?: E;
    37| }
    38| export interface SnapOutput<E> {
    39|   readonly output: CoordAdt;
    40|   readonly extra: Optional<E>;
    41| }
    42| export interface SnapPin<E> {
    43|   readonly coord: CoordAdt;
    44|   readonly extra: Optional<E>;
    45| }
    46| export interface SnapsConfig<E> {
    47|   readonly getSnapPoints: (comp: AlloyComponent) => Array<SnapConfig<E>>;
    48|   readonly leftAttr: string;
    49|   readonly topAttr: string;
    50|   readonly onSensor: (component: AlloyComponent, extra: E) => void;
    51|   readonly lazyViewport: (component: AlloyComponent) => Bounds;
    52|   readonly mustSnap: boolean;
    53| }
    54| export interface SnapsConfigSpec<E> {
    55|   readonly getSnapPoints: (comp: AlloyComponent) => Array<SnapConfig<E>>;
    56|   readonly leftAttr: string;
    57|   readonly topAttr: string;
    58|   readonly onSensor?: (component: AlloyComponent, extra: E) => void;
    59|   readonly lazyViewport?: (component: AlloyComponent) => Bounds;
    60|   readonly mustSnap?: boolean;
    61| }
    62| export interface DraggingConfig<E> {
    63|   readonly getTarget: (comp: SugarElement<HTMLElement>) => SugarElement<HTMLElement>;
    64|   readonly snaps: Optional<SnapsConfig<E>>;
    65|   readonly onDrop: (comp: AlloyComponent, target: SugarElement<HTMLElement>) => void;
    66|   readonly repositionTarget: boolean;
    67|   readonly onDrag: (comp: AlloyComponent, target: SugarElement<HTMLElement>, delta: SugarPosition) => void;
    68|   readonly getBounds: () => Bounds;
    69|   readonly blockerClass: string;
    70|   readonly dragger: {
    71|     readonly handlers: (dragConfig: DraggingConfig<E>, dragState: DraggingState) => AlloyEvents.AlloyEventRecord;
    72|   };
    73| }
    74| export interface CommonDraggingConfigSpec<E> {
    75|   readonly useFixed?: () => boolean;
    76|   readonly onDrop?: (comp: AlloyComponent, target: SugarElement<HTMLElement>) => void;
    77|   readonly repositionTarget?: boolean;
    78|   readonly onDrag?: (comp: AlloyComponent, target: SugarElement<HTMLElement>, delta: SugarPosition) => void;
    79|   readonly getTarget?: (elem: SugarElement<HTMLElement>) => SugarElement<HTMLElement>;
    80|   readonly getBounds?: () => Bounds;
    81|   readonly snaps?: SnapsConfigSpec<E>;
    82|   readonly blockerClass: string;
    83| }
    84| export type DraggingConfigSpec<E> = MouseDraggingConfigSpec<E> | TouchDraggingConfigSpec<E> | MouseOrTouchDraggingConfigSpec<E>;
    85| export interface DragModeDeltas<E extends Event, T> {
    86|   readonly getData: (event: EventArgs<E>) => Optional<T>;
    87|   readonly getDelta: (old: T, nu: T) => T;
    88| }
    89| export interface DragStartData {
    90|   readonly width: number;
    91|   readonly height: number;
    92|   readonly bounds: Bounds;
    93| }
    94| export interface BaseDraggingState<T> extends BehaviourState {
    95|   readonly update: <E extends Event>(mode: DragModeDeltas<E, T>, dragEvent: EventArgs<E>) => Optional<T>;
    96|   readonly setStartData: (data: DragStartData) => void;
    97|   readonly getStartData: () => Optional<DragStartData>;
    98|   readonly reset: () => void;
    99| }
   100| export interface DraggingState extends BaseDraggingState<SugarPosition> { }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DataTransfers.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| import { Arr, Strings, Type } from '@ephox/katamari';
     2| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
     3| const setData = (transfer: DataTransfer, types: string[], data: string): void => {
     4|   transfer.items.clear();
     5|   Arr.each(types, (type) => {
     6|     transfer.items.add(data, type);
     7|   });
     8| };
     9| const getData = (transfer: DataTransfer, type: string): string => {
    10|   const data = transfer.getData(type);
    11|   return Type.isNull(data) ? '' : data;
    12| };
    13| const setDragImage = (transfer: DataTransfer, image: Element, x: number, y: number): void => {
    14|   transfer.setDragImage(image, x, y);
    15| };
    16| const setDropEffect = (transfer: DataTransfer, effect: DataTransfer['dropEffect']): void => {
    17|   transfer.dropEffect = effect;
    18| };
    19| const setEffectAllowed = (transfer: DataTransfer, effect: DataTransfer['effectAllowed']): void => {
    20|   transfer.effectAllowed = effect;
    21| };
    22| const getFiles = (transfer: DataTransfer): File[] => Arr.from(transfer.files);
    23| const isValidDrop = (transfer: DataTransfer): boolean => {
    24|   const effectAllowed = transfer.effectAllowed.toLowerCase();
    25|   const dropEffect = transfer.dropEffect.toLowerCase();
    26|   return effectAllowed === 'all' || effectAllowed === 'uninitialized' || Strings.contains(effectAllowed, dropEffect);
    27| };
    28| const getDataTransferFromEvent = (simulatedEvent: NativeSimulatedEvent<DragEvent>): DataTransfer => {
    29|   const rawEvent = simulatedEvent.event.raw;
    30|   return rawEvent.dataTransfer as DataTransfer;
    31| };
    32| const setDropEffectOnEvent = (simulatedEvent: NativeSimulatedEvent<DragEvent>, dropEffect: DataTransfer['dropEffect']): void => {
    33|   setDropEffect(getDataTransferFromEvent(simulatedEvent), dropEffect);
    34| };
    35| export {
    36|   setData,
    37|   getData,
    38|   setDragImage,
    39|   setDropEffect,
    40|   setEffectAllowed,
    41|   getFiles,
    42|   isValidDrop,
    43|   getDataTransferFromEvent,
    44|   setDropEffectOnEvent
    45| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DragStarting.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| import { FieldProcessor, FieldSchema } from '@ephox/boulder';
     2| import { Fun } from '@ephox/katamari';
     3| import { EventArgs, SugarBody, SugarElement, Traverse } from '@ephox/sugar';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import * as AlloyEvents from '../../api/events/AlloyEvents';
     6| import * as NativeEvents from '../../api/events/NativeEvents';
     7| import * as DomModification from '../../dom/DomModification';
     8| import * as DataTransfers from './DataTransfers';
     9| import { DragStartingConfig } from './DragnDropTypes';
    10| import { setImageClone } from './ImageClone';
    11| const dragStart = (component: AlloyComponent, target: SugarElement<Node>, config: DragStartingConfig, transfer: DataTransfer) => {
    12|   DataTransfers.setEffectAllowed(transfer, config.effectAllowed);
    13|   config.getData.each((getData) => {
    14|     const data = getData(component);
    15|     const types = [ config.type ].concat(config.phoneyTypes);
    16|     DataTransfers.setData(transfer, types, data);
    17|   });
    18|   config.getImage.each((f) => {
    19|     const image = f(component);
    20|     const parent = config.getImageParent.fold(
    21|       () => Traverse.parentElement(target).getOr(SugarBody.body()),
    22|       (f) => f(component)
    23|     );
    24|     setImageClone(transfer, image, parent);
    25|   });
    26| };
    27| const schema: FieldProcessor[] = [
    28|   FieldSchema.defaultedString('type', 'text/plain'),
    29|   FieldSchema.defaulted('phoneyTypes', []),
    30|   FieldSchema.defaultedStringEnum('effectAllowed', 'all', [ 'copy', 'move', 'link', 'all', 'copyLink', 'linkMove', 'copyMove' ]),
    31|   FieldSchema.optionFunction('getData'),
    32|   FieldSchema.optionFunction('getImageParent'),
    33|   FieldSchema.optionFunction('getImage'),
    34|   FieldSchema.defaultedFunction('canDrag', Fun.always),
    35|   FieldSchema.defaultedFunction('onDragstart', Fun.identity),
    36|   FieldSchema.defaultedFunction('onDragover', Fun.identity),
    37|   FieldSchema.defaultedFunction('onDragend', Fun.identity),
    38|   FieldSchema.customField('instance', () => {
    39|     const exhibit = () => DomModification.nu({
    40|       attributes: {
    41|         draggable: 'true'
    42|       }
    43|     });
    44|     const handlers = (config: DragStartingConfig): AlloyEvents.AlloyEventRecord => AlloyEvents.derive([
    45|       AlloyEvents.run(NativeEvents.dragover(), config.onDragover),
    46|       AlloyEvents.run(NativeEvents.dragend(), config.onDragend),
    47|       AlloyEvents.run<EventArgs<DragEvent>>(NativeEvents.dragstart(), (component, simulatedEvent) => {
    48|         const target = simulatedEvent.event.target;
    49|         const transfer: DataTransfer = DataTransfers.getDataTransferFromEvent(simulatedEvent);
    50|         if (config.canDrag(component, target)) {
    51|           dragStart(component, target, config, transfer);
    52|           config.onDragstart(component, simulatedEvent);
    53|         } else {
    54|           simulatedEvent.event.prevent();
    55|         }
    56|       })
    57|     ]);
    58|     return {
    59|       exhibit,
    60|       handlers
    61|     };
    62|   })
    63| ];
    64| export default schema;


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DragnDropTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as Behaviour from '../../api/behaviour/Behaviour';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import * as AlloyEvents from '../../api/events/AlloyEvents';
     6| import { DomDefinitionDetail } from '../../dom/DomDefinition';
     7| import { DomModification } from '../../dom/DomModification';
     8| import { EventFormat, NativeSimulatedEvent } from '../../events/SimulatedEvent';
     9| import { DropEvent } from './DropEvent';
    10| import { DragnDropImageClone } from './ImageClone';
    11| export interface DragnDropBehaviour extends Behaviour.AlloyBehaviour<DragnDropConfigSpec, DragnDropConfig> {
    12|   config: (config: DragnDropConfigSpec) => Behaviour.NamedConfiguredBehaviour<DragnDropConfigSpec, DragnDropConfig>;
    13| }
    14| export type DragnDropConfig = DragStartingConfig | DroppingConfig;
    15| export interface StartingDragndropConfigSpec {
    16|   mode: 'drag';
    17|   type?: string;
    18|   phoneyTypes?: string[];
    19|   effectAllowed?: string;
    20|   getData?: (component: AlloyComponent) => string;
    21|   getImageParent?: (component: AlloyComponent) => SugarElement<Element>;
    22|   getImage?: (component: AlloyComponent) => DragnDropImageClone;
    23|   canDrag?: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
    24|   onDragstart?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    25|   onDragover?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    26|   onDragend?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    27| }
    28| export interface DragStartingConfig {
    29|   type: string;
    30|   phoneyTypes: string[];
    31|   effectAllowed: DataTransfer['effectAllowed'];
    32|   getData: Optional<(component: AlloyComponent) => string>;
    33|   getImageParent: Optional<(component: AlloyComponent) => SugarElement<Element>>;
    34|   getImage: Optional<(component: AlloyComponent) => DragnDropImageClone>;
    35|   canDrag: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
    36|   onDragstart: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    37|   onDragover: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    38|   onDragend: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
    39|   instance: {
    40|     exhibit: (base: DomDefinitionDetail, dragInfo: DragStartingConfig) => DomModification;
    41|     handlers: (dragInfo: DragStartingConfig) => {
    42|       dragover: AlloyEvents.AlloyEventHandler<EventFormat>;
    43|       dragend: AlloyEvents.AlloyEventHandler<EventFormat>;
    44|       dragstart: AlloyEvents.AlloyEventHandler<EventFormat>;
    45|     };
    46|   };
    47| }
    48| export interface DropDragndropConfigSpec {
    49|   mode: 'drop';
    50|   type?: string;
    51|   dropEffect?: string;
    52|   onDrop?: (component: AlloyComponent, dropEvent: DropEvent) => void;
    53|   onDrag?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    54|   onDragover?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    55|   onDragenter?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    56|   onDragleave?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    57| }
    58| export interface DroppingConfig {
    59|   type: string;
    60|   dropEffect: DataTransfer['dropEffect'];
    61|   onDrop: (component: AlloyComponent, dropEvent: DropEvent) => void;
    62|   onDrag: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    63|   onDragover: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    64|   onDragenter: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    65|   onDragleave: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
    66|   instance: {
    67|     exhibit: (base: DomDefinitionDetail, dragInfo: DragStartingConfig) => DomModification;
    68|     handlers: (dragInfo: DroppingConfig) => {
    69|       dragover: AlloyEvents.AlloyEventHandler<EventFormat>;
    70|       dragleave: AlloyEvents.AlloyEventHandler<EventFormat>;
    71|       drag: AlloyEvents.AlloyEventHandler<EventFormat>;
    72|       dragenter: AlloyEvents.AlloyEventHandler<EventFormat>;
    73|       drop: AlloyEvents.AlloyEventHandler<EventFormat>;
    74|     };
    75|   };
    76| }
    77| export type DragnDropConfigSpec = StartingDragndropConfigSpec | DropDragndropConfigSpec;


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/ImageClone.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| import { Css, Insert, Remove, Replication, SugarElement } from '@ephox/sugar';
     2| import * as DataTransfers from './DataTransfers';
     3| export interface DragnDropImageClone {
     4|   readonly element: SugarElement<HTMLElement>;
     5|   readonly x: number;
     6|   readonly y: number;
     7| }
     8| const createGhostClone = (image: DragnDropImageClone): SugarElement<HTMLElement> => {
     9|   const ghost = Replication.deep(image.element);
    10|   Css.setAll(ghost, {
    11|     'position': 'absolute',
    12|     'top': '-300px',
    13|     'max-width': '175px',
    14|     'max-height': '175px',
    15|     'overflow': 'hidden'
    16|   });
    17|   return ghost;
    18| };
    19| const setDragImageFromClone = (transfer: DataTransfer, parent: SugarElement<Element>, image: DragnDropImageClone): void => {
    20|   const ghost = createGhostClone(image);
    21|   Insert.append(parent, ghost);
    22|   DataTransfers.setDragImage(transfer, ghost.dom, image.x, image.y);
    23|   setTimeout(() => {
    24|     Remove.remove(ghost);
    25|   }, 0);
    26| };
    27| const setImageClone = (transfer: DataTransfer, image: DragnDropImageClone, parent: SugarElement<Element>): void => {
    28|   setDragImageFromClone(transfer, parent, image);
    29| };
    30| export { setImageClone };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dragging/snap/Presnaps.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| import { Optional, Type } from '@ephox/katamari';
     2| import { Attribute, SugarElement, SugarPosition } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import { SnapsConfig } from '../common/DraggingTypes';
     5| const parseAttrToInt = (element: SugarElement<Element>, name: string): number => {
     6|   const value = Attribute.get(element, name);
     7|   return Type.isUndefined(value) ? NaN : parseInt(value, 10);
     8| };
     9| const get = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>): Optional<SugarPosition> => {
    10|   const element = component.element;
    11|   const x = parseAttrToInt(element, snapsInfo.leftAttr);
    12|   const y = parseAttrToInt(element, snapsInfo.topAttr);
    13|   return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(
    14|     SugarPosition(x, y)
    15|   );
    16| };
    17| const set = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>, pt: SugarPosition): void => {
    18|   const element = component.element;
    19|   Attribute.set(element, snapsInfo.leftAttr, pt.left + 'px');
    20|   Attribute.set(element, snapsInfo.topAttr, pt.top + 'px');
    21| };
    22| const clear = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>): void => {
    23|   const element = component.element;
    24|   Attribute.remove(element, snapsInfo.leftAttr);
    25|   Attribute.remove(element, snapsInfo.topAttr);
    26| };
    27| export {
    28|   get,
    29|   set,
    30|   clear
    31| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/dropdown/DropdownUtils.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-263 ---
     1| import { Arr, Fun, Future, Optional, Result } from '@ephox/katamari';
     2| import { Css, Width } from '@ephox/sugar';
     3| import * as ComponentStructure from '../alien/ComponentStructure';
     4| import { Composing } from '../api/behaviour/Composing';
     5| import { Coupling } from '../api/behaviour/Coupling';
     6| import { Focusing } from '../api/behaviour/Focusing';
     7| import { Positioning } from '../api/behaviour/Positioning';
     8| import { Receiving } from '../api/behaviour/Receiving';
     9| import { Representing } from '../api/behaviour/Representing';
    10| import { Sandboxing } from '../api/behaviour/Sandboxing';
    11| import { LazySink } from '../api/component/CommonTypes';
    12| import { AlloyComponent } from '../api/component/ComponentApi';
    13| import { SketchBehaviours } from '../api/component/SketchBehaviours';
    14| import { AlloySpec, SketchSpec } from '../api/component/SpecTypes';
    15| import { TieredData, tieredMenu as TieredMenu } from '../api/ui/TieredMenu';
    16| import * as AriaControls from '../aria/AriaControls';
    17| import * as InternalSink from '../parts/InternalSink';
    18| import { HotspotAnchorSpec } from '../positioning/mode/Anchoring';
    19| import * as Tagger from '../registry/Tagger';
    20| import * as Dismissal from '../sandbox/Dismissal';
    21| import * as Reposition from '../sandbox/Reposition';
    22| import { CommonDropdownDetail } from '../ui/types/DropdownTypes';
    23| type OnOpenSyncFunc = (sandbox: AlloyComponent) => void;
    24| type MapFetch = (tdata: Optional<TieredData>) => Optional<TieredData>;
    25| export interface SandboxExtras {
    26|   onClose?: (component: AlloyComponent, menu: AlloyComponent) => void;
    27|   onOpen?: (component: AlloyComponent, menu: AlloyComponent) => void;
    28| }
    29| export enum HighlightOnOpen { HighlightFirst, HighlightNone }
    30| const getAnchor = (
    31|   detail: CommonDropdownDetail<TieredData>,
    32|   component: AlloyComponent
    33| ): HotspotAnchorSpec => {
    34|   const hotspot = detail.getHotspot(component).getOr(component);
    35|   const type = 'hotspot';
    36|   const overrides = detail.getAnchorOverrides();
    37|   return detail.layouts.fold(
    38|     () => ({ type, hotspot, overrides }),
    39|     (layouts) => ({ type, hotspot, overrides, layouts })
    40|   );
    41| };
    42| const fetch = (
    43|   detail: CommonDropdownDetail<TieredData>,
    44|   mapFetch: MapFetch,
    45|   component: AlloyComponent
    46| ): Future<Optional<TieredData>> => {
    47|   const fetcher = detail.fetch;
    48|   return fetcher(component).map(mapFetch);
    49| };
    50| const openF = (
    51|   detail: CommonDropdownDetail<TieredData>,
    52|   mapFetch: MapFetch,
    53|   anchor: HotspotAnchorSpec,
    54|   component: AlloyComponent,
    55|   sandbox: AlloyComponent,
    56|   externals: any,
    57|   highlightOnOpen: HighlightOnOpen
    58| ): Future<Optional<SketchSpec>> => {
    59|   const futureData: Future<Optional<TieredData>> = fetch(detail, mapFetch, component);
    60|   const getLazySink = getSink(component, detail);
    61|   return futureData.map((tdata) => tdata.bind((data) => Optional.from(TieredMenu.sketch({
    62|     ...externals.menu(),
    63|     uid: Tagger.generate(''),
    64|     data,
    65|     highlightImmediately: highlightOnOpen === HighlightOnOpen.HighlightFirst,
    66|     onOpenMenu: (tmenu, menu) => {
    67|       const sink = getLazySink().getOrDie();
    68|       Positioning.position(sink, menu, { anchor });
    69|       Sandboxing.decloak(sandbox);
    70|     },
    71|     onOpenSubmenu: (tmenu, item, submenu) => {
    72|       const sink = getLazySink().getOrDie();
    73|       Positioning.position(sink, submenu, {
    74|         anchor: {
    75|           type: 'submenu',
    76|           item
    77|         }
    78|       });
    79|       Sandboxing.decloak(sandbox);
    80|     },
    81|     onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
    82|       const sink = getLazySink().getOrDie();
    83|       Positioning.position(sink, primaryMenu, { anchor });
    84|       Arr.each(submenuTriggers, (st) => {
    85|         Positioning.position(sink, st.triggeredMenu, {
    86|           anchor: { type: 'submenu', item: st.triggeringItem }
    87|         });
    88|       });
    89|     },
    90|     onEscape: () => {
    91|       Focusing.focus(component);
    92|       Sandboxing.close(sandbox);
    93|       return Optional.some(true);
    94|     }
    95|   }))));
    96| };
    97| const open = (
    98|   detail: CommonDropdownDetail<TieredData>,
    99|   mapFetch: MapFetch,
   100|   hotspot: AlloyComponent,
   101|   sandbox: AlloyComponent,
   102|   externals: any,
   103|   onOpenSync: OnOpenSyncFunc,
   104|   highlightOnOpen: HighlightOnOpen
   105| ): Future<AlloyComponent> => {
   106|   const anchor = getAnchor(detail, hotspot);
   107|   const processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
   108|   return processed.map((tdata) => {
   109|     tdata.fold(
   110|       () => {
   111|         if (Sandboxing.isOpen(sandbox)) {
   112|           Sandboxing.close(sandbox);
   113|         }
   114|       },
   115|       (data) => {
   116|         Sandboxing.cloak(sandbox);
   117|         Sandboxing.open(sandbox, data);
   118|         onOpenSync(sandbox);
   119|       }
   120|     );
   121|     return sandbox;
   122|   });
   123| };
   124| const close = (
   125|   detail: CommonDropdownDetail<TieredData>,
   126|   mapFetch: MapFetch,
   127|   component: AlloyComponent,
   128|   sandbox: AlloyComponent,
   129|   _externals: any,
   130|   _onOpenSync: OnOpenSyncFunc,
   131|   _highlightOnOpen: HighlightOnOpen
   132| ): Future<AlloyComponent> => {
   133|   Sandboxing.close(sandbox);
   134|   return Future.pure(sandbox);
   135| };
   136| const togglePopup = (
   137|   detail: CommonDropdownDetail<TieredData>,
   138|   mapFetch: MapFetch,
   139|   hotspot: AlloyComponent,
   140|   externals: any,
   141|   onOpenSync: OnOpenSyncFunc,
   142|   highlightOnOpen: HighlightOnOpen
   143| ): Future<AlloyComponent> => {
   144|   const sandbox = Coupling.getCoupled(hotspot, 'sandbox');
   145|   const showing = Sandboxing.isOpen(sandbox);
   146|   const action = showing ? close : open;
   147|   return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
   148| };
   149| const matchWidth = (hotspot: AlloyComponent, container: AlloyComponent, useMinWidth: boolean): void => {
   150|   const menu = Composing.getCurrent(container).getOr(container);
   151|   const buttonWidth = Width.get(hotspot.element);
   152|   if (useMinWidth) {
   153|     Css.set(menu.element, 'min-width', buttonWidth + 'px');
   154|   } else {
   155|     Width.set(menu.element, buttonWidth);
   156|   }
   157| };
   158| interface SinkDetail {
   159|   uid: string;
   160|   lazySink: Optional<LazySink>;
   161| }
   162| const getSink = (
   163|   anyInSystem: AlloyComponent,
   164|   sinkDetail: SinkDetail
   165| ): () => ReturnType<LazySink> =>
   166|   anyInSystem
   167|     .getSystem()
   168|     .getByUid(sinkDetail.uid + '-' + InternalSink.suffix())
   169|     .map((internalSink) => () => Result.value(internalSink))
   170|     .getOrThunk(
   171|       () => sinkDetail.lazySink.fold(
   172|         () => () => Result.error(new Error(
   173|           'No internal sink is specified, nor could an external sink be found'
   174|         )),
   175|         (lazySinkFn) => () => lazySinkFn(anyInSystem))
   176|     );
   177| const doRepositionMenus = (sandbox: AlloyComponent): void => {
   178|   Sandboxing.getState(sandbox).each((tmenu) => {
   179|     TieredMenu.repositionMenus(tmenu);
   180|   });
   181| };
   182| const makeSandbox = (
   183|   detail: CommonDropdownDetail<TieredData>,
   184|   hotspot: AlloyComponent,
   185|   extras?: SandboxExtras
   186| ): AlloySpec => {
   187|   const ariaControls = AriaControls.manager();
   188|   const onOpen = (component: AlloyComponent, menu: AlloyComponent) => {
   189|     const anchor = getAnchor(detail, hotspot);
   190|     ariaControls.link(hotspot.element);
   191|     if (detail.matchWidth) {
   192|       matchWidth(anchor.hotspot, menu, detail.useMinWidth);
   193|     }
   194|     detail.onOpen(anchor, component, menu);
   195|     if (extras !== undefined && extras.onOpen !== undefined) {
   196|       extras.onOpen(component, menu);
   197|     }
   198|   };
   199|   const onClose = (component: AlloyComponent, menu: AlloyComponent) => {
   200|     ariaControls.unlink(hotspot.element);
   201|     if (extras !== undefined && extras.onClose !== undefined) {
   202|       extras.onClose(component, menu);
   203|     }
   204|   };
   205|   const lazySink = getSink(hotspot, detail);
   206|   return {
   207|     dom: {
   208|       tag: 'div',
   209|       classes: detail.sandboxClasses,
   210|       attributes: {
   211|         id: ariaControls.id,
   212|         role: 'listbox'
   213|       }
   214|     },
   215|     behaviours: SketchBehaviours.augment(
   216|       detail.sandboxBehaviours,
   217|       [
   218|         Representing.config({
   219|           store: {
   220|             mode: 'memory',
   221|             initialValue: hotspot
   222|           }
   223|         }),
   224|         Sandboxing.config({
   225|           onOpen,
   226|           onClose,
   227|           isPartOf: (container, data, queryElem): boolean => {
   228|             return ComponentStructure.isPartOf(data, queryElem) || ComponentStructure.isPartOf(hotspot, queryElem);
   229|           },
   230|           getAttachPoint: () => {
   231|             return lazySink().getOrDie();
   232|           }
   233|         }),
   234|         Composing.config({
   235|           find: (sandbox: AlloyComponent): Optional<AlloyComponent> => {
   236|             return Sandboxing.getState(sandbox).bind((menu) => Composing.getCurrent(menu));
   237|           }
   238|         }),
   239|         Receiving.config({
   240|           channels: {
   241|             ...Dismissal.receivingChannel({
   242|               isExtraPart: Fun.never
   243|             }),
   244|             ...Reposition.receivingChannel({
   245|               doReposition: doRepositionMenus
   246|             })
   247|           }
   248|         })
   249|       ]
   250|     )
   251|   };
   252| };
   253| const repositionMenus = (comp: AlloyComponent): void => {
   254|   const sandbox = Coupling.getCoupled(comp, 'sandbox');
   255|   doRepositionMenus(sandbox);
   256| };
   257| export {
   258|   makeSandbox,
   259|   togglePopup,
   260|   open,
   261|   repositionMenus,
   262|   getSink
   263| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/DefaultEvents.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import { Compare, SugarElement } from '@ephox/sugar';
     2| import { AlloyComponent } from '../api/component/ComponentApi';
     3| import * as AlloyEvents from '../api/events/AlloyEvents';
     4| import * as SystemEvents from '../api/events/SystemEvents';
     5| import * as AlloyLogger from '../log/AlloyLogger';
     6| import { FocusingEvent } from './SimulatedEvent';
     7| const isRecursive = (component: AlloyComponent, originator: SugarElement<Node>, target: SugarElement<Node>): boolean =>
     8|   Compare.eq(originator, component.element) && !Compare.eq(originator, target);
     9| const events: AlloyEvents.AlloyEventRecord = AlloyEvents.derive([
    10|   AlloyEvents.can<FocusingEvent>(SystemEvents.focus(), (component, simulatedEvent) => {
    11|     const event = simulatedEvent.event;
    12|     const originator = event.originator;
    13|     const target = event.target;
    14|     if (isRecursive(component, originator, target)) {
    15|       console.warn(
    16|         SystemEvents.focus() + ' did not get interpreted by the desired target. ' +
    17|         '\nOriginator: ' + AlloyLogger.element(originator) +
    18|         '\nTarget: ' + AlloyLogger.element(target) +
    19|         '\nCheck the ' + SystemEvents.focus() + ' event handlers'
    20|       );
    21|       return false;
    22|     } else {
    23|       return true;
    24|     }
    25|   })
    26| ]);
    27| export {
    28|   events
    29| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/EventRegistry.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-70 ---
     1| import { Obj, Optional } from '@ephox/katamari';
     2| import { SugarElement, TransformFind } from '@ephox/sugar';
     3| import * as Tagger from '../registry/Tagger';
     4| import * as DescribedHandler from './DescribedHandler';
     5| export interface ElementAndHandler {
     6|   readonly element: SugarElement<Node>;
     7|   readonly descHandler: CurriedHandler;
     8| }
     9| export interface CurriedHandler {
    10|   readonly purpose: string;
    11|   readonly cHandler: Function;
    12| }
    13| export interface UncurriedHandler {
    14|   readonly purpose: string;
    15|   readonly handler: Function;
    16| }
    17| export interface UidAndHandler {
    18|   readonly id: string;
    19|   readonly descHandler: CurriedHandler;
    20| }
    21| export interface EventRegistry {
    22|   readonly registerId: (extraArgs: any[], id: string, events: Record<EventName, UncurriedHandler>) => void;
    23|   readonly unregisterId: (id: string) => void;
    24|   readonly filterByType: (type: string) => UidAndHandler[];
    25|   readonly find: (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
    26| }
    27| const eventHandler = (element: SugarElement<Node>, descHandler: CurriedHandler): ElementAndHandler => ({
    28|   element,
    29|   descHandler
    30| });
    31| const broadcastHandler = (id: string, handler: CurriedHandler): UidAndHandler => ({
    32|   id,
    33|   descHandler: handler
    34| });
    35| export type EventName = string;
    36| export type Uid = string;
    37| export const EventRegistry = (): EventRegistry => {
    38|   const registry: Record<EventName, Record<Uid, CurriedHandler>> = { };
    39|   const registerId = (extraArgs: any[], id: string, events: Record<EventName, UncurriedHandler>) => {
    40|     Obj.each(events, (v: UncurriedHandler, k: EventName) => {
    41|       const handlers = registry[k] !== undefined ? registry[k] : { };
    42|       handlers[id] = DescribedHandler.curryArgs(v, extraArgs);
    43|       registry[k] = handlers;
    44|     });
    45|   };
    46|   const findHandler = (handlers: Record<Uid, CurriedHandler>, elem: SugarElement<Node>): Optional<ElementAndHandler> =>
    47|     Tagger.read(elem)
    48|       .bind((id) => Obj.get(handlers, id))
    49|       .map((descHandler) => eventHandler(elem, descHandler));
    50|   const filterByType = (type: string): UidAndHandler[] =>
    51|     Obj.get(registry, type)
    52|       .map((handlers) => Obj.mapToArray(handlers, (f, id) => broadcastHandler(id, f)))
    53|       .getOr([ ]);
    54|   const find = (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>): Optional<ElementAndHandler> =>
    55|     Obj.get(registry, type)
    56|       .bind((handlers) => TransformFind.closest(target, (elem) => findHandler(handlers, elem), isAboveRoot));
    57|   const unregisterId = (id: string): void => {
    58|     Obj.each(registry, (handlersById, _eventName) => {
    59|       if (Obj.has(handlersById, id)) {
    60|         delete handlersById[id];
    61|       }
    62|     });
    63|   };
    64|   return {
    65|     registerId,
    66|     unregisterId,
    67|     filterByType,
    68|     find
    69|   };
    70| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/EventSource.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import { Cell, Obj } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { EventFormat } from './SimulatedEvent';
     4| const derive = (rawEvent: EventFormat, rawTarget: SugarElement<Node>): Cell<SugarElement<Node>> => {
     5|   const source = Obj.get(rawEvent, 'target').getOr(rawTarget);
     6|   return Cell(source);
     7| };
     8| export {
     9|   derive
    10| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/GuiEvents.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-118 ---
     1| import { Arr, Singleton } from '@ephox/katamari';
     2| import { DomEvent, EventArgs, SelectorExists, SugarElement, SugarNode } from '@ephox/sugar';
     3| import * as Keys from '../alien/Keys';
     4| import * as SystemEvents from '../api/events/SystemEvents';
     5| import * as TapEvent from './TapEvent';
     6| const isDangerous = (event: EventArgs<KeyboardEvent>): boolean => {
     7|   const keyEv = event.raw;
     8|   return keyEv.which === Keys.BACKSPACE[0] && !Arr.contains([ 'input', 'textarea' ], SugarNode.name(event.target)) && !SelectorExists.closest(event.target, '[contenteditable="true"]');
     9| };
    10| export interface GuiEventSettings {
    11|   readonly triggerEvent: (eventName: string, event: EventArgs) => boolean;
    12|   readonly stopBackspace?: boolean;
    13| }
    14| const setup = (container: SugarElement, rawSettings: GuiEventSettings): { unbind: () => void } => {
    15|   const settings: Required<GuiEventSettings> = {
    16|     stopBackspace: true,
    17|     ...rawSettings
    18|   };
    19|   const pointerEvents = [
    20|     'touchstart',
    21|     'touchmove',
    22|     'touchend',
    23|     'touchcancel',
    24|     'gesturestart',
    25|     'mousedown',
    26|     'mouseup',
    27|     'mouseover',
    28|     'mousemove',
    29|     'mouseout',
    30|     'click'
    31|   ];
    32|   const tapEvent = TapEvent.monitor(settings);
    33|   const simpleEvents = Arr.map(
    34|     pointerEvents.concat([
    35|       'selectstart',
    36|       'input',
    37|       'contextmenu',
    38|       'change',
    39|       'transitionend',
    40|       'transitioncancel',
    41|       'drag',
    42|       'dragstart',
    43|       'dragend',
    44|       'dragenter',
    45|       'dragleave',
    46|       'dragover',
    47|       'drop',
    48|       'keyup'
    49|     ]),
    50|     (type) => DomEvent.bind(container, type, (event) => {
    51|       tapEvent.fireIfReady(event, type).each((tapStopped) => {
    52|         if (tapStopped) {
    53|           event.kill();
    54|         }
    55|       });
    56|       const stopped = settings.triggerEvent(type, event);
    57|       if (stopped) {
    58|         event.kill();
    59|       }
    60|     })
    61|   );
    62|   const pasteTimeout = Singleton.value<number>();
    63|   const onPaste = DomEvent.bind(container, 'paste', (event) => {
    64|     tapEvent.fireIfReady(event, 'paste').each((tapStopped) => {
    65|       if (tapStopped) {
    66|         event.kill();
    67|       }
    68|     });
    69|     const stopped = settings.triggerEvent('paste', event);
    70|     if (stopped) {
    71|       event.kill();
    72|     }
    73|     pasteTimeout.set(setTimeout(() => {
    74|       settings.triggerEvent(SystemEvents.postPaste(), event);
    75|     }, 0));
    76|   });
    77|   const onKeydown = DomEvent.bind(container, 'keydown', (event) => {
    78|     const stopped = settings.triggerEvent('keydown', event);
    79|     if (stopped) {
    80|       event.kill();
    81|     } else if (settings.stopBackspace && isDangerous(event)) {
    82|       event.prevent();
    83|     }
    84|   });
    85|   const onFocusIn = DomEvent.bind(container, 'focusin', (event) => {
    86|     const stopped = settings.triggerEvent('focusin', event);
    87|     if (stopped) {
    88|       event.kill();
    89|     }
    90|   });
    91|   const focusoutTimeout = Singleton.value<number>();
    92|   const onFocusOut = DomEvent.bind(container, 'focusout', (event) => {
    93|     const stopped = settings.triggerEvent('focusout', event);
    94|     if (stopped) {
    95|       event.kill();
    96|     }
    97|     focusoutTimeout.set(setTimeout(() => {
    98|       settings.triggerEvent(SystemEvents.postBlur(), event);
    99|     }, 0));
   100|   });
   101|   const unbind = (): void => {
   102|     Arr.each(simpleEvents, (e) => {
   103|       e.unbind();
   104|     });
   105|     onKeydown.unbind();
   106|     onFocusIn.unbind();
   107|     onFocusOut.unbind();
   108|     onPaste.unbind();
   109|     pasteTimeout.on(clearTimeout);
   110|     focusoutTimeout.on(clearTimeout);
   111|   };
   112|   return {
   113|     unbind
   114|   };
   115| };
   116| export {
   117|   setup
   118| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/SimulatedEvent.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| import { Cell, Fun } from '@ephox/katamari';
     2| import { EventArgs, SugarElement } from '@ephox/sugar';
     3| export interface EventFormat {
     4|   readonly target: SugarElement<Node>;
     5|   readonly kill: () => void;
     6|   readonly prevent: () => void;
     7| }
     8| export interface SimulatedEvent<T extends EventFormat> {
     9|   readonly stop: () => void;
    10|   readonly cut: () => void;
    11|   readonly isStopped: () => boolean;
    12|   readonly isCut: () => boolean;
    13|   readonly event: T;
    14|   readonly getSource: () => SugarElement<Node>;
    15|   readonly setSource: (elem: SugarElement<Node>) => void;
    16| }
    17| export type NativeSimulatedEvent<T = Event> = SimulatedEvent<EventArgs<T>>;
    18| export type CustomSimulatedEvent = SimulatedEvent<CustomEvent>;
    19| export interface CustomEvent extends EventFormat {
    20|   readonly [key: string]: any;
    21| }
    22| export interface ReceivingUniversalInternalEvent {
    23|   readonly universal: true;
    24|   readonly data: any;
    25| }
    26| export interface ReceivingChannelsInternalEvent {
    27|   readonly universal: false;
    28|   readonly channels: ReadonlyArray<string>;
    29|   readonly data: any;
    30| }
    31| export type ReceivingInternalEvent = ReceivingUniversalInternalEvent | ReceivingChannelsInternalEvent;
    32| export interface ReceivingEvent extends EventFormat {
    33|   readonly data: any;
    34| }
    35| export interface FocusingEvent extends EventFormat {
    36|   readonly originator: SugarElement<Node>;
    37| }
    38| const fromSource = <T extends EventFormat>(event: T, source: Cell<SugarElement<Node>>): SimulatedEvent<T> => {
    39|   const stopper = Cell(false);
    40|   const cutter = Cell(false);
    41|   const stop = () => {
    42|     stopper.set(true);
    43|   };
    44|   const cut = () => {
    45|     cutter.set(true);
    46|   };
    47|   return {
    48|     stop,
    49|     cut,
    50|     isStopped: stopper.get,
    51|     isCut: cutter.get,
    52|     event,
    53|     setSource: source.set,
    54|     getSource: source.get
    55|   };
    56| };
    57| const fromExternal = <T extends EventFormat>(event: T): SimulatedEvent<T> => {
    58|   const stopper = Cell(false);
    59|   const stop = () => {
    60|     stopper.set(true);
    61|   };
    62|   return {
    63|     stop,
    64|     cut: Fun.noop, // cutting has no meaning for a broadcasted event
    65|     isStopped: stopper.get,
    66|     isCut: Fun.never,
    67|     event,
    68|     setSource: Fun.die('Cannot set source of a broadcasted event'),
    69|     getSource: Fun.die('Cannot get source of a broadcasted event')
    70|   };
    71| };
    72| const fromTarget = <T extends EventFormat>(event: T, target: SugarElement<Node>): SimulatedEvent<T> => {
    73|   const source = Cell(target);
    74|   return fromSource(event, source);
    75| };
    76| export {
    77|   fromSource,
    78|   fromExternal,
    79|   fromTarget
    80| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/TapEvent.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| import { Objects } from '@ephox/boulder';
     2| import { Cell, Obj, Optional, Singleton } from '@ephox/katamari';
     3| import { Compare, EventArgs, SugarElement } from '@ephox/sugar';
     4| import { DelayedFunction } from '../alien/DelayedFunction';
     5| import * as NativeEvents from '../api/events/NativeEvents';
     6| import * as SystemEvents from '../api/events/SystemEvents';
     7| import { GuiEventSettings } from './GuiEvents';
     8| type EventHandler = (event: EventArgs<Event>) => Optional<boolean>;
     9| export interface TouchHistoryData {
    10|   readonly x: number;
    11|   readonly y: number;
    12|   readonly target: SugarElement<Node>;
    13| }
    14| interface Monitor {
    15|   readonly fireIfReady: (event: EventArgs<Event>, type: string) => Optional<boolean>;
    16| }
    17| const SIGNIFICANT_MOVE = 5;
    18| const LONGPRESS_DELAY = 400;
    19| const getTouch = (event: EventArgs<TouchEvent>): Optional<Touch> => {
    20|   const raw = event.raw;
    21|   if (raw.touches === undefined || raw.touches.length !== 1) {
    22|     return Optional.none();
    23|   }
    24|   return Optional.some(raw.touches[0]);
    25| };
    26| const isFarEnough = (touch: Touch, data: TouchHistoryData): boolean => {
    27|   const distX = Math.abs(touch.clientX - data.x);
    28|   const distY = Math.abs(touch.clientY - data.y);
    29|   return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
    30| };
    31| const monitor = (settings: GuiEventSettings): Monitor => {
    32|   /* A tap event is a combination of touchstart and touchend on the same element
    33|    * without a *significant* touchmove in between.
    34|    */
    35|   const startData = Singleton.value<TouchHistoryData>();
    36|   const longpressFired = Cell<boolean>(false);
    37|   const longpress = DelayedFunction((event: EventArgs) => {
    38|     settings.triggerEvent(SystemEvents.longpress(), event);
    39|     longpressFired.set(true);
    40|   }, LONGPRESS_DELAY);
    41|   const handleTouchstart = (event: EventArgs<TouchEvent>): Optional<boolean> => {
    42|     getTouch(event).each((touch) => {
    43|       longpress.cancel();
    44|       const data = {
    45|         x: touch.clientX,
    46|         y: touch.clientY,
    47|         target: event.target
    48|       };
    49|       longpress.schedule(event);
    50|       longpressFired.set(false);
    51|       startData.set(data);
    52|     });
    53|     return Optional.none();
    54|   };
    55|   const handleTouchmove = (event: EventArgs<TouchEvent>): Optional<boolean> => {
    56|     longpress.cancel();
    57|     getTouch(event).each((touch) => {
    58|       startData.on((data) => {
    59|         if (isFarEnough(touch, data)) {
    60|           startData.clear();
    61|         }
    62|       });
    63|     });
    64|     return Optional.none();
    65|   };
    66|   const handleTouchend = (event: EventArgs): Optional<boolean> => {
    67|     longpress.cancel();
    68|     const isSame = (data: TouchHistoryData) => Compare.eq(data.target, event.target);
    69|     return startData.get().filter(isSame).map((_data) => {
    70|       if (longpressFired.get()) {
    71|         event.prevent();
    72|         return false;
    73|       } else {
    74|         return settings.triggerEvent(SystemEvents.tap(), event);
    75|       }
    76|     });
    77|   };
    78|   const handlers: Record<string, EventHandler> = Objects.wrapAll([
    79|     { key: NativeEvents.touchstart(), value: handleTouchstart },
    80|     { key: NativeEvents.touchmove(), value: handleTouchmove },
    81|     { key: NativeEvents.touchend(), value: handleTouchend }
    82|   ] as Array<{ key: string; value: EventHandler }>);
    83|   const fireIfReady = (event: EventArgs<Event>, type: string): Optional<boolean> =>
    84|     Obj.get(handlers, type).bind((handler) => handler(event));
    85|   return {
    86|     fireIfReady
    87|   };
    88| };
    89| export {
    90|   monitor
    91| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/events/Triggers.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-88 ---
     1| import { Adt, Arr, Cell, Fun, Optional } from '@ephox/katamari';
     2| import { SugarElement, Traverse } from '@ephox/sugar';
     3| import { DebuggerLogger } from '../debugging/Debugging';
     4| import * as DescribedHandler from './DescribedHandler';
     5| import { ElementAndHandler, UidAndHandler } from './EventRegistry';
     6| import * as EventSource from './EventSource';
     7| import { EventFormat, fromExternal, fromSource } from './SimulatedEvent';
     8| type LookupEvent = (eventName: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
     9| export interface TriggerAdt {
    10|   fold: <T>(
    11|     stopped: () => T,
    12|     resume: (elem: SugarElement<Node & ParentNode>) => T,
    13|     complete: () => T
    14|   ) => T;
    15|   match: <T> (branches: {
    16|     stopped: () => T;
    17|     resume: (elem: SugarElement<Node & ParentNode>) => T;
    18|     complete: () => T;
    19|   }) => T;
    20|   log: (label: string) => void;
    21| }
    22| const adt: {
    23|   stopped: () => TriggerAdt;
    24|   resume: (elem: SugarElement<Node & ParentNode>) => TriggerAdt;
    25|   complete: () => TriggerAdt;
    26| } = Adt.generate([
    27|   { stopped: [ ] },
    28|   { resume: [ 'element' ] },
    29|   { complete: [ ] }
    30| ]);
    31| const doTriggerHandler = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, target: SugarElement<Node>, source: Cell<SugarElement<Node>>, logger: DebuggerLogger): TriggerAdt => {
    32|   const handler = lookup(eventType, target);
    33|   const simulatedEvent = fromSource(rawEvent, source);
    34|   return handler.fold(() => {
    35|     logger.logEventNoHandlers(eventType, target);
    36|     return adt.complete();
    37|   }, (handlerInfo) => {
    38|     const descHandler = handlerInfo.descHandler;
    39|     const eventHandler = DescribedHandler.getCurried(descHandler);
    40|     eventHandler(simulatedEvent);
    41|     if (simulatedEvent.isStopped()) {
    42|       logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
    43|       return adt.stopped();
    44|     } else if (simulatedEvent.isCut()) {
    45|       logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
    46|       return adt.complete();
    47|     } else {
    48|       return Traverse.parent(handlerInfo.element).fold(() => {
    49|         logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
    50|         return adt.complete();
    51|       }, (parent) => {
    52|         logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
    53|         return adt.resume(parent);
    54|       });
    55|     }
    56|   });
    57| };
    58| const doTriggerOnUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, rawTarget: SugarElement<Node>, source: Cell<SugarElement<Node>>, logger: DebuggerLogger): boolean =>
    59|   doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(
    60|     Fun.always,
    61|     (parent) => doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger),
    62|     Fun.never
    63|   );
    64| const triggerHandler = <T extends EventFormat>(lookup: LookupEvent, eventType: string, rawEvent: T, target: SugarElement<Node>, logger: DebuggerLogger): TriggerAdt => {
    65|   const source = EventSource.derive(rawEvent, target);
    66|   return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
    67| };
    68| const broadcast = (listeners: UidAndHandler[], rawEvent: EventFormat, _logger?: DebuggerLogger): boolean => {
    69|   const simulatedEvent = fromExternal(rawEvent);
    70|   Arr.each(listeners, (listener) => {
    71|     const descHandler = listener.descHandler;
    72|     const handler = DescribedHandler.getCurried(descHandler);
    73|     handler(simulatedEvent);
    74|   });
    75|   return simulatedEvent.isStopped();
    76| };
    77| const triggerUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, logger: DebuggerLogger): boolean =>
    78|   triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);
    79| const triggerOnUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, rawTarget: SugarElement<Node>, logger: DebuggerLogger): boolean => {
    80|   const source = EventSource.derive(rawEvent, rawTarget);
    81|   return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
    82| };
    83| export {
    84|   triggerHandler,
    85|   triggerUntilStopped,
    86|   triggerOnUntilStopped,
    87|   broadcast
    88| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/foreign/ForeignCache.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| import { Obj } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as DomState from '../alien/DomState';
     4| import { Dragging } from '../api/behaviour/Dragging';
     5| import { Pinching } from '../api/behaviour/Pinching';
     6| import { Toggling } from '../api/behaviour/Toggling';
     7| import * as CompBehaviours from '../api/component/CompBehaviours';
     8| import { DispatchedAlloyConfig } from '../api/system/ForeignGui';
     9| import * as BehaviourBlob from '../behaviour/common/BehaviourBlob';
    10| import * as ComponentEvents from '../construct/ComponentEvents';
    11| import { UncurriedHandler } from '../events/EventRegistry';
    12| interface Events {
    13|   readonly elem: SugarElement<Node>;
    14|   readonly evts: Record<string, UncurriedHandler>;
    15| }
    16| export interface ForeignCache {
    17|   readonly getEvents: (elem: SugarElement<Node>, spec: DispatchedAlloyConfig) => Events;
    18| }
    19| export default (): ForeignCache => {
    20|   const getEvents = (elem: SugarElement<Node>, spec: DispatchedAlloyConfig): Events => {
    21|     const evts = DomState.getOrCreate(elem, () => {
    22|       const info = {
    23|         events: Obj.hasNonNullableKey(spec, 'events') ? spec.events : { },
    24|         eventOrder: Obj.hasNonNullableKey(spec, 'eventOrder') ? spec.eventOrder : { }
    25|       };
    26|       const bInfo = CompBehaviours.generateFrom(spec, [ Toggling, Dragging, Pinching ]);
    27|       const baseEvents = {
    28|         'alloy.base.behaviour': info.events
    29|       };
    30|       const bData = BehaviourBlob.getData(bInfo);
    31|       return ComponentEvents.combine(bData, info.eventOrder, [ Toggling, Dragging, Pinching ], baseEvents).getOrDie();
    32|     });
    33|     return {
    34|       elem,
    35|       evts
    36|     };
    37|   };
    38|   return {
    39|     getEvents
    40|   };
    41| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/frame/Frames.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { Navigation } from './Navigation';
     4| const walkUp = (navigation: Navigation, doc: SugarElement<Document>): SugarElement<Element>[] => {
     5|   const frame = navigation.view(doc);
     6|   return frame.fold(Fun.constant([]), (f) => {
     7|     const parent = navigation.owner(f);
     8|     const rest = walkUp(navigation, parent);
     9|     return [ f ].concat(rest);
    10|   });
    11| };
    12| const pathTo = (element: SugarElement<Node>, navigation: Navigation): Optional<SugarElement<Element>[]> => {
    13|   const d = navigation.owner(element);
    14|   const paths = walkUp(navigation, d);
    15|   return Optional.some(paths);
    16| };
    17| export {
    18|   pathTo
    19| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/frame/OuterPosition.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| import { Arr, Fun } from '@ephox/katamari';
     2| import { Scroll, SugarDocument, SugarElement, SugarLocation, SugarPosition } from '@ephox/sugar';
     3| import * as Frames from './Frames';
     4| import * as Navigation from './Navigation';
     5| const find = (element: SugarElement<Element>): SugarPosition => {
     6|   const doc = SugarDocument.getDocument();
     7|   const scroll = Scroll.get(doc);
     8|   const path = Frames.pathTo(element, Navigation);
     9|   return path.fold(Fun.curry(SugarLocation.absolute, element), (frames) => {
    10|     const offset = SugarLocation.viewport(element);
    11|     const r = Arr.foldr(frames, (b, a) => {
    12|       const loc = SugarLocation.viewport(a);
    13|       return {
    14|         left: b.left + loc.left,
    15|         top: b.top + loc.top
    16|       };
    17|     }, { left: 0, top: 0 });
    18|     return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
    19|   });
    20| };
    21| export {
    22|   find
    23| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/FlatgridType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Fun, Optional } from '@ephox/katamari';
     3| import { SelectorFind, SugarElement } from '@ephox/sugar';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import * as KeyingState from '../behaviour/keyboard/KeyingState';
     7| import * as Fields from '../data/Fields';
     8| import { NativeSimulatedEvent } from '../events/SimulatedEvent';
     9| import * as DomMovement from '../navigation/DomMovement';
    10| import * as DomPinpoint from '../navigation/DomPinpoint';
    11| import * as KeyMatch from '../navigation/KeyMatch';
    12| import * as KeyRules from '../navigation/KeyRules';
    13| import * as WrapArrNavigation from '../navigation/WrapArrNavigation';
    14| import { FlatgridConfig, FlatgridState, KeyRuleHandler } from './KeyingModeTypes';
    15| import * as KeyingType from './KeyingType';
    16| import * as KeyingTypes from './KeyingTypes';
    17| const schema = [
    18|   FieldSchema.required('selector'),
    19|   FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
    20|   Fields.onKeyboardHandler('onEscape'),
    21|   FieldSchema.defaulted('captureTab', false),
    22|   Fields.initSize()
    23| ];
    24| const focusIn = (component: AlloyComponent, gridConfig: FlatgridConfig, _gridState: FlatgridState): void => {
    25|   SelectorFind.descendant<HTMLElement>(component.element, gridConfig.selector).each((first) => {
    26|     gridConfig.focusManager.set(component, first);
    27|   });
    28| };
    29| const findCurrent = (component: AlloyComponent, gridConfig: FlatgridConfig): Optional<SugarElement<HTMLElement>> =>
    30|   gridConfig.focusManager.get(component).bind((elem) => SelectorFind.closest(elem, gridConfig.selector));
    31| const execute = (
    32|   component: AlloyComponent,
    33|   simulatedEvent: NativeSimulatedEvent,
    34|   gridConfig: FlatgridConfig,
    35|   _gridState: FlatgridState
    36| ): Optional<boolean> =>
    37|   findCurrent(component, gridConfig)
    38|     .bind((focused) => gridConfig.execute(component, simulatedEvent, focused));
    39| const doMove = (
    40|   cycle: WrapArrNavigation.ArrNavigationFunc<SugarElement<HTMLElement>>
    41| ): DomMovement.ElementMover<FlatgridConfig, FlatgridState> =>
    42|   (element, focused, gridConfig, gridState) =>
    43|     DomPinpoint.locateVisible(element, focused, gridConfig.selector)
    44|       .bind((identified) => cycle(
    45|         identified.candidates,
    46|         identified.index,
    47|         gridState.getNumRows().getOr(gridConfig.initSize.numRows),
    48|         gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)
    49|       ));
    50| const handleTab: KeyRuleHandler<FlatgridConfig, FlatgridState> = (_component, _simulatedEvent, gridConfig) =>
    51|   gridConfig.captureTab ? Optional.some<boolean>(true) : Optional.none();
    52| const doEscape: KeyRuleHandler<FlatgridConfig, FlatgridState> = (component, simulatedEvent, gridConfig) =>
    53|   gridConfig.onEscape(component, simulatedEvent);
    54| const moveLeft = doMove(WrapArrNavigation.cycleLeft);
    55| const moveRight = doMove(WrapArrNavigation.cycleRight);
    56| const moveNorth = doMove(WrapArrNavigation.cycleUp);
    57| const moveSouth = doMove(WrapArrNavigation.cycleDown);
    58| const getKeydownRules: () => Array<KeyRules.KeyRule<FlatgridConfig, FlatgridState>> = Fun.constant([
    59|   KeyRules.rule(KeyMatch.inSet(Keys.LEFT), DomMovement.west<FlatgridConfig, FlatgridState>(moveLeft, moveRight)),
    60|   KeyRules.rule(KeyMatch.inSet(Keys.RIGHT), DomMovement.east(moveLeft, moveRight)),
    61|   KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.north(moveNorth)),
    62|   KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.south(moveSouth)),
    63|   KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), handleTab),
    64|   KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.TAB) ]), handleTab),
    65|   KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), doEscape),
    66|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE.concat(Keys.ENTER)), execute)
    67| ]);
    68| const getKeyupRules: () => Array<KeyRules.KeyRule<FlatgridConfig, FlatgridState>> = Fun.constant([
    69|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
    70| ]);
    71| export default KeyingType.typical(
    72|   schema,
    73|   KeyingState.flatgrid,
    74|   getKeydownRules,
    75|   getKeyupRules,
    76|   () => Optional.some(focusIn)
    77| );


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/FlowType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-68 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Fun, Optional } from '@ephox/katamari';
     3| import { SelectorFind, SugarElement } from '@ephox/sugar';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import { NoState, Stateless } from '../behaviour/common/BehaviourState';
     7| import * as Fields from '../data/Fields';
     8| import { NativeSimulatedEvent } from '../events/SimulatedEvent';
     9| import * as DomMovement from '../navigation/DomMovement';
    10| import * as DomNavigation from '../navigation/DomNavigation';
    11| import * as KeyMatch from '../navigation/KeyMatch';
    12| import * as KeyRules from '../navigation/KeyRules';
    13| import { FlowConfig, KeyRuleHandler } from './KeyingModeTypes';
    14| import * as KeyingType from './KeyingType';
    15| import * as KeyingTypes from './KeyingTypes';
    16| const schema = [
    17|   FieldSchema.required('selector'),
    18|   FieldSchema.defaulted('getInitial', Optional.none),
    19|   FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
    20|   Fields.onKeyboardHandler('onEscape'),
    21|   FieldSchema.defaulted('executeOnMove', false),
    22|   FieldSchema.defaulted('allowVertical', true)
    23| ];
    24| const findCurrent = (component: AlloyComponent, flowConfig: FlowConfig): Optional<SugarElement<HTMLElement>> =>
    25|   flowConfig.focusManager.get(component).bind((elem) => SelectorFind.closest(elem, flowConfig.selector));
    26| const execute = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent, flowConfig: FlowConfig): Optional<boolean> =>
    27|   findCurrent(component, flowConfig).bind((focused) => flowConfig.execute(component, simulatedEvent, focused));
    28| const focusIn = (component: AlloyComponent, flowConfig: FlowConfig, _state: Stateless): void => {
    29|   flowConfig.getInitial(component).orThunk(
    30|     () => SelectorFind.descendant<HTMLElement>(component.element, flowConfig.selector)
    31|   ).each((first) => {
    32|     flowConfig.focusManager.set(component, first);
    33|   });
    34| };
    35| const moveLeft = (element: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, info: FlowConfig): Optional<SugarElement<HTMLElement>> =>
    36|   DomNavigation.horizontal(element, info.selector, focused, -1);
    37| const moveRight = (element: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, info: FlowConfig): Optional<SugarElement<HTMLElement>> =>
    38|   DomNavigation.horizontal(element, info.selector, focused, +1);
    39| const doMove = (movement: KeyRuleHandler<FlowConfig, Stateless>): KeyRuleHandler<FlowConfig, Stateless> =>
    40|   (component, simulatedEvent, flowConfig, flowState) =>
    41|     movement(component, simulatedEvent, flowConfig, flowState).bind(
    42|       () =>
    43|         flowConfig.executeOnMove ?
    44|           execute(component, simulatedEvent, flowConfig) :
    45|           Optional.some<boolean>(true)
    46|     );
    47| const doEscape: KeyRuleHandler<FlowConfig, Stateless> = (component, simulatedEvent, flowConfig) =>
    48|   flowConfig.onEscape(component, simulatedEvent);
    49| const getKeydownRules = (
    50|   _component: AlloyComponent,
    51|   _se: NativeSimulatedEvent,
    52|   flowConfig: FlowConfig,
    53|   _flowState: Stateless
    54| ): Array<KeyRules.KeyRule<FlowConfig, Stateless>> => {
    55|   const westMovers = Keys.LEFT.concat(flowConfig.allowVertical ? Keys.UP : [ ]);
    56|   const eastMovers = Keys.RIGHT.concat(flowConfig.allowVertical ? Keys.DOWN : [ ]);
    57|   return [
    58|     KeyRules.rule(KeyMatch.inSet(westMovers), doMove(DomMovement.west(moveLeft, moveRight))),
    59|     KeyRules.rule(KeyMatch.inSet(eastMovers), doMove(DomMovement.east(moveLeft, moveRight))),
    60|     KeyRules.rule(KeyMatch.inSet(Keys.ENTER), execute),
    61|     KeyRules.rule(KeyMatch.inSet(Keys.SPACE), execute),
    62|     KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), doEscape)
    63|   ];
    64| };
    65| const getKeyupRules: () => Array<KeyRules.KeyRule<FlowConfig, Stateless>> = Fun.constant([
    66|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
    67| ]);
    68| export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/KeyingModeTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-180 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { EventArgs, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import * as AlloyEvents from '../api/events/AlloyEvents';
     5| import { FocusManager } from '../api/focus/FocusManagers';
     6| import { BehaviourState, Stateless } from '../behaviour/common/BehaviourState';
     7| import { NativeSimulatedEvent, SimulatedEvent } from '../events/SimulatedEvent';
     8| export type KeyHandlerApi = (comp: AlloyComponent, se: NativeSimulatedEvent<KeyboardEvent>) => Optional<boolean>;
     9| export type KeyRuleHandler<C, S> = (comp: AlloyComponent, se: NativeSimulatedEvent<KeyboardEvent>, config: C, state: S) => Optional<boolean>;
    10| export enum FocusInsideModes {
    11|   OnFocusMode = 'onFocus',
    12|   OnEnterOrSpaceMode = 'onEnterOrSpace',
    13|   OnApiMode = 'onApi'
    14| }
    15| export interface GeneralKeyingConfigSpec {
    16|   focusManager?: FocusManager;
    17|   focusInside?: FocusInsideModes;
    18| }
    19| export interface GeneralKeyingConfig {
    20|   focusManager: FocusManager;
    21|   sendFocusIn: <C extends GeneralKeyingConfig, S>(conf: C) => Optional<(comp: AlloyComponent, config: C, state: S, evt?: SimulatedEvent<EventArgs>) => void>;
    22|   focusInside: FocusInsideModes;
    23|   handler: {
    24|     toEvents: <C extends GeneralKeyingConfig, S>(keyingConfig: C, keyingState: S) => AlloyEvents.AlloyEventRecord;
    25|   };
    26|   state: <C extends GeneralKeyingConfig>(spec: C) => Stateless | FlatgridState;
    27| }
    28| export interface TabbingConfigSpec extends GeneralKeyingConfigSpec {
    29|   onEscape?: KeyHandlerApi;
    30|   onEnter?: KeyHandlerApi;
    31|   selector?: string;
    32|   firstTabstop?: number;
    33|   useTabstopAt?: (elem: SugarElement<HTMLElement>) => boolean;
    34|   visibilitySelector?: string;
    35| }
    36| export interface TabbingConfig extends GeneralKeyingConfig {
    37|   onEscape: Optional<KeyHandlerApi>;
    38|   onEnter: Optional<KeyHandlerApi>;
    39|   selector: string;
    40|   firstTabstop: number;
    41|   useTabstopAt: (elem: SugarElement<HTMLElement>) => boolean;
    42|   visibilitySelector: Optional<string>;
    43|   cyclic: boolean;
    44| }
    45| export interface AcylicConfigSpec extends TabbingConfigSpec {
    46|   mode: 'acyclic';
    47| }
    48| export interface CyclicConfigSpec extends TabbingConfigSpec {
    49|   mode: 'cyclic';
    50| }
    51| export interface AcyclicConfig extends TabbingConfig {
    52|   cyclic: false;
    53| }
    54| export interface CyclicConfig extends TabbingConfig {
    55|   cyclic: true;
    56| }
    57| export interface EscapingConfigSpec extends GeneralKeyingConfigSpec {
    58|   mode: 'escaping';
    59|   onEscape: KeyHandlerApi;
    60| }
    61| export interface EscapingConfig extends GeneralKeyingConfig {
    62|   onEscape: KeyHandlerApi;
    63| }
    64| export interface ExecutingConfigSpec extends GeneralKeyingConfigSpec {
    65|   mode: 'execution';
    66|   execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
    67|   useSpace?: boolean;
    68|   useEnter?: boolean;
    69|   useControlEnter?: boolean;
    70|   useDown?: boolean;
    71| }
    72| export interface ExecutingConfig extends GeneralKeyingConfig {
    73|   execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
    74|   useSpace: boolean;
    75|   useEnter: boolean;
    76|   useControlEnter: boolean;
    77|   useDown: boolean;
    78| }
    79| export interface FlatgridConfigSpec extends GeneralKeyingConfigSpec {
    80|   mode: 'flatgrid';
    81|   selector: string;
    82|   execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
    83|   onEscape?: KeyHandlerApi;
    84|   captureTab?: boolean;
    85|   initSize: {
    86|     numColumns: number;
    87|     numRows: number;
    88|   };
    89| }
    90| export interface FlatgridConfig extends GeneralKeyingConfig {
    91|   selector: string;
    92|   execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
    93|   onEscape: KeyHandlerApi;
    94|   captureTab: boolean;
    95|   initSize: {
    96|     numColumns: number;
    97|     numRows: number;
    98|   };
    99| }
   100| export interface FlatgridState extends BehaviourState {
   101|   getNumRows: () => Optional<number>;
   102|   getNumColumns: () => Optional<number>;
   103|   setGridSize: (numRows: number, numColumns: number) => void;
   104| }
   105| export interface FlowConfigSpec extends GeneralKeyingConfigSpec {
   106|   mode: 'flow';
   107|   selector: string;
   108|   getInitial?: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
   109|   onEscape?: KeyHandlerApi;
   110|   execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   111|   executeOnMove?: boolean;
   112|   allowVertical?: boolean;
   113| }
   114| export interface FlowConfig extends GeneralKeyingConfig {
   115|   selector: string;
   116|   getInitial: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
   117|   onEscape: KeyHandlerApi;
   118|   execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   119|   executeOnMove: boolean;
   120|   allowVertical: boolean;
   121| }
   122| export interface MatrixConfigSpec extends GeneralKeyingConfigSpec {
   123|   mode: 'matrix';
   124|   selectors: {
   125|     row: string;
   126|     cell: string;
   127|   };
   128|   cycles?: boolean;
   129|   previousSelector?: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
   130|   execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   131| }
   132| export interface MatrixConfig extends GeneralKeyingConfig {
   133|   selectors: {
   134|     row: string;
   135|     cell: string;
   136|   };
   137|   cycles: boolean;
   138|   previousSelector: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
   139|   execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   140| }
   141| export interface MenuConfigSpec extends GeneralKeyingConfigSpec {
   142|   mode: 'menu';
   143|   selector: string;
   144|   execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   145|   moveOnTab?: boolean;
   146| }
   147| export interface MenuConfig extends GeneralKeyingConfig {
   148|   selector: string;
   149|   execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
   150|   moveOnTab: boolean;
   151| }
   152| export interface SpecialConfigSpec extends GeneralKeyingConfigSpec {
   153|   mode: 'special';
   154|   onSpace?: KeyHandlerApi;
   155|   onEnter?: KeyHandlerApi;
   156|   onShiftEnter?: KeyHandlerApi;
   157|   onLeft?: KeyHandlerApi;
   158|   onRight?: KeyHandlerApi;
   159|   onTab?: KeyHandlerApi;
   160|   onShiftTab?: KeyHandlerApi;
   161|   onUp?: KeyHandlerApi;
   162|   onDown?: KeyHandlerApi;
   163|   onEscape?: KeyHandlerApi;
   164|   stopSpaceKeyup?: boolean;
   165|   focusIn?: (comp: AlloyComponent, info: SpecialConfig, state: Stateless) => void;
   166| }
   167| export interface SpecialConfig extends GeneralKeyingConfig {
   168|   onSpace: KeyHandlerApi;
   169|   onEnter: KeyHandlerApi;
   170|   onShiftEnter: KeyHandlerApi;
   171|   onLeft: KeyHandlerApi;
   172|   onRight: KeyHandlerApi;
   173|   onTab: KeyHandlerApi;
   174|   onShiftTab: KeyHandlerApi;
   175|   onUp: KeyHandlerApi;
   176|   onDown: KeyHandlerApi;
   177|   onEscape: KeyHandlerApi;
   178|   stopSpaceKeyup: boolean;
   179|   focusIn: Optional<(comp: AlloyComponent, info: SpecialConfig, state: Stateless) => void>;
   180| }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/KeyingType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-87 ---
     1| import { FieldProcessor, FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Arr, Optional, Result } from '@ephox/katamari';
     3| import { EventArgs } from '@ephox/sugar';
     4| import * as EventRoot from '../alien/EventRoot';
     5| import * as Keys from '../alien/Keys';
     6| import { AlloyComponent } from '../api/component/ComponentApi';
     7| import * as AlloyEvents from '../api/events/AlloyEvents';
     8| import * as NativeEvents from '../api/events/NativeEvents';
     9| import * as SystemEvents from '../api/events/SystemEvents';
    10| import * as FocusManagers from '../api/focus/FocusManagers';
    11| import { BehaviourState } from '../behaviour/common/BehaviourState';
    12| import * as Fields from '../data/Fields';
    13| import { EventFormat, NativeSimulatedEvent, SimulatedEvent } from '../events/SimulatedEvent';
    14| import { inSet } from '../navigation/KeyMatch';
    15| import * as KeyRules from '../navigation/KeyRules';
    16| import { FocusInsideModes, GeneralKeyingConfig } from './KeyingModeTypes';
    17| type GetRulesFunc<C extends GeneralKeyingConfig, S extends BehaviourState> = (component: AlloyComponent, simulatedEvent: SimulatedEvent<EventArgs>, keyingConfig: C, keyingState: S) => Array<KeyRules.KeyRule<C, S>>;
    18| export interface KeyingType <C extends GeneralKeyingConfig, S extends BehaviourState> {
    19|   readonly schema: () => FieldProcessor[];
    20|   readonly processKey: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>, getRules: GetRulesFunc<C, S>, keyingConfig: C, keyingState: S) => Optional<boolean>;
    21|   readonly toEvents: (keyingConfig: C, keyingState: S) => AlloyEvents.AlloyEventRecord;
    22| }
    23| const typical = <C extends GeneralKeyingConfig, S extends BehaviourState>(
    24|   infoSchema: FieldProcessor[],
    25|   stateInit: (config: C) => BehaviourState,
    26|   getKeydownRules: (comp: AlloyComponent, se: NativeSimulatedEvent, config: C, state: S) => Array<KeyRules.KeyRule<C, S>>,
    27|   getKeyupRules: (comp: AlloyComponent, se: NativeSimulatedEvent, config: C, state: S) => Array<KeyRules.KeyRule<C, S>>,
    28|   optFocusIn: (config: C) => Optional<(comp: AlloyComponent, config: C, state: S) => void>): KeyingType<C, S> => {
    29|   const schema = () => infoSchema.concat([
    30|     FieldSchema.defaulted('focusManager', FocusManagers.dom()),
    31|     FieldSchema.defaultedOf('focusInside', 'onFocus', StructureSchema.valueOf((val) => Arr.contains([ 'onFocus', 'onEnterOrSpace', 'onApi' ], val) ? Result.value(val) : Result.error('Invalid value for focusInside'))),
    32|     Fields.output('handler', me),
    33|     Fields.output('state', stateInit),
    34|     Fields.output('sendFocusIn', optFocusIn)
    35|   ]);
    36|   const processKey = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>, getRules: GetRulesFunc<C, S>, keyingConfig: C, keyingState: S): Optional<boolean> => {
    37|     const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
    38|     return KeyRules.choose(rules, simulatedEvent.event).bind((rule) => rule(component, simulatedEvent, keyingConfig, keyingState));
    39|   };
    40|   const toEvents = (keyingConfig: C, keyingState: S): AlloyEvents.AlloyEventRecord => {
    41|     const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode
    42|       ? Optional.none<AlloyEvents.AlloyEventKeyAndHandler<EventFormat>>()
    43|       : optFocusIn(keyingConfig).map((focusIn) =>
    44|         AlloyEvents.run<EventArgs<FocusEvent>>(SystemEvents.focus(), (component, simulatedEvent) => {
    45|           focusIn(component, keyingConfig, keyingState);
    46|           simulatedEvent.stop();
    47|         }));
    48|     const tryGoInsideComponent = (component: AlloyComponent, simulatedEvent: SimulatedEvent<EventArgs<KeyboardEvent>>) => {
    49|       const isEnterOrSpace = inSet(Keys.SPACE.concat(Keys.ENTER))(simulatedEvent.event);
    50|       if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && EventRoot.isSource(component, simulatedEvent)) {
    51|         optFocusIn(keyingConfig).each((focusIn) => {
    52|           focusIn(component, keyingConfig, keyingState);
    53|           simulatedEvent.stop();
    54|         });
    55|       }
    56|     };
    57|     const keyboardEvents = [
    58|       AlloyEvents.run<EventArgs<KeyboardEvent>>(NativeEvents.keydown(), (component, simulatedEvent) => {
    59|         processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(
    60|           () => {
    61|             tryGoInsideComponent(component, simulatedEvent);
    62|           },
    63|           (_) => {
    64|             simulatedEvent.stop();
    65|           }
    66|         );
    67|       }),
    68|       AlloyEvents.run<EventArgs<KeyboardEvent>>(NativeEvents.keyup(), (component, simulatedEvent) => {
    69|         processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each((_) => {
    70|           simulatedEvent.stop();
    71|         });
    72|       })
    73|     ];
    74|     return AlloyEvents.derive(
    75|       onFocusHandler.toArray().concat(keyboardEvents as Array<AlloyEvents.AlloyEventKeyAndHandler<EventArgs>>)
    76|     );
    77|   };
    78|   const me = {
    79|     schema,
    80|     processKey,
    81|     toEvents
    82|   };
    83|   return me;
    84| };
    85| export {
    86|   typical
    87| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/KeyingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import * as EditableFields from '../alien/EditableFields';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import * as AlloyTriggers from '../api/events/AlloyTriggers';
     7| import * as SystemEvents from '../api/events/SystemEvents';
     8| import { NativeSimulatedEvent } from '../events/SimulatedEvent';
     9| import * as KeyMatch from '../navigation/KeyMatch';
    10| import { GeneralKeyingConfig, KeyRuleHandler } from './KeyingModeTypes';
    11| const doDefaultExecute = (
    12|   component: AlloyComponent,
    13|   _simulatedEvent: NativeSimulatedEvent<KeyboardEvent>,
    14|   focused: SugarElement<HTMLElement>
    15| ): Optional<boolean> => {
    16|   AlloyTriggers.dispatch(component, focused, SystemEvents.execute());
    17|   return Optional.some(true);
    18| };
    19| const defaultExecute = (
    20|   component: AlloyComponent,
    21|   simulatedEvent: NativeSimulatedEvent<KeyboardEvent>,
    22|   focused: SugarElement<HTMLElement>
    23| ): Optional<boolean> => {
    24|   const isComplex = EditableFields.inside(focused) && KeyMatch.inSet(Keys.SPACE)(simulatedEvent.event);
    25|   return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
    26| };
    27| const stopEventForFirefox: KeyRuleHandler<GeneralKeyingConfig, any> = (
    28|   _component: AlloyComponent,
    29|   _simulatedEvent: NativeSimulatedEvent<KeyboardEvent>
    30| ) => Optional.some<boolean>(true);
    31| export {
    32|   defaultExecute,
    33|   stopEventForFirefox
    34| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/MatrixType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Arr, Fun, Optional } from '@ephox/katamari';
     3| import { Focus, SelectorFilter, SelectorFind, SugarElement } from '@ephox/sugar';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import { NoState, Stateless } from '../behaviour/common/BehaviourState';
     7| import * as DomMovement from '../navigation/DomMovement';
     8| import * as DomPinpoint from '../navigation/DomPinpoint';
     9| import * as KeyMatch from '../navigation/KeyMatch';
    10| import * as KeyRules from '../navigation/KeyRules';
    11| import * as MatrixNavigation from '../navigation/MatrixNavigation';
    12| import { KeyRuleHandler, MatrixConfig } from './KeyingModeTypes';
    13| import * as KeyingType from './KeyingType';
    14| import * as KeyingTypes from './KeyingTypes';
    15| const schema = [
    16|   FieldSchema.requiredObjOf('selectors', [
    17|     FieldSchema.required('row'),
    18|     FieldSchema.required('cell')
    19|   ]),
    20|   FieldSchema.defaulted('cycles', true),
    21|   FieldSchema.defaulted('previousSelector', Optional.none),
    22|   FieldSchema.defaulted('execute', KeyingTypes.defaultExecute)
    23| ];
    24| const focusIn = (component: AlloyComponent, matrixConfig: MatrixConfig, _state: Stateless): void => {
    25|   const focused = matrixConfig.previousSelector(component).orThunk(() => {
    26|     const selectors = matrixConfig.selectors;
    27|     return SelectorFind.descendant<HTMLElement>(component.element, selectors.cell);
    28|   });
    29|   focused.each((cell) => {
    30|     matrixConfig.focusManager.set(component, cell);
    31|   });
    32| };
    33| const execute: KeyRuleHandler<MatrixConfig, Stateless> = (component, simulatedEvent, matrixConfig) => Focus.search(component.element).bind((focused) => matrixConfig.execute(component, simulatedEvent, focused));
    34| const toMatrix = (rows: SugarElement<HTMLElement>[], matrixConfig: MatrixConfig): SugarElement<HTMLElement>[][] =>
    35|   Arr.map(rows, (row) => SelectorFilter.descendants(row, matrixConfig.selectors.cell));
    36| const doMove = (ifCycle: MatrixNavigation.MatrixNavigationFunc<SugarElement<HTMLElement>>, ifMove: MatrixNavigation.MatrixNavigationFunc<SugarElement<HTMLElement>>): DomMovement.ElementMover<MatrixConfig, Stateless> => (element, focused, matrixConfig) => {
    37|   const move = matrixConfig.cycles ? ifCycle : ifMove;
    38|   return SelectorFind.closest(focused, matrixConfig.selectors.row).bind((inRow) => {
    39|     const cellsInRow = SelectorFilter.descendants(inRow, matrixConfig.selectors.cell);
    40|     return DomPinpoint.findIndex(cellsInRow, focused).bind((colIndex) => {
    41|       const allRows = SelectorFilter.descendants<HTMLElement>(element, matrixConfig.selectors.row);
    42|       return DomPinpoint.findIndex(allRows, inRow).bind((rowIndex) => {
    43|         const matrix = toMatrix(allRows, matrixConfig);
    44|         return move(matrix, rowIndex, colIndex).map((next) => next.cell);
    45|       });
    46|     });
    47|   });
    48| };
    49| const moveLeft = doMove(MatrixNavigation.cycleLeft, MatrixNavigation.moveLeft);
    50| const moveRight = doMove(MatrixNavigation.cycleRight, MatrixNavigation.moveRight);
    51| const moveNorth = doMove(MatrixNavigation.cycleUp, MatrixNavigation.moveUp);
    52| const moveSouth = doMove(MatrixNavigation.cycleDown, MatrixNavigation.moveDown);
    53| const getKeydownRules: () => Array<KeyRules.KeyRule<MatrixConfig, Stateless>> = Fun.constant([
    54|   KeyRules.rule(KeyMatch.inSet(Keys.LEFT), DomMovement.west(moveLeft, moveRight)),
    55|   KeyRules.rule(KeyMatch.inSet(Keys.RIGHT), DomMovement.east(moveLeft, moveRight)),
    56|   KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.north(moveNorth)),
    57|   KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.south(moveSouth)),
    58|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE.concat(Keys.ENTER)), execute)
    59| ]);
    60| const getKeyupRules: () => Array<KeyRules.KeyRule<MatrixConfig, Stateless>> = Fun.constant([
    61|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
    62| ]);
    63| export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/MenuType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Fun, Optional } from '@ephox/katamari';
     3| import { SelectorFind } from '@ephox/sugar';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import { NoState, Stateless } from '../behaviour/common/BehaviourState';
     7| import * as DomMovement from '../navigation/DomMovement';
     8| import * as DomNavigation from '../navigation/DomNavigation';
     9| import * as KeyMatch from '../navigation/KeyMatch';
    10| import * as KeyRules from '../navigation/KeyRules';
    11| import { KeyRuleHandler, MenuConfig } from './KeyingModeTypes';
    12| import * as KeyingType from './KeyingType';
    13| import * as KeyingTypes from './KeyingTypes';
    14| const schema = [
    15|   FieldSchema.required('selector'),
    16|   FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
    17|   FieldSchema.defaulted('moveOnTab', false)
    18| ];
    19| const execute: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind((focused) => menuConfig.execute(component, simulatedEvent, focused));
    20| const focusIn = (component: AlloyComponent, menuConfig: MenuConfig, _state: Stateless): void => {
    21|   SelectorFind.descendant<HTMLElement>(component.element, menuConfig.selector).each((first) => {
    22|     menuConfig.focusManager.set(component, first);
    23|   });
    24| };
    25| const moveUp: DomMovement.ElementMover<MenuConfig, Stateless> = (element, focused, info) => DomNavigation.horizontal(element, info.selector, focused, -1);
    26| const moveDown: DomMovement.ElementMover<MenuConfig, Stateless> = (element, focused, info) => DomNavigation.horizontal(element, info.selector, focused, +1);
    27| const fireShiftTab: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? DomMovement.move(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    28| const fireTab: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? DomMovement.move(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
    29| const getKeydownRules = Fun.constant([
    30|   KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.move(moveUp)),
    31|   KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.move(moveDown)),
    32|   KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), fireShiftTab),
    33|   KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.TAB) ]), fireTab),
    34|   KeyRules.rule(KeyMatch.inSet(Keys.ENTER), execute),
    35|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE), execute)
    36| ]);
    37| const getKeyupRules = Fun.constant([
    38|   KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
    39| ]);
    40| export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/keying/TabbingTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| import { FieldProcessor, FieldSchema } from '@ephox/boulder';
     2| import { Arr, Fun, Optional } from '@ephox/katamari';
     3| import { Compare, Height, SelectorFilter, SelectorFind, SugarElement } from '@ephox/sugar';
     4| import * as Keys from '../alien/Keys';
     5| import { AlloyComponent } from '../api/component/ComponentApi';
     6| import { NoState, Stateless } from '../behaviour/common/BehaviourState';
     7| import { NativeSimulatedEvent } from '../events/SimulatedEvent';
     8| import * as ArrNavigation from '../navigation/ArrNavigation';
     9| import * as KeyMatch from '../navigation/KeyMatch';
    10| import * as KeyRules from '../navigation/KeyRules';
    11| import { KeyRuleHandler, TabbingConfig } from './KeyingModeTypes';
    12| import * as KeyingType from './KeyingType';
    13| const create = (cyclicField: FieldProcessor): KeyingType.KeyingType<TabbingConfig, Stateless> => {
    14|   const schema: FieldProcessor[] = [
    15|     FieldSchema.option('onEscape'),
    16|     FieldSchema.option('onEnter'),
    17|     FieldSchema.defaulted('selector', '[data-alloy-tabstop="true"]:not(:disabled)'),
    18|     FieldSchema.defaulted('firstTabstop', 0),
    19|     FieldSchema.defaulted('useTabstopAt', Fun.always),
    20|     FieldSchema.option('visibilitySelector')
    21|   ].concat([
    22|     cyclicField
    23|   ]);
    24|   const isVisible = (tabbingConfig: TabbingConfig, element: SugarElement<HTMLElement>): boolean => {
    25|     const target = tabbingConfig.visibilitySelector
    26|       .bind((sel) => SelectorFind.closest<HTMLElement>(element, sel))
    27|       .getOr(element);
    28|     return Height.get(target) > 0;
    29|   };
    30|   const findInitial = (component: AlloyComponent, tabbingConfig: TabbingConfig): Optional<SugarElement<HTMLElement>> => {
    31|     const tabstops: SugarElement<HTMLElement>[] = SelectorFilter.descendants<HTMLElement>(component.element, tabbingConfig.selector);
    32|     const visibles: SugarElement<HTMLElement>[] = Arr.filter(tabstops, (elem) => isVisible(tabbingConfig, elem));
    33|     return Optional.from(visibles[tabbingConfig.firstTabstop]);
    34|   };
    35|   const findCurrent = (component: AlloyComponent, tabbingConfig: TabbingConfig): Optional<SugarElement<HTMLElement>> =>
    36|     tabbingConfig.focusManager.get(component)
    37|       .bind((elem) => SelectorFind.closest<HTMLElement>(elem, tabbingConfig.selector));
    38|   const isTabstop = (tabbingConfig: TabbingConfig, element: SugarElement<HTMLElement>): boolean =>
    39|     isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);
    40|   const focusIn = (component: AlloyComponent, tabbingConfig: TabbingConfig, _tabbingState: Stateless): void => {
    41|     findInitial(component, tabbingConfig).each((target) => {
    42|       tabbingConfig.focusManager.set(component, target);
    43|     });
    44|   };
    45|   const goFromTabstop = (
    46|     component: AlloyComponent,
    47|     tabstops: SugarElement<HTMLElement>[],
    48|     stopIndex: number,
    49|     tabbingConfig: TabbingConfig,
    50|     cycle: ArrNavigation.ArrCycle<SugarElement<HTMLElement>>
    51|   ): Optional<boolean> =>
    52|     cycle(tabstops, stopIndex, (elem) => isTabstop(tabbingConfig, elem))
    53|       .fold(
    54|         () => tabbingConfig.cyclic ? Optional.some<boolean>(true) : Optional.none(),
    55|         (target) => {
    56|           tabbingConfig.focusManager.set(component, target);
    57|           return Optional.some<boolean>(true);
    58|         }
    59|       );
    60|   const go = (
    61|     component: AlloyComponent,
    62|     _simulatedEvent: NativeSimulatedEvent,
    63|     tabbingConfig: TabbingConfig,
    64|     cycle: ArrNavigation.ArrCycle<SugarElement<HTMLElement>>
    65|   ): Optional<boolean> => {
    66|     const tabstops = SelectorFilter.descendants<HTMLElement>(component.element, tabbingConfig.selector);
    67|     return findCurrent(component, tabbingConfig).bind((tabstop) => {
    68|       const optStopIndex = Arr.findIndex(tabstops, Fun.curry(Compare.eq, tabstop));
    69|       return optStopIndex.bind((stopIndex) => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));
    70|     });
    71|   };
    72|   const goBackwards: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) => {
    73|     const navigate = tabbingConfig.cyclic ? ArrNavigation.cyclePrev : ArrNavigation.tryPrev;
    74|     return go(component, simulatedEvent, tabbingConfig, navigate);
    75|   };
    76|   const goForwards: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) => {
    77|     const navigate = tabbingConfig.cyclic ? ArrNavigation.cycleNext : ArrNavigation.tryNext;
    78|     return go(component, simulatedEvent, tabbingConfig, navigate);
    79|   };
    80|   const execute: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) =>
    81|     tabbingConfig.onEnter.bind((f) => f(component, simulatedEvent));
    82|   const exit: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) =>
    83|     tabbingConfig.onEscape.bind((f) => f(component, simulatedEvent));
    84|   const getKeydownRules = Fun.constant([
    85|     KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), goBackwards),
    86|     KeyRules.rule(KeyMatch.inSet(Keys.TAB), goForwards),
    87|     KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), exit),
    88|     KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.ENTER) ]), execute)
    89|   ]);
    90|   const getKeyupRules = Fun.constant([ ]);
    91|   return KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));
    92| };
    93| export {
    94|   create
    95| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/log/AlloyLogger.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| import { SugarElement, Truncate } from '@ephox/sugar';
     2| const element = (elem: SugarElement<Node>): string => Truncate.getHtml(elem);
     3| export {
     4|   element
     5| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/menu/build/WidgetType.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Optional } from '@ephox/katamari';
     3| import * as EditableFields from '../../alien/EditableFields';
     4| import * as Behaviour from '../../api/behaviour/Behaviour';
     5| import { Focusing } from '../../api/behaviour/Focusing';
     6| import { Keying } from '../../api/behaviour/Keying';
     7| import { Representing } from '../../api/behaviour/Representing';
     8| import { AlloyComponent } from '../../api/component/ComponentApi';
     9| import { SketchBehaviours } from '../../api/component/SketchBehaviours';
    10| import * as AlloyEvents from '../../api/events/AlloyEvents';
    11| import * as NativeEvents from '../../api/events/NativeEvents';
    12| import * as SystemEvents from '../../api/events/SystemEvents';
    13| import * as Fields from '../../data/Fields';
    14| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
    15| import * as AlloyParts from '../../parts/AlloyParts';
    16| import { WidgetItemDetail } from '../../ui/types/ItemTypes';
    17| import * as ItemEvents from '../util/ItemEvents';
    18| import * as WidgetParts from './WidgetParts';
    19| const builder = (detail: WidgetItemDetail) => {
    20|   const subs = AlloyParts.substitutes(WidgetParts.owner(), detail, WidgetParts.parts());
    21|   const components = AlloyParts.components(WidgetParts.owner(), detail, subs.internals());
    22|   const focusWidget = (component: AlloyComponent) => AlloyParts.getPart(component, detail, 'widget').map((widget) => {
    23|     Keying.focusIn(widget);
    24|     return widget;
    25|   });
    26|   const onHorizontalArrow = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>): Optional<boolean> =>
    27|     EditableFields.inside(simulatedEvent.event.target) ? Optional.none<boolean>() : (() => {
    28|       if (detail.autofocus) {
    29|         simulatedEvent.setSource(component.element);
    30|         return Optional.none<boolean>();
    31|       } else {
    32|         return Optional.none<boolean>();
    33|       }
    34|     })();
    35|   return {
    36|     dom: detail.dom,
    37|     components,
    38|     domModification: detail.domModification,
    39|     events: AlloyEvents.derive([
    40|       AlloyEvents.runOnExecute((component, simulatedEvent) => {
    41|         focusWidget(component).each((_widget) => {
    42|           simulatedEvent.stop();
    43|         });
    44|       }),
    45|       AlloyEvents.run(NativeEvents.mouseover(), ItemEvents.onHover),
    46|       AlloyEvents.run(SystemEvents.focusItem(), (component, _simulatedEvent) => {
    47|         if (detail.autofocus) {
    48|           focusWidget(component);
    49|         } else {
    50|           Focusing.focus(component);
    51|         }
    52|       })
    53|     ]),
    54|     behaviours: SketchBehaviours.augment(
    55|       detail.widgetBehaviours,
    56|       [
    57|         Representing.config({
    58|           store: {
    59|             mode: 'memory',
    60|             initialValue: detail.data
    61|           }
    62|         }),
    63|         Focusing.config({
    64|           ignore: detail.ignoreFocus,
    65|           onFocus: (component) => {
    66|             ItemEvents.onFocus(component);
    67|           }
    68|         }),
    69|         Keying.config({
    70|           mode: 'special',
    71|           focusIn: detail.autofocus ? (component) => {
    72|             focusWidget(component);
    73|           } : Behaviour.revoke(),
    74|           onLeft: onHorizontalArrow,
    75|           onRight: onHorizontalArrow,
    76|           onEscape: (component, simulatedEvent) => {
    77|             if (!Focusing.isFocused(component) && !detail.autofocus) {
    78|               Focusing.focus(component);
    79|               return Optional.some<boolean>(true);
    80|             } else if (detail.autofocus) {
    81|               simulatedEvent.setSource(component.element);
    82|               return Optional.none<boolean>();
    83|             } else {
    84|               return Optional.none<boolean>();
    85|             }
    86|           }
    87|         })
    88|       ]
    89|     )
    90|   };
    91| };
    92| const schema = [
    93|   FieldSchema.required('uid'),
    94|   FieldSchema.required('data'),
    95|   FieldSchema.required('components'),
    96|   FieldSchema.required('dom'),
    97|   FieldSchema.defaulted('autofocus', false),
    98|   FieldSchema.defaulted('ignoreFocus', false),
    99|   SketchBehaviours.field('widgetBehaviours', [ Representing, Focusing, Keying ]),
   100|   FieldSchema.defaulted('domModification', { }),
   101|   AlloyParts.defaultUidsSchema(WidgetParts.parts()),
   102|   Fields.output('builder', builder)
   103| ];
   104| export default schema;


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/navigation/DomMovement.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { Direction, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import { NativeSimulatedEvent } from '../events/SimulatedEvent';
     5| import { GeneralKeyingConfig, KeyRuleHandler } from '../keying/KeyingModeTypes';
     6| export type ElementMover <C, S> = (elem: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, config: C, state: S) => Optional<SugarElement<HTMLElement>>;
     7| const useH = <C extends GeneralKeyingConfig, S>(movement: (elem: SugarElement<Element>) => ElementMover<C, S>): KeyRuleHandler<C, S> =>
     8|   (component, simulatedEvent, config, state) => {
     9|     const move = movement(component.element);
    10|     return use(move, component, simulatedEvent, config, state);
    11|   };
    12| const west = <C extends GeneralKeyingConfig, S>(moveLeft: ElementMover<C, S>, moveRight: ElementMover<C, S>): KeyRuleHandler<C, S> => {
    13|   const movement = Direction.onDirection(moveLeft, moveRight);
    14|   return useH(movement);
    15| };
    16| const east = <C extends GeneralKeyingConfig, S>(moveLeft: ElementMover<C, S>, moveRight: ElementMover<C, S>): KeyRuleHandler<C, S> => {
    17|   const movement = Direction.onDirection(moveRight, moveLeft);
    18|   return useH(movement);
    19| };
    20| const useV = <C extends GeneralKeyingConfig, S>(move: ElementMover<C, S>): KeyRuleHandler<C, S> =>
    21|   (component, simulatedEvent, config, state) => use(move, component, simulatedEvent, config, state);
    22| const use = <C extends GeneralKeyingConfig, S>(move: ElementMover<C, S>, component: AlloyComponent, simulatedEvent: NativeSimulatedEvent, config: C, state: S): Optional<boolean> => {
    23|   const outcome = config.focusManager.get(component).bind((focused) => move(component.element, focused, config, state));
    24|   return outcome.map((newFocus): boolean => {
    25|     config.focusManager.set(component, newFocus);
    26|     return true;
    27|   });
    28| };
    29| const north = useV;
    30| const south = useV;
    31| const move = useV;
    32| export {
    33|   east,
    34|   west,
    35|   north,
    36|   south,
    37|   move
    38| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/navigation/DomNavigation.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { Num, Optional } from '@ephox/katamari';
     2| import { Attribute, SugarElement, SugarNode } from '@ephox/sugar';
     3| import * as DomPinpoint from './DomPinpoint';
     4| const horizontal = (container: SugarElement<HTMLElement>, selector: string, current: SugarElement<HTMLElement>, delta: number): Optional<SugarElement<HTMLElement>> => {
     5|   const isDisabledButton = (candidate: SugarElement<HTMLElement>) =>
     6|     SugarNode.name(candidate) === 'button' && Attribute.get(candidate, 'disabled') === 'disabled';
     7|   const tryCycle = (initial: number, index: number, candidates: Array<SugarElement<HTMLElement>>): Optional<SugarElement<HTMLElement>> => {
     8|     const newIndex = Num.cycleBy(index, delta, 0, candidates.length - 1);
     9|     if (newIndex === initial) { // If we've cycled back to the original index, we've failed to find a new valid candidate
    10|       return Optional.none();
    11|     } else {
    12|       return isDisabledButton(candidates[newIndex]) ?
    13|         tryCycle(initial, newIndex, candidates) :
    14|         Optional.from(candidates[newIndex]);
    15|     }
    16|   };
    17|   return DomPinpoint.locateVisible(container, current, selector).bind((identified) => {
    18|     const index = identified.index;
    19|     const candidates = identified.candidates;
    20|     return tryCycle(index, index, candidates);
    21|   });
    22| };
    23| export {
    24|   horizontal
    25| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/navigation/DomPinpoint.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| import { Arr, Optional } from '@ephox/katamari';
     2| import { Compare, SelectorFilter, SugarElement, Visibility } from '@ephox/sugar';
     3| import * as ArrPinpoint from './ArrPinpoint';
     4| const locateVisible = (container: SugarElement<HTMLElement>, current: SugarElement<HTMLElement>, selector: string): Optional<ArrPinpoint.IndexInfo<SugarElement<HTMLElement>>> => {
     5|   const predicate = (x: SugarElement<Node>) => Compare.eq(x, current);
     6|   const candidates = SelectorFilter.descendants<HTMLElement>(container, selector);
     7|   const visible = Arr.filter(candidates, Visibility.isVisible);
     8|   return ArrPinpoint.locate(visible, predicate);
     9| };
    10| const findIndex = <T> (elements: Array<SugarElement<T>>, target: SugarElement<T>): Optional<number> =>
    11|   Arr.findIndex(elements, (elem) => Compare.eq(target, elem));
    12| export {
    13|   locateVisible,
    14|   findIndex
    15| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/layout/Anchor.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { SugarElement } from '@ephox/sugar';
     2| import { AnchorBox } from './LayoutTypes';
     3| import * as Origins from './Origins';
     4| /*
     5|  * Smooths over the difference between passing an element anchor (which requires an origin to determine the box) and passing a box.
     6|  *
     7|  * It is only useful for fixed origins; relative needs to do everything the old way.
     8|  */
     9| export interface Anchor {
    10|   readonly anchorBox: AnchorBox;
    11|   readonly origin: Origins.OriginAdt;
    12| }
    13| const anchor = (anchorBox: AnchorBox, origin: Origins.OriginAdt): Anchor => ({
    14|   anchorBox,
    15|   origin
    16| });
    17| const element = (anchorElement: SugarElement<HTMLElement>, origin: Origins.OriginAdt): Anchor => {
    18|   const anchorBox = Origins.toBox(origin, anchorElement);
    19|   return anchor(anchorBox, origin);
    20| };
    21| const box = (anchorBox: AnchorBox, origin: Origins.OriginAdt): Anchor => anchor(anchorBox, origin);
    22| export {
    23|   box,
    24|   element
    25| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/layout/MaxHeight.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { Css, Height, SugarElement } from '@ephox/sugar';
     3| const setMaxHeight = (element: SugarElement<HTMLElement>, maxHeight: number): void => {
     4|   Height.setMax(element, Math.floor(maxHeight));
     5| };
     6| const anchored = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
     7|   setMaxHeight(element, available);
     8|   Css.setAll(element, {
     9|     'overflow-x': 'hidden',
    10|     'overflow-y': 'auto'
    11|   });
    12| });
    13| /*
    14|  * This adds max height, but not overflow - the effect of this is that elements can grow beyond the max height,
    15|  * but if they run off the top they're pushed down.
    16|  *
    17|  * If the element expands below the screen height it will be cut off, but we were already doing that.
    18|  */
    19| const expandable = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
    20|   setMaxHeight(element, available);
    21| });
    22| export {
    23|   anchored,
    24|   expandable
    25| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/layout/MaxWidth.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { SugarElement, Width } from '@ephox/sugar';
     3| const expandable = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
     4|   Width.setMax(element, Math.floor(available));
     5| });
     6| export { expandable };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/layout/Origins.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-112 ---
     1| import { Adt, Fun, Optional } from '@ephox/katamari';
     2| import { Height, Scroll, SugarElement, SugarPosition, Width } from '@ephox/sugar';
     3| import * as Boxes from '../../alien/Boxes';
     4| import * as OuterPosition from '../../frame/OuterPosition';
     5| import { NuPositionCss, PositionCss } from '../view/PositionCss';
     6| import { RepositionDecision } from '../view/Reposition';
     7| import * as Direction from './Direction';
     8| type NoneOrigin<T> = () => T;
     9| type RelativeOrigin<T> = (x: number, y: number, width: number, height: number) => T;
    10| type FixedOrigin<T> = (x: number, y: number, width: number, height: number) => T;
    11| export interface OriginAdt {
    12|   fold: <T>(
    13|     none: NoneOrigin<T>,
    14|     relative: RelativeOrigin<T>,
    15|     fixed: FixedOrigin<T>
    16|   ) => T;
    17|   match: <T>(branches: {
    18|     none: NoneOrigin<T>;
    19|     relative: RelativeOrigin<T>;
    20|     fixed: FixedOrigin<T>;
    21|   }) => T;
    22|   log: (label: string) => void;
    23| }
    24| const adt: {
    25|   none: NoneOrigin<OriginAdt>;
    26|   relative: RelativeOrigin<OriginAdt>;
    27|   fixed: FixedOrigin<OriginAdt>;
    28| } = Adt.generate([
    29|   { none: [ ] },
    30|   { relative: [ 'x', 'y', 'width', 'height' ] },
    31|   { fixed: [ 'x', 'y', 'width', 'height' ] }
    32| ]);
    33| const positionWithDirection = (posName: string, decision: RepositionDecision, x: number, y: number, width: number, height: number) => {
    34|   const decisionRect = decision.rect;
    35|   const decisionX = decisionRect.x - x;
    36|   const decisionY = decisionRect.y - y;
    37|   const decisionWidth = decisionRect.width;
    38|   const decisionHeight = decisionRect.height;
    39|   const decisionRight = width - (decisionX + decisionWidth);
    40|   const decisionBottom = height - (decisionY + decisionHeight);
    41|   const left = Optional.some(decisionX);
    42|   const top = Optional.some(decisionY);
    43|   const right = Optional.some(decisionRight);
    44|   const bottom = Optional.some(decisionBottom);
    45|   const none = Optional.none<number>();
    46|   return Direction.cata(decision.direction,
    47|     () => NuPositionCss(posName, left, top, none, none), // southeast
    48|     () => NuPositionCss(posName, none, top, right, none), // southwest
    49|     () => NuPositionCss(posName, left, none, none, bottom), // northeast
    50|     () => NuPositionCss(posName, none, none, right, bottom), // northwest
    51|     () => NuPositionCss(posName, left, top, none, none), // south
    52|     () => NuPositionCss(posName, left, none, none, bottom), // north
    53|     () => NuPositionCss(posName, left, top, none, none), // east
    54|     () => NuPositionCss(posName, none, top, right, none) // west
    55|   );
    56| };
    57| const reposition = (origin: OriginAdt, decision: RepositionDecision): PositionCss => origin.fold(() => {
    58|   const decisionRect = decision.rect;
    59|   return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
    60| }, (x, y, width, height) => {
    61|   return positionWithDirection('absolute', decision, x, y, width, height);
    62| }, (x, y, width, height) => {
    63|   return positionWithDirection('fixed', decision, x, y, width, height);
    64| });
    65| const toBox = (origin: OriginAdt, element: SugarElement<HTMLElement>): Boxes.Bounds => {
    66|   const rel = Fun.curry(OuterPosition.find, element);
    67|   const position = origin.fold(rel, rel, () => {
    68|     const scroll = Scroll.get();
    69|     return OuterPosition.find(element).translate(-scroll.left, -scroll.top);
    70|   });
    71|   const width = Width.getOuter(element);
    72|   const height = Height.getOuter(element);
    73|   return Boxes.bounds(position.left, position.top, width, height);
    74| };
    75| const viewport = (origin: OriginAdt, getBounds: Optional<() => Boxes.Bounds>): Boxes.Bounds => getBounds.fold(() =>
    76| /* There are no bounds supplied */
    77|   origin.fold(Boxes.win, Boxes.win, Boxes.bounds)
    78| , (b) =>
    79| /* Use any bounds supplied or remove the scroll position of the bounds for fixed. */
    80|   origin.fold(b, b, () => {
    81|     const bounds = b();
    82|     const pos = translate(origin, bounds.x, bounds.y);
    83|     return Boxes.bounds(pos.left, pos.top, bounds.width, bounds.height);
    84|   })
    85| );
    86| const translate = (origin: OriginAdt, x: number, y: number): SugarPosition => {
    87|   const pos = SugarPosition(x, y);
    88|   const removeScroll = () => {
    89|     const outerScroll = Scroll.get();
    90|     return pos.translate(-outerScroll.left, -outerScroll.top);
    91|   };
    92|   return origin.fold(Fun.constant(pos), Fun.constant(pos), removeScroll);
    93| };
    94| const cata = <B>(
    95|   subject: OriginAdt,
    96|   onNone: NoneOrigin<B>,
    97|   onRelative: RelativeOrigin<B>,
    98|   onFixed: FixedOrigin<B>
    99| ): B => subject.fold<B>(onNone, onRelative, onFixed);
   100| const none = adt.none;
   101| const relative = adt.relative;
   102| const fixed = adt.fixed;
   103| export {
   104|   none,
   105|   relative,
   106|   fixed,
   107|   reposition,
   108|   viewport,
   109|   toBox,
   110|   translate,
   111|   cata
   112| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/layout/SimpleLayout.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import { AnchorOverrides, MaxHeightFunction, MaxWidthFunction } from '../mode/Anchoring';
     5| import * as Callouts from '../view/Callouts';
     6| import { Transition } from '../view/Transitions';
     7| import { Anchor } from './Anchor';
     8| import { Bubble } from './Bubble';
     9| import { PlacerResult } from './LayoutTypes';
    10| import * as LayoutTypes from './LayoutTypes';
    11| import * as MaxHeight from './MaxHeight';
    12| import * as Origins from './Origins';
    13| export interface ReparteeOptions {
    14|   readonly bounds: Bounds;
    15|   readonly origin: Origins.OriginAdt;
    16|   readonly preference: LayoutTypes.AnchorLayout[];
    17|   readonly maxHeightFunction: MaxHeightFunction;
    18|   readonly maxWidthFunction: MaxWidthFunction;
    19|   readonly lastPlacement: Optional<PlacerResult>;
    20|   readonly transition: Optional<Transition>;
    21| }
    22| const defaultOr = <K extends keyof AnchorOverrides>(options: AnchorOverrides, key: K, dephault: NonNullable<AnchorOverrides[K]>): NonNullable<AnchorOverrides[K]> => options[key] === undefined ? dephault : options[key] as NonNullable<AnchorOverrides[K]>;
    23| const simple = (
    24|   anchor: Anchor,
    25|   element: SugarElement<HTMLElement>,
    26|   bubble: Bubble,
    27|   layouts: LayoutTypes.AnchorLayout[],
    28|   lastPlacement: Optional<PlacerResult>,
    29|   getBounds: Optional<() => Bounds>,
    30|   overrideOptions: AnchorOverrides,
    31|   transition: Optional<Transition>
    32| ): PlacerResult => {
    33|   const maxHeightFunction: MaxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', MaxHeight.anchored());
    34|   const maxWidthFunction: MaxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', Fun.noop);
    35|   const anchorBox = anchor.anchorBox;
    36|   const origin = anchor.origin;
    37|   const options: ReparteeOptions = {
    38|     bounds: Origins.viewport(origin, getBounds),
    39|     origin,
    40|     preference: layouts,
    41|     maxHeightFunction,
    42|     maxWidthFunction,
    43|     lastPlacement,
    44|     transition
    45|   };
    46|   return go(anchorBox, element, bubble, options);
    47| };
    48| const go = (anchorBox: LayoutTypes.AnchorBox, element: SugarElement<HTMLElement>, bubble: Bubble, options: ReparteeOptions): PlacerResult => {
    49|   const decision = Callouts.layout(anchorBox, element, bubble, options);
    50|   Callouts.position(element, decision, options);
    51|   Callouts.setPlacement(element, decision);
    52|   Callouts.setClasses(element, decision);
    53|   Callouts.setHeight(element, decision, options);
    54|   Callouts.setWidth(element, decision, options);
    55|   return {
    56|     layout: decision.layout,
    57|     placement: decision.placement
    58|   };
    59| };
    60| export { simple };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/mode/AnchorLayouts.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| import { FieldProcessor, FieldSchema } from '@ephox/boulder';
     2| import { Optional } from '@ephox/katamari';
     3| import { Direction, SugarElement } from '@ephox/sugar';
     4| import { AnchorLayout } from '../layout/LayoutTypes';
     5| import { HasLayoutAnchor } from './Anchoring';
     6| import { isBottomToTopDir } from './VerticalDir';
     7| const schema = (): FieldProcessor => FieldSchema.optionObjOf('layouts', [
     8|   FieldSchema.required('onLtr'),
     9|   FieldSchema.required('onRtl'),
    10|   FieldSchema.option('onBottomLtr'),
    11|   FieldSchema.option('onBottomRtl')
    12| ]);
    13| const get = (
    14|   elem: SugarElement<Element>,
    15|   info: HasLayoutAnchor,
    16|   defaultLtr: AnchorLayout[],
    17|   defaultRtl: AnchorLayout[],
    18|   defaultBottomLtr: AnchorLayout[],
    19|   defaultBottomRtl: AnchorLayout[],
    20|   dirElement: Optional<SugarElement<Element>>
    21| ): AnchorLayout[] => {
    22|   const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
    23|   const customLtr = info.layouts.map((ls) => ls.onLtr(elem));
    24|   const customRtl = info.layouts.map((ls) => ls.onRtl(elem));
    25|   const ltr = isBottomToTop ?
    26|     info.layouts.bind((ls) => ls.onBottomLtr.map((f) => f(elem)))
    27|       .or(customLtr)
    28|       .getOr(defaultBottomLtr) :
    29|     customLtr.getOr(defaultLtr);
    30|   const rtl = isBottomToTop ?
    31|     info.layouts.bind((ls) => ls.onBottomRtl.map((f) => f(elem)))
    32|       .or(customRtl)
    33|       .getOr(defaultBottomRtl) :
    34|     customRtl.getOr(defaultRtl);
    35|   const f = Direction.onDirection(ltr, rtl);
    36|   return f(elem);
    37| };
    38| export {
    39|   schema,
    40|   get
    41| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/mode/Anchoring.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-126 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { SimRange, SugarElement } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import { Bubble } from '../layout/Bubble';
     6| import { AnchorBox, AnchorLayout, PlacerResult } from '../layout/LayoutTypes';
     7| import { OriginAdt } from '../layout/Origins';
     8| import { Transition } from '../view/Transitions';
     9| export type AnchorPlacement = (
    10|   comp: AlloyComponent,
    11|   origin: OriginAdt,
    12|   anchoring: Anchoring,
    13|   getBounds: Optional<() => Bounds>,
    14|   placee: AlloyComponent,
    15|   lastPlacement: Optional<PlacerResult>,
    16|   transition: Optional<Transition>
    17| ) => PlacerResult;
    18| export interface CommonAnchorSpec {
    19|   type: string;
    20| }
    21| export type AnchorSpec = SelectionAnchorSpec | HotspotAnchorSpec | SubmenuAnchorSpec | MakeshiftAnchorSpec | NodeAnchorSpec;
    22| export interface AnchorDetail<D> {
    23|   placement: (comp: AlloyComponent, anchor: D, origin: OriginAdt) => Optional<Anchoring>;
    24| }
    25| export type MaxHeightFunction = (elem: SugarElement<HTMLElement>, available: number) => void;
    26| export type MaxWidthFunction = (elem: SugarElement<HTMLElement>, available: number) => void;
    27| export interface AnchorOverrides {
    28|   maxHeightFunction?: MaxHeightFunction;
    29|   maxWidthFunction?: MaxWidthFunction;
    30| }
    31| export interface LayoutsDetail {
    32|   onLtr: (elem: SugarElement<Element>) => AnchorLayout[];
    33|   onRtl: (elem: SugarElement<Element>) => AnchorLayout[];
    34|   onBottomLtr: Optional<(elem: SugarElement<Element>) => AnchorLayout[]>;
    35|   onBottomRtl: Optional<(elem: SugarElement<Element>) => AnchorLayout[]>;
    36| }
    37| export interface HasLayoutAnchor {
    38|   layouts: Optional<LayoutsDetail>;
    39| }
    40| export interface Layouts {
    41|   onLtr: (elem: SugarElement<Element>) => AnchorLayout[];
    42|   onRtl: (elem: SugarElement<Element>) => AnchorLayout[];
    43|   onBottomLtr?: (elem: SugarElement<Element>) => AnchorLayout[];
    44|   onBottomRtl?: (elem: SugarElement<Element>) => AnchorLayout[];
    45| }
    46| export interface HasLayoutAnchorSpec {
    47|   layouts?: Layouts;
    48| }
    49| export interface SelectionAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
    50|   type: 'selection';
    51|   getSelection?: () => Optional<SimRange>;
    52|   root: SugarElement<Node>;
    53|   bubble?: Bubble;
    54|   overrides?: AnchorOverrides;
    55|   showAbove?: boolean;
    56| }
    57| export interface SelectionAnchor extends AnchorDetail<SelectionAnchor>, HasLayoutAnchor {
    58|   getSelection: Optional<() => Optional<SimRange>>;
    59|   root: SugarElement<Node>;
    60|   bubble: Optional<Bubble>;
    61|   overrides: AnchorOverrides;
    62|   showAbove: boolean;
    63| }
    64| export interface NodeAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
    65|   type: 'node';
    66|   node: Optional<SugarElement<Element>>;
    67|   root: SugarElement<Node>;
    68|   bubble?: Bubble;
    69|   overrides?: AnchorOverrides;
    70|   showAbove?: boolean;
    71| }
    72| export interface NodeAnchor extends AnchorDetail<NodeAnchor>, HasLayoutAnchor {
    73|   node: Optional<SugarElement<Element>>;
    74|   root: SugarElement<Node>;
    75|   bubble: Optional<Bubble>;
    76|   overrides: AnchorOverrides;
    77|   showAbove: boolean;
    78| }
    79| export interface HotspotAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
    80|   type: 'hotspot';
    81|   hotspot: AlloyComponent;
    82|   bubble?: Bubble;
    83|   overrides?: AnchorOverrides;
    84| }
    85| export interface HotspotAnchor extends AnchorDetail<HotspotAnchor>, HasLayoutAnchor {
    86|   hotspot: AlloyComponent;
    87|   bubble: Optional<Bubble>;
    88|   overrides: AnchorOverrides;
    89| }
    90| export interface SubmenuAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
    91|   type: 'submenu';
    92|   overrides?: AnchorOverrides;
    93|   item: AlloyComponent;
    94| }
    95| export interface SubmenuAnchor extends AnchorDetail<SubmenuAnchor>, HasLayoutAnchor {
    96|   item: AlloyComponent;
    97|   overrides: AnchorOverrides;
    98| }
    99| export interface MakeshiftAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
   100|   type: 'makeshift';
   101|   x: number;
   102|   y: number;
   103|   height?: number;
   104|   width?: number;
   105|   bubble?: Bubble;
   106|   overrides?: AnchorOverrides;
   107| }
   108| export interface MakeshiftAnchor extends AnchorDetail<MakeshiftAnchor>, HasLayoutAnchor {
   109|   x: number;
   110|   y: number;
   111|   height: number;
   112|   width: number;
   113|   bubble: Bubble;
   114|   overrides: AnchorOverrides;
   115| }
   116| export interface Anchoring {
   117|   anchorBox: AnchorBox;
   118|   bubble: Bubble;
   119|   overrides: AnchorOverrides;
   120|   layouts: AnchorLayout[];
   121|   placer: Optional<AnchorPlacement>;
   122| }
   123| const nu: (spec: Anchoring) => Anchoring = Fun.identity;
   124| export {
   125|   nu
   126| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/mode/ContentAnchorCommon.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement, SugarPosition } from '@ephox/sugar';
     3| import * as Boxes from '../../alien/Boxes';
     4| import * as CssPosition from '../../alien/CssPosition';
     5| import * as Bubble from '../layout/Bubble';
     6| import * as Layout from '../layout/Layout';
     7| import * as Origins from '../layout/Origins';
     8| import { Anchoring, NodeAnchor, nu as NuAnchor, SelectionAnchor } from './Anchoring';
     9| import * as AnchorLayouts from './AnchorLayouts';
    10| const getBox = (left: number, top: number, width: number, height: number): Optional<Boxes.BoxByPoint> => {
    11|   const point = CssPosition.screen(SugarPosition(left, top));
    12|   return Optional.some(Boxes.pointed(point, width, height));
    13| };
    14| const calcNewAnchor = (optBox: Optional<Boxes.BoxByPoint>, rootPoint: CssPosition.CssPositionAdt, anchorInfo: SelectionAnchor | NodeAnchor, origin: Origins.OriginAdt, elem: SugarElement<Element>): Optional<Anchoring> =>
    15|   optBox.map((box) => {
    16|     const points = [ rootPoint, box.point ];
    17|     const topLeft = Origins.cata(origin,
    18|       () => CssPosition.sumAsAbsolute(points),
    19|       () => CssPosition.sumAsAbsolute(points),
    20|       () => CssPosition.sumAsFixed(points)
    21|     );
    22|     const anchorBox = Boxes.rect(
    23|       topLeft.left,
    24|       topLeft.top,
    25|       box.width,
    26|       box.height
    27|     );
    28|     const layoutsLtr = anchorInfo.showAbove ?
    29|       Layout.aboveOrBelow() :
    30|       Layout.belowOrAbove();
    31|     const layoutsRtl = anchorInfo.showAbove ?
    32|       Layout.aboveOrBelowRtl() :
    33|       Layout.belowOrAboveRtl();
    34|     const layouts = AnchorLayouts.get(
    35|       elem,
    36|       anchorInfo,
    37|       layoutsLtr,
    38|       layoutsRtl,
    39|       layoutsLtr,
    40|       layoutsRtl,
    41|       Optional.none()
    42|     );
    43|     return NuAnchor({
    44|       anchorBox,
    45|       bubble: anchorInfo.bubble.getOr(Bubble.fallback()),
    46|       overrides: anchorInfo.overrides,
    47|       layouts,
    48|       placer: Optional.none()
    49|     });
    50|   });
    51| export {
    52|   getBox,
    53|   calcNewAnchor
    54| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/mode/SelectionAnchor.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Optional, Unicode } from '@ephox/katamari';
     3| import { Insert, Remove, SimRange, SimSelection, SugarElement, SugarNode, Traverse, WindowSelection } from '@ephox/sugar';
     4| import * as Descend from '../../alien/Descend';
     5| import { AlloyComponent } from '../../api/component/ComponentApi';
     6| import * as Fields from '../../data/Fields';
     7| import * as Origins from '../layout/Origins';
     8| import { Anchoring, SelectionAnchor } from './Anchoring';
     9| import * as AnchorLayouts from './AnchorLayouts';
    10| import * as ContainerOffsets from './ContainerOffsets';
    11| import * as ContentAnchorCommon from './ContentAnchorCommon';
    12| const descendOnce = (element: SugarElement<Node>, offset: number): Descend.ElementAndOffset<Node> =>
    13|   SugarNode.isText(element) ? Descend.point(element, offset) : Descend.descendOnce(element, offset);
    14| const getAnchorSelection = (win: Window, anchorInfo: SelectionAnchor): Optional<SimRange> => {
    15|   const getSelection = anchorInfo.getSelection.getOrThunk(() => () => WindowSelection.getExact(win));
    16|   return getSelection().map((sel) => {
    17|     const modStart = descendOnce(sel.start, sel.soffset);
    18|     const modFinish = descendOnce(sel.finish, sel.foffset);
    19|     return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
    20|   });
    21| };
    22| const placement = (component: AlloyComponent, anchorInfo: SelectionAnchor, origin: Origins.OriginAdt): Optional<Anchoring> => {
    23|   const win: Window = Traverse.defaultView(anchorInfo.root).dom;
    24|   const rootPoint = ContainerOffsets.getRootPoint(component, origin, anchorInfo);
    25|   const selectionBox = getAnchorSelection(win, anchorInfo).bind((sel) => {
    26|     const optRect = WindowSelection.getBounds(win, SimSelection.exactFromRange(sel)).orThunk(() => {
    27|       const x = SugarElement.fromText(Unicode.zeroWidth);
    28|       Insert.before(sel.start, x);
    29|       const rect = WindowSelection.getFirstRect(win, SimSelection.exact(x, 0, x, 1));
    30|       Remove.remove(x);
    31|       return rect;
    32|     });
    33|     return optRect.bind((rawRect) => ContentAnchorCommon.getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height));
    34|   });
    35|   const targetElement = getAnchorSelection(win, anchorInfo)
    36|     .bind((sel) => SugarNode.isElement(sel.start) ? Optional.some(sel.start) : Traverse.parentElement(sel.start));
    37|   const elem = targetElement.getOr(component.element);
    38|   return ContentAnchorCommon.calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
    39| };
    40| export default [
    41|   FieldSchema.option('getSelection'),
    42|   FieldSchema.required('root'),
    43|   FieldSchema.option('bubble'),
    44|   AnchorLayouts.schema(),
    45|   FieldSchema.defaulted('overrides', { }),
    46|   FieldSchema.defaulted('showAbove', false),
    47|   Fields.output('placement', placement)
    48| ];


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/mode/VerticalDir.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| import { Attribute as Attrib, PredicateExists, SugarElement, SugarNode } from '@ephox/sugar';
     2| export enum AttributeValue {
     3|   TopToBottom = 'toptobottom',
     4|   BottomToTop = 'bottomtotop'
     5| }
     6| export const Attribute = 'data-alloy-vertical-dir';
     7| const isBottomToTopDir = (el: SugarElement<Element>): boolean => PredicateExists.closest(el, (current) =>
     8|   SugarNode.isElement(current) && Attrib.get(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop);
     9| export {
    10|   isBottomToTopDir
    11| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/view/Callouts.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| import { Classes, Css, Height, SugarElement, Width } from '@ephox/sugar';
     2| import { Bubble } from '../layout/Bubble';
     3| import { AnchorBox, AnchorElement } from '../layout/LayoutTypes';
     4| import * as Origins from '../layout/Origins';
     5| import * as Placement from '../layout/Placement';
     6| import { ReparteeOptions } from '../layout/SimpleLayout';
     7| import * as Bounder from './Bounder';
     8| import { applyPositionCss } from './PositionCss';
     9| import { RepositionDecision } from './Reposition';
    10| import { applyTransitionCss } from './Transitions';
    11| /*
    12|  * This is the old repartee API. It is retained in a similar structure to the original form,
    13|  * in case we decide to bring back the flexibility of working with non-standard positioning.
    14|  */
    15| const elementSize = (p: SugarElement<HTMLElement>): AnchorElement => ({
    16|   width: Width.getOuter(p),
    17|   height: Height.getOuter(p)
    18| });
    19| const layout = (anchorBox: AnchorBox, element: SugarElement<HTMLElement>, bubbles: Bubble, options: ReparteeOptions): RepositionDecision => {
    20|   Css.remove(element, 'max-height');
    21|   Css.remove(element, 'max-width');
    22|   const elementBox = elementSize(element);
    23|   return Bounder.attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);
    24| };
    25| const setClasses = (element: SugarElement<HTMLElement>, decision: RepositionDecision): void => {
    26|   const classInfo = decision.classes;
    27|   Classes.remove(element, classInfo.off);
    28|   Classes.add(element, classInfo.on);
    29| };
    30| /*
    31|  * maxHeightFunction is a MaxHeight instance.
    32|  * max-height is usually the distance between the edge of the popup and the screen; top of popup to bottom of screen for south, bottom of popup to top of screen for north.
    33|  *
    34|  * There are a few cases where we specifically don't want a max-height, which is why it's optional.
    35|  */
    36| const setHeight = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
    37|   const maxHeightFunction = options.maxHeightFunction;
    38|   maxHeightFunction(element, decision.maxHeight);
    39| };
    40| const setWidth = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
    41|   const maxWidthFunction = options.maxWidthFunction;
    42|   maxWidthFunction(element, decision.maxWidth);
    43| };
    44| const position = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
    45|   const positionCss = Origins.reposition(options.origin, decision);
    46|   options.transition.each((transition) => {
    47|     applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);
    48|   });
    49|   applyPositionCss(element, positionCss);
    50| };
    51| const setPlacement = (element: SugarElement<HTMLElement>, decision: RepositionDecision): void => {
    52|   Placement.setPlacement(element, decision.placement);
    53| };
    54| export {
    55|   layout,
    56|   setClasses,
    57|   setHeight,
    58|   setWidth,
    59|   position,
    60|   setPlacement
    61| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/positioning/view/Transitions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-122 ---
     1| import { Arr, Obj, Optional, Optionals, Singleton, Strings, Type } from '@ephox/katamari';
     2| import { Attribute, Classes, Compare, Css, DomEvent, EventArgs, SugarElement } from '@ephox/sugar';
     3| import * as NativeEvents from '../../api/events/NativeEvents';
     4| import { PlacerResult } from '../layout/LayoutTypes';
     5| import * as Origins from '../layout/Origins';
     6| import { PositionCss } from './PositionCss';
     7| import { RepositionDecision } from './Reposition';
     8| export type TransitionProp = 'top' | 'left' | 'bottom' | 'right';
     9| export type TransitionMode = 'all' | 'layout' | 'placement';
    10| export interface Transition {
    11|   readonly classes: string[];
    12|   readonly mode: TransitionMode;
    13| }
    14| const properties: TransitionProp[] = [ 'top', 'bottom', 'right', 'left' ];
    15| const timerAttr = 'data-alloy-transition-timer';
    16| const isTransitioning = (element: SugarElement<HTMLElement>, transition: Transition): boolean =>
    17|   Classes.hasAll(element, transition.classes);
    18| const shouldApplyTransitionCss = (transition: Transition, decision: RepositionDecision, lastPlacement: Optional<PlacerResult>): boolean => {
    19|   return lastPlacement.exists((placer) => {
    20|     const mode = transition.mode;
    21|     return mode === 'all' ? true : placer[mode] !== decision[mode];
    22|   });
    23| };
    24| const hasChanges = (position: PositionCss, intermediate: Record<TransitionProp, Optional<string>>): boolean => {
    25|   const round = (value: string) => parseFloat(value).toFixed(3);
    26|   return Obj.find(intermediate, (value, key) => {
    27|     const newValue = position[key as TransitionProp].map(round);
    28|     const val = value.map(round);
    29|     return !Optionals.equals(newValue, val);
    30|   }).isSome();
    31| };
    32| const getTransitionDuration = (element: SugarElement<HTMLElement>): number => {
    33|   const get = (name: string) => {
    34|     const style = Css.get(element, name);
    35|     const times = style.split(/\s*,\s*/);
    36|     return Arr.filter(times, Strings.isNotEmpty);
    37|   };
    38|   const parse = (value: string | undefined) => {
    39|     if (Type.isString(value) && /^[\d.]+/.test(value)) {
    40|       const num = parseFloat(value);
    41|       return Strings.endsWith(value, 'ms') ? num : num * 1000;
    42|     } else {
    43|       return 0;
    44|     }
    45|   };
    46|   const delay = get('transition-delay');
    47|   const duration = get('transition-duration');
    48|   return Arr.foldl(duration, (acc, dur, i) => {
    49|     const time = parse(delay[i]) + parse(dur);
    50|     return Math.max(acc, time);
    51|   }, 0);
    52| };
    53| const setupTransitionListeners = (element: SugarElement<HTMLElement>, transition: Transition): void => {
    54|   const transitionEnd = Singleton.unbindable();
    55|   const transitionCancel = Singleton.unbindable();
    56|   let timer: number;
    57|   const isSourceTransition = (e: EventArgs<TransitionEvent>) => {
    58|     const pseudoElement = e.raw.pseudoElement ?? '';
    59|     return Compare.eq(e.target, element) && Strings.isEmpty(pseudoElement) && Arr.contains(properties, e.raw.propertyName);
    60|   };
    61|   const transitionDone = (e?: EventArgs<TransitionEvent>) => {
    62|     if (Type.isNullable(e) || isSourceTransition(e)) {
    63|       transitionEnd.clear();
    64|       transitionCancel.clear();
    65|       const type = e?.raw.type;
    66|       if (Type.isNullable(type) || type === NativeEvents.transitionend()) {
    67|         clearTimeout(timer);
    68|         Attribute.remove(element, timerAttr);
    69|         Classes.remove(element, transition.classes);
    70|       }
    71|     }
    72|   };
    73|   const transitionStart = DomEvent.bind(element, NativeEvents.transitionstart(), (e) => {
    74|     if (isSourceTransition(e)) {
    75|       transitionStart.unbind();
    76|       transitionEnd.set(DomEvent.bind(element, NativeEvents.transitionend(), transitionDone));
    77|       transitionCancel.set(DomEvent.bind(element, NativeEvents.transitioncancel(), transitionDone));
    78|     }
    79|   });
    80|   const duration = getTransitionDuration(element);
    81|   requestAnimationFrame(() => {
    82|     timer = setTimeout(transitionDone, duration + 17);
    83|     Attribute.set(element, timerAttr, timer);
    84|   });
    85| };
    86| const startTransitioning = (element: SugarElement<HTMLElement>, transition: Transition): void => {
    87|   Classes.add(element, transition.classes);
    88|   Attribute.getOpt(element, timerAttr).each((timerId) => {
    89|     clearTimeout(parseInt(timerId, 10));
    90|     Attribute.remove(element, timerAttr);
    91|   });
    92|   setupTransitionListeners(element, transition);
    93| };
    94| const applyTransitionCss = (
    95|   element: SugarElement<HTMLElement>,
    96|   origin: Origins.OriginAdt,
    97|   position: PositionCss,
    98|   transition: Transition,
    99|   decision: RepositionDecision,
   100|   lastPlacement: Optional<PlacerResult>
   101| ): void => {
   102|   const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
   103|   if (shouldTransition || isTransitioning(element, transition)) {
   104|     Css.set(element, 'position', position.position);
   105|     const rect = Origins.toBox(origin, element);
   106|     const intermediatePosition = Origins.reposition(origin, { ...decision, rect });
   107|     const intermediateCssOptions = Arr.mapToObject(properties, (prop) => intermediatePosition[prop]);
   108|     if (hasChanges(position, intermediateCssOptions)) {
   109|       Css.setOptions(element, intermediateCssOptions);
   110|       if (shouldTransition) {
   111|         startTransitioning(element, transition);
   112|       }
   113|       Css.reflow(element);
   114|     }
   115|   } else {
   116|     Classes.remove(element, transition.classes);
   117|   }
   118| };
   119| export {
   120|   getTransitionDuration,
   121|   applyTransitionCss
   122| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/registry/Registry.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| import { Obj, Optional } from '@ephox/katamari';
     2| import { SugarBody, SugarElement } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import { ElementAndHandler, EventRegistry, UidAndHandler } from '../events/EventRegistry';
     5| import * as AlloyLogger from '../log/AlloyLogger';
     6| import * as Tagger from './Tagger';
     7| export interface Registry {
     8|   readonly find: (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
     9|   readonly filter: (type: string) => UidAndHandler[];
    10|   readonly register: (component: AlloyComponent) => void;
    11|   readonly unregister: (component: AlloyComponent) => void;
    12|   readonly getById: (id: string) => Optional<AlloyComponent>;
    13| }
    14| export const Registry = (): Registry => {
    15|   const events = EventRegistry();
    16|   const components: Record<string, AlloyComponent> = { };
    17|   const readOrTag = (component: AlloyComponent): string => {
    18|     const elem = component.element;
    19|     return Tagger.read(elem).getOrThunk(() =>
    20|       Tagger.write('uid-', component.element)
    21|     );
    22|   };
    23|   const failOnDuplicate = (component: AlloyComponent, tagId: string): void => {
    24|     const conflict = components[tagId];
    25|     if (conflict === component) {
    26|       unregister(component);
    27|     } else {
    28|       throw new Error(
    29|         'The tagId "' + tagId + '" is already used by: ' + AlloyLogger.element(conflict.element) + '\nCannot use it for: ' + AlloyLogger.element(component.element) + '\n' +
    30|         'The conflicting element is' + (SugarBody.inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM'
    31|       );
    32|     }
    33|   };
    34|   const register = (component: AlloyComponent): void => {
    35|     const tagId = readOrTag(component);
    36|     if (Obj.hasNonNullableKey(components, tagId)) {
    37|       failOnDuplicate(component, tagId);
    38|     }
    39|     const extraArgs = [ component ];
    40|     events.registerId(extraArgs, tagId, component.events);
    41|     components[tagId] = component;
    42|   };
    43|   const unregister = (component: AlloyComponent): void => {
    44|     Tagger.read(component.element).each((tagId) => {
    45|       delete components[tagId];
    46|       events.unregisterId(tagId);
    47|     });
    48|   };
    49|   const filter = (type: string): UidAndHandler[] => events.filterByType(type);
    50|   const find = (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>): Optional<ElementAndHandler> =>
    51|     events.find(isAboveRoot, type, target);
    52|   const getById = (id: string): Optional<AlloyComponent> => Obj.get(components, id);
    53|   return {
    54|     find,
    55|     filter,
    56|     register,
    57|     unregister,
    58|     getById
    59|   };
    60| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/registry/Tagger.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| import { Fun, Id, Optional } from '@ephox/katamari';
     2| import { SugarElement, SugarNode } from '@ephox/sugar';
     3| import * as AlloyTags from '../ephemera/AlloyTags';
     4| import * as AlloyLogger from '../log/AlloyLogger';
     5| const prefix = AlloyTags.prefix();
     6| const idAttr = AlloyTags.idAttr();
     7| const write = (label: string, elem: SugarElement<Element>): string => {
     8|   const id: string = Id.generate(prefix + label);
     9|   writeOnly(elem, id);
    10|   return id;
    11| };
    12| const writeOnly = (elem: SugarElement<Node>, uid: string | null): void => {
    13|   Object.defineProperty(elem.dom, idAttr, {
    14|     value: uid,
    15|     writable: true
    16|   });
    17| };
    18| const read = (elem: SugarElement<Node>): Optional<string> => {
    19|   const id = SugarNode.isElement(elem) ? (elem.dom as any)[idAttr] : null;
    20|   return Optional.from(id);
    21| };
    22| const readOrDie = (elem: SugarElement<Node>): string => read(elem).getOrDie('Could not find alloy uid in: ' + AlloyLogger.element(elem));
    23| const generate = (prefix: string): string => Id.generate(prefix);
    24| const revoke = (elem: SugarElement<Node>): void => {
    25|   writeOnly(elem, null);
    26| };
    27| const attribute: () => string = Fun.constant(idAttr);
    28| export {
    29|   revoke,
    30|   write,
    31|   writeOnly,
    32|   read,
    33|   readOrDie,
    34|   generate,
    35|   attribute
    36| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/sandbox/Dismissal.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Fun, Optional } from '@ephox/katamari';
     3| import { SugarElement } from '@ephox/sugar';
     4| import { NamedConfiguredBehaviour } from '../api/behaviour/Behaviour';
     5| import { Receiving } from '../api/behaviour/Receiving';
     6| import { Sandboxing } from '../api/behaviour/Sandboxing';
     7| import { AlloyComponent } from '../api/component/ComponentApi';
     8| import * as AlloyTriggers from '../api/events/AlloyTriggers';
     9| import * as SystemEvents from '../api/events/SystemEvents';
    10| import * as Channels from '../api/messages/Channels';
    11| import { ReceivingChannelSpec, ReceivingConfig, ReceivingConfigSpec } from '../behaviour/receiving/ReceivingTypes';
    12| interface DismissalReceivingDetail {
    13|   isExtraPart: (sandbox: AlloyComponent, target: SugarElement<Node>) => boolean;
    14|   fireEventInstead: Optional<{
    15|     event: string;
    16|   }>;
    17| }
    18| export interface DismissalReceivingSpec {
    19|   isExtraPart?: (sandbox: AlloyComponent, target: SugarElement<Node>) => boolean;
    20|   fireEventInstead?: {
    21|     event?: string;
    22|   };
    23| }
    24| const schema = StructureSchema.objOfOnly([
    25|   FieldSchema.defaulted('isExtraPart', Fun.never),
    26|   FieldSchema.optionObjOf('fireEventInstead', [
    27|     FieldSchema.defaulted('event', SystemEvents.dismissRequested())
    28|   ])
    29| ]);
    30| const receivingConfig = (rawSpec: DismissalReceivingSpec): NamedConfiguredBehaviour<ReceivingConfigSpec, ReceivingConfig> => {
    31|   const c = receivingChannel(rawSpec);
    32|   return Receiving.config({
    33|     channels: c
    34|   });
    35| };
    36| const receivingChannel = (rawSpec: DismissalReceivingSpec): Record<string, ReceivingChannelSpec> => {
    37|   const detail: DismissalReceivingDetail = StructureSchema.asRawOrDie('Dismissal', schema, rawSpec);
    38|   return {
    39|     [Channels.dismissPopups()]: {
    40|       schema: StructureSchema.objOfOnly([
    41|         FieldSchema.required('target')
    42|       ]),
    43|       onReceive: (sandbox: AlloyComponent, data: { target: SugarElement<Node> }) => {
    44|         if (Sandboxing.isOpen(sandbox)) {
    45|           const isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
    46|           if (!isPart) {
    47|             detail.fireEventInstead.fold(
    48|               () => Sandboxing.close(sandbox),
    49|               (fe) => AlloyTriggers.emit(sandbox, fe.event)
    50|             );
    51|           }
    52|         }
    53|       }
    54|     }
    55|   };
    56| };
    57| export {
    58|   receivingChannel,
    59|   receivingConfig
    60| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/system/InternalAttachment.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| import { Arr } from '@ephox/katamari';
     2| import { Insert, Remove, SugarBody } from '@ephox/sugar';
     3| import { AlloyComponent } from '../api/component/ComponentApi';
     4| import { AlloySpec } from '../api/component/SpecTypes';
     5| import * as AlloyTriggers from '../api/events/AlloyTriggers';
     6| import * as SystemEvents from '../api/events/SystemEvents';
     7| import * as GuiTypes from '../api/ui/GuiTypes';
     8| const isConnected = (comp: AlloyComponent) =>
     9|   comp.getSystem().isConnected();
    10| const fireDetaching = (component: AlloyComponent): void => {
    11|   AlloyTriggers.emit(component, SystemEvents.detachedFromDom());
    12|   const children = component.components();
    13|   Arr.each(children, fireDetaching);
    14| };
    15| const fireAttaching = (component: AlloyComponent): void => {
    16|   const children = component.components();
    17|   Arr.each(children, fireAttaching);
    18|   AlloyTriggers.emit(component, SystemEvents.attachedToDom());
    19| };
    20| const virtualAttach = (parent: AlloyComponent, child: AlloyComponent): void => {
    21|   parent.getSystem().addToWorld(child);
    22|   if (SugarBody.inBody(parent.element)) {
    23|     fireAttaching(child);
    24|   }
    25| };
    26| const virtualDetach = (comp: AlloyComponent): void => {
    27|   fireDetaching(comp);
    28|   comp.getSystem().removeFromWorld(comp);
    29| };
    30| const attach = (parent: AlloyComponent, child: AlloyComponent): void => {
    31|   Insert.append(parent.element, child.element);
    32| };
    33| const detachChildren = (component: AlloyComponent): void => {
    34|   Arr.each(component.components(), (childComp) => Remove.remove(childComp.element));
    35|   Remove.empty(component.element);
    36|   component.syncComponents();
    37| };
    38| const replaceChildren = (component: AlloyComponent, newSpecs: AlloySpec[], buildNewChildren: (newSpecs: AlloySpec[]) => AlloyComponent[]): void => {
    39|   const subs = component.components();
    40|   detachChildren(component);
    41|   const newChildren = buildNewChildren(newSpecs);
    42|   const deleted = Arr.difference(subs, newChildren);
    43|   Arr.each(deleted, (comp) => {
    44|     fireDetaching(comp);
    45|     component.getSystem().removeFromWorld(comp);
    46|   });
    47|   Arr.each(newChildren, (childComp) => {
    48|     if (!isConnected(childComp)) {
    49|       component.getSystem().addToWorld(childComp);
    50|       attach(component, childComp);
    51|       if (SugarBody.inBody(component.element)) {
    52|         fireAttaching(childComp);
    53|       }
    54|     } else {
    55|       attach(component, childComp);
    56|     }
    57|   });
    58|   component.syncComponents();
    59| };
    60| const virtualReplaceChildren = (component: AlloyComponent, newSpecs: AlloySpec[], buildNewChildren: (newSpecs: AlloySpec[]) => AlloyComponent[]): void => {
    61|   const subs = component.components();
    62|   const existingComps = Arr.bind(newSpecs, (spec) => GuiTypes.getPremade(spec).toArray());
    63|   Arr.each(subs, (childComp) => {
    64|     if (!Arr.contains(existingComps, childComp)) {
    65|       virtualDetach(childComp);
    66|     }
    67|   });
    68|   const newChildren = buildNewChildren(newSpecs);
    69|   const deleted = Arr.difference(subs, newChildren);
    70|   Arr.each(deleted, (deletedComp) => {
    71|     if (isConnected(deletedComp)) {
    72|       virtualDetach(deletedComp);
    73|     }
    74|   });
    75|   Arr.each(newChildren, (childComp) => {
    76|     if (!isConnected(childComp)) {
    77|       virtualAttach(component, childComp);
    78|     } else {
    79|     }
    80|   });
    81|   component.syncComponents();
    82| };
    83| export {
    84|   fireAttaching,
    85|   fireDetaching,
    86|   detachChildren,
    87|   replaceChildren,
    88|   virtualAttach,
    89|   virtualDetach,
    90|   virtualReplaceChildren
    91| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/schema/ModalDialogSchema.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Fun } from '@ephox/katamari';
     3| import { SelectorFind } from '@ephox/sugar';
     4| import * as Boxes from '../../alien/Boxes';
     5| import * as Behaviour from '../../api/behaviour/Behaviour';
     6| import { Dragging } from '../../api/behaviour/Dragging';
     7| import { Keying } from '../../api/behaviour/Keying';
     8| import * as SketchBehaviours from '../../api/component/SketchBehaviours';
     9| import * as Fields from '../../data/Fields';
    10| import * as PartType from '../../parts/PartType';
    11| import { ModalDialogDetail } from '../types/ModalDialogTypes';
    12| const schema = Fun.constant([
    13|   FieldSchema.required('lazySink'),
    14|   FieldSchema.option('dragBlockClass'),
    15|   FieldSchema.defaultedFunction('getBounds', Boxes.win),
    16|   FieldSchema.defaulted('useTabstopAt', Fun.always),
    17|   FieldSchema.defaulted('eventOrder', {}),
    18|   SketchBehaviours.field('modalBehaviours', [ Keying ]),
    19|   Fields.onKeyboardHandler('onExecute'),
    20|   Fields.onStrictKeyboardHandler('onEscape')
    21| ]);
    22| const basic = { sketch: Fun.identity };
    23| const parts: () => PartType.PartTypeAdt[] = Fun.constant([
    24|   PartType.optional<ModalDialogDetail>({
    25|     name: 'draghandle',
    26|     overrides: (detail: ModalDialogDetail, spec) => {
    27|       return {
    28|         behaviours: Behaviour.derive([
    29|           Dragging.config({
    30|             mode: 'mouse',
    31|             getTarget: (handle) => {
    32|               return SelectorFind.ancestor<HTMLElement>(handle, '[role="dialog"]').getOr(handle);
    33|             },
    34|             blockerClass: detail.dragBlockClass.getOrDie(
    35|               new Error(
    36|                 'The drag blocker class was not specified for a dialog with a drag handle: \n' +
    37|                 JSON.stringify(spec, null, 2)
    38|               ).message
    39|             ),
    40|             getBounds: detail.getDragBounds
    41|           })
    42|         ])
    43|       };
    44|     }
    45|   }),
    46|   PartType.required<ModalDialogDetail>({
    47|     schema: [ FieldSchema.required('dom') ],
    48|     name: 'title'
    49|   }),
    50|   PartType.required<ModalDialogDetail>({
    51|     factory: basic,
    52|     schema: [ FieldSchema.required('dom') ],
    53|     name: 'close'
    54|   }),
    55|   PartType.required<ModalDialogDetail>({
    56|     factory: basic,
    57|     schema: [ FieldSchema.required('dom') ],
    58|     name: 'body'
    59|   }),
    60|   PartType.optional<ModalDialogDetail>({
    61|     factory: basic,
    62|     schema: [ FieldSchema.required('dom') ],
    63|     name: 'footer'
    64|   }),
    65|   PartType.external<ModalDialogDetail>({
    66|     factory: {
    67|       sketch: (spec, detail) =>
    68|         ({
    69|           ...spec,
    70|           dom: detail.dom,
    71|           components: detail.components
    72|         })
    73|     },
    74|     schema: [
    75|       FieldSchema.defaulted('dom', {
    76|         tag: 'div',
    77|         styles: {
    78|           position: 'fixed',
    79|           left: '0px',
    80|           top: '0px',
    81|           right: '0px',
    82|           bottom: '0px'
    83|         }
    84|       }),
    85|       FieldSchema.defaulted('components', [ ])
    86|     ],
    87|     name: 'blocker'
    88|   })
    89| ]);
    90| const name = Fun.constant('ModalDialog');
    91| export {
    92|   name,
    93|   schema,
    94|   parts
    95| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/EdgeActions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| import { AlloyComponent } from '../../api/component/ComponentApi';
     2| import * as AlloyTriggers from '../../api/events/AlloyTriggers';
     3| import { SliderValue, SliderValueXY, TwoDSliderDetail } from '../types/SliderTypes';
     4| import * as ModelCommon from './ModelCommon';
     5| import { halfX, halfY, max1X, max1Y, min1X, min1Y } from './SliderValues';
     6| const xyValue = (x: number, y: number): SliderValueXY => ({
     7|   x,
     8|   y
     9| });
    10| const fireSliderChange = (component: AlloyComponent, value: SliderValue): void => {
    11|   AlloyTriggers.emitWith(component, ModelCommon.sliderChangeEvent(), { value });
    12| };
    13| const setToTLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    14|   fireSliderChange(edge, xyValue(min1X(detail), min1Y(detail)));
    15| };
    16| const setToTEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    17|   fireSliderChange(edge, min1Y(detail));
    18| };
    19| const setToTEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    20|   fireSliderChange(edge, xyValue(halfX(detail), min1Y(detail)));
    21| };
    22| const setToTREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    23|   fireSliderChange(edge, xyValue(max1X(detail), min1Y(detail)));
    24| };
    25| const setToREdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    26|   fireSliderChange(edge, max1X(detail));
    27| };
    28| const setToREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    29|   fireSliderChange(edge, xyValue(max1X(detail), halfY(detail)));
    30| };
    31| const setToBREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    32|   fireSliderChange(edge, xyValue(max1X(detail), max1Y(detail)));
    33| };
    34| const setToBEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    35|   fireSliderChange(edge, max1Y(detail));
    36| };
    37| const setToBEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    38|   fireSliderChange(edge, xyValue(halfX(detail), max1Y(detail)));
    39| };
    40| const setToBLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    41|   fireSliderChange(edge, xyValue(min1X(detail), max1Y(detail)));
    42| };
    43| const setToLEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    44|   fireSliderChange(edge, min1X(detail));
    45| };
    46| const setToLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
    47|   fireSliderChange(edge, xyValue(min1X(detail), halfY(detail)));
    48| };
    49| export {
    50|   setToTLEdgeXY,
    51|   setToTEdge,
    52|   setToTEdgeXY,
    53|   setToTREdgeXY,
    54|   setToREdge,
    55|   setToREdgeXY,
    56|   setToBREdgeXY,
    57|   setToBEdge,
    58|   setToBEdgeXY,
    59|   setToBLEdgeXY,
    60|   setToLEdge,
    61|   setToLEdgeXY
    62| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/HorizontalModel.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-126 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Css, Width } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import * as AlloyTriggers from '../../api/events/AlloyTriggers';
     5| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
     6| import { HorizontalSliderDetail, SliderValueX } from '../types/SliderTypes';
     7| import * as EdgeActions from './EdgeActions';
     8| import * as ModelCommon from './ModelCommon';
     9| import * as SliderModel from './SliderModel';
    10| import { getMaxXBounds, getMinXBounds, getXCenterOffSetOf, getXScreenRange } from './SliderOffsets';
    11| import { currentValue, hasLEdge, hasREdge, maxX, minX, rounded, snap, snapStart, step, xRange } from './SliderValues';
    12| const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueX): void => {
    13|   AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
    14| };
    15| const findValueOfOffset = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, left: number): number => {
    16|   const args = {
    17|     min: minX(detail),
    18|     max: maxX(detail),
    19|     range: xRange(detail),
    20|     value: left,
    21|     step: step(detail),
    22|     snap: snap(detail),
    23|     snapStart: snapStart(detail),
    24|     rounded: rounded(detail),
    25|     hasMinEdge: hasLEdge(detail),
    26|     hasMaxEdge: hasREdge(detail),
    27|     minBound: getMinXBounds(spectrum),
    28|     maxBound: getMaxXBounds(spectrum),
    29|     screenRange: getXScreenRange(spectrum)
    30|   };
    31|   return SliderModel.findValueOf(args);
    32| };
    33| const setValueFrom = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, value: number): number => {
    34|   const xValue = findValueOfOffset(spectrum, detail, value);
    35|   const sliderVal = xValue;
    36|   fireSliderChange(spectrum, sliderVal);
    37|   return xValue;
    38| };
    39| const setToMin = (spectrum: AlloyComponent, detail: HorizontalSliderDetail): void => {
    40|   const min = minX(detail);
    41|   fireSliderChange(spectrum, min);
    42| };
    43| const setToMax = (spectrum: AlloyComponent, detail: HorizontalSliderDetail): void => {
    44|   const max = maxX(detail);
    45|   fireSliderChange(spectrum, max);
    46| };
    47| const moveBy = (direction: number, spectrum: AlloyComponent, detail: HorizontalSliderDetail): Optional<number> => {
    48|   const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
    49|   const xValue = f(currentValue(detail), minX(detail), maxX(detail), step(detail));
    50|   fireSliderChange(spectrum, xValue);
    51|   return Optional.some(xValue);
    52| };
    53| const handleMovement = (direction: number) => (spectrum: AlloyComponent, detail: HorizontalSliderDetail): Optional<boolean> =>
    54|   moveBy(direction, spectrum, detail).map<boolean>(Fun.always);
    55| const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<number> => {
    56|   const pos = ModelCommon.getEventSource(simulatedEvent);
    57|   return pos.map((p) => p.left);
    58| };
    59| const findOffsetOfValue = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>): number => {
    60|   const minOffset = 0;
    61|   const maxOffset = getXScreenRange(spectrum);
    62|   const centerMinEdge = minEdge.bind((edge: AlloyComponent) =>
    63|     Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(minOffset);
    64|   const centerMaxEdge = maxEdge.bind((edge: AlloyComponent) =>
    65|     Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
    66|   const args = {
    67|     min: minX(detail),
    68|     max: maxX(detail),
    69|     range: xRange(detail),
    70|     value,
    71|     hasMinEdge: hasLEdge(detail),
    72|     hasMaxEdge: hasREdge(detail),
    73|     minBound: getMinXBounds(spectrum),
    74|     minOffset,
    75|     maxBound: getMaxXBounds(spectrum),
    76|     maxOffset,
    77|     centerMinEdge,
    78|     centerMaxEdge
    79|   };
    80|   return SliderModel.findOffsetOfValue(args);
    81| };
    82| const findPositionOfValue = (slider: AlloyComponent, spectrum: AlloyComponent, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>, detail: HorizontalSliderDetail): number => {
    83|   const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
    84|   return (getMinXBounds(spectrum) - getMinXBounds(slider)) + offset;
    85| };
    86| const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: HorizontalSliderDetail, edges: any): void => {
    87|   const value = currentValue(detail);
    88|   const pos = findPositionOfValue(
    89|     slider,
    90|     edges.getSpectrum(slider),
    91|     value,
    92|     edges.getLeftEdge(slider),
    93|     edges.getRightEdge(slider),
    94|     detail
    95|   );
    96|   const thumbRadius = Width.get(thumb.element) / 2;
    97|   Css.set(thumb.element, 'left', (pos - thumbRadius) + 'px');
    98| };
    99| const onLeft = handleMovement(-1);
   100| const onRight = handleMovement(1);
   101| const onUp = Optional.none;
   102| const onDown = Optional.none;
   103| const edgeActions = {
   104|   'top-left': Optional.none(),
   105|   'top': Optional.none(),
   106|   'top-right': Optional.none(),
   107|   'right': Optional.some(EdgeActions.setToREdge),
   108|   'bottom-right': Optional.none(),
   109|   'bottom': Optional.none(),
   110|   'bottom-left': Optional.none(),
   111|   'left': Optional.some(EdgeActions.setToLEdge)
   112| };
   113| export {
   114|   setValueFrom,
   115|   setToMin,
   116|   setToMax,
   117|   findValueOfOffset,
   118|   getValueFromEvent,
   119|   findPositionOfValue,
   120|   setPositionFromValue,
   121|   onLeft,
   122|   onRight,
   123|   onUp,
   124|   onDown,
   125|   edgeActions
   126| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/SliderParts.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-113 ---
     1| import { FieldSchema } from '@ephox/boulder';
     2| import { Cell, Fun } from '@ephox/katamari';
     3| import { EventArgs, SugarPosition } from '@ephox/sugar';
     4| import * as Behaviour from '../../api/behaviour/Behaviour';
     5| import { Focusing } from '../../api/behaviour/Focusing';
     6| import { Keying } from '../../api/behaviour/Keying';
     7| import { AlloyComponent } from '../../api/component/ComponentApi';
     8| import { OptionalDomSchema } from '../../api/component/SpecTypes';
     9| import * as AlloyEvents from '../../api/events/AlloyEvents';
    10| import * as NativeEvents from '../../api/events/NativeEvents';
    11| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
    12| import * as PartType from '../../parts/PartType';
    13| import { EdgeActions, SliderDetail } from '../types/SliderTypes';
    14| const labelPart = PartType.optional({
    15|   schema: [ FieldSchema.required('dom') ],
    16|   name: 'label'
    17| });
    18| const edgePart = (name: keyof EdgeActions): PartType.PartTypeAdt => PartType.optional({
    19|   name: '' + name + '-edge',
    20|   overrides: (detail: SliderDetail) => {
    21|     const action = detail.model.manager.edgeActions[name];
    22|     return action.fold(() => ({}),
    23|       (a) => ({
    24|         events: AlloyEvents.derive([
    25|           AlloyEvents.runActionExtra(NativeEvents.touchstart(), (comp, se, d) => a(comp, d), [ detail ]),
    26|           AlloyEvents.runActionExtra(NativeEvents.mousedown(), (comp, se, d) => a(comp, d), [ detail ]),
    27|           AlloyEvents.runActionExtra(NativeEvents.mousemove(), (comp, se, det: SliderDetail) => {
    28|             if (det.mouseIsDown.get()) {
    29|               a(comp, det);
    30|             }
    31|           }, [ detail ])
    32|         ])
    33|       })
    34|     );
    35|   }
    36| });
    37| const tlEdgePart = edgePart('top-left');
    38| const tedgePart = edgePart('top');
    39| const trEdgePart = edgePart('top-right');
    40| const redgePart = edgePart('right');
    41| const brEdgePart = edgePart('bottom-right');
    42| const bedgePart = edgePart('bottom');
    43| const blEdgePart = edgePart('bottom-left');
    44| const ledgePart = edgePart('left');
    45| const thumbPart = PartType.required<SliderDetail, { dom: OptionalDomSchema; events: AlloyEvents.AlloyEventRecord }>({
    46|   name: 'thumb',
    47|   defaults: Fun.constant({
    48|     dom: {
    49|       styles: { position: 'absolute' }
    50|     }
    51|   }),
    52|   overrides: (detail) => {
    53|     return {
    54|       events: AlloyEvents.derive([
    55|         AlloyEvents.redirectToPart(NativeEvents.touchstart(), detail, 'spectrum'),
    56|         AlloyEvents.redirectToPart(NativeEvents.touchmove(), detail, 'spectrum'),
    57|         AlloyEvents.redirectToPart(NativeEvents.touchend(), detail, 'spectrum'),
    58|         AlloyEvents.redirectToPart(NativeEvents.mousedown(), detail, 'spectrum'),
    59|         AlloyEvents.redirectToPart(NativeEvents.mousemove(), detail, 'spectrum'),
    60|         AlloyEvents.redirectToPart(NativeEvents.mouseup(), detail, 'spectrum')
    61|       ])
    62|     };
    63|   }
    64| });
    65| const spectrumPart = PartType.required({
    66|   schema: [
    67|     FieldSchema.customField('mouseIsDown', () => Cell(false))
    68|   ],
    69|   name: 'spectrum',
    70|   overrides: (detail: SliderDetail) => {
    71|     const modelDetail = detail.model;
    72|     const model = modelDetail.manager;
    73|     const setValueFrom = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>) =>
    74|       model.getValueFromEvent(simulatedEvent).map((value: number | SugarPosition) => model.setValueFrom(component, detail, value));
    75|     return {
    76|       behaviours: Behaviour.derive([
    77|         Keying.config(
    78|           {
    79|             mode: 'special',
    80|             onLeft: (spectrum) => model.onLeft(spectrum, detail),
    81|             onRight: (spectrum) => model.onRight(spectrum, detail),
    82|             onUp: (spectrum) => model.onUp(spectrum, detail),
    83|             onDown: (spectrum) => model.onDown(spectrum, detail)
    84|           }
    85|         ),
    86|         Focusing.config({})
    87|       ]),
    88|       events: AlloyEvents.derive([
    89|         AlloyEvents.run(NativeEvents.touchstart(), setValueFrom),
    90|         AlloyEvents.run(NativeEvents.touchmove(), setValueFrom),
    91|         AlloyEvents.run(NativeEvents.mousedown(), setValueFrom),
    92|         AlloyEvents.run<EventArgs<MouseEvent>>(NativeEvents.mousemove(), (spectrum, se) => {
    93|           if (detail.mouseIsDown.get()) {
    94|             setValueFrom(spectrum, se);
    95|           }
    96|         })
    97|       ])
    98|     };
    99|   }
   100| });
   101| export default [
   102|   labelPart,
   103|   ledgePart,
   104|   redgePart,
   105|   tedgePart,
   106|   bedgePart,
   107|   tlEdgePart,
   108|   trEdgePart,
   109|   blEdgePart,
   110|   brEdgePart,
   111|   thumbPart,
   112|   spectrumPart
   113| ] as PartType.PartTypeAdt[];


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/SliderUi.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-137 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Keying } from '../../api/behaviour/Keying';
     3| import { Receiving } from '../../api/behaviour/Receiving';
     4| import { Representing } from '../../api/behaviour/Representing';
     5| import { AlloyComponent } from '../../api/component/ComponentApi';
     6| import * as SketchBehaviours from '../../api/component/SketchBehaviours';
     7| import { AlloySpec } from '../../api/component/SpecTypes';
     8| import * as AlloyEvents from '../../api/events/AlloyEvents';
     9| import * as NativeEvents from '../../api/events/NativeEvents';
    10| import * as Channels from '../../api/messages/Channels';
    11| import { CompositeSketchFactory } from '../../api/ui/UiSketcher';
    12| import { EventFormat, NativeSimulatedEvent } from '../../events/SimulatedEvent';
    13| import * as AlloyParts from '../../parts/AlloyParts';
    14| import { SliderDetail, SliderSpec, SliderUpdateEvent, SliderValue } from '../types/SliderTypes';
    15| import * as ModelCommon from './ModelCommon';
    16| const sketch: CompositeSketchFactory<SliderDetail, SliderSpec> = (detail: SliderDetail, components: AlloySpec[], _spec: SliderSpec, _externals) => {
    17|   const getThumb = (component: AlloyComponent): AlloyComponent => AlloyParts.getPartOrDie(component, detail, 'thumb');
    18|   const getSpectrum = (component: AlloyComponent): AlloyComponent => AlloyParts.getPartOrDie(component, detail, 'spectrum');
    19|   const getLeftEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'left-edge');
    20|   const getRightEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'right-edge');
    21|   const getTopEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'top-edge');
    22|   const getBottomEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'bottom-edge');
    23|   const modelDetail = detail.model;
    24|   const model = modelDetail.manager;
    25|   const refresh = (slider: AlloyComponent, thumb: AlloyComponent): void => {
    26|     model.setPositionFromValue(slider, thumb, detail, {
    27|       getLeftEdge,
    28|       getRightEdge,
    29|       getTopEdge,
    30|       getBottomEdge,
    31|       getSpectrum
    32|     });
    33|   };
    34|   const setValue = (slider: AlloyComponent, newValue: SliderValue): void => {
    35|     modelDetail.value.set(newValue);
    36|     const thumb = getThumb(slider);
    37|     refresh(slider, thumb);
    38|   };
    39|   const changeValue = (slider: AlloyComponent, newValue: SliderValue): Optional<boolean> => {
    40|     setValue(slider, newValue);
    41|     const thumb = getThumb(slider);
    42|     detail.onChange(slider, thumb, newValue);
    43|     return Optional.some<boolean>(true);
    44|   };
    45|   const resetToMin = (slider: AlloyComponent) => {
    46|     model.setToMin(slider, detail);
    47|   };
    48|   const resetToMax = (slider: AlloyComponent) => {
    49|     model.setToMax(slider, detail);
    50|   };
    51|   const choose = (slider: AlloyComponent) => {
    52|     const fireOnChoose = () => {
    53|       AlloyParts.getPart(slider, detail, 'thumb').each((thumb) => {
    54|         const value = modelDetail.value.get();
    55|         detail.onChoose(slider, thumb, value);
    56|       });
    57|     };
    58|     const wasDown = detail.mouseIsDown.get();
    59|     detail.mouseIsDown.set(false);
    60|     if (wasDown) {
    61|       fireOnChoose();
    62|     }
    63|   };
    64|   const onDragStart = (slider: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => {
    65|     simulatedEvent.stop();
    66|     detail.mouseIsDown.set(true);
    67|     detail.onDragStart(slider, getThumb(slider));
    68|   };
    69|   const onDragEnd = (slider: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => {
    70|     simulatedEvent.stop();
    71|     detail.onDragEnd(slider, getThumb(slider));
    72|     choose(slider);
    73|   };
    74|   return {
    75|     uid: detail.uid,
    76|     dom: detail.dom,
    77|     components,
    78|     behaviours: SketchBehaviours.augment(
    79|       detail.sliderBehaviours,
    80|       [
    81|         Keying.config({
    82|           mode: 'special',
    83|           focusIn: (slider) => {
    84|             return AlloyParts.getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(Fun.always);
    85|           }
    86|         }),
    87|         Representing.config({
    88|           store: {
    89|             mode: 'manual',
    90|             getValue: (_) => {
    91|               return modelDetail.value.get();
    92|             },
    93|             setValue
    94|           }
    95|         }),
    96|         Receiving.config({
    97|           channels: {
    98|             [Channels.mouseReleased()]: {
    99|               onReceive: choose
   100|             }
   101|           }
   102|         })
   103|       ]
   104|     ),
   105|     events: AlloyEvents.derive([
   106|       AlloyEvents.run<SliderUpdateEvent>(ModelCommon.sliderChangeEvent(), (slider, simulatedEvent) => {
   107|         changeValue(slider, simulatedEvent.event.value);
   108|       }) as AlloyEvents.AlloyEventKeyAndHandler<EventFormat>,
   109|       AlloyEvents.runOnAttached((slider, _simulatedEvent) => {
   110|         const getInitial = modelDetail.getInitialValue();
   111|         modelDetail.value.set(getInitial);
   112|         const thumb = getThumb(slider);
   113|         refresh(slider, thumb);
   114|         const spectrum = getSpectrum(slider);
   115|         detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
   116|       }),
   117|       AlloyEvents.run(NativeEvents.touchstart(), onDragStart),
   118|       AlloyEvents.run(NativeEvents.touchend(), onDragEnd),
   119|       AlloyEvents.run(NativeEvents.mousedown(), onDragStart),
   120|       AlloyEvents.run(NativeEvents.mouseup(), onDragEnd)
   121|     ]),
   122|     apis: {
   123|       resetToMin,
   124|       resetToMax,
   125|       setValue,
   126|       refresh
   127|     },
   128|     domModification: {
   129|       styles: {
   130|         position: 'relative'
   131|       }
   132|     }
   133|   };
   134| };
   135| export {
   136|   sketch
   137| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/TwoDModel.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-98 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Css, Height, SugarPosition, Width } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import * as AlloyTriggers from '../../api/events/AlloyTriggers';
     5| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
     6| import { SliderModelDetailParts, SliderValueXY, TwoDSliderDetail } from '../types/SliderTypes';
     7| import * as EdgeActions from './EdgeActions';
     8| import * as HorizontalModel from './HorizontalModel';
     9| import * as ModelCommon from './ModelCommon';
    10| import * as SliderModel from './SliderModel';
    11| import { currentValue, maxX, maxY, minX, minY, step } from './SliderValues';
    12| import * as VerticalModel from './VerticalModel';
    13| const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueXY): void => {
    14|   AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
    15| };
    16| const sliderValue = (x: number, y: number): SliderValueXY => ({
    17|   x,
    18|   y
    19| });
    20| const setValueFrom = (spectrum: AlloyComponent, detail: TwoDSliderDetail, value: SugarPosition): SliderValueXY => {
    21|   const xValue = HorizontalModel.findValueOfOffset(spectrum, detail, value.left);
    22|   const yValue = VerticalModel.findValueOfOffset(spectrum, detail, value.top);
    23|   const val = sliderValue(xValue, yValue);
    24|   fireSliderChange(spectrum, val);
    25|   return val;
    26| };
    27| const moveBy = (direction: number, isVerticalMovement: boolean, spectrum: AlloyComponent, detail: TwoDSliderDetail): Optional<number> => {
    28|   const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
    29|   const xValue = isVerticalMovement ? currentValue(detail).x :
    30|     f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
    31|   const yValue = !isVerticalMovement ? currentValue(detail).y :
    32|     f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));
    33|   fireSliderChange(spectrum, sliderValue(xValue, yValue));
    34|   return Optional.some(xValue);
    35| };
    36| const handleMovement = (direction: number, isVerticalMovement: boolean) => (spectrum: AlloyComponent, detail: TwoDSliderDetail): Optional<boolean> =>
    37|   moveBy(direction, isVerticalMovement, spectrum, detail).map<boolean>(Fun.always);
    38| const setToMin = (spectrum: AlloyComponent, detail: TwoDSliderDetail): void => {
    39|   const mX = minX(detail);
    40|   const mY = minY(detail);
    41|   fireSliderChange(spectrum, sliderValue(mX, mY));
    42| };
    43| const setToMax = (spectrum: AlloyComponent, detail: TwoDSliderDetail): void => {
    44|   const mX = maxX(detail);
    45|   const mY = maxY(detail);
    46|   fireSliderChange(spectrum, sliderValue(mX, mY));
    47| };
    48| const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<SugarPosition> =>
    49|   ModelCommon.getEventSource(simulatedEvent);
    50| const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: TwoDSliderDetail, edges: SliderModelDetailParts): void => {
    51|   const value = currentValue(detail);
    52|   const xPos = HorizontalModel.findPositionOfValue(
    53|     slider,
    54|     edges.getSpectrum(slider),
    55|     value.x,
    56|     edges.getLeftEdge(slider),
    57|     edges.getRightEdge(slider),
    58|     detail
    59|   );
    60|   const yPos = VerticalModel.findPositionOfValue(
    61|     slider,
    62|     edges.getSpectrum(slider),
    63|     value.y,
    64|     edges.getTopEdge(slider),
    65|     edges.getBottomEdge(slider),
    66|     detail
    67|   );
    68|   const thumbXRadius = Width.get(thumb.element) / 2;
    69|   const thumbYRadius = Height.get(thumb.element) / 2;
    70|   Css.set(thumb.element, 'left', (xPos - thumbXRadius) + 'px');
    71|   Css.set(thumb.element, 'top', (yPos - thumbYRadius) + 'px');
    72| };
    73| const onLeft = handleMovement(-1, false);
    74| const onRight = handleMovement(1, false);
    75| const onUp = handleMovement(-1, true);
    76| const onDown = handleMovement(1, true);
    77| const edgeActions = {
    78|   'top-left': Optional.some(EdgeActions.setToTLEdgeXY),
    79|   'top': Optional.some(EdgeActions.setToTEdgeXY),
    80|   'top-right': Optional.some(EdgeActions.setToTREdgeXY),
    81|   'right': Optional.some(EdgeActions.setToREdgeXY),
    82|   'bottom-right': Optional.some(EdgeActions.setToBREdgeXY),
    83|   'bottom': Optional.some(EdgeActions.setToBEdgeXY),
    84|   'bottom-left': Optional.some(EdgeActions.setToBLEdgeXY),
    85|   'left': Optional.some(EdgeActions.setToLEdgeXY)
    86| };
    87| export {
    88|   setValueFrom,
    89|   setToMin,
    90|   setToMax,
    91|   getValueFromEvent,
    92|   setPositionFromValue,
    93|   onLeft,
    94|   onRight,
    95|   onUp,
    96|   onDown,
    97|   edgeActions
    98| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/slider/VerticalModel.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| import { Fun, Optional } from '@ephox/katamari';
     2| import { Css, Height } from '@ephox/sugar';
     3| import { AlloyComponent } from '../../api/component/ComponentApi';
     4| import * as AlloyTriggers from '../../api/events/AlloyTriggers';
     5| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
     6| import { SliderValueY, VerticalSliderDetail } from '../types/SliderTypes';
     7| import * as EdgeActions from './EdgeActions';
     8| import * as ModelCommon from './ModelCommon';
     9| import * as SliderModel from './SliderModel';
    10| import { getMaxYBounds, getMinYBounds, getYCenterOffSetOf, getYScreenRange } from './SliderOffsets';
    11| import { currentValue, hasBEdge, hasTEdge, maxY, minY, rounded, snap, snapStart, step, yRange } from './SliderValues';
    12| const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueY): void => {
    13|   AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
    14| };
    15| const findValueOfOffset = (spectrum: AlloyComponent, detail: VerticalSliderDetail, top: number): number => {
    16|   const args = {
    17|     min: minY(detail),
    18|     max: maxY(detail),
    19|     range: yRange(detail),
    20|     value: top,
    21|     step: step(detail),
    22|     snap: snap(detail),
    23|     snapStart: snapStart(detail),
    24|     rounded: rounded(detail),
    25|     hasMinEdge: hasTEdge(detail),
    26|     hasMaxEdge: hasBEdge(detail),
    27|     minBound: getMinYBounds(spectrum),
    28|     maxBound: getMaxYBounds(spectrum),
    29|     screenRange: getYScreenRange(spectrum)
    30|   };
    31|   return SliderModel.findValueOf(args);
    32| };
    33| const setValueFrom = (spectrum: AlloyComponent, detail: VerticalSliderDetail, value: number): number => {
    34|   const yValue = findValueOfOffset(spectrum, detail, value);
    35|   const sliderVal = yValue;
    36|   fireSliderChange(spectrum, sliderVal);
    37|   return yValue;
    38| };
    39| const setToMin = (spectrum: AlloyComponent, detail: VerticalSliderDetail): void => {
    40|   const min = minY(detail);
    41|   fireSliderChange(spectrum, min);
    42| };
    43| const setToMax = (spectrum: AlloyComponent, detail: VerticalSliderDetail): void => {
    44|   const max = maxY(detail);
    45|   fireSliderChange(spectrum, max);
    46| };
    47| const moveBy = (direction: number, spectrum: AlloyComponent, detail: VerticalSliderDetail): Optional<number> => {
    48|   const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
    49|   const yValue = f(currentValue(detail), minY(detail), maxY(detail), step(detail));
    50|   fireSliderChange(spectrum, yValue);
    51|   return Optional.some(yValue);
    52| };
    53| const handleMovement = (direction: number) => (spectrum: AlloyComponent, detail: VerticalSliderDetail): Optional<boolean> =>
    54|   moveBy(direction, spectrum, detail).map<boolean>(Fun.always);
    55| const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<number> => {
    56|   const pos = ModelCommon.getEventSource(simulatedEvent);
    57|   return pos.map((p) => {
    58|     return p.top;
    59|   });
    60| };
    61| const findOffsetOfValue = (spectrum: AlloyComponent, detail: VerticalSliderDetail, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>): number => {
    62|   const minOffset = 0;
    63|   const maxOffset = getYScreenRange(spectrum);
    64|   const centerMinEdge = minEdge.bind((edge: AlloyComponent) =>
    65|     Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(minOffset);
    66|   const centerMaxEdge = maxEdge.bind((edge: AlloyComponent) =>
    67|     Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
    68|   const args = {
    69|     min: minY(detail),
    70|     max: maxY(detail),
    71|     range: yRange(detail),
    72|     value,
    73|     hasMinEdge: hasTEdge(detail),
    74|     hasMaxEdge: hasBEdge(detail),
    75|     minBound: getMinYBounds(spectrum),
    76|     minOffset,
    77|     maxBound: getMaxYBounds(spectrum),
    78|     maxOffset,
    79|     centerMinEdge,
    80|     centerMaxEdge
    81|   };
    82|   return SliderModel.findOffsetOfValue(args);
    83| };
    84| const findPositionOfValue = (slider: AlloyComponent, spectrum: AlloyComponent, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>, detail: VerticalSliderDetail): number => {
    85|   const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
    86|   return (getMinYBounds(spectrum) - getMinYBounds(slider)) + offset;
    87| };
    88| const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: VerticalSliderDetail, edges: any): void => {
    89|   const value = currentValue(detail);
    90|   const pos = findPositionOfValue(
    91|     slider,
    92|     edges.getSpectrum(slider),
    93|     value,
    94|     edges.getTopEdge(slider),
    95|     edges.getBottomEdge(slider),
    96|     detail
    97|   );
    98|   const thumbRadius = Height.get(thumb.element) / 2;
    99|   Css.set(thumb.element, 'top', (pos - thumbRadius) + 'px');
   100| };
   101| const onLeft = Optional.none;
   102| const onRight = Optional.none;
   103| const onUp = handleMovement(-1);
   104| const onDown = handleMovement(1);
   105| const edgeActions = {
   106|   'top-left': Optional.none(),
   107|   'top': Optional.some(EdgeActions.setToTEdge),
   108|   'top-right': Optional.none(),
   109|   'right': Optional.none(),
   110|   'bottom-right': Optional.none(),
   111|   'bottom': Optional.some(EdgeActions.setToBEdge),
   112|   'bottom-left': Optional.none(),
   113|   'left': Optional.none()
   114| };
   115| export {
   116|   setValueFrom,
   117|   setToMin,
   118|   setToMax,
   119|   findValueOfOffset,
   120|   getValueFromEvent,
   121|   findPositionOfValue,
   122|   setPositionFromValue,
   123|   onLeft,
   124|   onRight,
   125|   onUp,
   126|   onDown,
   127|   edgeActions
   128| };


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/types/InlineViewTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-67 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
     5| import { LazySink } from '../../api/component/CommonTypes';
     6| import { AlloyComponent } from '../../api/component/ComponentApi';
     7| import { SketchBehaviours } from '../../api/component/SketchBehaviours';
     8| import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
     9| import { SingleSketch, SingleSketchDetail, SingleSketchSpec } from '../../api/ui/Sketcher';
    10| import { PlacementSpec } from '../../behaviour/positioning/PositioningTypes';
    11| import { TieredData, TieredMenuSpec } from './TieredMenuTypes';
    12| export interface InlineViewDetail extends SingleSketchDetail {
    13|   uid: string;
    14|   dom: RawDomSchema;
    15|   components: AlloySpec[ ];
    16|   inlineBehaviours: SketchBehaviours;
    17|   onShow: (component: AlloyComponent) => void;
    18|   onHide: (component: AlloyComponent) => void;
    19|   onEscape: Optional<(component: AlloyComponent) => void>;
    20|   getRelated: (component: AlloyComponent) => Optional<AlloyComponent>;
    21|   isExtraPart: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
    22|   lazySink: LazySink;
    23|   eventOrder: Record<string, string[]>;
    24|   fireDismissalEventInstead: Optional<{
    25|     event: string;
    26|   }>;
    27|   fireRepositionEventInstead: Optional<{
    28|     event: string;
    29|   }>;
    30| }
    31| export interface InlineViewSpec extends SingleSketchSpec {
    32|   uid?: string;
    33|   dom: RawDomSchema;
    34|   components?: AlloySpec[];
    35|   inlineBehaviours?: AlloyBehaviourRecord;
    36|   lazySink: LazySink;
    37|   onShow?: (component: AlloyComponent) => void;
    38|   onHide?: (component: AlloyComponent) => void;
    39|   onEscape?: (component: AlloyComponent) => void;
    40|   getRelated?: (component: AlloyComponent) => Optional<AlloyComponent>;
    41|   isExtraPart?: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
    42|   eventOrder?: Record<string, string[]>;
    43|   fireDismissalEventInstead?: {
    44|     event?: string;
    45|   };
    46|   fireRepositionEventInstead?: {
    47|     event?: string;
    48|   };
    49| }
    50| export interface InlineMenuSpec {
    51|   data: TieredData;
    52|   menu: Partial<TieredMenuSpec> & { markers: TieredMenuSpec['markers'] };
    53|   type?: 'vertical' | 'horizontal';
    54| }
    55| export interface InlineViewApis {
    56|   showAt: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec) => void;
    57|   showWithin: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => void;
    58|   showWithinBounds: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, getBounds: () => Optional<Bounds>) => void;
    59|   showMenuAt: (component: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec) => void;
    60|   showMenuWithinBounds: (component: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Bounds>) => void;
    61|   hide: (component: AlloyComponent) => void;
    62|   isOpen: (component: AlloyComponent) => boolean;
    63|   getContent: (component: AlloyComponent) => Optional<AlloyComponent>;
    64|   setContent: (component: AlloyComponent, thing: AlloySpec) => void;
    65|   reposition: (component: AlloyComponent) => void;
    66| }
    67| export interface InlineViewSketcher extends SingleSketch<InlineViewSpec>, InlineViewApis { }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/types/ModalDialogTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| import { Optional } from '@ephox/katamari';
     2| import { SugarElement } from '@ephox/sugar';
     3| import { Bounds } from '../../alien/Boxes';
     4| import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
     5| import { LazySink } from '../../api/component/CommonTypes';
     6| import { AlloyComponent } from '../../api/component/ComponentApi';
     7| import { SketchBehaviours } from '../../api/component/SketchBehaviours';
     8| import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
     9| import { CompositeSketch, CompositeSketchDetail, CompositeSketchSpec } from '../../api/ui/Sketcher';
    10| import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
    11| export interface ModalDialogDetail extends CompositeSketchDetail {
    12|   uid: string;
    13|   dom: RawDomSchema;
    14|   components: AlloySpec[ ];
    15|   modalBehaviours: SketchBehaviours;
    16|   eventOrder: Record<string, string[]>;
    17|   onExecute: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
    18|   onEscape: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
    19|   useTabstopAt: (elem: SugarElement<HTMLElement>) => boolean;
    20|   lazySink: LazySink;
    21|   dragBlockClass: Optional<string>;
    22|   getDragBounds: () => Bounds;
    23| }
    24| export interface ModalDialogSpec extends CompositeSketchSpec {
    25|   uid?: string;
    26|   dom: RawDomSchema;
    27|   components?: AlloySpec[];
    28|   modalBehaviours?: AlloyBehaviourRecord;
    29|   eventOrder?: Record<string, string[]>;
    30|   lazySink?: LazySink;
    31|   useTabstopAt?: (comp: SugarElement<HTMLElement>) => boolean;
    32|   onExecute?: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
    33|   onEscape?: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
    34|   dragBlockClass?: string;
    35|   getDragBounds?: () => Bounds;
    36|   parts: {
    37|     blocker: {
    38|       dom?: Partial<RawDomSchema>;
    39|       components?: AlloySpec[];
    40|     };
    41|   };
    42| }
    43| export type GetBusySpec = (
    44|   dlg: AlloyComponent,
    45|   busyBehaviours: AlloyBehaviourRecord
    46| ) => AlloySpec;
    47| export interface ModalDialogApis {
    48|   show: (dialog: AlloyComponent) => void;
    49|   hide: (dialog: AlloyComponent) => void;
    50|   getBody: (dialog: AlloyComponent) => AlloyComponent;
    51|   getFooter: (dialog: AlloyComponent) => AlloyComponent;
    52|   setBusy: (dialog: AlloyComponent, getBusySpec: GetBusySpec) => void;
    53|   setIdle: (dialog: AlloyComponent) => void;
    54| }
    55| export interface ModalDialogSketcher extends CompositeSketch<ModalDialogSpec>, ModalDialogApis { }


# ====================================================================
# FILE: modules/alloy/src/main/ts/ephox/alloy/ui/types/SliderTypes.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-139 ---
     1| import { Cell, Optional } from '@ephox/katamari';
     2| import { SugarPosition } from '@ephox/sugar';
     3| import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
     4| import { AlloyComponent } from '../../api/component/ComponentApi';
     5| import { SketchBehaviours } from '../../api/component/SketchBehaviours';
     6| import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
     7| import { CompositeSketch, CompositeSketchDetail, CompositeSketchSpec } from '../../api/ui/Sketcher';
     8| import { CustomEvent, NativeSimulatedEvent } from '../../events/SimulatedEvent';
     9| export type SliderValueX = number;
    10| export type SliderValueY = number;
    11| export interface SliderValueXY {
    12|   readonly x: number;
    13|   readonly y: number;
    14| }
    15| export type SliderValue = SliderValueX | SliderValueY | SliderValueXY;
    16| export interface SliderUpdateEvent extends CustomEvent {
    17|   value: SliderValue;
    18| }
    19| export interface SliderModelDetailParts {
    20|   getSpectrum: (component: AlloyComponent) => AlloyComponent;
    21|   getLeftEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
    22|   getRightEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
    23|   getTopEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
    24|   getBottomEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
    25| }
    26| export interface EdgeActions {
    27|   'top-left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    28|   'top': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    29|   'top-right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    30|   'right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    31|   'bottom-right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    32|   'bottom': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    33|   'bottom-left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    34|   'left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
    35| }
    36| export interface Manager {
    37|   setValueFrom: (spectrum: AlloyComponent, detail: SliderDetail, value: number | SugarPosition) => void;
    38|   setToMin: (spectrum: AlloyComponent, detail: SliderDetail) => void;
    39|   setToMax: (spectrum: AlloyComponent, detail: SliderDetail) => void;
    40|   getValueFromEvent: (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>) => Optional<number | SugarPosition>;
    41|   setPositionFromValue: (slider: AlloyComponent, thumb: AlloyComponent, detail: SliderDetail, parts: SliderModelDetailParts) => void;
    42|   onLeft: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
    43|   onRight: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
    44|   onUp: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
    45|   onDown: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
    46|   edgeActions: EdgeActions;
    47| }
    48| export interface SliderModelDetail {
    49|   minX?: number;
    50|   maxX?: number;
    51|   minY?: number;
    52|   maxY?: number;
    53|   value: Cell<SliderValue>;
    54|   getInitialValue: () => SliderValue;
    55|   manager: Manager;
    56| }
    57| export interface VerticalSliderModelDetail extends SliderModelDetail {
    58|   minY: number;
    59|   maxY: number;
    60| }
    61| export interface HorizontalSliderModelDetail extends SliderModelDetail {
    62|   minX: number;
    63|   maxX: number;
    64| }
    65| export interface TwoDSliderModelDetail extends SliderModelDetail {
    66|   minX: number;
    67|   maxX: number;
    68|   minY: number;
    69|   maxY: number;
    70| }
    71| export interface SliderDetail extends CompositeSketchDetail {
    72|   uid: string;
    73|   dom: RawDomSchema;
    74|   components: AlloySpec[];
    75|   sliderBehaviours: SketchBehaviours;
    76|   model: SliderModelDetail;
    77|   rounded: boolean;
    78|   stepSize: number;
    79|   snapToGrid: boolean;
    80|   snapStart: Optional<number>;
    81|   onChange: (component: AlloyComponent, thumb: AlloyComponent, value: number | SliderValue) => void;
    82|   onChoose: (component: AlloyComponent, thumb: AlloyComponent, value: number | SliderValue) => void;
    83|   onDragStart: (component: AlloyComponent, thumb: AlloyComponent) => void;
    84|   onDragEnd: (component: AlloyComponent, thumb: AlloyComponent) => void;
    85|   onInit: (component: AlloyComponent, thumb: AlloyComponent, spectrum: AlloyComponent, value: number | SliderValue) => void;
    86|   mouseIsDown: Cell<boolean>;
    87| }
    88| export interface VerticalSliderDetail extends SliderDetail {
    89|   model: VerticalSliderModelDetail;
    90| }
    91| export interface HorizontalSliderDetail extends SliderDetail {
    92|   model: HorizontalSliderModelDetail;
    93| }
    94| export interface TwoDSliderDetail extends SliderDetail {
    95|   model: TwoDSliderModelDetail;
    96| }
    97| export interface HorizontalSliderSpecMode {
    98|   mode: 'x';
    99|   minX?: number;
   100|   maxX?: number;
   101|   getInitialValue: () => SliderValueX;
   102| }
   103| export interface VerticalSliderSpecMode {
   104|   mode: 'y';
   105|   minY?: number;
   106|   maxY?: number;
   107|   getInitialValue: () => SliderValueY;
   108| }
   109| export interface TwoDSliderSpecMode {
   110|   mode: 'xy';
   111|   minX?: number;
   112|   maxX?: number;
   113|   minY?: number;
   114|   maxY?: number;
   115|   getInitialValue: () => SliderValueXY;
   116| }
   117| export interface SliderSpec extends CompositeSketchSpec {
   118|   uid?: string;
   119|   dom: RawDomSchema;
   120|   components?: AlloySpec[];
   121|   sliderBehaviours?: AlloyBehaviourRecord;
   122|   model: HorizontalSliderSpecMode | VerticalSliderSpecMode | TwoDSliderSpecMode;
   123|   stepSize?: number;
   124|   snapToGrid?: boolean;
   125|   snapStart?: number;
   126|   rounded?: boolean;
   127|   onChange?: (component: AlloyComponent, thumb: AlloyComponent, value: SliderValue) => void;
   128|   onChoose?: (component: AlloyComponent, thumb: AlloyComponent, value: SliderValue) => void;
   129|   onDragStart?: (component: AlloyComponent, thumb: AlloyComponent) => void;
   130|   onDragEnd?: (component: AlloyComponent, thumb: AlloyComponent) => void;
   131|   onInit?: (component: AlloyComponent, thumb: AlloyComponent, spectrum: AlloyComponent, value: SliderValue) => void;
   132| }
   133| export interface SliderApis {
   134|   setValue: (slider: AlloyComponent, value: SliderValue) => void;
   135|   resetToMin: (slider: AlloyComponent) => void;
   136|   resetToMax: (slider: AlloyComponent) => void;
   137|   refresh: (slider: AlloyComponent) => void;
   138| }
   139| export interface SliderSketcher extends CompositeSketch<SliderSpec>, SliderApis { }


# ====================================================================
# FILE: modules/bridge/src/demo/ts/dialogs/DemoDialogHelpers.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| import { StructureProcessor, StructureSchema } from '@ephox/boulder';
     2| import { Cell, Fun, Merger } from '@ephox/katamari';
     3| import { DialogManager } from '../../../main/ts/ephox/bridge/api/DialogManager';
     4| import { Dialog, DialogInstanceApi, DialogSpec } from '../../../main/ts/ephox/bridge/components/dialog/Dialog';
     5| const createDemoApi = <T>(internalStructure: Dialog<T>, initalData: Partial<T>, dataValidator: StructureProcessor): DialogInstanceApi<T> => {
     6|   const data = Cell(initalData);
     7|   console.log({
     8|     internalStructure,
     9|     initalData
    10|   });
    11|   return {
    12|     getData: () =>
    13|       data.get() as any,
    14|     setData: (newData: Partial<T>) => {
    15|       const mergedData = Merger.deepMerge(data.get(), newData);
    16|       const newInternalData = StructureSchema.getOrDie(StructureSchema.asRaw('data', dataValidator, mergedData));
    17|       data.set(newInternalData);
    18|     },
    19|     redial: Fun.noop,
    20|     focus: (_name: string) => {},
    21|     showTab: (_title: string) => {},
    22|     setEnabled: (_name: string, _state: boolean) => {},
    23|     block: (_message: string) => {},
    24|     unblock: Fun.noop,
    25|     close: Fun.noop
    26|   };
    27| };
    28| export const openDemoDialog = <T>(structure: DialogSpec<T>): void => {
    29|   DialogManager.open(createDemoApi, structure);
    30| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/dialogs/FindReplaceDialog.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| import { openDemoDialog } from './DemoDialogHelpers';
     2| export const createFindReplaceDialog = (): void => {
     3|   openDemoDialog(
     4|     {
     5|       title: 'Find and replace',
     6|       body: {
     7|         type: 'panel',
     8|         items: [
     9|           {
    10|             name: 'find',
    11|             type: 'input'
    12|           },
    13|           {
    14|             name: 'replace',
    15|             type: 'input'
    16|           },
    17|           {
    18|             name: 'matchcase',
    19|             type: 'checkbox',
    20|             label: 'Match Case'
    21|           },
    22|           {
    23|             name: 'wholewords',
    24|             type: 'checkbox',
    25|             label: 'Whole Words'
    26|           }
    27|         ]
    28|       },
    29|       buttons: [
    30|         {
    31|           type: 'custom',
    32|           name: 'find',
    33|           text: 'Find',
    34|           align: 'start',
    35|           primary: true
    36|         },
    37|         {
    38|           type: 'custom',
    39|           name: 'replace',
    40|           text: 'Replace',
    41|           align: 'start',
    42|           enabled: false
    43|         },
    44|         {
    45|           type: 'custom',
    46|           name: 'replaceall',
    47|           text: 'Replace all',
    48|           align: 'start',
    49|           enabled: false
    50|         },
    51|         {
    52|           type: 'custom',
    53|           name: 'prev',
    54|           text: 'Prev',
    55|           align: 'end',
    56|           enabled: false
    57|         },
    58|         {
    59|           type: 'custom',
    60|           name: 'next',
    61|           text: 'Next',
    62|           align: 'end',
    63|           enabled: false
    64|         }
    65|       ],
    66|       initialData: {
    67|         find: '',
    68|         replace: '',
    69|         matchcase: 'checked',
    70|         wholewords: 'unchecked'
    71|       },
    72|       onAction: (api, details) => {
    73|         const data = api.getData();
    74|         console.log(details.name); // Show action find/replace etc
    75|         console.log({
    76|           find: data.find,
    77|           replace: data.replace,
    78|           matchcase: data.matchcase,
    79|           wholewords: data.wholewords
    80|         });
    81|       }
    82|     }
    83|   );
    84| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/AnchorItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| const editor = {
     3|   on: (_s, _f) => { },
     4|   off: (_s, _f) => { }
     5| };
     6| export const registerAnchorItems = (): void => {
     7|   getDemoRegistry().addToggleButton('anchor', {
     8|     type: 'togglebutton',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       const f = (e) => {
    12|         const state = e;
    13|         buttonApi.setActive(state);
    14|       };
    15|       editor.on('NodeChange', f);
    16|       return () => editor.off('nodeChange', f);
    17|     },
    18|     onAction: (_buttonApi) => {
    19|     }
    20|   });
    21| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/AutosaveItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| const editor = {
     3|   on: (_s, _f) => { },
     4|   off: (_s, _f) => { }
     5| };
     6| export const registerAutosaveItems = (): void => {
     7|   getDemoRegistry().addButton('restoredraft', {
     8|     type: 'button',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       const editorOffCallback = (e) => {
    12|         const state = e;
    13|         buttonApi.setEnabled(!state);
    14|       };
    15|       editor.on('StoreDraft RestoreDraft RemoveDraft', editorOffCallback);
    16|       return () => editor.off('StoreDraft RestoreDraft RemoveDraft', editorOffCallback);
    17|     },
    18|     onAction: (_buttonApi) => {
    19|     }
    20|   });
    21| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/CharmapItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerCharmapItems = (): void => {
     3|   getDemoRegistry().addButton('charmap', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/CodeItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerCodeItems = (): void => {
     3|   getDemoRegistry().addButton('code', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/CodeSampleItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerCodeSampleItems = (): void => {
     3|   getDemoRegistry().addButton('codesample', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/DirectionalityItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| const editor = {
     3|   on: (_s, _f) => { },
     4|   off: (_s, _f) => { }
     5| };
     6| export const registerDirectionalityItems = (): void => {
     7|   getDemoRegistry().addToggleButton('dir', {
     8|     type: 'togglebutton',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       const f = (e) => {
    12|         buttonApi.setActive(e);
    13|       };
    14|       editor.on('nodeChange', f);
    15|       return () => editor.off('nodeChange', f);
    16|     },
    17|     onAction: (_buttonApi) => {
    18|     }
    19|   });
    20| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/FullscreenItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| const editor = {
     3|   on: (_s, _f) => { },
     4|   off: (_s, _f) => { }
     5| };
     6| export const registerFullscreenItems = (): void => {
     7|   getDemoRegistry().addToggleButton('fullscreen', {
     8|     type: 'togglebutton',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       const f = (e) => {
    12|         buttonApi.setActive(e.something);
    13|       };
    14|       editor.on('FullscreenStateChanged', f);
    15|       return () => editor.off('FullscreenStateChanged', f);
    16|     },
    17|     onAction: (_buttonApi) => {
    18|     }
    19|   });
    20| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/LinkItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerLinkItems = (): void => {
     3|   getDemoRegistry().addButton('link', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/ListItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerListItems = (): void => {
     3|   getDemoRegistry().addButton('indent', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/MediaItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { }
     5| };
     6| export const registerMediaItems = (): void => {
     7|   getDemoRegistry().addToggleButton('media', {
     8|     type: 'togglebutton',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       editor.on('nodeChange', (e) => {
    12|         buttonApi.setActive(e);
    13|       });
    14|       return Fun.noop;
    15|     },
    16|     onAction: (_buttonApi) => {
    17|     }
    18|   });
    19| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/NonbreakingItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerNonbreakingItems = (): void => {
     3|   getDemoRegistry().addButton('nonbreaking', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/PagebreakItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerPageBreakItems = (): void => {
     3|   getDemoRegistry().addButton('pagebreak', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/PasteItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { }
     5| };
     6| export const registerPasteItems = (): void => {
     7|   getDemoRegistry().addToggleButton('pastetext', {
     8|     type: 'togglebutton',
     9|     enabled: true,
    10|     onSetup: (buttonApi) => {
    11|       editor.on('PastePlainTextToggle', (e) => {
    12|         buttonApi.setActive(e.state);
    13|       });
    14|       return Fun.noop;
    15|     },
    16|     onAction: (_buttonApi) => {
    17|     }
    18|   });
    19| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/PreviewItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerPreviewItems = (): void => {
     3|   getDemoRegistry().addButton('preview', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/SaveItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { },
     5|   off: (_s, _f) => { },
     6|   isDirty: Fun.always
     7| };
     8| export const registerSaveItems = (): void => {
     9|   getDemoRegistry().addButton('save', {
    10|     type: 'button',
    11|     enabled: true,
    12|     onSetup: (buttonApi) => {
    13|       const editorOffCallback = () => {
    14|         buttonApi.setEnabled(!editor.isDirty());
    15|       };
    16|       editor.on('nodeChange dirty', editorOffCallback);
    17|       return () => editor.off('nodeChange dirty', editorOffCallback);
    18|     },
    19|     onAction: (_buttonApi) => {
    20|     }
    21|   });
    22| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/SearchReplaceItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerSearchReplaceItems = (): void => {
     3|   getDemoRegistry().addButton('searchreplace', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/TODO_EmoticonItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| export const registerEmoticonItems = (): void => {
     4|   getDemoRegistry().addButton('emoticon', {
     5|     type: 'button',
     6|     enabled: true,
     7|     onSetup: (_buttonApi) => Fun.noop,
     8|     onAction: (_buttonApi) => {
     9|     }
    10|   });
    11| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/TemplateItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { getDemoRegistry } from '../buttons/DemoRegistry';
     2| export const registerTemplateItems = (): void => {
     3|   getDemoRegistry().addButton('template', {
     4|     type: 'button',
     5|     enabled: true,
     6|     onAction: (_buttonApi) => {
     7|     }
     8|   });
     9| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/TocItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { },
     5|   isDirty: Fun.always
     6| };
     7| export const registerTocItems = (): void => {
     8|   getDemoRegistry().addButton('toc', {
     9|     type: 'button',
    10|     enabled: true,
    11|     onSetup: (buttonApi) => {
    12|       editor.on('LoadContent SetContent change', (e) => {
    13|         buttonApi.setEnabled(!e);
    14|       });
    15|       return Fun.noop;
    16|     },
    17|     onAction: (_buttonApi) => {
    18|     }
    19|   });
    20| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/VisualBlocksItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { },
     5|   isDirty: Fun.always
     6| };
     7| export const registerVisualBlocksItems = (): void => {
     8|   getDemoRegistry().addToggleButton('visualblocks', {
     9|     type: 'togglebutton',
    10|     enabled: true,
    11|     onSetup: (buttonApi) => {
    12|       editor.on('VisualBlocks', (e) => {
    13|         buttonApi.setActive(e);
    14|       });
    15|       return Fun.noop;
    16|     },
    17|     onAction: (_buttonApi) => {
    18|     }
    19|   });
    20| };


# ====================================================================
# FILE: modules/bridge/src/demo/ts/plugins/VisualCharsItems.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { Fun } from '@ephox/katamari';
     2| import { getDemoRegistry } from '../buttons/DemoRegistry';
     3| const editor = {
     4|   on: (_s, _f) => { },
     5|   isDirty: Fun.always
     6| };
     7| export const registerVisualCharsItems = (): void => {
     8|   getDemoRegistry().addToggleButton('visualchars', {
     9|     type: 'togglebutton',
    10|     enabled: true,
    11|     onSetup: (buttonApi) => {
    12|       editor.on('VisualChars', (e) => {
    13|         buttonApi.setActive(e);
    14|       });
    15|       return Fun.noop;
    16|     },
    17|     onAction: (_buttonApi) => {
    18|     }
    19|   });
    20| };


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/api/Dialog.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-167 ---
     1| import { AlertBanner, AlertBannerSpec, createAlertBanner } from '../components/dialog/AlertBanner';
     2| import { Bar, BarSpec, createBarFields } from '../components/dialog/Bar';
     3| import { BodyComponent, BodyComponentSpec } from '../components/dialog/BodyComponent';
     4| import { Button, ButtonSpec, createButton } from '../components/dialog/Button';
     5| import { Checkbox, CheckboxSpec, createCheckbox } from '../components/dialog/Checkbox';
     6| import { Collection, collectionDataProcessor, CollectionItem, CollectionSpec, createCollection } from '../components/dialog/Collection';
     7| import { ColorInput, ColorInputSpec, createColorInput } from '../components/dialog/ColorInput';
     8| import { ColorPicker, ColorPickerSpec, createColorPicker } from '../components/dialog/ColorPicker';
     9| import {
    10|   createCustomEditor, CustomEditor, CustomEditorInit, CustomEditorInitFn, CustomEditorNew, CustomEditorOld, customEditorSchema, CustomEditorSpec
    11| } from '../components/dialog/CustomEditor';
    12| import {
    13|   createDialog, Dialog, DialogActionDetails, DialogActionHandler, DialogCancelHandler, DialogChangeDetails, DialogCloseHandler, DialogData,
    14|   DialogInstanceApi, DialogSize, DialogSpec, DialogSubmitHandler, DialogTabChangeDetails, DialogTabChangeHandler
    15| } from '../components/dialog/Dialog';
    16| import {
    17|   createDialogFooterButton, DialogFooterButton, DialogFooterButtonSpec, DialogFooterMenuButton, DialogFooterMenuButtonItemSpec,
    18|   DialogFooterMenuButtonSpec, DialogFooterNormalButton, DialogFooterNormalButtonSpec, DialogFooterToggleMenuItem
    19| } from '../components/dialog/DialogFooterButton';
    20| import { createDropZone, DropZone, DropZoneSpec } from '../components/dialog/Dropzone';
    21| import { createGridFields, Grid, GridSpec } from '../components/dialog/Grid';
    22| import { createHtmlPanel, HtmlPanel, HtmlPanelSpec } from '../components/dialog/HtmlPanel';
    23| import { createIframe, Iframe, IframeSpec } from '../components/dialog/Iframe';
    24| import { ImagePreview, ImagePreviewData, ImagePreviewSpec } from '../components/dialog/ImagePreview';
    25| import { createInput, Input, InputSpec } from '../components/dialog/Input';
    26| import { createLabelFields, Label, LabelSpec } from '../components/dialog/Label';
    27| import {
    28|   createListBox, ListBox, ListBoxItem, ListBoxItemSpec, ListBoxNestedItemSpec, ListBoxSingleItemSpec, ListBoxSpec
    29| } from '../components/dialog/ListBox';
    30| import { createPanel, Panel, PanelSpec } from '../components/dialog/Panel';
    31| import { createSelectBox, SelectBox, SelectBoxItem, SelectBoxItemSpec, SelectBoxSpec } from '../components/dialog/SelectBox';
    32| import { createSizeInput, SizeInput, SizeInputSpec } from '../components/dialog/SizeInput';
    33| import { Slider, SliderSpec } from '../components/dialog/Slider';
    34| import { createTable, Table, TableSpec } from '../components/dialog/Table';
    35| import { createTabPanel, Tab, TabPanel, TabPanelSpec, TabSpec } from '../components/dialog/TabPanel';
    36| import { createTextArea, TextArea, TextAreaSpec } from '../components/dialog/Textarea';
    37| import {
    38|   createUrlDialog, UrlDialog, UrlDialogActionDetails, UrlDialogActionHandler, UrlDialogCancelHandler, UrlDialogCloseHandler, UrlDialogFooterButton,
    39|   UrlDialogFooterButtonSpec, UrlDialogInstanceApi, UrlDialogMessage, UrlDialogMessageHandler, UrlDialogSpec
    40| } from '../components/dialog/UrlDialog';
    41| import { createUrlInput, UrlInput, UrlInputData, UrlInputSpec } from '../components/dialog/UrlInput';
    42| export {
    43|   AlertBanner,
    44|   AlertBannerSpec,
    45|   createAlertBanner,
    46|   Bar,
    47|   BarSpec,
    48|   createBarFields,
    49|   BodyComponent,
    50|   BodyComponentSpec,
    51|   Button,
    52|   ButtonSpec,
    53|   createButton,
    54|   Checkbox,
    55|   CheckboxSpec,
    56|   createCheckbox,
    57|   Collection,
    58|   CollectionItem,
    59|   CollectionSpec,
    60|   createCollection,
    61|   collectionDataProcessor,
    62|   ColorInput,
    63|   ColorInputSpec,
    64|   createColorInput,
    65|   ColorPicker,
    66|   ColorPickerSpec,
    67|   createColorPicker,
    68|   CustomEditor,
    69|   CustomEditorSpec,
    70|   CustomEditorOld,
    71|   CustomEditorNew,
    72|   CustomEditorInit,
    73|   CustomEditorInitFn,
    74|   createCustomEditor,
    75|   customEditorSchema,
    76|   Dialog,
    77|   DialogSpec,
    78|   DialogInstanceApi,
    79|   DialogActionDetails,
    80|   DialogActionHandler,
    81|   DialogChangeDetails,
    82|   DialogCancelHandler,
    83|   DialogCloseHandler,
    84|   DialogSubmitHandler,
    85|   DialogTabChangeDetails,
    86|   DialogTabChangeHandler,
    87|   DialogData,
    88|   DialogSize,
    89|   createDialog,
    90|   DialogFooterButton,
    91|   DialogFooterButtonSpec,
    92|   DialogFooterNormalButton,
    93|   DialogFooterNormalButtonSpec,
    94|   DialogFooterMenuButton,
    95|   DialogFooterMenuButtonSpec,
    96|   DialogFooterToggleMenuItem,
    97|   DialogFooterMenuButtonItemSpec,
    98|   createDialogFooterButton,
    99|   DropZone,
   100|   DropZoneSpec,
   101|   createDropZone,
   102|   Grid,
   103|   GridSpec,
   104|   createGridFields,
   105|   HtmlPanel,
   106|   HtmlPanelSpec,
   107|   createHtmlPanel,
   108|   Iframe,
   109|   IframeSpec,
   110|   createIframe,
   111|   ImagePreview,
   112|   ImagePreviewData,
   113|   ImagePreviewSpec,
   114|   Input,
   115|   InputSpec,
   116|   createInput,
   117|   Label,
   118|   LabelSpec,
   119|   createLabelFields,
   120|   ListBox,
   121|   ListBoxSpec,
   122|   ListBoxItem,
   123|   ListBoxItemSpec,
   124|   ListBoxNestedItemSpec,
   125|   ListBoxSingleItemSpec,
   126|   createListBox,
   127|   Panel,
   128|   PanelSpec,
   129|   createPanel,
   130|   SelectBox,
   131|   SelectBoxSpec,
   132|   SelectBoxItem,
   133|   SelectBoxItemSpec,
   134|   createSelectBox,
   135|   SizeInput,
   136|   SizeInputSpec,
   137|   createSizeInput,
   138|   Slider,
   139|   SliderSpec,
   140|   Table,
   141|   TableSpec,
   142|   createTable,
   143|   TabPanel,
   144|   TabPanelSpec,
   145|   Tab,
   146|   TabSpec,
   147|   createTabPanel,
   148|   TextArea,
   149|   TextAreaSpec,
   150|   createTextArea,
   151|   UrlDialog,
   152|   UrlDialogSpec,
   153|   UrlDialogInstanceApi,
   154|   UrlDialogFooterButton,
   155|   UrlDialogFooterButtonSpec,
   156|   UrlDialogActionDetails,
   157|   UrlDialogActionHandler,
   158|   UrlDialogCancelHandler,
   159|   UrlDialogCloseHandler,
   160|   UrlDialogMessage,
   161|   UrlDialogMessageHandler,
   162|   createUrlDialog,
   163|   UrlInput,
   164|   UrlInputData,
   165|   UrlInputSpec,
   166|   createUrlInput
   167| };


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/api/DialogManager.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| import { StructureProcessor, StructureSchema } from '@ephox/boulder';
     2| import { createDialog, Dialog, DialogData, DialogInstanceApi, DialogSpec } from '../components/dialog/Dialog';
     3| import { createUrlDialog, UrlDialog, UrlDialogInstanceApi, UrlDialogSpec } from '../components/dialog/UrlDialog';
     4| import { createDataValidator } from '../core/DialogData';
     5| interface DialogManager {
     6|   open: <T extends DialogData>(factory: DialogFactory<T>, structure: DialogSpec<T>) => DialogInstanceApi<T>;
     7|   openUrl: (factory: UrlDialogFactory, structure: UrlDialogSpec) => UrlDialogInstanceApi;
     8|   redial: <T extends DialogData>(structure: DialogSpec<T>) => DialogInit<T>;
     9| }
    10| export type DialogFactory<T extends DialogData> = (internalDialog: Dialog<T>, initialData: Partial<T>, dataValidator: StructureProcessor) => DialogInstanceApi<T>;
    11| export type UrlDialogFactory = (internalDialog: UrlDialog) => UrlDialogInstanceApi;
    12| export interface DialogInit<T extends DialogData> {
    13|   internalDialog: Dialog<T>;
    14|   initialData: Partial<T>;
    15|   dataValidator: StructureProcessor;
    16| }
    17| const extract = <T>(structure: DialogSpec<T>): DialogInit<T> => {
    18|   const internalDialog = StructureSchema.getOrDie(createDialog(structure));
    19|   const dataValidator = createDataValidator<T>(structure);
    20|   const initialData = structure.initialData;
    21|   return {
    22|     internalDialog,
    23|     dataValidator,
    24|     initialData
    25|   };
    26| };
    27| const DialogManager: DialogManager = {
    28|   open: <T extends DialogData>(factory: DialogFactory<T>, structure: DialogSpec<T>): DialogInstanceApi<T> => {
    29|     const extraction = extract(structure);
    30|     return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
    31|   },
    32|   openUrl: (factory: UrlDialogFactory, structure: UrlDialogSpec): UrlDialogInstanceApi => {
    33|     const internalDialog = StructureSchema.getOrDie(createUrlDialog(structure));
    34|     return factory(internalDialog);
    35|   },
    36|   redial: <T extends DialogData>(structure: DialogSpec<T>): DialogInit<T> => extract(structure)
    37| };
    38| export {
    39|   DialogManager
    40| };


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/api/PublicDialog.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| import { AlertBannerSpec } from '../components/dialog/AlertBanner';
     2| import { BarSpec } from '../components/dialog/Bar';
     3| import { BodyComponentSpec } from '../components/dialog/BodyComponent';
     4| import { ButtonSpec } from '../components/dialog/Button';
     5| import { CheckboxSpec } from '../components/dialog/Checkbox';
     6| import { CollectionItem, CollectionSpec } from '../components/dialog/Collection';
     7| import { ColorInputSpec } from '../components/dialog/ColorInput';
     8| import { ColorPickerSpec } from '../components/dialog/ColorPicker';
     9| import { CustomEditorInit, CustomEditorInitFn, CustomEditorSpec } from '../components/dialog/CustomEditor';
    10| import {
    11|   DialogActionDetails, DialogChangeDetails, DialogData, DialogInstanceApi, DialogSize, DialogSpec, DialogTabChangeDetails
    12| } from '../components/dialog/Dialog';
    13| import { DialogFooterButtonSpec } from '../components/dialog/DialogFooterButton';
    14| import { DropZoneSpec } from '../components/dialog/Dropzone';
    15| import { GridSpec } from '../components/dialog/Grid';
    16| import { HtmlPanelSpec } from '../components/dialog/HtmlPanel';
    17| import { IframeSpec } from '../components/dialog/Iframe';
    18| import { ImagePreviewSpec } from '../components/dialog/ImagePreview';
    19| import { InputSpec } from '../components/dialog/Input';
    20| import { LabelSpec } from '../components/dialog/Label';
    21| import { ListBoxItemSpec, ListBoxSpec, ListBoxSingleItemSpec, ListBoxNestedItemSpec } from '../components/dialog/ListBox';
    22| import { PanelSpec } from '../components/dialog/Panel';
    23| import { SelectBoxItemSpec, SelectBoxSpec } from '../components/dialog/SelectBox';
    24| import { SizeInputSpec } from '../components/dialog/SizeInput';
    25| import { SliderSpec } from '../components/dialog/Slider';
    26| import { TableSpec } from '../components/dialog/Table';
    27| import { TabPanelSpec, TabSpec } from '../components/dialog/TabPanel';
    28| import { TextAreaSpec } from '../components/dialog/Textarea';
    29| import {
    30|   UrlDialogActionDetails, UrlDialogFooterButtonSpec, UrlDialogInstanceApi, UrlDialogMessage, UrlDialogSpec
    31| } from '../components/dialog/UrlDialog';
    32| import { UrlInputData, UrlInputSpec } from '../components/dialog/UrlInput';
    33| export {
    34|   AlertBannerSpec,
    35|   BarSpec,
    36|   BodyComponentSpec,
    37|   ButtonSpec,
    38|   CheckboxSpec,
    39|   CollectionItem,
    40|   CollectionSpec,
    41|   ColorInputSpec,
    42|   ColorPickerSpec,
    43|   CustomEditorSpec,
    44|   CustomEditorInit,
    45|   CustomEditorInitFn,
    46|   DialogData,
    47|   DialogSize,
    48|   DialogSpec,
    49|   DialogInstanceApi,
    50|   DialogFooterButtonSpec,
    51|   DialogActionDetails,
    52|   DialogChangeDetails,
    53|   DialogTabChangeDetails,
    54|   DropZoneSpec,
    55|   GridSpec,
    56|   HtmlPanelSpec,
    57|   IframeSpec,
    58|   ImagePreviewSpec,
    59|   InputSpec,
    60|   LabelSpec,
    61|   ListBoxSpec,
    62|   ListBoxItemSpec,
    63|   ListBoxNestedItemSpec,
    64|   ListBoxSingleItemSpec,
    65|   PanelSpec,
    66|   SelectBoxSpec,
    67|   SelectBoxItemSpec,
    68|   SizeInputSpec,
    69|   SliderSpec,
    70|   TableSpec,
    71|   TabSpec,
    72|   TabPanelSpec,
    73|   TextAreaSpec,
    74|   UrlInputData,
    75|   UrlInputSpec,
    76|   UrlDialogSpec,
    77|   UrlDialogFooterButtonSpec,
    78|   UrlDialogInstanceApi,
    79|   UrlDialogActionDetails,
    80|   UrlDialogMessage
    81| };


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/content/Autocompleter.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| import { FieldSchema, StructureSchema, ValueType } from '@ephox/boulder';
     2| import { Optional, Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| import { CardMenuItemSpec } from '../menu/CardMenuItem';
     5| import { SeparatorMenuItem, separatorMenuItemSchema, SeparatorMenuItemSpec } from '../menu/SeparatorMenuItem';
     6| export type ColumnTypes = number | 'auto';
     7| export type SeparatorItemSpec = SeparatorMenuItemSpec;
     8| export interface AutocompleterItemSpec {
     9|   type?: 'autocompleteitem';
    10|   value: string;
    11|   text?: string;
    12|   icon?: string;
    13|   meta?: Record<string, any>;
    14| }
    15| export type AutocompleterContents = SeparatorItemSpec | AutocompleterItemSpec | CardMenuItemSpec;
    16| export type SeparatorItem = SeparatorMenuItem;
    17| export interface AutocompleterItem {
    18|   type: 'autocompleteitem';
    19|   value: string;
    20|   text: Optional<string>;
    21|   icon: Optional<string>;
    22|   active: boolean;
    23|   enabled: boolean;
    24|   meta: Record<string, any>;
    25| }
    26| export interface AutocompleterSpec {
    27|   type?: 'autocompleter';
    28|   ch: string;
    29|   minChars?: number;
    30|   columns?: ColumnTypes;
    31|   matches?: (rng: Range, text: string, pattern: string) => boolean;
    32|   fetch: (pattern: string, maxResults: number, fetchOptions: Record<string, any>) => Promise<AutocompleterContents[]>;
    33|   onAction: (autocompleterApi: AutocompleterInstanceApi, rng: Range, value: string, meta: Record<string, any>) => void;
    34|   maxResults?: number;
    35|   highlightOn?: string[];
    36| }
    37| export interface AutocompleterInstanceApi {
    38|   hide: () => void;
    39|   reload: (fetchOptions: Record<string, any>) => void;
    40| }
    41| export interface Autocompleter {
    42|   type: 'autocompleter';
    43|   ch: string;
    44|   minChars: number;
    45|   columns: ColumnTypes;
    46|   matches: Optional<(rng: Range, text: string, pattern: string) => boolean>;
    47|   fetch: (pattern: string, maxResults: number, fetchOptions: Record<string, any>) => Promise<AutocompleterContents[]>;
    48|   onAction: (autocompleterApi: AutocompleterInstanceApi, rng: Range, value: string, meta: Record<string, any>) => void;
    49|   maxResults: number;
    50|   highlightOn: string[];
    51| }
    52| const autocompleterItemSchema = StructureSchema.objOf([
    53|   ComponentSchema.defaultedType('autocompleteitem'),
    54|   ComponentSchema.active,
    55|   ComponentSchema.enabled,
    56|   ComponentSchema.defaultedMeta,
    57|   ComponentSchema.value,
    58|   ComponentSchema.optionalText,
    59|   ComponentSchema.optionalIcon
    60| ]);
    61| const autocompleterSchema = StructureSchema.objOf([
    62|   ComponentSchema.type,
    63|   FieldSchema.requiredString('ch'),
    64|   FieldSchema.defaultedNumber('minChars', 1),
    65|   ComponentSchema.defaultedColumns(1),
    66|   FieldSchema.defaultedNumber('maxResults', 10),
    67|   FieldSchema.optionFunction('matches'),
    68|   ComponentSchema.fetch,
    69|   ComponentSchema.onAction,
    70|   FieldSchema.defaultedArrayOf('highlightOn', [], ValueType.string)
    71| ]);
    72| export const createSeparatorItem = (spec: SeparatorItemSpec): Result<SeparatorItem, StructureSchema.SchemaError<any>> =>
    73|   StructureSchema.asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);
    74| export const createAutocompleterItem = (spec: AutocompleterItemSpec): Result<AutocompleterItem, StructureSchema.SchemaError<any>> =>
    75|   StructureSchema.asRaw<AutocompleterItem>('Autocompleter.Item', autocompleterItemSchema, spec);
    76| export const createAutocompleter = (spec: AutocompleterSpec): Result<Autocompleter, StructureSchema.SchemaError<any>> =>
    77|   StructureSchema.asRaw<Autocompleter>('Autocompleter', autocompleterSchema, spec);


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/content/ContextForm.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-98 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Fun, Optional, Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| import { BaseToolbarButton, baseToolbarButtonFields, BaseToolbarButtonInstanceApi, BaseToolbarButtonSpec } from '../toolbar/ToolbarButton';
     5| import {
     6|   BaseToolbarToggleButton, baseToolbarToggleButtonFields, BaseToolbarToggleButtonInstanceApi, BaseToolbarToggleButtonSpec
     7| } from '../toolbar/ToolbarToggleButton';
     8| import { ContextBar, contextBarFields, ContextBarSpec } from './ContextBar';
     9| export interface ContextFormLaunchButtonApi extends BaseToolbarButtonSpec<BaseToolbarButtonInstanceApi> {
    10|   type: 'contextformbutton';
    11| }
    12| export interface ContextFormLaunchButton extends BaseToolbarButton<BaseToolbarButtonInstanceApi> {
    13|   type: 'contextformbutton';
    14| }
    15| export interface ContextFormLaunchToggleButtonSpec extends BaseToolbarToggleButtonSpec<BaseToolbarToggleButtonInstanceApi> {
    16|   type: 'contextformtogglebutton';
    17| }
    18| export interface ContextFormLaunchToggleButton extends BaseToolbarToggleButton<BaseToolbarToggleButtonInstanceApi> {
    19|   type: 'contextformtogglebutton';
    20| }
    21| export interface ContextFormButtonInstanceApi extends BaseToolbarButtonInstanceApi {
    22| }
    23| export interface ContextFormToggleButtonInstanceApi extends BaseToolbarToggleButtonInstanceApi {
    24| }
    25| export interface ContextFormButtonSpec extends BaseToolbarButtonSpec<ContextFormButtonInstanceApi> {
    26|   type?: 'contextformbutton';
    27|   primary?: boolean;
    28|   onAction: (formApi: ContextFormInstanceApi, api: ContextFormButtonInstanceApi) => void;
    29| }
    30| export interface ContextFormToggleButtonSpec extends BaseToolbarToggleButtonSpec<ContextFormToggleButtonInstanceApi> {
    31|   type?: 'contextformtogglebutton';
    32|   onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormToggleButtonInstanceApi) => void;
    33|   primary?: boolean;
    34| }
    35| export interface ContextFormButton extends BaseToolbarButton<ContextFormButtonInstanceApi> {
    36|   type?: 'contextformbutton';
    37|   primary?: boolean;
    38|   onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormButtonInstanceApi) => void;
    39|   original: ContextFormButtonSpec;
    40| }
    41| export interface ContextFormToggleButton extends BaseToolbarToggleButton<ContextFormToggleButtonInstanceApi> {
    42|   type?: 'contextformtogglebutton';
    43|   primary?: boolean;
    44|   onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormToggleButtonInstanceApi) => void;
    45|   original: ContextFormToggleButtonSpec;
    46| }
    47| export interface ContextFormInstanceApi {
    48|   hide: () => void;
    49|   getValue: () => string; // Maybe we need to support other data types?
    50| }
    51| export interface ContextFormSpec extends ContextBarSpec {
    52|   type?: 'contextform';
    53|   initValue?: () => string;
    54|   label?: string;
    55|   launch?: ContextFormLaunchButtonApi | ContextFormLaunchToggleButtonSpec;
    56|   commands: Array<ContextFormToggleButtonSpec | ContextFormButtonSpec>;
    57| }
    58| export interface ContextForm extends ContextBar {
    59|   type: 'contextform';
    60|   initValue: () => string;
    61|   label: Optional<string>;
    62|   launch: Optional<ContextFormLaunchButton | ContextFormLaunchToggleButton>;
    63|   commands: Array<ContextFormToggleButton | ContextFormButton>;
    64| }
    65| const contextButtonFields = baseToolbarButtonFields.concat([
    66|   ComponentSchema.defaultedType('contextformbutton'),
    67|   ComponentSchema.primary,
    68|   ComponentSchema.onAction,
    69|   FieldSchema.customField('original', Fun.identity)
    70| ]);
    71| const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
    72|   ComponentSchema.defaultedType('contextformbutton'),
    73|   ComponentSchema.primary,
    74|   ComponentSchema.onAction,
    75|   FieldSchema.customField('original', Fun.identity)
    76| ]);
    77| const launchButtonFields = baseToolbarButtonFields.concat([
    78|   ComponentSchema.defaultedType('contextformbutton')
    79| ]);
    80| const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
    81|   ComponentSchema.defaultedType('contextformtogglebutton')
    82| ]);
    83| const toggleOrNormal = StructureSchema.choose('type', {
    84|   contextformbutton: contextButtonFields,
    85|   contextformtogglebutton: contextToggleButtonFields
    86| });
    87| const contextFormSchema = StructureSchema.objOf([
    88|   ComponentSchema.defaultedType('contextform'),
    89|   FieldSchema.defaultedFunction('initValue', Fun.constant('')),
    90|   ComponentSchema.optionalLabel,
    91|   FieldSchema.requiredArrayOf('commands', toggleOrNormal),
    92|   FieldSchema.optionOf('launch', StructureSchema.choose('type', {
    93|     contextformbutton: launchButtonFields,
    94|     contextformtogglebutton: launchToggleButtonFields
    95|   }))
    96| ].concat(contextBarFields));
    97| export const createContextForm = (spec: ContextFormSpec): Result<ContextForm, StructureSchema.SchemaError<any>> =>
    98|   StructureSchema.asRaw<ContextForm>('ContextForm', contextFormSchema, spec);


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/content/ContextToolbar.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| import { ContextBar, contextBarFields, ContextBarSpec } from './ContextBar';
     5| export interface ContextToolbarSpec extends ContextBarSpec {
     6|   type?: 'contexttoolbar';
     7|   items: string;
     8| }
     9| export interface ContextToolbar extends ContextBar {
    10|   type: 'contexttoolbar';
    11|   items: string;
    12| }
    13| const contextToolbarSchema = StructureSchema.objOf([
    14|   ComponentSchema.defaultedType('contexttoolbar'),
    15|   FieldSchema.requiredString('items')
    16| ].concat(contextBarFields));
    17| export const createContextToolbar = (spec: ContextToolbarSpec): Result<ContextToolbar, StructureSchema.SchemaError<any>> =>
    18|   StructureSchema.asRaw<ContextToolbar>('ContextToolbar', contextToolbarSchema, spec);


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/dialog/AlertBanner.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| export interface AlertBannerSpec {
     5|   type: 'alertbanner';
     6|   level: 'info' | 'warn' | 'error' | 'success';
     7|   text: string;
     8|   icon: string;
     9|   url?: string;
    10| }
    11| export interface AlertBanner {
    12|   type: 'alertbanner';
    13|   level: 'info' | 'warn' | 'error' | 'success';
    14|   text: string;
    15|   icon: string;
    16|   url: string;
    17| }
    18| const alertBannerFields = [
    19|   ComponentSchema.type,
    20|   ComponentSchema.text,
    21|   FieldSchema.requiredStringEnum('level', [ 'info', 'warn', 'error', 'success' ]),
    22|   ComponentSchema.icon,
    23|   FieldSchema.defaulted('url', '')
    24| ];
    25| export const alertBannerSchema = StructureSchema.objOf(alertBannerFields);
    26| export const createAlertBanner = (spec: AlertBannerSpec): Result<AlertBanner, StructureSchema.SchemaError<any>> =>
    27|   StructureSchema.asRaw<AlertBanner>('alertbanner', alertBannerSchema, spec);


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/dialog/Bar.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| import { FieldProcessor } from '@ephox/boulder';
     2| import * as ComponentSchema from '../../core/ComponentSchema';
     3| import { BodyComponent, BodyComponentSpec } from './BodyComponent';
     4| export interface BarSpec {
     5|   type: 'bar';
     6|   items: BodyComponentSpec[];
     7| }
     8| export interface Bar {
     9|   type: 'bar';
    10|   items: BodyComponent[];
    11| }
    12| export const createBarFields = (itemsField: FieldProcessor): FieldProcessor[] => [
    13|   ComponentSchema.type,
    14|   itemsField
    15| ];


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/dialog/BodyComponent.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| import { AlertBanner, AlertBannerSpec } from './AlertBanner';
     2| import { Bar, BarSpec } from './Bar';
     3| import { Button, ButtonSpec } from './Button';
     4| import { Checkbox, CheckboxSpec } from './Checkbox';
     5| import { Collection, CollectionSpec } from './Collection';
     6| import { ColorInput, ColorInputSpec } from './ColorInput';
     7| import { ColorPicker, ColorPickerSpec } from './ColorPicker';
     8| import { CustomEditor, CustomEditorSpec } from './CustomEditor';
     9| import { DropZone, DropZoneSpec } from './Dropzone';
    10| import { Grid, GridSpec } from './Grid';
    11| import { HtmlPanel, HtmlPanelSpec } from './HtmlPanel';
    12| import { Iframe, IframeSpec } from './Iframe';
    13| import { ImagePreview, ImagePreviewSpec } from './ImagePreview';
    14| import { Input, InputSpec } from './Input';
    15| import { Label, LabelSpec } from './Label';
    16| import { ListBox, ListBoxSpec } from './ListBox';
    17| import { Panel, PanelSpec } from './Panel';
    18| import { SelectBox, SelectBoxSpec } from './SelectBox';
    19| import { SizeInput, SizeInputSpec } from './SizeInput';
    20| import { Slider, SliderSpec } from './Slider';
    21| import { Table, TableSpec } from './Table';
    22| import { TextArea, TextAreaSpec } from './Textarea';
    23| import { UrlInput, UrlInputSpec } from './UrlInput';
    24| export type BodyComponentSpec
    25|   = BarSpec
    26|   | ButtonSpec
    27|   | CheckboxSpec
    28|   | TextAreaSpec
    29|   | InputSpec
    30|   | ListBoxSpec
    31|   | SelectBoxSpec
    32|   | SizeInputSpec
    33|   | SliderSpec
    34|   | IframeSpec
    35|   | HtmlPanelSpec
    36|   | UrlInputSpec
    37|   | DropZoneSpec
    38|   | ColorInputSpec
    39|   | GridSpec
    40|   | ColorPickerSpec
    41|   | ImagePreviewSpec
    42|   | AlertBannerSpec
    43|   | CollectionSpec
    44|   | LabelSpec
    45|   | TableSpec
    46|   | PanelSpec
    47|   | CustomEditorSpec;
    48| export type BodyComponent
    49|   = Bar
    50|   | Button
    51|   | Checkbox
    52|   | TextArea
    53|   | Input
    54|   | ListBox
    55|   | SelectBox
    56|   | SizeInput
    57|   | Slider
    58|   | Iframe
    59|   | HtmlPanel
    60|   | UrlInput
    61|   | DropZone
    62|   | ColorInput
    63|   | Grid
    64|   | ColorPicker
    65|   | ImagePreview
    66|   | AlertBanner
    67|   | Collection
    68|   | Label
    69|   | Table
    70|   | Panel
    71|   | CustomEditor;


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/dialog/Button.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| import { FieldSchema, StructureSchema } from '@ephox/boulder';
     2| import { Optional, Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| export interface ButtonSpec {
     5|   type: 'button';
     6|   text: string;
     7|   enabled?: boolean;
     8|   /** @deprecated use `buttonType: "primary"` instead */
     9|   primary?: boolean;
    10|   name?: string;
    11|   icon?: string;
    12|   borderless?: boolean;
    13|   buttonType?: 'primary' | 'secondary' | 'toolbar';
    14| }
    15| export interface Button {
    16|   type: 'button';
    17|   text: string;
    18|   enabled: boolean;
    19|   /** @deprecated use `buttonType: "primary"` instead */
    20|   primary: boolean;
    21|   name: string;
    22|   icon: Optional<string>;
    23|   borderless: boolean;
    24|   buttonType: Optional<'primary' | 'secondary' | 'toolbar'>;
    25| }
    26| const buttonFields = [
    27|   ComponentSchema.type,
    28|   ComponentSchema.text,
    29|   ComponentSchema.enabled,
    30|   ComponentSchema.generatedName('button'),
    31|   ComponentSchema.optionalIcon,
    32|   ComponentSchema.borderless,
    33|   FieldSchema.optionStringEnum('buttonType', [ 'primary', 'secondary', 'toolbar' ]),
    34|   ComponentSchema.primary,
    35| ];
    36| export const buttonSchema = StructureSchema.objOf(buttonFields);
    37| export const createButton = (spec: ButtonSpec): Result<Button, StructureSchema.SchemaError<any>> =>
    38|   StructureSchema.asRaw<Button>('button', buttonSchema, spec);


# ====================================================================
# FILE: modules/bridge/src/main/ts/ephox/bridge/components/dialog/Checkbox.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| import { StructureSchema, ValueType } from '@ephox/boulder';
     2| import { Result } from '@ephox/katamari';
     3| import * as ComponentSchema from '../../core/ComponentSchema';
     4| import { FormComponent, formComponentFields, FormComponentSpec } from './FormComponent';
     5| export interface CheckboxSpec extends FormComponentSpec {
     6|   type: 'checkbox';
     7|   label: string;
     8|   enabled?: boolean;
     9| }
    10| export interface Checkbox extends FormComponent {
    11|   type: 'checkbox';
    12|   label: string;
    13|   enabled: boolean;
    14| }
    15| const checkboxFields = formComponentFields.concat([
    16|   ComponentSchema.label,
    17|   ComponentSchema.enabled
    18| ]);
    19| export const checkboxSchema = StructureSchema.objOf(checkboxFields);
    20| export const checkboxDataProcessor = ValueType.boolean;
    21| export const createCheckbox = (spec: CheckboxSpec): Result<Checkbox, StructureSchema.SchemaError<any>> =>
    22|   StructureSchema.asRaw<Checkbox>('checkbox', checkboxSchema, spec);

