--- a//dev/null
+++ b/Gruntfile.js
@@ -0,0 +1,167 @@
+const runsHeadless = [
+  '@ephox/alloy',
+  '@ephox/mcagar',
+  '@ephox/katamari',
+  '@ephox/katamari-test',
+  '@ephox/jax'
+];
+if (!Array.prototype.flatMap) {
+  const concat = (x, y) => x.concat(y);
+  const flatMap = (f, xs) => xs.map(f).reduce(concat, []);
+  Array.prototype.flatMap = function (f) {
+    return flatMap(f, this);
+  };
+}
+const filterChanges = (changes, tests) => {
+  return changes.filter((change => tests.indexOf(change.name) > -1));
+};
+const filterChangesNot = (changes, badTests) => {
+  return changes.filter((change => badTests.indexOf(change.name) === -1));
+};
+/* structure of lerna output
+{
+  name: string,
+  version: string,
+  private: boolean,
+  location: string
+}
+*/
+/** Note: this is optimized for speed. Turns out globbing in node.js is time-consuming.
+ *  Restrict tinymce to 2 arbitrary levels of test base folders.
+ *  All other projects need their tests in src/test/ts
+ */
+const testFolders = (tests, auto) => tests.flatMap((test) => {
+  const testTypes = ['atomic', 'browser', 'headless'].concat(auto ? ['webdriver'] : []);
+  const bases = test.name === "tinymce" ? ["src/*/test/ts", "src/*/*/test/ts"] : ["src/test/ts"];
+  return bases.flatMap(base => testTypes.map(tt => `${test.location}/${base}/${tt}/**/*Test.ts`));
+});
+const bedrockDefaults = {
+  config: 'tsconfig.json',
+  customRoutes: 'modules/tinymce/src/core/test/json/routes.json',
+  overallTimeout: 180000,
+  singleTimeout: 60000,
+};
+const bedrockHeadless = (tests, browser, auto) => {
+  if (tests.length === 0) {
+    return {};
+  } else {
+    return {
+      headless: {
+        ...bedrockDefaults,
+        name: 'headless-tests',
+        browser,
+        testfiles: testFolders(tests, auto),
+      }
+    }
+  }
+};
+const bedrockBrowser = (tests, browserName, osName, bucket, buckets, chunk, auto) => {
+  if (tests.length === 0) {
+    return {};
+  } else {
+    return {
+      browser: {
+        ...bedrockDefaults,
+        overallTimeout: 1200000,
+        name: `${browserName}-${osName}`,
+        browser: browserName,
+        testfiles: testFolders(tests, auto),
+        bucket: bucket,
+        buckets: buckets,
+        chunk: chunk,
+        retries: 3
+      }
+    };
+  }
+};
+const fetchLernaProjects = (log, runAllTests) => {
+  var exec = require('child_process').execSync;
+  const parseLernaList = (cmd) => {
+    try {
+      return JSON.parse(exec(`yarn -s lerna ${cmd} -a --json --loglevel warn 2>&1`));
+    } catch (e) {
+      if (e.status === 1) {
+        return [];
+      } else {
+        throw e;
+      }
+    }
+  };
+  const changes = runAllTests ? [] : parseLernaList('changed --no-ignore-changes');
+  if (changes.length === 0) {
+    log.writeln('No changes found, testing all projects');
+    return parseLernaList('list');
+  } else {
+    return changes;
+  }
+};
+module.exports = function (grunt) {
+  const runAllTests = grunt.option('ignore-lerna-changed') || false;
+  const changes = fetchLernaProjects(grunt.log, runAllTests);
+  const bucket = parseInt(grunt.option('bucket'), 10) || 1;
+  const buckets = parseInt(grunt.option('buckets'), 10) || 1;
+  const chunk = parseInt(grunt.option('chunk'), 10) || 100;
+  const headlessTests = filterChanges(changes, runsHeadless);
+  const browserTests = filterChangesNot(changes, runsHeadless);
+  const activeBrowser = grunt.option('bedrock-browser') || 'chrome-headless';
+  const headlessBrowser = activeBrowser.endsWith("-headless") ? activeBrowser : 'chrome-headless'
+  const activeOs = grunt.option('bedrock-os') || 'tests';
+  const gruntConfig = {
+    shell: {
+      tsc: { command: 'yarn -s tsc' },
+      legacy: { command: 'yarn build' },
+      yarn: { command: 'yarn' },
+      'yarn-dev': { command: 'yarn -s dev' }
+    },
+    'bedrock-auto': {
+      ...bedrockHeadless(headlessTests, headlessBrowser, true),
+      ...bedrockBrowser(browserTests, activeBrowser, activeOs, bucket, buckets, chunk, true)
+    },
+    'bedrock-manual': {
+      ...bedrockHeadless(headlessTests, headlessBrowser, false),
+      ...bedrockBrowser(browserTests, activeBrowser, activeOs, bucket, buckets, chunk, false)
+    }
+  };
+  grunt.initConfig(gruntConfig);
+  if (headlessTests.length > 0) {
+    grunt.registerTask('list-changed-headless', () => {
+      const changeList = JSON.stringify(headlessTests.reduce((acc, change) => acc.concat(change.name), []), null, 2);
+      grunt.log.writeln('Changed projects for headless testing:', changeList);
+    });
+    grunt.registerTask('headless-auto', ['list-changed-headless', 'shell:tsc', 'bedrock-auto:headless']);
+    grunt.registerTask('headless-manual', ['list-changed-headless', 'shell:tsc', 'bedrock-manual:headless']);
+  } else {
+    const noHeadless = () => {
+      grunt.log.writeln('no changed modules need headless testing');
+    };
+    grunt.registerTask('headless-auto', noHeadless);
+    grunt.registerTask('headless-manual', noHeadless);
+    grunt.registerTask('list-changed-headless', noHeadless);
+  }
+  if (browserTests.length > 0) {
+    grunt.registerTask('list-changed-browser', () => {
+      const changeList = JSON.stringify(browserTests.reduce((acc, change) => acc.concat(change.name), []), null, 2);
+      grunt.log.writeln('Changed projects for browser testing:', changeList);
+    });
+    grunt.registerTask('browser-auto', ['list-changed-browser', 'shell:tsc', 'bedrock-auto:browser']);
+    grunt.registerTask('browser-manual', ['list-changed-browser', 'shell:tsc', 'bedrock-manual:browser']);
+  } else {
+    const noBrowser = () => {
+      grunt.log.writeln('no changed modules need browser testing');
+    };
+    grunt.registerTask('browser-auto', noBrowser);
+    grunt.registerTask('browser-manual', noBrowser);
+    grunt.registerTask('list-changed-browser', noBrowser);
+  }
+  grunt.registerTask('legacy-warn', () => grunt.log.warn(`
+*******
+Top-level grunt has been replaced by 'yarn build', and the output has moved from project root to modules/tinymce
+*******
+`));
+  grunt.registerTask('default', ['legacy-warn', 'shell:legacy']);
+  require('load-grunt-tasks')(grunt, {
+    requireResolution: true,
+    config: 'package.json',
+    pattern: ['@ephox/bedrock-server', 'grunt-shell']
+  });
+};

--- a//dev/null
+++ b/bin/build-prism.js
@@ -0,0 +1,31 @@
+#!/usr/bin/env node
+const fs = require('fs');
+const path = require('path');
+const files = [
+  'components/prism-core.js',
+  'components/prism-clike.js',
+  'components/prism-markup-templating.js',
+  'components/prism-c.js',
+  'components/prism-cpp.js',
+  'components/prism-csharp.js',
+  'components/prism-css.js',
+  'components/prism-java.js',
+  'components/prism-javascript.js',
+  'components/prism-markup.js',
+  'components/prism-php.js',
+  'components/prism-python.js',
+  'components/prism-ruby.js'
+];
+let content = `const prismjs = function(global, module, exports) {
+const oldprism = window.Prism;
+window.Prism = { manual: true };
+`;
+files.forEach((file) => {
+  content += fs.readFileSync(path.resolve(__dirname, '../node_modules/prismjs', file)).toString() + '\n';
+});
+content += `// restore the original Prism reference
+window.Prism = oldprism;
+return Prism;
+}(undefined, undefined, undefined);
+export default prismjs;`
+fs.writeFileSync(path.resolve(__dirname, '../node_modules/prismjs/prism.js'), content);

--- a//dev/null
+++ b/modules/acid/src/main/ts/ephox/acid/api/colour/RgbaColour.ts
@@ -0,0 +1,111 @@
+import { Optional } from '@ephox/katamari';
+import { Hex, Hsv, Rgba } from './ColourTypes';
+import * as HexColour from './HexColour';
+const min = Math.min;
+const max = Math.max;
+const round = Math.round;
+const rgbRegex = /^\s*rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*$/i;
+const rgbaRegex = /^\s*rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?(?:\.\d+)?)\s*\)\s*$/i;
+const rgbaColour = (red: number, green: number, blue: number, alpha: number): Rgba => ({
+  red,
+  green,
+  blue,
+  alpha
+});
+const isRgbaComponent = (value: string): boolean => {
+  const num = parseInt(value, 10);
+  return num.toString() === value && num >= 0 && num <= 255;
+};
+const fromHsv = (hsv: Hsv): Rgba => {
+  let r; let g; let b;
+  const hue = (hsv.hue || 0) % 360;
+  let saturation = hsv.saturation / 100;
+  let brightness = hsv.value / 100;
+  saturation = max(0, min(saturation, 1));
+  brightness = max(0, min(brightness, 1));
+  if (saturation === 0) {
+    r = g = b = round(255 * brightness);
+    return rgbaColour(r, g, b, 1);
+  }
+  const side = hue / 60;
+  const chroma = brightness * saturation;
+  const x = chroma * (1 - Math.abs(side % 2 - 1));
+  const match = brightness - chroma;
+  switch (Math.floor(side)) {
+    case 0:
+      r = chroma;
+      g = x;
+      b = 0;
+      break;
+    case 1:
+      r = x;
+      g = chroma;
+      b = 0;
+      break;
+    case 2:
+      r = 0;
+      g = chroma;
+      b = x;
+      break;
+    case 3:
+      r = 0;
+      g = x;
+      b = chroma;
+      break;
+    case 4:
+      r = x;
+      g = 0;
+      b = chroma;
+      break;
+    case 5:
+      r = chroma;
+      g = 0;
+      b = x;
+      break;
+    default:
+      r = g = b = 0;
+  }
+  r = round(255 * (r + match));
+  g = round(255 * (g + match));
+  b = round(255 * (b + match));
+  return rgbaColour(r, g, b, 1);
+};
+const fromHex = (hexColour: Hex): Rgba => {
+  const result = HexColour.extractValues(hexColour);
+  const red = parseInt(result[1], 16);
+  const green = parseInt(result[2], 16);
+  const blue = parseInt(result[3], 16);
+  return rgbaColour(red, green, blue, 1);
+};
+const fromStringValues = (red: string, green: string, blue: string, alpha: string): Rgba => {
+  const r = parseInt(red, 10);
+  const g = parseInt(green, 10);
+  const b = parseInt(blue, 10);
+  const a = parseFloat(alpha);
+  return rgbaColour(r, g, b, a);
+};
+const fromString = (rgbaString: string): Optional<Rgba> => {
+  if (rgbaString === 'transparent') {
+    return Optional.some(rgbaColour(0, 0, 0, 0));
+  }
+  const rgbMatch = rgbRegex.exec(rgbaString);
+  if (rgbMatch !== null) {
+    return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));
+  }
+  const rgbaMatch = rgbaRegex.exec(rgbaString);
+  if (rgbaMatch !== null) {
+    return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));
+  }
+  return Optional.none();
+};
+const toString = (rgba: Rgba): string => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;
+const red = rgbaColour(255, 0, 0, 1);
+export {
+  rgbaColour,
+  isRgbaComponent,
+  fromHsv,
+  fromHex,
+  fromString,
+  toString,
+  red
+};

--- a//dev/null
+++ b/modules/acid/src/main/ts/ephox/acid/api/colour/Transformations.ts
@@ -0,0 +1,36 @@
+import { Hex, Hsv } from './ColourTypes';
+import * as HexColour from './HexColour';
+import * as HsvColour from './HsvColour';
+import * as RgbaColour from './RgbaColour';
+const hexToHsv = (hex: Hex): Hsv => HsvColour.fromRgb(RgbaColour.fromHex(hex));
+const hsvToHex = (hsv: Hsv): Hex => HexColour.fromRgba(RgbaColour.fromHsv(hsv));
+const anyToHex = (color: string): Hex =>
+  HexColour.fromString(color)
+    .orThunk(() => RgbaColour.fromString(color).map(HexColour.fromRgba))
+    .getOrThunk(() => {
+      const canvas = document.createElement('canvas');
+      canvas.height = 1;
+      canvas.width = 1;
+      const canvasContext = canvas.getContext('2d') as CanvasRenderingContext2D;
+      canvasContext.clearRect(0, 0, canvas.width, canvas.height);
+      canvasContext.fillStyle = '#FFFFFF'; // lgtm[js/useless-assignment-to-property]
+      canvasContext.fillStyle = color;
+      canvasContext.fillRect(0, 0, 1, 1);
+      const rgba = canvasContext.getImageData(0, 0, 1, 1).data;
+      const r = rgba[0];
+      const g = rgba[1];
+      const b = rgba[2];
+      const a = rgba[3];
+      return HexColour.fromRgba(RgbaColour.rgbaColour(r, g, b, a));
+    });
+const rgbaToHexString = (color: string): string =>
+  RgbaColour.fromString(color)
+    .map(HexColour.fromRgba)
+    .map((h) => '#' + h.value)
+    .getOr(color);
+export {
+  anyToHex,
+  rgbaToHexString,
+  hexToHsv,
+  hsvToHex
+};

--- a//dev/null
+++ b/modules/acid/src/main/ts/ephox/acid/gui/ColourPicker.ts
@@ -0,0 +1,144 @@
+import {
+  AddEventsBehaviour, AlloyComponent, AlloyEvents, Behaviour, Composing, Keying, Memento, RawDomSchema, SimulatedEvent, Sketcher, Slider
+} from '@ephox/alloy';
+import { FieldSchema } from '@ephox/boulder';
+import { Arr, Cell, Fun } from '@ephox/katamari';
+import { Hex } from '../api/colour/ColourTypes';
+import * as HsvColour from '../api/colour/HsvColour';
+import * as RgbaColour from '../api/colour/RgbaColour';
+import * as Transformations from '../api/colour/Transformations';
+import * as ColourEvents from './ColourEvents';
+import * as HueSlider from './components/HueSlider';
+import * as RgbForm from './components/RgbForm';
+import * as SaturationBrightnessPalette from './components/SaturationBrightnessPalette';
+export interface ColourPickerDetail extends Sketcher.SingleSketchDetail {
+  readonly dom: RawDomSchema;
+  readonly onValidHex: (component: AlloyComponent) => void;
+  readonly onInvalidHex: (component: AlloyComponent) => void;
+}
+export interface ColourPickerSpec extends Sketcher.SingleSketchSpec {
+  readonly dom: RawDomSchema;
+  readonly onValidHex?: (component: AlloyComponent) => void;
+  readonly onInvalidHex?: (component: AlloyComponent) => void;
+}
+export interface ColourPickerSketcher extends Sketcher.SingleSketch<ColourPickerSpec> {
+}
+const makeFactory = (
+  translate: (key: string) => string,
+  getClass: (key: string) => string
+): ColourPickerSketcher => {
+  const factory = (detail: ColourPickerDetail) => {
+    const rgbForm = RgbForm.rgbFormFactory(translate, getClass, detail.onValidHex, detail.onInvalidHex);
+    const sbPalette = SaturationBrightnessPalette.paletteFactory(translate, getClass);
+    const hueSliderToDegrees = (hue: number): number => (100 - hue) / 100 * 360;
+    const hueDegreesToSlider = (hue: number): number => 100 - (hue / 360) * 100;
+    const state = {
+      paletteRgba: Cell(RgbaColour.red),
+      paletteHue: Cell(0)
+    };
+    const memSlider = Memento.record(
+      HueSlider.sliderFactory(translate, getClass)
+    );
+    const memPalette = Memento.record(
+      sbPalette.sketch({})
+    );
+    const memRgb = Memento.record(
+      rgbForm.sketch({})
+    );
+    const updatePalette = (anyInSystem: AlloyComponent, _hex: Hex, hue: number) => {
+      memPalette.getOpt(anyInSystem).each((palette) => {
+        sbPalette.setHue(palette, hue);
+      });
+    };
+    const updateFields = (anyInSystem: AlloyComponent, hex: Hex) => {
+      memRgb.getOpt(anyInSystem).each((form) => {
+        rgbForm.updateHex(form, hex);
+      });
+    };
+    const updateSlider = (anyInSystem: AlloyComponent, _hex: Hex, hue: number) => {
+      memSlider.getOpt(anyInSystem).each((slider) => {
+        Slider.setValue(slider, hueDegreesToSlider(hue));
+      });
+    };
+    const updatePaletteThumb = (anyInSystem: AlloyComponent, hex: Hex) => {
+      memPalette.getOpt(anyInSystem).each((palette) => {
+        sbPalette.setThumb(palette, hex);
+      });
+    };
+    const updateState = (hex: Hex, hue: number) => {
+      const rgba = RgbaColour.fromHex(hex);
+      state.paletteRgba.set(rgba);
+      state.paletteHue.set(hue);
+    };
+    const runUpdates = (anyInSystem: AlloyComponent, hex: Hex, hue: number, updates: ((anyInSystem: AlloyComponent, hex: Hex, hue: number) => void)[]) => {
+      updateState(hex, hue);
+      Arr.each(updates, (update) => {
+        update(anyInSystem, hex, hue);
+      });
+    };
+    const onPaletteUpdate = () => {
+      const updates = [ updateFields ];
+      return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.PaletteUpdateEvent>) => {
+        const value = simulatedEvent.event.value;
+        const oldHue = state.paletteHue.get();
+        const newHsv = HsvColour.hsvColour(oldHue, value.x, (100 - value.y));
+        const newHex = Transformations.hsvToHex(newHsv);
+        runUpdates(form, newHex, oldHue, updates);
+      };
+    };
+    const onSliderUpdate = () => {
+      const updates = [ updatePalette, updateFields ];
+      return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.SliderUpdateEvent>) => {
+        const hue = hueSliderToDegrees(simulatedEvent.event.value);
+        const oldRgb = state.paletteRgba.get();
+        const oldHsv = HsvColour.fromRgb(oldRgb);
+        const newHsv = HsvColour.hsvColour(hue, oldHsv.saturation, oldHsv.value);
+        const newHex = Transformations.hsvToHex(newHsv);
+        runUpdates(form, newHex, hue, updates);
+      };
+    };
+    const onFieldsUpdate = () => {
+      const updates = [ updatePalette, updateSlider, updatePaletteThumb ];
+      return (form: AlloyComponent, simulatedEvent: SimulatedEvent<ColourEvents.FieldsUpdateEvent>) => {
+        const hex = simulatedEvent.event.hex;
+        const hsv = Transformations.hexToHsv(hex);
+        runUpdates(form, hex, hsv.hue, updates);
+      };
+    };
+    return {
+      uid: detail.uid,
+      dom: detail.dom,
+      components: [
+        memPalette.asSpec(),
+        memSlider.asSpec(),
+        memRgb.asSpec()
+      ],
+      behaviours: Behaviour.derive([
+        AddEventsBehaviour.config('colour-picker-events', [
+          AlloyEvents.run(ColourEvents.fieldsUpdate, onFieldsUpdate()),
+          AlloyEvents.run(ColourEvents.paletteUpdate, onPaletteUpdate()),
+          AlloyEvents.run(ColourEvents.sliderUpdate, onSliderUpdate())
+        ]),
+        Composing.config({
+          find: (comp) => memRgb.getOpt(comp)
+        }),
+        Keying.config({
+          mode: 'acyclic'
+        })
+      ])
+    };
+  };
+  const colourPickerSketcher = Sketcher.single({
+    name: 'ColourPicker',
+    configFields: [
+      FieldSchema.required('dom'),
+      FieldSchema.defaulted('onValidHex', Fun.noop),
+      FieldSchema.defaulted('onInvalidHex', Fun.noop)
+    ],
+    factory
+  }) as ColourPickerSketcher;
+  return colourPickerSketcher;
+};
+export {
+  makeFactory
+};

--- a//dev/null
+++ b/modules/acid/src/main/ts/ephox/acid/gui/components/HueSlider.ts
@@ -0,0 +1,52 @@
+import { AlloyComponent, AlloyTriggers, Behaviour, Focusing, SketchSpec, Slider } from '@ephox/alloy';
+import { Fun } from '@ephox/katamari';
+import { sliderUpdate } from '../ColourEvents';
+const sliderFactory = (translate: (key: string) => string, getClass: (key: string) => string): SketchSpec => {
+  const spectrum = Slider.parts.spectrum({
+    dom: {
+      tag: 'div',
+      classes: [ getClass('hue-slider-spectrum') ],
+      attributes: {
+        role: 'presentation'
+      }
+    }
+  });
+  const thumb = Slider.parts.thumb({
+    dom: {
+      tag: 'div',
+      classes: [ getClass('hue-slider-thumb') ],
+      attributes: {
+        role: 'presentation'
+      }
+    }
+  });
+  return Slider.sketch({
+    dom: {
+      tag: 'div',
+      classes: [ getClass('hue-slider') ],
+      attributes: {
+        role: 'presentation'
+      }
+    },
+    rounded: false,
+    model: {
+      mode: 'y',
+      getInitialValue: Fun.constant(0)
+    },
+    components: [
+      spectrum,
+      thumb
+    ],
+    sliderBehaviours: Behaviour.derive([
+      Focusing.config({ })
+    ]),
+    onChange: (slider: AlloyComponent, _thumb: any, value: any) => {
+      AlloyTriggers.emitWith(slider, sliderUpdate, {
+        value
+      });
+    }
+  });
+};
+export {
+  sliderFactory
+};

--- a//dev/null
+++ b/modules/acid/src/main/ts/ephox/acid/gui/components/RgbForm.ts
@@ -0,0 +1,288 @@
+import {
+  AddEventsBehaviour, AlloyComponent, AlloyEvents, AlloyTriggers, Behaviour, EventFormat, Focusing, Form, FormField, FormTypes, GuiFactory, Input, Invalidating,
+  Memento, Representing, SimulatedEvent, Sketcher, SketchSpec, Tabstopping, UiSketcher
+} from '@ephox/alloy';
+import { Cell, Fun, Future, Id, Merger, Optional, Result } from '@ephox/katamari';
+import { Css } from '@ephox/sugar';
+import { Hex, Rgba } from '../../api/colour/ColourTypes';
+import * as HexColour from '../../api/colour/HexColour';
+import * as RgbaColour from '../../api/colour/RgbaColour';
+import * as ColourEvents from '../ColourEvents';
+const validInput = Id.generate('valid-input');
+const invalidInput = Id.generate('invalid-input');
+const validatingInput = Id.generate('validating-input');
+interface HexInputEvent extends EventFormat {
+  readonly type: 'hex';
+  readonly value: string;
+}
+interface ColorInputEvent extends EventFormat {
+  readonly type: 'red' | 'green' | 'blue';
+  readonly value: string;
+}
+type InputEvent = HexInputEvent | ColorInputEvent;
+const translatePrefix = 'colorcustom.rgb.';
+export interface RgbFormDetail extends Sketcher.SingleSketchDetail {
+}
+export interface RgbFormSpec extends Sketcher.SingleSketchSpec {
+}
+export interface RgbFormSketcher extends Sketcher.SingleSketch<RgbFormSpec> {
+  updateHex: (slider: AlloyComponent, colour: Hex) => void;
+}
+const rgbFormFactory = (
+  translate: (key: string) => string,
+  getClass: (key: string) => string,
+  onValidHexx: (component: AlloyComponent) => void,
+  onInvalidHexx: (component: AlloyComponent) => void
+): RgbFormSketcher => {
+  const invalidation = (label: string, isValid: (value: string) => boolean) => Invalidating.config({
+    invalidClass: getClass('invalid'),
+    notify: {
+      onValidate: (comp: AlloyComponent) => {
+        AlloyTriggers.emitWith(comp, validatingInput, {
+          type: label
+        });
+      },
+      onValid: (comp: AlloyComponent) => {
+        AlloyTriggers.emitWith(comp, validInput, {
+          type: label,
+          value: Representing.getValue(comp)
+        });
+      },
+      onInvalid: (comp: AlloyComponent) => {
+        AlloyTriggers.emitWith(comp, invalidInput, {
+          type: label,
+          value: Representing.getValue(comp)
+        });
+      }
+    },
+    validator: {
+      validate: (comp: AlloyComponent) => {
+        const value = Representing.getValue(comp);
+        const res = isValid(value) ? Result.value(true) : Result.error(translate('aria.input.invalid'));
+        return Future.pure(res);
+      },
+      validateOnLoad: false
+    }
+  });
+  const renderTextField = (
+    isValid: (value: string) => boolean,
+    name: string,
+    label: string,
+    description: string,
+    data: string | number
+  ) => {
+    const helptext = translate(translatePrefix + 'range');
+    const pLabel = FormField.parts.label({
+      dom: { tag: 'label', attributes: { 'aria-label': description }},
+      components: [ GuiFactory.text(label) ]
+    });
+    const pField = FormField.parts.field({
+      data,
+      factory: Input,
+      inputAttributes: {
+        type: 'text',
+        ...name === 'hex' ? { 'aria-live': 'polite' } : {}
+      },
+      inputClasses: [ getClass('textfield') ],
+      inputBehaviours: Behaviour.derive([
+        invalidation(name, isValid),
+        Tabstopping.config({})
+      ]),
+      onSetValue: (input: AlloyComponent) => {
+        if (Invalidating.isInvalid(input)) {
+          const run = Invalidating.run(input);
+          run.get(Fun.noop);
+        }
+      }
+    });
+    const comps = [ pLabel, pField ];
+    const concats = name !== 'hex' ? [ FormField.parts['aria-descriptor']({
+      text: helptext
+    }) ] : [];
+    const components = comps.concat(concats);
+    return {
+      dom: {
+        tag: 'div',
+        attributes: {
+          role: 'presentation'
+        }
+      },
+      components
+    };
+  };
+  const copyRgbToHex = (form: AlloyComponent, rgba: Rgba) => {
+    const hex = HexColour.fromRgba(rgba);
+    Form.getField(form, 'hex').each((hexField: AlloyComponent) => {
+      if (!Focusing.isFocused(hexField)) {
+        Representing.setValue(form, {
+          hex: hex.value
+        });
+      }
+    });
+    return hex;
+  };
+  const copyRgbToForm = (form: AlloyComponent, rgb: Rgba): void => {
+    const red = rgb.red; const green = rgb.green; const blue = rgb.blue;
+    Representing.setValue(form, { red, green, blue });
+  };
+  const memPreview = Memento.record(
+    {
+      dom: {
+        tag: 'div',
+        classes: [ getClass('rgba-preview') ],
+        styles: {
+          'background-color': 'white'
+        },
+        attributes: {
+          role: 'presentation'
+        }
+      }
+    }
+  );
+  const updatePreview = (anyInSystem: AlloyComponent, hex: Hex) => {
+    memPreview.getOpt(anyInSystem).each((preview: AlloyComponent) => {
+      Css.set(preview.element, 'background-color', '#' + hex.value);
+    });
+  };
+  const factory: UiSketcher.SingleSketchFactory<RgbFormDetail, RgbFormSpec> = (): SketchSpec => {
+    const state = {
+      red: Cell(Optional.some(255)),
+      green: Cell(Optional.some(255)),
+      blue: Cell(Optional.some(255)),
+      hex: Cell(Optional.some('ffffff'))
+    };
+    const copyHexToRgb = (form: AlloyComponent, hex: Hex) => {
+      const rgb = RgbaColour.fromHex(hex);
+      copyRgbToForm(form, rgb);
+      setValueRgb(rgb);
+    };
+    const get = (prop: keyof typeof state): Optional<any> => state[prop].get();
+    const set = (prop: keyof typeof state, value: Optional<any>): void => {
+      state[prop].set(value);
+    };
+    const getValueRgb = () => get('red').bind(
+      (red) => get('green').bind(
+        (green) => get('blue').map(
+          (blue) => RgbaColour.rgbaColour(red, green, blue, 1)
+        )
+      )
+    );
+    const setValueRgb = (rgb: Rgba): void => {
+      const red = rgb.red; const green = rgb.green; const blue = rgb.blue;
+      set('red', Optional.some(red));
+      set('green', Optional.some(green));
+      set('blue', Optional.some(blue));
+    };
+    const onInvalidInput = (form: AlloyComponent, simulatedEvent: SimulatedEvent<InputEvent>) => {
+      const data = simulatedEvent.event;
+      if (data.type !== 'hex') {
+        set(data.type, Optional.none());
+      } else {
+        onInvalidHexx(form);
+      }
+    };
+    const onValidHex = (form: AlloyComponent, value: string) => {
+      onValidHexx(form);
+      const hex = HexColour.hexColour(value);
+      set('hex', Optional.some(value));
+      const rgb = RgbaColour.fromHex(hex);
+      copyRgbToForm(form, rgb);
+      setValueRgb(rgb);
+      AlloyTriggers.emitWith(form, ColourEvents.fieldsUpdate, {
+        hex
+      });
+      updatePreview(form, hex);
+    };
+    const onValidRgb = (form: AlloyComponent, prop: 'red' | 'green' | 'blue', value: string) => {
+      const val = parseInt(value, 10);
+      set(prop, Optional.some(val));
+      getValueRgb().each((rgb) => {
+        const hex = copyRgbToHex(form, rgb);
+        AlloyTriggers.emitWith(form, ColourEvents.fieldsUpdate, {
+          hex
+        });
+        updatePreview(form, hex);
+      });
+    };
+    const isHexInputEvent = (data: InputEvent): data is HexInputEvent => data.type === 'hex';
+    const onValidInput = (form: AlloyComponent, simulatedEvent: SimulatedEvent<InputEvent>) => {
+      const data = simulatedEvent.event;
+      if (isHexInputEvent(data)) {
+        onValidHex(form, data.value);
+      } else {
+        onValidRgb(form, data.type, data.value);
+      }
+    };
+    const formPartStrings = (key: string) => ({
+      label: translate(translatePrefix + key + '.label'),
+      description: translate(translatePrefix + key + '.description')
+    });
+    const redStrings = formPartStrings('red');
+    const greenStrings = formPartStrings('green');
+    const blueStrings = formPartStrings('blue');
+    const hexStrings = formPartStrings('hex');
+    return Merger.deepMerge(
+      Form.sketch((parts: FormTypes.FormParts) => ({
+        dom: {
+          tag: 'form',
+          classes: [ getClass('rgb-form') ],
+          attributes: { 'aria-label': translate('aria.color.picker') }
+        },
+        components: [
+          parts.field('red', FormField.sketch(
+            renderTextField(RgbaColour.isRgbaComponent, 'red', redStrings.label, redStrings.description, 255)
+          )),
+          parts.field('green', FormField.sketch(
+            renderTextField(RgbaColour.isRgbaComponent, 'green', greenStrings.label, greenStrings.description, 255)
+          )),
+          parts.field('blue', FormField.sketch(
+            renderTextField(RgbaColour.isRgbaComponent, 'blue', blueStrings.label, blueStrings.description, 255)
+          )),
+          parts.field('hex', FormField.sketch(
+            renderTextField(HexColour.isHexString, 'hex', hexStrings.label, hexStrings.description, 'ffffff')
+          )),
+          memPreview.asSpec()
+        ],
+        formBehaviours: Behaviour.derive([
+          Invalidating.config({
+            invalidClass: getClass('form-invalid')
+          }),
+          AddEventsBehaviour.config('rgb-form-events', [
+            AlloyEvents.run(validInput, onValidInput),
+            AlloyEvents.run(invalidInput, onInvalidInput),
+            AlloyEvents.run(validatingInput, onInvalidInput)
+          ])
+        ])
+      })),
+      {
+        apis: {
+          updateHex: (form: AlloyComponent, hex: Hex) => {
+            Representing.setValue(form, {
+              hex: hex.value
+            });
+            copyHexToRgb(form, hex);
+            updatePreview(form, hex);
+          }
+        }
+      }
+    );
+  };
+  interface Apis {
+    updateHex(form: AlloyComponent, hex: Hex): void;
+  }
+  const rgbFormSketcher = Sketcher.single({
+    factory,
+    name: 'RgbForm',
+    configFields: [],
+    apis: {
+      updateHex: (apis: Apis, form: AlloyComponent, hex: Hex) => {
+        apis.updateHex(form, hex);
+      }
+    },
+    extraApis: {}
+  }) as RgbFormSketcher;
+  return rgbFormSketcher;
+};
+export {
+  rgbFormFactory
+};

--- a//dev/null
+++ b/modules/agar/src/demo/ts/ephox/agar/demo/DemoContainer.ts
@@ -0,0 +1,29 @@
+import { Class, Html, Insert, InsertAll, Remove, SugarElement, SugarElements } from '@ephox/sugar';
+export const init = (name: string, f: (success: () => void, failure: (err: any) => void) => SugarElement<Node>[]): void => {
+  const container = SugarElement.fromTag('div');
+  Class.add(container, 'demo-container');
+  Html.set(container, '<p>' + name + '</p>');
+  const outcome = SugarElement.fromTag('div');
+  Html.set(outcome, 'Running ....');
+  const success = () => {
+    Class.add(outcome, 'success');
+    Html.set(outcome, 'Success!');
+  };
+  const htmlentities = (str: string): string =>
+    String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
+  const keepMarkers = (html: string): string =>
+    html.replace(/&lt;del&gt;/g, '<del>').replace(/&lt;\/del&gt;/g, '</del>').replace(/&lt;ins&gt;/g, '<ins>').replace(/&lt;\/ins&gt;/g, '</ins>');
+  const failure = (err: any): void => {
+    Class.add(outcome, 'failure');
+    Remove.empty(outcome);
+    if (err.diff) {
+      InsertAll.append(outcome, SugarElements.fromHtml(keepMarkers(htmlentities(err.diff.comparison))));
+    } else {
+      Insert.append(outcome, SugarElement.fromText(err));
+    }
+  };
+  Insert.append(container, outcome);
+  const elements = f(success, failure);
+  InsertAll.append(container, elements);
+  Insert.append(SugarElement.fromDom(document.body), container);
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/alien/SizzleFind.ts
@@ -0,0 +1,33 @@
+import { Arr, Optional } from '@ephox/katamari';
+import { SugarElement, SugarNode, Traverse } from '@ephox/sugar';
+import * as Sizzle from 'sizzle';
+type SizzleContext = Element | Document | DocumentFragment;
+const toOptionEl = <T extends Element>(output: T[]): Optional<SugarElement<T>> =>
+  output.length === 0 ? Optional.none() : Optional.from(output[0]).map(SugarElement.fromDom);
+/* Petrie makes extensive use of :visible, :has() and :contains() which are sizzle extensions */
+const descendant = <T extends Element>(sugarElement: SugarElement<SizzleContext>, selector: string): Optional<SugarElement<T>> => {
+  const siz = Sizzle(selector, sugarElement.dom) as T[];
+  return toOptionEl(siz);
+};
+const toArrayEl = <T extends Node | Window>(elements: T[]): SugarElement<T>[] =>
+  Arr.map(elements, SugarElement.fromDom);
+/* Petrie makes extensive use of :visible, :has() and :contains() which are sizzle extensions */
+const descendants = <T extends Element>(sugarElement: SugarElement<SizzleContext>, selector: string): SugarElement<T>[] =>
+  toArrayEl(Sizzle(selector, sugarElement.dom) as T[]);
+const matches = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): sugarElement is SugarElement<T> =>
+  SugarNode.isElement(sugarElement) && Sizzle.matchesSelector(sugarElement.dom, selector);
+const child = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): Optional<SugarElement<T>> => {
+  const children = Traverse.children(sugarElement);
+  return Arr.find(children, (child): child is SugarElement<T> => matches(child, selector));
+};
+const children = <T extends Element>(sugarElement: SugarElement<Node>, selector: string): SugarElement<T>[] => {
+  const children = Traverse.children(sugarElement);
+  return Arr.filter(children, (child): child is SugarElement<T> => matches(child, selector));
+};
+export {
+  descendant,
+  descendants,
+  matches,
+  child,
+  children
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/ApproxStructure.ts
@@ -0,0 +1,63 @@
+import { Arr, Obj } from '@ephox/katamari';
+import { Attribute, Classes, Css, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
+import * as ApproxComparisons from '../assertions/ApproxComparisons';
+import * as ApproxStructures from '../assertions/ApproxStructures';
+type StringAssert = ApproxStructures.StringAssert;
+type ArrayAssert = ApproxStructures.ArrayAssert;
+type StructAssert = ApproxStructures.StructAssert;
+type StructAssertBasic = ApproxStructures.StructAssertBasic;
+type StructAssertAdv = ApproxStructures.StructAssertAdv;
+type CombinedAssert = ApproxComparisons.CombinedAssert;
+export type ArrayApi = typeof arrApi;
+export type StringApi = typeof strApi;
+export type StructApi = typeof structApi;
+export type Builder<T> = (struct: StructApi, str: StringApi, arr: ArrayApi) => T;
+const structApi = {
+  element: ApproxStructures.element,
+  text: ApproxStructures.text,
+  anything: ApproxStructures.anything,
+  either: ApproxStructures.either,
+  repeat: ApproxStructures.repeat,
+  zeroOrOne: ApproxStructures.zeroOrOne,
+  zeroOrMore: ApproxStructures.zeroOrMore,
+  oneOrMore: ApproxStructures.oneOrMore,
+  theRest: ApproxStructures.theRest
+};
+const strApi = {
+  is: ApproxComparisons.is,
+  startsWith: ApproxComparisons.startsWith,
+  contains: ApproxComparisons.contains,
+  none: ApproxComparisons.none
+};
+const arrApi = {
+  not: ApproxComparisons.not,
+  has: ApproxComparisons.has,
+  hasPrefix: ApproxComparisons.hasPrefix
+};
+const build = <T>(f: Builder<T>): T =>
+  f(structApi, strApi, arrApi);
+const getAttrsExcept = (node: SugarElement<Element>, exclude: string[]): Record<string, string> =>
+  Obj.bifilter(Attribute.clone(node), (value, key) => !Arr.contains(exclude, key)).t;
+const toAssertableObj = (obj: Record<string, string>): Record<string, CombinedAssert> =>
+  Obj.map(obj, ApproxComparisons.is);
+const toAssertableArr = (arr: string[]): (StringAssert & ArrayAssert)[] =>
+  Arr.map(arr, ApproxComparisons.has);
+const fromElement = (node: SugarElement<Node>): StructAssert => {
+  if (SugarNode.isElement(node)) {
+    return ApproxStructures.element(SugarNode.name(node), {
+      children: Arr.map(Traverse.children(node), fromElement),
+      attrs: toAssertableObj(getAttrsExcept(node, [ 'style', 'class' ])),
+      styles: toAssertableObj(Css.getAllRaw(node)),
+      classes: toAssertableArr(Classes.get(node))
+    });
+  } else {
+    return ApproxStructures.text(ApproxComparisons.is(SugarNode.value(node)), true);
+  }
+};
+const fromHtml = (html: string): StructAssertBasic | StructAssertAdv =>
+  fromElement(SugarElement.fromHtml(html));
+export {
+  build,
+  fromHtml,
+  fromElement
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Arbitraries.ts
@@ -0,0 +1,25 @@
+import { SimRange, SugarElement } from '@ephox/sugar';
+import * as fc from 'fast-check';
+import * as ArbContent from '../arbitrary/ArbContent';
+import { SchemaDetail } from '../arbitrary/ArbSchemaTypes';
+import { SelectionExclusions } from '../arbitrary/GenSelection';
+import * as Generators from './Generators';
+const scenario = (
+  component: string,
+  overrides: Record<string, Partial<SchemaDetail>>,
+  exclusions: SelectionExclusions
+): fc.Arbitrary<{ root: SugarElement<Node>; selection: SimRange }> => {
+  const arbitrary = content(component, overrides);
+  return arbitrary.chain((root) =>
+    Generators.selection(root, exclusions).map((selection) => ({
+      root,
+      selection
+    }))
+  );
+};
+const content = <T extends Node>(component: string, overrides?: Record<string, Partial<SchemaDetail>>): fc.Arbitrary<SugarElement<T>> =>
+  ArbContent.arbOf<T>(component, overrides);
+export {
+  scenario,
+  content
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Assertions.ts
@@ -0,0 +1,92 @@
+import { Assert, TestError, TestLabel } from '@ephox/bedrock-client';
+import { Obj, Optional } from '@ephox/katamari';
+import { Compare, SugarElement, Truncate } from '@ephox/sugar';
+import { elementQueue, StructAssert } from '../assertions/ApproxStructures';
+import * as Differ from '../assertions/Differ';
+import * as ApproxStructure from './ApproxStructure';
+import { Chain } from './Chain';
+import * as Logger from './Logger';
+import { Step } from './Step';
+import * as UiFinder from './UiFinder';
+const toStep = <U extends any[]>(method: (...args: U) => void) =>
+  <T>(...args: U) => Step.sync<T>(() => {
+    method.apply(undefined, args);
+  });
+const toChain = <B, C>(method: (label: TestLabel, expected: B, actual: C) => void) =>
+  (label: string, expected: B): Chain<C, C> =>
+    Chain.op<C>((actual: C) => {
+      method.call(undefined, label, expected, actual);
+    });
+const textError = (label: string, expected: string, actual: string): TestError.HtmlDiffAssertionError => {
+  const err: Partial<TestError.HtmlDiffAssertionError> = new Error(label);
+  err.diff = {
+    expected,
+    actual,
+    comparison: Differ.htmlDiff(expected, actual)
+  };
+  err.label = label;
+  err.name = 'HtmlAssertion';
+  return err as TestError.HtmlDiffAssertionError;
+};
+const assertHtml = (label: TestLabel, expected: string, actual: string): void => {
+  if (expected !== actual) {
+    throw textError(TestLabel.asString(label), expected, actual);
+  }
+};
+const assertStructure = (label: TestLabel, expected: StructAssert, container: SugarElement<Node>): void => {
+  Logger.sync(label, () => {
+    if (expected.type === 'advanced') {
+      expected.doAssert(elementQueue([ container ], Optional.none()));
+    } else {
+      expected.doAssert(container);
+    }
+  });
+};
+const assertHtmlStructure = (label: TestLabel, expected: string, actual: string): void => {
+  assertStructure(label, ApproxStructure.fromHtml(expected), SugarElement.fromHtml(actual));
+};
+const assertHtmlStructure2 = (label: TestLabel, expected: string, actual: SugarElement<Node>): void => {
+  assertStructure(label, ApproxStructure.fromHtml(expected), actual);
+};
+const assertPresence = (label: TestLabel, expected: Record<string, number>, container: SugarElement<Node>): void => {
+  Obj.each(expected, (num: number, selector: string) => {
+    const actual = UiFinder.findAllIn(container, selector).length;
+    Assert.eq(TestLabel.concat('Did not find ' + num + ' of ' + selector + ', found: ' + actual + '. Test: ', label), num, actual);
+  });
+};
+const assertEq = Assert.eq;
+const assertDomEq = (label: TestLabel, expected: SugarElement<Node>, actual: SugarElement<Node>): void => {
+  Assert.eq(
+    TestLabel.concat(label, () => '\nExpected : ' + Truncate.getHtml(expected) + '\nActual: ' + Truncate.getHtml(actual)),
+    true,
+    Compare.eq(expected, actual)
+  );
+};
+const sAssertEq: <T, V> (label: TestLabel, expected: V, actual: V) => Step<T, T> = toStep(Assert.eq);
+const sAssertHtml = toStep(assertHtml);
+const sAssertPresence = toStep(assertPresence);
+const sAssertStructure = toStep(assertStructure);
+const cAssertEq: <T> (label: string, expected: T) => Chain<T, T> = toChain(Assert.eq);
+const cAssertDomEq = toChain(assertDomEq);
+const cAssertHtml = toChain(assertHtml);
+const cAssertPresence = toChain(assertPresence);
+const cAssertHtmlStructure = toChain(assertHtmlStructure2);
+const cAssertStructure = toChain(assertStructure);
+export {
+  assertEq,
+  assertDomEq,
+  assertHtml,
+  assertPresence,
+  assertHtmlStructure,
+  assertStructure,
+  sAssertEq,
+  sAssertHtml,
+  sAssertPresence,
+  sAssertStructure,
+  cAssertEq,
+  cAssertDomEq,
+  cAssertHtml,
+  cAssertPresence,
+  cAssertHtmlStructure,
+  cAssertStructure
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Chain.ts
@@ -0,0 +1,213 @@
+import { Failure } from '@ephox/bedrock-common';
+import { Arr, Fun, Result } from '@ephox/katamari';
+import * as AsyncActions from '../pipe/AsyncActions';
+import * as GeneralActions from '../pipe/GeneralActions';
+import { DieFn, NextFn, Pipe, RunFn } from '../pipe/Pipe';
+import { addLogging, GuardFn } from './Guard';
+import { Pipeline } from './Pipeline';
+import { Step } from './Step';
+import { addLogEntry, TestLogs } from './TestLogs';
+export interface Chain<T, U> {
+  runChain: RunFn<T, U>;
+}
+export type ChainGuard<T, U, V> = GuardFn<T, U, V>;
+const on = <T, U>(f: (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void): Chain<T, U> => {
+  const runChain = Pipe((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    f(input, (v: U, newLogs) => {
+      next(v, newLogs);
+    }, (err, newLogs) => die(err, newLogs), logs);
+  });
+  return {
+    runChain
+  };
+};
+const control = <T, U, V>(chain: Chain<T, U>, guard: ChainGuard<T, U, V>): Chain<T, V> =>
+  on((input: T, next: NextFn<V>, die: DieFn, logs: TestLogs) => {
+    guard(chain.runChain, input, (v: V, newLogs: TestLogs) => {
+      next(v, newLogs);
+    }, die, logs);
+  });
+const mapper = <T, U>(fx: (value: T) => U): Chain<T, U> =>
+  on((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    next(fx(input), logs);
+  });
+const identity = mapper(Fun.identity);
+const binder = <T, U, E>(fx: (input: T) => Result<U, E>): Chain<T, U> =>
+  on((input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    fx(input).fold((err) => {
+      die(err, logs);
+    }, (v) => {
+      next(v, logs);
+    });
+  });
+const op = <T>(fx: (value: T) => void): Chain<T, T> =>
+  on((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    fx(input);
+    next(input, logs);
+  });
+const async = <T, U>(fx: (input: T, next: (v: U) => void, die: (err) => void) => void): Chain<T, U> =>
+  on<T, U>((v, n, d, logs) => fx(v, (v) => n(v, logs), (err) => d(err, logs)));
+const inject = <T, U>(value: U): Chain<T, U> =>
+  on((_input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    next(value, logs);
+  });
+const injectThunked = <T, U>(f: () => U): Chain<T, U> =>
+  on((_input: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    next(f(), logs);
+  });
+const extract = <T, U>(chain: Chain<T, U>): Step<T, U> => ({
+  runStep: chain.runChain
+});
+const fromChains = <T = any, U = any>(chains: Chain<any, any>[]): Chain<T, U> => {
+  const cs = Arr.map(chains, extract);
+  return on<T, U>((value, next, die, initLogs) => {
+    Pipeline.async(value, cs, (v, newLogs) => next(v, newLogs), die, initLogs);
+  });
+};
+const fromChainsWith = <T, U = any, V = any>(initial: T, chains: Chain<any, any>[]): Chain<U, V> =>
+  fromChains<U, V>(
+    [ inject(initial) ].concat(chains)
+  );
+const fromIsolatedChains = <T = any>(chains: Chain<any, any>[]): Chain<T, T> => {
+  const cs = Arr.map(chains, extract);
+  return on<T, T>((value, next, die, initLogs) => {
+    Pipeline.async(value, cs, (_v, newLogs) => {
+      next(value, newLogs);
+    }, die, initLogs);
+  });
+};
+const fromIsolatedChainsWith = <T, U = any>(initial: T, chains: Chain<any, any>[]): Chain<U, U> =>
+  fromIsolatedChains<U>(
+    [ inject(initial) ].concat(chains)
+  );
+const exists = <T, U>(chains: Chain<T, U>[]): Chain<T, U> => {
+  const cs = Arr.map(chains, extract);
+  let index = 0;
+  const attempt = (value: T, next: NextFn<U>, die: DieFn, initLogs: TestLogs): void => {
+    let replacementDie = die;
+    if (index + 1 < cs.length) {
+      replacementDie = () => {
+        index += 1;
+        attempt(value, next, die, initLogs);
+      };
+    }
+    Pipeline.runStep(value, cs[index], next, replacementDie, initLogs);
+  };
+  return on(attempt);
+};
+const fromParent = <T, U, V>(parent: Chain<T, U>, chains: Chain<U, V>[]): Chain<T, U> =>
+  on((cvalue: T, cnext: NextFn<U>, cdie: DieFn, clogs: TestLogs) => {
+    Pipeline.async(cvalue, [ extract(parent) ], (value: U, parentLogs: TestLogs) => {
+      const cs = Arr.map(chains, (c) =>
+        Step.raw((_, next, die, logs) => {
+          c.runChain(value, next, die, logs);
+        }));
+      Pipeline.async(cvalue, cs, (_, finalLogs) => {
+        cnext(value, finalLogs);
+      }, cdie, parentLogs);
+    }, cdie, clogs);
+  });
+/**
+ * @deprecated Use isolate() instead
+ * TODO: remove
+ */
+const asStep = <T, U>(initial: U, chains: Chain<any, any>[]): Step<T, T> =>
+  Step.raw<T, T>((initValue, next, die, logs) => {
+    const cs = Arr.map(chains, extract);
+    Pipeline.async(
+      initial,
+      cs,
+      (_v, ls) => {
+        next(initValue, ls);
+      },
+      die,
+      logs
+    );
+  });
+/**
+ * Wrap a Chain into an "isolated" Step, with its own local state.
+ * The state of the outer Step is passed-through.
+ * Use the functions in ChainSequence to compose multiple Chains.
+ *
+ * @param initial
+ * @param chain
+ */
+const isolate = <T, U, V>(initial: U, chain: Chain<U, V>): Step<T, T> =>
+  Step.raw<T, T>((initValue, next, die, logs) => {
+    Pipeline.runStep(
+      initial,
+      extract(chain),
+      (_v, ls) => {
+        next(initValue, ls);
+      },
+      die,
+      logs
+    );
+  });
+const debugging = op(GeneralActions.debug);
+const log = <T>(message: string): Chain<T, T> =>
+  on((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    console.log(message);
+    next(input, addLogEntry(logs, message));
+  });
+const label = <T, U>(label: string, chain: Chain<T, U>): Chain<T, U> =>
+  control(chain, addLogging(label));
+const wait = <T>(amount: number): Chain<T, T> =>
+  on<T, T>((input: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    AsyncActions.delay(amount)(() => next(input, logs), die);
+  });
+const pipeline = (chains: Chain<any, any>[], onSuccess: NextFn<any>, onFailure: DieFn, initLogs?: TestLogs): void => {
+  Pipeline.async({}, Arr.map(chains, extract), (output, logs) => {
+    onSuccess(output, logs);
+  }, onFailure, TestLogs.getOrInit(initLogs));
+};
+const runStepsOnValue = <I, O>(getSteps: (value: I) => Step<I, O>[]): Chain<I, O> =>
+  Chain.on((input: I, next, die, initLogs) => {
+    const steps = getSteps(input);
+    Pipeline.async(input, steps, (stepsOutput, newLogs) => next(stepsOutput, newLogs), die, initLogs);
+  });
+const predicate = <T>(p: (value: T) => boolean): Chain<T, T> =>
+  on((input, next, die, logs) =>
+    p(input) ? next(input, logs) : die('predicate did not succeed', logs));
+const toPromise = <A, B>(c: Chain<A, B>) => (a: A): Promise<B> =>
+  new Promise((resolve, reject) => {
+    c.runChain(a,
+      (b, _logs) => {
+        resolve(b);
+      }, (err, logs) => {
+        reject(Failure.prepFailure(err, logs));
+      },
+      TestLogs.init()
+    );
+  });
+const fromPromise = <A, B>(f: (a: A) => Promise<B>): Chain<A, B> => Chain.async((input, next, die) => {
+  f(input).then(next, die);
+});
+export const Chain = {
+  on,
+  op,
+  async,
+  control,
+  mapper,
+  identity,
+  binder,
+  runStepsOnValue,
+  inject,
+  injectThunked,
+  fromChains,
+  fromChainsWith,
+  fromIsolatedChains,
+  fromIsolatedChainsWith,
+  exists,
+  fromParent,
+  asStep,
+  isolate,
+  wait,
+  debugging,
+  log,
+  label,
+  toPromise,
+  fromPromise,
+  pipeline,
+  predicate
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Clipboard.ts
@@ -0,0 +1,85 @@
+import { Arr, Obj } from '@ephox/katamari';
+import { SugarBody, SugarElement } from '@ephox/sugar';
+import { createCopyEvent, createCutEvent, createPasteEvent } from '../clipboard/ClipboardEvents';
+import { createDataTransfer } from '../datatransfer/DataTransfer';
+import { getWindowFromElement } from '../dragndrop/DndEvents';
+import { Chain } from './Chain';
+import * as ChainSequence from './ChainSequence';
+import { Step } from './Step';
+import { cFindIn } from './UiFinder';
+const pasteDataTransfer = (target: SugarElement<Element>, mutator: (dataTransfer: DataTransfer) => void): void => {
+  const win = getWindowFromElement(target);
+  const dataTransfer = createDataTransfer();
+  const event = createPasteEvent(win, 0, 0, dataTransfer);
+  mutator(dataTransfer);
+  target.dom.dispatchEvent(event);
+};
+const pasteItems = (target: SugarElement<Element>, items: Record<string, string>): void =>
+  pasteDataTransfer(target, (dataTransfer) => {
+    Obj.each(items, (data, mime) => {
+      dataTransfer.setData(mime, data);
+    });
+  });
+const pasteFiles = (target: SugarElement<Element>, files: File[]): void =>
+  pasteDataTransfer(target, (dataTransfer) => {
+    Arr.each(files, (file) => {
+      dataTransfer.items.add(file);
+    });
+  });
+const cPasteDataTransfer = <T extends Element>(mutator: (dataTransfer: DataTransfer) => void): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((target) => pasteDataTransfer(target, mutator));
+const cPasteItems = <T extends Element>(items: Record<string, string>): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((target) => pasteItems(target, items));
+const cPasteFiles = <T extends Element>(files: File[]): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((target) => pasteFiles(target, files));
+const sPasteDataTransfer = <T>(mutator: (dataTransfer: DataTransfer) => void, selector: string): Step<T, T> =>
+  Chain.isolate({}, ChainSequence.sequence([
+    Chain.injectThunked(SugarBody.body),
+    cFindIn(selector),
+    cPasteDataTransfer(mutator)
+  ]));
+const sPasteItems = <T>(items: Record<string, string>, selector: string): Step<T, T> =>
+  Chain.isolate({}, ChainSequence.sequence([
+    Chain.injectThunked(SugarBody.body),
+    cFindIn(selector),
+    cPasteItems(items)
+  ]));
+const sPasteFiles = <T>(files: File[], selector: string): Step<T, T> =>
+  Chain.isolate({}, ChainSequence.sequence([
+    Chain.injectThunked(SugarBody.body),
+    cFindIn(selector),
+    cPasteFiles(files)
+  ]));
+const cut = (target: SugarElement<Element>): DataTransfer => {
+  const win = getWindowFromElement(target);
+  const dataTransfer = createDataTransfer();
+  const event = createCutEvent(win, 0, 0, dataTransfer);
+  target.dom.dispatchEvent(event);
+  return dataTransfer;
+};
+const copy = (target: SugarElement<Element>): DataTransfer => {
+  const win = getWindowFromElement(target);
+  const dataTransfer = createDataTransfer();
+  const event = createCopyEvent(win, 0, 0, dataTransfer);
+  target.dom.dispatchEvent(event);
+  return dataTransfer;
+};
+const cCut: Chain<SugarElement<Element>, DataTransfer> =
+  Chain.mapper(cut);
+const cCopy: Chain<SugarElement<Element>, DataTransfer> =
+  Chain.mapper(copy);
+export {
+  pasteDataTransfer,
+  pasteItems,
+  pasteFiles,
+  cPasteDataTransfer,
+  cPasteItems,
+  cPasteFiles,
+  sPasteDataTransfer,
+  sPasteItems,
+  sPasteFiles,
+  cut,
+  copy,
+  cCut,
+  cCopy
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Cursors.ts
@@ -0,0 +1,104 @@
+import { Result } from '@ephox/katamari';
+import { Hierarchy, SugarElement } from '@ephox/sugar';
+import { Chain } from './Chain';
+export interface CursorRange {
+  readonly start: SugarElement<Node>;
+  readonly soffset: number;
+  readonly finish: SugarElement<Node>;
+  readonly foffset: number;
+}
+export interface CursorPath {
+  readonly startPath: number[];
+  readonly soffset: number;
+  readonly finishPath: number[];
+  readonly foffset: number;
+}
+const range = (obj: { start: SugarElement<Node>; soffset: number; finish: SugarElement<Node>; foffset: number }): CursorRange => ({
+  start: obj.start,
+  soffset: obj.soffset,
+  finish: obj.finish,
+  foffset: obj.foffset
+});
+const path = (obj: { startPath: number[]; soffset: number; finishPath: number[]; foffset: number }): CursorPath => ({
+  startPath: obj.startPath,
+  soffset: obj.soffset,
+  finishPath: obj.finishPath,
+  foffset: obj.foffset
+});
+export interface CursorSpec {
+  readonly element: number[];
+  readonly offset: number;
+}
+const pathFromCollapsed = (spec: CursorSpec): CursorPath =>
+  path({
+    startPath: spec.element,
+    soffset: spec.offset,
+    finishPath: spec.element,
+    foffset: spec.offset
+  });
+export interface RangeSpec {
+  readonly start: CursorSpec;
+  readonly finish?: CursorSpec;
+}
+const pathFromRange = (spec: RangeSpec): CursorPath => {
+  const finish = spec.finish !== undefined ? spec.finish : spec.start;
+  return path({
+    startPath: spec.start.element,
+    soffset: spec.start.offset,
+    finishPath: finish.element,
+    foffset: finish.offset
+  });
+};
+const isCursorSpec = (spec: CursorSpec | RangeSpec): spec is CursorSpec =>
+  !('start' in spec) && 'element' in spec;
+const pathFrom = (spec: CursorSpec | RangeSpec): CursorPath =>
+  isCursorSpec(spec) ? pathFromCollapsed(spec) : pathFromRange(spec);
+const follow = (container: SugarElement<Node>, calcPath: number[]): Result<SugarElement<Node>, string> =>
+  Hierarchy.follow(container, calcPath).fold(() =>
+    Result.error('Could not follow path: ' + calcPath.join(',')),
+  Result.value
+  );
+const followPath = (container: SugarElement<Node>, calcPath: CursorPath): Result<CursorRange, string> =>
+  follow(container, calcPath.startPath).bind((start) =>
+    follow(container, calcPath.finishPath).map((finish) =>
+      range({
+        start,
+        soffset: calcPath.soffset,
+        finish,
+        foffset: calcPath.foffset
+      })));
+const cFollowPath = (calcPath: CursorPath): Chain<SugarElement<Node>, CursorRange> =>
+  Chain.binder((container) => followPath(container, calcPath));
+const cFollowCursor = (elementPath: number[], offset: number): Chain<SugarElement<Node>, CursorRange> =>
+  Chain.binder((container) =>
+    follow(container, elementPath).map((element) =>
+      range({
+        start: element,
+        soffset: offset,
+        finish: element,
+        foffset: offset
+      })
+    )
+  );
+const cFollow = (elementPath: number[]): Chain<SugarElement<Node>, SugarElement<Node>> =>
+  Chain.binder((container) => follow(container, elementPath));
+const cToRange = Chain.mapper(range);
+const cToPath = Chain.mapper(path);
+const calculate = (container: SugarElement<Node>, calcPath: CursorPath): CursorRange =>
+  followPath(container, calcPath).getOrDie();
+const calculateOne = (container: SugarElement<Node>, calcPath: number[]): SugarElement<Node> =>
+  follow(container, calcPath).getOrDie();
+export {
+  range,
+  path,
+  pathFrom,
+  follow,
+  followPath,
+  cFollow,
+  cFollowPath,
+  cFollowCursor,
+  cToRange,
+  cToPath,
+  calculate,
+  calculateOne
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/DragnDrop.ts
@@ -0,0 +1,120 @@
+import { Arr } from '@ephox/katamari';
+import { Attribute, SugarBody, SugarElement, SugarNode } from '@ephox/sugar';
+import { createDataTransfer, getDragImage } from '../datatransfer/DataTransfer';
+import {
+  createDragendEvent, createDragenterEvent, createDragEvent, createDragoverEvent, createDragstartEvent, createDropEvent, dispatchDndEvent,
+  getWindowFromElement, isDefaultPrevented
+} from '../dragndrop/DndEvents';
+import { Chain } from './Chain';
+import { NamedChain } from './NamedChain';
+import { Step } from './Step';
+import * as UiFinder from './UiFinder';
+interface Item {
+  data: string;
+  type: string;
+}
+const isDraggable = (element: SugarElement<Element>): boolean => {
+  const name = SugarNode.name(element);
+  return (
+    name === 'img' ||
+    name === 'a' && Attribute.has(element, 'href') ||
+    Attribute.get(element, 'draggable') === 'true'
+  );
+};
+const checkDefaultPrevented = (evt: DragEvent): void => {
+  if (isDefaultPrevented(evt) === false) {
+    throw new Error(`preventDefault was not called on drag event: ${evt.type}`);
+  }
+};
+const checkNotDefaultPrevented = (evt: DragEvent): void => {
+  if (isDefaultPrevented(evt) === true) {
+    throw new Error(`preventDefault was called on drag event: ${evt.type}`);
+  }
+};
+const dragnDrop = (from: SugarElement<Element>, to: SugarElement<Element>, prevented: boolean = true): void => {
+  const fromWin = getWindowFromElement(from);
+  const toWin = getWindowFromElement(to);
+  const fromRect = from.dom.getBoundingClientRect();
+  const toRect = from.dom.getBoundingClientRect();
+  const transfer = createDataTransfer();
+  if (isDraggable(from) === false) {
+    throw new Error('Can not drag a non draggable element.');
+  }
+  const check = prevented ? checkDefaultPrevented : checkNotDefaultPrevented;
+  dispatchDndEvent(createDragstartEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
+  dispatchDndEvent(createDragEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
+  check(dispatchDndEvent(createDragenterEvent(toWin, toRect.left, toRect.top, transfer), to));
+  check(dispatchDndEvent(createDragoverEvent(toWin, toRect.left, toRect.top, transfer), to));
+  check(dispatchDndEvent(createDropEvent(toWin, toRect.left, toRect.top, transfer), to));
+  dispatchDndEvent(createDragendEvent(fromWin, fromRect.left, fromRect.top, transfer), from);
+};
+const drop = (to: SugarElement<Element>, prevented: boolean, addItems: (transfer: DataTransfer) => void): void => {
+  const toWin = getWindowFromElement(to);
+  const toRect = to.dom.getBoundingClientRect();
+  const transfer = createDataTransfer();
+  addItems(transfer);
+  const check = prevented ? checkDefaultPrevented : checkNotDefaultPrevented;
+  dispatchDndEvent(createDragenterEvent(toWin, toRect.left, toRect.top, transfer), to);
+  dispatchDndEvent(createDragoverEvent(toWin, toRect.left, toRect.top, transfer), to);
+  check(dispatchDndEvent(createDropEvent(toWin, toRect.left, toRect.top, transfer), to));
+};
+const dropFiles = (files: File[], to: SugarElement<Element>, prevented: boolean = true): void => {
+  drop(to, prevented, (transfer) => {
+    Arr.each(files, (file) => {
+      transfer.items.add(file);
+    });
+  });
+};
+const dropItems = (items: Item[], to: SugarElement<Element>, prevented: boolean = true): void => {
+  drop(to, prevented, (transfer) => {
+    Arr.each(items, (item) => {
+      transfer.items.add(item.data, item.type);
+    });
+  });
+};
+const cDragnDrop = <T extends Element> (fromSelector: string, toSelector: string, prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> => NamedChain.asChain([
+  NamedChain.direct(NamedChain.inputName(), UiFinder.cFindIn(fromSelector), 'from'),
+  NamedChain.direct(NamedChain.inputName(), UiFinder.cFindIn(toSelector), 'to'),
+  Chain.op((obj) => dragnDrop(obj.from, obj.to, prevented)),
+  NamedChain.output(NamedChain.inputName())
+]);
+const sDragnDrop = <T>(fromSelector: string, toSelector: string, prevented?: boolean): Step<T, T> =>
+  Chain.asStep(SugarBody.body(), [ cDragnDrop(fromSelector, toSelector, prevented) ]);
+const pDragnDrop = (fromSelector: string, toSelector: string, prevented?: boolean): Promise<SugarElement<HTMLElement>> =>
+  Chain.toPromise(cDragnDrop<HTMLElement>(fromSelector, toSelector, prevented))(SugarBody.body());
+const sDropFiles = <T>(files: File[], toSelector: string, prevented?: boolean): Step<T, T> => Chain.asStep(SugarBody.body(), [
+  UiFinder.cFindIn(toSelector),
+  cDropFiles(files, prevented)
+]);
+const cDropFiles = <T extends Element> (files: File[], prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((elm) => {
+    dropFiles(files, elm, prevented);
+  });
+const pDropFiles = <T extends Element> (elm: SugarElement<T>, files: File[], prevented?: boolean): Promise<SugarElement<T>> =>
+  Chain.toPromise(cDropFiles<T>(files, prevented))(elm);
+const sDropItems = <T> (items: Item[], toSelector: string, prevented?: boolean): Step<T, T> => Chain.asStep(SugarBody.body(), [
+  UiFinder.cFindIn(toSelector),
+  cDropItems(items, prevented)
+]);
+const cDropItems = <T extends Element> (items: Item[], prevented?: boolean): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((elm) => {
+    dropItems(items, elm, prevented);
+  });
+const pDropItems = <T extends Element> (elm: SugarElement<T>, items: Item[], prevented?: boolean): Promise<SugarElement<T>> =>
+  Chain.toPromise(cDropItems<T>(items, prevented))(elm);
+export {
+  isDraggable,
+  dragnDrop,
+  dropFiles,
+  dropItems,
+  cDragnDrop,
+  sDragnDrop,
+  pDragnDrop,
+  sDropFiles,
+  cDropFiles,
+  pDropFiles,
+  sDropItems,
+  cDropItems,
+  pDropItems,
+  getDragImage
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/FocusTools.ts
@@ -0,0 +1,117 @@
+import { Result } from '@ephox/katamari';
+import { Compare, Focus, SugarElement, SugarShadowDom, Truncate } from '@ephox/sugar';
+import * as SizzleFind from '../alien/SizzleFind';
+import { Chain } from './Chain';
+import * as Guard from './Guard';
+import * as Logger from './Logger';
+import { Step } from './Step';
+import * as UiControls from './UiControls';
+import * as UiFinder from './UiFinder';
+import * as Waiter from './Waiter';
+const getFocused = <T extends HTMLElement>(doc: SugarElement<Document | ShadowRoot>): Result<SugarElement<T>, string> => {
+  return Focus.active<T>(doc).fold(
+    () => Result.error('Could not find active element'),
+    Result.value
+  );
+};
+const getActiveValue = (element: SugarElement<Node>): string | undefined => {
+  const doc = SugarShadowDom.getRootNode(element);
+  const focused = getFocused(doc).getOrDie();
+  return UiControls.getValue(focused as SugarElement<any>);
+};
+const setFocus = <T extends HTMLElement>(container: SugarElement<Node>, selector: string): SugarElement<T> => {
+  const elem = UiFinder.findIn<T>(container, selector).getOrDie();
+  Focus.focus(elem);
+  return elem;
+};
+const setActiveValue = (doc: SugarElement<Document | ShadowRoot>, newValue: string): SugarElement<HTMLElement> => {
+  const focused = getFocused(doc).getOrDie();
+  UiControls.setValue(focused as SugarElement<any>, newValue);
+  return focused;
+};
+const isOn = (label: string, element: SugarElement<Node>): SugarElement<HTMLElement> => {
+  const doc = SugarShadowDom.getRootNode(element);
+  return getFocused(doc).bind((active) => {
+    return Compare.eq(element, active) ? Result.value(active) : Result.error(
+      label + '\nExpected focus: ' + Truncate.getHtml(element) + '\nActual focus: ' + Truncate.getHtml(active)
+    );
+  }).getOrDie();
+};
+const isOnSelector = (label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): SugarElement<HTMLElement> => {
+  return getFocused(doc).bind((active) => {
+    return SizzleFind.matches(active, selector) ? Result.value(active) : Result.error(
+      label + '\nExpected focus $("' + selector + '")]\nActual focus: ' + Truncate.getHtml(active)
+    );
+  }).getOrDie();
+};
+const cGetFocused: Chain<SugarElement<Document | ShadowRoot>, SugarElement<HTMLElement>> =
+  Chain.binder(getFocused);
+const cGetRootNode: Chain<SugarElement<Node>, SugarElement<Document | ShadowRoot>> =
+  Chain.mapper(SugarShadowDom.getRootNode);
+const wrapInResult = <R>(f: () => R) => (): Result<R, string> => {
+  try {
+    return Result.value(f());
+  } catch (e) {
+    return Result.error(e.message);
+  }
+};
+const sIsOn = <T>(label: string, element: SugarElement<Node>): Step<T, T> =>
+  Chain.asStep<T, SugarElement<Node>>(element, [
+    Chain.binder(wrapInResult(() => isOn(label, element)))
+  ]);
+const sIsOnSelector = <T>(label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Step<T, T> =>
+  Logger.t(
+    `${label}: sIsOnSelector(${selector})`,
+    Chain.asStep<T, SugarElement<Document | ShadowRoot>>(doc, [
+      Chain.binder(wrapInResult(() => isOnSelector(label, doc, selector)))
+    ])
+  );
+const sTryOnSelector = <T>(label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Step<T, T> =>
+  Logger.t<T, T>(
+    label + '. Focus did not match: ' + selector,
+    Waiter.sTryUntil(
+      'Waiting for focus',
+      sIsOnSelector(label, doc, selector),
+      10, 4000
+    )
+  );
+const pTryOnSelector = (label: string, doc: SugarElement<Document | ShadowRoot>, selector: string): Promise<SugarElement<HTMLElement>> =>
+  Waiter.pTryUntil(label + '. Focus did not match: ' + selector, () => isOnSelector(label, doc, selector));
+const cSetFocus = <T extends Node, U extends HTMLElement>(label: string, selector: string): Chain<SugarElement<T>, SugarElement<U>> =>
+  Chain.control(
+    Chain.mapper((container) => setFocus<U>(container, selector)),
+    Guard.addLogging(label)
+  );
+const cSetActiveValue = (newValue: string): Chain<SugarElement<Node>, SugarElement<HTMLElement>> =>
+  Chain.fromChains([
+    cGetRootNode,
+    Chain.mapper((root) => setActiveValue(root, newValue))
+  ]);
+const cGetActiveValue: Chain<SugarElement<Node>, string> =
+  Chain.fromChains([
+    cGetRootNode,
+    cGetFocused,
+    UiControls.cGetValue
+  ]);
+const sSetFocus = <T>(label: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Chain.asStep<T, SugarElement<Node>>(container, [ cSetFocus(label, selector) ]);
+const sSetActiveValue = <T>(doc: SugarElement<Document | ShadowRoot>, newValue: string): Step<T, T> =>
+  Step.sync(() => setActiveValue(doc, newValue));
+export {
+  getActiveValue,
+  setActiveValue,
+  setFocus,
+  getFocused,
+  isOn,
+  isOnSelector,
+  pTryOnSelector,
+  sSetActiveValue,
+  sSetFocus,
+  sIsOn,
+  sIsOnSelector,
+  sTryOnSelector,
+  cSetFocus,
+  cSetActiveValue,
+  cGetActiveValue,
+  cGetFocused
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Generators.ts
@@ -0,0 +1,52 @@
+import { Hierarchy, Html, SimRange, SugarElement, Truncate } from '@ephox/sugar';
+import * as fc from 'fast-check';
+import * as GenSelection from '../arbitrary/GenSelection';
+import * as TagDecorator from '../arbitrary/TagDecorator';
+interface DescribedSimRange {
+  readonly selection: {
+    readonly startElement: string;
+    readonly startElementFull: string;
+    readonly startPath: number[];
+    readonly startOffset: number;
+    readonly finishElement: string;
+    readonly finishElementFull: string;
+    readonly finishPath: number[];
+    readonly finishOffset: number;
+  };
+}
+const selection = (container: SugarElement<Node>, exclusions: GenSelection.SelectionExclusions): fc.Arbitrary<SimRange> =>
+  GenSelection.selection(container, exclusions);
+const describeSelection = (root: SugarElement<Node>, generated: SimRange): DescribedSimRange | SimRange =>
+  Hierarchy.path(root, generated.start).bind((startPath) =>
+    Hierarchy.path(root, generated.finish).map((finishPath) => ({
+      selection: {
+        startElement: Truncate.getHtml(generated.start),
+        startElementFull: Html.getOuter(generated.start),
+        startPath,
+        startOffset: generated.soffset,
+        finishElement: Truncate.getHtml(generated.finish),
+        finishElementFull: Html.getOuter(generated.finish),
+        finishPath,
+        finishOffset: generated.foffset
+      }
+    }))).getOr(generated);
+const chooseOne = <T>(choices: TagDecorator.Decorator<T>[]): fc.Arbitrary<Record<string, T>> =>
+  TagDecorator.gOne(choices);
+const enforce = <T extends Record<string, string | number | boolean>>(attrs: T): fc.Arbitrary<T> =>
+  TagDecorator.gEnforce(attrs);
+const hexDigit = fc.constantFrom(...'0123456789abcdef'.split(''));
+const hexColor = fc.tuple(
+  hexDigit,
+  hexDigit,
+  hexDigit,
+  hexDigit,
+  hexDigit,
+  hexDigit
+).map((digits) => [ '#' ].concat(digits).join(''));
+export {
+  selection,
+  describeSelection,
+  chooseOne,
+  enforce,
+  hexColor
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Keyboard.ts
@@ -0,0 +1,54 @@
+import { Arr } from '@ephox/katamari';
+import { Focus, SugarElement, Traverse } from '@ephox/sugar';
+import { keyevent, MixedKeyModifiers } from '../keyboard/FakeKeys';
+import { Step } from './Step';
+export type KeyModifiers = MixedKeyModifiers;
+/*
+  doc - document scope
+  value - which keycode
+  modifiers - { shift: BOOL, alt: BOOL }
+  dispatcher - dispatch event from some element
+*/
+const fakeKeys = (types: string[]) => (value: number, modifiers: KeyModifiers = {}, dispatcher: SugarElement<Node>) => {
+  const doc = Traverse.owner(dispatcher);
+  Arr.each(types, (type) => {
+    keyevent(type, doc, value, modifiers, dispatcher);
+  });
+};
+const activeFakeKeys = (types: string[]) => (doc: SugarElement<Document | ShadowRoot>, value: number, modifiers: KeyModifiers = {}) => {
+  const focused = Focus.active(doc).getOrDie('Could not find active element');
+  fakeKeys(types)(value, modifiers, focused);
+};
+const sFakeKey = (types: string[]) => <T>(doc: SugarElement<Document | ShadowRoot>, keyvalue: number, modifiers: KeyModifiers = {}): Step<T, T> => Step.sync(() => {
+  activeFakeKeys(types)(doc, keyvalue, modifiers);
+});
+const keydownTypes = [ 'keydown' ];
+const keyupTypes = [ 'keyup' ];
+const keypressTypes = [ 'keypress' ];
+const keystrokeTypes = [ 'keydown', 'keyup' ];
+const keydown = fakeKeys(keydownTypes);
+const keyup = fakeKeys(keyupTypes);
+const keypress = fakeKeys(keypressTypes);
+const keystroke = fakeKeys(keystrokeTypes);
+const activeKeydown = activeFakeKeys(keydownTypes);
+const activeKeyup = activeFakeKeys(keyupTypes);
+const activeKeypress = activeFakeKeys(keypressTypes);
+const activeKeystroke = activeFakeKeys(keystrokeTypes);
+const sKeydown = sFakeKey(keydownTypes);
+const sKeyup = sFakeKey(keyupTypes);
+const sKeypress = sFakeKey(keypressTypes);
+const sKeystroke = sFakeKey(keystrokeTypes);
+export {
+  keydown,
+  keyup,
+  keypress,
+  keystroke,
+  activeKeydown,
+  activeKeyup,
+  activeKeypress,
+  activeKeystroke,
+  sKeydown,
+  sKeyup,
+  sKeypress,
+  sKeystroke
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Main.ts
@@ -0,0 +1,76 @@
+import { StructAssert, StructAssertAdv, StructAssertBasic } from '../assertions/ApproxStructures';
+import * as ApproxStructure from './ApproxStructure';
+import * as Arbitraries from './Arbitraries';
+import * as Assertions from './Assertions';
+import { Chain } from './Chain';
+import * as ChainSequence from './ChainSequence';
+import { Cleaner } from './Cleaner';
+import * as Clipboard from './Clipboard';
+import * as Cursors from './Cursors';
+import * as DragnDrop from './DragnDrop';
+import * as FileInput from './FileInput';
+import * as Files from './Files';
+import * as FocusTools from './FocusTools';
+import * as GeneralSteps from './GeneralSteps';
+import * as Generators from './Generators';
+import { GroupStore } from './GroupStore';
+import * as Guard from './Guard';
+import * as Keyboard from './Keyboard';
+import { Keys } from './Keys';
+import * as Log from './Log';
+import * as Logger from './Logger';
+import { Monitor } from './Monitor';
+import * as Mouse from './Mouse';
+import { NamedChain } from './NamedChain';
+import { Pipeline } from './Pipeline';
+import * as PropertySteps from './PropertySteps';
+import * as RealClipboard from './RealClipboard';
+import { RealKeys } from './RealKeys';
+import * as RealMouse from './RealMouse';
+import { Step } from './Step';
+import * as StepSequence from './StepSequence';
+import { TestLogs } from './TestLogs';
+import * as Touch from './Touch';
+import * as UiControls from './UiControls';
+import * as UiFinder from './UiFinder';
+import * as Waiter from './Waiter';
+export {
+  ApproxStructure,
+  Arbitraries,
+  Assertions,
+  Chain,
+  ChainSequence,
+  Cleaner,
+  Clipboard,
+  Cursors,
+  FocusTools,
+  GeneralSteps,
+  StepSequence,
+  Generators,
+  GroupStore,
+  Guard,
+  Keyboard,
+  Keys,
+  Log,
+  Logger,
+  Monitor,
+  Mouse,
+  NamedChain,
+  Pipeline,
+  PropertySteps,
+  RealClipboard,
+  RealKeys,
+  RealMouse,
+  Step,
+  TestLogs,
+  UiControls,
+  UiFinder,
+  Waiter,
+  Touch,
+  StructAssert,
+  StructAssertBasic,
+  StructAssertAdv,
+  DragnDrop,
+  Files,
+  FileInput
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Mouse.ts
@@ -0,0 +1,140 @@
+import { Fun } from '@ephox/katamari';
+import { Focus, SugarElement } from '@ephox/sugar';
+import * as Clicks from '../mouse/Clicks';
+import { Chain } from './Chain';
+import { Step } from './Step';
+import * as UiFinder from './UiFinder';
+const click = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.click(settings)(element);
+const mouseOver = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseOver(settings)(element);
+const mouseDown = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseDown(settings)(element);
+const mouseUp = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseUp(settings)(element);
+const mouseMove = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseMove(settings)(element);
+const mouseOut = (element: SugarElement<Node>, settings: Clicks.Settings = { }): void => Clicks.mouseOut(settings)(element);
+const mouseMoveTo = (element: SugarElement<Node>, dx: number, dy: number, settings: Omit<Clicks.Settings, 'dx' | 'dy'> = { }): void =>
+  Clicks.mouseMove({ ...settings, dx, dy })(element);
+const mouseUpTo = (element: SugarElement<Node>, dx: number, dy: number, settings: Omit<Clicks.Settings, 'dx' | 'dy'> = { }): void =>
+  Clicks.mouseUp({ ...settings, dx, dy })(element);
+const cClickWith = Fun.compose(Chain.op, Clicks.click);
+const cContextMenuWith = Fun.compose(Chain.op, Clicks.contextMenu);
+const cMouseOverWith = Fun.compose(Chain.op, Clicks.mouseOver);
+const cMouseDownWith = Fun.compose(Chain.op, Clicks.mouseDown);
+const cMouseUpWith = Fun.compose(Chain.op, Clicks.mouseUp);
+const cMouseMoveWith = Fun.compose(Chain.op, Clicks.mouseMove);
+const cMouseOutWith = Fun.compose(Chain.op, Clicks.mouseOut);
+/**
+ * @deprecated use cMouseUpWith({ dx, dy }) instead */
+const cMouseUpTo = (dx: number, dy: number): Chain<SugarElement<Node>, SugarElement<Node>> => cMouseUpWith({ dx, dy });
+/**
+ * @deprecated use cMouseMoveWith({ dx, dy }) instead */
+const cMouseMoveTo = (dx: number, dy: number): Chain<SugarElement<Node>, SugarElement<Node>> => cMouseMoveWith({ dx, dy });
+/**
+ * @deprecated use cClickWith({ }) instead*/
+const cClick = cClickWith({ });
+/**
+ * @deprecated use cContextMenuWith({ }) instead */
+const cContextMenu = cContextMenuWith({ });
+/**
+ * @deprecated use cMouseOverWith({ }) instead */
+const cMouseOver = cMouseOverWith({ });
+/**
+ * @deprecated use cMouseDownWith({ }) instead */
+const cMouseDown = cMouseDownWith({ });
+/**
+ * @deprecated use cMouseUpWith({ }) instead */
+const cMouseUp = cMouseUpWith({ });
+/**
+ * @deprecated use cMouseMoveWith({ }) instead */
+const cMouseMove = cMouseMoveWith({ });
+/**
+ * @deprecated use cMouseOutWith({ }) instead */
+const cMouseOut = cMouseOutWith({ });
+const triggerOn = <T extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<T>) => void): SugarElement<T> => {
+  const ele = UiFinder.findIn<T>(container, selector).getOrDie();
+  action(ele);
+  return ele;
+};
+const sTriggerOn = <T, U extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<U>) => void) =>
+  Step.sync<T>(() => triggerOn(container, selector, action));
+const clickOn = <T extends HTMLElement>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
+  triggerOn<T>(container, selector, Clicks.trigger);
+const hoverOn = <T extends Element>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
+  triggerOn<T>(container, selector, mouseOver);
+const contextMenuOn = <T extends Element>(container: SugarElement<Node>, selector: string): SugarElement<T> =>
+  triggerOn<T>(container, selector, Clicks.contextMenu({ }));
+const sClickOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerOn<T, Element>(container, selector, Clicks.trigger);
+const sHoverOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerOn<T, Element>(container, selector, Clicks.mouseOver({ }));
+const sContextMenuOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerOn<T, Element>(container, selector, Clicks.contextMenu({ }));
+const cClickOn = <T>(selector: string): Chain<SugarElement<T>, SugarElement<T>> => Chain.fromIsolatedChains([
+  UiFinder.cFindIn(selector),
+  cClick
+]);
+const trueClick = (elem: SugarElement<HTMLElement>): void => {
+  Focus.focus(elem);
+  mouseDown(elem);
+  mouseUp(elem);
+  Clicks.trigger(elem);
+};
+const trueClickOn = (container: SugarElement<Node>, selector: string): void => {
+  triggerOn(container, selector, trueClick);
+};
+const cTrueClick = Chain.op(trueClick);
+const sTrueClickOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerOn<T, HTMLElement>(container, selector, trueClick);
+const leftClickButton = Clicks.leftClickButton ;
+const middleClickButton = Clicks.middleClickButton ;
+const rightClickButton = Clicks.rightClickButton ;
+const leftClickButtons = Clicks.leftClickButtons ;
+const rightClickButtons = Clicks.rightClickButtons ;
+const middleClickButtons = Clicks.middleClickButtons ;
+/**
+ * @deprecated Use event instead */
+const point = Clicks.point;
+const event = Clicks.event;
+export {
+  cClickWith,
+  cContextMenuWith,
+  cMouseOverWith,
+  cMouseDownWith,
+  cMouseUpWith,
+  cMouseMoveWith,
+  cMouseOutWith,
+  cClick,
+  cContextMenu,
+  cMouseOver,
+  cMouseDown,
+  cMouseUp,
+  cMouseMove,
+  cMouseOut,
+  cMouseUpTo,
+  cMouseMoveTo,
+  sClickOn,
+  sHoverOn,
+  sContextMenuOn,
+  cClickOn,
+  trueClick,
+  trueClickOn,
+  cTrueClick,
+  sTrueClickOn,
+  leftClickButton,
+  middleClickButton,
+  rightClickButton,
+  leftClickButtons,
+  rightClickButtons,
+  middleClickButtons,
+  click,
+  mouseOver,
+  mouseDown,
+  mouseUp,
+  mouseUpTo,
+  mouseMove,
+  mouseMoveTo,
+  mouseOut,
+  clickOn,
+  contextMenuOn,
+  hoverOn,
+  point,
+  event
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/RealClipboard.ts
@@ -0,0 +1,36 @@
+import { PlatformDetection } from '@ephox/sand';
+import { KeyModifiers } from '../keyboard/FakeKeys';
+import * as SeleniumAction from '../server/SeleniumAction';
+import { RealKeys } from './RealKeys';
+import { Step } from './Step';
+const platform = PlatformDetection.detect();
+const pImportToClipboard = (filename: string): Promise<{}> =>
+  SeleniumAction.pPerform('/clipboard', {
+    import: filename
+  });
+const sImportToClipboard = <T>(filename: string): Step<T, T> =>
+  Step.fromPromise(() => pImportToClipboard(filename));
+const pCopy = (selector: string): Promise<{}> => {
+  const modifiers: KeyModifiers = platform.os.isMacOS() ? { metaKey: true } : { ctrlKey: true };
+  return RealKeys.pSendKeysOn(selector, [
+    RealKeys.combo(modifiers, 'c')
+  ]);
+};
+const sCopy = <T>(selector: string): Step<T, T> =>
+  Step.fromPromise<T>(() => pCopy(selector));
+const pPaste = (selector: string): Promise<{}> => {
+  const modifiers: KeyModifiers = platform.os.isMacOS() ? { metaKey: true } : { ctrlKey: true };
+  return RealKeys.pSendKeysOn(selector, [
+    RealKeys.combo(modifiers, 'v')
+  ]);
+};
+const sPaste = <T>(selector: string): Step<T, T> =>
+  Step.fromPromise(() => pPaste(selector));
+export {
+  pImportToClipboard,
+  pCopy,
+  pPaste,
+  sImportToClipboard,
+  sCopy,
+  sPaste
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Step.ts
@@ -0,0 +1,84 @@
+import { Failure } from '@ephox/bedrock-common';
+import * as AsyncActions from '../pipe/AsyncActions';
+import * as GeneralActions from '../pipe/GeneralActions';
+import { DieFn, NextFn, Pipe, RunFn } from '../pipe/Pipe';
+import { addLogging, GuardFn } from './Guard';
+import { addLogEntry, TestLogs } from './TestLogs';
+export interface Step<T, U> {
+  runStep: (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void;
+}
+const raw = <T, U>(f: RunFn<T, U>): Step<T, U> =>
+  ({ runStep: Pipe(f) });
+const stateful = <T, U>(f: (v: T, next: (v: U) => void, die: (err) => void) => void): Step<T, U> =>
+  raw<T, U>((value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => {
+    f(
+      value,
+      (nextValue: U) => next(nextValue, logs),
+      (err) => die(err, logs)
+    );
+  });
+const control = <T, U, V>(step: Step<T, U>, guard: GuardFn<T, U, V>): Step<T, V> =>
+  raw<T, V>((value: T, next: NextFn<V>, die: DieFn, logs: TestLogs) => {
+    guard(step.runStep, value, next, die, logs);
+  });
+const sync = <T>(f: () => void): Step<T, T> =>
+  raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    f();
+    next(value, logs);
+  });
+const async = <T>(f: (next: () => void, die: (err) => void) => void): Step<T, T> =>
+  raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    f(
+      () => next(value, logs),
+      (err) => die(err, logs)
+    );
+  });
+const debugging: Step<any, any> =
+  sync<any>(GeneralActions.debug);
+const log = <T>(message: string): Step<T, T> =>
+  raw<T, T>((value: T, next: NextFn<T>, die: DieFn, logs: TestLogs) => {
+    console.log(message);
+    next(value, addLogEntry(logs, message));
+  });
+const label = <T, U>(label: string, chain: Step<T, U>): Step<T, U> =>
+  control(chain, addLogging(label));
+const wait = <T>(amount: number): Step<T, T> =>
+  async(AsyncActions.delay(amount));
+const fail = <T>(message: string): Step<T, T> =>
+  async(AsyncActions.fail(message));
+const pass: Step<any, any> = sync<any>(GeneralActions.pass);
+const predicate = <T>(p: (value: T) => boolean): Step<T, T> =>
+  stateful((value: T, next, die) => {
+    p(value) ? next(value) : die('predicate did not succeed');
+  });
+const toPromise = <A, B>(step: Step<A, B>) => (a: A): Promise<B> => {
+  return new Promise(((resolve, reject) => {
+    step.runStep(a,
+      (b, _logs) => {
+        resolve(b);
+      }, (err, logs) => {
+        reject(Failure.prepFailure(err, logs));
+      },
+      TestLogs.init()
+    );
+  }));
+};
+const fromPromise = <T>(p: () => Promise<unknown>): Step<T, T> => Step.async<T>((next, die) => {
+  p().then(next, die);
+});
+export const Step = {
+  stateful,
+  control,
+  sync,
+  async,
+  debugging,
+  log,
+  label,
+  wait,
+  fail,
+  pass,
+  raw,
+  predicate,
+  toPromise,
+  fromPromise
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/Touch.ts
@@ -0,0 +1,75 @@
+import { Focus, SugarElement } from '@ephox/sugar';
+import * as Touches from '../touch/Touches';
+import { Chain } from './Chain';
+import { Step } from './Step';
+import * as UiFinder from './UiFinder';
+const touchStart = Touches.touchstart;
+const touchStartAt = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchstartAt(dx, dy)(element);
+const touchEnd = Touches.touchend;
+const touchEndAt = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchendAt(dx, dy)(element);
+const touchMove = Touches.touchmove;
+const touchMoveTo = (element: SugarElement<Node>, dx: number, dy: number): void => Touches.touchmoveTo(dx, dy)(element);
+const cTrigger = <T extends Node, U extends Element>(selector: string, action: (ele: SugarElement<U>) => void) =>
+  Chain.async<SugarElement<T>, SugarElement<T>>((container, next, die) => {
+    UiFinder.findIn<U>(container, selector).fold(
+      () => die('Could not find element: ' + selector),
+      (ele) => {
+        action(ele);
+        next(container);
+      }
+    );
+  });
+const sTriggerWith = <T, U extends Element>(container: SugarElement<Node>, selector: string, action: (ele: SugarElement<U>) => void) =>
+  Chain.asStep<T, SugarElement<Node>>(container, [ cTrigger<Node, U>(selector, action) ]);
+const trueTap = (elem: SugarElement<HTMLElement>): void => {
+  Focus.focus(elem);
+  Touches.touchstart(elem);
+  Touches.touchend(elem);
+};
+const tap = (elem: SugarElement<Node>): void => {
+  Touches.touchstart(elem);
+  Touches.touchend(elem);
+};
+const sTap = <T>(element: SugarElement<Node>): Step<T, T> =>
+  Step.sync<T>(() => tap(element));
+const sTrueTapOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerWith<T, HTMLElement>(container, selector, trueTap);
+const sTapOn = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  sTriggerWith<T, Element>(container, selector, tap);
+const cTapOn = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
+  cTrigger(selector, tap);
+const cTouchStartAt = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op<SugarElement<T>>(Touches.touchstartAt(dx, dy));
+const cTouchEndAt = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op<SugarElement<T>>(Touches.touchendAt(dx, dy));
+const cTouchMoveTo = <T extends Node>(dx: number, dy: number): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op<SugarElement<T>>(Touches.touchmoveTo(dx, dy));
+const point = Touches.point;
+const cTrueTap = Chain.op(trueTap);
+const cTap = Chain.op(tap);
+const cTouchMove = Chain.op(Touches.touchmove);
+const cTouchStart = Chain.op(Touches.touchstart);
+const cTouchEnd = Chain.op(Touches.touchend);
+export {
+  point,
+  tap,
+  trueTap,
+  touchStart,
+  touchStartAt,
+  touchEnd,
+  touchEndAt,
+  touchMove,
+  touchMoveTo,
+  sTap,
+  sTapOn,
+  sTrueTapOn,
+  cTap,
+  cTapOn,
+  cTrueTap,
+  cTouchStart,
+  cTouchStartAt,
+  cTouchMove,
+  cTouchMoveTo,
+  cTouchEnd,
+  cTouchEndAt
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/UiControls.ts
@@ -0,0 +1,43 @@
+import { Type } from '@ephox/katamari';
+import { SugarElement, Value } from '@ephox/sugar';
+import { Chain } from './Chain';
+import { Step } from './Step';
+import * as UiFinder from './UiFinder';
+type TogglableElement = HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement | HTMLOptionElement | HTMLButtonElement;
+const fireEvent = (elem: SugarElement<Node>, event: string) => {
+  const evt = new Event(event, {
+    bubbles: true,
+    cancelable: true
+  });
+  elem.dom.dispatchEvent(evt);
+};
+const setValue = (element: SugarElement<TogglableElement>, newValue: string, eventName?: string): void => {
+  Value.set(element, newValue);
+  if (Type.isNonNullable(eventName)) {
+    fireEvent(element, eventName);
+  }
+};
+const setValueOn = (container: SugarElement<Node>, selector: string, newValue: string, eventName?: string): void => {
+  const element = UiFinder.findIn<TogglableElement>(container, selector).getOrDie();
+  setValue(element, newValue, eventName);
+};
+const getValue = (element: SugarElement<TogglableElement>): string => Value.get(element);
+const cSetValue = <T extends TogglableElement>(newValue: string): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((element) => {
+    setValue(element, newValue);
+  });
+const cGetValue: Chain<SugarElement<TogglableElement>, string> =
+  Chain.mapper(getValue);
+const sSetValue = <T>(element: SugarElement<TogglableElement>, newValue: string): Step<T, T> =>
+  Step.sync(() => setValue(element, newValue));
+const sSetValueOn = <T>(container: SugarElement<Node>, selector: string, newValue: string): Step<T, T> =>
+  Step.sync(() => setValueOn(container, selector, newValue));
+export {
+  setValue,
+  setValueOn,
+  getValue,
+  sSetValueOn,
+  sSetValue,
+  cSetValue,
+  cGetValue
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/api/UiFinder.ts
@@ -0,0 +1,96 @@
+import { Fun, Result } from '@ephox/katamari';
+import { SugarElement, Truncate, Visibility } from '@ephox/sugar';
+import * as UiSearcher from '../find/UiSearcher';
+import { Chain } from './Chain';
+import * as Guard from './Guard';
+import { Step } from './Step';
+const findIn = UiSearcher.findIn;
+const findAllIn = UiSearcher.findAllIn;
+const exists = (container: SugarElement<Node>, selector: string): void => {
+  findIn(container, selector).fold(
+    () => {
+      throw new Error('Expected ' + selector + ' to exist.');
+    },
+    Fun.noop
+  );
+};
+const notExists = (container: SugarElement<Node>, selector: string): void => {
+  return findIn(container, selector).fold(
+    Fun.noop,
+    () => {
+      throw new Error('Expected ' + selector + ' not to exist.');
+    }
+  );
+};
+const cWaitFor = <T extends Element>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
+  cWaitForState(message, selector, Fun.always);
+const sWaitFor = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Chain.asStep<T, SugarElement<Node>>(container, [ cWaitFor(message, selector) ]);
+const cWaitForVisible = <T extends HTMLElement>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
+  cWaitForState<T>(message, selector, Visibility.isVisible);
+const cWaitForHidden = <T extends HTMLElement>(message: string, selector: string): Chain<SugarElement<Node>, SugarElement<T>> =>
+  cWaitForState<T>(message, selector, Fun.not(Visibility.isVisible));
+const sWaitForVisible = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Chain.asStep<T, SugarElement<Node>>(container, [ cWaitForVisible(message, selector) ]);
+const sWaitForHidden = <T>(message: string, container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Chain.asStep<T, SugarElement<Node>>(container, [ cWaitForHidden(message, selector) ]);
+const cHasState = <T extends Node> (predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.binder((element) => predicate(element) ? Result.value(element) :
+    Result.error(Truncate.getHtml(element) + ' did not match predicate: ' + predicate.toString()));
+const cFindWithState = <T extends Element>(selector: string, predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<Node>, SugarElement<T>> =>
+  Chain.fromChains([
+    cFindIn(selector),
+    cHasState(predicate)
+  ]);
+const cWaitForState = <T extends Element>(message: string, selector: string, predicate: (element: SugarElement<T>) => boolean): Chain<SugarElement<Node>, SugarElement<T>> =>
+  Chain.control(
+    cFindWithState(selector, predicate),
+    Guard.tryUntil(message, 10, 10000)
+  );
+const sExists = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Step.sync<T>(() => exists(container, selector));
+const sNotExists = <T>(container: SugarElement<Node>, selector: string): Step<T, T> =>
+  Step.sync<T>(() => notExists(container, selector));
+const cExists = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((container) => exists(container, selector));
+const cNotExists = <T extends Node>(selector: string): Chain<SugarElement<T>, SugarElement<T>> =>
+  Chain.op((container) => notExists(container, selector));
+const cFindIn = (selector: string): Chain<SugarElement<Node>, SugarElement<Element>> =>
+  Chain.binder((container) =>
+    findIn(container, selector)
+  );
+const cFindAllIn = <T extends Element>(selector: string): Chain<SugarElement<Node>, SugarElement<T>[]> =>
+  Chain.mapper((container) =>
+    findAllIn(container, selector)
+  );
+const pWaitFor = <T extends Element>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
+  Chain.toPromise(cWaitFor<T>(message, selector))(container);
+const pWaitForVisible = <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
+  Chain.toPromise(cWaitForVisible<T>(message, selector))(container);
+const pWaitForHidden = <T extends HTMLElement>(message: string, container: SugarElement<Node>, selector: string): Promise<SugarElement<T>> =>
+  Chain.toPromise(cWaitForHidden<T>(message, selector))(container);
+const pWaitForState = <T extends Element>(message: string, container: SugarElement<Node>, selector: string, predicate: (element: SugarElement<T>) => boolean): Promise<SugarElement<T>> =>
+  Chain.toPromise(cWaitForState(message, selector, predicate))(container);
+export {
+  findIn,
+  findAllIn,
+  exists,
+  notExists,
+  sExists,
+  sNotExists,
+  sWaitFor,
+  sWaitForVisible,
+  sWaitForHidden,
+  cExists,
+  cNotExists,
+  cWaitFor,
+  cWaitForVisible,
+  cWaitForHidden,
+  cWaitForState,
+  cFindIn,
+  cFindAllIn,
+  pWaitFor,
+  pWaitForVisible,
+  pWaitForHidden,
+  pWaitForState
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/ArbChildrenSchema.ts
@@ -0,0 +1,62 @@
+import { Arr, Fun, Merger, Obj } from '@ephox/katamari';
+import * as fc from 'fast-check';
+import * as WeightedChoice from './WeightedChoice';
+type WeightedItem = WeightedChoice.WeightedItem;
+interface ChanceItem {
+  readonly chance: number;
+}
+interface Detail<T> {
+  readonly components: Record<string, T>;
+}
+export interface CompositeDetail extends Detail<WeightedItem> {
+  readonly recursionDepth?: number;
+}
+export interface StructureDetail extends Detail<ChanceItem> {}
+type Component<T> = T & {
+  readonly component?: string;
+};
+export type Construct<T> = (component: string, depth: number) => fc.Arbitrary<T>;
+const skipChild = '_';
+const toComponents = <T>(detail: Detail<T>): Component<T>[] =>
+  Obj.mapToArray(detail.components, (v, k) =>
+    k !== skipChild ? Merger.deepMerge(v, { component: k }) : v
+  );
+const none = fc.constant([]);
+const composite = <T>(rawDepth: number | undefined, detail: CompositeDetail, construct: Construct<T>): fc.Arbitrary<T[]> => {
+  const components = toComponents(detail);
+  const depth = rawDepth ?? detail.recursionDepth;
+  if (depth === 0) {
+    return none;
+  } else {
+    const genComponent = (choice: Component<WeightedItem>, depth: number | undefined) => {
+      const newDepth = choice.useDepth === true ? depth - 1 : depth;
+      return fc.array(construct(choice.component, newDepth), { minLength: 1, maxLength: 5 });
+    };
+    const repeat = WeightedChoice.generator(components).chain((choice) =>
+      choice.fold(
+        Fun.constant(none),
+        (c) => genComponent(c, depth)
+      )
+    );
+    return fc.array(repeat, { minLength: 1, maxLength: 5 }).map(Arr.flatten);
+  }
+};
+const structure = <T>(rawDepth: number | undefined, detail: StructureDetail, construct: Construct<T>): fc.Arbitrary<T[]> => {
+  const components = toComponents(detail);
+  return fc.float({ min: 0, max: 1 }).chain((random) => {
+    const children = Arr.foldl<Component<ChanceItem>, fc.Arbitrary<T>[]>(
+      components,
+      (b, component) =>
+        random <= component.chance ?
+          b.concat([ construct(component.component, rawDepth) ]) :
+          b,
+      []
+    );
+    return fc.tuple(...children);
+  });
+};
+export {
+  none,
+  composite,
+  structure
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/ArbContent.ts
@@ -0,0 +1,42 @@
+import { Merger, Obj } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as fc from 'fast-check';
+import { ArbSchema } from './ArbSchema';
+import { Schema, SchemaDetail } from './ArbSchemaTypes';
+import * as ArbSchemaTypes from './ArbSchemaTypes';
+interface ContentSchema {
+  [key: string]: <T extends Node>(rawDepth: number | undefined) => fc.Arbitrary<SugarElement<T>>;
+}
+const unknownDepth = undefined;
+const makeArbOf = <T extends Node>(component: string, schema: ContentSchema, depth: number | undefined): fc.Arbitrary<SugarElement<T>> => {
+  const arbitrary = schema[component];
+  if (arbitrary === undefined) {
+    const message =
+      'Did not understand arbitrary schema element: ' + JSON.stringify(component) +
+      '. Known schema elements were: ' + JSON.stringify(Obj.keys(schema));
+    console.error(message);
+    throw new Error(message);
+  }
+  return arbitrary(depth);
+};
+const createSchema = (factory: Schema, extras: Record<string, Partial<SchemaDetail>>): ContentSchema => {
+  const base = ArbSchema;
+  const schema = Merger.deepMerge(base, extras);
+  return Obj.map(schema, (s, k) => {
+    const type: string = s.type;
+    if (factory[type] === undefined && base[k] !== undefined) {
+      throw new Error('Component: ' + k + ' has invalid type: ' + type);
+    } else {
+      return factory[type](s);
+    }
+  });
+};
+const arbOf = <T extends Node>(component: string, extras: Record<string, Partial<SchemaDetail>> = {}): fc.Arbitrary<SugarElement<T>> => {
+  const constructor = (comp: string, newDepth: number) => makeArbOf(comp, schema, newDepth);
+  const factory = ArbSchemaTypes.create(constructor);
+  const schema = createSchema(factory, extras);
+  return makeArbOf(component, schema, unknownDepth);
+};
+export {
+  arbOf
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/ArbNodes.ts
@@ -0,0 +1,27 @@
+import { SugarElement } from '@ephox/sugar';
+import * as fc from 'fast-check';
+const createTag = <T extends HTMLElement>(name: string): SugarElement<T> => {
+  const partial = name.split('-');
+  const tag = partial.length > 0 ? partial[0] : name;
+  return SugarElement.fromTag(tag) as SugarElement<T>;
+};
+const comment = fc.string()
+  .map((s) => {
+    const raw = document.createComment(s);
+    return SugarElement.fromDom(raw);
+  });
+const elementOfArb = <T extends HTMLElement>(arb: fc.Arbitrary<string>): fc.Arbitrary<SugarElement<T>> =>
+  arb.map((name) => createTag<T>(name));
+const elementOf = <T extends HTMLElement>(tag: string): SugarElement<T> =>
+  createTag<T>(tag);
+const textOfArb = (arb: fc.Arbitrary<string>): fc.Arbitrary<SugarElement<Text>> =>
+  arb.map(SugarElement.fromText);
+const textOf = (s: string): SugarElement<Text> =>
+  SugarElement.fromText(s);
+export {
+  elementOfArb,
+  elementOf,
+  comment,
+  textOf,
+  textOfArb
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/ArbSchema.ts
@@ -0,0 +1,188 @@
+import { Unicode } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as fc from 'fast-check';
+import * as ArbNodes from './ArbNodes';
+import { ArbitraryDetail, CompositeDetail, StructureDetail } from './ArbSchemaTypes';
+const formatting: CompositeDetail = {
+  type: 'composite',
+  tags: {
+    p: { weight: 1 },
+    h1: { weight: 1 }
+  },
+  components: {
+    anytext: { weight: 0.5 },
+    netext: { weight: 0.5 },
+    inline: { weight: 1.0 },
+    whitespace: { weight: 1.6 }
+  }
+};
+const inline: CompositeDetail = {
+  type: 'composite',
+  recursionDepth: 3,
+  tags: {
+    'span-strikethrough': { weight: 1, styles: { 'text-decoration': 'line-through' }},
+    'span': { weight: 1 },
+    'font': { weight: 0 },
+    'em': { weight: 1 },
+    'strong': { weight: 1 },
+    'b': { weight: 1 },
+    'i': { weight: 1 },
+    'span-underline': { weight: 1, styles: { 'text-decoration': 'underline' }}
+  },
+  components: {
+    anytext: { weight: 0.5 },
+    netext: { weight: 0.5 },
+    inline: { useDepth: true, weight: 1.0 },
+    _: { weight: 5.0 }
+  }
+};
+const container: CompositeDetail = {
+  type: 'composite',
+  recursionDepth: 3,
+  tags: {
+    div: { weight: 1 },
+    blockquote: { weight: 1 }
+  },
+  components: {
+    anytext: { weight: 0.5 },
+    netext: { weight: 0.5 },
+    inline: { weight: 1.0 },
+    container: { weight: 0.4, useDepth: true },
+    _: { weight: 0.5 }
+  }
+};
+const listitem: CompositeDetail = {
+  type: 'composite',
+  recursionDepth: 5,
+  tag: 'li',
+  components: {
+    whitespace: { weight: 0.1 },
+    anytext: { weight: 0.5 },
+    list: { useDepth: true, weight: 1 }
+  }
+};
+const list: CompositeDetail = {
+  type: 'composite',
+  recursionDepth: 5,
+  tags: {
+    ol: { weight: 1.0 },
+    ul: { weight: 1.0 }
+  },
+  components: {
+    listitem: { weight: 1, useDepth: true },
+    whitespace: { weight: 1 }
+  }
+};
+const table: StructureDetail = {
+  type: 'structure',
+  tag: 'table',
+  components: {
+    caption: { chance: 0.4 },
+    tbody: { chance: 1.0 },
+    thead: { chance: 0.2 },
+    tfoot: { chance: 0.2 }
+  }
+};
+const tbody: CompositeDetail = {
+  type: 'composite',
+  tag: 'tbody',
+  components: {
+    tr: { weight: 1.5 },
+    whitespace: { weight: 0.1 }
+  }
+};
+const thead: CompositeDetail = {
+  type: 'composite',
+  tag: 'thead',
+  components: {
+    tr: { weight: 1.5 },
+    whitespace: { weight: 0.1 }
+  }
+};
+const tfoot: CompositeDetail = {
+  type: 'composite',
+  tag: 'tfoot',
+  components: {
+    tr: { weight: 1.5 },
+    whitespace: { weight: 0.1 }
+  }
+};
+const tr: CompositeDetail = {
+  type: 'composite',
+  tag: 'tr',
+  components: {
+    whitespace: { weight: 0.5 },
+    tablecell: { weight: 3.5 }
+  }
+};
+const tablecell: CompositeDetail = {
+  type: 'composite',
+  tags: {
+    th: { weight: 1.0 },
+    td: { weight: 1.0 }
+  },
+  components: {
+    netext: { weight: 0.5 },
+    anytext: { weight: 0.5 },
+    whitespace: { weight: 1.0 }
+  }
+};
+const caption: CompositeDetail = {
+  type: 'composite',
+  tag: 'caption',
+  components: {
+    netext: { weight: 0.5 },
+    anytext: { weight: 0.5 },
+    whitespace: { weight: 1.0 }
+  }
+};
+const image: ArbitraryDetail<SugarElement<HTMLElement>> = {
+  type: 'arbitrary',
+  component: ArbNodes.elementOfArb(fc.constantFrom('img'))
+};
+const netext: ArbitraryDetail<SugarElement<Text>> = {
+  type: 'arbitrary',
+  component: ArbNodes.textOfArb(fc.string({ minLength: 1 }))
+};
+const anytext: ArbitraryDetail<SugarElement<Text>> = {
+  type: 'arbitrary',
+  component: ArbNodes.textOfArb(fc.string())
+};
+const whitespace: ArbitraryDetail<SugarElement<Text>> = {
+  type: 'arbitrary',
+  component: ArbNodes.textOfArb(fc.constantFrom(' ', '\n'))
+};
+const zerowidth: ArbitraryDetail<SugarElement<Text>> = {
+  type: 'arbitrary',
+  component: ArbNodes.textOfArb(fc.constant(Unicode.zeroWidth))
+};
+const zerowidths: ArbitraryDetail<SugarElement<Text>> = {
+  type: 'arbitrary',
+  component: ArbNodes.textOfArb(fc.constantFrom('\u200B', Unicode.zeroWidth))
+};
+const comment: ArbitraryDetail<SugarElement<Comment>> = {
+  type: 'arbitrary',
+  component: ArbNodes.comment
+};
+export const ArbSchema = {
+  whitespace,
+  formatting,
+  inline,
+  netext,
+  anytext,
+  container,
+  listitem,
+  list,
+  table,
+  tbody,
+  thead,
+  tfoot,
+  tr,
+  tablecell,
+  caption,
+  image,
+  comment,
+  zerowidth,
+  zerowidths
+};
+export type ArbSchema = typeof ArbSchema;

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/ArbSchemaTypes.ts
@@ -0,0 +1,109 @@
+import { Merger, Obj } from '@ephox/katamari';
+import { Attribute, Css, InsertAll, SugarElement } from '@ephox/sugar';
+import * as fc from 'fast-check';
+import * as ArbChildrenSchema from './ArbChildrenSchema';
+import * as ArbNodes from './ArbNodes';
+import * as WeightedChoice from './WeightedChoice';
+interface Decorations {
+  readonly attributes?: Record<string, string | boolean | number>;
+  readonly styles?: Record<string, string>;
+}
+interface ArbDecorations {
+  readonly attributes?: fc.Arbitrary<Record<string, string | boolean | number>>;
+  readonly styles?: fc.Arbitrary<Record<string, string>>;
+}
+export interface TagDetail extends ArbDecorations {
+  readonly tag: string;
+}
+export interface TagsDetail extends ArbDecorations {
+  readonly tags: Record<string, WeightedChoice.WeightedItem & Decorations>;
+}
+export type CompositeDetail = (TagDetail | TagsDetail) & ArbChildrenSchema.CompositeDetail & {
+  readonly type: 'composite';
+};
+export interface StructureDetail extends TagDetail, ArbChildrenSchema.StructureDetail {
+  readonly type: 'structure';
+}
+export interface LeafDetail extends TagDetail {
+  readonly type: 'leaf';
+}
+export interface ArbitraryDetail<T> {
+  readonly type: 'arbitrary';
+  readonly component: fc.Arbitrary<T>;
+}
+export type SchemaDetail = ArbitraryDetail<any> | CompositeDetail | LeafDetail | StructureDetail;
+interface Tag extends WeightedChoice.WeightedItem, Decorations {
+  readonly tag: string;
+}
+export interface Schema {
+  readonly arbitrary: <T extends Node>(arb: ArbitraryDetail<T>) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<T>>;
+  readonly leaf: (detail: LeafDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
+  readonly structure: (detail: StructureDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
+  readonly composite: (detail: CompositeDetail) => (rawDepth: number | undefined) => fc.Arbitrary<SugarElement<HTMLElement>>;
+}
+const isTagsDetail = (detail: TagsDetail | TagDetail): detail is TagsDetail =>
+  (detail as TagsDetail).tags !== undefined;
+const toTags = (detail: TagsDetail): Tag[] =>
+  Obj.mapToArray(detail.tags, (v, k) => Merger.deepMerge(v, { tag: k }));
+const flattenTag = (tag: string): Record<string, WeightedChoice.WeightedItem & Decorations> => {
+  const r = {};
+  r[tag] = { weight: 1.0 };
+  return r;
+};
+const conform = (detail: TagsDetail | TagDetail): TagsDetail => {
+  if (isTagsDetail(detail)) {
+    return detail;
+  } else {
+    return Merger.deepMerge(detail, {
+      tags: flattenTag(detail.tag)
+    });
+  }
+};
+const addDecorations = (detail: ArbDecorations, element: SugarElement<HTMLElement>) => {
+  const attrDecorator = detail.attributes !== undefined ? detail.attributes : fc.constant({});
+  const styleDecorator = detail.styles !== undefined ? detail.styles : fc.constant({});
+  return attrDecorator.chain((attrs) => {
+    Attribute.setAll(element, attrs);
+    return styleDecorator.map((styles) => {
+      Css.setAll(element, styles);
+      return element;
+    });
+  });
+};
+const makeTag = (choice: Tag): SugarElement<HTMLElement> => {
+  const element = ArbNodes.elementOf(choice.tag);
+  const attributes = choice.attributes !== undefined ? choice.attributes : {};
+  const styles = choice.styles !== undefined ? choice.styles : {};
+  Attribute.setAll(element, attributes);
+  Css.setAll(element, styles);
+  return element;
+};
+export const create = (construct: ArbChildrenSchema.Construct<SugarElement<Node>>): Schema => {
+  const combine = (detail: LeafDetail | StructureDetail | CompositeDetail, childGenerator: fc.Arbitrary<SugarElement<Node>[]>) => {
+    const tags = toTags(conform(detail));
+    return WeightedChoice.generator(tags).chain((choiceOption) => {
+      const choice = choiceOption.getOrDie('Every entry in tags for: ' + JSON.stringify(detail) + ' must have a tag');
+      return childGenerator.chain((children) => {
+        const parent = makeTag(choice);
+        InsertAll.append(parent, children);
+        return addDecorations(detail, parent);
+      });
+    });
+  };
+  const composite = (detail: CompositeDetail) => (rawDepth: number | undefined) => {
+    const childGenerator = ArbChildrenSchema.composite(rawDepth, detail, construct);
+    return combine(detail, childGenerator);
+  };
+  const leaf = (detail: LeafDetail) => (_: number | undefined) => combine(detail, ArbChildrenSchema.none);
+  const structure = (detail: StructureDetail) => (rawDepth: number | undefined) => {
+    const childGenerator = ArbChildrenSchema.structure(rawDepth, detail, construct);
+    return combine(detail, childGenerator);
+  };
+  const arbitrary = (arb) => (_) => arb.component;
+  return {
+    arbitrary,
+    leaf,
+    structure,
+    composite
+  };
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/GenSelection.ts
@@ -0,0 +1,33 @@
+import { Fun, Merger } from '@ephox/katamari';
+import { PredicateFilter, SimRange, SugarElement, SugarNode, SugarText, Traverse } from '@ephox/sugar';
+import * as fc from 'fast-check';
+export interface SelectionExclusions {
+  containers: (container: SugarElement<Node>) => boolean;
+}
+const defaultExclusions: SelectionExclusions = {
+  containers: Fun.never
+  /* Maybe support offsets later if it makes sense to do so */
+};
+const getEnd = (target: SugarElement<Node>): number =>
+  SugarNode.isText(target) ? SugarText.get(target).length : Traverse.children(target).length;
+const gChooseIn = <T extends Node>(target: SugarElement<T>): fc.Arbitrary<{ element: SugarElement<T>; offset: number }> => {
+  const offsets = getEnd(target);
+  return fc.integer({ min: 0, max: offsets }).map((offset) => ({ element: target, offset }));
+};
+const gChooseFrom = (root: SugarElement<Node>, exclusions: SelectionExclusions) => {
+  const self = exclusions.containers(root) ? [] : [ root ];
+  const everything = PredicateFilter.descendants(root, Fun.not(exclusions.containers)).concat(self);
+  return fc.constantFrom(...(everything.length > 0 ? everything : [ root ])).chain(gChooseIn);
+};
+const selection = (root: SugarElement<Node>, rawExclusions: SelectionExclusions): fc.Arbitrary<SimRange> => {
+  const exclusions: SelectionExclusions = Merger.deepMerge(defaultExclusions, rawExclusions);
+  return gChooseFrom(root, exclusions).chain((start) => gChooseFrom(root, exclusions).map((finish): SimRange => ({
+    start: start.element,
+    soffset: start.offset,
+    finish: finish.element,
+    foffset: finish.offset
+  })));
+};
+export {
+  selection
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/PropertySteps.ts
@@ -0,0 +1,17 @@
+import * as fc from 'fast-check';
+import { Step } from '../api/Step';
+import { TestLogs } from '../api/TestLogs';
+const stepToPromise = <T, U>(step: Step<T, U>) => (input: T): PromiseLike<true> =>
+  new Promise<true>((resolve, reject) => {
+    step.runStep(input, () => {
+      resolve(true);
+    }, reject, TestLogs.init());
+  });
+const sAsyncProperty = <T, X>(name: string, arbitraries: fc.Arbitrary<X>[], statefulStep: Step<X, any>, options?: fc.Parameters): Step<T, T> => {
+  return Step.async<T>((next, die) => {
+    fc.assert(fc.asyncProperty.call(fc, ...arbitraries, stepToPromise(statefulStep)), options).then(next, die);
+  });
+};
+export {
+  sAsyncProperty
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/TagDecorator.ts
@@ -0,0 +1,21 @@
+import * as fc from 'fast-check';
+import * as WeightedChoice from './WeightedChoice';
+export interface Decorator<T> extends WeightedChoice.WeightedItem{
+  property: string;
+  value: fc.Arbitrary<T>;
+}
+const gOne = <T>(wDecorations: Decorator<T>[]): fc.Arbitrary<Record<string, T>> =>
+  WeightedChoice.generator(wDecorations).chain((choice) =>
+    choice.fold(() =>
+      fc.constant({}),
+    (c) => c.value.map((v) => {
+      const r = {};
+      r[c.property] = v;
+      return r;
+    })));
+const gEnforce = <T>(decorations: T): fc.Arbitrary<T> =>
+  fc.constant(decorations);
+export {
+  gOne,
+  gEnforce
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/arbitrary/WeightedChoice.ts
@@ -0,0 +1,46 @@
+import { Arr, Obj, Optional } from '@ephox/katamari';
+import * as fc from 'fast-check';
+export interface WeightedItem {
+  useDepth?: boolean;
+  weight: number;
+}
+export interface AccWeightItem {
+  accWeight: number;
+}
+export interface WeightedList<T extends WeightedItem> {
+  readonly list: (T & AccWeightItem)[];
+  readonly total: number;
+}
+const weighted = <T extends WeightedItem> (list: (T & AccWeightItem)[], total: number): WeightedList<T> => ({
+  list,
+  total
+});
+const choose = <T extends WeightedItem>(candidates: T[]): WeightedList<T> => {
+  const result = Arr.foldl(candidates, (rest, d) => {
+    const newTotal = rest.total + d.weight;
+    const merged: T & AccWeightItem = {
+      ...d,
+      accWeight: newTotal
+    };
+    return {
+      total: newTotal,
+      list: rest.list.concat([ merged ])
+    };
+  }, { list: [] as Array<T & AccWeightItem>, total: 0 });
+  return weighted(result.list, result.total);
+};
+const gChoose = <T extends WeightedItem>(weighted: WeightedList<T>): fc.Arbitrary<Optional<T & AccWeightItem>> =>
+  fc.float({ min: 0, max: weighted.total }).map((w): Optional<T & AccWeightItem> => {
+    const raw = Arr.find(weighted.list, (d) =>
+      w <= d.accWeight
+    );
+    const keys = raw.map(Obj.keys).getOr([]);
+    return keys.length === [ 'weight', 'accWeight' ].length ? Optional.none() : raw;
+  });
+const generator = <T extends WeightedItem>(candidates: T[]): fc.Arbitrary<Optional<T & AccWeightItem>> => {
+  const list = choose(candidates);
+  return gChoose(list);
+};
+export {
+  generator
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/assertions/ApproxStructures.ts
@@ -0,0 +1,285 @@
+import { Assert, TestLabel } from '@ephox/bedrock-client';
+import { Arr, Fun, Obj, Optional } from '@ephox/katamari';
+import { Attribute, Classes, Css, Html, SugarElement, SugarNode, SugarText, Traverse, Truncate, Value } from '@ephox/sugar';
+import * as ApproxComparisons from './ApproxComparisons';
+export interface StringAssert {
+  show: () => string;
+  strAssert: (label: TestLabel, actual: string) => void;
+}
+export interface ArrayAssert {
+  show: () => void;
+  arrAssert: (label: TestLabel, array: any[]) => void;
+}
+export interface ElementQueue {
+  context(): string;
+  current(): Optional<SugarElement<Node>>;
+  peek(): Optional<SugarElement<Node>>;
+  take(): Optional<SugarElement<Node>>;
+  mark(): {
+    reset: () => void ;
+    atMark: () => boolean;
+  };
+}
+export interface StructAssertBasic {
+  type?: 'basic';
+  doAssert: (actual: SugarElement<Node>) => void;
+}
+export interface StructAssertAdv {
+  type: 'advanced';
+  doAssert: (queue: ElementQueue) => void;
+}
+export type StructAssert = StructAssertBasic | StructAssertAdv;
+export interface ElementFields {
+  attrs?: Record<string, StringAssert>;
+  classes?: ArrayAssert[];
+  styles?: Record<string, StringAssert>;
+  html?: StringAssert;
+  value?: StringAssert;
+  children?: StructAssert[];
+}
+const elementQueue = (items: SugarElement<Node>[], container: Optional<SugarElement<Node>>): ElementQueue => {
+  let i = -1;
+  const context = () => {
+    const hasItem = i >= 0 && i < items.length;
+    const itemHtml = hasItem ? '\n' + Truncate.getHtml(items[i]) : ' *missing*';
+    const itemInfo = '\nItem[' + i + ']:' + itemHtml;
+    return container.fold(
+      () => {
+        const structHtml = Arr.map(items, Html.getOuter).join('');
+        const structInfo = '\nComplete Structure:\n' + structHtml;
+        return itemInfo + structInfo;
+      },
+      (element) => {
+        const containerHtml = Truncate.getHtml(element);
+        const containerInfo = '\nContainer:\n' + containerHtml;
+        const structHtml = Html.getOuter(element);
+        const structInfo = '\nComplete Structure:\n' + structHtml;
+        return containerInfo + itemInfo + structInfo;
+      }
+    );
+  };
+  const current = () => i >= 0 && i < items.length ? Optional.some(items[i]) : Optional.none<SugarElement<Node>>();
+  const peek = () => i + 1 < items.length ? Optional.some(items[i + 1]) : Optional.none<SugarElement<Node>>();
+  const take = () => {
+    i += 1;
+    return current();
+  };
+  const mark = () => {
+    const x = i;
+    const reset = () => {
+      i = x;
+    };
+    const atMark = () => i === x;
+    return {
+      reset,
+      atMark
+    };
+  };
+  return {
+    context,
+    current,
+    peek,
+    take,
+    mark
+  };
+};
+const element = (tag: string, fields: ElementFields): StructAssert => {
+  const doAssert = (actual: SugarElement<Node>): void => {
+    if (SugarNode.isHTMLElement(actual)) {
+      Assert.eq(() => 'Incorrect node name for: ' + Truncate.getHtml(actual), tag, SugarNode.name(actual));
+      const attrs = fields.attrs !== undefined ? fields.attrs : {};
+      const classes = fields.classes !== undefined ? fields.classes : [];
+      const styles = fields.styles !== undefined ? fields.styles : {};
+      const html = fields.html !== undefined ? Optional.some(fields.html) : Optional.none<StringAssert>();
+      const value = fields.value !== undefined ? Optional.some(fields.value) : Optional.none<StringAssert>();
+      const children = fields.children !== undefined ? Optional.some(fields.children) : Optional.none<StructAssert[]>();
+      assertAttrs(attrs, actual);
+      assertClasses(classes, actual);
+      assertStyles(styles, actual);
+      assertHtml(html, actual);
+      assertValue(value, actual);
+      assertChildren(children, actual);
+    } else {
+      Assert.eq('Incorrect node type for: ' + Truncate.getHtml(actual), 1, SugarNode.type(actual));
+    }
+  };
+  return {
+    doAssert
+  };
+};
+const text = (s: StringAssert, combineSiblings = false): StructAssert => {
+  const doAssert = (queue: ElementQueue): void => {
+    queue.take().fold(() => {
+      Assert.fail('No more nodes, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
+    }, (actual) => {
+      SugarText.getOption(actual).fold(() => {
+        Assert.fail('Node is not a text node, so cannot check if its text is: ' + s.show() + ' for ' + queue.context());
+      }, (t: string) => {
+        let text = t;
+        if (combineSiblings) {
+          while (queue.peek().exists(SugarNode.isText)) {
+            text += queue.take().bind(SugarText.getOption).getOr('');
+          }
+        }
+        if (s.strAssert === undefined) {
+          throw new Error(JSON.stringify(s) + ' is not a *string assertion*');
+        }
+        s.strAssert('Checking text content', text);
+      });
+    });
+  };
+  return {
+    type: 'advanced',
+    doAssert
+  };
+};
+const applyAssert = (structAssert: StructAssert, queue: ElementQueue) => {
+  if (structAssert.type === 'advanced') {
+    structAssert.doAssert(queue);
+  } else {
+    queue.take().fold(() => {
+      Assert.fail('Expected more children to satisfy assertion for ' + queue.context());
+    }, (item) => {
+      structAssert.doAssert(item);
+    });
+  }
+};
+const either = (structAsserts: StructAssert[]): StructAssert => {
+  const doAssert = (queue: ElementQueue) => {
+    const mark = queue.mark();
+    for (let i = 0; i < structAsserts.length - 1; i++) {
+      try {
+        applyAssert(structAsserts[i], queue);
+        return;
+      } catch (e) {
+        mark.reset();
+      }
+    }
+    if (structAsserts.length > 0) {
+      applyAssert(structAsserts[structAsserts.length - 1], queue);
+    }
+  };
+  return {
+    type: 'advanced',
+    doAssert
+  };
+};
+const repeat = (min: number, max: number | true = min) => (structAssert: StructAssert): StructAssert => {
+  const doAssert = (queue: ElementQueue) => {
+    let i = 0;
+    for (; i < min; i++) {
+      applyAssert(structAssert, queue);
+    }
+    for (; (max === true || i < max) && queue.peek().isSome(); i++) {
+      const mark = queue.mark();
+      try {
+        applyAssert(structAssert, queue);
+      } catch (e) {
+        mark.reset();
+      }
+      if (mark.atMark()) {
+        break;
+      }
+    }
+  };
+  return {
+    type: 'advanced',
+    doAssert
+  };
+};
+const zeroOrOne = repeat(0, 1);
+const zeroOrMore = repeat(0, true);
+const oneOrMore = repeat(1, true);
+const anythingStruct: StructAssert = {
+  doAssert: Fun.noop
+};
+const assertAttrs = (expectedAttrs: Record<string, StringAssert>, actual: SugarElement<Element>) => {
+  Obj.each(expectedAttrs, (v, k) => {
+    if (v.strAssert === undefined) {
+      throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* attributes of ' + Truncate.getHtml(actual));
+    }
+    const actualValue = Attribute.getOpt(actual, k).getOrThunk(ApproxComparisons.missing);
+    v.strAssert(
+      () => 'Checking attribute: "' + k + '" of ' + Truncate.getHtml(actual) + '\n',
+      actualValue
+    );
+  });
+};
+const assertClasses = (expectedClasses: ArrayAssert[], actual: SugarElement<Element>) => {
+  const actualClasses = Classes.get(actual);
+  Arr.each(expectedClasses, (eCls) => {
+    if (eCls.arrAssert === undefined) {
+      throw new Error(JSON.stringify(eCls) + ' is not an *array assertion*.\nSpecified in *expected* classes of ' + Truncate.getHtml(actual));
+    }
+    eCls.arrAssert(() => 'Checking classes in ' + Truncate.getHtml(actual) + '\n', actualClasses);
+  });
+};
+const assertStyles = (expectedStyles: Record<string, StringAssert>, actual: SugarElement<Element>) => {
+  Obj.each(expectedStyles, (v, k) => {
+    const actualValue = Css.getRaw(actual, k).getOrThunk(ApproxComparisons.missing);
+    if (v.strAssert === undefined) {
+      throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* styles of ' + Truncate.getHtml(actual));
+    }
+    v.strAssert(
+      () => 'Checking style: "' + k + '" of ' + Truncate.getHtml(actual) + '\n',
+      actualValue
+    );
+  });
+};
+const assertHtml = (expectedHtml: Optional<StringAssert>, actual: SugarElement<HTMLElement>) => {
+  expectedHtml.each((expected) => {
+    const actualHtml = Html.get(actual);
+    if (expected.strAssert === undefined) {
+      throw new Error(JSON.stringify(expected) + ' is not a *string assertion*.\nSpecified in *expected* innerHTML of ' + Truncate.getHtml(actual));
+    }
+    expected.strAssert(() => 'Checking HTML of ' + Truncate.getHtml(actual), actualHtml);
+  });
+};
+const assertValue = (expectedValue: Optional<StringAssert>, actual: SugarElement<HTMLElement>) => {
+  expectedValue.each((v) => {
+    if (v.strAssert === undefined) {
+      throw new Error(JSON.stringify(v) + ' is not a *string assertion*.\nSpecified in *expected* value of ' + Truncate.getHtml(actual));
+    }
+    v.strAssert(
+      () => 'Checking value of ' + Truncate.getHtml(actual),
+      Value.get(actual as SugarElement<any>)
+    );
+  });
+};
+const assertChildren = (expectedChildren: Optional<StructAssert[]>, actual: SugarElement<Node>) => {
+  expectedChildren.each((expected) => {
+    const children = elementQueue(Traverse.children(actual), Optional.some(actual));
+    Arr.each(expected, (structExpectation, i) => {
+      if (structExpectation.doAssert === undefined) {
+        throw new Error(JSON.stringify(structExpectation) + ' is not a *structure assertion*.\n' +
+          'Specified in *expected* children of ' + Truncate.getHtml(actual));
+      }
+      if (structExpectation.type === 'advanced') {
+        structExpectation.doAssert(children);
+      } else {
+        children.take().fold(() => {
+          Assert.fail('Expected more children to satisfy assertion ' + i + ' for ' + children.context());
+        }, (item) => {
+          structExpectation.doAssert(item);
+        });
+      }
+    });
+    if (children.peek().isSome()) {
+      Assert.fail('More children than expected for ' + children.context());
+    }
+  });
+};
+const anything = Fun.constant(anythingStruct);
+const theRest = Fun.constant(zeroOrMore(anythingStruct));
+export {
+  elementQueue,
+  anything,
+  element,
+  text,
+  either,
+  repeat,
+  zeroOrOne,
+  zeroOrMore,
+  oneOrMore,
+  theRest
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/assertions/Differ.ts
@@ -0,0 +1,130 @@
+/*
+ * Javascript Diff Algorithm
+ *  By John Resig (http://ejohn.org/)
+ *  Modified by Chu Alan "sprite"
+ *
+ * Released under the MIT license.
+ *
+ * More Info:
+ *  http://ejohn.org/projects/javascript-diff-algorithm/
+ *
+ * Usage: QUnit.diff(expected, actual)
+ *
+ * QUnit.diff( "the quick brown fox jumped over", "the quick fox jumps over" ) == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
+ */
+const htmlDiff: (v1: string, v2: string) => string = (() => {
+  const hasOwn = Object.prototype.hasOwnProperty;
+  /* jshint eqeqeq:false, eqnull:true */
+  const diff = (o, n) => {
+    let i;
+    const ns = {};
+    const os = {};
+    for (i = 0; i < n.length; i++) {
+      if (!hasOwn.call(ns, n[i])) {
+        ns[n[i]] = {
+          rows: [],
+          o: null
+        };
+      }
+      ns[n[i]].rows.push(i);
+    }
+    for (i = 0; i < o.length; i++) {
+      if (!hasOwn.call(os, o[i])) {
+        os[o[i]] = {
+          rows: [],
+          n: null
+        };
+      }
+      os[o[i]].rows.push(i);
+    }
+    for (i in ns) {
+      if (hasOwn.call(ns, i)) {
+        if (ns[i].rows.length === 1 && hasOwn.call(os, i) && os[i].rows.length === 1) {
+          n[ns[i].rows[0]] = {
+            text: n[ns[i].rows[0]],
+            row: os[i].rows[0]
+          };
+          o[os[i].rows[0]] = {
+            text: o[os[i].rows[0]],
+            row: ns[i].rows[0]
+          };
+        }
+      }
+    }
+    for (i = 0; i < n.length - 1; i++) {
+      if (n[i].text != null && n[i + 1].text == null && n[i].row + 1 < o.length && o[n[i].row + 1].text == null &&
+        n[i + 1] === o[n[i].row + 1]) {
+        n[i + 1] = {
+          text: n[i + 1],
+          row: n[i].row + 1
+        };
+        o[n[i].row + 1] = {
+          text: o[n[i].row + 1],
+          row: i + 1
+        };
+      }
+    }
+    for (i = n.length - 1; i > 0; i--) {
+      if (n[i].text != null && n[i - 1].text == null && n[i].row > 0 && o[n[i].row - 1].text == null &&
+        n[i - 1] === o[n[i].row - 1]) {
+        n[i - 1] = {
+          text: n[i - 1],
+          row: n[i].row - 1
+        };
+        o[n[i].row - 1] = {
+          text: o[n[i].row - 1],
+          row: i - 1
+        };
+      }
+    }
+    return {
+      o,
+      n
+    };
+  };
+  return (o, n) => {
+    o = o.replace(/\s+$/, '');
+    n = n.replace(/\s+$/, '');
+    let i, pre,
+      str = '',
+      oSpace = o.match(/\s+/g),
+      nSpace = n.match(/\s+/g);
+    const out = diff(o === '' ? [] : o.split(/\s+/), n === '' ? [] : n.split(/\s+/));
+    if (oSpace == null) {
+      oSpace = [ ' ' ];
+    } else {
+      oSpace.push(' ');
+    }
+    if (nSpace == null) {
+      nSpace = [ ' ' ];
+    } else {
+      nSpace.push(' ');
+    }
+    if (out.n.length === 0) {
+      for (i = 0; i < out.o.length; i++) {
+        str += '<del>' + out.o[i] + oSpace[i] + '</del>';
+      }
+    } else {
+      if (out.n[0].text == null) {
+        for (let j = 0; j < out.o.length && out.o[j].text == null; j++) {
+          str += '<del>' + out.o[j] + oSpace[j] + '</del>';
+        }
+      }
+      for (i = 0; i < out.n.length; i++) {
+        if (out.n[i].text == null) {
+          str += '<ins>' + out.n[i] + nSpace[i] + '</ins>';
+        } else {
+          pre = '';
+          for (let j = out.n[i].row + 1; j < out.o.length && out.o[j].text == null; j++) {
+            pre += '<del>' + out.o[j] + oSpace[j] + '</del>';
+          }
+          str += ' ' + out.n[i].text + nSpace[i] + pre;
+        }
+      }
+    }
+    return str;
+  };
+})();
+export {
+  htmlDiff
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/dragndrop/DndEvents.ts
@@ -0,0 +1,50 @@
+import { SugarElement } from '@ephox/sugar';
+import { setProtectedMode, setReadOnlyMode, setReadWriteMode } from '../datatransfer/Mode';
+const createDndEvent = (name: string) => (win: Window, x: number, y: number, dataTransfer: DataTransfer): DragEvent => {
+  const event: any = document.createEvent('CustomEvent');
+  event.initCustomEvent(name, true, true, null);
+  event.view = win;
+  event.ctrlKey = false;
+  event.altKey = false;
+  event.shiftKey = false;
+  event.metaKey = false;
+  event.button = 0;
+  event.relatedTarget = null;
+  event.screenX = win.screenX + x;
+  event.screenY = win.screenY + y;
+  event.dataTransfer = dataTransfer;
+  return event;
+};
+const createDragoverEvent = createDndEvent('dragover');
+const createDragendEvent = createDndEvent('dragend');
+const createDragstartEvent = createDndEvent('dragstart');
+const createDragleaveEvent = createDndEvent('dragleave');
+const createDragenterEvent = createDndEvent('dragenter');
+const createDropEvent = createDndEvent('drop');
+const createDragEvent = createDndEvent('drag');
+const isDefaultPrevented = (evt: DragEvent): boolean => evt.defaultPrevented;
+const dispatchDndEvent = (event: DragEvent, target: SugarElement<Node>): DragEvent => {
+  if (event.type === 'dragstart') {
+    setReadWriteMode(event.dataTransfer);
+  } else if (event.type === 'drop') {
+    setReadOnlyMode(event.dataTransfer);
+  } else {
+    setProtectedMode(event.dataTransfer);
+  }
+  target.dom.dispatchEvent(event);
+  return event;
+};
+const getWindowFromElement = (element: SugarElement<Element>): Window => element.dom.ownerDocument.defaultView;
+export {
+  createDndEvent,
+  createDragoverEvent,
+  createDragendEvent,
+  createDragstartEvent,
+  createDragleaveEvent,
+  createDragenterEvent,
+  createDropEvent,
+  createDragEvent,
+  isDefaultPrevented,
+  dispatchDndEvent,
+  getWindowFromElement
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/find/UiSearcher.ts
@@ -0,0 +1,68 @@
+import { TestLabel } from '@ephox/bedrock-client';
+import { Adt, Optional, Result } from '@ephox/katamari';
+import { SugarElement, Truncate } from '@ephox/sugar';
+import * as SizzleFind from '../alien/SizzleFind';
+interface TargetAdt {
+  fold: <T> (
+    self: (element: SugarElement<Node>, selector: string) => T,
+    children: (element: SugarElement<Node>, selector: string) => T,
+    descendants: (element: SugarElement<Node>, selector: string) => T
+  ) => T;
+  match: <T>(branches: {
+    self: (element: SugarElement<Node>, selector: string) => T;
+    children: (element: SugarElement<Node>, selector: string) => T;
+    descendants: (element: SugarElement<Node>, selector: string) => T;
+  }) => T;
+  log: (label: string) => void;
+}
+const targets: {
+  self: (element: SugarElement<Node>, selector: string) => TargetAdt;
+  children: (element: SugarElement<Node>, selector: string) => TargetAdt;
+  descendants: (element: SugarElement<Node>, selector: string) => TargetAdt;
+} = Adt.generate([
+  { self: [ 'element', 'selector' ] },
+  { children: [ 'element', 'selector' ] },
+  { descendants: [ 'element', 'selector' ] }
+]);
+const derive = (element: SugarElement<Node>, selector: string) => {
+  if (selector === undefined) {
+    throw new Error('No selector passed through');
+  } else if (selector.indexOf('root:') === 0) {
+    return targets.self(element, selector.substring('root:'.length));
+  } else if (selector.indexOf('root>') === 0) {
+    return targets.children(element, selector.substring('root>'.length));
+  } else {
+    return targets.descendants(element, selector);
+  }
+};
+const matchesSelf = <T extends Element>(element: SugarElement<Node>, selector: string): Optional<SugarElement<T>> =>
+  SizzleFind.matches<T>(element, selector) ? Optional.some(element) : Optional.none();
+const select = <T extends Element>(element: SugarElement<Node>, selector: string): Optional<SugarElement<T>> =>
+  derive(element, selector).fold<Optional<SugarElement<T>>>(
+    matchesSelf,
+    SizzleFind.child,
+    SizzleFind.descendant
+  );
+const selectAll = <T extends Element>(element: SugarElement<Node>, selector: string): Array<SugarElement<T>> =>
+  derive(element, selector).fold<Array<SugarElement<T>>>(
+    (element, selector) => matchesSelf<T>(element, selector).toArray(),
+    SizzleFind.children,
+    SizzleFind.descendants
+  );
+const toResult = <T>(message: TestLabel, option: Optional<T>): Result<T, TestLabel> =>
+  option.fold(
+    () => Result.error<T, TestLabel>(TestLabel.asString(message)),
+    Result.value
+  );
+const findIn = <T extends Element>(container: SugarElement<Node>, selector: string): Result<SugarElement<T>, TestLabel> =>
+  toResult(
+    () => 'Could not find selector: ' + selector + ' in ' + Truncate.getHtml(container),
+    select(container, selector)
+  );
+const findAllIn = <T extends Element>(container: SugarElement<Node>, selector: string): Array<SugarElement<T>> =>
+  selectAll(container, selector);
+export {
+  select,
+  findIn,
+  findAllIn
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/keyboard/FakeKeys.ts
@@ -0,0 +1,76 @@
+import { PlatformDetection } from '@ephox/sand';
+import { SugarElement } from '@ephox/sugar';
+export interface OldKeyModifiers {
+  shift?: boolean;
+  meta?: boolean;
+  ctrl?: boolean;
+  alt?: boolean;
+}
+export interface KeyModifiers {
+  shiftKey?: boolean;
+  metaKey?: boolean;
+  ctrlKey?: boolean;
+  altKey?: boolean;
+}
+export type MixedKeyModifiers = OldKeyModifiers | KeyModifiers;
+const isNewKeyModifiers = (modifiers: MixedKeyModifiers): modifiers is KeyModifiers =>
+  'shiftKey' in modifiers || 'metaKey' in modifiers || 'ctrlKey' in modifiers || 'altKey' in modifiers;
+const newModifiers = (modifiers: MixedKeyModifiers): KeyModifiers => isNewKeyModifiers(modifiers) ? modifiers :
+  { shiftKey: modifiers.shift, metaKey: modifiers.meta, ctrlKey: modifiers.ctrl, altKey: modifiers.alt };
+const keyevent = (type: string, doc: SugarElement<Document>, value: number, modifiers: MixedKeyModifiers, focus?: SugarElement<Node>): void => {
+  const domDoc: Document = doc.dom;
+  const mod = newModifiers(modifiers);
+  const oEvent = domDoc.createEvent('KeyboardEvent');
+  const getter = () => value;
+  const defineGetter = (obj, key: string, propGetter) => {
+    Object.defineProperty(obj, key, { get: propGetter, enumerable: true });
+  };
+  const dispatcher = focus !== undefined ? focus : doc;
+  const platform = PlatformDetection.detect();
+  if (platform.browser.isSafari()) {
+    safari(type, doc, value, mod, dispatcher);
+  } else {
+    if (platform.browser.isChromium() || platform.browser.isFirefox()) {
+      if (type === 'keypress') {
+        defineGetter(oEvent, 'charCode', getter);
+      }
+      defineGetter(oEvent, 'keyCode', getter);
+      defineGetter(oEvent, 'which', getter);
+      defineGetter(oEvent, 'shiftKey', () => mod.shiftKey === true);
+      defineGetter(oEvent, 'metaKey', () => mod.metaKey === true);
+      defineGetter(oEvent, 'ctrlKey', () => mod.ctrlKey === true);
+      defineGetter(oEvent, 'altKey', () => mod.altKey === true);
+    }
+    const canBubble = true;
+    const cancellable = true;
+    const ctrlKey = mod.ctrlKey === true;
+    const altKey = mod.altKey === true;
+    const shiftKey = mod.shiftKey === true;
+    const metaKey = mod.metaKey === true;
+    const anyEvent = oEvent as any;
+    if (anyEvent.initKeyboardEvent) {
+      anyEvent.initKeyboardEvent(type, canBubble, cancellable, domDoc.defaultView, ctrlKey, altKey, shiftKey, metaKey, value, value);
+    } else {
+      anyEvent.initKeyEvent(type, canBubble, cancellable, domDoc.defaultView, ctrlKey, altKey, shiftKey, metaKey, value, type === 'keypress' && platform.browser.isFirefox() ? value : 0);
+    }
+    dispatcher.dom.dispatchEvent(oEvent);
+  }
+};
+const safari = (type: string, doc: SugarElement<Document>, value: number, modifiers: KeyModifiers, dispatcher: SugarElement<Node>): void => {
+  const oEvent = doc.dom.createEvent('Events');
+  oEvent.initEvent(type, true, true);
+  if (type === 'keypress') {
+    (oEvent as any).charCode = value;
+  }
+  (oEvent as any).which = value;
+  (oEvent as any).keyCode = value;
+  (oEvent as any).shiftKey = modifiers.shiftKey === true;
+  (oEvent as any).ctrlKey = modifiers.ctrlKey === true;
+  (oEvent as any).metaKey = modifiers.metaKey === true;
+  (oEvent as any).altKey = modifiers.altKey === true;
+  dispatcher.dom.dispatchEvent(oEvent);
+};
+export {
+  newModifiers,
+  keyevent
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/mouse/Clicks.ts
@@ -0,0 +1,85 @@
+import { Fun, Obj } from '@ephox/katamari';
+import { SugarElement, SugarLocation, SugarNode, SugarPosition, Traverse } from '@ephox/sugar';
+const leftClickButton = 0;
+const middleClickButton = 1;
+const rightClickButton = 2;
+const leftClickButtons = 1;
+const rightClickButtons = 2;
+const middleClickButtons = 4;
+interface Settings {
+  dx?: number;
+  dy?: number;
+  button?: number;
+  buttons?: number;
+  ctrlKey?: boolean;
+  shiftKey?: boolean;
+  altKey?: boolean;
+  metaKey?: boolean;
+  bubbles?: boolean;
+  cancelable?: boolean;
+}
+type EventType = 'click' | 'mousedown' | 'mouseup' | 'mousemove' | 'mouseover' | 'mouseout' | 'contextmenu';
+const event = (type: EventType, { dx, dy, ...settings }: Settings) => (element: SugarElement<Node>): void => {
+  const location = (SugarNode.isElement(element) ? SugarLocation.absolute(element) : SugarPosition(0, 0)).translate(dx || 0, dy || 0);
+  const event = new MouseEvent(type, {
+    screenX: location.left,
+    screenY: location.top,
+    clientX: location.left,
+    clientY: location.top,
+    bubbles: true,
+    cancelable: true,
+    ...settings
+  });
+  element.dom.dispatchEvent(event);
+};
+const click = (settings: Settings) => (element: SugarElement<Node>): void => {
+  const dom = element.dom;
+  Obj.get(dom as any, 'click').fold(() => event('click', settings)(element), Fun.call);
+};
+const mouseDown = Fun.curry(event, 'mousedown');
+const mouseUp = Fun.curry(event, 'mouseup');
+const mouseMove = Fun.curry(event, 'mousemove');
+const mouseOver = Fun.curry(event, 'mouseover');
+const mouseOut = Fun.curry(event, 'mouseout');
+const contextMenu = (settings: Settings): (element: SugarElement<Node>) => void =>
+  event('contextmenu', { button: rightClickButton, ...settings });
+const trigger = (element: SugarElement<HTMLElement>): void => {
+  const ele = element.dom;
+  if (ele.click !== undefined) {
+    return ele.click();
+  }
+  point('click', leftClickButton, element, 0, 0);
+  return;
+};
+const point = (type: string, button: number, element: SugarElement<Node>, x: number, y: number): void => {
+  const ev: MouseEvent = Traverse.owner(element).dom.createEvent('MouseEvents');
+  ev.initMouseEvent(
+    type,
+    true /* bubble */, true /* cancelable */,
+    window, null,
+    x, y, x, y, /* coordinates */
+    false, false, false, false, /* modifier keys */
+    button, null
+  );
+  element.dom.dispatchEvent(ev);
+};
+export {
+  event,
+  Settings,
+  EventType,
+  leftClickButton,
+  middleClickButton,
+  rightClickButton,
+  leftClickButtons,
+  rightClickButtons,
+  middleClickButtons,
+  click,
+  mouseDown,
+  mouseUp,
+  mouseMove,
+  mouseOver,
+  mouseOut,
+  contextMenu,
+  point,
+  trigger
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/pipe/Pipe.ts
@@ -0,0 +1,17 @@
+import { addStackTrace, TestLogs } from '../api/TestLogs';
+export type NextFn<T> = (value: T, logs: TestLogs) => void;
+export type DieFn = (err: any, logs: TestLogs) => void;
+export type RunFn<T, U> = (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs) => void;
+export const Pipe = <T, U>(f: RunFn<T, U>): RunFn<T, U> => (value: T, next: NextFn<U>, die: DieFn, logs: TestLogs): void => {
+  const bounceNext = (value, nextLogs) => {
+    Promise.resolve().then(() => {
+      next(value, nextLogs);
+    });
+  };
+  try {
+    f(value, bounceNext, die, logs);
+  } catch (err) {
+    const logsWithTrace = addStackTrace(logs, err);
+    die(err, logsWithTrace);
+  }
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/server/SeleniumAction.ts
@@ -0,0 +1,33 @@
+import { DataType, Http } from '@ephox/jax';
+import { Chain } from '../api/Chain';
+import { Step } from '../api/Step';
+const postInfo = (path: string, info: any, die: (err: any) => void, next: (v: {}) => void): void => {
+  Http.post({
+    url: path,
+    body: {
+      type: DataType.JSON,
+      data: info
+    },
+    responseType: DataType.JSON
+  }).get((res) => {
+    res.fold((e) => die(JSON.stringify(e)), next);
+  });
+};
+const sPerform = <T> (path: string, info: any): Step<T, T> =>
+  Step.async<T>((next, die) => {
+    postInfo(path, info, die, next);
+  });
+const cPerform = <T> (path: string): Chain<T, T> =>
+  Chain.async((info, next, die) => {
+    postInfo(path, info, die, next);
+  });
+const pPerform = (path: string, info: any): Promise<{}> => {
+  return new Promise(((resolve, reject) => {
+    postInfo(path, info, reject, resolve);
+  }));
+};
+export {
+  sPerform,
+  cPerform,
+  pPerform
+};

--- a//dev/null
+++ b/modules/agar/src/main/ts/ephox/agar/touch/Touches.ts
@@ -0,0 +1,62 @@
+import { SugarElement, SugarLocation, SugarNode, Traverse } from '@ephox/sugar';
+const point = (type: string, element: SugarElement<Node>, x: number, y: number): void => {
+  const touch = {
+    identifier: Date.now(),
+    target: element.dom,
+    clientX: x,
+    clientY: y,
+    pageX: x,
+    pageY: y,
+    radiusX: 2.5,
+    radiusY: 2.5,
+    rotationAngle: 10,
+    force: 0.5
+  };
+  if (typeof TouchEvent === 'function' && typeof Touch === 'function') {
+    const touchAction = new Touch(touch);
+    const ev: TouchEvent = new TouchEvent(type, {
+      cancelable: true,
+      bubbles: true,
+      view: window,
+      touches: [ touchAction ],
+      targetTouches: [],
+      changedTouches: [ touchAction ]
+    });
+    element.dom.dispatchEvent(ev);
+  } else {
+    const ev: any = new UIEvent(type, {
+      cancelable: true,
+      bubbles: true,
+      view: window
+    });
+    ev.touches = [ touch ];
+    ev.targetTouches = [];
+    ev.changedTouches = [ touch ];
+    element.dom.dispatchEvent(ev);
+  }
+};
+const findElement = (element: SugarElement<Node>): SugarElement<Element> =>
+  (SugarNode.isText(element) ? Traverse.parent(element).getOrDie() : element) as SugarElement<Element>;
+const touch = (eventType: string) => (element: SugarElement<Node>): void => {
+  const position = SugarLocation.absolute(findElement(element));
+  point(eventType, element, position.left, position.top);
+};
+const touchAt = (eventType: string) => (dx: number, dy: number) => (element: SugarElement<Node>): void => {
+  const position = SugarLocation.absolute(findElement(element));
+  point(eventType, element, position.left + dx, position.top + dy);
+};
+const touchstart = touch('touchstart');
+const touchstartAt = touchAt('touchstart');
+const touchend = touch('touchend');
+const touchendAt = touchAt('touchend');
+const touchmove = touch('touchmove');
+const touchmoveTo = touchAt('touchmove');
+export {
+  touchstart,
+  touchstartAt,
+  touchend,
+  touchendAt,
+  touchmove,
+  touchmoveTo,
+  point
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/DraggableResizerDemo.ts
@@ -0,0 +1,86 @@
+import { PlatformDetection } from '@ephox/sand';
+import { Class, Css, SugarElement, SugarPosition, Traverse } from '@ephox/sugar';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { Dragging } from 'ephox/alloy/api/behaviour/Dragging';
+import { Unselecting } from 'ephox/alloy/api/behaviour/Unselecting';
+import { AlloyComponent } from 'ephox/alloy/api/component/ComponentApi';
+import * as Attachment from 'ephox/alloy/api/system/Attachment';
+import * as Gui from 'ephox/alloy/api/system/Gui';
+import { Button } from 'ephox/alloy/api/ui/Button';
+import { Container } from 'ephox/alloy/api/ui/Container';
+import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
+export default (): void => {
+  const gui = Gui.create();
+  const body = SugarElement.fromDom(document.body);
+  Class.add(gui.element, 'gui-root-demo-container');
+  Attachment.attachSystem(body, gui);
+  Css.set(body, 'margin-bottom', '2000px');
+  const onDrag = (comp: AlloyComponent, targetElement: SugarElement<Node>, delta: SugarPosition) => {
+    Traverse.parent(targetElement).bind(Traverse.parent).bind(Traverse.firstChild).each((box) => {
+      Css.getRaw(box, 'height').each((h) => {
+        const parsedHeight = parseInt(h, 10);
+        const newHeight = parsedHeight + delta.top;
+        Css.set(box, 'height', newHeight + 'px');
+      });
+    });
+  };
+  HtmlDisplay.section(
+    gui,
+    'Drag the X to resize the box',
+    Container.sketch({
+      dom: {
+        styles: {
+          width: '500px'
+        }
+      },
+      components: [
+        Container.sketch({
+          dom: {
+            tag: 'div',
+            styles: {
+              background: 'blue',
+              height: '200px',
+              border: '2px solid black'
+            }
+          }
+        }),
+        Container.sketch({
+          dom: {
+            styles: {
+              position: 'relative'
+            }
+          },
+          components: [
+            Button.sketch({
+              dom: {
+                tag: 'span',
+                innerHtml: 'X',
+                styles: {
+                  position: 'absolute',
+                  right: '0px',
+                  bottom: '0px',
+                  padding: '10px',
+                  display: 'inline-block',
+                  background: '#333',
+                  color: '#fff'
+                }
+              },
+              buttonBehaviours: Behaviour.derive([
+                Dragging.config({
+                  mode: PlatformDetection.detect().deviceType.isTouch() ? 'touch' : 'mouse',
+                  blockerClass: 'blocker',
+                  repositionTarget: false,
+                  onDrag
+                }),
+                Unselecting.config({ })
+              ]),
+              eventOrder: {
+                mousedown: [ 'dragging', 'alloy.base.behaviour' ]
+              }
+            })
+          ]
+        })
+      ]
+    })
+  );
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/DragnDropDemo.ts
@@ -0,0 +1,121 @@
+import { Class, Css, Replication, SugarElement } from '@ephox/sugar';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { DragnDrop } from 'ephox/alloy/api/behaviour/DragnDrop';
+import * as Attachment from 'ephox/alloy/api/system/Attachment';
+import * as Gui from 'ephox/alloy/api/system/Gui';
+import { Button } from 'ephox/alloy/api/ui/Button';
+import { Container } from 'ephox/alloy/api/ui/Container';
+import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
+export default (): void => {
+  const gui = Gui.create();
+  const body = SugarElement.fromDom(document.body);
+  Class.add(gui.element, 'gui-root-demo-container');
+  Attachment.attachSystem(body, gui);
+  Css.set(body, 'margin-bottom', '2000px');
+  const createDropZone = (dropEffect: string) => Container.sketch({
+    dom: {
+      tag: 'div',
+      innerHtml: `Drop zone that accepts <b>${dropEffect}</b> also accepts files`,
+      styles: {
+        'margin': '10px 10px 20px 10px',
+        'padding': '20px',
+        'height': '40px',
+        'border': '3px dashed black',
+        'text-align': 'center'
+      }
+    },
+    containerBehaviours: Behaviour.derive([
+      DragnDrop.config({
+        mode: 'drop',
+        type: 'text/plain',
+        dropEffect,
+        onDrop: (_component, dropEvent) => {
+          console.log('onDrop', {
+            data: dropEvent.data,
+            files: dropEvent.files
+          });
+        },
+        onDrag: (_component, _simulatedEvent) => {
+        },
+        onDragover: (_component, _simulatedEvent) => {
+        },
+        onDragenter: (_component, _simulatedEvent) => {
+        },
+        onDragleave: (_component, _simulatedEvent) => {
+        }
+      })
+    ])
+  });
+  const createDraggable = (effectAllowed: string, data: string) => Button.sketch({
+    dom: {
+      tag: 'span',
+      innerHtml: `${effectAllowed}`,
+      styles: {
+        padding: '10px',
+        margin: '10px',
+        border: '1px solid black',
+        display: 'inline-block',
+        background: 'gray'
+      }
+    },
+    buttonBehaviours: Behaviour.derive([
+      DragnDrop.config({
+        mode: 'drag',
+        type: 'text/plain',
+        phoneyTypes: [ '-x-alloy/something' ],
+        effectAllowed,
+        getData: (_component) => {
+          return data;
+        },
+        getImage: (component) => {
+          const clone = Replication.deep<HTMLElement>(component.element);
+          Css.set(clone, 'background-color', 'blue');
+          return {
+            element: clone,
+            x: 0,
+            y: 0
+          };
+        },
+        canDrag: (_component, _target) =>
+          true,
+        onDragstart: (_component, _simulatedEvent) => {
+        },
+        onDragover: (_component, _simulatedEvent) => {
+        },
+        onDragend: (_component, _simulatedEvent) => {
+        }
+      })
+    ])
+  });
+  HtmlDisplay.section(
+    gui,
+    'Drag the gray boxes into the drop zones and check console log for messages.',
+    Container.sketch({
+      components: [
+        Container.sketch({
+          components: [
+            createDropZone('copy'),
+            createDropZone('link'),
+            createDropZone('move')
+          ]
+        }),
+        Container.sketch({
+          dom: {
+            styles: {
+              color: 'white'
+            }
+          },
+          components: [
+            createDraggable('copy', 'custom data for copy'),
+            createDraggable('link', 'custom data for link'),
+            createDraggable('move', 'custom data for move'),
+            createDraggable('all', 'custom data for all'),
+            createDraggable('copyLink', 'custom data for copyLink'),
+            createDraggable('linkMove', 'custom data for linkMove'),
+            createDraggable('copyMove', 'custom data for copyMove')
+          ]
+        })
+      ]
+    })
+  );
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/ForeignGuiDemo.ts
@@ -0,0 +1,115 @@
+import { Optional, Optionals } from '@ephox/katamari';
+import { PlatformDetection } from '@ephox/sand';
+import { Css, DomEvent, EventArgs, Height, Insert, InsertAll, SelectorFind, SugarElement, SugarElements, SugarNode, Width } from '@ephox/sugar';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { Dragging } from 'ephox/alloy/api/behaviour/Dragging';
+import { Pinching } from 'ephox/alloy/api/behaviour/Pinching';
+import { Toggling } from 'ephox/alloy/api/behaviour/Toggling';
+import * as AlloyEvents from 'ephox/alloy/api/events/AlloyEvents';
+import * as NativeEvents from 'ephox/alloy/api/events/NativeEvents';
+import * as SystemEvents from 'ephox/alloy/api/events/SystemEvents';
+import * as ForeignGui from 'ephox/alloy/api/system/ForeignGui';
+import * as Frames from './frames/Frames';
+const resize = (element: SugarElement<HTMLElement>, changeX: number, changeY: number): void => {
+  const heading = document.querySelector('h2');
+  if (heading === null) {
+    throw new Error('heading not found');
+  } else {
+    heading.innerHTML = 'resizing';
+    const width = Css.getRaw(element, 'width').map((w) => parseInt(w, 10)).getOrThunk(() => Width.get(element));
+    const height = Css.getRaw(element, 'height').map((h) => parseInt(h, 10)).getOrThunk(() => Height.get(element));
+    Css.set(element, 'width', (width + changeX) + 'px');
+    Css.set(element, 'height', (height + changeY) + 'px');
+  }
+};
+export default (): void => {
+  const ephoxUi = SelectorFind.first('#ephox-ui').getOrDie();
+  const platform = PlatformDetection.detect();
+  const onNode = (name: string) => (elem: SugarElement<Node>): Optional<SugarElement<Node>> =>
+    Optionals.someIf(SugarNode.name(elem) === name, elem);
+  const contents = '<div><strong>drag1</strong> and <code>click1</code> and <strong>drag2</strong> ' +
+    'and <code>click2</code> and <img style="width: 140px; height: 130px;" /></div>';
+  const frame = SugarElement.fromTag('iframe');
+  Css.set(frame, 'min-width', '80%');
+  const onload = DomEvent.bind(frame, 'load', () => {
+    onload.unbind();
+    Frames.write(
+      frame,
+      '<html>' +
+        '<head>' +
+          '<style>' +
+            '.selected { color: white; background: black; }' +
+            '* { font-size: bigger; }\n' +
+            'span { padding: 30px; display: inline-block; border: 1px solid blue; }' +
+          '</style>' +
+        '</head>' +
+        '<body>' +
+          contents +
+        '</body>' +
+      '</html>'
+    );
+    const root = SugarElement.fromDom(Frames.readDoc(frame).dom.documentElement);
+    addAsForeign(root);
+  });
+  const inlineContainer = SugarElement.fromHtml<HTMLDivElement>(
+    contents
+  );
+  const addAsForeign = (root: SugarElement<HTMLElement>) => {
+    const connection = ForeignGui.engage({
+      root,
+      dispatchers: [
+        {
+          getTarget: onNode('code'),
+          alloyConfig: {
+            behaviours: Behaviour.derive([
+              Toggling.config({
+                toggleClass: 'selected'
+              })
+            ]),
+            events: AlloyEvents.derive([
+              AlloyEvents.run<EventArgs>(NativeEvents.click(), (component, simulatedEvent) => {
+                connection.unproxy(component);
+                connection.dispatchTo(SystemEvents.execute(), simulatedEvent.event);
+              })
+            ])
+          }
+        },
+        {
+          getTarget: onNode('strong'),
+          alloyConfig: {
+            behaviours: Behaviour.derive([
+              Dragging.config({
+                mode: platform.deviceType.isTouch() ? 'touch' : 'mouse',
+                blockerClass: 'blocker'
+              })
+            ])
+          }
+        },
+        {
+          getTarget: onNode('img'),
+          alloyConfig: {
+            behaviours: Behaviour.derive([
+              Pinching.config({
+                onPinch: resize,
+                onPunch: resize
+              })
+            ])
+          }
+        }
+      ]
+    });
+    return connection;
+  };
+  InsertAll.append(ephoxUi,
+    SugarElements.fromHtml(
+      '<p>This is a demo for alloy delegation. The iframe and the div editor are not alloy components' +
+        ' but they need to exhibit alloy behaviours. This is done through ForeignGui</p>' +
+      '<p>Drag the <strong>dragx</strong> elements and click on the <code>clickx</code> elements</p>'
+    )
+  );
+  Insert.append(ephoxUi, SugarElement.fromHtml('<h3>IFrame Editor</h3>'));
+  Insert.append(ephoxUi, frame);
+  Insert.append(ephoxUi, SugarElement.fromHtml('<h3>Div Editor</h3>'));
+  Insert.append(ephoxUi, inlineContainer);
+  addAsForeign(inlineContainer);
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/InlinesDemo.ts
@@ -0,0 +1,233 @@
+import { Arr, Fun, Optional, Result } from '@ephox/katamari';
+import { Class, EventArgs, SugarElement, Value } from '@ephox/sugar';
+import * as AddEventsBehaviour from 'ephox/alloy/api/behaviour/AddEventsBehaviour';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { Keying } from 'ephox/alloy/api/behaviour/Keying';
+import { Positioning } from 'ephox/alloy/api/behaviour/Positioning';
+import { Tooltipping } from 'ephox/alloy/api/behaviour/Tooltipping';
+import { LazySink } from 'ephox/alloy/api/component/CommonTypes';
+import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
+import * as AlloyEvents from 'ephox/alloy/api/events/AlloyEvents';
+import * as NativeEvents from 'ephox/alloy/api/events/NativeEvents';
+import * as Attachment from 'ephox/alloy/api/system/Attachment';
+import * as Gui from 'ephox/alloy/api/system/Gui';
+import { Button } from 'ephox/alloy/api/ui/Button';
+import { Container } from 'ephox/alloy/api/ui/Container';
+import { InlineView } from 'ephox/alloy/api/ui/InlineView';
+import { Input } from 'ephox/alloy/api/ui/Input';
+import { tieredMenu as TieredMenu } from 'ephox/alloy/api/ui/TieredMenu';
+import * as DemoSink from 'ephox/alloy/demo/DemoSink';
+import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
+import { AnchorSpec, SelectionAnchorSpec, SubmenuAnchorSpec } from 'ephox/alloy/positioning/mode/Anchoring';
+import * as DemoRenders from './forms/DemoRenders';
+/* eslint-disable no-console */
+export default (): void => {
+  const gui = Gui.create();
+  const body = SugarElement.fromDom(document.body);
+  Class.add(gui.element, 'gui-root-demo-container');
+  Attachment.attachSystem(body, gui);
+  const sink = DemoSink.make();
+  const lazySink: LazySink = (_) => Result.value(sink);
+  const inlineComp = GuiFactory.build(
+    InlineView.sketch({
+      uid: 'inline-comp',
+      dom: {
+        tag: 'div'
+      },
+      lazySink: Fun.constant(Result.value(sink))
+    })
+  );
+  const makeItem = (v: string, t: string, c: string): DemoRenders.DemoItem => ({
+    type: 'item',
+    data: {
+      value: v,
+      meta: {
+        'text': t,
+        'item-class': c
+      }
+    },
+    itemBehaviours: Behaviour.derive([
+      Tooltipping.config({
+        lazySink,
+        tooltipDom: {
+          tag: 'div',
+          styles: {
+            background: '#cadbee',
+            padding: '3em'
+          }
+        },
+        tooltipComponents: [
+          GuiFactory.text(t)
+        ],
+        anchor: (comp) => ({
+          type: 'submenu',
+          item: comp
+        }),
+        onShow: (component, _tooltip) => {
+          setTimeout(() => {
+            Tooltipping.setComponents(component, [
+              {
+                dom: {
+                  tag: 'div',
+                  innerHtml: 'This lazy loaded'
+                }
+              }
+            ]);
+          }, 2000);
+        },
+        onHide: (_component, _tooltip) => {
+        }
+      })
+    ])
+  });
+  const inlineMenu = TieredMenu.sketch({
+    dom: {
+      tag: 'div'
+    },
+    onEscape: () => {
+      console.log('inline.menu.escape');
+      return Optional.some<boolean>(true);
+    },
+    onExecute: () => {
+      console.log('inline.menu.execute');
+      return Optional.some<boolean>(true);
+    },
+    onOpenMenu: (_sandbox, _menu) => {
+    },
+    onOpenSubmenu: (sandbox, item, submenu) => {
+      const sink = lazySink(sandbox).getOrDie();
+      Positioning.position(sink, submenu, {
+        anchor: {
+          type: 'submenu',
+          item
+        }
+      });
+    },
+    data: {
+      expansions: {
+        gamma: 'gamma-menu'
+      },
+      menus: {
+        'dog': DemoRenders.menu({
+          value: 'dog',
+          items: Arr.map([
+            makeItem('alpha', 'Alpha', 'alpha'),
+            makeItem('beta', 'Beta', 'beta'),
+            makeItem('gamma', 'Gamma', 'gamma'),
+            makeItem('delta', 'Delta', 'delta')
+          ], DemoRenders.item),
+          textkey: 'Dog'
+        }),
+        'gamma-menu': DemoRenders.menu({
+          value: 'gamma-menu',
+          items: Arr.map([
+            makeItem('gamma-1', 'Gamma-1', 'gamma-1'),
+            makeItem('gamma-2', 'Gamma-2', 'gamma-2')
+          ], DemoRenders.item),
+          textkey: 'gamma-menu'
+        })
+      },
+      primary: 'dog'
+    },
+    markers: DemoRenders.tieredMarkers()
+  });
+  gui.add(sink);
+  HtmlDisplay.section(
+    gui,
+    'This inline menu component is a context menu. Right click inside the yellow area',
+    Container.sketch({
+      dom: {
+        styles: {
+          background: '#ffff33',
+          height: '100px'
+        }
+      },
+      events: AlloyEvents.derive([
+        AlloyEvents.run<EventArgs<MouseEvent>>(NativeEvents.contextmenu(), (component, simulatedEvent) => {
+          simulatedEvent.event.kill();
+          InlineView.showAt(inlineComp, inlineMenu, {
+            anchor: {
+              type: 'makeshift',
+              x: simulatedEvent.event.x,
+              y: simulatedEvent.event.y
+            }
+          });
+        })
+      ])
+    })
+  );
+  HtmlDisplay.section(
+    gui,
+    'This inline toolbar shows up when you click in the second input field. Note, ' +
+    'how when you focus an empty input, it will attach at the end of the field, and ' +
+    'when you focus a non-empty input, it will attach below',
+    Container.sketch({
+      containerBehaviours: Behaviour.derive([
+        Keying.config({
+          mode: 'cyclic',
+          selector: 'input'
+        })
+      ]),
+      components: [
+        Input.sketch({
+          inputStyles: { 'display': 'block', 'margin-bottom': '50px' }
+        }),
+        Input.sketch({
+          inputStyles: { display: 'block' },
+          inputBehaviours: Behaviour.derive([
+            AddEventsBehaviour.config('adhoc-show-popup', [
+              AlloyEvents.run(NativeEvents.focusin(), (input) => {
+                const emptyAnchor: SubmenuAnchorSpec = {
+                  type: 'submenu',
+                  item: input
+                };
+                const nonEmptyAnchor: SelectionAnchorSpec = {
+                  type: 'selection',
+                  root: gui.element
+                };
+                const anchor: AnchorSpec = Value.get(input.element).length > 0 ? nonEmptyAnchor : emptyAnchor;
+                InlineView.showAt(inlineComp, Container.sketch({
+                  containerBehaviours: Behaviour.derive([
+                    Keying.config({
+                      mode: 'flow',
+                      selector: 'button'
+                    })
+                  ]),
+                  components: [
+                    Button.sketch({
+                      dom: {
+                        tag: 'button',
+                        innerHtml: 'B'
+                      },
+                      action: () => {
+                        console.log('inline bold');
+                      }
+                    }),
+                    Button.sketch({
+                      dom: {
+                        tag: 'button',
+                        innerHtml: 'I'
+                      },
+                      action: () => {
+                        console.log('inline italic');
+                      }
+                    }),
+                    Button.sketch({
+                      dom: {
+                        tag: 'button',
+                        innerHtml: 'U'
+                      },
+                      action: () => {
+                        console.log('inline underline');
+                      }
+                    })
+                  ]
+                }), { anchor });
+              })
+            ])
+          ])
+        })
+      ]
+    })
+  );
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/PinchingDemo.ts
@@ -0,0 +1,39 @@
+import { Css, Height, SelectorFind, SugarElement, Width } from '@ephox/sugar';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { Pinching } from 'ephox/alloy/api/behaviour/Pinching';
+import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
+import * as Attachment from 'ephox/alloy/api/system/Attachment';
+import * as Gui from 'ephox/alloy/api/system/Gui';
+export default (): void => {
+  const ephoxUi = SelectorFind.first('#ephox-ui').getOrDie();
+  const resize = (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => {
+    const width = Css.getRaw(element, 'width').map((w) => parseInt(w, 10)).getOrThunk(() => Width.get(element));
+    const height = Css.getRaw(element, 'height').map((h) => parseInt(h, 10)).getOrThunk(() => Height.get(element));
+    Css.set(element, 'width', (width + changeX) + 'px');
+    Css.set(element, 'height', (height + changeY) + 'px');
+  };
+  const box = GuiFactory.build({
+    dom: {
+      tag: 'div',
+      classes: [ 'demo-pinch-box' ],
+      styles: {
+        width: '200px',
+        height: '200px',
+        background: 'black'
+      }
+    },
+    behaviours: Behaviour.derive([
+      Pinching.config({
+        onPinch: (span, changeX, changeY) => {
+          resize(span, changeX, changeY);
+        },
+        onPunch: (span, changeX, changeY) => {
+          resize(span, changeX, changeY);
+        }
+      })
+    ])
+  });
+  const gui = Gui.create();
+  gui.add(box);
+  Attachment.attachSystem(ephoxUi, gui);
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/SliderDemo.ts
@@ -0,0 +1,222 @@
+import { Fun } from '@ephox/katamari';
+import { PlatformDetection } from '@ephox/sand';
+import { Class, Css, DomEvent, Insert, SugarElement } from '@ephox/sugar';
+import * as Behaviour from 'ephox/alloy/api/behaviour/Behaviour';
+import { Keying } from 'ephox/alloy/api/behaviour/Keying';
+import { Replacing } from 'ephox/alloy/api/behaviour/Replacing';
+import { Toggling } from 'ephox/alloy/api/behaviour/Toggling';
+import { AlloyComponent } from 'ephox/alloy/api/component/ComponentApi';
+import * as GuiFactory from 'ephox/alloy/api/component/GuiFactory';
+import * as Gui from 'ephox/alloy/api/system/Gui';
+import { Container } from 'ephox/alloy/api/ui/Container';
+import { Slider } from 'ephox/alloy/api/ui/Slider';
+import * as HtmlDisplay from 'ephox/alloy/demo/HtmlDisplay';
+import { SliderValue, SliderValueXY } from 'ephox/alloy/ui/types/SliderTypes';
+export default (): void => {
+  const gui = Gui.create();
+  const body = SugarElement.fromDom(document.body);
+  Class.add(gui.element, 'gui-root-demo-container');
+  Insert.append(body, gui.element);
+  const slider1 = HtmlDisplay.section(
+    gui,
+    'This is a basic slider from [20, 100] with snapping to grid at 10',
+    Slider.sketch({
+      dom: {
+        tag: 'div'
+      },
+      model: {
+        mode: 'x',
+        minX: 20,
+        maxX: 100,
+        getInitialValue: Fun.constant(80)
+      },
+      stepSize: 10,
+      snapToGrid: true,
+      components: [
+        Slider.parts.spectrum({
+          dom: {
+            tag: 'div',
+            styles: {
+              height: '20px',
+              background: 'blue',
+              outline: '4px solid green'
+            }
+          }
+        }),
+        Slider.parts.thumb({
+          dom: {
+            tag: 'div',
+            styles: {
+              'height': '30px',
+              'width': '10px',
+              'top': '0px',
+              'background': 'black',
+              'padding-top': '-5px'
+            }
+          }
+        })
+      ]
+    })
+  );
+  HtmlDisplay.section(
+    gui,
+    'This is a basic slider with two snapping regions [35] and [75]. The minimum value is 0',
+    Slider.sketch({
+      dom: { tag: 'div', styles: { 'margin-bottom': '40px' }},
+      model: {
+        mode: 'y',
+        getInitialValue: Fun.constant(35)
+      },
+      stepSize: 40,
+      snapStart: 35,
+      snapToGrid: true,
+      onDragStart: (_, thumb) => {
+        Toggling.on(thumb);
+      },
+      onDragEnd: (_, thumb) => {
+        Toggling.off(thumb);
+      },
+      onChange: (_slider, thumb, value: SliderValue) => {
+        Replacing.set(thumb, [
+          GuiFactory.text(value.toString())
+        ]);
+      },
+      onInit: (_slider, thumb, _spectrum, value: SliderValue) => {
+        Replacing.set(thumb, [
+          GuiFactory.text(value.toString())
+        ]);
+      },
+      components: [
+        Slider.parts.spectrum({
+          dom: {
+            tag: 'div',
+            styles: {
+              width: '20px', background: 'green', height: '300px'
+            }
+          }
+        }),
+        Slider.parts.thumb({
+          dom: {
+            tag: 'div',
+            styles: {
+              'border-radius': '20px',
+              'width': '25px',
+              'height': '25px',
+              'border': '1px solid green',
+              'background': 'transparent',
+              'display': 'flex', 'align-items': 'center', 'justify-content': 'center'
+            }
+          },
+          behaviours: Behaviour.derive([
+            Replacing.config({}),
+            Toggling.config({
+              toggleClass: 'thumb-pressed'
+            })
+          ])
+        })
+      ]
+    })
+  );
+  const getColor = (hue: number) => {
+    if (hue < 0) {
+      return 'black';
+    } else if (hue > 360) {
+      return 'white';
+    } else {
+      return 'hsl(' + hue + ', 100%, 50%)';
+    }
+  };
+  const setColor = (thumb: AlloyComponent, hue: number) => {
+    Css.set(thumb.element, 'background', getColor(hue));
+  };
+  HtmlDisplay.section(
+    gui,
+    'This is a basic color slider with a sliding thumb and edges',
+    Slider.sketch({
+      dom: {
+        tag: 'div'
+      },
+      model: {
+        mode: 'xy',
+        minX: 0,
+        maxX: 360,
+        minY: 0,
+        maxY: 360,
+        getInitialValue: Fun.constant({ x: 120, y: 120 })
+      },
+      stepSize: 10,
+      onChange: (_slider, thumb, value: SliderValue) => {
+        setColor(thumb, (value as SliderValueXY).x);
+      },
+      onInit: (_slider, thumb, _spectrum, value: SliderValue) => {
+        setColor(thumb, (value as SliderValueXY).x);
+      },
+      components: [
+        Container.sketch({
+          dom: {
+            tag: 'div',
+            styles: {
+              display: 'flex',
+              width: '540px',
+              border: '1px solid black'
+            }
+          },
+          components: [
+            Slider.parts['left-edge']({
+              dom: {
+                tag: 'div',
+                styles: {
+                  width: '20px',
+                  height: '500px',
+                  background: 'black'
+                }
+              }
+            }),
+            Slider.parts.spectrum({
+              dom: {
+                tag: 'div',
+                styles: {
+                  height: '500px',
+                  background: 'linear-gradient(to right, hsl(0, 100%, 50%) 0%, hsl(60, 100%, 50%) 17%, hsl(120, 100%, 50%) 33%, hsl(180, 100%, 50%) 50%, hsl(240, 100%, 50%) 67%, hsl(300, 100%, 50%) 83%, hsl(360, 100%, 50%) 100%)',
+                  width: '500px'
+                }
+              }
+            }),
+            Slider.parts['right-edge']({
+              dom: {
+                tag: 'div',
+                styles: {
+                  width: '20px',
+                  height: '500px',
+                  background: 'white'
+                }
+              }
+            })
+          ]
+        }),
+        Slider.parts.thumb({
+          dom: {
+            tag: 'div',
+            classes: [ 'demo-sliding-thumb' ],
+            styles: {
+              'height': '30px',
+              'width': '10px',
+              'top': '0px',
+              'background': 'black',
+              'padding-top': '-5px',
+              'border': '1px solid black',
+              'outline': '1px solid white'
+            }
+          }
+        })
+      ]
+    })
+  );
+  const platform = PlatformDetection.detect();
+  const isTouch = platform.deviceType.isTouch();
+  DomEvent.bind(body, 'click', () => {
+    if (!isTouch) {
+      Keying.focusIn(slider1);
+    }
+  });
+};

--- a//dev/null
+++ b/modules/alloy/src/demo/ts/ephox/alloy/demo/frames/Frames.ts
@@ -0,0 +1,34 @@
+import { Optional } from '@ephox/katamari';
+import { SugarBody, SugarElement, Traverse } from '@ephox/sugar';
+/* eslint-disable no-console */
+const iframeDoc = (element: SugarElement<HTMLIFrameElement>): Optional<SugarElement<Document>> => {
+  const dom = element.dom;
+  try {
+    const idoc = dom.contentWindow ? dom.contentWindow.document : dom.contentDocument;
+    return idoc !== undefined && idoc !== null ? Optional.some(SugarElement.fromDom(idoc)) : Optional.none();
+  } catch (err) {
+    console.log('Error reading iframe: ', dom);
+    console.log('Error was: ' + err);
+    return Optional.none();
+  }
+};
+const readDoc = (element: SugarElement<HTMLIFrameElement>): SugarElement<Document> => {
+  const optDoc = iframeDoc(element);
+  return optDoc.getOrThunk(() =>
+    Traverse.owner(element)
+  );
+};
+const write = (element: SugarElement<HTMLIFrameElement>, content: string): void => {
+  if (!SugarBody.inBody(element)) {
+    throw new Error('Internal error: attempted to write to an iframe that is not n the DOM');
+  }
+  const doc = readDoc(element);
+  const dom = doc.dom;
+  dom.open();
+  dom.writeln(content);
+  dom.close();
+};
+export {
+  write,
+  readDoc
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/ComponentStructure.ts
@@ -0,0 +1,15 @@
+import { Fun } from '@ephox/katamari';
+import { Compare, PredicateExists, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AriaControls from '../aria/AriaControls';
+import { AnchorSpec } from '../positioning/mode/Anchoring';
+const isAriaPartOf = (component: AlloyComponent, queryElem: SugarElement<Node>): boolean =>
+  AriaControls.find(queryElem).exists((owner) => isPartOf(component, owner));
+const isPartOf = (component: AlloyComponent, queryElem: SugarElement<Node>): boolean =>
+  PredicateExists.closest(queryElem, (el) => Compare.eq(el, component.element), Fun.never) || isAriaPartOf(component, queryElem);
+const isPartOfAnchor = (anchor: AnchorSpec, queryElem: SugarElement<Node>): boolean =>
+  anchor.type === 'hotspot' && isPartOf(anchor.hotspot, queryElem);
+export {
+  isPartOf,
+  isPartOfAnchor
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/Descend.ts
@@ -0,0 +1,25 @@
+import { SugarElement, SugarNode, SugarText, Traverse } from '@ephox/sugar';
+export interface ElementAndOffset<T extends Node> {
+  readonly element: SugarElement<T>;
+  readonly offset: number;
+}
+const point = <T extends Node> (element: SugarElement<T>, offset: number): ElementAndOffset<T> => ({
+  element,
+  offset
+});
+const descendOnce = (element: SugarElement<Node>, offset: number): ElementAndOffset<Node> => {
+  const children = Traverse.children(element);
+  if (children.length === 0) {
+    return point(element, offset);
+  } else if (offset < children.length) {
+    return point(children[offset], 0);
+  } else {
+    const last = children[children.length - 1];
+    const len = SugarNode.isText(last) ? SugarText.get(last).length : Traverse.children(last).length;
+    return point(last, len);
+  }
+};
+export {
+  point,
+  descendOnce
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/DomState.ts
@@ -0,0 +1,13 @@
+import { Id, Obj } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+const attrName = Id.generate('dom-data');
+const getOrCreate = <A>(element: SugarElement<Node>, f: () => A): A => {
+  const elem = element.dom as any;
+  const existing = Obj.get<Record<string, A>, string>(elem, attrName);
+  const data = existing.getOrThunk(f);
+  elem[attrName] = data;
+  return data;
+};
+export {
+  getOrCreate
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/EditableFields.ts
@@ -0,0 +1,8 @@
+import { Attribute, SugarElement, SugarNode } from '@ephox/sugar';
+const inside = (target: SugarElement<Node>): boolean => (
+  (SugarNode.isTag('input')(target) && Attribute.get(target, 'type') !== 'radio') ||
+  SugarNode.isTag('textarea')(target)
+);
+export {
+  inside
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/ElementFromPoint.ts
@@ -0,0 +1,18 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement, SugarNode, Traverse } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+const insideComponent = (component: AlloyComponent, x: number, y: number): Optional<SugarElement<Element>> => {
+  const isInside = (node: SugarElement<Element>) => component.element.dom.contains(node.dom);
+  const hasValidRect = (node: SugarElement<Element>): boolean => {
+    const elem = SugarNode.isText(node) ? Traverse.parentElement(node) : Optional.some(node);
+    return elem.exists((e) => {
+      const rect = e.dom.getBoundingClientRect();
+      return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
+    });
+  };
+  const doc = Traverse.owner(component.element);
+  return SugarElement.fromPoint(doc, x, y).filter(isInside).filter(hasValidRect);
+};
+export {
+  insideComponent
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/alien/OffsetOrigin.ts
@@ -0,0 +1,25 @@
+import { Optional, Optionals } from '@ephox/katamari';
+import { Css, Insert, Remove, SugarElement, SugarLocation, SugarPosition, Traverse } from '@ephox/sugar';
+const getOffsetParent = (element: SugarElement<HTMLElement>): Optional<SugarElement<HTMLElement>> => {
+  const isFixed = Optionals.is(Css.getRaw(element, 'position'), 'fixed');
+  const offsetParent = isFixed ? Optional.none<SugarElement<HTMLElement>>() : Traverse.offsetParent(element);
+  return offsetParent.orThunk(() => {
+    const marker = SugarElement.fromTag('span');
+    return Traverse.parent(element).bind((parent) => {
+      Insert.append(parent, marker);
+      const offsetParent = Traverse.offsetParent(marker);
+      Remove.remove(marker);
+      return offsetParent;
+    });
+  });
+};
+/*
+ * This allows the absolute coordinates to be obtained by adding the
+ * origin to the offset coordinates and not needing to know scroll.
+ */
+const getOrigin = (element: SugarElement<HTMLElement>): SugarPosition =>
+  getOffsetParent(element).map(SugarLocation.absolute).getOrThunk(() => SugarPosition(0, 0));
+export {
+  getOrigin,
+  getOffsetParent
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/behaviour/Replacing.ts
@@ -0,0 +1,14 @@
+import { FieldSchema } from '@ephox/boulder';
+import * as ReplaceApis from '../../behaviour/replacing/ReplaceApis';
+import { ReplacingBehaviour } from '../../behaviour/replacing/ReplacingTypes';
+import * as Behaviour from './Behaviour';
+const Replacing: ReplacingBehaviour = Behaviour.create({
+  fields: [
+    FieldSchema.defaultedBoolean('reuseDom', true)
+  ],
+  name: 'replacing',
+  apis: ReplaceApis
+});
+export {
+  Replacing
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/component/Component.ts
@@ -0,0 +1,96 @@
+import { StructureSchema } from '@ephox/boulder';
+import { Arr, Cell, Optional, Type } from '@ephox/katamari';
+import { SugarElement, Traverse } from '@ephox/sugar';
+import * as BehaviourBlob from '../../behaviour/common/BehaviourBlob';
+import { BehaviourState } from '../../behaviour/common/BehaviourState';
+import * as ComponentDom from '../../construct/ComponentDom';
+import * as ComponentEvents from '../../construct/ComponentEvents';
+import * as CustomDefinition from '../../construct/CustomDefinition';
+import { DomDefinitionDetail } from '../../dom/DomDefinition';
+import * as DomModification from '../../dom/DomModification';
+import * as DomRender from '../../dom/DomRender';
+import { UncurriedHandler } from '../../events/EventRegistry';
+import { AlloyBehaviour } from '../behaviour/Behaviour';
+import { NoContextApi, singleton } from '../system/NoContextApi';
+import { AlloySystemApi } from '../system/SystemApi';
+import * as CompBehaviours from './CompBehaviours';
+import { AlloyComponent } from './ComponentApi';
+import { ComponentDetail } from './SpecTypes';
+const getDomDefinition = (
+  info: CustomDefinition.CustomDetail<any>,
+  bList: Array<AlloyBehaviour<any, any>>,
+  bData: Record<string, () => Optional<BehaviourBlob.BehaviourConfigAndState<any, BehaviourState>>>
+): DomDefinitionDetail => {
+  const definition = CustomDefinition.toDefinition(info);
+  const infoModification = CustomDefinition.toModification(info);
+  const baseModification = {
+    'alloy.base.modification': infoModification
+  };
+  const modification = bList.length > 0 ? ComponentDom.combine(bData, baseModification, bList, definition) : infoModification;
+  return DomModification.merge(definition, modification);
+};
+const getEvents = (
+  info: CustomDefinition.CustomDetail<any>,
+  bList: Array<AlloyBehaviour<any, any>>,
+  bData: Record<string, () => Optional<BehaviourBlob.BehaviourConfigAndState<any, BehaviourState>>>
+): Record<string, UncurriedHandler> => {
+  const baseEvents = {
+    'alloy.base.behaviour': CustomDefinition.toEvents(info)
+  };
+  return ComponentEvents.combine(bData, info.eventOrder, bList, baseEvents).getOrDie();
+};
+const build = (spec: ComponentDetail, obsoleted: Optional<SugarElement<Node>>): AlloyComponent => {
+  const getMe = () => me;
+  const systemApi = Cell(singleton);
+  const info: CustomDefinition.CustomDetail<any> = StructureSchema.getOrDie(CustomDefinition.toInfo(spec));
+  const bBlob = CompBehaviours.generate(spec);
+  const bList = BehaviourBlob.getBehaviours(bBlob);
+  const bData = BehaviourBlob.getData(bBlob);
+  const modDefinition = getDomDefinition(info, bList, bData);
+  const item = DomRender.renderToDom(modDefinition, obsoleted);
+  const events = getEvents(info, bList, bData);
+  const subcomponents = Cell(info.components);
+  const connect = (newApi: AlloySystemApi): void => {
+    systemApi.set(newApi);
+  };
+  const disconnect = (): void => {
+    systemApi.set(NoContextApi(getMe));
+  };
+  const syncComponents = (): void => {
+    const children = Traverse.children(item);
+    const subs = Arr.bind(children, (child) => systemApi.get().getByDom(child).fold(
+      () => [ ],
+      Arr.pure
+    ));
+    subcomponents.set(subs);
+  };
+  const config = (behaviour: AlloyBehaviour<any, any>): Optional<BehaviourBlob.BehaviourConfigAndState<any, any>> => {
+    const b = bData;
+    const f = Type.isFunction(b[behaviour.name()]) ? b[behaviour.name()] : () => {
+      throw new Error('Could not find ' + behaviour.name() + ' in ' + JSON.stringify(spec, null, 2));
+    };
+    return f();
+  };
+  const hasConfigured = (behaviour: AlloyBehaviour<any, any>): boolean => Type.isFunction(bData[behaviour.name()]);
+  const getApis = <A>(): A => info.apis;
+  const readState = (behaviourName: string): any => bData[behaviourName]().map((b) => b.state.readState()).getOr('not enabled');
+  const me: AlloyComponent = {
+    uid: spec.uid,
+    getSystem: systemApi.get,
+    config,
+    hasConfigured,
+    spec,
+    readState,
+    getApis,
+    connect,
+    disconnect,
+    element: item,
+    syncComponents,
+    components: subcomponents.get,
+    events
+  };
+  return me;
+};
+export {
+  build
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/component/ComponentApi.ts
@@ -0,0 +1,24 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { BehaviourConfigAndState } from '../../behaviour/common/BehaviourBlob';
+import { UncurriedHandler } from '../../events/EventRegistry';
+import { AlloyBehaviour } from '../behaviour/Behaviour';
+import { AlloySystemApi } from '../system/SystemApi';
+type ReadonlyRecord<K extends keyof any, T> = {
+  readonly [P in K]: T;
+};
+export interface AlloyComponent {
+  readonly uid: string;
+  readonly getSystem: () => AlloySystemApi;
+  readonly config: (behaviour: AlloyBehaviour<any, any>) => Optional<BehaviourConfigAndState<any, any>>;
+  readonly hasConfigured: (behaviour: AlloyBehaviour<any, any>) => boolean;
+  readonly spec: any;
+  readonly readState: (behaviourName: string) => any;
+  readonly connect: (newApi: AlloySystemApi) => void;
+  readonly disconnect: () => void;
+  readonly getApis: <A>() => A;
+  readonly element: SugarElement<any>;
+  readonly syncComponents: () => void;
+  readonly components: () => AlloyComponent[];
+  readonly events: ReadonlyRecord<string, UncurriedHandler>;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/component/ComponentUtil.ts
@@ -0,0 +1,9 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from './ComponentApi';
+const toElem = (component: AlloyComponent): SugarElement<any> => component.element;
+const getByUid = (component: AlloyComponent, uid: string): Optional<AlloyComponent> => component.getSystem().getByUid(uid).toOptional();
+export {
+  toElem,
+  getByUid
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/component/GuiFactory.ts
@@ -0,0 +1,91 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Arr, Cell, Fun, Obj, Optional, Result } from '@ephox/katamari';
+import { SugarElement, Traverse } from '@ephox/sugar';
+import * as DefaultEvents from '../../events/DefaultEvents';
+import * as Tagger from '../../registry/Tagger';
+import * as CustomSpec from '../../spec/CustomSpec';
+import { NoContextApi } from '../system/NoContextApi';
+import { AlloySystemApi } from '../system/SystemApi';
+import * as GuiTypes from '../ui/GuiTypes';
+import * as Component from './Component';
+import { AlloyComponent } from './ComponentApi';
+import { AlloySpec, PremadeSpec, SimpleOrSketchSpec, SketchSpec } from './SpecTypes';
+const buildSubcomponents = (spec: SimpleOrSketchSpec, obsoleted: Optional<SugarElement<Node>>): AlloyComponent[] => {
+  const components = Obj.get(spec, 'components').getOr([ ]);
+  return obsoleted.fold(
+    () => Arr.map(components, build),
+    (obs) => Arr.map(components, (c, i) => {
+      return buildOrPatch(c, Traverse.child(obs, i));
+    })
+  );
+};
+const buildFromSpec = (userSpec: SketchSpec, obsoleted: Optional<SugarElement<Node>>): Result<AlloyComponent, string> => {
+  const { events: specEvents, ...spec }: SketchSpec = CustomSpec.make(userSpec);
+  const components: AlloyComponent[] = buildSubcomponents(spec, obsoleted);
+  const completeSpec = {
+    ...spec,
+    events: { ...DefaultEvents, ...specEvents },
+    components
+  };
+  return Result.value(
+    Component.build(completeSpec, obsoleted)
+  );
+};
+const text = (textContent: string): PremadeSpec => {
+  const element = SugarElement.fromText(textContent);
+  return external({
+    element
+  });
+};
+export interface ExternalElement { uid?: string; element: SugarElement<Node> }
+const external = (spec: ExternalElement): PremadeSpec => {
+  const extSpec: { uid: Optional<string>; element: SugarElement<Node> } = StructureSchema.asRawOrDie('external.component', StructureSchema.objOfOnly([
+    FieldSchema.required('element'),
+    FieldSchema.option('uid')
+  ]), spec);
+  const systemApi = Cell(NoContextApi());
+  const connect = (newApi: AlloySystemApi) => {
+    systemApi.set(newApi);
+  };
+  const disconnect = () => {
+    systemApi.set(NoContextApi(() => me));
+  };
+  const uid = extSpec.uid.getOrThunk(() => Tagger.generate('external'));
+  Tagger.writeOnly(extSpec.element, uid);
+  const me: AlloyComponent = {
+    uid,
+    getSystem: systemApi.get,
+    config: Optional.none,
+    hasConfigured: Fun.never,
+    connect,
+    disconnect,
+    getApis: <A>(): A => ({ } as any),
+    element: extSpec.element,
+    spec,
+    readState: Fun.constant('No state'),
+    syncComponents: Fun.noop,
+    components: Fun.constant([ ]),
+    events: { }
+  };
+  return GuiTypes.premade(me);
+};
+const uids = Tagger.generate;
+const isSketchSpec = (spec: AlloySpec): spec is SketchSpec =>
+  Obj.has(spec as SimpleOrSketchSpec, 'uid');
+const buildOrPatch = (spec: AlloySpec, obsoleted: Optional<SugarElement<Node>>): AlloyComponent => GuiTypes.getPremade(spec).getOrThunk(() => {
+  const userSpecWithUid = isSketchSpec(spec) ? spec : {
+    uid: uids(''),
+    ...spec
+  } as SketchSpec;
+  return buildFromSpec(userSpecWithUid, obsoleted).getOrDie();
+});
+const build = (spec: AlloySpec): AlloyComponent =>
+  buildOrPatch(spec, Optional.none());
+const premade = GuiTypes.premade;
+export {
+  build,
+  buildOrPatch,
+  premade,
+  external,
+  text
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/events/AlloyTriggers.ts
@@ -0,0 +1,38 @@
+import { SugarElement } from '@ephox/sugar';
+import { EventFormat, SimulatedEvent } from '../../events/SimulatedEvent';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as SystemEvents from './SystemEvents';
+const emit = (component: AlloyComponent, event: string): void => {
+  dispatchWith(component, component.element, event, { });
+};
+const emitWith = (component: AlloyComponent, event: string, properties: Record<string, any>): void => {
+  dispatchWith(component, component.element, event, properties);
+};
+const emitExecute = (component: AlloyComponent): void => {
+  emit(component, SystemEvents.execute());
+};
+const dispatch = (component: AlloyComponent, target: SugarElement<Node>, event: string): void => {
+  dispatchWith(component, target, event, { });
+};
+const dispatchWith = (component: AlloyComponent, target: SugarElement<Node>, event: string, properties: Record<string, any>): void => {
+  const data = {
+    target,
+    ...properties
+  };
+  component.getSystem().triggerEvent(event, target, data);
+};
+const dispatchEvent = <T extends EventFormat>(component: AlloyComponent, target: SugarElement<Node>, event: string, simulatedEvent: SimulatedEvent<T>): void => {
+  component.getSystem().triggerEvent(event, target, simulatedEvent.event);
+};
+const dispatchFocus = (component: AlloyComponent, target: SugarElement<HTMLElement>): void => {
+  component.getSystem().triggerFocus(target, component.element);
+};
+export {
+  emit,
+  emitWith,
+  emitExecute,
+  dispatch,
+  dispatchWith,
+  dispatchEvent,
+  dispatchFocus
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/events/SystemEvents.ts
@@ -0,0 +1,80 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { PlatformDetection } from '@ephox/sand';
+import { SugarElement } from '@ephox/sugar';
+import { CustomEvent } from '../../events/SimulatedEvent';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as NativeEvents from './NativeEvents';
+const prefixName = (name: string) => Fun.constant('alloy.' + name);
+const alloy = { tap: prefixName('tap') };
+const focus = prefixName('focus');
+const postBlur = prefixName('blur.post');
+const postPaste = prefixName('paste.post');
+const receive = prefixName('receive');
+const execute = prefixName('execute');
+const focusItem = prefixName('focus.item');
+const tap = alloy.tap;
+/*
+ * Tap event for touch device, otherwise click event
+ * @deprecated
+ */
+const tapOrClick = (): string => PlatformDetection.detect().deviceType.isTouch() ? alloy.tap() : NativeEvents.click();
+const longpress = prefixName('longpress');
+const sandboxClose = prefixName('sandbox.close');
+const typeaheadCancel = prefixName('typeahead.cancel');
+const systemInit = prefixName('system.init');
+const documentTouchmove = prefixName('system.touchmove');
+const documentTouchend = prefixName('system.touchend');
+const windowScroll = prefixName('system.scroll');
+const windowResize = prefixName('system.resize');
+const attachedToDom = prefixName('system.attached');
+const detachedFromDom = prefixName('system.detached');
+const dismissRequested = prefixName('system.dismissRequested');
+const repositionRequested = prefixName('system.repositionRequested');
+export interface AlloyFocusShiftedEvent extends CustomEvent {
+  readonly prevFocus: Optional<SugarElement<HTMLElement>>;
+  readonly newFocus: Optional<SugarElement<HTMLElement>>;
+}
+const focusShifted = prefixName('focusmanager.shifted');
+const slotVisibility = prefixName('slotcontainer.visibility');
+export interface AlloySlotVisibilityEvent extends CustomEvent {
+  readonly name: string;
+  readonly visible: boolean;
+}
+export interface AlloyChangeTabEvent extends CustomEvent {
+  readonly button: AlloyComponent;
+}
+export interface AlloyDismissTabEvent extends CustomEvent {
+  readonly button: AlloyComponent;
+}
+const changeTab = prefixName('change.tab');
+const dismissTab = prefixName('dismiss.tab');
+const highlight = prefixName('highlight');
+const dehighlight = prefixName('dehighlight');
+export {
+  focus,
+  postBlur,
+  postPaste,
+  receive,
+  execute,
+  focusItem,
+  tap,
+  tapOrClick,
+  longpress,
+  sandboxClose,
+  systemInit,
+  typeaheadCancel,
+  documentTouchmove,
+  documentTouchend,
+  windowScroll,
+  windowResize,
+  dismissRequested,
+  repositionRequested,
+  focusShifted,
+  attachedToDom,
+  detachedFromDom,
+  changeTab,
+  dismissTab,
+  slotVisibility,
+  highlight,
+  dehighlight
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/focus/FocusManagers.ts
@@ -0,0 +1,51 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Compare, Focus, SugarElement } from '@ephox/sugar';
+import { Highlighting } from '../behaviour/Highlighting';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as AlloyTriggers from '../events/AlloyTriggers';
+import * as SystemEvents from '../events/SystemEvents';
+const reportFocusShifting = (component: AlloyComponent, prevFocus: Optional<SugarElement<HTMLElement>>, newFocus: Optional<SugarElement<HTMLElement>>) => {
+  const noChange = prevFocus.exists((p) => newFocus.exists((n) => Compare.eq(n, p)));
+  if (!noChange) {
+    AlloyTriggers.emitWith(component, SystemEvents.focusShifted(), {
+      prevFocus,
+      newFocus
+    });
+  }
+};
+export interface FocusManager {
+  get: (component: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
+  set: (component: AlloyComponent, focusee: SugarElement<HTMLElement>) => void;
+}
+const dom = (): FocusManager => {
+  const get = (component: AlloyComponent) => Focus.search(component.element);
+  const set = (component: AlloyComponent, focusee: SugarElement<HTMLElement>) => {
+    const prevFocus = get(component);
+    component.getSystem().triggerFocus(focusee, component.element);
+    const newFocus = get(component);
+    reportFocusShifting(component, prevFocus, newFocus);
+  };
+  return {
+    get,
+    set
+  };
+};
+const highlights = (): FocusManager => {
+  const get = (component: AlloyComponent) => Highlighting.getHighlighted(component).map((item) => item.element);
+  const set = (component: AlloyComponent, element: SugarElement<HTMLElement>) => {
+    const prevFocus = get(component);
+    component.getSystem().getByDom(element).fold(Fun.noop, (item) => {
+      Highlighting.highlight(component, item);
+    });
+    const newFocus = get(component);
+    reportFocusShifting(component, prevFocus, newFocus);
+  };
+  return {
+    get,
+    set
+  };
+};
+export {
+  dom,
+  highlights
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/system/Attachment.ts
@@ -0,0 +1,63 @@
+import { Arr } from '@ephox/katamari';
+import { Insert, Remove, SugarBody, SugarElement, Traverse } from '@ephox/sugar';
+import * as InternalAttachment from '../../system/InternalAttachment';
+import { AlloyComponent } from '../component/ComponentApi';
+import { GuiSystem } from './Gui';
+const attach = (parent: AlloyComponent, child: AlloyComponent): void => {
+  attachWith(parent, child, Insert.append);
+};
+const attachWith = (parent: AlloyComponent, child: AlloyComponent, insertion: (parent: SugarElement<Node>, child: SugarElement<Node>) => void): void => {
+  parent.getSystem().addToWorld(child);
+  insertion(parent.element, child.element);
+  if (SugarBody.inBody(parent.element)) {
+    InternalAttachment.fireAttaching(child);
+  }
+  parent.syncComponents();
+};
+const doDetach = (component: AlloyComponent) => {
+  InternalAttachment.fireDetaching(component);
+  Remove.remove(component.element);
+  component.getSystem().removeFromWorld(component);
+};
+const detach = (component: AlloyComponent): void => {
+  const parent = Traverse.parent(component.element).bind((p) => component.getSystem().getByDom(p).toOptional());
+  doDetach(component);
+  parent.each((p) => {
+    p.syncComponents();
+  });
+};
+const detachChildren = (component: AlloyComponent): void => {
+  const subs = component.components();
+  Arr.each(subs, doDetach);
+  Remove.empty(component.element);
+  component.syncComponents();
+};
+const attachSystem = (element: SugarElement<Node>, guiSystem: GuiSystem): void => {
+  attachSystemWith(element, guiSystem, Insert.append);
+};
+const attachSystemAfter = (element: SugarElement<Node>, guiSystem: GuiSystem): void => {
+  attachSystemWith(element, guiSystem, Insert.after);
+};
+const attachSystemWith = (element: SugarElement<Node>, guiSystem: GuiSystem, inserter: (marker: SugarElement<Node>, element: SugarElement<Node>) => void): void => {
+  inserter(element, guiSystem.element);
+  const children = Traverse.children(guiSystem.element);
+  Arr.each(children, (child) => {
+    guiSystem.getByDom(child).each(InternalAttachment.fireAttaching);
+  });
+};
+const detachSystem = (guiSystem: GuiSystem): void => {
+  const children = Traverse.children(guiSystem.element);
+  Arr.each(children, (child) => {
+    guiSystem.getByDom(child).each(InternalAttachment.fireDetaching);
+  });
+  Remove.remove(guiSystem.element);
+};
+export {
+  attach,
+  attachWith,
+  detach,
+  detachChildren,
+  attachSystem,
+  attachSystemAfter,
+  detachSystem
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/system/ForeignGui.ts
@@ -0,0 +1,159 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Arr, Obj, Optional } from '@ephox/katamari';
+import { DomEvent, EventArgs, Insert, SugarElement } from '@ephox/sugar';
+import { UncurriedHandler } from '../../events/EventRegistry';
+import * as SimulatedEvent from '../../events/SimulatedEvent';
+import ForeignCache from '../../foreign/ForeignCache';
+import * as Tagger from '../../registry/Tagger';
+import { AlloyBehaviourRecord } from '../behaviour/Behaviour';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as GuiFactory from '../component/GuiFactory';
+import { AlloyEventRecord } from '../events/AlloyEvents';
+import * as Gui from './Gui';
+export interface ForeignGuiSpec {
+  readonly root: SugarElement<Node>;
+  readonly dispatchers: Dispatcher[];
+  readonly insertion?: (root: SugarElement<Node>, system: Gui.GuiSystem) => void;
+}
+export interface DispatchedAlloyConfig {
+  readonly events?: AlloyEventRecord;
+  readonly behaviours: AlloyBehaviourRecord;
+  readonly eventOrder?: Record<string, string[]>;
+}
+export interface Dispatcher {
+  readonly getTarget: (elem: SugarElement<Node>) => Optional<SugarElement<Node>>;
+  readonly alloyConfig: DispatchedAlloyConfig;
+}
+export interface ForeignGuiDetail {
+  readonly root: SugarElement<Node>;
+  readonly dispatchers: Dispatcher[];
+  readonly insertion: (root: SugarElement<Node>, system: Gui.GuiSystem) => void;
+}
+interface DispatcherMission {
+  readonly target: SugarElement<Node>;
+  readonly dispatcher: Dispatcher;
+}
+export interface ForeignGuiConnection {
+  readonly dispatchTo: (type: string, event: EventArgs) => void;
+  readonly unproxy: (component: AlloyComponent) => void;
+  readonly disengage: () => void;
+}
+const schema = StructureSchema.objOfOnly([
+  FieldSchema.required('root'),
+  FieldSchema.requiredArrayOfObj('dispatchers', [
+    FieldSchema.required('getTarget'),
+    FieldSchema.required('alloyConfig')
+  ]),
+  FieldSchema.defaulted('insertion', (root: SugarElement<Node>, system: AlloyComponent) => {
+    Insert.append(root, system.element);
+  })
+]);
+/*
+ * ForeignGui is an experimental concept
+ *
+ * Essentially, the basic idea is that we want to be able to use alloy behaviours and events
+ * on elements that were not created by alloy. The common example of this is the contents inside
+ * an iframe of an editor. We did not create the content (it is also volatile), but we still
+ * want to be able to pinch it, drag it, toggle it etc. However, we don't have Component
+ * instances for any of these things inside the alloy root ... they are completely separate.
+ *
+ * Most behaviours (probably not all) require configuration and a connection to an alloy
+ * root to exist for a small amount of time to execute their actions. For this reason, we
+ * create an internal alloy root for this foreign object (and insert it using insertion, so
+ * for iframes, it would often be inserted at the document level so that it wasn't in the content),
+ * and connect and disconnect the external elements to that. The elements themselves store their
+ * configuration so that we get garbage collecting benefits (a previous version stored them in
+ * a separate map), and that configuration can be retrieved from the element. If it isn't there,
+ * it is recreated (and any state with it). The configuration is maintained on the DOM object
+ * itself (through DomState), and the connection to the internal alloy root (/system) is removed after
+ * execution of the action.
+ *
+ * The connection to the internal alloy root can be required if the behaviour needs to create additional
+ * components (e.g. blockers for dragging). However, because these components are already within
+ * the internal alloy root, they don't need to be handled in this way (they are just maintained
+ * like normal alloy components having been built by alloy). Therefore, we exit dispatching if the
+ * target is within our internal system.
+ *
+ * A ForeignGui is setup with a list of dispatchers. Dispatchers tell alloy which things should have
+ * alloy like behaviour. Note, that each dispatcher has a getTarget, which returns an option of element.
+ * The purpose of this is it means that you may choose to add the behaviour to an *ancestor* of the target
+ * element (e.g. table) rather than the target element itself (td). The alloyConfig lists the behaviours and
+ * events to proxy for this dispatcher.
+ */
+const supportedEvents = [
+  'click', 'mousedown', 'mousemove', 'touchstart', 'touchend', 'gesturestart', 'touchmove'
+];
+const findDispatcher = (dispatchers: Dispatcher[], target: SugarElement<Node>): Optional<DispatcherMission> =>
+  Arr.findMap(dispatchers, (dispatcher: Dispatcher) => dispatcher.getTarget(target).map((newTarget) => ({
+    target: newTarget,
+    dispatcher
+  })));
+const getProxy = <T extends SimulatedEvent.EventFormat>(event: T, target: SugarElement<Node>) => {
+  const component = GuiFactory.build(
+    GuiFactory.external({ element: target })
+  );
+  const simulatedEvent = SimulatedEvent.fromTarget(event, target);
+  return {
+    component,
+    simulatedEvent
+  };
+};
+const engage = (spec: ForeignGuiSpec): ForeignGuiConnection => {
+  const detail: ForeignGuiDetail = StructureSchema.asRawOrDie('ForeignGui', schema, spec);
+  const gui = Gui.create();
+  detail.insertion(detail.root, gui);
+  const cache = ForeignCache();
+  const domEvents = Arr.map(supportedEvents, (type) => DomEvent.bind(detail.root, type, (event) => {
+    dispatchTo(type, event);
+  }));
+  const proxyFor = <T extends SimulatedEvent.EventFormat>(event: T, target: SugarElement<Node>, descHandler: UncurriedHandler) => {
+    const proxy = getProxy(event, target);
+    const component = proxy.component;
+    gui.addToWorld(component);
+    const handler = descHandler.handler;
+    handler(component, proxy.simulatedEvent);
+    unproxy(component);
+  };
+  const dispatchTo = (type: string, event: EventArgs): void => {
+    /*
+     * 1. Check that the event did not originate in our internal alloy root. If it did,
+     * we don't need to handle it here. The alloy root will handle it as usual.
+     * 2. Find the dispatcher based on the target element. It will find the first dispatcher
+     * that matches
+     * 3. Retrieve the configuration for this external element from its DOM state or create
+     * it if it doesn't already exist
+     * 4. If the event is supported:
+     * a) create a thin proxy wrapping for the DOM element to have component like APIs
+     * b) add it to the internal system
+     * c) execute the event handler
+     * d) remove it from the internal system and clear any DOM markers (alloy-ids etc)
+     */
+    if (gui.element.dom.contains(event.target.dom)) {
+      return;
+    }
+    findDispatcher(detail.dispatchers, event.target).each((mission) => {
+      const data = cache.getEvents(mission.target, mission.dispatcher.alloyConfig);
+      const events = data.evts;
+      if (Obj.hasNonNullableKey(events, type)) {
+        proxyFor(event, mission.target, events[type]);
+      }
+    });
+  };
+  const unproxy = (component: AlloyComponent): void => {
+    gui.removeFromWorld(component);
+    Tagger.revoke(component.element);
+  };
+  const disengage = (): void => {
+    Arr.each(domEvents, (e) => {
+      e.unbind();
+    });
+  };
+  return {
+    dispatchTo,
+    unproxy,
+    disengage
+  };
+};
+export {
+  engage
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/system/Gui.ts
@@ -0,0 +1,185 @@
+import { Arr, Fun, Result } from '@ephox/katamari';
+import { Compare, EventArgs, Focus, Remove, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
+import * as Debugging from '../../debugging/Debugging';
+import * as DescribedHandler from '../../events/DescribedHandler';
+import * as GuiEvents from '../../events/GuiEvents';
+import { FocusingEvent, ReceivingInternalEvent } from '../../events/SimulatedEvent';
+import * as Triggers from '../../events/Triggers';
+import { Registry } from '../../registry/Registry';
+import * as Tagger from '../../registry/Tagger';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as GuiFactory from '../component/GuiFactory';
+import * as SystemEvents from '../events/SystemEvents';
+import { Container } from '../ui/Container';
+import * as Attachment from './Attachment';
+import { AlloySystemApi } from './SystemApi';
+export interface GuiSystem {
+  readonly root: AlloyComponent;
+  readonly element: SugarElement<HTMLElement>;
+  readonly destroy: () => void;
+  readonly add: (component: AlloyComponent) => void;
+  readonly remove: (component: AlloyComponent) => void;
+  readonly getByUid: (uid: string) => Result<AlloyComponent, Error>;
+  readonly getByDom: (element: SugarElement<Node>) => Result<AlloyComponent, Error>;
+  readonly addToWorld: (comp: AlloyComponent) => void;
+  readonly removeFromWorld: (comp: AlloyComponent) => void;
+  readonly broadcast: <T>(message: T) => void;
+  readonly broadcastOn: <T>(channels: string[], message: T) => void;
+  readonly broadcastEvent: (eventName: string, event: EventArgs) => void;
+}
+export type message = Record<string, any>;
+const create = (): GuiSystem => {
+  const root = GuiFactory.build(
+    Container.sketch({
+      dom: {
+        tag: 'div'
+      }
+    })
+  );
+  return takeover(root);
+};
+const takeover = (root: AlloyComponent): GuiSystem => {
+  const isAboveRoot = (el: SugarElement<Node>): boolean => Traverse.parent(root.element).fold(
+    Fun.always,
+    (parent) => Compare.eq(el, parent)
+  );
+  const registry = Registry();
+  const lookup = (eventName: string, target: SugarElement<Node>) => registry.find(isAboveRoot, eventName, target);
+  const domEvents = GuiEvents.setup(root.element, {
+    triggerEvent: (eventName, event) => {
+      return Debugging.monitorEvent(eventName, event.target, (logger: Debugging.DebuggerLogger) => Triggers.triggerUntilStopped(lookup, eventName, event, logger));
+    }
+  });
+  const systemApi: AlloySystemApi = {
+    debugInfo: Fun.constant('real'),
+    triggerEvent: (eventName: string, target: SugarElement<Node>, data: any) => {
+      Debugging.monitorEvent(eventName, target, (logger: Debugging.DebuggerLogger) =>
+        Triggers.triggerOnUntilStopped(lookup, eventName, data, target, logger)
+      );
+    },
+    triggerFocus: (target: SugarElement<HTMLElement>, originator: SugarElement<Node>) => {
+      Tagger.read(target).fold(() => {
+        Focus.focus(target);
+      }, (_alloyId) => {
+        Debugging.monitorEvent(SystemEvents.focus(), target, (logger: Debugging.DebuggerLogger) => {
+          Triggers.triggerHandler<FocusingEvent>(lookup, SystemEvents.focus(), {
+            originator,
+            kill: Fun.noop,
+            prevent: Fun.noop,
+            target
+          }, target, logger);
+          return false;
+        });
+      });
+    },
+    triggerEscape: (comp, simulatedEvent) => {
+      systemApi.triggerEvent('keydown', comp.element, simulatedEvent.event);
+    },
+    getByUid: (uid) => {
+      return getByUid(uid);
+    },
+    getByDom: (elem) => {
+      return getByDom(elem);
+    },
+    build: GuiFactory.build,
+    buildOrPatch: GuiFactory.buildOrPatch,
+    addToGui: (c) => {
+      add(c);
+    },
+    removeFromGui: (c) => {
+      remove(c);
+    },
+    addToWorld: (c) => {
+      addToWorld(c);
+    },
+    removeFromWorld: (c) => {
+      removeFromWorld(c);
+    },
+    broadcast: (message) => {
+      broadcast(message);
+    },
+    broadcastOn: (channels, message) => {
+      broadcastOn(channels, message);
+    },
+    broadcastEvent: (eventName: string, event: EventArgs) => {
+      broadcastEvent(eventName, event);
+    },
+    isConnected: Fun.always
+  };
+  const addToWorld = (component: AlloyComponent) => {
+    component.connect(systemApi);
+    if (!SugarNode.isText(component.element)) {
+      registry.register(component);
+      Arr.each(component.components(), addToWorld);
+      systemApi.triggerEvent(SystemEvents.systemInit(), component.element, { target: component.element });
+    }
+  };
+  const removeFromWorld = (component: AlloyComponent) => {
+    if (!SugarNode.isText(component.element)) {
+      Arr.each(component.components(), removeFromWorld);
+      registry.unregister(component);
+    }
+    component.disconnect();
+  };
+  const add = (component: AlloyComponent) => {
+    Attachment.attach(root, component);
+  };
+  const remove = (component: AlloyComponent) => {
+    Attachment.detach(component);
+  };
+  const destroy = () => {
+    domEvents.unbind();
+    Remove.remove(root.element);
+  };
+  const broadcastData = (data: ReceivingInternalEvent) => {
+    const receivers = registry.filter(SystemEvents.receive());
+    Arr.each(receivers, (receiver) => {
+      const descHandler = receiver.descHandler;
+      const handler = DescribedHandler.getCurried(descHandler);
+      handler(data);
+    });
+  };
+  const broadcast = <T>(message: T) => {
+    broadcastData({
+      universal: true,
+      data: message
+    });
+  };
+  const broadcastOn = <T>(channels: string[], message: T) => {
+    broadcastData({
+      universal: false,
+      channels,
+      data: message
+    });
+  };
+  const broadcastEvent = (eventName: string, event: EventArgs) => {
+    const listeners = registry.filter(eventName);
+    return Triggers.broadcast(listeners, event);
+  };
+  const getByUid = (uid: string) => registry.getById(uid).fold(() => Result.error<AlloyComponent, Error>(
+    new Error('Could not find component with uid: "' + uid + '" in system.')
+  ), Result.value);
+  const getByDom = (elem: SugarElement<Node>): Result<AlloyComponent, Error> => {
+    const uid = Tagger.read(elem).getOr('not found');
+    return getByUid(uid);
+  };
+  addToWorld(root);
+  return {
+    root,
+    element: root.element,
+    destroy,
+    add,
+    remove,
+    getByUid,
+    getByDom,
+    addToWorld,
+    removeFromWorld,
+    broadcast,
+    broadcastOn,
+    broadcastEvent
+  };
+};
+export {
+  create,
+  takeover
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/system/NoContextApi.ts
@@ -0,0 +1,37 @@
+import { Fun } from '@ephox/katamari';
+import * as AlloyLogger from '../../log/AlloyLogger';
+import { AlloyComponent } from '../component/ComponentApi';
+import { AlloySystemApi } from './SystemApi';
+const NoContextApi = (getComp?: () => AlloyComponent): AlloySystemApi => {
+  const getMessage = (event: string) => `The component must be in a context to execute: ${event}` +
+    (getComp ? '\n' + AlloyLogger.element(getComp().element) + ' is not in context.' : '');
+  const fail = (event: string) => (): never => {
+    throw new Error(getMessage(event));
+  };
+  const warn = (event: string) => (): void => {
+    console.warn(getMessage(event));
+  };
+  return {
+    debugInfo: Fun.constant('fake'),
+    triggerEvent: warn('triggerEvent'),
+    triggerFocus: warn('triggerFocus'),
+    triggerEscape: warn('triggerEscape'),
+    broadcast: warn('broadcast'),
+    broadcastOn: warn('broadcastOn'),
+    broadcastEvent: warn('broadcastEvent'),
+    build: fail('build'),
+    buildOrPatch: fail('buildOrPatch'),
+    addToWorld: fail('addToWorld'),
+    removeFromWorld: fail('removeFromWorld'),
+    addToGui: fail('addToGui'),
+    removeFromGui: fail('removeFromGui'),
+    getByUid: fail('getByUid'),
+    getByDom: fail('getByDom'),
+    isConnected: Fun.never
+  };
+};
+const singleton = NoContextApi();
+export {
+  singleton,
+  NoContextApi
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/system/SystemApi.ts
@@ -0,0 +1,23 @@
+import { Optional, Result } from '@ephox/katamari';
+import { EventArgs, SugarElement } from '@ephox/sugar';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import { AlloyComponent } from '../component/ComponentApi';
+import { AlloySpec } from '../component/SpecTypes';
+export interface AlloySystemApi {
+  addToGui: (comp: AlloyComponent) => void;
+  addToWorld: (comp: AlloyComponent) => void;
+  broadcast: (message: any) => void;
+  broadcastOn: (channels: string[], message: any) => void;
+  broadcastEvent: (eventName: string, event: EventArgs) => void;
+  build: (spec: AlloySpec) => AlloyComponent;
+  buildOrPatch: (spec: AlloySpec, optObsoleted: Optional<SugarElement<Node>>) => AlloyComponent;
+  debugInfo: () => string;
+  getByDom: (element: SugarElement<Node>) => Result<AlloyComponent, Error>;
+  getByUid: (uid: string) => Result<AlloyComponent, Error>;
+  removeFromGui: (component: AlloyComponent) => void;
+  removeFromWorld: (component: AlloyComponent) => void;
+  isConnected: () => boolean;
+  triggerEscape: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  triggerEvent: (eventName: string, target: SugarElement<Node>, data: {}) => void;
+  triggerFocus: (target: SugarElement<HTMLElement>, originator: SugarElement<Node>) => void;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/ui/FloatingToolbarButton.ts
@@ -0,0 +1,173 @@
+import { Fun, Optional } from '@ephox/katamari';
+import * as ComponentStructure from '../../alien/ComponentStructure';
+import * as AriaControls from '../../aria/AriaControls';
+import * as MaxWidth from '../../positioning/layout/MaxWidth';
+import { Layouts } from '../../positioning/mode/Anchoring';
+import * as Dismissal from '../../sandbox/Dismissal';
+import * as Reposition from '../../sandbox/Reposition';
+import * as FloatingToolbarButtonSchema from '../../ui/schema/FloatingToolbarButtonSchema';
+import {
+  FloatingToolbarButtonApis, FloatingToolbarButtonDetail, FloatingToolbarButtonSketcher, FloatingToolbarButtonSpec
+} from '../../ui/types/FloatingToolbarButtonTypes';
+import * as Behaviour from '../behaviour/Behaviour';
+import { Coupling } from '../behaviour/Coupling';
+import { Focusing } from '../behaviour/Focusing';
+import { Keying } from '../behaviour/Keying';
+import { Positioning } from '../behaviour/Positioning';
+import { Receiving } from '../behaviour/Receiving';
+import { Sandboxing } from '../behaviour/Sandboxing';
+import { Toggling } from '../behaviour/Toggling';
+import { AlloyComponent } from '../component/ComponentApi';
+import { SketchBehaviours } from '../component/SketchBehaviours';
+import { AlloySpec, SketchSpec } from '../component/SpecTypes';
+import { Button } from './Button';
+import * as Sketcher from './Sketcher';
+import { Toolbar } from './Toolbar';
+import { CompositeSketchFactory } from './UiSketcher';
+const toggle = (button: AlloyComponent, externals: Record<string, any>) => {
+  const toolbarSandbox = Coupling.getCoupled(button, 'toolbarSandbox');
+  if (Sandboxing.isOpen(toolbarSandbox)) {
+    Sandboxing.close(toolbarSandbox);
+  } else {
+    Sandboxing.open(toolbarSandbox, externals.toolbar());
+  }
+};
+const position = (button: AlloyComponent, toolbar: AlloyComponent, detail: FloatingToolbarButtonDetail, layouts: Layouts | undefined) => {
+  const bounds = detail.getBounds.map((bounder) => bounder());
+  const sink = detail.lazySink(button).getOrDie();
+  Positioning.positionWithinBounds(sink, toolbar, {
+    anchor: {
+      type: 'hotspot',
+      hotspot: button,
+      layouts,
+      overrides: {
+        maxWidthFunction: MaxWidth.expandable()
+      }
+    }
+  }, bounds);
+};
+const setGroups = (button: AlloyComponent, toolbar: AlloyComponent, detail: FloatingToolbarButtonDetail, layouts: Layouts | undefined, groups: AlloySpec[]) => {
+  Toolbar.setGroups(toolbar, groups);
+  position(button, toolbar, detail, layouts);
+  Toggling.on(button);
+};
+const makeSandbox = (button: AlloyComponent, spec: FloatingToolbarButtonSpec, detail: FloatingToolbarButtonDetail) => {
+  const ariaControls = AriaControls.manager();
+  const onOpen = (sandbox: AlloyComponent, toolbar: AlloyComponent) => {
+    detail.fetch().get((groups) => {
+      setGroups(button, toolbar, detail, spec.layouts, groups);
+      ariaControls.link(button.element);
+      Keying.focusIn(toolbar);
+    });
+  };
+  const onClose = () => {
+    Toggling.off(button);
+    Focusing.focus(button);
+    ariaControls.unlink(button.element);
+  };
+  return {
+    dom: {
+      tag: 'div',
+      attributes: {
+        id: ariaControls.id
+      }
+    },
+    behaviours: Behaviour.derive(
+      [
+        Keying.config({
+          mode: 'special',
+          onEscape: (comp) => {
+            Sandboxing.close(comp);
+            return Optional.some<boolean>(true);
+          }
+        }),
+        Sandboxing.config({
+          onOpen,
+          onClose,
+          isPartOf: (container, data, queryElem): boolean => {
+            return ComponentStructure.isPartOf(data, queryElem) || ComponentStructure.isPartOf(button, queryElem);
+          },
+          getAttachPoint: () => {
+            return detail.lazySink(button).getOrDie();
+          }
+        }),
+        Receiving.config({
+          channels: {
+            ...Dismissal.receivingChannel({
+              isExtraPart: Fun.never,
+              ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ })
+            }),
+            ...Reposition.receivingChannel({
+              doReposition: () => {
+                Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
+                  position(button, toolbar, detail, spec.layouts);
+                });
+              }
+            })
+          }
+        })
+      ]
+    )
+  };
+};
+const factory: CompositeSketchFactory<FloatingToolbarButtonDetail, FloatingToolbarButtonSpec> = (detail, components, spec, externals): SketchSpec => ({
+  ...Button.sketch({
+    ...externals.button(),
+    action: (button) => {
+      toggle(button, externals);
+    },
+    buttonBehaviours: SketchBehaviours.augment(
+      { dump: externals.button().buttonBehaviours },
+      [
+        Coupling.config({
+          others: {
+            toolbarSandbox: (button) => {
+              return makeSandbox(button, spec, detail);
+            }
+          }
+        })
+      ]
+    )
+  }),
+  apis: {
+    setGroups: (button: AlloyComponent, groups: AlloySpec[]) => {
+      Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
+        setGroups(button, toolbar, detail, spec.layouts, groups);
+      });
+    },
+    reposition: (button: AlloyComponent) => {
+      Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox')).each((toolbar) => {
+        position(button, toolbar, detail, spec.layouts);
+      });
+    },
+    toggle: (button: AlloyComponent) => {
+      toggle(button, externals);
+    },
+    getToolbar: (button: AlloyComponent) => {
+      return Sandboxing.getState(Coupling.getCoupled(button, 'toolbarSandbox'));
+    },
+    isOpen: (button: AlloyComponent) => {
+      return Sandboxing.isOpen(Coupling.getCoupled(button, 'toolbarSandbox'));
+    }
+  }
+});
+const FloatingToolbarButton: FloatingToolbarButtonSketcher = Sketcher.composite<FloatingToolbarButtonSpec, FloatingToolbarButtonDetail, FloatingToolbarButtonApis>({
+  name: 'FloatingToolbarButton',
+  factory,
+  configFields: FloatingToolbarButtonSchema.schema(),
+  partFields: FloatingToolbarButtonSchema.parts(),
+  apis: {
+    setGroups: (apis, button, groups) => {
+      apis.setGroups(button, groups);
+    },
+    reposition: (apis, button) => {
+      apis.reposition(button);
+    },
+    toggle: (apis, button) => {
+      apis.toggle(button);
+    },
+    getToolbar: (apis, button) => apis.getToolbar(button),
+    isOpen: (apis, button) => apis.isOpen(button)
+  }
+});
+export { FloatingToolbarButton };

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/ui/GuiTypes.ts
@@ -0,0 +1,29 @@
+import { Objects } from '@ephox/boulder';
+import { Id, Obj, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as FunctionAnnotator from '../../debugging/FunctionAnnotator';
+import { AlloyComponent } from '../component/ComponentApi';
+import { AlloySpec, PremadeSpec } from '../component/SpecTypes';
+const premadeTag = Id.generate('alloy-premade');
+const premade = (comp: AlloyComponent): PremadeSpec => {
+  Object.defineProperty(comp.element.dom, premadeTag, {
+    value: comp.uid,
+    writable: true
+  });
+  return Objects.wrap(premadeTag, comp);
+};
+const isPremade = (element: SugarElement<Node>): boolean =>
+  Obj.has(element.dom as any, premadeTag);
+const getPremade = (spec: AlloySpec): Optional<AlloyComponent> =>
+  Obj.get<any, string>(spec, premadeTag);
+const makeApi = <A, R>(f: (api: A, comp: AlloyComponent, ...rest: any[]) => R): FunctionAnnotator.FunctionWithAnnotation<(comp: AlloyComponent, ...rest: any[]) => R> =>
+  FunctionAnnotator.markAsSketchApi(
+    (component: AlloyComponent, ...rest: any[]) => f(component.getApis(), component, ...rest),
+    f
+  );
+export {
+  makeApi,
+  premade,
+  getPremade,
+  isPremade
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/ui/InlineView.ts
@@ -0,0 +1,242 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Arr, Fun, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as Boxes from '../../alien/Boxes';
+import * as ComponentStructure from '../../alien/ComponentStructure';
+import { PlacementSpec } from '../../behaviour/positioning/PositioningTypes';
+import * as Fields from '../../data/Fields';
+import * as Layout from '../../positioning/layout/Layout';
+import * as Dismissal from '../../sandbox/Dismissal';
+import * as Reposition from '../../sandbox/Reposition';
+import { InlineMenuSpec, InlineViewApis, InlineViewDetail, InlineViewSketcher, InlineViewSpec } from '../../ui/types/InlineViewTypes';
+import { Positioning } from '../behaviour/Positioning';
+import { Receiving } from '../behaviour/Receiving';
+import { Representing } from '../behaviour/Representing';
+import { Sandboxing } from '../behaviour/Sandboxing';
+import { LazySink } from '../component/CommonTypes';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as SketchBehaviours from '../component/SketchBehaviours';
+import { AlloySpec, SketchSpec } from '../component/SpecTypes';
+import * as SystemEvents from '../events/SystemEvents';
+import * as Sketcher from './Sketcher';
+import { tieredMenu as TieredMenu } from './TieredMenu';
+import { SingleSketchFactory } from './UiSketcher';
+interface InlineViewPositionState {
+  mode: 'position';
+  config: PlacementSpec;
+  getBounds: () => Optional<Boxes.Bounds>;
+}
+interface InlineViewMenuState {
+  mode: 'menu';
+  menu: InlineMenuSpec;
+}
+type InlineViewState = InlineViewMenuState | InlineViewPositionState;
+const makeMenu = (detail: InlineViewDetail, menuSandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Boxes.Bounds>) => {
+  const lazySink: () => ReturnType<LazySink> = () => detail.lazySink(menuSandbox);
+  const layouts = menuSpec.type === 'horizontal' ? { layouts: {
+    onLtr: () => Layout.belowOrAbove(),
+    onRtl: () => Layout.belowOrAboveRtl()
+  }} : { };
+  const isFirstTierSubmenu = (triggeringPaths: string[]) => triggeringPaths.length === 2; // primary and first tier menu === 2 items
+  const getSubmenuLayouts = (triggeringPaths: string[]) => isFirstTierSubmenu(triggeringPaths) ? layouts : { };
+  return TieredMenu.sketch({
+    dom: {
+      tag: 'div'
+    },
+    data: menuSpec.data,
+    markers: menuSpec.menu.markers,
+    highlightImmediately: menuSpec.menu.highlightImmediately,
+    onEscape: () => {
+      Sandboxing.close(menuSandbox);
+      detail.onEscape.map((handler) => handler(menuSandbox));
+      return Optional.some<boolean>(true);
+    },
+    onExecute: () => {
+      return Optional.some<boolean>(true);
+    },
+    onOpenMenu: (tmenu, menu) => {
+      Positioning.positionWithinBounds(lazySink().getOrDie(), menu, placementSpec, getBounds());
+    },
+    onOpenSubmenu: (tmenu, item, submenu, triggeringPaths) => {
+      const sink = lazySink().getOrDie();
+      Positioning.position(sink, submenu, {
+        anchor: {
+          type: 'submenu',
+          item,
+          ...getSubmenuLayouts(triggeringPaths)
+        }
+      });
+    },
+    onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
+      const sink = lazySink().getOrDie();
+      Positioning.positionWithinBounds(sink, primaryMenu, placementSpec, getBounds());
+      Arr.each(submenuTriggers, (st) => {
+        const submenuLayouts = getSubmenuLayouts(st.triggeringPath);
+        Positioning.position(sink, st.triggeredMenu, {
+          anchor: { type: 'submenu', item: st.triggeringItem, ...submenuLayouts }
+        });
+      });
+    }
+  });
+};
+const factory: SingleSketchFactory<InlineViewDetail, InlineViewSpec> = (detail: InlineViewDetail, spec): SketchSpec => {
+  const isPartOfRelated = (sandbox: AlloyComponent, queryElem: SugarElement<Node>) => {
+    const related = detail.getRelated(sandbox);
+    return related.exists((rel) => ComponentStructure.isPartOf(rel, queryElem));
+  };
+  const setContent = (sandbox: AlloyComponent, thing: AlloySpec) => {
+    Sandboxing.setContent(sandbox, thing);
+  };
+  const showAt = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec) => {
+    showWithin(sandbox, thing, placementSpec, Optional.none());
+  };
+  const showWithin = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => {
+    showWithinBounds(sandbox, thing, placementSpec, () => boxElement.map((elem) => Boxes.box(elem)));
+  };
+  const showWithinBounds = (sandbox: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, getBounds: () => Optional<Boxes.Bounds>) => {
+    const sink = detail.lazySink(sandbox).getOrDie();
+    Sandboxing.openWhileCloaked(sandbox, thing, () => Positioning.positionWithinBounds(sink, sandbox, placementSpec, getBounds()));
+    Representing.setValue(sandbox, Optional.some({
+      mode: 'position',
+      config: placementSpec,
+      getBounds
+    }));
+  };
+  const showMenuAt = (sandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec) => {
+    showMenuWithinBounds(sandbox, placementSpec, menuSpec, Optional.none);
+  };
+  const showMenuWithinBounds = (sandbox: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Boxes.Bounds>) => {
+    const menu = makeMenu(detail, sandbox, placementSpec, menuSpec, getBounds);
+    Sandboxing.open(sandbox, menu);
+    Representing.setValue(sandbox, Optional.some({
+      mode: 'menu',
+      menu
+    }));
+  };
+  const hide = (sandbox: AlloyComponent) => {
+    if (Sandboxing.isOpen(sandbox)) {
+      Representing.setValue(sandbox, Optional.none());
+      Sandboxing.close(sandbox);
+    }
+  };
+  const getContent = (sandbox: AlloyComponent): Optional<AlloyComponent> => Sandboxing.getState(sandbox);
+  const reposition = (sandbox: AlloyComponent) => {
+    if (Sandboxing.isOpen(sandbox)) {
+      Representing.getValue(sandbox).each((state: InlineViewState) => {
+        switch (state.mode) {
+          case 'menu':
+            Sandboxing.getState(sandbox).each(TieredMenu.repositionMenus);
+            break;
+          case 'position':
+            const sink = detail.lazySink(sandbox).getOrDie();
+            Positioning.positionWithinBounds(sink, sandbox, state.config, state.getBounds());
+            break;
+        }
+      });
+    }
+  };
+  const apis = {
+    setContent,
+    showAt,
+    showWithin,
+    showWithinBounds,
+    showMenuAt,
+    showMenuWithinBounds,
+    hide,
+    getContent,
+    reposition,
+    isOpen: Sandboxing.isOpen
+  };
+  return {
+    uid: detail.uid,
+    dom: detail.dom,
+    behaviours: SketchBehaviours.augment(
+      detail.inlineBehaviours,
+      [
+        Sandboxing.config({
+          isPartOf: (sandbox, data, queryElem) => {
+            return ComponentStructure.isPartOf(data, queryElem) || isPartOfRelated(sandbox, queryElem);
+          },
+          getAttachPoint: (sandbox) => {
+            return detail.lazySink(sandbox).getOrDie();
+          },
+          onOpen: (sandbox) => {
+            detail.onShow(sandbox);
+          },
+          onClose: (sandbox) => {
+            detail.onHide(sandbox);
+          }
+        }),
+        Representing.config({
+          store: {
+            mode: 'memory',
+            initialValue: Optional.none()
+          }
+        }),
+        Receiving.config({
+          channels: {
+            ...Dismissal.receivingChannel({
+              isExtraPart: spec.isExtraPart,
+              ...detail.fireDismissalEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ })
+            }),
+            ...Reposition.receivingChannel({
+              ...detail.fireRepositionEventInstead.map((fe) => ({ fireEventInstead: { event: fe.event }} as any)).getOr({ }),
+              doReposition: reposition
+            })
+          }
+        })
+      ]
+    ),
+    eventOrder: detail.eventOrder,
+    apis
+  };
+};
+const InlineView: InlineViewSketcher = Sketcher.single<InlineViewSpec, InlineViewDetail, InlineViewApis>({
+  name: 'InlineView',
+  configFields: [
+    FieldSchema.required('lazySink'),
+    Fields.onHandler('onShow'),
+    Fields.onHandler('onHide'),
+    FieldSchema.optionFunction('onEscape'),
+    SketchBehaviours.field('inlineBehaviours', [ Sandboxing, Representing, Receiving ]),
+    FieldSchema.optionObjOf('fireDismissalEventInstead', [
+      FieldSchema.defaulted('event', SystemEvents.dismissRequested())
+    ]),
+    FieldSchema.optionObjOf('fireRepositionEventInstead', [
+      FieldSchema.defaulted('event', SystemEvents.repositionRequested())
+    ]),
+    FieldSchema.defaulted('getRelated', Optional.none),
+    FieldSchema.defaulted('isExtraPart', Fun.never),
+    FieldSchema.defaulted('eventOrder', Optional.none)
+  ],
+  factory,
+  apis: {
+    showAt: (apis, component, anchor, thing) => {
+      apis.showAt(component, anchor, thing);
+    },
+    showWithin: (apis, component, anchor, thing, boxElement) => {
+      apis.showWithin(component, anchor, thing, boxElement);
+    },
+    showWithinBounds: (apis, component, anchor, thing, bounds) => {
+      apis.showWithinBounds(component, anchor, thing, bounds);
+    },
+    showMenuAt: (apis, component, anchor, menuSpec) => {
+      apis.showMenuAt(component, anchor, menuSpec);
+    },
+    showMenuWithinBounds: (apis, component, anchor, menuSpec, bounds) => {
+      apis.showMenuWithinBounds(component, anchor, menuSpec, bounds);
+    },
+    hide: (apis, component) => {
+      apis.hide(component);
+    },
+    isOpen: (apis, component) => apis.isOpen(component),
+    getContent: (apis, component) => apis.getContent(component),
+    setContent: (apis, component, thing) => {
+      apis.setContent(component, thing);
+    },
+    reposition: (apis, component) => {
+      apis.reposition(component);
+    }
+  }
+});
+export { InlineView };

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/api/ui/TouchMenu.ts
@@ -0,0 +1,182 @@
+import { Cell, Fun, Optional } from '@ephox/katamari';
+import { EventArgs, Focus, SugarShadowDom } from '@ephox/sugar';
+import * as ElementFromPoint from '../../alien/ElementFromPoint';
+import { TransitionPropertiesSpec } from '../../behaviour/transitioning/TransitioningTypes';
+import * as DropdownUtils from '../../dropdown/DropdownUtils';
+import * as TouchMenuSchema from '../../ui/schema/TouchMenuSchema';
+import { TouchMenuDetail, TouchMenuSketcher, TouchMenuSpec } from '../../ui/types/TouchMenuTypes';
+import * as AddEventsBehaviour from '../behaviour/AddEventsBehaviour';
+import * as Behaviour from '../behaviour/Behaviour';
+import { Coupling } from '../behaviour/Coupling';
+import { Highlighting } from '../behaviour/Highlighting';
+import { Representing } from '../behaviour/Representing';
+import { Sandboxing } from '../behaviour/Sandboxing';
+import { Toggling } from '../behaviour/Toggling';
+import { Transitioning } from '../behaviour/Transitioning';
+import { Unselecting } from '../behaviour/Unselecting';
+import { AlloyComponent } from '../component/ComponentApi';
+import * as SketchBehaviours from '../component/SketchBehaviours';
+import * as AlloyEvents from '../events/AlloyEvents';
+import * as AlloyTriggers from '../events/AlloyTriggers';
+import * as NativeEvents from '../events/NativeEvents';
+import * as SystemEvents from '../events/SystemEvents';
+import { InlineView } from './InlineView';
+import { Menu } from './Menu';
+import * as Sketcher from './Sketcher';
+import { CompositeSketchFactory } from './UiSketcher';
+type TouchHoverState = (comp: AlloyComponent) => void;
+const factory: CompositeSketchFactory<TouchMenuDetail, TouchMenuSpec> = (detail, components, spec, externals) => {
+  const getMenu = (component: AlloyComponent): Optional<AlloyComponent> => {
+    const sandbox = Coupling.getCoupled(component, 'sandbox');
+    return Sandboxing.getState(sandbox);
+  };
+  const hoveredState = Cell<boolean>(false);
+  const hoverOn = (component: AlloyComponent): void => {
+    if (!hoveredState.get()) {
+      forceHoverOn(component);
+    }
+  };
+  const forceHoverOn = (component: AlloyComponent): void => {
+    detail.onHoverOn(component);
+    hoveredState.set(true);
+  };
+  const hoverOff = (component: AlloyComponent): void => {
+    if (hoveredState.get()) {
+      detail.onHoverOff(component);
+      hoveredState.set(false);
+    }
+  };
+  return {
+    uid: detail.uid,
+    dom: detail.dom,
+    components,
+    domModification: {
+      attributes: {
+        role: detail.role.getOr('button')
+      }
+    },
+    behaviours: SketchBehaviours.augment(
+      detail.touchmenuBehaviours,
+      [
+        Toggling.config({
+          toggleClass: detail.toggleClass,
+          aria: {
+            mode: 'pressed',
+            syncWithExpanded: true
+          }
+        }),
+        Unselecting.config({ }),
+        Coupling.config({
+          others: {
+            sandbox: (hotspot) => {
+              return InlineView.sketch({
+                ...externals.view(),
+                lazySink: DropdownUtils.getSink(hotspot, detail),
+                inlineBehaviours: Behaviour.derive([
+                  AddEventsBehaviour.config('execute-for-menu', [
+                    AlloyEvents.runOnExecute((c, s) => {
+                      const target = s.event.target;
+                      c.getSystem().getByDom(target).each((item) => {
+                        detail.onExecute(hotspot, c, item, Representing.getValue(item));
+                      });
+                    })
+                  ]),
+                  Transitioning.config({
+                    initialState: 'closed',
+                    destinationAttr: 'data-longpress-destination',
+                    stateAttr: 'data-longpress-state',
+                    routes: Transitioning.createBistate(
+                      'open',
+                      'closed',
+                      detail.menuTransition.map((t) => ({
+                        transition: t
+                      } as TransitionPropertiesSpec)).getOr({ })
+                    ),
+                    onFinish: (view, destination) => {
+                      if (destination === 'closed') {
+                        InlineView.hide(view);
+                        detail.onClosed(hotspot, view);
+                      }
+                    }
+                  })
+                ]),
+                onShow: (view: AlloyComponent) => {
+                  Transitioning.progressTo(view, 'open');
+                }
+              });
+            }
+          }
+        })
+      ]
+    ),
+    events: AlloyEvents.derive([
+      AlloyEvents.abort(NativeEvents.contextmenu(), Fun.always),
+      AlloyEvents.run(NativeEvents.touchstart(), (comp, _se) => {
+        Toggling.on(comp);
+      }),
+      AlloyEvents.run(SystemEvents.tap(), (comp, _se) => {
+        detail.onTap(comp);
+      }),
+      AlloyEvents.run(SystemEvents.longpress(), (component, _simulatedEvent) => {
+        detail.fetch(component).get((items) => {
+          forceHoverOn(component);
+          const iMenu = Menu.sketch({
+            ...externals.menu(),
+            items
+          });
+          const sandbox = Coupling.getCoupled(component, 'sandbox');
+          const anchor = detail.getAnchor(component);
+          InlineView.showAt(sandbox, iMenu, { anchor });
+        });
+      }),
+      AlloyEvents.run<EventArgs<TouchEvent>>(NativeEvents.touchmove(), (component, simulatedEvent) => {
+        const raw = simulatedEvent.event.raw;
+        const e = raw.touches[0];
+        getMenu(component).each((iMenu) => {
+          ElementFromPoint.insideComponent(iMenu, e.clientX, e.clientY).fold(() => {
+            Highlighting.dehighlightAll(iMenu);
+            const dos = SugarShadowDom.getRootNode(component.element);
+            Focus.active(dos).each(Focus.blur);
+            const hoverF = ElementFromPoint.insideComponent(component, e.clientX, e.clientY).fold<TouchHoverState>(
+              Fun.constant(hoverOff),
+              Fun.constant(hoverOn)
+            );
+            hoverF(component);
+          }, (elem) => {
+            AlloyTriggers.dispatchWith(component, elem, NativeEvents.mouseover(), {
+              x: e.clientX,
+              y: e.clientY
+            });
+            hoverOff(component);
+          });
+          simulatedEvent.stop();
+        });
+      }),
+      AlloyEvents.run(NativeEvents.touchend(), (component, _simulatedEvent) => {
+        getMenu(component).each((iMenu) => {
+          Highlighting.getHighlighted(iMenu).each(AlloyTriggers.emitExecute);
+        });
+        const sandbox = Coupling.getCoupled(component, 'sandbox');
+        Transitioning.progressTo(sandbox, 'closed');
+        Toggling.off(component);
+      }),
+      AlloyEvents.runOnDetached((component, _simulatedEvent) => {
+        const sandbox = Coupling.getCoupled(component, 'sandbox');
+        InlineView.hide(sandbox);
+      })
+    ]),
+    eventOrder: {
+      ...detail.eventOrder,
+      [SystemEvents.execute()]: [ 'toggling', 'alloy.base.behaviour' ]
+    }
+  };
+};
+const TouchMenu: TouchMenuSketcher = Sketcher.composite({
+  name: 'TouchMenu',
+  configFields: TouchMenuSchema.schema(),
+  partFields: TouchMenuSchema.parts(),
+  factory
+});
+export {
+  TouchMenu
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/aria/AriaControls.ts
@@ -0,0 +1,40 @@
+import { Id, Optional } from '@ephox/katamari';
+import { Attribute, PredicateFind, SelectorFind, SugarElement, SugarNode, SugarShadowDom } from '@ephox/sugar';
+export interface AriaManager {
+  readonly id: string;
+  readonly link: (elem: SugarElement<Element>) => void;
+  readonly unlink: (elem: SugarElement<Element>) => void;
+}
+const attribute = 'aria-controls';
+const find = (queryElem: SugarElement<Node>): Optional<SugarElement<Element>> => {
+  const dependent = PredicateFind.closest(queryElem, (elem): elem is SugarElement<Element> => {
+    if (!SugarNode.isElement(elem)) {
+      return false;
+    }
+    const id = Attribute.get(elem, 'id');
+    return id !== undefined && id.indexOf(attribute) > -1;
+  });
+  return dependent.bind((dep) => {
+    const id = Attribute.get(dep, 'id');
+    const dos = SugarShadowDom.getRootNode(dep);
+    return SelectorFind.descendant(dos, `[${attribute}="${id}"]`);
+  });
+};
+const manager = (): AriaManager => {
+  const ariaId = Id.generate(attribute);
+  const link = (elem: SugarElement<Element>) => {
+    Attribute.set(elem, attribute, ariaId);
+  };
+  const unlink = (elem: SugarElement<Element>) => {
+    Attribute.remove(elem, attribute);
+  };
+  return {
+    id: ariaId,
+    link,
+    unlink,
+  };
+};
+export {
+  find,
+  manager
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/aria/AriaDescribe.ts
@@ -0,0 +1,14 @@
+import { Fun, Id, Optional } from '@ephox/katamari';
+import { Attribute, SugarElement } from '@ephox/sugar';
+const describedBy = (describedElement: SugarElement<Element>, describeElement: SugarElement<Element>): void => {
+  const describeId = Optional.from(Attribute.get(describedElement, 'id'))
+    .fold(() => {
+      const id = Id.generate('dialog-describe');
+      Attribute.set(describeElement, 'id', id);
+      return id;
+    }, Fun.identity);
+  Attribute.set(describedElement, 'aria-describedby', describeId);
+};
+export {
+  describedBy
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/aria/AriaFocus.ts
@@ -0,0 +1,19 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Compare, Focus, PredicateFind, SugarElement, SugarShadowDom } from '@ephox/sugar';
+const preserve = <T extends Node, R>(f: (e: SugarElement<T>) => R, container: SugarElement<T>): R => {
+  const dos = SugarShadowDom.getRootNode(container);
+  const refocus = Focus.active(dos).bind((focused): Optional<SugarElement<HTMLElement>> => {
+    const hasFocus = (elem: SugarElement<Node>): elem is SugarElement<HTMLElement> => Compare.eq(focused, elem);
+    return hasFocus(container) ? Optional.some(container) : PredicateFind.descendant(container, hasFocus);
+  });
+  const result = f(container);
+  refocus.each((oldFocus) => {
+    Focus.active(dos).filter((newFocus) => Compare.eq(newFocus, oldFocus)).fold(() => {
+      Focus.focus(oldFocus);
+    }, Fun.noop);
+  });
+  return result;
+};
+export {
+  preserve
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/aria/AriaLabel.ts
@@ -0,0 +1,11 @@
+import { Fun, Id } from '@ephox/katamari';
+import { Attribute, SugarElement } from '@ephox/sugar';
+export const labelledBy = (labelledElement: SugarElement<Element>, labelElement: SugarElement<Element>): void => {
+  const labelId = Attribute.getOpt(labelledElement, 'id')
+    .fold(() => {
+      const id = Id.generate('dialog-label');
+      Attribute.set(labelElement, 'id', id);
+      return id;
+    }, Fun.identity);
+  Attribute.set(labelledElement, 'aria-labelledby', labelId);
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/aria/AriaVoice.ts
@@ -0,0 +1,60 @@
+import { Fun, Id } from '@ephox/katamari';
+import { PlatformDetection } from '@ephox/sand';
+import { Attribute, Css, Insert, Remove, SugarElement, Traverse } from '@ephox/sugar';
+const offscreen = {
+  position: 'absolute',
+  left: '-9999px'
+};
+const tokenSelector = Fun.constant('span[id^="ephox-alloy-aria-voice"]');
+const create = (doc: SugarElement<Document>, text: string): SugarElement<HTMLSpanElement> => {
+  const span = SugarElement.fromTag('span', doc.dom);
+  Attribute.set(span, 'role', 'presentation');
+  const contents = SugarElement.fromText(text, doc.dom);
+  Insert.append(span, contents);
+  return span;
+};
+const linkToDescription = (item: SugarElement<Element>, token: SugarElement<Element>): void => {
+  const id = Id.generate('ephox-alloy-aria-voice');
+  Attribute.set(token, 'id', id);
+  Attribute.set(item, 'aria-describedby', id);
+};
+const describe = (item: SugarElement<Element>, description: string): SugarElement<HTMLSpanElement> => {
+  const doc = Traverse.owner(item);
+  const token = create(doc, description);
+  Css.set(token, 'display', 'none');
+  Attribute.set(token, 'aria-hidden', 'true'); // aria-hidden needs to be in sync with dom visibility
+  linkToDescription(item, token);
+  return token;
+};
+const base = (getAttrs: (string: string) => { }, parent: SugarElement<Element>, text: string): void => {
+  const doc = Traverse.owner(parent);
+  const token = create(doc, text);
+  if (PlatformDetection.detect().browser.isFirefox()) {
+    linkToDescription(parent, token);
+  }
+  Attribute.setAll(token, getAttrs(text));
+  Css.setAll(token, offscreen);
+  Insert.append(parent, token);
+  setTimeout(() => {
+    Attribute.remove(token, 'aria-live');
+    Remove.remove(token);
+  }, 1000);
+};
+const getSpeakAttrs = (text: string) => ({
+  'aria-live': 'polite',
+  'aria-atomic': 'true',
+  'aria-label': text
+});
+const getShoutAttrs = (_text: string) => ({
+  'aria-live': 'assertive',
+  'aria-atomic': 'true',
+  'role': 'alert'
+});
+const speak = (parent: SugarElement<Element>, text: string): void => base(getSpeakAttrs, parent, text);
+const shout = (parent: SugarElement<Element>, text: string): void => base(getShoutAttrs, parent, text);
+export {
+  describe,
+  speak,
+  shout,
+  tokenSelector
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/coupling/CouplingState.ts
@@ -0,0 +1,31 @@
+import { Fun, Obj } from '@ephox/katamari';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { nuState } from '../common/BehaviourState';
+import { CouplingConfig, CouplingState } from './CouplingTypes';
+const init = (): CouplingState => {
+  const coupled: Record<string, AlloyComponent> = { };
+  const getOrCreate = (component: AlloyComponent, coupleConfig: CouplingConfig, name: string): AlloyComponent => {
+    const available = Obj.keys(coupleConfig.others);
+    if (!available) {
+      throw new Error('Cannot find coupled component: ' + name + '. Known coupled components: ' + JSON.stringify(available, null, 2));
+    } else {
+      return Obj.get<any, string>(coupled, name).getOrThunk(() => {
+        const builder = Obj.get<any, string>(coupleConfig.others, name).getOrDie(
+          'No information found for coupled component: ' + name
+        );
+        const spec = builder(component);
+        const built = component.getSystem().build(spec);
+        coupled[name] = built;
+        return built;
+      });
+    }
+  };
+  const readState = Fun.constant({ });
+  return nuState({
+    readState,
+    getOrCreate
+  });
+};
+export {
+  init
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/highlighting/HighlightApis.ts
@@ -0,0 +1,105 @@
+import { Arr, Num, Optional, Optionals, Result } from '@ephox/katamari';
+import { Class, SelectorFilter, SelectorFind } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyTriggers from '../../api/events/AlloyTriggers';
+import * as SystemEvents from '../../api/events/SystemEvents';
+import { Stateless } from '../common/BehaviourState';
+import { HighlightingConfig } from './HighlightingTypes';
+const dehighlightAllExcept = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, skip: AlloyComponent[]): void => {
+  const highlighted = SelectorFilter.descendants(component.element, '.' + hConfig.highlightClass);
+  Arr.each(highlighted, (h) => {
+    if (!Arr.exists(skip, (skipComp) => skipComp.element === h)) {
+      Class.remove(h, hConfig.highlightClass);
+      component.getSystem().getByDom(h).each((target) => {
+        hConfig.onDehighlight(component, target);
+        AlloyTriggers.emit(target, SystemEvents.dehighlight());
+      });
+    }
+  });
+};
+const dehighlightAll = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => dehighlightAllExcept(component, hConfig, hState, []);
+const dehighlight = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, target: AlloyComponent): void => {
+  if (isHighlighted(component, hConfig, hState, target)) {
+    Class.remove(target.element, hConfig.highlightClass);
+    hConfig.onDehighlight(component, target);
+    AlloyTriggers.emit(target, SystemEvents.dehighlight());
+  }
+};
+const highlight = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, target: AlloyComponent): void => {
+  dehighlightAllExcept(component, hConfig, hState, [ target ]);
+  if (!isHighlighted(component, hConfig, hState, target)) {
+    Class.add(target.element, hConfig.highlightClass);
+    hConfig.onHighlight(component, target);
+    AlloyTriggers.emit(target, SystemEvents.highlight());
+  }
+};
+const highlightFirst = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => {
+  getFirst(component, hConfig, hState).each((firstComp) => {
+    highlight(component, hConfig, hState, firstComp);
+  });
+};
+const highlightLast = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): void => {
+  getLast(component, hConfig, hState).each((lastComp) => {
+    highlight(component, hConfig, hState, lastComp);
+  });
+};
+const highlightAt = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, index: number): void => {
+  getByIndex(component, hConfig, hState, index).fold((err) => {
+    throw err;
+  }, (firstComp) => {
+    highlight(component, hConfig, hState, firstComp);
+  });
+};
+const highlightBy = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, predicate: (comp: AlloyComponent) => boolean): void => {
+  const candidates = getCandidates(component, hConfig, hState);
+  const targetComp = Arr.find(candidates, predicate);
+  targetComp.each((c) => {
+    highlight(component, hConfig, hState, c);
+  });
+};
+const isHighlighted = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, queryTarget: AlloyComponent): boolean => Class.has(queryTarget.element, hConfig.highlightClass);
+const getHighlighted = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> =>
+  SelectorFind.descendant(component.element, '.' + hConfig.highlightClass).bind((e) => component.getSystem().getByDom(e).toOptional());
+const getByIndex = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, index: number): Result<AlloyComponent, Error> => {
+  const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
+  return Optional.from(items[index]).fold(() => Result.error(new Error('No element found with index ' + index)), component.getSystem().getByDom);
+};
+const getFirst = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> =>
+  SelectorFind.descendant(component.element, '.' + hConfig.itemClass).bind((e) => component.getSystem().getByDom(e).toOptional());
+const getLast = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): Optional<AlloyComponent> => {
+  const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
+  const last = items.length > 0 ? Optional.some(items[items.length - 1]) : Optional.none();
+  return last.bind((c) => component.getSystem().getByDom(c).toOptional());
+};
+const getDelta = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless, delta: number): Optional<AlloyComponent> => {
+  const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
+  const current = Arr.findIndex(items, (item) => Class.has(item, hConfig.highlightClass));
+  return current.bind((selected) => {
+    const dest = Num.cycleBy(selected, delta, 0, items.length - 1);
+    return component.getSystem().getByDom(items[dest]).toOptional();
+  });
+};
+const getPrevious = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): Optional<AlloyComponent> => getDelta(component, hConfig, hState, -1);
+const getNext = (component: AlloyComponent, hConfig: HighlightingConfig, hState: Stateless): Optional<AlloyComponent> => getDelta(component, hConfig, hState, +1);
+const getCandidates = (component: AlloyComponent, hConfig: HighlightingConfig, _hState: Stateless): AlloyComponent[] => {
+  const items = SelectorFilter.descendants(component.element, '.' + hConfig.itemClass);
+  return Optionals.cat(
+    Arr.map(items, (i) => component.getSystem().getByDom(i).toOptional())
+  );
+};
+export {
+  dehighlightAll,
+  dehighlight,
+  highlight,
+  highlightFirst,
+  highlightLast,
+  highlightAt,
+  highlightBy,
+  isHighlighted,
+  getHighlighted,
+  getFirst,
+  getLast,
+  getPrevious,
+  getNext,
+  getCandidates
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/invalidating/InvalidateApis.ts
@@ -0,0 +1,73 @@
+import { Arr, Future, Result } from '@ephox/katamari';
+import { Attribute, Class, Html, SugarElement, SugarNode } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { Stateless } from '../common/BehaviourState';
+import { InvalidatingConfig } from './InvalidateTypes';
+const ariaElements = [
+  'input',
+  'textarea'
+];
+const isAriaElement = (elem: SugarElement<Node>): elem is SugarElement<HTMLInputElement | HTMLTextAreaElement> => {
+  const name = SugarNode.name(elem);
+  return Arr.contains(ariaElements, name);
+};
+const markValid = (component: AlloyComponent, invalidConfig: InvalidatingConfig): void => {
+  const elem = invalidConfig.getRoot(component).getOr(component.element);
+  Class.remove(elem, invalidConfig.invalidClass);
+  invalidConfig.notify.each((notifyInfo) => {
+    if (isAriaElement(component.element)) {
+      Attribute.set(component.element, 'aria-invalid', false);
+    }
+    notifyInfo.getContainer(component).each((container) => {
+      Html.set(container, notifyInfo.validHtml);
+    });
+    notifyInfo.onValid(component);
+  });
+};
+const markInvalid = (component: AlloyComponent, invalidConfig: InvalidatingConfig, invalidState: Stateless, text: string): void => {
+  const elem = invalidConfig.getRoot(component).getOr(component.element);
+  Class.add(elem, invalidConfig.invalidClass);
+  invalidConfig.notify.each((notifyInfo) => {
+    if (isAriaElement(component.element)) {
+      Attribute.set(component.element, 'aria-invalid', true);
+    }
+    notifyInfo.getContainer(component).each((container) => {
+      Html.set(container, text);
+    });
+    notifyInfo.onInvalid(component, text);
+  });
+};
+const query = (component: AlloyComponent, invalidConfig: InvalidatingConfig, _invalidState: Stateless): Future<Result<any, string>> =>
+  invalidConfig.validator.fold(
+    () => Future.pure(Result.value(true)),
+    (validatorInfo) => validatorInfo.validate(component)
+  );
+const run = (component: AlloyComponent, invalidConfig: InvalidatingConfig, invalidState: Stateless): Future<Result<any, string>> => {
+  invalidConfig.notify.each((notifyInfo) => {
+    notifyInfo.onValidate(component);
+  });
+  return query(component, invalidConfig, invalidState).map((valid: Result<any, string>) => {
+    if (component.getSystem().isConnected()) {
+      return valid.fold((err) => {
+        markInvalid(component, invalidConfig, invalidState, err);
+        return Result.error(err);
+      }, (v) => {
+        markValid(component, invalidConfig);
+        return Result.value(v);
+      });
+    } else {
+      return Result.error('No longer in system');
+    }
+  });
+};
+const isInvalid = (component: AlloyComponent, invalidConfig: InvalidatingConfig): boolean => {
+  const elem = invalidConfig.getRoot(component).getOr(component.element);
+  return Class.has(elem, invalidConfig.invalidClass);
+};
+export {
+  markValid,
+  markInvalid,
+  query,
+  run,
+  isInvalid
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/invalidating/InvalidateTypes.ts
@@ -0,0 +1,47 @@
+import { Future, Optional, Result } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+export interface InvalidatingBehaviour extends Behaviour.AlloyBehaviour<InvalidatingConfigSpec, InvalidatingConfig> {
+  config: (config: InvalidatingConfigSpec) => Behaviour.NamedConfiguredBehaviour<InvalidatingConfigSpec, InvalidatingConfig>;
+  markValid: (component: AlloyComponent) => void;
+  isInvalid: (component: AlloyComponent) => boolean;
+  markInvalid: (component: AlloyComponent, text: string) => void;
+  query: (component: AlloyComponent) => Future<Result<any, string>>;
+  run: (component: AlloyComponent) => Future<Result<any, string>>;
+  validation: <T>(validate: (v: string) => Result<T, string>) => (component: AlloyComponent) => Future<Result<T, string>>;
+}
+export interface InvalidatingConfigSpec extends Behaviour.BehaviourConfigSpec {
+  invalidClass: string;
+  getRoot?: (comp: AlloyComponent) => Optional<SugarElement<Element>>;
+  notify?: {
+    aria?: string;
+    getContainer?: (input: AlloyComponent) => Optional<SugarElement<Node>>;
+    validHtml?: string;
+    onValid?: (comp: AlloyComponent) => void;
+    onInvalid?: (comp: AlloyComponent, err: string) => void;
+    onValidate?: (comp: AlloyComponent) => void;
+  };
+  validator?: {
+    validate: (input: AlloyComponent) => Future<Result<any, string>>;
+    onEvent?: string;
+    validateOnLoad?: boolean;
+  };
+}
+export interface InvalidatingConfig extends Behaviour.BehaviourConfigDetail {
+  invalidClass: string;
+  notify: Optional<{
+    aria: string;
+    getContainer: (input: AlloyComponent) => Optional<SugarElement<Node>>;
+    onValid: (comp: AlloyComponent) => void;
+    validHtml: string;
+    onInvalid: (comp: AlloyComponent, err: string) => void;
+    onValidate: (comp: AlloyComponent) => void;
+  }>;
+  getRoot: (comp: AlloyComponent) => Optional<SugarElement<Element>>;
+  validator: Optional<{
+    validate: (input: AlloyComponent) => Future<Result<any, string>>;
+    onEvent: string;
+    validateOnLoad?: boolean;
+  }>;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/pinching/PinchingTypes.ts
@@ -0,0 +1,20 @@
+import { SugarElement } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { BaseDraggingState } from '../../dragging/common/DraggingTypes';
+export interface PinchDragData {
+  readonly deltaX: number;
+  readonly deltaY: number;
+  readonly deltaDistance: number;
+}
+export interface PinchingBehaviour extends Behaviour.AlloyBehaviour<PinchingConfigSpec, PinchingConfig> {
+  readonly config: (config: PinchingConfigSpec) => Behaviour.NamedConfiguredBehaviour<PinchingConfigSpec, PinchingConfig>;
+}
+export interface PinchingConfig extends Behaviour.BehaviourConfigDetail {
+  readonly onPinch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
+  readonly onPunch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
+}
+export interface PinchingConfigSpec extends Behaviour.BehaviourConfigSpec {
+  readonly onPinch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
+  readonly onPunch: (element: SugarElement<HTMLElement>, changeX: number, changeY: number) => void;
+}
+export interface PinchingState extends BaseDraggingState<PinchDragData> { }

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/positioning/PositionApis.ts
@@ -0,0 +1,83 @@
+import { StructureSchema } from '@ephox/boulder';
+import { Arr, Fun, Optional, Optionals } from '@ephox/katamari';
+import { Css, SugarElement, SugarLocation } from '@ephox/sugar';
+import { Bounds, box } from '../../alien/Boxes';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AriaFocus from '../../aria/AriaFocus';
+import * as Anchor from '../../positioning/layout/Anchor';
+import { PlacerResult } from '../../positioning/layout/LayoutTypes';
+import * as Origins from '../../positioning/layout/Origins';
+import * as Placement from '../../positioning/layout/Placement';
+import * as SimpleLayout from '../../positioning/layout/SimpleLayout';
+import { Anchoring } from '../../positioning/mode/Anchoring';
+import { Transition } from '../../positioning/view/Transitions';
+import { PlacementDetail, PlacementSpec, PositioningConfig, PositioningState } from './PositioningTypes';
+import { PlacementSchema } from './PositionSchema';
+const getFixedOrigin = (): Origins.OriginAdt => {
+  const html = document.documentElement;
+  return Origins.fixed(0, 0, html.clientWidth, html.clientHeight);
+};
+const getRelativeOrigin = (component: AlloyComponent): Origins.OriginAdt => {
+  const position = SugarLocation.absolute(component.element);
+  const bounds = component.element.dom.getBoundingClientRect();
+  return Origins.relative(position.left, position.top, bounds.width, bounds.height);
+};
+const place = (component: AlloyComponent, origin: Origins.OriginAdt, anchoring: Anchoring, getBounds: Optional<() => Bounds>, placee: AlloyComponent, lastPlace: Optional<PlacerResult>, transition: Optional<Transition>): PlacerResult => {
+  const anchor = Anchor.box(anchoring.anchorBox, origin);
+  return SimpleLayout.simple(anchor, placee.element, anchoring.bubble, anchoring.layouts, lastPlace, getBounds, anchoring.overrides, transition);
+};
+const position = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec): void => {
+  positionWithin(component, posConfig, posState, placee, placementSpec, Optional.none());
+};
+const positionWithin = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>): void => {
+  const boundsBox = boxElement.map(box);
+  return positionWithinBounds(component, posConfig, posState, placee, placementSpec, boundsBox);
+};
+const positionWithinBounds = (component: AlloyComponent, posConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent, placementSpec: PlacementSpec, bounds: Optional<Bounds>): void => {
+  const placeeDetail: PlacementDetail = StructureSchema.asRawOrDie('placement.info', StructureSchema.objOf(PlacementSchema), placementSpec);
+  const anchorage = placeeDetail.anchor;
+  const element = placee.element;
+  const placeeState = posState.get(placee.uid);
+  AriaFocus.preserve(() => {
+    Css.set(element, 'position', 'fixed');
+    const oldVisibility = Css.getRaw(element, 'visibility');
+    Css.set(element, 'visibility', 'hidden');
+    const origin = posConfig.useFixed() ? getFixedOrigin() : getRelativeOrigin(component);
+    const placer = anchorage.placement;
+    const getBounds = bounds.map(Fun.constant).or(posConfig.getBounds);
+    placer(component, anchorage, origin).each((anchoring) => {
+      const doPlace = anchoring.placer.getOr(place);
+      const newState = doPlace(component, origin, anchoring, getBounds, placee, placeeState, placeeDetail.transition);
+      posState.set(placee.uid, newState);
+    });
+    oldVisibility.fold(() => {
+      Css.remove(element, 'visibility');
+    }, (vis) => {
+      Css.set(element, 'visibility', vis);
+    });
+    if (
+      Css.getRaw(element, 'left').isNone() &&
+      Css.getRaw(element, 'top').isNone() &&
+      Css.getRaw(element, 'right').isNone() &&
+      Css.getRaw(element, 'bottom').isNone() &&
+      Optionals.is(Css.getRaw(element, 'position'), 'fixed')
+    ) {
+      Css.remove(element, 'position');
+    }
+  }, element);
+};
+const getMode = (component: AlloyComponent, pConfig: PositioningConfig, _pState: PositioningState): string =>
+  pConfig.useFixed() ? 'fixed' : 'absolute';
+const reset = (component: AlloyComponent, pConfig: PositioningConfig, posState: PositioningState, placee: AlloyComponent): void => {
+  const element = placee.element;
+  Arr.each([ 'position', 'left', 'right', 'top', 'bottom' ], (prop) => Css.remove(element, prop));
+  Placement.reset(element);
+  posState.clear(placee.uid);
+};
+export {
+  position,
+  positionWithin,
+  positionWithinBounds,
+  getMode,
+  reset
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/positioning/PositioningTypes.ts
@@ -0,0 +1,46 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { PlacerResult } from '../../positioning/layout/LayoutTypes';
+import { AnchorDetail, AnchorSpec } from '../../positioning/mode/Anchoring';
+import { TransitionMode } from '../../positioning/view/Transitions';
+import { BehaviourState } from '../common/BehaviourState';
+interface TransitionSpec {
+  readonly classes: string[];
+  readonly mode?: TransitionMode;
+}
+interface TransitionDetail {
+  readonly classes: string[];
+  readonly mode: TransitionMode;
+}
+export interface PlacementSpec {
+  readonly anchor: AnchorSpec;
+  readonly transition?: TransitionSpec;
+}
+export interface PlacementDetail {
+  readonly anchor: AnchorDetail<any>;
+  readonly transition: Optional<TransitionDetail>;
+}
+export interface PositioningBehaviour extends Behaviour.AlloyBehaviour<PositioningConfigSpec, PositioningConfig> {
+  readonly config: (config: PositioningConfigSpec) => Behaviour.NamedConfiguredBehaviour<PositioningConfigSpec, PositioningConfig>;
+  readonly position: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec) => void;
+  readonly positionWithin: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => void;
+  readonly positionWithinBounds: (component: AlloyComponent, placee: AlloyComponent, spec: PlacementSpec, bounds: Optional<Bounds>) => void;
+  readonly getMode: (component: AlloyComponent) => string;
+  readonly reset: (component: AlloyComponent, placee: AlloyComponent) => void;
+}
+export interface PositioningConfigSpec extends Behaviour.BehaviourConfigSpec {
+  readonly useFixed?: () => boolean;
+  readonly getBounds?: () => Bounds;
+}
+export interface PositioningConfig extends Behaviour.BehaviourConfigDetail {
+  readonly useFixed: () => boolean;
+  readonly getBounds: Optional<() => Bounds>;
+}
+export interface PositioningState extends BehaviourState {
+  readonly clear: (id?: string) => void;
+  readonly get: (id: string) => Optional<PlacerResult>;
+  readonly set: (id: string, state: PlacerResult) => void;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ActiveReflecting.ts
@@ -0,0 +1,39 @@
+import { Arr } from '@ephox/katamari';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import * as SystemEvents from '../../api/events/SystemEvents';
+import { ReceivingEvent, ReceivingInternalEvent } from '../../events/SimulatedEvent';
+import { withoutReuse, withReuse } from '../replacing/ReplacingAll';
+import { ReflectingConfig, ReflectingState } from './ReflectingTypes';
+const events = <I, S>(reflectingConfig: ReflectingConfig<I, S>, reflectingState: ReflectingState<S>): AlloyEvents.AlloyEventRecord => {
+  const update = (component: AlloyComponent, data: I) => {
+    reflectingConfig.updateState.each((updateState) => {
+      const newState = updateState(component, data);
+      reflectingState.set(newState);
+    });
+    reflectingConfig.renderComponents.each((renderComponents) => {
+      const newComponents = renderComponents(data, reflectingState.get());
+      const replacer = reflectingConfig.reuseDom ? withReuse : withoutReuse;
+      replacer(component, newComponents);
+    });
+  };
+  return AlloyEvents.derive([
+    AlloyEvents.run<ReceivingEvent>(SystemEvents.receive(), (component, message) => {
+      const receivingData = message as unknown as ReceivingInternalEvent;
+      if (!receivingData.universal) {
+        const channel = reflectingConfig.channel;
+        if (Arr.contains(receivingData.channels, channel)) {
+          update(component, receivingData.data);
+        }
+      }
+    }),
+    AlloyEvents.runOnAttached((comp, _se) => {
+      reflectingConfig.initialData.each((rawData) => {
+        update(comp, rawData);
+      });
+    })
+  ]);
+};
+export {
+  events
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ReflectingSchema.ts
@@ -0,0 +1,8 @@
+import { FieldSchema } from '@ephox/boulder';
+export default [
+  FieldSchema.required('channel'),
+  FieldSchema.option('renderComponents'),
+  FieldSchema.option('updateState'),
+  FieldSchema.option('initialData'),
+  FieldSchema.defaultedBoolean('reuseDom', true)
+];

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/reflecting/ReflectingTypes.ts
@@ -0,0 +1,28 @@
+import { Optional } from '@ephox/katamari';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import { BehaviourState } from '../common/BehaviourState';
+export interface ReflectingBehaviour<I, S> extends Behaviour.AlloyBehaviour<ReflectingConfigSpec<I, S>, ReflectingConfig<I, S>> {
+  config: (config: ReflectingConfigSpec<I, S>) => Behaviour.NamedConfiguredBehaviour<ReflectingConfigSpec<I, S>, ReflectingConfig<I, S>>;
+  getState: (comp: AlloyComponent) => ReflectingState<S>;
+}
+export interface ReflectingConfigSpec<I, S> extends Behaviour.BehaviourConfigSpec {
+  channel: string;
+  renderComponents?: (data: I, state: Optional<S>) => AlloySpec[ ];
+  updateState?: (comp: AlloyComponent, data: I) => Optional<S>;
+  initialData?: I;
+  reuseDom?: boolean;
+}
+export interface ReflectingState<S> extends BehaviourState {
+  get: () => Optional<S>;
+  set: (optS: Optional<S>) => void;
+  clear: () => void;
+}
+export interface ReflectingConfig<I, S> extends Behaviour.BehaviourConfigDetail {
+  channel: string;
+  renderComponents: Optional<(data: I, state: Optional<S>) => AlloySpec[ ]>;
+  updateState: Optional<(comp: AlloyComponent, data: I) => Optional<S>>;
+  initialData: Optional<any>;
+  reuseDom: boolean;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplaceApis.ts
@@ -0,0 +1,66 @@
+import { Arr, Optional } from '@ephox/katamari';
+import { Compare, Insert, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import * as Attachment from '../../api/system/Attachment';
+import * as Patching from '../../dom/Patching';
+import * as InternalAttachment from '../../system/InternalAttachment';
+import { Stateless } from '../common/BehaviourState';
+import { withoutReuse, withReuse } from './ReplacingAll';
+import { ReplacingConfig } from './ReplacingTypes';
+const virtualReplace = (component: AlloyComponent, replacee: AlloyComponent, replaceeIndex: number, childSpec: AlloySpec) => {
+  InternalAttachment.virtualDetach(replacee);
+  const child = Patching.patchSpecChild(component.element, replaceeIndex, childSpec, component.getSystem().buildOrPatch);
+  InternalAttachment.virtualAttach(component, child);
+  component.syncComponents();
+};
+const insert = (component: AlloyComponent, insertion: (p: SugarElement<Node>, c: SugarElement<Node>) => void, childSpec: AlloySpec): void => {
+  const child = component.getSystem().build(childSpec);
+  Attachment.attachWith(component, child, insertion);
+};
+const replace = (component: AlloyComponent, replacee: AlloyComponent, replaceeIndex: number, childSpec: AlloySpec) => {
+  Attachment.detach(replacee);
+  insert(component, (p, c) => Insert.appendAt(p, c, replaceeIndex), childSpec);
+};
+const set = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, data: AlloySpec[]): void => {
+  const replacer = replaceConfig.reuseDom ? withReuse : withoutReuse;
+  return replacer(component, data);
+};
+const append = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, appendee: AlloySpec): void => {
+  insert(component, Insert.append, appendee);
+};
+const prepend = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, prependee: AlloySpec): void => {
+  insert(component, Insert.prepend, prependee);
+};
+const remove = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, removee: AlloyComponent): void => {
+  const children = contents(component, replaceConfig);
+  const foundChild = Arr.find(children, (child) => Compare.eq(removee.element, child.element));
+  foundChild.each(Attachment.detach);
+};
+const contents = (component: AlloyComponent, _replaceConfig: ReplacingConfig): AlloyComponent[] => component.components();
+const replaceAt = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, replaceeIndex: number, replacer: Optional<AlloySpec>): Optional<AlloyComponent> => {
+  const children = contents(component, replaceConfig);
+  return Optional.from(children[replaceeIndex]).map((replacee) => {
+    replacer.fold(
+      () => Attachment.detach(replacee),
+      (r) => {
+        const replacer = replaceConfig.reuseDom ? virtualReplace : replace;
+        replacer(component, replacee, replaceeIndex, r);
+      }
+    );
+    return replacee;
+  });
+};
+const replaceBy = (component: AlloyComponent, replaceConfig: ReplacingConfig, replaceState: Stateless, replaceePred: (comp: AlloyComponent) => boolean, replacer: Optional<AlloySpec>): Optional<AlloyComponent> => {
+  const children = contents(component, replaceConfig);
+  return Arr.findIndex(children, replaceePred).bind((replaceeIndex) => replaceAt(component, replaceConfig, replaceState, replaceeIndex, replacer));
+};
+export {
+  append,
+  prepend,
+  remove,
+  replaceAt,
+  replaceBy,
+  set,
+  contents
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplacingAll.ts
@@ -0,0 +1,26 @@
+import { Arr } from '@ephox/katamari';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import * as AriaFocus from '../../aria/AriaFocus';
+import { patchSpecChildren } from '../../dom/Patching';
+import * as InternalAttachment from '../../system/InternalAttachment';
+const withoutReuse = (parent: AlloyComponent, data: AlloySpec[]): void => {
+  AriaFocus.preserve(() => {
+    InternalAttachment.replaceChildren(parent, data, () => Arr.map(data, parent.getSystem().build));
+  }, parent.element);
+};
+const withReuse = (parent: AlloyComponent, data: AlloySpec[]): void => {
+  AriaFocus.preserve(() => {
+    InternalAttachment.virtualReplaceChildren(parent, data, () => {
+      return patchSpecChildren(
+        parent.element,
+        data,
+        parent.getSystem().buildOrPatch
+      );
+    });
+  }, parent.element);
+};
+export {
+  withoutReuse,
+  withReuse
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/replacing/ReplacingTypes.ts
@@ -0,0 +1,20 @@
+import { Optional } from '@ephox/katamari';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+export interface ReplacingBehaviour extends Behaviour.AlloyBehaviour<ReplacingConfigSpec, ReplacingConfig> {
+  config: (config: ReplacingConfigSpec) => Behaviour.NamedConfiguredBehaviour<ReplacingConfigSpec, ReplacingConfig>;
+  append: (component: AlloyComponent, appendee: AlloySpec) => void;
+  prepend: (component: AlloyComponent, prependee: AlloySpec) => void;
+  remove: (component: AlloyComponent, removee: AlloyComponent) => void;
+  replaceAt: (component: AlloyComponent, replaceeIndex: number, replacer: Optional<AlloySpec>) => Optional<AlloyComponent>;
+  replaceBy: (component: AlloyComponent, replaceePred: (comp: AlloyComponent) => boolean, replacer: Optional<AlloySpec>) => Optional<AlloyComponent>;
+  set: (component: AlloyComponent, data: AlloySpec[]) => void;
+  contents: (component: AlloyComponent) => AlloyComponent[];
+}
+export interface ReplacingConfigSpec extends Behaviour.BehaviourConfigSpec {
+  reuseDom?: boolean;
+}
+export interface ReplacingConfig extends Behaviour.BehaviourConfigDetail {
+  reuseDom: boolean;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sandboxing/SandboxApis.ts
@@ -0,0 +1,87 @@
+import { Arr, Optional } from '@ephox/katamari';
+import { Attribute, Css, SugarElement } from '@ephox/sugar';
+import { Positioning } from '../../api/behaviour/Positioning';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import * as Attachment from '../../api/system/Attachment';
+import { SandboxingConfig, SandboxingState } from './SandboxingTypes';
+const rebuild = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): AlloyComponent => {
+  sState.get().each((_data) => {
+    Attachment.detachChildren(sandbox);
+  });
+  const point = sConfig.getAttachPoint(sandbox);
+  Attachment.attach(point, sandbox);
+  const built = sandbox.getSystem().build(data);
+  Attachment.attach(sandbox, built);
+  sState.set(built);
+  return built;
+};
+const open = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): AlloyComponent => {
+  const newState = rebuild(sandbox, sConfig, sState, data);
+  sConfig.onOpen(sandbox, newState);
+  return newState;
+};
+const setContent = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec): Optional<AlloyComponent> =>
+  sState.get().map(() => rebuild(sandbox, sConfig, sState, data));
+const openWhileCloaked = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, data: AlloySpec, transaction: () => void): void => {
+  cloak(sandbox, sConfig, sState);
+  open(sandbox, sConfig, sState, data);
+  transaction();
+  decloak(sandbox, sConfig, sState);
+};
+const close = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState): void => {
+  sState.get().each((data) => {
+    Attachment.detachChildren(sandbox);
+    Attachment.detach(sandbox);
+    sConfig.onClose(sandbox, data);
+    sState.clear();
+  });
+};
+const isOpen = (_sandbox: AlloyComponent, _sConfig: SandboxingConfig, sState: SandboxingState): boolean =>
+  sState.isOpen();
+const isPartOf = (sandbox: AlloyComponent, sConfig: SandboxingConfig, sState: SandboxingState, queryElem: SugarElement<Node>): boolean =>
+  isOpen(sandbox, sConfig, sState) && sState.get().exists(
+    (data) => sConfig.isPartOf(sandbox, data, queryElem)
+  );
+const getState = (_sandbox: AlloyComponent, _sConfig: SandboxingConfig, sState: SandboxingState): Optional<AlloyComponent> =>
+  sState.get();
+const store = (sandbox: AlloyComponent, cssKey: string, attr: string, newValue: string): void => {
+  Css.getRaw(sandbox.element, cssKey).fold(() => {
+    Attribute.remove(sandbox.element, attr);
+  }, (v) => {
+    Attribute.set(sandbox.element, attr, v);
+  });
+  Css.set(sandbox.element, cssKey, newValue);
+};
+const restore = (sandbox: AlloyComponent, cssKey: string, attr: string): void => {
+  Attribute.getOpt(sandbox.element, attr).fold(
+    () => Css.remove(sandbox.element, cssKey),
+    (oldValue) => Css.set(sandbox.element, cssKey, oldValue)
+  );
+};
+const cloak = (sandbox: AlloyComponent, sConfig: SandboxingConfig, _sState: SandboxingState): void => {
+  const sink = sConfig.getAttachPoint(sandbox);
+  Css.set(sandbox.element, 'position', Positioning.getMode(sink));
+  store(sandbox, 'visibility', sConfig.cloakVisibilityAttr, 'hidden');
+};
+const hasPosition = (element: SugarElement<HTMLElement>): boolean => Arr.exists(
+  [ 'top', 'left', 'right', 'bottom' ],
+  (pos) => Css.getRaw(element, pos).isSome()
+);
+const decloak = (sandbox: AlloyComponent, sConfig: SandboxingConfig, _sState: SandboxingState): void => {
+  if (!hasPosition(sandbox.element)) {
+    Css.remove(sandbox.element, 'position');
+  }
+  restore(sandbox, 'visibility', sConfig.cloakVisibilityAttr);
+};
+export {
+  cloak,
+  decloak,
+  open,
+  openWhileCloaked,
+  close,
+  isOpen,
+  isPartOf,
+  getState,
+  setContent
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sandboxing/SandboxingTypes.ts
@@ -0,0 +1,39 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import { BehaviourState } from '../common/BehaviourState';
+export interface SandboxingBehaviour extends Behaviour.AlloyBehaviour<SandboxingConfigSpec, SandboxingConfig> {
+  config: (config: SandboxingConfigSpec) => Behaviour.NamedConfiguredBehaviour<SandboxingConfigSpec, SandboxingConfig>;
+  cloak: (sandbox: AlloyComponent) => void;
+  decloak: (sandbox: AlloyComponent) => void;
+  open: (sandbox: AlloyComponent, thing: AlloySpec) => AlloyComponent;
+  openWhileCloaked: (sandbox: AlloyComponent, thing: AlloySpec, transaction: () => void) => AlloyComponent;
+  close: (sandbox: AlloyComponent) => void;
+  isOpen: (sandbox: AlloyComponent) => boolean;
+  isPartOf: (sandbox: AlloyComponent, candidate: SugarElement<Node>) => boolean;
+  getState: (sandbox: AlloyComponent) => Optional<AlloyComponent>;
+  setContent: (sandbox: AlloyComponent, thing: AlloySpec) => Optional<AlloyComponent>;
+  closeSandbox: (sandbox: AlloyComponent) => void;
+}
+export interface SandboxingConfigSpec extends Behaviour.BehaviourConfigSpec {
+  getAttachPoint: (sandbox: AlloyComponent) => AlloyComponent;
+  isPartOf: (sandbox: AlloyComponent, data: AlloyComponent, queryElem: SugarElement<Node>) => boolean;
+  onOpen?: (sandbox: AlloyComponent, menu: AlloyComponent) => void;
+  onClose?: (sandbox: AlloyComponent, menu: AlloyComponent) => void;
+  cloakVisibilityAttr?: string;
+}
+export interface SandboxingConfig extends Behaviour.BehaviourConfigDetail {
+  cloakVisibilityAttr: string;
+  getAttachPoint: (sandbox: AlloyComponent) => AlloyComponent;
+  onOpen: (sandbox: AlloyComponent, thing: AlloyComponent) => void;
+  onClose: (sandbox: AlloyComponent, thing: AlloyComponent) => void;
+  isPartOf: (sandbox: AlloyComponent, data: AlloyComponent, queryElem: SugarElement<Node>) => boolean;
+}
+export interface SandboxingState extends BehaviourState {
+  get: () => Optional<AlloyComponent>;
+  set: (comp: AlloyComponent) => void;
+  isOpen: () => boolean;
+  clear: () => void;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingApis.ts
@@ -0,0 +1,124 @@
+import { Optional } from '@ephox/katamari';
+import { Class, Classes, Css, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SlidingConfig, SlidingState } from './SlidingTypes';
+import { getAnimationRoot } from './SlidingUtils';
+const getDimensionProperty = (slideConfig: SlidingConfig): string =>
+  slideConfig.dimension.property;
+const getDimension = (slideConfig: SlidingConfig, elem: SugarElement<HTMLElement>): string =>
+  slideConfig.dimension.getDimension(elem);
+const disableTransitions = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
+  const root = getAnimationRoot(component, slideConfig);
+  Classes.remove(root, [ slideConfig.shrinkingClass, slideConfig.growingClass ]);
+};
+const setShrunk = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
+  Class.remove(component.element, slideConfig.openClass);
+  Class.add(component.element, slideConfig.closedClass);
+  Css.set(component.element, getDimensionProperty(slideConfig), '0px');
+  Css.reflow(component.element);
+};
+const setGrown = (component: AlloyComponent, slideConfig: SlidingConfig): void => {
+  Class.remove(component.element, slideConfig.closedClass);
+  Class.add(component.element, slideConfig.openClass);
+  Css.remove(component.element, getDimensionProperty(slideConfig));
+};
+const doImmediateShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState, _calculatedSize: Optional<string>): void => {
+  slideState.setCollapsed();
+  Css.set(component.element, getDimensionProperty(slideConfig), getDimension(slideConfig, component.element));
+  Css.reflow(component.element);
+  disableTransitions(component, slideConfig);
+  setShrunk(component, slideConfig);
+  slideConfig.onStartShrink(component);
+  slideConfig.onShrunk(component);
+};
+const doStartShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState, calculatedSize: Optional<string>): void => {
+  const size = calculatedSize.getOrThunk(() => getDimension(slideConfig, component.element));
+  slideState.setCollapsed();
+  Css.set(component.element, getDimensionProperty(slideConfig), size);
+  Css.reflow(component.element);
+  const root = getAnimationRoot(component, slideConfig);
+  Class.remove(root, slideConfig.growingClass);
+  Class.add(root, slideConfig.shrinkingClass); // enable transitions
+  setShrunk(component, slideConfig);
+  slideConfig.onStartShrink(component);
+};
+const doStartSmartShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  const size: string = getDimension(slideConfig, component.element);
+  const shrinker = size === '0px' ? doImmediateShrink : doStartShrink;
+  shrinker(component, slideConfig, slideState, Optional.some(size));
+};
+const doStartGrow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  const root = getAnimationRoot(component, slideConfig);
+  const wasShrinking = Class.has(root, slideConfig.shrinkingClass);
+  const beforeSize = getDimension(slideConfig, component.element);
+  setGrown(component, slideConfig);
+  const fullSize = getDimension(slideConfig, component.element);
+  const startPartialGrow = () => {
+    Css.set(component.element, getDimensionProperty(slideConfig), beforeSize);
+    Css.reflow(component.element);
+  };
+  const startCompleteGrow = () => {
+    setShrunk(component, slideConfig);
+  };
+  const setStartSize = wasShrinking ? startPartialGrow : startCompleteGrow;
+  setStartSize();
+  Class.remove(root, slideConfig.shrinkingClass);
+  Class.add(root, slideConfig.growingClass);
+  setGrown(component, slideConfig);
+  Css.set(component.element, getDimensionProperty(slideConfig), fullSize);
+  slideState.setExpanded();
+  slideConfig.onStartGrow(component);
+};
+const refresh = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  if (slideState.isExpanded()) {
+    Css.remove(component.element, getDimensionProperty(slideConfig));
+    const fullSize = getDimension(slideConfig, component.element);
+    Css.set(component.element, getDimensionProperty(slideConfig), fullSize);
+  }
+};
+const grow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  if (!slideState.isExpanded()) {
+    doStartGrow(component, slideConfig, slideState);
+  }
+};
+const shrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  if (slideState.isExpanded()) {
+    doStartSmartShrink(component, slideConfig, slideState);
+  }
+};
+const immediateShrink = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  if (slideState.isExpanded()) {
+    doImmediateShrink(component, slideConfig, slideState, Optional.none());
+  }
+};
+const hasGrown = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
+  slideState.isExpanded();
+const hasShrunk = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
+  slideState.isCollapsed();
+const isGrowing = (component: AlloyComponent, slideConfig: SlidingConfig, _slideState: SlidingState): boolean => {
+  const root = getAnimationRoot(component, slideConfig);
+  return Class.has(root, slideConfig.growingClass) === true;
+};
+const isShrinking = (component: AlloyComponent, slideConfig: SlidingConfig, _slideState: SlidingState): boolean => {
+  const root = getAnimationRoot(component, slideConfig);
+  return Class.has(root, slideConfig.shrinkingClass) === true;
+};
+const isTransitioning = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): boolean =>
+  isGrowing(component, slideConfig, slideState) || isShrinking(component, slideConfig, slideState);
+const toggleGrow = (component: AlloyComponent, slideConfig: SlidingConfig, slideState: SlidingState): void => {
+  const f = slideState.isExpanded() ? doStartSmartShrink : doStartGrow;
+  f(component, slideConfig, slideState);
+};
+export {
+  refresh,
+  grow,
+  shrink,
+  immediateShrink,
+  hasGrown,
+  hasShrunk,
+  isGrowing,
+  isShrinking,
+  isTransitioning,
+  toggleGrow,
+  disableTransitions
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingSchema.ts
@@ -0,0 +1,27 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Height, SugarElement, Width } from '@ephox/sugar';
+import * as Fields from '../../data/Fields';
+export default [
+  FieldSchema.required('closedClass'),
+  FieldSchema.required('openClass'),
+  FieldSchema.required('shrinkingClass'),
+  FieldSchema.required('growingClass'),
+  FieldSchema.option('getAnimationRoot'),
+  Fields.onHandler('onShrunk'),
+  Fields.onHandler('onStartShrink'),
+  Fields.onHandler('onGrown'),
+  Fields.onHandler('onStartGrow'),
+  FieldSchema.defaulted('expanded', false),
+  FieldSchema.requiredOf('dimension', StructureSchema.choose(
+    'property', {
+      width: [
+        Fields.output('property', 'width'),
+        Fields.output('getDimension', (elem: SugarElement<HTMLElement>) => Width.get(elem) + 'px')
+      ],
+      height: [
+        Fields.output('property', 'height'),
+        Fields.output('getDimension', (elem: SugarElement<HTMLElement>) => Height.get(elem) + 'px')
+      ]
+    }
+  ))
+];

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingTypes.ts
@@ -0,0 +1,56 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { BehaviourState } from '../common/BehaviourState';
+export interface SlidingBehaviour extends Behaviour.AlloyBehaviour<SlidingConfigSpec, SlidingConfig> {
+  config: (config: SlidingConfigSpec) => Behaviour.NamedConfiguredBehaviour<SlidingConfigSpec, SlidingConfig>;
+  refresh: (component: AlloyComponent) => void;
+  grow: (component: AlloyComponent) => void;
+  shrink: (component: AlloyComponent) => void;
+  immediateShrink: (component: AlloyComponent) => void;
+  hasGrown: (component: AlloyComponent) => boolean;
+  hasShrunk: (component: AlloyComponent) => boolean;
+  isGrowing: (component: AlloyComponent) => boolean;
+  isShrinking: (component: AlloyComponent) => boolean;
+  isTransitioning: (component: AlloyComponent) => boolean;
+  toggleGrow: (component: AlloyComponent) => void;
+  disableTransitions: (component: AlloyComponent) => void;
+}
+export interface SlidingConfig extends Behaviour.BehaviourConfigDetail {
+  expanded: boolean;
+  openClass: string;
+  closedClass: string;
+  dimension: {
+    property: string;
+    getDimension: (elem: SugarElement<HTMLElement>) => string;
+  };
+  onGrown: (comp: AlloyComponent) => void;
+  onShrunk: (comp: AlloyComponent) => void;
+  shrinkingClass: string;
+  growingClass: string;
+  onStartGrow: (comp: AlloyComponent) => void;
+  onStartShrink: (comp: AlloyComponent) => void;
+  getAnimationRoot: Optional<(comp: AlloyComponent) => SugarElement<Element>>;
+}
+export interface SlidingState extends BehaviourState {
+  isExpanded: () => boolean;
+  setExpanded: () => void;
+  isCollapsed: () => boolean;
+  setCollapsed: () => void;
+}
+export interface SlidingConfigSpec extends Behaviour.BehaviourConfigSpec {
+  dimension: {
+    property: string;
+  };
+  closedClass: string;
+  openClass: string;
+  shrinkingClass: string;
+  growingClass: string;
+  onStartGrow?: (component: AlloyComponent) => void;
+  getAnimationRoot?: (component: AlloyComponent) => SugarElement<Element>;
+  onStartShrink?: (component: AlloyComponent) => void;
+  onShrunk?: (component: AlloyComponent) => void;
+  onGrown?: (component: AlloyComponent) => void;
+  expanded?: boolean;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/sliding/SlidingUtils.ts
@@ -0,0 +1,8 @@
+import { SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SlidingConfig } from './SlidingTypes';
+export const getAnimationRoot = (component: AlloyComponent, slideConfig: SlidingConfig): SugarElement<Element> =>
+  slideConfig.getAnimationRoot.fold(
+    () => component.element,
+    (get) => get(component)
+  );

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/behaviour/swapping/SwapApis.ts
@@ -0,0 +1,29 @@
+import { Class, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { Stateless } from '../common/BehaviourState';
+import { SwappingConfig } from './SwappingTypes';
+const swap = (element: SugarElement<Element>, addCls: string, removeCls: string): void => {
+  Class.remove(element, removeCls);
+  Class.add(element, addCls);
+};
+const toAlpha = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
+  swap(component.element, swapConfig.alpha, swapConfig.omega);
+};
+const toOmega = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
+  swap(component.element, swapConfig.omega, swapConfig.alpha);
+};
+const clear = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): void => {
+  Class.remove(component.element, swapConfig.alpha);
+  Class.remove(component.element, swapConfig.omega);
+};
+const isAlpha = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): boolean =>
+  Class.has(component.element, swapConfig.alpha);
+const isOmega = (component: AlloyComponent, swapConfig: SwappingConfig, _swapState: Stateless): boolean =>
+  Class.has(component.element, swapConfig.omega);
+export {
+  toAlpha,
+  toOmega,
+  isAlpha,
+  isOmega,
+  clear
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/debugging/Debugging.ts
@@ -0,0 +1,211 @@
+import { Objects } from '@ephox/boulder';
+import { Arr, Cell, Fun, Global, Obj, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as SystemEvents from '../api/events/SystemEvents';
+import { GuiSystem } from '../api/system/Gui';
+import * as AlloyLogger from '../log/AlloyLogger';
+export interface DebuggerLogger {
+  logEventCut: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
+  logEventStopped: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
+  logNoParent: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
+  logEventNoHandlers: (eventName: string, target: SugarElement<Node>) => void;
+  logEventResponse: (eventName: string, target: SugarElement<Node>, purpose: string) => void;
+  write: () => void;
+}
+export interface InspectorInfo {
+  '(original.spec)': any;
+  '(dom.ref)': Node;
+  '(element)': string;
+  '(initComponents)': InspectorInfo[];
+  '(components)': InspectorInfo[];
+  '(bound.events)': string;
+  '(behaviours)': string | Record<string, any>;
+}
+type LookupInfo = { [key: string]: InspectorInfo } | { error: string };
+export interface Inspector {
+  systems: Record<string, GuiSystem>;
+  lookup: (uid: string) => Optional<LookupInfo>;
+  events: {
+    setToNormal: (eventName: string) => void;
+    setToLogging: (eventName: string) => void;
+    setToStop: (eventName: string) => void;
+  };
+}
+interface AlloyGlobal {
+  __CHROME_INSPECTOR_CONNECTION_TO_ALLOY__: Inspector;
+}
+const unknown = 'unknown';
+/*
+  typescipt qwerk:
+  const debugging: boolean = true;
+  if (boolean === false) {  -> this throws a type error! // TS2365:Operator '===' cannot be applied to types 'false' and 'true'
+    https://www.typescriptlang.org/play/#src=const%20foo%3A%20boolean%20%3D%20true%3B%0D%0A%0D%0Aif%20(foo%20%3D%3D%3D%20false)%20%7B%0D%0A%20%20%20%20%0D%0A%7D
+  }
+*/
+const debugging: any = true;
+const CHROME_INSPECTOR_GLOBAL = '__CHROME_INSPECTOR_CONNECTION_TO_ALLOY__';
+enum EventConfiguration {
+  STOP,
+  NORMAL,
+  LOGGING
+}
+const eventConfig = Cell<Record<string, EventConfiguration>>({ });
+export type EventProcessor = (logger: DebuggerLogger) => boolean;
+const makeEventLogger = (eventName: string, initialTarget: SugarElement<Node>): DebuggerLogger => {
+  const sequence: Array<{ outcome: string; target: SugarElement<Node>; purpose?: string }> = [ ];
+  const startTime = new Date().getTime();
+  return {
+    logEventCut: (_name: string, target: SugarElement<Node>, purpose: string) => {
+      sequence.push({ outcome: 'cut', target, purpose });
+    },
+    logEventStopped: (_name: string, target: SugarElement<Node>, purpose: string) => {
+      sequence.push({ outcome: 'stopped', target, purpose });
+    },
+    logNoParent: (_name: string, target: SugarElement<Node>, purpose: string) => {
+      sequence.push({ outcome: 'no-parent', target, purpose });
+    },
+    logEventNoHandlers: (_name: string, target: SugarElement<Node>) => {
+      sequence.push({ outcome: 'no-handlers-left', target });
+    },
+    logEventResponse: (_name: string, target: SugarElement<Node>, purpose: string) => {
+      sequence.push({ outcome: 'response', purpose, target });
+    },
+    write: () => {
+      const finishTime = new Date().getTime();
+      if (Arr.contains([ 'mousemove', 'mouseover', 'mouseout', SystemEvents.systemInit() ], eventName)) {
+        return;
+      }
+      console.log(eventName, {
+        event: eventName,
+        time: finishTime - startTime,
+        target: initialTarget.dom,
+        sequence: Arr.map(sequence, (s) => {
+          if (!Arr.contains([ 'cut', 'stopped', 'response' ], s.outcome)) {
+            return s.outcome;
+          } else {
+            return '{' + s.purpose + '} ' + s.outcome + ' at (' + AlloyLogger.element(s.target) + ')';
+          }
+        })
+      });
+    }
+  };
+};
+const processEvent = (eventName: string, initialTarget: SugarElement<Node>, f: EventProcessor) => {
+  const status = Obj.get(eventConfig.get(), eventName).orThunk(() => {
+    const patterns = Obj.keys(eventConfig.get());
+    return Arr.findMap(patterns, (p) => eventName.indexOf(p) > -1 ? Optional.some(eventConfig.get()[p]) : Optional.none());
+  }).getOr(
+    EventConfiguration.NORMAL
+  );
+  switch (status) {
+    case EventConfiguration.NORMAL:
+      return f(noLogger());
+    case EventConfiguration.LOGGING: {
+      const logger = makeEventLogger(eventName, initialTarget);
+      const output = f(logger);
+      logger.write();
+      return output;
+    }
+    case EventConfiguration.STOP:
+      return true;
+  }
+};
+const path = [
+  'alloy/data/Fields',
+  'alloy/debugging/Debugging'
+];
+const getTrace = (): string => {
+  if (debugging === false) {
+    return unknown;
+  }
+  const err = new Error();
+  if (err.stack !== undefined) {
+    const lines = err.stack.split('\n');
+    return Arr.find(lines, (line) => line.indexOf('alloy') > 0 && !Arr.exists(path, (p) => line.indexOf(p) > -1)).getOr(unknown);
+  } else {
+    return unknown;
+  }
+};
+const logHandler = (_label: string, _handlerName: string, _trace: any): void => {
+};
+const ignoreEvent = {
+  logEventCut: Fun.noop,
+  logEventStopped: Fun.noop,
+  logNoParent: Fun.noop,
+  logEventNoHandlers: Fun.noop,
+  logEventResponse: Fun.noop,
+  write: Fun.noop
+};
+const monitorEvent = (eventName: string, initialTarget: SugarElement<Node>, f: EventProcessor): boolean =>
+  processEvent(eventName, initialTarget, f);
+const inspectorInfo = (comp: AlloyComponent) => {
+  const go = (c: AlloyComponent): InspectorInfo => {
+    const cSpec = c.spec;
+    return {
+      '(original.spec)': cSpec,
+      '(dom.ref)': c.element.dom,
+      '(element)': AlloyLogger.element(c.element),
+      '(initComponents)': Arr.map(cSpec.components !== undefined ? cSpec.components : [ ], go),
+      '(components)': Arr.map(c.components(), go),
+      '(bound.events)': Obj.mapToArray(c.events, (_v, k) => [ k ]).join(', '),
+      '(behaviours)': cSpec.behaviours !== undefined ? Obj.map(cSpec.behaviours, (v, k) => v === undefined ? '--revoked--' : {
+        'config': v.configAsRaw(),
+        'original-config': v.initialConfig,
+        'state': c.readState(k)
+      }) : 'none'
+    };
+  };
+  return go(comp);
+};
+const getOrInitConnection = (): Inspector => {
+  const win: AlloyGlobal = Global;
+  if (win[CHROME_INSPECTOR_GLOBAL] !== undefined) {
+    return win[CHROME_INSPECTOR_GLOBAL];
+  } else {
+    const setEventStatus = (eventName: string, status: EventConfiguration) => {
+      const evs = eventConfig.get();
+      evs[eventName] = status;
+      eventConfig.set(evs);
+    };
+    win[CHROME_INSPECTOR_GLOBAL] = {
+      systems: { },
+      lookup: (uid: string) => {
+        const systems = win[CHROME_INSPECTOR_GLOBAL].systems;
+        const connections: string[] = Obj.keys(systems);
+        return Arr.findMap(connections, (conn) => {
+          const connGui = systems[conn];
+          return connGui.getByUid(uid).toOptional().map((comp): LookupInfo => Objects.wrap(AlloyLogger.element(comp.element), inspectorInfo(comp)));
+        }).orThunk(() => Optional.some<LookupInfo>({
+          error: 'Systems (' + connections.join(', ') + ') did not contain uid: ' + uid
+        }));
+      },
+      events: {
+        setToNormal: (eventName: string) => {
+          setEventStatus(eventName, EventConfiguration.NORMAL);
+        },
+        setToLogging: (eventName: string) => {
+          setEventStatus(eventName, EventConfiguration.LOGGING);
+        },
+        setToStop: (eventName: string) => {
+          setEventStatus(eventName, EventConfiguration.STOP);
+        }
+      }
+    };
+    return win[CHROME_INSPECTOR_GLOBAL];
+  }
+};
+const registerInspector = (name: string, gui: GuiSystem): void => {
+  const connection = getOrInitConnection();
+  connection.systems[name] = gui;
+};
+const noLogger = Fun.constant(ignoreEvent);
+const isDebugging = Fun.constant(debugging);
+export {
+  logHandler,
+  noLogger,
+  getTrace,
+  monitorEvent,
+  isDebugging,
+  registerInspector
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dom/DomDefinition.ts
@@ -0,0 +1,44 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+export interface GeneralDefinitionSpec<EC> {
+  uid: string;
+  tag?: string;
+  attributes?: Record<string, any>;
+  classes?: string[];
+  styles?: Record<string, string>;
+  value?: any;
+  innerHtml?: string;
+  domChildren?: EC;
+}
+export interface DomDefinitionSpec extends GeneralDefinitionSpec<SugarElement<Node>> {
+}
+export interface GeneralDefinitionDetail<EC> {
+  uid: string;
+  tag: string;
+  attributes: Record<string, any>;
+  classes: string[];
+  styles: Record<string, string>;
+  value: Optional<any>;
+  innerHtml: Optional<string>;
+  domChildren: EC[];
+}
+export interface DomDefinitionDetail extends GeneralDefinitionDetail<SugarElement<Node>> {
+}
+const defToStr = <EC>(defn: GeneralDefinitionDetail<EC>): string => {
+  const raw = defToRaw(defn);
+  return JSON.stringify(raw, null, 2);
+};
+const defToRaw = <EC>(defn: GeneralDefinitionDetail<EC>): GeneralDefinitionSpec<string> => ({
+  uid: defn.uid,
+  tag: defn.tag,
+  classes: defn.classes,
+  attributes: defn.attributes,
+  styles: defn.styles,
+  value: defn.value.getOr('<none>'),
+  innerHtml: defn.innerHtml.getOr('<none>'),
+  domChildren: defn.domChildren.length === 0 ? '0 children, but still specified' : String(defn.domChildren.length)
+});
+export {
+  defToStr,
+  defToRaw
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dom/DomRender.ts
@@ -0,0 +1,42 @@
+import { Optional } from '@ephox/katamari';
+import { Attribute, Classes, Css, Html, InsertAll, SugarElement, SugarNode, Value } from '@ephox/sugar';
+import { isPremade } from '../api/ui/GuiTypes';
+import * as Tagger from '../registry/Tagger';
+import * as DomDefinition from './DomDefinition';
+import { reconcileToDom } from './Reconcile';
+const introduceToDom = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>): SugarElement<HTMLElement> => {
+  const subject = SugarElement.fromTag(definition.tag);
+  Attribute.setAll(subject, definition.attributes);
+  Classes.add(subject, definition.classes);
+  Css.setAll(subject, definition.styles);
+  definition.innerHtml.each((html) => Html.set(subject, html));
+  const children = definition.domChildren;
+  InsertAll.append(subject, children);
+  definition.value.each((value) => {
+    Value.set(subject as SugarElement<HTMLInputElement | HTMLTextAreaElement>, value);
+  });
+  return subject;
+};
+const attemptPatch = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>, obsoleted: SugarElement<Element>): Optional<SugarElement<Element>> => {
+  try {
+    const e = reconcileToDom(definition, obsoleted);
+    return Optional.some(e);
+  } catch (err) {
+    return Optional.none();
+  }
+};
+const hasMixedChildren = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>) =>
+  definition.innerHtml.isSome() && definition.domChildren.length > 0;
+const renderToDom = (definition: DomDefinition.GeneralDefinitionDetail<SugarElement<Node>>, optObsoleted: Optional<SugarElement<Node>>): SugarElement<Element> => {
+  const canBePatched = (candidate: SugarElement<Node>): candidate is SugarElement<Element> =>
+    SugarNode.name(candidate) === definition.tag && !hasMixedChildren(definition) && !isPremade(candidate);
+  const elem = optObsoleted
+    .filter(canBePatched)
+    .bind((obsoleted) => attemptPatch(definition, obsoleted))
+    .getOrThunk(() => introduceToDom(definition));
+  Tagger.writeOnly(elem, definition.uid);
+  return elem;
+};
+export {
+  renderToDom
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dom/Patching.ts
@@ -0,0 +1,59 @@
+import { Arr, Optional } from '@ephox/katamari';
+import { Compare, Insert, Remove, SugarElement, SugarNode, Traverse } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { AlloySpec } from '../api/component/SpecTypes';
+type SpecBuilder = (spec: AlloySpec, optObs: Optional<SugarElement<Node>>) => AlloyComponent;
+const determineObsoleted = (parent: SugarElement<Element>, index: number, oldObsoleted: Optional<SugarElement<Node>>): Optional<SugarElement<Node>> => {
+  const newObsoleted = Traverse.child(parent, index);
+  return newObsoleted.map((newObs) => {
+    const elemChanged = oldObsoleted.exists((o) => !Compare.eq(o, newObs));
+    if (elemChanged) {
+      const oldTag = oldObsoleted.map(SugarNode.name).getOr('span');
+      const marker = SugarElement.fromTag(oldTag);
+      Insert.before(newObs, marker);
+      return marker;
+    } else {
+      return newObs;
+    }
+  });
+};
+const ensureInDom = (parent: SugarElement<Element>, child: SugarElement<Node>, obsoleted: Optional<SugarElement<Node>>): void => {
+  obsoleted.fold(
+    () => Insert.append(parent, child),
+    (obs) => {
+      if (!Compare.eq(obs, child)) {
+        Insert.before(obs, child);
+        Remove.remove(obs);
+      } else {
+      }
+    }
+  );
+};
+const patchChildrenWith = <T, C>(parent: SugarElement<Element>, nu: T[], f: (n: T, i: number) => C) => {
+  const builtChildren = Arr.map(nu, f);
+  const currentChildren = Traverse.children(parent);
+  Arr.each(currentChildren.slice(builtChildren.length), Remove.remove);
+  return builtChildren;
+};
+const patchSpecChild = (parent: SugarElement<Element>, index: number, spec: AlloySpec, build: SpecBuilder): AlloyComponent => {
+  const oldObsoleted = Traverse.child(parent, index);
+  const childComp = build(spec, oldObsoleted);
+  const obsoleted = determineObsoleted(parent, index, oldObsoleted);
+  ensureInDom(parent, childComp.element, obsoleted);
+  return childComp;
+};
+const patchSpecChildren = (parent: SugarElement<Element>, specs: AlloySpec[], build: SpecBuilder): AlloyComponent[] =>
+  patchChildrenWith(parent, specs, (spec, index) =>
+    patchSpecChild(parent, index, spec, build)
+  );
+const patchDomChildren = (parent: SugarElement<Element>, nodes: SugarElement<Node>[]): SugarElement<Node>[] =>
+  patchChildrenWith(parent, nodes, (node, index) => {
+    const optObsoleted = Traverse.child(parent, index);
+    ensureInDom(parent, node, optObsoleted);
+    return node;
+  });
+export {
+  patchDomChildren,
+  patchSpecChild,
+  patchSpecChildren
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dom/Reconcile.ts
@@ -0,0 +1,60 @@
+import { Arr, Obj } from '@ephox/katamari';
+import { Attribute, Classes, Css, Html, SugarElement, Value } from '@ephox/sugar';
+import { DomDefinitionDetail } from './DomDefinition';
+import { patchDomChildren } from './Patching';
+interface KeyValueDiff {
+  readonly toSet: Record<string, string>;
+  readonly toRemove: string[];
+}
+const diffKeyValueSet = (newObj: Record<string, string>, oldObj: Record<string, string>): KeyValueDiff => {
+  const newKeys = Obj.keys(newObj);
+  const oldKeys = Obj.keys(oldObj);
+  const toRemove = Arr.difference(oldKeys, newKeys);
+  const toSet = Obj.bifilter(newObj, (v, k) => {
+    return !Obj.has(oldObj, k) || v !== oldObj[k];
+  }).t;
+  return { toRemove, toSet };
+};
+const reconcileToDom = (definition: DomDefinitionDetail, obsoleted: SugarElement<Element>): SugarElement<Element> => {
+  const { class: clazz, style, ...existingAttributes } = Attribute.clone(obsoleted);
+  const { toSet: attrsToSet, toRemove: attrsToRemove } = diffKeyValueSet(definition.attributes, existingAttributes);
+  const updateAttrs = () => {
+    Arr.each(attrsToRemove, (a) => Attribute.remove(obsoleted, a));
+    Attribute.setAll(obsoleted, attrsToSet);
+  };
+  const existingStyles = Css.getAllRaw(obsoleted);
+  const { toSet: stylesToSet, toRemove: stylesToRemove } = diffKeyValueSet(definition.styles, existingStyles);
+  const updateStyles = () => {
+    Arr.each(stylesToRemove, (s) => Css.remove(obsoleted, s));
+    Css.setAll(obsoleted, stylesToSet);
+  };
+  const existingClasses = Classes.get(obsoleted);
+  const classesToRemove = Arr.difference(existingClasses, definition.classes);
+  const classesToAdd = Arr.difference(definition.classes, existingClasses);
+  const updateClasses = () => {
+    Classes.add(obsoleted, classesToAdd);
+    Classes.remove(obsoleted, classesToRemove);
+  };
+  const updateHtml = (html: string) => {
+    Html.set(obsoleted, html);
+  };
+  const updateChildren = () => {
+    const children = definition.domChildren;
+    patchDomChildren(obsoleted, children);
+  };
+  const updateValue = () => {
+    const valueElement = obsoleted as SugarElement<HTMLInputElement | HTMLTextAreaElement>;
+    definition.value
+      .filter((value) => value !== Value.get(valueElement))
+      .each((value) => Value.set(valueElement, value));
+  };
+  updateAttrs();
+  updateClasses();
+  updateStyles();
+  definition.innerHtml.fold(updateChildren, updateHtml);
+  updateValue();
+  return obsoleted;
+};
+export {
+  reconcileToDom
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/common/DragMovement.ts
@@ -0,0 +1,66 @@
+import { Fun, Num, Optional, Optionals } from '@ephox/katamari';
+import { Css, Scroll, SugarElement, SugarLocation, SugarPosition, Traverse } from '@ephox/sugar';
+import * as OffsetOrigin from '../../alien/OffsetOrigin';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as DragCoord from '../../api/data/DragCoord';
+import * as Snappables from '../snap/Snappables';
+import { DraggingConfig, DragStartData, SnapsConfig } from './DraggingTypes';
+const getCurrentCoord = (target: SugarElement<HTMLElement>): DragCoord.CoordAdt =>
+  Optionals.lift3(Css.getRaw(target, 'left'), Css.getRaw(target, 'top'), Css.getRaw(target, 'position'), (left, top, position) => {
+    const nu = position === 'fixed' ? DragCoord.fixed : DragCoord.offset;
+    return nu(
+      parseInt(left, 10),
+      parseInt(top, 10)
+    );
+  }).getOrThunk(() => {
+    const location = SugarLocation.absolute(target);
+    return DragCoord.absolute(location.left, location.top);
+  });
+const clampCoords = (component: AlloyComponent, coords: DragCoord.CoordAdt, scroll: SugarPosition, origin: SugarPosition, startData: DragStartData): DragCoord.CoordAdt => {
+  const bounds = startData.bounds;
+  const absoluteCoord = DragCoord.asAbsolute(coords, scroll, origin);
+  const newX = Num.clamp(absoluteCoord.left, bounds.x, bounds.x + bounds.width - startData.width);
+  const newY = Num.clamp(absoluteCoord.top, bounds.y, bounds.y + bounds.height - startData.height);
+  const newCoords = DragCoord.absolute(newX, newY);
+  return coords.fold(
+    () => {
+      const offset = DragCoord.asOffset(newCoords, scroll, origin);
+      return DragCoord.offset(offset.left, offset.top);
+    },
+    Fun.constant(newCoords),
+    () => {
+      const fixed = DragCoord.asFixed(newCoords, scroll, origin);
+      return DragCoord.fixed(fixed.left, fixed.top);
+    }
+  );
+};
+const calcNewCoord = <E>(component: AlloyComponent, optSnaps: Optional<SnapsConfig<E>>, currentCoord: DragCoord.CoordAdt, scroll: SugarPosition, origin: SugarPosition, delta: SugarPosition, startData: DragStartData): DragCoord.CoordAdt => {
+  const newCoord = optSnaps.fold(() => {
+    const translated = DragCoord.translate(currentCoord, delta.left, delta.top);
+    const fixedCoord = DragCoord.asFixed(translated, scroll, origin);
+    return DragCoord.fixed(fixedCoord.left, fixedCoord.top);
+  }, (snapInfo) => {
+    const snapping = Snappables.moveOrSnap(component, snapInfo, currentCoord, delta, scroll, origin);
+    snapping.extra.each((extra) => {
+      snapInfo.onSensor(component, extra);
+    });
+    return snapping.coord;
+  });
+  return clampCoords(component, newCoord, scroll, origin, startData);
+};
+const dragBy = <E>(component: AlloyComponent, dragConfig: DraggingConfig<E>, startData: DragStartData, delta: SugarPosition): void => {
+  const target = dragConfig.getTarget(component.element);
+  if (dragConfig.repositionTarget) {
+    const doc = Traverse.owner(component.element);
+    const scroll = Scroll.get(doc);
+    const origin = OffsetOrigin.getOrigin(target);
+    const currentCoord = getCurrentCoord(target);
+    const newCoord = calcNewCoord(component, dragConfig.snaps, currentCoord, scroll, origin, delta, startData);
+    const styles = DragCoord.toStyles(newCoord, scroll, origin);
+    Css.setOptions(target, styles);
+  }
+  dragConfig.onDrag(component, target, delta);
+};
+export {
+  dragBy
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/common/DraggingTypes.ts
@@ -0,0 +1,100 @@
+import { Optional } from '@ephox/katamari';
+import { EventArgs, SugarElement, SugarPosition } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { CoordAdt } from '../../api/data/DragCoord';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import { BehaviourState } from '../../behaviour/common/BehaviourState';
+import { MouseDraggingConfigSpec } from '../mouse/MouseDraggingTypes';
+import { MouseOrTouchDraggingConfigSpec } from '../mouseortouch/MouseOrTouchDraggingTypes';
+import { TouchDraggingConfigSpec } from '../touch/TouchDraggingTypes';
+export interface DraggingBehaviour<E> extends Behaviour.AlloyBehaviour<DraggingConfigSpec<E>, DraggingConfig<E>, DraggingState> {
+  config: (config: DraggingConfigSpec<E>) => Behaviour.NamedConfiguredBehaviour<DraggingConfigSpec<E>, DraggingConfig<E>, DraggingState>;
+  snap: (sConfig: SnapConfigSpec<E>) => SnapConfig<E>;
+  snapTo: (component: AlloyComponent, sConfig: SnapConfig<E>) => void;
+}
+/*
+ * Current dragging modes supported:
+ *  - mouse: Will allow dragging when using mouse events only
+ *  - touch: Will allow dragging when using touch events only
+ *  - mouseOrTouch: Will allow dragging with both mouse and touch events
+ */
+export type DraggingMode = 'touch' | 'mouse' | 'mouseOrTouch';
+export type SensorCoords = (x: number, y: number) => CoordAdt;
+export type OutputCoords = (x: Optional<number>, y: Optional<number>) => CoordAdt;
+export interface SnapConfig<E> {
+  readonly sensor: CoordAdt;
+  readonly range: SugarPosition;
+  readonly output: CoordAdt<Optional<number>>;
+  readonly extra: Optional<E>;
+}
+export interface SnapConfigSpec<E> {
+  readonly sensor: CoordAdt;
+  readonly range: SugarPosition;
+  readonly output: CoordAdt<Optional<number>>;
+  readonly extra?: E;
+}
+export interface SnapOutput<E> {
+  readonly output: CoordAdt;
+  readonly extra: Optional<E>;
+}
+export interface SnapPin<E> {
+  readonly coord: CoordAdt;
+  readonly extra: Optional<E>;
+}
+export interface SnapsConfig<E> {
+  readonly getSnapPoints: (comp: AlloyComponent) => Array<SnapConfig<E>>;
+  readonly leftAttr: string;
+  readonly topAttr: string;
+  readonly onSensor: (component: AlloyComponent, extra: E) => void;
+  readonly lazyViewport: (component: AlloyComponent) => Bounds;
+  readonly mustSnap: boolean;
+}
+export interface SnapsConfigSpec<E> {
+  readonly getSnapPoints: (comp: AlloyComponent) => Array<SnapConfig<E>>;
+  readonly leftAttr: string;
+  readonly topAttr: string;
+  readonly onSensor?: (component: AlloyComponent, extra: E) => void;
+  readonly lazyViewport?: (component: AlloyComponent) => Bounds;
+  readonly mustSnap?: boolean;
+}
+export interface DraggingConfig<E> {
+  readonly getTarget: (comp: SugarElement<HTMLElement>) => SugarElement<HTMLElement>;
+  readonly snaps: Optional<SnapsConfig<E>>;
+  readonly onDrop: (comp: AlloyComponent, target: SugarElement<HTMLElement>) => void;
+  readonly repositionTarget: boolean;
+  readonly onDrag: (comp: AlloyComponent, target: SugarElement<HTMLElement>, delta: SugarPosition) => void;
+  readonly getBounds: () => Bounds;
+  readonly blockerClass: string;
+  readonly dragger: {
+    readonly handlers: (dragConfig: DraggingConfig<E>, dragState: DraggingState) => AlloyEvents.AlloyEventRecord;
+  };
+}
+export interface CommonDraggingConfigSpec<E> {
+  readonly useFixed?: () => boolean;
+  readonly onDrop?: (comp: AlloyComponent, target: SugarElement<HTMLElement>) => void;
+  readonly repositionTarget?: boolean;
+  readonly onDrag?: (comp: AlloyComponent, target: SugarElement<HTMLElement>, delta: SugarPosition) => void;
+  readonly getTarget?: (elem: SugarElement<HTMLElement>) => SugarElement<HTMLElement>;
+  readonly getBounds?: () => Bounds;
+  readonly snaps?: SnapsConfigSpec<E>;
+  readonly blockerClass: string;
+}
+export type DraggingConfigSpec<E> = MouseDraggingConfigSpec<E> | TouchDraggingConfigSpec<E> | MouseOrTouchDraggingConfigSpec<E>;
+export interface DragModeDeltas<E extends Event, T> {
+  readonly getData: (event: EventArgs<E>) => Optional<T>;
+  readonly getDelta: (old: T, nu: T) => T;
+}
+export interface DragStartData {
+  readonly width: number;
+  readonly height: number;
+  readonly bounds: Bounds;
+}
+export interface BaseDraggingState<T> extends BehaviourState {
+  readonly update: <E extends Event>(mode: DragModeDeltas<E, T>, dragEvent: EventArgs<E>) => Optional<T>;
+  readonly setStartData: (data: DragStartData) => void;
+  readonly getStartData: () => Optional<DragStartData>;
+  readonly reset: () => void;
+}
+export interface DraggingState extends BaseDraggingState<SugarPosition> { }

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DataTransfers.ts
@@ -0,0 +1,45 @@
+import { Arr, Strings, Type } from '@ephox/katamari';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+const setData = (transfer: DataTransfer, types: string[], data: string): void => {
+  transfer.items.clear();
+  Arr.each(types, (type) => {
+    transfer.items.add(data, type);
+  });
+};
+const getData = (transfer: DataTransfer, type: string): string => {
+  const data = transfer.getData(type);
+  return Type.isNull(data) ? '' : data;
+};
+const setDragImage = (transfer: DataTransfer, image: Element, x: number, y: number): void => {
+  transfer.setDragImage(image, x, y);
+};
+const setDropEffect = (transfer: DataTransfer, effect: DataTransfer['dropEffect']): void => {
+  transfer.dropEffect = effect;
+};
+const setEffectAllowed = (transfer: DataTransfer, effect: DataTransfer['effectAllowed']): void => {
+  transfer.effectAllowed = effect;
+};
+const getFiles = (transfer: DataTransfer): File[] => Arr.from(transfer.files);
+const isValidDrop = (transfer: DataTransfer): boolean => {
+  const effectAllowed = transfer.effectAllowed.toLowerCase();
+  const dropEffect = transfer.dropEffect.toLowerCase();
+  return effectAllowed === 'all' || effectAllowed === 'uninitialized' || Strings.contains(effectAllowed, dropEffect);
+};
+const getDataTransferFromEvent = (simulatedEvent: NativeSimulatedEvent<DragEvent>): DataTransfer => {
+  const rawEvent = simulatedEvent.event.raw;
+  return rawEvent.dataTransfer as DataTransfer;
+};
+const setDropEffectOnEvent = (simulatedEvent: NativeSimulatedEvent<DragEvent>, dropEffect: DataTransfer['dropEffect']): void => {
+  setDropEffect(getDataTransferFromEvent(simulatedEvent), dropEffect);
+};
+export {
+  setData,
+  getData,
+  setDragImage,
+  setDropEffect,
+  setEffectAllowed,
+  getFiles,
+  isValidDrop,
+  getDataTransferFromEvent,
+  setDropEffectOnEvent
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DragStarting.ts
@@ -0,0 +1,64 @@
+import { FieldProcessor, FieldSchema } from '@ephox/boulder';
+import { Fun } from '@ephox/katamari';
+import { EventArgs, SugarBody, SugarElement, Traverse } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import * as NativeEvents from '../../api/events/NativeEvents';
+import * as DomModification from '../../dom/DomModification';
+import * as DataTransfers from './DataTransfers';
+import { DragStartingConfig } from './DragnDropTypes';
+import { setImageClone } from './ImageClone';
+const dragStart = (component: AlloyComponent, target: SugarElement<Node>, config: DragStartingConfig, transfer: DataTransfer) => {
+  DataTransfers.setEffectAllowed(transfer, config.effectAllowed);
+  config.getData.each((getData) => {
+    const data = getData(component);
+    const types = [ config.type ].concat(config.phoneyTypes);
+    DataTransfers.setData(transfer, types, data);
+  });
+  config.getImage.each((f) => {
+    const image = f(component);
+    const parent = config.getImageParent.fold(
+      () => Traverse.parentElement(target).getOr(SugarBody.body()),
+      (f) => f(component)
+    );
+    setImageClone(transfer, image, parent);
+  });
+};
+const schema: FieldProcessor[] = [
+  FieldSchema.defaultedString('type', 'text/plain'),
+  FieldSchema.defaulted('phoneyTypes', []),
+  FieldSchema.defaultedStringEnum('effectAllowed', 'all', [ 'copy', 'move', 'link', 'all', 'copyLink', 'linkMove', 'copyMove' ]),
+  FieldSchema.optionFunction('getData'),
+  FieldSchema.optionFunction('getImageParent'),
+  FieldSchema.optionFunction('getImage'),
+  FieldSchema.defaultedFunction('canDrag', Fun.always),
+  FieldSchema.defaultedFunction('onDragstart', Fun.identity),
+  FieldSchema.defaultedFunction('onDragover', Fun.identity),
+  FieldSchema.defaultedFunction('onDragend', Fun.identity),
+  FieldSchema.customField('instance', () => {
+    const exhibit = () => DomModification.nu({
+      attributes: {
+        draggable: 'true'
+      }
+    });
+    const handlers = (config: DragStartingConfig): AlloyEvents.AlloyEventRecord => AlloyEvents.derive([
+      AlloyEvents.run(NativeEvents.dragover(), config.onDragover),
+      AlloyEvents.run(NativeEvents.dragend(), config.onDragend),
+      AlloyEvents.run<EventArgs<DragEvent>>(NativeEvents.dragstart(), (component, simulatedEvent) => {
+        const target = simulatedEvent.event.target;
+        const transfer: DataTransfer = DataTransfers.getDataTransferFromEvent(simulatedEvent);
+        if (config.canDrag(component, target)) {
+          dragStart(component, target, config, transfer);
+          config.onDragstart(component, simulatedEvent);
+        } else {
+          simulatedEvent.event.prevent();
+        }
+      })
+    ]);
+    return {
+      exhibit,
+      handlers
+    };
+  })
+];
+export default schema;

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/DragnDropTypes.ts
@@ -0,0 +1,77 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import { DomDefinitionDetail } from '../../dom/DomDefinition';
+import { DomModification } from '../../dom/DomModification';
+import { EventFormat, NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import { DropEvent } from './DropEvent';
+import { DragnDropImageClone } from './ImageClone';
+export interface DragnDropBehaviour extends Behaviour.AlloyBehaviour<DragnDropConfigSpec, DragnDropConfig> {
+  config: (config: DragnDropConfigSpec) => Behaviour.NamedConfiguredBehaviour<DragnDropConfigSpec, DragnDropConfig>;
+}
+export type DragnDropConfig = DragStartingConfig | DroppingConfig;
+export interface StartingDragndropConfigSpec {
+  mode: 'drag';
+  type?: string;
+  phoneyTypes?: string[];
+  effectAllowed?: string;
+  getData?: (component: AlloyComponent) => string;
+  getImageParent?: (component: AlloyComponent) => SugarElement<Element>;
+  getImage?: (component: AlloyComponent) => DragnDropImageClone;
+  canDrag?: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
+  onDragstart?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+  onDragover?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+  onDragend?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+}
+export interface DragStartingConfig {
+  type: string;
+  phoneyTypes: string[];
+  effectAllowed: DataTransfer['effectAllowed'];
+  getData: Optional<(component: AlloyComponent) => string>;
+  getImageParent: Optional<(component: AlloyComponent) => SugarElement<Element>>;
+  getImage: Optional<(component: AlloyComponent) => DragnDropImageClone>;
+  canDrag: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
+  onDragstart: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+  onDragover: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+  onDragend: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => void;
+  instance: {
+    exhibit: (base: DomDefinitionDetail, dragInfo: DragStartingConfig) => DomModification;
+    handlers: (dragInfo: DragStartingConfig) => {
+      dragover: AlloyEvents.AlloyEventHandler<EventFormat>;
+      dragend: AlloyEvents.AlloyEventHandler<EventFormat>;
+      dragstart: AlloyEvents.AlloyEventHandler<EventFormat>;
+    };
+  };
+}
+export interface DropDragndropConfigSpec {
+  mode: 'drop';
+  type?: string;
+  dropEffect?: string;
+  onDrop?: (component: AlloyComponent, dropEvent: DropEvent) => void;
+  onDrag?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragover?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragenter?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragleave?: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+}
+export interface DroppingConfig {
+  type: string;
+  dropEffect: DataTransfer['dropEffect'];
+  onDrop: (component: AlloyComponent, dropEvent: DropEvent) => void;
+  onDrag: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragover: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragenter: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  onDragleave: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => void;
+  instance: {
+    exhibit: (base: DomDefinitionDetail, dragInfo: DragStartingConfig) => DomModification;
+    handlers: (dragInfo: DroppingConfig) => {
+      dragover: AlloyEvents.AlloyEventHandler<EventFormat>;
+      dragleave: AlloyEvents.AlloyEventHandler<EventFormat>;
+      drag: AlloyEvents.AlloyEventHandler<EventFormat>;
+      dragenter: AlloyEvents.AlloyEventHandler<EventFormat>;
+      drop: AlloyEvents.AlloyEventHandler<EventFormat>;
+    };
+  };
+}
+export type DragnDropConfigSpec = StartingDragndropConfigSpec | DropDragndropConfigSpec;

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/dragndrop/ImageClone.ts
@@ -0,0 +1,30 @@
+import { Css, Insert, Remove, Replication, SugarElement } from '@ephox/sugar';
+import * as DataTransfers from './DataTransfers';
+export interface DragnDropImageClone {
+  readonly element: SugarElement<HTMLElement>;
+  readonly x: number;
+  readonly y: number;
+}
+const createGhostClone = (image: DragnDropImageClone): SugarElement<HTMLElement> => {
+  const ghost = Replication.deep(image.element);
+  Css.setAll(ghost, {
+    'position': 'absolute',
+    'top': '-300px',
+    'max-width': '175px',
+    'max-height': '175px',
+    'overflow': 'hidden'
+  });
+  return ghost;
+};
+const setDragImageFromClone = (transfer: DataTransfer, parent: SugarElement<Element>, image: DragnDropImageClone): void => {
+  const ghost = createGhostClone(image);
+  Insert.append(parent, ghost);
+  DataTransfers.setDragImage(transfer, ghost.dom, image.x, image.y);
+  setTimeout(() => {
+    Remove.remove(ghost);
+  }, 0);
+};
+const setImageClone = (transfer: DataTransfer, image: DragnDropImageClone, parent: SugarElement<Element>): void => {
+  setDragImageFromClone(transfer, parent, image);
+};
+export { setImageClone };

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dragging/snap/Presnaps.ts
@@ -0,0 +1,31 @@
+import { Optional, Type } from '@ephox/katamari';
+import { Attribute, SugarElement, SugarPosition } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SnapsConfig } from '../common/DraggingTypes';
+const parseAttrToInt = (element: SugarElement<Element>, name: string): number => {
+  const value = Attribute.get(element, name);
+  return Type.isUndefined(value) ? NaN : parseInt(value, 10);
+};
+const get = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>): Optional<SugarPosition> => {
+  const element = component.element;
+  const x = parseAttrToInt(element, snapsInfo.leftAttr);
+  const y = parseAttrToInt(element, snapsInfo.topAttr);
+  return isNaN(x) || isNaN(y) ? Optional.none() : Optional.some(
+    SugarPosition(x, y)
+  );
+};
+const set = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>, pt: SugarPosition): void => {
+  const element = component.element;
+  Attribute.set(element, snapsInfo.leftAttr, pt.left + 'px');
+  Attribute.set(element, snapsInfo.topAttr, pt.top + 'px');
+};
+const clear = <E>(component: AlloyComponent, snapsInfo: SnapsConfig<E>): void => {
+  const element = component.element;
+  Attribute.remove(element, snapsInfo.leftAttr);
+  Attribute.remove(element, snapsInfo.topAttr);
+};
+export {
+  get,
+  set,
+  clear
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/dropdown/DropdownUtils.ts
@@ -0,0 +1,263 @@
+import { Arr, Fun, Future, Optional, Result } from '@ephox/katamari';
+import { Css, Width } from '@ephox/sugar';
+import * as ComponentStructure from '../alien/ComponentStructure';
+import { Composing } from '../api/behaviour/Composing';
+import { Coupling } from '../api/behaviour/Coupling';
+import { Focusing } from '../api/behaviour/Focusing';
+import { Positioning } from '../api/behaviour/Positioning';
+import { Receiving } from '../api/behaviour/Receiving';
+import { Representing } from '../api/behaviour/Representing';
+import { Sandboxing } from '../api/behaviour/Sandboxing';
+import { LazySink } from '../api/component/CommonTypes';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { SketchBehaviours } from '../api/component/SketchBehaviours';
+import { AlloySpec, SketchSpec } from '../api/component/SpecTypes';
+import { TieredData, tieredMenu as TieredMenu } from '../api/ui/TieredMenu';
+import * as AriaControls from '../aria/AriaControls';
+import * as InternalSink from '../parts/InternalSink';
+import { HotspotAnchorSpec } from '../positioning/mode/Anchoring';
+import * as Tagger from '../registry/Tagger';
+import * as Dismissal from '../sandbox/Dismissal';
+import * as Reposition from '../sandbox/Reposition';
+import { CommonDropdownDetail } from '../ui/types/DropdownTypes';
+type OnOpenSyncFunc = (sandbox: AlloyComponent) => void;
+type MapFetch = (tdata: Optional<TieredData>) => Optional<TieredData>;
+export interface SandboxExtras {
+  onClose?: (component: AlloyComponent, menu: AlloyComponent) => void;
+  onOpen?: (component: AlloyComponent, menu: AlloyComponent) => void;
+}
+export enum HighlightOnOpen { HighlightFirst, HighlightNone }
+const getAnchor = (
+  detail: CommonDropdownDetail<TieredData>,
+  component: AlloyComponent
+): HotspotAnchorSpec => {
+  const hotspot = detail.getHotspot(component).getOr(component);
+  const type = 'hotspot';
+  const overrides = detail.getAnchorOverrides();
+  return detail.layouts.fold(
+    () => ({ type, hotspot, overrides }),
+    (layouts) => ({ type, hotspot, overrides, layouts })
+  );
+};
+const fetch = (
+  detail: CommonDropdownDetail<TieredData>,
+  mapFetch: MapFetch,
+  component: AlloyComponent
+): Future<Optional<TieredData>> => {
+  const fetcher = detail.fetch;
+  return fetcher(component).map(mapFetch);
+};
+const openF = (
+  detail: CommonDropdownDetail<TieredData>,
+  mapFetch: MapFetch,
+  anchor: HotspotAnchorSpec,
+  component: AlloyComponent,
+  sandbox: AlloyComponent,
+  externals: any,
+  highlightOnOpen: HighlightOnOpen
+): Future<Optional<SketchSpec>> => {
+  const futureData: Future<Optional<TieredData>> = fetch(detail, mapFetch, component);
+  const getLazySink = getSink(component, detail);
+  return futureData.map((tdata) => tdata.bind((data) => Optional.from(TieredMenu.sketch({
+    ...externals.menu(),
+    uid: Tagger.generate(''),
+    data,
+    highlightImmediately: highlightOnOpen === HighlightOnOpen.HighlightFirst,
+    onOpenMenu: (tmenu, menu) => {
+      const sink = getLazySink().getOrDie();
+      Positioning.position(sink, menu, { anchor });
+      Sandboxing.decloak(sandbox);
+    },
+    onOpenSubmenu: (tmenu, item, submenu) => {
+      const sink = getLazySink().getOrDie();
+      Positioning.position(sink, submenu, {
+        anchor: {
+          type: 'submenu',
+          item
+        }
+      });
+      Sandboxing.decloak(sandbox);
+    },
+    onRepositionMenu: (tmenu, primaryMenu, submenuTriggers) => {
+      const sink = getLazySink().getOrDie();
+      Positioning.position(sink, primaryMenu, { anchor });
+      Arr.each(submenuTriggers, (st) => {
+        Positioning.position(sink, st.triggeredMenu, {
+          anchor: { type: 'submenu', item: st.triggeringItem }
+        });
+      });
+    },
+    onEscape: () => {
+      Focusing.focus(component);
+      Sandboxing.close(sandbox);
+      return Optional.some(true);
+    }
+  }))));
+};
+const open = (
+  detail: CommonDropdownDetail<TieredData>,
+  mapFetch: MapFetch,
+  hotspot: AlloyComponent,
+  sandbox: AlloyComponent,
+  externals: any,
+  onOpenSync: OnOpenSyncFunc,
+  highlightOnOpen: HighlightOnOpen
+): Future<AlloyComponent> => {
+  const anchor = getAnchor(detail, hotspot);
+  const processed = openF(detail, mapFetch, anchor, hotspot, sandbox, externals, highlightOnOpen);
+  return processed.map((tdata) => {
+    tdata.fold(
+      () => {
+        if (Sandboxing.isOpen(sandbox)) {
+          Sandboxing.close(sandbox);
+        }
+      },
+      (data) => {
+        Sandboxing.cloak(sandbox);
+        Sandboxing.open(sandbox, data);
+        onOpenSync(sandbox);
+      }
+    );
+    return sandbox;
+  });
+};
+const close = (
+  detail: CommonDropdownDetail<TieredData>,
+  mapFetch: MapFetch,
+  component: AlloyComponent,
+  sandbox: AlloyComponent,
+  _externals: any,
+  _onOpenSync: OnOpenSyncFunc,
+  _highlightOnOpen: HighlightOnOpen
+): Future<AlloyComponent> => {
+  Sandboxing.close(sandbox);
+  return Future.pure(sandbox);
+};
+const togglePopup = (
+  detail: CommonDropdownDetail<TieredData>,
+  mapFetch: MapFetch,
+  hotspot: AlloyComponent,
+  externals: any,
+  onOpenSync: OnOpenSyncFunc,
+  highlightOnOpen: HighlightOnOpen
+): Future<AlloyComponent> => {
+  const sandbox = Coupling.getCoupled(hotspot, 'sandbox');
+  const showing = Sandboxing.isOpen(sandbox);
+  const action = showing ? close : open;
+  return action(detail, mapFetch, hotspot, sandbox, externals, onOpenSync, highlightOnOpen);
+};
+const matchWidth = (hotspot: AlloyComponent, container: AlloyComponent, useMinWidth: boolean): void => {
+  const menu = Composing.getCurrent(container).getOr(container);
+  const buttonWidth = Width.get(hotspot.element);
+  if (useMinWidth) {
+    Css.set(menu.element, 'min-width', buttonWidth + 'px');
+  } else {
+    Width.set(menu.element, buttonWidth);
+  }
+};
+interface SinkDetail {
+  uid: string;
+  lazySink: Optional<LazySink>;
+}
+const getSink = (
+  anyInSystem: AlloyComponent,
+  sinkDetail: SinkDetail
+): () => ReturnType<LazySink> =>
+  anyInSystem
+    .getSystem()
+    .getByUid(sinkDetail.uid + '-' + InternalSink.suffix())
+    .map((internalSink) => () => Result.value(internalSink))
+    .getOrThunk(
+      () => sinkDetail.lazySink.fold(
+        () => () => Result.error(new Error(
+          'No internal sink is specified, nor could an external sink be found'
+        )),
+        (lazySinkFn) => () => lazySinkFn(anyInSystem))
+    );
+const doRepositionMenus = (sandbox: AlloyComponent): void => {
+  Sandboxing.getState(sandbox).each((tmenu) => {
+    TieredMenu.repositionMenus(tmenu);
+  });
+};
+const makeSandbox = (
+  detail: CommonDropdownDetail<TieredData>,
+  hotspot: AlloyComponent,
+  extras?: SandboxExtras
+): AlloySpec => {
+  const ariaControls = AriaControls.manager();
+  const onOpen = (component: AlloyComponent, menu: AlloyComponent) => {
+    const anchor = getAnchor(detail, hotspot);
+    ariaControls.link(hotspot.element);
+    if (detail.matchWidth) {
+      matchWidth(anchor.hotspot, menu, detail.useMinWidth);
+    }
+    detail.onOpen(anchor, component, menu);
+    if (extras !== undefined && extras.onOpen !== undefined) {
+      extras.onOpen(component, menu);
+    }
+  };
+  const onClose = (component: AlloyComponent, menu: AlloyComponent) => {
+    ariaControls.unlink(hotspot.element);
+    if (extras !== undefined && extras.onClose !== undefined) {
+      extras.onClose(component, menu);
+    }
+  };
+  const lazySink = getSink(hotspot, detail);
+  return {
+    dom: {
+      tag: 'div',
+      classes: detail.sandboxClasses,
+      attributes: {
+        id: ariaControls.id,
+        role: 'listbox'
+      }
+    },
+    behaviours: SketchBehaviours.augment(
+      detail.sandboxBehaviours,
+      [
+        Representing.config({
+          store: {
+            mode: 'memory',
+            initialValue: hotspot
+          }
+        }),
+        Sandboxing.config({
+          onOpen,
+          onClose,
+          isPartOf: (container, data, queryElem): boolean => {
+            return ComponentStructure.isPartOf(data, queryElem) || ComponentStructure.isPartOf(hotspot, queryElem);
+          },
+          getAttachPoint: () => {
+            return lazySink().getOrDie();
+          }
+        }),
+        Composing.config({
+          find: (sandbox: AlloyComponent): Optional<AlloyComponent> => {
+            return Sandboxing.getState(sandbox).bind((menu) => Composing.getCurrent(menu));
+          }
+        }),
+        Receiving.config({
+          channels: {
+            ...Dismissal.receivingChannel({
+              isExtraPart: Fun.never
+            }),
+            ...Reposition.receivingChannel({
+              doReposition: doRepositionMenus
+            })
+          }
+        })
+      ]
+    )
+  };
+};
+const repositionMenus = (comp: AlloyComponent): void => {
+  const sandbox = Coupling.getCoupled(comp, 'sandbox');
+  doRepositionMenus(sandbox);
+};
+export {
+  makeSandbox,
+  togglePopup,
+  open,
+  repositionMenus,
+  getSink
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/DefaultEvents.ts
@@ -0,0 +1,29 @@
+import { Compare, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AlloyEvents from '../api/events/AlloyEvents';
+import * as SystemEvents from '../api/events/SystemEvents';
+import * as AlloyLogger from '../log/AlloyLogger';
+import { FocusingEvent } from './SimulatedEvent';
+const isRecursive = (component: AlloyComponent, originator: SugarElement<Node>, target: SugarElement<Node>): boolean =>
+  Compare.eq(originator, component.element) && !Compare.eq(originator, target);
+const events: AlloyEvents.AlloyEventRecord = AlloyEvents.derive([
+  AlloyEvents.can<FocusingEvent>(SystemEvents.focus(), (component, simulatedEvent) => {
+    const event = simulatedEvent.event;
+    const originator = event.originator;
+    const target = event.target;
+    if (isRecursive(component, originator, target)) {
+      console.warn(
+        SystemEvents.focus() + ' did not get interpreted by the desired target. ' +
+        '\nOriginator: ' + AlloyLogger.element(originator) +
+        '\nTarget: ' + AlloyLogger.element(target) +
+        '\nCheck the ' + SystemEvents.focus() + ' event handlers'
+      );
+      return false;
+    } else {
+      return true;
+    }
+  })
+]);
+export {
+  events
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/EventRegistry.ts
@@ -0,0 +1,70 @@
+import { Obj, Optional } from '@ephox/katamari';
+import { SugarElement, TransformFind } from '@ephox/sugar';
+import * as Tagger from '../registry/Tagger';
+import * as DescribedHandler from './DescribedHandler';
+export interface ElementAndHandler {
+  readonly element: SugarElement<Node>;
+  readonly descHandler: CurriedHandler;
+}
+export interface CurriedHandler {
+  readonly purpose: string;
+  readonly cHandler: Function;
+}
+export interface UncurriedHandler {
+  readonly purpose: string;
+  readonly handler: Function;
+}
+export interface UidAndHandler {
+  readonly id: string;
+  readonly descHandler: CurriedHandler;
+}
+export interface EventRegistry {
+  readonly registerId: (extraArgs: any[], id: string, events: Record<EventName, UncurriedHandler>) => void;
+  readonly unregisterId: (id: string) => void;
+  readonly filterByType: (type: string) => UidAndHandler[];
+  readonly find: (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
+}
+const eventHandler = (element: SugarElement<Node>, descHandler: CurriedHandler): ElementAndHandler => ({
+  element,
+  descHandler
+});
+const broadcastHandler = (id: string, handler: CurriedHandler): UidAndHandler => ({
+  id,
+  descHandler: handler
+});
+export type EventName = string;
+export type Uid = string;
+export const EventRegistry = (): EventRegistry => {
+  const registry: Record<EventName, Record<Uid, CurriedHandler>> = { };
+  const registerId = (extraArgs: any[], id: string, events: Record<EventName, UncurriedHandler>) => {
+    Obj.each(events, (v: UncurriedHandler, k: EventName) => {
+      const handlers = registry[k] !== undefined ? registry[k] : { };
+      handlers[id] = DescribedHandler.curryArgs(v, extraArgs);
+      registry[k] = handlers;
+    });
+  };
+  const findHandler = (handlers: Record<Uid, CurriedHandler>, elem: SugarElement<Node>): Optional<ElementAndHandler> =>
+    Tagger.read(elem)
+      .bind((id) => Obj.get(handlers, id))
+      .map((descHandler) => eventHandler(elem, descHandler));
+  const filterByType = (type: string): UidAndHandler[] =>
+    Obj.get(registry, type)
+      .map((handlers) => Obj.mapToArray(handlers, (f, id) => broadcastHandler(id, f)))
+      .getOr([ ]);
+  const find = (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>): Optional<ElementAndHandler> =>
+    Obj.get(registry, type)
+      .bind((handlers) => TransformFind.closest(target, (elem) => findHandler(handlers, elem), isAboveRoot));
+  const unregisterId = (id: string): void => {
+    Obj.each(registry, (handlersById, _eventName) => {
+      if (Obj.has(handlersById, id)) {
+        delete handlersById[id];
+      }
+    });
+  };
+  return {
+    registerId,
+    unregisterId,
+    filterByType,
+    find
+  };
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/EventSource.ts
@@ -0,0 +1,10 @@
+import { Cell, Obj } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { EventFormat } from './SimulatedEvent';
+const derive = (rawEvent: EventFormat, rawTarget: SugarElement<Node>): Cell<SugarElement<Node>> => {
+  const source = Obj.get(rawEvent, 'target').getOr(rawTarget);
+  return Cell(source);
+};
+export {
+  derive
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/GuiEvents.ts
@@ -0,0 +1,118 @@
+import { Arr, Singleton } from '@ephox/katamari';
+import { DomEvent, EventArgs, SelectorExists, SugarElement, SugarNode } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import * as SystemEvents from '../api/events/SystemEvents';
+import * as TapEvent from './TapEvent';
+const isDangerous = (event: EventArgs<KeyboardEvent>): boolean => {
+  const keyEv = event.raw;
+  return keyEv.which === Keys.BACKSPACE[0] && !Arr.contains([ 'input', 'textarea' ], SugarNode.name(event.target)) && !SelectorExists.closest(event.target, '[contenteditable="true"]');
+};
+export interface GuiEventSettings {
+  readonly triggerEvent: (eventName: string, event: EventArgs) => boolean;
+  readonly stopBackspace?: boolean;
+}
+const setup = (container: SugarElement, rawSettings: GuiEventSettings): { unbind: () => void } => {
+  const settings: Required<GuiEventSettings> = {
+    stopBackspace: true,
+    ...rawSettings
+  };
+  const pointerEvents = [
+    'touchstart',
+    'touchmove',
+    'touchend',
+    'touchcancel',
+    'gesturestart',
+    'mousedown',
+    'mouseup',
+    'mouseover',
+    'mousemove',
+    'mouseout',
+    'click'
+  ];
+  const tapEvent = TapEvent.monitor(settings);
+  const simpleEvents = Arr.map(
+    pointerEvents.concat([
+      'selectstart',
+      'input',
+      'contextmenu',
+      'change',
+      'transitionend',
+      'transitioncancel',
+      'drag',
+      'dragstart',
+      'dragend',
+      'dragenter',
+      'dragleave',
+      'dragover',
+      'drop',
+      'keyup'
+    ]),
+    (type) => DomEvent.bind(container, type, (event) => {
+      tapEvent.fireIfReady(event, type).each((tapStopped) => {
+        if (tapStopped) {
+          event.kill();
+        }
+      });
+      const stopped = settings.triggerEvent(type, event);
+      if (stopped) {
+        event.kill();
+      }
+    })
+  );
+  const pasteTimeout = Singleton.value<number>();
+  const onPaste = DomEvent.bind(container, 'paste', (event) => {
+    tapEvent.fireIfReady(event, 'paste').each((tapStopped) => {
+      if (tapStopped) {
+        event.kill();
+      }
+    });
+    const stopped = settings.triggerEvent('paste', event);
+    if (stopped) {
+      event.kill();
+    }
+    pasteTimeout.set(setTimeout(() => {
+      settings.triggerEvent(SystemEvents.postPaste(), event);
+    }, 0));
+  });
+  const onKeydown = DomEvent.bind(container, 'keydown', (event) => {
+    const stopped = settings.triggerEvent('keydown', event);
+    if (stopped) {
+      event.kill();
+    } else if (settings.stopBackspace && isDangerous(event)) {
+      event.prevent();
+    }
+  });
+  const onFocusIn = DomEvent.bind(container, 'focusin', (event) => {
+    const stopped = settings.triggerEvent('focusin', event);
+    if (stopped) {
+      event.kill();
+    }
+  });
+  const focusoutTimeout = Singleton.value<number>();
+  const onFocusOut = DomEvent.bind(container, 'focusout', (event) => {
+    const stopped = settings.triggerEvent('focusout', event);
+    if (stopped) {
+      event.kill();
+    }
+    focusoutTimeout.set(setTimeout(() => {
+      settings.triggerEvent(SystemEvents.postBlur(), event);
+    }, 0));
+  });
+  const unbind = (): void => {
+    Arr.each(simpleEvents, (e) => {
+      e.unbind();
+    });
+    onKeydown.unbind();
+    onFocusIn.unbind();
+    onFocusOut.unbind();
+    onPaste.unbind();
+    pasteTimeout.on(clearTimeout);
+    focusoutTimeout.on(clearTimeout);
+  };
+  return {
+    unbind
+  };
+};
+export {
+  setup
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/SimulatedEvent.ts
@@ -0,0 +1,80 @@
+import { Cell, Fun } from '@ephox/katamari';
+import { EventArgs, SugarElement } from '@ephox/sugar';
+export interface EventFormat {
+  readonly target: SugarElement<Node>;
+  readonly kill: () => void;
+  readonly prevent: () => void;
+}
+export interface SimulatedEvent<T extends EventFormat> {
+  readonly stop: () => void;
+  readonly cut: () => void;
+  readonly isStopped: () => boolean;
+  readonly isCut: () => boolean;
+  readonly event: T;
+  readonly getSource: () => SugarElement<Node>;
+  readonly setSource: (elem: SugarElement<Node>) => void;
+}
+export type NativeSimulatedEvent<T = Event> = SimulatedEvent<EventArgs<T>>;
+export type CustomSimulatedEvent = SimulatedEvent<CustomEvent>;
+export interface CustomEvent extends EventFormat {
+  readonly [key: string]: any;
+}
+export interface ReceivingUniversalInternalEvent {
+  readonly universal: true;
+  readonly data: any;
+}
+export interface ReceivingChannelsInternalEvent {
+  readonly universal: false;
+  readonly channels: ReadonlyArray<string>;
+  readonly data: any;
+}
+export type ReceivingInternalEvent = ReceivingUniversalInternalEvent | ReceivingChannelsInternalEvent;
+export interface ReceivingEvent extends EventFormat {
+  readonly data: any;
+}
+export interface FocusingEvent extends EventFormat {
+  readonly originator: SugarElement<Node>;
+}
+const fromSource = <T extends EventFormat>(event: T, source: Cell<SugarElement<Node>>): SimulatedEvent<T> => {
+  const stopper = Cell(false);
+  const cutter = Cell(false);
+  const stop = () => {
+    stopper.set(true);
+  };
+  const cut = () => {
+    cutter.set(true);
+  };
+  return {
+    stop,
+    cut,
+    isStopped: stopper.get,
+    isCut: cutter.get,
+    event,
+    setSource: source.set,
+    getSource: source.get
+  };
+};
+const fromExternal = <T extends EventFormat>(event: T): SimulatedEvent<T> => {
+  const stopper = Cell(false);
+  const stop = () => {
+    stopper.set(true);
+  };
+  return {
+    stop,
+    cut: Fun.noop, // cutting has no meaning for a broadcasted event
+    isStopped: stopper.get,
+    isCut: Fun.never,
+    event,
+    setSource: Fun.die('Cannot set source of a broadcasted event'),
+    getSource: Fun.die('Cannot get source of a broadcasted event')
+  };
+};
+const fromTarget = <T extends EventFormat>(event: T, target: SugarElement<Node>): SimulatedEvent<T> => {
+  const source = Cell(target);
+  return fromSource(event, source);
+};
+export {
+  fromSource,
+  fromExternal,
+  fromTarget
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/TapEvent.ts
@@ -0,0 +1,91 @@
+import { Objects } from '@ephox/boulder';
+import { Cell, Obj, Optional, Singleton } from '@ephox/katamari';
+import { Compare, EventArgs, SugarElement } from '@ephox/sugar';
+import { DelayedFunction } from '../alien/DelayedFunction';
+import * as NativeEvents from '../api/events/NativeEvents';
+import * as SystemEvents from '../api/events/SystemEvents';
+import { GuiEventSettings } from './GuiEvents';
+type EventHandler = (event: EventArgs<Event>) => Optional<boolean>;
+export interface TouchHistoryData {
+  readonly x: number;
+  readonly y: number;
+  readonly target: SugarElement<Node>;
+}
+interface Monitor {
+  readonly fireIfReady: (event: EventArgs<Event>, type: string) => Optional<boolean>;
+}
+const SIGNIFICANT_MOVE = 5;
+const LONGPRESS_DELAY = 400;
+const getTouch = (event: EventArgs<TouchEvent>): Optional<Touch> => {
+  const raw = event.raw;
+  if (raw.touches === undefined || raw.touches.length !== 1) {
+    return Optional.none();
+  }
+  return Optional.some(raw.touches[0]);
+};
+const isFarEnough = (touch: Touch, data: TouchHistoryData): boolean => {
+  const distX = Math.abs(touch.clientX - data.x);
+  const distY = Math.abs(touch.clientY - data.y);
+  return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;
+};
+const monitor = (settings: GuiEventSettings): Monitor => {
+  /* A tap event is a combination of touchstart and touchend on the same element
+   * without a *significant* touchmove in between.
+   */
+  const startData = Singleton.value<TouchHistoryData>();
+  const longpressFired = Cell<boolean>(false);
+  const longpress = DelayedFunction((event: EventArgs) => {
+    settings.triggerEvent(SystemEvents.longpress(), event);
+    longpressFired.set(true);
+  }, LONGPRESS_DELAY);
+  const handleTouchstart = (event: EventArgs<TouchEvent>): Optional<boolean> => {
+    getTouch(event).each((touch) => {
+      longpress.cancel();
+      const data = {
+        x: touch.clientX,
+        y: touch.clientY,
+        target: event.target
+      };
+      longpress.schedule(event);
+      longpressFired.set(false);
+      startData.set(data);
+    });
+    return Optional.none();
+  };
+  const handleTouchmove = (event: EventArgs<TouchEvent>): Optional<boolean> => {
+    longpress.cancel();
+    getTouch(event).each((touch) => {
+      startData.on((data) => {
+        if (isFarEnough(touch, data)) {
+          startData.clear();
+        }
+      });
+    });
+    return Optional.none();
+  };
+  const handleTouchend = (event: EventArgs): Optional<boolean> => {
+    longpress.cancel();
+    const isSame = (data: TouchHistoryData) => Compare.eq(data.target, event.target);
+    return startData.get().filter(isSame).map((_data) => {
+      if (longpressFired.get()) {
+        event.prevent();
+        return false;
+      } else {
+        return settings.triggerEvent(SystemEvents.tap(), event);
+      }
+    });
+  };
+  const handlers: Record<string, EventHandler> = Objects.wrapAll([
+    { key: NativeEvents.touchstart(), value: handleTouchstart },
+    { key: NativeEvents.touchmove(), value: handleTouchmove },
+    { key: NativeEvents.touchend(), value: handleTouchend }
+  ] as Array<{ key: string; value: EventHandler }>);
+  const fireIfReady = (event: EventArgs<Event>, type: string): Optional<boolean> =>
+    Obj.get(handlers, type).bind((handler) => handler(event));
+  return {
+    fireIfReady
+  };
+};
+export {
+  monitor
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/events/Triggers.ts
@@ -0,0 +1,88 @@
+import { Adt, Arr, Cell, Fun, Optional } from '@ephox/katamari';
+import { SugarElement, Traverse } from '@ephox/sugar';
+import { DebuggerLogger } from '../debugging/Debugging';
+import * as DescribedHandler from './DescribedHandler';
+import { ElementAndHandler, UidAndHandler } from './EventRegistry';
+import * as EventSource from './EventSource';
+import { EventFormat, fromExternal, fromSource } from './SimulatedEvent';
+type LookupEvent = (eventName: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
+export interface TriggerAdt {
+  fold: <T>(
+    stopped: () => T,
+    resume: (elem: SugarElement<Node & ParentNode>) => T,
+    complete: () => T
+  ) => T;
+  match: <T> (branches: {
+    stopped: () => T;
+    resume: (elem: SugarElement<Node & ParentNode>) => T;
+    complete: () => T;
+  }) => T;
+  log: (label: string) => void;
+}
+const adt: {
+  stopped: () => TriggerAdt;
+  resume: (elem: SugarElement<Node & ParentNode>) => TriggerAdt;
+  complete: () => TriggerAdt;
+} = Adt.generate([
+  { stopped: [ ] },
+  { resume: [ 'element' ] },
+  { complete: [ ] }
+]);
+const doTriggerHandler = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, target: SugarElement<Node>, source: Cell<SugarElement<Node>>, logger: DebuggerLogger): TriggerAdt => {
+  const handler = lookup(eventType, target);
+  const simulatedEvent = fromSource(rawEvent, source);
+  return handler.fold(() => {
+    logger.logEventNoHandlers(eventType, target);
+    return adt.complete();
+  }, (handlerInfo) => {
+    const descHandler = handlerInfo.descHandler;
+    const eventHandler = DescribedHandler.getCurried(descHandler);
+    eventHandler(simulatedEvent);
+    if (simulatedEvent.isStopped()) {
+      logger.logEventStopped(eventType, handlerInfo.element, descHandler.purpose);
+      return adt.stopped();
+    } else if (simulatedEvent.isCut()) {
+      logger.logEventCut(eventType, handlerInfo.element, descHandler.purpose);
+      return adt.complete();
+    } else {
+      return Traverse.parent(handlerInfo.element).fold(() => {
+        logger.logNoParent(eventType, handlerInfo.element, descHandler.purpose);
+        return adt.complete();
+      }, (parent) => {
+        logger.logEventResponse(eventType, handlerInfo.element, descHandler.purpose);
+        return adt.resume(parent);
+      });
+    }
+  });
+};
+const doTriggerOnUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, rawTarget: SugarElement<Node>, source: Cell<SugarElement<Node>>, logger: DebuggerLogger): boolean =>
+  doTriggerHandler(lookup, eventType, rawEvent, rawTarget, source, logger).fold(
+    Fun.always,
+    (parent) => doTriggerOnUntilStopped(lookup, eventType, rawEvent, parent, source, logger),
+    Fun.never
+  );
+const triggerHandler = <T extends EventFormat>(lookup: LookupEvent, eventType: string, rawEvent: T, target: SugarElement<Node>, logger: DebuggerLogger): TriggerAdt => {
+  const source = EventSource.derive(rawEvent, target);
+  return doTriggerHandler(lookup, eventType, rawEvent, target, source, logger);
+};
+const broadcast = (listeners: UidAndHandler[], rawEvent: EventFormat, _logger?: DebuggerLogger): boolean => {
+  const simulatedEvent = fromExternal(rawEvent);
+  Arr.each(listeners, (listener) => {
+    const descHandler = listener.descHandler;
+    const handler = DescribedHandler.getCurried(descHandler);
+    handler(simulatedEvent);
+  });
+  return simulatedEvent.isStopped();
+};
+const triggerUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, logger: DebuggerLogger): boolean =>
+  triggerOnUntilStopped(lookup, eventType, rawEvent, rawEvent.target, logger);
+const triggerOnUntilStopped = (lookup: LookupEvent, eventType: string, rawEvent: EventFormat, rawTarget: SugarElement<Node>, logger: DebuggerLogger): boolean => {
+  const source = EventSource.derive(rawEvent, rawTarget);
+  return doTriggerOnUntilStopped(lookup, eventType, rawEvent, rawTarget, source, logger);
+};
+export {
+  triggerHandler,
+  triggerUntilStopped,
+  triggerOnUntilStopped,
+  broadcast
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/foreign/ForeignCache.ts
@@ -0,0 +1,41 @@
+import { Obj } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as DomState from '../alien/DomState';
+import { Dragging } from '../api/behaviour/Dragging';
+import { Pinching } from '../api/behaviour/Pinching';
+import { Toggling } from '../api/behaviour/Toggling';
+import * as CompBehaviours from '../api/component/CompBehaviours';
+import { DispatchedAlloyConfig } from '../api/system/ForeignGui';
+import * as BehaviourBlob from '../behaviour/common/BehaviourBlob';
+import * as ComponentEvents from '../construct/ComponentEvents';
+import { UncurriedHandler } from '../events/EventRegistry';
+interface Events {
+  readonly elem: SugarElement<Node>;
+  readonly evts: Record<string, UncurriedHandler>;
+}
+export interface ForeignCache {
+  readonly getEvents: (elem: SugarElement<Node>, spec: DispatchedAlloyConfig) => Events;
+}
+export default (): ForeignCache => {
+  const getEvents = (elem: SugarElement<Node>, spec: DispatchedAlloyConfig): Events => {
+    const evts = DomState.getOrCreate(elem, () => {
+      const info = {
+        events: Obj.hasNonNullableKey(spec, 'events') ? spec.events : { },
+        eventOrder: Obj.hasNonNullableKey(spec, 'eventOrder') ? spec.eventOrder : { }
+      };
+      const bInfo = CompBehaviours.generateFrom(spec, [ Toggling, Dragging, Pinching ]);
+      const baseEvents = {
+        'alloy.base.behaviour': info.events
+      };
+      const bData = BehaviourBlob.getData(bInfo);
+      return ComponentEvents.combine(bData, info.eventOrder, [ Toggling, Dragging, Pinching ], baseEvents).getOrDie();
+    });
+    return {
+      elem,
+      evts
+    };
+  };
+  return {
+    getEvents
+  };
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/frame/Frames.ts
@@ -0,0 +1,19 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { Navigation } from './Navigation';
+const walkUp = (navigation: Navigation, doc: SugarElement<Document>): SugarElement<Element>[] => {
+  const frame = navigation.view(doc);
+  return frame.fold(Fun.constant([]), (f) => {
+    const parent = navigation.owner(f);
+    const rest = walkUp(navigation, parent);
+    return [ f ].concat(rest);
+  });
+};
+const pathTo = (element: SugarElement<Node>, navigation: Navigation): Optional<SugarElement<Element>[]> => {
+  const d = navigation.owner(element);
+  const paths = walkUp(navigation, d);
+  return Optional.some(paths);
+};
+export {
+  pathTo
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/frame/OuterPosition.ts
@@ -0,0 +1,23 @@
+import { Arr, Fun } from '@ephox/katamari';
+import { Scroll, SugarDocument, SugarElement, SugarLocation, SugarPosition } from '@ephox/sugar';
+import * as Frames from './Frames';
+import * as Navigation from './Navigation';
+const find = (element: SugarElement<Element>): SugarPosition => {
+  const doc = SugarDocument.getDocument();
+  const scroll = Scroll.get(doc);
+  const path = Frames.pathTo(element, Navigation);
+  return path.fold(Fun.curry(SugarLocation.absolute, element), (frames) => {
+    const offset = SugarLocation.viewport(element);
+    const r = Arr.foldr(frames, (b, a) => {
+      const loc = SugarLocation.viewport(a);
+      return {
+        left: b.left + loc.left,
+        top: b.top + loc.top
+      };
+    }, { left: 0, top: 0 });
+    return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);
+  });
+};
+export {
+  find
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/FlatgridType.ts
@@ -0,0 +1,77 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Fun, Optional } from '@ephox/katamari';
+import { SelectorFind, SugarElement } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as KeyingState from '../behaviour/keyboard/KeyingState';
+import * as Fields from '../data/Fields';
+import { NativeSimulatedEvent } from '../events/SimulatedEvent';
+import * as DomMovement from '../navigation/DomMovement';
+import * as DomPinpoint from '../navigation/DomPinpoint';
+import * as KeyMatch from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import * as WrapArrNavigation from '../navigation/WrapArrNavigation';
+import { FlatgridConfig, FlatgridState, KeyRuleHandler } from './KeyingModeTypes';
+import * as KeyingType from './KeyingType';
+import * as KeyingTypes from './KeyingTypes';
+const schema = [
+  FieldSchema.required('selector'),
+  FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
+  Fields.onKeyboardHandler('onEscape'),
+  FieldSchema.defaulted('captureTab', false),
+  Fields.initSize()
+];
+const focusIn = (component: AlloyComponent, gridConfig: FlatgridConfig, _gridState: FlatgridState): void => {
+  SelectorFind.descendant<HTMLElement>(component.element, gridConfig.selector).each((first) => {
+    gridConfig.focusManager.set(component, first);
+  });
+};
+const findCurrent = (component: AlloyComponent, gridConfig: FlatgridConfig): Optional<SugarElement<HTMLElement>> =>
+  gridConfig.focusManager.get(component).bind((elem) => SelectorFind.closest(elem, gridConfig.selector));
+const execute = (
+  component: AlloyComponent,
+  simulatedEvent: NativeSimulatedEvent,
+  gridConfig: FlatgridConfig,
+  _gridState: FlatgridState
+): Optional<boolean> =>
+  findCurrent(component, gridConfig)
+    .bind((focused) => gridConfig.execute(component, simulatedEvent, focused));
+const doMove = (
+  cycle: WrapArrNavigation.ArrNavigationFunc<SugarElement<HTMLElement>>
+): DomMovement.ElementMover<FlatgridConfig, FlatgridState> =>
+  (element, focused, gridConfig, gridState) =>
+    DomPinpoint.locateVisible(element, focused, gridConfig.selector)
+      .bind((identified) => cycle(
+        identified.candidates,
+        identified.index,
+        gridState.getNumRows().getOr(gridConfig.initSize.numRows),
+        gridState.getNumColumns().getOr(gridConfig.initSize.numColumns)
+      ));
+const handleTab: KeyRuleHandler<FlatgridConfig, FlatgridState> = (_component, _simulatedEvent, gridConfig) =>
+  gridConfig.captureTab ? Optional.some<boolean>(true) : Optional.none();
+const doEscape: KeyRuleHandler<FlatgridConfig, FlatgridState> = (component, simulatedEvent, gridConfig) =>
+  gridConfig.onEscape(component, simulatedEvent);
+const moveLeft = doMove(WrapArrNavigation.cycleLeft);
+const moveRight = doMove(WrapArrNavigation.cycleRight);
+const moveNorth = doMove(WrapArrNavigation.cycleUp);
+const moveSouth = doMove(WrapArrNavigation.cycleDown);
+const getKeydownRules: () => Array<KeyRules.KeyRule<FlatgridConfig, FlatgridState>> = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.LEFT), DomMovement.west<FlatgridConfig, FlatgridState>(moveLeft, moveRight)),
+  KeyRules.rule(KeyMatch.inSet(Keys.RIGHT), DomMovement.east(moveLeft, moveRight)),
+  KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.north(moveNorth)),
+  KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.south(moveSouth)),
+  KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), handleTab),
+  KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.TAB) ]), handleTab),
+  KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), doEscape),
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE.concat(Keys.ENTER)), execute)
+]);
+const getKeyupRules: () => Array<KeyRules.KeyRule<FlatgridConfig, FlatgridState>> = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
+]);
+export default KeyingType.typical(
+  schema,
+  KeyingState.flatgrid,
+  getKeydownRules,
+  getKeyupRules,
+  () => Optional.some(focusIn)
+);

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/FlowType.ts
@@ -0,0 +1,68 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Fun, Optional } from '@ephox/katamari';
+import { SelectorFind, SugarElement } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { NoState, Stateless } from '../behaviour/common/BehaviourState';
+import * as Fields from '../data/Fields';
+import { NativeSimulatedEvent } from '../events/SimulatedEvent';
+import * as DomMovement from '../navigation/DomMovement';
+import * as DomNavigation from '../navigation/DomNavigation';
+import * as KeyMatch from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import { FlowConfig, KeyRuleHandler } from './KeyingModeTypes';
+import * as KeyingType from './KeyingType';
+import * as KeyingTypes from './KeyingTypes';
+const schema = [
+  FieldSchema.required('selector'),
+  FieldSchema.defaulted('getInitial', Optional.none),
+  FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
+  Fields.onKeyboardHandler('onEscape'),
+  FieldSchema.defaulted('executeOnMove', false),
+  FieldSchema.defaulted('allowVertical', true)
+];
+const findCurrent = (component: AlloyComponent, flowConfig: FlowConfig): Optional<SugarElement<HTMLElement>> =>
+  flowConfig.focusManager.get(component).bind((elem) => SelectorFind.closest(elem, flowConfig.selector));
+const execute = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent, flowConfig: FlowConfig): Optional<boolean> =>
+  findCurrent(component, flowConfig).bind((focused) => flowConfig.execute(component, simulatedEvent, focused));
+const focusIn = (component: AlloyComponent, flowConfig: FlowConfig, _state: Stateless): void => {
+  flowConfig.getInitial(component).orThunk(
+    () => SelectorFind.descendant<HTMLElement>(component.element, flowConfig.selector)
+  ).each((first) => {
+    flowConfig.focusManager.set(component, first);
+  });
+};
+const moveLeft = (element: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, info: FlowConfig): Optional<SugarElement<HTMLElement>> =>
+  DomNavigation.horizontal(element, info.selector, focused, -1);
+const moveRight = (element: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, info: FlowConfig): Optional<SugarElement<HTMLElement>> =>
+  DomNavigation.horizontal(element, info.selector, focused, +1);
+const doMove = (movement: KeyRuleHandler<FlowConfig, Stateless>): KeyRuleHandler<FlowConfig, Stateless> =>
+  (component, simulatedEvent, flowConfig, flowState) =>
+    movement(component, simulatedEvent, flowConfig, flowState).bind(
+      () =>
+        flowConfig.executeOnMove ?
+          execute(component, simulatedEvent, flowConfig) :
+          Optional.some<boolean>(true)
+    );
+const doEscape: KeyRuleHandler<FlowConfig, Stateless> = (component, simulatedEvent, flowConfig) =>
+  flowConfig.onEscape(component, simulatedEvent);
+const getKeydownRules = (
+  _component: AlloyComponent,
+  _se: NativeSimulatedEvent,
+  flowConfig: FlowConfig,
+  _flowState: Stateless
+): Array<KeyRules.KeyRule<FlowConfig, Stateless>> => {
+  const westMovers = Keys.LEFT.concat(flowConfig.allowVertical ? Keys.UP : [ ]);
+  const eastMovers = Keys.RIGHT.concat(flowConfig.allowVertical ? Keys.DOWN : [ ]);
+  return [
+    KeyRules.rule(KeyMatch.inSet(westMovers), doMove(DomMovement.west(moveLeft, moveRight))),
+    KeyRules.rule(KeyMatch.inSet(eastMovers), doMove(DomMovement.east(moveLeft, moveRight))),
+    KeyRules.rule(KeyMatch.inSet(Keys.ENTER), execute),
+    KeyRules.rule(KeyMatch.inSet(Keys.SPACE), execute),
+    KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), doEscape)
+  ];
+};
+const getKeyupRules: () => Array<KeyRules.KeyRule<FlowConfig, Stateless>> = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
+]);
+export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/KeyingModeTypes.ts
@@ -0,0 +1,180 @@
+import { Optional } from '@ephox/katamari';
+import { EventArgs, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AlloyEvents from '../api/events/AlloyEvents';
+import { FocusManager } from '../api/focus/FocusManagers';
+import { BehaviourState, Stateless } from '../behaviour/common/BehaviourState';
+import { NativeSimulatedEvent, SimulatedEvent } from '../events/SimulatedEvent';
+export type KeyHandlerApi = (comp: AlloyComponent, se: NativeSimulatedEvent<KeyboardEvent>) => Optional<boolean>;
+export type KeyRuleHandler<C, S> = (comp: AlloyComponent, se: NativeSimulatedEvent<KeyboardEvent>, config: C, state: S) => Optional<boolean>;
+export enum FocusInsideModes {
+  OnFocusMode = 'onFocus',
+  OnEnterOrSpaceMode = 'onEnterOrSpace',
+  OnApiMode = 'onApi'
+}
+export interface GeneralKeyingConfigSpec {
+  focusManager?: FocusManager;
+  focusInside?: FocusInsideModes;
+}
+export interface GeneralKeyingConfig {
+  focusManager: FocusManager;
+  sendFocusIn: <C extends GeneralKeyingConfig, S>(conf: C) => Optional<(comp: AlloyComponent, config: C, state: S, evt?: SimulatedEvent<EventArgs>) => void>;
+  focusInside: FocusInsideModes;
+  handler: {
+    toEvents: <C extends GeneralKeyingConfig, S>(keyingConfig: C, keyingState: S) => AlloyEvents.AlloyEventRecord;
+  };
+  state: <C extends GeneralKeyingConfig>(spec: C) => Stateless | FlatgridState;
+}
+export interface TabbingConfigSpec extends GeneralKeyingConfigSpec {
+  onEscape?: KeyHandlerApi;
+  onEnter?: KeyHandlerApi;
+  selector?: string;
+  firstTabstop?: number;
+  useTabstopAt?: (elem: SugarElement<HTMLElement>) => boolean;
+  visibilitySelector?: string;
+}
+export interface TabbingConfig extends GeneralKeyingConfig {
+  onEscape: Optional<KeyHandlerApi>;
+  onEnter: Optional<KeyHandlerApi>;
+  selector: string;
+  firstTabstop: number;
+  useTabstopAt: (elem: SugarElement<HTMLElement>) => boolean;
+  visibilitySelector: Optional<string>;
+  cyclic: boolean;
+}
+export interface AcylicConfigSpec extends TabbingConfigSpec {
+  mode: 'acyclic';
+}
+export interface CyclicConfigSpec extends TabbingConfigSpec {
+  mode: 'cyclic';
+}
+export interface AcyclicConfig extends TabbingConfig {
+  cyclic: false;
+}
+export interface CyclicConfig extends TabbingConfig {
+  cyclic: true;
+}
+export interface EscapingConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'escaping';
+  onEscape: KeyHandlerApi;
+}
+export interface EscapingConfig extends GeneralKeyingConfig {
+  onEscape: KeyHandlerApi;
+}
+export interface ExecutingConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'execution';
+  execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  useSpace?: boolean;
+  useEnter?: boolean;
+  useControlEnter?: boolean;
+  useDown?: boolean;
+}
+export interface ExecutingConfig extends GeneralKeyingConfig {
+  execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  useSpace: boolean;
+  useEnter: boolean;
+  useControlEnter: boolean;
+  useDown: boolean;
+}
+export interface FlatgridConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'flatgrid';
+  selector: string;
+  execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  onEscape?: KeyHandlerApi;
+  captureTab?: boolean;
+  initSize: {
+    numColumns: number;
+    numRows: number;
+  };
+}
+export interface FlatgridConfig extends GeneralKeyingConfig {
+  selector: string;
+  execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  onEscape: KeyHandlerApi;
+  captureTab: boolean;
+  initSize: {
+    numColumns: number;
+    numRows: number;
+  };
+}
+export interface FlatgridState extends BehaviourState {
+  getNumRows: () => Optional<number>;
+  getNumColumns: () => Optional<number>;
+  setGridSize: (numRows: number, numColumns: number) => void;
+}
+export interface FlowConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'flow';
+  selector: string;
+  getInitial?: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
+  onEscape?: KeyHandlerApi;
+  execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  executeOnMove?: boolean;
+  allowVertical?: boolean;
+}
+export interface FlowConfig extends GeneralKeyingConfig {
+  selector: string;
+  getInitial: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
+  onEscape: KeyHandlerApi;
+  execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  executeOnMove: boolean;
+  allowVertical: boolean;
+}
+export interface MatrixConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'matrix';
+  selectors: {
+    row: string;
+    cell: string;
+  };
+  cycles?: boolean;
+  previousSelector?: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
+  execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+}
+export interface MatrixConfig extends GeneralKeyingConfig {
+  selectors: {
+    row: string;
+    cell: string;
+  };
+  cycles: boolean;
+  previousSelector: (comp: AlloyComponent) => Optional<SugarElement<HTMLElement>>;
+  execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+}
+export interface MenuConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'menu';
+  selector: string;
+  execute?: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  moveOnTab?: boolean;
+}
+export interface MenuConfig extends GeneralKeyingConfig {
+  selector: string;
+  execute: (comp: AlloyComponent, se: NativeSimulatedEvent, focused: SugarElement<HTMLElement>) => Optional<boolean>;
+  moveOnTab: boolean;
+}
+export interface SpecialConfigSpec extends GeneralKeyingConfigSpec {
+  mode: 'special';
+  onSpace?: KeyHandlerApi;
+  onEnter?: KeyHandlerApi;
+  onShiftEnter?: KeyHandlerApi;
+  onLeft?: KeyHandlerApi;
+  onRight?: KeyHandlerApi;
+  onTab?: KeyHandlerApi;
+  onShiftTab?: KeyHandlerApi;
+  onUp?: KeyHandlerApi;
+  onDown?: KeyHandlerApi;
+  onEscape?: KeyHandlerApi;
+  stopSpaceKeyup?: boolean;
+  focusIn?: (comp: AlloyComponent, info: SpecialConfig, state: Stateless) => void;
+}
+export interface SpecialConfig extends GeneralKeyingConfig {
+  onSpace: KeyHandlerApi;
+  onEnter: KeyHandlerApi;
+  onShiftEnter: KeyHandlerApi;
+  onLeft: KeyHandlerApi;
+  onRight: KeyHandlerApi;
+  onTab: KeyHandlerApi;
+  onShiftTab: KeyHandlerApi;
+  onUp: KeyHandlerApi;
+  onDown: KeyHandlerApi;
+  onEscape: KeyHandlerApi;
+  stopSpaceKeyup: boolean;
+  focusIn: Optional<(comp: AlloyComponent, info: SpecialConfig, state: Stateless) => void>;
+}

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/KeyingType.ts
@@ -0,0 +1,87 @@
+import { FieldProcessor, FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Arr, Optional, Result } from '@ephox/katamari';
+import { EventArgs } from '@ephox/sugar';
+import * as EventRoot from '../alien/EventRoot';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AlloyEvents from '../api/events/AlloyEvents';
+import * as NativeEvents from '../api/events/NativeEvents';
+import * as SystemEvents from '../api/events/SystemEvents';
+import * as FocusManagers from '../api/focus/FocusManagers';
+import { BehaviourState } from '../behaviour/common/BehaviourState';
+import * as Fields from '../data/Fields';
+import { EventFormat, NativeSimulatedEvent, SimulatedEvent } from '../events/SimulatedEvent';
+import { inSet } from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import { FocusInsideModes, GeneralKeyingConfig } from './KeyingModeTypes';
+type GetRulesFunc<C extends GeneralKeyingConfig, S extends BehaviourState> = (component: AlloyComponent, simulatedEvent: SimulatedEvent<EventArgs>, keyingConfig: C, keyingState: S) => Array<KeyRules.KeyRule<C, S>>;
+export interface KeyingType <C extends GeneralKeyingConfig, S extends BehaviourState> {
+  readonly schema: () => FieldProcessor[];
+  readonly processKey: (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>, getRules: GetRulesFunc<C, S>, keyingConfig: C, keyingState: S) => Optional<boolean>;
+  readonly toEvents: (keyingConfig: C, keyingState: S) => AlloyEvents.AlloyEventRecord;
+}
+const typical = <C extends GeneralKeyingConfig, S extends BehaviourState>(
+  infoSchema: FieldProcessor[],
+  stateInit: (config: C) => BehaviourState,
+  getKeydownRules: (comp: AlloyComponent, se: NativeSimulatedEvent, config: C, state: S) => Array<KeyRules.KeyRule<C, S>>,
+  getKeyupRules: (comp: AlloyComponent, se: NativeSimulatedEvent, config: C, state: S) => Array<KeyRules.KeyRule<C, S>>,
+  optFocusIn: (config: C) => Optional<(comp: AlloyComponent, config: C, state: S) => void>): KeyingType<C, S> => {
+  const schema = () => infoSchema.concat([
+    FieldSchema.defaulted('focusManager', FocusManagers.dom()),
+    FieldSchema.defaultedOf('focusInside', 'onFocus', StructureSchema.valueOf((val) => Arr.contains([ 'onFocus', 'onEnterOrSpace', 'onApi' ], val) ? Result.value(val) : Result.error('Invalid value for focusInside'))),
+    Fields.output('handler', me),
+    Fields.output('state', stateInit),
+    Fields.output('sendFocusIn', optFocusIn)
+  ]);
+  const processKey = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>, getRules: GetRulesFunc<C, S>, keyingConfig: C, keyingState: S): Optional<boolean> => {
+    const rules = getRules(component, simulatedEvent, keyingConfig, keyingState);
+    return KeyRules.choose(rules, simulatedEvent.event).bind((rule) => rule(component, simulatedEvent, keyingConfig, keyingState));
+  };
+  const toEvents = (keyingConfig: C, keyingState: S): AlloyEvents.AlloyEventRecord => {
+    const onFocusHandler = keyingConfig.focusInside !== FocusInsideModes.OnFocusMode
+      ? Optional.none<AlloyEvents.AlloyEventKeyAndHandler<EventFormat>>()
+      : optFocusIn(keyingConfig).map((focusIn) =>
+        AlloyEvents.run<EventArgs<FocusEvent>>(SystemEvents.focus(), (component, simulatedEvent) => {
+          focusIn(component, keyingConfig, keyingState);
+          simulatedEvent.stop();
+        }));
+    const tryGoInsideComponent = (component: AlloyComponent, simulatedEvent: SimulatedEvent<EventArgs<KeyboardEvent>>) => {
+      const isEnterOrSpace = inSet(Keys.SPACE.concat(Keys.ENTER))(simulatedEvent.event);
+      if (keyingConfig.focusInside === FocusInsideModes.OnEnterOrSpaceMode && isEnterOrSpace && EventRoot.isSource(component, simulatedEvent)) {
+        optFocusIn(keyingConfig).each((focusIn) => {
+          focusIn(component, keyingConfig, keyingState);
+          simulatedEvent.stop();
+        });
+      }
+    };
+    const keyboardEvents = [
+      AlloyEvents.run<EventArgs<KeyboardEvent>>(NativeEvents.keydown(), (component, simulatedEvent) => {
+        processKey(component, simulatedEvent, getKeydownRules, keyingConfig, keyingState).fold(
+          () => {
+            tryGoInsideComponent(component, simulatedEvent);
+          },
+          (_) => {
+            simulatedEvent.stop();
+          }
+        );
+      }),
+      AlloyEvents.run<EventArgs<KeyboardEvent>>(NativeEvents.keyup(), (component, simulatedEvent) => {
+        processKey(component, simulatedEvent, getKeyupRules, keyingConfig, keyingState).each((_) => {
+          simulatedEvent.stop();
+        });
+      })
+    ];
+    return AlloyEvents.derive(
+      onFocusHandler.toArray().concat(keyboardEvents as Array<AlloyEvents.AlloyEventKeyAndHandler<EventArgs>>)
+    );
+  };
+  const me = {
+    schema,
+    processKey,
+    toEvents
+  };
+  return me;
+};
+export {
+  typical
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/KeyingTypes.ts
@@ -0,0 +1,34 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import * as EditableFields from '../alien/EditableFields';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AlloyTriggers from '../api/events/AlloyTriggers';
+import * as SystemEvents from '../api/events/SystemEvents';
+import { NativeSimulatedEvent } from '../events/SimulatedEvent';
+import * as KeyMatch from '../navigation/KeyMatch';
+import { GeneralKeyingConfig, KeyRuleHandler } from './KeyingModeTypes';
+const doDefaultExecute = (
+  component: AlloyComponent,
+  _simulatedEvent: NativeSimulatedEvent<KeyboardEvent>,
+  focused: SugarElement<HTMLElement>
+): Optional<boolean> => {
+  AlloyTriggers.dispatch(component, focused, SystemEvents.execute());
+  return Optional.some(true);
+};
+const defaultExecute = (
+  component: AlloyComponent,
+  simulatedEvent: NativeSimulatedEvent<KeyboardEvent>,
+  focused: SugarElement<HTMLElement>
+): Optional<boolean> => {
+  const isComplex = EditableFields.inside(focused) && KeyMatch.inSet(Keys.SPACE)(simulatedEvent.event);
+  return isComplex ? Optional.none() : doDefaultExecute(component, simulatedEvent, focused);
+};
+const stopEventForFirefox: KeyRuleHandler<GeneralKeyingConfig, any> = (
+  _component: AlloyComponent,
+  _simulatedEvent: NativeSimulatedEvent<KeyboardEvent>
+) => Optional.some<boolean>(true);
+export {
+  defaultExecute,
+  stopEventForFirefox
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/MatrixType.ts
@@ -0,0 +1,63 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Arr, Fun, Optional } from '@ephox/katamari';
+import { Focus, SelectorFilter, SelectorFind, SugarElement } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { NoState, Stateless } from '../behaviour/common/BehaviourState';
+import * as DomMovement from '../navigation/DomMovement';
+import * as DomPinpoint from '../navigation/DomPinpoint';
+import * as KeyMatch from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import * as MatrixNavigation from '../navigation/MatrixNavigation';
+import { KeyRuleHandler, MatrixConfig } from './KeyingModeTypes';
+import * as KeyingType from './KeyingType';
+import * as KeyingTypes from './KeyingTypes';
+const schema = [
+  FieldSchema.requiredObjOf('selectors', [
+    FieldSchema.required('row'),
+    FieldSchema.required('cell')
+  ]),
+  FieldSchema.defaulted('cycles', true),
+  FieldSchema.defaulted('previousSelector', Optional.none),
+  FieldSchema.defaulted('execute', KeyingTypes.defaultExecute)
+];
+const focusIn = (component: AlloyComponent, matrixConfig: MatrixConfig, _state: Stateless): void => {
+  const focused = matrixConfig.previousSelector(component).orThunk(() => {
+    const selectors = matrixConfig.selectors;
+    return SelectorFind.descendant<HTMLElement>(component.element, selectors.cell);
+  });
+  focused.each((cell) => {
+    matrixConfig.focusManager.set(component, cell);
+  });
+};
+const execute: KeyRuleHandler<MatrixConfig, Stateless> = (component, simulatedEvent, matrixConfig) => Focus.search(component.element).bind((focused) => matrixConfig.execute(component, simulatedEvent, focused));
+const toMatrix = (rows: SugarElement<HTMLElement>[], matrixConfig: MatrixConfig): SugarElement<HTMLElement>[][] =>
+  Arr.map(rows, (row) => SelectorFilter.descendants(row, matrixConfig.selectors.cell));
+const doMove = (ifCycle: MatrixNavigation.MatrixNavigationFunc<SugarElement<HTMLElement>>, ifMove: MatrixNavigation.MatrixNavigationFunc<SugarElement<HTMLElement>>): DomMovement.ElementMover<MatrixConfig, Stateless> => (element, focused, matrixConfig) => {
+  const move = matrixConfig.cycles ? ifCycle : ifMove;
+  return SelectorFind.closest(focused, matrixConfig.selectors.row).bind((inRow) => {
+    const cellsInRow = SelectorFilter.descendants(inRow, matrixConfig.selectors.cell);
+    return DomPinpoint.findIndex(cellsInRow, focused).bind((colIndex) => {
+      const allRows = SelectorFilter.descendants<HTMLElement>(element, matrixConfig.selectors.row);
+      return DomPinpoint.findIndex(allRows, inRow).bind((rowIndex) => {
+        const matrix = toMatrix(allRows, matrixConfig);
+        return move(matrix, rowIndex, colIndex).map((next) => next.cell);
+      });
+    });
+  });
+};
+const moveLeft = doMove(MatrixNavigation.cycleLeft, MatrixNavigation.moveLeft);
+const moveRight = doMove(MatrixNavigation.cycleRight, MatrixNavigation.moveRight);
+const moveNorth = doMove(MatrixNavigation.cycleUp, MatrixNavigation.moveUp);
+const moveSouth = doMove(MatrixNavigation.cycleDown, MatrixNavigation.moveDown);
+const getKeydownRules: () => Array<KeyRules.KeyRule<MatrixConfig, Stateless>> = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.LEFT), DomMovement.west(moveLeft, moveRight)),
+  KeyRules.rule(KeyMatch.inSet(Keys.RIGHT), DomMovement.east(moveLeft, moveRight)),
+  KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.north(moveNorth)),
+  KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.south(moveSouth)),
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE.concat(Keys.ENTER)), execute)
+]);
+const getKeyupRules: () => Array<KeyRules.KeyRule<MatrixConfig, Stateless>> = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
+]);
+export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/MenuType.ts
@@ -0,0 +1,40 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Fun, Optional } from '@ephox/katamari';
+import { SelectorFind } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { NoState, Stateless } from '../behaviour/common/BehaviourState';
+import * as DomMovement from '../navigation/DomMovement';
+import * as DomNavigation from '../navigation/DomNavigation';
+import * as KeyMatch from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import { KeyRuleHandler, MenuConfig } from './KeyingModeTypes';
+import * as KeyingType from './KeyingType';
+import * as KeyingTypes from './KeyingTypes';
+const schema = [
+  FieldSchema.required('selector'),
+  FieldSchema.defaulted('execute', KeyingTypes.defaultExecute),
+  FieldSchema.defaulted('moveOnTab', false)
+];
+const execute: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig) => menuConfig.focusManager.get(component).bind((focused) => menuConfig.execute(component, simulatedEvent, focused));
+const focusIn = (component: AlloyComponent, menuConfig: MenuConfig, _state: Stateless): void => {
+  SelectorFind.descendant<HTMLElement>(component.element, menuConfig.selector).each((first) => {
+    menuConfig.focusManager.set(component, first);
+  });
+};
+const moveUp: DomMovement.ElementMover<MenuConfig, Stateless> = (element, focused, info) => DomNavigation.horizontal(element, info.selector, focused, -1);
+const moveDown: DomMovement.ElementMover<MenuConfig, Stateless> = (element, focused, info) => DomNavigation.horizontal(element, info.selector, focused, +1);
+const fireShiftTab: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? DomMovement.move(moveUp)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
+const fireTab: KeyRuleHandler<MenuConfig, Stateless> = (component, simulatedEvent, menuConfig, menuState) => menuConfig.moveOnTab ? DomMovement.move(moveDown)(component, simulatedEvent, menuConfig, menuState) : Optional.none();
+const getKeydownRules = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.UP), DomMovement.move(moveUp)),
+  KeyRules.rule(KeyMatch.inSet(Keys.DOWN), DomMovement.move(moveDown)),
+  KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), fireShiftTab),
+  KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.TAB) ]), fireTab),
+  KeyRules.rule(KeyMatch.inSet(Keys.ENTER), execute),
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE), execute)
+]);
+const getKeyupRules = Fun.constant([
+  KeyRules.rule(KeyMatch.inSet(Keys.SPACE), KeyingTypes.stopEventForFirefox)
+]);
+export default KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/keying/TabbingTypes.ts
@@ -0,0 +1,95 @@
+import { FieldProcessor, FieldSchema } from '@ephox/boulder';
+import { Arr, Fun, Optional } from '@ephox/katamari';
+import { Compare, Height, SelectorFilter, SelectorFind, SugarElement } from '@ephox/sugar';
+import * as Keys from '../alien/Keys';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { NoState, Stateless } from '../behaviour/common/BehaviourState';
+import { NativeSimulatedEvent } from '../events/SimulatedEvent';
+import * as ArrNavigation from '../navigation/ArrNavigation';
+import * as KeyMatch from '../navigation/KeyMatch';
+import * as KeyRules from '../navigation/KeyRules';
+import { KeyRuleHandler, TabbingConfig } from './KeyingModeTypes';
+import * as KeyingType from './KeyingType';
+const create = (cyclicField: FieldProcessor): KeyingType.KeyingType<TabbingConfig, Stateless> => {
+  const schema: FieldProcessor[] = [
+    FieldSchema.option('onEscape'),
+    FieldSchema.option('onEnter'),
+    FieldSchema.defaulted('selector', '[data-alloy-tabstop="true"]:not(:disabled)'),
+    FieldSchema.defaulted('firstTabstop', 0),
+    FieldSchema.defaulted('useTabstopAt', Fun.always),
+    FieldSchema.option('visibilitySelector')
+  ].concat([
+    cyclicField
+  ]);
+  const isVisible = (tabbingConfig: TabbingConfig, element: SugarElement<HTMLElement>): boolean => {
+    const target = tabbingConfig.visibilitySelector
+      .bind((sel) => SelectorFind.closest<HTMLElement>(element, sel))
+      .getOr(element);
+    return Height.get(target) > 0;
+  };
+  const findInitial = (component: AlloyComponent, tabbingConfig: TabbingConfig): Optional<SugarElement<HTMLElement>> => {
+    const tabstops: SugarElement<HTMLElement>[] = SelectorFilter.descendants<HTMLElement>(component.element, tabbingConfig.selector);
+    const visibles: SugarElement<HTMLElement>[] = Arr.filter(tabstops, (elem) => isVisible(tabbingConfig, elem));
+    return Optional.from(visibles[tabbingConfig.firstTabstop]);
+  };
+  const findCurrent = (component: AlloyComponent, tabbingConfig: TabbingConfig): Optional<SugarElement<HTMLElement>> =>
+    tabbingConfig.focusManager.get(component)
+      .bind((elem) => SelectorFind.closest<HTMLElement>(elem, tabbingConfig.selector));
+  const isTabstop = (tabbingConfig: TabbingConfig, element: SugarElement<HTMLElement>): boolean =>
+    isVisible(tabbingConfig, element) && tabbingConfig.useTabstopAt(element);
+  const focusIn = (component: AlloyComponent, tabbingConfig: TabbingConfig, _tabbingState: Stateless): void => {
+    findInitial(component, tabbingConfig).each((target) => {
+      tabbingConfig.focusManager.set(component, target);
+    });
+  };
+  const goFromTabstop = (
+    component: AlloyComponent,
+    tabstops: SugarElement<HTMLElement>[],
+    stopIndex: number,
+    tabbingConfig: TabbingConfig,
+    cycle: ArrNavigation.ArrCycle<SugarElement<HTMLElement>>
+  ): Optional<boolean> =>
+    cycle(tabstops, stopIndex, (elem) => isTabstop(tabbingConfig, elem))
+      .fold(
+        () => tabbingConfig.cyclic ? Optional.some<boolean>(true) : Optional.none(),
+        (target) => {
+          tabbingConfig.focusManager.set(component, target);
+          return Optional.some<boolean>(true);
+        }
+      );
+  const go = (
+    component: AlloyComponent,
+    _simulatedEvent: NativeSimulatedEvent,
+    tabbingConfig: TabbingConfig,
+    cycle: ArrNavigation.ArrCycle<SugarElement<HTMLElement>>
+  ): Optional<boolean> => {
+    const tabstops = SelectorFilter.descendants<HTMLElement>(component.element, tabbingConfig.selector);
+    return findCurrent(component, tabbingConfig).bind((tabstop) => {
+      const optStopIndex = Arr.findIndex(tabstops, Fun.curry(Compare.eq, tabstop));
+      return optStopIndex.bind((stopIndex) => goFromTabstop(component, tabstops, stopIndex, tabbingConfig, cycle));
+    });
+  };
+  const goBackwards: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) => {
+    const navigate = tabbingConfig.cyclic ? ArrNavigation.cyclePrev : ArrNavigation.tryPrev;
+    return go(component, simulatedEvent, tabbingConfig, navigate);
+  };
+  const goForwards: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) => {
+    const navigate = tabbingConfig.cyclic ? ArrNavigation.cycleNext : ArrNavigation.tryNext;
+    return go(component, simulatedEvent, tabbingConfig, navigate);
+  };
+  const execute: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) =>
+    tabbingConfig.onEnter.bind((f) => f(component, simulatedEvent));
+  const exit: KeyRuleHandler<TabbingConfig, Stateless> = (component, simulatedEvent, tabbingConfig) =>
+    tabbingConfig.onEscape.bind((f) => f(component, simulatedEvent));
+  const getKeydownRules = Fun.constant([
+    KeyRules.rule(KeyMatch.and([ KeyMatch.isShift, KeyMatch.inSet(Keys.TAB) ]), goBackwards),
+    KeyRules.rule(KeyMatch.inSet(Keys.TAB), goForwards),
+    KeyRules.rule(KeyMatch.inSet(Keys.ESCAPE), exit),
+    KeyRules.rule(KeyMatch.and([ KeyMatch.isNotShift, KeyMatch.inSet(Keys.ENTER) ]), execute)
+  ]);
+  const getKeyupRules = Fun.constant([ ]);
+  return KeyingType.typical(schema, NoState.init, getKeydownRules, getKeyupRules, () => Optional.some(focusIn));
+};
+export {
+  create
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/log/AlloyLogger.ts
@@ -0,0 +1,5 @@
+import { SugarElement, Truncate } from '@ephox/sugar';
+const element = (elem: SugarElement<Node>): string => Truncate.getHtml(elem);
+export {
+  element
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/menu/build/WidgetType.ts
@@ -0,0 +1,104 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Optional } from '@ephox/katamari';
+import * as EditableFields from '../../alien/EditableFields';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { Focusing } from '../../api/behaviour/Focusing';
+import { Keying } from '../../api/behaviour/Keying';
+import { Representing } from '../../api/behaviour/Representing';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SketchBehaviours } from '../../api/component/SketchBehaviours';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import * as NativeEvents from '../../api/events/NativeEvents';
+import * as SystemEvents from '../../api/events/SystemEvents';
+import * as Fields from '../../data/Fields';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import * as AlloyParts from '../../parts/AlloyParts';
+import { WidgetItemDetail } from '../../ui/types/ItemTypes';
+import * as ItemEvents from '../util/ItemEvents';
+import * as WidgetParts from './WidgetParts';
+const builder = (detail: WidgetItemDetail) => {
+  const subs = AlloyParts.substitutes(WidgetParts.owner(), detail, WidgetParts.parts());
+  const components = AlloyParts.components(WidgetParts.owner(), detail, subs.internals());
+  const focusWidget = (component: AlloyComponent) => AlloyParts.getPart(component, detail, 'widget').map((widget) => {
+    Keying.focusIn(widget);
+    return widget;
+  });
+  const onHorizontalArrow = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<KeyboardEvent>): Optional<boolean> =>
+    EditableFields.inside(simulatedEvent.event.target) ? Optional.none<boolean>() : (() => {
+      if (detail.autofocus) {
+        simulatedEvent.setSource(component.element);
+        return Optional.none<boolean>();
+      } else {
+        return Optional.none<boolean>();
+      }
+    })();
+  return {
+    dom: detail.dom,
+    components,
+    domModification: detail.domModification,
+    events: AlloyEvents.derive([
+      AlloyEvents.runOnExecute((component, simulatedEvent) => {
+        focusWidget(component).each((_widget) => {
+          simulatedEvent.stop();
+        });
+      }),
+      AlloyEvents.run(NativeEvents.mouseover(), ItemEvents.onHover),
+      AlloyEvents.run(SystemEvents.focusItem(), (component, _simulatedEvent) => {
+        if (detail.autofocus) {
+          focusWidget(component);
+        } else {
+          Focusing.focus(component);
+        }
+      })
+    ]),
+    behaviours: SketchBehaviours.augment(
+      detail.widgetBehaviours,
+      [
+        Representing.config({
+          store: {
+            mode: 'memory',
+            initialValue: detail.data
+          }
+        }),
+        Focusing.config({
+          ignore: detail.ignoreFocus,
+          onFocus: (component) => {
+            ItemEvents.onFocus(component);
+          }
+        }),
+        Keying.config({
+          mode: 'special',
+          focusIn: detail.autofocus ? (component) => {
+            focusWidget(component);
+          } : Behaviour.revoke(),
+          onLeft: onHorizontalArrow,
+          onRight: onHorizontalArrow,
+          onEscape: (component, simulatedEvent) => {
+            if (!Focusing.isFocused(component) && !detail.autofocus) {
+              Focusing.focus(component);
+              return Optional.some<boolean>(true);
+            } else if (detail.autofocus) {
+              simulatedEvent.setSource(component.element);
+              return Optional.none<boolean>();
+            } else {
+              return Optional.none<boolean>();
+            }
+          }
+        })
+      ]
+    )
+  };
+};
+const schema = [
+  FieldSchema.required('uid'),
+  FieldSchema.required('data'),
+  FieldSchema.required('components'),
+  FieldSchema.required('dom'),
+  FieldSchema.defaulted('autofocus', false),
+  FieldSchema.defaulted('ignoreFocus', false),
+  SketchBehaviours.field('widgetBehaviours', [ Representing, Focusing, Keying ]),
+  FieldSchema.defaulted('domModification', { }),
+  AlloyParts.defaultUidsSchema(WidgetParts.parts()),
+  Fields.output('builder', builder)
+];
+export default schema;

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/navigation/DomMovement.ts
@@ -0,0 +1,38 @@
+import { Optional } from '@ephox/katamari';
+import { Direction, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { NativeSimulatedEvent } from '../events/SimulatedEvent';
+import { GeneralKeyingConfig, KeyRuleHandler } from '../keying/KeyingModeTypes';
+export type ElementMover <C, S> = (elem: SugarElement<HTMLElement>, focused: SugarElement<HTMLElement>, config: C, state: S) => Optional<SugarElement<HTMLElement>>;
+const useH = <C extends GeneralKeyingConfig, S>(movement: (elem: SugarElement<Element>) => ElementMover<C, S>): KeyRuleHandler<C, S> =>
+  (component, simulatedEvent, config, state) => {
+    const move = movement(component.element);
+    return use(move, component, simulatedEvent, config, state);
+  };
+const west = <C extends GeneralKeyingConfig, S>(moveLeft: ElementMover<C, S>, moveRight: ElementMover<C, S>): KeyRuleHandler<C, S> => {
+  const movement = Direction.onDirection(moveLeft, moveRight);
+  return useH(movement);
+};
+const east = <C extends GeneralKeyingConfig, S>(moveLeft: ElementMover<C, S>, moveRight: ElementMover<C, S>): KeyRuleHandler<C, S> => {
+  const movement = Direction.onDirection(moveRight, moveLeft);
+  return useH(movement);
+};
+const useV = <C extends GeneralKeyingConfig, S>(move: ElementMover<C, S>): KeyRuleHandler<C, S> =>
+  (component, simulatedEvent, config, state) => use(move, component, simulatedEvent, config, state);
+const use = <C extends GeneralKeyingConfig, S>(move: ElementMover<C, S>, component: AlloyComponent, simulatedEvent: NativeSimulatedEvent, config: C, state: S): Optional<boolean> => {
+  const outcome = config.focusManager.get(component).bind((focused) => move(component.element, focused, config, state));
+  return outcome.map((newFocus): boolean => {
+    config.focusManager.set(component, newFocus);
+    return true;
+  });
+};
+const north = useV;
+const south = useV;
+const move = useV;
+export {
+  east,
+  west,
+  north,
+  south,
+  move
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/navigation/DomNavigation.ts
@@ -0,0 +1,25 @@
+import { Num, Optional } from '@ephox/katamari';
+import { Attribute, SugarElement, SugarNode } from '@ephox/sugar';
+import * as DomPinpoint from './DomPinpoint';
+const horizontal = (container: SugarElement<HTMLElement>, selector: string, current: SugarElement<HTMLElement>, delta: number): Optional<SugarElement<HTMLElement>> => {
+  const isDisabledButton = (candidate: SugarElement<HTMLElement>) =>
+    SugarNode.name(candidate) === 'button' && Attribute.get(candidate, 'disabled') === 'disabled';
+  const tryCycle = (initial: number, index: number, candidates: Array<SugarElement<HTMLElement>>): Optional<SugarElement<HTMLElement>> => {
+    const newIndex = Num.cycleBy(index, delta, 0, candidates.length - 1);
+    if (newIndex === initial) { // If we've cycled back to the original index, we've failed to find a new valid candidate
+      return Optional.none();
+    } else {
+      return isDisabledButton(candidates[newIndex]) ?
+        tryCycle(initial, newIndex, candidates) :
+        Optional.from(candidates[newIndex]);
+    }
+  };
+  return DomPinpoint.locateVisible(container, current, selector).bind((identified) => {
+    const index = identified.index;
+    const candidates = identified.candidates;
+    return tryCycle(index, index, candidates);
+  });
+};
+export {
+  horizontal
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/navigation/DomPinpoint.ts
@@ -0,0 +1,15 @@
+import { Arr, Optional } from '@ephox/katamari';
+import { Compare, SelectorFilter, SugarElement, Visibility } from '@ephox/sugar';
+import * as ArrPinpoint from './ArrPinpoint';
+const locateVisible = (container: SugarElement<HTMLElement>, current: SugarElement<HTMLElement>, selector: string): Optional<ArrPinpoint.IndexInfo<SugarElement<HTMLElement>>> => {
+  const predicate = (x: SugarElement<Node>) => Compare.eq(x, current);
+  const candidates = SelectorFilter.descendants<HTMLElement>(container, selector);
+  const visible = Arr.filter(candidates, Visibility.isVisible);
+  return ArrPinpoint.locate(visible, predicate);
+};
+const findIndex = <T> (elements: Array<SugarElement<T>>, target: SugarElement<T>): Optional<number> =>
+  Arr.findIndex(elements, (elem) => Compare.eq(target, elem));
+export {
+  locateVisible,
+  findIndex
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/layout/Anchor.ts
@@ -0,0 +1,25 @@
+import { SugarElement } from '@ephox/sugar';
+import { AnchorBox } from './LayoutTypes';
+import * as Origins from './Origins';
+/*
+ * Smooths over the difference between passing an element anchor (which requires an origin to determine the box) and passing a box.
+ *
+ * It is only useful for fixed origins; relative needs to do everything the old way.
+ */
+export interface Anchor {
+  readonly anchorBox: AnchorBox;
+  readonly origin: Origins.OriginAdt;
+}
+const anchor = (anchorBox: AnchorBox, origin: Origins.OriginAdt): Anchor => ({
+  anchorBox,
+  origin
+});
+const element = (anchorElement: SugarElement<HTMLElement>, origin: Origins.OriginAdt): Anchor => {
+  const anchorBox = Origins.toBox(origin, anchorElement);
+  return anchor(anchorBox, origin);
+};
+const box = (anchorBox: AnchorBox, origin: Origins.OriginAdt): Anchor => anchor(anchorBox, origin);
+export {
+  box,
+  element
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/layout/MaxHeight.ts
@@ -0,0 +1,25 @@
+import { Fun } from '@ephox/katamari';
+import { Css, Height, SugarElement } from '@ephox/sugar';
+const setMaxHeight = (element: SugarElement<HTMLElement>, maxHeight: number): void => {
+  Height.setMax(element, Math.floor(maxHeight));
+};
+const anchored = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
+  setMaxHeight(element, available);
+  Css.setAll(element, {
+    'overflow-x': 'hidden',
+    'overflow-y': 'auto'
+  });
+});
+/*
+ * This adds max height, but not overflow - the effect of this is that elements can grow beyond the max height,
+ * but if they run off the top they're pushed down.
+ *
+ * If the element expands below the screen height it will be cut off, but we were already doing that.
+ */
+const expandable = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
+  setMaxHeight(element, available);
+});
+export {
+  anchored,
+  expandable
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/layout/MaxWidth.ts
@@ -0,0 +1,6 @@
+import { Fun } from '@ephox/katamari';
+import { SugarElement, Width } from '@ephox/sugar';
+const expandable = Fun.constant((element: SugarElement<HTMLElement>, available: number): void => {
+  Width.setMax(element, Math.floor(available));
+});
+export { expandable };

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/layout/Origins.ts
@@ -0,0 +1,112 @@
+import { Adt, Fun, Optional } from '@ephox/katamari';
+import { Height, Scroll, SugarElement, SugarPosition, Width } from '@ephox/sugar';
+import * as Boxes from '../../alien/Boxes';
+import * as OuterPosition from '../../frame/OuterPosition';
+import { NuPositionCss, PositionCss } from '../view/PositionCss';
+import { RepositionDecision } from '../view/Reposition';
+import * as Direction from './Direction';
+type NoneOrigin<T> = () => T;
+type RelativeOrigin<T> = (x: number, y: number, width: number, height: number) => T;
+type FixedOrigin<T> = (x: number, y: number, width: number, height: number) => T;
+export interface OriginAdt {
+  fold: <T>(
+    none: NoneOrigin<T>,
+    relative: RelativeOrigin<T>,
+    fixed: FixedOrigin<T>
+  ) => T;
+  match: <T>(branches: {
+    none: NoneOrigin<T>;
+    relative: RelativeOrigin<T>;
+    fixed: FixedOrigin<T>;
+  }) => T;
+  log: (label: string) => void;
+}
+const adt: {
+  none: NoneOrigin<OriginAdt>;
+  relative: RelativeOrigin<OriginAdt>;
+  fixed: FixedOrigin<OriginAdt>;
+} = Adt.generate([
+  { none: [ ] },
+  { relative: [ 'x', 'y', 'width', 'height' ] },
+  { fixed: [ 'x', 'y', 'width', 'height' ] }
+]);
+const positionWithDirection = (posName: string, decision: RepositionDecision, x: number, y: number, width: number, height: number) => {
+  const decisionRect = decision.rect;
+  const decisionX = decisionRect.x - x;
+  const decisionY = decisionRect.y - y;
+  const decisionWidth = decisionRect.width;
+  const decisionHeight = decisionRect.height;
+  const decisionRight = width - (decisionX + decisionWidth);
+  const decisionBottom = height - (decisionY + decisionHeight);
+  const left = Optional.some(decisionX);
+  const top = Optional.some(decisionY);
+  const right = Optional.some(decisionRight);
+  const bottom = Optional.some(decisionBottom);
+  const none = Optional.none<number>();
+  return Direction.cata(decision.direction,
+    () => NuPositionCss(posName, left, top, none, none), // southeast
+    () => NuPositionCss(posName, none, top, right, none), // southwest
+    () => NuPositionCss(posName, left, none, none, bottom), // northeast
+    () => NuPositionCss(posName, none, none, right, bottom), // northwest
+    () => NuPositionCss(posName, left, top, none, none), // south
+    () => NuPositionCss(posName, left, none, none, bottom), // north
+    () => NuPositionCss(posName, left, top, none, none), // east
+    () => NuPositionCss(posName, none, top, right, none) // west
+  );
+};
+const reposition = (origin: OriginAdt, decision: RepositionDecision): PositionCss => origin.fold(() => {
+  const decisionRect = decision.rect;
+  return NuPositionCss('absolute', Optional.some(decisionRect.x), Optional.some(decisionRect.y), Optional.none(), Optional.none());
+}, (x, y, width, height) => {
+  return positionWithDirection('absolute', decision, x, y, width, height);
+}, (x, y, width, height) => {
+  return positionWithDirection('fixed', decision, x, y, width, height);
+});
+const toBox = (origin: OriginAdt, element: SugarElement<HTMLElement>): Boxes.Bounds => {
+  const rel = Fun.curry(OuterPosition.find, element);
+  const position = origin.fold(rel, rel, () => {
+    const scroll = Scroll.get();
+    return OuterPosition.find(element).translate(-scroll.left, -scroll.top);
+  });
+  const width = Width.getOuter(element);
+  const height = Height.getOuter(element);
+  return Boxes.bounds(position.left, position.top, width, height);
+};
+const viewport = (origin: OriginAdt, getBounds: Optional<() => Boxes.Bounds>): Boxes.Bounds => getBounds.fold(() =>
+/* There are no bounds supplied */
+  origin.fold(Boxes.win, Boxes.win, Boxes.bounds)
+, (b) =>
+/* Use any bounds supplied or remove the scroll position of the bounds for fixed. */
+  origin.fold(b, b, () => {
+    const bounds = b();
+    const pos = translate(origin, bounds.x, bounds.y);
+    return Boxes.bounds(pos.left, pos.top, bounds.width, bounds.height);
+  })
+);
+const translate = (origin: OriginAdt, x: number, y: number): SugarPosition => {
+  const pos = SugarPosition(x, y);
+  const removeScroll = () => {
+    const outerScroll = Scroll.get();
+    return pos.translate(-outerScroll.left, -outerScroll.top);
+  };
+  return origin.fold(Fun.constant(pos), Fun.constant(pos), removeScroll);
+};
+const cata = <B>(
+  subject: OriginAdt,
+  onNone: NoneOrigin<B>,
+  onRelative: RelativeOrigin<B>,
+  onFixed: FixedOrigin<B>
+): B => subject.fold<B>(onNone, onRelative, onFixed);
+const none = adt.none;
+const relative = adt.relative;
+const fixed = adt.fixed;
+export {
+  none,
+  relative,
+  fixed,
+  reposition,
+  viewport,
+  toBox,
+  translate,
+  cata
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/layout/SimpleLayout.ts
@@ -0,0 +1,60 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import { AnchorOverrides, MaxHeightFunction, MaxWidthFunction } from '../mode/Anchoring';
+import * as Callouts from '../view/Callouts';
+import { Transition } from '../view/Transitions';
+import { Anchor } from './Anchor';
+import { Bubble } from './Bubble';
+import { PlacerResult } from './LayoutTypes';
+import * as LayoutTypes from './LayoutTypes';
+import * as MaxHeight from './MaxHeight';
+import * as Origins from './Origins';
+export interface ReparteeOptions {
+  readonly bounds: Bounds;
+  readonly origin: Origins.OriginAdt;
+  readonly preference: LayoutTypes.AnchorLayout[];
+  readonly maxHeightFunction: MaxHeightFunction;
+  readonly maxWidthFunction: MaxWidthFunction;
+  readonly lastPlacement: Optional<PlacerResult>;
+  readonly transition: Optional<Transition>;
+}
+const defaultOr = <K extends keyof AnchorOverrides>(options: AnchorOverrides, key: K, dephault: NonNullable<AnchorOverrides[K]>): NonNullable<AnchorOverrides[K]> => options[key] === undefined ? dephault : options[key] as NonNullable<AnchorOverrides[K]>;
+const simple = (
+  anchor: Anchor,
+  element: SugarElement<HTMLElement>,
+  bubble: Bubble,
+  layouts: LayoutTypes.AnchorLayout[],
+  lastPlacement: Optional<PlacerResult>,
+  getBounds: Optional<() => Bounds>,
+  overrideOptions: AnchorOverrides,
+  transition: Optional<Transition>
+): PlacerResult => {
+  const maxHeightFunction: MaxHeightFunction = defaultOr(overrideOptions, 'maxHeightFunction', MaxHeight.anchored());
+  const maxWidthFunction: MaxWidthFunction = defaultOr(overrideOptions, 'maxWidthFunction', Fun.noop);
+  const anchorBox = anchor.anchorBox;
+  const origin = anchor.origin;
+  const options: ReparteeOptions = {
+    bounds: Origins.viewport(origin, getBounds),
+    origin,
+    preference: layouts,
+    maxHeightFunction,
+    maxWidthFunction,
+    lastPlacement,
+    transition
+  };
+  return go(anchorBox, element, bubble, options);
+};
+const go = (anchorBox: LayoutTypes.AnchorBox, element: SugarElement<HTMLElement>, bubble: Bubble, options: ReparteeOptions): PlacerResult => {
+  const decision = Callouts.layout(anchorBox, element, bubble, options);
+  Callouts.position(element, decision, options);
+  Callouts.setPlacement(element, decision);
+  Callouts.setClasses(element, decision);
+  Callouts.setHeight(element, decision, options);
+  Callouts.setWidth(element, decision, options);
+  return {
+    layout: decision.layout,
+    placement: decision.placement
+  };
+};
+export { simple };

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/mode/AnchorLayouts.ts
@@ -0,0 +1,41 @@
+import { FieldProcessor, FieldSchema } from '@ephox/boulder';
+import { Optional } from '@ephox/katamari';
+import { Direction, SugarElement } from '@ephox/sugar';
+import { AnchorLayout } from '../layout/LayoutTypes';
+import { HasLayoutAnchor } from './Anchoring';
+import { isBottomToTopDir } from './VerticalDir';
+const schema = (): FieldProcessor => FieldSchema.optionObjOf('layouts', [
+  FieldSchema.required('onLtr'),
+  FieldSchema.required('onRtl'),
+  FieldSchema.option('onBottomLtr'),
+  FieldSchema.option('onBottomRtl')
+]);
+const get = (
+  elem: SugarElement<Element>,
+  info: HasLayoutAnchor,
+  defaultLtr: AnchorLayout[],
+  defaultRtl: AnchorLayout[],
+  defaultBottomLtr: AnchorLayout[],
+  defaultBottomRtl: AnchorLayout[],
+  dirElement: Optional<SugarElement<Element>>
+): AnchorLayout[] => {
+  const isBottomToTop = dirElement.map(isBottomToTopDir).getOr(false);
+  const customLtr = info.layouts.map((ls) => ls.onLtr(elem));
+  const customRtl = info.layouts.map((ls) => ls.onRtl(elem));
+  const ltr = isBottomToTop ?
+    info.layouts.bind((ls) => ls.onBottomLtr.map((f) => f(elem)))
+      .or(customLtr)
+      .getOr(defaultBottomLtr) :
+    customLtr.getOr(defaultLtr);
+  const rtl = isBottomToTop ?
+    info.layouts.bind((ls) => ls.onBottomRtl.map((f) => f(elem)))
+      .or(customRtl)
+      .getOr(defaultBottomRtl) :
+    customRtl.getOr(defaultRtl);
+  const f = Direction.onDirection(ltr, rtl);
+  return f(elem);
+};
+export {
+  schema,
+  get
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/mode/Anchoring.ts
@@ -0,0 +1,126 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { SimRange, SugarElement } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { Bubble } from '../layout/Bubble';
+import { AnchorBox, AnchorLayout, PlacerResult } from '../layout/LayoutTypes';
+import { OriginAdt } from '../layout/Origins';
+import { Transition } from '../view/Transitions';
+export type AnchorPlacement = (
+  comp: AlloyComponent,
+  origin: OriginAdt,
+  anchoring: Anchoring,
+  getBounds: Optional<() => Bounds>,
+  placee: AlloyComponent,
+  lastPlacement: Optional<PlacerResult>,
+  transition: Optional<Transition>
+) => PlacerResult;
+export interface CommonAnchorSpec {
+  type: string;
+}
+export type AnchorSpec = SelectionAnchorSpec | HotspotAnchorSpec | SubmenuAnchorSpec | MakeshiftAnchorSpec | NodeAnchorSpec;
+export interface AnchorDetail<D> {
+  placement: (comp: AlloyComponent, anchor: D, origin: OriginAdt) => Optional<Anchoring>;
+}
+export type MaxHeightFunction = (elem: SugarElement<HTMLElement>, available: number) => void;
+export type MaxWidthFunction = (elem: SugarElement<HTMLElement>, available: number) => void;
+export interface AnchorOverrides {
+  maxHeightFunction?: MaxHeightFunction;
+  maxWidthFunction?: MaxWidthFunction;
+}
+export interface LayoutsDetail {
+  onLtr: (elem: SugarElement<Element>) => AnchorLayout[];
+  onRtl: (elem: SugarElement<Element>) => AnchorLayout[];
+  onBottomLtr: Optional<(elem: SugarElement<Element>) => AnchorLayout[]>;
+  onBottomRtl: Optional<(elem: SugarElement<Element>) => AnchorLayout[]>;
+}
+export interface HasLayoutAnchor {
+  layouts: Optional<LayoutsDetail>;
+}
+export interface Layouts {
+  onLtr: (elem: SugarElement<Element>) => AnchorLayout[];
+  onRtl: (elem: SugarElement<Element>) => AnchorLayout[];
+  onBottomLtr?: (elem: SugarElement<Element>) => AnchorLayout[];
+  onBottomRtl?: (elem: SugarElement<Element>) => AnchorLayout[];
+}
+export interface HasLayoutAnchorSpec {
+  layouts?: Layouts;
+}
+export interface SelectionAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
+  type: 'selection';
+  getSelection?: () => Optional<SimRange>;
+  root: SugarElement<Node>;
+  bubble?: Bubble;
+  overrides?: AnchorOverrides;
+  showAbove?: boolean;
+}
+export interface SelectionAnchor extends AnchorDetail<SelectionAnchor>, HasLayoutAnchor {
+  getSelection: Optional<() => Optional<SimRange>>;
+  root: SugarElement<Node>;
+  bubble: Optional<Bubble>;
+  overrides: AnchorOverrides;
+  showAbove: boolean;
+}
+export interface NodeAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
+  type: 'node';
+  node: Optional<SugarElement<Element>>;
+  root: SugarElement<Node>;
+  bubble?: Bubble;
+  overrides?: AnchorOverrides;
+  showAbove?: boolean;
+}
+export interface NodeAnchor extends AnchorDetail<NodeAnchor>, HasLayoutAnchor {
+  node: Optional<SugarElement<Element>>;
+  root: SugarElement<Node>;
+  bubble: Optional<Bubble>;
+  overrides: AnchorOverrides;
+  showAbove: boolean;
+}
+export interface HotspotAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
+  type: 'hotspot';
+  hotspot: AlloyComponent;
+  bubble?: Bubble;
+  overrides?: AnchorOverrides;
+}
+export interface HotspotAnchor extends AnchorDetail<HotspotAnchor>, HasLayoutAnchor {
+  hotspot: AlloyComponent;
+  bubble: Optional<Bubble>;
+  overrides: AnchorOverrides;
+}
+export interface SubmenuAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
+  type: 'submenu';
+  overrides?: AnchorOverrides;
+  item: AlloyComponent;
+}
+export interface SubmenuAnchor extends AnchorDetail<SubmenuAnchor>, HasLayoutAnchor {
+  item: AlloyComponent;
+  overrides: AnchorOverrides;
+}
+export interface MakeshiftAnchorSpec extends CommonAnchorSpec, HasLayoutAnchorSpec {
+  type: 'makeshift';
+  x: number;
+  y: number;
+  height?: number;
+  width?: number;
+  bubble?: Bubble;
+  overrides?: AnchorOverrides;
+}
+export interface MakeshiftAnchor extends AnchorDetail<MakeshiftAnchor>, HasLayoutAnchor {
+  x: number;
+  y: number;
+  height: number;
+  width: number;
+  bubble: Bubble;
+  overrides: AnchorOverrides;
+}
+export interface Anchoring {
+  anchorBox: AnchorBox;
+  bubble: Bubble;
+  overrides: AnchorOverrides;
+  layouts: AnchorLayout[];
+  placer: Optional<AnchorPlacement>;
+}
+const nu: (spec: Anchoring) => Anchoring = Fun.identity;
+export {
+  nu
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/mode/ContentAnchorCommon.ts
@@ -0,0 +1,54 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement, SugarPosition } from '@ephox/sugar';
+import * as Boxes from '../../alien/Boxes';
+import * as CssPosition from '../../alien/CssPosition';
+import * as Bubble from '../layout/Bubble';
+import * as Layout from '../layout/Layout';
+import * as Origins from '../layout/Origins';
+import { Anchoring, NodeAnchor, nu as NuAnchor, SelectionAnchor } from './Anchoring';
+import * as AnchorLayouts from './AnchorLayouts';
+const getBox = (left: number, top: number, width: number, height: number): Optional<Boxes.BoxByPoint> => {
+  const point = CssPosition.screen(SugarPosition(left, top));
+  return Optional.some(Boxes.pointed(point, width, height));
+};
+const calcNewAnchor = (optBox: Optional<Boxes.BoxByPoint>, rootPoint: CssPosition.CssPositionAdt, anchorInfo: SelectionAnchor | NodeAnchor, origin: Origins.OriginAdt, elem: SugarElement<Element>): Optional<Anchoring> =>
+  optBox.map((box) => {
+    const points = [ rootPoint, box.point ];
+    const topLeft = Origins.cata(origin,
+      () => CssPosition.sumAsAbsolute(points),
+      () => CssPosition.sumAsAbsolute(points),
+      () => CssPosition.sumAsFixed(points)
+    );
+    const anchorBox = Boxes.rect(
+      topLeft.left,
+      topLeft.top,
+      box.width,
+      box.height
+    );
+    const layoutsLtr = anchorInfo.showAbove ?
+      Layout.aboveOrBelow() :
+      Layout.belowOrAbove();
+    const layoutsRtl = anchorInfo.showAbove ?
+      Layout.aboveOrBelowRtl() :
+      Layout.belowOrAboveRtl();
+    const layouts = AnchorLayouts.get(
+      elem,
+      anchorInfo,
+      layoutsLtr,
+      layoutsRtl,
+      layoutsLtr,
+      layoutsRtl,
+      Optional.none()
+    );
+    return NuAnchor({
+      anchorBox,
+      bubble: anchorInfo.bubble.getOr(Bubble.fallback()),
+      overrides: anchorInfo.overrides,
+      layouts,
+      placer: Optional.none()
+    });
+  });
+export {
+  getBox,
+  calcNewAnchor
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/mode/SelectionAnchor.ts
@@ -0,0 +1,48 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Optional, Unicode } from '@ephox/katamari';
+import { Insert, Remove, SimRange, SimSelection, SugarElement, SugarNode, Traverse, WindowSelection } from '@ephox/sugar';
+import * as Descend from '../../alien/Descend';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as Fields from '../../data/Fields';
+import * as Origins from '../layout/Origins';
+import { Anchoring, SelectionAnchor } from './Anchoring';
+import * as AnchorLayouts from './AnchorLayouts';
+import * as ContainerOffsets from './ContainerOffsets';
+import * as ContentAnchorCommon from './ContentAnchorCommon';
+const descendOnce = (element: SugarElement<Node>, offset: number): Descend.ElementAndOffset<Node> =>
+  SugarNode.isText(element) ? Descend.point(element, offset) : Descend.descendOnce(element, offset);
+const getAnchorSelection = (win: Window, anchorInfo: SelectionAnchor): Optional<SimRange> => {
+  const getSelection = anchorInfo.getSelection.getOrThunk(() => () => WindowSelection.getExact(win));
+  return getSelection().map((sel) => {
+    const modStart = descendOnce(sel.start, sel.soffset);
+    const modFinish = descendOnce(sel.finish, sel.foffset);
+    return SimSelection.range(modStart.element, modStart.offset, modFinish.element, modFinish.offset);
+  });
+};
+const placement = (component: AlloyComponent, anchorInfo: SelectionAnchor, origin: Origins.OriginAdt): Optional<Anchoring> => {
+  const win: Window = Traverse.defaultView(anchorInfo.root).dom;
+  const rootPoint = ContainerOffsets.getRootPoint(component, origin, anchorInfo);
+  const selectionBox = getAnchorSelection(win, anchorInfo).bind((sel) => {
+    const optRect = WindowSelection.getBounds(win, SimSelection.exactFromRange(sel)).orThunk(() => {
+      const x = SugarElement.fromText(Unicode.zeroWidth);
+      Insert.before(sel.start, x);
+      const rect = WindowSelection.getFirstRect(win, SimSelection.exact(x, 0, x, 1));
+      Remove.remove(x);
+      return rect;
+    });
+    return optRect.bind((rawRect) => ContentAnchorCommon.getBox(rawRect.left, rawRect.top, rawRect.width, rawRect.height));
+  });
+  const targetElement = getAnchorSelection(win, anchorInfo)
+    .bind((sel) => SugarNode.isElement(sel.start) ? Optional.some(sel.start) : Traverse.parentElement(sel.start));
+  const elem = targetElement.getOr(component.element);
+  return ContentAnchorCommon.calcNewAnchor(selectionBox, rootPoint, anchorInfo, origin, elem);
+};
+export default [
+  FieldSchema.option('getSelection'),
+  FieldSchema.required('root'),
+  FieldSchema.option('bubble'),
+  AnchorLayouts.schema(),
+  FieldSchema.defaulted('overrides', { }),
+  FieldSchema.defaulted('showAbove', false),
+  Fields.output('placement', placement)
+];

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/mode/VerticalDir.ts
@@ -0,0 +1,11 @@
+import { Attribute as Attrib, PredicateExists, SugarElement, SugarNode } from '@ephox/sugar';
+export enum AttributeValue {
+  TopToBottom = 'toptobottom',
+  BottomToTop = 'bottomtotop'
+}
+export const Attribute = 'data-alloy-vertical-dir';
+const isBottomToTopDir = (el: SugarElement<Element>): boolean => PredicateExists.closest(el, (current) =>
+  SugarNode.isElement(current) && Attrib.get(current, 'data-alloy-vertical-dir') === AttributeValue.BottomToTop);
+export {
+  isBottomToTopDir
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/view/Callouts.ts
@@ -0,0 +1,61 @@
+import { Classes, Css, Height, SugarElement, Width } from '@ephox/sugar';
+import { Bubble } from '../layout/Bubble';
+import { AnchorBox, AnchorElement } from '../layout/LayoutTypes';
+import * as Origins from '../layout/Origins';
+import * as Placement from '../layout/Placement';
+import { ReparteeOptions } from '../layout/SimpleLayout';
+import * as Bounder from './Bounder';
+import { applyPositionCss } from './PositionCss';
+import { RepositionDecision } from './Reposition';
+import { applyTransitionCss } from './Transitions';
+/*
+ * This is the old repartee API. It is retained in a similar structure to the original form,
+ * in case we decide to bring back the flexibility of working with non-standard positioning.
+ */
+const elementSize = (p: SugarElement<HTMLElement>): AnchorElement => ({
+  width: Width.getOuter(p),
+  height: Height.getOuter(p)
+});
+const layout = (anchorBox: AnchorBox, element: SugarElement<HTMLElement>, bubbles: Bubble, options: ReparteeOptions): RepositionDecision => {
+  Css.remove(element, 'max-height');
+  Css.remove(element, 'max-width');
+  const elementBox = elementSize(element);
+  return Bounder.attempts(element, options.preference, anchorBox, elementBox, bubbles, options.bounds);
+};
+const setClasses = (element: SugarElement<HTMLElement>, decision: RepositionDecision): void => {
+  const classInfo = decision.classes;
+  Classes.remove(element, classInfo.off);
+  Classes.add(element, classInfo.on);
+};
+/*
+ * maxHeightFunction is a MaxHeight instance.
+ * max-height is usually the distance between the edge of the popup and the screen; top of popup to bottom of screen for south, bottom of popup to top of screen for north.
+ *
+ * There are a few cases where we specifically don't want a max-height, which is why it's optional.
+ */
+const setHeight = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
+  const maxHeightFunction = options.maxHeightFunction;
+  maxHeightFunction(element, decision.maxHeight);
+};
+const setWidth = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
+  const maxWidthFunction = options.maxWidthFunction;
+  maxWidthFunction(element, decision.maxWidth);
+};
+const position = (element: SugarElement<HTMLElement>, decision: RepositionDecision, options: ReparteeOptions): void => {
+  const positionCss = Origins.reposition(options.origin, decision);
+  options.transition.each((transition) => {
+    applyTransitionCss(element, options.origin, positionCss, transition, decision, options.lastPlacement);
+  });
+  applyPositionCss(element, positionCss);
+};
+const setPlacement = (element: SugarElement<HTMLElement>, decision: RepositionDecision): void => {
+  Placement.setPlacement(element, decision.placement);
+};
+export {
+  layout,
+  setClasses,
+  setHeight,
+  setWidth,
+  position,
+  setPlacement
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/positioning/view/Transitions.ts
@@ -0,0 +1,122 @@
+import { Arr, Obj, Optional, Optionals, Singleton, Strings, Type } from '@ephox/katamari';
+import { Attribute, Classes, Compare, Css, DomEvent, EventArgs, SugarElement } from '@ephox/sugar';
+import * as NativeEvents from '../../api/events/NativeEvents';
+import { PlacerResult } from '../layout/LayoutTypes';
+import * as Origins from '../layout/Origins';
+import { PositionCss } from './PositionCss';
+import { RepositionDecision } from './Reposition';
+export type TransitionProp = 'top' | 'left' | 'bottom' | 'right';
+export type TransitionMode = 'all' | 'layout' | 'placement';
+export interface Transition {
+  readonly classes: string[];
+  readonly mode: TransitionMode;
+}
+const properties: TransitionProp[] = [ 'top', 'bottom', 'right', 'left' ];
+const timerAttr = 'data-alloy-transition-timer';
+const isTransitioning = (element: SugarElement<HTMLElement>, transition: Transition): boolean =>
+  Classes.hasAll(element, transition.classes);
+const shouldApplyTransitionCss = (transition: Transition, decision: RepositionDecision, lastPlacement: Optional<PlacerResult>): boolean => {
+  return lastPlacement.exists((placer) => {
+    const mode = transition.mode;
+    return mode === 'all' ? true : placer[mode] !== decision[mode];
+  });
+};
+const hasChanges = (position: PositionCss, intermediate: Record<TransitionProp, Optional<string>>): boolean => {
+  const round = (value: string) => parseFloat(value).toFixed(3);
+  return Obj.find(intermediate, (value, key) => {
+    const newValue = position[key as TransitionProp].map(round);
+    const val = value.map(round);
+    return !Optionals.equals(newValue, val);
+  }).isSome();
+};
+const getTransitionDuration = (element: SugarElement<HTMLElement>): number => {
+  const get = (name: string) => {
+    const style = Css.get(element, name);
+    const times = style.split(/\s*,\s*/);
+    return Arr.filter(times, Strings.isNotEmpty);
+  };
+  const parse = (value: string | undefined) => {
+    if (Type.isString(value) && /^[\d.]+/.test(value)) {
+      const num = parseFloat(value);
+      return Strings.endsWith(value, 'ms') ? num : num * 1000;
+    } else {
+      return 0;
+    }
+  };
+  const delay = get('transition-delay');
+  const duration = get('transition-duration');
+  return Arr.foldl(duration, (acc, dur, i) => {
+    const time = parse(delay[i]) + parse(dur);
+    return Math.max(acc, time);
+  }, 0);
+};
+const setupTransitionListeners = (element: SugarElement<HTMLElement>, transition: Transition): void => {
+  const transitionEnd = Singleton.unbindable();
+  const transitionCancel = Singleton.unbindable();
+  let timer: number;
+  const isSourceTransition = (e: EventArgs<TransitionEvent>) => {
+    const pseudoElement = e.raw.pseudoElement ?? '';
+    return Compare.eq(e.target, element) && Strings.isEmpty(pseudoElement) && Arr.contains(properties, e.raw.propertyName);
+  };
+  const transitionDone = (e?: EventArgs<TransitionEvent>) => {
+    if (Type.isNullable(e) || isSourceTransition(e)) {
+      transitionEnd.clear();
+      transitionCancel.clear();
+      const type = e?.raw.type;
+      if (Type.isNullable(type) || type === NativeEvents.transitionend()) {
+        clearTimeout(timer);
+        Attribute.remove(element, timerAttr);
+        Classes.remove(element, transition.classes);
+      }
+    }
+  };
+  const transitionStart = DomEvent.bind(element, NativeEvents.transitionstart(), (e) => {
+    if (isSourceTransition(e)) {
+      transitionStart.unbind();
+      transitionEnd.set(DomEvent.bind(element, NativeEvents.transitionend(), transitionDone));
+      transitionCancel.set(DomEvent.bind(element, NativeEvents.transitioncancel(), transitionDone));
+    }
+  });
+  const duration = getTransitionDuration(element);
+  requestAnimationFrame(() => {
+    timer = setTimeout(transitionDone, duration + 17);
+    Attribute.set(element, timerAttr, timer);
+  });
+};
+const startTransitioning = (element: SugarElement<HTMLElement>, transition: Transition): void => {
+  Classes.add(element, transition.classes);
+  Attribute.getOpt(element, timerAttr).each((timerId) => {
+    clearTimeout(parseInt(timerId, 10));
+    Attribute.remove(element, timerAttr);
+  });
+  setupTransitionListeners(element, transition);
+};
+const applyTransitionCss = (
+  element: SugarElement<HTMLElement>,
+  origin: Origins.OriginAdt,
+  position: PositionCss,
+  transition: Transition,
+  decision: RepositionDecision,
+  lastPlacement: Optional<PlacerResult>
+): void => {
+  const shouldTransition = shouldApplyTransitionCss(transition, decision, lastPlacement);
+  if (shouldTransition || isTransitioning(element, transition)) {
+    Css.set(element, 'position', position.position);
+    const rect = Origins.toBox(origin, element);
+    const intermediatePosition = Origins.reposition(origin, { ...decision, rect });
+    const intermediateCssOptions = Arr.mapToObject(properties, (prop) => intermediatePosition[prop]);
+    if (hasChanges(position, intermediateCssOptions)) {
+      Css.setOptions(element, intermediateCssOptions);
+      if (shouldTransition) {
+        startTransitioning(element, transition);
+      }
+      Css.reflow(element);
+    }
+  } else {
+    Classes.remove(element, transition.classes);
+  }
+};
+export {
+  getTransitionDuration,
+  applyTransitionCss
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/registry/Registry.ts
@@ -0,0 +1,60 @@
+import { Obj, Optional } from '@ephox/katamari';
+import { SugarBody, SugarElement } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { ElementAndHandler, EventRegistry, UidAndHandler } from '../events/EventRegistry';
+import * as AlloyLogger from '../log/AlloyLogger';
+import * as Tagger from './Tagger';
+export interface Registry {
+  readonly find: (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>) => Optional<ElementAndHandler>;
+  readonly filter: (type: string) => UidAndHandler[];
+  readonly register: (component: AlloyComponent) => void;
+  readonly unregister: (component: AlloyComponent) => void;
+  readonly getById: (id: string) => Optional<AlloyComponent>;
+}
+export const Registry = (): Registry => {
+  const events = EventRegistry();
+  const components: Record<string, AlloyComponent> = { };
+  const readOrTag = (component: AlloyComponent): string => {
+    const elem = component.element;
+    return Tagger.read(elem).getOrThunk(() =>
+      Tagger.write('uid-', component.element)
+    );
+  };
+  const failOnDuplicate = (component: AlloyComponent, tagId: string): void => {
+    const conflict = components[tagId];
+    if (conflict === component) {
+      unregister(component);
+    } else {
+      throw new Error(
+        'The tagId "' + tagId + '" is already used by: ' + AlloyLogger.element(conflict.element) + '\nCannot use it for: ' + AlloyLogger.element(component.element) + '\n' +
+        'The conflicting element is' + (SugarBody.inBody(conflict.element) ? ' ' : ' not ') + 'already in the DOM'
+      );
+    }
+  };
+  const register = (component: AlloyComponent): void => {
+    const tagId = readOrTag(component);
+    if (Obj.hasNonNullableKey(components, tagId)) {
+      failOnDuplicate(component, tagId);
+    }
+    const extraArgs = [ component ];
+    events.registerId(extraArgs, tagId, component.events);
+    components[tagId] = component;
+  };
+  const unregister = (component: AlloyComponent): void => {
+    Tagger.read(component.element).each((tagId) => {
+      delete components[tagId];
+      events.unregisterId(tagId);
+    });
+  };
+  const filter = (type: string): UidAndHandler[] => events.filterByType(type);
+  const find = (isAboveRoot: (elem: SugarElement<Node>) => boolean, type: string, target: SugarElement<Node>): Optional<ElementAndHandler> =>
+    events.find(isAboveRoot, type, target);
+  const getById = (id: string): Optional<AlloyComponent> => Obj.get(components, id);
+  return {
+    find,
+    filter,
+    register,
+    unregister,
+    getById
+  };
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/registry/Tagger.ts
@@ -0,0 +1,36 @@
+import { Fun, Id, Optional } from '@ephox/katamari';
+import { SugarElement, SugarNode } from '@ephox/sugar';
+import * as AlloyTags from '../ephemera/AlloyTags';
+import * as AlloyLogger from '../log/AlloyLogger';
+const prefix = AlloyTags.prefix();
+const idAttr = AlloyTags.idAttr();
+const write = (label: string, elem: SugarElement<Element>): string => {
+  const id: string = Id.generate(prefix + label);
+  writeOnly(elem, id);
+  return id;
+};
+const writeOnly = (elem: SugarElement<Node>, uid: string | null): void => {
+  Object.defineProperty(elem.dom, idAttr, {
+    value: uid,
+    writable: true
+  });
+};
+const read = (elem: SugarElement<Node>): Optional<string> => {
+  const id = SugarNode.isElement(elem) ? (elem.dom as any)[idAttr] : null;
+  return Optional.from(id);
+};
+const readOrDie = (elem: SugarElement<Node>): string => read(elem).getOrDie('Could not find alloy uid in: ' + AlloyLogger.element(elem));
+const generate = (prefix: string): string => Id.generate(prefix);
+const revoke = (elem: SugarElement<Node>): void => {
+  writeOnly(elem, null);
+};
+const attribute: () => string = Fun.constant(idAttr);
+export {
+  revoke,
+  write,
+  writeOnly,
+  read,
+  readOrDie,
+  generate,
+  attribute
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/sandbox/Dismissal.ts
@@ -0,0 +1,60 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Fun, Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { NamedConfiguredBehaviour } from '../api/behaviour/Behaviour';
+import { Receiving } from '../api/behaviour/Receiving';
+import { Sandboxing } from '../api/behaviour/Sandboxing';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import * as AlloyTriggers from '../api/events/AlloyTriggers';
+import * as SystemEvents from '../api/events/SystemEvents';
+import * as Channels from '../api/messages/Channels';
+import { ReceivingChannelSpec, ReceivingConfig, ReceivingConfigSpec } from '../behaviour/receiving/ReceivingTypes';
+interface DismissalReceivingDetail {
+  isExtraPart: (sandbox: AlloyComponent, target: SugarElement<Node>) => boolean;
+  fireEventInstead: Optional<{
+    event: string;
+  }>;
+}
+export interface DismissalReceivingSpec {
+  isExtraPart?: (sandbox: AlloyComponent, target: SugarElement<Node>) => boolean;
+  fireEventInstead?: {
+    event?: string;
+  };
+}
+const schema = StructureSchema.objOfOnly([
+  FieldSchema.defaulted('isExtraPart', Fun.never),
+  FieldSchema.optionObjOf('fireEventInstead', [
+    FieldSchema.defaulted('event', SystemEvents.dismissRequested())
+  ])
+]);
+const receivingConfig = (rawSpec: DismissalReceivingSpec): NamedConfiguredBehaviour<ReceivingConfigSpec, ReceivingConfig> => {
+  const c = receivingChannel(rawSpec);
+  return Receiving.config({
+    channels: c
+  });
+};
+const receivingChannel = (rawSpec: DismissalReceivingSpec): Record<string, ReceivingChannelSpec> => {
+  const detail: DismissalReceivingDetail = StructureSchema.asRawOrDie('Dismissal', schema, rawSpec);
+  return {
+    [Channels.dismissPopups()]: {
+      schema: StructureSchema.objOfOnly([
+        FieldSchema.required('target')
+      ]),
+      onReceive: (sandbox: AlloyComponent, data: { target: SugarElement<Node> }) => {
+        if (Sandboxing.isOpen(sandbox)) {
+          const isPart = Sandboxing.isPartOf(sandbox, data.target) || detail.isExtraPart(sandbox, data.target);
+          if (!isPart) {
+            detail.fireEventInstead.fold(
+              () => Sandboxing.close(sandbox),
+              (fe) => AlloyTriggers.emit(sandbox, fe.event)
+            );
+          }
+        }
+      }
+    }
+  };
+};
+export {
+  receivingChannel,
+  receivingConfig
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/system/InternalAttachment.ts
@@ -0,0 +1,91 @@
+import { Arr } from '@ephox/katamari';
+import { Insert, Remove, SugarBody } from '@ephox/sugar';
+import { AlloyComponent } from '../api/component/ComponentApi';
+import { AlloySpec } from '../api/component/SpecTypes';
+import * as AlloyTriggers from '../api/events/AlloyTriggers';
+import * as SystemEvents from '../api/events/SystemEvents';
+import * as GuiTypes from '../api/ui/GuiTypes';
+const isConnected = (comp: AlloyComponent) =>
+  comp.getSystem().isConnected();
+const fireDetaching = (component: AlloyComponent): void => {
+  AlloyTriggers.emit(component, SystemEvents.detachedFromDom());
+  const children = component.components();
+  Arr.each(children, fireDetaching);
+};
+const fireAttaching = (component: AlloyComponent): void => {
+  const children = component.components();
+  Arr.each(children, fireAttaching);
+  AlloyTriggers.emit(component, SystemEvents.attachedToDom());
+};
+const virtualAttach = (parent: AlloyComponent, child: AlloyComponent): void => {
+  parent.getSystem().addToWorld(child);
+  if (SugarBody.inBody(parent.element)) {
+    fireAttaching(child);
+  }
+};
+const virtualDetach = (comp: AlloyComponent): void => {
+  fireDetaching(comp);
+  comp.getSystem().removeFromWorld(comp);
+};
+const attach = (parent: AlloyComponent, child: AlloyComponent): void => {
+  Insert.append(parent.element, child.element);
+};
+const detachChildren = (component: AlloyComponent): void => {
+  Arr.each(component.components(), (childComp) => Remove.remove(childComp.element));
+  Remove.empty(component.element);
+  component.syncComponents();
+};
+const replaceChildren = (component: AlloyComponent, newSpecs: AlloySpec[], buildNewChildren: (newSpecs: AlloySpec[]) => AlloyComponent[]): void => {
+  const subs = component.components();
+  detachChildren(component);
+  const newChildren = buildNewChildren(newSpecs);
+  const deleted = Arr.difference(subs, newChildren);
+  Arr.each(deleted, (comp) => {
+    fireDetaching(comp);
+    component.getSystem().removeFromWorld(comp);
+  });
+  Arr.each(newChildren, (childComp) => {
+    if (!isConnected(childComp)) {
+      component.getSystem().addToWorld(childComp);
+      attach(component, childComp);
+      if (SugarBody.inBody(component.element)) {
+        fireAttaching(childComp);
+      }
+    } else {
+      attach(component, childComp);
+    }
+  });
+  component.syncComponents();
+};
+const virtualReplaceChildren = (component: AlloyComponent, newSpecs: AlloySpec[], buildNewChildren: (newSpecs: AlloySpec[]) => AlloyComponent[]): void => {
+  const subs = component.components();
+  const existingComps = Arr.bind(newSpecs, (spec) => GuiTypes.getPremade(spec).toArray());
+  Arr.each(subs, (childComp) => {
+    if (!Arr.contains(existingComps, childComp)) {
+      virtualDetach(childComp);
+    }
+  });
+  const newChildren = buildNewChildren(newSpecs);
+  const deleted = Arr.difference(subs, newChildren);
+  Arr.each(deleted, (deletedComp) => {
+    if (isConnected(deletedComp)) {
+      virtualDetach(deletedComp);
+    }
+  });
+  Arr.each(newChildren, (childComp) => {
+    if (!isConnected(childComp)) {
+      virtualAttach(component, childComp);
+    } else {
+    }
+  });
+  component.syncComponents();
+};
+export {
+  fireAttaching,
+  fireDetaching,
+  detachChildren,
+  replaceChildren,
+  virtualAttach,
+  virtualDetach,
+  virtualReplaceChildren
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/schema/ModalDialogSchema.ts
@@ -0,0 +1,95 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Fun } from '@ephox/katamari';
+import { SelectorFind } from '@ephox/sugar';
+import * as Boxes from '../../alien/Boxes';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { Dragging } from '../../api/behaviour/Dragging';
+import { Keying } from '../../api/behaviour/Keying';
+import * as SketchBehaviours from '../../api/component/SketchBehaviours';
+import * as Fields from '../../data/Fields';
+import * as PartType from '../../parts/PartType';
+import { ModalDialogDetail } from '../types/ModalDialogTypes';
+const schema = Fun.constant([
+  FieldSchema.required('lazySink'),
+  FieldSchema.option('dragBlockClass'),
+  FieldSchema.defaultedFunction('getBounds', Boxes.win),
+  FieldSchema.defaulted('useTabstopAt', Fun.always),
+  FieldSchema.defaulted('eventOrder', {}),
+  SketchBehaviours.field('modalBehaviours', [ Keying ]),
+  Fields.onKeyboardHandler('onExecute'),
+  Fields.onStrictKeyboardHandler('onEscape')
+]);
+const basic = { sketch: Fun.identity };
+const parts: () => PartType.PartTypeAdt[] = Fun.constant([
+  PartType.optional<ModalDialogDetail>({
+    name: 'draghandle',
+    overrides: (detail: ModalDialogDetail, spec) => {
+      return {
+        behaviours: Behaviour.derive([
+          Dragging.config({
+            mode: 'mouse',
+            getTarget: (handle) => {
+              return SelectorFind.ancestor<HTMLElement>(handle, '[role="dialog"]').getOr(handle);
+            },
+            blockerClass: detail.dragBlockClass.getOrDie(
+              new Error(
+                'The drag blocker class was not specified for a dialog with a drag handle: \n' +
+                JSON.stringify(spec, null, 2)
+              ).message
+            ),
+            getBounds: detail.getDragBounds
+          })
+        ])
+      };
+    }
+  }),
+  PartType.required<ModalDialogDetail>({
+    schema: [ FieldSchema.required('dom') ],
+    name: 'title'
+  }),
+  PartType.required<ModalDialogDetail>({
+    factory: basic,
+    schema: [ FieldSchema.required('dom') ],
+    name: 'close'
+  }),
+  PartType.required<ModalDialogDetail>({
+    factory: basic,
+    schema: [ FieldSchema.required('dom') ],
+    name: 'body'
+  }),
+  PartType.optional<ModalDialogDetail>({
+    factory: basic,
+    schema: [ FieldSchema.required('dom') ],
+    name: 'footer'
+  }),
+  PartType.external<ModalDialogDetail>({
+    factory: {
+      sketch: (spec, detail) =>
+        ({
+          ...spec,
+          dom: detail.dom,
+          components: detail.components
+        })
+    },
+    schema: [
+      FieldSchema.defaulted('dom', {
+        tag: 'div',
+        styles: {
+          position: 'fixed',
+          left: '0px',
+          top: '0px',
+          right: '0px',
+          bottom: '0px'
+        }
+      }),
+      FieldSchema.defaulted('components', [ ])
+    ],
+    name: 'blocker'
+  })
+]);
+const name = Fun.constant('ModalDialog');
+export {
+  name,
+  schema,
+  parts
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/EdgeActions.ts
@@ -0,0 +1,62 @@
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyTriggers from '../../api/events/AlloyTriggers';
+import { SliderValue, SliderValueXY, TwoDSliderDetail } from '../types/SliderTypes';
+import * as ModelCommon from './ModelCommon';
+import { halfX, halfY, max1X, max1Y, min1X, min1Y } from './SliderValues';
+const xyValue = (x: number, y: number): SliderValueXY => ({
+  x,
+  y
+});
+const fireSliderChange = (component: AlloyComponent, value: SliderValue): void => {
+  AlloyTriggers.emitWith(component, ModelCommon.sliderChangeEvent(), { value });
+};
+const setToTLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(min1X(detail), min1Y(detail)));
+};
+const setToTEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, min1Y(detail));
+};
+const setToTEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(halfX(detail), min1Y(detail)));
+};
+const setToTREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(max1X(detail), min1Y(detail)));
+};
+const setToREdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, max1X(detail));
+};
+const setToREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(max1X(detail), halfY(detail)));
+};
+const setToBREdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(max1X(detail), max1Y(detail)));
+};
+const setToBEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, max1Y(detail));
+};
+const setToBEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(halfX(detail), max1Y(detail)));
+};
+const setToBLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(min1X(detail), max1Y(detail)));
+};
+const setToLEdge = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, min1X(detail));
+};
+const setToLEdgeXY = (edge: AlloyComponent, detail: TwoDSliderDetail): void => {
+  fireSliderChange(edge, xyValue(min1X(detail), halfY(detail)));
+};
+export {
+  setToTLEdgeXY,
+  setToTEdge,
+  setToTEdgeXY,
+  setToTREdgeXY,
+  setToREdge,
+  setToREdgeXY,
+  setToBREdgeXY,
+  setToBEdge,
+  setToBEdgeXY,
+  setToBLEdgeXY,
+  setToLEdge,
+  setToLEdgeXY
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/HorizontalModel.ts
@@ -0,0 +1,126 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Css, Width } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyTriggers from '../../api/events/AlloyTriggers';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import { HorizontalSliderDetail, SliderValueX } from '../types/SliderTypes';
+import * as EdgeActions from './EdgeActions';
+import * as ModelCommon from './ModelCommon';
+import * as SliderModel from './SliderModel';
+import { getMaxXBounds, getMinXBounds, getXCenterOffSetOf, getXScreenRange } from './SliderOffsets';
+import { currentValue, hasLEdge, hasREdge, maxX, minX, rounded, snap, snapStart, step, xRange } from './SliderValues';
+const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueX): void => {
+  AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
+};
+const findValueOfOffset = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, left: number): number => {
+  const args = {
+    min: minX(detail),
+    max: maxX(detail),
+    range: xRange(detail),
+    value: left,
+    step: step(detail),
+    snap: snap(detail),
+    snapStart: snapStart(detail),
+    rounded: rounded(detail),
+    hasMinEdge: hasLEdge(detail),
+    hasMaxEdge: hasREdge(detail),
+    minBound: getMinXBounds(spectrum),
+    maxBound: getMaxXBounds(spectrum),
+    screenRange: getXScreenRange(spectrum)
+  };
+  return SliderModel.findValueOf(args);
+};
+const setValueFrom = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, value: number): number => {
+  const xValue = findValueOfOffset(spectrum, detail, value);
+  const sliderVal = xValue;
+  fireSliderChange(spectrum, sliderVal);
+  return xValue;
+};
+const setToMin = (spectrum: AlloyComponent, detail: HorizontalSliderDetail): void => {
+  const min = minX(detail);
+  fireSliderChange(spectrum, min);
+};
+const setToMax = (spectrum: AlloyComponent, detail: HorizontalSliderDetail): void => {
+  const max = maxX(detail);
+  fireSliderChange(spectrum, max);
+};
+const moveBy = (direction: number, spectrum: AlloyComponent, detail: HorizontalSliderDetail): Optional<number> => {
+  const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
+  const xValue = f(currentValue(detail), minX(detail), maxX(detail), step(detail));
+  fireSliderChange(spectrum, xValue);
+  return Optional.some(xValue);
+};
+const handleMovement = (direction: number) => (spectrum: AlloyComponent, detail: HorizontalSliderDetail): Optional<boolean> =>
+  moveBy(direction, spectrum, detail).map<boolean>(Fun.always);
+const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<number> => {
+  const pos = ModelCommon.getEventSource(simulatedEvent);
+  return pos.map((p) => p.left);
+};
+const findOffsetOfValue = (spectrum: AlloyComponent, detail: HorizontalSliderDetail, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>): number => {
+  const minOffset = 0;
+  const maxOffset = getXScreenRange(spectrum);
+  const centerMinEdge = minEdge.bind((edge: AlloyComponent) =>
+    Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(minOffset);
+  const centerMaxEdge = maxEdge.bind((edge: AlloyComponent) =>
+    Optional.some(getXCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
+  const args = {
+    min: minX(detail),
+    max: maxX(detail),
+    range: xRange(detail),
+    value,
+    hasMinEdge: hasLEdge(detail),
+    hasMaxEdge: hasREdge(detail),
+    minBound: getMinXBounds(spectrum),
+    minOffset,
+    maxBound: getMaxXBounds(spectrum),
+    maxOffset,
+    centerMinEdge,
+    centerMaxEdge
+  };
+  return SliderModel.findOffsetOfValue(args);
+};
+const findPositionOfValue = (slider: AlloyComponent, spectrum: AlloyComponent, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>, detail: HorizontalSliderDetail): number => {
+  const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
+  return (getMinXBounds(spectrum) - getMinXBounds(slider)) + offset;
+};
+const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: HorizontalSliderDetail, edges: any): void => {
+  const value = currentValue(detail);
+  const pos = findPositionOfValue(
+    slider,
+    edges.getSpectrum(slider),
+    value,
+    edges.getLeftEdge(slider),
+    edges.getRightEdge(slider),
+    detail
+  );
+  const thumbRadius = Width.get(thumb.element) / 2;
+  Css.set(thumb.element, 'left', (pos - thumbRadius) + 'px');
+};
+const onLeft = handleMovement(-1);
+const onRight = handleMovement(1);
+const onUp = Optional.none;
+const onDown = Optional.none;
+const edgeActions = {
+  'top-left': Optional.none(),
+  'top': Optional.none(),
+  'top-right': Optional.none(),
+  'right': Optional.some(EdgeActions.setToREdge),
+  'bottom-right': Optional.none(),
+  'bottom': Optional.none(),
+  'bottom-left': Optional.none(),
+  'left': Optional.some(EdgeActions.setToLEdge)
+};
+export {
+  setValueFrom,
+  setToMin,
+  setToMax,
+  findValueOfOffset,
+  getValueFromEvent,
+  findPositionOfValue,
+  setPositionFromValue,
+  onLeft,
+  onRight,
+  onUp,
+  onDown,
+  edgeActions
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/SliderParts.ts
@@ -0,0 +1,113 @@
+import { FieldSchema } from '@ephox/boulder';
+import { Cell, Fun } from '@ephox/katamari';
+import { EventArgs, SugarPosition } from '@ephox/sugar';
+import * as Behaviour from '../../api/behaviour/Behaviour';
+import { Focusing } from '../../api/behaviour/Focusing';
+import { Keying } from '../../api/behaviour/Keying';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { OptionalDomSchema } from '../../api/component/SpecTypes';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import * as NativeEvents from '../../api/events/NativeEvents';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import * as PartType from '../../parts/PartType';
+import { EdgeActions, SliderDetail } from '../types/SliderTypes';
+const labelPart = PartType.optional({
+  schema: [ FieldSchema.required('dom') ],
+  name: 'label'
+});
+const edgePart = (name: keyof EdgeActions): PartType.PartTypeAdt => PartType.optional({
+  name: '' + name + '-edge',
+  overrides: (detail: SliderDetail) => {
+    const action = detail.model.manager.edgeActions[name];
+    return action.fold(() => ({}),
+      (a) => ({
+        events: AlloyEvents.derive([
+          AlloyEvents.runActionExtra(NativeEvents.touchstart(), (comp, se, d) => a(comp, d), [ detail ]),
+          AlloyEvents.runActionExtra(NativeEvents.mousedown(), (comp, se, d) => a(comp, d), [ detail ]),
+          AlloyEvents.runActionExtra(NativeEvents.mousemove(), (comp, se, det: SliderDetail) => {
+            if (det.mouseIsDown.get()) {
+              a(comp, det);
+            }
+          }, [ detail ])
+        ])
+      })
+    );
+  }
+});
+const tlEdgePart = edgePart('top-left');
+const tedgePart = edgePart('top');
+const trEdgePart = edgePart('top-right');
+const redgePart = edgePart('right');
+const brEdgePart = edgePart('bottom-right');
+const bedgePart = edgePart('bottom');
+const blEdgePart = edgePart('bottom-left');
+const ledgePart = edgePart('left');
+const thumbPart = PartType.required<SliderDetail, { dom: OptionalDomSchema; events: AlloyEvents.AlloyEventRecord }>({
+  name: 'thumb',
+  defaults: Fun.constant({
+    dom: {
+      styles: { position: 'absolute' }
+    }
+  }),
+  overrides: (detail) => {
+    return {
+      events: AlloyEvents.derive([
+        AlloyEvents.redirectToPart(NativeEvents.touchstart(), detail, 'spectrum'),
+        AlloyEvents.redirectToPart(NativeEvents.touchmove(), detail, 'spectrum'),
+        AlloyEvents.redirectToPart(NativeEvents.touchend(), detail, 'spectrum'),
+        AlloyEvents.redirectToPart(NativeEvents.mousedown(), detail, 'spectrum'),
+        AlloyEvents.redirectToPart(NativeEvents.mousemove(), detail, 'spectrum'),
+        AlloyEvents.redirectToPart(NativeEvents.mouseup(), detail, 'spectrum')
+      ])
+    };
+  }
+});
+const spectrumPart = PartType.required({
+  schema: [
+    FieldSchema.customField('mouseIsDown', () => Cell(false))
+  ],
+  name: 'spectrum',
+  overrides: (detail: SliderDetail) => {
+    const modelDetail = detail.model;
+    const model = modelDetail.manager;
+    const setValueFrom = (component: AlloyComponent, simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>) =>
+      model.getValueFromEvent(simulatedEvent).map((value: number | SugarPosition) => model.setValueFrom(component, detail, value));
+    return {
+      behaviours: Behaviour.derive([
+        Keying.config(
+          {
+            mode: 'special',
+            onLeft: (spectrum) => model.onLeft(spectrum, detail),
+            onRight: (spectrum) => model.onRight(spectrum, detail),
+            onUp: (spectrum) => model.onUp(spectrum, detail),
+            onDown: (spectrum) => model.onDown(spectrum, detail)
+          }
+        ),
+        Focusing.config({})
+      ]),
+      events: AlloyEvents.derive([
+        AlloyEvents.run(NativeEvents.touchstart(), setValueFrom),
+        AlloyEvents.run(NativeEvents.touchmove(), setValueFrom),
+        AlloyEvents.run(NativeEvents.mousedown(), setValueFrom),
+        AlloyEvents.run<EventArgs<MouseEvent>>(NativeEvents.mousemove(), (spectrum, se) => {
+          if (detail.mouseIsDown.get()) {
+            setValueFrom(spectrum, se);
+          }
+        })
+      ])
+    };
+  }
+});
+export default [
+  labelPart,
+  ledgePart,
+  redgePart,
+  tedgePart,
+  bedgePart,
+  tlEdgePart,
+  trEdgePart,
+  blEdgePart,
+  brEdgePart,
+  thumbPart,
+  spectrumPart
+] as PartType.PartTypeAdt[];

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/SliderUi.ts
@@ -0,0 +1,137 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Keying } from '../../api/behaviour/Keying';
+import { Receiving } from '../../api/behaviour/Receiving';
+import { Representing } from '../../api/behaviour/Representing';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as SketchBehaviours from '../../api/component/SketchBehaviours';
+import { AlloySpec } from '../../api/component/SpecTypes';
+import * as AlloyEvents from '../../api/events/AlloyEvents';
+import * as NativeEvents from '../../api/events/NativeEvents';
+import * as Channels from '../../api/messages/Channels';
+import { CompositeSketchFactory } from '../../api/ui/UiSketcher';
+import { EventFormat, NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import * as AlloyParts from '../../parts/AlloyParts';
+import { SliderDetail, SliderSpec, SliderUpdateEvent, SliderValue } from '../types/SliderTypes';
+import * as ModelCommon from './ModelCommon';
+const sketch: CompositeSketchFactory<SliderDetail, SliderSpec> = (detail: SliderDetail, components: AlloySpec[], _spec: SliderSpec, _externals) => {
+  const getThumb = (component: AlloyComponent): AlloyComponent => AlloyParts.getPartOrDie(component, detail, 'thumb');
+  const getSpectrum = (component: AlloyComponent): AlloyComponent => AlloyParts.getPartOrDie(component, detail, 'spectrum');
+  const getLeftEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'left-edge');
+  const getRightEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'right-edge');
+  const getTopEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'top-edge');
+  const getBottomEdge = (component: AlloyComponent): Optional<AlloyComponent> => AlloyParts.getPart(component, detail, 'bottom-edge');
+  const modelDetail = detail.model;
+  const model = modelDetail.manager;
+  const refresh = (slider: AlloyComponent, thumb: AlloyComponent): void => {
+    model.setPositionFromValue(slider, thumb, detail, {
+      getLeftEdge,
+      getRightEdge,
+      getTopEdge,
+      getBottomEdge,
+      getSpectrum
+    });
+  };
+  const setValue = (slider: AlloyComponent, newValue: SliderValue): void => {
+    modelDetail.value.set(newValue);
+    const thumb = getThumb(slider);
+    refresh(slider, thumb);
+  };
+  const changeValue = (slider: AlloyComponent, newValue: SliderValue): Optional<boolean> => {
+    setValue(slider, newValue);
+    const thumb = getThumb(slider);
+    detail.onChange(slider, thumb, newValue);
+    return Optional.some<boolean>(true);
+  };
+  const resetToMin = (slider: AlloyComponent) => {
+    model.setToMin(slider, detail);
+  };
+  const resetToMax = (slider: AlloyComponent) => {
+    model.setToMax(slider, detail);
+  };
+  const choose = (slider: AlloyComponent) => {
+    const fireOnChoose = () => {
+      AlloyParts.getPart(slider, detail, 'thumb').each((thumb) => {
+        const value = modelDetail.value.get();
+        detail.onChoose(slider, thumb, value);
+      });
+    };
+    const wasDown = detail.mouseIsDown.get();
+    detail.mouseIsDown.set(false);
+    if (wasDown) {
+      fireOnChoose();
+    }
+  };
+  const onDragStart = (slider: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => {
+    simulatedEvent.stop();
+    detail.mouseIsDown.set(true);
+    detail.onDragStart(slider, getThumb(slider));
+  };
+  const onDragEnd = (slider: AlloyComponent, simulatedEvent: NativeSimulatedEvent<DragEvent>) => {
+    simulatedEvent.stop();
+    detail.onDragEnd(slider, getThumb(slider));
+    choose(slider);
+  };
+  return {
+    uid: detail.uid,
+    dom: detail.dom,
+    components,
+    behaviours: SketchBehaviours.augment(
+      detail.sliderBehaviours,
+      [
+        Keying.config({
+          mode: 'special',
+          focusIn: (slider) => {
+            return AlloyParts.getPart(slider, detail, 'spectrum').map(Keying.focusIn).map(Fun.always);
+          }
+        }),
+        Representing.config({
+          store: {
+            mode: 'manual',
+            getValue: (_) => {
+              return modelDetail.value.get();
+            },
+            setValue
+          }
+        }),
+        Receiving.config({
+          channels: {
+            [Channels.mouseReleased()]: {
+              onReceive: choose
+            }
+          }
+        })
+      ]
+    ),
+    events: AlloyEvents.derive([
+      AlloyEvents.run<SliderUpdateEvent>(ModelCommon.sliderChangeEvent(), (slider, simulatedEvent) => {
+        changeValue(slider, simulatedEvent.event.value);
+      }) as AlloyEvents.AlloyEventKeyAndHandler<EventFormat>,
+      AlloyEvents.runOnAttached((slider, _simulatedEvent) => {
+        const getInitial = modelDetail.getInitialValue();
+        modelDetail.value.set(getInitial);
+        const thumb = getThumb(slider);
+        refresh(slider, thumb);
+        const spectrum = getSpectrum(slider);
+        detail.onInit(slider, thumb, spectrum, modelDetail.value.get());
+      }),
+      AlloyEvents.run(NativeEvents.touchstart(), onDragStart),
+      AlloyEvents.run(NativeEvents.touchend(), onDragEnd),
+      AlloyEvents.run(NativeEvents.mousedown(), onDragStart),
+      AlloyEvents.run(NativeEvents.mouseup(), onDragEnd)
+    ]),
+    apis: {
+      resetToMin,
+      resetToMax,
+      setValue,
+      refresh
+    },
+    domModification: {
+      styles: {
+        position: 'relative'
+      }
+    }
+  };
+};
+export {
+  sketch
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/TwoDModel.ts
@@ -0,0 +1,98 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Css, Height, SugarPosition, Width } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyTriggers from '../../api/events/AlloyTriggers';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import { SliderModelDetailParts, SliderValueXY, TwoDSliderDetail } from '../types/SliderTypes';
+import * as EdgeActions from './EdgeActions';
+import * as HorizontalModel from './HorizontalModel';
+import * as ModelCommon from './ModelCommon';
+import * as SliderModel from './SliderModel';
+import { currentValue, maxX, maxY, minX, minY, step } from './SliderValues';
+import * as VerticalModel from './VerticalModel';
+const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueXY): void => {
+  AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
+};
+const sliderValue = (x: number, y: number): SliderValueXY => ({
+  x,
+  y
+});
+const setValueFrom = (spectrum: AlloyComponent, detail: TwoDSliderDetail, value: SugarPosition): SliderValueXY => {
+  const xValue = HorizontalModel.findValueOfOffset(spectrum, detail, value.left);
+  const yValue = VerticalModel.findValueOfOffset(spectrum, detail, value.top);
+  const val = sliderValue(xValue, yValue);
+  fireSliderChange(spectrum, val);
+  return val;
+};
+const moveBy = (direction: number, isVerticalMovement: boolean, spectrum: AlloyComponent, detail: TwoDSliderDetail): Optional<number> => {
+  const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
+  const xValue = isVerticalMovement ? currentValue(detail).x :
+    f(currentValue(detail).x, minX(detail), maxX(detail), step(detail));
+  const yValue = !isVerticalMovement ? currentValue(detail).y :
+    f(currentValue(detail).y, minY(detail), maxY(detail), step(detail));
+  fireSliderChange(spectrum, sliderValue(xValue, yValue));
+  return Optional.some(xValue);
+};
+const handleMovement = (direction: number, isVerticalMovement: boolean) => (spectrum: AlloyComponent, detail: TwoDSliderDetail): Optional<boolean> =>
+  moveBy(direction, isVerticalMovement, spectrum, detail).map<boolean>(Fun.always);
+const setToMin = (spectrum: AlloyComponent, detail: TwoDSliderDetail): void => {
+  const mX = minX(detail);
+  const mY = minY(detail);
+  fireSliderChange(spectrum, sliderValue(mX, mY));
+};
+const setToMax = (spectrum: AlloyComponent, detail: TwoDSliderDetail): void => {
+  const mX = maxX(detail);
+  const mY = maxY(detail);
+  fireSliderChange(spectrum, sliderValue(mX, mY));
+};
+const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<SugarPosition> =>
+  ModelCommon.getEventSource(simulatedEvent);
+const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: TwoDSliderDetail, edges: SliderModelDetailParts): void => {
+  const value = currentValue(detail);
+  const xPos = HorizontalModel.findPositionOfValue(
+    slider,
+    edges.getSpectrum(slider),
+    value.x,
+    edges.getLeftEdge(slider),
+    edges.getRightEdge(slider),
+    detail
+  );
+  const yPos = VerticalModel.findPositionOfValue(
+    slider,
+    edges.getSpectrum(slider),
+    value.y,
+    edges.getTopEdge(slider),
+    edges.getBottomEdge(slider),
+    detail
+  );
+  const thumbXRadius = Width.get(thumb.element) / 2;
+  const thumbYRadius = Height.get(thumb.element) / 2;
+  Css.set(thumb.element, 'left', (xPos - thumbXRadius) + 'px');
+  Css.set(thumb.element, 'top', (yPos - thumbYRadius) + 'px');
+};
+const onLeft = handleMovement(-1, false);
+const onRight = handleMovement(1, false);
+const onUp = handleMovement(-1, true);
+const onDown = handleMovement(1, true);
+const edgeActions = {
+  'top-left': Optional.some(EdgeActions.setToTLEdgeXY),
+  'top': Optional.some(EdgeActions.setToTEdgeXY),
+  'top-right': Optional.some(EdgeActions.setToTREdgeXY),
+  'right': Optional.some(EdgeActions.setToREdgeXY),
+  'bottom-right': Optional.some(EdgeActions.setToBREdgeXY),
+  'bottom': Optional.some(EdgeActions.setToBEdgeXY),
+  'bottom-left': Optional.some(EdgeActions.setToBLEdgeXY),
+  'left': Optional.some(EdgeActions.setToLEdgeXY)
+};
+export {
+  setValueFrom,
+  setToMin,
+  setToMax,
+  getValueFromEvent,
+  setPositionFromValue,
+  onLeft,
+  onRight,
+  onUp,
+  onDown,
+  edgeActions
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/slider/VerticalModel.ts
@@ -0,0 +1,128 @@
+import { Fun, Optional } from '@ephox/katamari';
+import { Css, Height } from '@ephox/sugar';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import * as AlloyTriggers from '../../api/events/AlloyTriggers';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+import { SliderValueY, VerticalSliderDetail } from '../types/SliderTypes';
+import * as EdgeActions from './EdgeActions';
+import * as ModelCommon from './ModelCommon';
+import * as SliderModel from './SliderModel';
+import { getMaxYBounds, getMinYBounds, getYCenterOffSetOf, getYScreenRange } from './SliderOffsets';
+import { currentValue, hasBEdge, hasTEdge, maxY, minY, rounded, snap, snapStart, step, yRange } from './SliderValues';
+const fireSliderChange = (spectrum: AlloyComponent, value: SliderValueY): void => {
+  AlloyTriggers.emitWith(spectrum, ModelCommon.sliderChangeEvent(), { value });
+};
+const findValueOfOffset = (spectrum: AlloyComponent, detail: VerticalSliderDetail, top: number): number => {
+  const args = {
+    min: minY(detail),
+    max: maxY(detail),
+    range: yRange(detail),
+    value: top,
+    step: step(detail),
+    snap: snap(detail),
+    snapStart: snapStart(detail),
+    rounded: rounded(detail),
+    hasMinEdge: hasTEdge(detail),
+    hasMaxEdge: hasBEdge(detail),
+    minBound: getMinYBounds(spectrum),
+    maxBound: getMaxYBounds(spectrum),
+    screenRange: getYScreenRange(spectrum)
+  };
+  return SliderModel.findValueOf(args);
+};
+const setValueFrom = (spectrum: AlloyComponent, detail: VerticalSliderDetail, value: number): number => {
+  const yValue = findValueOfOffset(spectrum, detail, value);
+  const sliderVal = yValue;
+  fireSliderChange(spectrum, sliderVal);
+  return yValue;
+};
+const setToMin = (spectrum: AlloyComponent, detail: VerticalSliderDetail): void => {
+  const min = minY(detail);
+  fireSliderChange(spectrum, min);
+};
+const setToMax = (spectrum: AlloyComponent, detail: VerticalSliderDetail): void => {
+  const max = maxY(detail);
+  fireSliderChange(spectrum, max);
+};
+const moveBy = (direction: number, spectrum: AlloyComponent, detail: VerticalSliderDetail): Optional<number> => {
+  const f = (direction > 0) ? SliderModel.increaseBy : SliderModel.reduceBy;
+  const yValue = f(currentValue(detail), minY(detail), maxY(detail), step(detail));
+  fireSliderChange(spectrum, yValue);
+  return Optional.some(yValue);
+};
+const handleMovement = (direction: number) => (spectrum: AlloyComponent, detail: VerticalSliderDetail): Optional<boolean> =>
+  moveBy(direction, spectrum, detail).map<boolean>(Fun.always);
+const getValueFromEvent = (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>): Optional<number> => {
+  const pos = ModelCommon.getEventSource(simulatedEvent);
+  return pos.map((p) => {
+    return p.top;
+  });
+};
+const findOffsetOfValue = (spectrum: AlloyComponent, detail: VerticalSliderDetail, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>): number => {
+  const minOffset = 0;
+  const maxOffset = getYScreenRange(spectrum);
+  const centerMinEdge = minEdge.bind((edge: AlloyComponent) =>
+    Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(minOffset);
+  const centerMaxEdge = maxEdge.bind((edge: AlloyComponent) =>
+    Optional.some(getYCenterOffSetOf(edge, spectrum))).getOr(maxOffset);
+  const args = {
+    min: minY(detail),
+    max: maxY(detail),
+    range: yRange(detail),
+    value,
+    hasMinEdge: hasTEdge(detail),
+    hasMaxEdge: hasBEdge(detail),
+    minBound: getMinYBounds(spectrum),
+    minOffset,
+    maxBound: getMaxYBounds(spectrum),
+    maxOffset,
+    centerMinEdge,
+    centerMaxEdge
+  };
+  return SliderModel.findOffsetOfValue(args);
+};
+const findPositionOfValue = (slider: AlloyComponent, spectrum: AlloyComponent, value: number, minEdge: Optional<AlloyComponent>, maxEdge: Optional<AlloyComponent>, detail: VerticalSliderDetail): number => {
+  const offset = findOffsetOfValue(spectrum, detail, value, minEdge, maxEdge);
+  return (getMinYBounds(spectrum) - getMinYBounds(slider)) + offset;
+};
+const setPositionFromValue = (slider: AlloyComponent, thumb: AlloyComponent, detail: VerticalSliderDetail, edges: any): void => {
+  const value = currentValue(detail);
+  const pos = findPositionOfValue(
+    slider,
+    edges.getSpectrum(slider),
+    value,
+    edges.getTopEdge(slider),
+    edges.getBottomEdge(slider),
+    detail
+  );
+  const thumbRadius = Height.get(thumb.element) / 2;
+  Css.set(thumb.element, 'top', (pos - thumbRadius) + 'px');
+};
+const onLeft = Optional.none;
+const onRight = Optional.none;
+const onUp = handleMovement(-1);
+const onDown = handleMovement(1);
+const edgeActions = {
+  'top-left': Optional.none(),
+  'top': Optional.some(EdgeActions.setToTEdge),
+  'top-right': Optional.none(),
+  'right': Optional.none(),
+  'bottom-right': Optional.none(),
+  'bottom': Optional.some(EdgeActions.setToBEdge),
+  'bottom-left': Optional.none(),
+  'left': Optional.none()
+};
+export {
+  setValueFrom,
+  setToMin,
+  setToMax,
+  findValueOfOffset,
+  getValueFromEvent,
+  findPositionOfValue,
+  setPositionFromValue,
+  onLeft,
+  onRight,
+  onUp,
+  onDown,
+  edgeActions
+};

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/types/InlineViewTypes.ts
@@ -0,0 +1,67 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
+import { LazySink } from '../../api/component/CommonTypes';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SketchBehaviours } from '../../api/component/SketchBehaviours';
+import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
+import { SingleSketch, SingleSketchDetail, SingleSketchSpec } from '../../api/ui/Sketcher';
+import { PlacementSpec } from '../../behaviour/positioning/PositioningTypes';
+import { TieredData, TieredMenuSpec } from './TieredMenuTypes';
+export interface InlineViewDetail extends SingleSketchDetail {
+  uid: string;
+  dom: RawDomSchema;
+  components: AlloySpec[ ];
+  inlineBehaviours: SketchBehaviours;
+  onShow: (component: AlloyComponent) => void;
+  onHide: (component: AlloyComponent) => void;
+  onEscape: Optional<(component: AlloyComponent) => void>;
+  getRelated: (component: AlloyComponent) => Optional<AlloyComponent>;
+  isExtraPart: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
+  lazySink: LazySink;
+  eventOrder: Record<string, string[]>;
+  fireDismissalEventInstead: Optional<{
+    event: string;
+  }>;
+  fireRepositionEventInstead: Optional<{
+    event: string;
+  }>;
+}
+export interface InlineViewSpec extends SingleSketchSpec {
+  uid?: string;
+  dom: RawDomSchema;
+  components?: AlloySpec[];
+  inlineBehaviours?: AlloyBehaviourRecord;
+  lazySink: LazySink;
+  onShow?: (component: AlloyComponent) => void;
+  onHide?: (component: AlloyComponent) => void;
+  onEscape?: (component: AlloyComponent) => void;
+  getRelated?: (component: AlloyComponent) => Optional<AlloyComponent>;
+  isExtraPart?: (component: AlloyComponent, target: SugarElement<Node>) => boolean;
+  eventOrder?: Record<string, string[]>;
+  fireDismissalEventInstead?: {
+    event?: string;
+  };
+  fireRepositionEventInstead?: {
+    event?: string;
+  };
+}
+export interface InlineMenuSpec {
+  data: TieredData;
+  menu: Partial<TieredMenuSpec> & { markers: TieredMenuSpec['markers'] };
+  type?: 'vertical' | 'horizontal';
+}
+export interface InlineViewApis {
+  showAt: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec) => void;
+  showWithin: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, boxElement: Optional<SugarElement<HTMLElement>>) => void;
+  showWithinBounds: (component: AlloyComponent, thing: AlloySpec, placementSpec: PlacementSpec, getBounds: () => Optional<Bounds>) => void;
+  showMenuAt: (component: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec) => void;
+  showMenuWithinBounds: (component: AlloyComponent, placementSpec: PlacementSpec, menuSpec: InlineMenuSpec, getBounds: () => Optional<Bounds>) => void;
+  hide: (component: AlloyComponent) => void;
+  isOpen: (component: AlloyComponent) => boolean;
+  getContent: (component: AlloyComponent) => Optional<AlloyComponent>;
+  setContent: (component: AlloyComponent, thing: AlloySpec) => void;
+  reposition: (component: AlloyComponent) => void;
+}
+export interface InlineViewSketcher extends SingleSketch<InlineViewSpec>, InlineViewApis { }

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/types/ModalDialogTypes.ts
@@ -0,0 +1,55 @@
+import { Optional } from '@ephox/katamari';
+import { SugarElement } from '@ephox/sugar';
+import { Bounds } from '../../alien/Boxes';
+import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
+import { LazySink } from '../../api/component/CommonTypes';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SketchBehaviours } from '../../api/component/SketchBehaviours';
+import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
+import { CompositeSketch, CompositeSketchDetail, CompositeSketchSpec } from '../../api/ui/Sketcher';
+import { NativeSimulatedEvent } from '../../events/SimulatedEvent';
+export interface ModalDialogDetail extends CompositeSketchDetail {
+  uid: string;
+  dom: RawDomSchema;
+  components: AlloySpec[ ];
+  modalBehaviours: SketchBehaviours;
+  eventOrder: Record<string, string[]>;
+  onExecute: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
+  onEscape: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
+  useTabstopAt: (elem: SugarElement<HTMLElement>) => boolean;
+  lazySink: LazySink;
+  dragBlockClass: Optional<string>;
+  getDragBounds: () => Bounds;
+}
+export interface ModalDialogSpec extends CompositeSketchSpec {
+  uid?: string;
+  dom: RawDomSchema;
+  components?: AlloySpec[];
+  modalBehaviours?: AlloyBehaviourRecord;
+  eventOrder?: Record<string, string[]>;
+  lazySink?: LazySink;
+  useTabstopAt?: (comp: SugarElement<HTMLElement>) => boolean;
+  onExecute?: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
+  onEscape?: (comp: AlloyComponent, simulatedEvent: NativeSimulatedEvent) => Optional<boolean>;
+  dragBlockClass?: string;
+  getDragBounds?: () => Bounds;
+  parts: {
+    blocker: {
+      dom?: Partial<RawDomSchema>;
+      components?: AlloySpec[];
+    };
+  };
+}
+export type GetBusySpec = (
+  dlg: AlloyComponent,
+  busyBehaviours: AlloyBehaviourRecord
+) => AlloySpec;
+export interface ModalDialogApis {
+  show: (dialog: AlloyComponent) => void;
+  hide: (dialog: AlloyComponent) => void;
+  getBody: (dialog: AlloyComponent) => AlloyComponent;
+  getFooter: (dialog: AlloyComponent) => AlloyComponent;
+  setBusy: (dialog: AlloyComponent, getBusySpec: GetBusySpec) => void;
+  setIdle: (dialog: AlloyComponent) => void;
+}
+export interface ModalDialogSketcher extends CompositeSketch<ModalDialogSpec>, ModalDialogApis { }

--- a//dev/null
+++ b/modules/alloy/src/main/ts/ephox/alloy/ui/types/SliderTypes.ts
@@ -0,0 +1,139 @@
+import { Cell, Optional } from '@ephox/katamari';
+import { SugarPosition } from '@ephox/sugar';
+import { AlloyBehaviourRecord } from '../../api/behaviour/Behaviour';
+import { AlloyComponent } from '../../api/component/ComponentApi';
+import { SketchBehaviours } from '../../api/component/SketchBehaviours';
+import { AlloySpec, RawDomSchema } from '../../api/component/SpecTypes';
+import { CompositeSketch, CompositeSketchDetail, CompositeSketchSpec } from '../../api/ui/Sketcher';
+import { CustomEvent, NativeSimulatedEvent } from '../../events/SimulatedEvent';
+export type SliderValueX = number;
+export type SliderValueY = number;
+export interface SliderValueXY {
+  readonly x: number;
+  readonly y: number;
+}
+export type SliderValue = SliderValueX | SliderValueY | SliderValueXY;
+export interface SliderUpdateEvent extends CustomEvent {
+  value: SliderValue;
+}
+export interface SliderModelDetailParts {
+  getSpectrum: (component: AlloyComponent) => AlloyComponent;
+  getLeftEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
+  getRightEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
+  getTopEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
+  getBottomEdge: (component: AlloyComponent) => Optional<AlloyComponent>;
+}
+export interface EdgeActions {
+  'top-left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'top': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'top-right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'bottom-right': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'bottom': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'bottom-left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+  'left': Optional<(edge: AlloyComponent, detail: SliderDetail) => void>;
+}
+export interface Manager {
+  setValueFrom: (spectrum: AlloyComponent, detail: SliderDetail, value: number | SugarPosition) => void;
+  setToMin: (spectrum: AlloyComponent, detail: SliderDetail) => void;
+  setToMax: (spectrum: AlloyComponent, detail: SliderDetail) => void;
+  getValueFromEvent: (simulatedEvent: NativeSimulatedEvent<MouseEvent | TouchEvent>) => Optional<number | SugarPosition>;
+  setPositionFromValue: (slider: AlloyComponent, thumb: AlloyComponent, detail: SliderDetail, parts: SliderModelDetailParts) => void;
+  onLeft: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
+  onRight: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
+  onUp: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
+  onDown: (spectrum: AlloyComponent, detail: SliderDetail) => Optional<boolean>;
+  edgeActions: EdgeActions;
+}
+export interface SliderModelDetail {
+  minX?: number;
+  maxX?: number;
+  minY?: number;
+  maxY?: number;
+  value: Cell<SliderValue>;
+  getInitialValue: () => SliderValue;
+  manager: Manager;
+}
+export interface VerticalSliderModelDetail extends SliderModelDetail {
+  minY: number;
+  maxY: number;
+}
+export interface HorizontalSliderModelDetail extends SliderModelDetail {
+  minX: number;
+  maxX: number;
+}
+export interface TwoDSliderModelDetail extends SliderModelDetail {
+  minX: number;
+  maxX: number;
+  minY: number;
+  maxY: number;
+}
+export interface SliderDetail extends CompositeSketchDetail {
+  uid: string;
+  dom: RawDomSchema;
+  components: AlloySpec[];
+  sliderBehaviours: SketchBehaviours;
+  model: SliderModelDetail;
+  rounded: boolean;
+  stepSize: number;
+  snapToGrid: boolean;
+  snapStart: Optional<number>;
+  onChange: (component: AlloyComponent, thumb: AlloyComponent, value: number | SliderValue) => void;
+  onChoose: (component: AlloyComponent, thumb: AlloyComponent, value: number | SliderValue) => void;
+  onDragStart: (component: AlloyComponent, thumb: AlloyComponent) => void;
+  onDragEnd: (component: AlloyComponent, thumb: AlloyComponent) => void;
+  onInit: (component: AlloyComponent, thumb: AlloyComponent, spectrum: AlloyComponent, value: number | SliderValue) => void;
+  mouseIsDown: Cell<boolean>;
+}
+export interface VerticalSliderDetail extends SliderDetail {
+  model: VerticalSliderModelDetail;
+}
+export interface HorizontalSliderDetail extends SliderDetail {
+  model: HorizontalSliderModelDetail;
+}
+export interface TwoDSliderDetail extends SliderDetail {
+  model: TwoDSliderModelDetail;
+}
+export interface HorizontalSliderSpecMode {
+  mode: 'x';
+  minX?: number;
+  maxX?: number;
+  getInitialValue: () => SliderValueX;
+}
+export interface VerticalSliderSpecMode {
+  mode: 'y';
+  minY?: number;
+  maxY?: number;
+  getInitialValue: () => SliderValueY;
+}
+export interface TwoDSliderSpecMode {
+  mode: 'xy';
+  minX?: number;
+  maxX?: number;
+  minY?: number;
+  maxY?: number;
+  getInitialValue: () => SliderValueXY;
+}
+export interface SliderSpec extends CompositeSketchSpec {
+  uid?: string;
+  dom: RawDomSchema;
+  components?: AlloySpec[];
+  sliderBehaviours?: AlloyBehaviourRecord;
+  model: HorizontalSliderSpecMode | VerticalSliderSpecMode | TwoDSliderSpecMode;
+  stepSize?: number;
+  snapToGrid?: boolean;
+  snapStart?: number;
+  rounded?: boolean;
+  onChange?: (component: AlloyComponent, thumb: AlloyComponent, value: SliderValue) => void;
+  onChoose?: (component: AlloyComponent, thumb: AlloyComponent, value: SliderValue) => void;
+  onDragStart?: (component: AlloyComponent, thumb: AlloyComponent) => void;
+  onDragEnd?: (component: AlloyComponent, thumb: AlloyComponent) => void;
+  onInit?: (component: AlloyComponent, thumb: AlloyComponent, spectrum: AlloyComponent, value: SliderValue) => void;
+}
+export interface SliderApis {
+  setValue: (slider: AlloyComponent, value: SliderValue) => void;
+  resetToMin: (slider: AlloyComponent) => void;
+  resetToMax: (slider: AlloyComponent) => void;
+  refresh: (slider: AlloyComponent) => void;
+}
+export interface SliderSketcher extends CompositeSketch<SliderSpec>, SliderApis { }

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/dialogs/DemoDialogHelpers.ts
@@ -0,0 +1,30 @@
+import { StructureProcessor, StructureSchema } from '@ephox/boulder';
+import { Cell, Fun, Merger } from '@ephox/katamari';
+import { DialogManager } from '../../../main/ts/ephox/bridge/api/DialogManager';
+import { Dialog, DialogInstanceApi, DialogSpec } from '../../../main/ts/ephox/bridge/components/dialog/Dialog';
+const createDemoApi = <T>(internalStructure: Dialog<T>, initalData: Partial<T>, dataValidator: StructureProcessor): DialogInstanceApi<T> => {
+  const data = Cell(initalData);
+  console.log({
+    internalStructure,
+    initalData
+  });
+  return {
+    getData: () =>
+      data.get() as any,
+    setData: (newData: Partial<T>) => {
+      const mergedData = Merger.deepMerge(data.get(), newData);
+      const newInternalData = StructureSchema.getOrDie(StructureSchema.asRaw('data', dataValidator, mergedData));
+      data.set(newInternalData);
+    },
+    redial: Fun.noop,
+    focus: (_name: string) => {},
+    showTab: (_title: string) => {},
+    setEnabled: (_name: string, _state: boolean) => {},
+    block: (_message: string) => {},
+    unblock: Fun.noop,
+    close: Fun.noop
+  };
+};
+export const openDemoDialog = <T>(structure: DialogSpec<T>): void => {
+  DialogManager.open(createDemoApi, structure);
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/dialogs/FindReplaceDialog.ts
@@ -0,0 +1,84 @@
+import { openDemoDialog } from './DemoDialogHelpers';
+export const createFindReplaceDialog = (): void => {
+  openDemoDialog(
+    {
+      title: 'Find and replace',
+      body: {
+        type: 'panel',
+        items: [
+          {
+            name: 'find',
+            type: 'input'
+          },
+          {
+            name: 'replace',
+            type: 'input'
+          },
+          {
+            name: 'matchcase',
+            type: 'checkbox',
+            label: 'Match Case'
+          },
+          {
+            name: 'wholewords',
+            type: 'checkbox',
+            label: 'Whole Words'
+          }
+        ]
+      },
+      buttons: [
+        {
+          type: 'custom',
+          name: 'find',
+          text: 'Find',
+          align: 'start',
+          primary: true
+        },
+        {
+          type: 'custom',
+          name: 'replace',
+          text: 'Replace',
+          align: 'start',
+          enabled: false
+        },
+        {
+          type: 'custom',
+          name: 'replaceall',
+          text: 'Replace all',
+          align: 'start',
+          enabled: false
+        },
+        {
+          type: 'custom',
+          name: 'prev',
+          text: 'Prev',
+          align: 'end',
+          enabled: false
+        },
+        {
+          type: 'custom',
+          name: 'next',
+          text: 'Next',
+          align: 'end',
+          enabled: false
+        }
+      ],
+      initialData: {
+        find: '',
+        replace: '',
+        matchcase: 'checked',
+        wholewords: 'unchecked'
+      },
+      onAction: (api, details) => {
+        const data = api.getData();
+        console.log(details.name); // Show action find/replace etc
+        console.log({
+          find: data.find,
+          replace: data.replace,
+          matchcase: data.matchcase,
+          wholewords: data.wholewords
+        });
+      }
+    }
+  );
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/AnchorItems.ts
@@ -0,0 +1,21 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  off: (_s, _f) => { }
+};
+export const registerAnchorItems = (): void => {
+  getDemoRegistry().addToggleButton('anchor', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      const f = (e) => {
+        const state = e;
+        buttonApi.setActive(state);
+      };
+      editor.on('NodeChange', f);
+      return () => editor.off('nodeChange', f);
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/AutosaveItems.ts
@@ -0,0 +1,21 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  off: (_s, _f) => { }
+};
+export const registerAutosaveItems = (): void => {
+  getDemoRegistry().addButton('restoredraft', {
+    type: 'button',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      const editorOffCallback = (e) => {
+        const state = e;
+        buttonApi.setEnabled(!state);
+      };
+      editor.on('StoreDraft RestoreDraft RemoveDraft', editorOffCallback);
+      return () => editor.off('StoreDraft RestoreDraft RemoveDraft', editorOffCallback);
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/CharmapItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerCharmapItems = (): void => {
+  getDemoRegistry().addButton('charmap', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/CodeItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerCodeItems = (): void => {
+  getDemoRegistry().addButton('code', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/CodeSampleItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerCodeSampleItems = (): void => {
+  getDemoRegistry().addButton('codesample', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/DirectionalityItems.ts
@@ -0,0 +1,20 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  off: (_s, _f) => { }
+};
+export const registerDirectionalityItems = (): void => {
+  getDemoRegistry().addToggleButton('dir', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      const f = (e) => {
+        buttonApi.setActive(e);
+      };
+      editor.on('nodeChange', f);
+      return () => editor.off('nodeChange', f);
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/FullscreenItems.ts
@@ -0,0 +1,20 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  off: (_s, _f) => { }
+};
+export const registerFullscreenItems = (): void => {
+  getDemoRegistry().addToggleButton('fullscreen', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      const f = (e) => {
+        buttonApi.setActive(e.something);
+      };
+      editor.on('FullscreenStateChanged', f);
+      return () => editor.off('FullscreenStateChanged', f);
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/LinkItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerLinkItems = (): void => {
+  getDemoRegistry().addButton('link', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/ListItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerListItems = (): void => {
+  getDemoRegistry().addButton('indent', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/MediaItems.ts
@@ -0,0 +1,19 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { }
+};
+export const registerMediaItems = (): void => {
+  getDemoRegistry().addToggleButton('media', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      editor.on('nodeChange', (e) => {
+        buttonApi.setActive(e);
+      });
+      return Fun.noop;
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/NonbreakingItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerNonbreakingItems = (): void => {
+  getDemoRegistry().addButton('nonbreaking', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/PagebreakItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerPageBreakItems = (): void => {
+  getDemoRegistry().addButton('pagebreak', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/PasteItems.ts
@@ -0,0 +1,19 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { }
+};
+export const registerPasteItems = (): void => {
+  getDemoRegistry().addToggleButton('pastetext', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      editor.on('PastePlainTextToggle', (e) => {
+        buttonApi.setActive(e.state);
+      });
+      return Fun.noop;
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/PreviewItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerPreviewItems = (): void => {
+  getDemoRegistry().addButton('preview', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/SaveItems.ts
@@ -0,0 +1,22 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  off: (_s, _f) => { },
+  isDirty: Fun.always
+};
+export const registerSaveItems = (): void => {
+  getDemoRegistry().addButton('save', {
+    type: 'button',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      const editorOffCallback = () => {
+        buttonApi.setEnabled(!editor.isDirty());
+      };
+      editor.on('nodeChange dirty', editorOffCallback);
+      return () => editor.off('nodeChange dirty', editorOffCallback);
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/SearchReplaceItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerSearchReplaceItems = (): void => {
+  getDemoRegistry().addButton('searchreplace', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/TODO_EmoticonItems.ts
@@ -0,0 +1,11 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerEmoticonItems = (): void => {
+  getDemoRegistry().addButton('emoticon', {
+    type: 'button',
+    enabled: true,
+    onSetup: (_buttonApi) => Fun.noop,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/TemplateItems.ts
@@ -0,0 +1,9 @@
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+export const registerTemplateItems = (): void => {
+  getDemoRegistry().addButton('template', {
+    type: 'button',
+    enabled: true,
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/TocItems.ts
@@ -0,0 +1,20 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  isDirty: Fun.always
+};
+export const registerTocItems = (): void => {
+  getDemoRegistry().addButton('toc', {
+    type: 'button',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      editor.on('LoadContent SetContent change', (e) => {
+        buttonApi.setEnabled(!e);
+      });
+      return Fun.noop;
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/VisualBlocksItems.ts
@@ -0,0 +1,20 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  isDirty: Fun.always
+};
+export const registerVisualBlocksItems = (): void => {
+  getDemoRegistry().addToggleButton('visualblocks', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      editor.on('VisualBlocks', (e) => {
+        buttonApi.setActive(e);
+      });
+      return Fun.noop;
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/demo/ts/plugins/VisualCharsItems.ts
@@ -0,0 +1,20 @@
+import { Fun } from '@ephox/katamari';
+import { getDemoRegistry } from '../buttons/DemoRegistry';
+const editor = {
+  on: (_s, _f) => { },
+  isDirty: Fun.always
+};
+export const registerVisualCharsItems = (): void => {
+  getDemoRegistry().addToggleButton('visualchars', {
+    type: 'togglebutton',
+    enabled: true,
+    onSetup: (buttonApi) => {
+      editor.on('VisualChars', (e) => {
+        buttonApi.setActive(e);
+      });
+      return Fun.noop;
+    },
+    onAction: (_buttonApi) => {
+    }
+  });
+};

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/api/Dialog.ts
@@ -0,0 +1,167 @@
+import { AlertBanner, AlertBannerSpec, createAlertBanner } from '../components/dialog/AlertBanner';
+import { Bar, BarSpec, createBarFields } from '../components/dialog/Bar';
+import { BodyComponent, BodyComponentSpec } from '../components/dialog/BodyComponent';
+import { Button, ButtonSpec, createButton } from '../components/dialog/Button';
+import { Checkbox, CheckboxSpec, createCheckbox } from '../components/dialog/Checkbox';
+import { Collection, collectionDataProcessor, CollectionItem, CollectionSpec, createCollection } from '../components/dialog/Collection';
+import { ColorInput, ColorInputSpec, createColorInput } from '../components/dialog/ColorInput';
+import { ColorPicker, ColorPickerSpec, createColorPicker } from '../components/dialog/ColorPicker';
+import {
+  createCustomEditor, CustomEditor, CustomEditorInit, CustomEditorInitFn, CustomEditorNew, CustomEditorOld, customEditorSchema, CustomEditorSpec
+} from '../components/dialog/CustomEditor';
+import {
+  createDialog, Dialog, DialogActionDetails, DialogActionHandler, DialogCancelHandler, DialogChangeDetails, DialogCloseHandler, DialogData,
+  DialogInstanceApi, DialogSize, DialogSpec, DialogSubmitHandler, DialogTabChangeDetails, DialogTabChangeHandler
+} from '../components/dialog/Dialog';
+import {
+  createDialogFooterButton, DialogFooterButton, DialogFooterButtonSpec, DialogFooterMenuButton, DialogFooterMenuButtonItemSpec,
+  DialogFooterMenuButtonSpec, DialogFooterNormalButton, DialogFooterNormalButtonSpec, DialogFooterToggleMenuItem
+} from '../components/dialog/DialogFooterButton';
+import { createDropZone, DropZone, DropZoneSpec } from '../components/dialog/Dropzone';
+import { createGridFields, Grid, GridSpec } from '../components/dialog/Grid';
+import { createHtmlPanel, HtmlPanel, HtmlPanelSpec } from '../components/dialog/HtmlPanel';
+import { createIframe, Iframe, IframeSpec } from '../components/dialog/Iframe';
+import { ImagePreview, ImagePreviewData, ImagePreviewSpec } from '../components/dialog/ImagePreview';
+import { createInput, Input, InputSpec } from '../components/dialog/Input';
+import { createLabelFields, Label, LabelSpec } from '../components/dialog/Label';
+import {
+  createListBox, ListBox, ListBoxItem, ListBoxItemSpec, ListBoxNestedItemSpec, ListBoxSingleItemSpec, ListBoxSpec
+} from '../components/dialog/ListBox';
+import { createPanel, Panel, PanelSpec } from '../components/dialog/Panel';
+import { createSelectBox, SelectBox, SelectBoxItem, SelectBoxItemSpec, SelectBoxSpec } from '../components/dialog/SelectBox';
+import { createSizeInput, SizeInput, SizeInputSpec } from '../components/dialog/SizeInput';
+import { Slider, SliderSpec } from '../components/dialog/Slider';
+import { createTable, Table, TableSpec } from '../components/dialog/Table';
+import { createTabPanel, Tab, TabPanel, TabPanelSpec, TabSpec } from '../components/dialog/TabPanel';
+import { createTextArea, TextArea, TextAreaSpec } from '../components/dialog/Textarea';
+import {
+  createUrlDialog, UrlDialog, UrlDialogActionDetails, UrlDialogActionHandler, UrlDialogCancelHandler, UrlDialogCloseHandler, UrlDialogFooterButton,
+  UrlDialogFooterButtonSpec, UrlDialogInstanceApi, UrlDialogMessage, UrlDialogMessageHandler, UrlDialogSpec
+} from '../components/dialog/UrlDialog';
+import { createUrlInput, UrlInput, UrlInputData, UrlInputSpec } from '../components/dialog/UrlInput';
+export {
+  AlertBanner,
+  AlertBannerSpec,
+  createAlertBanner,
+  Bar,
+  BarSpec,
+  createBarFields,
+  BodyComponent,
+  BodyComponentSpec,
+  Button,
+  ButtonSpec,
+  createButton,
+  Checkbox,
+  CheckboxSpec,
+  createCheckbox,
+  Collection,
+  CollectionItem,
+  CollectionSpec,
+  createCollection,
+  collectionDataProcessor,
+  ColorInput,
+  ColorInputSpec,
+  createColorInput,
+  ColorPicker,
+  ColorPickerSpec,
+  createColorPicker,
+  CustomEditor,
+  CustomEditorSpec,
+  CustomEditorOld,
+  CustomEditorNew,
+  CustomEditorInit,
+  CustomEditorInitFn,
+  createCustomEditor,
+  customEditorSchema,
+  Dialog,
+  DialogSpec,
+  DialogInstanceApi,
+  DialogActionDetails,
+  DialogActionHandler,
+  DialogChangeDetails,
+  DialogCancelHandler,
+  DialogCloseHandler,
+  DialogSubmitHandler,
+  DialogTabChangeDetails,
+  DialogTabChangeHandler,
+  DialogData,
+  DialogSize,
+  createDialog,
+  DialogFooterButton,
+  DialogFooterButtonSpec,
+  DialogFooterNormalButton,
+  DialogFooterNormalButtonSpec,
+  DialogFooterMenuButton,
+  DialogFooterMenuButtonSpec,
+  DialogFooterToggleMenuItem,
+  DialogFooterMenuButtonItemSpec,
+  createDialogFooterButton,
+  DropZone,
+  DropZoneSpec,
+  createDropZone,
+  Grid,
+  GridSpec,
+  createGridFields,
+  HtmlPanel,
+  HtmlPanelSpec,
+  createHtmlPanel,
+  Iframe,
+  IframeSpec,
+  createIframe,
+  ImagePreview,
+  ImagePreviewData,
+  ImagePreviewSpec,
+  Input,
+  InputSpec,
+  createInput,
+  Label,
+  LabelSpec,
+  createLabelFields,
+  ListBox,
+  ListBoxSpec,
+  ListBoxItem,
+  ListBoxItemSpec,
+  ListBoxNestedItemSpec,
+  ListBoxSingleItemSpec,
+  createListBox,
+  Panel,
+  PanelSpec,
+  createPanel,
+  SelectBox,
+  SelectBoxSpec,
+  SelectBoxItem,
+  SelectBoxItemSpec,
+  createSelectBox,
+  SizeInput,
+  SizeInputSpec,
+  createSizeInput,
+  Slider,
+  SliderSpec,
+  Table,
+  TableSpec,
+  createTable,
+  TabPanel,
+  TabPanelSpec,
+  Tab,
+  TabSpec,
+  createTabPanel,
+  TextArea,
+  TextAreaSpec,
+  createTextArea,
+  UrlDialog,
+  UrlDialogSpec,
+  UrlDialogInstanceApi,
+  UrlDialogFooterButton,
+  UrlDialogFooterButtonSpec,
+  UrlDialogActionDetails,
+  UrlDialogActionHandler,
+  UrlDialogCancelHandler,
+  UrlDialogCloseHandler,
+  UrlDialogMessage,
+  UrlDialogMessageHandler,
+  createUrlDialog,
+  UrlInput,
+  UrlInputData,
+  UrlInputSpec,
+  createUrlInput
+};

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/api/DialogManager.ts
@@ -0,0 +1,40 @@
+import { StructureProcessor, StructureSchema } from '@ephox/boulder';
+import { createDialog, Dialog, DialogData, DialogInstanceApi, DialogSpec } from '../components/dialog/Dialog';
+import { createUrlDialog, UrlDialog, UrlDialogInstanceApi, UrlDialogSpec } from '../components/dialog/UrlDialog';
+import { createDataValidator } from '../core/DialogData';
+interface DialogManager {
+  open: <T extends DialogData>(factory: DialogFactory<T>, structure: DialogSpec<T>) => DialogInstanceApi<T>;
+  openUrl: (factory: UrlDialogFactory, structure: UrlDialogSpec) => UrlDialogInstanceApi;
+  redial: <T extends DialogData>(structure: DialogSpec<T>) => DialogInit<T>;
+}
+export type DialogFactory<T extends DialogData> = (internalDialog: Dialog<T>, initialData: Partial<T>, dataValidator: StructureProcessor) => DialogInstanceApi<T>;
+export type UrlDialogFactory = (internalDialog: UrlDialog) => UrlDialogInstanceApi;
+export interface DialogInit<T extends DialogData> {
+  internalDialog: Dialog<T>;
+  initialData: Partial<T>;
+  dataValidator: StructureProcessor;
+}
+const extract = <T>(structure: DialogSpec<T>): DialogInit<T> => {
+  const internalDialog = StructureSchema.getOrDie(createDialog(structure));
+  const dataValidator = createDataValidator<T>(structure);
+  const initialData = structure.initialData;
+  return {
+    internalDialog,
+    dataValidator,
+    initialData
+  };
+};
+const DialogManager: DialogManager = {
+  open: <T extends DialogData>(factory: DialogFactory<T>, structure: DialogSpec<T>): DialogInstanceApi<T> => {
+    const extraction = extract(structure);
+    return factory(extraction.internalDialog, extraction.initialData, extraction.dataValidator);
+  },
+  openUrl: (factory: UrlDialogFactory, structure: UrlDialogSpec): UrlDialogInstanceApi => {
+    const internalDialog = StructureSchema.getOrDie(createUrlDialog(structure));
+    return factory(internalDialog);
+  },
+  redial: <T extends DialogData>(structure: DialogSpec<T>): DialogInit<T> => extract(structure)
+};
+export {
+  DialogManager
+};

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/api/PublicDialog.ts
@@ -0,0 +1,81 @@
+import { AlertBannerSpec } from '../components/dialog/AlertBanner';
+import { BarSpec } from '../components/dialog/Bar';
+import { BodyComponentSpec } from '../components/dialog/BodyComponent';
+import { ButtonSpec } from '../components/dialog/Button';
+import { CheckboxSpec } from '../components/dialog/Checkbox';
+import { CollectionItem, CollectionSpec } from '../components/dialog/Collection';
+import { ColorInputSpec } from '../components/dialog/ColorInput';
+import { ColorPickerSpec } from '../components/dialog/ColorPicker';
+import { CustomEditorInit, CustomEditorInitFn, CustomEditorSpec } from '../components/dialog/CustomEditor';
+import {
+  DialogActionDetails, DialogChangeDetails, DialogData, DialogInstanceApi, DialogSize, DialogSpec, DialogTabChangeDetails
+} from '../components/dialog/Dialog';
+import { DialogFooterButtonSpec } from '../components/dialog/DialogFooterButton';
+import { DropZoneSpec } from '../components/dialog/Dropzone';
+import { GridSpec } from '../components/dialog/Grid';
+import { HtmlPanelSpec } from '../components/dialog/HtmlPanel';
+import { IframeSpec } from '../components/dialog/Iframe';
+import { ImagePreviewSpec } from '../components/dialog/ImagePreview';
+import { InputSpec } from '../components/dialog/Input';
+import { LabelSpec } from '../components/dialog/Label';
+import { ListBoxItemSpec, ListBoxSpec, ListBoxSingleItemSpec, ListBoxNestedItemSpec } from '../components/dialog/ListBox';
+import { PanelSpec } from '../components/dialog/Panel';
+import { SelectBoxItemSpec, SelectBoxSpec } from '../components/dialog/SelectBox';
+import { SizeInputSpec } from '../components/dialog/SizeInput';
+import { SliderSpec } from '../components/dialog/Slider';
+import { TableSpec } from '../components/dialog/Table';
+import { TabPanelSpec, TabSpec } from '../components/dialog/TabPanel';
+import { TextAreaSpec } from '../components/dialog/Textarea';
+import {
+  UrlDialogActionDetails, UrlDialogFooterButtonSpec, UrlDialogInstanceApi, UrlDialogMessage, UrlDialogSpec
+} from '../components/dialog/UrlDialog';
+import { UrlInputData, UrlInputSpec } from '../components/dialog/UrlInput';
+export {
+  AlertBannerSpec,
+  BarSpec,
+  BodyComponentSpec,
+  ButtonSpec,
+  CheckboxSpec,
+  CollectionItem,
+  CollectionSpec,
+  ColorInputSpec,
+  ColorPickerSpec,
+  CustomEditorSpec,
+  CustomEditorInit,
+  CustomEditorInitFn,
+  DialogData,
+  DialogSize,
+  DialogSpec,
+  DialogInstanceApi,
+  DialogFooterButtonSpec,
+  DialogActionDetails,
+  DialogChangeDetails,
+  DialogTabChangeDetails,
+  DropZoneSpec,
+  GridSpec,
+  HtmlPanelSpec,
+  IframeSpec,
+  ImagePreviewSpec,
+  InputSpec,
+  LabelSpec,
+  ListBoxSpec,
+  ListBoxItemSpec,
+  ListBoxNestedItemSpec,
+  ListBoxSingleItemSpec,
+  PanelSpec,
+  SelectBoxSpec,
+  SelectBoxItemSpec,
+  SizeInputSpec,
+  SliderSpec,
+  TableSpec,
+  TabSpec,
+  TabPanelSpec,
+  TextAreaSpec,
+  UrlInputData,
+  UrlInputSpec,
+  UrlDialogSpec,
+  UrlDialogFooterButtonSpec,
+  UrlDialogInstanceApi,
+  UrlDialogActionDetails,
+  UrlDialogMessage
+};

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/content/Autocompleter.ts
@@ -0,0 +1,77 @@
+import { FieldSchema, StructureSchema, ValueType } from '@ephox/boulder';
+import { Optional, Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+import { CardMenuItemSpec } from '../menu/CardMenuItem';
+import { SeparatorMenuItem, separatorMenuItemSchema, SeparatorMenuItemSpec } from '../menu/SeparatorMenuItem';
+export type ColumnTypes = number | 'auto';
+export type SeparatorItemSpec = SeparatorMenuItemSpec;
+export interface AutocompleterItemSpec {
+  type?: 'autocompleteitem';
+  value: string;
+  text?: string;
+  icon?: string;
+  meta?: Record<string, any>;
+}
+export type AutocompleterContents = SeparatorItemSpec | AutocompleterItemSpec | CardMenuItemSpec;
+export type SeparatorItem = SeparatorMenuItem;
+export interface AutocompleterItem {
+  type: 'autocompleteitem';
+  value: string;
+  text: Optional<string>;
+  icon: Optional<string>;
+  active: boolean;
+  enabled: boolean;
+  meta: Record<string, any>;
+}
+export interface AutocompleterSpec {
+  type?: 'autocompleter';
+  ch: string;
+  minChars?: number;
+  columns?: ColumnTypes;
+  matches?: (rng: Range, text: string, pattern: string) => boolean;
+  fetch: (pattern: string, maxResults: number, fetchOptions: Record<string, any>) => Promise<AutocompleterContents[]>;
+  onAction: (autocompleterApi: AutocompleterInstanceApi, rng: Range, value: string, meta: Record<string, any>) => void;
+  maxResults?: number;
+  highlightOn?: string[];
+}
+export interface AutocompleterInstanceApi {
+  hide: () => void;
+  reload: (fetchOptions: Record<string, any>) => void;
+}
+export interface Autocompleter {
+  type: 'autocompleter';
+  ch: string;
+  minChars: number;
+  columns: ColumnTypes;
+  matches: Optional<(rng: Range, text: string, pattern: string) => boolean>;
+  fetch: (pattern: string, maxResults: number, fetchOptions: Record<string, any>) => Promise<AutocompleterContents[]>;
+  onAction: (autocompleterApi: AutocompleterInstanceApi, rng: Range, value: string, meta: Record<string, any>) => void;
+  maxResults: number;
+  highlightOn: string[];
+}
+const autocompleterItemSchema = StructureSchema.objOf([
+  ComponentSchema.defaultedType('autocompleteitem'),
+  ComponentSchema.active,
+  ComponentSchema.enabled,
+  ComponentSchema.defaultedMeta,
+  ComponentSchema.value,
+  ComponentSchema.optionalText,
+  ComponentSchema.optionalIcon
+]);
+const autocompleterSchema = StructureSchema.objOf([
+  ComponentSchema.type,
+  FieldSchema.requiredString('ch'),
+  FieldSchema.defaultedNumber('minChars', 1),
+  ComponentSchema.defaultedColumns(1),
+  FieldSchema.defaultedNumber('maxResults', 10),
+  FieldSchema.optionFunction('matches'),
+  ComponentSchema.fetch,
+  ComponentSchema.onAction,
+  FieldSchema.defaultedArrayOf('highlightOn', [], ValueType.string)
+]);
+export const createSeparatorItem = (spec: SeparatorItemSpec): Result<SeparatorItem, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw('Autocompleter.Separator', separatorMenuItemSchema, spec);
+export const createAutocompleterItem = (spec: AutocompleterItemSpec): Result<AutocompleterItem, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<AutocompleterItem>('Autocompleter.Item', autocompleterItemSchema, spec);
+export const createAutocompleter = (spec: AutocompleterSpec): Result<Autocompleter, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<Autocompleter>('Autocompleter', autocompleterSchema, spec);

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/content/ContextForm.ts
@@ -0,0 +1,98 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Fun, Optional, Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+import { BaseToolbarButton, baseToolbarButtonFields, BaseToolbarButtonInstanceApi, BaseToolbarButtonSpec } from '../toolbar/ToolbarButton';
+import {
+  BaseToolbarToggleButton, baseToolbarToggleButtonFields, BaseToolbarToggleButtonInstanceApi, BaseToolbarToggleButtonSpec
+} from '../toolbar/ToolbarToggleButton';
+import { ContextBar, contextBarFields, ContextBarSpec } from './ContextBar';
+export interface ContextFormLaunchButtonApi extends BaseToolbarButtonSpec<BaseToolbarButtonInstanceApi> {
+  type: 'contextformbutton';
+}
+export interface ContextFormLaunchButton extends BaseToolbarButton<BaseToolbarButtonInstanceApi> {
+  type: 'contextformbutton';
+}
+export interface ContextFormLaunchToggleButtonSpec extends BaseToolbarToggleButtonSpec<BaseToolbarToggleButtonInstanceApi> {
+  type: 'contextformtogglebutton';
+}
+export interface ContextFormLaunchToggleButton extends BaseToolbarToggleButton<BaseToolbarToggleButtonInstanceApi> {
+  type: 'contextformtogglebutton';
+}
+export interface ContextFormButtonInstanceApi extends BaseToolbarButtonInstanceApi {
+}
+export interface ContextFormToggleButtonInstanceApi extends BaseToolbarToggleButtonInstanceApi {
+}
+export interface ContextFormButtonSpec extends BaseToolbarButtonSpec<ContextFormButtonInstanceApi> {
+  type?: 'contextformbutton';
+  primary?: boolean;
+  onAction: (formApi: ContextFormInstanceApi, api: ContextFormButtonInstanceApi) => void;
+}
+export interface ContextFormToggleButtonSpec extends BaseToolbarToggleButtonSpec<ContextFormToggleButtonInstanceApi> {
+  type?: 'contextformtogglebutton';
+  onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormToggleButtonInstanceApi) => void;
+  primary?: boolean;
+}
+export interface ContextFormButton extends BaseToolbarButton<ContextFormButtonInstanceApi> {
+  type?: 'contextformbutton';
+  primary?: boolean;
+  onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormButtonInstanceApi) => void;
+  original: ContextFormButtonSpec;
+}
+export interface ContextFormToggleButton extends BaseToolbarToggleButton<ContextFormToggleButtonInstanceApi> {
+  type?: 'contextformtogglebutton';
+  primary?: boolean;
+  onAction: (formApi: ContextFormInstanceApi, buttonApi: ContextFormToggleButtonInstanceApi) => void;
+  original: ContextFormToggleButtonSpec;
+}
+export interface ContextFormInstanceApi {
+  hide: () => void;
+  getValue: () => string; // Maybe we need to support other data types?
+}
+export interface ContextFormSpec extends ContextBarSpec {
+  type?: 'contextform';
+  initValue?: () => string;
+  label?: string;
+  launch?: ContextFormLaunchButtonApi | ContextFormLaunchToggleButtonSpec;
+  commands: Array<ContextFormToggleButtonSpec | ContextFormButtonSpec>;
+}
+export interface ContextForm extends ContextBar {
+  type: 'contextform';
+  initValue: () => string;
+  label: Optional<string>;
+  launch: Optional<ContextFormLaunchButton | ContextFormLaunchToggleButton>;
+  commands: Array<ContextFormToggleButton | ContextFormButton>;
+}
+const contextButtonFields = baseToolbarButtonFields.concat([
+  ComponentSchema.defaultedType('contextformbutton'),
+  ComponentSchema.primary,
+  ComponentSchema.onAction,
+  FieldSchema.customField('original', Fun.identity)
+]);
+const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([
+  ComponentSchema.defaultedType('contextformbutton'),
+  ComponentSchema.primary,
+  ComponentSchema.onAction,
+  FieldSchema.customField('original', Fun.identity)
+]);
+const launchButtonFields = baseToolbarButtonFields.concat([
+  ComponentSchema.defaultedType('contextformbutton')
+]);
+const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([
+  ComponentSchema.defaultedType('contextformtogglebutton')
+]);
+const toggleOrNormal = StructureSchema.choose('type', {
+  contextformbutton: contextButtonFields,
+  contextformtogglebutton: contextToggleButtonFields
+});
+const contextFormSchema = StructureSchema.objOf([
+  ComponentSchema.defaultedType('contextform'),
+  FieldSchema.defaultedFunction('initValue', Fun.constant('')),
+  ComponentSchema.optionalLabel,
+  FieldSchema.requiredArrayOf('commands', toggleOrNormal),
+  FieldSchema.optionOf('launch', StructureSchema.choose('type', {
+    contextformbutton: launchButtonFields,
+    contextformtogglebutton: launchToggleButtonFields
+  }))
+].concat(contextBarFields));
+export const createContextForm = (spec: ContextFormSpec): Result<ContextForm, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<ContextForm>('ContextForm', contextFormSchema, spec);

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/content/ContextToolbar.ts
@@ -0,0 +1,18 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+import { ContextBar, contextBarFields, ContextBarSpec } from './ContextBar';
+export interface ContextToolbarSpec extends ContextBarSpec {
+  type?: 'contexttoolbar';
+  items: string;
+}
+export interface ContextToolbar extends ContextBar {
+  type: 'contexttoolbar';
+  items: string;
+}
+const contextToolbarSchema = StructureSchema.objOf([
+  ComponentSchema.defaultedType('contexttoolbar'),
+  FieldSchema.requiredString('items')
+].concat(contextBarFields));
+export const createContextToolbar = (spec: ContextToolbarSpec): Result<ContextToolbar, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<ContextToolbar>('ContextToolbar', contextToolbarSchema, spec);

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/dialog/AlertBanner.ts
@@ -0,0 +1,27 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+export interface AlertBannerSpec {
+  type: 'alertbanner';
+  level: 'info' | 'warn' | 'error' | 'success';
+  text: string;
+  icon: string;
+  url?: string;
+}
+export interface AlertBanner {
+  type: 'alertbanner';
+  level: 'info' | 'warn' | 'error' | 'success';
+  text: string;
+  icon: string;
+  url: string;
+}
+const alertBannerFields = [
+  ComponentSchema.type,
+  ComponentSchema.text,
+  FieldSchema.requiredStringEnum('level', [ 'info', 'warn', 'error', 'success' ]),
+  ComponentSchema.icon,
+  FieldSchema.defaulted('url', '')
+];
+export const alertBannerSchema = StructureSchema.objOf(alertBannerFields);
+export const createAlertBanner = (spec: AlertBannerSpec): Result<AlertBanner, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<AlertBanner>('alertbanner', alertBannerSchema, spec);

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/dialog/Bar.ts
@@ -0,0 +1,15 @@
+import { FieldProcessor } from '@ephox/boulder';
+import * as ComponentSchema from '../../core/ComponentSchema';
+import { BodyComponent, BodyComponentSpec } from './BodyComponent';
+export interface BarSpec {
+  type: 'bar';
+  items: BodyComponentSpec[];
+}
+export interface Bar {
+  type: 'bar';
+  items: BodyComponent[];
+}
+export const createBarFields = (itemsField: FieldProcessor): FieldProcessor[] => [
+  ComponentSchema.type,
+  itemsField
+];

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/dialog/BodyComponent.ts
@@ -0,0 +1,71 @@
+import { AlertBanner, AlertBannerSpec } from './AlertBanner';
+import { Bar, BarSpec } from './Bar';
+import { Button, ButtonSpec } from './Button';
+import { Checkbox, CheckboxSpec } from './Checkbox';
+import { Collection, CollectionSpec } from './Collection';
+import { ColorInput, ColorInputSpec } from './ColorInput';
+import { ColorPicker, ColorPickerSpec } from './ColorPicker';
+import { CustomEditor, CustomEditorSpec } from './CustomEditor';
+import { DropZone, DropZoneSpec } from './Dropzone';
+import { Grid, GridSpec } from './Grid';
+import { HtmlPanel, HtmlPanelSpec } from './HtmlPanel';
+import { Iframe, IframeSpec } from './Iframe';
+import { ImagePreview, ImagePreviewSpec } from './ImagePreview';
+import { Input, InputSpec } from './Input';
+import { Label, LabelSpec } from './Label';
+import { ListBox, ListBoxSpec } from './ListBox';
+import { Panel, PanelSpec } from './Panel';
+import { SelectBox, SelectBoxSpec } from './SelectBox';
+import { SizeInput, SizeInputSpec } from './SizeInput';
+import { Slider, SliderSpec } from './Slider';
+import { Table, TableSpec } from './Table';
+import { TextArea, TextAreaSpec } from './Textarea';
+import { UrlInput, UrlInputSpec } from './UrlInput';
+export type BodyComponentSpec
+  = BarSpec
+  | ButtonSpec
+  | CheckboxSpec
+  | TextAreaSpec
+  | InputSpec
+  | ListBoxSpec
+  | SelectBoxSpec
+  | SizeInputSpec
+  | SliderSpec
+  | IframeSpec
+  | HtmlPanelSpec
+  | UrlInputSpec
+  | DropZoneSpec
+  | ColorInputSpec
+  | GridSpec
+  | ColorPickerSpec
+  | ImagePreviewSpec
+  | AlertBannerSpec
+  | CollectionSpec
+  | LabelSpec
+  | TableSpec
+  | PanelSpec
+  | CustomEditorSpec;
+export type BodyComponent
+  = Bar
+  | Button
+  | Checkbox
+  | TextArea
+  | Input
+  | ListBox
+  | SelectBox
+  | SizeInput
+  | Slider
+  | Iframe
+  | HtmlPanel
+  | UrlInput
+  | DropZone
+  | ColorInput
+  | Grid
+  | ColorPicker
+  | ImagePreview
+  | AlertBanner
+  | Collection
+  | Label
+  | Table
+  | Panel
+  | CustomEditor;

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/dialog/Button.ts
@@ -0,0 +1,38 @@
+import { FieldSchema, StructureSchema } from '@ephox/boulder';
+import { Optional, Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+export interface ButtonSpec {
+  type: 'button';
+  text: string;
+  enabled?: boolean;
+  /** @deprecated use `buttonType: "primary"` instead */
+  primary?: boolean;
+  name?: string;
+  icon?: string;
+  borderless?: boolean;
+  buttonType?: 'primary' | 'secondary' | 'toolbar';
+}
+export interface Button {
+  type: 'button';
+  text: string;
+  enabled: boolean;
+  /** @deprecated use `buttonType: "primary"` instead */
+  primary: boolean;
+  name: string;
+  icon: Optional<string>;
+  borderless: boolean;
+  buttonType: Optional<'primary' | 'secondary' | 'toolbar'>;
+}
+const buttonFields = [
+  ComponentSchema.type,
+  ComponentSchema.text,
+  ComponentSchema.enabled,
+  ComponentSchema.generatedName('button'),
+  ComponentSchema.optionalIcon,
+  ComponentSchema.borderless,
+  FieldSchema.optionStringEnum('buttonType', [ 'primary', 'secondary', 'toolbar' ]),
+  ComponentSchema.primary,
+];
+export const buttonSchema = StructureSchema.objOf(buttonFields);
+export const createButton = (spec: ButtonSpec): Result<Button, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<Button>('button', buttonSchema, spec);

--- a//dev/null
+++ b/modules/bridge/src/main/ts/ephox/bridge/components/dialog/Checkbox.ts
@@ -0,0 +1,22 @@
+import { StructureSchema, ValueType } from '@ephox/boulder';
+import { Result } from '@ephox/katamari';
+import * as ComponentSchema from '../../core/ComponentSchema';
+import { FormComponent, formComponentFields, FormComponentSpec } from './FormComponent';
+export interface CheckboxSpec extends FormComponentSpec {
+  type: 'checkbox';
+  label: string;
+  enabled?: boolean;
+}
+export interface Checkbox extends FormComponent {
+  type: 'checkbox';
+  label: string;
+  enabled: boolean;
+}
+const checkboxFields = formComponentFields.concat([
+  ComponentSchema.label,
+  ComponentSchema.enabled
+]);
+export const checkboxSchema = StructureSchema.objOf(checkboxFields);
+export const checkboxDataProcessor = ValueType.boolean;
+export const createCheckbox = (spec: CheckboxSpec): Result<Checkbox, StructureSchema.SchemaError<any>> =>
+  StructureSchema.asRaw<Checkbox>('checkbox', checkboxSchema, spec);

--- a/modules/tinymce/src/core/main/ts/content/GetContentImpl.ts
+++ b//dev/null
@@ -1,54 +0,0 @@
-import { Fun, Optional, Type } from '@ephox/katamari';
-import { Attribute, Css, Html, Insert, Remove, SugarElement, SugarShadowDom } from '@ephox/sugar';
-import Editor from '../api/Editor';
-import AstNode from '../api/html/Node';
-import * as Options from '../api/Options';
-import Tools from '../api/util/Tools';
-import * as ElementType from '../dom/ElementType';
-import * as TrimBody from '../dom/TrimBody';
-import * as Zwsp from '../text/Zwsp';
-import { cleanupBogusElements, cleanupInputNames } from './ContentCleanup';
-import { Content, GetContentArgs } from './ContentTypes';
-const trimEmptyContents = (editor: Editor, html: string): string => {
-  const blockName = Options.getForcedRootBlock(editor);
-  const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\s|\u00a0|<br \\/>|)<\\/${blockName}>[\r\n]*|<br \\/>[\r\n]*)$`);
-  return html.replace(emptyRegExp, '');
-};
-const getPlainTextContent = (editor: Editor, body: HTMLElement) => {
-  const doc = editor.getDoc();
-  const dos = SugarShadowDom.getRootNode(SugarElement.fromDom(editor.getBody()));
-  const offscreenDiv = SugarElement.fromTag('div', doc);
-  Attribute.set(offscreenDiv, 'data-mce-bogus', 'all');
-  Css.setAll(offscreenDiv, {
-    position: 'fixed',
-    left: '-9999999px',
-    top: '0'
-  });
-  Html.set(offscreenDiv, body.innerHTML);
-  cleanupBogusElements(offscreenDiv);
-  cleanupInputNames(offscreenDiv);
-  const root = SugarShadowDom.getContentContainer(dos);
-  Insert.append(root, offscreenDiv);
-  const content = Zwsp.trim(offscreenDiv.dom.innerText);
-  Remove.remove(offscreenDiv);
-  return content;
-};
-const getContentFromBody = (editor: Editor, args: GetContentArgs, body: HTMLElement): Content => {
-  let content: Content;
-  if (args.format === 'raw') {
-    content = Tools.trim(Zwsp.trim(TrimBody.trim(body, editor.serializer.getTempAttrs()).innerHTML));
-  } else if (args.format === 'text') {
-    content = getPlainTextContent(editor, body);
-  } else if (args.format === 'tree') {
-    content = editor.serializer.serialize(body, args);
-  } else {
-    content = trimEmptyContents(editor, editor.serializer.serialize(body, args));
-  }
-  const shouldTrim = args.format !== 'text' && !ElementType.isWsPreserveElement(SugarElement.fromDom(body));
-  return shouldTrim && Type.isString(content) ? Tools.trim(content) : content;
-};
-export const getContentInternal = (editor: Editor, args: GetContentArgs): Content => Optional.from(editor.getBody())
-  .fold(
-    Fun.constant(args.format === 'tree' ? new AstNode('body', 11) : ''),
-    (body) => getContentFromBody(editor, args, body)
-  );

--- a/modules/tinymce/src/core/main/ts/dom/TrimBody.ts
+++ b//dev/null
@@ -1,60 +0,0 @@
-import { Arr, Type } from '@ephox/katamari';
-import { Attribute, Remove, SugarElement } from '@ephox/sugar';
-import * as Zwsp from '../text/Zwsp';
-const getTemporaryNodeSelector = (tempAttrs: string[]): string =>
-  `${tempAttrs.length === 0 ? '' : `${Arr.map(tempAttrs, (attr) => `[${attr}]`).join(',')},`}[data-mce-bogus="all"]`;
-const getTemporaryNodes = (body: HTMLElement, tempAttrs: string[]): NodeListOf<Element> =>
-  body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));
-const createCommentWalker = (body: HTMLElement): TreeWalker =>
-  document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, null);
-const hasComments = (body: HTMLElement): boolean =>
-  createCommentWalker(body).nextNode() !== null;
-const hasTemporaryNodes = (body: HTMLElement, tempAttrs: string[]): boolean =>
-  body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;
-const trimTemporaryNodes = (body: HTMLElement, tempAttrs: string[]): void => {
-  Arr.each(getTemporaryNodes(body, tempAttrs), (elm) => {
-    const element = SugarElement.fromDom(elm);
-    if (Attribute.get(element, 'data-mce-bogus') === 'all') {
-      Remove.remove(element);
-    } else {
-      Arr.each(tempAttrs, (attr) => {
-        if (Attribute.has(element, attr)) {
-          Attribute.remove(element, attr);
-        }
-      });
-    }
-  });
-};
-const removeCommentsContainingZwsp = (body: HTMLElement): void => {
-  const walker = createCommentWalker(body);
-  let nextNode = walker.nextNode();
-  while (nextNode !== null) {
-    const comment = walker.currentNode as Comment;
-    nextNode = walker.nextNode();
-    if (Type.isString(comment.nodeValue) && comment.nodeValue.includes(Zwsp.ZWSP)) {
-      Remove.remove(SugarElement.fromDom(comment));
-    }
-  }
-};
-const deepClone = (body: HTMLElement): HTMLElement => body.cloneNode(true) as HTMLElement;
-const trim = (body: HTMLElement, tempAttrs: string[]): HTMLElement => {
-  let trimmed = body;
-  if (hasComments(body)) {
-    trimmed = deepClone(body);
-    removeCommentsContainingZwsp(trimmed);
-    if (hasTemporaryNodes(trimmed, tempAttrs)) {
-      trimTemporaryNodes(trimmed, tempAttrs);
-    }
-  } else if (hasTemporaryNodes(body, tempAttrs)) {
-    trimmed = deepClone(body);
-    trimTemporaryNodes(trimmed, tempAttrs);
-  }
-  return trimmed;
-};
-export {
-  trim,
-  hasComments,
-  hasTemporaryNodes,
-  removeCommentsContainingZwsp,
-  trimTemporaryNodes
-};

--- a/modules/tinymce/src/core/main/ts/undo/Fragments.ts
+++ b//dev/null
@@ -1,74 +0,0 @@
-import { Arr, Fun } from '@ephox/katamari';
-import Entities from '../api/html/Entities';
-import * as NodeType from '../dom/NodeType';
-import * as Zwsp from '../text/Zwsp';
-import * as Diff from './Diff';
-/**
- * This module reads and applies html fragments from/to dom nodes.
- *
- * @class tinymce.undo.Fragments
- * @private
- */
-const getOuterHtml = (elm: Node): string => {
-  if (NodeType.isElement(elm)) {
-    return elm.outerHTML;
-  } else if (NodeType.isText(elm)) {
-    return Entities.encodeRaw(elm.data, false);
-  } else if (NodeType.isComment(elm)) {
-    return '<!--' + elm.data + '-->';
-  }
-  return '';
-};
-const createFragment = (html: string): DocumentFragment => {
-  let node;
-  const container = document.createElement('div');
-  const frag = document.createDocumentFragment();
-  if (html) {
-    container.innerHTML = html;
-  }
-  while ((node = container.firstChild)) {
-    frag.appendChild(node);
-  }
-  return frag;
-};
-const insertAt = (elm: Element, html: string, index: number) => {
-  const fragment = createFragment(html);
-  if (elm.hasChildNodes() && index < elm.childNodes.length) {
-    const target = elm.childNodes[index];
-    elm.insertBefore(fragment, target);
-  } else {
-    elm.appendChild(fragment);
-  }
-};
-const removeAt = (elm: Element, index: number) => {
-  if (elm.hasChildNodes() && index < elm.childNodes.length) {
-    const target = elm.childNodes[index];
-    elm.removeChild(target);
-  }
-};
-const applyDiff = (diff: Diff.Diff<string>[], elm: Element) => {
-  let index = 0;
-  Arr.each(diff, (action) => {
-    if (action[0] === Diff.KEEP) {
-      index++;
-    } else if (action[0] === Diff.INSERT) {
-      insertAt(elm, action[1], index);
-      index++;
-    } else if (action[0] === Diff.DELETE) {
-      removeAt(elm, index);
-    }
-  });
-};
-const read = (elm: Element, trimZwsp?: boolean): string[] =>
-  Arr.filter(Arr.map(Arr.from(elm.childNodes), trimZwsp ? Fun.compose(Zwsp.trim, getOuterHtml) : getOuterHtml), (item) => {
-    return item.length > 0;
-  });
-const write = (fragments: string[], elm: Element): Element => {
-  const currentFragments = Arr.map(Arr.from(elm.childNodes), getOuterHtml);
-  applyDiff(Diff.diff(currentFragments, fragments), elm);
-  return elm;
-};
-export {
-  read,
-  write
-};

--- a/modules/tinymce/src/core/main/ts/undo/Levels.ts
+++ b//dev/null
@@ -1,77 +0,0 @@
-import { Arr, Thunk, Type } from '@ephox/katamari';
-import { Html, Remove, SelectorFilter, SugarElement } from '@ephox/sugar';
-import Editor from '../api/Editor';
-import { isPathBookmark } from '../bookmark/BookmarkTypes';
-import * as TrimBody from '../dom/TrimBody';
-import * as Zwsp from '../text/Zwsp';
-import * as Fragments from './Fragments';
-import { CompleteUndoLevel, FragmentedUndoLevel, NewUndoLevel, UndoLevel } from './UndoManagerTypes';
-const lazyTempDocument = Thunk.cached(() => document.implementation.createHTMLDocument('undo'));
-const hasIframes = (body: HTMLElement) => body.querySelector('iframe') !== null;
-const createFragmentedLevel = (fragments: string[]): FragmentedUndoLevel => {
-  return {
-    type: 'fragmented',
-    fragments,
-    content: '',
-    bookmark: null,
-    beforeBookmark: null
-  };
-};
-const createCompleteLevel = (content: string): CompleteUndoLevel => {
-  return {
-    type: 'complete',
-    fragments: null,
-    content,
-    bookmark: null,
-    beforeBookmark: null
-  };
-};
-const createFromEditor = (editor: Editor): NewUndoLevel => {
-  const tempAttrs = editor.serializer.getTempAttrs();
-  const body = TrimBody.trim(editor.getBody(), tempAttrs);
-  return hasIframes(body) ? createFragmentedLevel(Fragments.read(body, true)) : createCompleteLevel(Zwsp.trim(body.innerHTML));
-};
-const applyToEditor = (editor: Editor, level: UndoLevel, before: boolean): void => {
-  const bookmark = before ? level.beforeBookmark : level.bookmark;
-  if (level.type === 'fragmented') {
-    Fragments.write(level.fragments, editor.getBody());
-  } else {
-    editor.setContent(level.content, {
-      format: 'raw',
-      no_selection: Type.isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true
-    });
-  }
-  if (bookmark) {
-    editor.selection.moveToBookmark(bookmark);
-    editor.selection.scrollIntoView();
-  }
-};
-const getLevelContent = (level: NewUndoLevel): string => {
-  return level.type === 'fragmented' ? level.fragments.join('') : level.content;
-};
-const getCleanLevelContent = (level: NewUndoLevel): string => {
-  const elm = SugarElement.fromTag('body', lazyTempDocument());
-  Html.set(elm, getLevelContent(level));
-  Arr.each(SelectorFilter.descendants(elm, '*[data-mce-bogus]'), Remove.unwrap);
-  return Html.get(elm);
-};
-const hasEqualContent = (level1: NewUndoLevel, level2: NewUndoLevel): boolean =>
-  getLevelContent(level1) === getLevelContent(level2);
-const hasEqualCleanedContent = (level1: NewUndoLevel, level2: NewUndoLevel): boolean =>
-  getCleanLevelContent(level1) === getCleanLevelContent(level2);
-const isEq = (level1: NewUndoLevel | undefined, level2: NewUndoLevel | undefined): boolean => {
-  if (!level1 || !level2) {
-    return false;
-  } else if (hasEqualContent(level1, level2)) {
-    return true;
-  } else {
-    return hasEqualCleanedContent(level1, level2);
-  }
-};
-export {
-  createFragmentedLevel,
-  createCompleteLevel,
-  createFromEditor,
-  applyToEditor,
-  isEq
-};

--- a/modules/tinymce/src/themes/silver/main/ts/ui/general/Notification.ts
+++ b//dev/null
@@ -1,201 +0,0 @@
-import {
-  AddEventsBehaviour, AlloyComponent, AlloyEvents, AlloySpec, Behaviour, Button, DomFactory, Focusing, GuiFactory, Memento, NativeEvents, Replacing, Sketcher,
-  UiSketcher
-} from '@ephox/alloy';
-import { FieldSchema } from '@ephox/boulder';
-import { Arr, Optional } from '@ephox/katamari';
-import { TranslatedString, Untranslated } from 'tinymce/core/api/util/I18n';
-import * as HtmlSanitizer from '../core/HtmlSanitizer';
-import * as Icons from '../icons/Icons';
-export interface NotificationSketchApis {
-  updateProgress: (comp: AlloyComponent, percent: number) => void;
-  updateText: (comp: AlloyComponent, text: string) => void;
-}
-export interface NotificationSketchSpec extends Sketcher.SingleSketchSpec {
-  readonly text: string;
-  readonly level?: 'info' | 'warn' | 'warning' | 'error' | 'success';
-  readonly icon?: string;
-  readonly closeButton?: boolean;
-  readonly progress: boolean;
-  readonly onAction: Function;
-  readonly iconProvider: Icons.IconProvider;
-  readonly translationProvider: (text: Untranslated) => TranslatedString;
-}
-export interface NotificationSketchDetail extends Sketcher.SingleSketchDetail {
-  readonly text: string;
-  readonly level: Optional<'info' | 'warn' | 'warning' | 'error' | 'success'>;
-  readonly icon: Optional<string>;
-  readonly closeButton: boolean;
-  readonly onAction: Function;
-  readonly progress: boolean;
-  readonly iconProvider: Icons.IconProvider;
-  readonly translationProvider: (text: Untranslated) => TranslatedString;
-}
-export interface NotificationSketcher extends Sketcher.SingleSketch<NotificationSketchSpec>, NotificationSketchApis {
-}
-const notificationIconMap = {
-  success: 'checkmark',
-  error: 'warning',
-  err: 'error',
-  warning: 'warning',
-  warn: 'warning',
-  info: 'info'
-};
-const factory: UiSketcher.SingleSketchFactory<NotificationSketchDetail, NotificationSketchSpec> = (detail) => {
-  const memBannerText = Memento.record({
-    dom: DomFactory.fromHtml(`<p>${HtmlSanitizer.sanitizeHtmlString(detail.translationProvider(detail.text))}</p>`),
-    behaviours: Behaviour.derive([
-      Replacing.config({ })
-    ])
-  });
-  const renderPercentBar = (percent: number) => ({
-    dom: {
-      tag: 'div',
-      classes: [ 'tox-bar' ],
-      styles: {
-        width: `${percent}%`
-      }
-    }
-  });
-  const renderPercentText = (percent: number) => ({
-    dom: {
-      tag: 'div',
-      classes: [ 'tox-text' ],
-      innerHtml: `${percent}%`
-    }
-  });
-  const memBannerProgress = Memento.record({
-    dom: {
-      tag: 'div',
-      classes: detail.progress ? [ 'tox-progress-bar', 'tox-progress-indicator' ] : [ 'tox-progress-bar' ]
-    },
-    components: [
-      {
-        dom: {
-          tag: 'div',
-          classes: [ 'tox-bar-container' ]
-        },
-        components: [
-          renderPercentBar(0)
-        ]
-      },
-      renderPercentText(0)
-    ],
-    behaviours: Behaviour.derive([
-      Replacing.config({ })
-    ])
-  });
-  const updateProgress: NotificationSketchApis['updateProgress'] = (comp, percent) => {
-    if (comp.getSystem().isConnected()) {
-      memBannerProgress.getOpt(comp).each((progress) => {
-        Replacing.set(progress, [
-          {
-            dom: {
-              tag: 'div',
-              classes: [ 'tox-bar-container' ]
-            },
-            components: [
-              renderPercentBar(percent)
-            ]
-          },
-          renderPercentText(percent)
-        ]);
-      });
-    }
-  };
-  const updateText: NotificationSketchApis['updateText'] = (comp, text) => {
-    if (comp.getSystem().isConnected()) {
-      const banner = memBannerText.get(comp);
-      Replacing.set(banner, [
-        GuiFactory.text(text)
-      ]);
-    }
-  };
-  const apis: NotificationSketchApis = {
-    updateProgress,
-    updateText
-  };
-  const iconChoices = Arr.flatten([
-    detail.icon.toArray(),
-    detail.level.toArray(),
-    detail.level.bind((level) => Optional.from(notificationIconMap[level])).toArray()
-  ]);
-  const memButton = Memento.record(Button.sketch({
-    dom: {
-      tag: 'button',
-      classes: [ 'tox-notification__dismiss', 'tox-button', 'tox-button--naked', 'tox-button--icon' ]
-    },
-    components: [
-      Icons.render('close', {
-        tag: 'span',
-        classes: [ 'tox-icon' ],
-        attributes: {
-          'aria-label': detail.translationProvider('Close')
-        }
-      }, detail.iconProvider)
-    ],
-    action: (comp) => {
-      detail.onAction(comp);
-    }
-  }));
-  const notificationIconSpec = Icons.renderFirst(iconChoices, { tag: 'div', classes: [ 'tox-notification__icon' ] }, detail.iconProvider);
-  const notificationBodySpec = {
-    dom: {
-      tag: 'div',
-      classes: [ 'tox-notification__body' ]
-    },
-    components: [
-      memBannerText.asSpec()
-    ],
-    behaviours: Behaviour.derive([
-      Replacing.config({ })
-    ])
-  };
-  const components: AlloySpec[] = [ notificationIconSpec, notificationBodySpec ];
-  return {
-    uid: detail.uid,
-    dom: {
-      tag: 'div',
-      attributes: {
-        role: 'alert'
-      },
-      classes: detail.level.map((level) => [ 'tox-notification', 'tox-notification--in', `tox-notification--${level}` ]).getOr(
-        [ 'tox-notification', 'tox-notification--in' ]
-      )
-    },
-    behaviours: Behaviour.derive([
-      Focusing.config({ }),
-      AddEventsBehaviour.config('notification-events', [
-        AlloyEvents.run(NativeEvents.focusin(), (comp) => {
-          memButton.getOpt(comp).each(Focusing.focus);
-        })
-      ])
-    ]),
-    components: components
-      .concat(detail.progress ? [ memBannerProgress.asSpec() ] : [])
-      .concat(!detail.closeButton ? [] : [ memButton.asSpec() ]),
-    apis
-  };
-};
-export const Notification: NotificationSketcher = Sketcher.single({
-  name: 'Notification',
-  factory,
-  configFields: [
-    FieldSchema.option('level'),
-    FieldSchema.required('progress'),
-    FieldSchema.option('icon'),
-    FieldSchema.required('onAction'),
-    FieldSchema.required('text'),
-    FieldSchema.required('iconProvider'),
-    FieldSchema.required('translationProvider'),
-    FieldSchema.defaultedBoolean('closeButton', true)
-  ],
-  apis: {
-    updateProgress: (apis: NotificationSketchApis, comp: AlloyComponent, percent: number) => {
-      apis.updateProgress(comp, percent);
-    },
-    updateText: (apis: NotificationSketchApis, comp: AlloyComponent, text: string) => {
-      apis.updateText(comp, text);
-    }
-  }
-}) as NotificationSketcher;
