# ====================================================================
# FILE: src/SharpCompress/Common/ExtractionMethods.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| ï»¿using System;
     2| using System.IO;
     3| namespace SharpCompress.Common
     4| {
     5|     internal static class ExtractionMethods
     6|     {
     7|         public static void WriteEntryToDirectory(IEntry entry,
     8|                                                  string destinationDirectory,
     9|                                                  ExtractionOptions? options,
    10|                                                  Action<string, ExtractionOptions?> write)
    11|         {
    12|             string destinationFileName;
    13|             string fullDestinationDirectoryPath = Path.GetFullPath(destinationDirectory);
    14|             if (fullDestinationDirectoryPath[fullDestinationDirectoryPath.Length - 1] != Path.DirectorySeparatorChar)
    15|             {
    16|                 fullDestinationDirectoryPath += Path.DirectorySeparatorChar;
    17|             }
    18|             if (!Directory.Exists(fullDestinationDirectoryPath))
    19|             {
    20|                 throw new ExtractionException($"Directory does not exist to extract to: {fullDestinationDirectoryPath}");
    21|             }
    22|             options ??= new ExtractionOptions()
    23|             {
    24|                 Overwrite = true
    25|             };
    26|             string file = Path.GetFileName(entry.Key);
    27|             if (options.ExtractFullPath)
    28|             {
    29|                 string folder = Path.GetDirectoryName(entry.Key)!;
    30|                 string destdir = Path.GetFullPath(Path.Combine(fullDestinationDirectoryPath, folder));
    31|                 if (!Directory.Exists(destdir))
    32|                 {
    33|                     if (!destdir.StartsWith(fullDestinationDirectoryPath, StringComparison.Ordinal))
    34|                     {
    35|                         throw new ExtractionException("Entry is trying to create a directory outside of the destination directory.");
    36|                     }
    37|                     Directory.CreateDirectory(destdir);
    38|                 }
    39|                 destinationFileName = Path.Combine(destdir, file);
    40|             }
    41|             else
    42|             {
    43|                 destinationFileName = Path.Combine(fullDestinationDirectoryPath, file);
    44|             }
    45|             if (!entry.IsDirectory)
    46|             {


# ====================================================================
# FILE: src/SharpCompress/Common/Zip/SeekableZipHeaderFactory.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 74-114 ---
    74|             for( int i = 0; i < needle.Length; i++ )
    75|             {
    76|                 if( haystack[ position + i ] != needle[ i ] )
    77|                 {
    78|                     return false;
    79|                 }
    80|             }
    81|             return true;
    82|         }
    83|         private static void SeekBackToHeader(Stream stream, BinaryReader reader)
    84|         {
    85|             if (stream.Length < MINIMUM_EOCD_LENGTH)
    86|             {
    87|                 throw new ArchiveException("Could not find Zip file Directory at the end of the file. File may be corrupted.");
    88|             }
    89|             int len = stream.Length < MAX_SEARCH_LENGTH_FOR_EOCD ? (int)stream.Length : MAX_SEARCH_LENGTH_FOR_EOCD;
    90|             byte[] needle = { 0x06, 0x05, 0x4b, 0x50 };
    91|             stream.Seek(-len, SeekOrigin.End);
    92|             byte[] seek = reader.ReadBytes(len);
    93|             Array.Reverse(seek);
    94|             var max_search_area = len; // - MINIMUM_EOCD_LENGTH;
    95|             for( int pos_from_end = 0; pos_from_end < max_search_area; ++pos_from_end)
    96|             {
    97|                 if( IsMatch(seek, pos_from_end, needle) )
    98|                 {
    99|                     stream.Seek(-pos_from_end, SeekOrigin.End);
   100|                     return;
   101|                 }
   102|             }
   103|             throw new ArchiveException("Failed to locate the Zip Header");
   104|         }
   105|         internal LocalEntryHeader GetLocalHeader(Stream stream, DirectoryEntryHeader directoryEntryHeader)
   106|         {
   107|             stream.Seek(directoryEntryHeader.RelativeOffsetOfEntryHeader, SeekOrigin.Begin);
   108|             BinaryReader reader = new BinaryReader(stream);
   109|             uint signature = reader.ReadUInt32();
   110|             var localEntryHeader = ReadHeader(signature, reader, _zip64) as LocalEntryHeader;
   111|             if (localEntryHeader is null)
   112|             {
   113|                 throw new InvalidOperationException();
   114|             }


# ====================================================================
# FILE: src/SharpCompress/Writers/Tar/TarWriter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-112 ---
    60|             int pos = filename.IndexOf(':');
    61|             if (pos >= 0)
    62|             {
    63|                 filename = filename.Remove(0, pos + 1);
    64|             }
    65|             return filename.Trim('/');
    66|         }
    67|         public void Write(string filename, Stream source, DateTime? modificationTime, long? size)
    68|         {
    69|             if (!source.CanSeek && size is null)
    70|             {
    71|                 throw new ArgumentException("Seekable stream is required if no size is given.");
    72|             }
    73|             long realSize = size ?? source.Length;
    74|             TarHeader header = new TarHeader(WriterOptions.ArchiveEncoding);
    75|             header.LastModifiedTime = modificationTime ?? TarHeader.EPOCH;
    76|             header.Name = NormalizeFilename(filename);
    77|             header.Size = realSize;
    78|             header.Write(OutputStream);
    79|             size = source.TransferTo(OutputStream);
    80|             PadTo512(size.Value);
    81|         }
    82|         private void PadTo512(long size)
    83|         {
    84|             int zeros = unchecked((int)(((size + 511L) & ~511L) - size));
    85|             OutputStream.Write(stackalloc byte[zeros]);
    86|         }
    87|         protected override void Dispose(bool isDisposing)
    88|         {
    89|             if (isDisposing)
    90|             {
    91|                 if (finalizeArchiveOnClose)
    92|                 {
    93|                     OutputStream.Write(stackalloc byte[1024]);
    94|                 }
    95|                 switch (OutputStream)
    96|                 {
    97|                     case BZip2Stream b:
    98|                         {
    99|                             b.Finish();
   100|                             break;
   101|                         }
   102|                     case LZipStream l:
   103|                         {
   104|                             l.Finish();
   105|                             break;
   106|                         }
   107|                 }
   108|             }
   109|             base.Dispose(isDisposing);
   110|         }
   111|     }
   112| }

