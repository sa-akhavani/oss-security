# ====================================================================
# FILE: src/SharpCompress/Common/ExtractionMethods.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| ï»¿using System;
     2| using System.IO;
     3| namespace SharpCompress.Common
     4| {
     5|     internal static class ExtractionMethods
     6|     {
     7|         public static void WriteEntryToDirectory(IEntry entry,
     8|                                                  string destinationDirectory,
     9|                                                  ExtractionOptions? options,
    10|                                                  Action<string, ExtractionOptions?> write)
    11|         {
    12|             string destinationFileName;
    13|             string file = Path.GetFileName(entry.Key);
    14|             string fullDestinationDirectoryPath = Path.GetFullPath(destinationDirectory);
    15|             options ??= new ExtractionOptions()
    16|             {
    17|                 Overwrite = true
    18|             };
    19|             if (options.ExtractFullPath)
    20|             {
    21|                 string folder = Path.GetDirectoryName(entry.Key)!;
    22|                 string destdir = Path.GetFullPath(Path.Combine(fullDestinationDirectoryPath, folder));
    23|                 if (!Directory.Exists(destdir))
    24|                 {
    25|                     if (!destdir.StartsWith(fullDestinationDirectoryPath, StringComparison.Ordinal))
    26|                     {
    27|                         throw new ExtractionException("Entry is trying to create a directory outside of the destination directory.");
    28|                     }
    29|                     Directory.CreateDirectory(destdir);
    30|                 }
    31|                 destinationFileName = Path.Combine(destdir, file);
    32|             }
    33|             else
    34|             {
    35|                 destinationFileName = Path.Combine(fullDestinationDirectoryPath, file);
    36|             }
    37|             if (!entry.IsDirectory)
    38|             {


# ====================================================================
# FILE: src/SharpCompress/Common/Zip/SeekableZipHeaderFactory.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 74-114 ---
    74|             for( int i = 0; i < needle.Length; i++ )
    75|             {
    76|                 if( haystack[ position + i ] != needle[ i ] )
    77|                 {
    78|                     return false;
    79|                 }
    80|             }
    81|             return true;
    82|         }
    83|         private static void SeekBackToHeader(Stream stream, BinaryReader reader)
    84|         {
    85|             if (stream.Length < MINIMUM_EOCD_LENGTH)
    86|             {
    87|                 throw new ArchiveException("Could not find Zip file Directory at the end of the file. File may be corrupted.");
    88|             }
    89|             int len = stream.Length < MAX_SEARCH_LENGTH_FOR_EOCD ? (int)stream.Length : MAX_SEARCH_LENGTH_FOR_EOCD;
    90|             byte[] needle = { 0x06, 0x05, 0x4b, 0x50 };
    91|             stream.Seek(-len, SeekOrigin.End);
    92|             byte[] seek = reader.ReadBytes(len);
    93|             Array.Reverse(seek);
    94|             var max_search_area = len - MINIMUM_EOCD_LENGTH;
    95|             for( int pos_from_end = 0; pos_from_end < max_search_area; ++pos_from_end)
    96|             {
    97|                 if( IsMatch(seek, pos_from_end, needle) )
    98|                 {
    99|                     stream.Seek(-pos_from_end, SeekOrigin.End);
   100|                     return;
   101|                 }
   102|             }
   103|             throw new ArchiveException("Failed to locate the Zip Header");
   104|         }
   105|         internal LocalEntryHeader GetLocalHeader(Stream stream, DirectoryEntryHeader directoryEntryHeader)
   106|         {
   107|             stream.Seek(directoryEntryHeader.RelativeOffsetOfEntryHeader, SeekOrigin.Begin);
   108|             BinaryReader reader = new BinaryReader(stream);
   109|             uint signature = reader.ReadUInt32();
   110|             var localEntryHeader = ReadHeader(signature, reader, _zip64) as LocalEntryHeader;
   111|             if (localEntryHeader is null)
   112|             {
   113|                 throw new InvalidOperationException();
   114|             }


# ====================================================================
# FILE: src/SharpCompress/Writers/Tar/TarWriter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 60-118 ---
    60|             int pos = filename.IndexOf(':');
    61|             if (pos >= 0)
    62|             {
    63|                 filename = filename.Remove(0, pos + 1);
    64|             }
    65|             return filename.Trim('/');
    66|         }
    67|         public void Write(string filename, Stream source, DateTime? modificationTime, long? size)
    68|         {
    69|             if (!source.CanSeek && size is null)
    70|             {
    71|                 throw new ArgumentException("Seekable stream is required if no size is given.");
    72|             }
    73|             long realSize = size ?? source.Length;
    74|             TarHeader header = new TarHeader(WriterOptions.ArchiveEncoding);
    75|             header.LastModifiedTime = modificationTime ?? TarHeader.EPOCH;
    76|             header.Name = NormalizeFilename(filename);
    77|             header.Size = realSize;
    78|             header.Write(OutputStream);
    79|             size = source.TransferTo(OutputStream);
    80|             PadTo512(size.Value, false);
    81|         }
    82|         private void PadTo512(long size, bool forceZeros)
    83|         {
    84|             int zeros = (int)size % 512;
    85|             if (zeros == 0 && !forceZeros)
    86|             {
    87|                 return;
    88|             }
    89|             zeros = 512 - zeros;
    90|             OutputStream.Write(stackalloc byte[zeros]);
    91|         }
    92|         protected override void Dispose(bool isDisposing)
    93|         {
    94|             if (isDisposing)
    95|             {
    96|                 if (finalizeArchiveOnClose)
    97|                 {
    98|                     PadTo512(0, true);
    99|                     PadTo512(0, true);
   100|                 }
   101|                 switch (OutputStream)
   102|                 {
   103|                     case BZip2Stream b:
   104|                         {
   105|                             b.Finish();
   106|                             break;
   107|                         }
   108|                     case LZipStream l:
   109|                         {
   110|                             l.Finish();
   111|                             break;
   112|                         }
   113|                 }
   114|             }
   115|             base.Dispose(isDisposing);
   116|         }
   117|     }
   118| }

