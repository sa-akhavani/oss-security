--- a//dev/null
+++ b/.devcontainer/scripts/onCreateCommand.sh
@@ -0,0 +1,8 @@
+set -e
+./build.sh libs+clr -rc Release
+./build.sh libs.tests -restore
+make -C src/mono/wasm provision-wasm
+export EMSDK_PATH=$PWD/src/mono/wasm/emsdk
+./build.sh mono+libs -os Browser -c release
+./dotnet.sh tool install dotnet-serve --tool-path ./.dotnet-tools-global
+git rev-parse HEAD > ./artifacts/prebuild.sha

--- a//dev/null
+++ b/.devcontainer/scripts/postCreateCommand.sh
@@ -0,0 +1,2 @@
+set -e
+git reset --hard $(cat ./artifacts/prebuild.sha)

--- a//dev/null
+++ b/docs/design/coreclr/profiling/davbr-blog-archive/samples/sigformat.cpp
@@ -0,0 +1,320 @@
+#include "SigParse.cpp"
+ #define dimensionof(a) (sizeof(a)/sizeof(*(a)))
+ #define MAKE_CASE(__elt) case __elt: return #__elt;
+ #define MAKE_CASE_OR(__elt) case __elt: return #__elt "|";
+class SigFormat : public SigParser
+{
+private:
+	UINT nIndentLevel;
+public:
+	SigFormat() {nIndentLevel = 0; }
+	UINT GetIndentLevel() { return nIndentLevel;}
+protected:
+	LPCSTR SigIndexTypeToString(sig_index_type sit)
+	{
+		switch(sit)
+		{
+			default:
+			DebugBreak();
+			return "unknown index type";
+			MAKE_CASE(SIG_INDEX_TYPE_TYPEDEF)
+			MAKE_CASE(SIG_INDEX_TYPE_TYPEREF)
+			MAKE_CASE(SIG_INDEX_TYPE_TYPESPEC)
+		}
+	}
+	LPCSTR SigMemberTypeOptionToString(sig_elem_type set)
+	{
+		switch(set & 0xf0)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			case 0:
+			return "";
+			MAKE_CASE_OR(SIG_GENERIC)
+			MAKE_CASE_OR(SIG_HASTHIS)
+			MAKE_CASE_OR(SIG_EXPLICITTHIS)
+		}
+	}
+	LPCSTR SigMemberTypeToString(sig_elem_type set)
+	{
+		switch(set & 0xf)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			MAKE_CASE(SIG_METHOD_DEFAULT)
+			MAKE_CASE(SIG_METHOD_C)
+			MAKE_CASE(SIG_METHOD_STDCALL)
+			MAKE_CASE(SIG_METHOD_THISCALL)
+			MAKE_CASE(SIG_METHOD_FASTCALL)
+			MAKE_CASE(SIG_METHOD_VARARG)
+			MAKE_CASE(SIG_FIELD)
+			MAKE_CASE(SIG_LOCAL_SIG)
+			MAKE_CASE(SIG_PROPERTY)
+		}
+	}
+	LPCSTR SigElementTypeToString(sig_elem_type set)
+	{
+		switch(set)
+		{
+			default:
+			DebugBreak();
+			return "unknown element type";
+			MAKE_CASE(ELEMENT_TYPE_END)
+			MAKE_CASE(ELEMENT_TYPE_VOID)
+			MAKE_CASE(ELEMENT_TYPE_BOOLEAN)
+			MAKE_CASE(ELEMENT_TYPE_CHAR)
+			MAKE_CASE(ELEMENT_TYPE_I1)
+			MAKE_CASE(ELEMENT_TYPE_U1)
+			MAKE_CASE(ELEMENT_TYPE_I2)
+			MAKE_CASE(ELEMENT_TYPE_U2)
+			MAKE_CASE(ELEMENT_TYPE_I4)
+			MAKE_CASE(ELEMENT_TYPE_U4)
+			MAKE_CASE(ELEMENT_TYPE_I8)
+			MAKE_CASE(ELEMENT_TYPE_U8)
+			MAKE_CASE(ELEMENT_TYPE_R4)
+			MAKE_CASE(ELEMENT_TYPE_R8)
+			MAKE_CASE(ELEMENT_TYPE_STRING)
+			MAKE_CASE(ELEMENT_TYPE_PTR)
+			MAKE_CASE(ELEMENT_TYPE_BYREF)
+			MAKE_CASE(ELEMENT_TYPE_VALUETYPE)
+			MAKE_CASE(ELEMENT_TYPE_CLASS)
+			MAKE_CASE(ELEMENT_TYPE_VAR)
+			MAKE_CASE(ELEMENT_TYPE_ARRAY)
+			MAKE_CASE(ELEMENT_TYPE_GENERICINST)
+			MAKE_CASE(ELEMENT_TYPE_TYPEDBYREF)
+			MAKE_CASE(ELEMENT_TYPE_I)
+			MAKE_CASE(ELEMENT_TYPE_U)
+			MAKE_CASE(ELEMENT_TYPE_FNPTR)
+			MAKE_CASE(ELEMENT_TYPE_OBJECT)
+			MAKE_CASE(ELEMENT_TYPE_SZARRAY)
+			MAKE_CASE(ELEMENT_TYPE_MVAR)
+			MAKE_CASE(ELEMENT_TYPE_CMOD_REQD)
+			MAKE_CASE(ELEMENT_TYPE_CMOD_OPT)
+			MAKE_CASE(ELEMENT_TYPE_INTERNAL)
+			MAKE_CASE(ELEMENT_TYPE_MODIFIER)
+			MAKE_CASE(ELEMENT_TYPE_SENTINEL)
+			MAKE_CASE(ELEMENT_TYPE_PINNED)
+		}
+	}
+	void PrintIndent()
+	{
+		const char k_szSpaces[] = " ";
+		printf(k_szSpaces + ((dimensionof(k_szSpaces)-1) - nIndentLevel));
+	}
+	void IncIndent()
+	{
+		nIndentLevel += 2;
+	}
+	void DecIndent()
+	{
+		nIndentLevel -= 2;
+	}
+	void Print(const char* format, ...)
+	{
+		va_list argList;
+		va_start(argList, format);
+		PrintIndent();
+		vprintf(format, argList);
+	}
+	virtual void NotifyBeginMethod(sig_elem_type elem_type)
+	{
+		Print("BEGIN METHOD\n");
+		IncIndent();
+	}
+	virtual void NotifyEndMethod()
+	{
+		DecIndent();
+		Print("END METHOD\n");
+	}
+	virtual void NotifyParamCount(sig_count count)
+	{
+		Print("Param count = '%d'\n", count);
+	}
+	virtual void NotifyBeginRetType()
+	{
+		Print("BEGIN RET TYPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndRetType()
+	{
+		DecIndent();
+		Print("END RET TYPE\n");
+	}
+	virtual void NotifyBeginParam()
+	{
+		Print("BEGIN PARAM\n");
+		IncIndent();
+	}
+	virtual void NotifyEndParam()
+	{
+		DecIndent();
+		Print("END PARAM\n");
+	}
+	virtual void NotifySentinel()
+	{
+		Print("...\n");
+	}
+	virtual void NotifyGenericParamCount(sig_count count)
+	{
+		Print("Generic param count = '%d'\n", count);
+	}
+	virtual void NotifyBeginField(sig_elem_type elem_type)
+	{
+		Print("BEGIN FIELD: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndField()
+	{
+		DecIndent();
+		Print("END FIELD\n");
+	}
+	virtual void NotifyBeginLocals(sig_elem_type elem_type)
+	{
+		Print("BEGIN LOCALS: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndLocals()
+	{
+		DecIndent();
+		Print("END LOCALS\n");
+	}
+	virtual void NotifyLocalsCount(sig_count count)
+	{
+		Print("Locals count: '%d'\n", count);
+	}
+	virtual void NotifyBeginLocal()
+	{
+		Print("BEGIN LOCAL\n");
+		IncIndent();
+	}
+	virtual void NotifyEndLocal()
+	{
+		DecIndent();
+		Print("END LOCAL\n");
+	}
+	virtual void NotifyConstraint(sig_elem_type elem_type)
+	{
+		Print("Constraint: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+	}
+	virtual void NotifyBeginProperty(sig_elem_type elem_type)
+	{
+		Print("BEGIN PROPERTY: '%s%s'\n", SigMemberTypeOptionToString(elem_type), SigMemberTypeToString(elem_type));
+		IncIndent();
+	}
+	virtual void NotifyEndProperty()
+	{
+		DecIndent();
+		Print("END PROPERTY\n");
+	}
+	virtual void NotifyBeginArrayShape()
+	{
+		Print("BEGIN ARRAY SHAPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndArrayShape()
+	{
+		DecIndent();
+		Print("END ARRAY SHAPE\n");
+	}
+	virtual void NotifyRank(sig_count count)
+	{
+		Print("Rank: '%d'\n", count);
+	}
+	virtual void NotifyNumSizes(sig_count count)
+	{
+		Print("Num Sizes: '%d'\n", count);
+	}
+	virtual void NotifySize(sig_count count)
+	{
+		Print("Size: '%d'\n", count);
+	}
+	virtual void NotifyNumLoBounds(sig_count count)
+	{
+		Print("Num Low Bounds: '%d'\n", count);
+	}
+	virtual void NotifyLoBound(sig_count count)
+	{
+		Print("Low Bound: '%d'\n", count);
+	}
+	virtual void NotifyBeginType()
+	{
+		Print("BEGIN TYPE\n");
+		IncIndent();
+	}
+	virtual void NotifyEndType()
+	{
+		DecIndent();
+		Print("END TYPE\n");
+	}
+	virtual void NotifyTypedByref()
+	{
+		Print("Typed byref\n");
+	}
+	virtual void NotifyByref()
+	{
+		Print("Byref\n");
+	}
+	virtual void NotifyVoid()
+	{
+		Print("Void\n");
+	}
+	virtual void NotifyCustomMod(sig_elem_type cmod, sig_index_type indexType, sig_index index)
+	{
+		Print(
+			"Custom modifiers: '%s', index type: '%s', index: '0x%x'\n",
+			SigElementTypeToString(cmod),
+			SigIndexTypeToString(indexType),
+			index);
+	}
+	virtual void NotifyTypeSimple(sig_elem_type elem_type)
+	{
+		Print("Type simple: '%s'\n", SigElementTypeToString(elem_type));
+	}
+	virtual void NotifyTypeDefOrRef(sig_index_type indexType, int index)
+	{
+		Print("Type def or ref: '%s', index: '0x%x'\n", SigIndexTypeToString(indexType), index);
+	}
+	virtual void NotifyTypeGenericInst(sig_elem_type elem_type, sig_index_type indexType, sig_index index, sig_mem_number number)
+	{
+		Print(
+			"Type generic instance: '%s', index type: '%s', index: '0x%x', member number: '%d'\n",
+			SigElementTypeToString(elem_type),
+			SigIndexTypeToString(indexType),
+			index,
+			number);
+	}
+	virtual void NotifyTypeGenericTypeVariable(sig_mem_number number)
+	{
+		Print("Type generic type variable: number: '%d'\n", number);
+	}
+	virtual void NotifyTypeGenericMemberVariable(sig_mem_number number)
+	{
+		Print("Type generic member variable: number: '%d'\n", number);
+	}
+	virtual void NotifyTypeValueType()
+	{
+		Print("Type value type\n");
+	}
+	virtual void NotifyTypeClass()
+	{
+		Print("Type class\n");
+	}
+	virtual void NotifyTypePointer()
+	{
+		Print("Type pointer\n");
+	}
+	virtual void NotifyTypeFunctionPointer()
+	{
+		Print("Type function pointer\n");
+	}
+	virtual void NotifyTypeArray()
+	{
+		Print("Type array\n");
+	}
+	virtual void NotifyTypeSzArray()
+	{
+		Print("Type sz array\n");
+	}
+};

--- a//dev/null
+++ b/docs/design/coreclr/profiling/davbr-blog-archive/samples/sigparse.cpp
@@ -0,0 +1,680 @@
+ #define ELEMENT_TYPE_END 0x00 //Marks end of a list
+ #define ELEMENT_TYPE_VOID 0x01
+ #define ELEMENT_TYPE_BOOLEAN 0x02
+ #define ELEMENT_TYPE_CHAR 0x03
+ #define ELEMENT_TYPE_I1 0x04
+ #define ELEMENT_TYPE_U1 0x05
+ #define ELEMENT_TYPE_I2 0x06
+ #define ELEMENT_TYPE_U2 0x07
+ #define ELEMENT_TYPE_I4 0x08
+ #define ELEMENT_TYPE_U4 0x09
+ #define ELEMENT_TYPE_I8 0x0a
+ #define ELEMENT_TYPE_U8 0x0b
+ #define ELEMENT_TYPE_R4 0x0c
+ #define ELEMENT_TYPE_R8 0x0d
+ #define ELEMENT_TYPE_STRING 0x0e
+ #define ELEMENT_TYPE_PTR 0x0f // Followed by type
+ #define ELEMENT_TYPE_BYREF 0x10 // Followed by type
+ #define ELEMENT_TYPE_VALUETYPE 0x11 // Followed by TypeDef or TypeRef token
+ #define ELEMENT_TYPE_CLASS 0x12 // Followed by TypeDef or TypeRef token
+ #define ELEMENT_TYPE_VAR 0x13 // Generic parameter in a generic type definition, represented as number
+ #define ELEMENT_TYPE_ARRAY 0x14 // type rank boundsCount bound1 … loCount lo1 …
+ #define ELEMENT_TYPE_GENERICINST 0x15 // Generic type instantiation. Followed by type type-arg-count type-1 ... type-n
+ #define ELEMENT_TYPE_TYPEDBYREF 0x16
+ #define ELEMENT_TYPE_I 0x18 // System.IntPtr
+ #define ELEMENT_TYPE_U 0x19 // System.UIntPtr
+ #define ELEMENT_TYPE_FNPTR 0x1b // Followed by full method signature
+ #define ELEMENT_TYPE_OBJECT 0x1c // System.Object
+ #define ELEMENT_TYPE_SZARRAY 0x1d // Single-dim array with 0 lower bound
+ #define ELEMENT_TYPE_MVAR 0x1e // Generic parameter in a generic method definition,represented as number
+ #define ELEMENT_TYPE_CMOD_REQD 0x1f // Required modifier : followed by a TypeDef or TypeRef token
+ #define ELEMENT_TYPE_CMOD_OPT 0x20 // Optional modifier : followed by a TypeDef or TypeRef token
+ #define ELEMENT_TYPE_INTERNAL 0x21 // Implemented within the CLI
+ #define ELEMENT_TYPE_MODIFIER 0x40 // Or’d with following element types
+ #define ELEMENT_TYPE_SENTINEL 0x41 // Sentinel for vararg method signature
+ #define ELEMENT_TYPE_PINNED 0x45 // Denotes a local variable that points at a pinned object
+ #define SIG_METHOD_DEFAULT 0x0 // default calling convention
+ #define SIG_METHOD_C 0x1 // C calling convention
+ #define SIG_METHOD_STDCALL 0x2 // Stdcall calling convention
+ #define SIG_METHOD_THISCALL 0x3 // thiscall calling convention
+ #define SIG_METHOD_FASTCALL 0x4 // fastcall calling convention
+ #define SIG_METHOD_VARARG 0x5 // vararg calling convention
+ #define SIG_FIELD 0x6 // encodes a field
+ #define SIG_LOCAL_SIG 0x7 // used for the .locals directive
+ #define SIG_PROPERTY 0x8 // used to encode a property
+ #define SIG_GENERIC 0x10 // used to indicate that the method has one or more generic parameters.
+ #define SIG_HASTHIS 0x20 // used to encode the keyword instance in the calling convention
+ #define SIG_EXPLICITTHIS 0x40 // used to encode the keyword explicit in the calling convention
+ #define SIG_INDEX_TYPE_TYPEDEF 0 // ParseTypeDefOrRefEncoded returns this as the out index type for typedefs
+ #define SIG_INDEX_TYPE_TYPEREF 1 // ParseTypeDefOrRefEncoded returns this as the out index type for typerefs
+ #define SIG_INDEX_TYPE_TYPESPEC 2 // ParseTypeDefOrRefEncoded returns this as the out index type for typespecs
+typedef unsigned char sig_byte;
+typedef unsigned char sig_elem_type;
+typedef unsigned char sig_index_type;
+typedef unsigned int sig_index;
+typedef unsigned int sig_count;
+typedef unsigned int sig_mem_number;
+class SigParser
+{
+private:
+	sig_byte *pbBase;
+	sig_byte *pbCur;
+	sig_byte *pbEnd;
+public:
+	bool Parse(sig_byte *blob, sig_count len);
+private:
+	bool ParseByte(sig_byte *pbOut);
+	bool ParseNumber(sig_count *pOut);
+	bool ParseTypeDefOrRefEncoded(sig_index_type *pOutIndexType, sig_index *pOutIndex);
+	bool ParseMethod(sig_elem_type);
+	bool ParseField(sig_elem_type);
+	bool ParseProperty(sig_elem_type);
+	bool ParseLocals(sig_elem_type);
+	bool ParseLocal();
+	bool ParseOptionalCustomMods();
+	bool ParseOptionalCustomModsOrConstraint();
+	bool ParseCustomMod();
+	bool ParseRetType();
+	bool ParseType();
+	bool ParseParam();
+	bool ParseArrayShape();
+protected:
+	virtual void NotifyBeginMethod(sig_elem_type elem_type) {}
+	virtual void NotifyEndMethod() {}
+	virtual void NotifyParamCount(sig_count) {}
+	virtual void NotifyBeginRetType() {}
+	virtual void NotifyEndRetType() {}
+	virtual void NotifyBeginParam() {}
+	virtual void NotifyEndParam() {}
+	virtual void NotifySentinel() {}
+	virtual void NotifyGenericParamCount(sig_count) {}
+	virtual void NotifyBeginField(sig_elem_type elem_type) {}
+	virtual void NotifyEndField() {}
+	virtual void NotifyBeginLocals(sig_elem_type elem_type) {}
+	virtual void NotifyEndLocals() {}
+	virtual void NotifyLocalsCount(sig_count) {}
+	virtual void NotifyBeginLocal() {}
+	virtual void NotifyEndLocal() {}
+	virtual void NotifyConstraint(sig_elem_type elem_type) {}
+	virtual void NotifyBeginProperty(sig_elem_type elem_type) {}
+	virtual void NotifyEndProperty() {}
+	virtual void NotifyBeginArrayShape() {}
+	virtual void NotifyEndArrayShape() {}
+	virtual void NotifyRank(sig_count) {}
+	virtual void NotifyNumSizes(sig_count) {}
+	virtual void NotifySize(sig_count) {}
+	virtual void NotifyNumLoBounds(sig_count) {}
+	virtual void NotifyLoBound(sig_count) {}
+	virtual void NotifyBeginType() {};
+	virtual void NotifyEndType() {};
+	virtual void NotifyTypedByref() {}
+	virtual void NotifyByref() {}
+	virtual void NotifyVoid() {}
+	virtual void NotifyCustomMod(sig_elem_type cmod, sig_index_type indexType, sig_index index) {}
+	virtual void NotifyTypeSimple(sig_elem_type elem_type) {}
+	virtual void NotifyTypeDefOrRef(sig_index_type indexType, int index) {}
+	virtual void NotifyTypeGenericInst(sig_elem_type elem_type, sig_index_type indexType, sig_index index, sig_mem_number number) {}
+	virtual void NotifyTypeGenericTypeVariable(sig_mem_number number) {}
+	virtual void NotifyTypeGenericMemberVariable(sig_mem_number number) {}
+	virtual void NotifyTypeValueType() {}
+	virtual void NotifyTypeClass() {}
+	virtual void NotifyTypePointer() {}
+	virtual void NotifyTypeFunctionPointer() {}
+	virtual void NotifyTypeArray() {}
+	virtual void NotifyTypeSzArray() {}
+};
+bool SigParser::Parse(sig_byte *pb, sig_count cbBuffer)
+{
+	pbBase = pb;
+	pbCur = pb;
+	pbEnd = pbBase + cbBuffer;
+	sig_elem_type elem_type;
+	if (!ParseByte(&elem_type))
+		return false;
+	switch (elem_type & 0xf)
+	{
+		case SIG_METHOD_DEFAULT: // default calling convention
+		case SIG_METHOD_C: // C calling convention
+		case SIG_METHOD_STDCALL: // Stdcall calling convention
+		case SIG_METHOD_THISCALL: // thiscall calling convention
+		case SIG_METHOD_FASTCALL: // fastcall calling convention
+		case SIG_METHOD_VARARG: // vararg calling convention
+			return ParseMethod(elem_type);
+			break;
+ 		case SIG_FIELD: // encodes a field
+ 			return ParseField(elem_type);
+ 			break;
+ 		case SIG_LOCAL_SIG: // used for the .locals directive
+ 			return ParseLocals(elem_type);
+ 			break;
+		case SIG_PROPERTY: // used to encode a property
+ 			return ParseProperty(elem_type);
+ 			break;
+ 		default:
+ 			break;
+	}
+	return false;
+}
+bool SigParser::ParseByte(sig_byte *pbOut)
+{
+	if (pbCur < pbEnd)
+	{
+		*pbOut = *pbCur;
+		pbCur++;
+		return true;
+	}
+	return false;
+}
+bool SigParser::ParseMethod(sig_elem_type elem_type)
+{
+	NotifyBeginMethod(elem_type);
+	sig_count gen_param_count;
+	sig_count param_count;
+	if (elem_type & SIG_GENERIC)
+	{
+		if (!ParseNumber(&gen_param_count))
+		{
+			return false;
+		}
+		NotifyGenericParamCount(gen_param_count);
+	}
+	if (!ParseNumber(¶m_count))
+	{
+		return false;
+	}
+	NotifyParamCount(param_count);
+	if (!ParseRetType())
+	{
+		return false;
+	}
+	bool fEncounteredSentinel = false;
+	for (sig_count i = 0; i < param_count; i++)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return false;
+		}
+		if (*pbCur == ELEMENT_TYPE_SENTINEL)
+		{
+			if (fEncounteredSentinel)
+			{
+				return false;
+			}
+			fEncounteredSentinel = true;
+			NotifySentinel();
+			pbCur++;
+		}
+		if (!ParseParam())
+		{
+			return false;
+		}
+	}
+	NotifyEndMethod();
+	return true;
+}
+bool SigParser::ParseField(sig_elem_type elem_type)
+{
+	NotifyBeginField(elem_type);
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	NotifyEndField();
+	return true;
+}
+bool SigParser::ParseProperty(sig_elem_type elem_type)
+{
+	NotifyBeginProperty(elem_type);
+	sig_count param_count;
+	if (!ParseNumber(&param_count))
+	{
+		return false;
+	}
+	NotifyParamCount(param_count);
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	for (sig_count i = 0; i < param_count; i++)
+	{
+		if (!ParseParam())
+		{
+			return false;
+		}
+	}
+	NotifyEndProperty();
+	return true;
+}
+bool SigParser::ParseLocals(sig_elem_type elem_type)
+{
+	NotifyBeginLocals(elem_type);
+	sig_count local_count;
+	if (!ParseNumber(&local_count))
+	{
+		return false;
+	}
+	NotifyLocalsCount(local_count);
+	for (sig_count i = 0; i < local_count; i++)
+	{
+		if (!ParseLocal())
+		{
+			return false;
+		}
+	}
+	NotifyEndLocals();
+	return true;
+}
+bool SigParser::ParseLocal()
+{
+	NotifyBeginLocal();
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (!ParseOptionalCustomModsOrConstraint())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndLocal();
+	return true;
+}
+bool SigParser::ParseOptionalCustomModsOrConstraint()
+{
+	for (;;)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return true;
+		}
+		switch (*pbCur)
+		{
+			case ELEMENT_TYPE_CMOD_OPT:
+			case ELEMENT_TYPE_CMOD_REQD:
+				if (!ParseCustomMod())
+				{
+					return false;
+				}
+			break;
+			case ELEMENT_TYPE_PINNED:
+				NotifyConstraint(*pbCur);
+				pbCur++;
+				break;
+			default:
+				return true;
+		}
+	}
+	return false;
+}
+bool SigParser::ParseOptionalCustomMods()
+{
+	for (;;)
+	{
+		if (pbCur >= pbEnd)
+		{
+			return true;
+		}
+		switch (*pbCur)
+		{
+			case ELEMENT_TYPE_CMOD_OPT:
+			case ELEMENT_TYPE_CMOD_REQD:
+				if (!ParseCustomMod())
+				{
+					return false;
+				}
+				break;
+			default:
+				return true;
+		}
+	}
+	return false;
+}
+bool SigParser::ParseCustomMod()
+{
+	sig_elem_type cmod = 0;
+	sig_index index;
+	sig_index_type indexType;
+	if (!ParseByte(&cmod))
+	{
+		return false;
+	}
+	if (cmod == ELEMENT_TYPE_CMOD_OPT || cmod == ELEMENT_TYPE_CMOD_REQD)
+	{
+		if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+		{
+			return false;
+		}
+		NotifyCustomMod(cmod, indexType, index);
+		return true;
+	}
+	return false;
+}
+bool SigParser::ParseParam()
+{
+	NotifyBeginParam();
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndParam();
+	return true;
+}
+bool SigParser::ParseRetType()
+{
+	NotifyBeginRetType();
+	if (!ParseOptionalCustomMods())
+	{
+		return false;
+	}
+	if (pbCur >= pbEnd)
+	{
+		return false;
+	}
+	if (*pbCur == ELEMENT_TYPE_TYPEDBYREF)
+	{
+		NotifyTypedByref();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_VOID)
+	{
+		NotifyVoid();
+		pbCur++;
+		goto Success;
+	}
+	if (*pbCur == ELEMENT_TYPE_BYREF)
+	{
+		NotifyByref();
+		pbCur++;
+	}
+	if (!ParseType())
+	{
+		return false;
+	}
+	Success:
+	NotifyEndRetType();
+	return true;
+}
+bool SigParser::ParseArrayShape()
+{
+	sig_count rank;
+	sig_count numsizes;
+	sig_count size;
+	NotifyBeginArrayShape();
+	if (!ParseNumber(&rank))
+	{
+		return false;
+	}
+	NotifyRank(rank);
+	if (!ParseNumber(&numsizes))
+	{
+		return false;
+	}
+	NotifyNumSizes(numsizes);
+	for (sig_count i = 0; i < numsizes; i++)
+	{
+		if (!ParseNumber(&size))
+		{
+			return false;
+		}
+		NotifySize(size);
+	}
+	if (!ParseNumber(&numsizes))
+	{
+		return false;
+	}
+	NotifyNumLoBounds(numsizes);
+	for (sig_count i = 0; i < numsizes; i++)
+	{
+		if (!ParseNumber(&size))
+		{
+			return false;
+		}
+		NotifyLoBound(size);
+	}
+	NotifyEndArrayShape();
+	return true;
+}
+bool SigParser::ParseType()
+{
+	NotifyBeginType();
+	sig_elem_type elem_type;
+	sig_index index;
+	sig_mem_number number;
+	sig_index_type indexType;
+	if (!ParseByte(&elem_type))
+		return false;
+	switch (elem_type)
+	{
+		case ELEMENT_TYPE_BOOLEAN:
+		case ELEMENT_TYPE_CHAR:
+		case ELEMENT_TYPE_I1:
+		case ELEMENT_TYPE_U1:
+		case ELEMENT_TYPE_U2:
+		case ELEMENT_TYPE_I2:
+		case ELEMENT_TYPE_I4:
+		case ELEMENT_TYPE_U4:
+		case ELEMENT_TYPE_I8:
+		case ELEMENT_TYPE_U8:
+		case ELEMENT_TYPE_R4:
+		case ELEMENT_TYPE_R8:
+		case ELEMENT_TYPE_I:
+		case ELEMENT_TYPE_U:
+		case ELEMENT_TYPE_STRING:
+		case ELEMENT_TYPE_OBJECT:
+			NotifyTypeSimple(elem_type);
+			break;
+		case ELEMENT_TYPE_PTR:
+			NotifyTypePointer();
+			if (!ParseOptionalCustomMods())
+			{
+				return false;
+			}
+			if (pbCur >= pbEnd)
+			{
+				return false;
+			}
+			if (*pbCur == ELEMENT_TYPE_VOID)
+			{
+				pbCur++;
+				NotifyVoid();
+				break;
+			}
+			if (!ParseType())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_CLASS:
+			NotifyTypeClass();
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			NotifyTypeDefOrRef(indexType, index);
+			break;
+		case ELEMENT_TYPE_VALUETYPE:
+			NotifyTypeValueType();
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			NotifyTypeDefOrRef(indexType, index);
+			break;
+		case ELEMENT_TYPE_FNPTR:
+			NotifyTypeFunctionPointer();
+			if (!ParseByte(&elem_type))
+			{
+				return false;
+			}
+			if (!ParseMethod(elem_type))
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_ARRAY:
+			NotifyTypeArray();
+			if (!ParseType())
+			{
+				return false;
+			}
+			if (!ParseArrayShape())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_SZARRAY:
+			NotifyTypeSzArray();
+			if (!ParseOptionalCustomMods())
+			{
+				return false;
+			}
+			if (!ParseType())
+			{
+				return false;
+			}
+			break;
+		case ELEMENT_TYPE_GENERICINST:
+			if (!ParseByte(&elem_type))
+			{
+				return false;
+			}
+			if (elem_type != ELEMENT_TYPE_CLASS && elem_type != ELEMENT_TYPE_VALUETYPE)
+			{
+				return false;
+			}
+			if (!ParseTypeDefOrRefEncoded(&indexType, &index))
+			{
+				return false;
+			}
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericInst(elem_type, indexType, index, number);
+			{
+				for (sig_mem_number i=0; i < number; i++)
+				{
+					if (!ParseType())
+					{
+						return false;
+					}
+				}
+			}
+			break;
+		case ELEMENT_TYPE_VAR:
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericTypeVariable(number);
+			break;
+		case ELEMENT_TYPE_MVAR:
+			if (!ParseNumber(&number))
+			{
+				return false;
+			}
+			NotifyTypeGenericMemberVariable(number);
+			break;
+	}
+	NotifyEndType();
+	return true;
+}
+bool SigParser::ParseTypeDefOrRefEncoded(sig_index_type *pIndexTypeOut, sig_index *pIndexOut)
+{
+	sig_count encoded = 0;
+	if (!ParseNumber(&encoded))
+	{
+		return false;
+	}
+	*pIndexTypeOut = (sig_index_type) (encoded & 0x3);
+	*pIndexOut = (encoded >> 2);
+	return true;
+}
+bool SigParser::ParseNumber(sig_count *pOut)
+{
+	sig_byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;
+	if (!ParseByte(&b1))
+	{
+		return false;
+	}
+	if (b1 == 0xff)
+	{
+		return false;
+	}
+	if ( (b1 & 0x80) == 0)
+	{
+		*pOut = (int)b1;
+		return true;
+	}
+	if (!ParseByte(&b2))
+	{
+		return false;
+	}
+	if ( (b1 & 0x40) == 0)
+	{
+		*pOut = (((b1 & 0x3f) << 8) | b2);
+		return true;
+	}
+	if ( (b1 & 0x20) != 0)
+	{
+		return false;
+	}
+	if (!ParseByte(&b3))
+	{
+		return false;
+	}
+	if (!ParseByte(&b4))
+	{
+		return false;
+	}
+	*pOut = ((b1 & 0x1f) << 24) | (b2 << 16) | (b3 << 8) | b4;
+	return true;
+}

--- a//dev/null
+++ b/eng/actions/backport/index.js
@@ -0,0 +1,116 @@
+function BackportException(message, postToGitHub = true) {
+  this.message = message;
+  this.postToGitHub = postToGitHub;
+}
+async function run() {
+  const util = require("util");
+  const jsExec = util.promisify(require("child_process").exec);
+  console.log("Installing npm dependencies");
+  const { stdout, stderr } = await jsExec("npm install @actions/core @actions/github @actions/exec");
+  console.log("npm-install stderr:\n\n" + stderr);
+  console.log("npm-install stdout:\n\n" + stdout);
+  console.log("Finished installing npm dependencies");
+  const core = require("@actions/core");
+  const github = require("@actions/github");
+  const exec = require("@actions/exec");
+  const repo_owner = github.context.payload.repository.owner.login;
+  const repo_name = github.context.payload.repository.name;
+  const pr_number = github.context.payload.issue.number;
+  const comment_user = github.context.payload.comment.user.login;
+  let octokit = github.getOctokit(core.getInput("auth_token", { required: true }));
+  let target_branch = core.getInput("target_branch", { required: true });
+  try {
+    try {
+      await octokit.rest.repos.checkCollaborator({
+        owner: repo_owner,
+        repo: repo_name,
+        username: comment_user
+      });
+      console.log(`Verified ${comment_user} is a repo collaborator.`);
+    } catch (error) {
+      console.log(error);
+      throw new BackportException(`Error: @${comment_user} is not a repo collaborator, backporting is not allowed. If you're a collaborator please make sure your ${repo_owner} team membership visibility is set to Public on https://github.com/orgs/${repo_owner}/people?query=${comment_user}`);
+    }
+    try { await exec.exec(`git ls-remote --exit-code --heads origin ${target_branch}`) } catch { throw new BackportException(`Error: The specified backport target branch ${target_branch} wasn't found in the repo.`); }
+    console.log(`Backport target branch: ${target_branch}`);
+    console.log("Applying backport patch");
+    await exec.exec(`git checkout ${target_branch}`);
+    await exec.exec(`git clean -xdff`);
+    await exec.exec(`git config user.name "github-actions"`);
+    await exec.exec(`git config user.email "github-actions@github.com"`);
+    const temp_branch = `backport/pr-${pr_number}-to-${target_branch}`;
+    await exec.exec(`git checkout -b ${temp_branch}`);
+    let should_open_pull_request = true;
+    try {
+      await exec.exec(`git ls-remote --exit-code --heads origin ${temp_branch}`);
+      should_open_pull_request = false;
+    } catch { }
+    await exec.exec(`curl -sSL "${github.context.payload.issue.pull_request.patch_url}" --output changes.patch`);
+    const git_am_command = "git am --3way --ignore-whitespace --keep-non-patch changes.patch";
+    let git_am_output = `$ ${git_am_command}\n\n`;
+    let git_am_failed = false;
+    try {
+      await exec.exec(git_am_command, [], {
+        listeners: {
+          stdout: function stdout(data) { git_am_output += data; },
+          stderr: function stderr(data) { git_am_output += data; }
+        }
+      });
+    } catch (error) {
+      git_am_output += error;
+      git_am_failed = true;
+    }
+    if (git_am_failed) {
+      const git_am_failed_body = `@${github.context.payload.comment.user.login} backporting to ${target_branch} failed, the patch most likely resulted in conflicts:\n\n\`\`\`shell\n${git_am_output}\n\`\`\`\n\nPlease backport manually!`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: git_am_failed_body
+      });
+      throw new BackportException("Error: git am failed, most likely due to a merge conflict.", false);
+    }
+    else {
+      await exec.exec(`git push --force --set-upstream origin HEAD:${temp_branch}`);
+    }
+    if (!should_open_pull_request) {
+      console.log("Backport temp branch already exists, skipping opening a PR.");
+      return;
+    }
+    let backport_pr_title = core.getInput("pr_title_template");
+    let backport_pr_description = core.getInput("pr_description_template");
+    let cc_users = `@${comment_user}`;
+    if (comment_user != github.context.payload.issue.user.login) cc_users += ` @${github.context.payload.issue.user.login}`;
+    backport_pr_title = backport_pr_title
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    backport_pr_description = backport_pr_description
+      .replace(/%target_branch%/g, target_branch)
+      .replace(/%source_pr_title%/g, github.context.payload.issue.title)
+      .replace(/%source_pr_number%/g, github.context.payload.issue.number)
+      .replace(/%cc_users%/g, cc_users);
+    await octokit.rest.pulls.create({
+      owner: repo_owner,
+      repo: repo_name,
+      title: backport_pr_title,
+      body: backport_pr_description,
+      head: temp_branch,
+      base: target_branch
+    });
+    console.log("Successfully opened the GitHub PR.");
+  } catch (error) {
+    core.setFailed(error);
+    if (error.postToGitHub === undefined || error.postToGitHub == true) {
+      const unknown_error_body = `@${comment_user} an error occurred while backporting to ${target_branch}, please check the run log for details!\n\n${error.message}`;
+      await octokit.rest.issues.createComment({
+        owner: repo_owner,
+        repo: repo_name,
+        issue_number: pr_number,
+        body: unknown_error_body
+      });
+    }
+  }
+}
+run();

--- a//dev/null
+++ b/eng/build.sh
@@ -0,0 +1,422 @@
+set -ue
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+usage()
+{
+  echo "Common settings:"
+  echo "  --arch (-a)                     Target platform: x86, x64, arm, armv6, armel, arm64, loongarch64, riscv64, s390x, ppc64le or wasm."
+  echo "                                  [Default: Your machine's architecture.]"
+  echo "  --binaryLog (-bl)               Output binary log."
+  echo "  --cross                         Optional argument to signify cross compilation."
+  echo "  --configuration (-c)            Build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR subset. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  --help (-h)                     Print help and exit."
+  echo "  --librariesConfiguration (-lc)  Libraries build configuration: Debug or Release."
+  echo "                                  [Default: Debug]"
+  echo "  --os                            Target operating system: windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS,"
+  echo "                                  tvOSSimulator, iOS, iOSSimulator, Android, Browser, NetBSD, illumos or Solaris."
+  echo "                                  [Default: Your machine's OS.]"
+  echo "  --projects <value>              Project or solution file(s) to build."
+  echo "  --runtimeConfiguration (-rc)    Runtime build configuration: Debug, Release or Checked."
+  echo "                                  Checked is exclusive to the CLR runtime. It is the same as Debug, except code is"
+  echo "                                  compiled with optimizations enabled."
+  echo "                                  [Default: Debug]"
+  echo "  -runtimeFlavor (-rf)            Runtime flavor: CoreCLR or Mono."
+  echo "                                  [Default: CoreCLR]"
+  echo "  --subset (-s)                   Build a subset, print available subsets with -subset help."
+  echo "                                 '--subset' can be omitted if the subset is given as the first argument."
+  echo "                                  [Default: Builds the entire repo.]"
+  echo "  --verbosity (-v)                MSBuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]."
+  echo "                                  [Default: Minimal]"
+  echo ""
+  echo "Actions (defaults to --restore --build):"
+  echo "  --build (-b)               Build all source projects."
+  echo "                             This assumes --restore has been run already."
+  echo "  --clean                    Clean the solution."
+  echo "  --pack                     Package build outputs into NuGet packages."
+  echo "  --publish                  Publish artifacts (e.g. symbols)."
+  echo "                             This assumes --build has been run already."
+  echo "  --rebuild                  Rebuild all source projects."
+  echo "  --restore (-r)             Restore dependencies."
+  echo "  --sign                     Sign build outputs."
+  echo "  --test (-t)                Incrementally builds and runs tests."
+  echo "                             Use in conjunction with --testnobuild to only run tests."
+  echo ""
+  echo "Libraries settings:"
+  echo "  --allconfigurations        Build packages for all build configurations."
+  echo "  --coverage                 Collect code coverage when testing."
+  echo "  --framework (-f)           Build framework: net7.0 or net48."
+  echo "                             [Default: net7.0]"
+  echo "  --testnobuild              Skip building tests when invoking -test."
+  echo "  --testscope                Test scope, allowed values: innerloop, outerloop, all."
+  echo ""
+  echo "Native build settings:"
+  echo "  --clang                    Optional argument to build using clang in PATH (default)."
+  echo "  --clangx                   Optional argument to build using clang version x (used for Clang 7 and newer)."
+  echo "  --clangx.y                 Optional argument to build using clang version x.y (used for Clang 6 and older)."
+  echo "  --cmakeargs                User-settable additional arguments passed to CMake."
+  echo "  --gcc                      Optional argument to build using gcc in PATH (default)."
+  echo "  --gccx.y                   Optional argument to build using gcc version x.y."
+  echo "  --portablebuild            Optional argument: set to false to force a non-portable build."
+  echo "  --keepnativesymbols        Optional argument: set to true to keep native symbols/debuginfo in generated binaries."
+  echo "  --ninja                    Optional argument: set to true to use Ninja instead of Make to run the native build."
+  echo "  --pgoinstrument            Optional argument: build PGO-instrumented runtime"
+  echo ""
+  echo "Command line arguments starting with '/p:' are passed through to MSBuild."
+  echo "Arguments can also be passed in with a single hyphen."
+  echo ""
+  echo "Here are some quick examples. These assume you are on a Linux x64 machine:"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Release configuration:"
+  echo "./build.sh clr -c release"
+  echo ""
+  echo "* Build Debug libraries with a Release runtime for Linux x64."
+  echo "./build.sh clr+libs -rc release"
+  echo ""
+  echo "* Build Release libraries and their tests with a Checked runtime for Linux x64, and run the tests."
+  echo "./build.sh clr+libs+libs.tests -rc checked -lc release -test"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using Clang 9."
+  echo "./build.sh clr -clang9"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 on Debug configuration using GCC 8.4."
+  echo "./build.sh clr -gcc8.4"
+  echo ""
+  echo "* Build CoreCLR for Linux x64 using extra compiler flags (-fstack-clash-protection)."
+  echo "EXTRA_CFLAGS=-fstack-clash-protection EXTRA_CXXFLAGS=-fstack-clash-protection ./build.sh clr"
+  echo ""
+  echo "* Cross-compile CoreCLR runtime for Linux ARM64 on Release configuration."
+  echo "./build.sh clr.runtime -arch arm64 -c release -cross"
+  echo ""
+  echo "However, for this example, you need to already have ROOTFS_DIR set up."
+  echo "Further information on this can be found here:"
+  echo "https://github.com/dotnet/runtime/blob/main/docs/workflow/building/coreclr/linux-instructions.md"
+  echo ""
+  echo "* Build Mono runtime for Linux x64 on Release configuration."
+  echo "./build.sh mono -c release"
+  echo ""
+  echo "* Build Release coreclr corelib, crossgen corelib and update Debug libraries testhost to run test on an updated corelib."
+  echo "./build.sh clr.corelib+clr.nativecorelib+libs.pretest -rc release"
+  echo ""
+  echo "* Build Debug mono corelib and update Release libraries testhost to run test on an updated corelib."
+  echo "./build.sh mono.corelib+libs.pretest -rc debug -c release"
+  echo ""
+  echo ""
+  echo "For more general information, check out https://github.com/dotnet/runtime/blob/main/docs/workflow/README.md"
+}
+initDistroRid()
+{
+    source "$scriptroot"/native/init-distro-rid.sh
+    local passedRootfsDir=""
+    local targetOs="$1"
+    local buildArch="$2"
+    local isCrossBuild="$3"
+    local isPortableBuild="$4"
+    if [[ $isCrossBuild == 1 && "$targetOs" != "OSX" ]]; then
+        passedRootfsDir=${ROOTFS_DIR}
+    fi
+    initDistroRidGlobal ${targetOs} ${buildArch} ${isPortableBuild} ${passedRootfsDir}
+}
+showSubsetHelp()
+{
+  "$scriptroot/common/build.sh" "-restore" "-build" "/p:Subset=help" "/clp:nosummary"
+}
+arguments=''
+cmakeargs=''
+extraargs=''
+crossBuild=0
+portableBuild=1
+source $scriptroot/native/init-os-and-arch.sh
+hostArch=$arch
+declare -a actions=("b" "build" "r" "restore" "rebuild" "testnobuild" "sign" "publish" "clean")
+actInt=($(comm -12 <(printf '%s\n' "${actions[@]/#/-}" | sort) <(printf '%s\n' "${@/#--/-}" | sort)))
+firstArgumentChecked=0
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  if [[ $firstArgumentChecked -eq 0 && $opt =~ ^[a-zA-Z.+]+$ ]]; then
+    if [[ "$opt" == "help" ]]; then
+      showSubsetHelp
+      exit 0
+    fi
+    arguments="$arguments /p:Subset=$1"
+    shift 1
+    continue
+  fi
+  firstArgumentChecked=1
+  case "$opt" in
+     -help|-h|-\?|/?)
+      usage
+      exit 0
+      ;;
+     -subset|-s)
+      if [ -z ${2+x} ]; then
+        showSubsetHelp
+        exit 0
+      else
+        passedSubset="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [[ "$passedSubset" == "help" ]]; then
+          showSubsetHelp
+          exit 0
+        fi
+        arguments="$arguments /p:Subset=$2"
+        shift 2
+      fi
+      ;;
+     -arch|-a)
+      if [ -z ${2+x} ]; then
+        echo "No architecture supplied. See help (--help) for supported architectures." 1>&2
+        exit 1
+      fi
+      passedArch="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedArch" in
+        x64|x86|arm|armv6|armel|arm64|loongarch64|riscv64|s390x|ppc64le|wasm)
+          arch=$passedArch
+          ;;
+        *)
+          echo "Unsupported target architecture '$2'."
+          echo "The allowed values are x86, x64, arm, armv6, armel, arm64, loongarch64, riscv64, s390x, ppc64le and wasm."
+          exit 1
+          ;;
+      esac
+      shift 2
+      ;;
+     -configuration|-c)
+      if [ -z ${2+x} ]; then
+        echo "No configuration supplied. See help (--help) for supported configurations." 1>&2
+        exit 1
+      fi
+      passedConfig="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedConfig" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedConfig:0:1})${passedConfig:1}"
+          ;;
+        *)
+          echo "Unsupported target configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments -configuration $val"
+      shift 2
+      ;;
+     -framework|-f)
+      if [ -z ${2+x} ]; then
+        echo "No framework supplied. See help (--help) for supported frameworks." 1>&2
+        exit 1
+      fi
+      val="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      arguments="$arguments /p:BuildTargetFramework=$val"
+      shift 2
+      ;;
+     -os)
+      if [ -z ${2+x} ]; then
+        echo "No target operating system supplied. See help (--help) for supported target operating systems." 1>&2
+        exit 1
+      fi
+      passedOS="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedOS" in
+        windows)
+          os="windows" ;;
+        linux)
+          os="Linux" ;;
+        freebsd)
+          os="FreeBSD" ;;
+        osx)
+          os="OSX" ;;
+        maccatalyst)
+          os="MacCatalyst" ;;
+        tvos)
+          os="tvOS" ;;
+        tvossimulator)
+          os="tvOSSimulator" ;;
+        ios)
+          os="iOS" ;;
+        iossimulator)
+          os="iOSSimulator" ;;
+        android)
+          os="Android" ;;
+        browser)
+          os="Browser" ;;
+        illumos)
+          os="illumos" ;;
+        solaris)
+          os="Solaris" ;;
+        *)
+          echo "Unsupported target OS '$2'."
+          echo "The allowed values are windows, Linux, FreeBSD, OSX, MacCatalyst, tvOS, tvOSSimulator, iOS, iOSSimulator, Android, Browser, illumos and Solaris."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:TargetOS=$os"
+      shift 2
+      ;;
+     -allconfigurations)
+      arguments="$arguments /p:BuildAllConfigurations=true"
+      shift 1
+      ;;
+     -testscope)
+      if [ -z ${2+x} ]; then
+        echo "No test scope supplied. See help (--help) for supported test scope values." 1>&2
+        exit 1
+      fi
+      arguments="$arguments /p:TestScope=$2"
+      shift 2
+      ;;
+     -testnobuild)
+      arguments="$arguments /p:TestNoBuild=true"
+      shift 1
+      ;;
+     -coverage)
+      arguments="$arguments /p:Coverage=true"
+      shift 1
+      ;;
+     -runtimeconfiguration|-rc)
+      if [ -z ${2+x} ]; then
+        echo "No runtime configuration supplied. See help (--help) for supported runtime configurations." 1>&2
+        exit 1
+      fi
+      passedRuntimeConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeConf" in
+        debug|release|checked)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeConf:0:1})${passedRuntimeConf:1}"
+          ;;
+        *)
+          echo "Unsupported runtime configuration '$2'."
+          echo "The allowed values are Debug, Release, and Checked."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeConfiguration=$val"
+      shift 2
+      ;;
+     -runtimeflavor|-rf)
+      if [ -z ${2+x} ]; then
+        echo "No runtime flavor supplied. See help (--help) for supported runtime flavors." 1>&2
+        exit 1
+      fi
+      passedRuntimeFlav="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedRuntimeFlav" in
+        coreclr|mono)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedRuntimeFlav:0:1})${passedRuntimeFlav:1}"
+          ;;
+        *)
+          echo "Unsupported runtime flavor '$2'."
+          echo "The allowed values are CoreCLR and Mono."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:RuntimeFlavor=$val"
+      shift 2
+      ;;
+     -librariesconfiguration|-lc)
+      if [ -z ${2+x} ]; then
+        echo "No libraries configuration supplied. See help (--help) for supported libraries configurations." 1>&2
+        exit 1
+      fi
+      passedLibConf="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      case "$passedLibConf" in
+        debug|release)
+          val="$(tr '[:lower:]' '[:upper:]' <<< ${passedLibConf:0:1})${passedLibConf:1}"
+          ;;
+        *)
+          echo "Unsupported libraries configuration '$2'."
+          echo "The allowed values are Debug and Release."
+          exit 1
+          ;;
+      esac
+      arguments="$arguments /p:LibrariesConfiguration=$val"
+      shift 2
+      ;;
+     -cross)
+      crossBuild=1
+      arguments="$arguments /p:CrossBuild=True"
+      shift 1
+      ;;
+     -clang*)
+      compiler="${opt/#-/}" # -clang-9 => clang-9 or clang-9 => (unchanged)
+      arguments="$arguments /p:Compiler=$compiler /p:CppCompilerAndLinker=$compiler"
+      shift 1
+      ;;
+     -cmakeargs)
+      if [ -z ${2+x} ]; then
+        echo "No cmake args supplied." 1>&2
+        exit 1
+      fi
+      cmakeargs="${cmakeargs} $2"
+      shift 2
+      ;;
+     -gcc*)
+      compiler="${opt/#-/}" # -gcc-9 => gcc-9 or gcc-9 => (unchanged)
+      arguments="$arguments /p:Compiler=$compiler /p:CppCompilerAndLinker=$compiler"
+      shift 1
+      ;;
+     -portablebuild)
+      if [ -z ${2+x} ]; then
+        echo "No value for portablebuild is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedPortable="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedPortable" = false ]; then
+        portableBuild=0
+        arguments="$arguments /p:PortableBuild=false"
+      fi
+      shift 2
+      ;;
+     -keepnativesymbols)
+      if [ -z ${2+x} ]; then
+        echo "No value for keepNativeSymbols is supplied. See help (--help) for supported values." 1>&2
+        exit 1
+      fi
+      passedKeepNativeSymbols="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+      if [ "$passedKeepNativeSymbols" = true ]; then
+        arguments="$arguments /p:KeepNativeSymbols=true"
+      fi
+      shift 2
+      ;;
+      -ninja)
+      if [ -z ${2+x} ]; then
+        arguments="$arguments /p:Ninja=true"
+        shift 1
+      else
+        ninja="$(echo "$2" | tr "[:upper:]" "[:lower:]")"
+        if [ "$ninja" = true ]; then
+          arguments="$arguments /p:Ninja=true"
+          shift 2
+        elif [ "$ninja" = false ]; then
+          arguments="$arguments /p:Ninja=false"
+          shift 2
+        else
+          arguments="$arguments /p:Ninja=true"
+          shift 1
+        fi
+      fi
+      ;;
+      -pgoinstrument)
+      arguments="$arguments /p:PgoInstrument=true"
+      shift 1
+      ;;
+      *)
+      extraargs="$extraargs $1"
+      shift 1
+      ;;
+  esac
+done
+if [ ${#actInt[@]} -eq 0 ]; then
+    arguments="-restore -build $arguments"
+fi
+if [[ "$os" == "Browser" && "$arch" != "wasm" ]]; then
+    arch=wasm
+fi
+initDistroRid $os $arch $crossBuild $portableBuild
+export DOTNETSDK_ALLOW_TARGETING_PACK_CACHING=0
+cmakeargs="${cmakeargs// /%20}"
+arguments="$arguments /p:TargetArchitecture=$arch /p:BuildArchitecture=$hostArch"
+arguments="$arguments /p:CMakeArgs=\"$cmakeargs\" $extraargs"
+"$scriptroot/common/build.sh" $arguments

--- a//dev/null
+++ b/eng/common/SetupNugetSources.sh
@@ -0,0 +1,110 @@
+ConfigFile=$1
+CredToken=$2
+NL='\n'
+TB='    '
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ ! -f "$ConfigFile" ]; then
+    Write-PipelineTelemetryError -Category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Couldn't find the NuGet config file: $ConfigFile"
+    ExitWithExitCode 1
+fi
+if [ -z "$CredToken" ]; then
+    Write-PipelineTelemetryError -category 'Build' "Error: Eng/common/SetupNugetSources.sh returned a non-zero exit code. Please supply a valid PAT"
+    ExitWithExitCode 1
+fi
+if [[ `uname -s` == "Darwin" ]]; then
+    NL=$'\\\n'
+    TB=''
+fi
+grep -i "<packageSources>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSources>...</packageSources> section."
+    ConfigNodeHeader="<configuration>"
+    PackageSourcesTemplate="${TB}<packageSources>${NL}${TB}</packageSources>"
+    sed -i.bak "s|$ConfigNodeHeader|$ConfigNodeHeader${NL}$PackageSourcesTemplate|" $ConfigFile
+fi
+grep -i "<packageSourceCredentials>" $ConfigFile
+if [ "$?" != "0" ]; then
+    echo "Adding <packageSourceCredentials>...</packageSourceCredentials> section."
+    PackageSourcesNodeFooter="</packageSources>"
+    PackageSourceCredentialsTemplate="${TB}<packageSourceCredentials>${NL}${TB}</packageSourceCredentials>"
+    sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourcesNodeFooter${NL}$PackageSourceCredentialsTemplate|" $ConfigFile
+fi
+PackageSources=()
+grep -i "<add key=\"dotnet3.1\"" $ConfigFile
+if [ "$?" == "0" ]; then
+    grep -i "<add key=\"dotnet3.1-internal\"" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal')
+    grep -i "<add key=\"dotnet3.1-internal-transport\">" $ConfigFile
+    if [ "$?" != "0" ]; then
+        echo "Adding dotnet3.1-internal-transport to the packageSources."
+        PackageSourcesNodeFooter="</packageSources>"
+        PackageSourceTemplate="${TB}<add key=\"dotnet3.1-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/_packaging/dotnet3.1-internal-transport/nuget/v2\" />"
+        sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+    fi
+    PackageSources+=('dotnet3.1-internal-transport')
+fi
+DotNetVersions=('5' '6' '7')
+for DotNetVersion in ${DotNetVersions[@]} ; do
+    FeedPrefix="dotnet${DotNetVersion}";
+    grep -i "<add key=\"$FeedPrefix\"" $ConfigFile
+    if [ "$?" == "0" ]; then
+        grep -i "<add key=\"$FeedPrefix-internal\"" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal/nuget/v2\" />"
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal")
+        grep -i "<add key=\"$FeedPrefix-internal-transport\">" $ConfigFile
+        if [ "$?" != "0" ]; then
+            echo "Adding $FeedPrefix-internal-transport to the packageSources."
+            PackageSourcesNodeFooter="</packageSources>"
+            PackageSourceTemplate="${TB}<add key=\"$FeedPrefix-internal-transport\" value=\"https://pkgs.dev.azure.com/dnceng/internal/_packaging/$FeedPrefix-internal-transport/nuget/v2\" />"
+            sed -i.bak "s|$PackageSourcesNodeFooter|$PackageSourceTemplate${NL}$PackageSourcesNodeFooter|" $ConfigFile
+        fi
+        PackageSources+=("$FeedPrefix-internal-transport")
+    fi
+done
+PrevIFS=$IFS
+IFS=$'\n'
+PackageSources+="$IFS"
+PackageSources+=$(grep -oh '"darc-int-[^"]*"' $ConfigFile | tr -d '"')
+IFS=$PrevIFS
+for FeedName in ${PackageSources[@]} ; do
+    grep -i "<$FeedName>" $ConfigFile 
+    if [ "$?" != "0" ]; then
+        echo "Adding credentials for $FeedName."
+        PackageSourceCredentialsNodeFooter="</packageSourceCredentials>"
+        NewCredential="${TB}${TB}<$FeedName>${NL}<add key=\"Username\" value=\"dn-bot\" />${NL}<add key=\"ClearTextPassword\" value=\"$CredToken\" />${NL}</$FeedName>"
+        sed -i.bak "s|$PackageSourceCredentialsNodeFooter|$NewCredential${NL}$PackageSourceCredentialsNodeFooter|" $ConfigFile
+    fi
+done
+grep -i "<disabledPackageSources>" $ConfigFile
+if [ "$?" == "0" ]; then
+    DisabledDarcIntSources=()
+    echo "Re-enabling any disabled \"darc-int\" package sources in $ConfigFile"
+    DisabledDarcIntSources+=$(grep -oh '"darc-int-[^"]*" value="true"' $ConfigFile  | tr -d '"')
+    for DisabledSourceName in ${DisabledDarcIntSources[@]} ; do
+        if [[ $DisabledSourceName == darc-int* ]]
+            then
+                OldDisableValue="<add key=\"$DisabledSourceName\" value=\"true\" />"
+                NewDisableValue="<!-- Reenabled for build : $DisabledSourceName -->"
+                sed -i.bak "s|$OldDisableValue|$NewDisableValue|" $ConfigFile
+                echo "Neutralized disablePackageSources entry for '$DisabledSourceName'"
+        fi
+    done
+fi

--- a//dev/null
+++ b/eng/common/build.sh
@@ -0,0 +1,215 @@
+set -u
+set -e
+usage()
+{
+  echo "Common settings:"
+  echo "  --configuration <value>    Build configuration: 'Debug' or 'Release' (short: -c)"
+  echo "  --verbosity <value>        Msbuild verbosity: q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic] (short: -v)"
+  echo "  --binaryLog                Create MSBuild binary log (short: -bl)"
+  echo "  --help                     Print help and exit (short: -h)"
+  echo ""
+  echo "Actions:"
+  echo "  --restore                  Restore dependencies (short: -r)"
+  echo "  --build                    Build solution (short: -b)"
+  echo "  --sourceBuild              Source-build the solution (short: -sb)"
+  echo "                             Will additionally trigger the following actions: --restore, --build, --pack"
+  echo "                             If --configuration is not set explicitly, will also set it to 'Release'"
+  echo "  --rebuild                  Rebuild solution"
+  echo "  --test                     Run all unit tests in the solution (short: -t)"
+  echo "  --integrationTest          Run all integration tests in the solution"
+  echo "  --performanceTest          Run all performance tests in the solution"
+  echo "  --pack                     Package build outputs into NuGet packages and Willow components"
+  echo "  --sign                     Sign build outputs"
+  echo "  --publish                  Publish artifacts (e.g. symbols)"
+  echo "  --clean                    Clean the solution"
+  echo ""
+  echo "Advanced settings:"
+  echo "  --projects <value>       Project or solution file(s) to build"
+  echo "  --ci                     Set when running on CI server"
+  echo "  --excludeCIBinarylog     Don't output binary log (short: -nobl)"
+  echo "  --prepareMachine         Prepare machine for CI run, clean up processes after build"
+  echo "  --nodeReuse <value>      Sets nodereuse msbuild parameter ('true' or 'false')"
+  echo "  --warnAsError <value>    Sets warnaserror msbuild parameter ('true' or 'false')"
+  echo ""
+  echo "Command line arguments not listed above are passed thru to msbuild."
+  echo "Arguments can also be passed in with a single hyphen."
+}
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+restore=false
+build=false
+source_build=false
+rebuild=false
+test=false
+integration_test=false
+performance_test=false
+pack=false
+publish=false
+sign=false
+public=false
+ci=false
+clean=false
+warn_as_error=true
+node_reuse=true
+binary_log=false
+exclude_ci_binary_log=false
+pipelines_log=false
+projects=''
+configuration=''
+prepare_machine=false
+verbosity='minimal'
+runtime_source_feed=''
+runtime_source_feed_key=''
+properties=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -help|-h)
+      usage
+      exit 0
+      ;;
+    -clean)
+      clean=true
+      ;;
+    -configuration|-c)
+      configuration=$2
+      shift
+      ;;
+    -verbosity|-v)
+      verbosity=$2
+      shift
+      ;;
+    -binarylog|-bl)
+      binary_log=true
+      ;;
+    -excludeCIBinarylog|-nobl)
+      exclude_ci_binary_log=true
+      ;;
+    -pipelineslog|-pl)
+      pipelines_log=true
+      ;;
+    -restore|-r)
+      restore=true
+      ;;
+    -build|-b)
+      build=true
+      ;;
+    -rebuild)
+      rebuild=true
+      ;;
+    -pack)
+      pack=true
+      ;;
+    -sourcebuild|-sb)
+      build=true
+      source_build=true
+      restore=true
+      pack=true
+      ;;
+    -test|-t)
+      test=true
+      ;;
+    -integrationtest)
+      integration_test=true
+      ;;
+    -performancetest)
+      performance_test=true
+      ;;
+    -sign)
+      sign=true
+      ;;
+    -publish)
+      publish=true
+      ;;
+    -preparemachine)
+      prepare_machine=true
+      ;;
+    -projects)
+      projects=$2
+      shift
+      ;;
+    -ci)
+      ci=true
+      ;;
+    -warnaserror)
+      warn_as_error=$2
+      shift
+      ;;
+    -nodereuse)
+      node_reuse=$2
+      shift
+      ;;
+    -runtimesourcefeed)
+      runtime_source_feed=$2
+      shift
+      ;;
+     -runtimesourcefeedkey)
+      runtime_source_feed_key=$2
+      shift
+      ;;
+    *)
+      properties="$properties $1"
+      ;;
+  esac
+  shift
+done
+if [[ -z "$configuration" ]]; then
+  if [[ "$source_build" = true ]]; then configuration="Release"; else configuration="Debug"; fi
+fi
+if [[ "$ci" == true ]]; then
+  pipelines_log=true
+  node_reuse=false
+  if [[ "$exclude_ci_binary_log" == false ]]; then
+    binary_log=true
+  fi
+fi
+. "$scriptroot/tools.sh"
+function InitializeCustomToolset {
+  local script="$eng_root/restore-toolset.sh"
+  if [[ -a "$script" ]]; then
+    . "$script"
+  fi
+}
+function Build {
+  InitializeToolset
+  InitializeCustomToolset
+  if [[ ! -z "$projects" ]]; then
+    properties="$properties /p:Projects=$projects"
+  fi
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:\"$log_dir/Build.binlog\""
+  fi
+  MSBuild $_InitializeToolset \
+    $bl \
+    /p:Configuration=$configuration \
+    /p:RepoRoot="$repo_root" \
+    /p:Restore=$restore \
+    /p:Build=$build \
+    /p:ArcadeBuildFromSource=$source_build \
+    /p:Rebuild=$rebuild \
+    /p:Test=$test \
+    /p:Pack=$pack \
+    /p:IntegrationTest=$integration_test \
+    /p:PerformanceTest=$performance_test \
+    /p:Sign=$sign \
+    /p:Publish=$publish \
+    $properties
+  ExitWithExitCode 0
+}
+if [[ "$clean" == true ]]; then
+  if [ -d "$artifacts_dir" ]; then
+    rm -rf $artifacts_dir
+    echo "Artifacts directory deleted."
+  fi
+  exit 0
+fi
+if [[ "$restore" == true ]]; then
+  InitializeNativeTools
+fi
+Build

--- a//dev/null
+++ b/eng/common/cross/arm/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__ARM_HARDFP_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__ARM_HARDFP_CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__ARM_HARDFP_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-arm ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/arm/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR 
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ 
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize arm base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs armv7hl gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs armv7hl lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7hl libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs armv7hl gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/cross/build-rootfs.sh
@@ -0,0 +1,443 @@
+set -e
+usage()
+{
+    echo "Usage: $0 [BuildArch] [CodeName] [lldbx.y] [llvmx[.y]] [--skipunmount] --rootfsdir <directory>]"
+    echo "BuildArch can be: arm(default), arm64, armel, armv6, ppc64le, riscv64, s390x, x64, x86"
+    echo "CodeName - optional, Code name for Linux, can be: xenial(default), zesty, bionic, alpine, alpine3.13 or alpine3.14. If BuildArch is armel, LinuxCodeName is jessie(default) or tizen."
+    echo "                              for FreeBSD can be: freebsd12, freebsd13"
+    echo "                              for illumos can be: illumos"
+    echo "                                for Haiku can be: haiku."
+    echo "lldbx.y - optional, LLDB version, can be: lldb3.9(default), lldb4.0, lldb5.0, lldb6.0 no-lldb. Ignored for alpine and FreeBSD"
+    echo "llvmx[.y] - optional, LLVM version for LLVM related packages."
+    echo "--skipunmount - optional, will skip the unmount of rootfs folder."
+    echo "--use-mirror - optional, use mirror URL to fetch resources, when available."
+    echo "--jobs N - optional, restrict to N jobs."
+    exit 1
+}
+__CodeName=xenial
+__CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__BuildArch=arm
+__AlpineArch=armv7
+__FreeBSDArch=arm
+__FreeBSDMachineArch=armv7
+__IllumosArch=arm7
+__QEMUArch=arm
+__UbuntuArch=armhf
+__UbuntuRepo="http://ports.ubuntu.com/"
+__LLDB_Package="liblldb-3.9-dev"
+__SkipUnmount=0
+__UbuntuPackages="build-essential"
+__AlpinePackages="alpine-base"
+__AlpinePackages+=" build-base"
+__AlpinePackages+=" linux-headers"
+__AlpinePackages+=" lldb-dev"
+__AlpinePackages+=" python3"
+__AlpinePackages+=" libedit"
+__UbuntuPackages+=" symlinks"
+__UbuntuPackages+=" libicu-dev"
+__UbuntuPackages+=" liblttng-ust-dev"
+__UbuntuPackages+=" libunwind8-dev"
+__AlpinePackages+=" gettext-dev"
+__AlpinePackages+=" icu-dev"
+__AlpinePackages+=" libunwind-dev"
+__AlpinePackages+=" lttng-ust-dev"
+__AlpinePackages+=" compiler-rt-static"
+__UbuntuPackages+=" libcurl4-openssl-dev"
+__UbuntuPackages+=" libkrb5-dev"
+__UbuntuPackages+=" libssl-dev"
+__UbuntuPackages+=" zlib1g-dev"
+__AlpinePackages+=" curl-dev"
+__AlpinePackages+=" krb5-dev"
+__AlpinePackages+=" openssl-dev"
+__AlpinePackages+=" zlib-dev"
+__FreeBSDBase="12.3-RELEASE"
+__FreeBSDPkg="1.17.0"
+__FreeBSDABI="12"
+__FreeBSDPackages="libunwind"
+__FreeBSDPackages+=" icu"
+__FreeBSDPackages+=" libinotify"
+__FreeBSDPackages+=" openssl"
+__FreeBSDPackages+=" krb5"
+__FreeBSDPackages+=" terminfo-db"
+__IllumosPackages="icu"
+__IllumosPackages+=" mit-krb5"
+__IllumosPackages+=" openssl"
+__IllumosPackages+=" zlib"
+__HaikuPackages="gmp"
+__HaikuPackages+=" gmp_devel"
+__HaikuPackages+=" krb5"
+__HaikuPackages+=" krb5_devel"
+__HaikuPackages+=" libiconv"
+__HaikuPackages+=" libiconv_devel"
+__HaikuPackages+=" llvm12_libunwind"
+__HaikuPackages+=" llvm12_libunwind_devel"
+__HaikuPackages+=" mpfr"
+__HaikuPackages+=" mpfr_devel"
+__UbuntuPackages+=" libomp5"
+__UbuntuPackages+=" libomp-dev"
+__Keyring=
+__UseMirror=0
+__UnprocessedBuildArgs=
+while :; do
+    if [[ "$#" -le 0 ]]; then
+        break
+    fi
+    lowerI="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+    case $lowerI in
+        -\?|-h|--help)
+            usage
+            exit 1
+            ;;
+        arm)
+            __BuildArch=arm
+            __UbuntuArch=armhf
+            __AlpineArch=armv7
+            __QEMUArch=arm
+            ;;
+        arm64)
+            __BuildArch=arm64
+            __UbuntuArch=arm64
+            __AlpineArch=aarch64
+            __QEMUArch=aarch64
+            __FreeBSDArch=arm64
+            __FreeBSDMachineArch=aarch64
+            ;;
+        armel)
+            __BuildArch=armel
+            __UbuntuArch=armel
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __CodeName=jessie
+            ;;
+        armv6)
+            __BuildArch=armv6
+            __UbuntuArch=armhf
+            __QEMUArch=arm
+            __UbuntuRepo="http://raspbian.raspberrypi.org/raspbian/"
+            __CodeName=buster
+            __LLDB_Package="liblldb-6.0-dev"
+            if [[ -e "/usr/share/keyrings/raspbian-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/raspbian-archive-keyring.gpg"
+            fi
+            ;;
+        ppc64le)
+            __BuildArch=ppc64le
+            __UbuntuArch=ppc64el
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            unset __LLDB_Package
+            ;;
+        riscv64)
+            __BuildArch=riscv64
+            __UbuntuArch=riscv64
+            __UbuntuRepo="http://deb.debian.org/debian-ports"
+            __CodeName=sid
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            unset __LLDB_Package
+            if [[ -e "/usr/share/keyrings/debian-ports-archive-keyring.gpg" ]]; then
+                __Keyring="--keyring /usr/share/keyrings/debian-ports-archive-keyring.gpg --include=debian-ports-archive-keyring"
+            fi
+            ;;
+        s390x)
+            __BuildArch=s390x
+            __UbuntuArch=s390x
+            __UbuntuRepo="http://ports.ubuntu.com/ubuntu-ports/"
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libunwind8-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp-dev//')
+            __UbuntuPackages=$(echo ${__UbuntuPackages} | sed 's/ libomp5//')
+            unset __LLDB_Package
+            ;;
+        x64)
+            __BuildArch=x64
+            __UbuntuArch=amd64
+            __FreeBSDArch=amd64
+            __FreeBSDMachineArch=amd64
+            __illumosArch=x86_64
+            __UbuntuRepo=
+            ;;
+        x86)
+            __BuildArch=x86
+            __UbuntuArch=i386
+            __UbuntuRepo="http://archive.ubuntu.com/ubuntu/"
+            ;;
+        lldb*)
+            version="${lowerI/lldb/}"
+            parts=(${version//./ })
+            if [[ "${parts[0]}" -gt 6 ]]; then
+                version="${parts[0]}"
+            fi
+            __LLDB_Package="liblldb-${version}-dev"
+            ;;
+        no-lldb)
+            unset __LLDB_Package
+            ;;
+        llvm*)
+            version="${lowerI/llvm/}"
+            parts=(${version//./ })
+            __LLVM_MajorVersion="${parts[0]}"
+            __LLVM_MinorVersion="${parts[1]}"
+            if [[ -z "$__LLVM_MinorVersion" && "$__LLVM_MajorVersion" -le 6 ]]; then
+                __LLVM_MinorVersion=0;
+            fi
+            ;;
+        xenial) # Ubuntu 16.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=xenial
+            fi
+            ;;
+        zesty) # Ubuntu 17.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=zesty
+            fi
+            ;;
+        bionic) # Ubuntu 18.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=bionic
+            fi
+            ;;
+        focal) # Ubuntu 20.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=focal
+            fi
+            ;;
+        jammy) # Ubuntu 22.04
+            if [[ "$__CodeName" != "jessie" ]]; then
+                __CodeName=jammy
+            fi
+            ;;
+        jessie) # Debian 8
+            __CodeName=jessie
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            ;;
+        stretch) # Debian 9
+            __CodeName=stretch
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        buster) # Debian 10
+            __CodeName=buster
+            __UbuntuRepo="http://ftp.debian.org/debian/"
+            __LLDB_Package="liblldb-6.0-dev"
+            ;;
+        tizen)
+            __CodeName=
+            __UbuntuRepo=
+            __Tizen=tizen
+            ;;
+        alpine|alpine3.13)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.13
+            __AlpinePackages+=" llvm10-libs"
+            ;;
+        alpine3.14)
+            __CodeName=alpine
+            __UbuntuRepo=
+            __AlpineVersion=3.14
+            __AlpinePackages+=" llvm11-libs"
+            ;;
+        freebsd12)
+            __CodeName=freebsd
+            __SkipUnmount=1
+            ;;
+        freebsd13)
+            __CodeName=freebsd
+            __FreeBSDBase="13.0-RELEASE"
+            __FreeBSDABI="13"
+            __SkipUnmount=1
+            ;;
+        illumos)
+            __CodeName=illumos
+            __SkipUnmount=1
+            ;;
+        haiku)
+            __CodeName=haiku
+            __BuildArch=x64
+            __SkipUnmount=1
+            ;;
+        --skipunmount)
+            __SkipUnmount=1
+            ;;
+        --rootfsdir|-rootfsdir)
+            shift
+            __RootfsDir="$1"
+            ;;
+        --use-mirror)
+            __UseMirror=1
+            ;;
+        --use-jobs)
+            shift
+            MAXJOBS=$1
+            ;;
+        *)
+            __UnprocessedBuildArgs="$__UnprocessedBuildArgs $1"
+            ;;
+    esac
+    shift
+done
+if [[ "$__BuildArch" == "armel" ]]; then
+    __LLDB_Package="lldb-3.5-dev"
+fi
+__UbuntuPackages+=" ${__LLDB_Package:-}"
+if [[ -n "$__LLVM_MajorVersion" ]]; then
+    __UbuntuPackages+=" libclang-common-${__LLVM_MajorVersion}${__LLVM_MinorVersion:+.$__LLVM_MinorVersion}-dev"
+fi
+if [[ -z "$__RootfsDir" && -n "$ROOTFS_DIR" ]]; then
+    __RootfsDir="$ROOTFS_DIR"
+fi
+if [[ -z "$__RootfsDir" ]]; then
+    __RootfsDir="$__CrossDir/../../../.tools/rootfs/$__BuildArch"
+fi
+if [[ -d "$__RootfsDir" ]]; then
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
+    fi
+    rm -rf "$__RootfsDir"
+fi
+mkdir -p "$__RootfsDir"
+__RootfsDir="$( cd "$__RootfsDir" && pwd )"
+if [[ "$__CodeName" == "alpine" ]]; then
+    __ApkToolsVersion=2.9.1
+    __ApkToolsDir="$(mktemp -d)"
+    wget "https://github.com/alpinelinux/apk-tools/releases/download/v$__ApkToolsVersion/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz" -P "$__ApkToolsDir"
+    tar -xf "$__ApkToolsDir/apk-tools-$__ApkToolsVersion-x86_64-linux.tar.gz" -C "$__ApkToolsDir"
+    mkdir -p "$__RootfsDir"/usr/bin
+    cp -v "/usr/bin/qemu-$__QEMUArch-static" "$__RootfsDir/usr/bin"
+    "$__ApkToolsDir/apk-tools-$__ApkToolsVersion/apk" \
+      -X "http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/main" \
+      -X "http://dl-cdn.alpinelinux.org/alpine/v$__AlpineVersion/community" \
+      -U --allow-untrusted --root "$__RootfsDir" --arch "$__AlpineArch" --initdb \
+      add $__AlpinePackages
+    rm -r "$__ApkToolsDir"
+elif [[ "$__CodeName" == "freebsd" ]]; then
+    mkdir -p "$__RootfsDir"/usr/local/etc
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    wget -O - "https://download.freebsd.org/ftp/releases/${__FreeBSDArch}/${__FreeBSDMachineArch}/${__FreeBSDBase}/base.txz" | tar -C "$__RootfsDir" -Jxf - ./lib ./usr/lib ./usr/libdata ./usr/include ./usr/share/keys ./etc ./bin/freebsd-version
+    echo "ABI = \"FreeBSD:${__FreeBSDABI}:${__FreeBSDMachineArch}\"; FINGERPRINTS = \"${__RootfsDir}/usr/share/keys\"; REPOS_DIR = [\"${__RootfsDir}/etc/pkg\"]; REPO_AUTOUPDATE = NO; RUN_SCRIPTS = NO;" > "${__RootfsDir}"/usr/local/etc/pkg.conf
+    echo "FreeBSD: { url: \"pkg+http://pkg.FreeBSD.org/\${ABI}/quarterly\", mirror_type: \"srv\", signature_type: \"fingerprints\", fingerprints: \"${__RootfsDir}/usr/share/keys/pkg\", enabled: yes }" > "${__RootfsDir}"/etc/pkg/FreeBSD.conf
+    mkdir -p "$__RootfsDir"/tmp
+    wget -O - "https://github.com/freebsd/pkg/archive/${__FreeBSDPkg}.tar.gz" | tar -C "$__RootfsDir"/tmp -zxf -
+    cd "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
+    mkdir -p "$__RootfsDir"/host/etc
+    ./autogen.sh && ./configure --prefix="$__RootfsDir"/host && make -j "$JOBS" && make install
+    rm -rf "$__RootfsDir/tmp/pkg-${__FreeBSDPkg}"
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf update
+    INSTALL_AS_USER=$(whoami) "$__RootfsDir"/host/sbin/pkg -r "$__RootfsDir" -C "$__RootfsDir"/usr/local/etc/pkg.conf install --yes $__FreeBSDPackages
+elif [[ "$__CodeName" == "illumos" ]]; then
+    mkdir "$__RootfsDir/tmp"
+    pushd "$__RootfsDir/tmp"
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    echo "Downloading sysroot."
+    wget -O - https://github.com/illumos/sysroot/releases/download/20181213-de6af22ae73b-v1/illumos-sysroot-i386-20181213-de6af22ae73b-v1.tar.gz | tar -C "$__RootfsDir" -xzf -
+    echo "Building binutils. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/binutils/binutils-2.33.1.tar.bz2 | tar -xjf -
+    mkdir build-binutils && cd build-binutils
+    ../binutils-2.33.1/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir"
+    make -j "$JOBS" && make install && cd ..
+    echo "Building gcc. Please wait.."
+    wget -O - https://ftp.gnu.org/gnu/gcc/gcc-8.4.0/gcc-8.4.0.tar.xz | tar -xJf -
+    CFLAGS="-fPIC"
+    CXXFLAGS="-fPIC"
+    CXXFLAGS_FOR_TARGET="-fPIC"
+    CFLAGS_FOR_TARGET="-fPIC"
+    export CFLAGS CXXFLAGS CXXFLAGS_FOR_TARGET CFLAGS_FOR_TARGET
+    mkdir build-gcc && cd build-gcc
+    ../gcc-8.4.0/configure --prefix="$__RootfsDir" --target="${__illumosArch}-sun-solaris2.10" --program-prefix="${__illumosArch}-illumos-" --with-sysroot="$__RootfsDir" --with-gnu-as       \
+        --with-gnu-ld --disable-nls --disable-libgomp --disable-libquadmath --disable-libssp --disable-libvtv --disable-libcilkrts --disable-libada --disable-libsanitizer \
+        --disable-libquadmath-support --disable-shared --enable-tls
+    make -j "$JOBS" && make install && cd ..
+    BaseUrl=https://pkgsrc.joyent.com
+    if [[ "$__UseMirror" == 1 ]]; then
+        BaseUrl=http://pkgsrc.smartos.skylime.net
+    fi
+    BaseUrl="$BaseUrl/packages/SmartOS/trunk/${__illumosArch}/All"
+    echo "Downloading manifest"
+    wget "$BaseUrl"
+    echo "Downloading dependencies."
+    read -ra array <<<"$__IllumosPackages"
+    for package in "${array[@]}"; do
+        echo "Installing '$package'"
+        package="$(grep ">$package-[0-9]" All | sed -En 's/.*href="(.*)\.tgz".*/\1/p')"
+        echo "Resolved name '$package'"
+        wget "$BaseUrl"/"$package".tgz
+        ar -x "$package".tgz
+        tar --skip-old-files -xzf "$package".tmp.tg* -C "$__RootfsDir" 2>/dev/null
+    done
+    echo "Cleaning up temporary files."
+    popd
+    rm -rf "$__RootfsDir"/{tmp,+*}
+    mkdir -p "$__RootfsDir"/usr/include/net
+    mkdir -p "$__RootfsDir"/usr/include/netpacket
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/bpf.h
+    wget -P "$__RootfsDir"/usr/include/net https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/io/bpf/net/dlt.h
+    wget -P "$__RootfsDir"/usr/include/netpacket https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/inet/sockmods/netpacket/packet.h
+    wget -P "$__RootfsDir"/usr/include/sys https://raw.githubusercontent.com/illumos/illumos-gate/master/usr/src/uts/common/sys/sdt.h
+elif [[ "$__CodeName" == "haiku" ]]; then
+    JOBS=${MAXJOBS:="$(getconf _NPROCESSORS_ONLN)"}
+    echo "Building Haiku sysroot for x86_64"
+    mkdir -p "$__RootfsDir/tmp"
+    cd "$__RootfsDir/tmp"
+    git clone -b hrev56235  https://review.haiku-os.org/haiku
+    git clone -b btrev43195 https://review.haiku-os.org/buildtools
+    cd "$__RootfsDir/tmp/buildtools" && git checkout 7487388f5110021d400b9f3b88e1a7f310dc066d
+    cd "$__RootfsDir/tmp/haiku"
+    git fetch origin refs/changes/64/4164/1 && git -c commit.gpgsign=false cherry-pick FETCH_HEAD
+    cd "$__RootfsDir/tmp/buildtools/jam"
+    make
+    echo "Building cross-compiler"
+    mkdir -p "$__RootfsDir/generated"
+    cd "$__RootfsDir/generated"
+    "$__RootfsDir/tmp/haiku/configure" -j"$JOBS" --sysroot "$__RootfsDir" --cross-tools-source "$__RootfsDir/tmp/buildtools" --build-cross-tools x86_64
+    echo "Building Haiku"
+    echo 'HAIKU_BUILD_PROFILE = "development-raw" ;' > UserProfileConfig
+    "$__RootfsDir/tmp/buildtools/jam/jam0" -j"$JOBS" -q '<build>package' '<repository>Haiku'
+    BaseUrl="https://depot.haiku-os.org/__api/v2/pkg/get-pkg"
+    echo "Downloading additional required packages"
+    read -ra array <<<"$__HaikuPackages"
+    for package in "${array[@]}"; do
+        echo "Downloading $package..."
+        hpkgDownloadUrl="$(wget -qO- --post-data='{"name":"'"$package"'","repositorySourceCode":"haikuports_x86_64","versionType":"LATEST","naturalLanguageCode":"en"}' \
+            --header='Content-Type:application/json' "$BaseUrl" | jq -r '.result.versions[].hpkgDownloadURL')"
+        wget -P "$__RootfsDir/generated/download" "$hpkgDownloadUrl"
+    done
+    echo "Setting up sysroot and extracting needed packages"
+    mkdir -p "$__RootfsDir/boot/system"
+    for file in "$__RootfsDir/generated/objects/haiku/x86_64/packaging/packages/"*.hpkg; do
+        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
+    done
+    for file in "$__RootfsDir/generated/download/"*.hpkg; do
+        "$__RootfsDir/generated/objects/linux/x86_64/release/tools/package/package" extract -C "$__RootfsDir/boot/system" "$file"
+    done
+    echo "Cleaning up temporary files"
+    rm -rf "$__RootfsDir/tmp"
+    for name in "$__RootfsDir/generated/"*; do
+        if [[ "$name" =~ "cross-tools-" ]]; then
+            : # Keep the cross-compiler
+        else
+            rm -rf "$name"
+        fi
+    done
+elif [[ -n "$__CodeName" ]]; then
+    qemu-debootstrap $__Keyring --arch "$__UbuntuArch" "$__CodeName" "$__RootfsDir" "$__UbuntuRepo"
+    cp "$__CrossDir/$__BuildArch/sources.list.$__CodeName" "$__RootfsDir/etc/apt/sources.list"
+    chroot "$__RootfsDir" apt-get update
+    chroot "$__RootfsDir" apt-get -f -y install
+    chroot "$__RootfsDir" apt-get -y install $__UbuntuPackages
+    chroot "$__RootfsDir" symlinks -cr /usr
+    chroot "$__RootfsDir" apt-get clean
+    if [[ "$__SkipUnmount" == "0" ]]; then
+        umount "$__RootfsDir"/* || true
+    fi
+    if [[ "$__BuildArch" == "armel" && "$__CodeName" == "jessie" ]]; then
+        pushd "$__RootfsDir"
+        patch -p1 < "$__CrossDir/$__BuildArch/armel.jessie.patch"
+        popd
+    fi
+elif [[ "$__Tizen" == "tizen" ]]; then
+    ROOTFS_DIR="$__RootfsDir" "$__CrossDir/$__BuildArch/tizen-build-rootfs.sh"
+else
+    echo "Unsupported target platform."
+    usage;
+    exit 1
+fi

--- a//dev/null
+++ b/eng/common/cross/x86/tizen-build-rootfs.sh
@@ -0,0 +1,24 @@
+set -e
+__X86_CrossDir=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+__TIZEN_CROSSDIR="$__X86_CrossDir/tizen"
+if [[ -z "$ROOTFS_DIR" ]]; then
+    echo "ROOTFS_DIR is not defined."
+    exit 1;
+fi
+TIZEN_TMP_DIR=$ROOTFS_DIR/tizen_tmp
+mkdir -p $TIZEN_TMP_DIR
+echo ">>Start downloading files"
+VERBOSE=1 $__X86_CrossDir/tizen-fetch.sh $TIZEN_TMP_DIR
+echo "<<Finish downloading files"
+echo ">>Start constructing Tizen rootfs"
+TIZEN_RPM_FILES=`ls $TIZEN_TMP_DIR/*.rpm`
+cd $ROOTFS_DIR
+for f in $TIZEN_RPM_FILES; do
+    rpm2cpio $f  | cpio -idm --quiet
+done
+echo "<<Finish constructing Tizen rootfs"
+rm -rf $TIZEN_TMP_DIR
+echo ">>Start configuring Tizen rootfs"
+ln -sfn asm-x86 ./usr/include/asm
+patch -p1 < $__TIZEN_CROSSDIR/tizen.patch
+echo "<<Finish configuring Tizen rootfs"

--- a//dev/null
+++ b/eng/common/cross/x86/tizen-fetch.sh
@@ -0,0 +1,134 @@
+set -e
+if [[ -z "${VERBOSE// }" ]] || [ "$VERBOSE" -ne "$VERBOSE" ] 2>/dev/null; then
+	VERBOSE=0
+fi
+Log()
+{
+	if [ $VERBOSE -ge $1 ]; then
+		echo ${@:2}
+	fi
+}
+Inform()
+{
+	Log 1 -e "\x1B[0;34m$@\x1B[m"
+}
+Debug()
+{
+	Log 2 -e "\x1B[0;32m$@\x1B[m"
+}
+Error()
+{
+	>&2 Log 0 -e "\x1B[0;31m$@\x1B[m"
+}
+Fetch()
+{
+	URL=$1
+	FILE=$2
+	PROGRESS=$3
+	if [ $VERBOSE -ge 1 ] && [ $PROGRESS ]; then
+		CURL_OPT="--progress-bar"
+	else
+		CURL_OPT="--silent"
+	fi
+	curl $CURL_OPT $URL > $FILE
+}
+hash curl 2> /dev/null || { Error "Require 'curl' Aborting."; exit 1; }
+hash xmllint 2> /dev/null || { Error "Require 'xmllint' Aborting."; exit 1; }
+hash sha256sum 2> /dev/null || { Error "Require 'sha256sum' Aborting."; exit 1; }
+TMPDIR=$1
+if [ ! -d $TMPDIR ]; then
+	TMPDIR=./tizen_tmp
+	Debug "Create temporary directory : $TMPDIR"
+	mkdir -p $TMPDIR 
+fi
+TIZEN_URL=http://download.tizen.org/snapshots/tizen
+BUILD_XML=build.xml
+REPOMD_XML=repomd.xml
+PRIMARY_XML=primary.xml
+TARGET_URL="http://__not_initialized"
+Xpath_get()
+{
+	XPATH_RESULT=''
+	XPATH=$1
+	XML_FILE=$2
+	RESULT=$(xmllint --xpath $XPATH $XML_FILE)
+	if [[ -z ${RESULT// } ]]; then
+		Error "Can not find target from $XML_FILE"
+		Debug "Xpath = $XPATH"
+		exit 1
+	fi
+	XPATH_RESULT=$RESULT
+}
+fetch_tizen_pkgs_init()
+{
+	TARGET=$1
+	PROFILE=$2
+	Debug "Initialize TARGET=$TARGET, PROFILE=$PROFILE"
+	TMP_PKG_DIR=$TMPDIR/tizen_${PROFILE}_pkgs
+	if [ -d $TMP_PKG_DIR ]; then rm -rf $TMP_PKG_DIR; fi
+	mkdir -p $TMP_PKG_DIR
+	PKG_URL=$TIZEN_URL/$PROFILE/latest
+	BUILD_XML_URL=$PKG_URL/$BUILD_XML
+	TMP_BUILD=$TMP_PKG_DIR/$BUILD_XML
+	TMP_REPOMD=$TMP_PKG_DIR/$REPOMD_XML
+	TMP_PRIMARY=$TMP_PKG_DIR/$PRIMARY_XML
+	TMP_PRIMARYGZ=${TMP_PRIMARY}.gz
+	Fetch $BUILD_XML_URL $TMP_BUILD
+	Debug "fetch $BUILD_XML_URL to $TMP_BUILD"
+	TARGET_XPATH="//build/buildtargets/buildtarget[@name=\"$TARGET\"]/repo[@type=\"binary\"]/text()"
+	Xpath_get $TARGET_XPATH $TMP_BUILD
+	TARGET_PATH=$XPATH_RESULT
+	TARGET_URL=$PKG_URL/$TARGET_PATH
+	REPOMD_URL=$TARGET_URL/repodata/repomd.xml
+	PRIMARY_XPATH='string(//*[local-name()="data"][@type="primary"]/*[local-name()="location"]/@href)'
+	Fetch $REPOMD_URL $TMP_REPOMD
+	Debug "fetch $REPOMD_URL to $TMP_REPOMD"
+	Xpath_get $PRIMARY_XPATH $TMP_REPOMD
+	PRIMARY_XML_PATH=$XPATH_RESULT
+	PRIMARY_URL=$TARGET_URL/$PRIMARY_XML_PATH
+	Fetch $PRIMARY_URL $TMP_PRIMARYGZ
+	Debug "fetch $PRIMARY_URL to $TMP_PRIMARYGZ"
+	gunzip $TMP_PRIMARYGZ 
+	Debug "unzip $TMP_PRIMARYGZ to $TMP_PRIMARY" 
+}
+fetch_tizen_pkgs()
+{
+	ARCH=$1
+	PACKAGE_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="location"]/@href)'
+	PACKAGE_CHECKSUM_XPATH_TPL='string(//*[local-name()="metadata"]/*[local-name()="package"][*[local-name()="name"][text()="_PKG_"]][*[local-name()="arch"][text()="_ARCH_"]]/*[local-name()="checksum"]/text())'
+	for pkg in ${@:2}
+	do
+		Inform "Fetching... $pkg"
+		XPATH=${PACKAGE_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		PKG_PATH=$XPATH_RESULT
+		XPATH=${PACKAGE_CHECKSUM_XPATH_TPL/_PKG_/$pkg}
+		XPATH=${XPATH/_ARCH_/$ARCH}
+		Xpath_get $XPATH $TMP_PRIMARY
+		CHECKSUM=$XPATH_RESULT
+		PKG_URL=$TARGET_URL/$PKG_PATH
+		PKG_FILE=$(basename $PKG_PATH)
+		PKG_PATH=$TMPDIR/$PKG_FILE
+		Debug "Download $PKG_URL to $PKG_PATH"
+		Fetch $PKG_URL $PKG_PATH true
+		echo "$CHECKSUM $PKG_PATH" | sha256sum -c - > /dev/null
+		if [ $? -ne 0 ]; then
+			Error "Fail to fetch $PKG_URL to $PKG_PATH"
+			Debug "Checksum = $CHECKSUM"
+			exit 1
+		fi
+	done
+}
+Inform "Initialize i686 base"
+fetch_tizen_pkgs_init standard base
+Inform "fetch common packages"
+fetch_tizen_pkgs i686 gcc gcc-devel-static glibc glibc-devel libicu libicu-devel libatomic linux-glibc-devel keyutils keyutils-devel libkeyutils
+Inform "fetch coreclr packages"
+fetch_tizen_pkgs i686 lldb lldb-devel libgcc libstdc++ libstdc++-devel libunwind libunwind-devel lttng-ust-devel lttng-ust userspace-rcu-devel userspace-rcu
+Inform "fetch corefx packages"
+fetch_tizen_pkgs i686 libcom_err libcom_err-devel zlib zlib-devel libopenssl11 libopenssl1.1-devel krb5 krb5-devel
+Inform "Initialize standard unified"
+fetch_tizen_pkgs_init standard unified
+Inform "fetch corefx packages"
+fetch_tizen_pkgs i686 gssdp gssdp-devel tizen-release

--- a//dev/null
+++ b/eng/common/darc-init.sh
@@ -0,0 +1,66 @@
+source="${BASH_SOURCE[0]}"
+darcVersion=''
+versionEndpoint='https://maestro-prod.westus2.cloudapp.azure.com/api/assets/darc-version?api-version=2019-01-16'
+verbosity='minimal'
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    --darcversion)
+      darcVersion=$2
+      shift
+      ;;
+    --versionendpoint)
+      versionEndpoint=$2
+      shift
+      ;;
+    --verbosity)
+      verbosity=$2
+      shift
+      ;;
+    --toolpath)
+      toolpath=$2
+      shift
+      ;;
+    *)
+      echo "Invalid argument: $1"
+      usage
+      exit 1
+      ;;
+  esac
+  shift
+done
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+if [ -z "$darcVersion" ]; then
+  darcVersion=$(curl -X GET "$versionEndpoint" -H "accept: text/plain")
+fi
+function InstallDarcCli {
+  local darc_cli_package_name="microsoft.dotnet.darc"
+  InitializeDotNetCli true
+  local dotnet_root=$_InitializeDotNetCli
+  if [ -z "$toolpath" ]; then
+    local tool_list=$($dotnet_root/dotnet tool list -g)
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name -g)
+    fi
+  else
+    local tool_list=$($dotnet_root/dotnet tool list --tool-path "$toolpath")
+    if [[ $tool_list = *$darc_cli_package_name* ]]; then
+      echo $($dotnet_root/dotnet tool uninstall $darc_cli_package_name --tool-path "$toolpath")
+    fi
+  fi
+  local arcadeServicesSource="https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json"
+  echo "Installing Darc CLI version $darcVersion..."
+  echo "You may need to restart your command shell if this is the first dotnet tool you have installed."
+  if [ -z "$toolpath" ]; then
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity -g)
+  else
+    echo $($dotnet_root/dotnet tool install $darc_cli_package_name --version $darcVersion --add-source "$arcadeServicesSource" -v $verbosity --tool-path "$toolpath")
+  fi
+}
+InstallDarcCli

--- a//dev/null
+++ b/eng/common/dotnet-install.sh
@@ -0,0 +1,75 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. "$scriptroot/tools.sh"
+version='Latest'
+architecture=''
+runtime='dotnet'
+runtimeSourceFeed=''
+runtimeSourceFeedKey=''
+while [[ $# > 0 ]]; do
+  opt="$(echo "$1" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -version|-v)
+      shift
+      version="$1"
+      ;;
+    -architecture|-a)
+      shift
+      architecture="$1"
+      ;;
+    -runtime|-r)
+      shift
+      runtime="$1"
+      ;;
+    -runtimesourcefeed)
+      shift
+      runtimeSourceFeed="$1"
+      ;;
+    -runtimesourcefeedkey)
+      shift
+      runtimeSourceFeedKey="$1"
+      ;;
+    *)
+      Write-PipelineTelemetryError -Category 'Build' -Message "Invalid argument: $1"
+      exit 1
+      ;;
+  esac
+  shift
+done
+cpuname=$(uname -m)
+case $cpuname in
+  arm64|aarch64)
+    buildarch=arm64
+    ;;
+  loongarch64)
+    buildarch=loongarch64
+    ;;
+  amd64|x86_64)
+    buildarch=x64
+    ;;
+  armv*l)
+    buildarch=arm
+    ;;
+  i[3-6]86)
+    buildarch=x86
+    ;;
+  *)
+    echo "Unknown CPU $cpuname detected, treating it as x64"
+    buildarch=x64
+    ;;
+esac
+dotnetRoot="${repo_root}.dotnet"
+if [[ $architecture != "" ]] && [[ $architecture != $buildarch ]]; then
+  dotnetRoot="$dotnetRoot/$architecture"
+fi
+InstallDotNet $dotnetRoot $version "$architecture" $runtime true $runtimeSourceFeed $runtimeSourceFeedKey || {
+  local exit_code=$?
+  Write-PipelineTelemetryError -Category 'InitializeToolset' -Message "dotnet-install.sh failed (exit code '$exit_code')." >&2
+  ExitWithExitCode $exit_code
+}
+ExitWithExitCode 0

--- a//dev/null
+++ b/eng/common/generate-sbom-prep.sh
@@ -0,0 +1,22 @@
+source="${BASH_SOURCE[0]}"
+while [[ -h $source ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+. $scriptroot/pipeline-logging-functions.sh
+manifest_dir=$1
+if [ ! -d "$manifest_dir" ] ; then
+  mkdir -p "$manifest_dir"
+  echo "Sbom directory created." $manifest_dir
+else
+  Write-PipelineTelemetryError -category 'Build'  "Unable to create sbom folder."
+fi
+artifact_name=$SYSTEM_STAGENAME"_"$AGENT_JOBNAME"_SBOM"
+echo "Artifact name before : "$artifact_name
+safe_artifact_name="${artifact_name//["/:<>\\|?@*$" ]/_}"
+echo "Artifact name after : "$safe_artifact_name
+export ARTIFACT_NAME=$safe_artifact_name
+echo "##vso[task.setvariable variable=ARTIFACT_NAME]$safe_artifact_name"
+exit 0

--- a//dev/null
+++ b/eng/common/init-tools-native.sh
@@ -0,0 +1,192 @@
+source="${BASH_SOURCE[0]}"
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+base_uri='https://netcorenativeassets.blob.core.windows.net/resource-packages/external'
+install_directory=''
+clean=false
+force=false
+download_retries=5
+retry_wait_time_seconds=30
+global_json_file="$(dirname "$(dirname "${scriptroot}")")/global.json"
+declare -a native_assets
+. $scriptroot/pipeline-logging-functions.sh
+. $scriptroot/native/common-library.sh
+while (($# > 0)); do
+  lowerI="$(echo $1 | tr "[:upper:]" "[:lower:]")"
+  case $lowerI in
+    --baseuri)
+      base_uri=$2
+      shift 2
+      ;;
+    --installdirectory)
+      install_directory=$2
+      shift 2
+      ;;
+    --clean)
+      clean=true
+      shift 1
+      ;;
+    --force)
+      force=true
+      shift 1
+      ;;
+    --donotabortonfailure)
+      donotabortonfailure=true
+      shift 1
+      ;;
+    --donotdisplaywarnings)
+      donotdisplaywarnings=true
+      shift 1
+      ;;
+    --downloadretries)
+      download_retries=$2
+      shift 2
+      ;;
+    --retrywaittimeseconds)
+      retry_wait_time_seconds=$2
+      shift 2
+      ;;
+    --help)
+      echo "Common settings:"
+      echo "  --installdirectory                  Directory to install native toolset."
+      echo "                                      This is a command-line override for the default"
+      echo "                                      Install directory precedence order:"
+      echo "                                          - InstallDirectory command-line override"
+      echo "                                          - NETCOREENG_INSTALL_DIRECTORY environment variable"
+      echo "                                          - (default) %USERPROFILE%/.netcoreeng/native"
+      echo ""
+      echo "  --clean                             Switch specifying not to install anything, but cleanup native asset folders"
+      echo "  --donotabortonfailure               Switch specifiying whether to abort native tools installation on failure"
+      echo "  --donotdisplaywarnings              Switch specifiying whether to display warnings during native tools installation on failure"
+      echo "  --force                             Clean and then install tools"
+      echo "  --help                              Print help and exit"
+      echo ""
+      echo "Advanced settings:"
+      echo "  --baseuri <value>                   Base URI for where to download native tools from"
+      echo "  --downloadretries <value>           Number of times a download should be attempted"
+      echo "  --retrywaittimeseconds <value>      Wait time between download attempts"
+      echo ""
+      exit 0
+      ;;
+  esac
+done
+function ReadGlobalJsonNativeTools {
+  if command -v jq &> /dev/null; then
+    while IFS= read -rd '' line; do
+      native_assets+=("$line")
+    done < <(jq -r '. |
+        select(has("native-tools")) |
+        ."native-tools" |
+        keys[] as $k |
+        @sh "KEY=\($k) VALUE=\(.[$k])\u0000"' "$global_json_file")
+    return
+  fi
+  if [[ ! "$(cat "$global_json_file")" =~ \"native-tools\"[[:space:]\:\{]*([^\}]+) ]]; then
+    return
+  fi
+  section="${BASH_REMATCH[1]}"
+  parseStarted=0
+  possibleEnd=0
+  escaping=0
+  escaped=0
+  isKey=1
+  for (( i=0; i<${#section}; i++ )); do
+    char="${section:$i:1}"
+    if ! ((parseStarted)) && [[ "$char" =~ [[:space:],:] ]]; then continue; fi
+    if ! ((escaping)) && [[ "$char" == "\\" ]]; then
+      escaping=1
+    elif ((escaping)) && ! ((escaped)); then
+      escaped=1
+    fi
+    if ! ((parseStarted)) && [[ "$char" == "\"" ]]; then
+      parseStarted=1
+      possibleEnd=0
+    elif [[ "$char" == "'" ]]; then
+      token="$token'\\\''"
+      possibleEnd=0
+    elif ((escaping)) || [[ "$char" != "\"" ]]; then
+      token="$token$char"
+      possibleEnd=1
+    fi
+    if ((possibleEnd)) && ! ((escaping)) && [[ "$char" == "\"" ]]; then
+      printf -v token "'$token'"
+      if ((isKey)); then
+        KEY="$token"
+        isKey=0
+      else
+        line="KEY=$KEY VALUE=$token"
+        native_assets+=("$line")
+        isKey=1
+      fi
+      parseStarted=0
+      token=
+    elif ((escaping)) && ((escaped)); then
+      escaping=0
+      escaped=0
+    fi
+  done
+}
+native_base_dir=$install_directory
+if [[ -z $install_directory ]]; then
+  native_base_dir=$(GetNativeInstallDirectory)
+fi
+install_bin="${native_base_dir}/bin"
+installed_any=false
+ReadGlobalJsonNativeTools
+if [[ ${#native_assets[@]} -eq 0 ]]; then
+  echo "No native tools defined in global.json"
+  exit 0;
+else
+  native_installer_dir="$scriptroot/native"
+  for index in "${!native_assets[@]}"; do
+    eval "${native_assets["$index"]}"
+    installer_path="$native_installer_dir/install-$KEY.sh"
+    installer_command="$installer_path"
+    installer_command+=" --baseuri $base_uri"
+    installer_command+=" --installpath $install_bin"
+    installer_command+=" --version $VALUE"
+    echo $installer_command
+    if [[ $force = true ]]; then
+      installer_command+=" --force"
+    fi
+    if [[ $clean = true ]]; then
+      installer_command+=" --clean"
+    fi
+    if [[ -a $installer_path ]]; then
+      $installer_command
+      if [[ $? != 0 ]]; then
+        if [[ $donotabortonfailure = true ]]; then
+          if [[ $donotdisplaywarnings != true ]]; then
+            Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          fi
+        else
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed"
+          exit 1
+        fi
+      else
+        $installed_any = true
+      fi
+    else
+      if [[ $donotabortonfailure == true ]]; then
+        if [[ $donotdisplaywarnings != true ]]; then
+          Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        fi
+      else
+        Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Execution Failed: no install script"
+        exit 1
+      fi
+    fi
+  done
+fi
+if [[ $clean = true ]]; then
+  exit 0
+fi
+if [[ -d $install_bin ]]; then
+  echo "Native tools are available from $install_bin"
+  echo "##vso[task.prependpath]$install_bin"
+else
+  if [[ $installed_any = true ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Native tools install directory does not exist, installation failed"
+    exit 1
+  fi
+fi
+exit 0

--- a//dev/null
+++ b/eng/common/native/common-library.sh
@@ -0,0 +1,132 @@
+function GetNativeInstallDirectory {
+  local install_dir
+  if [[ -z $NETCOREENG_INSTALL_DIRECTORY ]]; then
+    install_dir=$HOME/.netcoreeng/native/
+  else
+    install_dir=$NETCOREENG_INSTALL_DIRECTORY
+  fi
+  echo $install_dir
+  return 0
+}
+function GetTempDirectory {
+  echo $(GetNativeInstallDirectory)temp/
+  return 0
+}
+function ExpandZip {
+  local zip_path=$1
+  local output_directory=$2
+  local force=${3:-false}
+  echo "Extracting $zip_path to $output_directory"
+  if [[ -d $output_directory ]] && [[ $force = false ]]; then
+    echo "Directory '$output_directory' already exists, skipping extract"
+    return 0
+  fi
+  if [[ -d $output_directory ]]; then
+    echo "'Force flag enabled, but '$output_directory' exists. Removing directory"
+    rm -rf $output_directory
+    if [[ $? != 0 ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to remove '$output_directory'"
+      return 1
+    fi
+  fi
+  echo "Creating directory: '$output_directory'"
+  mkdir -p $output_directory
+  echo "Extracting archive"
+  tar -xf $zip_path -C $output_directory
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Unable to extract '$zip_path'"
+    return 1
+  fi
+  return 0
+}
+function GetCurrentOS {
+  local unameOut="$(uname -s)"
+  case $unameOut in
+    Linux*)     echo "Linux";;
+    Darwin*)    echo "MacOS";;
+  esac
+  return 0
+}
+function GetFile {
+  local uri=$1
+  local path=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  if [[ -f $path ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$path' already exists. Skipping download"
+      return 0
+    else
+      rm -rf $path
+    fi
+  fi
+  if [[ -f $uri ]]; then
+    echo "'$uri' is a file path, copying file to '$path'"
+    cp $uri $path
+    return $?
+  fi
+  echo "Downloading $uri"
+  if command -v curl > /dev/null; then
+    curl "$uri" -sSL --retry $download_retries --retry-delay $retry_wait_time_seconds --create-dirs -o "$path" --fail
+  else
+    wget -q -O "$path" "$uri" --tries="$download_retries"
+  fi
+  return $?
+}
+function GetTempPathFileName {
+  local path=$1
+  local temp_dir=$(GetTempDirectory)
+  local temp_file_name=$(basename $path)
+  echo $temp_dir$temp_file_name
+  return 0
+}
+function DownloadAndExtract {
+  local uri=$1
+  local installDir=$2
+  local force=${3:-false}
+  local download_retries=${4:-5}
+  local retry_wait_time_seconds=${5:-30}
+  local temp_tool_path=$(GetTempPathFileName $uri)
+  echo "downloading to: $temp_tool_path"
+  GetFile "$uri" "$temp_tool_path" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to download '$uri' to '$temp_tool_path'."
+    return 1
+  fi
+  echo "extracting from  $temp_tool_path to $installDir"
+  ExpandZip "$temp_tool_path" "$installDir" $force $download_retries $retry_wait_time_seconds
+  if [[ $? != 0 ]]; then
+    Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Failed to extract '$temp_tool_path' to '$installDir'."
+    return 1
+  fi
+  return 0
+}
+function NewScriptShim {
+  local shimpath=$1
+  local tool_file_path=$2
+  local force=${3:-false}
+  echo "Generating '$shimpath' shim"
+  if [[ -f $shimpath ]]; then
+    if [[ $force = false ]]; then
+      echo "File '$shimpath' already exists." >&2
+      return 1
+    else
+      rm -rf $shimpath
+    fi
+  fi
+  if [[ ! -f $tool_file_path ]]; then
+    tool_file_path="$(echo $tool_file_path | tr "[:upper:]" "[:lower:]")" 
+    if [[ ! -f $tool_file_path ]]; then
+      Write-PipelineTelemetryError -category 'NativeToolsBootstrap' "Specified tool file path:'$tool_file_path' does not exist"
+      return 1
+    fi
+  fi
+  local shim_contents=$'#!/usr/bin/env bash\n'
+  shim_contents+="SHIMARGS="$'$1\n'
+  shim_contents+="$tool_file_path"$' $SHIMARGS\n'
+  echo "$shim_contents" > $shimpath
+  chmod +x $shimpath
+  echo "Finished generating shim '$shimpath'"
+  return $?
+}

--- a//dev/null
+++ b/eng/common/native/init-compiler.sh
@@ -0,0 +1,112 @@
+if [[ "$#" -lt 3 ]]; then
+  echo "Usage..."
+  echo "init-compiler.sh <script directory> <Architecture> <compiler>"
+  echo "Specify the script directory."
+  echo "Specify the target architecture."
+  echo "Specify the name of compiler (clang or gcc)."
+  exit 1
+fi
+nativescriptroot="$1"
+build_arch="$2"
+compiler="$3"
+case "$compiler" in
+    clang*|-clang*|--clang*)
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        parts=(${version//./ })
+        majorVersion="${parts[0]}"
+        minorVersion="${parts[1]}"
+        if [[ -z "$minorVersion" && "$majorVersion" -le 6 ]]; then
+            minorVersion=0;
+        fi
+        compiler=clang
+        ;;
+    gcc*|-gcc*|--gcc*)
+        version="$(echo "$compiler" | tr -d '[:alpha:]-=')"
+        parts=(${version//./ })
+        majorVersion="${parts[0]}"
+        minorVersion="${parts[1]}"
+        compiler=gcc
+        ;;
+esac
+cxxCompiler="$compiler++"
+. "$nativescriptroot"/../pipeline-logging-functions.sh
+CC=
+CXX=
+LDFLAGS=
+if [[ "$compiler" == "gcc" ]]; then cxxCompiler="g++"; fi
+check_version_exists() {
+    desired_version=-1
+    if command -v "$compiler-$1.$2" > /dev/null; then
+        desired_version="-$1.$2"
+    elif command -v "$compiler$1$2" > /dev/null; then
+        desired_version="$1$2"
+    elif command -v "$compiler-$1$2" > /dev/null; then
+        desired_version="-$1$2"
+    fi
+    echo "$desired_version"
+}
+if [[ -z "$CLR_CC" ]]; then
+    if [[ -z "$majorVersion" ]]; then
+        if [[ "$compiler" == "clang" ]]; then versions=( 15 14 13 12 11 10 9 8 7 6.0 5.0 4.0 3.9 3.8 3.7 3.6 3.5 )
+        elif [[ "$compiler" == "gcc" ]]; then versions=( 12 11 10 9 8 7 6 5 4.9 ); fi
+        for version in "${versions[@]}"; do
+            parts=(${version//./ })
+            desired_version="$(check_version_exists "${parts[0]}" "${parts[1]}")"
+            if [[ "$desired_version" != "-1" ]]; then majorVersion="${parts[0]}"; break; fi
+        done
+        if [[ -z "$majorVersion" ]]; then
+            if command -v "$compiler" > /dev/null; then
+                if [[ "$(uname)" != "Darwin" ]]; then
+                    Write-PipelineTelemetryError -category "Build" -type "warning" "Specific version of $compiler not found, falling back to use the one in PATH."
+                fi
+                CC="$(command -v "$compiler")"
+                CXX="$(command -v "$cxxCompiler")"
+            else
+                Write-PipelineTelemetryError -category "Build" "No usable version of $compiler found."
+                exit 1
+            fi
+        else
+            if [[ "$compiler" == "clang" && "$majorVersion" -lt 5 ]]; then
+                if [[ "$build_arch" == "arm" || "$build_arch" == "armel" ]]; then
+                    if command -v "$compiler" > /dev/null; then
+                        Write-PipelineTelemetryError -category "Build" -type "warning" "Found clang version $majorVersion which is not supported on arm/armel architectures, falling back to use clang from PATH."
+                        CC="$(command -v "$compiler")"
+                        CXX="$(command -v "$cxxCompiler")"
+                    else
+                        Write-PipelineTelemetryError -category "Build" "Found clang version $majorVersion which is not supported on arm/armel architectures, and there is no clang in PATH."
+                        exit 1
+                    fi
+                fi
+            fi
+        fi
+    else
+        desired_version="$(check_version_exists "$majorVersion" "$minorVersion")"
+        if [[ "$desired_version" == "-1" ]]; then
+            Write-PipelineTelemetryError -category "Build" "Could not find specific version of $compiler: $majorVersion $minorVersion."
+            exit 1
+        fi
+    fi
+    if [[ -z "$CC" ]]; then
+        CC="$(command -v "$compiler$desired_version")"
+        CXX="$(command -v "$cxxCompiler$desired_version")"
+        if [[ -z "$CXX" ]]; then CXX="$(command -v "$cxxCompiler")"; fi
+    fi
+else
+    if [[ ! -f "$CLR_CC" ]]; then
+        Write-PipelineTelemetryError -category "Build" "CLR_CC is set but path '$CLR_CC' does not exist"
+        exit 1
+    fi
+    CC="$CLR_CC"
+    CXX="$CLR_CXX"
+fi
+if [[ -z "$CC" ]]; then
+    Write-PipelineTelemetryError -category "Build" "Unable to find $compiler."
+    exit 1
+fi
+if [[ "$compiler" == "clang" && "$majorVersion" -ge 9 ]]; then
+    if "$CC" -fuse-ld=lld -Wl,--version >/dev/null 2>&1; then
+        LDFLAGS="-fuse-ld=lld"
+    fi
+fi
+SCAN_BUILD_COMMAND="$(command -v "scan-build$desired_version")"
+export CC CXX LDFLAGS SCAN_BUILD_COMMAND

--- a//dev/null
+++ b/eng/common/tools.sh
@@ -0,0 +1,390 @@
+ci=${ci:-false}
+if [[ "$ci" == true ]]; then
+  pipelines_log=${pipelines_log:-true}
+else
+  pipelines_log=${pipelines_log:-false}
+fi
+configuration=${configuration:-'Debug'}
+exclude_ci_binary_log=${exclude_ci_binary_log:-false}
+if [[ "$ci" == true && "$exclude_ci_binary_log" == false ]]; then
+  binary_log_default=true
+else
+  binary_log_default=false
+fi
+binary_log=${binary_log:-$binary_log_default}
+prepare_machine=${prepare_machine:-false}
+restore=${restore:-true}
+verbosity=${verbosity:-'minimal'}
+if [[ "$ci" == true ]]; then
+  node_reuse=${node_reuse:-false}
+else
+  node_reuse=${node_reuse:-true}
+fi
+warn_as_error=${warn_as_error:-true}
+use_installed_dotnet_cli=${use_installed_dotnet_cli:-true}
+dotnetInstallScriptVersion=${dotnetInstallScriptVersion:-'v1'}
+if [[ "$ci" == true ]]; then
+  use_global_nuget_cache=${use_global_nuget_cache:-false}
+else
+  use_global_nuget_cache=${use_global_nuget_cache:-true}
+fi
+runtime_source_feed=${runtime_source_feed:-''}
+runtime_source_feed_key=${runtime_source_feed_key:-''}
+function ResolvePath {
+  local path=$1
+  while [[ -h $path ]]; do
+    local dir="$( cd -P "$( dirname "$path" )" && pwd )"
+    path="$(readlink "$path")"
+    [[ $path != /* ]] && path="$dir/$path"
+  done
+  _ResolvePath="$path"
+}
+function ReadGlobalVersion {
+  local key=$1
+  if command -v jq &> /dev/null; then
+    _ReadGlobalVersion="$(jq -r ".[] | select(has(\"$key\")) | .\"$key\"" "$global_json_file")"
+  elif [[ "$(cat "$global_json_file")" =~ \"$key\"[[:space:]\:]*\"([^\"]+) ]]; then
+    _ReadGlobalVersion=${BASH_REMATCH[1]}
+  fi
+  if [[ -z "$_ReadGlobalVersion" ]]; then
+    Write-PipelineTelemetryError -category 'Build' "Error: Cannot find \"$key\" in $global_json_file"
+    ExitWithExitCode 1
+  fi
+}
+function InitializeDotNetCli {
+  if [[ -n "${_InitializeDotNetCli:-}" ]]; then
+    return
+  fi
+  local install=$1
+  export DOTNET_MULTILEVEL_LOOKUP=0
+  export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
+  if [[ $ci == true ]]; then
+    export DOTNET_CLI_TELEMETRY_OPTOUT=1
+  fi
+  export LTTNG_HOME="$HOME"
+  if [[ -n "${DotNetCoreSdkDir:-}" ]]; then
+    export DOTNET_INSTALL_DIR="$DotNetCoreSdkDir"
+  fi
+  if [[ "$use_installed_dotnet_cli" == true && $global_json_has_runtimes == false && -z "${DOTNET_INSTALL_DIR:-}" ]]; then
+    local dotnet_path=`command -v dotnet`
+    if [[ -n "$dotnet_path" ]]; then
+      ResolvePath "$dotnet_path"
+      export DOTNET_INSTALL_DIR=`dirname "$_ResolvePath"`
+    fi
+  fi
+  ReadGlobalVersion "dotnet"
+  local dotnet_sdk_version=$_ReadGlobalVersion
+  local dotnet_root=""
+  if [[ $global_json_has_runtimes == false && -n "${DOTNET_INSTALL_DIR:-}" && -d "$DOTNET_INSTALL_DIR/sdk/$dotnet_sdk_version" ]]; then
+    dotnet_root="$DOTNET_INSTALL_DIR"
+  else
+    dotnet_root="$repo_root/.dotnet"
+    export DOTNET_INSTALL_DIR="$dotnet_root"
+    if [[ ! -d "$DOTNET_INSTALL_DIR/sdk/$dotnet_sdk_version" ]]; then
+      if [[ "$install" == true ]]; then
+        InstallDotNetSdk "$dotnet_root" "$dotnet_sdk_version"
+      else
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Unable to find dotnet with SDK version '$dotnet_sdk_version'"
+        ExitWithExitCode 1
+      fi
+    fi
+  fi
+  Write-PipelinePrependPath -path "$dotnet_root"
+  Write-PipelineSetVariable -name "DOTNET_MULTILEVEL_LOOKUP" -value "0"
+  Write-PipelineSetVariable -name "DOTNET_SKIP_FIRST_TIME_EXPERIENCE" -value "1"
+  _InitializeDotNetCli="$dotnet_root"
+}
+function InstallDotNetSdk {
+  local root=$1
+  local version=$2
+  local architecture="unset"
+  if [[ $# -ge 3 ]]; then
+    architecture=$3
+  fi
+  InstallDotNet "$root" "$version" $architecture 'sdk' 'true' $runtime_source_feed $runtime_source_feed_key
+}
+function InstallDotNet {
+  local root=$1
+  local version=$2
+  GetDotNetInstallScript "$root"
+  local install_script=$_GetDotNetInstallScript
+  local installParameters=(--version $version --install-dir "$root")
+  if [[ -n "${3:-}" ]] && [ "$3" != 'unset' ]; then
+    installParameters+=(--architecture $3)
+  fi
+  if [[ -n "${4:-}" ]] && [ "$4" != 'sdk' ]; then
+    installParameters+=(--runtime $4)
+  fi
+  if [[ "$#" -ge "5" ]] && [[ "$5" != 'false' ]]; then
+    installParameters+=(--skip-non-versioned-files)
+  fi
+  local variations=() # list of variable names with parameter arrays in them
+  local public_location=("${installParameters[@]}")
+  variations+=(public_location)
+  local dotnetbuilds=("${installParameters[@]}" --azure-feed "https://dotnetbuilds.azureedge.net/public")
+  variations+=(dotnetbuilds)
+  if [[ -n "${6:-}" ]]; then
+    variations+=(private_feed)
+    local private_feed=("${installParameters[@]}" --azure-feed $6)
+    if [[ -n "${7:-}" ]]; then
+      decodeArg="--decode"
+      if base64 --help 2>&1 | grep -q "BusyBox"; then
+          decodeArg="-d"
+      fi
+      decodedFeedKey=`echo $7 | base64 $decodeArg`
+      private_feed+=(--feed-credential $decodedFeedKey)
+    fi
+  fi
+  local installSuccess=0
+  for variationName in "${variations[@]}"; do
+    local name="$variationName[@]"
+    local variation=("${!name}")
+    echo "Attempting to install dotnet from $variationName."
+    bash "$install_script" "${variation[@]}" && installSuccess=1
+    if [[ "$installSuccess" -eq 1 ]]; then
+      break
+    fi
+    echo "Failed to install dotnet from $variationName."
+  done
+  if [[ "$installSuccess" -eq 0 ]]; then
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to install dotnet SDK from any of the specified locations."
+    ExitWithExitCode 1
+  fi
+}
+function with_retries {
+  local maxRetries=5
+  local retries=1
+  echo "Trying to run '$@' for maximum of $maxRetries attempts."
+  while [[ $((retries++)) -le $maxRetries ]]; do
+    "$@"
+    if [[ $? == 0 ]]; then
+      echo "Ran '$@' successfully."
+      return 0
+    fi
+    timeout=$((3**$retries-1))
+    echo "Failed to execute '$@'. Waiting $timeout seconds before next attempt ($retries out of $maxRetries)." 1>&2
+    sleep $timeout
+  done
+  echo "Failed to execute '$@' for $maxRetries times." 1>&2
+  return 1
+}
+function GetDotNetInstallScript {
+  local root=$1
+  local install_script="$root/dotnet-install.sh"
+  local install_script_url="https://dotnet.microsoft.com/download/dotnet/scripts/$dotnetInstallScriptVersion/dotnet-install.sh"
+  if [[ ! -a "$install_script" ]]; then
+    mkdir -p "$root"
+    echo "Downloading '$install_script_url'"
+    if command -v curl > /dev/null; then
+      curl "$install_script_url" -sSL --retry 10 --create-dirs -o "$install_script" || {
+        if command -v openssl &> /dev/null; then
+          echo "Curl failed; dumping some information about dotnet.microsoft.com for later investigation"
+          echo | openssl s_client -showcerts -servername dotnet.microsoft.com  -connect dotnet.microsoft.com:443
+        fi
+        echo "Will now retry the same URL with verbose logging."
+        with_retries curl "$install_script_url" -sSL --verbose --retry 10 --create-dirs -o "$install_script" || {
+          local exit_code=$?
+          Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
+          ExitWithExitCode $exit_code
+        }
+      }
+    else
+      with_retries wget -v -O "$install_script" "$install_script_url" || {
+        local exit_code=$?
+        Write-PipelineTelemetryError -category 'InitializeToolset' "Failed to acquire dotnet install script (exit code '$exit_code')."
+        ExitWithExitCode $exit_code
+      }
+    fi
+  fi
+  _GetDotNetInstallScript="$install_script"
+}
+function InitializeBuildTool {
+  if [[ -n "${_InitializeBuildTool:-}" ]]; then
+    return
+  fi
+  InitializeDotNetCli $restore
+  _InitializeBuildTool="$_InitializeDotNetCli/dotnet"
+  _InitializeBuildToolCommand="msbuild"
+  _InitializeBuildToolFramework="net7.0"
+}
+function GetNuGetPackageCachePath {
+  if [[ -z ${NUGET_PACKAGES:-} ]]; then
+    if [[ "$use_global_nuget_cache" == true ]]; then
+      export NUGET_PACKAGES="$HOME/.nuget/packages"
+    else
+      export NUGET_PACKAGES="$repo_root/.packages"
+      export RESTORENOCACHE=true
+    fi
+  fi
+  _GetNuGetPackageCachePath=$NUGET_PACKAGES
+}
+function InitializeNativeTools() {
+  if [[ -n "${DisableNativeToolsetInstalls:-}" ]]; then
+    return
+  fi
+  if grep -Fq "native-tools" $global_json_file
+  then
+    local nativeArgs=""
+    if [[ "$ci" == true ]]; then
+      nativeArgs="--installDirectory $tools_dir"
+    fi
+    "$_script_dir/init-tools-native.sh" $nativeArgs
+  fi
+}
+function InitializeToolset {
+  if [[ -n "${_InitializeToolset:-}" ]]; then
+    return
+  fi
+  GetNuGetPackageCachePath
+  ReadGlobalVersion "Microsoft.DotNet.Arcade.Sdk"
+  local toolset_version=$_ReadGlobalVersion
+  local toolset_location_file="$toolset_dir/$toolset_version.txt"
+  if [[ -a "$toolset_location_file" ]]; then
+    local path=`cat "$toolset_location_file"`
+    if [[ -a "$path" ]]; then
+      _InitializeToolset="$path"
+      return
+    fi
+  fi
+  if [[ "$restore" != true ]]; then
+    Write-PipelineTelemetryError -category 'InitializeToolset' "Toolset version $toolset_version has not been restored."
+    ExitWithExitCode 2
+  fi
+  local proj="$toolset_dir/restore.proj"
+  local bl=""
+  if [[ "$binary_log" == true ]]; then
+    bl="/bl:$log_dir/ToolsetRestore.binlog"
+  fi
+  echo '<Project Sdk="Microsoft.DotNet.Arcade.Sdk"/>' > "$proj"
+  MSBuild-Core "$proj" $bl /t:__WriteToolsetLocation /clp:ErrorsOnly\;NoSummary /p:__ToolsetLocationOutputFile="$toolset_location_file"
+  local toolset_build_proj=`cat "$toolset_location_file"`
+  if [[ ! -a "$toolset_build_proj" ]]; then
+    Write-PipelineTelemetryError -category 'Build' "Invalid toolset path: $toolset_build_proj"
+    ExitWithExitCode 3
+  fi
+  _InitializeToolset="$toolset_build_proj"
+}
+function ExitWithExitCode {
+  if [[ "$ci" == true && "$prepare_machine" == true ]]; then
+    StopProcesses
+  fi
+  exit $1
+}
+function StopProcesses {
+  echo "Killing running build processes..."
+  pkill -9 "dotnet" || true
+  pkill -9 "vbcscompiler" || true
+  return 0
+}
+function MSBuild {
+  local args=$@
+  if [[ "$pipelines_log" == true ]]; then
+    InitializeBuildTool
+    InitializeToolset
+    if [[ "$ci" == true ]]; then
+      export NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS=20
+      export NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS=20
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_HANDSHAKE_TIMEOUT_IN_SECONDS" -value "20"
+      Write-PipelineSetVariable -name "NUGET_PLUGIN_REQUEST_TIMEOUT_IN_SECONDS" -value "20"
+      export NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY=true
+      export NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT=6
+      export NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS=1000
+      Write-PipelineSetVariable -name "NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY" -value "true"
+      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_MAX_NETWORK_TRY_COUNT" -value "6"
+      Write-PipelineSetVariable -name "NUGET_EXPERIMENTAL_NETWORK_RETRY_DELAY_MILLISECONDS" -value "1000"
+    fi
+    local toolset_dir="${_InitializeToolset%/*}"
+    local selectedPath=
+    local possiblePaths=()
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/$_InitializeBuildToolFramework/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp2.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.ArcadeLogging.dll" )
+    possiblePaths+=( "$toolset_dir/netcoreapp3.1/Microsoft.DotNet.Arcade.Sdk.dll" )
+    for path in "${possiblePaths[@]}"; do
+      if [[ -f $path ]]; then
+        selectedPath=$path
+        break
+      fi
+    done
+    if [[ -z "$selectedPath" ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Unable to find arcade sdk logger assembly."
+      ExitWithExitCode 1
+    fi
+    args+=( "-logger:$selectedPath" )
+  fi
+  MSBuild-Core ${args[@]}
+}
+function MSBuild-Core {
+  if [[ "$ci" == true ]]; then
+    if [[ "$binary_log" != true && "$exclude_ci_binary_log" != true ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Binary log must be enabled in CI build, or explicitly opted-out from with the -noBinaryLog switch."
+      ExitWithExitCode 1
+    fi
+    if [[ "$node_reuse" == true ]]; then
+      Write-PipelineTelemetryError -category 'Build'  "Node reuse must be disabled in CI build."
+      ExitWithExitCode 1
+    fi
+  fi
+  InitializeBuildTool
+  local warnaserror_switch=""
+  if [[ $warn_as_error == true ]]; then
+    warnaserror_switch="/warnaserror"
+  fi
+  function RunBuildTool {
+    export ARCADE_BUILD_TOOL_COMMAND="$_InitializeBuildTool $@"
+    "$_InitializeBuildTool" "$@" || {
+      local exit_code=$?
+      echo "Build failed with exit code $exit_code. Check errors above."
+      if [[ "$ci" == "true" ]]; then
+        Write-PipelineSetResult -result "Failed" -message "msbuild execution failed."
+        ExitWithExitCode 0
+      else
+        ExitWithExitCode $exit_code
+      fi
+    }
+  }
+  RunBuildTool "$_InitializeBuildToolCommand" /m /nologo /clp:Summary /v:$verbosity /nr:$node_reuse $warnaserror_switch /p:TreatWarningsAsErrors=$warn_as_error /p:ContinuousIntegrationBuild=$ci "$@"
+}
+ResolvePath "${BASH_SOURCE[0]}"
+_script_dir=`dirname "$_ResolvePath"`
+. "$_script_dir/pipeline-logging-functions.sh"
+eng_root=`cd -P "$_script_dir/.." && pwd`
+repo_root=`cd -P "$_script_dir/../.." && pwd`
+repo_root="${repo_root}/"
+artifacts_dir="${repo_root}artifacts"
+toolset_dir="$artifacts_dir/toolset"
+tools_dir="${repo_root}.tools"
+log_dir="$artifacts_dir/log/$configuration"
+temp_dir="$artifacts_dir/tmp/$configuration"
+global_json_file="${repo_root}global.json"
+global_json_has_runtimes=false
+if command -v jq &> /dev/null; then
+  if jq -er '. | select(has("runtimes"))' "$global_json_file" &> /dev/null; then
+    global_json_has_runtimes=true
+  fi
+elif [[ "$(cat "$global_json_file")" =~ \"runtimes\"[[:space:]\:]*\{ ]]; then
+  global_json_has_runtimes=true
+fi
+if [[ -z $HOME ]]; then
+  export HOME="${repo_root}artifacts/.home/"
+  mkdir -p "$HOME"
+fi
+mkdir -p "$toolset_dir"
+mkdir -p "$temp_dir"
+mkdir -p "$log_dir"
+Write-PipelineSetVariable -name "Artifacts" -value "$artifacts_dir"
+Write-PipelineSetVariable -name "Artifacts.Toolset" -value "$toolset_dir"
+Write-PipelineSetVariable -name "Artifacts.Log" -value "$log_dir"
+Write-PipelineSetVariable -name "Temp" -value "$temp_dir"
+Write-PipelineSetVariable -name "TMP" -value "$temp_dir"
+if [ -z "${disable_configure_toolset_import:-}" ]; then
+  configure_toolset_script="$eng_root/configure-toolset.sh"
+  if [[ -a "$configure_toolset_script" ]]; then
+    . "$configure_toolset_script"
+  fi
+fi
+if [[ -n "${useInstalledDotNetCli:-}" ]]; then
+  use_installed_dotnet_cli="$useInstalledDotNetCli"
+fi

--- a//dev/null
+++ b/eng/docker/build-docker-sdk.sh
@@ -0,0 +1,34 @@
+set -u
+set -e
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+imagename="dotnet-sdk-libs-current"
+configuration="Release"
+while [[ $# > 0 ]]; do
+  opt="$(echo "${1/#--/-}" | tr "[:upper:]" "[:lower:]")"
+  case "$opt" in
+    -imagename|-t)
+      imagename=$2
+      shift 2
+      ;;
+    -configuration|-c)
+      configuration=$2
+      shift 2
+      ;;
+    *)
+      shift 1
+      ;;
+  esac
+done
+repo_root=$(git rev-parse --show-toplevel)
+docker_file="$scriptroot/libraries-sdk.linux.Dockerfile"
+docker build --tag $imagename \
+    --build-arg CONFIGURATION=$configuration \
+    --file $docker_file \
+    $repo_root
+exit $?

--- a//dev/null
+++ b/eng/formatting/download-tools.sh
@@ -0,0 +1,30 @@
+set -ue
+source="${BASH_SOURCE[0]}"
+while [[ -h "$source" ]]; do
+  scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+  source="$(readlink "$source")"
+  [[ $source != /* ]] && source="$scriptroot/$source"
+done
+scriptroot="$( cd -P "$( dirname "$source" )" && pwd )"
+function DownloadClangTool {
+    targetPlatform=$(dotnet --info |grep RID:)
+    targetPlatform=${targetPlatform##*RID:* }
+    toolUrl=https://clrjit.blob.core.windows.net/clang-tools/${targetPlatform}/$1
+    toolOutput=$2/$1
+    if [[ ! -x "$toolOutput" ]]; then
+        curl --retry 5 -o "${toolOutput}" "$toolUrl"
+        chmod 751 $toolOutput
+    fi
+    if [[ ! -x "$toolOutput" ]]; then
+        echo "Failed to download $1"
+        exit 1
+    fi
+}
+engFolder="$(cd -P "$( dirname "$scriptroot" )" && pwd )"
+downloadPathFolder="$(cd -P "$( dirname "$engFolder" )" && pwd )/artifacts/tools"
+mkdir -p "$downloadPathFolder"
+. "$scriptroot/../common/tools.sh"
+InitializeDotNetCli true
+DownloadClangTool "clang-format" "$downloadPathFolder"
+DownloadClangTool "clang-tidy" "$downloadPathFolder"
+export PATH=$downloadPathFolder:$PATH

--- a/src/coreclr/inc/clrconfigvalues.h
+++ b//dev/null
@@ -1,539 +0,0 @@
-CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
-CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
-CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
-CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
-CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
-CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
-CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
-CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
-CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
-CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
-CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
-CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
-CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
-CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
-CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
-CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
-CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
-CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
-CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
-CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
-CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
-CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
-CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
-CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
-CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
-CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
-CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
-CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
-CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
-CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
-CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
-#ifdef DACCESS_COMPILE
-CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
-#endif
-CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
-#ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
-#endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
-CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RichDebugInfo, W("RichDebugInfo"), 0, "If non-zero store some additional debug information for each jitted method")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_OutOfProcessSetContext, W("OutOfProcessSetContext"), 0, "If enabled the debugger will not modify thread contexts in-process.  Enabled by default when CET is enabled for the process.")
-CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
-CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
-CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
-#ifdef FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
-#endif // FEATURE_EH_FUNCLETS
-CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
-CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
-#ifdef FEATURE_CONSERVATIVE_GC
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
-#endif
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
-CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
-CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
-CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
-/**
- * This flag allows us to force the runtime to use global allocation context on Windows x86/amd64 instead of thread allocation context just for testing purpose.
- * The flag is unsafe for a subtle reason. Although the access to the g_global_alloc_context is protected under a lock. The implementation of
- * that lock in the JIT helpers are not multi-core safe (in particular, it used and inc instruction without using the LOCK prefix). This is
- * only useful for ad-hoc testing.
- */
-CONFIG_DWORD_INFO(INTERNAL_GCUseGlobalAllocationContext, W("GCUseGlobalAllocationContext"), 0, "Force using the global allocation context for testing only")
-CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
-#if !defined(DEBUG) && !defined(_DEBUG)
-#define INTERNAL_JitEnableNoWayAssert_Default 0
-#else
-#define INTERNAL_JitEnableNoWayAssert_Default 1
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
-CONFIG_DWORD_INFO(INTERNAL_JitThrowOnAssertionFailure, W("JitThrowOnAssertionFailure"), 0, "Throw managed exception on assertion failures during JIT instead of failfast")
-CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
-CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary jit to use")
-CONFIG_STRING_INFO(INTERNAL_JitPath, W("JitPath"), "Full path to primary jit to use")
-#if defined(ALLOW_SXS_JIT)
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative jit to use, will fall back to primary jit.")
-CONFIG_STRING_INFO(INTERNAL_AltJitPath, W("AltJitPath"), "Full path to alternative jit to use")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitOs, W("AltJitOS"), "Sets target OS for AltJit or uses native one by default. Only applicable for ARM/AMR64 at the moment.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
-#endif // defined(ALLOW_SXS_JIT)
-#if defined(FEATURE_STACK_SAMPLING)
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
-#endif // defined(FEATURE_JIT_SAMPLING)
-#if defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
-#endif // defined(ALLOW_SXS_JIT_NGEN)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
-CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
-CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
-#if defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
-#else
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
-#if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
-#define EXTERNAL_FeatureSIMD_Default 1
-#else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-#define EXTERNAL_FeatureSIMD_Default 0
-#endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
-#ifdef FEATURE_MULTICOREJIT
-RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
-#endif
-#ifdef FEATURE_INTERPRETER
-RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
-CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
-#endif
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
-CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
-CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
-CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
-CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
-CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
-CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
-CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
-CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
-CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
-CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
-CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load into currently running process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load into currently running 32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load into currently running 64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM32, W("CORECLR_NOTIFICATION_PROFILERS_ARM32"), "A semi-colon separated list of notification profilers to load into currently running ARM32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM64, W("CORECLR_NOTIFICATION_PROFILERS_ARM64"), "A semi-colon separated list of notification profilers to load into currently running ARM64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
-RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
-CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
-CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
-#ifdef FEATURE_PERFMAP
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to /tmp")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
-#endif
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
-CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
-CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
-CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
-RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPoolForIO, W("ThreadPool_UsePortableThreadPoolForIO"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one for async IO.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
-#ifdef TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
-#else // !TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
-#endif // TARGET_ARM64
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
-#ifdef FEATURE_TIERED_COMPILATION
-#ifdef _DEBUG
-#define TC_BackgroundWorkerTimeoutMs (100)
-#define TC_CallCountThreshold (2)
-#define TC_CallCountingDelayMs (1)
-#define TC_DelaySingleProcMultiplier (2)
-#else // !_DEBUG
-#define TC_BackgroundWorkerTimeoutMs (4000)
-#define TC_CallCountThreshold (30)
-#define TC_CallCountingDelayMs (100)
-#define TC_DelaySingleProcMultiplier (10)
-#endif // _DEBUG
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
-#if defined(TARGET_AMD64) || defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 1, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
-#else // !(defined(TARGET_AMD64) || defined(TARGET_ARM64))
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
-#endif // defined(TARGET_AMD64) || defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), TC_BackgroundWorkerTimeoutMs, "How long in milliseconds the background worker thread may remain idle before exiting.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), TC_CallCountThreshold, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), TC_CallCountingDelayMs, "A perpetual delay in milliseconds that is applied to call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), TC_DelaySingleProcMultiplier, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 0, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
-#undef TC_BackgroundWorkerTimeoutMs
-#undef TC_CallCountThreshold
-#undef TC_CallCountingDelayMs
-#undef TC_DelaySingleProcMultiplier
-#undef TC_DeleteCallCountingStubsAfter
-#endif // FEATURE_TIERED_COMPILATION
-#ifdef FEATURE_ON_STACK_REPLACEMENT
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
-CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
-CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
-#endif
-#ifdef FEATURE_PGO
-RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
-#endif
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
-CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
-#if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
-#endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
-CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
-RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
-RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeEnableStackwalk, W("EventPipeEnableStackwalk"), 1, "Set to 0 to disable collecting stacks for EventPipe events.")
-#ifdef FEATURE_AUTO_TRACE
-RETAIL_CONFIG_DWORD_INFO_EX(INTERNAL_AutoTrace_N_Tracers, W("AutoTrace_N_Tracers"), 0, "", CLRConfig::LookupOptions::ParseIntegerAsBase10)
-RETAIL_CONFIG_STRING_INFO(INTERNAL_AutoTrace_Command, W("AutoTrace_Command"), "")
-#endif // FEATURE_AUTO_TRACE
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeUSec, W("GCGenAnalysisTimeUSec"), 0, "The number of microseconds to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeMSec, W("GCGenAnalysisTimeMSec"), 0, "The number of milliseconds to trigger generational aware analysis")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
-RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 1, "Enable W^X for executable memory.");
-#ifdef FEATURE_GDBJIT
-CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
-#ifdef FEATURE_GDBJIT_FRAME
-RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
-#endif
-#endif
-#if defined(TARGET_LOONGARCH64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  0, "Allows Base+ hardware intrinsics to be disabled")
-#else
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  1, "Allows Base+ hardware intrinsics to be disabled")
-#endif // defined(TARGET_LOONGARCH64)
-#if defined(TARGET_AMD64) || defined(TARGET_X86)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAES,          W("EnableAES"),          1, "Allows AES+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX,          W("EnableAVX"),          1, "Allows AVX+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX2,         W("EnableAVX2"),         1, "Allows AVX2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVXVNNI,      W("EnableAVXVNNI"),      1, "Allows AVX VNNI+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI1,         W("EnableBMI1"),         1, "Allows BMI1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI2,         W("EnableBMI2"),         1, "Allows BMI2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableFMA,          W("EnableFMA"),          1, "Allows FMA+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableLZCNT,        W("EnableLZCNT"),        1, "Allows LZCNT+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePCLMULQDQ,    W("EnablePCLMULQDQ"),    1, "Allows PCLMULQDQ+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableMOVBE,        W("EnableMOVBE"),        1, "Allows MOVBE+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePOPCNT,       W("EnablePOPCNT"),       1, "Allows POPCNT+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE,          W("EnableSSE"),          1, "Allows SSE+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE2,         W("EnableSSE2"),         1, "Allows SSE2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3,         W("EnableSSE3"),         1, "Allows SSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3_4,       W("EnableSSE3_4"),       1, "Allows SSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE41,        W("EnableSSE41"),        1, "Allows SSE4.1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE42,        W("EnableSSE42"),        1, "Allows SSE4.2+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSSE3,        W("EnableSSSE3"),        1, "Allows SSSE3+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableX86Serialize, W("EnableX86Serialize"), 1, "Allows X86Serialize+ hardware intrinsics to be disabled")
-#elif defined(TARGET_ARM64)
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64AdvSimd, W("EnableArm64AdvSimd"), 1, "Allows Arm64 AdvSimd+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Aes,     W("EnableArm64Aes"),     1, "Allows Arm64 Aes+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Atomics, W("EnableArm64Atomics"), 1, "Allows Arm64 Atomics+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Crc32,   W("EnableArm64Crc32"),   1, "Allows Arm64 Crc32+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dczva,   W("EnableArm64Dczva"),   1, "Allows Arm64 Dczva+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dp,      W("EnableArm64Dp"),      1, "Allows Arm64 Dp+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rdm,     W("EnableArm64Rdm"),     1, "Allows Arm64 Rdm+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha1,    W("EnableArm64Sha1"),    1, "Allows Arm64 Sha1+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha256,  W("EnableArm64Sha256"),  1, "Allows Arm64 Sha256+ hardware intrinsics to be disabled")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rcpc,    W("EnableArm64Rcpc"),    1, "Allows Arm64 Rcpc+ hardware intrinsics to be disabled")
-#endif
-CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
-CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
-CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
-CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
-CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
-CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
-CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
-CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
-CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
-CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
-CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
-CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
-CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
-CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
-CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
-CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
-RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
-CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
-CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
-RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
-#ifdef _DEBUG
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
-#endif
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
-RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
-CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")

--- a/src/coreclr/jit/lclvars.cpp
+++ b//dev/null
@@ -1,5963 +0,0 @@
-/*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
-XX                                                                           XX
-XX                           LclVarsInfo                                     XX
-XX                                                                           XX
-XX   The variables to be used by the code generator.                         XX
-XX                                                                           XX
-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
-XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
-*/
-#include "jitpch.h"
-#ifdef _MSC_VER
-#pragma hdrstop
-#endif
-#include "emit.h"
-#include "register_arg_convention.h"
-#include "jitstd/algorithm.h"
-#include "patchpointinfo.h"
-/*****************************************************************************/
-#ifdef DEBUG
-#if DOUBLE_ALIGN
-/* static */
-unsigned Compiler::s_lvaDoubleAlignedProcsCount = 0;
-#endif
-#endif
-/*****************************************************************************/
-void Compiler::lvaInit()
-{
-    /* We haven't allocated stack variables yet */
-    lvaRefCountState = RCS_INVALID;
-    lvaGenericsContextInUse = false;
-    lvaTrackedToVarNumSize = 0;
-    lvaTrackedToVarNum     = nullptr;
-    lvaTrackedFixed = false; // false: We can still add new tracked variables
-    lvaDoneFrameLayout = NO_FRAME_LAYOUT;
-#if !defined(FEATURE_EH_FUNCLETS)
-    lvaShadowSPslotsVar = BAD_VAR_NUM;
-#endif // !FEATURE_EH_FUNCLETS
-    lvaInlinedPInvokeFrameVar = BAD_VAR_NUM;
-    lvaReversePInvokeFrameVar = BAD_VAR_NUM;
-#if FEATURE_FIXED_OUT_ARGS
-    lvaPInvokeFrameRegSaveVar = BAD_VAR_NUM;
-    lvaOutgoingArgSpaceVar    = BAD_VAR_NUM;
-    lvaOutgoingArgSpaceSize   = PhasedVar<unsigned>();
-#endif // FEATURE_FIXED_OUT_ARGS
-#ifdef JIT32_GCENCODER
-    lvaLocAllocSPvar = BAD_VAR_NUM;
-#endif // JIT32_GCENCODER
-    lvaNewObjArrayArgs  = BAD_VAR_NUM;
-    lvaGSSecurityCookie = BAD_VAR_NUM;
-#ifdef TARGET_X86
-    lvaVarargsBaseOfStkArgs = BAD_VAR_NUM;
-#endif // TARGET_X86
-    lvaVarargsHandleArg = BAD_VAR_NUM;
-    lvaStubArgumentVar  = BAD_VAR_NUM;
-    lvaArg0Var          = BAD_VAR_NUM;
-    lvaMonAcquired      = BAD_VAR_NUM;
-    lvaRetAddrVar       = BAD_VAR_NUM;
-    lvaInlineeReturnSpillTemp = BAD_VAR_NUM;
-    gsShadowVarInfo = nullptr;
-#if defined(FEATURE_EH_FUNCLETS)
-    lvaPSPSym = BAD_VAR_NUM;
-#endif
-#if FEATURE_SIMD
-    lvaSIMDInitTempVarNum = BAD_VAR_NUM;
-#endif // FEATURE_SIMD
-    lvaCurEpoch = 0;
-    structPromotionHelper = new (this, CMK_Generic) StructPromotionHelper(this);
-}
-/*****************************************************************************/
-void Compiler::lvaInitTypeRef()
-{
-    /* x86 args look something like this:
-        [this ptr] [hidden return buffer] [declared arguments]* [generic context] [var arg cookie]
-       x64 is closer to the native ABI:
-        [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*
-        (Note: prior to .NET Framework 4.5.1 for Windows 8.1 (but not .NET Framework 4.5.1 "downlevel"),
-        the "hidden return buffer" came before the "this ptr". Now, the "this ptr" comes first. This
-        is different from the C++ order, where the "hidden return buffer" always comes first.)
-       ARM and ARM64 are the same as the current x64 convention:
-        [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*
-       Key difference:
-           The var arg cookie and generic context are swapped with respect to the user arguments
-    */
-    /* Set compArgsCount and compLocalsCount */
-    info.compArgsCount = info.compMethodInfo->args.numArgs;
-    if (!info.compIsStatic)
-    {
-        info.compArgsCount++;
-    }
-    else
-    {
-        info.compThisArg = BAD_VAR_NUM;
-    }
-    info.compILargsCount = info.compArgsCount;
-#ifdef FEATURE_SIMD
-    if (info.compRetNativeType == TYP_STRUCT)
-    {
-        var_types structType = impNormStructType(info.compMethodInfo->args.retTypeClass);
-        info.compRetType     = structType;
-    }
-#endif // FEATURE_SIMD
-    const bool hasRetBuffArg = impMethodInfo_hasRetBuffArg(info.compMethodInfo, info.compCallConv);
-    if (!hasRetBuffArg && varTypeIsStruct(info.compRetNativeType))
-    {
-        CORINFO_CLASS_HANDLE retClsHnd = info.compMethodInfo->args.retTypeClass;
-        Compiler::structPassingKind howToReturnStruct;
-        var_types returnType = getReturnTypeForStruct(retClsHnd, info.compCallConv, &howToReturnStruct);
-        if ((howToReturnStruct == SPK_PrimitiveType) || (howToReturnStruct == SPK_EnclosingType))
-        {
-            assert(returnType != TYP_UNKNOWN);
-            assert(returnType != TYP_STRUCT);
-            info.compRetNativeType = returnType;
-            if ((returnType == TYP_LONG) && (compLongUsed == false))
-            {
-                compLongUsed = true;
-            }
-            else if (((returnType == TYP_FLOAT) || (returnType == TYP_DOUBLE)) && (compFloatingPointUsed == false))
-            {
-                compFloatingPointUsed = true;
-            }
-        }
-    }
-    if (hasRetBuffArg)
-    {
-        info.compArgsCount++;
-    }
-    else
-    {
-        info.compRetBuffArg = BAD_VAR_NUM;
-    }
-    /* There is a 'hidden' cookie pushed last when the
-       calling convention is varargs */
-    if (info.compIsVarArgs)
-    {
-        info.compArgsCount++;
-    }
-    if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
-    {
-        info.compArgsCount++;
-    }
-    else
-    {
-        info.compTypeCtxtArg = BAD_VAR_NUM;
-    }
-    lvaCount = info.compLocalsCount = info.compArgsCount + info.compMethodInfo->locals.numArgs;
-    info.compILlocalsCount = info.compILargsCount + info.compMethodInfo->locals.numArgs;
-    /* Now allocate the variable descriptor table */
-    if (compIsForInlining())
-    {
-        lvaTable    = impInlineInfo->InlinerCompiler->lvaTable;
-        lvaCount    = impInlineInfo->InlinerCompiler->lvaCount;
-        lvaTableCnt = impInlineInfo->InlinerCompiler->lvaTableCnt;
-        return;
-    }
-    lvaTableCnt = lvaCount * 2;
-    if (lvaTableCnt < 16)
-    {
-        lvaTableCnt = 16;
-    }
-    lvaTable         = getAllocator(CMK_LvaTable).allocate<LclVarDsc>(lvaTableCnt);
-    size_t tableSize = lvaTableCnt * sizeof(*lvaTable);
-    memset(lvaTable, 0, tableSize);
-    for (unsigned i = 0; i < lvaTableCnt; i++)
-    {
-        new (&lvaTable[i], jitstd::placement_t()) LclVarDsc(); // call the constructor.
-    }
-    InitVarDscInfo varDscInfo;
-#ifdef TARGET_X86
-    switch (info.compCallConv)
-    {
-        case CorInfoCallConvExtension::Thiscall:
-            varDscInfo.Init(lvaTable, hasRetBuffArg, 1, 0);
-            break;
-        case CorInfoCallConvExtension::C:
-        case CorInfoCallConvExtension::Stdcall:
-        case CorInfoCallConvExtension::CMemberFunction:
-        case CorInfoCallConvExtension::StdcallMemberFunction:
-            varDscInfo.Init(lvaTable, hasRetBuffArg, 0, 0);
-            break;
-        case CorInfoCallConvExtension::Managed:
-        case CorInfoCallConvExtension::Fastcall:
-        case CorInfoCallConvExtension::FastcallMemberFunction:
-        default:
-            varDscInfo.Init(lvaTable, hasRetBuffArg, MAX_REG_ARG, MAX_FLOAT_REG_ARG);
-            break;
-    }
-#else
-    varDscInfo.Init(lvaTable, hasRetBuffArg, MAX_REG_ARG, MAX_FLOAT_REG_ARG);
-#endif
-    lvaInitArgs(&varDscInfo);
-    unsigned                varNum    = varDscInfo.varNum;
-    LclVarDsc*              varDsc    = varDscInfo.varDsc;
-    CORINFO_ARG_LIST_HANDLE localsSig = info.compMethodInfo->locals.args;
-#ifdef TARGET_ARM
-    compHasSplitParam = varDscInfo.hasSplitParam;
-#endif
-    for (unsigned i = 0; i < info.compMethodInfo->locals.numArgs;
-         i++, varNum++, varDsc++, localsSig = info.compCompHnd->getArgNext(localsSig))
-    {
-        CORINFO_CLASS_HANDLE typeHnd;
-        CorInfoTypeWithMod   corInfoTypeWithMod =
-            info.compCompHnd->getArgType(&info.compMethodInfo->locals, localsSig, &typeHnd);
-        CorInfoType corInfoType = strip(corInfoTypeWithMod);
-        lvaInitVarDsc(varDsc, varNum, corInfoType, typeHnd, localsSig, &info.compMethodInfo->locals);
-        if ((corInfoTypeWithMod & CORINFO_TYPE_MOD_PINNED) != 0)
-        {
-            if ((corInfoType == CORINFO_TYPE_CLASS) || (corInfoType == CORINFO_TYPE_BYREF))
-            {
-                JITDUMP("Setting lvPinned for V%02u\n", varNum);
-                varDsc->lvPinned = 1;
-                if (opts.IsOSR())
-                {
-                    varDsc->lvImplicitlyReferenced = 1;
-                }
-            }
-            else
-            {
-                JITDUMP("Ignoring pin for non-GC type V%02u\n", varNum);
-            }
-        }
-        varDsc->lvOnFrame = true; // The final home for this local variable might be our local stack frame
-        if (corInfoType == CORINFO_TYPE_CLASS)
-        {
-            CORINFO_CLASS_HANDLE clsHnd = info.compCompHnd->getArgClass(&info.compMethodInfo->locals, localsSig);
-            lvaSetClass(varNum, clsHnd);
-        }
-    }
-    if ( // If there already exist unsafe buffers, don't mark more structs as unsafe
-        !getNeedsGSSecurityCookie() &&
-        !opts.compDbgEnC && compStressCompile(STRESS_UNSAFE_BUFFER_CHECKS, 25))
-    {
-        setNeedsGSSecurityCookie();
-        compGSReorderStackLayout = true;
-        for (unsigned i = 0; i < lvaCount; i++)
-        {
-            if ((lvaTable[i].lvType == TYP_STRUCT) && compStressCompile(STRESS_GENERIC_VARN, 60))
-            {
-                lvaTable[i].lvIsUnsafeBuffer = true;
-            }
-        }
-    }
-    if (opts.IsOSR())
-    {
-        for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
-        {
-            LclVarDsc* const varDsc = lvaGetDesc(lclNum);
-            varDsc->lvIsOSRLocal    = true;
-            if (info.compPatchpointInfo->IsExposed(lclNum))
-            {
-                JITDUMP("-- V%02u is OSR exposed\n", lclNum);
-                varDsc->lvHasLdAddrOp = 1;
-                if (!varTypeIsStruct(varDsc) && !varTypeIsSIMD(varDsc))
-                {
-                    lvaSetVarAddrExposed(lclNum DEBUGARG(AddressExposedReason::OSR_EXPOSED));
-                }
-                varDsc->lvImplicitlyReferenced = 1;
-            }
-        }
-    }
-    if (getNeedsGSSecurityCookie())
-    {
-        unsigned   dummy         = lvaGrabTempWithImplicitUse(false DEBUGARG("GSCookie dummy"));
-        LclVarDsc* gsCookieDummy = lvaGetDesc(dummy);
-        gsCookieDummy->lvType    = TYP_INT;
-        gsCookieDummy->lvIsTemp  = true; // It is not alive at all, set the flag to prevent zero-init.
-        lvaSetVarDoNotEnregister(dummy DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
-    }
-    lvaAllocOutgoingArgSpaceVar();
-#ifdef DEBUG
-    if (verbose)
-    {
-        lvaTableDump(INITIAL_FRAME_LAYOUT);
-    }
-#endif
-}
-/*****************************************************************************/
-void Compiler::lvaInitArgs(InitVarDscInfo* varDscInfo)
-{
-    compArgSize = 0;
-#if defined(TARGET_ARM) && defined(PROFILING_SUPPORTED)
-    if (compIsProfilerHookNeeded())
-    {
-        codeGen->regSet.rsMaskPreSpillRegArg |= RBM_ARG_REGS;
-    }
-#endif
-    /* Is there a "this" pointer ? */
-    lvaInitThisPtr(varDscInfo);
-    unsigned numUserArgsToSkip = 0;
-    unsigned numUserArgs       = info.compMethodInfo->args.numArgs;
-#if !defined(TARGET_ARM)
-    if (TargetOS::IsWindows && callConvIsInstanceMethodCallConv(info.compCallConv))
-    {
-        assert(numUserArgs >= 1);
-        lvaInitUserArgs(varDscInfo, 0, 1);
-        numUserArgsToSkip++;
-        numUserArgs--;
-        lvaInitRetBuffArg(varDscInfo, false);
-    }
-    else
-#endif
-    {
-        /* If we have a hidden return-buffer parameter, that comes here */
-        lvaInitRetBuffArg(varDscInfo, true);
-    }
-#if USER_ARGS_COME_LAST
-    lvaInitGenericsCtxt(varDscInfo);
-    /* If the method is varargs, process the varargs cookie */
-    lvaInitVarArgsHandle(varDscInfo);
-#endif
-    lvaInitUserArgs(varDscInfo, numUserArgsToSkip, numUserArgs);
-#if !USER_ARGS_COME_LAST
-    lvaInitGenericsCtxt(varDscInfo);
-    /* If the method is varargs, process the varargs cookie */
-    lvaInitVarArgsHandle(varDscInfo);
-#endif
-    noway_assert(varDscInfo->varNum == info.compArgsCount);
-    assert(varDscInfo->intRegArgNum <= MAX_REG_ARG);
-    codeGen->intRegState.rsCalleeRegArgCount   = varDscInfo->intRegArgNum;
-    codeGen->floatRegState.rsCalleeRegArgCount = varDscInfo->floatRegArgNum;
-#if FEATURE_FASTTAILCALL
-    info.compArgStackSize = varDscInfo->stackArgSize;
-#endif // FEATURE_FASTTAILCALL
-    noway_assert((compArgSize % TARGET_POINTER_SIZE) == 0);
-#ifdef TARGET_X86
-    /* We can not pass more than 2^16 dwords as arguments as the "ret"
-       instruction can only pop 2^16 arguments. Could be handled correctly
-       but it will be very difficult for fully interruptible code */
-    if (compArgSize != (size_t)(unsigned short)compArgSize)
-        IMPL_LIMITATION("Too many arguments for the \"ret\" instruction to pop");
-#endif
-}
-/*****************************************************************************/
-void Compiler::lvaInitThisPtr(InitVarDscInfo* varDscInfo)
-{
-    LclVarDsc* varDsc = varDscInfo->varDsc;
-    if (!info.compIsStatic)
-    {
-        varDsc->lvIsParam = 1;
-        varDsc->lvIsPtr   = 1;
-        lvaArg0Var = info.compThisArg = varDscInfo->varNum;
-        noway_assert(info.compThisArg == 0);
-        if (eeIsValueClass(info.compClassHnd))
-        {
-            varDsc->lvType = TYP_BYREF;
-#ifdef FEATURE_SIMD
-            CorInfoType simdBaseJitType = CORINFO_TYPE_UNDEF;
-            var_types   type            = impNormStructType(info.compClassHnd, &simdBaseJitType);
-            if (simdBaseJitType != CORINFO_TYPE_UNDEF)
-            {
-                assert(varTypeIsSIMD(type));
-                varDsc->lvSIMDType = true;
-                varDsc->SetSimdBaseJitType(simdBaseJitType);
-                varDsc->lvExactSize = genTypeSize(type);
-            }
-#endif // FEATURE_SIMD
-        }
-        else
-        {
-            varDsc->lvType = TYP_REF;
-            lvaSetClass(varDscInfo->varNum, info.compClassHnd);
-        }
-        varDsc->lvIsRegArg = 1;
-        noway_assert(varDscInfo->intRegArgNum == 0);
-        varDsc->SetArgReg(genMapRegArgNumToRegNum(varDscInfo->allocRegArg(TYP_INT), varDsc->TypeGet()));
-#if FEATURE_MULTIREG_ARGS
-        varDsc->SetOtherArgReg(REG_NA);
-#endif
-        varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
-#ifdef DEBUG
-        if (verbose)
-        {
-            printf("'this'    passed in register %s\n", getRegName(varDsc->GetArgReg()));
-        }
-#endif
-        compArgSize += TARGET_POINTER_SIZE;
-        varDscInfo->varNum++;
-        varDscInfo->varDsc++;
-    }
-}
-/*****************************************************************************/
-void Compiler::lvaInitRetBuffArg(InitVarDscInfo* varDscInfo, bool useFixedRetBufReg)
-{
-    LclVarDsc* varDsc        = varDscInfo->varDsc;
-    bool       hasRetBuffArg = impMethodInfo_hasRetBuffArg(info.compMethodInfo, info.compCallConv);
-    noway_assert(hasRetBuffArg == varDscInfo->hasRetBufArg);
-    if (hasRetBuffArg)
-    {
-        info.compRetBuffArg = varDscInfo->varNum;
-        varDsc->lvType      = TYP_BYREF;
-        varDsc->lvIsParam   = 1;
-        varDsc->lvIsRegArg  = 0;
-        if (useFixedRetBufReg && hasFixedRetBuffReg())
-        {
-            varDsc->lvIsRegArg = 1;
-            varDsc->SetArgReg(theFixedRetBuffReg());
-        }
-        else if (varDscInfo->canEnreg(TYP_INT))
-        {
-            varDsc->lvIsRegArg     = 1;
-            unsigned retBuffArgNum = varDscInfo->allocRegArg(TYP_INT);
-            varDsc->SetArgReg(genMapIntRegArgNumToRegNum(retBuffArgNum));
-        }
-#if FEATURE_MULTIREG_ARGS
-        varDsc->SetOtherArgReg(REG_NA);
-#endif
-        varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
-#ifdef FEATURE_SIMD
-        if (varTypeIsSIMD(info.compRetType))
-        {
-            varDsc->lvSIMDType = true;
-            CorInfoType simdBaseJitType =
-                getBaseJitTypeAndSizeOfSIMDType(info.compMethodInfo->args.retTypeClass, &varDsc->lvExactSize);
-            varDsc->SetSimdBaseJitType(simdBaseJitType);
-            assert(varDsc->GetSimdBaseType() != TYP_UNKNOWN);
-        }
-#endif // FEATURE_SIMD
-        assert(!varDsc->lvIsRegArg || isValidIntArgReg(varDsc->GetArgReg()));
-#ifdef DEBUG
-        if (varDsc->lvIsRegArg && verbose)
-        {
-            printf("'__retBuf'  passed in register %s\n", getRegName(varDsc->GetArgReg()));
-        }
-#endif
-        /* Update the total argument size, count and varDsc */
-        compArgSize += TARGET_POINTER_SIZE;
-        varDscInfo->varNum++;
-        varDscInfo->varDsc++;
-    }
-}
-void Compiler::lvaInitUserArgs(InitVarDscInfo* varDscInfo, unsigned skipArgs, unsigned takeArgs)
-{
-#if defined(TARGET_X86)
-    if (info.compIsVarArgs)
-    {
-        varDscInfo->maxIntRegArgNum = varDscInfo->intRegArgNum;
-    }
-#elif defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI)
-    varDscInfo->floatRegArgNum = varDscInfo->intRegArgNum;
-#endif // TARGET*
-    CORINFO_ARG_LIST_HANDLE argLst = info.compMethodInfo->args.args;
-    const unsigned argSigLen = info.compMethodInfo->args.numArgs;
-    const int64_t numUserArgs = min(takeArgs, (argSigLen - (int64_t)skipArgs));
-    if (numUserArgs <= 0)
-    {
-        return;
-    }
-#ifdef TARGET_ARM
-    regMaskTP doubleAlignMask = RBM_NONE;
-#endif // TARGET_ARM
-    for (unsigned i = 0; i < skipArgs; i++, argLst = info.compCompHnd->getArgNext(argLst))
-    {
-        ;
-    }
-    for (unsigned i = 0; i < numUserArgs;
-         i++, varDscInfo->varNum++, varDscInfo->varDsc++, argLst = info.compCompHnd->getArgNext(argLst))
-    {
-        LclVarDsc*           varDsc  = varDscInfo->varDsc;
-        CORINFO_CLASS_HANDLE typeHnd = nullptr;
-        CorInfoTypeWithMod corInfoType = info.compCompHnd->getArgType(&info.compMethodInfo->args, argLst, &typeHnd);
-        varDsc->lvIsParam              = 1;
-        lvaInitVarDsc(varDsc, varDscInfo->varNum, strip(corInfoType), typeHnd, argLst, &info.compMethodInfo->args);
-        if (strip(corInfoType) == CORINFO_TYPE_CLASS)
-        {
-            CORINFO_CLASS_HANDLE clsHnd = info.compCompHnd->getArgClass(&info.compMethodInfo->args, argLst);
-            lvaSetClass(varDscInfo->varNum, clsHnd);
-        }
-        var_types argType = mangleVarArgsType(varDsc->TypeGet());
-        var_types origArgType = argType;
-        bool     isSoftFPPreSpill = opts.compUseSoftFP && varTypeIsFloating(varDsc->TypeGet());
-        unsigned argSize          = eeGetArgSize(argLst, &info.compMethodInfo->args);
-        unsigned cSlots =
-            (argSize + TARGET_POINTER_SIZE - 1) / TARGET_POINTER_SIZE; // the total number of slots of this argument
-        bool      isHfaArg = false;
-        var_types hfaType  = TYP_UNDEF;
-        if (((TargetOS::IsUnix && TargetArchitecture::IsArm64) || !info.compIsVarArgs) && !opts.compUseSoftFP)
-        {
-            if (varTypeIsStruct(argType))
-            {
-                hfaType  = GetHfaType(typeHnd);
-                isHfaArg = varTypeIsValidHfaType(hfaType);
-            }
-        }
-        else if (info.compIsVarArgs)
-        {
-            if (TargetOS::IsUnix)
-            {
-                NYI("InitUserArgs for Vararg callee is not yet implemented on non Windows targets.");
-            }
-        }
-        if (isHfaArg)
-        {
-            argType = hfaType; // TODO-Cleanup: remove this assignment and mark `argType` as const.
-            varDsc->SetHfaType(hfaType);
-            cSlots = varDsc->lvHfaSlots();
-        }
-        unsigned cSlotsToEnregister = cSlots;
-#if defined(TARGET_ARM64)
-        if (compFeatureArgSplit())
-        {
-            if (this->info.compIsVarArgs && argType == TYP_STRUCT)
-            {
-                if (varDscInfo->canEnreg(TYP_INT, 1) &&     // The beginning of the struct can go in a register
-                    !varDscInfo->canEnreg(TYP_INT, cSlots)) // The end of the struct can't fit in a register
-                {
-                    cSlotsToEnregister = 1; // Force the split
-                }
-            }
-        }
-#endif // defined(TARGET_ARM64)
-#ifdef TARGET_ARM
-        unsigned cAlign;
-        bool     preSpill = info.compIsVarArgs || isSoftFPPreSpill;
-        switch (origArgType)
-        {
-            case TYP_STRUCT:
-                assert(varDsc->lvSize() == argSize);
-                cAlign = varDsc->lvStructDoubleAlign ? 2 : 1;
-                if (!isHfaArg)
-                {
-                    cSlotsToEnregister = 1; // HFAs must be totally enregistered or not, but other structs can be split.
-                    preSpill           = true;
-                }
-                break;
-            case TYP_DOUBLE:
-            case TYP_LONG:
-                cAlign = 2;
-                break;
-            default:
-                cAlign = 1;
-                break;
-        }
-        if (isRegParamType(argType))
-        {
-            compArgSize += varDscInfo->alignReg(argType, cAlign) * REGSIZE_BYTES;
-        }
-        if (argType == TYP_STRUCT)
-        {
-            if (varDscInfo->canEnreg(TYP_INT, 1) &&       // The beginning of the struct can go in a register
-                !varDscInfo->canEnreg(TYP_INT, cSlots) && // The end of the struct can't fit in a register
-                varDscInfo->existAnyFloatStackArgs())     // There's at least one stack-based FP arg already
-            {
-                varDscInfo->setAllRegArgUsed(TYP_INT); // Prevent all future use of integer registers
-                preSpill = false;                      // This struct won't be prespilled, since it will go on the stack
-            }
-        }
-        if (preSpill)
-        {
-            for (unsigned ix = 0; ix < cSlots; ix++)
-            {
-                if (!varDscInfo->canEnreg(TYP_INT, ix + 1))
-                {
-                    break;
-                }
-                regMaskTP regMask = genMapArgNumToRegMask(varDscInfo->regArgNum(TYP_INT) + ix, TYP_INT);
-                if (cAlign == 2)
-                {
-                    doubleAlignMask |= regMask;
-                }
-                codeGen->regSet.rsMaskPreSpillRegArg |= regMask;
-            }
-        }
-#else // !TARGET_ARM
-#if defined(UNIX_AMD64_ABI)
-        SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR structDesc;
-        if (varTypeIsStruct(argType))
-        {
-            assert(typeHnd != nullptr);
-            eeGetSystemVAmd64PassStructInRegisterDescriptor(typeHnd, &structDesc);
-            if (structDesc.passedInRegisters)
-            {
-                unsigned intRegCount   = 0;
-                unsigned floatRegCount = 0;
-                for (unsigned int i = 0; i < structDesc.eightByteCount; i++)
-                {
-                    if (structDesc.IsIntegralSlot(i))
-                    {
-                        intRegCount++;
-                    }
-                    else if (structDesc.IsSseSlot(i))
-                    {
-                        floatRegCount++;
-                    }
-                    else
-                    {
-                        assert(false && "Invalid eightbyte classification type.");
-                        break;
-                    }
-                }
-                if (intRegCount != 0 && !varDscInfo->canEnreg(TYP_INT, intRegCount))
-                {
-                    structDesc.passedInRegisters = false; // No register to enregister the eightbytes.
-                }
-                if (floatRegCount != 0 && !varDscInfo->canEnreg(TYP_FLOAT, floatRegCount))
-                {
-                    structDesc.passedInRegisters = false; // No register to enregister the eightbytes.
-                }
-            }
-        }
-#endif // UNIX_AMD64_ABI
-#endif // !TARGET_ARM
-        varDsc->lvOnFrame = true;
-        bool canPassArgInRegisters = false;
-#if defined(UNIX_AMD64_ABI)
-        if (varTypeIsStruct(argType))
-        {
-            canPassArgInRegisters = structDesc.passedInRegisters;
-        }
-        else
-#elif defined(TARGET_X86)
-        if (varTypeIsStruct(argType) && isTrivialPointerSizedStruct(typeHnd))
-        {
-            canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, cSlotsToEnregister);
-        }
-        else
-#elif defined(TARGET_LOONGARCH64)
-        uint32_t  floatFlags          = STRUCT_NO_FLOAT_FIELD;
-        var_types argRegTypeInStruct1 = TYP_UNKNOWN;
-        var_types argRegTypeInStruct2 = TYP_UNKNOWN;
-        if ((strip(corInfoType) == CORINFO_TYPE_VALUECLASS) && (argSize <= MAX_PASS_MULTIREG_BYTES))
-        {
-            floatFlags = info.compCompHnd->getLoongArch64PassStructInRegisterFlags(typeHnd);
-        }
-        if ((floatFlags & STRUCT_HAS_FLOAT_FIELDS_MASK) != 0)
-        {
-            assert(varTypeIsStruct(argType));
-            int floatNum = 0;
-            if ((floatFlags & STRUCT_FLOAT_FIELD_ONLY_ONE) != 0)
-            {
-                assert(argSize <= 8);
-                assert(varDsc->lvExactSize <= argSize);
-                floatNum              = 1;
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
-                argRegTypeInStruct1 = (varDsc->lvExactSize == 8) ? TYP_DOUBLE : TYP_FLOAT;
-            }
-            else if ((floatFlags & STRUCT_FLOAT_FIELD_ONLY_TWO) != 0)
-            {
-                floatNum              = 2;
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 2);
-                argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
-                argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
-            }
-            else if ((floatFlags & STRUCT_FLOAT_FIELD_FIRST) != 0)
-            {
-                floatNum              = 1;
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
-                canPassArgInRegisters = canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1);
-                argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
-                argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_LONG : TYP_INT;
-            }
-            else if ((floatFlags & STRUCT_FLOAT_FIELD_SECOND) != 0)
-            {
-                floatNum              = 1;
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
-                canPassArgInRegisters = canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1);
-                argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_LONG : TYP_INT;
-                argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
-            }
-            assert((floatNum == 1) || (floatNum == 2));
-            if (!canPassArgInRegisters)
-            {
-                canPassArgInRegisters = varDscInfo->canEnreg(argType, cSlotsToEnregister);
-                argRegTypeInStruct1 = TYP_UNKNOWN;
-                argRegTypeInStruct2 = TYP_UNKNOWN;
-                if (cSlotsToEnregister == 2)
-                {
-                    if (!canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1))
-                    {
-                        argRegTypeInStruct1   = TYP_I_IMPL;
-                        canPassArgInRegisters = true;
-                    }
-                }
-            }
-        }
-        else
-#endif // defined(TARGET_LOONGARCH64)
-        {
-            canPassArgInRegisters = varDscInfo->canEnreg(argType, cSlotsToEnregister);
-#if defined(TARGET_LOONGARCH64)
-            if (!canPassArgInRegisters && varTypeIsFloating(argType))
-            {
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, cSlotsToEnregister);
-                argType               = canPassArgInRegisters ? TYP_I_IMPL : argType;
-            }
-            if (!canPassArgInRegisters && (cSlots > 1))
-            {
-                canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, 1);
-                argRegTypeInStruct1   = canPassArgInRegisters ? TYP_I_IMPL : TYP_UNKNOWN;
-            }
-#endif
-        }
-        if (canPassArgInRegisters)
-        {
-            /* Another register argument */
-            unsigned firstAllocatedRegArgNum = 0;
-#if FEATURE_MULTIREG_ARGS
-            varDsc->SetOtherArgReg(REG_NA);
-#endif // FEATURE_MULTIREG_ARGS
-#if defined(UNIX_AMD64_ABI)
-            unsigned  secondAllocatedRegArgNum = 0;
-            var_types firstEightByteType       = TYP_UNDEF;
-            var_types secondEightByteType      = TYP_UNDEF;
-            if (varTypeIsStruct(argType))
-            {
-                if (structDesc.eightByteCount >= 1)
-                {
-                    firstEightByteType      = GetEightByteType(structDesc, 0);
-                    firstAllocatedRegArgNum = varDscInfo->allocRegArg(firstEightByteType, 1);
-                }
-            }
-            else
-#elif defined(TARGET_LOONGARCH64)
-            if (argRegTypeInStruct1 != TYP_UNKNOWN)
-            {
-                firstAllocatedRegArgNum = varDscInfo->allocRegArg(argRegTypeInStruct1, 1);
-            }
-            else
-#endif // defined(TARGET_LOONGARCH64)
-            {
-                firstAllocatedRegArgNum = varDscInfo->allocRegArg(argType, cSlots);
-            }
-            if (isHfaArg)
-            {
-                if (varDsc->lvHfaSlots() != 1)
-                {
-                    varDsc->lvIsMultiRegArg = true;
-                }
-            }
-            varDsc->lvIsRegArg = 1;
-#if FEATURE_MULTIREG_ARGS
-#ifdef TARGET_ARM64
-            if (argType == TYP_STRUCT)
-            {
-                varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
-                if (cSlots == 2)
-                {
-                    varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_I_IMPL));
-                    varDsc->lvIsMultiRegArg = true;
-                }
-            }
-#elif defined(UNIX_AMD64_ABI)
-            if (varTypeIsStruct(argType))
-            {
-                varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, firstEightByteType));
-                if (structDesc.eightByteCount >= 2)
-                {
-                    secondEightByteType      = GetEightByteType(structDesc, 1);
-                    secondAllocatedRegArgNum = varDscInfo->allocRegArg(secondEightByteType, 1);
-                    varDsc->lvIsMultiRegArg  = true;
-                }
-                if (secondEightByteType != TYP_UNDEF)
-                {
-                    varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, secondEightByteType));
-                }
-            }
-#elif defined(TARGET_LOONGARCH64)
-            if (argType == TYP_STRUCT)
-            {
-                if (argRegTypeInStruct1 != TYP_UNKNOWN)
-                {
-                    varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, argRegTypeInStruct1));
-                    varDsc->lvIs4Field1 = (genTypeSize(argRegTypeInStruct1) == 4) ? 1 : 0;
-                    if (argRegTypeInStruct2 != TYP_UNKNOWN)
-                    {
-                        unsigned secondAllocatedRegArgNum = varDscInfo->allocRegArg(argRegTypeInStruct2, 1);
-                        varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, argRegTypeInStruct2));
-                        varDsc->lvIs4Field2 = (genTypeSize(argRegTypeInStruct2) == 4) ? 1 : 0;
-                    }
-                    else if (cSlots > 1)
-                    {
-                        varDsc->lvIsSplit = 1;
-                        varDsc->SetOtherArgReg(REG_STK);
-                        varDscInfo->setAllRegArgUsed(argRegTypeInStruct1);
-#if FEATURE_FASTTAILCALL
-                        varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
-#endif
-                    }
-                }
-                else
-                {
-                    varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
-                    if (cSlots == 2)
-                    {
-                        varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_I_IMPL));
-                    }
-                }
-            }
-#else  // ARM32
-            if (varTypeIsStruct(argType))
-            {
-                varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
-            }
-#endif // ARM32
-            else
-#endif // FEATURE_MULTIREG_ARGS
-            {
-                varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, argType));
-            }
-#ifdef TARGET_ARM
-            if (varDsc->TypeGet() == TYP_LONG)
-            {
-                varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_INT));
-            }
-#if FEATURE_FASTTAILCALL
-            if (!varTypeUsesFloatReg(argType))
-            {
-                unsigned firstRegArgNum = genMapIntRegNumToRegArgNum(varDsc->GetArgReg());
-                unsigned lastRegArgNum  = firstRegArgNum + cSlots - 1;
-                if (lastRegArgNum >= varDscInfo->maxIntRegArgNum)
-                {
-                    assert(varDscInfo->stackArgSize == 0);
-                    unsigned numEnregistered = varDscInfo->maxIntRegArgNum - firstRegArgNum;
-                    varDsc->SetStackOffset(-(int)numEnregistered * REGSIZE_BYTES);
-                    varDscInfo->stackArgSize += (cSlots - numEnregistered) * REGSIZE_BYTES;
-                    varDscInfo->hasSplitParam = true;
-                    JITDUMP("set user arg V%02u offset to %d\n", varDscInfo->varNum, varDsc->GetStackOffset());
-                }
-            }
-#endif
-#endif // TARGET_ARM
-#ifdef DEBUG
-            if (verbose)
-            {
-                printf("Arg #%u    passed in register(s) ", varDscInfo->varNum);
-#if defined(UNIX_AMD64_ABI)
-                if (varTypeIsStruct(argType))
-                {
-                    if (firstEightByteType == TYP_UNDEF)
-                    {
-                        printf("firstEightByte: <not used>");
-                    }
-                    else
-                    {
-                        printf("firstEightByte: %s",
-                               getRegName(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, firstEightByteType)));
-                    }
-                    if (secondEightByteType == TYP_UNDEF)
-                    {
-                        printf(", secondEightByte: <not used>");
-                    }
-                    else
-                    {
-                        printf(", secondEightByte: %s",
-                               getRegName(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, secondEightByteType)));
-                    }
-                }
-                else
-#endif // defined(UNIX_AMD64_ABI)
-                {
-                    bool     isFloat   = varTypeUsesFloatReg(argType);
-                    unsigned regArgNum = genMapRegNumToRegArgNum(varDsc->GetArgReg(), argType);
-                    for (unsigned ix = 0; ix < cSlots; ix++, regArgNum++)
-                    {
-                        if (ix > 0)
-                        {
-                            printf(",");
-                        }
-                        if (!isFloat && (regArgNum >= varDscInfo->maxIntRegArgNum)) // a struct has been split between
-                        {
-                            printf(" stack slots:%d", cSlots - ix);
-                            break;
-                        }
-#ifdef TARGET_ARM
-                        if (isFloat)
-                        {
-                            if (argType == TYP_DOUBLE)
-                            {
-                                printf("%s/%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)),
-                                       getRegName(genMapRegArgNumToRegNum(regArgNum + 1, argType)));
-                                assert(ix + 1 < cSlots);
-                                ++ix;
-                                ++regArgNum;
-                            }
-                            else
-                            {
-                                printf("%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)));
-                            }
-                        }
-                        else
-#endif // TARGET_ARM
-                        {
-                            printf("%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)));
-                        }
-                    }
-                }
-                printf("\n");
-            }
-#endif    // DEBUG
-        } // end if (canPassArgInRegisters)
-        else
-        {
-#if defined(TARGET_ARM)
-            varDscInfo->setAllRegArgUsed(argType);
-            if (varTypeUsesFloatReg(argType))
-            {
-                varDscInfo->setAnyFloatStackArgs();
-            }
-#elif defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-            varDscInfo->setAllRegArgUsed(argType);
-#endif // TARGET_XXX
-#if FEATURE_FASTTAILCALL
-#ifdef TARGET_ARM
-            unsigned argAlignment = cAlign * TARGET_POINTER_SIZE;
-#else
-            unsigned argAlignment = eeGetArgSizeAlignment(origArgType, (hfaType == TYP_FLOAT));
-            assert(compMacOsArm64Abi() || ((varDscInfo->stackArgSize % argAlignment) == 0));
-#endif
-            varDscInfo->stackArgSize = roundUp(varDscInfo->stackArgSize, argAlignment);
-            JITDUMP("set user arg V%02u offset to %u\n", varDscInfo->varNum, varDscInfo->stackArgSize);
-            varDsc->SetStackOffset(varDscInfo->stackArgSize);
-            varDscInfo->stackArgSize += argSize;
-#endif // FEATURE_FASTTAILCALL
-        }
-#ifdef UNIX_AMD64_ABI
-        compArgSize += roundUp(argSize, TARGET_POINTER_SIZE);
-#else  // !UNIX_AMD64_ABI
-        compArgSize += argSize;
-#endif // !UNIX_AMD64_ABI
-        if (info.compIsVarArgs || isSoftFPPreSpill)
-        {
-#if defined(TARGET_X86)
-            varDsc->SetStackOffset(compArgSize);
-#else  // !TARGET_X86
-            lvaSetVarAddrExposed(varDscInfo->varNum DEBUGARG(AddressExposedReason::TOO_CONSERVATIVE));
-#endif // !TARGET_X86
-        }
-    }
-    compArgSize = GetOutgoingArgByteSize(compArgSize);
-#ifdef TARGET_ARM
-    if (doubleAlignMask != RBM_NONE)
-    {
-        assert(RBM_ARG_REGS == 0xF);
-        assert((doubleAlignMask & RBM_ARG_REGS) == doubleAlignMask);
-        if (doubleAlignMask != RBM_NONE && doubleAlignMask != RBM_ARG_REGS)
-        {
-            assert((doubleAlignMask == 0b0011) || (doubleAlignMask == 0b1100) ||
-                   (doubleAlignMask == 0b0111) /* || 0b1111 is if'ed out */);
-            bool startsAtR0 = (doubleAlignMask & 1) == 1;
-            bool r2XorR3    = ((codeGen->regSet.rsMaskPreSpillRegArg & RBM_R2) == 0) !=
-                           ((codeGen->regSet.rsMaskPreSpillRegArg & RBM_R3) == 0);
-            if (startsAtR0 && r2XorR3)
-            {
-                codeGen->regSet.rsMaskPreSpillAlign =
-                    (~codeGen->regSet.rsMaskPreSpillRegArg & ~doubleAlignMask) & RBM_ARG_REGS;
-            }
-        }
-    }
-#endif // TARGET_ARM
-}
-/*****************************************************************************/
-void Compiler::lvaInitGenericsCtxt(InitVarDscInfo* varDscInfo)
-{
-    if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
-    {
-        info.compTypeCtxtArg = varDscInfo->varNum;
-        LclVarDsc* varDsc = varDscInfo->varDsc;
-        varDsc->lvIsParam = 1;
-        varDsc->lvType    = TYP_I_IMPL;
-        if (varDscInfo->canEnreg(TYP_I_IMPL))
-        {
-            /* Another register argument */
-            varDsc->lvIsRegArg = 1;
-            varDsc->SetArgReg(genMapRegArgNumToRegNum(varDscInfo->regArgNum(TYP_INT), varDsc->TypeGet()));
-#if FEATURE_MULTIREG_ARGS
-            varDsc->SetOtherArgReg(REG_NA);
-#endif
-            varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
-            varDscInfo->intRegArgNum++;
-#ifdef DEBUG
-            if (verbose)
-            {
-                printf("'GenCtxt'   passed in register %s\n", getRegName(varDsc->GetArgReg()));
-            }
-#endif
-        }
-        else
-        {
-            varDsc->lvOnFrame = true;
-#if FEATURE_FASTTAILCALL
-            varDsc->SetStackOffset(varDscInfo->stackArgSize);
-            varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
-#endif // FEATURE_FASTTAILCALL
-        }
-        compArgSize += TARGET_POINTER_SIZE;
-#if defined(TARGET_X86)
-        if (info.compIsVarArgs)
-            varDsc->SetStackOffset(compArgSize);
-#endif // TARGET_X86
-        varDscInfo->varNum++;
-        varDscInfo->varDsc++;
-    }
-}
-/*****************************************************************************/
-void Compiler::lvaInitVarArgsHandle(InitVarDscInfo* varDscInfo)
-{
-    if (info.compIsVarArgs)
-    {
-        lvaVarargsHandleArg = varDscInfo->varNum;
-        LclVarDsc* varDsc = varDscInfo->varDsc;
-        varDsc->lvType    = TYP_I_IMPL;
-        varDsc->lvIsParam = 1;
-#if defined(TARGET_X86)
-        varDsc->lvImplicitlyReferenced = 1;
-#endif // TARGET_X86
-        lvaSetVarDoNotEnregister(lvaVarargsHandleArg DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
-        assert(mostRecentlyActivePhase == PHASE_PRE_IMPORT);
-        if (varDscInfo->canEnreg(TYP_I_IMPL))
-        {
-            /* Another register argument */
-            unsigned varArgHndArgNum = varDscInfo->allocRegArg(TYP_I_IMPL);
-            varDsc->lvIsRegArg = 1;
-            varDsc->SetArgReg(genMapRegArgNumToRegNum(varArgHndArgNum, TYP_I_IMPL));
-#if FEATURE_MULTIREG_ARGS
-            varDsc->SetOtherArgReg(REG_NA);
-#endif
-            varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
-#ifdef TARGET_ARM
-            for (unsigned ix = varArgHndArgNum; ix < ArrLen(intArgMasks); ix++)
-            {
-                codeGen->regSet.rsMaskPreSpillRegArg |= intArgMasks[ix];
-            }
-#endif // TARGET_ARM
-#ifdef DEBUG
-            if (verbose)
-            {
-                printf("'VarArgHnd' passed in register %s\n", getRegName(varDsc->GetArgReg()));
-            }
-#endif // DEBUG
-        }
-        else
-        {
-            varDsc->lvOnFrame = true;
-#if FEATURE_FASTTAILCALL
-            varDsc->SetStackOffset(varDscInfo->stackArgSize);
-            varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
-#endif // FEATURE_FASTTAILCALL
-        }
-        /* Update the total argument size, count and varDsc */
-        compArgSize += TARGET_POINTER_SIZE;
-        varDscInfo->varNum++;
-        varDscInfo->varDsc++;
-#if defined(TARGET_X86)
-        varDsc->SetStackOffset(compArgSize);
-        lvaVarargsBaseOfStkArgs                  = lvaGrabTemp(false DEBUGARG("Varargs BaseOfStkArgs"));
-        lvaTable[lvaVarargsBaseOfStkArgs].lvType = TYP_I_IMPL;
-#endif // TARGET_X86
-    }
-}
-/*****************************************************************************/
-void Compiler::lvaInitVarDsc(LclVarDsc*              varDsc,
-                             unsigned                varNum,
-                             CorInfoType             corInfoType,
-                             CORINFO_CLASS_HANDLE    typeHnd,
-                             CORINFO_ARG_LIST_HANDLE varList,
-                             CORINFO_SIG_INFO*       varSig)
-{
-    noway_assert(varDsc == lvaGetDesc(varNum));
-    switch (corInfoType)
-    {
-        case CORINFO_TYPE_PTR:
-        case CORINFO_TYPE_BYREF:
-        case CORINFO_TYPE_CLASS:
-        case CORINFO_TYPE_STRING:
-        case CORINFO_TYPE_VAR:
-        case CORINFO_TYPE_REFANY:
-            varDsc->lvIsPtr = 1;
-            break;
-        default:
-            break;
-    }
-    var_types type = JITtype2varType(corInfoType);
-    if (varTypeIsFloating(type))
-    {
-        compFloatingPointUsed = true;
-    }
-    if (typeHnd != NO_CLASS_HANDLE)
-    {
-        varDsc->lvOverlappingFields = StructHasOverlappingFields(info.compCompHnd->getClassAttribs(typeHnd));
-    }
-#if FEATURE_IMPLICIT_BYREFS
-    varDsc->lvIsImplicitByRef = 0;
-#endif // FEATURE_IMPLICIT_BYREFS
-#ifdef TARGET_LOONGARCH64
-    varDsc->lvIs4Field1 = 0;
-    varDsc->lvIs4Field2 = 0;
-    varDsc->lvIsSplit   = 0;
-#endif // TARGET_LOONGARCH64
-    if (GlobalJitOptions::compFeatureHfa)
-    {
-        varDsc->SetHfaType(TYP_UNDEF);
-    }
-    if ((varTypeIsStruct(type)))
-    {
-        lvaSetStruct(varNum, typeHnd, typeHnd != NO_CLASS_HANDLE);
-        if (info.compIsVarArgs)
-        {
-            lvaSetStructUsedAsVarArg(varNum);
-        }
-    }
-    else
-    {
-        varDsc->lvType = type;
-    }
-    if (type == TYP_BOOL)
-    {
-        varDsc->lvIsBoolean = true;
-    }
-#ifdef DEBUG
-    varDsc->SetStackOffset(BAD_STK_OFFS);
-#endif
-#if FEATURE_MULTIREG_ARGS
-    varDsc->SetOtherArgReg(REG_NA);
-#endif // FEATURE_MULTIREG_ARGS
-}
-/*****************************************************************************
- * Returns our internal varNum for a given IL variable.
- * Asserts assume it is called after lvaTable[] has been set up.
- */
-unsigned Compiler::compMapILvarNum(unsigned ILvarNum)
-{
-    noway_assert(ILvarNum < info.compILlocalsCount || ILvarNum > unsigned(ICorDebugInfo::UNKNOWN_ILNUM));
-    unsigned varNum;
-    if (ILvarNum == (unsigned)ICorDebugInfo::VARARGS_HND_ILNUM)
-    {
-        noway_assert(info.compIsVarArgs);
-        varNum = lvaVarargsHandleArg;
-        noway_assert(lvaTable[varNum].lvIsParam);
-    }
-    else if (ILvarNum == (unsigned)ICorDebugInfo::RETBUF_ILNUM)
-    {
-        noway_assert(info.compRetBuffArg != BAD_VAR_NUM);
-        varNum = info.compRetBuffArg;
-    }
-    else if (ILvarNum == (unsigned)ICorDebugInfo::TYPECTXT_ILNUM)
-    {
-        noway_assert(info.compTypeCtxtArg >= 0);
-        varNum = unsigned(info.compTypeCtxtArg);
-    }
-    else if (ILvarNum < info.compILargsCount)
-    {
-        varNum = compMapILargNum(ILvarNum);
-        noway_assert(lvaTable[varNum].lvIsParam);
-    }
-    else if (ILvarNum < info.compILlocalsCount)
-    {
-        unsigned lclNum = ILvarNum - info.compILargsCount;
-        varNum          = info.compArgsCount + lclNum;
-        noway_assert(!lvaTable[varNum].lvIsParam);
-    }
-    else
-    {
-        unreached();
-    }
-    noway_assert(varNum < info.compLocalsCount);
-    return varNum;
-}
-/*****************************************************************************
- * Returns the IL variable number given our internal varNum.
- * Special return values are VARG_ILNUM, RETBUF_ILNUM, TYPECTXT_ILNUM.
- *
- * Returns UNKNOWN_ILNUM if it can't be mapped.
- */
-unsigned Compiler::compMap2ILvarNum(unsigned varNum) const
-{
-    if (compIsForInlining())
-    {
-        return impInlineInfo->InlinerCompiler->compMap2ILvarNum(varNum);
-    }
-    noway_assert(varNum < lvaCount);
-    if (varNum == info.compRetBuffArg)
-    {
-        return (unsigned)ICorDebugInfo::RETBUF_ILNUM;
-    }
-    if (info.compIsVarArgs && varNum == lvaVarargsHandleArg)
-    {
-        return (unsigned)ICorDebugInfo::VARARGS_HND_ILNUM;
-    }
-    if ((info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE) && varNum == (unsigned)info.compTypeCtxtArg)
-    {
-        return (unsigned)ICorDebugInfo::TYPECTXT_ILNUM;
-    }
-#if FEATURE_FIXED_OUT_ARGS
-    if (varNum == lvaOutgoingArgSpaceVar)
-    {
-        return (unsigned)ICorDebugInfo::UNKNOWN_ILNUM; // Cannot be mapped
-    }
-#endif // FEATURE_FIXED_OUT_ARGS
-    if ((info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE) && varNum > (unsigned)info.compTypeCtxtArg)
-    {
-        varNum--;
-    }
-    if (info.compIsVarArgs && varNum > lvaVarargsHandleArg)
-    {
-        varNum--;
-    }
-    /* Is there a hidden argument for the return buffer.
-       Note that this code works because if the RetBuffArg is not present,
-       compRetBuffArg will be BAD_VAR_NUM */
-    if (info.compRetBuffArg != BAD_VAR_NUM && varNum > info.compRetBuffArg)
-    {
-        varNum--;
-    }
-    if (varNum >= info.compLocalsCount)
-    {
-        return (unsigned)ICorDebugInfo::UNKNOWN_ILNUM; // Cannot be mapped
-    }
-    return varNum;
-}
-/*****************************************************************************
- * Returns true if variable "varNum" may be address-exposed.
- */
-bool Compiler::lvaVarAddrExposed(unsigned varNum) const
-{
-    const LclVarDsc* varDsc = lvaGetDesc(varNum);
-    return varDsc->IsAddressExposed();
-}
-/*****************************************************************************
- * Returns true iff variable "varNum" should not be enregistered (or one of several reasons).
- */
-bool Compiler::lvaVarDoNotEnregister(unsigned varNum)
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    return varDsc->lvDoNotEnregister;
-}
-void Compiler::lvSetMinOptsDoNotEnreg()
-{
-    JITDUMP("compEnregLocals() is false, setting doNotEnreg flag for all locals.");
-    assert(!compEnregLocals());
-    for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
-    {
-        lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NoRegVars));
-    }
-}
-/*****************************************************************************
- * Returns the handle to the class of the local variable varNum
- */
-CORINFO_CLASS_HANDLE Compiler::lvaGetStruct(unsigned varNum)
-{
-    const LclVarDsc* varDsc = lvaGetDesc(varNum);
-    return varDsc->GetStructHnd();
-}
-bool Compiler::lvaFieldOffsetCmp::operator()(const lvaStructFieldInfo& field1, const lvaStructFieldInfo& field2)
-{
-    return field1.fldOffset < field2.fldOffset;
-}
-Compiler::StructPromotionHelper::StructPromotionHelper(Compiler* compiler)
-    : compiler(compiler)
-    , structPromotionInfo()
-#ifdef DEBUG
-    , retypedFieldsMap(compiler->getAllocator(CMK_DebugOnly))
-#endif // DEBUG
-{
-}
-bool Compiler::StructPromotionHelper::TryPromoteStructVar(unsigned lclNum)
-{
-    if (CanPromoteStructVar(lclNum))
-    {
-#if 0
-            static int structPromoVarNum = 0;
-            structPromoVarNum++;
-            if (atoi(getenv("structpromovarnumlo")) <= structPromoVarNum && structPromoVarNum <= atoi(getenv("structpromovarnumhi")))
-#endif // 0
-        if (ShouldPromoteStructVar(lclNum))
-        {
-            PromoteStructVar(lclNum);
-            return true;
-        }
-    }
-    return false;
-}
-#ifdef DEBUG
-void Compiler::StructPromotionHelper::CheckRetypedAsScalar(CORINFO_FIELD_HANDLE fieldHnd, var_types requestedType)
-{
-    assert(retypedFieldsMap.Lookup(fieldHnd));
-    assert(retypedFieldsMap[fieldHnd] == requestedType);
-}
-#endif // DEBUG
-bool Compiler::StructPromotionHelper::CanPromoteStructType(CORINFO_CLASS_HANDLE typeHnd)
-{
-    assert(typeHnd != nullptr);
-    if (!compiler->eeIsValueClass(typeHnd))
-    {
-        return false;
-    }
-    if (structPromotionInfo.typeHnd == typeHnd)
-    {
-        return structPromotionInfo.canPromote;
-    }
-    structPromotionInfo = lvaStructPromotionInfo(typeHnd);
-    CLANG_FORMAT_COMMENT_ANCHOR;
-#if defined(FEATURE_SIMD)
-#if defined(TARGET_XARCH)
-    const int MaxOffset = MAX_NumOfFieldsInPromotableStruct * YMM_REGSIZE_BYTES;
-#elif defined(TARGET_ARM64)
-    const int MaxOffset      = MAX_NumOfFieldsInPromotableStruct * FP_REGSIZE_BYTES;
-#endif // defined(TARGET_XARCH) || defined(TARGET_ARM64)
-#else  // !FEATURE_SIMD
-    const int MaxOffset = MAX_NumOfFieldsInPromotableStruct * sizeof(double);
-#endif // !FEATURE_SIMD
-    assert((BYTE)MaxOffset == MaxOffset); // because lvaStructFieldInfo.fldOffset is byte-sized
-    assert((BYTE)MAX_NumOfFieldsInPromotableStruct ==
-           MAX_NumOfFieldsInPromotableStruct); // because lvaStructFieldInfo.fieldCnt is byte-sized
-    bool containsGCpointers = false;
-    COMP_HANDLE compHandle = compiler->info.compCompHnd;
-    unsigned structSize = compHandle->getClassSize(typeHnd);
-    if (structSize > MaxOffset)
-    {
-        return false; // struct is too large
-    }
-    unsigned fieldCnt = compHandle->getClassNumInstanceFields(typeHnd);
-    if (fieldCnt == 0 || fieldCnt > MAX_NumOfFieldsInPromotableStruct)
-    {
-        return false; // struct must have between 1 and MAX_NumOfFieldsInPromotableStruct fields
-    }
-    structPromotionInfo.fieldCnt = (unsigned char)fieldCnt;
-    DWORD typeFlags              = compHandle->getClassAttribs(typeHnd);
-    bool overlappingFields = StructHasOverlappingFields(typeFlags);
-    if (overlappingFields)
-    {
-        return false;
-    }
-    if (StructHasCustomLayout(typeFlags) && compiler->IsHfa(typeHnd))
-    {
-        return false;
-    }
-#ifdef TARGET_ARM
-    unsigned structAlignment = roundUp(compHandle->getClassAlignmentRequirement(typeHnd), TARGET_POINTER_SIZE);
-#endif // TARGET_ARM
-    if (StructHasCustomLayout(typeFlags) && ((typeFlags & CORINFO_FLG_CONTAINS_GC_PTR) == 0))
-    {
-        structPromotionInfo.customLayout = true;
-    }
-    if (StructHasDontDigFieldsFlagSet(typeFlags))
-    {
-        return CanConstructAndPromoteField(&structPromotionInfo);
-    }
-    unsigned fieldsSize = 0;
-    for (BYTE ordinal = 0; ordinal < fieldCnt; ++ordinal)
-    {
-        CORINFO_FIELD_HANDLE fieldHnd       = compHandle->getFieldInClass(typeHnd, ordinal);
-        structPromotionInfo.fields[ordinal] = GetFieldInfo(fieldHnd, ordinal);
-        const lvaStructFieldInfo& fieldInfo = structPromotionInfo.fields[ordinal];
-        noway_assert(fieldInfo.fldOffset < structSize);
-        if (fieldInfo.fldSize == 0)
-        {
-            return false;
-        }
-        if ((fieldInfo.fldOffset % fieldInfo.fldSize) != 0)
-        {
-            return false;
-        }
-        if (varTypeIsGC(fieldInfo.fldType))
-        {
-            containsGCpointers = true;
-        }
-        noway_assert(fieldInfo.fldOffset + fieldInfo.fldSize <= structSize);
-        fieldsSize += fieldInfo.fldSize;
-#ifdef TARGET_ARM
-        if (fieldInfo.fldSize > structAlignment)
-        {
-            return false;
-        }
-#endif // TARGET_ARM
-    }
-    noway_assert((containsGCpointers == false) ||
-                 ((typeFlags & (CORINFO_FLG_CONTAINS_GC_PTR | CORINFO_FLG_BYREF_LIKE)) != 0));
-    assert(!overlappingFields);
-    if (fieldsSize != structSize)
-    {
-        structPromotionInfo.containsHoles = true;
-    }
-    structPromotionInfo.canPromote = true;
-    return true;
-}
-bool Compiler::StructPromotionHelper::CanConstructAndPromoteField(lvaStructPromotionInfo* structPromotionInfo)
-{
-    const CORINFO_CLASS_HANDLE typeHnd    = structPromotionInfo->typeHnd;
-    const COMP_HANDLE          compHandle = compiler->info.compCompHnd;
-    const DWORD                typeFlags  = compHandle->getClassAttribs(typeHnd);
-    if (structPromotionInfo->fieldCnt != 1)
-    {
-        return false;
-    }
-    if ((typeFlags & CORINFO_FLG_CONTAINS_GC_PTR) == 0)
-    {
-        return false;
-    }
-    const unsigned structSize = compHandle->getClassSize(typeHnd);
-    if (structSize != TARGET_POINTER_SIZE)
-    {
-        return false;
-    }
-    assert(!structPromotionInfo->containsHoles);
-    assert(!structPromotionInfo->customLayout);
-    lvaStructFieldInfo& fldInfo = structPromotionInfo->fields[0];
-    fldInfo.fldHnd = compHandle->getFieldInClass(typeHnd, 0);
-    fldInfo.fldTypeHnd = 0;
-    fldInfo.fldOffset  = 0;
-    fldInfo.fldOrdinal = 0;
-    fldInfo.fldSize    = TARGET_POINTER_SIZE;
-    fldInfo.fldType    = TYP_REF;
-    structPromotionInfo->canPromote = true;
-    return true;
-}
-bool Compiler::StructPromotionHelper::CanPromoteStructVar(unsigned lclNum)
-{
-    LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
-    assert(varTypeIsStruct(varDsc));
-    assert(!varDsc->lvPromoted); // Don't ask again :)
-    if (varDsc->lvIsUsedInSIMDIntrinsic())
-    {
-        JITDUMP("  struct promotion of V%02u is disabled because lvIsUsedInSIMDIntrinsic()\n", lclNum);
-        return false;
-    }
-    if (varDsc->lvIsParam && compiler->compGSReorderStackLayout)
-    {
-        JITDUMP("  struct promotion of V%02u is disabled because lvIsParam and compGSReorderStackLayout\n", lclNum);
-        return false;
-    }
-    if (!compiler->lvaEnregMultiRegVars && varDsc->lvIsMultiRegArgOrRet())
-    {
-        JITDUMP("  struct promotion of V%02u is disabled because lvIsMultiRegArgOrRet()\n", lclNum);
-        return false;
-    }
-    if (compiler->lvaIsOSRLocal(lclNum) && compiler->info.compPatchpointInfo->IsExposed(lclNum))
-    {
-        JITDUMP("  struct promotion of V%02u is disabled because it is an exposed OSR local\n", lclNum);
-        return false;
-    }
-    CORINFO_CLASS_HANDLE typeHnd = varDsc->GetStructHnd();
-    assert(typeHnd != NO_CLASS_HANDLE);
-    bool canPromote = CanPromoteStructType(typeHnd);
-    if (canPromote && varDsc->lvIsMultiRegArgOrRet())
-    {
-        unsigned fieldCnt = structPromotionInfo.fieldCnt;
-        if (fieldCnt > MAX_MULTIREG_COUNT)
-        {
-            canPromote = false;
-        }
-#if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
-        else
-        {
-            for (unsigned i = 0; canPromote && (i < fieldCnt); i++)
-            {
-                var_types fieldType = structPromotionInfo.fields[i].fldType;
-                if (varDsc->lvIsParam && (varDsc->lvIsHfa() != varTypeUsesFloatReg(fieldType)))
-                {
-                    canPromote = false;
-                }
-#if defined(FEATURE_SIMD)
-                else if ((fieldCnt > 1) && varTypeIsStruct(fieldType) &&
-                         !compiler->isOpaqueSIMDType(structPromotionInfo.fields[i].fldTypeHnd))
-                {
-                    canPromote = false;
-                }
-#endif // FEATURE_SIMD
-            }
-        }
-#elif defined(UNIX_AMD64_ABI)
-        else
-        {
-            SortStructFields();
-            SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR structDesc;
-            compiler->eeGetSystemVAmd64PassStructInRegisterDescriptor(typeHnd, &structDesc);
-            unsigned regCount = structDesc.eightByteCount;
-            if ((structPromotionInfo.fieldCnt == 1) && varTypeIsSIMD(structPromotionInfo.fields[0].fldType))
-            {
-            }
-            else if (structPromotionInfo.fieldCnt != regCount)
-            {
-                canPromote = false;
-            }
-            else
-            {
-                for (unsigned i = 0; canPromote && (i < regCount); i++)
-                {
-                    lvaStructFieldInfo* fieldInfo = &(structPromotionInfo.fields[i]);
-                    var_types           fieldType = fieldInfo->fldType;
-                    if (varTypeIsSIMD(fieldType))
-                    {
-                        canPromote = false;
-                    }
-                    else if (varTypeUsesFloatReg(fieldType) !=
-                             (structDesc.eightByteClassifications[i] == SystemVClassificationTypeSSE))
-                    {
-                        canPromote = false;
-                    }
-                }
-            }
-        }
-#endif // UNIX_AMD64_ABI
-    }
-    return canPromote;
-}
-bool Compiler::StructPromotionHelper::ShouldPromoteStructVar(unsigned lclNum)
-{
-    LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
-    assert(varTypeIsStruct(varDsc));
-    assert(varDsc->GetStructHnd() == structPromotionInfo.typeHnd);
-    assert(structPromotionInfo.canPromote);
-    bool shouldPromote = true;
-    if (structPromotionInfo.fieldCnt > 3 && !varDsc->lvFieldAccessed)
-    {
-        JITDUMP("Not promoting promotable struct local V%02u: #fields = %d, fieldAccessed = %d.\n", lclNum,
-                structPromotionInfo.fieldCnt, varDsc->lvFieldAccessed);
-        shouldPromote = false;
-    }
-    else if (varDsc->lvIsMultiRegRet && structPromotionInfo.containsHoles && structPromotionInfo.customLayout)
-    {
-        JITDUMP("Not promoting multi-reg returned struct local V%02u with holes.\n", lclNum);
-        shouldPromote = false;
-    }
-#if defined(TARGET_AMD64) || defined(TARGET_ARM64) || defined(TARGET_ARM) || defined(TARGET_LOONGARCH64)
-    else if ((structPromotionInfo.fieldCnt == 1) && varTypeIsFloating(structPromotionInfo.fields[0].fldType))
-    {
-        JITDUMP("Not promoting promotable struct local V%02u: #fields = %d because it is a struct with "
-                "single float field.\n",
-                lclNum, structPromotionInfo.fieldCnt);
-        shouldPromote = false;
-    }
-#if defined(TARGET_LOONGARCH64)
-    else if ((structPromotionInfo.fieldCnt == 2) && (varTypeIsFloating(structPromotionInfo.fields[0].fldType) ||
-                                                     varTypeIsFloating(structPromotionInfo.fields[1].fldType)))
-    {
-        JITDUMP("Not promoting promotable struct local V%02u: #fields = %d because it is a struct with "
-                "float field(s).\n",
-                lclNum, structPromotionInfo.fieldCnt);
-        shouldPromote = false;
-    }
-#endif
-#endif // TARGET_AMD64 || TARGET_ARM64 || TARGET_ARM || TARGET_LOONGARCH64
-    else if (varDsc->lvIsParam && !compiler->lvaIsImplicitByRefLocal(lclNum) && !varDsc->lvIsHfa())
-    {
-#if FEATURE_MULTIREG_STRUCT_PROMOTE
-        if (compiler->lvaIsMultiregStruct(varDsc, compiler->info.compIsVarArgs))
-        {
-            if (structPromotionInfo.containsHoles && structPromotionInfo.customLayout)
-            {
-                JITDUMP("Not promoting multi-reg struct local V%02u with holes.\n", lclNum);
-                shouldPromote = false;
-            }
-            else if ((structPromotionInfo.fieldCnt != 2) &&
-                     !((structPromotionInfo.fieldCnt == 1) && varTypeIsSIMD(structPromotionInfo.fields[0].fldType)))
-            {
-                JITDUMP("Not promoting multireg struct local V%02u, because lvIsParam is true, #fields != 2 and it's "
-                        "not a single SIMD.\n",
-                        lclNum);
-                shouldPromote = false;
-            }
-        }
-        else
-#endif // !FEATURE_MULTIREG_STRUCT_PROMOTE
-            if (structPromotionInfo.fieldCnt != 1)
-        {
-            JITDUMP("Not promoting promotable struct local V%02u, because lvIsParam is true and #fields = "
-                    "%d.\n",
-                    lclNum, structPromotionInfo.fieldCnt);
-            shouldPromote = false;
-        }
-    }
-    else if ((lclNum == compiler->genReturnLocal) && (structPromotionInfo.fieldCnt > 1))
-    {
-        shouldPromote = false;
-    }
-#if defined(DEBUG)
-    else if (compiler->compPromoteFewerStructs(lclNum))
-    {
-        JITDUMP("Not promoting promotable struct local V%02u, because of STRESS_PROMOTE_FEWER_STRUCTS\n", lclNum);
-        shouldPromote = false;
-    }
-#endif
-    CLANG_FORMAT_COMMENT_ANCHOR;
-    return shouldPromote;
-}
-void Compiler::StructPromotionHelper::SortStructFields()
-{
-    if (!structPromotionInfo.fieldsSorted)
-    {
-        jitstd::sort(structPromotionInfo.fields, structPromotionInfo.fields + structPromotionInfo.fieldCnt,
-                     lvaFieldOffsetCmp());
-        structPromotionInfo.fieldsSorted = true;
-    }
-}
-Compiler::lvaStructFieldInfo Compiler::StructPromotionHelper::GetFieldInfo(CORINFO_FIELD_HANDLE fieldHnd, BYTE ordinal)
-{
-    lvaStructFieldInfo fieldInfo;
-    fieldInfo.fldHnd = fieldHnd;
-    unsigned fldOffset  = compiler->info.compCompHnd->getFieldOffset(fieldInfo.fldHnd);
-    fieldInfo.fldOffset = (BYTE)fldOffset;
-    fieldInfo.fldOrdinal = ordinal;
-    CorInfoType corType  = compiler->info.compCompHnd->getFieldType(fieldInfo.fldHnd, &fieldInfo.fldTypeHnd);
-    fieldInfo.fldType    = JITtype2varType(corType);
-    fieldInfo.fldSize    = genTypeSize(fieldInfo.fldType);
-#ifdef FEATURE_SIMD
-    if (compiler->usesSIMDTypes() && (fieldInfo.fldSize == 0) && compiler->isSIMDorHWSIMDClass(fieldInfo.fldTypeHnd))
-    {
-        unsigned    simdSize;
-        CorInfoType simdBaseJitType = compiler->getBaseJitTypeAndSizeOfSIMDType(fieldInfo.fldTypeHnd, &simdSize);
-        if (simdBaseJitType != CORINFO_TYPE_UNDEF)
-        {
-            if ((simdSize >= compiler->minSIMDStructBytes()) && (simdSize <= compiler->maxSIMDStructBytes()))
-            {
-                fieldInfo.fldType = compiler->getSIMDTypeForSize(simdSize);
-                fieldInfo.fldSize = simdSize;
-#ifdef DEBUG
-                retypedFieldsMap.Set(fieldInfo.fldHnd, fieldInfo.fldType, RetypedAsScalarFieldsMap::Overwrite);
-#endif // DEBUG
-            }
-        }
-    }
-#endif // FEATURE_SIMD
-    if (fieldInfo.fldSize == 0)
-    {
-        TryPromoteStructField(fieldInfo);
-    }
-    return fieldInfo;
-}
-bool Compiler::StructPromotionHelper::TryPromoteStructField(lvaStructFieldInfo& fieldInfo)
-{
-    if (fieldInfo.fldType != TYP_STRUCT)
-    {
-        return false;
-    }
-    COMP_HANDLE compHandle = compiler->info.compCompHnd;
-    if (compHandle->getClassNumInstanceFields(fieldInfo.fldTypeHnd) != 1)
-    {
-        return false;
-    }
-    CORINFO_FIELD_HANDLE innerFieldHndl   = compHandle->getFieldInClass(fieldInfo.fldTypeHnd, 0);
-    unsigned             innerFieldOffset = compHandle->getFieldOffset(innerFieldHndl);
-    if (innerFieldOffset != 0)
-    {
-        return false;
-    }
-    CorInfoType fieldCorType = compHandle->getFieldType(innerFieldHndl);
-    var_types   fieldVarType = JITtype2varType(fieldCorType);
-    unsigned    fieldSize    = genTypeSize(fieldVarType);
-    if (fieldSize == 0 || fieldSize > TARGET_POINTER_SIZE || varTypeIsFloating(fieldVarType))
-    {
-        JITDUMP("Promotion blocked: struct contains struct field with one field,"
-                " but that field has invalid size or type.\n");
-        return false;
-    }
-    if (fieldSize != TARGET_POINTER_SIZE)
-    {
-        unsigned outerFieldOffset = compHandle->getFieldOffset(fieldInfo.fldHnd);
-        if ((outerFieldOffset % fieldSize) != 0)
-        {
-            JITDUMP("Promotion blocked: struct contains struct field with one field,"
-                    " but the outer struct offset %u is not a multiple of the inner field size %u.\n",
-                    outerFieldOffset, fieldSize);
-            return false;
-        }
-    }
-    unsigned innerStructSize = compHandle->getClassSize(fieldInfo.fldTypeHnd);
-    if (fieldSize != innerStructSize)
-    {
-        JITDUMP("Promotion blocked: struct contains struct field with one field,"
-                " but that field is not the same size as its parent.\n");
-        return false;
-    }
-    fieldInfo.fldType = fieldVarType;
-    fieldInfo.fldSize = fieldSize;
-#ifdef DEBUG
-    retypedFieldsMap.Set(fieldInfo.fldHnd, fieldInfo.fldType, RetypedAsScalarFieldsMap::Overwrite);
-#endif // DEBUG
-    return true;
-}
-void Compiler::StructPromotionHelper::PromoteStructVar(unsigned lclNum)
-{
-    LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
-    assert(!varDsc->lvRegStruct);
-    assert(varDsc->GetStructHnd() == structPromotionInfo.typeHnd);
-    assert(structPromotionInfo.canPromote);
-    varDsc->lvFieldCnt      = structPromotionInfo.fieldCnt;
-    varDsc->lvFieldLclStart = compiler->lvaCount;
-    varDsc->lvPromoted      = true;
-    varDsc->lvContainsHoles = structPromotionInfo.containsHoles;
-    varDsc->lvCustomLayout  = structPromotionInfo.customLayout;
-#ifdef DEBUG
-    varDsc->lvKeepType = 1;
-#endif
-#ifdef DEBUG
-    if (compiler->verbose)
-    {
-        printf("\nPromoting struct local V%02u (%s):", lclNum, compiler->eeGetClassName(varDsc->GetStructHnd()));
-    }
-#endif
-    SortStructFields();
-    for (unsigned index = 0; index < structPromotionInfo.fieldCnt; ++index)
-    {
-        const lvaStructFieldInfo* pFieldInfo = &structPromotionInfo.fields[index];
-        if (varTypeUsesFloatReg(pFieldInfo->fldType))
-        {
-            compiler->compFloatingPointUsed = true;
-        }
-#ifdef DEBUG
-        char buf[200];
-        sprintf_s(buf, sizeof(buf), "%s V%02u.%s (fldOffset=0x%x)", "field", lclNum,
-                  compiler->eeGetFieldName(pFieldInfo->fldHnd), pFieldInfo->fldOffset);
-        size_t len  = strlen(buf) + 1;
-        char*  bufp = compiler->getAllocator(CMK_DebugOnly).allocate<char>(len);
-        strcpy_s(bufp, len, buf);
-        if (index > 0)
-        {
-            noway_assert(pFieldInfo->fldOffset > (pFieldInfo - 1)->fldOffset);
-        }
-#endif
-        const unsigned varNum = compiler->lvaGrabTemp(false DEBUGARG(bufp));
-        varDsc = compiler->lvaGetDesc(lclNum);
-        LclVarDsc* fieldVarDsc       = compiler->lvaGetDesc(varNum);
-        fieldVarDsc->lvType          = pFieldInfo->fldType;
-        fieldVarDsc->lvExactSize     = pFieldInfo->fldSize;
-        fieldVarDsc->lvIsStructField = true;
-        fieldVarDsc->lvFieldHnd      = pFieldInfo->fldHnd;
-        fieldVarDsc->lvFldOffset     = pFieldInfo->fldOffset;
-        fieldVarDsc->lvFldOrdinal    = pFieldInfo->fldOrdinal;
-        fieldVarDsc->lvParentLcl     = lclNum;
-        fieldVarDsc->lvIsParam       = varDsc->lvIsParam;
-        fieldVarDsc->lvIsOSRLocal    = varDsc->lvIsOSRLocal;
-        if (fieldVarDsc->lvType == TYP_LONG)
-        {
-            compiler->compLongUsed = true;
-        }
-#if FEATURE_IMPLICIT_BYREFS
-        fieldVarDsc->lvIsImplicitByRef = 0;
-#endif // FEATURE_IMPLICIT_BYREFS
-        if (varDsc->lvIsRegArg)
-        {
-            fieldVarDsc->lvIsRegArg = true;
-            regNumber parentArgReg  = varDsc->GetArgReg();
-#if FEATURE_MULTIREG_ARGS
-            if (!compiler->lvaIsImplicitByRefLocal(lclNum))
-            {
-#ifdef UNIX_AMD64_ABI
-                if (varTypeIsSIMD(fieldVarDsc) && (varDsc->lvFieldCnt == 1))
-                {
-                    fieldVarDsc->SetArgReg(parentArgReg);
-                    fieldVarDsc->SetOtherArgReg(varDsc->GetOtherArgReg());
-                }
-                else
-#endif // UNIX_AMD64_ABI
-                {
-                    regNumber fieldRegNum;
-                    if (index == 0)
-                    {
-                        fieldRegNum = parentArgReg;
-                    }
-                    else if (varDsc->lvIsHfa())
-                    {
-                        unsigned regIncrement = fieldVarDsc->lvFldOrdinal;
-#ifdef TARGET_ARM
-                        if (varDsc->GetHfaType() == TYP_DOUBLE)
-                        {
-                            regIncrement *= 2;
-                        }
-#endif // TARGET_ARM
-                        fieldRegNum = (regNumber)(parentArgReg + regIncrement);
-                    }
-                    else
-                    {
-                        assert(index == 1);
-                        fieldRegNum = varDsc->GetOtherArgReg();
-                    }
-                    fieldVarDsc->SetArgReg(fieldRegNum);
-                }
-            }
-            else
-#endif // FEATURE_MULTIREG_ARGS && defined(FEATURE_SIMD)
-            {
-                fieldVarDsc->SetArgReg(parentArgReg);
-            }
-        }
-#ifdef FEATURE_SIMD
-        if (varTypeIsSIMD(pFieldInfo->fldType))
-        {
-            fieldVarDsc->lvExactSize = 0;
-            compiler->lvaSetStruct(varNum, pFieldInfo->fldTypeHnd, false);
-            fieldVarDsc->lvRegStruct = true;
-        }
-#endif // FEATURE_SIMD
-#ifdef DEBUG
-        fieldVarDsc->lvKeepType = 1;
-#endif
-    }
-}
-unsigned Compiler::lvaGetFieldLocal(const LclVarDsc* varDsc, unsigned int fldOffset)
-{
-    noway_assert(varTypeIsStruct(varDsc));
-    noway_assert(varDsc->lvPromoted);
-    for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
-    {
-        noway_assert(lvaTable[i].lvIsStructField);
-        noway_assert(lvaTable[i].lvParentLcl == (unsigned)(varDsc - lvaTable));
-        if (lvaTable[i].lvFldOffset == fldOffset)
-        {
-            return i;
-        }
-    }
-    return BAD_VAR_NUM;
-}
-/*****************************************************************************
- *
- *  Set the local var "varNum" as address-exposed.
- *  If this is a promoted struct, label it's fields the same way.
- */
-void Compiler::lvaSetVarAddrExposed(unsigned varNum DEBUGARG(AddressExposedReason reason))
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    varDsc->SetAddressExposed(true DEBUGARG(reason));
-    if (varDsc->lvPromoted)
-    {
-        noway_assert(varTypeIsStruct(varDsc));
-        for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
-        {
-            noway_assert(lvaTable[i].lvIsStructField);
-            lvaTable[i].SetAddressExposed(true DEBUGARG(AddressExposedReason::PARENT_EXPOSED));
-            lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::AddrExposed));
-        }
-    }
-    lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::AddrExposed));
-}
-void Compiler::lvaSetHiddenBufferStructArg(unsigned varNum)
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-#ifdef DEBUG
-    varDsc->SetHiddenBufferStructArg(true);
-#endif
-    if (varDsc->lvPromoted)
-    {
-        noway_assert(varTypeIsStruct(varDsc));
-        for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
-        {
-            noway_assert(lvaTable[i].lvIsStructField);
-#ifdef DEBUG
-            lvaTable[i].SetHiddenBufferStructArg(true);
-#endif
-            lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::HiddenBufferStructArg));
-        }
-    }
-    lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::HiddenBufferStructArg));
-}
-void Compiler::lvaSetVarLiveInOutOfHandler(unsigned varNum)
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    varDsc->lvLiveInOutOfHndlr = 1;
-    if (varDsc->lvPromoted)
-    {
-        noway_assert(varTypeIsStruct(varDsc));
-        for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
-        {
-            noway_assert(lvaTable[i].lvIsStructField);
-            lvaTable[i].lvLiveInOutOfHndlr = 1;
-            if (!lvaEnregEHVars || !lvaTable[i].lvSingleDefRegCandidate || lvaTable[i].lvRefCnt() <= 1)
-            {
-                lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
-            }
-        }
-    }
-    if (!lvaEnregEHVars || !varDsc->lvSingleDefRegCandidate || varDsc->lvRefCnt() <= 1)
-    {
-        lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
-    }
-#ifdef JIT32_GCENCODER
-    else if (lvaKeepAliveAndReportThis() && (varNum == info.compThisArg))
-    {
-        lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
-    }
-#endif // JIT32_GCENCODER
-}
-/*****************************************************************************
- *
- *  Record that the local var "varNum" should not be enregistered (for one of several reasons.)
- */
-void Compiler::lvaSetVarDoNotEnregister(unsigned varNum DEBUGARG(DoNotEnregisterReason reason))
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    const bool wasAlreadyMarkedDoNotEnreg = (varDsc->lvDoNotEnregister == 1);
-    varDsc->lvDoNotEnregister             = 1;
-#ifdef DEBUG
-    if (!wasAlreadyMarkedDoNotEnreg)
-    {
-        varDsc->SetDoNotEnregReason(reason);
-    }
-    if (verbose)
-    {
-        printf("\nLocal V%02u should not be enregistered because: ", varNum);
-    }
-    switch (reason)
-    {
-        case DoNotEnregisterReason::AddrExposed:
-            JITDUMP("it is address exposed\n");
-            assert(varDsc->IsAddressExposed());
-            break;
-        case DoNotEnregisterReason::HiddenBufferStructArg:
-            JITDUMP("it is hidden buffer struct arg\n");
-            assert(varDsc->IsHiddenBufferStructArg());
-            break;
-        case DoNotEnregisterReason::DontEnregStructs:
-            JITDUMP("struct enregistration is disabled\n");
-            assert(varTypeIsStruct(varDsc));
-            break;
-        case DoNotEnregisterReason::NotRegSizeStruct:
-            JITDUMP("struct size does not match reg size\n");
-            assert(varTypeIsStruct(varDsc));
-            break;
-        case DoNotEnregisterReason::LocalField:
-            JITDUMP("was accessed as a local field\n");
-            break;
-        case DoNotEnregisterReason::VMNeedsStackAddr:
-            JITDUMP("VM needs stack addr\n");
-            break;
-        case DoNotEnregisterReason::LiveInOutOfHandler:
-            JITDUMP("live in/out of a handler\n");
-            varDsc->lvLiveInOutOfHndlr = 1;
-            break;
-        case DoNotEnregisterReason::BlockOp:
-            JITDUMP("written/read in a block op\n");
-            break;
-        case DoNotEnregisterReason::IsStructArg:
-            if (varTypeIsStruct(varDsc))
-            {
-                JITDUMP("it is a struct arg\n");
-            }
-            else
-            {
-                JITDUMP("it is reinterpreted as a struct arg\n");
-            }
-            break;
-        case DoNotEnregisterReason::DepField:
-            JITDUMP("field of a dependently promoted struct\n");
-            assert(varDsc->lvIsStructField && (lvaGetParentPromotionType(varNum) != PROMOTION_TYPE_INDEPENDENT));
-            break;
-        case DoNotEnregisterReason::NoRegVars:
-            JITDUMP("opts.compFlags & CLFLG_REGVAR is not set\n");
-            assert(!compEnregLocals());
-            break;
-        case DoNotEnregisterReason::MinOptsGC:
-            JITDUMP("it is a GC Ref and we are compiling MinOpts\n");
-            assert(!JitConfig.JitMinOptsTrackGCrefs() && varTypeIsGC(varDsc->TypeGet()));
-            break;
-#if !defined(TARGET_64BIT)
-        case DoNotEnregisterReason::LongParamField:
-            JITDUMP("it is a decomposed field of a long parameter\n");
-            break;
-#endif
-#ifdef JIT32_GCENCODER
-        case DoNotEnregisterReason::PinningRef:
-            JITDUMP("pinning ref\n");
-            assert(varDsc->lvPinned);
-            break;
-#endif
-        case DoNotEnregisterReason::LclAddrNode:
-            JITDUMP("LclAddrVar/Fld takes the address of this node\n");
-            break;
-        case DoNotEnregisterReason::CastTakesAddr:
-            JITDUMP("cast takes addr\n");
-            break;
-        case DoNotEnregisterReason::StoreBlkSrc:
-            JITDUMP("the local is used as store block src\n");
-            break;
-        case DoNotEnregisterReason::OneAsgRetyping:
-            JITDUMP("OneAsg forbids enreg\n");
-            break;
-        case DoNotEnregisterReason::SwizzleArg:
-            JITDUMP("SwizzleArg\n");
-            break;
-        case DoNotEnregisterReason::BlockOpRet:
-            JITDUMP("return uses a block op\n");
-            break;
-        case DoNotEnregisterReason::ReturnSpCheck:
-            JITDUMP("Used for SP check\n");
-            break;
-        case DoNotEnregisterReason::SimdUserForcesDep:
-            JITDUMP("Promoted struct used by a SIMD/HWI node\n");
-            break;
-        default:
-            unreached();
-            break;
-    }
-#endif
-}
-bool Compiler::lvaIsImplicitByRefLocal(unsigned lclNum) const
-{
-#if FEATURE_IMPLICIT_BYREFS
-    LclVarDsc* varDsc = lvaGetDesc(lclNum);
-    if (varDsc->lvIsImplicitByRef)
-    {
-        assert(varDsc->lvIsParam);
-        assert(varTypeIsStruct(varDsc) || (varDsc->TypeGet() == TYP_BYREF));
-        return true;
-    }
-#endif // FEATURE_IMPLICIT_BYREFS
-    return false;
-}
-bool Compiler::lvaIsLocalImplicitlyAccessedByRef(unsigned lclNum) const
-{
-    if (lvaGetDesc(lclNum)->lvIsStructField)
-    {
-        return lvaIsImplicitByRefLocal(lvaGetDesc(lclNum)->lvParentLcl);
-    }
-    return lvaIsImplicitByRefLocal(lclNum);
-}
-bool Compiler::lvaIsMultiregStruct(LclVarDsc* varDsc, bool isVarArg)
-{
-    if (varTypeIsStruct(varDsc->TypeGet()))
-    {
-        CORINFO_CLASS_HANDLE clsHnd = varDsc->GetStructHnd();
-        structPassingKind    howToPassStruct;
-        var_types type = getArgTypeForStruct(clsHnd, &howToPassStruct, isVarArg, varDsc->lvExactSize);
-        if (howToPassStruct == SPK_ByValueAsHfa)
-        {
-            assert(type == TYP_STRUCT);
-            return true;
-        }
-#if defined(UNIX_AMD64_ABI) || defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-        if (howToPassStruct == SPK_ByValue)
-        {
-            assert(type == TYP_STRUCT);
-            return true;
-        }
-#endif
-    }
-    return false;
-}
-/*****************************************************************************
- * Set the lvClass for a local variable of a struct type */
-void Compiler::lvaSetStruct(unsigned varNum, CORINFO_CLASS_HANDLE typeHnd, bool unsafeValueClsCheck)
-{
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    if (varDsc->lvType == TYP_UNDEF)
-    {
-        varDsc->lvType = TYP_STRUCT;
-    }
-    if (varDsc->GetLayout() == nullptr)
-    {
-        ClassLayout* layout = typGetObjLayout(typeHnd);
-        varDsc->SetLayout(layout);
-        assert(varDsc->lvExactSize == 0);
-        varDsc->lvExactSize = layout->GetSize();
-        assert(varDsc->lvExactSize != 0);
-        if (layout->IsValueClass())
-        {
-            CorInfoType simdBaseJitType = CORINFO_TYPE_UNDEF;
-            varDsc->lvType              = impNormStructType(typeHnd, &simdBaseJitType);
-#if FEATURE_IMPLICIT_BYREFS
-            if (varDsc->lvIsParam && !varDsc->lvIsStructField)
-            {
-                structPassingKind howToReturnStruct;
-                getArgTypeForStruct(typeHnd, &howToReturnStruct, this->info.compIsVarArgs, varDsc->lvExactSize);
-                if (howToReturnStruct == SPK_ByReference)
-                {
-                    JITDUMP("Marking V%02i as a byref parameter\n", varNum);
-                    varDsc->lvIsImplicitByRef = 1;
-                }
-            }
-#endif // FEATURE_IMPLICIT_BYREFS
-#if FEATURE_SIMD
-            if (simdBaseJitType != CORINFO_TYPE_UNDEF)
-            {
-                assert(varTypeIsSIMD(varDsc));
-                varDsc->lvSIMDType = true;
-                varDsc->SetSimdBaseJitType(simdBaseJitType);
-            }
-#endif // FEATURE_SIMD
-            if (GlobalJitOptions::compFeatureHfa)
-            {
-                if (varDsc->lvExactSize <= MAX_PASS_MULTIREG_BYTES)
-                {
-                    var_types hfaType = GetHfaType(typeHnd);
-                    if (varTypeIsValidHfaType(hfaType))
-                    {
-                        varDsc->SetHfaType(hfaType);
-                        assert(!layout->HasGCPtr());
-                        assert((varDsc->lvExactSize % genTypeSize(hfaType)) == 0);
-                        assert((varDsc->lvExactSize / genTypeSize(hfaType)) <= MAX_ARG_REG_COUNT);
-                    }
-                }
-            }
-        }
-    }
-    else
-    {
-#if FEATURE_SIMD
-        assert(!varTypeIsSIMD(varDsc) || (varDsc->GetSimdBaseType() != TYP_UNKNOWN));
-#endif // FEATURE_SIMD
-        ClassLayout* layout = typGetObjLayout(typeHnd);
-        assert(ClassLayout::AreCompatible(varDsc->GetLayout(), layout));
-        varDsc->SetLayout(layout);
-        assert(varDsc->lvExactSize != 0);
-    }
-#ifndef TARGET_64BIT
-    bool fDoubleAlignHint = false;
-#ifdef TARGET_X86
-    fDoubleAlignHint = true;
-#endif
-    if (info.compCompHnd->getClassAlignmentRequirement(typeHnd, fDoubleAlignHint) == 8)
-    {
-#ifdef DEBUG
-        if (verbose)
-        {
-            printf("Marking struct in V%02i with double align flag\n", varNum);
-        }
-#endif
-        varDsc->lvStructDoubleAlign = 1;
-    }
-#endif // not TARGET_64BIT
-    unsigned classAttribs = info.compCompHnd->getClassAttribs(typeHnd);
-    varDsc->lvOverlappingFields = StructHasOverlappingFields(classAttribs);
-    if (unsafeValueClsCheck && (classAttribs & CORINFO_FLG_UNSAFE_VALUECLASS) && !opts.compDbgEnC)
-    {
-        setNeedsGSSecurityCookie();
-        compGSReorderStackLayout = true;
-        varDsc->lvIsUnsafeBuffer = true;
-    }
-#ifdef DEBUG
-    if (JitConfig.EnableExtraSuperPmiQueries())
-    {
-        makeExtraStructQueries(typeHnd, 2);
-    }
-#endif // DEBUG
-}
-#ifdef DEBUG
-void Compiler::makeExtraStructQueries(CORINFO_CLASS_HANDLE structHandle, int level)
-{
-    if (level <= 0)
-    {
-        return;
-    }
-    assert(structHandle != NO_CLASS_HANDLE);
-    (void)typGetObjLayout(structHandle);
-    DWORD typeFlags = info.compCompHnd->getClassAttribs(structHandle);
-    if (StructHasDontDigFieldsFlagSet(typeFlags))
-    {
-        return;
-    }
-    unsigned fieldCnt = info.compCompHnd->getClassNumInstanceFields(structHandle);
-    impNormStructType(structHandle);
-#ifdef TARGET_ARMARCH
-    GetHfaType(structHandle);
-#endif
-    for (unsigned int i = 0; i < fieldCnt; i++)
-    {
-        CORINFO_FIELD_HANDLE fieldHandle      = info.compCompHnd->getFieldInClass(structHandle, i);
-        unsigned             fldOffset        = info.compCompHnd->getFieldOffset(fieldHandle);
-        CORINFO_CLASS_HANDLE fieldClassHandle = NO_CLASS_HANDLE;
-        CorInfoType          fieldCorType     = info.compCompHnd->getFieldType(fieldHandle, &fieldClassHandle);
-        var_types            fieldVarType     = JITtype2varType(fieldCorType);
-        if (fieldClassHandle != NO_CLASS_HANDLE)
-        {
-            if (varTypeIsStruct(fieldVarType))
-            {
-                makeExtraStructQueries(fieldClassHandle, level - 1);
-            }
-        }
-    }
-}
-#endif // DEBUG
-void Compiler::lvaSetStructUsedAsVarArg(unsigned varNum)
-{
-    if (GlobalJitOptions::compFeatureHfa && TargetOS::IsWindows)
-    {
-#if defined(TARGET_ARM64)
-        LclVarDsc* varDsc = lvaGetDesc(varNum);
-        varDsc->SetHfaType(TYP_UNDEF);
-#endif // defined(TARGET_ARM64)
-    }
-}
-void Compiler::lvaSetClass(unsigned varNum, CORINFO_CLASS_HANDLE clsHnd, bool isExact)
-{
-    noway_assert(varNum < lvaCount);
-    if (compIsForImportOnly())
-    {
-        return;
-    }
-    if (clsHnd != NO_CLASS_HANDLE && !isExact && JitConfig.JitEnableExactDevirtualization())
-    {
-        CORINFO_CLASS_HANDLE exactClass;
-        if (info.compCompHnd->getExactClasses(clsHnd, 1, &exactClass) == 1)
-        {
-            isExact = true;
-            clsHnd  = exactClass;
-        }
-    }
-    assert(clsHnd != nullptr);
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    assert(varDsc->lvType == TYP_REF);
-    assert(varDsc->lvClassHnd == NO_CLASS_HANDLE);
-    assert(!varDsc->lvClassIsExact);
-    JITDUMP("\nlvaSetClass: setting class for V%02i to (%p) %s %s\n", varNum, dspPtr(clsHnd), eeGetClassName(clsHnd),
-            isExact ? " [exact]" : "");
-    varDsc->lvClassHnd     = clsHnd;
-    varDsc->lvClassIsExact = isExact;
-}
-void Compiler::lvaSetClass(unsigned varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)
-{
-    bool                 isExact   = false;
-    bool                 isNonNull = false;
-    CORINFO_CLASS_HANDLE clsHnd    = gtGetClassHandle(tree, &isExact, &isNonNull);
-    if (clsHnd != nullptr)
-    {
-        lvaSetClass(varNum, clsHnd, isExact);
-    }
-    else if (stackHnd != nullptr)
-    {
-        lvaSetClass(varNum, stackHnd);
-    }
-    else
-    {
-        lvaSetClass(varNum, impGetObjectClass());
-    }
-}
-void Compiler::lvaUpdateClass(unsigned varNum, CORINFO_CLASS_HANDLE clsHnd, bool isExact)
-{
-    assert(varNum < lvaCount);
-    if (compIsForImportOnly())
-    {
-        return;
-    }
-    assert(clsHnd != nullptr);
-    LclVarDsc* varDsc = lvaGetDesc(varNum);
-    assert(varDsc->lvType == TYP_REF);
-    assert(varDsc->lvClassHnd != NO_CLASS_HANDLE);
-    assert(varDsc->lvSingleDef);
-    const bool isNewClass   = (clsHnd != varDsc->lvClassHnd);
-    bool       shouldUpdate = false;
-    if (!varDsc->lvClassIsExact && isNewClass)
-    {
-        shouldUpdate = !!info.compCompHnd->isMoreSpecificType(varDsc->lvClassHnd, clsHnd);
-    }
-    else if (isExact && !varDsc->lvClassIsExact && !isNewClass)
-    {
-        shouldUpdate = true;
-    }
-#if DEBUG
-    if (isNewClass || (isExact != varDsc->lvClassIsExact))
-    {
-        JITDUMP("\nlvaUpdateClass:%s Updating class for V%02u", shouldUpdate ? "" : " NOT", varNum);
-        JITDUMP(" from (%p) %s%s", dspPtr(varDsc->lvClassHnd), eeGetClassName(varDsc->lvClassHnd),
-                varDsc->lvClassIsExact ? " [exact]" : "");
-        JITDUMP(" to (%p) %s%s\n", dspPtr(clsHnd), eeGetClassName(clsHnd), isExact ? " [exact]" : "");
-    }
-#endif // DEBUG
-    if (shouldUpdate)
-    {
-        varDsc->lvClassHnd     = clsHnd;
-        varDsc->lvClassIsExact = isExact;
-#if DEBUG
-        varDsc->lvClassInfoUpdated = true;
-#endif // DEBUG
-    }
-    return;
-}
-void Compiler::lvaUpdateClass(unsigned varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)
-{
-    bool                 isExact   = false;
-    bool                 isNonNull = false;
-    CORINFO_CLASS_HANDLE clsHnd    = gtGetClassHandle(tree, &isExact, &isNonNull);
-    if (clsHnd != nullptr)
-    {
-        lvaUpdateClass(varNum, clsHnd, isExact);
-    }
-    else if (stackHnd != nullptr)
-    {
-        lvaUpdateClass(varNum, stackHnd);
-    }
-}
-unsigned Compiler::lvaLclSize(unsigned varNum)
-{
-    assert(varNum < lvaCount);
-    var_types varType = lvaTable[varNum].TypeGet();
-    switch (varType)
-    {
-        case TYP_STRUCT:
-        case TYP_BLK:
-            return lvaTable[varNum].lvSize();
-        case TYP_LCLBLK:
-#if FEATURE_FIXED_OUT_ARGS
-            noway_assert(varNum == lvaOutgoingArgSpaceVar);
-            return lvaOutgoingArgSpaceSize;
-#else // FEATURE_FIXED_OUT_ARGS
-            assert(!"Unknown size");
-            NO_WAY("Target doesn't support TYP_LCLBLK");
-#endif // FEATURE_FIXED_OUT_ARGS
-        default: // This must be a primitive var. Fall out of switch statement
-            break;
-    }
-#ifdef TARGET_64BIT
-    if (lvaTable[varNum].lvQuirkToLong)
-    {
-        noway_assert(lvaTable[varNum].IsAddressExposed());
-        return genTypeStSz(TYP_LONG) * sizeof(int); // return 8  (2 * 4)
-    }
-#endif
-    return genTypeStSz(varType) * sizeof(int);
-}
-unsigned Compiler::lvaLclExactSize(unsigned varNum)
-{
-    assert(varNum < lvaCount);
-    var_types varType = lvaTable[varNum].TypeGet();
-    switch (varType)
-    {
-        case TYP_STRUCT:
-        case TYP_BLK:
-            return lvaTable[varNum].lvExactSize;
-        case TYP_LCLBLK:
-#if FEATURE_FIXED_OUT_ARGS
-            noway_assert(lvaOutgoingArgSpaceSize >= 0);
-            noway_assert(varNum == lvaOutgoingArgSpaceVar);
-            return lvaOutgoingArgSpaceSize;
-#else // FEATURE_FIXED_OUT_ARGS
-            assert(!"Unknown size");
-            NO_WAY("Target doesn't support TYP_LCLBLK");
-#endif // FEATURE_FIXED_OUT_ARGS
-        default: // This must be a primitive var. Fall out of switch statement
-            break;
-    }
-    return genTypeSize(varType);
-}
-weight_t BasicBlock::getCalledCount(Compiler* comp)
-{
-    weight_t calledCount = comp->fgCalledCount;
-    if (calledCount == 0)
-    {
-        if (comp->fgIsUsingProfileWeights())
-        {
-            calledCount = 1;
-        }
-        else
-        {
-            calledCount = comp->fgFirstBB->bbWeight;
-            if (calledCount == 0)
-            {
-                calledCount = BB_UNITY_WEIGHT;
-            }
-        }
-    }
-    return calledCount;
-}
-weight_t BasicBlock::getBBWeight(Compiler* comp)
-{
-    if (this->bbWeight == BB_ZERO_WEIGHT)
-    {
-        return BB_ZERO_WEIGHT;
-    }
-    else
-    {
-        weight_t calledCount = getCalledCount(comp);
-        weight_t fullResult = this->bbWeight * BB_UNITY_WEIGHT / calledCount;
-        return fullResult;
-    }
-}
-class LclVarDsc_SmallCode_Less
-{
-    const LclVarDsc* m_lvaTable;
-    INDEBUG(unsigned m_lvaCount;)
-public:
-    LclVarDsc_SmallCode_Less(const LclVarDsc* lvaTable DEBUGARG(unsigned lvaCount))
-        : m_lvaTable(lvaTable)
-#ifdef DEBUG
-        , m_lvaCount(lvaCount)
-#endif
-    {
-    }
-    bool operator()(unsigned n1, unsigned n2)
-    {
-        assert(n1 < m_lvaCount);
-        assert(n2 < m_lvaCount);
-        const LclVarDsc* dsc1 = &m_lvaTable[n1];
-        const LclVarDsc* dsc2 = &m_lvaTable[n2];
-        assert(dsc1->lvTracked);
-        assert(dsc2->lvTracked);
-        assert(!dsc1->lvRegister);
-        assert(!dsc2->lvRegister);
-        unsigned weight1 = dsc1->lvRefCnt();
-        unsigned weight2 = dsc2->lvRefCnt();
-#ifndef TARGET_ARM
-        const bool isFloat1 = isFloatRegType(dsc1->lvType);
-        const bool isFloat2 = isFloatRegType(dsc2->lvType);
-        if (isFloat1 != isFloat2)
-        {
-            if ((weight2 != 0) && isFloat1)
-            {
-                return false;
-            }
-            if ((weight1 != 0) && isFloat2)
-            {
-                return true;
-            }
-        }
-#endif
-        if (weight1 != weight2)
-        {
-            return weight1 > weight2;
-        }
-        if (dsc1->lvRefCntWtd() != dsc2->lvRefCntWtd())
-        {
-            return dsc1->lvRefCntWtd() > dsc2->lvRefCntWtd();
-        }
-        if (weight1 != 0)
-        {
-            if (dsc1->lvIsRegArg)
-            {
-                weight1 += 2 * BB_UNITY_WEIGHT_UNSIGNED;
-            }
-            if (varTypeIsGC(dsc1->TypeGet()))
-            {
-                weight1 += BB_UNITY_WEIGHT_UNSIGNED / 2;
-            }
-        }
-        if (weight2 != 0)
-        {
-            if (dsc2->lvIsRegArg)
-            {
-                weight2 += 2 * BB_UNITY_WEIGHT_UNSIGNED;
-            }
-            if (varTypeIsGC(dsc2->TypeGet()))
-            {
-                weight2 += BB_UNITY_WEIGHT_UNSIGNED / 2;
-            }
-        }
-        if (weight1 != weight2)
-        {
-            return weight1 > weight2;
-        }
-        return dsc1 < dsc2;
-    }
-};
-class LclVarDsc_BlendedCode_Less
-{
-    const LclVarDsc* m_lvaTable;
-    INDEBUG(unsigned m_lvaCount;)
-public:
-    LclVarDsc_BlendedCode_Less(const LclVarDsc* lvaTable DEBUGARG(unsigned lvaCount))
-        : m_lvaTable(lvaTable)
-#ifdef DEBUG
-        , m_lvaCount(lvaCount)
-#endif
-    {
-    }
-    bool operator()(unsigned n1, unsigned n2)
-    {
-        assert(n1 < m_lvaCount);
-        assert(n2 < m_lvaCount);
-        const LclVarDsc* dsc1 = &m_lvaTable[n1];
-        const LclVarDsc* dsc2 = &m_lvaTable[n2];
-        assert(dsc1->lvTracked);
-        assert(dsc2->lvTracked);
-        assert(!dsc1->lvRegister);
-        assert(!dsc2->lvRegister);
-        weight_t weight1 = dsc1->lvRefCntWtd();
-        weight_t weight2 = dsc2->lvRefCntWtd();
-#ifndef TARGET_ARM
-        const bool isFloat1 = isFloatRegType(dsc1->lvType);
-        const bool isFloat2 = isFloatRegType(dsc2->lvType);
-        if (isFloat1 != isFloat2)
-        {
-            if (!Compiler::fgProfileWeightsEqual(weight2, 0) && isFloat1)
-            {
-                return false;
-            }
-            if (!Compiler::fgProfileWeightsEqual(weight1, 0) && isFloat2)
-            {
-                return true;
-            }
-        }
-#endif
-        if (!Compiler::fgProfileWeightsEqual(weight1, 0) && dsc1->lvIsRegArg)
-        {
-            weight1 += 2 * BB_UNITY_WEIGHT;
-        }
-        if (!Compiler::fgProfileWeightsEqual(weight2, 0) && dsc2->lvIsRegArg)
-        {
-            weight2 += 2 * BB_UNITY_WEIGHT;
-        }
-        if (!Compiler::fgProfileWeightsEqual(weight1, weight2))
-        {
-            return weight1 > weight2;
-        }
-        if (dsc1->lvRefCnt() != dsc2->lvRefCnt())
-        {
-            return dsc1->lvRefCnt() > dsc2->lvRefCnt();
-        }
-        if (varTypeIsGC(dsc1->TypeGet()) != varTypeIsGC(dsc2->TypeGet()))
-        {
-            return varTypeIsGC(dsc1->TypeGet());
-        }
-        return dsc1 < dsc2;
-    }
-};
-/*****************************************************************************
- *
- *  Sort the local variable table by refcount and assign tracking indices.
- */
-void Compiler::lvaSortByRefCount()
-{
-    lvaTrackedCount             = 0;
-    lvaTrackedCountInSizeTUnits = 0;
-#ifdef DEBUG
-    VarSetOps::AssignNoCopy(this, lvaTrackedVars, VarSetOps::MakeEmpty(this));
-#endif
-    if (lvaCount == 0)
-    {
-        return;
-    }
-    /* We'll sort the variables by ref count - allocate the sorted table */
-    if (lvaTrackedToVarNumSize < lvaCount)
-    {
-        lvaTrackedToVarNumSize = lvaCount;
-        lvaTrackedToVarNum     = new (getAllocator(CMK_LvaTable)) unsigned[lvaTrackedToVarNumSize];
-    }
-    unsigned  trackedCount = 0;
-    unsigned* tracked      = lvaTrackedToVarNum;
-    for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
-    {
-        LclVarDsc* varDsc = lvaGetDesc(lclNum);
-        varDsc->lvTracked = 1;
-        if (varDsc->lvRefCnt() == 0)
-        {
-            varDsc->lvTracked = 0;
-            varDsc->setLvRefCntWtd(0);
-        }
-#if !defined(TARGET_64BIT)
-        if (varTypeIsLong(varDsc) && varDsc->lvPromoted)
-        {
-            varDsc->lvTracked = 0;
-        }
-#endif // !defined(TARGET_64BIT)
-        if (varDsc->IsAddressExposed())
-        {
-            varDsc->lvTracked = 0;
-            assert(varDsc->lvType != TYP_STRUCT ||
-                   varDsc->lvDoNotEnregister); // For structs, should have set this when we set m_addrExposed.
-        }
-        if (varTypeIsStruct(varDsc))
-        {
-            if (varDsc->lvPromoted)
-            {
-                varDsc->lvTracked = 0;
-            }
-            else if (!varDsc->IsEnregisterableType())
-            {
-                lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NotRegSizeStruct));
-            }
-            else if (varDsc->lvType == TYP_STRUCT)
-            {
-                if (!varDsc->lvRegStruct && !compEnregStructLocals())
-                {
-                    lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::DontEnregStructs));
-                }
-                else if (varDsc->lvIsMultiRegArgOrRet())
-                {
-                    lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::IsStructArg));
-                }
-#if defined(TARGET_ARM)
-                else if (varDsc->lvIsParam)
-                {
-                    lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::IsStructArg));
-                }
-#endif // TARGET_ARM
-            }
-        }
-        if (varDsc->lvIsStructField && (lvaGetParentPromotionType(lclNum) != PROMOTION_TYPE_INDEPENDENT))
-        {
-            lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::DepField));
-        }
-        if (varDsc->lvPinned)
-        {
-            varDsc->lvTracked = 0;
-#ifdef JIT32_GCENCODER
-            lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::PinningRef));
-#endif
-        }
-        if (opts.MinOpts() && !JitConfig.JitMinOptsTrackGCrefs() && varTypeIsGC(varDsc->TypeGet()))
-        {
-            varDsc->lvTracked = 0;
-            lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::MinOptsGC));
-        }
-        if (!compEnregLocals())
-        {
-            lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NoRegVars));
-        }
-#if defined(JIT32_GCENCODER) && defined(FEATURE_EH_FUNCLETS)
-        if (lvaIsOriginalThisArg(lclNum) && (info.compMethodInfo->options & CORINFO_GENERICS_CTXT_FROM_THIS) != 0)
-        {
-            varDsc->lvTracked = 0;
-        }
-#endif
-        if (opts.MinOpts() && compHndBBtabCount > 0)
-        {
-            lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
-        }
-        else
-        {
-            var_types type = genActualType(varDsc->TypeGet());
-            switch (type)
-            {
-                case TYP_FLOAT:
-                case TYP_DOUBLE:
-                case TYP_INT:
-                case TYP_LONG:
-                case TYP_REF:
-                case TYP_BYREF:
-#ifdef FEATURE_SIMD
-                case TYP_SIMD8:
-                case TYP_SIMD12:
-                case TYP_SIMD16:
-                case TYP_SIMD32:
-#endif // FEATURE_SIMD
-                case TYP_STRUCT:
-                    break;
-                case TYP_UNDEF:
-                case TYP_UNKNOWN:
-                    noway_assert(!"lvType not set correctly");
-                    varDsc->lvType = TYP_INT;
-                    FALLTHROUGH;
-                default:
-                    varDsc->lvTracked = 0;
-            }
-        }
-        if (varDsc->lvTracked)
-        {
-            tracked[trackedCount++] = lclNum;
-        }
-    }
-    if (compCodeOpt() == SMALL_CODE)
-    {
-        jitstd::sort(tracked, tracked + trackedCount, LclVarDsc_SmallCode_Less(lvaTable DEBUGARG(lvaCount)));
-    }
-    else
-    {
-        jitstd::sort(tracked, tracked + trackedCount, LclVarDsc_BlendedCode_Less(lvaTable DEBUGARG(lvaCount)));
-    }
-    lvaTrackedCount = min((unsigned)JitConfig.JitMaxLocalsToTrack(), trackedCount);
-    JITDUMP("Tracked variable (%u out of %u) table:\n", lvaTrackedCount, lvaCount);
-    for (unsigned varIndex = 0; varIndex < lvaTrackedCount; varIndex++)
-    {
-        LclVarDsc* varDsc = lvaGetDesc(tracked[varIndex]);
-        assert(varDsc->lvTracked);
-        varDsc->lvVarIndex = static_cast<unsigned short>(varIndex);
-        INDEBUG(if (verbose) { gtDispLclVar(tracked[varIndex]); })
-        JITDUMP(" [%6s]: refCnt = %4u, refCntWtd = %6s\n", varTypeName(varDsc->TypeGet()), varDsc->lvRefCnt(),
-                refCntWtd2str(varDsc->lvRefCntWtd()));
-    }
-    JITDUMP("\n");
-    for (unsigned varIndex = lvaTrackedCount; varIndex < trackedCount; varIndex++)
-    {
-        LclVarDsc* varDsc = lvaGetDesc(tracked[varIndex]);
-        assert(varDsc->lvTracked);
-        varDsc->lvTracked = 0;
-    }
-    lvaCurEpoch++;
-    lvaTrackedCountInSizeTUnits =
-        roundUp((unsigned)lvaTrackedCount, (unsigned)(sizeof(size_t) * 8)) / unsigned(sizeof(size_t) * 8);
-#ifdef DEBUG
-    VarSetOps::AssignNoCopy(this, lvaTrackedVars, VarSetOps::MakeFull(this));
-#endif
-}
-/*****************************************************************************
- *
- *  This is called by lvaMarkLclRefs to disqualify a variable from being
- *  considered by optAddCopies()
- */
-void LclVarDsc::lvaDisqualifyVar()
-{
-    this->lvDisqualify = true;
-    this->lvSingleDef  = false;
-    this->lvDefStmt    = nullptr;
-}
-#ifdef FEATURE_SIMD
-var_types LclVarDsc::GetSimdBaseType() const
-{
-    CorInfoType simdBaseJitType = GetSimdBaseJitType();
-    if (simdBaseJitType == CORINFO_TYPE_UNDEF)
-    {
-        return TYP_UNKNOWN;
-    }
-    return JitType2PreciseVarType(simdBaseJitType);
-}
-#endif // FEATURE_SIMD
-unsigned LclVarDsc::lvSize() const // Size needed for storage representation. Only used for structs or TYP_BLK.
-{
-    assert(varTypeIsStruct(lvType) || (lvType == TYP_BLK) || (lvPromoted && lvUnusedStruct));
-    if (lvIsParam)
-    {
-        assert(varTypeIsStruct(lvType));
-        const bool     isFloatHfa       = (lvIsHfa() && (GetHfaType() == TYP_FLOAT));
-        const unsigned argSizeAlignment = Compiler::eeGetArgSizeAlignment(lvType, isFloatHfa);
-        return roundUp(lvExactSize, argSizeAlignment);
-    }
-#if defined(FEATURE_SIMD) && !defined(TARGET_64BIT)
-    if (lvType == TYP_SIMD12)
-    {
-        assert(!lvIsParam);
-        assert(lvExactSize == 12);
-        return 16;
-    }
-#endif // defined(FEATURE_SIMD) && !defined(TARGET_64BIT)
-    return roundUp(lvExactSize, TARGET_POINTER_SIZE);
-}
-/**********************************************************************************
-* Get stack size of the varDsc.
-*/
-size_t LclVarDsc::lvArgStackSize() const
-{
-    assert(!this->lvIsRegArg);
-    size_t stackSize = 0;
-    if (varTypeIsStruct(this))
-    {
-#if defined(WINDOWS_AMD64_ABI)
-        stackSize = TARGET_POINTER_SIZE;
-#elif defined(TARGET_ARM64) || defined(UNIX_AMD64_ABI) || defined(TARGET_LOONGARCH64)
-        stackSize = this->lvSize();
-#if defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-        if ((stackSize > TARGET_POINTER_SIZE * 2) && (!this->lvIsHfa()))
-        {
-            stackSize = TARGET_POINTER_SIZE;
-        }
-#endif // defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-#else // !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI !TARGET_LOONGARCH64
-        NYI("Unsupported target.");
-        unreached();
-#endif //  !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI
-    }
-    else
-    {
-        stackSize = TARGET_POINTER_SIZE;
-    }
-    return stackSize;
-}
-var_types LclVarDsc::GetRegisterType(const GenTreeLclVarCommon* tree) const
-{
-    var_types targetType = tree->TypeGet();
-    if (targetType == TYP_STRUCT)
-    {
-        ClassLayout* layout;
-        if (tree->OperIs(GT_LCL_FLD, GT_STORE_LCL_FLD))
-        {
-            layout = tree->AsLclFld()->GetLayout();
-        }
-        else
-        {
-            assert((TypeGet() == TYP_STRUCT) && tree->OperIs(GT_LCL_VAR, GT_STORE_LCL_VAR));
-            layout = GetLayout();
-        }
-        targetType = layout->GetRegisterType();
-    }
-#ifdef DEBUG
-    if ((targetType != TYP_UNDEF) && tree->OperIs(GT_STORE_LCL_VAR) && lvNormalizeOnStore())
-    {
-        const bool phiStore = (tree->gtGetOp1()->OperIsNonPhiLocal() == false);
-        assert(phiStore || targetType == genActualType(TypeGet()));
-    }
-#endif
-    return targetType;
-}
-var_types LclVarDsc::GetRegisterType() const
-{
-    if (TypeGet() != TYP_STRUCT)
-    {
-#if !defined(TARGET_64BIT)
-        if (TypeGet() == TYP_LONG)
-        {
-            return TYP_UNDEF;
-        }
-#endif
-        return TypeGet();
-    }
-    assert(m_layout != nullptr);
-    return m_layout->GetRegisterType();
-}
-var_types LclVarDsc::GetStackSlotHomeType() const
-{
-    if (varTypeIsSmall(TypeGet()))
-    {
-        if (compMacOsArm64Abi() && lvIsParam && !lvIsRegArg)
-        {
-            return GetRegisterType();
-        }
-        if (lvIsOSRLocal && lvIsStructField)
-        {
-#if defined(TARGET_X86)
-            unreached();
-#else
-            return GetRegisterType();
-#endif
-        }
-    }
-    return genActualType(GetRegisterType());
-}
-bool LclVarDsc::CanBeReplacedWithItsField(Compiler* comp) const
-{
-    if (!lvPromoted)
-    {
-        return false;
-    }
-    if (comp->lvaGetPromotionType(this) != Compiler::PROMOTION_TYPE_INDEPENDENT)
-    {
-        return false;
-    }
-    if (lvFieldCnt != 1)
-    {
-        return false;
-    }
-    if (lvContainsHoles)
-    {
-        return false;
-    }
-#if defined(FEATURE_SIMD)
-    LclVarDsc* fieldDsc = comp->lvaGetDesc(lvFieldLclStart);
-    if (varTypeIsSIMD(fieldDsc))
-    {
-        return false;
-    }
-#endif // FEATURE_SIMD
-    return true;
-}
-void Compiler::lvaMarkLclRefs(GenTree* tree, BasicBlock* block, Statement* stmt, bool isRecompute)
-{
-    const weight_t weight = block->getBBWeight(this);
-    /* Is this a call to unmanaged code ? */
-    if (tree->IsCall() && compMethodRequiresPInvokeFrame())
-    {
-        assert((!opts.ShouldUsePInvokeHelpers()) || (info.compLvFrameListRoot == BAD_VAR_NUM));
-        if (!opts.ShouldUsePInvokeHelpers())
-        {
-            /* Get the special variable descriptor */
-            LclVarDsc* varDsc = lvaGetDesc(info.compLvFrameListRoot);
-            /* Increment the ref counts twice */
-            varDsc->incRefCnts(weight, this);
-            varDsc->incRefCnts(weight, this);
-        }
-    }
-    if (!isRecompute)
-    {
-        /* Is this an assignment? */
-        if (tree->OperIs(GT_ASG))
-        {
-            GenTree* op1 = tree->AsOp()->gtOp1;
-            GenTree* op2 = tree->AsOp()->gtOp2;
-            /* Is this an assignment to a local variable? */
-            if (op1->gtOper == GT_LCL_VAR)
-            {
-                LclVarDsc* varDsc = lvaGetDesc(op1->AsLclVarCommon());
-                if (varDsc->lvPinned && varDsc->lvAllDefsAreNoGc)
-                {
-                    if (!op2->IsNotGcDef())
-                    {
-                        varDsc->lvAllDefsAreNoGc = false;
-                    }
-                }
-                if (op2->gtType != TYP_BOOL)
-                {
-                    /* Only simple assignments allowed for booleans */
-                    if (tree->gtOper != GT_ASG)
-                    {
-                        goto NOT_BOOL;
-                    }
-                    /* Is the RHS clearly a boolean value? */
-                    switch (op2->gtOper)
-                    {
-                        case GT_CNS_INT:
-                            if (op2->AsIntCon()->gtIconVal == 0)
-                            {
-                                break;
-                            }
-                            if (op2->AsIntCon()->gtIconVal == 1)
-                            {
-                                break;
-                            }
-                            FALLTHROUGH;
-                        default:
-                            if (op2->OperIsCompare())
-                            {
-                                break;
-                            }
-                        NOT_BOOL:
-                            varDsc->lvIsBoolean = false;
-                            break;
-                    }
-                }
-            }
-        }
-    }
-    if (tree->OperIsLocalAddr())
-    {
-        LclVarDsc* varDsc = lvaGetDesc(tree->AsLclVarCommon());
-        assert(varDsc->IsAddressExposed());
-        varDsc->incRefCnts(weight, this);
-        return;
-    }
-    if ((tree->gtOper != GT_LCL_VAR) && (tree->gtOper != GT_LCL_FLD))
-    {
-        return;
-    }
-    /* This must be a local variable reference */
-    if ((tree->gtFlags & GTF_VAR_CONTEXT) != 0)
-    {
-        assert(tree->OperIs(GT_LCL_VAR));
-        if (!lvaGenericsContextInUse)
-        {
-            JITDUMP("-- generic context in use at [%06u]\n", dspTreeID(tree));
-            lvaGenericsContextInUse = true;
-        }
-    }
-    assert((tree->gtOper == GT_LCL_VAR) || (tree->gtOper == GT_LCL_FLD));
-    unsigned lclNum = tree->AsLclVarCommon()->GetLclNum();
-    LclVarDsc* varDsc = lvaGetDesc(lclNum);
-    /* Increment the reference counts */
-    varDsc->incRefCnts(weight, this);
-#ifdef DEBUG
-    if (varDsc->lvIsStructField)
-    {
-        LclVarDsc* parentStruct = lvaGetDesc(varDsc->lvParentLcl);
-        assert(!parentStruct->lvUndoneStructPromotion);
-    }
-#endif
-    if (!isRecompute)
-    {
-        if (lvaVarAddrExposed(lclNum))
-        {
-            varDsc->lvIsBoolean      = false;
-            varDsc->lvAllDefsAreNoGc = false;
-        }
-        if (tree->gtOper == GT_LCL_FLD)
-        {
-            varDsc->lvaDisqualifyVar();
-            return;
-        }
-        if (fgDomsComputed && IsDominatedByExceptionalEntry(block))
-        {
-            SetVolatileHint(varDsc);
-        }
-        /* Record if the variable has a single def or not */
-        if (!varDsc->lvDisqualify) // If this variable is already disqualified, we can skip this
-        {
-            if (tree->gtFlags & GTF_VAR_DEF) // Is this is a def of our variable
-            {
-                /*
-                   If we have one of these cases:
-                       1.    We have already seen a definition (i.e lvSingleDef is true)
-                       2. or info.CompInitMem is true (thus this would be the second definition)
-                       3. or we have an assignment inside QMARK-COLON trees
-                       4. or we have an update form of assignment (i.e. +=, -=, *=)
-                   Then we must disqualify this variable for use in optAddCopies()
-                   Note that all parameters start out with lvSingleDef set to true
-                */
-                if ((varDsc->lvSingleDef == true) || (info.compInitMem == true) || (tree->gtFlags & GTF_COLON_COND) ||
-                    (tree->gtFlags & GTF_VAR_USEASG))
-                {
-                    varDsc->lvaDisqualifyVar();
-                }
-                else
-                {
-                    varDsc->lvSingleDef = true;
-                    varDsc->lvDefStmt   = stmt;
-                }
-            }
-            else // otherwise this is a ref of our variable
-            {
-                if (BlockSetOps::MayBeUninit(varDsc->lvRefBlks))
-                {
-                    BlockSetOps::AssignNoCopy(this, varDsc->lvRefBlks, BlockSetOps::MakeEmpty(this));
-                }
-                BlockSetOps::AddElemD(this, varDsc->lvRefBlks, block->bbNum);
-            }
-        }
-        if (!varDsc->lvDisqualifySingleDefRegCandidate) // If this var is already disqualified, we can skip this
-        {
-            if (tree->gtFlags & GTF_VAR_DEF) // Is this is a def of our variable
-            {
-                bool bbInALoop  = (block->bbFlags & BBF_BACKWARD_JUMP) != 0;
-                bool bbIsReturn = block->bbJumpKind == BBJ_RETURN;
-                bool needsExplicitZeroInit = fgVarNeedsExplicitZeroInit(lclNum, bbInALoop, bbIsReturn);
-                if (varDsc->lvSingleDefRegCandidate || needsExplicitZeroInit)
-                {
-#ifdef DEBUG
-                    if (needsExplicitZeroInit)
-                    {
-                        varDsc->lvSingleDefDisqualifyReason = 'Z';
-                        JITDUMP("V%02u needs explicit zero init. Disqualified as a single-def register candidate.\n",
-                                lclNum);
-                    }
-                    else
-                    {
-                        varDsc->lvSingleDefDisqualifyReason = 'M';
-                        JITDUMP("V%02u has multiple definitions. Disqualified as a single-def register candidate.\n",
-                                lclNum);
-                    }
-#endif // DEBUG
-                    varDsc->lvSingleDefRegCandidate           = false;
-                    varDsc->lvDisqualifySingleDefRegCandidate = true;
-                }
-                else if (!varDsc->lvDoNotEnregister)
-                {
-                    CLANG_FORMAT_COMMENT_ANCHOR;
-#if FEATURE_PARTIAL_SIMD_CALLEE_SAVE
-                    if (!varTypeNeedsPartialCalleeSave(varDsc->GetRegisterType()))
-#endif
-                    {
-                        varDsc->lvSingleDefRegCandidate = true;
-                        JITDUMP("Marking EH Var V%02u as a register candidate.\n", lclNum);
-                    }
-                }
-            }
-        }
-        bool allowStructs = false;
-#ifdef UNIX_AMD64_ABI
-        allowStructs = varTypeIsStruct(varDsc);
-#endif // UNIX_AMD64_ABI
-        /* Variables must be used as the same type throughout the method */
-        noway_assert(varDsc->lvType == TYP_UNDEF || tree->gtType == TYP_UNKNOWN || allowStructs ||
-                     genActualType(varDsc->TypeGet()) == genActualType(tree->gtType) ||
-                     (tree->gtType == TYP_BYREF && varDsc->TypeGet() == TYP_I_IMPL) ||
-                     (tree->gtType == TYP_I_IMPL && varDsc->TypeGet() == TYP_BYREF) || (tree->gtFlags & GTF_VAR_CAST) ||
-                     (varTypeIsFloating(varDsc) && varTypeIsFloating(tree)) ||
-                     (varTypeIsStruct(varDsc) == varTypeIsStruct(tree)));
-        /* Remember the type of the reference */
-        if (tree->gtType == TYP_UNKNOWN || varDsc->lvType == TYP_UNDEF)
-        {
-            varDsc->lvType = tree->gtType;
-            noway_assert(genActualType(varDsc->TypeGet()) == tree->gtType); // no truncation
-        }
-#ifdef DEBUG
-        if (tree->gtFlags & GTF_VAR_CAST)
-        {
-            if (tree->TypeGet() != TYP_STRUCT)
-            {
-                unsigned treeSize = genTypeSize(tree->TypeGet());
-                unsigned varSize  = genTypeSize(varDsc->TypeGet());
-                if (varDsc->TypeGet() == TYP_STRUCT)
-                {
-                    varSize = varDsc->lvSize();
-                }
-                assert(treeSize <= varSize);
-            }
-        }
-#endif
-    }
-}
-bool Compiler::IsDominatedByExceptionalEntry(BasicBlock* block)
-{
-    assert(fgDomsComputed);
-    return block->IsDominatedByExceptionalEntryFlag();
-}
-void Compiler::SetVolatileHint(LclVarDsc* varDsc)
-{
-    varDsc->lvVolatileHint = true;
-}
-void Compiler::lvaMarkLocalVars(BasicBlock* block, bool isRecompute)
-{
-    class MarkLocalVarsVisitor final : public GenTreeVisitor<MarkLocalVarsVisitor>
-    {
-    private:
-        BasicBlock* m_block;
-        Statement*  m_stmt;
-        bool        m_isRecompute;
-    public:
-        enum
-        {
-            DoPreOrder = true,
-        };
-        MarkLocalVarsVisitor(Compiler* compiler, BasicBlock* block, Statement* stmt, bool isRecompute)
-            : GenTreeVisitor<MarkLocalVarsVisitor>(compiler), m_block(block), m_stmt(stmt), m_isRecompute(isRecompute)
-        {
-        }
-        Compiler::fgWalkResult PreOrderVisit(GenTree** use, GenTree* user)
-        {
-            assert(!m_isRecompute);
-            m_compiler->lvaMarkLclRefs(*use, m_block, m_stmt, m_isRecompute);
-            return WALK_CONTINUE;
-        }
-    };
-    JITDUMP("\n*** %s local variables in block " FMT_BB " (weight=%s)\n", isRecompute ? "recomputing" : "marking",
-            block->bbNum, refCntWtd2str(block->getBBWeight(this)));
-    for (Statement* const stmt : block->NonPhiStatements())
-    {
-        MarkLocalVarsVisitor visitor(this, block, stmt, isRecompute);
-        DISPSTMT(stmt);
-        visitor.WalkTree(stmt->GetRootNodePointer(), nullptr);
-    }
-}
-PhaseStatus Compiler::lvaMarkLocalVars()
-{
-    JITDUMP("\n*************** In lvaMarkLocalVars()");
-    if (compMethodRequiresPInvokeFrame())
-    {
-        assert((!opts.ShouldUsePInvokeHelpers()) || (info.compLvFrameListRoot == BAD_VAR_NUM));
-        if (!opts.ShouldUsePInvokeHelpers())
-        {
-            noway_assert(info.compLvFrameListRoot >= info.compLocalsCount && info.compLvFrameListRoot < lvaCount);
-        }
-    }
-    unsigned const lvaCountOrig = lvaCount;
-#if !defined(FEATURE_EH_FUNCLETS)
-    if (ehNeedsShadowSPslots())
-    {
-        unsigned slotsNeeded = 1;
-        unsigned handlerNestingLevel = ehMaxHndNestingCount;
-        if (opts.compDbgEnC && (handlerNestingLevel < (unsigned)MAX_EnC_HANDLER_NESTING_LEVEL))
-            handlerNestingLevel = (unsigned)MAX_EnC_HANDLER_NESTING_LEVEL;
-        slotsNeeded += handlerNestingLevel;
-        slotsNeeded++;
-        slotsNeeded++;
-        lvaShadowSPslotsVar           = lvaGrabTempWithImplicitUse(false DEBUGARG("lvaShadowSPslotsVar"));
-        LclVarDsc* shadowSPslotsVar   = lvaGetDesc(lvaShadowSPslotsVar);
-        shadowSPslotsVar->lvType      = TYP_BLK;
-        shadowSPslotsVar->lvExactSize = (slotsNeeded * TARGET_POINTER_SIZE);
-    }
-#endif // !FEATURE_EH_FUNCLETS
-    if (!IsTargetAbi(CORINFO_NATIVEAOT_ABI))
-    {
-#if defined(FEATURE_EH_FUNCLETS)
-        if (ehNeedsPSPSym())
-        {
-            lvaPSPSym            = lvaGrabTempWithImplicitUse(false DEBUGARG("PSPSym"));
-            LclVarDsc* lclPSPSym = lvaGetDesc(lvaPSPSym);
-            lclPSPSym->lvType    = TYP_I_IMPL;
-            lvaSetVarDoNotEnregister(lvaPSPSym DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
-        }
-#endif // FEATURE_EH_FUNCLETS
-#ifdef JIT32_GCENCODER
-        if (compLocallocUsed)
-        {
-            lvaLocAllocSPvar         = lvaGrabTempWithImplicitUse(false DEBUGARG("LocAllocSPvar"));
-            LclVarDsc* locAllocSPvar = lvaGetDesc(lvaLocAllocSPvar);
-            locAllocSPvar->lvType    = TYP_I_IMPL;
-        }
-#endif // JIT32_GCENCODER
-    }
-    lvaRefCountState = RCS_NORMAL;
-#if defined(DEBUG)
-    const bool setSlotNumbers = true;
-#else
-    const bool setSlotNumbers = opts.compScopeInfo && (info.compVarScopesCount > 0);
-#endif // defined(DEBUG)
-    const bool isRecompute = false;
-    lvaComputeRefCounts(isRecompute, setSlotNumbers);
-    if (!PreciseRefCountsRequired())
-    {
-        return (lvaCount != lvaCountOrig) ? PhaseStatus::MODIFIED_EVERYTHING : PhaseStatus::MODIFIED_NOTHING;
-    }
-    const bool reportParamTypeArg = lvaReportParamTypeArg();
-    if (lvaKeepAliveAndReportThis())
-    {
-        lvaGetDesc(0u)->lvImplicitlyReferenced = reportParamTypeArg;
-    }
-    else if (lvaReportParamTypeArg())
-    {
-        assert(info.compTypeCtxtArg != (int)BAD_VAR_NUM);
-        lvaGetDesc(info.compTypeCtxtArg)->lvImplicitlyReferenced = reportParamTypeArg;
-    }
-    assert(PreciseRefCountsRequired());
-    return (lvaCount != lvaCountOrig) ? PhaseStatus::MODIFIED_EVERYTHING : PhaseStatus::MODIFIED_NOTHING;
-}
-void Compiler::lvaComputeRefCounts(bool isRecompute, bool setSlotNumbers)
-{
-    JITDUMP("\n*** lvaComputeRefCounts ***\n");
-    unsigned   lclNum = 0;
-    LclVarDsc* varDsc = nullptr;
-    if (!PreciseRefCountsRequired())
-    {
-        if (isRecompute)
-        {
-#if defined(DEBUG)
-            for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-            {
-                const bool isSpecialVarargsParam = varDsc->lvIsParam && raIsVarargsStackArg(lclNum);
-                if (isSpecialVarargsParam)
-                {
-                    assert(varDsc->lvRefCnt() == 0);
-                }
-                else
-                {
-                    assert(varDsc->lvImplicitlyReferenced);
-                }
-                assert(!varDsc->lvTracked);
-            }
-#endif // defined (DEBUG)
-            return;
-        }
-        for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-        {
-            varDsc->setLvRefCnt(0);
-            varDsc->setLvRefCntWtd(BB_ZERO_WEIGHT);
-            const bool isSpecialVarargsParam = varDsc->lvIsParam && raIsVarargsStackArg(lclNum);
-            if (!isSpecialVarargsParam)
-            {
-                varDsc->lvImplicitlyReferenced = 1;
-            }
-            varDsc->lvTracked = 0;
-            if (setSlotNumbers)
-            {
-                varDsc->lvSlotNum = lclNum;
-            }
-            assert((varDsc->lvType != TYP_UNDEF) && (varDsc->lvType != TYP_VOID) && (varDsc->lvType != TYP_UNKNOWN));
-        }
-        lvaCurEpoch++;
-        lvaTrackedCount             = 0;
-        lvaTrackedCountInSizeTUnits = 0;
-        return;
-    }
-    for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-    {
-        varDsc->setLvRefCnt(0);
-        varDsc->setLvRefCntWtd(BB_ZERO_WEIGHT);
-        if (setSlotNumbers)
-        {
-            varDsc->lvSlotNum = lclNum;
-        }
-        if (!isRecompute)
-        {
-            varDsc->lvSingleDef             = varDsc->lvIsParam;
-            varDsc->lvSingleDefRegCandidate = varDsc->lvIsParam;
-            varDsc->lvAllDefsAreNoGc = (varDsc->lvImplicitlyReferenced == false);
-        }
-    }
-    const bool oldLvaGenericsContextInUse = lvaGenericsContextInUse;
-    lvaGenericsContextInUse               = false;
-    JITDUMP("\n*** lvaComputeRefCounts -- explicit counts ***\n");
-    for (BasicBlock* const block : Blocks())
-    {
-        if (block->IsLIR())
-        {
-            assert(isRecompute);
-            const weight_t weight = block->getBBWeight(this);
-            for (GenTree* node : LIR::AsRange(block))
-            {
-                switch (node->OperGet())
-                {
-                    case GT_LCL_VAR:
-                    case GT_LCL_FLD:
-                    case GT_LCL_VAR_ADDR:
-                    case GT_LCL_FLD_ADDR:
-                    case GT_STORE_LCL_VAR:
-                    case GT_STORE_LCL_FLD:
-                    {
-                        LclVarDsc* varDsc = lvaGetDesc(node->AsLclVarCommon());
-                        if (varDsc->lvLiveInOutOfHndlr && !varDsc->lvDoNotEnregister &&
-                            ((node->gtFlags & GTF_VAR_DEF) != 0))
-                        {
-                            varDsc->incRefCnts(0, this);
-                        }
-                        else
-                        {
-                            varDsc->incRefCnts(weight, this);
-                        }
-                        if ((node->gtFlags & GTF_VAR_CONTEXT) != 0)
-                        {
-                            assert(node->OperIs(GT_LCL_VAR));
-                            lvaGenericsContextInUse = true;
-                        }
-                        break;
-                    }
-                    default:
-                        break;
-                }
-            }
-        }
-        else
-        {
-            lvaMarkLocalVars(block, isRecompute);
-        }
-    }
-    if (oldLvaGenericsContextInUse && !lvaGenericsContextInUse)
-    {
-        JITDUMP("\n** Generics context no longer in use\n");
-    }
-    else if (lvaGenericsContextInUse && !oldLvaGenericsContextInUse)
-    {
-        assert(!"unexpected new use of generics context");
-    }
-    JITDUMP("\n*** lvaComputeRefCounts -- implicit counts ***\n");
-    for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-    {
-        if (varDsc->lvIsRegArg)
-        {
-            if ((lclNum < info.compArgsCount) && (varDsc->lvRefCnt() > 0))
-            {
-                varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
-                varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
-            }
-            if (varDsc->lvIsStructField)
-            {
-                varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
-            }
-        }
-        if (compJmpOpUsed && varDsc->lvIsParam && (varDsc->lvRefCnt() == 0))
-        {
-            if (!raIsVarargsStackArg(lclNum))
-            {
-                varDsc->lvImplicitlyReferenced = 1;
-            }
-        }
-        if (varDsc->lvPinned && varDsc->lvAllDefsAreNoGc)
-        {
-            varDsc->lvPinned = 0;
-            JITDUMP("V%02u was unpinned as all def candidates were local.\n", lclNum);
-        }
-    }
-}
-void Compiler::lvaAllocOutgoingArgSpaceVar()
-{
-#if FEATURE_FIXED_OUT_ARGS
-    if (lvaOutgoingArgSpaceVar == BAD_VAR_NUM)
-    {
-        lvaOutgoingArgSpaceVar = lvaGrabTemp(false DEBUGARG("OutgoingArgSpace"));
-        lvaTable[lvaOutgoingArgSpaceVar].lvType                 = TYP_LCLBLK;
-        lvaTable[lvaOutgoingArgSpaceVar].lvImplicitlyReferenced = 1;
-    }
-    noway_assert(lvaOutgoingArgSpaceVar >= info.compLocalsCount && lvaOutgoingArgSpaceVar < lvaCount);
-#endif // FEATURE_FIXED_OUT_ARGS
-}
-inline void Compiler::lvaIncrementFrameSize(unsigned size)
-{
-    if (size > MAX_FrameSize || compLclFrameSize + size > MAX_FrameSize)
-    {
-        BADCODE("Frame size overflow");
-    }
-    compLclFrameSize += size;
-}
-/****************************************************************************
-*
-*  Return true if absolute offsets of temps are larger than vars, or in other
-*  words, did we allocate temps before of after vars.  The /GS buffer overrun
-*  checks want temps to be at low stack addresses than buffers
-*/
-bool Compiler::lvaTempsHaveLargerOffsetThanVars()
-{
-#ifdef TARGET_ARM
-    return false;
-#else
-    if (compGSReorderStackLayout)
-    {
-        return codeGen->isFramePointerUsed();
-    }
-    else
-    {
-        return true;
-    }
-#endif
-}
-/****************************************************************************
-*
-*  Return an upper bound estimate for the size of the compiler spill temps
-*
-*/
-unsigned Compiler::lvaGetMaxSpillTempSize()
-{
-    unsigned result = 0;
-    if (codeGen->regSet.hasComputedTmpSize())
-    {
-        result = codeGen->regSet.tmpGetTotalSize();
-    }
-    else
-    {
-        result = MAX_SPILL_TEMP_SIZE;
-    }
-    return result;
-}
-/*****************************************************************************
- *
- *  Compute stack frame offsets for arguments, locals and optionally temps.
- *
- *  The frame is laid out as follows for x86:
- *
- *              ESP frames
- *
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      |-----------------------| <---- Virtual '0'
- *      |    return address     |
- *      +=======================+
- *      |Callee saved registers |
- *      |-----------------------|
- *      |       Temps           |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------| <---- Ambient ESP
- *      |   Arguments for the   |
- *      ~    next function      ~
- *      |                       |
- *      |       |               |
- *      |       | Stack grows   |
- *              | downward
- *              V
- *
- *
- *              EBP frames
- *
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      |-----------------------| <---- Virtual '0'
- *      |    return address     |
- *      +=======================+
- *      |    incoming EBP       |
- *      |-----------------------| <---- EBP
- *      |Callee saved registers |
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  Last-executed-filter |
- *      |-----------------------|
- *      |                       |
- *      ~      Shadow SPs       ~
- *      |                       |
- *      |-----------------------|
- *      |                       |
- *      ~      Variables        ~
- *      |                       |
- *      ~-----------------------|
- *      |       Temps           |
- *      |-----------------------|
- *      |       localloc        |
- *      |-----------------------| <---- Ambient ESP
- *      |   Arguments for the   |
- *      |    next function      ~
- *      |                       |
- *      |       |               |
- *      |       | Stack grows   |
- *              | downward
- *              V
- *
- *
- *  The frame is laid out as follows for x64:
- *
- *              RSP frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      |-----------------------|
- *      |   4 fixed incoming    |
- *      |    argument slots     |
- *      |-----------------------| <---- Caller's SP & Virtual '0'
- *      |    return address     |
- *      +=======================+
- *      | Callee saved Int regs |
- *      -------------------------
- *      |        Padding        | <---- this padding (0 or 8 bytes) is to ensure flt registers are saved at a mem location aligned at 16-bytes
- *      |                       |       so that we can save 128-bit callee saved xmm regs using performant "movaps" instruction instead of "movups"
- *      -------------------------
- *      | Callee saved Flt regs | <----- entire 128-bits of callee saved xmm registers are stored here
- *      |-----------------------|
- *      |         Temps         |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |   Arguments for the   |
- *      ~    next function      ~
- *      |                       |
- *      |-----------------------|
- *      |   4 fixed outgoing    |
- *      |    argument slots     |
- *      |-----------------------| <---- Ambient RSP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *              RBP frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      |-----------------------|
- *      |   4 fixed incoming    |
- *      |    argument slots     |
- *      |-----------------------| <---- Caller's SP & Virtual '0'
- *      |    return address     |
- *      +=======================+
- *      | Callee saved Int regs |
- *      -------------------------
- *      |        Padding        |
- *      -------------------------
- *      | Callee saved Flt regs |
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |                       |
- *      |                       |
- *      ~       Variables       ~
- *      |                       |
- *      |                       |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |                       |
- *      ~       localloc        ~   // not in frames with EH
- *      |                       |
- *      |-----------------------|
- *      |        PSPSym         |   // only in frames with EH (thus no localloc)
- *      |                       |
- *      |-----------------------| <---- RBP in localloc frames (max 240 bytes from Initial-SP)
- *      |   Arguments for the   |
- *      ~    next function      ~
- *      |                       |
- *      |-----------------------|
- *      |   4 fixed outgoing    |
- *      |    argument slots     |
- *      |-----------------------| <---- Ambient RSP (before localloc, this is Initial-SP)
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *  The frame is laid out as follows for ARM (this is a general picture; details may differ for different conditions):
- *
- *              SP frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      +=======================+ <---- Caller's SP
- *      |  Pre-spill registers  |
- *      |-----------------------| <---- Virtual '0'
- *      |Callee saved registers |
- *      |-----------------------|
- *      ~ possible double align ~
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |   Stub Argument Var   |
- *      |-----------------------|
- *      |Inlined PInvoke Frame V|
- *      |-----------------------|
- *      ~ possible double align ~
- *      |-----------------------|
- *      |   Arguments for the   |
- *      ~    next function      ~
- *      |                       |
- *      |-----------------------| <---- Ambient SP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *              FP / R11 frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      +=======================+ <---- Caller's SP
- *      |  Pre-spill registers  |
- *      |-----------------------| <---- Virtual '0'
- *      |Callee saved registers |
- *      |-----------------------|
- *      |        PSPSym         |   // Only for frames with EH, which means FP-based frames
- *      |-----------------------|
- *      ~ possible double align ~
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |   Stub Argument Var   |
- *      |-----------------------|
- *      |Inlined PInvoke Frame V|
- *      |-----------------------|
- *      ~ possible double align ~
- *      |-----------------------|
- *      |       localloc        |
- *      |-----------------------|
- *      |   Arguments for the   |
- *      ~    next function      ~
- *      |                       |
- *      |-----------------------| <---- Ambient SP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *  The frame is laid out as follows for ARM64 (this is a general picture; details may differ for different conditions):
- *  NOTE: SP must be 16-byte aligned, so there may be alignment slots in the frame.
- *  We will often save and establish a frame pointer to create better ETW stack walks.
- *
- *              SP frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      +=======================+ <---- Caller's SP
- *      |         homed         | // this is only needed if reg argument need to be homed, e.g., for varargs
- *      |   register arguments  |
- *      |-----------------------| <---- Virtual '0'
- *      |Callee saved registers |
- *      |   except fp/lr        |
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |   Stub Argument Var   |
- *      |-----------------------|
- *      |Inlined PInvoke Frame V|
- *      |-----------------------|
- *      |      Saved LR         |
- *      |-----------------------|
- *      |      Saved FP         | <---- Frame pointer
- *      |-----------------------|
- *      |  Stack arguments for  |
- *      |   the next function   |
- *      |-----------------------| <---- SP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *              FP (R29 / x29) frames
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      +=======================+ <---- Caller's SP
- *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs
- *      |   register arguments  |
- *      |-----------------------| <---- Virtual '0'
- *      |Callee saved registers |
- *      |   except fp/lr        |
- *      |-----------------------|
- *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |   Stub Argument Var   |
- *      |-----------------------|
- *      |Inlined PInvoke Frame V|
- *      |-----------------------|
- *      |      Saved LR         |
- *      |-----------------------|
- *      |      Saved FP         | <---- Frame pointer
- *      |-----------------------|
- *      ~       localloc        ~
- *      |-----------------------|
- *      |  Stack arguments for  |
- *      |   the next function   |
- *      |-----------------------| <---- Ambient SP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *              FP (R29 / x29) frames where FP/LR are stored at the top of the frame (frames requiring GS that have localloc)
- *      |                       |
- *      |-----------------------|
- *      |       incoming        |
- *      |       arguments       |
- *      +=======================+ <---- Caller's SP
- *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs
- *      |   register arguments  |
- *      |-----------------------| <---- Virtual '0'
- *      |      Saved LR         |
- *      |-----------------------|
- *      |      Saved FP         | <---- Frame pointer
- *      |-----------------------|
- *      |Callee saved registers |
- *      |-----------------------|
- *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames
- *      |-----------------------|
- *      |   security object     |
- *      |-----------------------|
- *      |     ParamTypeArg      |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |       Variables       |
- *      |-----------------------|
- *      |  possible GS cookie   |
- *      |-----------------------|
- *      |        Temps          |
- *      |-----------------------|
- *      |   Stub Argument Var   |
- *      |-----------------------|
- *      |Inlined PInvoke Frame V|
- *      |-----------------------|
- *      ~       localloc        ~
- *      |-----------------------|
- *      |  Stack arguments for  |
- *      |   the next function   |
- *      |-----------------------| <---- Ambient SP
- *      |       |               |
- *      ~       | Stack grows   ~
- *      |       | downward      |
- *              V
- *
- *
- *  Doing this all in one pass is 'hard'.  So instead we do it in 2 basic passes:
- *    1. Assign all the offsets relative to the Virtual '0'. Offsets above (the
- *      incoming arguments) are positive. Offsets below (everything else) are
- *      negative.  This pass also calcuates the total frame size (between Caller's
- *      SP/return address and the Ambient SP).
- *    2. Figure out where to place the frame pointer, and then adjust the offsets
- *      as needed for the final stack size and whether the offset is frame pointer
- *      relative or stack pointer relative.
- *
- */
-void Compiler::lvaAssignFrameOffsets(FrameLayoutState curState)
-{
-    noway_assert((lvaDoneFrameLayout < curState) || (curState == REGALLOC_FRAME_LAYOUT));
-    lvaDoneFrameLayout = curState;
-#ifdef DEBUG
-    if (verbose)
-    {
-        printf("*************** In lvaAssignFrameOffsets");
-        if (curState == INITIAL_FRAME_LAYOUT)
-        {
-            printf("(INITIAL_FRAME_LAYOUT)");
-        }
-        else if (curState == PRE_REGALLOC_FRAME_LAYOUT)
-        {
-            printf("(PRE_REGALLOC_FRAME_LAYOUT)");
-        }
-        else if (curState == REGALLOC_FRAME_LAYOUT)
-        {
-            printf("(REGALLOC_FRAME_LAYOUT)");
-        }
-        else if (curState == TENTATIVE_FRAME_LAYOUT)
-        {
-            printf("(TENTATIVE_FRAME_LAYOUT)");
-        }
-        else if (curState == FINAL_FRAME_LAYOUT)
-        {
-            printf("(FINAL_FRAME_LAYOUT)");
-        }
-        else
-        {
-            printf("(UNKNOWN)");
-            unreached();
-        }
-        printf("\n");
-    }
-#endif
-#if FEATURE_FIXED_OUT_ARGS
-    assert(lvaOutgoingArgSpaceVar != BAD_VAR_NUM);
-#endif // FEATURE_FIXED_OUT_ARGS
-    /*-------------------------------------------------------------------------
-     *
-     * First process the arguments.
-     *
-     *-------------------------------------------------------------------------
-     */
-    lvaAssignVirtualFrameOffsetsToArgs();
-    /*-------------------------------------------------------------------------
-     *
-     * Now compute stack offsets for any variables that don't live in registers
-     *
-     *-------------------------------------------------------------------------
-     */
-    lvaAssignVirtualFrameOffsetsToLocals();
-    lvaAlignFrame();
-    /*-------------------------------------------------------------------------
-     *
-     * Now patch the offsets
-     *
-     *-------------------------------------------------------------------------
-     */
-    lvaFixVirtualFrameOffsets();
-    lvaAssignFrameOffsetsToPromotedStructs();
-    /*-------------------------------------------------------------------------
-     *
-     * Finalize
-     *
-     *-------------------------------------------------------------------------
-     */
-    if (curState < FINAL_FRAME_LAYOUT)
-    {
-        codeGen->resetFramePointerUsedWritePhase();
-    }
-}
-/*****************************************************************************
- *  lvaFixVirtualFrameOffsets() : Now that everything has a virtual offset,
- *  determine the final value for the frame pointer (if needed) and then
- *  adjust all the offsets appropriately.
- *
- *  This routine fixes virtual offset to be relative to frame pointer or SP
- *  based on whether varDsc->lvFramePointerBased is true or false respectively.
- */
-void Compiler::lvaFixVirtualFrameOffsets()
-{
-    LclVarDsc* varDsc;
-#if defined(FEATURE_EH_FUNCLETS) && defined(TARGET_AMD64)
-    if (lvaPSPSym != BAD_VAR_NUM)
-    {
-        varDsc = lvaGetDesc(lvaPSPSym);
-        assert(varDsc->lvFramePointerBased); // We always access it RBP-relative.
-        assert(!varDsc->lvMustInit);         // It is never "must init".
-        varDsc->SetStackOffset(codeGen->genCallerSPtoInitialSPdelta() + lvaLclSize(lvaOutgoingArgSpaceVar));
-        if (opts.IsOSR())
-        {
-            varDsc->SetStackOffset(varDsc->GetStackOffset() - info.compPatchpointInfo->TotalFrameSize());
-        }
-    }
-#endif
-    int delta = 0;
-#ifdef TARGET_XARCH
-    delta += REGSIZE_BYTES; // pushed PC (return address) for x86/x64
-    JITDUMP("--- delta bump %d for RA\n", REGSIZE_BYTES);
-    if (codeGen->doubleAlignOrFramePointerUsed())
-    {
-        JITDUMP("--- delta bump %d for FP\n", REGSIZE_BYTES);
-        delta += REGSIZE_BYTES; // pushed EBP (frame pointer)
-    }
-#endif
-    if (!codeGen->isFramePointerUsed())
-    {
-        JITDUMP("--- delta bump %d for RSP frame\n", codeGen->genTotalFrameSize());
-        delta += codeGen->genTotalFrameSize();
-    }
-#if defined(TARGET_ARM)
-    else
-    {
-        delta += 2 * REGSIZE_BYTES;
-    }
-#elif defined(TARGET_AMD64) || defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-    else
-    {
-        JITDUMP("--- delta bump %d for FP frame\n", codeGen->genTotalFrameSize() - codeGen->genSPtoFPdelta());
-        delta += codeGen->genTotalFrameSize() - codeGen->genSPtoFPdelta();
-    }
-#endif // TARGET_AMD64 || TARGET_ARM64 || TARGET_LOONGARCH64
-    if (opts.IsOSR())
-    {
-#if defined(TARGET_AMD64) || defined(TARGET_ARM64)
-        JITDUMP("--- delta bump %d for OSR + Tier0 frame\n", info.compPatchpointInfo->TotalFrameSize());
-        delta += info.compPatchpointInfo->TotalFrameSize();
-#endif
-    }
-    JITDUMP("--- virtual stack offset to actual stack offset delta is %d\n", delta);
-    unsigned lclNum;
-    for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-    {
-        bool doAssignStkOffs = true;
-        noway_assert(!varDsc->lvFramePointerBased || codeGen->doubleAlignOrFramePointerUsed());
-        if (varDsc->lvIsStructField)
-        {
-            LclVarDsc*       parentvarDsc  = lvaGetDesc(varDsc->lvParentLcl);
-            lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
-#if defined(TARGET_X86)
-            if ((!varDsc->lvIsParam || parentvarDsc->lvIsParam) && promotionType == PROMOTION_TYPE_DEPENDENT)
-#else
-            if (!varDsc->lvIsParam && promotionType == PROMOTION_TYPE_DEPENDENT)
-#endif
-            {
-                doAssignStkOffs = false; // Assigned later in lvaAssignFrameOffsetsToPromotedStructs()
-            }
-        }
-        if (!varDsc->lvOnFrame)
-        {
-            if (!varDsc->lvIsParam
-#if !defined(TARGET_AMD64)
-                || (varDsc->lvIsRegArg
-#if defined(TARGET_ARM) && defined(PROFILING_SUPPORTED)
-                    && compIsProfilerHookNeeded() &&
-                    !lvaIsPreSpilled(lclNum, codeGen->regSet.rsMaskPreSpillRegs(false)) // We need assign stack offsets
-#endif
-                    )
-#endif // !defined(TARGET_AMD64)
-                    )
-            {
-                doAssignStkOffs = false; // Not on frame or an incoming stack arg
-            }
-        }
-        if (doAssignStkOffs)
-        {
-            JITDUMP("-- V%02u was %d, now %d\n", lclNum, varDsc->GetStackOffset(), varDsc->GetStackOffset() + delta);
-            varDsc->SetStackOffset(varDsc->GetStackOffset() + delta);
-#if DOUBLE_ALIGN
-            if (genDoubleAlign() && !codeGen->isFramePointerUsed())
-            {
-                if (varDsc->lvFramePointerBased)
-                {
-                    varDsc->SetStackOffset(varDsc->GetStackOffset() - delta);
-                    varDsc->SetStackOffset(varDsc->GetStackOffset() +
-                                           (2 * TARGET_POINTER_SIZE)); // return address and pushed EBP
-                    noway_assert(varDsc->GetStackOffset() >= FIRST_ARG_STACK_OFFS);
-                }
-            }
-#endif
-            assert(codeGen->isFramePointerUsed() || varDsc->GetStackOffset() >= 0);
-        }
-    }
-    assert(codeGen->regSet.tmpAllFree());
-    for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
-    {
-        temp->tdAdjustTempOffs(delta);
-    }
-    lvaCachedGenericContextArgOffs += delta;
-#if FEATURE_FIXED_OUT_ARGS
-    if (lvaOutgoingArgSpaceVar != BAD_VAR_NUM)
-    {
-        varDsc = lvaGetDesc(lvaOutgoingArgSpaceVar);
-        varDsc->SetStackOffset(0);
-        varDsc->lvFramePointerBased = false;
-        varDsc->lvMustInit          = false;
-    }
-#endif // FEATURE_FIXED_OUT_ARGS
-#if defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-    assert(codeGen->isFramePointerUsed());
-    if (lvaRetAddrVar != BAD_VAR_NUM)
-    {
-        lvaTable[lvaRetAddrVar].SetStackOffset(REGSIZE_BYTES);
-    }
-#endif // TARGET_ARM64 || TARGET_LOONGARCH64
-}
-#ifdef TARGET_ARM
-bool Compiler::lvaIsPreSpilled(unsigned lclNum, regMaskTP preSpillMask)
-{
-    const LclVarDsc& desc = lvaTable[lclNum];
-    return desc.lvIsRegArg && (preSpillMask & genRegMask(desc.GetArgReg()));
-}
-#endif // TARGET_ARM
-void Compiler::lvaUpdateArgWithInitialReg(LclVarDsc* varDsc)
-{
-    noway_assert(varDsc->lvIsParam);
-    if (varDsc->lvIsRegCandidate())
-    {
-        varDsc->SetRegNum(varDsc->GetArgInitReg());
-    }
-}
-void Compiler::lvaUpdateArgsWithInitialReg()
-{
-    if (!compLSRADone)
-    {
-        return;
-    }
-    for (unsigned lclNum = 0; lclNum < info.compArgsCount; lclNum++)
-    {
-        LclVarDsc* varDsc = lvaGetDesc(lclNum);
-        if (varDsc->lvPromotedStruct())
-        {
-            for (unsigned fieldVarNum = varDsc->lvFieldLclStart;
-                 fieldVarNum < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++fieldVarNum)
-            {
-                LclVarDsc* fieldVarDsc = lvaGetDesc(fieldVarNum);
-                lvaUpdateArgWithInitialReg(fieldVarDsc);
-            }
-        }
-        else
-        {
-            lvaUpdateArgWithInitialReg(varDsc);
-        }
-    }
-}
-/*****************************************************************************
- *  lvaAssignVirtualFrameOffsetsToArgs() : Assign virtual stack offsets to the
- *  arguments, and implicit arguments (this ptr, return buffer, generics,
- *  and varargs).
- */
-void Compiler::lvaAssignVirtualFrameOffsetsToArgs()
-{
-    unsigned lclNum  = 0;
-    int      argOffs = 0;
-#ifdef UNIX_AMD64_ABI
-    int callerArgOffset = 0;
-#endif // UNIX_AMD64_ABI
-    /*
-        Assign stack offsets to arguments (in reverse order of passing).
-        This means that if we pass arguments left->right, we start at
-        the end of the list and work backwards, for right->left we start
-        with the first argument and move forward.
-        This is all relative to our Virtual '0'
-     */
-    if (info.compArgOrder == Target::ARG_ORDER_L2R)
-    {
-        argOffs = compArgSize;
-    }
-    /* Update the argOffs to reflect arguments that are passed in registers */
-    noway_assert(codeGen->intRegState.rsCalleeRegArgCount <= MAX_REG_ARG);
-    noway_assert(compMacOsArm64Abi() || compArgSize >= codeGen->intRegState.rsCalleeRegArgCount * REGSIZE_BYTES);
-    if (info.compArgOrder == Target::ARG_ORDER_L2R)
-    {
-        argOffs -= codeGen->intRegState.rsCalleeRegArgCount * REGSIZE_BYTES;
-    }
-    lvaUpdateArgsWithInitialReg();
-    /* Is there a "this" argument? */
-    if (!info.compIsStatic)
-    {
-        noway_assert(lclNum == info.compThisArg);
-#ifndef TARGET_X86
-        argOffs =
-            lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-#endif // TARGET_X86
-        lclNum++;
-    }
-    unsigned userArgsToSkip = 0;
-#if !defined(TARGET_ARM)
-    if (TargetOS::IsWindows && callConvIsInstanceMethodCallConv(info.compCallConv))
-    {
-#ifdef TARGET_X86
-        if (!lvaTable[lclNum].lvIsRegArg)
-        {
-            argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs);
-        }
-#elif !defined(UNIX_AMD64_ABI)
-        argOffs              = lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs);
-#endif // TARGET_X86
-        lclNum++;
-        userArgsToSkip++;
-    }
-#endif
-    /* if we have a hidden buffer parameter, that comes here */
-    if (info.compRetBuffArg != BAD_VAR_NUM)
-    {
-        noway_assert(lclNum == info.compRetBuffArg);
-        argOffs =
-            lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-        lclNum++;
-    }
-#if USER_ARGS_COME_LAST
-    if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
-    {
-        noway_assert(lclNum == (unsigned)info.compTypeCtxtArg);
-        argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
-                                                   argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-    }
-    if (info.compIsVarArgs)
-    {
-        argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
-                                                   argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-    }
-#endif // USER_ARGS_COME_LAST
-    CORINFO_ARG_LIST_HANDLE argLst    = info.compMethodInfo->args.args;
-    unsigned                argSigLen = info.compMethodInfo->args.numArgs;
-    assert(userArgsToSkip <= argSigLen);
-    argSigLen -= userArgsToSkip;
-    for (unsigned i = 0; i < userArgsToSkip; i++, argLst = info.compCompHnd->getArgNext(argLst))
-    {
-        ;
-    }
-#ifdef TARGET_ARM
-    unsigned argLcls = 0;
-    regMaskTP preSpillMask = codeGen->regSet.rsMaskPreSpillRegs(false);
-    regMaskTP tempMask     = RBM_NONE;
-    for (unsigned i = 0, preSpillLclNum = lclNum; i < argSigLen; ++i, ++preSpillLclNum)
-    {
-        if (lvaIsPreSpilled(preSpillLclNum, preSpillMask))
-        {
-            unsigned argSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
-            argOffs          = lvaAssignVirtualFrameOffsetToArg(preSpillLclNum, argSize, argOffs);
-            argLcls++;
-            tempMask |= ((((1 << (roundUp(argSize, TARGET_POINTER_SIZE) / REGSIZE_BYTES))) - 1)
-                         << lvaTable[preSpillLclNum].GetArgReg());
-            if (tempMask == preSpillMask)
-            {
-                break;
-            }
-        }
-        argLst = info.compCompHnd->getArgNext(argLst);
-    }
-    argLst = info.compMethodInfo->args.args;
-    for (unsigned i = 0, stkLclNum = lclNum; i < argSigLen; ++i, ++stkLclNum)
-    {
-        if (!lvaIsPreSpilled(stkLclNum, preSpillMask))
-        {
-            const unsigned argSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
-            argOffs                = lvaAssignVirtualFrameOffsetToArg(stkLclNum, argSize, argOffs);
-            argLcls++;
-        }
-        argLst = info.compCompHnd->getArgNext(argLst);
-    }
-    lclNum += argLcls;
-#else  // !TARGET_ARM
-    for (unsigned i = 0; i < argSigLen; i++)
-    {
-        unsigned argumentSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
-        assert(compMacOsArm64Abi() || argumentSize % TARGET_POINTER_SIZE == 0);
-        argOffs =
-            lvaAssignVirtualFrameOffsetToArg(lclNum++, argumentSize, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-        argLst = info.compCompHnd->getArgNext(argLst);
-    }
-#endif // !TARGET_ARM
-#if !USER_ARGS_COME_LAST
-    if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
-    {
-        noway_assert(lclNum == (unsigned)info.compTypeCtxtArg);
-        argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
-                                                   argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-    }
-    if (info.compIsVarArgs)
-    {
-        argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
-                                                   argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
-    }
-#endif // USER_ARGS_COME_LAST
-}
-#ifdef UNIX_AMD64_ABI
-int Compiler::lvaAssignVirtualFrameOffsetToArg(unsigned lclNum,
-                                               unsigned argSize,
-                                               int argOffs UNIX_AMD64_ABI_ONLY_ARG(int* callerArgOffset))
-{
-    noway_assert(lclNum < info.compArgsCount);
-    noway_assert(argSize);
-    if (info.compArgOrder == Target::ARG_ORDER_L2R)
-    {
-        argOffs -= argSize;
-    }
-    unsigned fieldVarNum = BAD_VAR_NUM;
-    LclVarDsc* varDsc = lvaGetDesc(lclNum);
-    noway_assert(varDsc->lvIsParam);
-    if (varDsc->lvIsRegArg)
-    {
-        if (varDsc->lvOnFrame)
-        {
-            varDsc->SetStackOffset(argOffs);
-        }
-        else
-        {
-            varDsc->SetStackOffset(0);
-        }
-    }
-    else
-    {
-        varDsc->SetStackOffset(*callerArgOffset);
-        if (argSize > TARGET_POINTER_SIZE)
-        {
-            *callerArgOffset += (int)roundUp(argSize, TARGET_POINTER_SIZE);
-        }
-        else
-        {
-            *callerArgOffset += TARGET_POINTER_SIZE;
-        }
-    }
-    if (varDsc->lvPromotedStruct())
-    {
-        unsigned firstFieldNum = varDsc->lvFieldLclStart;
-        int      offset        = varDsc->GetStackOffset();
-        for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
-        {
-            LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
-            fieldVarDsc->SetStackOffset(offset + fieldVarDsc->lvFldOffset);
-        }
-    }
-    if (info.compArgOrder == Target::ARG_ORDER_R2L && !varDsc->lvIsRegArg)
-    {
-        argOffs += argSize;
-    }
-    return argOffs;
-}
-#else // !UNIX_AMD64_ABI
-int Compiler::lvaAssignVirtualFrameOffsetToArg(unsigned lclNum,
-                                               unsigned argSize,
-                                               int argOffs UNIX_AMD64_ABI_ONLY_ARG(int* callerArgOffset))
-{
-    noway_assert(lclNum < info.compArgsCount);
-    noway_assert(argSize);
-    if (info.compArgOrder == Target::ARG_ORDER_L2R)
-    {
-        argOffs -= argSize;
-    }
-    unsigned fieldVarNum = BAD_VAR_NUM;
-    LclVarDsc* varDsc = lvaGetDesc(lclNum);
-    noway_assert(varDsc->lvIsParam);
-    if (varDsc->lvIsRegArg)
-    {
-        /* Argument is passed in a register, don't count it
-         * when updating the current offset on the stack */
-        CLANG_FORMAT_COMMENT_ANCHOR;
-#if !defined(TARGET_ARMARCH) && !defined(TARGET_LOONGARCH64)
-#if DEBUG
-        noway_assert(argSize == TARGET_POINTER_SIZE);
-#endif // DEBUG
-#endif
-#if defined(TARGET_X86)
-        argOffs += TARGET_POINTER_SIZE;
-#elif defined(TARGET_AMD64)
-        varDsc->SetStackOffset(argOffs);
-        argOffs += TARGET_POINTER_SIZE;
-#elif defined(TARGET_ARM64)
-        if (compFeatureArgSplit() && this->info.compIsVarArgs)
-        {
-            if (varDsc->lvType == TYP_STRUCT && varDsc->GetOtherArgReg() >= MAX_REG_ARG &&
-                varDsc->GetOtherArgReg() != REG_NA)
-            {
-                varDsc->SetStackOffset(varDsc->GetStackOffset() + TARGET_POINTER_SIZE);
-                argOffs += TARGET_POINTER_SIZE;
-            }
-        }
-#elif defined(TARGET_ARM)
-        regMaskTP regMask = genRegMask(varDsc->GetArgReg());
-        if (codeGen->regSet.rsMaskPreSpillRegArg & regMask)
-        {
-            if (codeGen->regSet.rsMaskPreSpillAlign != RBM_NONE)
-            {
-                assert(genCountBits(codeGen->regSet.rsMaskPreSpillAlign) == 1);
-                if (regMask > codeGen->regSet.rsMaskPreSpillAlign)
-                {
-                    if (!BitsBetween(codeGen->regSet.rsMaskPreSpillRegArg, regMask,
-                                     codeGen->regSet.rsMaskPreSpillAlign))
-                    {
-                        argOffs += TARGET_POINTER_SIZE;
-                    }
-                }
-            }
-            switch (varDsc->lvType)
-            {
-                case TYP_STRUCT:
-                    if (!varDsc->lvStructDoubleAlign)
-                    {
-                        break;
-                    }
-                    FALLTHROUGH;
-                case TYP_DOUBLE:
-                case TYP_LONG:
-                {
-                    int prevRegsSize =
-                        genCountBits(codeGen->regSet.rsMaskPreSpillRegArg & (regMask - 1)) * TARGET_POINTER_SIZE;
-                    if (argOffs < prevRegsSize)
-                    {
-                        argOffs = roundUp((unsigned)argOffs, 2 * TARGET_POINTER_SIZE);
-                    }
-                    assert(argOffs == prevRegsSize);
-                }
-                break;
-                default:
-                    break;
-            }
-            varDsc->SetStackOffset(argOffs);
-            argOffs += argSize;
-        }
-#elif defined(TARGET_LOONGARCH64)
-        if (varDsc->lvIsSplit)
-        {
-            assert((varDsc->lvType == TYP_STRUCT) && (varDsc->GetOtherArgReg() == REG_STK));
-            varDsc->SetStackOffset(varDsc->GetStackOffset() + TARGET_POINTER_SIZE);
-            argOffs += TARGET_POINTER_SIZE;
-        }
-#else // TARGET*
-#error Unsupported or unset target architecture
-#endif // TARGET*
-    }
-    else
-    {
-#if defined(TARGET_ARM)
-        int sizeofPreSpillRegArgs = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * REGSIZE_BYTES;
-        if (argOffs < sizeofPreSpillRegArgs)
-        {
-            CLANG_FORMAT_COMMENT_ANCHOR;
-#ifdef PROFILING_SUPPORTED
-            if (!compIsProfilerHookNeeded())
-#endif
-            {
-                bool cond = ((info.compIsVarArgs || opts.compUseSoftFP) &&
-                             ((varDsc->lvType == TYP_STRUCT && varDsc->lvStructDoubleAlign) ||
-                              (varDsc->lvType == TYP_DOUBLE) || (varDsc->lvType == TYP_LONG))) ||
-                            (codeGen->regSet.rsMaskPreSpillAlign & genRegMask(REG_ARG_LAST));
-                noway_assert(cond);
-                noway_assert(sizeofPreSpillRegArgs <=
-                             argOffs + TARGET_POINTER_SIZE); // at most one register of alignment
-            }
-            argOffs = sizeofPreSpillRegArgs;
-        }
-        noway_assert(argOffs >= sizeofPreSpillRegArgs);
-        int argOffsWithoutPreSpillRegArgs = argOffs - sizeofPreSpillRegArgs;
-        switch (varDsc->lvType)
-        {
-            case TYP_STRUCT:
-                if (!varDsc->lvStructDoubleAlign)
-                    break;
-                FALLTHROUGH;
-            case TYP_DOUBLE:
-            case TYP_LONG:
-                argOffs =
-                    roundUp((unsigned)argOffsWithoutPreSpillRegArgs, 2 * TARGET_POINTER_SIZE) + sizeofPreSpillRegArgs;
-                break;
-            default:
-                break;
-        }
-#endif // TARGET_ARM
-        const bool     isFloatHfa   = (varDsc->lvIsHfa() && (varDsc->GetHfaType() == TYP_FLOAT));
-        const unsigned argAlignment = eeGetArgSizeAlignment(varDsc->lvType, isFloatHfa);
-        if (compMacOsArm64Abi())
-        {
-            argOffs = roundUp(argOffs, argAlignment);
-        }
-        assert((argSize % argAlignment) == 0);
-        assert((argOffs % argAlignment) == 0);
-        varDsc->SetStackOffset(argOffs);
-    }
-    CLANG_FORMAT_COMMENT_ANCHOR;
-#if !defined(TARGET_64BIT)
-    if ((varDsc->TypeGet() == TYP_LONG) && varDsc->lvPromoted)
-    {
-        noway_assert(varDsc->lvFieldCnt == 2);
-        fieldVarNum = varDsc->lvFieldLclStart;
-        lvaTable[fieldVarNum].SetStackOffset(varDsc->GetStackOffset());
-        lvaTable[fieldVarNum + 1].SetStackOffset(varDsc->GetStackOffset() + genTypeSize(TYP_INT));
-    }
-    else
-#endif // !defined(TARGET_64BIT)
-        if (varDsc->lvPromotedStruct())
-    {
-        unsigned firstFieldNum = varDsc->lvFieldLclStart;
-        for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
-        {
-            LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
-            JITDUMP("Adjusting offset of dependent V%02u of arg V%02u: parent %u field %u net %u\n", lclNum,
-                    firstFieldNum + i, varDsc->GetStackOffset(), fieldVarDsc->lvFldOffset,
-                    varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
-            fieldVarDsc->SetStackOffset(varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
-        }
-    }
-    if (info.compArgOrder == Target::ARG_ORDER_R2L && !varDsc->lvIsRegArg)
-    {
-        argOffs += argSize;
-    }
-    return argOffs;
-}
-#endif // !UNIX_AMD64_ABI
-void Compiler::lvaAssignVirtualFrameOffsetsToLocals()
-{
-    int stkOffs              = 0;
-    int originalFrameStkOffs = 0;
-    int originalFrameSize    = 0;
-    if (lvaDoneFrameLayout <= PRE_REGALLOC_FRAME_LAYOUT)
-    {
-        codeGen->setFramePointerUsed(codeGen->isFramePointerRequired());
-    }
-#ifdef TARGET_ARM64
-    if (opts.compJitSaveFpLrWithCalleeSavedRegisters == 0)
-    {
-        codeGen->SetSaveFpLrWithAllCalleeSavedRegisters((getNeedsGSSecurityCookie() && compLocallocUsed) ||
-                                                        opts.compDbgEnC || compStressCompile(STRESS_GENERIC_VARN, 20));
-    }
-    else if (opts.compJitSaveFpLrWithCalleeSavedRegisters == 1)
-    {
-        codeGen->SetSaveFpLrWithAllCalleeSavedRegisters(false); // Disable using new frames
-    }
-    else if ((opts.compJitSaveFpLrWithCalleeSavedRegisters == 2) || (opts.compJitSaveFpLrWithCalleeSavedRegisters == 3))
-    {
-        codeGen->SetSaveFpLrWithAllCalleeSavedRegisters(true); // Force using new frames
-    }
-#endif // TARGET_ARM64
-#ifdef TARGET_XARCH
-    stkOffs -= TARGET_POINTER_SIZE; // return address;
-    if (lvaRetAddrVar != BAD_VAR_NUM)
-    {
-        lvaTable[lvaRetAddrVar].SetStackOffset(stkOffs);
-    }
-#endif
-    if (opts.IsOSR())
-    {
-        originalFrameSize    = info.compPatchpointInfo->TotalFrameSize();
-        originalFrameStkOffs = stkOffs;
-        stkOffs -= originalFrameSize;
-    }
-#ifdef TARGET_XARCH
-    if (codeGen->doubleAlignOrFramePointerUsed())
-    {
-        stkOffs -= REGSIZE_BYTES;
-    }
-#endif
-    int  preSpillSize    = 0;
-    bool mustDoubleAlign = false;
-#ifdef TARGET_ARM
-    mustDoubleAlign = true;
-    preSpillSize    = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * REGSIZE_BYTES;
-#else // !TARGET_ARM
-#if DOUBLE_ALIGN
-    if (genDoubleAlign())
-    {
-        mustDoubleAlign = true; // X86 only
-    }
-#endif
-#endif // !TARGET_ARM
-#ifdef TARGET_ARM64
-    int initialStkOffs = 0;
-    if (info.compIsVarArgs)
-    {
-        initialStkOffs = MAX_REG_ARG * REGSIZE_BYTES;
-        stkOffs -= initialStkOffs;
-    }
-    if (codeGen->IsSaveFpLrWithAllCalleeSavedRegisters() ||
-        !isFramePointerUsed()) // Note that currently we always have a frame pointer
-    {
-        stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;
-    }
-    else
-    {
-        assert(compCalleeRegsPushed >= 2);
-        stkOffs -= (compCalleeRegsPushed - 2) * REGSIZE_BYTES;
-    }
-#elif defined(TARGET_LOONGARCH64)
-    assert(compCalleeRegsPushed >= 2);
-    stkOffs -= (compCalleeRegsPushed - 2) * REGSIZE_BYTES;
-#else // !TARGET_LOONGARCH64
-#ifdef TARGET_ARM
-    if (lvaRetAddrVar != BAD_VAR_NUM)
-    {
-        lvaTable[lvaRetAddrVar].SetStackOffset(stkOffs - REGSIZE_BYTES);
-    }
-#endif
-    stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;
-#endif // !TARGET_LOONGARCH64
-    compLclFrameSize = 0;
-#ifdef TARGET_AMD64
-    if (doesMethodHavePatchpoints() || doesMethodHavePartialCompilationPatchpoints())
-    {
-        const unsigned regsPushed    = compCalleeRegsPushed + (codeGen->isFramePointerUsed() ? 1 : 0);
-        const unsigned extraSlots    = genCountBits(RBM_OSR_INT_CALLEE_SAVED) - regsPushed;
-        const unsigned extraSlotSize = extraSlots * REGSIZE_BYTES;
-        JITDUMP("\nMethod has patchpoints and has %u callee saves.\n"
-                "Reserving %u extra slots (%u bytes) for potential OSR method callee saves\n",
-                regsPushed, extraSlots, extraSlotSize);
-        stkOffs -= extraSlotSize;
-        lvaIncrementFrameSize(extraSlotSize);
-    }
-    const unsigned calleeFPRegsSavedSize = genCountBits(compCalleeFPRegsSavedMask) * XMM_REGSIZE_BYTES;
-    const int offsetForAlign = -(stkOffs + originalFrameSize);
-    if ((calleeFPRegsSavedSize > 0) && ((offsetForAlign % XMM_REGSIZE_BYTES) != 0))
-    {
-        int alignPad = (int)AlignmentPad((unsigned)offsetForAlign, XMM_REGSIZE_BYTES);
-        assert(alignPad != 0);
-        stkOffs -= alignPad;
-        lvaIncrementFrameSize(alignPad);
-    }
-    stkOffs -= calleeFPRegsSavedSize;
-    lvaIncrementFrameSize(calleeFPRegsSavedSize);
-    if (compVSQuirkStackPaddingNeeded > 0)
-    {
-#ifdef DEBUG
-        if (verbose)
-        {
-            printf("\nAdding VS quirk stack padding of %d bytes between save-reg area and locals\n",
-                   compVSQuirkStackPaddingNeeded);
-        }
-#endif // DEBUG
-        stkOffs -= compVSQuirkStackPaddingNeeded;
-        lvaIncrementFrameSize(compVSQuirkStackPaddingNeeded);
-    }
-#endif // TARGET_AMD64
-    if (lvaMonAcquired != BAD_VAR_NUM)
-    {
-        if (opts.IsOSR())
-        {
-            assert(info.compPatchpointInfo->HasMonitorAcquired());
-            int originalOffset = info.compPatchpointInfo->MonitorAcquiredOffset();
-            int offset         = originalFrameStkOffs + originalOffset;
-            JITDUMP(
-                "---OSR--- V%02u (on tier0 frame, monitor acquired) tier0 FP-rel offset %d tier0 frame offset %d new "
-                "virt offset %d\n",
-                lvaMonAcquired, originalOffset, originalFrameStkOffs, offset);
-            lvaTable[lvaMonAcquired].SetStackOffset(offset);
-        }
-        else
-        {
-            stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaMonAcquired, lvaLclSize(lvaMonAcquired), stkOffs);
-        }
-    }
-#if defined(FEATURE_EH_FUNCLETS) && (defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64))
-    if (lvaPSPSym != BAD_VAR_NUM)
-    {
-        noway_assert(codeGen->isFramePointerUsed()); // We need an explicit frame pointer
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);
-    }
-#endif // FEATURE_EH_FUNCLETS && (TARGET_ARMARCH || TARGET_LOONGARCH64)
-    if (mustDoubleAlign)
-    {
-        if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-        {
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-            stkOffs -= TARGET_POINTER_SIZE;
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-            stkOffs -= TARGET_POINTER_SIZE;
-        }
-        else // FINAL_FRAME_LAYOUT
-        {
-            if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
-            {
-                lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                stkOffs -= TARGET_POINTER_SIZE;
-            }
-            noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
-        }
-    }
-#ifdef JIT32_GCENCODER
-    if (lvaLocAllocSPvar != BAD_VAR_NUM)
-    {
-        noway_assert(codeGen->isFramePointerUsed()); // else offsets of locals of frameless methods will be incorrect
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaLocAllocSPvar, TARGET_POINTER_SIZE, stkOffs);
-    }
-#endif // JIT32_GCENCODER
-    if (lvaReportParamTypeArg())
-    {
-#ifdef JIT32_GCENCODER
-        noway_assert(codeGen->isFramePointerUsed());
-#endif
-        if (opts.IsOSR())
-        {
-            PatchpointInfo* ppInfo = info.compPatchpointInfo;
-            assert(ppInfo->HasGenericContextArgOffset());
-            const int originalOffset       = ppInfo->GenericContextArgOffset();
-            lvaCachedGenericContextArgOffs = originalFrameStkOffs + originalOffset;
-        }
-        else
-        {
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-            stkOffs -= TARGET_POINTER_SIZE;
-            lvaCachedGenericContextArgOffs = stkOffs;
-        }
-    }
-#ifndef JIT32_GCENCODER
-    else if (lvaKeepAliveAndReportThis())
-    {
-        bool canUseExistingSlot = false;
-        if (opts.IsOSR())
-        {
-            PatchpointInfo* ppInfo = info.compPatchpointInfo;
-            if (ppInfo->HasKeptAliveThis())
-            {
-                const int originalOffset       = ppInfo->KeptAliveThisOffset();
-                lvaCachedGenericContextArgOffs = originalFrameStkOffs + originalOffset;
-                canUseExistingSlot             = true;
-            }
-        }
-        if (!canUseExistingSlot)
-        {
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-            stkOffs -= TARGET_POINTER_SIZE;
-            lvaCachedGenericContextArgOffs = stkOffs;
-        }
-    }
-#endif
-#if !defined(FEATURE_EH_FUNCLETS)
-    /* If we need space for slots for shadow SP, reserve it now */
-    if (ehNeedsShadowSPslots())
-    {
-        noway_assert(codeGen->isFramePointerUsed()); // else offsets of locals of frameless methods will be incorrect
-        if (!lvaReportParamTypeArg())
-        {
-#ifndef JIT32_GCENCODER
-            if (!lvaKeepAliveAndReportThis())
-#endif
-            {
-                lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                stkOffs -= TARGET_POINTER_SIZE;
-            }
-        }
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaShadowSPslotsVar, lvaLclSize(lvaShadowSPslotsVar), stkOffs);
-    }
-#endif // !FEATURE_EH_FUNCLETS
-    if (compGSReorderStackLayout)
-    {
-        assert(getNeedsGSSecurityCookie());
-        if (!opts.IsOSR() || !info.compPatchpointInfo->HasSecurityCookie())
-        {
-            stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaGSSecurityCookie, lvaLclSize(lvaGSSecurityCookie), stkOffs);
-        }
-    }
-    /*
-        If we're supposed to track lifetimes of pointer temps, we'll
-        assign frame offsets in the following order:
-            non-pointer local variables (also untracked pointer variables)
-                pointer local variables
-                pointer temps
-            non-pointer temps
-     */
-    enum Allocation
-    {
-        ALLOC_NON_PTRS                 = 0x1, // assign offsets to non-ptr
-        ALLOC_PTRS                     = 0x2, // Second pass, assign offsets to tracked ptrs
-        ALLOC_UNSAFE_BUFFERS           = 0x4,
-        ALLOC_UNSAFE_BUFFERS_WITH_PTRS = 0x8
-    };
-    UINT alloc_order[5];
-    unsigned int cur = 0;
-    if (compGSReorderStackLayout)
-    {
-        noway_assert(getNeedsGSSecurityCookie());
-        if (codeGen->isFramePointerUsed())
-        {
-            alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;
-            alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
-        }
-    }
-    bool tempsAllocated = false;
-    if (lvaTempsHaveLargerOffsetThanVars() && !codeGen->isFramePointerUsed())
-    {
-        noway_assert(!tempsAllocated);
-        stkOffs        = lvaAllocateTemps(stkOffs, mustDoubleAlign);
-        tempsAllocated = true;
-    }
-    alloc_order[cur++] = ALLOC_NON_PTRS;
-    if (opts.compDbgEnC)
-    {
-        /* We will use just one pass, and assign offsets to all variables */
-        alloc_order[cur - 1] |= ALLOC_PTRS;
-        noway_assert(compGSReorderStackLayout == false);
-    }
-    else
-    {
-        alloc_order[cur++] = ALLOC_PTRS;
-    }
-    if (!codeGen->isFramePointerUsed() && compGSReorderStackLayout)
-    {
-        alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
-        alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;
-    }
-    alloc_order[cur] = 0;
-    noway_assert(cur < ArrLen(alloc_order));
-    UINT assignMore             = 0xFFFFFFFF;
-    bool have_LclVarDoubleAlign = false;
-    for (cur = 0; alloc_order[cur]; cur++)
-    {
-        if ((assignMore & alloc_order[cur]) == 0)
-        {
-            continue;
-        }
-        assignMore = 0;
-        unsigned   lclNum;
-        LclVarDsc* varDsc;
-        for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-        {
-            /* Ignore field locals of the promotion type PROMOTION_TYPE_FIELD_DEPENDENT.
-               In other words, we will not calculate the "base" address of the struct local if
-               the promotion type is PROMOTION_TYPE_FIELD_DEPENDENT.
-            */
-            if (lvaIsFieldOfDependentlyPromotedStruct(varDsc))
-            {
-                continue;
-            }
-#if FEATURE_FIXED_OUT_ARGS
-            if (lclNum == lvaOutgoingArgSpaceVar)
-            {
-                continue;
-            }
-#endif
-            bool allocateOnFrame = varDsc->lvOnFrame;
-            if (varDsc->lvRegister && (lvaDoneFrameLayout == REGALLOC_FRAME_LAYOUT) &&
-                ((varDsc->TypeGet() != TYP_LONG) || (varDsc->GetOtherReg() != REG_STK)))
-            {
-                allocateOnFrame = false;
-            }
-            if (lvaIsOSRLocal(lclNum))
-            {
-                if (varDsc->lvIsStructField)
-                {
-                    const unsigned parentLclNum         = varDsc->lvParentLcl;
-                    const int      parentOriginalOffset = info.compPatchpointInfo->Offset(parentLclNum);
-                    const int      offset = originalFrameStkOffs + parentOriginalOffset + varDsc->lvFldOffset;
-                    JITDUMP("---OSR--- V%02u (promoted field of V%02u; on tier0 frame) tier0 FP-rel offset %d tier0 "
-                            "frame offset %d field offset %d new virt offset "
-                            "%d\n",
-                            lclNum, parentLclNum, parentOriginalOffset, originalFrameStkOffs, varDsc->lvFldOffset,
-                            offset);
-                    lvaTable[lclNum].SetStackOffset(offset);
-                }
-                else
-                {
-                    const int originalOffset = info.compPatchpointInfo->Offset(lclNum);
-                    const int offset         = originalFrameStkOffs + originalOffset;
-                    JITDUMP(
-                        "---OSR--- V%02u (on tier0 frame) tier0 FP-rel offset %d tier0 frame offset %d new virt offset "
-                        "%d\n",
-                        lclNum, originalOffset, originalFrameStkOffs, offset);
-                    lvaTable[lclNum].SetStackOffset(offset);
-                }
-                continue;
-            }
-            /* Ignore variables that are not on the stack frame */
-            if (!allocateOnFrame)
-            {
-                /* For EnC, all variables have to be allocated space on the
-                   stack, even though they may actually be enregistered. This
-                   way, the frame layout can be directly inferred from the
-                   locals-sig.
-                 */
-                if (!opts.compDbgEnC)
-                {
-                    continue;
-                }
-                else if (lclNum >= info.compLocalsCount)
-                { // ignore temps for EnC
-                    continue;
-                }
-            }
-            else if (lvaGSSecurityCookie == lclNum && getNeedsGSSecurityCookie())
-            {
-                if (opts.IsOSR() && info.compPatchpointInfo->HasSecurityCookie())
-                {
-                    int originalOffset = info.compPatchpointInfo->SecurityCookieOffset();
-                    int offset         = originalFrameStkOffs + originalOffset;
-                    JITDUMP("---OSR--- V%02u (on tier0 frame, security cookie) tier0 FP-rel offset %d tier0 frame "
-                            "offset %d new "
-                            "virt offset %d\n",
-                            lclNum, originalOffset, originalFrameStkOffs, offset);
-                    lvaTable[lclNum].SetStackOffset(offset);
-                }
-                continue;
-            }
-            if (
-#if defined(FEATURE_EH_FUNCLETS)
-                lclNum == lvaPSPSym ||
-#else
-                lclNum == lvaShadowSPslotsVar ||
-#endif // FEATURE_EH_FUNCLETS
-#ifdef JIT32_GCENCODER
-                lclNum == lvaLocAllocSPvar ||
-#endif // JIT32_GCENCODER
-                lclNum == lvaRetAddrVar)
-            {
-                assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
-                continue;
-            }
-            if (lclNum == lvaMonAcquired)
-            {
-                continue;
-            }
-            if (lclNum == lvaStubArgumentVar)
-            {
-#ifdef JIT32_GCENCODER
-                noway_assert(codeGen->isFramePointerUsed());
-#endif
-                continue;
-            }
-            if (lclNum == lvaInlinedPInvokeFrameVar)
-            {
-                noway_assert(codeGen->isFramePointerUsed());
-                continue;
-            }
-            if (varDsc->lvIsParam)
-            {
-#if defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI)
-                assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
-                continue;
-#else // !TARGET_AMD64
-                if (!varDsc->lvIsRegArg)
-                {
-                    continue;
-                }
-#ifdef TARGET_ARM64
-                if (info.compIsVarArgs && varDsc->GetArgReg() != theFixedRetBuffArgNum())
-                {
-                    const unsigned regArgNum = genMapIntRegNumToRegArgNum(varDsc->GetArgReg());
-                    varDsc->SetStackOffset(-initialStkOffs + regArgNum * REGSIZE_BYTES);
-                    continue;
-                }
-#endif
-#ifdef TARGET_ARM
-                if ((codeGen->regSet.rsMaskPreSpillRegs(false) & genRegMask(varDsc->GetArgReg())) != 0)
-                {
-                    assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
-                    continue;
-                }
-#endif
-#endif // !TARGET_AMD64
-            }
-            /* Make sure the type is appropriate */
-            if (varDsc->lvIsUnsafeBuffer && compGSReorderStackLayout)
-            {
-                if (varDsc->lvIsPtr)
-                {
-                    if ((alloc_order[cur] & ALLOC_UNSAFE_BUFFERS_WITH_PTRS) == 0)
-                    {
-                        assignMore |= ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
-                        continue;
-                    }
-                }
-                else
-                {
-                    if ((alloc_order[cur] & ALLOC_UNSAFE_BUFFERS) == 0)
-                    {
-                        assignMore |= ALLOC_UNSAFE_BUFFERS;
-                        continue;
-                    }
-                }
-            }
-            else if (varTypeIsGC(varDsc->TypeGet()) && varDsc->lvTracked)
-            {
-                if ((alloc_order[cur] & ALLOC_PTRS) == 0)
-                {
-                    assignMore |= ALLOC_PTRS;
-                    continue;
-                }
-            }
-            else
-            {
-                if ((alloc_order[cur] & ALLOC_NON_PTRS) == 0)
-                {
-                    assignMore |= ALLOC_NON_PTRS;
-                    continue;
-                }
-            }
-            /* Need to align the offset? */
-            if (mustDoubleAlign && (varDsc->lvType == TYP_DOUBLE // Align doubles for ARM and x86
-#ifdef TARGET_ARM
-                                    || varDsc->lvType == TYP_LONG // Align longs for ARM
-#endif
-#ifndef TARGET_64BIT
-                                    || varDsc->lvStructDoubleAlign // Align when lvStructDoubleAlign is true
-#endif                                                             // !TARGET_64BIT
-                                    ))
-            {
-                noway_assert((compLclFrameSize % TARGET_POINTER_SIZE) == 0);
-                if ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) && !have_LclVarDoubleAlign)
-                {
-                    lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                    stkOffs -= TARGET_POINTER_SIZE;
-                }
-                else
-                {
-                    if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
-                    {
-                        lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                        stkOffs -= TARGET_POINTER_SIZE;
-                    }
-                    noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
-                }
-                have_LclVarDoubleAlign = true;
-            }
-            stkOffs = lvaAllocLocalAndSetVirtualOffset(lclNum, lvaLclSize(lclNum), stkOffs);
-#if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
-            if (varDsc->lvIsRegArg && varDsc->lvPromotedStruct())
-            {
-                unsigned firstFieldNum = varDsc->lvFieldLclStart;
-                for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
-                {
-                    LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
-                    fieldVarDsc->SetStackOffset(varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
-                }
-            }
-#ifdef TARGET_ARM
-            else if (varDsc->lvIsRegArg && varDsc->lvPromoted)
-            {
-                assert(varTypeIsLong(varDsc) && (varDsc->lvFieldCnt == 2));
-                unsigned fieldVarNum = varDsc->lvFieldLclStart;
-                lvaTable[fieldVarNum].SetStackOffset(varDsc->GetStackOffset());
-                lvaTable[fieldVarNum + 1].SetStackOffset(varDsc->GetStackOffset() + 4);
-            }
-#endif // TARGET_ARM
-#endif // TARGET_ARM64 || TARGET_LOONGARCH64
-        }
-    }
-    if (getNeedsGSSecurityCookie() && !compGSReorderStackLayout)
-    {
-        if (!opts.IsOSR() || !info.compPatchpointInfo->HasSecurityCookie())
-        {
-            stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaGSSecurityCookie, lvaLclSize(lvaGSSecurityCookie), stkOffs);
-        }
-    }
-    if (tempsAllocated == false)
-    {
-        /*-------------------------------------------------------------------------
-         *
-         * Now the temps
-         *
-         *-------------------------------------------------------------------------
-         */
-        stkOffs = lvaAllocateTemps(stkOffs, mustDoubleAlign);
-    }
-    /*-------------------------------------------------------------------------
-     *
-     * Now do some final stuff
-     *
-     *-------------------------------------------------------------------------
-     */
-    if (lvaStubArgumentVar != BAD_VAR_NUM)
-    {
-#ifdef JIT32_GCENCODER
-        noway_assert(codeGen->isFramePointerUsed());
-#endif
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaStubArgumentVar, lvaLclSize(lvaStubArgumentVar), stkOffs);
-    }
-    if (lvaInlinedPInvokeFrameVar != BAD_VAR_NUM)
-    {
-        noway_assert(codeGen->isFramePointerUsed());
-        stkOffs =
-            lvaAllocLocalAndSetVirtualOffset(lvaInlinedPInvokeFrameVar, lvaLclSize(lvaInlinedPInvokeFrameVar), stkOffs);
-    }
-    if (mustDoubleAlign)
-    {
-        if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-        {
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-            stkOffs -= TARGET_POINTER_SIZE;
-            if (have_LclVarDoubleAlign)
-            {
-                lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                stkOffs -= TARGET_POINTER_SIZE;
-            }
-        }
-        else // FINAL_FRAME_LAYOUT
-        {
-            if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
-            {
-                lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                stkOffs -= TARGET_POINTER_SIZE;
-            }
-            noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
-        }
-    }
-#if defined(FEATURE_EH_FUNCLETS) && defined(TARGET_AMD64)
-    if (lvaPSPSym != BAD_VAR_NUM)
-    {
-        noway_assert(codeGen->isFramePointerUsed()); // We need an explicit frame pointer
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);
-    }
-#endif // FEATURE_EH_FUNCLETS && defined(TARGET_AMD64)
-#ifdef TARGET_ARM64
-    if (!codeGen->IsSaveFpLrWithAllCalleeSavedRegisters() &&
-        isFramePointerUsed()) // Note that currently we always have a frame pointer
-    {
-        stkOffs -= 2 * REGSIZE_BYTES;
-    }
-#endif // TARGET_ARM64
-#if defined(TARGET_LOONGARCH64)
-    assert(isFramePointerUsed()); // Note that currently we always have a frame pointer
-    stkOffs -= 2 * REGSIZE_BYTES;
-#endif // TARGET_LOONGARCH64
-#if FEATURE_FIXED_OUT_ARGS
-    if (lvaOutgoingArgSpaceSize > 0)
-    {
-#if defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI) // No 4 slots for outgoing params on System V.
-        noway_assert(lvaOutgoingArgSpaceSize >= (4 * TARGET_POINTER_SIZE));
-#endif
-        noway_assert((lvaOutgoingArgSpaceSize % TARGET_POINTER_SIZE) == 0);
-        stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaOutgoingArgSpaceVar, lvaLclSize(lvaOutgoingArgSpaceVar), stkOffs);
-    }
-#endif // FEATURE_FIXED_OUT_ARGS
-    int pushedCount = compCalleeRegsPushed;
-#ifdef TARGET_ARM64
-    if (info.compIsVarArgs)
-    {
-        pushedCount += MAX_REG_ARG;
-    }
-#endif
-#ifdef TARGET_XARCH
-    if (codeGen->doubleAlignOrFramePointerUsed())
-    {
-        pushedCount += 1; // pushed EBP (frame pointer)
-    }
-    pushedCount += 1; // pushed PC (return address)
-#endif
-    noway_assert(compLclFrameSize + originalFrameSize ==
-                 (unsigned)-(stkOffs + (pushedCount * (int)TARGET_POINTER_SIZE)));
-}
-int Compiler::lvaAllocLocalAndSetVirtualOffset(unsigned lclNum, unsigned size, int stkOffs)
-{
-    noway_assert(lclNum != BAD_VAR_NUM);
-#ifdef TARGET_64BIT
-    if ((size >= 8) && ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || ((stkOffs % 8) != 0)
-#if defined(FEATURE_SIMD) && ALIGN_SIMD_TYPES
-                        || lclVarIsSIMDType(lclNum)
-#endif
-                            ))
-    {
-        assert(stkOffs <= 0);
-        unsigned pad = 0;
-#if defined(FEATURE_SIMD) && ALIGN_SIMD_TYPES
-        if (lclVarIsSIMDType(lclNum) && !lvaIsImplicitByRefLocal(lclNum))
-        {
-            int alignment = getSIMDTypeAlignment(lvaTable[lclNum].lvType);
-            if (stkOffs % alignment != 0)
-            {
-                if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-                {
-                    pad = alignment - 1;
-                }
-                else
-                {
-                    pad = alignment + (stkOffs % alignment); // +1 to +(alignment-1) bytes
-                }
-            }
-        }
-        else
-#endif // FEATURE_SIMD && ALIGN_SIMD_TYPES
-        {
-            if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-            {
-                pad = 7;
-            }
-            else
-            {
-                pad = 8 + (stkOffs % 8); // +1 to +7 bytes
-            }
-        }
-        lvaIncrementFrameSize(pad);
-        stkOffs -= pad;
-#ifdef DEBUG
-        if (verbose)
-        {
-            printf("Pad ");
-            gtDispLclVar(lclNum, /*pad*/ false);
-            printf(", size=%d, stkOffs=%c0x%x, pad=%d\n", size, stkOffs < 0 ? '-' : '+',
-                   stkOffs < 0 ? -stkOffs : stkOffs, pad);
-        }
-#endif
-    }
-#endif // TARGET_64BIT
-    /* Reserve space on the stack by bumping the frame size */
-    lvaIncrementFrameSize(size);
-    stkOffs -= size;
-    lvaTable[lclNum].SetStackOffset(stkOffs);
-#ifdef DEBUG
-    if (verbose)
-    {
-        printf("Assign ");
-        gtDispLclVar(lclNum, /*pad*/ false);
-        printf(", size=%d, stkOffs=%c0x%x\n", size, stkOffs < 0 ? '-' : '+', stkOffs < 0 ? -stkOffs : stkOffs);
-    }
-#endif
-    return stkOffs;
-}
-#ifdef TARGET_AMD64
-/*****************************************************************************
- *  lvaIsCalleeSavedIntRegCountEven() :  returns true if the number of integer registers
- *  pushed onto stack is even including RBP if used as frame pointer
- *
- *  Note that this excludes return address (PC) pushed by caller.  To know whether
- *  the SP offset after pushing integer registers is aligned, we need to take
- *  negation of this routine.
- */
-bool Compiler::lvaIsCalleeSavedIntRegCountEven()
-{
-    unsigned regsPushed = compCalleeRegsPushed + (codeGen->isFramePointerUsed() ? 1 : 0);
-    return (regsPushed % (16 / REGSIZE_BYTES)) == 0;
-}
-#endif // TARGET_AMD64
-/*****************************************************************************
- *  lvaAlignFrame() :  After allocating everything on the frame, reserve any
- *  extra space needed to keep the frame aligned
- */
-void Compiler::lvaAlignFrame()
-{
-#if defined(TARGET_AMD64)
-    if ((compLclFrameSize % 8) != 0)
-    {
-        lvaIncrementFrameSize(8 - (compLclFrameSize % 8));
-    }
-    else if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-    {
-        lvaIncrementFrameSize(8);
-    }
-    assert((compLclFrameSize % 8) == 0);
-    bool regPushedCountAligned = lvaIsCalleeSavedIntRegCountEven();
-    bool lclFrameSizeAligned   = (compLclFrameSize % 16) == 0;
-    CLANG_FORMAT_COMMENT_ANCHOR;
-#ifdef UNIX_AMD64_ABI
-    bool stackNeedsAlignment = (compLclFrameSize != 0 || opts.compNeedToAlignFrame);
-#else  // !UNIX_AMD64_ABI
-    bool stackNeedsAlignment = compLclFrameSize != 0;
-#endif // !UNIX_AMD64_ABI
-    if ((!codeGen->isFramePointerUsed() && (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)) ||
-        (stackNeedsAlignment && (regPushedCountAligned == lclFrameSizeAligned)))
-    {
-        lvaIncrementFrameSize(REGSIZE_BYTES);
-    }
-#elif defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
-    if ((compLclFrameSize % 8) != 0)
-    {
-        lvaIncrementFrameSize(8 - (compLclFrameSize % 8));
-    }
-    else if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-    {
-        lvaIncrementFrameSize(8);
-    }
-    assert((compLclFrameSize % 8) == 0);
-    bool regPushedCountAligned = (compCalleeRegsPushed % (16 / REGSIZE_BYTES)) == 0;
-    bool lclFrameSizeAligned   = (compLclFrameSize % 16) == 0;
-    if ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || (regPushedCountAligned != lclFrameSizeAligned))
-    {
-        lvaIncrementFrameSize(REGSIZE_BYTES);
-    }
-#elif defined(TARGET_ARM)
-    bool lclFrameSizeAligned   = (compLclFrameSize % sizeof(double)) == 0;
-    bool regPushedCountAligned = ((compCalleeRegsPushed + genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true))) %
-                                  (sizeof(double) / TARGET_POINTER_SIZE)) == 0;
-    if (regPushedCountAligned != lclFrameSizeAligned)
-    {
-        lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-    }
-#elif defined(TARGET_X86)
-#if DOUBLE_ALIGN
-    if (genDoubleAlign())
-    {
-        if (compLclFrameSize == 0)
-        {
-            lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-        }
-    }
-#endif
-    if (STACK_ALIGN > REGSIZE_BYTES)
-    {
-        if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
-        {
-            lvaIncrementFrameSize(STACK_ALIGN - REGSIZE_BYTES);
-        }
-        int  adjustFrameSize = compLclFrameSize;
-#if defined(UNIX_X86_ABI)
-        bool isEbpPushed     = codeGen->isFramePointerUsed();
-#if DOUBLE_ALIGN
-        isEbpPushed |= genDoubleAlign();
-#endif
-        int adjustCount = compCalleeRegsPushed + 1 + (isEbpPushed ? 1 : 0);
-        adjustFrameSize += (adjustCount * REGSIZE_BYTES) % STACK_ALIGN;
-#endif
-        if ((adjustFrameSize % STACK_ALIGN) != 0)
-        {
-            lvaIncrementFrameSize(STACK_ALIGN - (adjustFrameSize % STACK_ALIGN));
-        }
-    }
-#else
-    NYI("TARGET specific lvaAlignFrame");
-#endif // !TARGET_AMD64
-}
-/*****************************************************************************
- *  lvaAssignFrameOffsetsToPromotedStructs() :  Assign offsets to fields
- *  within a promoted struct (worker for lvaAssignFrameOffsets).
- */
-void Compiler::lvaAssignFrameOffsetsToPromotedStructs()
-{
-    LclVarDsc* varDsc = lvaTable;
-    for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++, varDsc++)
-    {
-        CLANG_FORMAT_COMMENT_ANCHOR;
-#if defined(UNIX_AMD64_ABI) || defined(TARGET_ARM) || defined(TARGET_X86)
-        const bool mustProcessParams = true;
-#else
-        const bool mustProcessParams = opts.IsOSR();
-#endif // defined(UNIX_AMD64_ABI) || defined(TARGET_ARM) || defined(TARGET_X86)
-        if (varDsc->lvIsStructField && (!varDsc->lvIsParam || mustProcessParams))
-        {
-            LclVarDsc*       parentvarDsc  = lvaGetDesc(varDsc->lvParentLcl);
-            lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
-            if (promotionType == PROMOTION_TYPE_INDEPENDENT)
-            {
-                continue;
-            }
-            else
-            {
-                noway_assert(promotionType == PROMOTION_TYPE_DEPENDENT);
-                noway_assert(varDsc->lvOnFrame);
-                if (parentvarDsc->lvOnFrame)
-                {
-                    JITDUMP("Adjusting offset of dependent V%02u of V%02u: parent %u field %u net %u\n", lclNum,
-                            varDsc->lvParentLcl, parentvarDsc->GetStackOffset(), varDsc->lvFldOffset,
-                            parentvarDsc->GetStackOffset() + varDsc->lvFldOffset);
-                    varDsc->SetStackOffset(parentvarDsc->GetStackOffset() + varDsc->lvFldOffset);
-                }
-                else
-                {
-                    varDsc->lvOnFrame = false;
-                    noway_assert(varDsc->lvRefCnt() == 0);
-                }
-            }
-        }
-    }
-}
-/*****************************************************************************
- *  lvaAllocateTemps() :  Assign virtual offsets to temps (always negative).
- */
-int Compiler::lvaAllocateTemps(int stkOffs, bool mustDoubleAlign)
-{
-    unsigned spillTempSize = 0;
-    if (lvaDoneFrameLayout == FINAL_FRAME_LAYOUT)
-    {
-        int preSpillSize = 0;
-#ifdef TARGET_ARM
-        preSpillSize = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * TARGET_POINTER_SIZE;
-#endif
-        /* Allocate temps */
-        assert(codeGen->regSet.tmpAllFree());
-        for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
-        {
-            var_types tempType = temp->tdTempType();
-            unsigned  size     = temp->tdTempSize();
-            /* Figure out and record the stack offset of the temp */
-            /* Need to align the offset? */
-            CLANG_FORMAT_COMMENT_ANCHOR;
-#ifdef TARGET_64BIT
-            if (varTypeIsGC(tempType) && ((stkOffs % TARGET_POINTER_SIZE) != 0))
-            {
-                int alignPad = (int)AlignmentPad((unsigned)-stkOffs, TARGET_POINTER_SIZE);
-                spillTempSize += alignPad;
-                lvaIncrementFrameSize(alignPad);
-                stkOffs -= alignPad;
-                noway_assert((stkOffs % TARGET_POINTER_SIZE) == 0);
-            }
-#endif
-            if (mustDoubleAlign && (tempType == TYP_DOUBLE)) // Align doubles for x86 and ARM
-            {
-                noway_assert((compLclFrameSize % TARGET_POINTER_SIZE) == 0);
-                if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
-                {
-                    spillTempSize += TARGET_POINTER_SIZE;
-                    lvaIncrementFrameSize(TARGET_POINTER_SIZE);
-                    stkOffs -= TARGET_POINTER_SIZE;
-                }
-                noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
-            }
-            spillTempSize += size;
-            lvaIncrementFrameSize(size);
-            stkOffs -= size;
-            temp->tdSetTempOffs(stkOffs);
-        }
-#ifdef TARGET_ARM
-        noway_assert(spillTempSize <= lvaGetMaxSpillTempSize());
-#endif
-    }
-    else // We haven't run codegen, so there are no Spill temps yet!
-    {
-        unsigned size = lvaGetMaxSpillTempSize();
-        lvaIncrementFrameSize(size);
-        stkOffs -= size;
-    }
-    return stkOffs;
-}
-#ifdef DEBUG
-/*****************************************************************************
- *
- *  Dump the register a local is in right now. It is only the current location, since the location changes and it
- *  is updated throughout code generation based on LSRA register assignments.
- */
-void Compiler::lvaDumpRegLocation(unsigned lclNum)
-{
-    const LclVarDsc* varDsc = lvaGetDesc(lclNum);
-#ifdef TARGET_ARM
-    if (varDsc->TypeGet() == TYP_DOUBLE)
-    {
-        printf("%3s:%-3s    ", getRegName(varDsc->GetRegNum()), getRegName(REG_NEXT(varDsc->GetRegNum())));
-    }
-    else
-#endif // TARGET_ARM
-    {
-        printf("%3s        ", getRegName(varDsc->GetRegNum()));
-    }
-}
-/*****************************************************************************
- *
- *  Dump the frame location assigned to a local.
- *  It's the home location, even though the variable doesn't always live
- *  in its home location.
- */
-void Compiler::lvaDumpFrameLocation(unsigned lclNum)
-{
-    int       offset;
-    regNumber baseReg;
-#ifdef TARGET_ARM
-    offset = lvaFrameAddress(lclNum, compLocallocUsed, &baseReg, 0, /* isFloatUsage */ false);
-#else
-    bool EBPbased;
-    offset  = lvaFrameAddress(lclNum, &EBPbased);
-    baseReg = EBPbased ? REG_FPBASE : REG_SPBASE;
-#endif
-    printf("[%2s%1s%02XH]  ", getRegName(baseReg), (offset < 0 ? "-" : "+"), (offset < 0 ? -offset : offset));
-}
-/*****************************************************************************
- *
- *  dump a single lvaTable entry
- */
-void Compiler::lvaDumpEntry(unsigned lclNum, FrameLayoutState curState, size_t refCntWtdWidth)
-{
-    LclVarDsc* varDsc = lvaGetDesc(lclNum);
-    var_types  type   = varDsc->TypeGet();
-    if (curState == INITIAL_FRAME_LAYOUT)
-    {
-        printf(";  ");
-        gtDispLclVar(lclNum);
-        printf(" %7s ", varTypeName(type));
-        gtDispLclVarStructType(lclNum);
-    }
-    else
-    {
-        if (varDsc->lvRefCnt() == 0)
-        {
-            printf(";* ");
-        }
-#if FEATURE_FIXED_OUT_ARGS
-        else if ((lclNum == lvaOutgoingArgSpaceVar) && lvaOutgoingArgSpaceSize.HasFinalValue() &&
-                 (lvaOutgoingArgSpaceSize == 0))
-        {
-            printf(";# ");
-        }
-#endif // FEATURE_FIXED_OUT_ARGS
-        else
-        {
-            printf(";  ");
-        }
-        gtDispLclVar(lclNum);
-        printf("[V%02u", lclNum);
-        if (varDsc->lvTracked)
-        {
-            printf(",T%02u]", varDsc->lvVarIndex);
-        }
-        else
-        {
-            printf("    ]");
-        }
-        printf(" (%3u,%*s)", varDsc->lvRefCnt(), (int)refCntWtdWidth, refCntWtd2str(varDsc->lvRefCntWtd()));
-        printf(" %7s ", varTypeName(type));
-        if (genTypeSize(type) == 0)
-        {
-            printf("(%2d) ", lvaLclSize(lclNum));
-        }
-        else
-        {
-            printf(" ->  ");
-        }
-        if ((varDsc->lvRefCnt() == 0) && !varDsc->lvImplicitlyReferenced)
-        {
-            printf("zero-ref   ");
-        }
-        else if (varDsc->lvRegister != 0)
-        {
-            lvaDumpRegLocation(lclNum);
-        }
-        else if (varDsc->lvOnFrame == 0)
-        {
-            printf("registers  ");
-        }
-        else
-        {
-            if (lvaDoneFrameLayout != NO_FRAME_LAYOUT)
-            {
-                lvaDumpFrameLocation(lclNum);
-            }
-        }
-    }
-    if (varDsc->lvIsHfa())
-    {
-        printf(" HFA(%s) ", varTypeName(varDsc->GetHfaType()));
-    }
-    if (varDsc->lvDoNotEnregister)
-    {
-        printf(" do-not-enreg[");
-        if (varDsc->IsAddressExposed())
-        {
-            printf("X");
-        }
-        if (varDsc->IsHiddenBufferStructArg())
-        {
-            printf("H");
-        }
-        if (varTypeIsStruct(varDsc))
-        {
-            printf("S");
-        }
-        if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::VMNeedsStackAddr)
-        {
-            printf("V");
-        }
-        if (lvaEnregEHVars && varDsc->lvLiveInOutOfHndlr)
-        {
-            printf("%c", varDsc->lvSingleDefDisqualifyReason);
-        }
-        if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::LocalField)
-        {
-            printf("F");
-        }
-        if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::BlockOp)
-        {
-            printf("B");
-        }
-        if (varDsc->lvIsMultiRegArg)
-        {
-            printf("A");
-        }
-        if (varDsc->lvIsMultiRegRet)
-        {
-            printf("R");
-        }
-#ifdef JIT32_GCENCODER
-        if (varDsc->lvPinned)
-            printf("P");
-#endif // JIT32_GCENCODER
-        printf("]");
-    }
-    if (varDsc->lvIsMultiRegArg)
-    {
-        printf(" multireg-arg");
-    }
-    if (varDsc->lvIsMultiRegRet)
-    {
-        printf(" multireg-ret");
-    }
-    if (varDsc->lvMustInit)
-    {
-        printf(" must-init");
-    }
-    if (varDsc->IsAddressExposed())
-    {
-        printf(" addr-exposed");
-    }
-    if (varDsc->IsHiddenBufferStructArg())
-    {
-        printf(" hidden-struct-arg");
-    }
-    if (varDsc->lvHasLdAddrOp)
-    {
-        printf(" ld-addr-op");
-    }
-    if (lvaIsOriginalThisArg(lclNum))
-    {
-        printf(" this");
-    }
-    if (varDsc->lvPinned)
-    {
-        printf(" pinned");
-    }
-    if (varDsc->lvClassHnd != NO_CLASS_HANDLE)
-    {
-        printf(" class-hnd");
-    }
-    if (varDsc->lvClassIsExact)
-    {
-        printf(" exact");
-    }
-    if (varDsc->lvLiveInOutOfHndlr)
-    {
-        printf(" EH-live");
-    }
-    if (varDsc->lvSpillAtSingleDef)
-    {
-        printf(" spill-single-def");
-    }
-    else if (varDsc->lvSingleDefRegCandidate)
-    {
-        printf(" single-def");
-    }
-    if (lvaIsOSRLocal(lclNum) && varDsc->lvOnFrame)
-    {
-        printf(" tier0-frame");
-    }
-#ifndef TARGET_64BIT
-    if (varDsc->lvStructDoubleAlign)
-        printf(" double-align");
-#endif // !TARGET_64BIT
-    if (varDsc->lvOverlappingFields)
-    {
-        printf(" overlapping-fields");
-    }
-    if (compGSReorderStackLayout && !varDsc->lvRegister)
-    {
-        if (varDsc->lvIsPtr)
-        {
-            printf(" ptr");
-        }
-        if (varDsc->lvIsUnsafeBuffer)
-        {
-            printf(" unsafe-buffer");
-        }
-    }
-    if (varDsc->lvIsStructField)
-    {
-        LclVarDsc* parentvarDsc = lvaGetDesc(varDsc->lvParentLcl);
-#if !defined(TARGET_64BIT)
-        if (varTypeIsLong(parentvarDsc))
-        {
-            bool isLo = (lclNum == parentvarDsc->lvFieldLclStart);
-            printf(" V%02u.%s(offs=0x%02x)", varDsc->lvParentLcl, isLo ? "lo" : "hi", isLo ? 0 : genTypeSize(TYP_INT));
-        }
-        else
-#endif // !defined(TARGET_64BIT)
-        {
-            CORINFO_CLASS_HANDLE typeHnd = parentvarDsc->GetStructHnd();
-            CORINFO_FIELD_HANDLE fldHnd  = info.compCompHnd->getFieldInClass(typeHnd, varDsc->lvFldOrdinal);
-            printf(" V%02u.%s(offs=0x%02x)", varDsc->lvParentLcl, eeGetFieldName(fldHnd), varDsc->lvFldOffset);
-            lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
-            switch (promotionType)
-            {
-                case PROMOTION_TYPE_NONE:
-                    printf(" P-NONE");
-                    break;
-                case PROMOTION_TYPE_DEPENDENT:
-                    printf(" P-DEP");
-                    break;
-                case PROMOTION_TYPE_INDEPENDENT:
-                    printf(" P-INDEP");
-                    break;
-            }
-        }
-    }
-    if (varDsc->lvReason != nullptr)
-    {
-        printf(" \"%s\"", varDsc->lvReason);
-    }
-    printf("\n");
-}
-/*****************************************************************************
-*
-*  dump the lvaTable
-*/
-void Compiler::lvaTableDump(FrameLayoutState curState)
-{
-    if (curState == NO_FRAME_LAYOUT)
-    {
-        curState = lvaDoneFrameLayout;
-        if (curState == NO_FRAME_LAYOUT)
-        {
-            curState = INITIAL_FRAME_LAYOUT;
-        }
-    }
-    if (curState == INITIAL_FRAME_LAYOUT)
-    {
-        printf("; Initial");
-    }
-    else if (curState == PRE_REGALLOC_FRAME_LAYOUT)
-    {
-        printf("; Pre-RegAlloc");
-    }
-    else if (curState == REGALLOC_FRAME_LAYOUT)
-    {
-        printf("; RegAlloc");
-    }
-    else if (curState == TENTATIVE_FRAME_LAYOUT)
-    {
-        printf("; Tentative");
-    }
-    else if (curState == FINAL_FRAME_LAYOUT)
-    {
-        printf("; Final");
-    }
-    else
-    {
-        printf("UNKNOWN FrameLayoutState!");
-        unreached();
-    }
-    printf(" local variable assignments\n");
-    printf(";\n");
-    unsigned   lclNum;
-    LclVarDsc* varDsc;
-    size_t refCntWtdWidth = 6; // Use 6 as the minimum width
-    if (curState != INITIAL_FRAME_LAYOUT) // don't need this info for INITIAL_FRAME_LAYOUT
-    {
-        for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-        {
-            size_t width = strlen(refCntWtd2str(varDsc->lvRefCntWtd()));
-            if (width > refCntWtdWidth)
-            {
-                refCntWtdWidth = width;
-            }
-        }
-    }
-    for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-    {
-        lvaDumpEntry(lclNum, curState, refCntWtdWidth);
-    }
-    assert(codeGen->regSet.tmpAllFree());
-    for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
-    {
-        printf(";  TEMP_%02u %26s%*s%7s  -> ", -temp->tdTempNum(), " ", refCntWtdWidth, " ",
-               varTypeName(temp->tdTempType()));
-        int offset = temp->tdTempOffs();
-        printf(" [%2s%1s0x%02X]\n", isFramePointerUsed() ? STR_FPBASE : STR_SPBASE, (offset < 0 ? "-" : "+"),
-               (offset < 0 ? -offset : offset));
-    }
-    if (curState >= TENTATIVE_FRAME_LAYOUT)
-    {
-        printf(";\n");
-        printf("; Lcl frame size = %d\n", compLclFrameSize);
-    }
-}
-#endif // DEBUG
-/*****************************************************************************
- *
- *  Conservatively estimate the layout of the stack frame.
- *
- *  This function is only used before final frame layout. It conservatively estimates the
- *  number of callee-saved registers that must be saved, then calls lvaAssignFrameOffsets().
- *  To do final frame layout, the callee-saved registers are known precisely, so
- *  lvaAssignFrameOffsets() is called directly.
- *
- *  Returns the (conservative, that is, overly large) estimated size of the frame,
- *  including the callee-saved registers. This is only used by the emitter during code
- *  generation when estimating the size of the offset of instructions accessing temps,
- *  and only if temps have a larger offset than variables.
- */
-unsigned Compiler::lvaFrameSize(FrameLayoutState curState)
-{
-    assert(curState < FINAL_FRAME_LAYOUT);
-    unsigned result;
-    /* Layout the stack frame conservatively.
-       Assume all callee-saved registers are spilled to stack */
-    compCalleeRegsPushed = CNT_CALLEE_SAVED;
-#if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
-    if (compFloatingPointUsed)
-        compCalleeRegsPushed += CNT_CALLEE_SAVED_FLOAT;
-    compCalleeRegsPushed++; // we always push LR/RA.  See genPushCalleeSavedRegisters
-#elif defined(TARGET_AMD64)
-    if (compFloatingPointUsed)
-    {
-        compCalleeFPRegsSavedMask = RBM_FLT_CALLEE_SAVED;
-    }
-    else
-    {
-        compCalleeFPRegsSavedMask = RBM_NONE;
-    }
-#endif
-#if DOUBLE_ALIGN
-    if (genDoubleAlign())
-    {
-        compCalleeRegsPushed++;
-    }
-#endif
-#ifdef TARGET_XARCH
-    if (codeGen->isFramePointerUsed())
-    {
-        compCalleeRegsPushed--;
-    }
-#endif
-    lvaAssignFrameOffsets(curState);
-    unsigned calleeSavedRegMaxSz = CALLEE_SAVED_REG_MAXSZ;
-#if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
-    if (compFloatingPointUsed)
-    {
-        calleeSavedRegMaxSz += CALLEE_SAVED_FLOAT_MAXSZ;
-    }
-    calleeSavedRegMaxSz += REGSIZE_BYTES; // we always push LR/RA.  See genPushCalleeSavedRegisters
-#endif
-    result = compLclFrameSize + calleeSavedRegMaxSz;
-    return result;
-}
-int Compiler::lvaGetSPRelativeOffset(unsigned varNum)
-{
-    assert(!compLocallocUsed);
-    assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
-    const LclVarDsc* varDsc = lvaGetDesc(varNum);
-    assert(varDsc->lvOnFrame);
-    int spRelativeOffset;
-    if (varDsc->lvFramePointerBased)
-    {
-        spRelativeOffset = varDsc->GetStackOffset() + codeGen->genSPtoFPdelta();
-    }
-    else
-    {
-        spRelativeOffset = varDsc->GetStackOffset();
-    }
-    assert(spRelativeOffset >= 0);
-    return spRelativeOffset;
-}
-/*****************************************************************************
- *
- *  Return the caller-SP-relative stack offset of a local/parameter.
- *  Requires the local to be on the stack and frame layout to be complete.
- */
-int Compiler::lvaGetCallerSPRelativeOffset(unsigned varNum)
-{
-    assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
-    const LclVarDsc* varDsc = lvaGetDesc(varNum);
-    assert(varDsc->lvOnFrame);
-    return lvaToCallerSPRelativeOffset(varDsc->GetStackOffset(), varDsc->lvFramePointerBased);
-}
-int Compiler::lvaToCallerSPRelativeOffset(int offset, bool isFpBased, bool forRootFrame) const
-{
-    assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
-    if (isFpBased)
-    {
-        offset += codeGen->genCallerSPtoFPdelta();
-    }
-    else
-    {
-        offset += codeGen->genCallerSPtoInitialSPdelta();
-    }
-#if defined(TARGET_AMD64) || defined(TARGET_ARM64)
-    if (forRootFrame && opts.IsOSR())
-    {
-        const PatchpointInfo* const ppInfo = info.compPatchpointInfo;
-#if defined(TARGET_AMD64)
-        const int adjustment = ppInfo->TotalFrameSize() + REGSIZE_BYTES;
-#elif defined(TARGET_ARM64)
-        const int adjustment = ppInfo->TotalFrameSize();
-#endif
-        offset -= adjustment;
-    }
-#else
-    assert(!opts.IsOSR());
-#endif
-    return offset;
-}
-/*****************************************************************************
- *
- *  Return the Initial-SP-relative stack offset of a local/parameter.
- *  Requires the local to be on the stack and frame layout to be complete.
- */
-int Compiler::lvaGetInitialSPRelativeOffset(unsigned varNum)
-{
-    assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
-    const LclVarDsc* varDsc = lvaGetDesc(varNum);
-    assert(varDsc->lvOnFrame);
-    return lvaToInitialSPRelativeOffset(varDsc->GetStackOffset(), varDsc->lvFramePointerBased);
-}
-int Compiler::lvaToInitialSPRelativeOffset(unsigned offset, bool isFpBased)
-{
-    assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
-#ifdef TARGET_AMD64
-    if (isFpBased)
-    {
-        assert(codeGen->isFramePointerUsed());
-        offset += codeGen->genSPtoFPdelta();
-    }
-    else
-    {
-    }
-#else  // !TARGET_AMD64
-    NYI("lvaToInitialSPRelativeOffset");
-#endif // !TARGET_AMD64
-    return offset;
-}
-/*****************************************************************************/
-#ifdef DEBUG
-/*****************************************************************************
- *  Pick a padding size at "random" for the local.
- *  0 means that it should not be converted to a GT_LCL_FLD
- */
-static unsigned LCL_FLD_PADDING(unsigned lclNum)
-{
-    if (lclNum % 2)
-    {
-        return 0;
-    }
-    unsigned size = lclNum % 7;
-    return size;
-}
-/*****************************************************************************
- *
- *  Callback for fgWalkAllTreesPre()
- *  Convert as many GT_LCL_VAR's to GT_LCL_FLD's
- */
-/* static */
-/*
-    The stress mode does 2 passes.
-    In the first pass we will mark the locals where we CAN't apply the stress mode.
-    In the second pass we will do the appropriate morphing wherever we've not determined we can't do it.
-*/
-Compiler::fgWalkResult Compiler::lvaStressLclFldCB(GenTree** pTree, fgWalkData* data)
-{
-    GenTree*   tree = *pTree;
-    genTreeOps oper = tree->OperGet();
-    GenTree*   lcl;
-    switch (oper)
-    {
-        case GT_LCL_VAR:
-        case GT_LCL_VAR_ADDR:
-            lcl = tree;
-            break;
-        case GT_ADDR:
-            if (tree->AsOp()->gtOp1->gtOper != GT_LCL_VAR)
-            {
-                return WALK_CONTINUE;
-            }
-            lcl = tree->AsOp()->gtOp1;
-            break;
-        default:
-            return WALK_CONTINUE;
-    }
-    noway_assert(lcl->OperIs(GT_LCL_VAR, GT_LCL_VAR_ADDR));
-    Compiler* const  pComp      = ((lvaStressLclFldArgs*)data->pCallbackData)->m_pCompiler;
-    const bool       bFirstPass = ((lvaStressLclFldArgs*)data->pCallbackData)->m_bFirstPass;
-    const unsigned   lclNum     = lcl->AsLclVarCommon()->GetLclNum();
-    var_types        type       = lcl->TypeGet();
-    LclVarDsc* const varDsc     = pComp->lvaGetDesc(lclNum);
-    if (varDsc->lvNoLclFldStress)
-    {
-        return WALK_SKIP_SUBTREES;
-    }
-    if (bFirstPass)
-    {
-        if (varDsc->lvIsParam || lclNum >= pComp->info.compLocalsCount)
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        if (pComp->lvaIsOSRLocal(lclNum))
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        if (pComp->doesMethodHavePatchpoints() || pComp->doesMethodHavePartialCompilationPatchpoints())
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        if (varDsc->lvKeepType)
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        if (!varTypeIsArithmetic(type))
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        if ((varDsc->lvType != lcl->gtType) && (varDsc->lvType != TYP_BLK))
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        var_types varType = varDsc->TypeGet();
-        if (varType != TYP_BLK && genTypeSize(varType) != genTypeSize(genActualType(varType)))
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-        unsigned padding = LCL_FLD_PADDING(lclNum);
-        if (padding == 0)
-        {
-            varDsc->lvNoLclFldStress = true;
-            return WALK_SKIP_SUBTREES;
-        }
-    }
-    else
-    {
-        noway_assert((varDsc->lvType == lcl->gtType) || (varDsc->lvType == TYP_BLK));
-        var_types varType = varDsc->TypeGet();
-        unsigned padding = LCL_FLD_PADDING(lclNum);
-#if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
-        unsigned alignment = 1;
-        pComp->codeGen->InferOpSizeAlign(lcl, &alignment);
-        alignment = roundUp(alignment, TARGET_POINTER_SIZE);
-        padding   = roundUp(padding, alignment);
-#endif // TARGET_ARMARCH || TARGET_LOONGARCH64
-        if (varType != TYP_BLK)
-        {
-            varDsc->lvExactSize = roundUp(padding + pComp->lvaLclSize(lclNum), TARGET_POINTER_SIZE);
-            varDsc->lvType      = TYP_BLK;
-            pComp->lvaSetVarAddrExposed(lclNum DEBUGARG(AddressExposedReason::STRESS_LCL_FLD));
-        }
-        tree->gtFlags |= GTF_GLOB_REF;
-        /* Now morph the tree appropriately */
-        if (oper == GT_LCL_VAR)
-        {
-            /* Change lclVar(lclNum) to lclFld(lclNum,padding) */
-            tree->ChangeOper(GT_LCL_FLD);
-            tree->AsLclFld()->SetLclOffs(padding);
-        }
-        else if (oper == GT_LCL_VAR_ADDR)
-        {
-            tree->ChangeOper(GT_LCL_FLD_ADDR);
-            tree->AsLclFld()->SetLclOffs(padding);
-        }
-        else
-        {
-            /* Change addr(lclVar) to addr(lclVar)+padding */
-            noway_assert(oper == GT_ADDR);
-            GenTree* paddingTree = pComp->gtNewIconNode(padding);
-            GenTree* newAddr     = pComp->gtNewOperNode(GT_ADD, tree->gtType, tree, paddingTree);
-            *pTree = newAddr;
-            lcl->gtType = TYP_BLK;
-        }
-    }
-    return WALK_SKIP_SUBTREES;
-}
-/*****************************************************************************/
-void Compiler::lvaStressLclFld()
-{
-    if (!compStressCompile(STRESS_LCL_FLDS, 5))
-    {
-        return;
-    }
-    lvaStressLclFldArgs Args;
-    Args.m_pCompiler  = this;
-    Args.m_bFirstPass = true;
-    fgWalkAllTreesPre(lvaStressLclFldCB, &Args);
-    Args.m_bFirstPass = false;
-    fgWalkAllTreesPre(lvaStressLclFldCB, &Args);
-}
-#endif // DEBUG
-/*****************************************************************************
- *
- *  A little routine that displays a local variable bitset.
- *  'set' is mask of variables that have to be displayed
- *  'allVars' is the complete set of interesting variables (blank space is
- *    inserted if its corresponding bit is not in 'set').
- */
-#ifdef DEBUG
-void Compiler::lvaDispVarSet(VARSET_VALARG_TP set)
-{
-    VARSET_TP allVars(VarSetOps::MakeEmpty(this));
-    lvaDispVarSet(set, allVars);
-}
-void Compiler::lvaDispVarSet(VARSET_VALARG_TP set, VARSET_VALARG_TP allVars)
-{
-    printf("{");
-    bool needSpace = false;
-    for (unsigned index = 0; index < lvaTrackedCount; index++)
-    {
-        if (VarSetOps::IsMember(this, set, index))
-        {
-            unsigned   lclNum;
-            LclVarDsc* varDsc;
-            /* Look for the matching variable */
-            for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
-            {
-                if ((varDsc->lvVarIndex == index) && varDsc->lvTracked)
-                {
-                    break;
-                }
-            }
-            if (needSpace)
-            {
-                printf(" ");
-            }
-            else
-            {
-                needSpace = true;
-            }
-            printf("V%02u", lclNum);
-        }
-        else if (VarSetOps::IsMember(this, allVars, index))
-        {
-            if (needSpace)
-            {
-                printf(" ");
-            }
-            else
-            {
-                needSpace = true;
-            }
-            printf("   ");
-        }
-    }
-    printf("}");
-}
-#endif // DEBUG

--- a/src/coreclr/vm/perfinfo.cpp
+++ b//dev/null
@@ -1,90 +0,0 @@
-#include "common.h"
-#if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
-#include "perfinfo.h"
-#include "pal.h"
-PerfInfo::PerfInfo(int pid, const char* basePath)
-  : m_Stream(nullptr)
-{
-    LIMITED_METHOD_CONTRACT;
-    SString path;
-    path.Printf("%s/perfinfo-%d.map", basePath, pid);
-    OpenFile(path);
-}
-void PerfInfo::LogImage(PEAssembly* pPEAssembly, WCHAR* guid)
-{
-    CONTRACTL
-    {
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pPEAssembly != nullptr);
-        PRECONDITION(guid != nullptr);
-    } CONTRACTL_END;
-    SString value;
-    const SString& path = pPEAssembly->GetPath();
-    if (path.IsEmpty())
-    {
-        return;
-    }
-    SIZE_T baseAddr = 0;
-    if (pPEAssembly->IsReadyToRun())
-    {
-        PEImageLayout *pLoadedLayout = pPEAssembly->GetLoadedLayout();
-        if (pLoadedLayout)
-        {
-            baseAddr = (SIZE_T)pLoadedLayout->GetBase();
-        }
-    }
-    value.Printf("%S%c%S%c%p", path.GetUnicode(), sDelimiter, guid, sDelimiter, baseAddr);
-    SString command;
-    command.Printf("%s", "ImageLoad");
-    WriteLine(command, value);
-}
-void PerfInfo::WriteLine(SString& type, SString& value)
-{
-    CONTRACTL
-    {
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-    } CONTRACTL_END;
-    if (m_Stream == nullptr)
-    {
-        return;
-    }
-    SString line;
-    line.Printf("%S%c%S%c\n",
-            type.GetUnicode(), sDelimiter, value.GetUnicode(), sDelimiter);
-    EX_TRY
-    {
-        const char* strLine = line.GetUTF8();
-        ULONG inCount = line.GetCount();
-        ULONG outCount;
-        m_Stream->Write(strLine, inCount, &outCount);
-        if (inCount != outCount)
-        {
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfInfo::OpenFile(SString& path)
-{
-    STANDARD_VM_CONTRACT;
-    m_Stream = new (nothrow) CFileStream();
-    if (m_Stream != nullptr)
-    {
-        HRESULT hr = m_Stream->OpenForWrite(path.GetUnicode());
-        if (FAILED(hr))
-        {
-            delete m_Stream;
-            m_Stream = nullptr;
-        }
-    }
-}
-PerfInfo::~PerfInfo()
-{
-    LIMITED_METHOD_CONTRACT;
-    delete m_Stream;
-    m_Stream = nullptr;
-}
-#endif

--- a/src/coreclr/vm/perfinfo.h
+++ b//dev/null
@@ -1,23 +0,0 @@
-#ifndef PERFINFO_H
-#define PERFINFO_H
-#include "sstring.h"
-#include "fstream.h"
-/*
-   A perfinfo-%d.map is created for every process that is created with manage code, the %d
-   being repaced with the process ID.
-   Every line in the perfinfo-%d.map is a type and value, separated by sDelimiter character: type;value
-   type represents what the user might want to do with its given value. value has a format chosen by
-   the user for parsing later on.
-*/
-class PerfInfo {
-public:
-    PerfInfo(int pid, const char* basePath);
-    ~PerfInfo();
-    void LogImage(PEAssembly* pPEAssembly, WCHAR* guid);
-private:
-    CFileStream* m_Stream;
-    const char sDelimiter = ';';
-    void OpenFile(SString& path);
-    void WriteLine(SString& type, SString& value);
-};
-#endif

--- a/src/coreclr/vm/perfmap.cpp
+++ b//dev/null
@@ -1,364 +0,0 @@
-#include "common.h"
-#if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
-#include <clrconfignocache.h>
-#include "perfmap.h"
-#include "perfinfo.h"
-#include "pal.h"
-#define FMT_CODE_ADDR "%p"
-#ifndef __ANDROID__
-#define TEMP_DIRECTORY_PATH "/tmp"
-#else
-#define TEMP_DIRECTORY_PATH "/data/local/tmp"
-#endif
-Volatile<bool> PerfMap::s_enabled = false;
-PerfMap * PerfMap::s_Current = nullptr;
-bool PerfMap::s_ShowOptimizationTiers = false;
-unsigned PerfMap::s_StubsMapped = 0;
-enum 
-{
-    DISABLED,
-    ALL,
-    JITDUMP,
-    PERFMAP
-};
-void PerfMap::Initialize()
-{
-    LIMITED_METHOD_CONTRACT;
-    const DWORD perfMapEnabled = CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapEnabled);
-    if (perfMapEnabled == DISABLED)
-    {
-        return;
-    }
-    char tempPathBuffer[MAX_LONGPATH+1];
-    const char* tempPath = InternalConstructPath(tempPathBuffer, sizeof(tempPathBuffer));
-    if (perfMapEnabled == ALL || perfMapEnabled == PERFMAP)
-    {
-        int currentPid = GetCurrentProcessId();
-        s_Current = new PerfMap(currentPid, tempPath);
-        int signalNum = (int) CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapIgnoreSignal);
-        if (signalNum > 0)
-        {
-            PAL_IgnoreProfileSignal(signalNum);
-        }
-    }
-    if (perfMapEnabled == ALL || perfMapEnabled == JITDUMP)
-    {
-        PAL_PerfJitDump_Start(tempPath);
-    }
-    if (CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapShowOptimizationTiers) != 0)
-    {
-        s_ShowOptimizationTiers = true;
-    }
-    s_enabled = true;
-}
-const char * PerfMap::InternalConstructPath(char *tmpBuf, int lenBuf)
-{
-    DWORD len = GetEnvironmentVariableA("DOTNET_PerfMapJitDumpPath", tmpBuf, lenBuf);
-    if (len == 0)
-    {
-        len = GetEnvironmentVariableA("COMPlus_PerfMapJitDumpPath", tmpBuf, lenBuf);
-    }
-    if (len == 0 || // GetEnvironmentVariableA returns 0 if the variable is not found, 
-        len >= lenBuf) // or the length of the string not including the null terminator on success.
-    {
-        return TEMP_DIRECTORY_PATH;
-    }
-    return tmpBuf;
-}
-void PerfMap::Destroy()
-{
-    LIMITED_METHOD_CONTRACT;
-    if (s_enabled)
-    {
-        s_enabled = false;
-        PAL_PerfJitDump_Finish();
-    }
-}
-PerfMap::PerfMap(int pid, const char* path)
-{
-    LIMITED_METHOD_CONTRACT;
-    m_ErrorEncountered = false;
-    SString pathFile;
-    pathFile.Printf("%s/perf-%d.map", path, pid);
-    OpenFile(pathFile);
-    m_PerfInfo = new PerfInfo(pid, path);
-}
-PerfMap::PerfMap()
-  : m_FileStream(nullptr)
-  , m_PerfInfo(nullptr)
-{
-    LIMITED_METHOD_CONTRACT;
-    m_ErrorEncountered = false;
-}
-PerfMap::~PerfMap()
-{
-    LIMITED_METHOD_CONTRACT;
-    delete m_FileStream;
-    m_FileStream = nullptr;
-    delete m_PerfInfo;
-    m_PerfInfo = nullptr;
-}
-void PerfMap::OpenFile(SString& path)
-{
-    STANDARD_VM_CONTRACT;
-    m_FileStream = new (nothrow) CFileStream();
-    if(m_FileStream != nullptr)
-    {
-        HRESULT hr = m_FileStream->OpenForWrite(path.GetUnicode());
-        if(FAILED(hr))
-        {
-            delete m_FileStream;
-            m_FileStream = nullptr;
-        }
-    }
-}
-void PerfMap::WriteLine(SString& line)
-{
-    STANDARD_VM_CONTRACT;
-    if (m_FileStream == nullptr || m_ErrorEncountered)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        const char * strLine = line.GetUTF8();
-        ULONG inCount = line.GetCount();
-        ULONG outCount;
-        m_FileStream->Write(strLine, inCount, &outCount);
-        if (inCount != outCount)
-        {
-            m_ErrorEncountered = true;
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogImageLoad(PEAssembly * pPEAssembly)
-{
-    if (s_enabled && s_Current != nullptr)
-    {
-        s_Current->LogImage(pPEAssembly);
-    }
-}
-void PerfMap::LogImage(PEAssembly * pPEAssembly)
-{
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pPEAssembly != nullptr);
-    } CONTRACTL_END;
-    if (m_FileStream == nullptr || m_ErrorEncountered)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        WCHAR wszSignature[39];
-        GetNativeImageSignature(pPEAssembly, wszSignature, ARRAY_SIZE(wszSignature));
-        m_PerfInfo->LogImage(pPEAssembly, wszSignature);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig)
-{
-    LIMITED_METHOD_CONTRACT;
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pMethod != nullptr);
-        PRECONDITION(pCode != nullptr);
-        PRECONDITION(codeSize > 0);
-    } CONTRACTL_END;
-    if (!s_enabled)
-    {
-        return;
-    }
-    const char *optimizationTier = nullptr;
-    if (s_ShowOptimizationTiers)
-    {
-        optimizationTier = PrepareCodeConfig::GetJitOptimizationTierStr(pConfig, pMethod);
-    }
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        if (optimizationTier != nullptr && s_ShowOptimizationTiers)
-        {
-            name.AppendPrintf("[%s]", optimizationTier);
-        }
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
-        if(s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode)
-{
-    LIMITED_METHOD_CONTRACT;
-    if (!s_enabled)
-    {
-        return;
-    }
-    EECodeInfo codeInfo(pCode);
-    _ASSERTE(codeInfo.IsValid());
-    IJitManager::MethodRegionInfo methodRegionInfo;
-    codeInfo.GetMethodRegionInfo(&methodRegionInfo);
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        if (s_ShowOptimizationTiers)
-        {
-            name.Append(W("[PreJIT]"));
-        }
-        if (methodRegionInfo.hotSize > 0)
-        {
-            PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.hotStartAddress, methodRegionInfo.hotSize, name.GetUTF8(), nullptr, nullptr);
-        }
-        if (methodRegionInfo.coldSize > 0)
-        {
-            if (s_ShowOptimizationTiers)
-            {
-                pMethod->GetFullMethodInfo(name);
-                name.Append(W("[PreJit-cold]"));
-            }
-            PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.coldStartAddress, methodRegionInfo.coldSize, name.GetUTF8(), nullptr, nullptr);
-        }
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize)
-{
-    LIMITED_METHOD_CONTRACT;
-    if (!s_enabled)
-    {
-        return;
-    }
-    EX_TRY
-    {
-        if(!stubOwner)
-        {
-            stubOwner = "?";
-        }
-        if(!stubType)
-        {
-            stubType = "?";
-        }
-        SString name;
-        name.Printf("stub<%d> %s<%s>", ++(s_StubsMapped), stubType, stubOwner);
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
-        if(s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void PerfMap::GetNativeImageSignature(PEAssembly * pPEAssembly, WCHAR * pwszSig, unsigned int nSigSize)
-{
-    CONTRACTL{
-        PRECONDITION(pPEAssembly != nullptr);
-        PRECONDITION(pwszSig != nullptr);
-        PRECONDITION(nSigSize >= 39);
-    } CONTRACTL_END;
-    GUID mvid;
-    pPEAssembly->GetMVID(&mvid);
-    if(!StringFromGUID2(mvid, pwszSig, nSigSize))
-    {
-        pwszSig[0] = '\0';
-    }
-}
-NativeImagePerfMap::NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath)
-  : PerfMap()
-{
-    STANDARD_VM_CONTRACT;
-    LPCUTF8 lpcSimpleName = pAssembly->GetSimpleName();
-    WCHAR wszSignature[39];
-    GetNativeImageSignature(pAssembly->GetPEAssembly(), wszSignature, ARRAY_SIZE(wszSignature));
-    SString sDestPerfMapPath;
-    sDestPerfMapPath.Printf("%S%s.ni.%S.map", pDestPath, lpcSimpleName, wszSignature);
-    OpenFile(sDestPerfMapPath);
-    m_EmitRVAs = true;
-    CLRConfigStringHolder wszFormat(CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_NativeImagePerfMapFormat));
-    if(wszFormat != NULL && (wcsncmp(wszFormat, strOFFSET, wcslen(strOFFSET)) == 0))
-    {
-        m_EmitRVAs = false;
-    }
-}
-void NativeImagePerfMap::LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier)
-{
-    CONTRACTL{
-        THROWS;
-        GC_NOTRIGGER;
-        MODE_PREEMPTIVE;
-        PRECONDITION(pMethod != nullptr);
-        PRECONDITION(pCode != nullptr);
-        PRECONDITION(codeSize > 0);
-    } CONTRACTL_END;
-    EX_TRY
-    {
-        SString name;
-        pMethod->GetFullMethodInfo(name);
-        if (optimizationTier != nullptr && s_ShowOptimizationTiers)
-        {
-            name.AppendPrintf("[%s]", optimizationTier);
-        }
-        SString line;
-        line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
-        if (s_Current != nullptr)
-        {
-            s_Current->WriteLine(line);
-        }
-        PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
-    }
-    EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
-}
-void NativeImagePerfMap::LogDataForModule(Module * pModule)
-{
-    STANDARD_VM_CONTRACT;
-    PEImageLayout * pLoadedLayout = pModule->GetPEAssembly()->GetLoadedLayout();
-    _ASSERTE(pLoadedLayout != nullptr);
-    ReadyToRunInfo::MethodIterator mi(pModule->GetReadyToRunInfo());
-    while (mi.Next())
-    {
-        MethodDesc* hotDesc = mi.GetMethodDesc();
-        LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, "ReadyToRun");
-    }
-}
-void NativeImagePerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier)
-{
-    STANDARD_VM_CONTRACT;
-    _ASSERTE(pLoadedLayout != nullptr);
-    SIZE_T baseAddr = (SIZE_T)pLoadedLayout->GetBase();
-    EECodeInfo codeInfo(pCode);
-    _ASSERTE(codeInfo.IsValid());
-    IJitManager::MethodRegionInfo methodRegionInfo;
-    codeInfo.GetMethodRegionInfo(&methodRegionInfo);
-    PCODE addr;
-    if (methodRegionInfo.hotSize > 0)
-    {
-        addr = (PCODE)methodRegionInfo.hotStartAddress - baseAddr;
-        if (!m_EmitRVAs)
-        {
-            addr = pLoadedLayout->RvaToOffset(addr);
-        }
-        LogMethod(pMethod, addr, methodRegionInfo.hotSize, optimizationTier);
-    }
-    if (methodRegionInfo.coldSize > 0)
-    {
-        addr = (PCODE)methodRegionInfo.coldStartAddress - baseAddr;
-        if (!m_EmitRVAs)
-        {
-            addr = pLoadedLayout->RvaToOffset(addr);
-        }
-        LogMethod(pMethod, addr, methodRegionInfo.coldSize, optimizationTier);
-    }
-}
-#endif // FEATURE_PERFMAP && !DACCESS_COMPILE

--- a/src/coreclr/vm/perfmap.h
+++ b//dev/null
@@ -1,45 +0,0 @@
-#ifndef PERFPID_H
-#define PERFPID_H
-#include "sstring.h"
-#include "fstream.h"
-#include "volatile.h"
-class PerfInfo;
-class PerfMap
-{
-private:
-    static Volatile<bool> s_enabled;
-    static unsigned s_StubsMapped;
-    CFileStream * m_FileStream;
-    PerfInfo* m_PerfInfo;
-    bool m_ErrorEncountered;
-    PerfMap(int pid, const char* path);
-    static const char* InternalConstructPath(char *tmpBuf, int lenBuf);
-protected:
-    static bool s_ShowOptimizationTiers;
-    static PerfMap * s_Current;
-    PerfMap();
-    ~PerfMap();
-    void OpenFile(SString& path);
-    void LogImage(PEAssembly * pPEAssembly);
-    static void GetNativeImageSignature(PEAssembly * pPEAssembly, WCHAR * pwszSig, unsigned int nSigSize);
-public:
-    void WriteLine(SString & line);
-    static void Initialize();
-    static void LogImageLoad(PEAssembly * pPEAssembly);
-    static void LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig);
-    static void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode);
-    static void LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize);
-    static void Destroy();
-};
-class NativeImagePerfMap : PerfMap
-{
-private:
-    const WCHAR *strOFFSET = W("OFFSET");
-    bool m_EmitRVAs;
-    void LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier);
-    void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier);
-public:
-    NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath);
-    void LogDataForModule(Module * pModule);
-};
-#endif // PERFPID_H

--- a/src/coreclr/vm/syncblk.h
+++ b//dev/null
@@ -1,1114 +0,0 @@
-#ifndef _SYNCBLK_H_
-#define _SYNCBLK_H_
-#include "util.hpp"
-#include "slist.h"
-#include "crst.h"
-#include "vars.hpp"
-#ifdef TARGET_X86
-#include <pshpack4.h>
-#endif // TARGET_X86
-class SyncBlock;
-class SyncBlockCache;
-class SyncTableEntry;
-class SyncBlockArray;
-class AwareLock;
-class Thread;
-class AppDomain;
-#ifdef EnC_SUPPORTED
-class EnCSyncBlockInfo;
-typedef DPTR(EnCSyncBlockInfo) PTR_EnCSyncBlockInfo;
-#endif // EnC_SUPPORTED
-#include "eventstore.hpp"
-#include "eventstore.hpp"
-#include "synch.h"
-#define BIT_SBLK_UNUSED                     0x80000000
-#define BIT_SBLK_FINALIZER_RUN              0x40000000
-#define BIT_SBLK_GC_RESERVE                 0x20000000
-#define BIT_SBLK_SPIN_LOCK                  0x10000000
-#define BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX    0x08000000
-#define SBLK_MASK_LOCK_THREADID             0x0000FFFF   // special value of 0 + 65535 thread ids
-#define SBLK_MASK_LOCK_RECLEVEL             0x003F0000   // 64 recursion levels
-#define SBLK_LOCK_RECLEVEL_INC              0x00010000   // each level is this much higher than the previous one
-#define SBLK_RECLEVEL_SHIFT                 16           // shift right this much to get recursion level
-#define BIT_SBLK_IS_HASHCODE            0x04000000
-#define HASHCODE_BITS                   26
-#define MASK_HASHCODE                   ((1<<HASHCODE_BITS)-1)
-#define SYNCBLOCKINDEX_BITS             26
-#define MASK_SYNCBLOCKINDEX             ((1<<SYNCBLOCKINDEX_BITS)-1)
-#define     BIT_SBLK_SPIN_COUNT         1000
-#ifdef HOST_64BIT
-#define SIZEOF_OBJHEADER    8
-#else // !HOST_64BIT
-#define SIZEOF_OBJHEADER    4
-#endif // !HOST_64BIT
-inline void InitializeSpinConstants()
-{
-    WRAPPER_NO_CONTRACT;
-#if !defined(DACCESS_COMPILE)
-    g_SpinConstants.dwInitialDuration = g_pConfig->SpinInitialDuration();
-    g_SpinConstants.dwMaximumDuration = min(g_pConfig->SpinLimitProcCap(), g_SystemInfo.dwNumberOfProcessors) * g_pConfig->SpinLimitProcFactor() + g_pConfig->SpinLimitConstant();
-    g_SpinConstants.dwBackoffFactor   = g_pConfig->SpinBackoffFactor();
-    g_SpinConstants.dwRepetitions     = g_pConfig->SpinRetryCount();
-    g_SpinConstants.dwMonitorSpinCount = g_SpinConstants.dwMaximumDuration == 0 ? 0 : g_pConfig->MonitorSpinCount();
-#endif
-}
-typedef DPTR(class AwareLock) PTR_AwareLock;
-class AwareLock
-{
-    friend class CheckAsmOffsets;
-    friend class SyncBlockCache;
-    friend class SyncBlock;
-public:
-    enum EnterHelperResult {
-        EnterHelperResult_Entered,
-        EnterHelperResult_Contention,
-        EnterHelperResult_UseSlowPath
-    };
-    enum LeaveHelperAction {
-        LeaveHelperAction_None,
-        LeaveHelperAction_Signal,
-        LeaveHelperAction_Yield,
-        LeaveHelperAction_Contention,
-        LeaveHelperAction_Error,
-    };
-private:
-    class LockState
-    {
-    private:
-        static const UINT32 IsLockedMask = (UINT32)1 << 0; // bit 0
-        static const UINT32 ShouldNotPreemptWaitersMask = (UINT32)1 << 1; // bit 1
-        static const UINT32 SpinnerCountIncrement = (UINT32)1 << 2;
-        static const UINT32 SpinnerCountMask = (UINT32)0x7 << 2; // bits 2-4
-        static const UINT32 IsWaiterSignaledToWakeMask = (UINT32)1 << 5; // bit 5
-        static const UINT8 WaiterCountShift = 6;
-        static const UINT32 WaiterCountIncrement = (UINT32)1 << WaiterCountShift;
-        static const UINT32 WaiterCountMask = (UINT32)-1 >> WaiterCountShift << WaiterCountShift; // bits 6-31
-    private:
-        UINT32 m_state;
-    public:
-        LockState(UINT32 state = 0) : m_state(state)
-        {
-            LIMITED_METHOD_CONTRACT;
-        }
-    public:
-        UINT32 GetState() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return m_state;
-        }
-        UINT32 GetMonitorHeldState() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            static_assert_no_msg(IsLockedMask == 1);
-            static_assert_no_msg(WaiterCountShift >= 1);
-            UINT32 state = m_state;
-            return (state & IsLockedMask) + (state >> WaiterCountShift << 1);
-        }
-    public:
-        bool IsUnlockedWithNoWaiters() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return !(m_state & (IsLockedMask + WaiterCountMask));
-        }
-        void InitializeToLockedWithNoWaiters()
-        {
-            LIMITED_METHOD_CONTRACT;
-            _ASSERTE(!m_state);
-            m_state = IsLockedMask;
-        }
-    public:
-        bool IsLocked() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return !!(m_state & IsLockedMask);
-        }
-    private:
-        void InvertIsLocked()
-        {
-            LIMITED_METHOD_CONTRACT;
-            m_state ^= IsLockedMask;
-        }
-    public:
-        bool ShouldNotPreemptWaiters() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return !!(m_state & ShouldNotPreemptWaitersMask);
-        }
-    private:
-        void InvertShouldNotPreemptWaiters()
-        {
-            WRAPPER_NO_CONTRACT;
-            m_state ^= ShouldNotPreemptWaitersMask;
-            _ASSERTE(!ShouldNotPreemptWaiters() || HasAnyWaiters());
-        }
-        bool ShouldNonWaiterAttemptToAcquireLock() const
-        {
-            WRAPPER_NO_CONTRACT;
-            _ASSERTE(!ShouldNotPreemptWaiters() || HasAnyWaiters());
-            return !(m_state & (IsLockedMask + ShouldNotPreemptWaitersMask));
-        }
-    public:
-        bool HasAnySpinners() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return !!(m_state & SpinnerCountMask);
-        }
-    private:
-        bool TryIncrementSpinnerCount()
-        {
-            WRAPPER_NO_CONTRACT;
-            LockState newState = m_state + SpinnerCountIncrement;
-            if (newState.HasAnySpinners()) // overflow check
-            {
-                m_state = newState;
-                return true;
-            }
-            return false;
-        }
-        void DecrementSpinnerCount()
-        {
-            WRAPPER_NO_CONTRACT;
-            _ASSERTE(HasAnySpinners());
-            m_state -= SpinnerCountIncrement;
-        }
-    public:
-        bool IsWaiterSignaledToWake() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return !!(m_state & IsWaiterSignaledToWakeMask);
-        }
-    private:
-        void InvertIsWaiterSignaledToWake()
-        {
-            LIMITED_METHOD_CONTRACT;
-            m_state ^= IsWaiterSignaledToWakeMask;
-        }
-    public:
-        bool HasAnyWaiters() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return m_state >= WaiterCountIncrement;
-        }
-    private:
-        void IncrementWaiterCount()
-        {
-            LIMITED_METHOD_CONTRACT;
-            _ASSERTE(m_state + WaiterCountIncrement >= WaiterCountIncrement);
-            m_state += WaiterCountIncrement;
-        }
-        void DecrementWaiterCount()
-        {
-            WRAPPER_NO_CONTRACT;
-            _ASSERTE(HasAnyWaiters());
-            m_state -= WaiterCountIncrement;
-        }
-    private:
-        bool NeedToSignalWaiter() const
-        {
-            WRAPPER_NO_CONTRACT;
-            return HasAnyWaiters() && !(m_state & (SpinnerCountMask + IsWaiterSignaledToWakeMask));
-        }
-    private:
-        operator UINT32() const
-        {
-            LIMITED_METHOD_CONTRACT;
-            return m_state;
-        }
-        LockState &operator =(UINT32 state)
-        {
-            LIMITED_METHOD_CONTRACT;
-            m_state = state;
-            return *this;
-        }
-    public:
-        LockState VolatileLoadWithoutBarrier() const
-        {
-            WRAPPER_NO_CONTRACT;
-            return ::VolatileLoadWithoutBarrier(&m_state);
-        }
-        LockState VolatileLoad() const
-        {
-            WRAPPER_NO_CONTRACT;
-            return ::VolatileLoad(&m_state);
-        }
-    private:
-        LockState CompareExchange(LockState toState, LockState fromState)
-        {
-            LIMITED_METHOD_CONTRACT;
-#if defined(TARGET_WINDOWS) && defined(TARGET_ARM64)
-            return (UINT32)FastInterlockedCompareExchange((LONG *)&m_state, (LONG)toState, (LONG)fromState);
-#else
-            return (UINT32)InterlockedCompareExchange((LONG *)&m_state, (LONG)toState, (LONG)fromState);
-#endif
-        }
-        LockState CompareExchangeAcquire(LockState toState, LockState fromState)
-        {
-            LIMITED_METHOD_CONTRACT;
-#if defined(TARGET_WINDOWS) && defined(TARGET_ARM64)
-            return (UINT32)FastInterlockedCompareExchangeAcquire((LONG *)&m_state, (LONG)toState, (LONG)fromState);
-#else
-            return (UINT32)InterlockedCompareExchangeAcquire((LONG *)&m_state, (LONG)toState, (LONG)fromState);
-#endif
-        }
-    public:
-        bool InterlockedTryLock();
-        bool InterlockedTryLock(LockState state);
-        bool InterlockedUnlock();
-        bool InterlockedTrySetShouldNotPreemptWaitersIfNecessary(AwareLock *awareLock);
-        bool InterlockedTrySetShouldNotPreemptWaitersIfNecessary(AwareLock *awareLock, LockState state);
-        EnterHelperResult InterlockedTry_LockOrRegisterSpinner(LockState state);
-        EnterHelperResult InterlockedTry_LockAndUnregisterSpinner();
-        bool InterlockedUnregisterSpinner_TryLock();
-        bool InterlockedTryLock_Or_RegisterWaiter(AwareLock *awareLock, LockState state);
-        void InterlockedUnregisterWaiter();
-        bool InterlockedTry_LockAndUnregisterWaiterAndObserveWakeSignal(AwareLock *awareLock);
-        bool InterlockedObserveWakeSignal_Try_LockAndUnregisterWaiter(AwareLock *awareLock);
-    };
-    friend class LockState;
-private:
-    LockState m_lockState;
-    ULONG           m_Recursion;
-    PTR_Thread      m_HoldingThread;
-    LONG            m_TransientPrecious;
-    DWORD           m_dwSyncIndex;
-    CLREvent        m_SemEvent;
-    DWORD m_waiterStarvationStartTimeMs;
-    static const DWORD WaiterStarvationDurationMsBeforeStoppingPreemptingWaiters = 100;
-    AwareLock(DWORD indx)
-        : m_Recursion(0),
-#ifndef DACCESS_COMPILE
-          m_HoldingThread(NULL),
-#endif // DACCESS_COMPILE
-          m_TransientPrecious(0),
-          m_dwSyncIndex(indx),
-          m_waiterStarvationStartTimeMs(0)
-    {
-        LIMITED_METHOD_CONTRACT;
-    }
-    ~AwareLock()
-    {
-        LIMITED_METHOD_CONTRACT;
-    }
-#if defined(ENABLE_CONTRACTS_IMPL)
-    void * GetPtrForLockContract()
-    {
-        return (void *) this;
-    }
-#endif // defined(ENABLE_CONTRACTS_IMPL)
-public:
-    UINT32 GetLockState() const
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_lockState.VolatileLoadWithoutBarrier().GetState();
-    }
-    bool IsUnlockedWithNoWaiters() const
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_lockState.VolatileLoadWithoutBarrier().IsUnlockedWithNoWaiters();
-    }
-    UINT32 GetMonitorHeldStateVolatile() const
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_lockState.VolatileLoad().GetMonitorHeldState();
-    }
-    ULONG GetRecursionLevel() const
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_Recursion;
-    }
-    PTR_Thread GetHoldingThread() const
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_HoldingThread;
-    }
-private:
-    void ResetWaiterStarvationStartTime();
-    void RecordWaiterStarvationStartTime();
-    bool ShouldStopPreemptingWaiters() const;
-private: // friend access is required for this unsafe function
-    void InitializeToLockedWithNoWaiters(ULONG recursionLevel, PTR_Thread holdingThread)
-    {
-        WRAPPER_NO_CONTRACT;
-        m_lockState.InitializeToLockedWithNoWaiters();
-        m_Recursion = recursionLevel;
-        m_HoldingThread = holdingThread;
-    }
-public:
-    static void SpinWait(const YieldProcessorNormalizationInfo &normalizationInfo, DWORD spinIteration);
-    bool TryEnterHelper(Thread* pCurThread);
-    EnterHelperResult TryEnterBeforeSpinLoopHelper(Thread *pCurThread);
-    EnterHelperResult TryEnterInsideSpinLoopHelper(Thread *pCurThread);
-    bool TryEnterAfterSpinLoopHelper(Thread *pCurThread);
-    AwareLock::LeaveHelperAction LeaveHelper(Thread* pCurThread);
-    void    Enter();
-    BOOL    TryEnter(INT32 timeOut = 0);
-    BOOL    EnterEpilog(Thread *pCurThread, INT32 timeOut = INFINITE);
-    BOOL    EnterEpilogHelper(Thread *pCurThread, INT32 timeOut);
-    BOOL    Leave();
-    void    Signal()
-    {
-        WRAPPER_NO_CONTRACT;
-        m_SemEvent.SetMonitorEvent();
-        m_lockState.InterlockedTrySetShouldNotPreemptWaitersIfNecessary(this);
-    }
-    void    AllocLockSemEvent();
-    LONG    LeaveCompletely();
-    BOOL    OwnedByCurrentThread();
-    void    IncrementTransientPrecious()
-    {
-        LIMITED_METHOD_CONTRACT;
-        InterlockedIncrement(&m_TransientPrecious);
-        _ASSERTE(m_TransientPrecious > 0);
-    }
-    void    DecrementTransientPrecious()
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE(m_TransientPrecious > 0);
-        InterlockedDecrement(&m_TransientPrecious);
-    }
-    DWORD GetSyncBlockIndex();
-    void SetPrecious();
-    inline OBJECTREF GetOwningObject();
-    inline PTR_Thread GetOwningThread()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_HoldingThread;
-    }
-};
-#ifdef FEATURE_COMINTEROP
-class ComCallWrapper;
-class ComClassFactory;
-struct RCW;
-class RCWHolder;
-typedef DPTR(class ComCallWrapper)        PTR_ComCallWrapper;
-#include "shash.h"
-#endif // FEATURE_COMINTEROP
-using ManagedObjectComWrapperByIdMap = MapSHash<INT64, void*>;
-class InteropSyncBlockInfo
-{
-    friend class RCWHolder;
-    friend class ClrDataAccess;
-public:
-#ifndef TARGET_UNIX
-    static SLIST_HEADER s_InteropInfoStandbyList;
-#endif // !TARGET_UNIX
-    InteropSyncBlockInfo()
-    {
-        LIMITED_METHOD_CONTRACT;
-        ZeroMemory(this, sizeof(InteropSyncBlockInfo));
-#if defined(FEATURE_COMWRAPPERS)
-        m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
-#endif // FEATURE_COMWRAPPERS
-    }
-#ifndef DACCESS_COMPILE
-    ~InteropSyncBlockInfo();
-#endif
-#ifndef TARGET_UNIX
-    static void FlushStandbyList();
-#endif // !TARGET_UNIX
-#ifdef FEATURE_COMINTEROP
-#ifndef DACCESS_COMPILE
-    RCW* GetRawRCW()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return (RCW *)((size_t)m_pRCW & ~1);
-    }
-    RCW* GetRCWAndIncrementUseCount();
-    void SetRawRCW(RCW* pRCW);
-    bool RCWWasUsed()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return (m_pRCW != NULL);
-    }
-#else // !DACCESS_COMPILE
-    TADDR DacGetRawRCW()
-    {
-        return (TADDR)((size_t)m_pRCW & ~1);
-    }
-#endif // DACCESS_COMPILE
-#ifndef DACCESS_COMPILE
-    void SetCCW(ComCallWrapper* pCCW)
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (pCCW == NULL)
-            pCCW = (ComCallWrapper*) 0x1;
-        m_pCCW = pCCW;
-    }
-#endif // !DACCESS_COMPILE
-    PTR_ComCallWrapper GetCCW()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        if (m_pCCW == (PTR_ComCallWrapper)0x1)
-            return NULL;
-        return m_pCCW;
-    }
-    bool CCWWasUsed()
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (m_pCCW == NULL)
-            return false;
-        return true;
-    }
-#ifdef FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
-    void SetComClassFactory(ComClassFactory* pCCF)
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (pCCF == NULL)
-            pCCF = (ComClassFactory*)0x1;
-        m_pCCF = pCCF;
-    }
-    ComClassFactory* GetComClassFactory()
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (m_pCCF == (ComClassFactory*)0x1)
-            return NULL;
-        return m_pCCF;
-    }
-    bool CCFWasUsed()
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (m_pCCF == NULL)
-            return false;
-        return true;
-    }
-#endif // FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
-#endif // FEATURE_COMINTEROP
-#if !defined(DACCESS_COMPILE)
-    bool SetUMEntryThunk(void* pUMEntryThunk)
-    {
-        WRAPPER_NO_CONTRACT;
-        return (InterlockedCompareExchangeT(&m_pUMEntryThunk,
-                                                    pUMEntryThunk,
-                                                    NULL) == NULL);
-    }
-    void FreeUMEntryThunk();
-#endif // DACCESS_COMPILE
-    void* GetUMEntryThunk()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_pUMEntryThunk;
-    }
-private:
-    void*               m_pUMEntryThunk;
-#ifdef FEATURE_COMINTEROP
-    PTR_ComCallWrapper  m_pCCW;
-#ifdef FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
-    ComClassFactory*    m_pCCF;
-#endif // FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
-public:
-#ifndef DACCESS_COMPILE
-    RCW*                m_pRCW;
-#else
-    TADDR               m_pRCW;
-#endif
-#endif // FEATURE_COMINTEROP
-#if defined(FEATURE_COMWRAPPERS)
-public:
-    bool TryGetManagedObjectComWrapper(_In_ INT64 wrapperId, _Out_ void** mocw)
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        *mocw = NULL;
-        if (m_managedObjectComWrapperMap == NULL)
-            return false;
-        CrstHolder lock(&m_managedObjectComWrapperLock);
-        return m_managedObjectComWrapperMap->Lookup(wrapperId, mocw);
-    }
-#ifndef DACCESS_COMPILE
-    bool TrySetManagedObjectComWrapper(_In_ INT64 wrapperId, _In_ void* mocw, _In_ void* curr = NULL)
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (m_managedObjectComWrapperMap == NULL)
-        {
-            NewHolder<ManagedObjectComWrapperByIdMap> map = new ManagedObjectComWrapperByIdMap();
-            if (InterlockedCompareExchangeT((ManagedObjectComWrapperByIdMap**)&m_managedObjectComWrapperMap, (ManagedObjectComWrapperByIdMap *)map, NULL) == NULL)
-            {
-                map.SuppressRelease();
-            }
-            _ASSERTE(m_managedObjectComWrapperMap != NULL);
-        }
-        CrstHolder lock(&m_managedObjectComWrapperLock);
-        if (m_managedObjectComWrapperMap->LookupPtr(wrapperId) != curr)
-            return false;
-        m_managedObjectComWrapperMap->Add(wrapperId, mocw);
-        return true;
-    }
-    using ClearWrappersCallback = void(void* mocw);
-    void ClearManagedObjectComWrappers(ClearWrappersCallback* callback)
-    {
-        LIMITED_METHOD_CONTRACT;
-        if (m_managedObjectComWrapperMap == NULL)
-            return;
-        CQuickArrayList<void*> localList;
-        {
-            CrstHolder lock(&m_managedObjectComWrapperLock);
-            if (callback != NULL)
-            {
-                ManagedObjectComWrapperByIdMap::Iterator iter = m_managedObjectComWrapperMap->Begin();
-                while (iter != m_managedObjectComWrapperMap->End())
-                {
-                    localList.Push(iter->Value());
-                    ++iter;
-                }
-            }
-            m_managedObjectComWrapperMap->RemoveAll();
-        }
-        for (SIZE_T i = 0; i < localList.Size(); i++)
-            callback(localList[i]);
-    }
-    using EnumWrappersCallback = bool(void* mocw, void* cxt);
-    void EnumManagedObjectComWrappers(EnumWrappersCallback* callback, void* cxt)
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE(callback != NULL);
-        if (m_managedObjectComWrapperMap == NULL)
-            return;
-        CrstHolder lock(&m_managedObjectComWrapperLock);
-        ManagedObjectComWrapperByIdMap::Iterator iter = m_managedObjectComWrapperMap->Begin();
-        while (iter != m_managedObjectComWrapperMap->End())
-        {
-            if (!callback(iter->Value(), cxt))
-                break;
-            ++iter;
-        }
-    }
-#endif // !DACCESS_COMPILE
-    bool TryGetExternalComObjectContext(_Out_ void** eoc)
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        *eoc = m_externalComObjectContext;
-        return (*eoc != NULL);
-    }
-#ifndef DACCESS_COMPILE
-    bool TrySetExternalComObjectContext(_In_ void* eoc, _In_ void* curr = NULL)
-    {
-        LIMITED_METHOD_CONTRACT;
-        return (InterlockedCompareExchangeT(
-                        &m_externalComObjectContext,
-                        eoc,
-                        curr) == curr);
-    }
-#endif // !DACCESS_COMPILE
-private:
-    void* m_externalComObjectContext;
-    CrstExplicitInit m_managedObjectComWrapperLock;
-    NewHolder<ManagedObjectComWrapperByIdMap> m_managedObjectComWrapperMap;
-#endif // FEATURE_COMWRAPPERS
-#ifdef FEATURE_OBJCMARSHAL
-public:
-#ifndef DACCESS_COMPILE
-    PTR_VOID AllocTaggedMemory(_Out_ size_t* memoryInSizeT)
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE(memoryInSizeT != NULL);
-        *memoryInSizeT = GetTaggedMemorySizeInBytes() / sizeof(SIZE_T);
-        m_taggedMemory = m_taggedAlloc;
-        return m_taggedMemory;
-    }
-#endif // !DACCESS_COMPILE
-    PTR_VOID GetTaggedMemory()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_taggedMemory;
-    }
-    size_t GetTaggedMemorySizeInBytes()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return ARRAY_SIZE(m_taggedAlloc);
-    }
-private:
-    PTR_VOID m_taggedMemory;
-    BYTE m_taggedAlloc[2 * sizeof(void*)];
-#endif // FEATURE_OBJCMARSHAL
-};
-typedef DPTR(InteropSyncBlockInfo) PTR_InteropSyncBlockInfo;
-typedef DPTR(SyncBlock) PTR_SyncBlock;
-class SyncBlock
-{
-    friend class ObjHeader;
-    friend class SyncBlockCache;
-    friend struct ThreadQueue;
-#ifdef DACCESS_COMPILE
-    friend class ClrDataAccess;
-#endif
-    friend class CheckAsmOffsets;
-  protected:
-    AwareLock  m_Monitor;                    // the actual monitor
-  public:
-    PTR_InteropSyncBlockInfo    m_pInteropInfo;
-  protected:
-#ifdef EnC_SUPPORTED
-    PTR_EnCSyncBlockInfo m_pEnCInfo;
-#endif // EnC_SUPPORTED
-    SLink       m_Link;
-    DWORD m_dwHashCode;
-    WCHAR m_BSTRTrailByte;
-  public:
-    SyncBlock(DWORD indx)
-        : m_Monitor(indx)
-#ifdef EnC_SUPPORTED
-        , m_pEnCInfo(PTR_NULL)
-#endif // EnC_SUPPORTED
-        , m_dwHashCode(0)
-        , m_BSTRTrailByte(0)
-    {
-        LIMITED_METHOD_CONTRACT;
-        m_pInteropInfo = NULL;
-        _ASSERTE((((size_t) &m_Monitor) & 3) == 0);
-    }
-    DWORD GetSyncBlockIndex()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_Monitor.GetSyncBlockIndex();
-    }
-   void SetPrecious()
-   {
-       WRAPPER_NO_CONTRACT;
-       m_Monitor.SetPrecious();
-   }
-   BOOL IsPrecious()
-   {
-       LIMITED_METHOD_CONTRACT;
-       return (m_Monitor.m_dwSyncIndex & SyncBlockPrecious) != 0;
-   }
-    BOOL IsIDisposable()
-    {
-        WRAPPER_NO_CONTRACT;
-        return (!IsPrecious() &&
-                m_Monitor.IsUnlockedWithNoWaiters() &&
-                m_Monitor.m_TransientPrecious == 0);
-    }
-    InteropSyncBlockInfo* GetInteropInfo()
-    {
-        CONTRACT (InteropSyncBlockInfo*)
-        {
-            THROWS;
-            GC_TRIGGERS;
-            MODE_ANY;
-            POSTCONDITION(CheckPointer(RETVAL));
-        }
-        CONTRACT_END;
-        if (!m_pInteropInfo)
-        {
-            NewHolder<InteropSyncBlockInfo> pInteropInfo;
-#ifndef TARGET_UNIX
-            pInteropInfo = (InteropSyncBlockInfo *)InterlockedPopEntrySList(&InteropSyncBlockInfo::s_InteropInfoStandbyList);
-            if (pInteropInfo != NULL)
-            {
-                new (pInteropInfo) InteropSyncBlockInfo();
-            }
-            else
-#endif // !TARGET_UNIX
-            {
-                pInteropInfo = new InteropSyncBlockInfo();
-            }
-            if (SetInteropInfo(pInteropInfo))
-                pInteropInfo.SuppressRelease();
-        }
-        RETURN m_pInteropInfo;
-    }
-    PTR_InteropSyncBlockInfo GetInteropInfoNoCreate()
-    {
-        CONTRACT (PTR_InteropSyncBlockInfo)
-        {
-            NOTHROW;
-            GC_NOTRIGGER;
-            MODE_ANY;
-            SUPPORTS_DAC;
-            POSTCONDITION(CheckPointer(RETVAL, NULL_OK));
-        }
-        CONTRACT_END;
-        RETURN m_pInteropInfo;
-    }
-    bool SetInteropInfo(InteropSyncBlockInfo* pInteropInfo);
-#ifdef EnC_SUPPORTED
-    PTR_EnCSyncBlockInfo GetEnCInfo()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        return m_pEnCInfo;
-    }
-    void SetEnCInfo(EnCSyncBlockInfo *pEnCInfo);
-#endif // EnC_SUPPORTED
-    DWORD GetHashCode()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_dwHashCode;
-    }
-    DWORD SetHashCode(DWORD hashCode)
-    {
-        WRAPPER_NO_CONTRACT;
-        DWORD result = InterlockedCompareExchange((LONG*)&m_dwHashCode, hashCode, 0);
-        if (result == 0)
-        {
-            SetPrecious();
-            return hashCode;
-        }
-        else
-            return result;
-    }
-    void *operator new (size_t sz, void* p)
-    {
-        LIMITED_METHOD_CONTRACT;
-        return p ;
-    }
-    void operator delete(void *p)
-    {
-        LIMITED_METHOD_CONTRACT;
-    }
-    void EnterMonitor()
-    {
-        WRAPPER_NO_CONTRACT;
-        m_Monitor.Enter();
-    }
-    BOOL TryEnterMonitor(INT32 timeOut = 0)
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_Monitor.TryEnter(timeOut);
-    }
-    BOOL LeaveMonitor()
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_Monitor.Leave();
-    }
-    AwareLock* GetMonitor()
-    {
-        WRAPPER_NO_CONTRACT;
-        SUPPORTS_DAC;
-#ifndef DACCESS_COMPILE
-        SetPrecious();
-#endif
-        return &m_Monitor;
-    }
-    AwareLock* QuickGetMonitor()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return &m_Monitor;
-    }
-    BOOL DoesCurrentThreadOwnMonitor()
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_Monitor.OwnedByCurrentThread();
-    }
-    LONG LeaveMonitorCompletely()
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_Monitor.LeaveCompletely();
-    }
-    BOOL Wait(INT32 timeOut);
-    void Pulse();
-    void PulseAll();
-    enum
-    {
-        SyncBlockPrecious   = 0x80000000,
-    };
-    BOOL HasCOMBstrTrailByte()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return (m_BSTRTrailByte!=0);
-    }
-    WCHAR GetCOMBstrTrailByte()
-    {
-        return m_BSTRTrailByte;
-    }
-    void SetCOMBstrTrailByte(WCHAR trailByte)
-    {
-        WRAPPER_NO_CONTRACT;
-        m_BSTRTrailByte = trailByte;
-        SetPrecious();
-    }
-  protected:
-    void InitState(ULONG recursionLevel, PTR_Thread holdingThread)
-    {
-        WRAPPER_NO_CONTRACT;
-        m_Monitor.InitializeToLockedWithNoWaiters(recursionLevel, holdingThread);
-    }
-#if defined(ENABLE_CONTRACTS_IMPL)
-    void * GetPtrForLockContract()
-    {
-        return m_Monitor.GetPtrForLockContract();
-    }
-#endif // defined(ENABLE_CONTRACTS_IMPL)
-};
-class SyncTableEntry
-{
-  public:
-    PTR_SyncBlock    m_SyncBlock;
-    VolatilePtr<Object, PTR_Object> m_Object;
-    static PTR_SyncTableEntry GetSyncTableEntry();
-#ifndef DACCESS_COMPILE
-    static SyncTableEntry*& GetSyncTableEntryByRef();
-#endif
-};
-#ifdef _DEBUG
-extern void DumpSyncBlockCache();
-#endif
-typedef DPTR(SyncBlockCache) PTR_SyncBlockCache;
-class SyncBlockCache
-{
-#ifdef DACCESS_COMPILE
-    friend class ClrDataAccess;
-#endif
-    friend class SyncBlock;
-  private:
-    PTR_SLink   m_pCleanupBlockList;    // list of sync blocks that need cleanup
-    SLink*      m_FreeBlockList;        // list of free sync blocks
-    Crst        m_CacheLock;            // cache lock
-    DWORD       m_FreeCount;            // count of active sync blocks
-    DWORD       m_ActiveCount;          // number active
-    SyncBlockArray *m_SyncBlocks;       // Array of new SyncBlocks.
-    DWORD       m_FreeSyncBlock;        // Next Free Syncblock in the array
-    DWORD       m_FreeSyncTableIndex;   // We allocate a large array of SyncTableEntry structures.
-    size_t      m_FreeSyncTableList;    // index of the first free SyncTableEntry in our free list.
-    DWORD       m_SyncTableSize;
-    SyncTableEntry *m_OldSyncTables;    // Next old SyncTable
-    BOOL        m_bSyncBlockCleanupInProgress;  // A flag indicating if sync block cleanup is in progress.
-    DWORD*      m_EphemeralBitmap;      // card table for ephemeral scanning
-    BOOL        GCWeakPtrScanElement(int elindex, HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2, BOOL& cleanup);
-    void SetCard (size_t card);
-    void ClearCard (size_t card);
-    BOOL CardSetP (size_t card);
-    void CardTableSetBit (size_t idx);
-    void Grow();
-  public:
-    SPTR_DECL(SyncBlockCache, s_pSyncBlockCache);
-    static SyncBlockCache*& GetSyncBlockCache();
-    void *operator new(size_t size, void *pInPlace)
-    {
-        LIMITED_METHOD_CONTRACT;
-        return pInPlace;
-    }
-    void operator delete(void *p)
-    {
-        LIMITED_METHOD_CONTRACT;
-    }
-    SyncBlockCache();
-    ~SyncBlockCache();
-    static void Attach();
-    static void Detach();
-    void DoDetach();
-    static void Start();
-    static void Stop();
-    SyncBlock* GetNextFreeSyncBlock();
-    SyncBlock* GetNextCleanupSyncBlock();
-    void    InsertCleanupSyncBlock(SyncBlock* psb);
-    DWORD   NewSyncBlockSlot(Object *obj);
-    void    DeleteSyncBlock(SyncBlock *sb);
-    void    DeleteSyncBlockMemory(SyncBlock *sb);
-    void    GCDeleteSyncBlock(SyncBlock *sb);
-    void    GCWeakPtrScan(HANDLESCANPROC scanProc, uintptr_t lp1, uintptr_t lp2);
-    void    GCDone(BOOL demoting, int max_gen);
-    void    CleanupSyncBlocks();
-    int GetTableEntryCount()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_FreeSyncTableIndex - 1;
-    }
-    BOOL    IsSyncBlockCleanupInProgress()
-    {
-        LIMITED_METHOD_CONTRACT;
-        return m_bSyncBlockCleanupInProgress;
-    }
-    DWORD GetActiveCount()
-    {
-        return m_ActiveCount;
-    }
-    class LockHolder : public CrstHolder
-    {
-    public:
-        LockHolder(SyncBlockCache *pCache)
-            : CrstHolder(&pCache->m_CacheLock)
-        {
-            CONTRACTL
-            {
-                NOTHROW;
-                GC_NOTRIGGER;
-                MODE_ANY;
-                CAN_TAKE_LOCK;
-            }
-            CONTRACTL_END;
-        }
-    };
-    friend class LockHolder;
-#ifdef _DEBUG
-    friend void DumpSyncBlockCache();
-#endif
-#ifdef VERIFY_HEAP
-    void    VerifySyncTableEntry();
-#endif
-};
-class ObjHeader
-{
-    friend class CheckAsmOffsets;
-  private:
-#ifdef HOST_64BIT
-    DWORD    m_alignpad;
-#endif // HOST_64BIT
-    Volatile<DWORD> m_SyncBlockValue;      // the Index and the Bits
-#if defined(HOST_64BIT) && defined(_DEBUG)
-    void IllegalAlignPad();
-#endif // HOST_64BIT && _DEBUG
-    INCONTRACT(void * GetPtrForLockContract());
-  public:
-    FORCEINLINE DWORD GetHeaderSyncBlockIndex()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-#if defined(HOST_64BIT) && defined(_DEBUG) && !defined(DACCESS_COMPILE)
-        if (m_alignpad != 0)
-            IllegalAlignPad();
-#endif // HOST_64BIT && _DEBUG && !DACCESS_COMPILE
-        DWORD value = m_SyncBlockValue.LoadWithoutBarrier();
-        if ((value & (BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE)) != BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX)
-            return 0;
-        return value & MASK_SYNCBLOCKINDEX;
-    }
-    void SetIndex(DWORD indx)
-    {
-        CONTRACTL
-        {
-            INSTANCE_CHECK;
-            NOTHROW;
-            GC_NOTRIGGER;
-            FORBID_FAULT;
-            MODE_ANY;
-            PRECONDITION(GetHeaderSyncBlockIndex() == 0);
-            PRECONDITION(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
-        }
-        CONTRACTL_END
-        LONG newValue;
-        LONG oldValue;
-        while (TRUE) {
-            oldValue = m_SyncBlockValue.LoadWithoutBarrier();
-            _ASSERTE(GetHeaderSyncBlockIndex() == 0);
-            newValue = (indx |
-                (oldValue & ~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX)));
-            if (InterlockedCompareExchange((LONG*)&m_SyncBlockValue,
-                                             newValue,
-                                             oldValue)
-                == oldValue)
-            {
-                return;
-            }
-        }
-    }
-    void ResetIndex()
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
-        InterlockedAnd((LONG*)&m_SyncBlockValue, ~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX));
-    }
-    void GCResetIndex()
-    {
-        LIMITED_METHOD_CONTRACT;
-        m_SyncBlockValue.RawValue() &=~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX);
-    }
-    void SetBit(DWORD bit)
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
-        InterlockedOr((LONG*)&m_SyncBlockValue, bit);
-    }
-    void ClrBit(DWORD bit)
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
-        InterlockedAnd((LONG*)&m_SyncBlockValue, ~bit);
-    }
-    void SetGCBit()
-    {
-        LIMITED_METHOD_CONTRACT;
-        m_SyncBlockValue.RawValue() |= BIT_SBLK_GC_RESERVE;
-    }
-    void ClrGCBit()
-    {
-        LIMITED_METHOD_CONTRACT;
-        m_SyncBlockValue.RawValue() &= ~BIT_SBLK_GC_RESERVE;
-    }
-    DWORD GetBits()
-    {
-        LIMITED_METHOD_CONTRACT;
-        SUPPORTS_DAC;
-#if defined(HOST_64BIT) && defined(_DEBUG) && !defined(DACCESS_COMPILE)
-        if (m_alignpad != 0)
-            IllegalAlignPad();
-#endif // HOST_64BIT && _DEBUG && !DACCESS_COMPILE
-        return m_SyncBlockValue.LoadWithoutBarrier();
-    }
-    DWORD SetBits(DWORD newBits, DWORD oldBits)
-    {
-        LIMITED_METHOD_CONTRACT;
-        _ASSERTE((oldBits & BIT_SBLK_SPIN_LOCK) == 0);
-        DWORD result = InterlockedCompareExchange((LONG*)&m_SyncBlockValue, newBits, oldBits);
-        return result;
-    }
-#ifdef _DEBUG
-    BOOL HasEmptySyncBlockInfo()
-    {
-        WRAPPER_NO_CONTRACT;
-        return m_SyncBlockValue.LoadWithoutBarrier() == 0;
-    }
-#endif
-    BOOL HasSyncBlockIndex()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        return (GetHeaderSyncBlockIndex() != 0);
-    }
-    SyncBlock *GetSyncBlock();
-    PTR_SyncBlock PassiveGetSyncBlock()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        return g_pSyncTable [(int)GetHeaderSyncBlockIndex()].m_SyncBlock;
-    }
-    DWORD GetSyncBlockIndex();
-    void EnterObjMonitor();
-    BOOL TryEnterObjMonitor(INT32 timeOut = 0);
-    AwareLock::EnterHelperResult EnterObjMonitorHelper(Thread* pCurThread);
-    AwareLock::EnterHelperResult EnterObjMonitorHelperSpin(Thread* pCurThread);
-    BOOL LeaveObjMonitor();
-    BOOL LeaveObjMonitorAtException();
-    AwareLock::LeaveHelperAction LeaveObjMonitorHelper(Thread* pCurThread);
-    BOOL GetThreadOwningMonitorLock(DWORD *pThreadId, DWORD *pAcquisitionCount);
-    PTR_Object GetBaseObject()
-    {
-        LIMITED_METHOD_DAC_CONTRACT;
-        return dac_cast<PTR_Object>(dac_cast<TADDR>(this + 1));
-    }
-    BOOL Wait(INT32 timeOut);
-    void Pulse();
-    void PulseAll();
-    void EnterSpinLock();
-    void ReleaseSpinLock();
-    BOOL Validate (BOOL bVerifySyncBlkIndex = TRUE);
-};
-typedef DPTR(class ObjHeader) PTR_ObjHeader;
-#define ENTER_SPIN_LOCK(pOh)        \
-    pOh->EnterSpinLock();
-#define LEAVE_SPIN_LOCK(pOh)        \
-    pOh->ReleaseSpinLock();
-#ifdef DACCESS_COMPILE
-typedef void (*FP_TQ_THREAD_ENUMERATION_CALLBACK)(PTR_Thread pThread, VOID* pUserData);
-#endif
-struct ThreadQueue
-{
-    static PTR_WaitEventLink WaitEventLinkForLink(PTR_SLink pLink);
-    static WaitEventLink *DequeueThread(SyncBlock *psb);
-    static void          EnqueueThread(WaitEventLink *pWaitEventLink, SyncBlock *psb);
-    static BOOL          RemoveThread (Thread *pThread, SyncBlock *psb);
-#ifdef DACCESS_COMPILE
-    static void          EnumerateThreads(SyncBlock *psb,
-                                          FP_TQ_THREAD_ENUMERATION_CALLBACK pCallbackFunction,
-                                          void* pUserData);
-#endif
-};
-inline void AwareLock::SetPrecious()
-{
-    LIMITED_METHOD_CONTRACT;
-    m_dwSyncIndex |= SyncBlock::SyncBlockPrecious;
-}
-inline DWORD AwareLock::GetSyncBlockIndex()
-{
-    LIMITED_METHOD_CONTRACT;
-    return (m_dwSyncIndex & ~SyncBlock::SyncBlockPrecious);
-}
-#ifdef TARGET_X86
-#include <poppack.h>
-#endif // TARGET_X86
-#endif // _SYNCBLK_H_

--- a/src/libraries/Common/src/System/Net/Http/X509ResourceClient.cs
+++ b//dev/null
@@ -1,251 +0,0 @@
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.IO;
-using System.Reflection;
-using System.Threading;
-using System.Threading.Tasks;
-namespace System.Net.Http
-{
-    internal static partial class X509ResourceClient
-    {
-        private const long DefaultAiaDownloadLimit = 100 * 1024 * 1024;
-        private static long AiaDownloadLimit { get; } = GetValue("System.Security.Cryptography.AiaDownloadLimit", DefaultAiaDownloadLimit);
-        private static readonly Func<string, CancellationToken, bool, ValueTask<byte[]?>>? s_downloadBytes = CreateDownloadBytesFunc();
-        static partial void ReportNoClient();
-        static partial void ReportNegativeTimeout();
-        static partial void ReportDownloadStart(long totalMillis, string uri);
-        static partial void ReportDownloadStop(int bytesDownloaded);
-        static partial void ReportRedirectsExceeded();
-        static partial void ReportRedirected(Uri newUri);
-        static partial void ReportRedirectNotFollowed(Uri redirectUri);
-        internal static byte[]? DownloadAsset(string uri, TimeSpan downloadTimeout)
-        {
-            ValueTask<byte[]?> task = DownloadAssetCore(uri, downloadTimeout, async: false);
-            Debug.Assert(task.IsCompletedSuccessfully);
-            return task.Result;
-        }
-        internal static Task<byte[]?> DownloadAssetAsync(string uri, TimeSpan downloadTimeout)
-        {
-            ValueTask<byte[]?> task = DownloadAssetCore(uri, downloadTimeout, async: true);
-            return task.AsTask();
-        }
-        private static async ValueTask<byte[]?> DownloadAssetCore(string uri, TimeSpan downloadTimeout, bool async)
-        {
-            if (s_downloadBytes is null)
-            {
-                ReportNoClient();
-                return null;
-            }
-            if (downloadTimeout <= TimeSpan.Zero)
-            {
-                ReportNegativeTimeout();
-                return null;
-            }
-            long totalMillis = (long)downloadTimeout.TotalMilliseconds;
-            ReportDownloadStart(totalMillis, uri);
-            CancellationTokenSource? cts = totalMillis > int.MaxValue ? null : new CancellationTokenSource((int)totalMillis);
-            byte[]? ret = null;
-            try
-            {
-                ret = await s_downloadBytes(uri, cts?.Token ?? default, async).ConfigureAwait(false);
-                return ret;
-            }
-            catch { }
-            finally
-            {
-                cts?.Dispose();
-                ReportDownloadStop(ret?.Length ?? 0);
-            }
-            return null;
-        }
-        private static Func<string, CancellationToken, bool, ValueTask<byte[]?>>? CreateDownloadBytesFunc()
-        {
-            try
-            {
-                Type? socketsHttpHandlerType = Type.GetType("System.Net.Http.SocketsHttpHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpMessageHandlerType = Type.GetType("System.Net.Http.HttpMessageHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpClientType = Type.GetType("System.Net.Http.HttpClient, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpRequestMessageType = Type.GetType("System.Net.Http.HttpRequestMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpResponseMessageType = Type.GetType("System.Net.Http.HttpResponseMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpResponseHeadersType = Type.GetType("System.Net.Http.Headers.HttpResponseHeaders, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                Type? httpContentType = Type.GetType("System.Net.Http.HttpContent, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
-                if (socketsHttpHandlerType == null || httpMessageHandlerType == null || httpClientType == null || httpRequestMessageType == null ||
-                    httpResponseMessageType == null || httpResponseHeadersType == null || httpContentType == null)
-                {
-                    Debug.Fail("Unable to load required type.");
-                    return null;
-                }
-                [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
-                   Justification = "The type HttpResponseMessage is a reference type")]
-                [return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
-                static Type GetTaskOfHttpResponseMessageType([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type? httpResponseMessageType) => typeof(Task<>).MakeGenericType(httpResponseMessageType!);
-                Type taskOfHttpResponseMessageType = GetTaskOfHttpResponseMessageType(httpResponseMessageType);
-                ConstructorInfo? socketsHttpHandlerCtor = socketsHttpHandlerType.GetConstructor(Type.EmptyTypes);
-                PropertyInfo? pooledConnectionIdleTimeoutProp = socketsHttpHandlerType.GetProperty("PooledConnectionIdleTimeout");
-                PropertyInfo? allowAutoRedirectProp = socketsHttpHandlerType.GetProperty("AllowAutoRedirect");
-                ConstructorInfo? httpClientCtor = httpClientType.GetConstructor(new Type[] { httpMessageHandlerType });
-                PropertyInfo? requestUriProp = httpRequestMessageType.GetProperty("RequestUri");
-                ConstructorInfo? httpRequestMessageCtor = httpRequestMessageType.GetConstructor(Type.EmptyTypes);
-                MethodInfo? sendMethod = httpClientType.GetMethod("Send", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
-                MethodInfo? sendAsyncMethod = httpClientType.GetMethod("SendAsync", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
-                PropertyInfo? maxResponseContentBufferSizeProp = httpClientType.GetProperty("MaxResponseContentBufferSize");
-                PropertyInfo? responseContentProp = httpResponseMessageType.GetProperty("Content");
-                PropertyInfo? responseStatusCodeProp = httpResponseMessageType.GetProperty("StatusCode");
-                PropertyInfo? responseHeadersProp = httpResponseMessageType.GetProperty("Headers");
-                PropertyInfo? responseHeadersLocationProp = httpResponseHeadersType.GetProperty("Location");
-                MethodInfo? readAsStreamMethod = httpContentType.GetMethod("ReadAsStream", Type.EmptyTypes);
-                PropertyInfo? taskOfHttpResponseMessageResultProp = taskOfHttpResponseMessageType.GetProperty("Result");
-                if (socketsHttpHandlerCtor == null || pooledConnectionIdleTimeoutProp == null ||
-                    allowAutoRedirectProp == null || httpClientCtor == null ||
-                    requestUriProp == null || httpRequestMessageCtor == null ||
-                    sendMethod == null || sendAsyncMethod == null || maxResponseContentBufferSizeProp == null ||
-                    responseContentProp == null || responseStatusCodeProp == null ||
-                    responseHeadersProp == null || responseHeadersLocationProp == null ||
-                    readAsStreamMethod == null || taskOfHttpResponseMessageResultProp == null)
-                {
-                    Debug.Fail("Unable to load required members.");
-                    return null;
-                }
-                const int PooledConnectionIdleTimeoutSeconds = 15;
-                const int MaxRedirections = 10;
-                object? socketsHttpHandler = socketsHttpHandlerCtor.Invoke(null);
-                pooledConnectionIdleTimeoutProp.SetValue(socketsHttpHandler, TimeSpan.FromSeconds(PooledConnectionIdleTimeoutSeconds));
-                allowAutoRedirectProp.SetValue(socketsHttpHandler, false);
-                object? httpClient = httpClientCtor.Invoke(new object?[] { socketsHttpHandler });
-                maxResponseContentBufferSizeProp.SetValue(httpClient, AiaDownloadLimit);
-                return async (string uriString, CancellationToken cancellationToken, bool async) =>
-                {
-                    Uri uri = new Uri(uriString);
-                    if (!IsAllowedScheme(uri.Scheme))
-                    {
-                        return null;
-                    }
-                    object requestMessage = httpRequestMessageCtor.Invoke(null);
-                    requestUriProp.SetValue(requestMessage, uri);
-                    object responseMessage;
-                    if (async)
-                    {
-                        Task sendTask = (Task)sendAsyncMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                        await sendTask.ConfigureAwait(false);
-                        responseMessage = taskOfHttpResponseMessageResultProp.GetValue(sendTask)!;
-                    }
-                    else
-                    {
-                        responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                    }
-                    int redirections = 0;
-                    Uri? redirectUri;
-                    bool hasRedirect;
-                    while (true)
-                    {
-                        int statusCode = (int)responseStatusCodeProp.GetValue(responseMessage)!;
-                        object responseHeaders = responseHeadersProp.GetValue(responseMessage)!;
-                        Uri? location = (Uri?)responseHeadersLocationProp.GetValue(responseHeaders);
-                        redirectUri = GetUriForRedirect((Uri)requestUriProp.GetValue(requestMessage)!, statusCode, location, out hasRedirect);
-                        if (redirectUri == null)
-                        {
-                            break;
-                        }
-                        ((IDisposable)responseMessage).Dispose();
-                        redirections++;
-                        if (redirections > MaxRedirections)
-                        {
-                            ReportRedirectsExceeded();
-                            return null;
-                        }
-                        ReportRedirected(redirectUri);
-                        requestMessage = httpRequestMessageCtor.Invoke(null);
-                        requestUriProp.SetValue(requestMessage, redirectUri);
-                        if (async)
-                        {
-                            Task sendTask = (Task)sendAsyncMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                            await sendTask.ConfigureAwait(false);
-                            responseMessage = taskOfHttpResponseMessageResultProp.GetValue(sendTask)!;
-                        }
-                        else
-                        {
-                            responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
-                        }
-                    }
-                    if (hasRedirect && redirectUri == null)
-                    {
-                        return null;
-                    }
-                    object content = responseContentProp.GetValue(responseMessage)!;
-                    using Stream responseStream = (Stream)readAsStreamMethod.Invoke(content, null)!;
-                    var result = new MemoryStream();
-                    if (async)
-                    {
-                        await responseStream.CopyToAsync(result).ConfigureAwait(false);
-                    }
-                    else
-                    {
-                        responseStream.CopyTo(result);
-                    }
-                    ((IDisposable)responseMessage).Dispose();
-                    return result.ToArray();
-                };
-            }
-            catch
-            {
-                return null;
-            }
-        }
-        private static Uri? GetUriForRedirect(Uri requestUri, int statusCode, Uri? location, out bool hasRedirect)
-        {
-            if (!IsRedirectStatusCode(statusCode))
-            {
-                hasRedirect = false;
-                return null;
-            }
-            hasRedirect = true;
-            if (location == null)
-            {
-                return null;
-            }
-            if (!location.IsAbsoluteUri)
-            {
-                location = new Uri(requestUri, location);
-            }
-            string requestFragment = requestUri.Fragment;
-            if (!string.IsNullOrEmpty(requestFragment))
-            {
-                string redirectFragment = location.Fragment;
-                if (string.IsNullOrEmpty(redirectFragment))
-                {
-                    location = new UriBuilder(location) { Fragment = requestFragment }.Uri;
-                }
-            }
-            if (!IsAllowedScheme(location.Scheme))
-            {
-                ReportRedirectNotFollowed(location);
-                return null;
-            }
-            return location;
-        }
-        private static bool IsRedirectStatusCode(int statusCode)
-        {
-            return (statusCode >= 300 && statusCode <= 303) || statusCode == 307 || statusCode == 308;
-        }
-        private static bool IsAllowedScheme(string scheme)
-        {
-            return string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase);
-        }
-        private static long GetValue(string name, long defaultValue)
-        {
-            object? data = AppContext.GetData(name);
-            if (data is null)
-            {
-                return defaultValue;
-            }
-            try
-            {
-                return Convert.ToInt64(data);
-            }
-            catch
-            {
-                return defaultValue;
-            }
-        }
-    }
-}

--- a/src/libraries/System.DirectoryServices.AccountManagement/src/System/DirectoryServices/AccountManagement/interopt.cs
+++ b//dev/null
@@ -1,376 +0,0 @@
-using System;
-using System.Runtime.InteropServices;
-#pragma warning disable CS0618 // Type or member is obsolete
-namespace System.DirectoryServices.AccountManagement
-{
-    internal static class Constants
-    {
-        internal static byte[] GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE = new byte[] { 0x22, 0xb7, 0x0c, 0x67, 0xd5, 0x6e, 0x4e, 0xfb, 0x91, 0xe9, 0x30, 0x0f, 0xca, 0x3d, 0xc1, 0xaa };
-    }
-    internal static class UnsafeNativeMethods
-    {
-        public static int ADsOpenObject(string path, string userName, string password, int flags, [In, Out] ref Guid iid, [Out, MarshalAs(UnmanagedType.Interface)] out object ppObject)
-        {
-            IntPtr ppObjPtr = IntPtr.Zero;
-            try
-            {
-                int hr = Interop.Activeds.ADsOpenObject(path, userName, password, flags, ref iid, out ppObjPtr);
-                ppObject = Marshal.GetObjectForIUnknown(ppObjPtr);
-                return hr;
-            }
-            catch (EntryPointNotFoundException)
-            {
-                throw new InvalidOperationException(SR.AdsiNotInstalled);
-            }
-            finally
-            {
-                if (ppObjPtr != IntPtr.Zero)
-                {
-                    Marshal.Release(ppObjPtr);
-                }
-            }
-        }
-        internal enum ADS_PASSWORD_ENCODING_ENUM
-        {
-            ADS_PASSWORD_ENCODE_REQUIRE_SSL = 0,
-            ADS_PASSWORD_ENCODE_CLEAR = 1
-        }
-        internal enum ADS_OPTION_ENUM
-        {
-            ADS_OPTION_SERVERNAME = 0,
-            ADS_OPTION_REFERRALS = 1,
-            ADS_OPTION_PAGE_SIZE = 2,
-            ADS_OPTION_SECURITY_MASK = 3,
-            ADS_OPTION_MUTUAL_AUTH_STATUS = 4,
-            ADS_OPTION_QUOTA = 5,
-            ADS_OPTION_PASSWORD_PORTNUMBER = 6,
-            ADS_OPTION_PASSWORD_METHOD = 7,
-            ADS_OPTION_ACCUMULATIVE_MODIFICATION = 8,
-            ADS_OPTION_SKIP_SID_LOOKUP = 9
-        }
-        [ComImport, Guid("7E99C0A2-F935-11D2-BA96-00C04FB6D0D1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADsDNWithBinary
-        {
-            object BinaryValue { get; set; }
-            string DNString { get; set; }
-        }
-        [ComImport, Guid("9068270b-0939-11D1-8be1-00c04fd8d503"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADsLargeInteger
-        {
-            int HighPart { get; set; }
-            int LowPart { get; set; }
-        }
-        [ComImport, Guid("927971f5-0939-11d1-8be1-00c04fd8d503")]
-        public class ADsLargeInteger
-        {
-        }
-        [ComImport, Guid("46f14fda-232b-11d1-a808-00c04fd8d5a8"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IAdsObjectOptions
-        {
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object GetOption(
-                [In]
-                int option);
-            void PutOption(
-                [In]
-                int option,
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProp);
-        }
-        [ComImport, Guid("FD8256D0-FD15-11CE-ABC4-02608C9E7553"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADs
-        {
-            string Name
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Class
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string GUID
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string ADsPath
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Parent
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Schema
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            void GetInfo();
-            void SetInfo();
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object Get(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName);
-            void Put(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName,
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProp);
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object GetEx(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName);
-            void PutEx(
-                [In, MarshalAs(UnmanagedType.U4)]
-                int lnControlCode,
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName,
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProp);
-            void GetInfoEx(
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProperties,
-                [In, MarshalAs(UnmanagedType.U4)]
-                int lnReserved);
-        }
-        [ComImport, Guid("27636b00-410f-11cf-b1ff-02608c9e7553"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADsGroup
-        {
-            string Name
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Class
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string GUID
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string ADsPath
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Parent
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            string Schema
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-            }
-            void GetInfo();
-            void SetInfo();
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object Get(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName);
-            void Put(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName,
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProp);
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object GetEx(
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName);
-            void PutEx(
-                [In, MarshalAs(UnmanagedType.U4)]
-                int lnControlCode,
-                [In, MarshalAs(UnmanagedType.BStr)]
-                string bstrName,
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProp);
-            void GetInfoEx(
-                [In, MarshalAs(UnmanagedType.Struct)]
-                object vProperties,
-                [In, MarshalAs(UnmanagedType.U4)]
-                int lnReserved);
-            string Description
-            {
-                [return: MarshalAs(UnmanagedType.BStr)]
-                get;
-                [param: MarshalAs(UnmanagedType.BStr)]
-                set;
-            }
-            IADsMembers Members();
-            bool IsMember([In, MarshalAs(UnmanagedType.BStr)] string bstrMember);
-            void Add([In, MarshalAs(UnmanagedType.BStr)] string bstrNewItem);
-            void Remove([In, MarshalAs(UnmanagedType.BStr)] string bstrItemToBeRemoved);
-        }
-        [ComImport, Guid("451a0030-72ec-11cf-b03b-00aa006e0975"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADsMembers
-        {
-            int Count
-            {
-                [return: MarshalAs(UnmanagedType.U4)]
-                get;
-            }
-            object _NewEnum
-            {
-                [return: MarshalAs(UnmanagedType.Interface)]
-                get;
-            }
-            object Filter
-            {
-                [return: MarshalAs(UnmanagedType.Struct)]
-                get;
-                [param: MarshalAs(UnmanagedType.Struct)]
-                set;
-            }
-        }
-        [ComImport, Guid("080d0d78-f421-11d0-a36e-00c04fb950dc")]
-        public class Pathname
-        {
-        }
-        [ComImport, Guid("d592aed4-f420-11d0-a36e-00c04fb950dc"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
-        public interface IADsPathname
-        {
-            void Set(
-                [In, MarshalAs(UnmanagedType.BStr)] string bstrADsPath,
-                [In, MarshalAs(UnmanagedType.U4)]  int lnSetType
-                );
-            void SetDisplayType(
-                [In, MarshalAs(UnmanagedType.U4)] int lnDisplayType
-                );
-            [return: MarshalAs(UnmanagedType.BStr)]
-            string Retrieve(
-                [In, MarshalAs(UnmanagedType.U4)] int lnFormatType
-                );
-            [return: MarshalAs(UnmanagedType.U4)]
-            int GetNumElements();
-            [return: MarshalAs(UnmanagedType.BStr)]
-            string
-            GetElement(
-                [In, MarshalAs(UnmanagedType.U4)]  int lnElementIndex
-                );
-            void AddLeafElement(
-                [In, MarshalAs(UnmanagedType.BStr)] string bstrLeafElement
-                );
-            void RemoveLeafElement();
-            [return: MarshalAs(UnmanagedType.Struct)]
-            object CopyPath();
-            [return: MarshalAs(UnmanagedType.BStr)]
-            string GetEscapedElement(
-                [In, MarshalAs(UnmanagedType.U4)] int lnReserved,
-                [In, MarshalAs(UnmanagedType.BStr)] string bstrInStr
-                );
-            int EscapedMode
-            {
-                [return: MarshalAs(UnmanagedType.U4)]
-                get;
-                [param: MarshalAs(UnmanagedType.U4)]
-                set;
-            }
-        }
-        /*
-        typedef enum
-        {
-          DsRole_RoleStandaloneWorkstation,
-          DsRole_RoleMemberWorkstation,
-          DsRole_RoleStandaloneServer,
-          DsRole_RoleMemberServer,
-          DsRole_RoleBackupDomainController,
-          DsRole_RolePrimaryDomainController,
-          DsRole_WorkstationWithSharedAccountDomain,
-          DsRole_ServerWithSharedAccountDomain,
-          DsRole_MemberWorkstationWithSharedAccountDomain,
-          DsRole_MemberServerWithSharedAccountDomain
-        }DSROLE_MACHINE_ROLE;
-        */
-        public enum DSROLE_MACHINE_ROLE
-        {
-            DsRole_RoleStandaloneWorkstation,
-            DsRole_RoleMemberWorkstation,
-            DsRole_RoleStandaloneServer,
-            DsRole_RoleMemberServer,
-            DsRole_RoleBackupDomainController,
-            DsRole_RolePrimaryDomainController,
-            DsRole_WorkstationWithSharedAccountDomain,
-            DsRole_ServerWithSharedAccountDomain,
-            DsRole_MemberWorkstationWithSharedAccountDomain,
-            DsRole_MemberServerWithSharedAccountDomain
-        }
-        /*
-         typedef struct _DSROLE_PRIMARY_DOMAIN_INFO_BASIC {
-         DSROLE_MACHINE_ROLE MachineRole;
-         ULONG Flags;
-         LPWSTR DomainNameFlat;
-         LPWSTR DomainNameDns;
-         LPWSTR DomainForestName;
-         GUID DomainGuid;
-         } DSROLE_PRIMARY_DOMAIN_INFO_BASIC,  *PDSROLE_PRIMARY_DOMAIN_INFO_BASIC;
-         */
-        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
-        public sealed class DSROLE_PRIMARY_DOMAIN_INFO_BASIC
-        {
-            public DSROLE_MACHINE_ROLE MachineRole;
-            public uint Flags;
-            [MarshalAs(UnmanagedType.LPWStr)]
-            public string DomainNameFlat;
-            [MarshalAs(UnmanagedType.LPWStr)]
-            public string DomainNameDns;
-            [MarshalAs(UnmanagedType.LPWStr)]
-            public string DomainForestName;
-            public Guid DomainGuid;
-        }
-        /*typedef struct _DOMAIN_CONTROLLER_INFO {
-            LPTSTR DomainControllerName;
-            LPTSTR DomainControllerAddress;
-            ULONG DomainControllerAddressType;
-            GUID DomainGuid;
-            LPTSTR DomainName;
-            LPTSTR DnsForestName;
-            ULONG Flags;
-            LPTSTR DcSiteName;
-            LPTSTR ClientSiteName;
-        } DOMAIN_CONTROLLER_INFO, *PDOMAIN_CONTROLLER_INFO; */
-        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
-        public sealed class DomainControllerInfo
-        {
-            public string DomainControllerName;
-            public string DomainControllerAddress;
-            public int DomainControllerAddressType;
-            public Guid DomainGuid;
-            public string DomainName;
-            public string DnsForestName;
-            public int Flags;
-            public string DcSiteName;
-            public string ClientSiteName;
-        }
-        /* typedef struct _WKSTA_INFO_100 {
-                DWORD wki100_platform_id;
-                LMSTR wki100_computername;
-                LMSTR wki100_langroup;
-                DWORD wki100_ver_major;
-                DWORD wki100_ver_minor;
-        } WKSTA_INFO_100, *PWKSTA_INFO_100; */
-        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
-        public sealed class WKSTA_INFO_100
-        {
-            public int wki100_platform_id;
-            public string wki100_computername;
-            public string wki100_langroup;
-            public int wki100_ver_major;
-            public int wki100_ver_minor;
-        };
-        [StructLayout(LayoutKind.Sequential)]
-        public struct POLICY_ACCOUNT_DOMAIN_INFO
-        {
-            public Interop.UNICODE_INTPTR_STRING DomainName;
-            public IntPtr DomainSid;
-        }
-    }
-}

--- a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/ConcurrencyLimiter.cs
+++ b//dev/null
@@ -1,373 +0,0 @@
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Threading.Tasks;
-namespace System.Threading.RateLimiting
-{
-    public sealed class ConcurrencyLimiter : RateLimiter
-    {
-        private int _permitCount;
-        private int _queueCount;
-        private long? _idleSince = Stopwatch.GetTimestamp();
-        private bool _disposed;
-        private long _failedLeasesCount;
-        private long _successfulLeasesCount;
-        private readonly ConcurrencyLimiterOptions _options;
-        private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
-        private static readonly ConcurrencyLease SuccessfulLease = new ConcurrencyLease(true, null, 0);
-        private static readonly ConcurrencyLease FailedLease = new ConcurrencyLease(false, null, 0);
-        private static readonly ConcurrencyLease QueueLimitLease = new ConcurrencyLease(false, null, 0, "Queue limit reached");
-        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
-        private object Lock => _queue;
-        public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
-        public ConcurrencyLimiter(ConcurrencyLimiterOptions options)
-        {
-            if (options is null)
-            {
-                throw new ArgumentNullException(nameof(options));
-            }
-            if (options.PermitLimit <= 0)
-            {
-                throw new ArgumentException($"{nameof(options.PermitLimit)} must be set to a value greater than 0.", nameof(options));
-            }
-            if (options.QueueLimit < 0)
-            {
-                throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
-            }
-            _options = new ConcurrencyLimiterOptions
-            {
-                PermitLimit = options.PermitLimit,
-                QueueProcessingOrder = options.QueueProcessingOrder,
-                QueueLimit = options.QueueLimit
-            };
-            _permitCount = _options.PermitLimit;
-        }
-        public override RateLimiterStatistics? GetStatistics()
-        {
-            ThrowIfDisposed();
-            return new RateLimiterStatistics()
-            {
-                CurrentAvailablePermits = _permitCount,
-                CurrentQueuedCount = _queueCount,
-                TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
-                TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
-            };
-        }
-        protected override RateLimitLease AttemptAcquireCore(int permitCount)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            ThrowIfDisposed();
-            if (permitCount == 0)
-            {
-                if (_permitCount > 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    return SuccessfulLease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return FailedLease;
-            }
-            if (_permitCount >= permitCount)
-            {
-                lock (Lock)
-                {
-                    if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                    {
-                        return lease;
-                    }
-                }
-            }
-            Interlocked.Increment(ref _failedLeasesCount);
-            return FailedLease;
-        }
-        protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            if (permitCount == 0 && _permitCount > 0 && !_disposed)
-            {
-                Interlocked.Increment(ref _successfulLeasesCount);
-                return new ValueTask<RateLimitLease>(SuccessfulLease);
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                {
-                    return new ValueTask<RateLimitLease>(lease);
-                }
-                Debug.Assert(_options.QueueLimit >= _queueCount);
-                if (_options.QueueLimit - _queueCount < permitCount)
-                {
-                    if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
-                    {
-                        do
-                        {
-                            RequestRegistration oldestRequest = _queue.DequeueHead();
-                            _queueCount -= oldestRequest.Count;
-                            Debug.Assert(_queueCount >= 0);
-                            if (!oldestRequest.TrySetResult(FailedLease))
-                            {
-                                if (!oldestRequest.QueueCountModified)
-                                {
-                                    oldestRequest.QueueCountModified = true;
-                                }
-                                else
-                                {
-                                    _queueCount += oldestRequest.Count;
-                                }
-                            }
-                            else
-                            {
-                                Interlocked.Increment(ref _failedLeasesCount);
-                            }
-                            disposer.Add(oldestRequest);
-                        }
-                        while (_options.QueueLimit - _queueCount < permitCount);
-                    }
-                    else
-                    {
-                        Interlocked.Increment(ref _failedLeasesCount);
-                        return new ValueTask<RateLimitLease>(QueueLimitLease);
-                    }
-                }
-                var request = new RequestRegistration(permitCount, this, cancellationToken);
-                _queue.EnqueueTail(request);
-                _queueCount += permitCount;
-                Debug.Assert(_queueCount <= _options.QueueLimit);
-                return new ValueTask<RateLimitLease>(request.Task);
-            }
-        }
-        private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
-        {
-            ThrowIfDisposed();
-            if (_permitCount >= permitCount && _permitCount != 0)
-            {
-                if (permitCount == 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-                if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
-                {
-                    _idleSince = null;
-                    _permitCount -= permitCount;
-                    Debug.Assert(_permitCount >= 0);
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = new ConcurrencyLease(true, this, permitCount);
-                    return true;
-                }
-            }
-            lease = null;
-            return false;
-        }
-#if DEBUG
-        internal event Action? ReleasePreHook;
-        internal event Action? ReleasePostHook;
-#endif
-        private void Release(int releaseCount)
-        {
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _permitCount += releaseCount;
-                Debug.Assert(_permitCount <= _options.PermitLimit);
-#if DEBUG
-                ReleasePreHook?.Invoke();
-#endif
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration nextPendingRequest =
-                        _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                        ? _queue.PeekHead()
-                        : _queue.PeekTail();
-                    if (nextPendingRequest.Task.IsCompleted)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        disposer.Add(nextPendingRequest);
-                        continue;
-                    }
-#if DEBUG
-                    ReleasePostHook?.Invoke();
-#endif
-                    if (_permitCount >= nextPendingRequest.Count)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        _permitCount -= nextPendingRequest.Count;
-                        _queueCount -= nextPendingRequest.Count;
-                        Debug.Assert(_permitCount >= 0);
-                        ConcurrencyLease lease = nextPendingRequest.Count == 0 ? SuccessfulLease : new ConcurrencyLease(true, this, nextPendingRequest.Count);
-                        if (!nextPendingRequest.TrySetResult(lease))
-                        {
-                            _permitCount += nextPendingRequest.Count;
-                            if (!nextPendingRequest.QueueCountModified)
-                            {
-                                nextPendingRequest.QueueCountModified = true;
-                            }
-                            else
-                            {
-                                _queueCount += nextPendingRequest.Count;
-                            }
-                        }
-                        else
-                        {
-                            Interlocked.Increment(ref _successfulLeasesCount);
-                        }
-                        disposer.Add(nextPendingRequest);
-                        Debug.Assert(_queueCount >= 0);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                }
-                if (_permitCount == _options.PermitLimit)
-                {
-                    Debug.Assert(_idleSince is null);
-                    _idleSince = Stopwatch.GetTimestamp();
-                }
-            }
-        }
-        protected override void Dispose(bool disposing)
-        {
-            if (!disposing)
-            {
-                return;
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _disposed = true;
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                        ? _queue.DequeueHead()
-                        : _queue.DequeueTail();
-                    disposer.Add(next);
-                    next.TrySetResult(FailedLease);
-                }
-            }
-        }
-        protected override ValueTask DisposeAsyncCore()
-        {
-            Dispose(true);
-            return default;
-        }
-        private void ThrowIfDisposed()
-        {
-            if (_disposed)
-            {
-                throw new ObjectDisposedException(nameof(ConcurrencyLimiter));
-            }
-        }
-        private sealed class ConcurrencyLease : RateLimitLease
-        {
-            private static readonly string[] s_allMetadataNames = new[] { MetadataName.ReasonPhrase.Name };
-            private bool _disposed;
-            private readonly ConcurrencyLimiter? _limiter;
-            private readonly int _count;
-            private readonly string? _reason;
-            public ConcurrencyLease(bool isAcquired, ConcurrencyLimiter? limiter, int count, string? reason = null)
-            {
-                IsAcquired = isAcquired;
-                _limiter = limiter;
-                _count = count;
-                _reason = reason;
-                Debug.Assert(count == 0 ? limiter is null : true);
-            }
-            public override bool IsAcquired { get; }
-            public override IEnumerable<string> MetadataNames => s_allMetadataNames;
-            public override bool TryGetMetadata(string metadataName, out object? metadata)
-            {
-                if (_reason is not null && metadataName == MetadataName.ReasonPhrase.Name)
-                {
-                    metadata = _reason;
-                    return true;
-                }
-                metadata = default;
-                return false;
-            }
-            protected override void Dispose(bool disposing)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _disposed = true;
-                _limiter?.Release(_count);
-            }
-        }
-        private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
-        {
-            private readonly CancellationToken _cancellationToken;
-            private CancellationTokenRegistration _cancellationTokenRegistration;
-            public bool QueueCountModified { get; set; }
-            private RequestRegistration? _next;
-            public RequestRegistration(int permitCount, ConcurrencyLimiter limiter, CancellationToken cancellationToken)
-                : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
-            {
-                Count = permitCount;
-                _cancellationToken = cancellationToken;
-                if (cancellationToken.CanBeCanceled)
-#if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
-                    _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
-#else
-                    _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
-#endif
-            }
-            public int Count { get; }
-            private static void Cancel(object? state)
-            {
-                if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
-                {
-                    var limiter = (ConcurrencyLimiter)registration.Task.AsyncState!;
-                    lock (limiter.Lock)
-                    {
-                        if (!registration.QueueCountModified)
-                        {
-                            limiter._queueCount -= registration.Count;
-                            registration.QueueCountModified = true;
-                        }
-                    }
-                }
-            }
-            public struct Disposer : IDisposable
-            {
-                private RequestRegistration? _next;
-                public void Add(RequestRegistration request)
-                {
-                    request._next = _next;
-                    _next = request;
-                }
-                public void Dispose()
-                {
-                    for (var current = _next; current is not null; current = current._next)
-                    {
-                        current._cancellationTokenRegistration.Dispose();
-                    }
-                    _next = null;
-                }
-            }
-        }
-    }
-}

--- a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/FixedWindowRateLimiter.cs
+++ b//dev/null
@@ -1,390 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Threading.Tasks;
-namespace System.Threading.RateLimiting
-{
-    public sealed class FixedWindowRateLimiter : ReplenishingRateLimiter
-    {
-        private int _permitCount;
-        private int _queueCount;
-        private long _lastReplenishmentTick;
-        private long? _idleSince;
-        private bool _disposed;
-        private long _failedLeasesCount;
-        private long _successfulLeasesCount;
-        private readonly Timer? _renewTimer;
-        private readonly FixedWindowRateLimiterOptions _options;
-        private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
-        private object Lock => _queue;
-        private static readonly RateLimitLease SuccessfulLease = new FixedWindowLease(true, null);
-        private static readonly RateLimitLease FailedLease = new FixedWindowLease(false, null);
-        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
-        public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
-        public override bool IsAutoReplenishing => _options.AutoReplenishment;
-        public override TimeSpan ReplenishmentPeriod => _options.Window;
-        public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options)
-        {
-            if (options is null)
-            {
-                throw new ArgumentNullException(nameof(options));
-            }
-            if (options.PermitLimit <= 0)
-            {
-                throw new ArgumentException($"{nameof(options.PermitLimit)} must be set to a value greater than 0.", nameof(options));
-            }
-            if (options.QueueLimit < 0)
-            {
-                throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
-            }
-            if (options.Window <= TimeSpan.Zero)
-            {
-                throw new ArgumentException($"{nameof(options.Window)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
-            }
-            _options = new FixedWindowRateLimiterOptions
-            {
-                PermitLimit = options.PermitLimit,
-                QueueProcessingOrder = options.QueueProcessingOrder,
-                QueueLimit = options.QueueLimit,
-                Window = options.Window,
-                AutoReplenishment = options.AutoReplenishment
-            };
-            _permitCount = options.PermitLimit;
-            _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
-            if (_options.AutoReplenishment)
-            {
-                _renewTimer = new Timer(Replenish, this, _options.Window, _options.Window);
-            }
-        }
-        public override RateLimiterStatistics? GetStatistics()
-        {
-            ThrowIfDisposed();
-            return new RateLimiterStatistics()
-            {
-                CurrentAvailablePermits = _permitCount,
-                CurrentQueuedCount = _queueCount,
-                TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
-                TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
-            };
-        }
-        protected override RateLimitLease AttemptAcquireCore(int permitCount)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            if (permitCount == 0 && !_disposed)
-            {
-                if (_permitCount > 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    return SuccessfulLease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return CreateFailedWindowLease(permitCount);
-            }
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                {
-                    return lease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return CreateFailedWindowLease(permitCount);
-            }
-        }
-        protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            ThrowIfDisposed();
-            if (permitCount == 0 && _permitCount > 0)
-            {
-                Interlocked.Increment(ref _successfulLeasesCount);
-                return new ValueTask<RateLimitLease>(SuccessfulLease);
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                {
-                    return new ValueTask<RateLimitLease>(lease);
-                }
-                Debug.Assert(_options.QueueLimit >= _queueCount);
-                if (_options.QueueLimit - _queueCount < permitCount)
-                {
-                    if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
-                    {
-                        do
-                        {
-                            RequestRegistration oldestRequest = _queue.DequeueHead();
-                            _queueCount -= oldestRequest.Count;
-                            Debug.Assert(_queueCount >= 0);
-                            if (!oldestRequest.TrySetResult(FailedLease))
-                            {
-                                if (!oldestRequest.QueueCountModified)
-                                {
-                                    oldestRequest.QueueCountModified = true;
-                                }
-                                else
-                                {
-                                    _queueCount += oldestRequest.Count;
-                                }
-                            }
-                            else
-                            {
-                                Interlocked.Increment(ref _failedLeasesCount);
-                            }
-                            disposer.Add(oldestRequest);
-                        }
-                        while (_options.QueueLimit - _queueCount < permitCount);
-                    }
-                    else
-                    {
-                        Interlocked.Increment(ref _failedLeasesCount);
-                        return new ValueTask<RateLimitLease>(CreateFailedWindowLease(permitCount));
-                    }
-                }
-                var registration = new RequestRegistration(permitCount, this, cancellationToken);
-                _queue.EnqueueTail(registration);
-                _queueCount += permitCount;
-                Debug.Assert(_queueCount <= _options.QueueLimit);
-                return new ValueTask<RateLimitLease>(registration.Task);
-            }
-        }
-        private RateLimitLease CreateFailedWindowLease(int permitCount)
-        {
-            int replenishAmount = permitCount - _permitCount + _queueCount;
-            int replenishWindow = Math.Max(replenishAmount / _options.PermitLimit, 1);
-            return new FixedWindowLease(false, TimeSpan.FromTicks(_options.Window.Ticks * replenishWindow));
-        }
-        private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
-        {
-            ThrowIfDisposed();
-            if (_permitCount >= permitCount && _permitCount != 0)
-            {
-                if (permitCount == 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-                if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
-                {
-                    _idleSince = null;
-                    _permitCount -= permitCount;
-                    Debug.Assert(_permitCount >= 0);
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-            }
-            lease = null;
-            return false;
-        }
-        public override bool TryReplenish()
-        {
-            if (_options.AutoReplenishment)
-            {
-                return false;
-            }
-            Replenish(this);
-            return true;
-        }
-        private static void Replenish(object? state)
-        {
-            FixedWindowRateLimiter limiter = (state as FixedWindowRateLimiter)!;
-            Debug.Assert(limiter is not null);
-            long nowTicks = Stopwatch.GetTimestamp();
-            limiter!.ReplenishInternal(nowTicks);
-        }
-        private void ReplenishInternal(long nowTicks)
-        {
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                if (((nowTicks - _lastReplenishmentTick) * TickFrequency) < _options.Window.Ticks && !_options.AutoReplenishment)
-                {
-                    return;
-                }
-                _lastReplenishmentTick = nowTicks;
-                int availablePermitCounters = _permitCount;
-                if (availablePermitCounters >= _options.PermitLimit)
-                {
-                    return;
-                }
-                _permitCount = _options.PermitLimit;
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration nextPendingRequest =
-                          _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                          ? _queue.PeekHead()
-                          : _queue.PeekTail();
-                    if (nextPendingRequest.Task.IsCompleted)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        disposer.Add(nextPendingRequest);
-                    }
-                    else if (_permitCount >= nextPendingRequest.Count)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        _queueCount -= nextPendingRequest.Count;
-                        _permitCount -= nextPendingRequest.Count;
-                        Debug.Assert(_permitCount >= 0);
-                        if (!nextPendingRequest.TrySetResult(SuccessfulLease))
-                        {
-                            _permitCount += nextPendingRequest.Count;
-                            if (!nextPendingRequest.QueueCountModified)
-                            {
-                                nextPendingRequest.QueueCountModified = true;
-                            }
-                            else
-                            {
-                                _queueCount += nextPendingRequest.Count;
-                            }
-                        }
-                        else
-                        {
-                            Interlocked.Increment(ref _successfulLeasesCount);
-                        }
-                        disposer.Add(nextPendingRequest);
-                        Debug.Assert(_queueCount >= 0);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                }
-                if (_permitCount == _options.PermitLimit)
-                {
-                    Debug.Assert(_idleSince is null);
-                    _idleSince = Stopwatch.GetTimestamp();
-                }
-            }
-        }
-        protected override void Dispose(bool disposing)
-        {
-            if (!disposing)
-            {
-                return;
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _disposed = true;
-                _renewTimer?.Dispose();
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                        ? _queue.DequeueHead()
-                        : _queue.DequeueTail();
-                    disposer.Add(next);
-                    next.TrySetResult(FailedLease);
-                }
-            }
-        }
-        protected override ValueTask DisposeAsyncCore()
-        {
-            Dispose(true);
-            return default;
-        }
-        private void ThrowIfDisposed()
-        {
-            if (_disposed)
-            {
-                throw new ObjectDisposedException(nameof(FixedWindowRateLimiter));
-            }
-        }
-        private sealed class FixedWindowLease : RateLimitLease
-        {
-            private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
-            private readonly TimeSpan? _retryAfter;
-            public FixedWindowLease(bool isAcquired, TimeSpan? retryAfter)
-            {
-                IsAcquired = isAcquired;
-                _retryAfter = retryAfter;
-            }
-            public override bool IsAcquired { get; }
-            public override IEnumerable<string> MetadataNames => s_allMetadataNames;
-            public override bool TryGetMetadata(string metadataName, out object? metadata)
-            {
-                if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
-                {
-                    metadata = _retryAfter.Value;
-                    return true;
-                }
-                metadata = default;
-                return false;
-            }
-        }
-        private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
-        {
-            private readonly CancellationToken _cancellationToken;
-            private CancellationTokenRegistration _cancellationTokenRegistration;
-            public bool QueueCountModified { get; set; }
-            private RequestRegistration? _next;
-            public RequestRegistration(int permitCount, FixedWindowRateLimiter limiter, CancellationToken cancellationToken)
-                : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
-            {
-                Count = permitCount;
-                _cancellationToken = cancellationToken;
-                if (cancellationToken.CanBeCanceled)
-#if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
-                    _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
-#else
-                    _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
-#endif
-            }
-            public int Count { get; }
-            private static void Cancel(object? state)
-            {
-                if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
-                {
-                    var limiter = (FixedWindowRateLimiter)registration.Task.AsyncState!;
-                    lock (limiter.Lock)
-                    {
-                        if (!registration.QueueCountModified)
-                        {
-                            limiter._queueCount -= registration.Count;
-                            registration.QueueCountModified = true;
-                        }
-                    }
-                }
-            }
-            public struct Disposer : IDisposable
-            {
-                private RequestRegistration? _next;
-                public void Add(RequestRegistration request)
-                {
-                    request._next = _next;
-                    _next = request;
-                }
-                public void Dispose()
-                {
-                    for (var current = _next; current is not null; current = current._next)
-                    {
-                        current._cancellationTokenRegistration.Dispose();
-                    }
-                    _next = null;
-                }
-            }
-        }
-    }
-}

--- a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/SlidingWindowRateLimiter.cs
+++ b//dev/null
@@ -1,397 +0,0 @@
-﻿// Licensed to the .NET Foundation under one or more agreements.
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Threading.Tasks;
-namespace System.Threading.RateLimiting
-{
-    public sealed class SlidingWindowRateLimiter : ReplenishingRateLimiter
-    {
-        private int _permitCount;
-        private int _queueCount;
-        private int[] _requestsPerSegment;
-        private int _currentSegmentIndex;
-        private long _lastReplenishmentTick;
-        private long? _idleSince;
-        private bool _disposed;
-        private long _failedLeasesCount;
-        private long _successfulLeasesCount;
-        private readonly Timer? _renewTimer;
-        private readonly SlidingWindowRateLimiterOptions _options;
-        private readonly TimeSpan _replenishmentPeriod;
-        private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
-        private object Lock => _queue;
-        private static readonly RateLimitLease SuccessfulLease = new SlidingWindowLease(true, null);
-        private static readonly RateLimitLease FailedLease = new SlidingWindowLease(false, null);
-        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
-        public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
-        public override bool IsAutoReplenishing => _options.AutoReplenishment;
-        public override TimeSpan ReplenishmentPeriod => _replenishmentPeriod;
-        public SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions options)
-        {
-            if (options is null)
-            {
-                throw new ArgumentNullException(nameof(options));
-            }
-            if (options.PermitLimit <= 0 || options.SegmentsPerWindow <= 0)
-            {
-                throw new ArgumentException($"Both {nameof(options.PermitLimit)} and {nameof(options.SegmentsPerWindow)} must be set to values greater than 0.", nameof(options));
-            }
-            if (options.QueueLimit < 0)
-            {
-                throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
-            }
-            if (options.Window <= TimeSpan.Zero)
-            {
-                throw new ArgumentException($"{nameof(options.Window)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
-            }
-            _options = new SlidingWindowRateLimiterOptions
-            {
-                PermitLimit = options.PermitLimit,
-                QueueProcessingOrder = options.QueueProcessingOrder,
-                QueueLimit = options.QueueLimit,
-                Window = options.Window,
-                SegmentsPerWindow = options.SegmentsPerWindow,
-                AutoReplenishment = options.AutoReplenishment
-            };
-            _permitCount = options.PermitLimit;
-            _replenishmentPeriod = new TimeSpan(_options.Window.Ticks / _options.SegmentsPerWindow);
-            _requestsPerSegment = new int[options.SegmentsPerWindow];
-            _currentSegmentIndex = 0;
-            _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
-            if (_options.AutoReplenishment)
-            {
-                _renewTimer = new Timer(Replenish, this, ReplenishmentPeriod, ReplenishmentPeriod);
-            }
-        }
-        public override RateLimiterStatistics? GetStatistics()
-        {
-            ThrowIfDisposed();
-            return new RateLimiterStatistics()
-            {
-                CurrentAvailablePermits = _permitCount,
-                CurrentQueuedCount = _queueCount,
-                TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
-                TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
-            };
-        }
-        protected override RateLimitLease AttemptAcquireCore(int permitCount)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            if (permitCount == 0 && !_disposed)
-            {
-                if (_permitCount > 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    return SuccessfulLease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return FailedLease;
-            }
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                {
-                    return lease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return FailedLease;
-            }
-        }
-        protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
-        {
-            if (permitCount > _options.PermitLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
-            }
-            ThrowIfDisposed();
-            if (permitCount == 0 && _permitCount > 0)
-            {
-                Interlocked.Increment(ref _successfulLeasesCount);
-                return new ValueTask<RateLimitLease>(SuccessfulLease);
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
-                {
-                    return new ValueTask<RateLimitLease>(lease);
-                }
-                Debug.Assert(_options.QueueLimit >= _queueCount);
-                if (_options.QueueLimit - _queueCount < permitCount)
-                {
-                    if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
-                    {
-                        do
-                        {
-                            RequestRegistration oldestRequest = _queue.DequeueHead();
-                            _queueCount -= oldestRequest.Count;
-                            Debug.Assert(_queueCount >= 0);
-                            if (!oldestRequest.TrySetResult(FailedLease))
-                            {
-                                if (!oldestRequest.QueueCountModified)
-                                {
-                                    oldestRequest.QueueCountModified = true;
-                                }
-                                else
-                                {
-                                    _queueCount += oldestRequest.Count;
-                                }
-                            }
-                            else
-                            {
-                                Interlocked.Increment(ref _failedLeasesCount);
-                            }
-                            disposer.Add(oldestRequest);
-                        }
-                        while (_options.QueueLimit - _queueCount < permitCount);
-                    }
-                    else
-                    {
-                        Interlocked.Increment(ref _failedLeasesCount);
-                        return new ValueTask<RateLimitLease>(FailedLease);
-                    }
-                }
-                var registration = new RequestRegistration(permitCount, this, cancellationToken);
-                _queue.EnqueueTail(registration);
-                _queueCount += permitCount;
-                Debug.Assert(_queueCount <= _options.QueueLimit);
-                return new ValueTask<RateLimitLease>(registration.Task);
-            }
-        }
-        private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
-        {
-            ThrowIfDisposed();
-            if (_permitCount >= permitCount && _permitCount != 0)
-            {
-                if (permitCount == 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-                if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
-                {
-                    _idleSince = null;
-                    _requestsPerSegment[_currentSegmentIndex] += permitCount;
-                    _permitCount -= permitCount;
-                    Debug.Assert(_permitCount >= 0);
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-            }
-            lease = null;
-            return false;
-        }
-        public override bool TryReplenish()
-        {
-            if (_options.AutoReplenishment)
-            {
-                return false;
-            }
-            Replenish(this);
-            return true;
-        }
-        private static void Replenish(object? state)
-        {
-            SlidingWindowRateLimiter limiter = (state as SlidingWindowRateLimiter)!;
-            Debug.Assert(limiter is not null);
-            long nowTicks = Stopwatch.GetTimestamp();
-            limiter!.ReplenishInternal(nowTicks);
-        }
-        private void ReplenishInternal(long nowTicks)
-        {
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                if (((nowTicks - _lastReplenishmentTick) * TickFrequency) < ReplenishmentPeriod.Ticks && !_options.AutoReplenishment)
-                {
-                    return;
-                }
-                _lastReplenishmentTick = nowTicks;
-                _currentSegmentIndex = (_currentSegmentIndex + 1) % _options.SegmentsPerWindow;
-                int oldSegmentPermitCount = _requestsPerSegment[_currentSegmentIndex];
-                _requestsPerSegment[_currentSegmentIndex] = 0;
-                if (oldSegmentPermitCount == 0)
-                {
-                    return;
-                }
-                _permitCount += oldSegmentPermitCount;
-                Debug.Assert(_permitCount <= _options.PermitLimit);
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration nextPendingRequest =
-                          _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                          ? _queue.PeekHead()
-                          : _queue.PeekTail();
-                    if (nextPendingRequest.Task.IsCompleted)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        disposer.Add(nextPendingRequest);
-                    }
-                    else if (_permitCount >= nextPendingRequest.Count)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? _queue.DequeueHead()
-                            : _queue.DequeueTail();
-                        _queueCount -= nextPendingRequest.Count;
-                        _permitCount -= nextPendingRequest.Count;
-                        _requestsPerSegment[_currentSegmentIndex] += nextPendingRequest.Count;
-                        Debug.Assert(_permitCount >= 0);
-                        if (!nextPendingRequest.TrySetResult(SuccessfulLease))
-                        {
-                            _permitCount += nextPendingRequest.Count;
-                            _requestsPerSegment[_currentSegmentIndex] -= nextPendingRequest.Count;
-                            if (!nextPendingRequest.QueueCountModified)
-                            {
-                                nextPendingRequest.QueueCountModified = true;
-                            }
-                            else
-                            {
-                                _queueCount += nextPendingRequest.Count;
-                            }
-                        }
-                        else
-                        {
-                            Interlocked.Increment(ref _successfulLeasesCount);
-                        }
-                        disposer.Add(nextPendingRequest);
-                        Debug.Assert(_queueCount >= 0);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                }
-                if (_permitCount == _options.PermitLimit)
-                {
-                    Debug.Assert(_idleSince is null);
-                    _idleSince = Stopwatch.GetTimestamp();
-                }
-            }
-        }
-        protected override void Dispose(bool disposing)
-        {
-            if (!disposing)
-            {
-                return;
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _disposed = true;
-                _renewTimer?.Dispose();
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                        ? _queue.DequeueHead()
-                        : _queue.DequeueTail();
-                    disposer.Add(next);
-                    next.TrySetResult(FailedLease);
-                }
-            }
-        }
-        protected override ValueTask DisposeAsyncCore()
-        {
-            Dispose(true);
-            return default;
-        }
-        private void ThrowIfDisposed()
-        {
-            if (_disposed)
-            {
-                throw new ObjectDisposedException(nameof(SlidingWindowRateLimiter));
-            }
-        }
-        private sealed class SlidingWindowLease : RateLimitLease
-        {
-            private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
-            private readonly TimeSpan? _retryAfter;
-            public SlidingWindowLease(bool isAcquired, TimeSpan? retryAfter)
-            {
-                IsAcquired = isAcquired;
-                _retryAfter = retryAfter;
-            }
-            public override bool IsAcquired { get; }
-            public override IEnumerable<string> MetadataNames => s_allMetadataNames;
-            public override bool TryGetMetadata(string metadataName, out object? metadata)
-            {
-                if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
-                {
-                    metadata = _retryAfter.Value;
-                    return true;
-                }
-                metadata = default;
-                return false;
-            }
-        }
-        private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
-        {
-            private readonly CancellationToken _cancellationToken;
-            private CancellationTokenRegistration _cancellationTokenRegistration;
-            public bool QueueCountModified { get; set; }
-            private RequestRegistration? _next;
-            public RequestRegistration(int permitCount, SlidingWindowRateLimiter limiter, CancellationToken cancellationToken)
-                : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
-            {
-                Count = permitCount;
-                _cancellationToken = cancellationToken;
-                if (cancellationToken.CanBeCanceled)
-#if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
-                    _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
-#else
-                    _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
-#endif
-            }
-            public int Count { get; }
-            private static void Cancel(object? state)
-            {
-                if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
-                {
-                    var limiter = (SlidingWindowRateLimiter)registration.Task.AsyncState!;
-                    lock (limiter.Lock)
-                    {
-                        if (!registration.QueueCountModified)
-                        {
-                            limiter._queueCount -= registration.Count;
-                            registration.QueueCountModified = true;
-                        }
-                    }
-                }
-            }
-            public struct Disposer : IDisposable
-            {
-                private RequestRegistration? _next;
-                public void Add(RequestRegistration request)
-                {
-                    request._next = _next;
-                    _next = request;
-                }
-                public void Dispose()
-                {
-                    for (var current = _next; current is not null; current = current._next)
-                    {
-                        current._cancellationTokenRegistration.Dispose();
-                    }
-                    _next = null;
-                }
-            }
-        }
-    }
-}

--- a/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs
+++ b//dev/null
@@ -1,399 +0,0 @@
-using System.Collections.Generic;
-using System.Diagnostics;
-using System.Diagnostics.CodeAnalysis;
-using System.Threading.Tasks;
-namespace System.Threading.RateLimiting
-{
-    public sealed class TokenBucketRateLimiter : ReplenishingRateLimiter
-    {
-        private double _tokenCount;
-        private int _queueCount;
-        private long _lastReplenishmentTick;
-        private long? _idleSince;
-        private bool _disposed;
-        private long _failedLeasesCount;
-        private long _successfulLeasesCount;
-        private readonly double _fillRate;
-        private readonly Timer? _renewTimer;
-        private readonly TokenBucketRateLimiterOptions _options;
-        private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
-        private object Lock => _queue;
-        private static readonly RateLimitLease SuccessfulLease = new TokenBucketLease(true, null);
-        private static readonly RateLimitLease FailedLease = new TokenBucketLease(false, null);
-        private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
-        public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
-        public override bool IsAutoReplenishing => _options.AutoReplenishment;
-        public override TimeSpan ReplenishmentPeriod => _options.ReplenishmentPeriod;
-        public TokenBucketRateLimiter(TokenBucketRateLimiterOptions options)
-        {
-            if (options is null)
-            {
-                throw new ArgumentNullException(nameof(options));
-            }
-            if (options.TokenLimit <= 0 || options.TokensPerPeriod <= 0)
-            {
-                throw new ArgumentException($"Both {nameof(options.TokenLimit)} and {nameof(options.TokensPerPeriod)} must be set to values greater than 0.", nameof(options));
-            }
-            if (options.QueueLimit < 0)
-            {
-                throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
-            }
-            if (options.ReplenishmentPeriod <= TimeSpan.Zero)
-            {
-                throw new ArgumentException($"{nameof(options.ReplenishmentPeriod)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
-            }
-            _options = new TokenBucketRateLimiterOptions
-            {
-                TokenLimit = options.TokenLimit,
-                QueueProcessingOrder = options.QueueProcessingOrder,
-                QueueLimit = options.QueueLimit,
-                ReplenishmentPeriod = options.ReplenishmentPeriod,
-                TokensPerPeriod = options.TokensPerPeriod,
-                AutoReplenishment = options.AutoReplenishment
-            };
-            _tokenCount = options.TokenLimit;
-            _fillRate = (double)options.TokensPerPeriod / options.ReplenishmentPeriod.Ticks;
-            _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
-            if (_options.AutoReplenishment)
-            {
-                _renewTimer = new Timer(Replenish, this, _options.ReplenishmentPeriod, _options.ReplenishmentPeriod);
-            }
-        }
-        public override RateLimiterStatistics? GetStatistics()
-        {
-            ThrowIfDisposed();
-            return new RateLimiterStatistics()
-            {
-                CurrentAvailablePermits = (long)_tokenCount,
-                CurrentQueuedCount = _queueCount,
-                TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
-                TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
-            };
-        }
-        protected override RateLimitLease AttemptAcquireCore(int tokenCount)
-        {
-            if (tokenCount > _options.TokenLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(tokenCount), tokenCount, SR.Format(SR.TokenLimitExceeded, tokenCount, _options.TokenLimit));
-            }
-            if (tokenCount == 0 && !_disposed)
-            {
-                if (_tokenCount > 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    return SuccessfulLease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return CreateFailedTokenLease(tokenCount);
-            }
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(tokenCount, out RateLimitLease? lease))
-                {
-                    return lease;
-                }
-                Interlocked.Increment(ref _failedLeasesCount);
-                return CreateFailedTokenLease(tokenCount);
-            }
-        }
-        protected override ValueTask<RateLimitLease> AcquireAsyncCore(int tokenCount, CancellationToken cancellationToken = default)
-        {
-            if (tokenCount > _options.TokenLimit)
-            {
-                throw new ArgumentOutOfRangeException(nameof(tokenCount), tokenCount, SR.Format(SR.TokenLimitExceeded, tokenCount, _options.TokenLimit));
-            }
-            ThrowIfDisposed();
-            if (tokenCount == 0 && _tokenCount > 0)
-            {
-                Interlocked.Increment(ref _successfulLeasesCount);
-                return new ValueTask<RateLimitLease>(SuccessfulLease);
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (TryLeaseUnsynchronized(tokenCount, out RateLimitLease? lease))
-                {
-                    return new ValueTask<RateLimitLease>(lease);
-                }
-                Debug.Assert(_options.QueueLimit >= _queueCount);
-                if (_options.QueueLimit - _queueCount < tokenCount)
-                {
-                    if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && tokenCount <= _options.QueueLimit)
-                    {
-                        do
-                        {
-                            RequestRegistration oldestRequest = _queue.DequeueHead();
-                            _queueCount -= oldestRequest.Count;
-                            Debug.Assert(_queueCount >= 0);
-                            if (!oldestRequest.TrySetResult(FailedLease))
-                            {
-                                if (!oldestRequest.QueueCountModified)
-                                {
-                                    oldestRequest.QueueCountModified = true;
-                                }
-                                else
-                                {
-                                    _queueCount += oldestRequest.Count;
-                                }
-                            }
-                            else
-                            {
-                                Interlocked.Increment(ref _failedLeasesCount);
-                            }
-                            disposer.Add(oldestRequest);
-                        }
-                        while (_options.QueueLimit - _queueCount < tokenCount);
-                    }
-                    else
-                    {
-                        Interlocked.Increment(ref _failedLeasesCount);
-                        return new ValueTask<RateLimitLease>(CreateFailedTokenLease(tokenCount));
-                    }
-                }
-                var registration = new RequestRegistration(tokenCount, this, cancellationToken);
-                _queue.EnqueueTail(registration);
-                _queueCount += tokenCount;
-                Debug.Assert(_queueCount <= _options.QueueLimit);
-                return new ValueTask<RateLimitLease>(registration.Task);
-            }
-        }
-        private RateLimitLease CreateFailedTokenLease(int tokenCount)
-        {
-            int replenishAmount = tokenCount - (int)_tokenCount + _queueCount;
-            Debug.Assert(_options.TokensPerPeriod > 0);
-            int replenishPeriods = Math.Max(replenishAmount / _options.TokensPerPeriod, 1);
-            return new TokenBucketLease(false, TimeSpan.FromTicks(_options.ReplenishmentPeriod.Ticks * replenishPeriods));
-        }
-        private bool TryLeaseUnsynchronized(int tokenCount, [NotNullWhen(true)] out RateLimitLease? lease)
-        {
-            ThrowIfDisposed();
-            if (_tokenCount >= tokenCount && _tokenCount != 0)
-            {
-                if (tokenCount == 0)
-                {
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-                if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
-                {
-                    _idleSince = null;
-                    _tokenCount -= tokenCount;
-                    Debug.Assert(_tokenCount >= 0);
-                    Interlocked.Increment(ref _successfulLeasesCount);
-                    lease = SuccessfulLease;
-                    return true;
-                }
-            }
-            lease = null;
-            return false;
-        }
-        public override bool TryReplenish()
-        {
-            if (_options.AutoReplenishment)
-            {
-                return false;
-            }
-            Replenish(this);
-            return true;
-        }
-        private static void Replenish(object? state)
-        {
-            TokenBucketRateLimiter limiter = (state as TokenBucketRateLimiter)!;
-            Debug.Assert(limiter is not null);
-            long nowTicks = Stopwatch.GetTimestamp();
-            limiter!.ReplenishInternal(nowTicks);
-        }
-        private void ReplenishInternal(long nowTicks)
-        {
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                if (_tokenCount == _options.TokenLimit)
-                {
-                    return;
-                }
-                double add;
-                if (_options.AutoReplenishment)
-                {
-                    add = _options.TokensPerPeriod;
-                }
-                else
-                {
-                    add = _fillRate * (nowTicks - _lastReplenishmentTick) * TickFrequency;
-                }
-                _tokenCount = Math.Min(_options.TokenLimit, _tokenCount + add);
-                _lastReplenishmentTick = nowTicks;
-                Deque<RequestRegistration> queue = _queue;
-                Debug.Assert(_tokenCount <= _options.TokenLimit);
-                while (queue.Count > 0)
-                {
-                    RequestRegistration nextPendingRequest =
-                          _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                          ? queue.PeekHead()
-                          : queue.PeekTail();
-                    if (nextPendingRequest.Task.IsCompleted)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? queue.DequeueHead()
-                            : queue.DequeueTail();
-                        disposer.Add(nextPendingRequest);
-                    }
-                    else if (_tokenCount >= nextPendingRequest.Count)
-                    {
-                        nextPendingRequest =
-                            _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                            ? queue.DequeueHead()
-                            : queue.DequeueTail();
-                        _queueCount -= nextPendingRequest.Count;
-                        _tokenCount -= nextPendingRequest.Count;
-                        Debug.Assert(_tokenCount >= 0);
-                        if (!nextPendingRequest.TrySetResult(SuccessfulLease))
-                        {
-                            _tokenCount += nextPendingRequest.Count;
-                            if (!nextPendingRequest.QueueCountModified)
-                            {
-                                nextPendingRequest.QueueCountModified = true;
-                            }
-                            else
-                            {
-                                _queueCount += nextPendingRequest.Count;
-                            }
-                        }
-                        else
-                        {
-                            Interlocked.Increment(ref _successfulLeasesCount);
-                        }
-                        disposer.Add(nextPendingRequest);
-                        Debug.Assert(_queueCount >= 0);
-                    }
-                    else
-                    {
-                        break;
-                    }
-                }
-                if (_tokenCount == _options.TokenLimit)
-                {
-                    Debug.Assert(_idleSince is null);
-                    _idleSince = Stopwatch.GetTimestamp();
-                }
-            }
-        }
-        protected override void Dispose(bool disposing)
-        {
-            if (!disposing)
-            {
-                return;
-            }
-            using var disposer = default(RequestRegistration.Disposer);
-            lock (Lock)
-            {
-                if (_disposed)
-                {
-                    return;
-                }
-                _disposed = true;
-                _renewTimer?.Dispose();
-                while (_queue.Count > 0)
-                {
-                    RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
-                        ? _queue.DequeueHead()
-                        : _queue.DequeueTail();
-                    disposer.Add(next);
-                    next.TrySetResult(FailedLease);
-                }
-            }
-        }
-        protected override ValueTask DisposeAsyncCore()
-        {
-            Dispose(true);
-            return default;
-        }
-        private void ThrowIfDisposed()
-        {
-            if (_disposed)
-            {
-                throw new ObjectDisposedException(nameof(TokenBucketRateLimiter));
-            }
-        }
-        private sealed class TokenBucketLease : RateLimitLease
-        {
-            private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
-            private readonly TimeSpan? _retryAfter;
-            public TokenBucketLease(bool isAcquired, TimeSpan? retryAfter)
-            {
-                IsAcquired = isAcquired;
-                _retryAfter = retryAfter;
-            }
-            public override bool IsAcquired { get; }
-            public override IEnumerable<string> MetadataNames => s_allMetadataNames;
-            public override bool TryGetMetadata(string metadataName, out object? metadata)
-            {
-                if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
-                {
-                    metadata = _retryAfter.Value;
-                    return true;
-                }
-                metadata = default;
-                return false;
-            }
-        }
-        private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
-        {
-            private readonly CancellationToken _cancellationToken;
-            private CancellationTokenRegistration _cancellationTokenRegistration;
-            public bool QueueCountModified { get; set; }
-            private RequestRegistration? _next;
-            public RequestRegistration(int permitCount, TokenBucketRateLimiter limiter, CancellationToken cancellationToken)
-                : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
-            {
-                Count = permitCount;
-                _cancellationToken = cancellationToken;
-                if (cancellationToken.CanBeCanceled)
-#if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
-                    _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
-#else
-                    _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
-#endif
-            }
-            public int Count { get; }
-            private static void Cancel(object? state)
-            {
-                if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
-                {
-                    var limiter = (TokenBucketRateLimiter)registration.Task.AsyncState!;
-                    lock (limiter.Lock)
-                    {
-                        if (!registration.QueueCountModified)
-                        {
-                            limiter._queueCount -= registration.Count;
-                            registration.QueueCountModified = true;
-                        }
-                    }
-                }
-            }
-            public struct Disposer : IDisposable
-            {
-                private RequestRegistration? _next;
-                public void Add(RequestRegistration request)
-                {
-                    request._next = _next;
-                    _next = request;
-                }
-                public void Dispose()
-                {
-                    for (var current = _next; current is not null; current = current._next)
-                    {
-                        current._cancellationTokenRegistration.Dispose();
-                    }
-                    _next = null;
-                }
-            }
-        }
-    }
-}

--- a/src/mono/mono/mini/driver.c
+++ b//dev/null
@@ -1,2798 +0,0 @@
-/**
- * \file
- * The new mono JIT compiler.
- *
- * Author:
- *   Paolo Molaro (lupus@ximian.com)
- *   Dietmar Maurer (dietmar@ximian.com)
- *
- * (C) 2002-2003 Ximian, Inc.
- * (C) 2003-2006 Novell, Inc.
- * Licensed under the MIT license. See LICENSE file in the project root for full license information.
- */
-#include <config.h>
-#include <signal.h>
-#if HAVE_SCHED_SETAFFINITY
-#include <sched.h>
-#endif
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-#include <mono/metadata/assembly-internals.h>
-#include <mono/metadata/image-internals.h>
-#include <mono/metadata/loader.h>
-#include <mono/metadata/tabledefs.h>
-#include <mono/metadata/class.h>
-#include <mono/metadata/object.h>
-#include <mono/metadata/exception.h>
-#include <mono/metadata/opcodes.h>
-#include <mono/metadata/mono-endian.h>
-#include <mono/metadata/tokentype.h>
-#include <mono/metadata/reflection-internals.h>
-#include <mono/metadata/tabledefs.h>
-#include <mono/metadata/threads.h>
-#include <mono/metadata/marshal.h>
-#include <mono/metadata/appdomain.h>
-#include <mono/metadata/debug-helpers.h>
-#include <mono/metadata/profiler-private.h>
-#include <mono/metadata/mono-config.h>
-#include <mono/metadata/environment.h>
-#include <mono/metadata/verify.h>
-#include <mono/metadata/mono-debug.h>
-#include <mono/metadata/gc-internals.h>
-#include <mono/metadata/coree.h>
-#include "mono/utils/mono-counters.h"
-#include "mono/utils/mono-hwcap.h"
-#include "mono/utils/mono-logger-internals.h"
-#include "mono/utils/options.h"
-#include "mono/metadata/w32handle.h"
-#include "mono/metadata/callspec.h"
-#include "mono/metadata/custom-attrs-internals.h"
-#include <mono/utils/w32subset.h>
-#include <mono/metadata/components.h>
-#include <mono/mini/debugger-agent-external.h>
-#include "mini.h"
-#include <mono/jit/jit.h>
-#include "aot-compiler.h"
-#include "aot-runtime.h"
-#include "mini-runtime.h"
-#include "interp/interp.h"
-#include <string.h>
-#include <ctype.h>
-#include <locale.h>
-#if TARGET_OSX
-#   include <sys/resource.h>
-#endif
-static FILE *mini_stats_fd;
-static void mini_usage (void);
-static void mono_runtime_set_execution_mode (int mode);
-static void mono_runtime_set_execution_mode_full (int mode, gboolean override);
-static int mono_jit_exec_internal (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[]);
-#ifdef HOST_WIN32
-/* Need this to determine whether to detach console */
-#include <mono/metadata/cil-coff.h>
-/* This turns off command line globbing under win32 */
-int _CRT_glob = 0;
-#endif
-typedef void (*OptFunc) (const char *p);
-#undef OPTFLAG
-#define MSGSTRFIELD(line) MSGSTRFIELD1(line)
-#define MSGSTRFIELD1(line) str##line
-static const struct msgstr_t {
-#define OPTFLAG(id,shift,name,desc) char MSGSTRFIELD(__LINE__) [sizeof (name) + sizeof (desc)];
-#include "optflags-def.h"
-#undef OPTFLAG
-} opstr = {
-#define OPTFLAG(id,shift,name,desc) name "\0" desc,
-#include "optflags-def.h"
-#undef OPTFLAG
-};
-static const gint16 opt_names [] = {
-#define OPTFLAG(id,shift,name,desc) offsetof (struct msgstr_t, MSGSTRFIELD(__LINE__)),
-#include "optflags-def.h"
-#undef OPTFLAG
-};
-#define optflag_get_name(id) ((const char*)&opstr + opt_names [(id)])
-#define optflag_get_desc(id) (optflag_get_name(id) + 1 + strlen (optflag_get_name(id)))
-#define DEFAULT_OPTIMIZATIONS (	\
-	MONO_OPT_PEEPHOLE |	\
-	MONO_OPT_CFOLD |	\
-	MONO_OPT_INLINE |       \
-	MONO_OPT_CONSPROP |     \
-	MONO_OPT_COPYPROP |     \
-	MONO_OPT_DEADCE |       \
-	MONO_OPT_BRANCH |	\
-	MONO_OPT_LINEARS |	\
-	MONO_OPT_INTRINS |  \
-	MONO_OPT_LOOP |  \
-	MONO_OPT_EXCEPTION |  \
-    MONO_OPT_CMOV |  \
-	MONO_OPT_GSHARED |	\
-	MONO_OPT_SIMD |	\
-	MONO_OPT_ALIAS_ANALYSIS	| \
-	MONO_OPT_AOT | \
-	MONO_OPT_FLOAT32)
-#define EXCLUDED_FROM_ALL (MONO_OPT_PRECOMP | MONO_OPT_UNSAFE | MONO_OPT_GSHAREDVT)
-static char *mono_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend);
-static char *mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend);
-static guint32
-parse_optimizations (guint32 opt, const char* p, gboolean cpu_opts)
-{
-	guint32 exclude = 0;
-	const char *n;
-	int i, invert;
-	char **parts, **ptr;
-	/* Initialize the hwcap module if necessary. */
-	mono_hwcap_init ();
-	/* call out to cpu detection code here that sets the defaults ... */
-	if (cpu_opts) {
-#ifndef MONO_CROSS_COMPILE
-		opt |= mono_arch_cpu_optimizations (&exclude);
-		opt &= ~exclude;
-#endif
-	}
-	if (!p)
-		return opt;
-	parts = g_strsplit (p, ",", -1);
-	for (ptr = parts; ptr && *ptr; ptr ++) {
-		char *arg = *ptr;
-		char *parg = arg;
-		if (*parg == '-') {
-			parg++;
-			invert = TRUE;
-		} else {
-			invert = FALSE;
-		}
-		for (i = 0; i < G_N_ELEMENTS (opt_names) && optflag_get_name (i); ++i) {
-			n = optflag_get_name (i);
-			if (!strcmp (parg, n)) {
-				if (invert)
-					opt &= ~ (1 << i);
-				else
-					opt |= 1 << i;
-				break;
-			}
-		}
-		if (i == G_N_ELEMENTS (opt_names) || !optflag_get_name (i)) {
-			if (strncmp (parg, "all", 3) == 0) {
-				if (invert)
-					opt = 0;
-				else
-					opt = ~(EXCLUDED_FROM_ALL | exclude);
-			} else {
-				fprintf (stderr, "Invalid optimization name `%s'\n", parg);
-				exit (1);
-			}
-		}
-		g_free (arg);
-	}
-	g_free (parts);
-	return opt;
-}
-static gboolean
-parse_debug_options (const char* p)
-{
-	MonoDebugOptions *opt = mini_get_debug_options ();
-	opt->enabled = TRUE;
-	do {
-		if (!*p) {
-			fprintf (stderr, "Syntax error; expected debug option name\n");
-			return FALSE;
-		}
-		if (!strncmp (p, "casts", 5)) {
-			opt->better_cast_details = TRUE;
-			p += 5;
-		} else if (!strncmp (p, "mdb-optimizations", 17)) {
-			opt->mdb_optimizations = TRUE;
-			p += 17;
-		} else if (!strncmp (p, "ignore", 6)) {
-			opt->enabled = FALSE;
-			p += 6;
-		} else {
-			fprintf (stderr, "Invalid debug option `%s', use --help-debug for details\n", p);
-			return FALSE;
-		}
-		if (*p == ',') {
-			p++;
-			if (!*p) {
-				fprintf (stderr, "Syntax error; expected debug option name\n");
-				return FALSE;
-			}
-		}
-	} while (*p);
-	return TRUE;
-}
-typedef struct {
-	char name [6];
-	char desc [18];
-	MonoGraphOptions value;
-} GraphName;
-static const GraphName
-graph_names [] = {
-	{"cfg",      "Control Flow",                            MONO_GRAPH_CFG},
-	{"dtree",    "Dominator Tree",                          MONO_GRAPH_DTREE},
-	{"code",     "CFG showing code",                        MONO_GRAPH_CFG_CODE},
-	{"ssa",      "CFG after SSA",                           MONO_GRAPH_CFG_SSA},
-	{"optc",     "CFG after IR opts",                       MONO_GRAPH_CFG_OPTCODE}
-};
-static MonoGraphOptions
-mono_parse_graph_options (const char* p)
-{
-	const char *n;
-	size_t i, len;
-	for (i = 0; i < G_N_ELEMENTS (graph_names); ++i) {
-		n = graph_names [i].name;
-		len = strlen (n);
-		if (strncmp (p, n, len) == 0)
-			return graph_names [i].value;
-	}
-	fprintf (stderr, "Invalid graph name provided: %s\n", p);
-	exit (1);
-}
-/**
- * mono_parse_default_optimizations:
- */
-int
-mono_parse_default_optimizations (const char* p)
-{
-	guint32 opt;
-	opt = parse_optimizations (DEFAULT_OPTIMIZATIONS, p, TRUE);
-	return opt;
-}
-char*
-mono_opt_descr (guint32 flags) {
-	GString *str = g_string_new ("");
-	int i;
-	gboolean need_comma;
-	need_comma = FALSE;
-	for (i = 0; i < G_N_ELEMENTS (opt_names); ++i) {
-		if (flags & (1 << i) && optflag_get_name (i)) {
-			if (need_comma)
-				g_string_append_c (str, ',');
-			g_string_append (str, optflag_get_name (i));
-			need_comma = TRUE;
-		}
-	}
-	return g_string_free (str, FALSE);
-}
-static const guint32
-opt_sets [] = {
-       0,
-       MONO_OPT_PEEPHOLE,
-       MONO_OPT_BRANCH,
-       MONO_OPT_CFOLD,
-       MONO_OPT_FCMOV,
-       MONO_OPT_ALIAS_ANALYSIS,
-#ifdef MONO_ARCH_SIMD_INTRINSICS
-       MONO_OPT_SIMD | MONO_OPT_INTRINS,
-       MONO_OPT_SSE2,
-       MONO_OPT_SIMD | MONO_OPT_SSE2 | MONO_OPT_INTRINS,
-#endif
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_INTRINS,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_INTRINS | MONO_OPT_ALIAS_ANALYSIS,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_CFOLD,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_ALIAS_ANALYSIS,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_TAILCALL,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_SSA,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_CMOV,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM,
-       MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_CMOV,
-       DEFAULT_OPTIMIZATIONS,
-};
-static const guint32
-interp_opt_sets [] = {
-	INTERP_OPT_NONE,
-	INTERP_OPT_INLINE,
-	INTERP_OPT_CPROP,
-	INTERP_OPT_SUPER_INSTRUCTIONS,
-	INTERP_OPT_INLINE | INTERP_OPT_CPROP,
-	INTERP_OPT_INLINE | INTERP_OPT_SUPER_INSTRUCTIONS,
-	INTERP_OPT_CPROP | INTERP_OPT_SUPER_INSTRUCTIONS,
-	INTERP_OPT_INLINE | INTERP_OPT_CPROP | INTERP_OPT_SUPER_INSTRUCTIONS | INTERP_OPT_BBLOCKS,
-};
-static const char* const
-interp_opflags_names [] = {
-	"inline",
-	"cprop",
-	"super-insn",
-	"bblocks"
-};
-static const char*
-interp_optflag_get_name (guint32 i)
-{
-	g_assert (i < G_N_ELEMENTS (interp_opflags_names));
-	return interp_opflags_names [i];
-}
-static char*
-interp_opt_descr (guint32 flags)
-{
-	GString *str = g_string_new ("");
-	int i;
-	gboolean need_comma;
-	need_comma = FALSE;
-	for (i = 0; i < G_N_ELEMENTS (interp_opflags_names); ++i) {
-		if (flags & (1 << i) && interp_optflag_get_name (i)) {
-			if (need_comma)
-				g_string_append_c (str, ',');
-			g_string_append (str, interp_optflag_get_name (i));
-			need_comma = TRUE;
-		}
-	}
-	return g_string_free (str, FALSE);
-}
-typedef int (*TestMethod) (void);
-#if 0
-static void
-domain_dump_native_code (MonoDomain *domain) {
-}
-#endif
-static gboolean do_regression_retries;
-static int regression_test_skip_index;
-static gboolean
-method_should_be_regression_tested (MonoMethod *method, gboolean interp)
-{
-	ERROR_DECL (error);
-	if (strncmp (method->name, "test_", 5) != 0)
-		return FALSE;
-	static gboolean filter_method_init = FALSE;
-	static const char *filter_method = NULL;
-	if (!filter_method_init) {
-		filter_method = g_getenv ("REGRESSION_FILTER_METHOD");
-		filter_method_init = TRUE;
-	}
-	if (filter_method) {
-		const char *name = filter_method;
-		if ((strchr (name, '.') > name) || strchr (name, ':')) {
-			MonoMethodDesc *desc = mono_method_desc_new (name, TRUE);
-			gboolean res = mono_method_desc_full_match (desc, method);
-			mono_method_desc_free (desc);
-			return res;
-		} else {
-			return strcmp (method->name, name) == 0;
-		}
-	}
-	MonoCustomAttrInfo* ainfo = mono_custom_attrs_from_method_checked (method, error);
-	mono_error_cleanup (error);
-	if (!ainfo)
-		return TRUE;
-	int j;
-	for (j = 0; j < ainfo->num_attrs; ++j) {
-		MonoCustomAttrEntry *centry = &ainfo->attrs [j];
-		if (centry->ctor == NULL)
-			continue;
-		MonoClass *klass = centry->ctor->klass;
-		if (strcmp (m_class_get_name (klass), "CategoryAttribute") || mono_method_signature_internal (centry->ctor)->param_count != 1)
-			continue;
-		MonoDecodeCustomAttr *decoded_args = mono_reflection_create_custom_attr_data_args_noalloc (mono_defaults.corlib, centry->ctor, centry->data, centry->data_size, error);
-		if (!is_ok (error))
-			continue;
-		const char *arg = (const char*)decoded_args->typed_args[0]->value.primitive;
-		mono_metadata_decode_value (arg, &arg);
-		char *utf8_str = (char*)arg; //this points into image memory that is constant
-		mono_reflection_free_custom_attr_data_args_noalloc (decoded_args);
-		if (interp && !strcmp (utf8_str, "!INTERPRETER")) {
-			g_print ("skip %s...\n", method->name);
-			return FALSE;
-		}
-#if HOST_WASM
-		if (!strcmp (utf8_str, "!WASM")) {
-			g_print ("skip %s...\n", method->name);
-			return FALSE;
-		}
-#endif
-		if (mono_aot_mode == MONO_AOT_MODE_FULL && !strcmp (utf8_str, "!FULLAOT")) {
-			g_print ("skip %s...\n", method->name);
-			return FALSE;
-		}
-		if ((mono_aot_mode == MONO_AOT_MODE_INTERP_LLVMONLY || mono_aot_mode == MONO_AOT_MODE_LLVMONLY_INTERP) && !strcmp (utf8_str, "!BITCODE")) {
-			g_print ("skip %s...\n", method->name);
-			return FALSE;
-		}
-	}
-	return TRUE;
-}
-static void
-mini_regression_step (MonoImage *image, int verbose, int *total_run, int *total,
-					  guint32 opt_flags, GTimer *timer)
-{
-	int result, expected, failed, cfailed, run, code_size;
-	double elapsed, comp_time, start_time;
-	char *n;
-	mono_set_defaults (verbose, opt_flags);
-	n = mono_opt_descr (opt_flags);
-	g_print ("Test run: image=%s, opts=%s\n", mono_image_get_filename (image), n);
-	g_free (n);
-	cfailed = failed = run = code_size = 0;
-	comp_time = elapsed = 0.0;
-	int local_skip_index = 0;
-	MonoJitMemoryManager *jit_mm = get_default_jit_mm ();
-	g_hash_table_destroy (jit_mm->jit_trampoline_hash);
-	jit_mm->jit_trampoline_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
-	mono_internal_hash_table_destroy (&(jit_mm->jit_code_hash));
-	mono_jit_code_hash_init (&(jit_mm->jit_code_hash));
-	g_timer_start (timer);
-	if (mini_stats_fd)
-		fprintf (mini_stats_fd, "[");
-	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
-		ERROR_DECL (error);
-		MonoMethod *method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
-		if (!method) {
-			mono_error_cleanup (error); /* FIXME don't swallow the error */
-			continue;
-		}
-		if (method_should_be_regression_tested (method, FALSE)) {
-			MonoCompile *cfg = NULL;
-			TestMethod func = NULL;
-			expected = atoi (method->name + 5);
-			run++;
-			start_time = g_timer_elapsed (timer, NULL);
-#ifdef DISABLE_JIT
-#ifdef MONO_USE_AOT_COMPILER
-			error_init_reuse (error);
-			func = (TestMethod)mono_aot_get_method (method, error);
-			mono_error_cleanup (error);
-#else
-			g_error ("No JIT or AOT available, regression testing not possible!");
-#endif
-#else
-			comp_time -= start_time;
-			cfg = mini_method_compile (method, mono_get_optimizations_for_method (method, opt_flags), JIT_FLAG_RUN_CCTORS, 0, -1);
-			comp_time += g_timer_elapsed (timer, NULL);
-			if (cfg->exception_type == MONO_EXCEPTION_NONE) {
-#ifdef MONO_USE_AOT_COMPILER
-				error_init_reuse (error);
-				func = (TestMethod)mono_aot_get_method (method, error);
-				mono_error_cleanup (error);
-				if (!func) {
-					func = (TestMethod)MINI_ADDR_TO_FTNPTR (cfg->native_code);
-				}
-#else
-				func = (TestMethod)(gpointer)cfg->native_code;
-				func = MINI_ADDR_TO_FTNPTR (func);
-#endif
-				func = (TestMethod)mono_create_ftnptr ((gpointer)func);
-			}
-#endif
-			if (func) {
-				if (do_regression_retries) {
-					++local_skip_index;
-					if(local_skip_index <= regression_test_skip_index)
-						continue;
-					++regression_test_skip_index;
-				}
-				if (verbose >= 2)
-					g_print ("Running '%s' ...\n", method->name);
-#if HOST_WASM
-				int (*func_2)(int) = (int (*)(int))(void*)func;
-				result = func_2 (-1);
-#else
-				result = func ();
-#endif
-				if (result != expected) {
-					failed++;
-					g_print ("Test '%s' failed result (got %d, expected %d).\n", method->name, result, expected);
-				}
-				if (cfg) {
-					code_size += cfg->code_len;
-					mono_destroy_compile (cfg);
-				}
-			} else {
-				cfailed++;
-				g_print ("Test '%s' failed compilation.\n", method->name);
-			}
-			if (mini_stats_fd)
-				fprintf (mini_stats_fd, "%f, ",
-						g_timer_elapsed (timer, NULL) - start_time);
-		}
-	}
-	if (mini_stats_fd)
-		fprintf (mini_stats_fd, "],\n");
-	g_timer_stop (timer);
-	elapsed = g_timer_elapsed (timer, NULL);
-	if (failed > 0 || cfailed > 0){
-		g_print ("Results: total tests: %d, failed: %d, cfailed: %d (pass: %.2f%%)\n",
-				run, failed, cfailed, 100.0*(run-failed-cfailed)/run);
-	} else {
-		g_print ("Results: total tests: %d, all pass \n",  run);
-	}
-	g_print ("Elapsed time: %f secs (%f, %f), Code size: %d\n\n", elapsed,
-			elapsed - comp_time, comp_time, code_size);
-	*total += failed + cfailed;
-	*total_run += run;
-}
-static int
-mini_regression (MonoImage *image, int verbose, int *total_run)
-{
-	MonoMethod *method;
-	char *n;
-	GTimer *timer = g_timer_new ();
-	guint32 exclude = 0;
-	int total;
-	/* Note: mono_hwcap_init () called in mono_init () before we get here. */
-	mono_arch_cpu_optimizations (&exclude);
-	if (mini_stats_fd) {
-		fprintf (mini_stats_fd, "$stattitle = \'Mono Benchmark Results (various optimizations)\';\n");
-		fprintf (mini_stats_fd, "$graph->set_legend(qw(");
-		for (guint32 opt = 0; opt < G_N_ELEMENTS (opt_sets); opt++) {
-			guint32 opt_flags = opt_sets [opt];
-			n = mono_opt_descr (opt_flags);
-			if (!n [0])
-				n = (char *)"none";
-			if (opt)
-				fprintf (mini_stats_fd, " ");
-			fprintf (mini_stats_fd, "%s", n);
-		}
-		fprintf (mini_stats_fd, "));\n");
-		fprintf (mini_stats_fd, "@data = (\n");
-		fprintf (mini_stats_fd, "[");
-	}
-	/* load the metadata */
-	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
-		ERROR_DECL (error);
-		method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
-		if (!method) {
-			mono_error_cleanup (error);
-			continue;
-		}
-		mono_class_init_internal (method->klass);
-		if (!strncmp (method->name, "test_", 5) && mini_stats_fd) {
-			fprintf (mini_stats_fd, "\"%s\",", method->name);
-		}
-	}
-	if (mini_stats_fd)
-		fprintf (mini_stats_fd, "],\n");
-	total = 0;
-	*total_run = 0;
-	if (mono_do_single_method_regression) {
-		GSList *iter;
-		mini_regression_step (image, verbose, total_run, &total,
-				0, timer);
-		if (total)
-			return total;
-		g_print ("Single method regression: %d methods\n", g_slist_length (mono_single_method_list));
-		for (iter = mono_single_method_list; iter; iter = g_slist_next (iter)) {
-			char *method_name;
-			mono_current_single_method = (MonoMethod *)iter->data;
-			method_name = mono_method_full_name (mono_current_single_method, TRUE);
-			g_print ("Current single method: %s\n", method_name);
-			g_free (method_name);
-			mini_regression_step (image, verbose, total_run, &total,
-								  0, timer);
-			if (total)
-				return total;
-		}
-	} else {
-		for (guint32 opt = 0; opt < G_N_ELEMENTS (opt_sets); ++opt) {
-			/* aot-tests.cs need OPT_INTRINS enabled */
-			if (!strcmp ("aot-tests", image->assembly_name))
-				if (!(opt_sets [opt] & MONO_OPT_INTRINS))
-					continue;
-			if ((mono_aot_mode == MONO_AOT_MODE_FULL || mono_aot_mode == MONO_AOT_MODE_LLVMONLY_INTERP) && opt_sets [opt] != DEFAULT_OPTIMIZATIONS) {
-				continue;
-			}
-			mini_regression_step (image, verbose, total_run, &total,
-								  opt_sets [opt] & ~exclude, timer);
-		}
-	}
-	if (mini_stats_fd) {
-		fprintf (mini_stats_fd, ");\n");
-		fflush (mini_stats_fd);
-	}
-	g_timer_destroy (timer);
-	return total;
-}
-static int
-mini_regression_list (int verbose, int count, char *images [])
-{
-	int i, total, total_run, run;
-	MonoAssembly *ass;
-	total_run =  total = 0;
-	for (i = 0; i < count; ++i) {
-		MonoAssemblyOpenRequest req;
-		mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
-		ass = mono_assembly_request_open (images [i], &req, NULL);
-		if (!ass) {
-			g_warning ("failed to load assembly: %s", images [i]);
-			continue;
-		}
-		total += mini_regression (mono_assembly_get_image_internal (ass), verbose, &run);
-		total_run += run;
-	}
-	if (total > 0){
-		g_print ("Overall results: tests: %d, failed: %d, opt combinations: %d (pass: %.2f%%)\n",
-			 total_run, total, (int)G_N_ELEMENTS (opt_sets), 100.0*(total_run-total)/total_run);
-	} else {
-		g_print ("Overall results: tests: %d, 100%% pass, opt combinations: %d\n",
-			 total_run, (int)G_N_ELEMENTS (opt_sets));
-	}
-	return total;
-}
-static void
-interp_regression_step (MonoImage *image, int verbose, int *total_run, int *total, const guint32 *opt_flags, GTimer *timer)
-{
-	int result, expected, failed, cfailed, run;
-	double elapsed, transform_time;
-	MonoObject *result_obj;
-	int local_skip_index = 0;
-	const char *n = NULL;
-	if (opt_flags) {
-		mini_get_interp_callbacks ()->set_optimizations (*opt_flags);
-		n = interp_opt_descr (*opt_flags);
-	} else {
-		n = mono_interp_opts_string;
-	}
-	g_print ("Test run: image=%s, opts=%s\n", mono_image_get_filename (image), n);
-	cfailed = failed = run = 0;
-	transform_time = elapsed = 0.0;
-	mini_get_interp_callbacks ()->invalidate_transformed ();
-	g_timer_start (timer);
-	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
-		ERROR_DECL (error);
-		MonoMethod *method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
-		if (!method) {
-			mono_error_cleanup (error); /* FIXME don't swallow the error */
-			continue;
-		}
-		if (method_should_be_regression_tested (method, TRUE)) {
-			ERROR_DECL (interp_error);
-			MonoObject *exc = NULL;
-			if (do_regression_retries) {
-				++local_skip_index;
-				if(local_skip_index <= regression_test_skip_index)
-					continue;
-				++regression_test_skip_index;
-			}
-			result_obj = mini_get_interp_callbacks ()->runtime_invoke (method, NULL, NULL, &exc, interp_error);
-			if (!is_ok (interp_error)) {
-				cfailed++;
-				g_print ("Test '%s' execution failed.\n", method->name);
-			} else if (exc != NULL) {
-				g_print ("Exception in Test '%s' occurred:\n", method->name);
-				mono_object_describe (exc);
-				run++;
-				failed++;
-			} else {
-				result = *(gint32 *) mono_object_unbox_internal (result_obj);
-				expected = atoi (method->name + 5);  // FIXME: oh no.
-				run++;
-				if (result != expected) {
-					failed++;
-					g_print ("Test '%s' failed result (got %d, expected %d).\n", method->name, result, expected);
-				}
-			}
-		}
-	}
-	g_timer_stop (timer);
-	elapsed = g_timer_elapsed (timer, NULL);
-	if (failed > 0 || cfailed > 0){
-		g_print ("Results: total tests: %d, failed: %d, cfailed: %d (pass: %.2f%%)\n",
-				run, failed, cfailed, 100.0*(run-failed-cfailed)/run);
-	} else {
-		g_print ("Results: total tests: %d, all pass \n",  run);
-	}
-	g_print ("Elapsed time: %f secs (%f, %f)\n\n", elapsed,
-			elapsed - transform_time, transform_time);
-	*total += failed + cfailed;
-	*total_run += run;
-}
-static int
-interp_regression (MonoImage *image, int verbose, int *total_run)
-{
-	MonoMethod *method;
-	GTimer *timer = g_timer_new ();
-	int total;
-	/* load the metadata */
-	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
-		ERROR_DECL (error);
-		method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
-		if (!method) {
-			mono_error_cleanup (error);
-			continue;
-		}
-		mono_class_init_internal (method->klass);
-	}
-	total = 0;
-	*total_run = 0;
-	if (mono_interp_opts_string) {
-		/* explicit option requested*/
-		interp_regression_step (image, verbose, total_run, &total, NULL, timer);
-	} else {
-		for (int opt = 0; opt < G_N_ELEMENTS (interp_opt_sets); ++opt)
-			interp_regression_step (image, verbose, total_run, &total, &interp_opt_sets [opt], timer);
-	}
-	g_timer_destroy (timer);
-	return total;
-}
-/* TODO: merge this code with the regression harness of the JIT */
-static int
-mono_interp_regression_list (int verbose, int count, char *images [])
-{
-	int i, total, total_run, run;
-	total_run = total = 0;
-	for (i = 0; i < count; ++i) {
-		MonoAssemblyOpenRequest req;
-		mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
-		MonoAssembly *ass = mono_assembly_request_open (images [i], &req, NULL);
-		if (!ass) {
-			g_warning ("failed to load assembly: %s", images [i]);
-			continue;
-		}
-		total += interp_regression (mono_assembly_get_image_internal (ass), verbose, &run);
-		total_run += run;
-	}
-	if (total > 0) {
-		g_print ("Overall results: tests: %d, failed: %d (pass: %.2f%%)\n", total_run, total, 100.0*(total_run-total)/total_run);
-	} else {
-		g_print ("Overall results: tests: %d, 100%% pass\n", total_run);
-	}
-	return total;
-}
-#ifdef MONO_JIT_INFO_TABLE_TEST
-typedef struct _JitInfoData
-{
-	guint start;
-	guint length;
-	MonoJitInfo *ji;
-	struct _JitInfoData *next;
-} JitInfoData;
-typedef struct
-{
-	guint start;
-	guint length;
-	int num_datas;
-	JitInfoData *data;
-} Region;
-typedef struct
-{
-	int num_datas;
-	int num_regions;
-	Region *regions;
-	int num_frees;
-	JitInfoData *frees;
-} ThreadData;
-static int num_threads;
-static ThreadData *thread_datas;
-static MonoDomain *test_domain;
-static JitInfoData*
-alloc_random_data (Region *region)
-{
-	JitInfoData **data;
-	JitInfoData *prev;
-	guint prev_end;
-	guint next_start;
-	guint max_len;
-	JitInfoData *d;
-	int num_retries = 0;
-	int pos, i;
- restart:
-	prev = NULL;
-	data = &region->data;
-	pos = random () % (region->num_datas + 1);
-	i = 0;
-	while (*data != NULL) {
-		if (i++ == pos)
-			break;
-		prev = *data;
-		data = &(*data)->next;
-	}
-	if (prev == NULL)
-		g_assert (*data == region->data);
-	else
-		g_assert (prev->next == *data);
-	if (prev == NULL)
-		prev_end = region->start;
-	else
-		prev_end = prev->start + prev->length;
-	if (*data == NULL)
-		next_start = region->start + region->length;
-	else
-		next_start = (*data)->start;
-	g_assert (prev_end <= next_start);
-	max_len = next_start - prev_end;
-	if (max_len < 128) {
-		if (++num_retries >= 10)
-			return NULL;
-		goto restart;
-	}
-	if (max_len > 1024)
-		max_len = 1024;
-	d = g_new0 (JitInfoData, 1);
-	d->start = prev_end + random () % (max_len / 2);
-	d->length = random () % MIN (max_len, next_start - d->start) + 1;
-	g_assert (d->start >= prev_end && d->start + d->length <= next_start);
-	d->ji = g_new0 (MonoJitInfo, 1);
-	d->ji->d.method = (MonoMethod*) 0xABadBabe;
-	d->ji->code_start = (gpointer)(gulong) d->start;
-	d->ji->code_size = d->length;
-	d->ji->cas_inited = 1;	/* marks an allocated jit info */
-	d->next = *data;
-	*data = d;
-	++region->num_datas;
-	return d;
-}
-static JitInfoData**
-choose_random_data (Region *region)
-{
-	int n;
-	int i;
-	JitInfoData **d;
-	g_assert (region->num_datas > 0);
-	n = random () % region->num_datas;
-	for (d = &region->data, i = 0;
-	     i < n;
-	     d = &(*d)->next, ++i)
-		;
-	return d;
-}
-static Region*
-choose_random_region (ThreadData *td)
-{
-	return &td->regions [random () % td->num_regions];
-}
-static ThreadData*
-choose_random_thread (void)
-{
-	return &thread_datas [random () % num_threads];
-}
-static void
-free_jit_info_data (ThreadData *td, JitInfoData *free)
-{
-	free->next = td->frees;
-	td->frees = free;
-	if (++td->num_frees >= 1000) {
-		int i;
-		for (i = 0; i < 500; ++i)
-			free = free->next;
-		while (free->next != NULL) {
-			JitInfoData *next = free->next->next;
-			g_free (free->next);
-			free->next = next;
-			--td->num_frees;
-		}
-	}
-}
-#define NUM_THREADS		8
-#define REGIONS_PER_THREAD	10
-#define REGION_SIZE		0x10000
-#define MAX_ADDR		(REGION_SIZE * REGIONS_PER_THREAD * NUM_THREADS)
-#define MODE_ALLOC	1
-#define MODE_FREE	2
-static void
-test_thread_func (gpointer void_arg)
-{
-	ThreadData* td = (ThreadData*)void_arg;
-	int mode = MODE_ALLOC;
-	int i = 0;
-	gulong lookup_successes = 0, lookup_failures = 0;
-	int thread_num = (int)(td - thread_datas);
-	gboolean modify_thread = thread_num < NUM_THREADS / 2; /* only half of the threads modify the table */
-	for (;;) {
-		int alloc;
-		int lookup = 1;
-		if (td->num_datas == 0) {
-			lookup = 0;
-			alloc = 1;
-		} else if (modify_thread && random () % 1000 < 5) {
-			lookup = 0;
-			if (mode == MODE_ALLOC)
-				alloc = (random () % 100) < 70;
-			else if (mode == MODE_FREE)
-				alloc = (random () % 100) < 30;
-		}
-		if (lookup) {
-			/* modify threads sometimes look up their own jit infos */
-			if (modify_thread && random () % 10 < 5) {
-				Region *region = choose_random_region (td);
-				if (region->num_datas > 0) {
-					JitInfoData **data = choose_random_data (region);
-					guint pos = (*data)->start + random () % (*data)->length;
-					MonoJitInfo *ji;
-					ji = mono_jit_info_table_find_internal ((char*)(gsize)pos, TRUE, FALSE);
-					g_assert (ji->cas_inited);
-					g_assert ((*data)->ji == ji);
-				}
-			} else {
-				int pos = random () % MAX_ADDR;
-				char *addr = (char*)(uintptr_t)pos;
-				MonoJitInfo *ji;
-				ji = mono_jit_info_table_find_internal (addr, TRUE, FALSE);
-				/*
-				 * FIXME: We are actually not allowed
-				 * to do this.  By the time we examine
-				 * the ji another thread might already
-				 * have removed it.
-				 */
-				if (ji != NULL) {
-					g_assert (addr >= (char*)ji->code_start && addr < (char*)ji->code_start + ji->code_size);
-					++lookup_successes;
-				} else
-					++lookup_failures;
-			}
-		} else if (alloc) {
-			JitInfoData *data = alloc_random_data (choose_random_region (td));
-			if (data != NULL) {
-				mono_jit_info_table_add (domain, data->ji);
-				++td->num_datas;
-			}
-		} else {
-			Region *region = choose_random_region (td);
-			if (region->num_datas > 0) {
-				JitInfoData **data = choose_random_data (region);
-				JitInfoData *free;
-				mono_jit_info_table_remove (domain, (*data)->ji);
-				free = *data;
-				*data = (*data)->next;
-				free_jit_info_data (td, free);
-				--region->num_datas;
-				--td->num_datas;
-			}
-		}
-		if (++i % 100000 == 0) {
-			int j;
-			g_print ("num datas %d (%ld - %ld): %d", (int)(td - thread_datas),
-				 lookup_successes, lookup_failures, td->num_datas);
-			for (j = 0; j < td->num_regions; ++j)
-				g_print ("  %d", td->regions [j].num_datas);
-			g_print ("\n");
-		}
-		if (td->num_datas < 100)
-			mode = MODE_ALLOC;
-		else if (td->num_datas > 2000)
-			mode = MODE_FREE;
-	}
-}
-/*
-static void
-small_id_thread_func (gpointer arg)
-{
-	MonoThread *thread = mono_thread_current ();
-	MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();
-	g_print ("my small id is %d\n", (int)thread->small_id);
-	mono_hazard_pointer_clear (hp, 1);
-	sleep (3);
-	g_print ("done %d\n", (int)thread->small_id);
-}
-*/
-static void
-jit_info_table_test (MonoDomain *domain)
-{
-	ERROR_DECL (error);
-	int i;
-	g_print ("testing jit_info_table\n");
-	num_threads = NUM_THREADS;
-	thread_datas = g_new0 (ThreadData, num_threads);
-	for (i = 0; i < num_threads; ++i) {
-		int j;
-		thread_datas [i].num_regions = REGIONS_PER_THREAD;
-		thread_datas [i].regions = g_new0 (Region, REGIONS_PER_THREAD);
-		for (j = 0; j < REGIONS_PER_THREAD; ++j) {
-			thread_datas [i].regions [j].start = (num_threads * j + i) * REGION_SIZE;
-			thread_datas [i].regions [j].length = REGION_SIZE;
-		}
-	}
-	test_domain = domain;
-	/*
-	for (i = 0; i < 72; ++i)
-		mono_thread_create (small_id_thread_func, NULL);
-	sleep (2);
-	*/
-	for (i = 0; i < num_threads; ++i) {
-		mono_thread_create_checked ((MonoThreadStart)test_thread_func, &thread_datas [i], error);
-		mono_error_assert_ok (error);
-	}
-}
-#endif
-enum {
-	DO_BENCH,
-	DO_REGRESSION,
-	DO_SINGLE_METHOD_REGRESSION,
-	DO_COMPILE,
-	DO_EXEC,
-	DO_DRAW,
-	DO_DEBUGGER
-};
-typedef struct CompileAllThreadArgs {
-	MonoAssembly *ass;
-	int verbose;
-	guint32 opts;
-	guint32 recompilation_times;
-} CompileAllThreadArgs;
-static void
-compile_all_methods_thread_main_inner (CompileAllThreadArgs *args)
-{
-	MonoAssembly *ass = args->ass;
-	int verbose = args->verbose;
-	MonoImage *image = mono_assembly_get_image_internal (ass);
-	MonoMethod *method;
-	MonoCompile *cfg;
-	int count = 0, fail_count = 0;
-	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
-		ERROR_DECL (error);
-		guint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);
-		MonoMethodSignature *sig;
-		if (mono_metadata_has_generic_params (image, token))
-			continue;
-		method = mono_get_method_checked (image, token, NULL, NULL, error);
-		if (!method) {
-			mono_error_cleanup (error); /* FIXME don't swallow the error */
-			continue;
-		}
-		if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
-		    (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||
-		    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||
-		    (method->flags & METHOD_ATTRIBUTE_ABSTRACT))
-			continue;
-		if (mono_class_is_gtd (method->klass))
-			continue;
-		sig = mono_method_signature_internal (method);
-		if (!sig) {
-			char * desc = mono_method_full_name (method, TRUE);
-			g_print ("Could not retrieve method signature for %s\n", desc);
-			g_free (desc);
-			fail_count ++;
-			continue;
-		}
-		if (sig->has_type_parameters)
-			continue;
-		count++;
-		if (verbose) {
-			char * desc = mono_method_full_name (method, TRUE);
-			g_print ("Compiling %d %s\n", count, desc);
-			g_free (desc);
-		}
-		if (mono_use_interpreter) {
-			mini_get_interp_callbacks ()->create_method_pointer (method, TRUE, error);
-			if (verbose && !is_ok (error))
-				g_print ("Compilation of %s failed\n", mono_method_full_name (method, TRUE));
-		} else {
-			cfg = mini_method_compile (method, mono_get_optimizations_for_method (method, args->opts), (JitFlags)JIT_FLAG_DISCARD_RESULTS, 0, -1);
-			if (cfg->exception_type != MONO_EXCEPTION_NONE) {
-				const char *msg = cfg->exception_message;
-				if (cfg->exception_type == MONO_EXCEPTION_MONO_ERROR)
-					msg = mono_error_get_message (cfg->error);
-				g_print ("Compilation of %s failed with exception '%s':\n", mono_method_full_name (cfg->method, TRUE), msg);
-				fail_count ++;
-			}
-			mono_destroy_compile (cfg);
-		}
-	}
-	if (fail_count)
-		exit (1);
-}
-static void
-compile_all_methods_thread_main (gpointer void_args)
-{
-	CompileAllThreadArgs *args = (CompileAllThreadArgs*)void_args;
-	guint32 i;
-	for (i = 0; i < args->recompilation_times; ++i)
-		compile_all_methods_thread_main_inner (args);
-}
-static void
-compile_all_methods (MonoAssembly *ass, int verbose, guint32 opts, guint32 recompilation_times)
-{
-	ERROR_DECL (error);
-	CompileAllThreadArgs args;
-	args.ass = ass;
-	args.verbose = verbose;
-	args.opts = opts;
-	args.recompilation_times = recompilation_times;
-	/*
-	 * Need to create a mono thread since compilation might trigger
-	 * running of managed code.
-	 */
-	mono_thread_create_checked ((MonoThreadStart)compile_all_methods_thread_main, &args, error);
-	mono_error_assert_ok (error);
-	mono_thread_manage_internal ();
-}
-/**
- * mono_jit_exec:
- * \param assembly reference to an assembly
- * \param argc argument count
- * \param argv argument vector
- * Start execution of a program.
- */
-int
-mono_jit_exec (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[])
-{
-	int rv;
-	MONO_ENTER_GC_UNSAFE;
-	rv = mono_jit_exec_internal (domain, assembly, argc, argv);
-	MONO_EXIT_GC_UNSAFE;
-	return rv;
-}
-int
-mono_jit_exec_internal (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[])
-{
-	MONO_REQ_GC_UNSAFE_MODE;
-	ERROR_DECL (error);
-	MonoImage *image = mono_assembly_get_image_internal (assembly);
-    if (!mono_runtime_run_module_cctor(image, error)) {
-        g_print ("Failed to run module constructor due to %s\n", mono_error_get_message (error));
-        return 1;
-    }
-	MonoMethod *method;
-	guint32 entry = mono_image_get_entry_point (image);
-	if (!entry) {
-		g_print ("Assembly '%s' doesn't have an entry point.\n", mono_image_get_filename (image));
-		/* FIXME: remove this silly requirement. */
-		mono_environment_exitcode_set (1);
-		return 1;
-	}
-	method = mono_get_method_checked (image, entry, NULL, NULL, error);
-	if (method == NULL){
-		g_print ("The entry point method could not be loaded due to %s\n", mono_error_get_message (error));
-		mono_error_cleanup (error);
-		mono_environment_exitcode_set (1);
-		return 1;
-	}
-	if (mono_llvm_only) {
-		MonoObject *exc = NULL;
-		int res;
-		res = mono_runtime_try_run_main (method, argc, argv, &exc);
-		if (exc) {
-			mono_unhandled_exception_internal (exc);
-			mono_invoke_unhandled_exception_hook (exc);
-			g_assert_not_reached ();
-		}
-		return res;
-	} else {
-		int res = mono_runtime_run_main_checked (method, argc, argv, error);
-		if (!is_ok (error)) {
-			MonoException *ex = mono_error_convert_to_exception (error);
-			if (ex) {
-				mono_unhandled_exception_internal (&ex->object);
-				mono_invoke_unhandled_exception_hook (&ex->object);
-				g_assert_not_reached ();
-			}
-		}
-		return res;
-	}
-}
-typedef struct
-{
-	MonoDomain *domain;
-	const char *file;
-	int argc;
-	char **argv;
-	guint32 opts;
-	char *aot_options;
-} MainThreadArgs;
-static void main_thread_handler (gpointer user_data)
-{
-	MainThreadArgs *main_args = (MainThreadArgs *)user_data;
-	MonoAssembly *assembly;
-	if (mono_compile_aot) {
-		int i, res;
-		gpointer *aot_state = NULL;
-		/* Treat the other arguments as assemblies to compile too */
-		for (i = 0; i < main_args->argc; ++i) {
-			assembly = mono_domain_assembly_open_internal (mono_alc_get_default (), main_args->argv [i]);
-			if (!assembly) {
-				fprintf (stderr, "Can not open image %s\n", main_args->argv [i]);
-				exit (1);
-			}
-			/* Check that the assembly loaded matches the filename */
-			{
-				MonoImageOpenStatus status;
-				MonoImage *img;
-				img = mono_image_open (main_args->argv [i], &status);
-				if (img && g_strcasecmp (img->name, assembly->image->name)) {
-					fprintf (stderr, "Error: Loaded assembly '%s' doesn't match original file name '%s'. Set MONO_PATH to the assembly's location.\n", assembly->image->name, img->name);
-					exit (1);
-				}
-			}
-			res = mono_compile_assembly (assembly, main_args->opts, main_args->aot_options, &aot_state);
-			if (res != 0) {
-				fprintf (stderr, "AOT of image %s failed.\n", main_args->argv [i]);
-				exit (1);
-			}
-		}
-		if (aot_state) {
-			res = mono_compile_deferred_assemblies (main_args->opts, main_args->aot_options, &aot_state);
-			if (res != 0) {
-				fprintf (stderr, "AOT of mode-specific deferred assemblies failed.\n");
-				exit (1);
-			}
-		}
-	} else {
-		assembly = mono_domain_assembly_open_internal (mono_alc_get_default (), main_args->file);
-		if (!assembly){
-			fprintf (stderr, "Can not open image %s\n", main_args->file);
-			exit (1);
-		}
-		/*
-		 * This must be done in a thread managed by mono since it can invoke
-		 * managed code.
-		 */
-		if (main_args->opts & MONO_OPT_PRECOMP)
-			mono_precompile_assemblies ();
-		mono_jit_exec (main_args->domain, assembly, main_args->argc, main_args->argv);
-	}
-}
-static int
-load_agent (MonoDomain *domain, char *desc)
-{
-	ERROR_DECL (error);
-	char* col = strchr (desc, ':');
-	char *agent, *args;
-	MonoAssembly *agent_assembly;
-	MonoImage *image;
-	MonoMethod *method;
-	guint32 entry;
-	MonoArray *main_args;
-	gpointer pa [1];
-	MonoImageOpenStatus open_status;
-	if (col) {
-		agent = (char *)g_memdup (desc, GPTRDIFF_TO_UINT (col - desc + 1));
-		agent [col - desc] = '\0';
-		args = col + 1;
-	} else {
-		agent = g_strdup (desc);
-		args = NULL;
-	}
-	MonoAssemblyOpenRequest req;
-	mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
-	agent_assembly = mono_assembly_request_open (agent, &req, &open_status);
-	if (!agent_assembly) {
-		fprintf (stderr, "Cannot open agent assembly '%s': %s.\n", agent, mono_image_strerror (open_status));
-		g_free (agent);
-		return 2;
-	}
-	/*
-	 * Can't use mono_jit_exec (), as it sets things which might confuse the
-	 * real Main method.
-	 */
-	image = mono_assembly_get_image_internal (agent_assembly);
-	entry = mono_image_get_entry_point (image);
-	if (!entry) {
-		g_print ("Assembly '%s' doesn't have an entry point.\n", mono_image_get_filename (image));
-		g_free (agent);
-		return 1;
-	}
-	method = mono_get_method_checked (image, entry, NULL, NULL, error);
-	if (method == NULL){
-		g_print ("The entry point method of assembly '%s' could not be loaded due to %s\n", agent, mono_error_get_message (error));
-		mono_error_cleanup (error);
-		g_free (agent);
-		return 1;
-	}
-	mono_thread_set_main (mono_thread_current ());
-	if (args) {
-		main_args = (MonoArray*)mono_array_new_checked (mono_defaults.string_class, 1, error);
-		if (main_args) {
-			MonoString *str = mono_string_new_checked (args, error);
-			if (str)
-				mono_array_set_internal (main_args, MonoString*, 0, str);
-		}
-	} else {
-		main_args = (MonoArray*)mono_array_new_checked (mono_defaults.string_class, 0, error);
-	}
-	if (!main_args) {
-		g_print ("Could not allocate array for main args of assembly '%s' due to %s\n", agent, mono_error_get_message (error));
-		mono_error_cleanup (error);
-		g_free (agent);
-		return 1;
-	}
-	pa [0] = main_args;
-	/* Pass NULL as 'exc' so unhandled exceptions abort the runtime */
-	mono_runtime_invoke_checked (method, NULL, pa, error);
-	if (!is_ok (error)) {
-		g_print ("The entry point method of assembly '%s' could not execute due to %s\n", agent, mono_error_get_message (error));
-		mono_error_cleanup (error);
-		g_free (agent);
-		return 1;
-	}
-	g_free (agent);
-	return 0;
-}
-static void
-mini_usage_jitdeveloper (void)
-{
-	int i;
-	fprintf (stdout,
-		 "Runtime and JIT debugging options:\n"
-		 "    --apply-bindings=FILE  Apply assembly bindings from FILE (only for AOT)\n"
-		 "    --breakonex            Inserts a breakpoint on exceptions\n"
-		 "    --break METHOD         Inserts a breakpoint at METHOD entry\n"
-		 "    --break-at-bb METHOD N Inserts a breakpoint in METHOD at BB N\n"
-		 "    --compile METHOD       Just compile METHOD in assembly\n"
-		 "    --compile-all=N        Compiles all the methods in the assembly multiple times (default: 1)\n"
-		 "    --ncompile N           Number of times to compile METHOD (default: 1)\n"
-		 "    --print-vtable         Print the vtable of all used classes\n"
-		 "    --regression           Runs the regression test contained in the assembly\n"
-		 "    --single-method=OPTS   Runs regressions with only one method optimized with OPTS at any time\n"
-		 "    --statfile FILE        Sets the stat file to FILE\n"
-		 "    --stats                Print statistics about the JIT operations\n"
-		 "    --inject-async-exc METHOD OFFSET Inject an asynchronous exception at METHOD\n"
-		 "    --verify-all           Run the verifier on all assemblies and methods\n"
-		 "    --full-aot             Avoid JITting any code\n"
-		 "    --llvmonly             Use LLVM compiled code only\n"
-		 "    --agent=ASSEMBLY[:ARG] Loads the specific agent assembly and executes its Main method with the given argument before loading the main assembly.\n"
-		 "    --no-x86-stack-align   Don't align stack on x86\n"
-		 "\n"
-		 "The options supported by MONO_DEBUG can also be passed on the command line.\n"
-		 "\n"
-		 "Other options:\n"
-		 "    --graph[=TYPE] METHOD  Draws a graph of the specified method:\n");
-	for (i = 0; i < G_N_ELEMENTS (graph_names); ++i) {
-		fprintf (stdout, "                           %-10s %s\n", graph_names [i].name, graph_names [i].desc);
-	}
-}
-static void
-mini_usage_list_opt (void)
-{
-	int i;
-	for (i = 0; i < G_N_ELEMENTS (opt_names); ++i)
-		fprintf (stdout, "                           %-10s %s\n", optflag_get_name (i), optflag_get_desc (i));
-}
-static void
-mini_usage (void)
-{
-	fprintf (stdout,
-		"Usage is: mono [options] program [program-options]\n"
-		"\n"
-		"Development:\n"
-		"    --aot[=<options>]      Compiles the assembly to native code\n"
-		"    --debug=ignore         Disable debugging support (on by default)\n"
-		"    --debug=[<options>]    Disable debugging support or enable debugging extras, use --help-debug for details\n"
- 		"    --debugger-agent=options Enable the debugger agent\n"
-		"    --profile[=profiler]   Runs in profiling mode with the specified profiler module\n"
-		"    --trace[=EXPR]         Enable tracing, use --help-trace for details\n"
-#ifdef __linux__
-		"    --jitmap               Output a jit method map to /tmp/perf-PID.map\n"
-#endif
-#ifdef ENABLE_JIT_DUMP
-		"    --jitdump              Output a jitdump file to /tmp/jit-PID.dump\n"
-#endif
-		"    --help-devel           Shows more options available to developers\n"
-		"\n"
-		"Runtime:\n"
-		"    --config FILE          Loads FILE as the Mono config\n"
-		"    --verbose, -v          Increases the verbosity level\n"
-		"    --help, -h             Show usage information\n"
-		"    --version, -V          Show version information\n"
-		"    --version=number       Show version number\n"
-		"    --runtime=VERSION      Use the VERSION runtime, instead of autodetecting\n"
-		"    --optimize=OPT         Turns on or off a specific optimization\n"
-		"                           Use --list-opt to get a list of optimizations\n"
-		"    --attach=OPTIONS       Pass OPTIONS to the attach agent in the runtime.\n"
-		"                           Currently the only supported option is 'disable'.\n"
-		"    --llvm, --nollvm       Controls whenever the runtime uses LLVM to compile code.\n"
-	        "    --gc=[sgen,boehm]      Select SGen or Boehm GC (runs mono or mono-sgen)\n"
-#ifdef TARGET_OSX
-		"    --arch=[32,64]         Select architecture (runs mono32 or mono64)\n"
-#endif
-#ifdef HOST_WIN32
-	        "    --mixed-mode           Enable mixed-mode image support.\n"
-#endif
-		"    --handlers             Install custom handlers, use --help-handlers for details.\n"
-		"    --aot-path=PATH        List of additional directories to search for AOT images.\n"
-	  );
-	g_print ("\nOptions:\n");
-	mono_options_print_usage ();
-}
-static void
-mini_trace_usage (void)
-{
-	fprintf (stdout,
-		 "Tracing options:\n"
-		 "   --trace[=EXPR]        Trace every call, optional EXPR controls the scope\n"
-		 "\n"
-		 "EXPR is composed of:\n"
-		 "    all                  All assemblies\n"
-		 "    none                 No assemblies\n"
-		 "    program              Entry point assembly\n"
-		 "    assembly             Specifies an assembly\n"
-		 "    wrapper              All wrappers bridging native and managed code\n"
-		 "    M:Type:Method        Specifies a method\n"
-		 "    N:Namespace          Specifies a namespace\n"
-		 "    T:Type               Specifies a type\n"
-		 "    E:Type               Specifies stack traces for an exception type\n"
-		 "    EXPR                 Includes expression\n"
-		 "    -EXPR                Excludes expression\n"
-		 "    EXPR,EXPR            Multiple expressions\n"
-		 "    disabled             Don't print any output until toggled via SIGUSR2\n");
-}
-static void
-mini_debug_usage (void)
-{
-	fprintf (stdout,
-		 "Debugging options:\n"
-		 "   --debug[=OPTIONS]     Disable debugging support or enable debugging extras, optional OPTIONS is a comma\n"
-		 "                         separated list of options\n"
-		 "\n"
-		 "OPTIONS is composed of:\n"
-		 "    ignore               Disable debugging support (on by default).\n"
-		 "    casts                Enable more detailed InvalidCastException messages.\n"
-		 "    mdb-optimizations    Disable some JIT optimizations which are normally\n"
-		 "                         disabled when running inside the debugger.\n"
-		 "                         This is useful if you plan to attach to the running\n"
-		 "                         process with the debugger.\n");
-}
-#if defined(MONO_ARCH_ARCHITECTURE)
-/* Redefine MONO_ARCHITECTURE to include more information */
-#undef MONO_ARCHITECTURE
-#define MONO_ARCHITECTURE MONO_ARCH_ARCHITECTURE
-#endif
-static char *
-mono_get_version_info (void)
-{
-	GString *output;
-	output = g_string_new ("");
-#ifdef MONO_KEYWORD_THREAD
-	g_string_append_printf (output, "\tTLS:           __thread\n");
-#else
-	g_string_append_printf (output, "\tTLS:           \n");
-#endif /* MONO_KEYWORD_THREAD */
-#ifdef MONO_ARCH_SIGSEGV_ON_ALTSTACK
-	g_string_append_printf (output, "\tSIGSEGV:       altstack\n");
-#else
-	g_string_append_printf (output, "\tSIGSEGV:       normal\n");
-#endif
-	g_string_append_printf (output, "\tArchitecture:  %s\n", MONO_ARCHITECTURE);
-	g_string_append_printf (output, "\tDisabled:      %s\n", DISABLED_FEATURES);
-	g_string_append_printf (output, "\tMisc:          ");
-#ifdef MONO_SMALL_CONFIG
-	g_string_append_printf (output, "smallconfig ");
-#endif
-#if !defined(DISABLE_SDB)
-	g_string_append_printf (output, "softdebug ");
-#endif
-	g_string_append_printf (output, "\n");
-#ifndef DISABLE_INTERPRETER
-	g_string_append_printf (output, "\tInterpreter:   yes\n");
-#else
-	g_string_append_printf (output, "\tInterpreter:   no\n");
-#endif
-#ifdef MONO_ARCH_LLVM_SUPPORTED
-#ifdef ENABLE_LLVM
-	g_string_append_printf (output, "\tLLVM:          yes(%d)\n", LLVM_API_VERSION);
-#else
-	g_string_append_printf (output, "\tLLVM:          supported, not enabled.\n");
-#endif
-#endif
-	mono_threads_suspend_policy_init ();
-	g_string_append_printf (output, "\tSuspend:       %s\n", mono_threads_suspend_policy_name (mono_threads_suspend_policy ()));
-	return g_string_free (output, FALSE);
-}
-#ifndef MONO_ARCH_AOT_SUPPORTED
-#define error_if_aot_unsupported() do {fprintf (stderr, "AOT compilation is not supported on this platform.\n"); exit (1);} while (0)
-#else
-#define error_if_aot_unsupported()
-#endif
-static gboolean enable_debugging;
-static void
-enable_runtime_stats (void)
-{
-	mono_counters_enable (-1);
-	mono_atomic_store_bool (&mono_stats.enabled, TRUE);
-	mono_atomic_store_bool (&mono_jit_stats.enabled, TRUE);
-}
-static MonoMethodDesc *
-parse_qualified_method_name (char *method_name)
-{
-	if (strlen (method_name) == 0) {
-		g_printerr ("Couldn't parse empty method name.");
-		exit (1);
-	}
-	MonoMethodDesc *result = mono_method_desc_new (method_name, TRUE);
-	if (!result) {
-		g_printerr ("Couldn't parse method name: %s\n", method_name);
-		exit (1);
-	}
-	return result;
-}
-/**
- * mono_jit_parse_options:
- *
- * Process the command line options in \p argv as done by the runtime executable.
- * This should be called before \c mono_jit_init.
- */
-void
-mono_jit_parse_options (int argc, char * argv[])
-{
-	ERROR_DECL (error);
-	int i;
-	char *trace_options = NULL;
-	int mini_verbose_level = 0;
-	guint32 opt;
-	/* Make a copy since mono_options_parse_options () modifies argv */
-	char **copy_argv = g_new0 (char*, argc);
-	memcpy (copy_argv, argv, sizeof (char*) * argc);
-	argv = copy_argv;
-	mono_options_parse_options ((const char**)argv, argc, &argc, error);
-	if (!is_ok (error)) {
-		g_printerr ("%s", mono_error_get_message (error));
-		mono_error_cleanup (error);
-	}
-	/*
-	 * Some options have no effect here, since they influence the behavior of
-	 * mono_main ().
-	 */
-	opt = mono_parse_default_optimizations (NULL);
-	/* FIXME: Avoid code duplication */
-	for (i = 0; i < argc; ++i) {
-		if (argv [i] [0] != '-')
-			break;
-		if (strncmp (argv [i], "--debugger-agent=", 17) == 0) {
-			MonoDebugOptions *debug_opt = mini_get_debug_options ();
-			mono_debugger_agent_parse_options (g_strdup (argv [i] + 17));
-			debug_opt ->mdb_optimizations = TRUE;
-			enable_debugging = TRUE;
-		} else if (!strcmp (argv [i], "--soft-breakpoints")) {
-			MonoDebugOptions *debug_opt  = mini_get_debug_options ();
-			debug_opt ->soft_breakpoints = TRUE;
-			debug_opt ->explicit_null_checks = TRUE;
-		} else if (strncmp (argv [i], "--optimize=", 11) == 0) {
-			opt = parse_optimizations (opt, argv [i] + 11, TRUE);
-			mono_set_optimizations (opt);
-		} else if (strncmp (argv [i], "-O=", 3) == 0) {
-			opt = parse_optimizations (opt, argv [i] + 3, TRUE);
-			mono_set_optimizations (opt);
-		} else if (strcmp (argv [i], "--trace") == 0) {
-			trace_options = (char*)"";
-		} else if (strncmp (argv [i], "--trace=", 8) == 0) {
-			trace_options = &argv [i][8];
-		} else if (strcmp (argv [i], "--verbose") == 0 || strcmp (argv [i], "-v") == 0) {
-			mini_verbose_level++;
-		} else if (strcmp (argv [i], "--breakonex") == 0) {
-			MonoDebugOptions *debug_opt = mini_get_debug_options ();
-			debug_opt->break_on_exc = TRUE;
-		} else if (strcmp (argv [i], "--stats") == 0) {
-			enable_runtime_stats ();
-		} else if (strncmp (argv [i], "--stats=", 8) == 0) {
-			enable_runtime_stats ();
-			if (mono_stats_method_desc)
-				g_free (mono_stats_method_desc);
-			mono_stats_method_desc = parse_qualified_method_name (argv [i] + 8);
-		} else if (strcmp (argv [i], "--break") == 0) {
-			if (i+1 >= argc){
-				fprintf (stderr, "Missing method name in --break command line option\n");
-				exit (1);
-			}
-			if (!mono_debugger_insert_breakpoint (argv [++i], FALSE))
-				fprintf (stderr, "Error: invalid method name '%s'\n", argv [i]);
-		} else if (strncmp (argv[i], "--gc-params=", 12) == 0) {
-			mono_gc_params_set (argv[i] + 12);
-		} else if (strncmp (argv[i], "--gc-debug=", 11) == 0) {
-			mono_gc_debug_set (argv[i] + 11);
-		} else if (strcmp (argv [i], "--llvm") == 0) {
-#ifndef MONO_ARCH_LLVM_SUPPORTED
-			fprintf (stderr, "Mono Warning: --llvm not supported on this platform.\n");
-#elif !defined(ENABLE_LLVM)
-			fprintf (stderr, "Mono Warning: --llvm not enabled in this runtime.\n");
-#else
-			mono_use_llvm = TRUE;
-#endif
-		} else if (strcmp (argv [i], "--profile") == 0) {
-			mini_add_profiler_argument (NULL);
-		} else if (strncmp (argv [i], "--profile=", 10) == 0) {
-			mini_add_profiler_argument (argv [i] + 10);
-		} else if (argv [i][0] == '-' && argv [i][1] == '-' && mini_parse_debug_option (argv [i] + 2)) {
-		} else {
-			fprintf (stderr, "Unsupported command line option: '%s'\n", argv [i]);
-			exit (1);
-		}
-	}
-	if (trace_options != NULL) {
-		/*
-		 * Need to call this before mini_init () so we can trace methods
-		 * compiled there too.
-		 */
-		mono_jit_trace_calls = mono_trace_set_options (trace_options);
-		if (mono_jit_trace_calls == NULL)
-			exit (1);
-	}
-	if (mini_verbose_level)
-		mono_set_verbose_level (mini_verbose_level);
-	/* Free the copy */
-	g_free (argv);
-}
-static void
-mono_set_use_smp (int use_smp)
-{
-#if HAVE_SCHED_SETAFFINITY
-	if (!use_smp) {
-		unsigned long proc_mask = 1;
-		sched_setaffinity (getpid(), sizeof (unsigned long), (const cpu_set_t *)&proc_mask);
-	}
-#endif
-}
-static void
-switch_gc (char* argv[], const char* target_gc)
-{
-	GString *path;
-	if (!strcmp (mono_gc_get_gc_name (), target_gc)) {
-		return;
-	}
-	path = g_string_new (argv [0]);
-	/*Running mono without any argument*/
-	if (strstr (argv [0], "-sgen"))
-		g_string_truncate (path, path->len - 5);
-	else if (strstr (argv [0], "-boehm"))
-		g_string_truncate (path, path->len - 6);
-	g_string_append_c (path, '-');
-	g_string_append (path, target_gc);
-#ifdef HAVE_EXECVP
-	execvp (path->str, argv);
-	fprintf (stderr, "Error: Failed to switch to %s gc. mono-%s is not installed.\n", target_gc, target_gc);
-#else
-	fprintf (stderr, "Error: --gc=<NAME> option not supported on this platform.\n");
-#endif
-}
-#ifdef TARGET_OSX
-/*
- * tries to increase the minimum number of files, if the number is below 1024
- */
-static void
-darwin_change_default_file_handles ()
-{
-	struct rlimit limit;
-	if (getrlimit (RLIMIT_NOFILE, &limit) == 0){
-		if (limit.rlim_cur < 1024){
-			limit.rlim_cur = MAX(1024,limit.rlim_cur);
-			setrlimit (RLIMIT_NOFILE, &limit);
-		}
-	}
-}
-static void
-switch_arch (char* argv[], const char* target_arch)
-{
-	GString *path;
-	gsize arch_offset;
-	if ((strcmp (target_arch, "32") == 0 && strcmp (MONO_ARCHITECTURE, "x86") == 0) ||
-		(strcmp (target_arch, "64") == 0 && strcmp (MONO_ARCHITECTURE, "amd64") == 0)) {
-		return; /* matching arch loaded */
-	}
-	path = g_string_new (argv [0]);
-	arch_offset = path->len -2; /* last two characters */
-	/* Remove arch suffix if present */
-	if (strstr (&path->str[arch_offset], "32") || strstr (&path->str[arch_offset], "64")) {
-		g_string_truncate (path, arch_offset);
-	}
-	g_string_append (path, target_arch);
-	if (execvp (path->str, argv) < 0) {
-		fprintf (stderr, "Error: --arch=%s Failed to switch to '%s'.\n", target_arch, path->str);
-		exit (1);
-	}
-}
-#endif
-#define MONO_HANDLERS_ARGUMENT "--handlers="
-#define MONO_HANDLERS_ARGUMENT_LEN STRING_LENGTH(MONO_HANDLERS_ARGUMENT)
-static void
-apply_root_domain_configuration_file_bindings (MonoDomain *domain, char *root_domain_configuration_file)
-{
-	g_assert_not_reached ();
-}
-static void
-mono_check_interp_supported (void)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_error ("--interpreter on cross-compile runtimes not supported\n");
-#endif
-#ifndef MONO_ARCH_INTERPRETER_SUPPORTED
-	g_error ("--interpreter not supported on this architecture.\n");
-#endif
-}
-static int
-mono_exec_regression_internal (int verbose_level, int count, char *images [], gboolean single_method)
-{
-	mono_do_single_method_regression = single_method;
-	if (mono_use_interpreter) {
-		if (mono_interp_regression_list (verbose_level, count, images)) {
-			g_print ("Regression ERRORS!\n");
-			return 1;
-		}
-		return 0;
-	}
-	if (mini_regression_list (verbose_level, count, images)) {
-		g_print ("Regression ERRORS!\n");
-		return 1;
-	}
-	return 0;
-}
-/**
- * Returns TRUE for success, FALSE for failure.
- */
-gboolean
-mono_regression_test_step (int verbose_level, const char *image, const char *method_name)
-{
-	if (method_name) {
-	} else {
-		do_regression_retries = TRUE;
-	}
-	char *images[] = {
-		(char*)image,
-		NULL
-	};
-	return mono_exec_regression_internal (verbose_level, 1, images, FALSE) == 0;
-}
-#ifdef ENABLE_ICALL_SYMBOL_MAP
-/* Print the icall table as JSON */
-static void
-print_icall_table (void)
-{
-	printf ("[\n{ \"klass\": \"\", \"icalls\": [");
-#define NOHANDLES(inner) inner
-#define HANDLES(id, name, func, ...)	printf ("\t,{ \"name\": \"%s\", \"func\": \"%s_raw\", \"handles\": true }\n", name, #func);
-#define HANDLES_REUSE_WRAPPER		HANDLES
-#define MONO_HANDLE_REGISTER_ICALL(...) /* nothing  */
-#define ICALL_TYPE(id,name,first) printf ("]},\n { \"klass\":\"%s\", \"icalls\": [{} ", name);
-#define ICALL(id,name,func) printf ("\t,{ \"name\": \"%s\", \"func\": \"%s\", \"handles\": false }\n", name, #func);
-#include <mono/metadata/icall-def.h>
-	printf ("]}\n]\n");
-}
-#endif
-/**
- * mono_main:
- * \param argc number of arguments in the argv array
- * \param argv array of strings containing the startup arguments
- * Launches the Mono JIT engine and parses all the command line options
- * in the same way that the mono command line VM would.
- */
-int
-mono_main (int argc, char* argv[])
-{
-	MainThreadArgs main_args;
-	MonoAssembly *assembly;
-	MonoMethodDesc *desc;
-	MonoMethod *method;
-	MonoDomain *domain;
-	MonoImageOpenStatus open_status;
-	const char* aname, *mname = NULL;
-	int i;
-#ifndef DISABLE_JIT
-	int count = 1;
-	MonoGraphOptions mono_graph_options = (MonoGraphOptions)0;
-#endif
-	guint32 opt, action = DO_EXEC, recompilation_times = 1;
-	int mini_verbose_level = 0;
-	char *trace_options = NULL;
-	char *aot_options = NULL;
-	GPtrArray *agents = NULL;
-	char *extra_bindings_config_file = NULL;
-#ifdef MONO_JIT_INFO_TABLE_TEST
-	int test_jit_info_table = FALSE;
-#endif
-#ifdef HOST_WIN32
-	int mixed_mode = FALSE;
-#endif
-	ERROR_DECL (error);
-#ifdef MOONLIGHT
-#ifndef HOST_WIN32
-	/* stdout defaults to block buffering if it's not writing to a terminal, which
-	 * happens with our test harness: we redirect stdout to capture it. Force line
-	 * buffering in all cases. */
-	setlinebuf (stdout);
-#endif
-#endif
-	setlocale (LC_ALL, "");
-#if TARGET_OSX
-	darwin_change_default_file_handles ();
-#endif
-	if (g_hasenv ("MONO_NO_SMP"))
-		mono_set_use_smp (FALSE);
-	g_log_set_always_fatal (G_LOG_LEVEL_ERROR);
-	g_log_set_fatal_mask (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR);
-	opt = mono_parse_default_optimizations (NULL);
-	enable_debugging = TRUE;
-	mono_options_parse_options ((const char**)argv + 1, argc - 1, &argc, error);
-	argc ++;
-	if (!is_ok (error)) {
-		g_printerr ("%s", mono_error_get_message (error));
-		mono_error_cleanup (error);
-		return 1;
-	}
-	for (i = 1; i < argc; ++i) {
-		if (argv [i] [0] != '-')
-			break;
-		if (strcmp (argv [i], "--regression") == 0) {
-			action = DO_REGRESSION;
-		} else if (strncmp (argv [i], "--single-method=", 16) == 0) {
-			char *full_opts = g_strdup_printf ("-all,%s", argv [i] + 16);
-			action = DO_SINGLE_METHOD_REGRESSION;
-			mono_single_method_regression_opt = parse_optimizations (opt, full_opts, TRUE);
-			g_free (full_opts);
-		} else if (strcmp (argv [i], "--verbose") == 0 || strcmp (argv [i], "-v") == 0) {
-			mini_verbose_level++;
-		} else if (strcmp (argv [i], "--version=number") == 0) {
-			g_print ("%s\n", VERSION);
-			return 0;
-		} else if (strcmp (argv [i], "--version") == 0 || strcmp (argv [i], "-V") == 0) {
-			char *build = mono_get_runtime_build_info ();
-			char *gc_descr;
-			g_print ("Mono JIT compiler version %s\nCopyright (C) Novell, Inc, Xamarin Inc and Contributors. www.mono-project.com\n", build);
-			g_free (build);
-			char *info = mono_get_version_info ();
-			g_print (info);
-			g_free (info);
-			gc_descr = mono_gc_get_description ();
-			g_print ("\tGC:            %s\n", gc_descr);
-			g_free (gc_descr);
-			return 0;
-		} else if (strcmp (argv [i], "--help") == 0 || strcmp (argv [i], "-h") == 0) {
-			mini_usage ();
-			return 0;
-		} else if (strcmp (argv [i], "--help-trace") == 0){
-			mini_trace_usage ();
-			return 0;
-		} else if (strcmp (argv [i], "--help-devel") == 0){
-			mini_usage_jitdeveloper ();
-			return 0;
-		} else if (strcmp (argv [i], "--help-debug") == 0){
-			mini_debug_usage ();
-			return 0;
-		} else if (strcmp (argv [i], "--list-opt") == 0){
-			mini_usage_list_opt ();
-			return 0;
-		} else if (strncmp (argv [i], "--statfile", 10) == 0) {
-			if (i + 1 >= argc){
-				fprintf (stderr, "error: --statfile requires a filename argument\n");
-				return 1;
-			}
-			mini_stats_fd = fopen (argv [++i], "w+");
-		} else if (strncmp (argv [i], "--optimize=", 11) == 0) {
-			opt = parse_optimizations (opt, argv [i] + 11, TRUE);
-		} else if (strncmp (argv [i], "-O=", 3) == 0) {
-			opt = parse_optimizations (opt, argv [i] + 3, TRUE);
-		} else if (strncmp (argv [i], "--bisect=", 9) == 0) {
-			char *param = argv [i] + 9;
-			char *sep = strchr (param, ':');
-			if (!sep) {
-				fprintf (stderr, "Error: --bisect requires OPT:FILENAME\n");
-				return 1;
-			}
-			char *bisect_opt_string = g_strndup (param, sep - param);
-			guint32 bisect_opt = parse_optimizations (0, bisect_opt_string, FALSE);
-			g_free (bisect_opt_string);
-			mono_set_bisect_methods (bisect_opt, sep + 1);
-		} else if (strcmp (argv [i], "--gc=sgen") == 0) {
-			switch_gc (argv, "sgen");
-		} else if (strcmp (argv [i], "--gc=boehm") == 0) {
-			switch_gc (argv, "boehm");
-		} else if (strncmp (argv[i], "--gc-params=", 12) == 0) {
-			mono_gc_params_set (argv[i] + 12);
-		} else if (strncmp (argv[i], "--gc-debug=", 11) == 0) {
-			mono_gc_debug_set (argv[i] + 11);
-		}
-#ifdef TARGET_OSX
-		else if (strcmp (argv [i], "--arch=32") == 0) {
-			switch_arch (argv, "32");
-		} else if (strcmp (argv [i], "--arch=64") == 0) {
-			switch_arch (argv, "64");
-		}
-#endif
-		else if (strcmp (argv [i], "--config") == 0) {
-			if (i +1 >= argc){
-				fprintf (stderr, "error: --config requires a filename argument\n");
-				return 1;
-			}
-			++i;
-#ifdef HOST_WIN32
-		} else if (strcmp (argv [i], "--mixed-mode") == 0) {
-			mixed_mode = TRUE;
-#endif
-#ifndef DISABLE_JIT
-		} else if (strcmp (argv [i], "--ncompile") == 0) {
-			if (i + 1 >= argc){
-				fprintf (stderr, "error: --ncompile requires an argument\n");
-				return 1;
-			}
-			count = atoi (argv [++i]);
-			action = DO_BENCH;
-#endif
-		} else if (strcmp (argv [i], "--trace") == 0) {
-			trace_options = (char*)"";
-		} else if (strncmp (argv [i], "--trace=", 8) == 0) {
-			trace_options = &argv [i][8];
-		} else if (strcmp (argv [i], "--breakonex") == 0) {
-			MonoDebugOptions *debug_opt = mini_get_debug_options ();
-			debug_opt->break_on_exc = TRUE;
-		} else if (strcmp (argv [i], "--break") == 0) {
-			if (i+1 >= argc){
-				fprintf (stderr, "Missing method name in --break command line option\n");
-				return 1;
-			}
-			if (!mono_debugger_insert_breakpoint (argv [++i], FALSE))
-				fprintf (stderr, "Error: invalid method name '%s'\n", argv [i]);
-		} else if (strcmp (argv [i], "--break-at-bb") == 0) {
-			if (i + 2 >= argc) {
-				fprintf (stderr, "Missing method name or bb num in --break-at-bb command line option.");
-				return 1;
-			}
-			mono_break_at_bb_method = mono_method_desc_new (argv [++i], TRUE);
-			if (mono_break_at_bb_method == NULL) {
-				fprintf (stderr, "Method name is in a bad format in --break-at-bb command line option.");
-				return 1;
-			}
-			mono_break_at_bb_bb_num = atoi (argv [++i]);
-		} else if (strcmp (argv [i], "--inject-async-exc") == 0) {
-			if (i + 2 >= argc) {
-				fprintf (stderr, "Missing method name or position in --inject-async-exc command line option\n");
-				return 1;
-			}
-			mono_inject_async_exc_method = mono_method_desc_new (argv [++i], TRUE);
-			if (mono_inject_async_exc_method == NULL) {
-				fprintf (stderr, "Method name is in a bad format in --inject-async-exc command line option\n");
-				return 1;
-			}
-			mono_inject_async_exc_pos = atoi (argv [++i]);
-		} else if (strcmp (argv [i], "--verify-all") == 0) {
-			g_warning ("--verify-all is obsolete, ignoring");
-		} else if (strcmp (argv [i], "--full-aot") == 0) {
-			mono_jit_set_aot_mode (MONO_AOT_MODE_FULL);
-		} else if (strcmp (argv [i], "--hybrid-aot") == 0) {
-			mono_jit_set_aot_mode (MONO_AOT_MODE_HYBRID);
-		} else if (strcmp (argv [i], "--full-aot-interp") == 0) {
-			mono_jit_set_aot_mode (MONO_AOT_MODE_INTERP);
-		} else if (strcmp (argv [i], "--llvmonly") == 0) {
-			/* Same as llvmonly-interp */
-			mono_jit_set_aot_mode (MONO_AOT_MODE_LLVMONLY_INTERP);
-		} else if (strcmp (argv [i], "--llvmonly-interp") == 0) {
-			mono_jit_set_aot_mode (MONO_AOT_MODE_LLVMONLY_INTERP);
-		} else if (strcmp (argv [i], "--print-vtable") == 0) {
-			mono_print_vtable = TRUE;
-		} else if (strcmp (argv [i], "--stats") == 0) {
-			enable_runtime_stats ();
-		} else if (strncmp (argv [i], "--stats=", 8) == 0) {
-			enable_runtime_stats ();
-			if (mono_stats_method_desc)
-				g_free (mono_stats_method_desc);
-			mono_stats_method_desc = parse_qualified_method_name (argv [i] + 8);
-#ifndef DISABLE_AOT
-		} else if (strcmp (argv [i], "--aot") == 0) {
-			error_if_aot_unsupported ();
-			mono_compile_aot = TRUE;
-		} else if (strncmp (argv [i], "--aot=", 6) == 0) {
-			error_if_aot_unsupported ();
-			mono_compile_aot = TRUE;
-			if (aot_options) {
-				char *tmp = g_strdup_printf ("%s,%s", aot_options, &argv [i][6]);
-				g_free (aot_options);
-				aot_options = tmp;
-			} else {
-				aot_options = g_strdup (&argv [i][6]);
-			}
-#endif
-		} else if (strncmp (argv [i], "--apply-bindings=", 17) == 0) {
-			extra_bindings_config_file = &argv[i][17];
-		} else if (strncmp (argv [i], "--aot-path=", 11) == 0) {
-			char **splitted;
-			splitted = g_strsplit (argv [i] + 11, G_SEARCHPATH_SEPARATOR_S, 1000);
-			while (*splitted) {
-				char *tmp = *splitted;
-				mono_aot_paths = g_list_append (mono_aot_paths, g_strdup (tmp));
-				g_free (tmp);
-				splitted++;
-			}
-		} else if (strncmp (argv [i], "--compile-all=", 14) == 0) {
-			action = DO_COMPILE;
-			recompilation_times = atoi (argv [i] + 14);
-		} else if (strcmp (argv [i], "--compile-all") == 0) {
-			action = DO_COMPILE;
-		} else if (strncmp (argv [i], "--runtime=", 10) == 0) {
-		} else if (strcmp (argv [i], "--jitmap") == 0) {
-			mono_enable_jit_map ();
-#ifdef ENABLE_JIT_DUMP
-		} else if (strcmp (argv [i], "--jitdump") == 0) {
-			mono_enable_jit_dump ();
-#endif
-		} else if (strcmp (argv [i], "--profile") == 0) {
-			mini_add_profiler_argument (NULL);
-		} else if (strncmp (argv [i], "--profile=", 10) == 0) {
-			mini_add_profiler_argument (argv [i] + 10);
-		} else if (strncmp (argv [i], "--agent=", 8) == 0) {
-			if (agents == NULL)
-				agents = g_ptr_array_new ();
-			g_ptr_array_add (agents, argv [i] + 8);
-		} else if (strncmp (argv [i], "--attach=", 9) == 0) {
-			g_warning ("--attach= option no longer supported.");
-		} else if (strcmp (argv [i], "--compile") == 0) {
-			if (i + 1 >= argc){
-				fprintf (stderr, "error: --compile option requires a method name argument\n");
-				return 1;
-			}
-			mname = argv [++i];
-			action = DO_BENCH;
-#ifndef DISABLE_JIT
-		} else if (strncmp (argv [i], "--graph=", 8) == 0) {
-			if (i + 1 >= argc){
-				fprintf (stderr, "error: --graph option requires a method name argument\n");
-				return 1;
-			}
-			mono_graph_options = mono_parse_graph_options (argv [i] + 8);
-			mname = argv [++i];
-			action = DO_DRAW;
-		} else if (strcmp (argv [i], "--graph") == 0) {
-			if (i + 1 >= argc){
-				fprintf (stderr, "error: --graph option requires a method name argument\n");
-				return 1;
-			}
-			mname = argv [++i];
-			mono_graph_options = MONO_GRAPH_CFG;
-			action = DO_DRAW;
-#endif
-		} else if (strcmp (argv [i], "--debug") == 0) {
-			enable_debugging = TRUE;
-		} else if (strncmp (argv [i], "--debug=", 8) == 0) {
-			enable_debugging = TRUE;
-			if (!parse_debug_options (argv [i] + 8))
-				return 1;
-			MonoDebugOptions *debug_opt = mini_get_debug_options ();
-			if (!debug_opt->enabled) {
-				enable_debugging = FALSE;
-			}
-		} else if (strncmp (argv [i], "--debugger-agent=", 17) == 0) {
-			MonoDebugOptions *debug_opt = mini_get_debug_options ();
-			mono_debugger_agent_parse_options (g_strdup (argv [i] + 17));
-			debug_opt->mdb_optimizations = TRUE;
-			enable_debugging = TRUE;
-		} else if (strcmp (argv [i], "--security") == 0) {
-			fprintf (stderr, "error: --security is obsolete.");
-			return 1;
-		} else if (strncmp (argv [i], "--security=", 11) == 0) {
-			if (strcmp (argv [i] + 11, "core-clr") == 0) {
-				fprintf (stderr, "error: --security=core-clr is obsolete.");
-				return 1;
-			} else if (strcmp (argv [i] + 11, "core-clr-test") == 0) {
-				fprintf (stderr, "error: --security=core-clr-test is obsolete.");
-				return 1;
-			} else if (strcmp (argv [i] + 11, "cas") == 0) {
-				fprintf (stderr, "error: --security=cas is obsolete.");
-				return 1;
-			} else if (strcmp (argv [i] + 11, "validil") == 0) {
-				fprintf (stderr, "error: --security=validil is obsolete.");
-				return 1;
-			} else if (strcmp (argv [i] + 11, "verifiable") == 0) {
-				fprintf (stderr, "error: --securty=verifiable is obsolete.");
-				return 1;
-			} else {
-				fprintf (stderr, "error: --security= option has invalid argument (cas, core-clr, verifiable or validil)\n");
-				return 1;
-			}
-		} else if (strcmp (argv [i], "--desktop") == 0) {
-			mono_gc_set_desktop_mode ();
-			/* Put more desktop-specific optimizations here */
-		} else if (strcmp (argv [i], "--server") == 0){
-		} else if (strcmp (argv [i], "--inside-mdb") == 0) {
-			action = DO_DEBUGGER;
-		} else if (strncmp (argv [i], "--wapi=", 7) == 0) {
-			fprintf (stderr, "--wapi= option no longer supported\n.");
-			return 1;
-		} else if (strcmp (argv [i], "--no-x86-stack-align") == 0) {
-			mono_do_x86_stack_align = FALSE;
-#ifdef MONO_JIT_INFO_TABLE_TEST
-		} else if (strcmp (argv [i], "--test-jit-info-table") == 0) {
-			test_jit_info_table = TRUE;
-#endif
-		} else if (strcmp (argv [i], "--llvm") == 0) {
-#ifndef MONO_ARCH_LLVM_SUPPORTED
-			fprintf (stderr, "Mono Warning: --llvm not supported on this platform.\n");
-#elif !defined(ENABLE_LLVM)
-			fprintf (stderr, "Mono Warning: --llvm not enabled in this runtime.\n");
-#else
-			mono_use_llvm = TRUE;
-#endif
-		} else if (strcmp (argv [i], "--nollvm") == 0){
-			mono_use_llvm = FALSE;
-		} else if (strcmp (argv [i], "--ffast-math") == 0){
-			mono_use_fast_math = TRUE;
-		} else if ((strcmp (argv [i], "--interpreter") == 0) || !strcmp (argv [i], "--interp")) {
-			mono_runtime_set_execution_mode (MONO_EE_MODE_INTERP);
-		} else if (strncmp (argv [i], "--interp=", 9) == 0) {
-			mono_runtime_set_execution_mode_full (MONO_EE_MODE_INTERP, FALSE);
-			mono_interp_opts_string = argv [i] + 9;
-		} else if (strcmp (argv [i], "--print-icall-table") == 0) {
-#ifdef ENABLE_ICALL_SYMBOL_MAP
-			print_icall_table ();
-			exit (0);
-#else
-			fprintf (stderr, "--print-icall-table requires a runtime configured with the --enable-icall-symbol-map option.\n");
-			exit (1);
-#endif
-		} else if (strncmp (argv [i], "--assembly-loader=", strlen("--assembly-loader=")) == 0) {
-			gchar *arg = argv [i] + strlen ("--assembly-loader=");
-			if (strcmp (arg, "strict") == 0)
-				mono_loader_set_strict_assembly_name_check (TRUE);
-			else if (strcmp (arg, "legacy") == 0)
-				mono_loader_set_strict_assembly_name_check (FALSE);
-			else
-				fprintf (stderr, "Warning: unknown argument to --assembly-loader. Should be \"strict\" or \"legacy\"\n");
-		} else if (strncmp (argv [i], MONO_HANDLERS_ARGUMENT, MONO_HANDLERS_ARGUMENT_LEN) == 0) {
-			if (!mono_runtime_install_custom_handlers (argv[i] + MONO_HANDLERS_ARGUMENT_LEN)) {
-				fprintf (stderr, "error: " MONO_HANDLERS_ARGUMENT ", one or more unknown handlers: '%s'\n", argv [i]);
-				return 1;
-			}
-		} else if (strcmp (argv [i], "--help-handlers") == 0) {
-			mono_runtime_install_custom_handlers_usage ();
-			return 0;
-		} else if (strncmp (argv [i], "--response=", 11) == 0){
-			gchar *response_content;
-			gchar *response_options;
-			gsize response_content_len;
-			if (!g_file_get_contents (&argv[i][11], &response_content, &response_content_len, NULL)){
-				fprintf (stderr, "The specified response file can not be read\n");
-				exit (1);
-			}
-			response_options = response_content;
-			if (response_content_len >= 3 && response_content [0] == '\xef' && response_content [1] == '\xbb' && response_content [2] == '\xbf') {
-				response_content_len -= 3;
-				response_options += 3;
-			}
-			if (response_content_len == 0) {
-				fprintf (stderr, "The specified response file is empty\n");
-				exit (1);
-			}
-			int orig_argc = argc;
-			mono_parse_response_options (response_options, &argc, &argv, FALSE);
-			g_free (response_content);
-			/* Parse newly added options */
-			int n = argc;
-			mono_options_parse_options ((const char**)(argv + orig_argc), argc - orig_argc, &n, error);
-			if (!is_ok (error)) {
-				g_printerr ("%s", mono_error_get_message (error));
-				mono_error_cleanup (error);
-				return 1;
-			}
-			argc -= (argc - orig_argc) - n;
-		} else if (argv [i][0] == '-' && argv [i][1] == '-' && mini_parse_debug_option (argv [i] + 2)) {
-		} else if (strcmp (argv [i], "--use-map-jit") == 0){
-			mono_setmmapjit (TRUE);
-		} else {
-			fprintf (stderr, "Unknown command line option: '%s'\n", argv [i]);
-			return 1;
-		}
-	}
-#if defined(MONO_ARCH_DISABLE_HW_TRAPS)
-	{
-		MonoDebugOptions *opt = mini_get_debug_options ();
-		opt->explicit_null_checks = TRUE;
-	}
-#endif
-	if (!argv [i]) {
-		mini_usage ();
-		return 1;
-	}
-	if (g_hasenv ("MONO_XDEBUG"))
-		enable_debugging = TRUE;
-#ifdef MONO_CROSS_COMPILE
-	if (!mono_compile_aot) {
-		fprintf (stderr, "This mono runtime is compiled for cross-compiling. Only the --aot option is supported.\n");
-		exit (1);
-	}
-#if TARGET_SIZEOF_VOID_P == 4 && (defined(TARGET_ARM64) || defined(TARGET_AMD64)) && !defined(MONO_ARCH_ILP32)
-	fprintf (stderr, "Can't cross-compile on 32-bit platforms to 64-bit architecture.\n");
-	exit (1);
-#endif
-#endif
-	mono_counters_init ();
-#ifndef HOST_WIN32
-	mono_w32handle_init ();
-#endif
-	if (trace_options != NULL){
-		/*
-		 * Need to call this before mini_init () so we can trace methods
-		 * compiled there too.
-		 */
-		mono_jit_trace_calls = mono_trace_set_options (trace_options);
-		if (mono_jit_trace_calls == NULL)
-			exit (1);
-	}
-#ifdef DISABLE_JIT
-	if (!mono_aot_only && !mono_use_interpreter) {
-		fprintf (stderr, "This runtime has been configured with --enable-minimal=jit, so the --full-aot command line option is required.\n");
-		exit (1);
-	}
-#endif
-	if (action == DO_DEBUGGER) {
-		enable_debugging = TRUE;
-		g_print ("The Mono Debugger is no longer supported.\n");
-		return 1;
-	} else if (enable_debugging)
-		mono_debug_init (MONO_DEBUG_FORMAT_MONO);
-#ifdef HOST_WIN32
-	if (mixed_mode)
-		mono_load_coree (argv [i]);
-#endif
-	mono_set_defaults (mini_verbose_level, opt);
-	domain = mini_init (argv [i]);
-	mono_gc_set_stack_end (&domain);
-	if (agents) {
-		for (guint agent_idx = 0; agent_idx < agents->len; ++agent_idx) {
-			int res = load_agent (domain, (char*)g_ptr_array_index (agents, agent_idx));
-			if (res) {
-				g_ptr_array_free (agents, TRUE);
-				mini_cleanup (domain);
-				return 1;
-			}
-		}
-		g_ptr_array_free (agents, TRUE);
-	}
-	switch (action) {
-	case DO_SINGLE_METHOD_REGRESSION:
-	case DO_REGRESSION:
-		 return mono_exec_regression_internal (mini_verbose_level, argc -i, argv + i, action == DO_SINGLE_METHOD_REGRESSION);
-	case DO_BENCH:
-		if (argc - i != 1 || mname == NULL) {
-			g_print ("Usage: mini --ncompile num --compile method assembly\n");
-			mini_cleanup (domain);
-			return 1;
-		}
-		aname = argv [i];
-		break;
-	case DO_COMPILE:
-		if (argc - i != 1) {
-			mini_usage ();
-			mini_cleanup (domain);
-			return 1;
-		}
-		aname = argv [i];
-		break;
-	case DO_DRAW:
-		if (argc - i != 1 || mname == NULL) {
-			mini_usage ();
-			mini_cleanup (domain);
-			return 1;
-		}
-		aname = argv [i];
-		break;
-	default:
-		if (argc - i < 1) {
-			mini_usage ();
-			mini_cleanup (domain);
-			return 1;
-		}
-		aname = argv [i];
-		break;
-	}
-#ifdef MONO_JIT_INFO_TABLE_TEST
-	if (test_jit_info_table)
-		jit_info_table_test (domain);
-#endif
-	if (mono_compile_aot && extra_bindings_config_file != NULL) {
-		apply_root_domain_configuration_file_bindings (domain, extra_bindings_config_file);
-	}
-	MonoAssemblyOpenRequest open_req;
-	mono_assembly_request_prepare_open (&open_req, mono_alc_get_default ());
-	assembly = mono_assembly_request_open (aname, &open_req, &open_status);
-	if (!assembly && !mono_compile_aot) {
-		fprintf (stderr, "Cannot open assembly '%s': %s.\n", aname, mono_image_strerror (open_status));
-		mini_cleanup (domain);
-		return 2;
-	}
-	mono_callspec_set_assembly (assembly);
-	if (mono_compile_aot || action == DO_EXEC) {
-		const char *version_error;
-		version_error = mono_check_corlib_version ();
-		if (version_error) {
-			fprintf (stderr, "Corlib not in sync with this runtime: %s\n", version_error);
-			fprintf (stderr, "Loaded from: %s\n",
-				mono_defaults.corlib? mono_image_get_filename (mono_defaults.corlib): "unknown");
-			fprintf (stderr, "Download a newer corlib or a newer runtime at http://www.mono-project.com/download.\n");
-			exit (1);
-		}
-#if defined(HOST_WIN32) && HAVE_API_SUPPORT_WIN32_CONSOLE
-		/* Detach console when executing IMAGE_SUBSYSTEM_WINDOWS_GUI on win32 */
-		if (!enable_debugging && !mono_compile_aot && mono_assembly_get_image_internal (assembly)->image_info->cli_header.nt.pe_subsys_required == IMAGE_SUBSYSTEM_WINDOWS_GUI)
-			FreeConsole ();
-#endif
-		main_args.domain = domain;
-		main_args.file = aname;
-		main_args.argc = argc - i;
-		main_args.argv = argv + i;
-		main_args.opts = opt;
-		main_args.aot_options = aot_options;
-		main_thread_handler (&main_args);
-		mono_thread_manage_internal ();
-		mini_cleanup (domain);
-		/* Look up return value from System.Environment.ExitCode */
-		i = mono_environment_exitcode_get ();
-		return i;
-	} else if (action == DO_COMPILE) {
-		compile_all_methods (assembly, mini_verbose_level, opt, recompilation_times);
-		mini_cleanup (domain);
-		return 0;
-	} else if (action == DO_DEBUGGER) {
-		return 1;
-	}
-	desc = mono_method_desc_new (mname, 0);
-	if (!desc) {
-		g_print ("Invalid method name %s\n", mname);
-		mini_cleanup (domain);
-		return 3;
-	}
-	method = mono_method_desc_search_in_image (desc, mono_assembly_get_image_internal (assembly));
-	if (!method) {
-		g_print ("Cannot find method %s\n", mname);
-		mini_cleanup (domain);
-		return 3;
-	}
-#ifndef DISABLE_JIT
-	MonoCompile *cfg;
-	if (action == DO_DRAW) {
-		int part = 0;
-		switch (mono_graph_options) {
-		case MONO_GRAPH_DTREE:
-			part = 1;
-			opt |= MONO_OPT_LOOP;
-			break;
-		case MONO_GRAPH_CFG_CODE:
-			part = 1;
-			break;
-		case MONO_GRAPH_CFG_SSA:
-			part = 2;
-			break;
-		case MONO_GRAPH_CFG_OPTCODE:
-			part = 3;
-			break;
-		default:
-			break;
-		}
-		if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
-			(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL)) {
-			MonoMethod *nm;
-			nm = mono_marshal_get_native_wrapper (method, TRUE, FALSE);
-			cfg = mini_method_compile (nm, opt, (JitFlags)0, part, -1);
-		}
-		else
-			cfg = mini_method_compile (method, opt, (JitFlags)0, part, -1);
-		if ((mono_graph_options & MONO_GRAPH_CFG_SSA) && !(cfg->comp_done & MONO_COMP_SSA)) {
-			g_warning ("no SSA info available (use -O=deadce)");
-			return 1;
-		}
-		mono_draw_graph (cfg, mono_graph_options);
-		mono_destroy_compile (cfg);
-	} else if (action == DO_BENCH) {
-		if (mini_stats_fd) {
-			const char *n;
-			double no_opt_time = 0.0;
-			GTimer *timer = g_timer_new ();
-			fprintf (mini_stats_fd, "$stattitle = \'Compilations times for %s\';\n",
-				 mono_method_full_name (method, TRUE));
-			fprintf (mini_stats_fd, "@data = (\n");
-			fprintf (mini_stats_fd, "[");
-			for (i = 0; i < G_N_ELEMENTS (opt_sets); i++) {
-				opt = opt_sets [i];
-				n = mono_opt_descr (opt);
-				if (!n [0])
-					n = "none";
-				fprintf (mini_stats_fd, "\"%s\",", n);
-			}
-			fprintf (mini_stats_fd, "],\n[");
-			for (i = 0; i < G_N_ELEMENTS (opt_sets); i++) {
-				int j;
-				double elapsed;
-				opt = opt_sets [i];
-				g_timer_start (timer);
-				for (j = 0; j < count; ++j) {
-					cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
-					mono_destroy_compile (cfg);
-				}
-				g_timer_stop (timer);
-				elapsed = g_timer_elapsed (timer, NULL);
-				if (!opt)
-					no_opt_time = elapsed;
-				fprintf (mini_stats_fd, "%f, ", elapsed);
-			}
-			fprintf (mini_stats_fd, "]");
-			if (no_opt_time > 0.0) {
-				fprintf (mini_stats_fd, ", \n[");
-				for (i = 0; i < G_N_ELEMENTS (opt_sets); i++)
-					fprintf (mini_stats_fd, "%f,", no_opt_time);
-				fprintf (mini_stats_fd, "]");
-			}
-			fprintf (mini_stats_fd, ");\n");
-		} else {
-			for (i = 0; i < count; ++i) {
-				if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
-					(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))
-					method = mono_marshal_get_native_wrapper (method, TRUE, FALSE);
-				cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
-				mono_destroy_compile (cfg);
-			}
-		}
-	} else {
-		cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
-		mono_destroy_compile (cfg);
-	}
-#endif
-	mini_cleanup (domain);
- 	return 0;
-}
-/**
- * mono_jit_init:
- * \param root_domain_name Friendly name to give to the initial domain
- *
- * \returns the \c MonoDomain representing the domain where the assembly
- * was loaded.
- */
-MonoDomain *
-mono_jit_init (const char *root_domain_name)
-{
-	MonoDomain *ret = mini_init (root_domain_name);
-	MONO_ENTER_GC_SAFE_UNBALANCED; //once it is not executing any managed code yet, it's safe to run the gc
-	return ret;
-}
-/**
- * mono_jit_init_version:
- * \param root_domain_name Friendly name to give to the initial domain
- * \param runtime_version ignored
- *
- * Deprecated. Use mono_jit_init instead.
- *
- * \returns the \c MonoDomain representing the domain where the assembly
- * was loaded.
- */
-MonoDomain *
-mono_jit_init_version (const char *root_domain_name, const char *runtime_version)
-{
-	MonoDomain *ret = mini_init (root_domain_name);
-	MONO_ENTER_GC_SAFE_UNBALANCED; //once it is not executing any managed code yet, it's safe to run the gc
-	return ret;
-}
-MonoDomain *
-mono_jit_init_version_for_test_only (const char *root_domain_name, const char *runtime_version)
-{
-	MonoDomain *ret = mini_init (root_domain_name);
-	return ret;
-}
-/**
- * mono_jit_cleanup:
- */
-void
-mono_jit_cleanup (MonoDomain *domain)
-{
-	MONO_STACKDATA (dummy);
-	(void) mono_threads_enter_gc_unsafe_region_unbalanced_internal (&dummy);
-	mono_thread_manage_internal ();
-	mini_cleanup (domain);
-}
-void
-mono_jit_set_aot_only (gboolean val)
-{
-	mono_aot_only = val;
-	mono_ee_features.use_aot_trampolines = val;
-}
-static void
-mono_runtime_set_execution_mode_full (int mode, gboolean override)
-{
-	static gboolean mode_initialized = FALSE;
-	if (mode_initialized && !override)
-		return;
-	mode_initialized = TRUE;
-	memset (&mono_ee_features, 0, sizeof (mono_ee_features));
-	switch (mode) {
-	case MONO_AOT_MODE_FULL:
-		mono_aot_only = TRUE;
-		mono_ee_features.use_aot_trampolines = TRUE;
-		break;
-	case MONO_AOT_MODE_HYBRID:
-		mono_set_generic_sharing_vt_supported (TRUE);
-		mono_set_partial_sharing_supported (TRUE);
-		break;
-	case MONO_AOT_MODE_INTERP:
-		mono_aot_only = TRUE;
-		mono_use_interpreter = TRUE;
-		mono_ee_features.use_aot_trampolines = TRUE;
-		break;
-	case MONO_AOT_MODE_INTERP_LLVMONLY:
-		mono_aot_only = TRUE;
-		mono_use_interpreter = TRUE;
-		mono_llvm_only = TRUE;
-		mono_ee_features.force_use_interpreter = TRUE;
-		break;
-	case MONO_AOT_MODE_LLVMONLY:
-	case MONO_AOT_MODE_LLVMONLY_INTERP:
-		mono_aot_only = TRUE;
-		mono_use_interpreter = TRUE;
-		mono_llvm_only = TRUE;
-		break;
-	case MONO_AOT_MODE_INTERP_ONLY:
-		mono_check_interp_supported ();
-		mono_use_interpreter = TRUE;
-		mono_ee_features.force_use_interpreter = TRUE;
-		break;
-	case MONO_AOT_MODE_NORMAL:
-	case MONO_AOT_MODE_NONE:
-		break;
-	default:
-		g_error ("Unknown execution-mode %d", mode);
-	}
-}
-static void
-mono_runtime_set_execution_mode (int mode)
-{
-	mono_runtime_set_execution_mode_full (mode, TRUE);
-}
-/**
- * mono_jit_set_aot_mode:
- */
-void
-mono_jit_set_aot_mode (MonoAotMode mode)
-{
-	/* we don't want to set mono_aot_mode twice */
-	static gboolean inited;
-	g_assert (!inited);
-	mono_aot_mode = mode;
-	inited = TRUE;
-	mono_runtime_set_execution_mode (mode);
-}
-mono_bool
-mono_jit_aot_compiling (void)
-{
-	return mono_compile_aot;
-}
-/**
- * mono_jit_set_trace_options:
- * \param options string representing the trace options
- * Set the options of the tracing engine. This function can be called before initializing
- * the mono runtime. See the --trace mono(1) manpage for the options format.
- *
- * \returns TRUE if the options were parsed and set correctly, FALSE otherwise.
- */
-gboolean
-mono_jit_set_trace_options (const char* options)
-{
-	MonoCallSpec *trace_opt = mono_trace_set_options (options);
-	if (trace_opt == NULL)
-		return FALSE;
-	mono_jit_trace_calls = trace_opt;
-	return TRUE;
-}
-/**
- * mono_set_signal_chaining:
- *
- * Enable/disable signal chaining. This should be called before \c mono_jit_init.
- * If signal chaining is enabled, the runtime saves the original signal handlers before
- * installing its own handlers, and calls the original ones in the following cases:
- * - a \c SIGSEGV / \c SIGABRT signal received while executing native (i.e. not JITted) code.
- * - \c SIGPROF
- * - \c SIGFPE
- * - \c SIGQUIT
- * - \c SIGUSR2
- * Signal chaining only works on POSIX platforms.
- */
-void
-mono_set_signal_chaining (gboolean chain_signals)
-{
-	mono_do_signal_chaining = chain_signals;
-}
-/**
- * mono_set_crash_chaining:
- *
- * Enable/disable crash chaining due to signals. When a fatal signal is delivered and
- * Mono doesn't know how to handle it, it will invoke the crash handler. If chrash chaining
- * is enabled, it will first print its crash information and then try to chain with the native handler.
- */
-void
-mono_set_crash_chaining (gboolean chain_crashes)
-{
-	mono_do_crash_chaining = chain_crashes;
-}
-/**
- * mono_parse_options_from:
- * \param options string containing strings
- * \param ref_argc pointer to the \c argc variable that might be updated
- * \param ref_argv pointer to the \c argv string vector variable that might be updated
- *
- * This function parses the contents of the \c MONO_ENV_OPTIONS
- * environment variable as if they were parsed by a command shell
- * splitting the contents by spaces into different elements of the
- * \p argv vector.  This method supports quoting with both the " and '
- * characters.  Inside quoting, spaces and tabs are significant,
- * otherwise, they are considered argument separators.
- *
- * The \ character can be used to escape the next character which will
- * be added to the current element verbatim.  Typically this is used
- * inside quotes.   If the quotes are not balanced, this method
- *
- * If the environment variable is empty, no changes are made
- * to the values pointed by \p ref_argc and \p ref_argv.
- *
- * Otherwise the \p ref_argv is modified to point to a new array that contains
- * all the previous elements contained in the vector, plus the values parsed.
- * The \p argc is updated to match the new number of parameters.
- *
- * \returns The value NULL is returned on success, otherwise a \c g_strdup allocated
- * string is returned (this is an alias to \c malloc under normal circumstances) that
- * contains the error message that happened during parsing.
- */
-char *
-mono_parse_options_from (const char *options, int *ref_argc, char **ref_argv [])
-{
-	return mono_parse_options (options, ref_argc, ref_argv, TRUE);
-}
-static void
-merge_parsed_options (GPtrArray *parsed_options, int *ref_argc, char **ref_argv [], gboolean prepend)
-{
-	int argc = *ref_argc;
-	char **argv = *ref_argv;
-	if (parsed_options->len > 0){
-		int new_argc = parsed_options->len + argc;
-		char **new_argv = g_new (char *, new_argc + 1);
-		guint i;
-		new_argv [0] = argv [0];
-		i = 1;
-		if (prepend){
-			/* First the environment variable settings, to allow the command line options to override */
-			for (i = 0; i < parsed_options->len; i++)
-				new_argv [i+1] = (char *)g_ptr_array_index (parsed_options, i);
-			i++;
-		}
-		for (int j = 1; j < argc; j++)
-			new_argv [i++] = argv [j];
-		if (!prepend){
-			for (guint j = 0; j < parsed_options->len; j++)
-				new_argv [i++] = (char *)g_ptr_array_index (parsed_options, j);
-		}
-		new_argv [i] = NULL;
-		*ref_argc = new_argc;
-		*ref_argv = new_argv;
-	}
-}
-static char *
-mono_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
-{
-	if (options == NULL)
-		return NULL;
-	GPtrArray *array = g_ptr_array_new ();
-	GString *buffer = g_string_new ("");
-	const char *p;
-	gboolean in_quotes = FALSE;
-	char quote_char = '\0';
-	for (p = options; *p; p++){
-		switch (*p){
-		case ' ': case '\t': case '\n':
-			if (!in_quotes) {
-				if (buffer->len != 0){
-					g_ptr_array_add (array, g_strdup (buffer->str));
-					g_string_truncate (buffer, 0);
-				}
-			} else {
-				g_string_append_c (buffer, *p);
-			}
-			break;
-		case '\\':
-			if (p [1]){
-				g_string_append_c (buffer, p [1]);
-				p++;
-			}
-			break;
-		case '\'':
-		case '"':
-			if (in_quotes) {
-				if (quote_char == *p)
-					in_quotes = FALSE;
-				else
-					g_string_append_c (buffer, *p);
-			} else {
-				in_quotes = TRUE;
-				quote_char = *p;
-			}
-			break;
-		default:
-			g_string_append_c (buffer, *p);
-			break;
-		}
-	}
-	if (in_quotes)
-		return g_strdup_printf ("Unmatched quotes in value: [%s]\n", options);
-	if (buffer->len != 0)
-		g_ptr_array_add (array, g_strdup (buffer->str));
-	g_string_free (buffer, TRUE);
-	merge_parsed_options (array, ref_argc, ref_argv, prepend);
-	g_ptr_array_free (array, TRUE);
-	return NULL;
-}
-#if defined(HOST_WIN32) && HAVE_API_SUPPORT_WIN32_COMMAND_LINE_TO_ARGV
-#include <shellapi.h>
-static char *
-mono_win32_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
-{
-	int argc;
-	gunichar2 **argv;
-	gunichar2 *optionsw;
-	if (!options)
-		return NULL;
-	GPtrArray *array = g_ptr_array_new ();
-	optionsw = g_utf8_to_utf16 (options, -1, NULL, NULL, NULL);
-	if (optionsw) {
-		gunichar2 *p;
-		gboolean in_quotes = FALSE;
-		gunichar2 quote_char = L'\0';
-		for (p = optionsw; *p; p++){
-			switch (*p){
-			case L'\n':
-				if (!in_quotes)
-					*p = L' ';
-				break;
-			case L'\'':
-			case L'"':
-				if (in_quotes) {
-					if (quote_char == *p)
-						in_quotes = FALSE;
-				} else {
-					in_quotes = TRUE;
-					quote_char = *p;
-				}
-				break;
-			}
-		}
-		argv = CommandLineToArgvW (optionsw, &argc);
-		if (argv) {
-			for (int i = 0; i < argc; i++)
-				g_ptr_array_add (array, g_utf16_to_utf8 (argv[i], -1, NULL, NULL, NULL));
-			LocalFree (argv);
-		}
-		g_free (optionsw);
-	}
-	merge_parsed_options (array, ref_argc, ref_argv, prepend);
-	g_ptr_array_free (array, TRUE);
-	return NULL;
-}
-static char *
-mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
-{
-	return mono_win32_parse_options (options, ref_argc, ref_argv, prepend);
-}
-#else
-static char *
-mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
-{
-	return mono_parse_options (options, ref_argc, ref_argv, prepend);
-}
-#endif
-/**
- * mono_parse_env_options:
- * \param ref_argc pointer to the \c argc variable that might be updated
- * \param ref_argv pointer to the \c argv string vector variable that might be updated
- *
- * This function parses the contents of the \c MONO_ENV_OPTIONS
- * environment variable as if they were parsed by a command shell
- * splitting the contents by spaces into different elements of the
- * \p argv vector.  This method supports quoting with both the " and '
- * characters.  Inside quoting, spaces and tabs are significant,
- * otherwise, they are considered argument separators.
- *
- * The \ character can be used to escape the next character which will
- * be added to the current element verbatim.  Typically this is used
- * inside quotes.   If the quotes are not balanced, this method
- *
- * If the environment variable is empty, no changes are made
- * to the values pointed by \p ref_argc and \p ref_argv.
- *
- * Otherwise the \p ref_argv is modified to point to a new array that contains
- * all the previous elements contained in the vector, plus the values parsed.
- * The \p argc is updated to match the new number of parameters.
- *
- * If there is an error parsing, this method will terminate the process by
- * calling exit(1).
- *
- * An alternative to this method that allows an arbitrary string to be parsed
- * and does not exit on error is the `api:mono_parse_options_from`.
- */
-void
-mono_parse_env_options (int *ref_argc, char **ref_argv [])
-{
-	char *ret;
-	char *env_options = g_getenv ("MONO_ENV_OPTIONS");
-	if (env_options == NULL)
-		return;
-	ret = mono_parse_options_from (env_options, ref_argc, ref_argv);
-	g_free (env_options);
-	if (ret == NULL)
-		return;
-	fprintf (stderr, "%s", ret);
-	exit (1);
-}
-MonoDebugOptions *
-get_mini_debug_options (void)
-{
-	return &mini_debug_options;
-}

--- a/src/mono/mono/utils/mono-context.c
+++ b//dev/null
@@ -1,576 +0,0 @@
-/**
- * \file
- * plat independent machine state definitions
- *
- *
- * Copyright (c) 2011 Novell, Inc (http://www.novell.com)
- * Licensed under the MIT license. See LICENSE file in the project root for full license information.
- */
-#include <mono/utils/mono-sigcontext.h>
-#ifdef HAVE_UCONTEXT_H
-#include <ucontext.h>
-#endif
-#if ((defined(__i386__) || defined(_M_IX86)) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_X86))
-#include <mono/utils/mono-context.h>
-#ifdef HOST_WIN32
-#include <windows.h>
-#endif
-#ifdef __sun
-#define REG_EAX EAX
-#define REG_EBX EBX
-#define REG_ECX ECX
-#define REG_EDX EDX
-#define REG_EBP EBP
-#define REG_ESP ESP
-#define REG_ESI ESI
-#define REG_EDI EDI
-#define REG_EIP EIP
-#endif
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-#if defined (HOST_WATCHOS)
-	printf("WARNING: mono_arch_sigctx_to_monoctx() called!\n");
-	mctx->eax = 0xDEADBEEF;
-	mctx->ebx = 0xDEADBEEF;
-	mctx->ecx = 0xDEADBEEF;
-	mctx->edx = 0xDEADBEEF;
-	mctx->ebp = 0xDEADBEEF;
-	mctx->esp = 0xDEADBEEF;
-	mctx->esi = 0xDEADBEEF;
-	mctx->edi = 0xDEADBEEF;
-	mctx->eip = 0xDEADBEEF;
-#elif MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
-	ucontext_t *ctx = (ucontext_t*)sigctx;
-	mctx->eax = UCONTEXT_REG_EAX (ctx);
-	mctx->ebx = UCONTEXT_REG_EBX (ctx);
-	mctx->ecx = UCONTEXT_REG_ECX (ctx);
-	mctx->edx = UCONTEXT_REG_EDX (ctx);
-	mctx->ebp = UCONTEXT_REG_EBP (ctx);
-	mctx->esp = UCONTEXT_REG_ESP (ctx);
-	mctx->esi = UCONTEXT_REG_ESI (ctx);
-	mctx->edi = UCONTEXT_REG_EDI (ctx);
-	mctx->eip = UCONTEXT_REG_EIP (ctx);
-#ifdef UCONTEXT_HAS_XMM
-	if (UCONTEXT_HAS_XMM (ctx)) {
-		mctx->fregs [0] = UCONTEXT_REG_XMM0 (ctx);
-		mctx->fregs [1] = UCONTEXT_REG_XMM1 (ctx);
-		mctx->fregs [2] = UCONTEXT_REG_XMM2 (ctx);
-		mctx->fregs [3] = UCONTEXT_REG_XMM3 (ctx);
-		mctx->fregs [4] = UCONTEXT_REG_XMM4 (ctx);
-		mctx->fregs [5] = UCONTEXT_REG_XMM5 (ctx);
-		mctx->fregs [6] = UCONTEXT_REG_XMM6 (ctx);
-		mctx->fregs [7] = UCONTEXT_REG_XMM7 (ctx);
-	}
-#endif
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)sigctx;
-	mctx->eip = context->Eip;
-	mctx->edi = context->Edi;
-	mctx->esi = context->Esi;
-	mctx->ebx = context->Ebx;
-	mctx->edx = context->Edx;
-	mctx->ecx = context->Ecx;
-	mctx->eax = context->Eax;
-	mctx->ebp = context->Ebp;
-	mctx->esp = context->Esp;
-#else
-	struct sigcontext *ctx = (struct sigcontext *)sigctx;
-	mctx->eax = ctx->SC_EAX;
-	mctx->ebx = ctx->SC_EBX;
-	mctx->ecx = ctx->SC_ECX;
-	mctx->edx = ctx->SC_EDX;
-	mctx->ebp = ctx->SC_EBP;
-	mctx->esp = ctx->SC_ESP;
-	mctx->esi = ctx->SC_ESI;
-	mctx->edi = ctx->SC_EDI;
-	mctx->eip = ctx->SC_EIP;
-#endif
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-#if defined(HOST_WATCHOS)
-	printf("WARNING: mono_arch_monoctx_to_sigctx() called!\n");
-#elif MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
-	ucontext_t *ctx = (ucontext_t*)sigctx;
-	UCONTEXT_REG_EAX (ctx) = mctx->eax;
-	UCONTEXT_REG_EBX (ctx) = mctx->ebx;
-	UCONTEXT_REG_ECX (ctx) = mctx->ecx;
-	UCONTEXT_REG_EDX (ctx) = mctx->edx;
-	UCONTEXT_REG_EBP (ctx) = mctx->ebp;
-	UCONTEXT_REG_ESP (ctx) = mctx->esp;
-	UCONTEXT_REG_ESI (ctx) = mctx->esi;
-	UCONTEXT_REG_EDI (ctx) = mctx->edi;
-	UCONTEXT_REG_EIP (ctx) = mctx->eip;
-#ifdef UCONTEXT_HAS_XMM
-	if (UCONTEXT_HAS_XMM (ctx)) {
-		UCONTEXT_REG_XMM0 (ctx) = mctx->fregs [0];
-		UCONTEXT_REG_XMM1 (ctx) = mctx->fregs [1];
-		UCONTEXT_REG_XMM2 (ctx) = mctx->fregs [2];
-		UCONTEXT_REG_XMM3 (ctx) = mctx->fregs [3];
-		UCONTEXT_REG_XMM4 (ctx) = mctx->fregs [4];
-		UCONTEXT_REG_XMM5 (ctx) = mctx->fregs [5];
-		UCONTEXT_REG_XMM6 (ctx) = mctx->fregs [6];
-		UCONTEXT_REG_XMM7 (ctx) = mctx->fregs [7];
-	}
-#endif
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)sigctx;
-	context->Eip = mctx->eip;
-	context->Edi = mctx->edi;
-	context->Esi = mctx->esi;
-	context->Ebx = mctx->ebx;
-	context->Edx = mctx->edx;
-	context->Ecx = mctx->ecx;
-	context->Eax = mctx->eax;
-	context->Ebp = mctx->ebp;
-	context->Esp = mctx->esp;
-#else
-	struct sigcontext *ctx = (struct sigcontext *)sigctx;
-	ctx->SC_EAX = mctx->eax;
-	ctx->SC_EBX = mctx->ebx;
-	ctx->SC_ECX = mctx->ecx;
-	ctx->SC_EDX = mctx->edx;
-	ctx->SC_EBP = mctx->ebp;
-	ctx->SC_ESP = mctx->esp;
-	ctx->SC_ESI = mctx->esi;
-	ctx->SC_EDI = mctx->edi;
-	ctx->SC_EIP = mctx->eip;
-#endif
-}
-#elif ((defined(__x86_64__) || defined(_M_X64)) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_AMD64))
-#include <mono/utils/mono-context.h>
-#ifdef HOST_WIN32
-#include <windows.h>
-#include <mono/utils/w32subset.h>
-#endif
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
-	ucontext_t *ctx = (ucontext_t*)sigctx;
-	mctx->gregs [AMD64_RAX] = UCONTEXT_REG_RAX (ctx);
-	mctx->gregs [AMD64_RBX] = UCONTEXT_REG_RBX (ctx);
-	mctx->gregs [AMD64_RCX] = UCONTEXT_REG_RCX (ctx);
-	mctx->gregs [AMD64_RDX] = UCONTEXT_REG_RDX (ctx);
-	mctx->gregs [AMD64_RBP] = UCONTEXT_REG_RBP (ctx);
-	mctx->gregs [AMD64_RSP] = UCONTEXT_REG_RSP (ctx);
-	mctx->gregs [AMD64_RSI] = UCONTEXT_REG_RSI (ctx);
-	mctx->gregs [AMD64_RDI] = UCONTEXT_REG_RDI (ctx);
-	mctx->gregs [AMD64_R8] = UCONTEXT_REG_R8 (ctx);
-	mctx->gregs [AMD64_R9] = UCONTEXT_REG_R9 (ctx);
-	mctx->gregs [AMD64_R10] = UCONTEXT_REG_R10 (ctx);
-	mctx->gregs [AMD64_R11] = UCONTEXT_REG_R11 (ctx);
-	mctx->gregs [AMD64_R12] = UCONTEXT_REG_R12 (ctx);
-	mctx->gregs [AMD64_R13] = UCONTEXT_REG_R13 (ctx);
-	mctx->gregs [AMD64_R14] = UCONTEXT_REG_R14 (ctx);
-	mctx->gregs [AMD64_R15] = UCONTEXT_REG_R15 (ctx);
-	mctx->gregs [AMD64_RIP] = UCONTEXT_REG_RIP (ctx);
-#ifdef UCONTEXT_HAS_XMM
-	if (UCONTEXT_HAS_XMM (ctx)) {
-		mctx->fregs [0] = UCONTEXT_REG_XMM0 (ctx);
-		mctx->fregs [1] = UCONTEXT_REG_XMM1 (ctx);
-		mctx->fregs [2] = UCONTEXT_REG_XMM2 (ctx);
-		mctx->fregs [3] = UCONTEXT_REG_XMM3 (ctx);
-		mctx->fregs [4] = UCONTEXT_REG_XMM4 (ctx);
-		mctx->fregs [5] = UCONTEXT_REG_XMM5 (ctx);
-		mctx->fregs [6] = UCONTEXT_REG_XMM6 (ctx);
-		mctx->fregs [7] = UCONTEXT_REG_XMM7 (ctx);
-		mctx->fregs [8] = UCONTEXT_REG_XMM8 (ctx);
-		mctx->fregs [9] = UCONTEXT_REG_XMM9 (ctx);
-		mctx->fregs [10] = UCONTEXT_REG_XMM10 (ctx);
-		mctx->fregs [11] = UCONTEXT_REG_XMM11 (ctx);
-		mctx->fregs [12] = UCONTEXT_REG_XMM12 (ctx);
-		mctx->fregs [13] = UCONTEXT_REG_XMM13 (ctx);
-		mctx->fregs [14] = UCONTEXT_REG_XMM14 (ctx);
-		mctx->fregs [15] = UCONTEXT_REG_XMM15 (ctx);
-	}
-#endif
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)sigctx;
-	mctx->gregs [AMD64_RIP] = context->Rip;
-	mctx->gregs [AMD64_RAX] = context->Rax;
-	mctx->gregs [AMD64_RCX] = context->Rcx;
-	mctx->gregs [AMD64_RDX] = context->Rdx;
-	mctx->gregs [AMD64_RBX] = context->Rbx;
-	mctx->gregs [AMD64_RSP] = context->Rsp;
-	mctx->gregs [AMD64_RBP] = context->Rbp;
-	mctx->gregs [AMD64_RSI] = context->Rsi;
-	mctx->gregs [AMD64_RDI] = context->Rdi;
-	mctx->gregs [AMD64_R8] = context->R8;
-	mctx->gregs [AMD64_R9] = context->R9;
-	mctx->gregs [AMD64_R10] = context->R10;
-	mctx->gregs [AMD64_R11] = context->R11;
-	mctx->gregs [AMD64_R12] = context->R12;
-	mctx->gregs [AMD64_R13] = context->R13;
-	mctx->gregs [AMD64_R14] = context->R14;
-	mctx->gregs [AMD64_R15] = context->R15;
-	memcpy (&(mctx->fregs [AMD64_XMM0]), &(context->Xmm0), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM1]), &(context->Xmm1), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM2]), &(context->Xmm2), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM3]), &(context->Xmm3), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM4]), &(context->Xmm4), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM5]), &(context->Xmm5), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM6]), &(context->Xmm6), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM7]), &(context->Xmm7), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM8]), &(context->Xmm8), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM9]), &(context->Xmm9), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM10]), &(context->Xmm10), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM11]), &(context->Xmm11), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM12]), &(context->Xmm12), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM13]), &(context->Xmm13), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM14]), &(context->Xmm14), sizeof (MonoContextSimdReg));
-	memcpy (&(mctx->fregs [AMD64_XMM15]), &(context->Xmm15), sizeof (MonoContextSimdReg));
-#ifdef MONO_HAVE_SIMD_REG_AVX
-#if HAVE_API_SUPPORT_WIN32_CONTEXT_XSTATE
-	DWORD64 features = 0;
-	if (((context->ContextFlags & CONTEXT_XSTATE) != 0) && (GetXStateFeaturesMask (context, &features) == TRUE) && ((features & XSTATE_MASK_AVX) != 0)) {
-		DWORD feature_len = 0;
-		PM128A ymm = (PM128A)LocateXStateFeature (context, XSTATE_AVX, &feature_len);
-#ifdef ENABLE_CHECKED_BUILD
-		g_assert (ymm);
-		g_assert (feature_len == (sizeof (MonoContextSimdReg) * AMD64_XMM_NREG));
-#endif
-		memcpy (&(mctx->fregs [AMD64_XMM_NREG]), ymm, feature_len);
-	} else {
-		memset (&(mctx->fregs [AMD64_XMM_NREG]), 0, sizeof (MonoContextSimdReg) * AMD64_XMM_NREG);
-	}
-#else
-	memset (&(mctx->fregs [AMD64_XMM_NREG]), 0, sizeof (MonoContextSimdReg) * AMD64_XMM_NREG);
-#endif
-#endif
-#elif defined(__HAIKU__)
-	struct sigcontext *ctx = (struct sigcontext *)sigctx;
-	mctx->gregs [AMD64_RIP] = ctx->regs.rip;
-	mctx->gregs [AMD64_RAX] = ctx->regs.rax;
-	mctx->gregs [AMD64_RCX] = ctx->regs.rcx;
-	mctx->gregs [AMD64_RDX] = ctx->regs.rdx;
-	mctx->gregs [AMD64_RBX] = ctx->regs.rbx;
-	mctx->gregs [AMD64_RSP] = ctx->regs.rsp;
-	mctx->gregs [AMD64_RBP] = ctx->regs.rbp;
-	mctx->gregs [AMD64_RSI] = ctx->regs.rsi;
-	mctx->gregs [AMD64_RDI] = ctx->regs.rdi;
-	mctx->gregs [AMD64_R8] = ctx->regs.r8;
-	mctx->gregs [AMD64_R9] = ctx->regs.r9;
-	mctx->gregs [AMD64_R10] = ctx->regs.r10;
-	mctx->gregs [AMD64_R11] = ctx->regs.r11;
-	mctx->gregs [AMD64_R12] = ctx->regs.r12;
-	mctx->gregs [AMD64_R13] = ctx->regs.r13;
-	mctx->gregs [AMD64_R14] = ctx->regs.r14;
-	mctx->gregs [AMD64_R15] = ctx->regs.r15;
-#else
-	g_assert_not_reached ();
-#endif
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
-	ucontext_t *ctx = (ucontext_t*)sigctx;
-	UCONTEXT_REG_RAX (ctx) = mctx->gregs [AMD64_RAX];
-	UCONTEXT_REG_RBX (ctx) = mctx->gregs [AMD64_RBX];
-	UCONTEXT_REG_RCX (ctx) = mctx->gregs [AMD64_RCX];
-	UCONTEXT_REG_RDX (ctx) = mctx->gregs [AMD64_RDX];
-	UCONTEXT_REG_RBP (ctx) = mctx->gregs [AMD64_RBP];
-	UCONTEXT_REG_RSP (ctx) = mctx->gregs [AMD64_RSP];
-	UCONTEXT_REG_RSI (ctx) = mctx->gregs [AMD64_RSI];
-	UCONTEXT_REG_RDI (ctx) = mctx->gregs [AMD64_RDI];
-	UCONTEXT_REG_R8 (ctx) = mctx->gregs [AMD64_R8];
-	UCONTEXT_REG_R9 (ctx) = mctx->gregs [AMD64_R9];
-	UCONTEXT_REG_R10 (ctx) = mctx->gregs [AMD64_R10];
-	UCONTEXT_REG_R11 (ctx) = mctx->gregs [AMD64_R11];
-	UCONTEXT_REG_R12 (ctx) = mctx->gregs [AMD64_R12];
-	UCONTEXT_REG_R13 (ctx) = mctx->gregs [AMD64_R13];
-	UCONTEXT_REG_R14 (ctx) = mctx->gregs [AMD64_R14];
-	UCONTEXT_REG_R15 (ctx) = mctx->gregs [AMD64_R15];
-	UCONTEXT_REG_RIP (ctx) = mctx->gregs [AMD64_RIP];
-#ifdef UCONTEXT_HAS_XMM
-	if (UCONTEXT_HAS_XMM (ctx)) {
-		UCONTEXT_REG_XMM0 (ctx) = mctx->fregs [0];
-		UCONTEXT_REG_XMM1 (ctx) = mctx->fregs [1];
-		UCONTEXT_REG_XMM2 (ctx) = mctx->fregs [2];
-		UCONTEXT_REG_XMM3 (ctx) = mctx->fregs [3];
-		UCONTEXT_REG_XMM4 (ctx) = mctx->fregs [4];
-		UCONTEXT_REG_XMM5 (ctx) = mctx->fregs [5];
-		UCONTEXT_REG_XMM6 (ctx) = mctx->fregs [6];
-		UCONTEXT_REG_XMM7 (ctx) = mctx->fregs [7];
-		UCONTEXT_REG_XMM8 (ctx) = mctx->fregs [8];
-		UCONTEXT_REG_XMM9 (ctx) = mctx->fregs [9];
-		UCONTEXT_REG_XMM10 (ctx) = mctx->fregs [10];
-		UCONTEXT_REG_XMM11 (ctx) = mctx->fregs [11];
-		UCONTEXT_REG_XMM12 (ctx) = mctx->fregs [12];
-		UCONTEXT_REG_XMM13 (ctx) = mctx->fregs [13];
-		UCONTEXT_REG_XMM14 (ctx) = mctx->fregs [14];
-		UCONTEXT_REG_XMM15 (ctx) = mctx->fregs [15];
-	}
-#endif
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)sigctx;
-	context->Rip = mctx->gregs [AMD64_RIP];
-	context->Rax = mctx->gregs [AMD64_RAX];
-	context->Rcx = mctx->gregs [AMD64_RCX];
-	context->Rdx = mctx->gregs [AMD64_RDX];
-	context->Rbx = mctx->gregs [AMD64_RBX];
-	context->Rsp = mctx->gregs [AMD64_RSP];
-	context->Rbp = mctx->gregs [AMD64_RBP];
-	context->Rsi = mctx->gregs [AMD64_RSI];
-	context->Rdi = mctx->gregs [AMD64_RDI];
-	context->R8 = mctx->gregs [AMD64_R8];
-	context->R9 = mctx->gregs [AMD64_R9];
-	context->R10 = mctx->gregs [AMD64_R10];
-	context->R11 = mctx->gregs [AMD64_R11];
-	context->R12 = mctx->gregs [AMD64_R12];
-	context->R13 = mctx->gregs [AMD64_R13];
-	context->R14 = mctx->gregs [AMD64_R14];
-	context->R15 = mctx->gregs [AMD64_R15];
-	memcpy (&(context->Xmm0), &(mctx->fregs [AMD64_XMM0]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm1), &(mctx->fregs [AMD64_XMM1]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm2), &(mctx->fregs [AMD64_XMM2]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm3), &(mctx->fregs [AMD64_XMM3]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm4), &(mctx->fregs [AMD64_XMM4]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm5), &(mctx->fregs [AMD64_XMM5]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm6), &(mctx->fregs [AMD64_XMM6]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm7), &(mctx->fregs [AMD64_XMM7]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm8), &(mctx->fregs [AMD64_XMM8]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm9), &(mctx->fregs [AMD64_XMM9]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm10), &(mctx->fregs [AMD64_XMM10]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm11), &(mctx->fregs [AMD64_XMM11]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm12), &(mctx->fregs [AMD64_XMM12]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm13), &(mctx->fregs [AMD64_XMM13]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm14), &(mctx->fregs [AMD64_XMM14]), sizeof (MonoContextSimdReg));
-	memcpy (&(context->Xmm15), &(mctx->fregs [AMD64_XMM15]), sizeof (MonoContextSimdReg));
-#elif defined(__HAIKU__)
-	struct sigcontext *ctx = (struct sigcontext *)sigctx;
-	ctx->regs.rip = mctx->gregs [AMD64_RIP];
-	ctx->regs.rax = mctx->gregs [AMD64_RAX];
-	ctx->regs.rcx = mctx->gregs [AMD64_RCX];
-	ctx->regs.rdx = mctx->gregs [AMD64_RDX];
-	ctx->regs.rbx = mctx->gregs [AMD64_RBX];
-	ctx->regs.rsp = mctx->gregs [AMD64_RSP];
-	ctx->regs.rbp = mctx->gregs [AMD64_RBP];
-	ctx->regs.rsi = mctx->gregs [AMD64_RSI];
-	ctx->regs.rdi = mctx->gregs [AMD64_RDI];
-	ctx->regs.r8 = mctx->gregs [AMD64_R8];
-	ctx->regs.r9 = mctx->gregs [AMD64_R9];
-	ctx->regs.r10 = mctx->gregs [AMD64_R10];
-	ctx->regs.r11 = mctx->gregs [AMD64_R11];
-	ctx->regs.r12 = mctx->gregs [AMD64_R12];
-	ctx->regs.r13 = mctx->gregs [AMD64_R13];
-	ctx->regs.r14 = mctx->gregs [AMD64_R14];
-	ctx->regs.r15 = mctx->gregs [AMD64_R15];
-#else
-	g_assert_not_reached ();
-#endif
-}
-#elif defined(__s390x__)
-#include <mono/utils/mono-context.h>
-/*------------------------------------------------------------------*/
-/*                                                                  */
-/* Name		- mono_arch_sigctx_to_monoctx.                      */
-/*                                                                  */
-/* Function	- Called from the signal handler to convert signal  */
-/*                context to MonoContext.                           */
-/*                                                                  */
-/*------------------------------------------------------------------*/
-void
-mono_sigctx_to_monoctx (void *ctx, MonoContext *mctx)
-{
-	memcpy (mctx, ctx, sizeof(MonoContext));
-}
-/*========================= End of Function ========================*/
-/*------------------------------------------------------------------*/
-/*                                                                  */
-/* Name		- mono_arch_monoctx_to_sigctx.                      */
-/*                                                                  */
-/* Function	- Convert MonoContext structure to signal context.  */
-/*                                                                  */
-/*------------------------------------------------------------------*/
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *ctx)
-{
-	memcpy (ctx, mctx, sizeof(MonoContext));
-}
-/*========================= End of Function ========================*/
-#elif (defined(__arm__) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_ARM))
-#include <mono/utils/mono-context.h>
-#include <mono/arch/arm/arm-codegen.h>
-#include <mono/arch/arm/arm-vfp-codegen.h>
-#ifdef HOST_WIN32
-#include <windows.h>
-#endif
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)sigctx;
-	mctx->pc = context->Pc;
-	mctx->cpsr = context->Cpsr;
-	memcpy (&mctx->regs, &context->R0, sizeof (DWORD) * 16);
-	/* Why are we only copying 16 registers?! There are 32! */
-	memcpy (&mctx->fregs, &context->D, sizeof (double) * 16);
-#else
-	arm_ucontext *my_uc = (arm_ucontext*)sigctx;
-	mctx->pc = UCONTEXT_REG_PC (my_uc);
-	mctx->regs [ARMREG_SP] = UCONTEXT_REG_SP (my_uc);
-	mctx->cpsr = UCONTEXT_REG_CPSR (my_uc);
-	memcpy (&mctx->regs, &UCONTEXT_REG_R0 (my_uc), sizeof (host_mgreg_t) * 16);
-#ifdef UCONTEXT_REG_VFPREGS
-	memcpy (&mctx->fregs, UCONTEXT_REG_VFPREGS (my_uc), sizeof (double) * 16);
-#endif
-#endif
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *ctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#elif defined(HOST_WIN32)
-	CONTEXT *context = (CONTEXT*)ctx;
-	context->Pc = mctx->pc;
-	context->Cpsr = mctx->cpsr;
-	memcpy (&context->R0, &mctx->regs, sizeof (DWORD) * 16);
-	/* Why are we only copying 16 registers?! There are 32! */
-	memcpy (&context->D, &mctx->fregs, sizeof (double) * 16);
-#else
-	arm_ucontext *my_uc = (arm_ucontext*)ctx;
-	UCONTEXT_REG_PC (my_uc) = mctx->pc;
-	UCONTEXT_REG_SP (my_uc) = mctx->regs [ARMREG_SP];
-	UCONTEXT_REG_CPSR (my_uc) = mctx->cpsr;
-	/* The upper registers are not guaranteed to be valid */
-	memcpy (&UCONTEXT_REG_R0 (my_uc), &mctx->regs, sizeof (host_mgreg_t) * 12);
-#ifdef UCONTEXT_REG_VFPREGS
-	memcpy (UCONTEXT_REG_VFPREGS (my_uc), &mctx->fregs, sizeof (double) * 16);
-#endif
-#endif
-}
-#elif (defined(__aarch64__) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_ARM64))
-#include <mono/utils/mono-context.h>
-#include <mono/utils/ftnptr.h>
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#else
-	memcpy (mctx->regs, UCONTEXT_GREGS (sigctx), sizeof (host_mgreg_t) * 31);
-	mctx->pc = UCONTEXT_REG_PC (sigctx);
-	mctx->regs [ARMREG_SP] = UCONTEXT_REG_SP (sigctx);
-#ifdef UCONTEXT_REG_LR
-	mctx->regs [ARMREG_LR] = UCONTEXT_REG_LR (sigctx);
-#endif
-#ifdef MONO_ARCH_ENABLE_PTRAUTH
-	mctx->regs [ARMREG_FP] = (host_mgreg_t)ptrauth_strip ((void*)mctx->regs [ARMREG_FP], ptrauth_key_frame_pointer);
-#endif
-#ifdef __linux__
-	struct fpsimd_context *fpctx = (struct fpsimd_context*)&((ucontext_t*)sigctx)->uc_mcontext.__reserved;
-	size_t size = 0;
-	do {
-		struct fpsimd_context *fpctx_temp = (struct fpsimd_context*)&(((ucontext_t*)sigctx)->uc_mcontext.__reserved[size]);
-		if (fpctx_temp->head.magic == FPSIMD_MAGIC)
-		{
-			g_assert (fpctx_temp->head.size >= sizeof (struct fpsimd_context));
-			g_assert (size + fpctx_temp->head.size <= sizeof (((ucontext_t*)sigctx)->uc_mcontext.__reserved));
-			fpctx = fpctx_temp;
-			break;
-		}
-		if (fpctx_temp->head.size == 0)
-			break;
-		size += fpctx_temp->head.size;
-	} while (size + sizeof (struct fpsimd_context) <= sizeof (((ucontext_t*)sigctx)->uc_mcontext.__reserved));
-	if (fpctx->head.magic == FPSIMD_MAGIC)
-		for (int i = 0; i < 32; ++i)
-			mctx->fregs [i] = fpctx->vregs [i];
-	else
-		for (int i = 0; i < 32; ++i)
-			mctx->fregs [i] = 0;
-#endif
-	/* FIXME: apple */
-#endif
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#else
-#ifdef MONO_ARCH_ENABLE_PTRAUTH
-	memcpy (UCONTEXT_GREGS (sigctx), mctx->regs, sizeof (host_mgreg_t) * 31);
-	UCONTEXT_REG_SET_PC (sigctx, (gpointer)mctx->pc);
-	UCONTEXT_REG_SET_SP (sigctx, mctx->regs [ARMREG_SP]);
-#else
-	memcpy (UCONTEXT_GREGS (sigctx), mctx->regs, sizeof (host_mgreg_t) * 31);
-	UCONTEXT_REG_SET_PC (sigctx, mctx->pc);
-	UCONTEXT_REG_SET_SP (sigctx, mctx->regs [ARMREG_SP]);
-#endif
-#endif
-}
-#elif (((defined(__ppc__) || defined(__powerpc__) || defined(__ppc64__)) && !defined(MONO_CROSS_COMPILE))) || (defined(TARGET_POWERPC))
-#include <mono/utils/mono-context.h>
-#include <mono/mini/mini-ppc.h>
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-	os_ucontext *uc = (os_ucontext*)sigctx;
-	mctx->sc_ir = UCONTEXT_REG_NIP(uc);
-	mctx->sc_sp = UCONTEXT_REG_Rn(uc, 1);
-	memcpy (&mctx->regs, &UCONTEXT_REG_Rn(uc, 0), sizeof (host_mgreg_t) * MONO_MAX_IREGS);
-	memcpy (&mctx->fregs, &UCONTEXT_REG_FPRn(uc, 0), sizeof (double) * MONO_MAX_FREGS);
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-	os_ucontext *uc = (os_ucontext*)sigctx;
-	memcpy (&UCONTEXT_REG_Rn(uc, 0), &mctx->regs, sizeof (host_mgreg_t) * MONO_MAX_IREGS);
-	memcpy (&UCONTEXT_REG_FPRn(uc, 0), &mctx->fregs, sizeof (double) * MONO_MAX_FREGS);
-	/* The valid values for pc and sp are stored here and not in regs array */
-	UCONTEXT_REG_NIP(uc) = mctx->sc_ir;
-	UCONTEXT_REG_Rn(uc, 1) = mctx->sc_sp;
-}
-#elif defined (TARGET_WASM)
-#include <mono/utils/mono-context.h>
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-	g_error ("MonoContext not supported");
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-	g_error ("MonoContext not supported");
-}
-#elif ((defined (HOST_RISCV) || defined (HOST_RISCV64)) && !defined (MONO_CROSS_COMPILE)) || defined (TARGET_RISCV)
-#include <mono/utils/mono-context.h>
-void
-mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#else
-	ucontext_t *uctx = sigctx;
-	memcpy (&mctx->gregs, &uctx->uc_mcontext.__gregs, sizeof (host_mgreg_t) * G_N_ELEMENTS (mctx->gregs));
-	memcpy (&mctx->fregs, &uctx->uc_mcontext.__fpregs, sizeof (double) * G_N_ELEMENTS (mctx->fregs));
-#endif
-}
-void
-mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
-{
-#ifdef MONO_CROSS_COMPILE
-	g_assert_not_reached ();
-#else
-	ucontext_t *uctx = sigctx;
-	memcpy (&uctx->uc_mcontext.__gregs, &mctx->gregs, sizeof (host_mgreg_t) * G_N_ELEMENTS (mctx->gregs));
-	memcpy (&uctx->uc_mcontext.__fpregs, &mctx->fregs, sizeof (double) * G_N_ELEMENTS (mctx->fregs));
-#endif
-}
-#endif /* #if defined(__i386__) */

--- a/src/native/eventpipe/ds-ipc-pal-namedpipe.c
+++ b//dev/null
@@ -1,805 +0,0 @@
-#ifdef FEATURE_PERFTRACING_STANDALONE_PAL
-#define EP_NO_RT_DEPENDENCY
-#endif
-#include "ds-rt-config.h"
-#ifdef ENABLE_PERFTRACING
-#ifdef HOST_WIN32
-#define DS_IMPL_IPC_PAL_NAMEDPIPE_GETTER_SETTER
-#include "ds-ipc-pal-namedpipe.h"
-#include <assert.h>
-#include <stdlib.h>
-#include <stdio.h>
-#ifndef FEATURE_PERFTRACING_STANDALONE_PAL
-#include "ds-rt.h"
-#else
-#ifndef ep_raise_error_if_nok
-#define ep_raise_error_if_nok(expr) do { if (!(expr)) goto ep_on_error; } while (0)
-#endif
-#ifndef ep_raise_error
-#define ep_raise_error() do { goto ep_on_error; } while (0)
-#endif
-#ifndef ep_exit_error_handler
-#define ep_exit_error_handler() do { goto ep_on_exit; } while (0)
-#endif
-#ifndef EP_ASSERT
-#define EP_ASSERT assert
-#endif
-#ifndef DS_ENTER_BLOCKING_PAL_SECTION
-#define DS_ENTER_BLOCKING_PAL_SECTION
-#endif
-#ifndef DS_EXIT_BLOCKING_PAL_SECTION
-#define DS_EXIT_BLOCKING_PAL_SECTION
-#endif
-#undef ep_rt_object_alloc
-#define ep_rt_object_alloc(obj_type) ((obj_type *)calloc(1, sizeof(obj_type)))
-static
-inline
-void
-ep_rt_object_free (void *ptr)
-{
-	if (ptr)
-		free (ptr);
-}
-#endif /* !FEATURE_PERFTRACING_STANDALONE_PAL */
-static HANDLE _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
-/*
- * Forward declares of all static functions.
- */
-static
-void
-ipc_stream_free_func (void *object);
-static
-bool
-ipc_stream_read_func (
-	void *object,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms);
-static
-bool
-ipc_stream_write_func (
-	void *object,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms);
-static
-bool
-ipc_stream_flush_func (void *object);
-static
-bool
-ipc_stream_close_func (void *object);
-static
-void
-ipc_close_ownership_handle (
-    ds_ipc_error_callback_func callback);
-static
-bool
-ipc_createpipe_helper (
-	DiagnosticsIpc *ipc,
-	bool ensure_pipe_creation,
-	ds_ipc_error_callback_func callback);
-static
-DiagnosticsIpcStream *
-ipc_stream_alloc (
-	HANDLE pipe,
-	DiagnosticsIpcConnectionMode mode);
-/*
- * DiagnosticsIpc.
- */
-bool
-ds_ipc_pal_init (void)
-{
-	return true;
-}
-bool
-ds_ipc_pal_shutdown (ds_ipc_error_callback_func callback)
-{
-    ipc_close_ownership_handle(callback);
-	return true;
-}
-DiagnosticsIpc *
-ds_ipc_alloc (
-	const ep_char8_t *ipc_name,
-	DiagnosticsIpcConnectionMode mode,
-	ds_ipc_error_callback_func callback)
-{
-	int32_t characters_written = -1;
-	DiagnosticsIpc *instance = ep_rt_object_alloc (DiagnosticsIpc);
-	ep_raise_error_if_nok (instance != NULL);
-	instance->mode = mode;
-	instance->is_listening = false;
-	instance->overlap.hEvent = INVALID_HANDLE_VALUE;
-	instance->pipe = INVALID_HANDLE_VALUE;
-	if (ipc_name) {
-		characters_written = sprintf_s (
-			(char *)&instance->pipe_name,
-			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
-			(const char *)"\\\\.\\pipe\\%s",
-			ipc_name);
-	} else {
-		characters_written = sprintf_s (
-			(char *)&instance->pipe_name,
-			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
-			(const char *)"\\\\.\\pipe\\dotnet-diagnostic-%d",
-			GetCurrentProcessId ());
-	}
-	if (characters_written <= 0 || characters_written >= DS_IPC_WIN32_MAX_NAMED_PIPE_LEN) {
-		if (callback)
-			callback ("Failed to generate the named pipe name", characters_written);
-		ep_raise_error ();
-	}
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ds_ipc_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-void
-ds_ipc_free (DiagnosticsIpc *ipc)
-{
-	if (!ipc)
-		return;
-	ds_ipc_close (ipc, false, NULL);
-	ep_rt_object_free (ipc);
-}
-int32_t
-ds_ipc_poll (
-	DiagnosticsIpcPollHandle *poll_handles_data,
-	size_t poll_handles_data_len,
-	uint32_t timeout_ms,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (poll_handles_data != NULL);
-	int32_t result = 1;
-	EP_ASSERT (poll_handles_data_len <= MAXIMUM_WAIT_OBJECTS);
-	HANDLE handles [MAXIMUM_WAIT_OBJECTS];
-	for (size_t i = 0; i < poll_handles_data_len; ++i) {
-		poll_handles_data [i].events = 0; // ignore any input on events.
-		if (poll_handles_data [i].ipc) {
-			EP_ASSERT (poll_handles_data [i].ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-			handles [i] = poll_handles_data [i].ipc->overlap.hEvent;
-		} else {
-			bool success = true;
-			DWORD bytes_read = 1;
-			if (!poll_handles_data [i].stream->is_test_reading) {
-				success = ReadFile (
-					poll_handles_data [i].stream->pipe,                                   // handle
-					NULL,                                                                 // null buffer
-					0,                                                                    // read 0 bytesd
-					&bytes_read,                                                          // dummy variable
-					&poll_handles_data [i].stream->overlap);    // overlap object to use
-				poll_handles_data [i].stream->is_test_reading = true;
-				if (!success) {
-					DWORD error = GetLastError ();
-					switch (error) {
-					case ERROR_IO_PENDING:
-						handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-						break;
-					case ERROR_PIPE_NOT_CONNECTED:
-						poll_handles_data [i].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-						result = -1;
-						ep_raise_error ();
-					default:
-						if (callback)
-							callback ("0 byte async read on client connection failed", error);
-						result = -1;
-						ep_raise_error ();
-					}
-				} else {
-					handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-				}
-			} else {
-				handles [i] = poll_handles_data [i].stream->overlap.hEvent;
-			}
-		}
-	}
-	DWORD wait = WAIT_FAILED;
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	wait = WaitForMultipleObjects (
-		(DWORD)poll_handles_data_len,      // count
-		handles,                           // handles
-		false,                             // don't wait all
-		(DWORD)timeout_ms);
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (wait == WAIT_TIMEOUT) {
-		result = 0;
-		ep_raise_error ();
-	}
-	if (wait == WAIT_FAILED) {
-		if (callback)
-			callback ("WaitForMultipleObjects failed", GetLastError());
-		result = -1;
-		ep_raise_error ();
-	}
-	DWORD index = wait - WAIT_OBJECT_0;
-	if (index < 0 || index > (poll_handles_data_len - 1)) {
-		DWORD abandonedIndex = wait - WAIT_ABANDONED_0;
-		if (abandonedIndex > 0 || abandonedIndex < (poll_handles_data_len - 1)) {
-			poll_handles_data [abandonedIndex].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-			result = -1;
-			ep_raise_error ();
-		} else {
-			if (callback)
-				callback ("WaitForMultipleObjects failed", GetLastError());
-			result = -1;
-			ep_raise_error ();
-		}
-	}
-	if (!poll_handles_data [index].ipc) {
-		DWORD dummy = 0;
-		BOOL success = GetOverlappedResult(
-			poll_handles_data [index].stream->pipe,
-			&poll_handles_data [index].stream->overlap,
-			&dummy,
-			false);
-		if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
-			dummy = 0;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success = GetOverlappedResult(
-				poll_handles_data [index].stream->pipe,
-				&poll_handles_data [index].stream->overlap,
-				&dummy,
-				true);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-		}
-		poll_handles_data [index].stream->is_test_reading = false;
-		if (!success) {
-			DWORD error = GetLastError();
-			if (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE) {
-				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
-			} else {
-				if (callback)
-					callback ("Client connection error", error);
-				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_ERR;
-				result = -1;
-				ep_raise_error ();
-			}
-		} else {
-			poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
-		}
-	} else {
-		poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
-	}
-	result = 1;
-ep_on_exit:
-	return result;
-ep_on_error:
-	if (result == 1)
-		result = -1;
-	ep_exit_error_handler ();
-}
-static
-bool
-ipc_createpipe_helper (
-	DiagnosticsIpc *ipc,
-	bool ensure_pipe_creation,
-	ds_ipc_error_callback_func callback)
-{
-	bool result = false;
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-	if (ipc->mode != DS_IPC_CONNECTION_MODE_LISTEN) {
-		if (callback)
-			callback ("Cannot call Listen on a client connection", -1);
-		return false;
-	}
-	if (ipc->is_listening)
-		return true;
-    if (!ensure_pipe_creation && _ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
-    {
-        if (callback)
-			callback ("Can't ensure we have ownership of the pipe. Disallowing creation.", -1);
-		return false;
-    }
-    if (ensure_pipe_creation && _ipc_listen_ownership_handle != INVALID_HANDLE_VALUE)
-    {
-        if (callback)
-			callback ("Inconsistent state - pipe sentinel already in use for listen.", -1);
-		return false;
-    }
-    EP_ASSERT (ipc->pipe == INVALID_HANDLE_VALUE);
-	const uint32_t in_buffer_size = 16 * 1024;
-	const uint32_t out_buffer_size = 16 * 1024;
-	DWORD creationFlags = PIPE_ACCESS_DUPLEX    // read/write access
-                | FILE_FLAG_OVERLAPPED;	        // async listening.
-	if (ensure_pipe_creation)
-	{
-		creationFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
-	}
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	ipc->pipe = CreateNamedPipeA (
-		ipc->pipe_name,                                             // pipe name
-		creationFlags,
-		PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS,    // message type pipe, message-read and blocking mode
-		PIPE_UNLIMITED_INSTANCES,                                   // max. instances
-		out_buffer_size,                                            // output buffer size
-		in_buffer_size,                                             // input buffer size
-		0,                                                          // default client time-out
-		NULL);                                                      // default security attribute
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (ipc->pipe == INVALID_HANDLE_VALUE) {
-		if (callback)
-			callback ("Failed to create an instance of a named pipe.", GetLastError());
-		ep_raise_error ();
-	}
-    if (ensure_pipe_creation)
-	{
-	    EP_ASSERT (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE);
-        bool createdSentinel = DuplicateHandle(
-                                    GetCurrentProcess(),
-                                    ipc->pipe,
-                                    GetCurrentProcess(),
-                                    &_ipc_listen_ownership_handle,
-                                    0,
-                                    FALSE,
-                                    DUPLICATE_SAME_ACCESS);
-        if (!createdSentinel)
-        {
-            if (callback)
-			    callback ("Failed to ownership sentinel.", GetLastError());
-            ep_raise_error();
-        }
-	}
-	EP_ASSERT (ipc->overlap.hEvent == INVALID_HANDLE_VALUE);
-	ipc->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
-	if (!ipc->overlap.hEvent) {
-		if (callback)
-			callback ("Failed to create overlap event", GetLastError());
-		ep_raise_error ();
-	}
-	if (ConnectNamedPipe (ipc->pipe, &ipc->overlap) == FALSE) {
-		const DWORD error_code = GetLastError ();
-		switch (error_code) {
-		case ERROR_IO_PENDING:
-		case ERROR_PIPE_CONNECTED:
-			break;
-		default:
-			if (callback)
-				callback ("A client process failed to connect.", error_code);
-			ep_raise_error ();
-		}
-	}
-	ipc->is_listening = true;
-	result = true;
-ep_on_exit:
-	return result;
-ep_on_error:
-	ds_ipc_close (ipc, false, callback);
-    if (ensure_pipe_creation)
-        ipc_close_ownership_handle(callback);
-	result = false;
-	ep_exit_error_handler ();
-}
-bool
-ds_ipc_listen (
-	DiagnosticsIpc *ipc,
-	ds_ipc_error_callback_func callback)
-{
-	return ipc_createpipe_helper(ipc, true, callback);
-}
-DiagnosticsIpcStream *
-ds_ipc_accept (
-	DiagnosticsIpc *ipc,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
-	DiagnosticsIpcStream *stream = NULL;
-	DWORD dummy = 0;
-	BOOL success = GetOverlappedResult (
-		ipc->pipe,      // handle
-		&ipc->overlap,  // overlapped
-		&dummy,         // throw-away dword
-		false);         // wait till event signals
-	if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
-		dummy = 0;
-		DS_ENTER_BLOCKING_PAL_SECTION;
-		success = GetOverlappedResult (
-			ipc->pipe,      // handle
-			&ipc->overlap,  // overlapped
-			&dummy,         // throw-away dword
-			true);          // wait till event signals
-		DS_EXIT_BLOCKING_PAL_SECTION;
-	}
-	if (!success) {
-		if (callback)
-			callback ("Failed to GetOverlappedResults for NamedPipe server", GetLastError());
-		CloseHandle (ipc->pipe);
-	} else {
-		stream = ipc_stream_alloc (ipc->pipe, DS_IPC_CONNECTION_MODE_LISTEN);
-		ep_raise_error_if_nok (stream != NULL);
-	}
-	ipc->pipe = INVALID_HANDLE_VALUE;
-	ipc->is_listening = false;
-	CloseHandle (ipc->overlap.hEvent);
-	memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-	ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
-	ep_raise_error_if_nok (ipc_createpipe_helper (ipc, false, callback));
-ep_on_exit:
-	return stream;
-ep_on_error:
-	ds_ipc_stream_free (stream);
-	stream = NULL;
-	ep_exit_error_handler ();
-}
-DiagnosticsIpcStream *
-ds_ipc_connect (
-	DiagnosticsIpc *ipc,
-	uint32_t timeout_ms,
-	ds_ipc_error_callback_func callback,
-	bool *timed_out)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (timed_out != NULL);
-	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_CONNECT);
-	DiagnosticsIpcStream *stream = NULL;
-	HANDLE pipe = INVALID_HANDLE_VALUE;
-	if (ipc->mode != DS_IPC_CONNECTION_MODE_CONNECT) {
-		if (callback)
-			callback ("Cannot call connect on a server connection", 0);
-		ep_raise_error ();
-	}
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	pipe = CreateFileA(
-		ipc->pipe_name,         // pipe name
-		PIPE_ACCESS_DUPLEX,     // read/write access
-		0,                      // no sharing
-		NULL,                   // default security attributes
-		OPEN_EXISTING,          // opens existing pipe
-		FILE_FLAG_OVERLAPPED,   // overlapped
-		NULL);                  // no template file
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	if (pipe == INVALID_HANDLE_VALUE) {
-		if (callback)
-			callback ("Failed to connect to named pipe.", GetLastError ());
-		ep_raise_error ();
-	}
-	stream = ipc_stream_alloc (pipe, ipc->mode);
-	ep_raise_error_if_nok (stream);
-	pipe = INVALID_HANDLE_VALUE;
-ep_on_exit:
-	return stream;
-ep_on_error:
-	ds_ipc_stream_free (stream);
-	stream = NULL;
-	if (pipe != INVALID_HANDLE_VALUE) {
-		CloseHandle (pipe);
-	}
-	ep_exit_error_handler ();
-}
-void
-ipc_close_ownership_handle (
-    ds_ipc_error_callback_func callback)
-{
-    if (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
-        return;
-    const BOOL success_close_pipe = CloseHandle(_ipc_listen_ownership_handle);
-    if (success_close_pipe != TRUE)
-    {
-        if (callback)
-            callback ("Failed to IPC ownership sentinel handle", GetLastError());
-        return;
-    }
-    _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
-}
-void
-ds_ipc_close (
-	DiagnosticsIpc *ipc,
-	bool is_shutdown,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc != NULL);
-	if (is_shutdown) {
-		if (callback)
-			callback ("Closing without cleaning underlying handles", 100);
-		return;
-	}
-	if (ipc->pipe != INVALID_HANDLE_VALUE) {
-		if (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
-			BOOL success_disconnect = FALSE;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success_disconnect = DisconnectNamedPipe (ipc->pipe);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-			if (success_disconnect != TRUE && callback)
-				callback ("Failed to disconnect NamedPipe", GetLastError());
-		}
-		const BOOL success_close_pipe = CloseHandle (ipc->pipe);
-		if (success_close_pipe != TRUE && callback)
-			callback ("Failed to close pipe handle", GetLastError());
-		ipc->pipe = INVALID_HANDLE_VALUE;
-	}
-	if (ipc->overlap.hEvent != INVALID_HANDLE_VALUE) {
-		const BOOL success_close_event = CloseHandle (ipc->overlap.hEvent);
-		if (success_close_event != TRUE && callback)
-			callback ("Failed to close overlap event handle", GetLastError());
-		memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-		ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
-	}
-}
-int32_t
-ds_ipc_to_string (
-	DiagnosticsIpc *ipc,
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	EP_ASSERT (ipc != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
-	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc->pipe, (int32_t)(size_t)ipc->overlap.hEvent);
-	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
-}
-/*
- * DiagnosticsIpcStream.
- */
-static
-void
-ipc_stream_free_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	ds_ipc_stream_free (ipc_stream);
-}
-static
-bool
-ipc_stream_read_func (
-	void *object,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms)
-{
-	EP_ASSERT (object != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (bytes_read != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	DWORD read = 0;
-	LPOVERLAPPED overlap = &ipc_stream->overlap;
-	bool success = ReadFile (
-		ipc_stream->pipe,   // handle to pipe
-		buffer,             // buffer to receive data
-		bytes_to_read,      // size of buffer
-		&read,              // number of bytes read
-		overlap) != FALSE;  // overlapped I/O
-	if (!success) {
-		DWORD error = GetLastError ();
-		if (error == ERROR_IO_PENDING) {
-			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				success = GetOverlappedResult (
-					ipc_stream->pipe,   // pipe
-					overlap,            // overlapped
-					&read,              // out actual number of bytes read
-					true) != FALSE;     // block until async IO completes
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			} else {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
-				if (wait == WAIT_OBJECT_0) {
-					success = GetOverlappedResult (
-						ipc_stream->pipe,   // pipe
-						overlap,            // overlapped
-						&read,              // out actual number of bytes read
-						true) != FALSE;     // block until async IO completes
-				} else {
-					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
-						success = GetOverlappedResult (
-							ipc_stream->pipe,   // pipe
-							overlap,            // overlapped
-							&read,              // out actual number of bytes read
-							true) != FALSE;     // block until async IO completes
-					}
-				}
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			}
-		}
-	}
-	*bytes_read = (uint32_t)read;
-	return success;
-}
-static
-bool
-ipc_stream_write_func (
-	void *object,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms)
-{
-	EP_ASSERT (object != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (bytes_written != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	DWORD written = 0;
-	LPOVERLAPPED overlap = &ipc_stream->overlap;
-	bool success = WriteFile (
-		ipc_stream->pipe,   // handle to pipe
-		buffer,             // buffer to write from
-		bytes_to_write,     // number of bytes to write
-		&written,           // number of bytes written
-		overlap) != FALSE;  // overlapped I/O
-	if (!success) {
-		DWORD error = GetLastError ();
-		if (error == ERROR_IO_PENDING) {
-			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				success = GetOverlappedResult (
-					ipc_stream->pipe,   // pipe
-					overlap,            // overlapped
-					&written,           // out actual number of bytes written
-					true) != FALSE;     // block until async IO completes
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			} else {
-				DS_ENTER_BLOCKING_PAL_SECTION;
-				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
-				if (wait == WAIT_OBJECT_0) {
-					success = GetOverlappedResult (
-						ipc_stream->pipe,   // pipe
-						overlap,            // overlapped
-						&written,           // out actual number of bytes written
-						true) != FALSE;     // block until async IO completes
-				} else {
-					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
-						success = GetOverlappedResult (
-							ipc_stream->pipe,   // pipe
-							overlap,            // overlapped
-							&written,           // out actual number of bytes written
-							true) != FALSE;         // block until async IO completes
-					}
-				}
-				DS_EXIT_BLOCKING_PAL_SECTION;
-			}
-		}
-	}
-	*bytes_written = (uint32_t)written;
-	return success;
-}
-static
-bool
-ipc_stream_flush_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	bool success = false;
-	DS_ENTER_BLOCKING_PAL_SECTION;
-	success = FlushFileBuffers (ipc_stream->pipe) != FALSE;
-	DS_EXIT_BLOCKING_PAL_SECTION;
-	return success;
-}
-static
-bool
-ipc_stream_close_func (void *object)
-{
-	EP_ASSERT (object != NULL);
-	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
-	return ds_ipc_stream_close (ipc_stream, NULL);
-}
-static IpcStreamVtable ipc_stream_vtable = {
-	ipc_stream_free_func,
-	ipc_stream_read_func,
-	ipc_stream_write_func,
-	ipc_stream_flush_func,
-	ipc_stream_close_func };
-static
-DiagnosticsIpcStream *
-ipc_stream_alloc (
-	HANDLE pipe,
-	DiagnosticsIpcConnectionMode mode)
-{
-	DiagnosticsIpcStream *instance = ep_rt_object_alloc (DiagnosticsIpcStream);
-	ep_raise_error_if_nok (instance != NULL);
-	instance->stream.vtable = &ipc_stream_vtable;
-	instance->pipe = pipe;
-	instance->mode = mode;
-	instance->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
-ep_on_exit:
-	return instance;
-ep_on_error:
-	ds_ipc_stream_free (instance);
-	instance = NULL;
-	ep_exit_error_handler ();
-}
-int32_t
-ds_ipc_stream_get_handle_int32_t (DiagnosticsIpcStream *ipc_stream)
-{
-	return (int32_t)(size_t)ipc_stream->pipe;
-}
-IpcStream *
-ds_ipc_stream_get_stream_ref (DiagnosticsIpcStream *ipc_stream)
-{
-	return &ipc_stream->stream;
-}
-void
-ds_ipc_stream_free (DiagnosticsIpcStream *ipc_stream)
-{
-	if (!ipc_stream)
-		return;
-	ds_ipc_stream_close (ipc_stream, NULL);
-	ep_rt_object_free (ipc_stream);
-}
-bool
-ds_ipc_stream_read (
-	DiagnosticsIpcStream *ipc_stream,
-	uint8_t *buffer,
-	uint32_t bytes_to_read,
-	uint32_t *bytes_read,
-	uint32_t timeout_ms)
-{
-	return ipc_stream_read_func (
-		ipc_stream,
-		buffer,
-		bytes_to_read,
-		bytes_read,
-		timeout_ms);
-}
-bool
-ds_ipc_stream_write (
-	DiagnosticsIpcStream *ipc_stream,
-	const uint8_t *buffer,
-	uint32_t bytes_to_write,
-	uint32_t *bytes_written,
-	uint32_t timeout_ms)
-{
-	return ipc_stream_write_func (
-		ipc_stream,
-		buffer,
-		bytes_to_write,
-		bytes_written,
-		timeout_ms);
-}
-bool
-ds_ipc_stream_flush (DiagnosticsIpcStream *ipc_stream)
-{
-	return ipc_stream_flush_func (ipc_stream);
-}
-bool
-ds_ipc_stream_close (
-	DiagnosticsIpcStream *ipc_stream,
-	ds_ipc_error_callback_func callback)
-{
-	EP_ASSERT (ipc_stream != NULL);
-	if (ipc_stream->pipe != INVALID_HANDLE_VALUE) {
-		ds_ipc_stream_flush (ipc_stream);
-		if (ipc_stream->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
-			BOOL success_disconnect = FALSE;
-			DS_ENTER_BLOCKING_PAL_SECTION;
-			success_disconnect = DisconnectNamedPipe (ipc_stream->pipe);
-			DS_EXIT_BLOCKING_PAL_SECTION;
-			if (success_disconnect != TRUE && callback)
-				callback ("Failed to disconnect NamedPipe", GetLastError());
-		}
-		const BOOL success_close_pipe = CloseHandle (ipc_stream->pipe);
-		if (success_close_pipe != TRUE && callback)
-			callback ("Failed to close pipe handle", GetLastError());
-		ipc_stream->pipe = INVALID_HANDLE_VALUE;
-	}
-	if (ipc_stream->overlap.hEvent != INVALID_HANDLE_VALUE) {
-		const BOOL success_close_event = CloseHandle (ipc_stream->overlap.hEvent);
-		if (success_close_event != TRUE && callback)
-			callback ("Failed to close overlapped event handle", GetLastError());
-		memset(&ipc_stream->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
-		ipc_stream->overlap.hEvent = INVALID_HANDLE_VALUE;
-	}
-	ipc_stream->is_test_reading = false;
-	return true;
-}
-int32_t
-ds_ipc_stream_to_string (
-	DiagnosticsIpcStream *ipc_stream,
-	ep_char8_t *buffer,
-	uint32_t buffer_len)
-{
-	EP_ASSERT (ipc_stream != NULL);
-	EP_ASSERT (buffer != NULL);
-	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
-	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc_stream->pipe, (int32_t)(size_t)ipc_stream->overlap.hEvent);
-	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
-}
-#endif /* HOST_WIN32 */
-#endif /* ENABLE_PERFTRACING */
-#ifndef DS_INCLUDE_SOURCE_FILES
-extern const char quiet_linker_empty_file_warning_diagnostics_ipc_win32;
-const char quiet_linker_empty_file_warning_diagnostics_ipc_win32 = 0;
-#endif

--- a/src/native/external/zlib-intel/compress.c
+++ b//dev/null
@@ -1,74 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#define ZLIB_INTERNAL
-#include "zlib.h"
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2(dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-    const uInt max = (uInt)-1;
-    uLong left;
-    left = *destLen;
-    *destLen = 0;
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-    stream.next_out = dest;
-    stream.avail_out = 0;
-    stream.next_in = (z_const Bytef *)source;
-    stream.avail_in = 0;
-    do {
-        if (stream.avail_out == 0) {
-            stream.avail_out = left > (uLong)max ? max : (uInt)left;
-            left -= stream.avail_out;
-        }
-        if (stream.avail_in == 0) {
-            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
-            sourceLen -= stream.avail_in;
-        }
-        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
-    } while (err == Z_OK);
-    *destLen = stream.total_out;
-    deflateEnd(&stream);
-    return err == Z_STREAM_END ? Z_OK : err;
-}
-/* ===========================================================================
- */
-int ZEXPORT compress(dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound(sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13;
-}

--- a/src/native/external/zlib-intel/crc32.c
+++ b//dev/null
@@ -1,1011 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * This interleaved implementation of a CRC makes use of pipelined multiple
- * arithmetic-logic units, commonly found in modern CPU cores. It is due to
- * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.
- */
-/* @(#) $Id$ */
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
-  MAKECRCH can be #defined to write out crc32.h. A main() routine is also
-  produced, so that this one source file can be compiled to an executable.
- */
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-#include "zutil.h"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */
- /*
-  A CRC of a message is computed on N braids of words in the message, where
-  each word consists of W bytes (4 or 8). If N is 3, for example, then three
-  running sparse CRCs are calculated respectively on each braid, at these
-  indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...
-  This is done starting at a word boundary, and continues until as many blocks
-  of N * W bytes as are available have been processed. The results are combined
-  into a single CRC at the end. For this code, N must be in the range 1..6 and
-  W must be 4 or 8. The upper limit on N can be increased if desired by adding
-  more #if blocks, extending the patterns apparent in the code. In addition,
-  crc32.h would need to be regenerated, if the maximum N value is increased.
-  N and W are chosen empirically by benchmarking the execution time on a given
-  processor. The choices for N and W below were based on testing on Intel Kaby
-  Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64
-  Octeon II processors. The Intel, AMD, and ARM processors were all fastest
-  with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.
-  They were all tested with either gcc or clang, all using the -O3 optimization
-  level. Your mileage may vary.
- */
-/* Define N */
-#ifdef Z_TESTN
-#  define N Z_TESTN
-#else
-#  define N 5
-#endif
-#if N < 1 || N > 6
-#  error N must be in 1..6
-#endif
-/*
-  z_crc_t must be at least 32 bits. z_word_t must be at least as long as
-  z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and
-  that bytes are eight bits.
- */
-/*
-  Define W and the associated z_word_t type. If W is not defined, then a
-  braided calculation is not used, and the associated tables and code are not
-  compiled.
- */
-#ifdef Z_TESTW
-#  if Z_TESTW-1 != -1
-#    define W Z_TESTW
-#  endif
-#else
-#  ifdef MAKECRCH
-#    define W 8         /* required for MAKECRCH */
-#  else
-#    if defined(__x86_64__) || defined(__aarch64__)
-#      define W 8
-#    else
-#      define W 4
-#    endif
-#  endif
-#endif
-#ifdef W
-#  if W == 8 && defined(Z_U8)
-     typedef Z_U8 z_word_t;
-#  elif defined(Z_U4)
-#    undef W
-#    define W 4
-     typedef Z_U4 z_word_t;
-#  else
-#    undef W
-#  endif
-#endif
-/* If available, use the ARM processor CRC32 instruction. */
-#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8
-#  define ARMCRC32
-#endif
-/* Local functions. */
-local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));
-local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));
-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
-    local z_word_t byte_swap OF((z_word_t word));
-#endif
-#if defined(W) && !defined(ARMCRC32)
-    local z_crc_t crc_word OF((z_word_t data));
-    local z_word_t crc_word_big OF((z_word_t data));
-#endif
-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
-/*
-  Swap the bytes in a z_word_t to convert between little and big endian. Any
-  self-respecting compiler will optimize this to a single machine byte-swap
-  instruction, if one is available. This assumes that word_t is either 32 bits
-  or 64 bits.
- */
-local z_word_t byte_swap(word)
-    z_word_t word;
-{
-#  if W == 8
-    return
-        (word & 0xff00000000000000) >> 56 |
-        (word & 0xff000000000000) >> 40 |
-        (word & 0xff0000000000) >> 24 |
-        (word & 0xff00000000) >> 8 |
-        (word & 0xff000000) << 8 |
-        (word & 0xff0000) << 24 |
-        (word & 0xff00) << 40 |
-        (word & 0xff) << 56;
-#  else   /* W == 4 */
-    return
-        (word & 0xff000000) >> 24 |
-        (word & 0xff0000) >> 8 |
-        (word & 0xff00) << 8 |
-        (word & 0xff) << 24;
-#  endif
-}
-#endif
-/* CRC polynomial. */
-#define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */
-#ifdef DYNAMIC_CRC_TABLE
-local z_crc_t FAR crc_table[256];
-local z_crc_t FAR x2n_table[32];
-local void make_crc_table OF((void));
-#ifdef W
-   local z_word_t FAR crc_big_table[256];
-   local z_crc_t FAR crc_braid_table[W][256];
-   local z_word_t FAR crc_braid_big_table[W][256];
-   local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));
-#endif
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const z_crc_t FAR *, int));
-   local void write_table32hi OF((FILE *, const z_word_t FAR *, int));
-   local void write_table64 OF((FILE *, const z_word_t FAR *, int));
-#endif /* MAKECRCH */
-/*
-  Define a once() function depending on the availability of atomics. If this is
-  compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in
-  multiple threads, and if atomics are not available, then get_crc_table() must
-  be called to initialize the tables and must return before any threads are
-  allowed to compute or combine CRCs.
- */
-/* Definition of once functionality. */
-typedef struct once_s once_t;
-local void once OF((once_t *, void (*)(void)));
-/* Check for the availability of atomics. */
-#if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \
-    !defined(__STDC_NO_ATOMICS__)
-#include <stdatomic.h>
-/* Structure for once(), which must be initialized with ONCE_INIT. */
-struct once_s {
-    atomic_flag begun;
-    atomic_int done;
-};
-#define ONCE_INIT {ATOMIC_FLAG_INIT, 0}
-/*
-  Run the provided init() function exactly once, even if multiple threads
-  invoke once() at the same time. The state must be a once_t initialized with
-  ONCE_INIT.
- */
-local void once(state, init)
-    once_t *state;
-    void (*init)(void);
-{
-    if (!atomic_load(&state->done)) {
-        if (atomic_flag_test_and_set(&state->begun))
-            while (!atomic_load(&state->done))
-                ;
-        else {
-            init();
-            atomic_store(&state->done, 1);
-        }
-    }
-}
-#else   /* no atomics */
-/* Structure for once(), which must be initialized with ONCE_INIT. */
-struct once_s {
-    volatile int begun;
-    volatile int done;
-};
-#define ONCE_INIT {0, 0}
-/* Test and set. Alas, not atomic, but tries to minimize the period of
-   vulnerability. */
-local int test_and_set OF((int volatile *));
-local int test_and_set(flag)
-    int volatile *flag;
-{
-    int was;
-    was = *flag;
-    *flag = 1;
-    return was;
-}
-/* Run the provided init() function once. This is not thread-safe. */
-local void once(state, init)
-    once_t *state;
-    void (*init)(void);
-{
-    if (!state->done) {
-        if (test_and_set(&state->begun))
-            while (!state->done)
-                ;
-        else {
-            init();
-            state->done = 1;
-        }
-    }
-}
-#endif
-/* State for once(). */
-local once_t made = ONCE_INIT;
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit. Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one. If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder. The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x
-  (which is shifting right by one and adding x^32 mod p if the bit shifted out
-  is a one). We start with the highest power (least significant bit) of q and
-  repeat for all eight bits of q.
-  The table is simply the CRC of all possible eight bit values. This is all the
-  information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.
- */
-local void make_crc_table()
-{
-    unsigned i, j, n;
-    z_crc_t p;
-    /* initialize the CRC of bytes tables */
-    for (i = 0; i < 256; i++) {
-        p = i;
-        for (j = 0; j < 8; j++)
-            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;
-        crc_table[i] = p;
-#ifdef W
-        crc_big_table[i] = byte_swap(p);
-#endif
-    }
-    /* initialize the x^2^n mod p(x) table */
-    p = (z_crc_t)1 << 30;         /* x^1 */
-    x2n_table[0] = p;
-    for (n = 1; n < 32; n++)
-        x2n_table[n] = p = multmodp(p, p);
-#ifdef W
-    /* initialize the braiding tables -- needs x2n_table[] */
-    braid(crc_braid_table, crc_braid_big_table, N, W);
-#endif
-#ifdef MAKECRCH
-    {
-        /*
-          The crc32.h header file contains tables for both 32-bit and 64-bit
-          z_word_t's, and so requires a 64-bit type be available. In that case,
-          z_word_t must be defined to be 64-bits. This code then also generates
-          and writes out the tables for the case that z_word_t is 32 bits.
-         */
-#if !defined(W) || W != 8
-#  error Need a 64-bit integer type in order to generate crc32.h.
-#endif
-        FILE *out;
-        int k, n;
-        z_crc_t ltl[8][256];
-        z_word_t big[8][256];
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        /* write out little-endian CRC table to crc32.h */
-        fprintf(out,
-            "/* crc32.h -- tables for rapid CRC calculation\n"
-            " * Generated automatically by crc32.c\n */\n"
-            "\n"
-            "local const z_crc_t FAR crc_table[] = {\n"
-            "    ");
-        write_table(out, crc_table, 256);
-        fprintf(out,
-            "};\n");
-        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */
-        fprintf(out,
-            "\n"
-            "#ifdef W\n"
-            "\n"
-            "#if W == 8\n"
-            "\n"
-            "local const z_word_t FAR crc_big_table[] = {\n"
-            "    ");
-        write_table64(out, crc_big_table, 256);
-        fprintf(out,
-            "};\n");
-        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */
-        fprintf(out,
-            "\n"
-            "#else /* W == 4 */\n"
-            "\n"
-            "local const z_word_t FAR crc_big_table[] = {\n"
-            "    ");
-        write_table32hi(out, crc_big_table, 256);
-        fprintf(out,
-            "};\n"
-            "\n"
-            "#endif\n");
-        /* write out braid tables for each value of N */
-        for (n = 1; n <= 6; n++) {
-            fprintf(out,
-            "\n"
-            "#if N == %d\n", n);
-            /* compute braid tables for this N and 64-bit word_t */
-            braid(ltl, big, n, 8);
-            /* write out braid tables for 64-bit z_word_t to crc32.h */
-            fprintf(out,
-            "\n"
-            "#if W == 8\n"
-            "\n"
-            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
-            for (k = 0; k < 8; k++) {
-                fprintf(out, "   {");
-                write_table(out, ltl[k], 256);
-                fprintf(out, "}%s", k < 7 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
-            for (k = 0; k < 8; k++) {
-                fprintf(out, "   {");
-                write_table64(out, big[k], 256);
-                fprintf(out, "}%s", k < 7 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n");
-            /* compute braid tables for this N and 32-bit word_t */
-            braid(ltl, big, n, 4);
-            /* write out braid tables for 32-bit z_word_t to crc32.h */
-            fprintf(out,
-            "\n"
-            "#else /* W == 4 */\n"
-            "\n"
-            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
-            for (k = 0; k < 4; k++) {
-                fprintf(out, "   {");
-                write_table(out, ltl[k], 256);
-                fprintf(out, "}%s", k < 3 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
-            for (k = 0; k < 4; k++) {
-                fprintf(out, "   {");
-                write_table32hi(out, big[k], 256);
-                fprintf(out, "}%s", k < 3 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "#endif\n"
-            "\n"
-            "#endif\n");
-        }
-        fprintf(out,
-            "\n"
-            "#endif\n");
-        /* write out zeros operator table to crc32.h */
-        fprintf(out,
-            "\n"
-            "local const z_crc_t FAR x2n_table[] = {\n"
-            "    ");
-        write_table(out, x2n_table, 32);
-        fprintf(out,
-            "};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-#ifdef MAKECRCH
-/*
-   Write the 32-bit values in table[0..k-1] to out, five per line in
-   hexadecimal separated by commas.
- */
-local void write_table(out, table, k)
-    FILE *out;
-    const z_crc_t FAR *table;
-    int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
-                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
-}
-/*
-   Write the high 32-bits of each value in table[0..k-1] to out, five per line
-   in hexadecimal separated by commas.
- */
-local void write_table32hi(out, table, k)
-FILE *out;
-const z_word_t FAR *table;
-int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
-                (unsigned long)(table[n] >> 32),
-                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
-}
-/*
-  Write the 64-bit values in table[0..k-1] to out, three per line in
-  hexadecimal separated by commas. This assumes that if there is a 64-bit
-  type, then there is also a long long integer type, and it is at least 64
-  bits. If not, then the type cast and format string can be adjusted
-  accordingly.
- */
-local void write_table64(out, table, k)
-    FILE *out;
-    const z_word_t FAR *table;
-    int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%016llx%s", n == 0 || n % 3 ? "" : "    ",
-                (unsigned long long)(table[n]),
-                n == k - 1 ? "" : (n % 3 == 2 ? ",\n" : ", "));
-}
-/* Actually do the deed. */
-int main()
-{
-    make_crc_table();
-    return 0;
-}
-#endif /* MAKECRCH */
-#ifdef W
-/*
-  Generate the little and big-endian braid tables for the given n and z_word_t
-  size w. Each array must have room for w blocks of 256 elements.
- */
-local void braid(ltl, big, n, w)
-    z_crc_t ltl[][256];
-    z_word_t big[][256];
-    int n;
-    int w;
-{
-    int k;
-    z_crc_t i, p, q;
-    for (k = 0; k < w; k++) {
-        p = x2nmodp((n * w + 3 - k) << 3, 0);
-        ltl[k][0] = 0;
-        big[w - 1 - k][0] = 0;
-        for (i = 1; i < 256; i++) {
-            ltl[k][i] = q = multmodp(i << 24, p);
-            big[w - 1 - k][i] = byte_swap(q);
-        }
-    }
-}
-#endif
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables for byte-wise and braided CRC-32 calculations, and a table of powers
- * of x for combining CRC-32s, all made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Routines used for CRC calculation. Some are also required for the table
- * generation above.
- */
-/*
-  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,
-  reflected. For speed, this requires that a not be zero.
- */
-local z_crc_t multmodp(a, b)
-    z_crc_t a;
-    z_crc_t b;
-{
-    z_crc_t m, p;
-    m = (z_crc_t)1 << 31;
-    p = 0;
-    for (;;) {
-        if (a & m) {
-            p ^= b;
-            if ((a & (m - 1)) == 0)
-                break;
-        }
-        m >>= 1;
-        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
-    }
-    return p;
-}
-/*
-  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been
-  initialized.
- */
-local z_crc_t x2nmodp(n, k)
-    z_off64_t n;
-    unsigned k;
-{
-    z_crc_t p;
-    p = (z_crc_t)1 << 31;           /* x^0 == 1 */
-    while (n) {
-        if (n & 1)
-            p = multmodp(x2n_table[k & 31], p);
-        n >>= 1;
-        k++;
-    }
-    return p;
-}
-/* =========================================================================
- * This function can be used by asm versions of crc32(), and to force the
- * generation of the CRC tables in a threaded application.
- */
-const z_crc_t FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const z_crc_t FAR *)crc_table;
-}
-/* =========================================================================
- * Use ARM machine instructions if available. This will compute the CRC about
- * ten times faster than the braided calculation. This code does not check for
- * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will
- * only be defined if the compilation specifies an ARM processor architecture
- * that has the instructions. For example, compiling with -march=armv8.1-a or
- * -march=armv8-a+crc, or -march=native if the compile machine has the crc32
- * instructions.
- */
-#ifdef ARMCRC32
-/*
-   Constants empirically determined to maximize speed. These values are from
-   measurements on a Cortex-A57. Your mileage may vary.
- */
-#define Z_BATCH 3990                /* number of words in a batch */
-#define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */
-#define Z_BATCH_MIN 800             /* fewest words in a final batch */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    z_crc_t val;
-    z_word_t crc1, crc2;
-    const z_word_t *word;
-    z_word_t val0, val1, val2;
-    z_size_t last, last2, i;
-    z_size_t num;
-    /* Return initial CRC, if requested. */
-    if (buf == Z_NULL) return 0;
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    /* Pre-condition the CRC */
-    crc = (~crc) & 0xffffffff;
-    /* Compute the CRC up to a word boundary. */
-    while (len && ((z_size_t)buf & 7) != 0) {
-        len--;
-        val = *buf++;
-        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
-    }
-    /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */
-    word = (z_word_t const *)buf;
-    num = len >> 3;
-    len &= 7;
-    /* Do three interleaved CRCs to realize the throughput of one crc32x
-       instruction per cycle. Each CRC is calculated on Z_BATCH words. The
-       three CRCs are combined into a single CRC after each set of batches. */
-    while (num >= 3 * Z_BATCH) {
-        crc1 = 0;
-        crc2 = 0;
-        for (i = 0; i < Z_BATCH; i++) {
-            val0 = word[i];
-            val1 = word[i + Z_BATCH];
-            val2 = word[i + 2 * Z_BATCH];
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
-        }
-        word += 3 * Z_BATCH;
-        num -= 3 * Z_BATCH;
-        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;
-        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;
-    }
-    /* Do one last smaller batch with the remaining words, if there are enough
-       to pay for the combination of CRCs. */
-    last = num / 3;
-    if (last >= Z_BATCH_MIN) {
-        last2 = last << 1;
-        crc1 = 0;
-        crc2 = 0;
-        for (i = 0; i < last; i++) {
-            val0 = word[i];
-            val1 = word[i + last];
-            val2 = word[i + last2];
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
-        }
-        word += 3 * last;
-        num -= 3 * last;
-        val = x2nmodp(last, 6);
-        crc = multmodp(val, crc) ^ crc1;
-        crc = multmodp(val, crc) ^ crc2;
-    }
-    /* Compute the CRC on any remaining words. */
-    for (i = 0; i < num; i++) {
-        val0 = word[i];
-        __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-    }
-    word += num;
-    /* Complete the CRC on any remaining bytes. */
-    buf = (const unsigned char FAR *)word;
-    while (len) {
-        len--;
-        val = *buf++;
-        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
-    }
-    /* Return the CRC, post-conditioned. */
-    return crc ^ 0xffffffff;
-}
-#else
-#ifdef W
-/*
-  Return the CRC of the W bytes in the word_t data, taking the
-  least-significant byte of the word as the first byte of data, without any pre
-  or post conditioning. This is used to combine the CRCs of each braid.
- */
-local z_crc_t crc_word(data)
-    z_word_t data;
-{
-    int k;
-    for (k = 0; k < W; k++)
-        data = (data >> 8) ^ crc_table[data & 0xff];
-    return (z_crc_t)data;
-}
-local z_word_t crc_word_big(data)
-    z_word_t data;
-{
-    int k;
-    for (k = 0; k < W; k++)
-        data = (data << 8) ^
-            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];
-    return data;
-}
-#endif
-/* ========================================================================= */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    /* Return initial CRC, if requested. */
-    if (buf == Z_NULL) return 0;
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    /* Pre-condition the CRC */
-    crc = (~crc) & 0xffffffff;
-#ifdef W
-    /* If provided enough bytes, do a braided CRC calculation. */
-    if (len >= N * W + W - 1) {
-        z_size_t blks;
-        z_word_t const *words;
-        unsigned endian;
-        int k;
-        /* Compute the CRC up to a z_word_t boundary. */
-        while (len && ((z_size_t)buf & (W - 1)) != 0) {
-            len--;
-            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        }
-        /* Compute the CRC on as many N z_word_t blocks as are available. */
-        blks = len / (N * W);
-        len -= blks * N * W;
-        words = (z_word_t const *)buf;
-        /* Do endian check at execution time instead of compile time, since ARM
-           processors can change the endianess at execution time. If the
-           compiler knows what the endianess will be, it can optimize out the
-           check and the unused branch. */
-        endian = 1;
-        if (*(unsigned char *)&endian) {
-            /* Little endian. */
-            z_crc_t crc0;
-            z_word_t word0;
-#if N > 1
-            z_crc_t crc1;
-            z_word_t word1;
-#if N > 2
-            z_crc_t crc2;
-            z_word_t word2;
-#if N > 3
-            z_crc_t crc3;
-            z_word_t word3;
-#if N > 4
-            z_crc_t crc4;
-            z_word_t word4;
-#if N > 5
-            z_crc_t crc5;
-            z_word_t word5;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /* Initialize the CRC for each braid. */
-            crc0 = crc;
-#if N > 1
-            crc1 = 0;
-#if N > 2
-            crc2 = 0;
-#if N > 3
-            crc3 = 0;
-#if N > 4
-            crc4 = 0;
-#if N > 5
-            crc5 = 0;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /*
-              Process the first blks-1 blocks, computing the CRCs on each braid
-              independently.
-             */
-            while (--blks) {
-                /* Load the word for each braid into registers. */
-                word0 = crc0 ^ words[0];
-#if N > 1
-                word1 = crc1 ^ words[1];
-#if N > 2
-                word2 = crc2 ^ words[2];
-#if N > 3
-                word3 = crc3 ^ words[3];
-#if N > 4
-                word4 = crc4 ^ words[4];
-#if N > 5
-                word5 = crc5 ^ words[5];
-#endif
-#endif
-#endif
-#endif
-#endif
-                words += N;
-                /* Compute and update the CRC for each word. The loop should
-                   get unrolled. */
-                crc0 = crc_braid_table[0][word0 & 0xff];
-#if N > 1
-                crc1 = crc_braid_table[0][word1 & 0xff];
-#if N > 2
-                crc2 = crc_braid_table[0][word2 & 0xff];
-#if N > 3
-                crc3 = crc_braid_table[0][word3 & 0xff];
-#if N > 4
-                crc4 = crc_braid_table[0][word4 & 0xff];
-#if N > 5
-                crc5 = crc_braid_table[0][word5 & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                for (k = 1; k < W; k++) {
-                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
-#if N > 1
-                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
-#if N > 2
-                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
-#if N > 3
-                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
-#if N > 4
-                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
-#if N > 5
-                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                }
-            }
-            /*
-              Process the last block, combining the CRCs of the N braids at the
-              same time.
-             */
-            crc = crc_word(crc0 ^ words[0]);
-#if N > 1
-            crc = crc_word(crc1 ^ words[1] ^ crc);
-#if N > 2
-            crc = crc_word(crc2 ^ words[2] ^ crc);
-#if N > 3
-            crc = crc_word(crc3 ^ words[3] ^ crc);
-#if N > 4
-            crc = crc_word(crc4 ^ words[4] ^ crc);
-#if N > 5
-            crc = crc_word(crc5 ^ words[5] ^ crc);
-#endif
-#endif
-#endif
-#endif
-#endif
-            words += N;
-        }
-        else {
-            /* Big endian. */
-            z_word_t crc0, word0, comb;
-#if N > 1
-            z_word_t crc1, word1;
-#if N > 2
-            z_word_t crc2, word2;
-#if N > 3
-            z_word_t crc3, word3;
-#if N > 4
-            z_word_t crc4, word4;
-#if N > 5
-            z_word_t crc5, word5;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /* Initialize the CRC for each braid. */
-            crc0 = byte_swap(crc);
-#if N > 1
-            crc1 = 0;
-#if N > 2
-            crc2 = 0;
-#if N > 3
-            crc3 = 0;
-#if N > 4
-            crc4 = 0;
-#if N > 5
-            crc5 = 0;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /*
-              Process the first blks-1 blocks, computing the CRCs on each braid
-              independently.
-             */
-            while (--blks) {
-                /* Load the word for each braid into registers. */
-                word0 = crc0 ^ words[0];
-#if N > 1
-                word1 = crc1 ^ words[1];
-#if N > 2
-                word2 = crc2 ^ words[2];
-#if N > 3
-                word3 = crc3 ^ words[3];
-#if N > 4
-                word4 = crc4 ^ words[4];
-#if N > 5
-                word5 = crc5 ^ words[5];
-#endif
-#endif
-#endif
-#endif
-#endif
-                words += N;
-                /* Compute and update the CRC for each word. The loop should
-                   get unrolled. */
-                crc0 = crc_braid_big_table[0][word0 & 0xff];
-#if N > 1
-                crc1 = crc_braid_big_table[0][word1 & 0xff];
-#if N > 2
-                crc2 = crc_braid_big_table[0][word2 & 0xff];
-#if N > 3
-                crc3 = crc_braid_big_table[0][word3 & 0xff];
-#if N > 4
-                crc4 = crc_braid_big_table[0][word4 & 0xff];
-#if N > 5
-                crc5 = crc_braid_big_table[0][word5 & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                for (k = 1; k < W; k++) {
-                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
-#if N > 1
-                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
-#if N > 2
-                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
-#if N > 3
-                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
-#if N > 4
-                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
-#if N > 5
-                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                }
-            }
-            /*
-              Process the last block, combining the CRCs of the N braids at the
-              same time.
-             */
-            comb = crc_word_big(crc0 ^ words[0]);
-#if N > 1
-            comb = crc_word_big(crc1 ^ words[1] ^ comb);
-#if N > 2
-            comb = crc_word_big(crc2 ^ words[2] ^ comb);
-#if N > 3
-            comb = crc_word_big(crc3 ^ words[3] ^ comb);
-#if N > 4
-            comb = crc_word_big(crc4 ^ words[4] ^ comb);
-#if N > 5
-            comb = crc_word_big(crc5 ^ words[5] ^ comb);
-#endif
-#endif
-#endif
-#endif
-#endif
-            words += N;
-            crc = byte_swap(comb);
-        }
-        /*
-          Update the pointer to the remaining bytes to process.
-         */
-        buf = (unsigned char const *)words;
-    }
-#endif /* W */
-    /* Complete the computation of the CRC on any remaining bytes. */
-    while (len >= 8) {
-        len -= 8;
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-    }
-    while (len) {
-        len--;
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-    }
-    /* Return the CRC, post-conditioned. */
-    return crc ^ 0xffffffff;
-}
-#endif
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    uInt len;
-{
-    return crc32_z(crc, buf, len);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    return crc32_combine64(crc1, crc2, (z_off64_t)len2);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_gen64(len2)
-    z_off64_t len2;
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return x2nmodp(len2, 3);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_gen(len2)
-    z_off_t len2;
-{
-    return crc32_combine_gen64((z_off64_t)len2);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_op(crc1, crc2, op)
-    uLong crc1;
-    uLong crc2;
-    uLong op;
-{
-    return multmodp(op, crc1) ^ (crc2 & 0xffffffff);
-}

--- a/src/native/external/zlib-intel/deflate.c
+++ b//dev/null
@@ -1,1849 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://tools.ietf.org/html/rfc1951
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-/* @(#) $Id$ */
-#include "deflate.h"
-const char deflate_copyright[] =
-   " deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-local int deflateStateCheck      OF((z_streamp strm));
-local void slide_hash     OF((deflate_state *s));
-local void slide_hash_c     OF((deflate_state *s));
-#ifdef USE_SSE_SLIDE
-extern void slide_hash_sse(deflate_state *s);
-#endif
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-#ifdef USE_QUICK
-block_state deflate_quick OF((deflate_state *s, int flush));
-#endif
-#ifdef USE_MEDIUM
-block_state deflate_medium OF((deflate_state *s, int flush));
-#endif
-local block_state deflate_rle    OF((deflate_state *s, int flush));
-local block_state deflate_huff   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
-ZLIB_INTERNAL void fill_window(deflate_state *s);
-/* ===========================================================================
- * Local data
- */
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-#ifdef USE_QUICK
-/* 1 */ {4,    4,  8,    4, deflate_quick},
-/* 1 */ {4,    4,  8,    4, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-#else
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-#endif
-#ifdef USE_MEDIUM
-/* 4 */ {4,    4, 16,   16, deflate_medium},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_medium},
-/* 6 */ {8,   16, 128, 128, deflate_medium},
-#else
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-#endif
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
-#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to INSERT_STRING are made with consecutive input
- *    characters and the first MIN_MATCH bytes of str are valid (except for
- *    the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    do { \
-        s->head[s->hash_size - 1] = NIL; \
-        zmemzero((Bytef *)s->head, \
-                 (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \
-    } while (0)
-/* ===========================================================================
- * Slide the hash table when sliding the window down (could be avoided with 32
- * bit values at the expense of memory usage). We slide even when level == 0 to
- * keep the hash table consistent if we switch back to level > 0 later.
- */
-local void slide_hash_c(s)
-    deflate_state *s;
-{
-    unsigned n, m;
-    Posf *p;
-    uInt wsize = s->w_size;
-    n = s->hash_size;
-    p = &s->head[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-    } while (--n);
-    n = wsize;
-#ifndef FASTEST
-    p = &s->prev[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-        /* If n is not on any hash chain, prev[n] is garbage but
-         * its value will never be used.
-         */
-    } while (--n);
-#endif
-}
-local void slide_hash(deflate_state *s)
-{
-#ifdef USE_SSE_SLIDE
-    if (x86_cpu_has_sse2)
-        slide_hash_sse(s);
-    else
-#endif
-        slide_hash_c(s);
-}
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    unsigned window_padding = 0;
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-#if defined(ZLIB_X86)
-    x86_check_features();
-#endif
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        if (windowBits < -15)
-            return Z_STREAM_ERROR;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-#ifdef USE_QUICK
-    if (level == 1 && windowBits > 13)
-        windowBits = 13;
-#endif
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = (uInt)windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-    s->hash_bits = (uInt)memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
-#if defined(USE_PCLMUL_CRC)
-    window_padding = 8;
-#endif
-    s->window = (Bytef *) ZALLOC(strm, s->w_size + window_padding, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-    s->high_water = 0;      /* nothing written to s->window yet */
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-    /* We overlay pending_buf and sym_buf. This works since the average size
-     * for length/distance pairs over any compressed block is assured to be 31
-     * bits or less.
-     *
-     * Analysis: The longest fixed codes are a length code of 8 bits plus 5
-     * extra bits, for lengths 131 to 257. The longest fixed distance codes are
-     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
-     * possible fixed-codes length/distance pair is then 31 bits total.
-     *
-     * sym_buf starts one-fourth of the way into pending_buf. So there are
-     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
-     * in sym_buf is three bytes -- two for the distance and one for the
-     * literal/length. As each symbol is consumed, the pointer to the next
-     * sym_buf value to read moves forward three bytes. From that symbol, up to
-     * 31 bits are written to pending_buf. The closest the written pending_buf
-     * bits gets to the next sym_buf symbol to read is just before the last
-     * code is written. At that time, 31*(n - 2) bits have been written, just
-     * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
-     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
-     * symbols are written.) The closest the writing gets to what is unread is
-     * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
-     * can range from 128 to 32768.
-     *
-     * Therefore, at a minimum, there are 142 bits of space between what is
-     * written and what is read in the overlain buffers, so the symbols cannot
-     * be overwritten by the compressed data. That space is actually 139 bits,
-     * due to the three-bit fixed-code block header.
-     *
-     * That covers the case where either Z_FIXED is specified, forcing fixed
-     * codes, or when the use of fixed codes is chosen, because that choice
-     * results in a smaller compressed block than dynamic codes. That latter
-     * condition then assures that the above analysis also covers all dynamic
-     * blocks. A dynamic-code block will only be chosen to be emitted if it has
-     * fewer bits than a fixed-code block would for the same set of symbols.
-     * Therefore its average symbol length is assured to be less than 31. So
-     * the compressed data for a dynamic block also cannot overwrite the
-     * symbols from which it is being constructed.
-     */
-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);
-    s->pending_buf_size = (ulg)s->lit_bufsize * 4;
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->sym_buf = s->pending_buf + s->lit_bufsize;
-    s->sym_end = (s->lit_bufsize - 1) * 3;
-    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-    return deflateReset(strm);
-}
-/* =========================================================================
- * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
- */
-local int deflateStateCheck(strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    s = strm->state;
-    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
-#ifdef GZIP
-                                           s->status != GZIP_STATE &&
-#endif
-                                           s->status != EXTRA_STATE &&
-                                           s->status != NAME_STATE &&
-                                           s->status != COMMENT_STATE &&
-                                           s->status != HCRC_STATE &&
-                                           s->status != BUSY_STATE &&
-                                           s->status != FINISH_STATE))
-        return 1;
-    return 0;
-}
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt str, n;
-    int wrap;
-    unsigned avail;
-    z_const unsigned char *next;
-    if (deflateStateCheck(strm) || dictionary == Z_NULL)
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    wrap = s->wrap;
-    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
-        return Z_STREAM_ERROR;
-    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
-    if (wrap == 1)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
-    /* if dictionary would fill window, just replace the history */
-    if (dictLength >= s->w_size) {
-        if (wrap == 0) {            /* already empty otherwise */
-            CLEAR_HASH(s);
-            s->strstart = 0;
-            s->block_start = 0L;
-            s->insert = 0;
-        }
-        dictionary += dictLength - s->w_size;  /* use the tail */
-        dictLength = s->w_size;
-    }
-    /* insert dictionary into window and hash */
-    avail = strm->avail_in;
-    next = strm->next_in;
-    strm->avail_in = dictLength;
-    strm->next_in = (z_const Bytef *)dictionary;
-    fill_window(s);
-    while (s->lookahead >= MIN_MATCH) {
-        str = s->strstart;
-        n = s->lookahead - (MIN_MATCH-1);
-        do {
-            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-            s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-            s->head[s->ins_h] = (Pos)str;
-            str++;
-        } while (--n);
-        s->strstart = str;
-        s->lookahead = MIN_MATCH-1;
-        fill_window(s);
-    }
-    s->strstart += s->lookahead;
-    s->block_start = (long)s->strstart;
-    s->insert = s->lookahead;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    strm->next_in = next;
-    strm->avail_in = avail;
-    s->wrap = wrap;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)
-    z_streamp strm;
-    Bytef *dictionary;
-    uInt  *dictLength;
-{
-    deflate_state *s;
-    uInt len;
-    if (deflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    len = s->strstart + s->lookahead;
-    if (len > s->w_size)
-        len = s->w_size;
-    if (dictionary != Z_NULL && len)
-        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
-    if (dictLength != Z_NULL)
-        *dictLength = len;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateResetKeep(strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (deflateStateCheck(strm)) {
-        return Z_STREAM_ERROR;
-    }
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status =
-#ifdef GZIP
-        s->wrap == 2 ? GZIP_STATE :
-#endif
-        INIT_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = -2;
-#if defined(USE_PCLMUL_CRC)
-    if (x86_cpu_has_pclmul) {
-        crc_fold_init(s->crc0);
-    }
-#endif
-    _tr_init(s);
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateReset(strm)
-    z_streamp strm;
-{
-    int ret;
-    ret = deflateResetKeep(strm);
-    if (ret == Z_OK)
-        lm_init(strm->state);
-    return ret;
-}
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader(strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (deflateStateCheck(strm) || strm->state->wrap != 2)
-        return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflatePending(strm, pending, bits)
-    unsigned *pending;
-    int *bits;
-    z_streamp strm;
-{
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    if (pending != Z_NULL)
-        *pending = strm->state->pending;
-    if (bits != Z_NULL)
-        *bits = strm->state->bi_valid;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflatePrime(strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    deflate_state *s;
-    int put;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    if (bits < 0 || bits > 16 ||
-        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
-        return Z_BUF_ERROR;
-    do {
-        put = Buf_size - s->bi_valid;
-        if (put > bits)
-            put = bits;
-        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
-        s->bi_valid += put;
-        _tr_flush_bits(s);
-        value >>= put;
-        bits -= put;
-    } while (bits);
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-    if ((strategy != s->strategy || func != configuration_table[level].func) &&
-        s->last_flush != -2) {
-        /* Flush the last buffer: */
-        int err = deflate(strm, Z_BLOCK);
-        if (err == Z_STREAM_ERROR)
-            return err;
-        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
-            return Z_BUF_ERROR;
-    }
-    if (s->level != level) {
-        if (s->level == 0 && s->matches != 0) {
-            if (s->matches == 1)
-                slide_hash(s);
-            else
-                CLEAR_HASH(s);
-            s->matches = 0;
-        }
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = (uInt)good_length;
-    s->max_lazy_match = (uInt)max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = (uInt)max_chain;
-    return Z_OK;
-}
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns a
- * close to exact, as well as small, upper bound on the compressed size. This
- * is an expansion of ~0.03%, plus a small constant.
- *
- * For any setting other than those defaults for windowBits and memLevel, one
- * of two worst case bounds is returned. This is at most an expansion of ~4% or
- * ~13%, plus a small constant.
- *
- * Both the 0.03% and 4% derive from the overhead of stored blocks. The first
- * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second
- * is for stored blocks of 127 bytes (the worst case memLevel == 1). The
- * expansion results from five bytes of header for each stored block.
- *
- * The larger expansion of 13% results from a window size less than or equal to
- * the symbols buffer size (windowBits <= memLevel + 7). In that case some of
- * the data being compressed may have slid out of the sliding window, impeding
- * a stored block from being emitted. Then the only choice is a fixed or
- * dynamic block, where a fixed block limits the maximum expansion to 9 bits
- * per 8-bit byte, plus 10 bits for every block. The smallest block size for
- * which this can occur is 255 (memLevel == 2).
- *
- * Shifts are used to approximate divisions, for speed.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong fixedlen, storelen, wraplen;
-    /* upper bound for fixed blocks with 9-bit literals and length 255
-       (memLevel == 2, which is the lowest that may not use stored blocks) --
-       ~13% overhead plus a small constant */
-    fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +
-               (sourceLen >> 9) + 4;
-    /* upper bound for stored blocks with length 127 (memLevel == 1) --
-       ~4% overhead plus a small constant */
-    storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +
-               (sourceLen >> 11) + 7;
-    /* if can't get parameters, return larger bound plus a zlib wrapper */
-    if (deflateStateCheck(strm))
-        return (fixedlen > storelen ? fixedlen : storelen) + 6;
-    /* compute wrapper length */
-    s = strm->state;
-    switch (s->wrap) {
-    case 0:                                 /* raw deflate */
-        wraplen = 0;
-        break;
-    case 1:                                 /* zlib wrapper */
-        wraplen = 6 + (s->strstart ? 4 : 0);
-        break;
-#ifdef GZIP
-    case 2:                                 /* gzip wrapper */
-        wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            Bytef *str;
-            if (s->gzhead->extra != Z_NULL)
-                wraplen += 2 + s->gzhead->extra_len;
-            str = s->gzhead->name;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            str = s->gzhead->comment;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            if (s->gzhead->hcrc)
-                wraplen += 2;
-        }
-        break;
-#endif
-    default:                                /* for compiler happiness */
-        wraplen = 6;
-    }
-    /* if not default parameters, return one of the conservative bounds */
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return (s->w_bits <= s->hash_bits ? fixedlen : storelen) + wraplen;
-    /* default settings: return tight bound for that case -- ~0.03% overhead
-       plus a small constant */
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13 - 6 + wraplen;
-}
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB(s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output, except for
- * some deflate_stored() output, goes through this function so some
- * applications may wish to modify it to avoid allocating a large
- * strm->next_out buffer and copying into it. (See also read_buf()).
- */
-ZLIB_INTERNAL void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len;
-    deflate_state *s = strm->state;
-    _tr_flush_bits(s);
-    len = s->pending;
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-    zmemcpy(strm->next_out, s->pending_out, len);
-    strm->next_out  += len;
-    s->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out -= len;
-    s->pending      -= len;
-    if (s->pending == 0) {
-        s->pending_out = s->pending_buf;
-    }
-}
-/* ===========================================================================
- * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
- */
-#define HCRC_UPDATE(beg) \
-    do { \
-        if (s->gzhead->hcrc && s->pending > (beg)) \
-            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
-                                s->pending - (beg)); \
-    } while (0)
-/* ========================================================================= */
-int ZEXPORT deflate(strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-    if (strm->next_out == Z_NULL ||
-        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-    /* Write the header */
-    if (s->status == INIT_STATE && s->wrap == 0)
-        s->status = BUSY_STATE;
-    if (s->status == INIT_STATE) {
-        /* zlib header */
-        uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
-        uInt level_flags;
-        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-            level_flags = 0;
-        else if (s->level < 6)
-            level_flags = 1;
-        else if (s->level == 6)
-            level_flags = 2;
-        else
-            level_flags = 3;
-        header |= (level_flags << 6);
-        if (s->strstart != 0) header |= PRESET_DICT;
-        header += 31 - (header % 31);
-        putShortMSB(s, header);
-        /* Save the adler32 of the preset dictionary: */
-        if (s->strstart != 0) {
-            putShortMSB(s, (uInt)(strm->adler >> 16));
-            putShortMSB(s, (uInt)(strm->adler & 0xffff));
-        }
-        strm->adler = adler32(0L, Z_NULL, 0);
-        s->status = BUSY_STATE;
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#ifdef GZIP
-    if (s->status == GZIP_STATE) {
-        /* gzip header */
-        strm->adler = crc32(0L, Z_NULL, 0);
-        put_byte(s, 31);
-        put_byte(s, 139);
-        put_byte(s, 8);
-        if (s->gzhead == Z_NULL) {
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, OS_CODE);
-            s->status = BUSY_STATE;
-            /* Compression must start with an empty pending buffer */
-            flush_pending(strm);
-            if (s->pending != 0) {
-                s->last_flush = -1;
-                return Z_OK;
-            }
-        }
-        else {
-            put_byte(s, (s->gzhead->text ? 1 : 0) +
-                     (s->gzhead->hcrc ? 2 : 0) +
-                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                     (s->gzhead->name == Z_NULL ? 0 : 8) +
-                     (s->gzhead->comment == Z_NULL ? 0 : 16)
-                     );
-            put_byte(s, (Byte)(s->gzhead->time & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, s->gzhead->os & 0xff);
-            if (s->gzhead->extra != Z_NULL) {
-                put_byte(s, s->gzhead->extra_len & 0xff);
-                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-            }
-            if (s->gzhead->hcrc)
-                strm->adler = crc32(strm->adler, s->pending_buf,
-                                    s->pending);
-            s->gzindex = 0;
-            s->status = EXTRA_STATE;
-        }
-    }
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
-            while (s->pending + left > s->pending_buf_size) {
-                uInt copy = s->pending_buf_size - s->pending;
-                zmemcpy(s->pending_buf + s->pending,
-                        s->gzhead->extra + s->gzindex, copy);
-                s->pending = s->pending_buf_size;
-                HCRC_UPDATE(beg);
-                s->gzindex += copy;
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-                beg = 0;
-                left -= copy;
-            }
-            zmemcpy(s->pending_buf + s->pending,
-                    s->gzhead->extra + s->gzindex, left);
-            s->pending += left;
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-        }
-        s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size) {
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-            }
-            put_byte(s, (Byte)(strm->adler & 0xff));
-            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-            strm->adler = crc32(0L, Z_NULL, 0);
-        }
-        s->status = BUSY_STATE;
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#endif
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-        if (s->level == 0)
-            bstate = deflate_stored(s, flush);
-	else if (s->strategy == Z_HUFFMAN_ONLY)
-            bstate = deflate_huff(s, flush);
-        else if (s->strategy == Z_RLE)
-            bstate = deflate_rle(s, flush);
-        else if (s->level == 1 && !x86_cpu_has_sse42)
-            bstate = deflate_fast(s, flush);
-        else
-	    bstate = (*configuration_table[s->level].func)(s, flush);
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                    if (s->lookahead == 0) {
-                        s->strstart = 0;
-                        s->block_start = 0L;
-                        s->insert = 0;
-                    }
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-#if defined(USE_PCLMUL_CRC)
-        if (x86_cpu_has_pclmul) {
-            s->strm->adler = crc_fold_512to32(s->crc0);
-        }
-#endif
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-/* ========================================================================= */
-int ZEXPORT deflateEnd(strm)
-    z_streamp strm;
-{
-    int status;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    status = strm->state->status;
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy(dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    if (deflateStateCheck(source) || dest == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-    ss = source->state;
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
-    ds->strm = dest;
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local unsigned read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-    if (len > size) len = size;
-    if (len == 0) return 0;
-    strm->avail_in  -= len;
-#ifdef GZIP
-    if (strm->state->wrap == 2) {
-#if defined(USE_PCLMUL_CRC)
-        if (x86_cpu_has_pclmul) {
-            crc_fold_copy(strm->state->crc0, buf, strm->next_in, len);
-        } else
-#endif
-        {
-            zmemcpy(buf, strm->next_in, len);
-            strm->adler = crc32(strm->adler, buf, len);
-        }
-    } else
-#endif
-    {
-        zmemcpy(buf, strm->next_in, len);
-        if (strm->state->wrap == 1)
-            strm->adler = adler32(strm->adler, buf, len);
-    }
-    strm->next_in  += len;
-    strm->total_in += len;
-    return len;
-}
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init(s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-    CLEAR_HASH(s);
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->insert = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-}
-#ifdef ZLIB_DEBUG
-#define EQUAL 0
-/* result of memcmp for equal strings */
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-ZLIB_INTERNAL void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start - match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#endif /* ZLIB_DEBUG */
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-ZLIB_INTERNAL void fill_window(s)
-    deflate_state *s;
-{
-    unsigned n;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize + MAX_DIST(s)) {
-            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-            if (s->insert > s->strstart)
-                s->insert = s->strstart;
-            slide_hash(s);
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) break;
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
-#ifdef USE_CRC_HASH
-	    if (!x86_cpu_has_sse42)
-#endif
-            {
-                s->ins_h = s->window[str];
-                UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-            }
-            while (s->insert) {
-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-                s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-                s->head[s->ins_h] = (Pos)str;
-                str++;
-                s->insert--;
-                if (s->lookahead + s->insert < MIN_MATCH)
-                    break;
-            }
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-    /* If the WIN_INIT bytes after the end of the current data have never been
-     * written, then zero those bytes in order to avoid memory check reports of
-     * the use of uninitialized (or uninitialised as Julian writes) bytes by
-     * the longest match routines.  Update the high water mark for the next
-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
-     */
-    if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
-        if (s->high_water < curr) {
-            /* Previous high water mark below current data -- zero WIN_INIT
-             * bytes or up to end of window, whichever is less.
-             */
-            init = s->window_size - curr;
-            if (init > WIN_INIT)
-                init = WIN_INIT;
-            zmemzero(s->window + curr, (unsigned)init);
-            s->high_water = curr + init;
-        }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
-            /* High water mark at or above current data, but below current data
-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
-             * to end of window, whichever is less.
-             */
-            init = (ulg)curr + WIN_INIT - s->high_water;
-            if (init > s->window_size - s->high_water)
-                init = s->window_size - s->high_water;
-            zmemzero(s->window + s->high_water, (unsigned)init);
-            s->high_water += init;
-        }
-    }
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "not enough room for search");
-}
-/* Maximum stored block length in deflate format (not including header). */
-#define MAX_STORED 65535
-/* Minimum of a and b. */
-#define MIN(a, b) ((a) > (b) ? (b) : (a))
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- *
- * In case deflateParams() is used to later switch to a non-zero compression
- * level, s->matches (otherwise unused when storing) keeps track of the number
- * of hash table slides to perform. If s->matches is 1, then one hash table
- * slide will be done when switching. If s->matches is 2, the maximum value
- * allowed here, then the hash table will be cleared, since two or more slides
- * is the same as a clear.
- *
- * deflate_stored() is written to minimize the number of times an input byte is
- * copied. It is most efficient with large input and output buffers, which
- * maximizes the opportunities to have a single copy from next_in to next_out.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Smallest worthy block size when not flushing or finishing. By default
-     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
-     * large input and output buffers, the stored block size will be larger.
-     */
-    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
-    /* Copy as many min_block or larger stored blocks directly to next_out as
-     * possible. If flushing, copy the remaining available input to next_out as
-     * stored blocks, if there is enough space.
-     */
-    unsigned len, left, have, last = 0;
-    unsigned used = s->strm->avail_in;
-    do {
-        /* Set len to the maximum size block that we can copy directly with the
-         * available input data and output space. Set left to how much of that
-         * would be copied from what's left in the window.
-         */
-        len = MAX_STORED;       /* maximum deflate stored block length */
-        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        if (s->strm->avail_out < have)          /* need room for header */
-            break;
-            /* maximum stored block length that will fit in avail_out: */
-        have = s->strm->avail_out - have;
-        left = s->strstart - s->block_start;    /* bytes left in window */
-        if (len > (ulg)left + s->strm->avail_in)
-            len = left + s->strm->avail_in;     /* limit len to the input */
-        if (len > have)
-            len = have;                         /* limit len to the output */
-        /* If the stored block would be less than min_block in length, or if
-         * unable to copy all of the available input when flushing, then try
-         * copying to the window and the pending buffer instead. Also don't
-         * write an empty block when flushing -- deflate() does that.
-         */
-        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
-                                flush == Z_NO_FLUSH ||
-                                len != left + s->strm->avail_in))
-            break;
-        /* Make a dummy stored block in pending to get the header bytes,
-         * including any pending bits. This also updates the debugging counts.
-         */
-        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
-        _tr_stored_block(s, (char *)0, 0L, last);
-        /* Replace the lengths in the dummy stored block with len. */
-        s->pending_buf[s->pending - 4] = len;
-        s->pending_buf[s->pending - 3] = len >> 8;
-        s->pending_buf[s->pending - 2] = ~len;
-        s->pending_buf[s->pending - 1] = ~len >> 8;
-        /* Write the stored block header bytes. */
-        flush_pending(s->strm);
-#ifdef ZLIB_DEBUG
-        /* Update debugging counts for the data about to be copied. */
-        s->compressed_len += len << 3;
-        s->bits_sent += len << 3;
-#endif
-        /* Copy uncompressed bytes from the window to next_out. */
-        if (left) {
-            if (left > len)
-                left = len;
-            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
-            s->strm->next_out += left;
-            s->strm->avail_out -= left;
-            s->strm->total_out += left;
-            s->block_start += left;
-            len -= left;
-        }
-        /* Copy uncompressed bytes directly from next_in to next_out, updating
-         * the check value.
-         */
-        if (len) {
-            read_buf(s->strm, s->strm->next_out, len);
-            s->strm->next_out += len;
-            s->strm->avail_out -= len;
-            s->strm->total_out += len;
-        }
-    } while (last == 0);
-    /* Update the sliding window with the last s->w_size bytes of the copied
-     * data, or append all of the copied data to the existing window if less
-     * than s->w_size bytes were copied. Also update the number of bytes to
-     * insert in the hash tables, in the event that deflateParams() switches to
-     * a non-zero compression level.
-     */
-    used -= s->strm->avail_in;      /* number of input bytes directly copied */
-    if (used) {
-        /* If any input was used, then no unused input remains in the window,
-         * therefore s->block_start == s->strstart.
-         */
-        if (used >= s->w_size) {    /* supplant the previous history */
-            s->matches = 2;         /* clear hash */
-            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
-            s->strstart = s->w_size;
-            s->insert = s->strstart;
-        }
-        else {
-            if (s->window_size - s->strstart <= used) {
-                /* Slide the window down. */
-                s->strstart -= s->w_size;
-                zmemcpy(s->window, s->window + s->w_size, s->strstart);
-                if (s->matches < 2)
-                    s->matches++;   /* add a pending slide_hash() */
-                if (s->insert > s->strstart)
-                    s->insert = s->strstart;
-            }
-            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
-            s->strstart += used;
-            s->insert += MIN(used, s->w_size - s->insert);
-        }
-        s->block_start = s->strstart;
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-    /* If the last block was written to next_out, then done. */
-    if (last)
-        return finish_done;
-    /* If flushing and all input has been consumed, then done. */
-    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
-        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
-        return block_done;
-    /* Fill the window with any remaining input. */
-    have = s->window_size - s->strstart;
-    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
-        /* Slide the window down. */
-        s->block_start -= s->w_size;
-        s->strstart -= s->w_size;
-        zmemcpy(s->window, s->window + s->w_size, s->strstart);
-        if (s->matches < 2)
-            s->matches++;           /* add a pending slide_hash() */
-        have += s->w_size;          /* more space now */
-        if (s->insert > s->strstart)
-            s->insert = s->strstart;
-    }
-    if (have > s->strm->avail_in)
-        have = s->strm->avail_in;
-    if (have) {
-        read_buf(s->strm, s->window + s->strstart, have);
-        s->strstart += have;
-        s->insert += MIN(have, s->w_size - s->insert);
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-    /* There was not enough avail_out to write a complete worthy or flushed
-     * stored block to next_out. Write a stored block to pending instead, if we
-     * have enough input for a worthy block, or if flushing and there is enough
-     * room for the remaining input as a stored block in the pending buffer.
-     */
-    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        /* maximum stored block length that will fit in pending: */
-    have = MIN(s->pending_buf_size - have, MAX_STORED);
-    min_block = MIN(have, s->w_size);
-    left = s->strstart - s->block_start;
-    if (left >= min_block ||
-        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
-         s->strm->avail_in == 0 && left <= have)) {
-        len = MIN(left, have);
-        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
-               len == left ? 1 : 0;
-        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
-        s->block_start += len;
-        flush_pending(s->strm);
-    }
-    /* We've done all we can with the available input and output. */
-    return last ? finish_started : need_more;
-}
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;       /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* Insert the string window[strstart .. strstart + 2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-            s->lookahead -= s->match_length;
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-#ifdef USE_CRC_HASH
-                if (!x86_cpu_has_sse42)
-#endif
-                {
-                    s->ins_h = s->window[s->strstart];
-                    UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                }
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit(s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;          /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* Insert the string window[strstart .. strstart + 2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-            check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
-            _tr_tally_dist(s, s->strstart - 1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart - 1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length - 1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-            if (bflush) FLUSH_BLOCK(s, 0);
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart - 1]));
-            _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart - 1]));
-        _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
-        s->match_available = 0;
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#endif /* FASTEST */
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest run, plus one for the unrolled loop.
-         */
-        if (s->lookahead <= MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* See how many times the previous byte repeats */
-        s->match_length = 0;
-        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
-            scan = s->window + s->strstart - 1;
-            prev = *scan;
-            if (prev == *++scan && prev == *++scan && prev == *++scan) {
-                strend = s->window + s->strstart + MAX_MATCH;
-                do {
-                } while (prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         scan < strend);
-                s->match_length = MAX_MATCH - (uInt)(strend - scan);
-                if (s->match_length > s->lookahead)
-                    s->match_length = s->lookahead;
-            }
-            Assert(scan <= s->window + (uInt)(s->window_size - 1),
-                   "wild scan");
-        }
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, s->match_length);
-            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
-            s->lookahead -= s->match_length;
-            s->strstart += s->match_length;
-            s->match_length = 0;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit(s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-/* ===========================================================================
- * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
- * (It will be regenerated if this run of deflate switches away from Huffman.)
- */
-local block_state deflate_huff(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    for (;;) {
-        /* Make sure that we have a literal to write. */
-        if (s->lookahead == 0) {
-            fill_window(s);
-            if (s->lookahead == 0) {
-                if (flush == Z_NO_FLUSH)
-                    return need_more;
-                break;      /* flush the current block */
-            }
-        }
-        /* Output a literal byte */
-        s->match_length = 0;
-        Tracevv((stderr,"%c", s->window[s->strstart]));
-        _tr_tally_lit(s, s->window[s->strstart], bflush);
-        s->lookahead--;
-        s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}

--- a/src/native/external/zlib-intel/deflate_quick.c
+++ b//dev/null
@@ -1,2332 +0,0 @@
-/*
- * The deflate_quick deflate strategy, designed to be used when cycles are
- * at a premium.
- *
- * Copyright (C) 2013 Intel Corporation. All rights reserved.
- * Authors:
- *  Wajdi Feghali   <wajdi.k.feghali@intel.com>
- *  Jim Guilford    <james.guilford@intel.com>
- *  Vinodh Gopal    <vinodh.gopal@intel.com>
- * 	Erdinc Ozturk   <erdinc.ozturk@intel.com>
- *  Jim Kukunas     <james.t.kukunas@linux.intel.com>
- *
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "deflate.h"
-#if defined(USE_QUICK)
-#include <immintrin.h>
-#ifndef _MSC_VER
-local inline long compare258(z_const unsigned char *z_const src0,
-        z_const unsigned char *z_const src1)
-{
-    long ax, dx, cx;
-    __m128i xmm_src0;
-    ax = 16;
-    dx = 16;
-    __asm__ __volatile__ (
-    "1:"
-        "movdqu     -16(%[src0], %[ax]), %[xmm_src0]\n\t"
-        "pcmpestri  $0x18, -16(%[src1], %[ax]), %[xmm_src0]\n\t"
-        "jc         2f\n\t"
-        "add        $16, %[ax]\n\t"
-        "movdqu     -16(%[src0], %[ax]), %[xmm_src0]\n\t"
-        "pcmpestri  $0x18, -16(%[src1], %[ax]), %[xmm_src0]\n\t"
-        "jc         2f\n\t"
-        "add        $16, %[ax]\n\t"
-        "cmp        $256 + 16, %[ax]\n\t"
-        "jb         1b\n\t"
-#ifdef X86
-        "movzwl     -16(%[src0], %[ax]), %[dx]\n\t"
-#else
-        "movzwq     -16(%[src0], %[ax]), %[dx]\n\t"
-#endif
-        "xorw       -16(%[src1], %[ax]), %%dx\n\t"
-        "jnz        3f\n\t"
-        "add        $2, %[ax]\n\t"
-        "jmp        4f\n\t"
-    "3:\n\t"
-        "rep; bsf   %[dx], %[cx]\n\t"
-        "shr        $3, %[cx]\n\t"
-    "2:"
-        "add        %[cx], %[ax]\n\t"
-    "4:"
-    : [ax] "+a" (ax),
-      [cx] "+c" (cx),
-      [dx] "+d" (dx),
-      [xmm_src0] "=x" (xmm_src0)
-    : [src0] "r" (src0),
-      [src1] "r" (src1)
-    : "cc"
-    );
-    return ax - 16;
-}
-#else
-#include <nmmintrin.h>
-local inline long compare258(z_const unsigned char *z_const src0,
-        z_const unsigned char *z_const src1)
-{
-    long cnt;
-    cnt = 0;
-    do {
-#define mode  _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_NEGATIVE_POLARITY
-        int ret;
-        __m128i xmm_src0, xmm_src1;
-        xmm_src0 = _mm_loadu_si128((__m128i *)(src0 + cnt));
-        xmm_src1 = _mm_loadu_si128((__m128i *)(src1 + cnt));
-        ret = _mm_cmpestri(xmm_src0, 16, xmm_src1, 16, mode);
-        if (_mm_cmpestrc(xmm_src0, 16, xmm_src1, 16, mode)) {
-            cnt += ret;
-            break;
-        }
-        cnt += 16;
-        xmm_src0 = _mm_loadu_si128((__m128i *)(src0 + cnt));
-        xmm_src1 = _mm_loadu_si128((__m128i *)(src1 + cnt));
-        ret = _mm_cmpestri(xmm_src0, 16, xmm_src1, 16, mode);
-        if (_mm_cmpestrc(xmm_src0, 16, xmm_src1, 16, mode)) {
-            cnt += ret;
-            break;
-        }
-        cnt += 16;
-    } while (cnt < 256);
-    if (*(unsigned short *)(src0 + cnt) == *(unsigned short *)(src1 + cnt)) {
-        cnt += 2;
-    } else if (*(src0 + cnt) == *(src1 + cnt)) {
-        cnt++;
-    }
-    return cnt;
-}
-#endif
-local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1];
-local z_const unsigned quick_dist_codes[8192];
-local inline void quick_send_bits(deflate_state *z_const s, z_const int value,
-        z_const int length)
-{
-    unsigned code, out, w, b;
-    out = s->bi_buf;
-    w = s->bi_valid;
-    code = value << s->bi_valid;
-    out |= code;
-    w += length;
-    if (s->pending + 4 >= s->pending_buf_size)
-        flush_pending(s->strm);
-    *(unsigned *)(s->pending_buf + s->pending) = out;
-    b = w >> 3;
-    s->pending += b;
-    s->bi_buf =  out >> (b << 3);
-    s->bi_valid = w - (b << 3);
-}
-local inline void static_emit_ptr(deflate_state *z_const s, z_const int lc,
-        z_const unsigned dist)
-{
-    unsigned code, len;
-    code = quick_len_codes[lc] >> 8;
-    len =  quick_len_codes[lc] & 0xFF;
-    quick_send_bits(s, code, len);
-    code = quick_dist_codes[dist-1] >> 8;
-    len  = quick_dist_codes[dist-1] & 0xFF;
-    quick_send_bits(s, code, len);
-}
-z_const ct_data static_ltree[L_CODES+2];
-local inline void static_emit_lit(deflate_state *z_const s,z_const int lit)
-{
-    quick_send_bits(s, static_ltree[lit].Code, static_ltree[lit].Len);
-    Tracecv(isgraph(lit), (stderr," '%c' ", lit));
-}
-local void static_emit_tree(deflate_state *z_const s,
-        z_const int flush)
-{
-    unsigned last;
-    last = flush == Z_FINISH ? 1 : 0;
-    send_bits(s, (STATIC_TREES<<1)+ last, 3);
-}
-local void static_emit_end_block(deflate_state *z_const s,
-        int last)
-{
-    send_code(s, END_BLOCK, static_ltree);
-    if (last)
-        bi_windup(s);
-    s->block_start = s->strstart;
-    flush_pending(s->strm);
-}
-local inline Pos quick_insert_string(deflate_state *z_const s, z_const Pos str)
-{
-    Pos ret;
-    unsigned h = 0;
-#ifndef _MSC_VER
-    __asm__ __volatile__ (
-        "crc32l (%[window], %[str], 1), %0\n\t"
-    : "+r" (h)
-    : [window] "r" (s->window),
-      [str] "r" ((long)str)
-    );
-#else
-    h = _mm_crc32_u32(h, *(unsigned *)(s->window + str));
-#endif
-    ret = s->head[h & s->hash_mask];
-    s->head[h & s->hash_mask] = str;
-    return ret;
-}
-block_state deflate_quick(deflate_state *s, int flush)
-{
-    IPos hash_head;
-    unsigned dist, match_len;
-    static_emit_tree(s, flush);
-    do {
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                static_emit_end_block(s, 0);
-                return need_more;
-            }
-            if (s->lookahead == 0)
-                break;
-        }
-        if (s->lookahead >= MIN_MATCH) {
-            hash_head = quick_insert_string(s, s->strstart);
-            dist = s->strstart - hash_head;
-            if ((dist-1) < (s->w_size - 1)) {
-                match_len = compare258(s->window + s->strstart, s->window + s->strstart - dist);
-                if (match_len >= MIN_MATCH) {
-                    if (match_len > s->lookahead)
-                        match_len = s->lookahead;
-                    static_emit_ptr(s, match_len - MIN_MATCH, s->strstart - hash_head);
-                    s->lookahead -= match_len;
-                    s->strstart += match_len;
-                    continue;
-                }
-            }
-        }
-        static_emit_lit(s, s->window[s->strstart]);
-        s->strstart++;
-        s->lookahead--;
-    } while (s->strm->avail_out != 0);
-    if (s->strm->avail_out == 0 && flush != Z_FINISH)
-        return need_more;
-    s->insert = s->strstart < MIN_MATCH - 1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        static_emit_end_block(s, 1);
-        if (s->strm->avail_out == 0)
-            return finish_started;
-        else
-            return finish_done;
-    }
-    static_emit_end_block(s, 0);
-    return block_done;
-}
-local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1] = {
-	0x00004007, 0x00002007, 0x00006007, 0x00001007, 
-	0x00005007, 0x00003007, 0x00007007, 0x00000807, 
-	0x00004808, 0x0000c808, 0x00002808, 0x0000a808, 
-	0x00006808, 0x0000e808, 0x00001808, 0x00009808, 
-	0x00005809, 0x0000d809, 0x00015809, 0x0001d809, 
-	0x00003809, 0x0000b809, 0x00013809, 0x0001b809, 
-	0x00007809, 0x0000f809, 0x00017809, 0x0001f809, 
-	0x00000409, 0x00008409, 0x00010409, 0x00018409, 
-	0x0000440a, 0x0000c40a, 0x0001440a, 0x0001c40a, 
-	0x0002440a, 0x0002c40a, 0x0003440a, 0x0003c40a, 
-	0x0000240a, 0x0000a40a, 0x0001240a, 0x0001a40a, 
-	0x0002240a, 0x0002a40a, 0x0003240a, 0x0003a40a, 
-	0x0000640a, 0x0000e40a, 0x0001640a, 0x0001e40a, 
-	0x0002640a, 0x0002e40a, 0x0003640a, 0x0003e40a, 
-	0x0000140a, 0x0000940a, 0x0001140a, 0x0001940a, 
-	0x0002140a, 0x0002940a, 0x0003140a, 0x0003940a, 
-	0x0000540b, 0x0000d40b, 0x0001540b, 0x0001d40b, 
-	0x0002540b, 0x0002d40b, 0x0003540b, 0x0003d40b, 
-	0x0004540b, 0x0004d40b, 0x0005540b, 0x0005d40b, 
-	0x0006540b, 0x0006d40b, 0x0007540b, 0x0007d40b, 
-	0x0000340b, 0x0000b40b, 0x0001340b, 0x0001b40b, 
-	0x0002340b, 0x0002b40b, 0x0003340b, 0x0003b40b, 
-	0x0004340b, 0x0004b40b, 0x0005340b, 0x0005b40b, 
-	0x0006340b, 0x0006b40b, 0x0007340b, 0x0007b40b, 
-	0x0000740b, 0x0000f40b, 0x0001740b, 0x0001f40b, 
-	0x0002740b, 0x0002f40b, 0x0003740b, 0x0003f40b, 
-	0x0004740b, 0x0004f40b, 0x0005740b, 0x0005f40b, 
-	0x0006740b, 0x0006f40b, 0x0007740b, 0x0007f40b, 
-	0x0000030c, 0x0001030c, 0x0002030c, 0x0003030c, 
-	0x0004030c, 0x0005030c, 0x0006030c, 0x0007030c, 
-	0x0008030c, 0x0009030c, 0x000a030c, 0x000b030c, 
-	0x000c030c, 0x000d030c, 0x000e030c, 0x000f030c, 
-	0x0000830d, 0x0001830d, 0x0002830d, 0x0003830d, 
-	0x0004830d, 0x0005830d, 0x0006830d, 0x0007830d, 
-	0x0008830d, 0x0009830d, 0x000a830d, 0x000b830d, 
-	0x000c830d, 0x000d830d, 0x000e830d, 0x000f830d, 
-	0x0010830d, 0x0011830d, 0x0012830d, 0x0013830d, 
-	0x0014830d, 0x0015830d, 0x0016830d, 0x0017830d, 
-	0x0018830d, 0x0019830d, 0x001a830d, 0x001b830d, 
-	0x001c830d, 0x001d830d, 0x001e830d, 0x001f830d, 
-	0x0000430d, 0x0001430d, 0x0002430d, 0x0003430d, 
-	0x0004430d, 0x0005430d, 0x0006430d, 0x0007430d, 
-	0x0008430d, 0x0009430d, 0x000a430d, 0x000b430d, 
-	0x000c430d, 0x000d430d, 0x000e430d, 0x000f430d, 
-	0x0010430d, 0x0011430d, 0x0012430d, 0x0013430d, 
-	0x0014430d, 0x0015430d, 0x0016430d, 0x0017430d, 
-	0x0018430d, 0x0019430d, 0x001a430d, 0x001b430d, 
-	0x001c430d, 0x001d430d, 0x001e430d, 0x001f430d, 
-	0x0000c30d, 0x0001c30d, 0x0002c30d, 0x0003c30d, 
-	0x0004c30d, 0x0005c30d, 0x0006c30d, 0x0007c30d, 
-	0x0008c30d, 0x0009c30d, 0x000ac30d, 0x000bc30d, 
-	0x000cc30d, 0x000dc30d, 0x000ec30d, 0x000fc30d, 
-	0x0010c30d, 0x0011c30d, 0x0012c30d, 0x0013c30d, 
-	0x0014c30d, 0x0015c30d, 0x0016c30d, 0x0017c30d, 
-	0x0018c30d, 0x0019c30d, 0x001ac30d, 0x001bc30d, 
-	0x001cc30d, 0x001dc30d, 0x001ec30d, 0x001fc30d, 
-	0x0000230d, 0x0001230d, 0x0002230d, 0x0003230d, 
-	0x0004230d, 0x0005230d, 0x0006230d, 0x0007230d, 
-	0x0008230d, 0x0009230d, 0x000a230d, 0x000b230d, 
-	0x000c230d, 0x000d230d, 0x000e230d, 0x000f230d, 
-	0x0010230d, 0x0011230d, 0x0012230d, 0x0013230d, 
-	0x0014230d, 0x0015230d, 0x0016230d, 0x0017230d, 
-	0x0018230d, 0x0019230d, 0x001a230d, 0x001b230d, 
-	0x001c230d, 0x001d230d, 0x001e230d, 0x0000a308, 
-};
-local z_const unsigned quick_dist_codes[8192] = {
-	0x00000005, 0x00001005, 0x00000805, 0x00001805, 
-	0x00000406, 0x00002406, 0x00001406, 0x00003406, 
-	0x00000c07, 0x00002c07, 0x00004c07, 0x00006c07, 
-	0x00001c07, 0x00003c07, 0x00005c07, 0x00007c07, 
-	0x00000208, 0x00002208, 0x00004208, 0x00006208, 
-	0x00008208, 0x0000a208, 0x0000c208, 0x0000e208, 
-	0x00001208, 0x00003208, 0x00005208, 0x00007208, 
-	0x00009208, 0x0000b208, 0x0000d208, 0x0000f208, 
-	0x00000a09, 0x00002a09, 0x00004a09, 0x00006a09, 
-	0x00008a09, 0x0000aa09, 0x0000ca09, 0x0000ea09, 
-	0x00010a09, 0x00012a09, 0x00014a09, 0x00016a09, 
-	0x00018a09, 0x0001aa09, 0x0001ca09, 0x0001ea09, 
-	0x00001a09, 0x00003a09, 0x00005a09, 0x00007a09, 
-	0x00009a09, 0x0000ba09, 0x0000da09, 0x0000fa09, 
-	0x00011a09, 0x00013a09, 0x00015a09, 0x00017a09, 
-	0x00019a09, 0x0001ba09, 0x0001da09, 0x0001fa09, 
-	0x0000060a, 0x0000260a, 0x0000460a, 0x0000660a, 
-	0x0000860a, 0x0000a60a, 0x0000c60a, 0x0000e60a, 
-	0x0001060a, 0x0001260a, 0x0001460a, 0x0001660a, 
-	0x0001860a, 0x0001a60a, 0x0001c60a, 0x0001e60a, 
-	0x0002060a, 0x0002260a, 0x0002460a, 0x0002660a, 
-	0x0002860a, 0x0002a60a, 0x0002c60a, 0x0002e60a, 
-	0x0003060a, 0x0003260a, 0x0003460a, 0x0003660a, 
-	0x0003860a, 0x0003a60a, 0x0003c60a, 0x0003e60a, 
-	0x0000160a, 0x0000360a, 0x0000560a, 0x0000760a, 
-	0x0000960a, 0x0000b60a, 0x0000d60a, 0x0000f60a, 
-	0x0001160a, 0x0001360a, 0x0001560a, 0x0001760a, 
-	0x0001960a, 0x0001b60a, 0x0001d60a, 0x0001f60a, 
-	0x0002160a, 0x0002360a, 0x0002560a, 0x0002760a, 
-	0x0002960a, 0x0002b60a, 0x0002d60a, 0x0002f60a, 
-	0x0003160a, 0x0003360a, 0x0003560a, 0x0003760a, 
-	0x0003960a, 0x0003b60a, 0x0003d60a, 0x0003f60a, 
-	0x00000e0b, 0x00002e0b, 0x00004e0b, 0x00006e0b, 
-	0x00008e0b, 0x0000ae0b, 0x0000ce0b, 0x0000ee0b, 
-	0x00010e0b, 0x00012e0b, 0x00014e0b, 0x00016e0b, 
-	0x00018e0b, 0x0001ae0b, 0x0001ce0b, 0x0001ee0b, 
-	0x00020e0b, 0x00022e0b, 0x00024e0b, 0x00026e0b, 
-	0x00028e0b, 0x0002ae0b, 0x0002ce0b, 0x0002ee0b, 
-	0x00030e0b, 0x00032e0b, 0x00034e0b, 0x00036e0b, 
-	0x00038e0b, 0x0003ae0b, 0x0003ce0b, 0x0003ee0b, 
-	0x00040e0b, 0x00042e0b, 0x00044e0b, 0x00046e0b, 
-	0x00048e0b, 0x0004ae0b, 0x0004ce0b, 0x0004ee0b, 
-	0x00050e0b, 0x00052e0b, 0x00054e0b, 0x00056e0b, 
-	0x00058e0b, 0x0005ae0b, 0x0005ce0b, 0x0005ee0b, 
-	0x00060e0b, 0x00062e0b, 0x00064e0b, 0x00066e0b, 
-	0x00068e0b, 0x0006ae0b, 0x0006ce0b, 0x0006ee0b, 
-	0x00070e0b, 0x00072e0b, 0x00074e0b, 0x00076e0b, 
-	0x00078e0b, 0x0007ae0b, 0x0007ce0b, 0x0007ee0b, 
-	0x00001e0b, 0x00003e0b, 0x00005e0b, 0x00007e0b, 
-	0x00009e0b, 0x0000be0b, 0x0000de0b, 0x0000fe0b, 
-	0x00011e0b, 0x00013e0b, 0x00015e0b, 0x00017e0b, 
-	0x00019e0b, 0x0001be0b, 0x0001de0b, 0x0001fe0b, 
-	0x00021e0b, 0x00023e0b, 0x00025e0b, 0x00027e0b, 
-	0x00029e0b, 0x0002be0b, 0x0002de0b, 0x0002fe0b, 
-	0x00031e0b, 0x00033e0b, 0x00035e0b, 0x00037e0b, 
-	0x00039e0b, 0x0003be0b, 0x0003de0b, 0x0003fe0b, 
-	0x00041e0b, 0x00043e0b, 0x00045e0b, 0x00047e0b, 
-	0x00049e0b, 0x0004be0b, 0x0004de0b, 0x0004fe0b, 
-	0x00051e0b, 0x00053e0b, 0x00055e0b, 0x00057e0b, 
-	0x00059e0b, 0x0005be0b, 0x0005de0b, 0x0005fe0b, 
-	0x00061e0b, 0x00063e0b, 0x00065e0b, 0x00067e0b, 
-	0x00069e0b, 0x0006be0b, 0x0006de0b, 0x0006fe0b, 
-	0x00071e0b, 0x00073e0b, 0x00075e0b, 0x00077e0b, 
-	0x00079e0b, 0x0007be0b, 0x0007de0b, 0x0007fe0b, 
-	0x0000010c, 0x0000210c, 0x0000410c, 0x0000610c, 
-	0x0000810c, 0x0000a10c, 0x0000c10c, 0x0000e10c, 
-	0x0001010c, 0x0001210c, 0x0001410c, 0x0001610c, 
-	0x0001810c, 0x0001a10c, 0x0001c10c, 0x0001e10c, 
-	0x0002010c, 0x0002210c, 0x0002410c, 0x0002610c, 
-	0x0002810c, 0x0002a10c, 0x0002c10c, 0x0002e10c, 
-	0x0003010c, 0x0003210c, 0x0003410c, 0x0003610c, 
-	0x0003810c, 0x0003a10c, 0x0003c10c, 0x0003e10c, 
-	0x0004010c, 0x0004210c, 0x0004410c, 0x0004610c, 
-	0x0004810c, 0x0004a10c, 0x0004c10c, 0x0004e10c, 
-	0x0005010c, 0x0005210c, 0x0005410c, 0x0005610c, 
-	0x0005810c, 0x0005a10c, 0x0005c10c, 0x0005e10c, 
-	0x0006010c, 0x0006210c, 0x0006410c, 0x0006610c, 
-	0x0006810c, 0x0006a10c, 0x0006c10c, 0x0006e10c, 
-	0x0007010c, 0x0007210c, 0x0007410c, 0x0007610c, 
-	0x0007810c, 0x0007a10c, 0x0007c10c, 0x0007e10c, 
-	0x0008010c, 0x0008210c, 0x0008410c, 0x0008610c, 
-	0x0008810c, 0x0008a10c, 0x0008c10c, 0x0008e10c, 
-	0x0009010c, 0x0009210c, 0x0009410c, 0x0009610c, 
-	0x0009810c, 0x0009a10c, 0x0009c10c, 0x0009e10c, 
-	0x000a010c, 0x000a210c, 0x000a410c, 0x000a610c, 
-	0x000a810c, 0x000aa10c, 0x000ac10c, 0x000ae10c, 
-	0x000b010c, 0x000b210c, 0x000b410c, 0x000b610c, 
-	0x000b810c, 0x000ba10c, 0x000bc10c, 0x000be10c, 
-	0x000c010c, 0x000c210c, 0x000c410c, 0x000c610c, 
-	0x000c810c, 0x000ca10c, 0x000cc10c, 0x000ce10c, 
-	0x000d010c, 0x000d210c, 0x000d410c, 0x000d610c, 
-	0x000d810c, 0x000da10c, 0x000dc10c, 0x000de10c, 
-	0x000e010c, 0x000e210c, 0x000e410c, 0x000e610c, 
-	0x000e810c, 0x000ea10c, 0x000ec10c, 0x000ee10c, 
-	0x000f010c, 0x000f210c, 0x000f410c, 0x000f610c, 
-	0x000f810c, 0x000fa10c, 0x000fc10c, 0x000fe10c, 
-	0x0000110c, 0x0000310c, 0x0000510c, 0x0000710c, 
-	0x0000910c, 0x0000b10c, 0x0000d10c, 0x0000f10c, 
-	0x0001110c, 0x0001310c, 0x0001510c, 0x0001710c, 
-	0x0001910c, 0x0001b10c, 0x0001d10c, 0x0001f10c, 
-	0x0002110c, 0x0002310c, 0x0002510c, 0x0002710c, 
-	0x0002910c, 0x0002b10c, 0x0002d10c, 0x0002f10c, 
-	0x0003110c, 0x0003310c, 0x0003510c, 0x0003710c, 
-	0x0003910c, 0x0003b10c, 0x0003d10c, 0x0003f10c, 
-	0x0004110c, 0x0004310c, 0x0004510c, 0x0004710c, 
-	0x0004910c, 0x0004b10c, 0x0004d10c, 0x0004f10c, 
-	0x0005110c, 0x0005310c, 0x0005510c, 0x0005710c, 
-	0x0005910c, 0x0005b10c, 0x0005d10c, 0x0005f10c, 
-	0x0006110c, 0x0006310c, 0x0006510c, 0x0006710c, 
-	0x0006910c, 0x0006b10c, 0x0006d10c, 0x0006f10c, 
-	0x0007110c, 0x0007310c, 0x0007510c, 0x0007710c, 
-	0x0007910c, 0x0007b10c, 0x0007d10c, 0x0007f10c, 
-	0x0008110c, 0x0008310c, 0x0008510c, 0x0008710c, 
-	0x0008910c, 0x0008b10c, 0x0008d10c, 0x0008f10c, 
-	0x0009110c, 0x0009310c, 0x0009510c, 0x0009710c, 
-	0x0009910c, 0x0009b10c, 0x0009d10c, 0x0009f10c, 
-	0x000a110c, 0x000a310c, 0x000a510c, 0x000a710c, 
-	0x000a910c, 0x000ab10c, 0x000ad10c, 0x000af10c, 
-	0x000b110c, 0x000b310c, 0x000b510c, 0x000b710c, 
-	0x000b910c, 0x000bb10c, 0x000bd10c, 0x000bf10c, 
-	0x000c110c, 0x000c310c, 0x000c510c, 0x000c710c, 
-	0x000c910c, 0x000cb10c, 0x000cd10c, 0x000cf10c, 
-	0x000d110c, 0x000d310c, 0x000d510c, 0x000d710c, 
-	0x000d910c, 0x000db10c, 0x000dd10c, 0x000df10c, 
-	0x000e110c, 0x000e310c, 0x000e510c, 0x000e710c, 
-	0x000e910c, 0x000eb10c, 0x000ed10c, 0x000ef10c, 
-	0x000f110c, 0x000f310c, 0x000f510c, 0x000f710c, 
-	0x000f910c, 0x000fb10c, 0x000fd10c, 0x000ff10c, 
-	0x0000090d, 0x0000290d, 0x0000490d, 0x0000690d, 
-	0x0000890d, 0x0000a90d, 0x0000c90d, 0x0000e90d, 
-	0x0001090d, 0x0001290d, 0x0001490d, 0x0001690d, 
-	0x0001890d, 0x0001a90d, 0x0001c90d, 0x0001e90d, 
-	0x0002090d, 0x0002290d, 0x0002490d, 0x0002690d, 
-	0x0002890d, 0x0002a90d, 0x0002c90d, 0x0002e90d, 
-	0x0003090d, 0x0003290d, 0x0003490d, 0x0003690d, 
-	0x0003890d, 0x0003a90d, 0x0003c90d, 0x0003e90d, 
-	0x0004090d, 0x0004290d, 0x0004490d, 0x0004690d, 
-	0x0004890d, 0x0004a90d, 0x0004c90d, 0x0004e90d, 
-	0x0005090d, 0x0005290d, 0x0005490d, 0x0005690d, 
-	0x0005890d, 0x0005a90d, 0x0005c90d, 0x0005e90d, 
-	0x0006090d, 0x0006290d, 0x0006490d, 0x0006690d, 
-	0x0006890d, 0x0006a90d, 0x0006c90d, 0x0006e90d, 
-	0x0007090d, 0x0007290d, 0x0007490d, 0x0007690d, 
-	0x0007890d, 0x0007a90d, 0x0007c90d, 0x0007e90d, 
-	0x0008090d, 0x0008290d, 0x0008490d, 0x0008690d, 
-	0x0008890d, 0x0008a90d, 0x0008c90d, 0x0008e90d, 
-	0x0009090d, 0x0009290d, 0x0009490d, 0x0009690d, 
-	0x0009890d, 0x0009a90d, 0x0009c90d, 0x0009e90d, 
-	0x000a090d, 0x000a290d, 0x000a490d, 0x000a690d, 
-	0x000a890d, 0x000aa90d, 0x000ac90d, 0x000ae90d, 
-	0x000b090d, 0x000b290d, 0x000b490d, 0x000b690d, 
-	0x000b890d, 0x000ba90d, 0x000bc90d, 0x000be90d, 
-	0x000c090d, 0x000c290d, 0x000c490d, 0x000c690d, 
-	0x000c890d, 0x000ca90d, 0x000cc90d, 0x000ce90d, 
-	0x000d090d, 0x000d290d, 0x000d490d, 0x000d690d, 
-	0x000d890d, 0x000da90d, 0x000dc90d, 0x000de90d, 
-	0x000e090d, 0x000e290d, 0x000e490d, 0x000e690d, 
-	0x000e890d, 0x000ea90d, 0x000ec90d, 0x000ee90d, 
-	0x000f090d, 0x000f290d, 0x000f490d, 0x000f690d, 
-	0x000f890d, 0x000fa90d, 0x000fc90d, 0x000fe90d, 
-	0x0010090d, 0x0010290d, 0x0010490d, 0x0010690d, 
-	0x0010890d, 0x0010a90d, 0x0010c90d, 0x0010e90d, 
-	0x0011090d, 0x0011290d, 0x0011490d, 0x0011690d, 
-	0x0011890d, 0x0011a90d, 0x0011c90d, 0x0011e90d, 
-	0x0012090d, 0x0012290d, 0x0012490d, 0x0012690d, 
-	0x0012890d, 0x0012a90d, 0x0012c90d, 0x0012e90d, 
-	0x0013090d, 0x0013290d, 0x0013490d, 0x0013690d, 
-	0x0013890d, 0x0013a90d, 0x0013c90d, 0x0013e90d, 
-	0x0014090d, 0x0014290d, 0x0014490d, 0x0014690d, 
-	0x0014890d, 0x0014a90d, 0x0014c90d, 0x0014e90d, 
-	0x0015090d, 0x0015290d, 0x0015490d, 0x0015690d, 
-	0x0015890d, 0x0015a90d, 0x0015c90d, 0x0015e90d, 
-	0x0016090d, 0x0016290d, 0x0016490d, 0x0016690d, 
-	0x0016890d, 0x0016a90d, 0x0016c90d, 0x0016e90d, 
-	0x0017090d, 0x0017290d, 0x0017490d, 0x0017690d, 
-	0x0017890d, 0x0017a90d, 0x0017c90d, 0x0017e90d, 
-	0x0018090d, 0x0018290d, 0x0018490d, 0x0018690d, 
-	0x0018890d, 0x0018a90d, 0x0018c90d, 0x0018e90d, 
-	0x0019090d, 0x0019290d, 0x0019490d, 0x0019690d, 
-	0x0019890d, 0x0019a90d, 0x0019c90d, 0x0019e90d, 
-	0x001a090d, 0x001a290d, 0x001a490d, 0x001a690d, 
-	0x001a890d, 0x001aa90d, 0x001ac90d, 0x001ae90d, 
-	0x001b090d, 0x001b290d, 0x001b490d, 0x001b690d, 
-	0x001b890d, 0x001ba90d, 0x001bc90d, 0x001be90d, 
-	0x001c090d, 0x001c290d, 0x001c490d, 0x001c690d, 
-	0x001c890d, 0x001ca90d, 0x001cc90d, 0x001ce90d, 
-	0x001d090d, 0x001d290d, 0x001d490d, 0x001d690d, 
-	0x001d890d, 0x001da90d, 0x001dc90d, 0x001de90d, 
-	0x001e090d, 0x001e290d, 0x001e490d, 0x001e690d, 
-	0x001e890d, 0x001ea90d, 0x001ec90d, 0x001ee90d, 
-	0x001f090d, 0x001f290d, 0x001f490d, 0x001f690d, 
-	0x001f890d, 0x001fa90d, 0x001fc90d, 0x001fe90d, 
-	0x0000190d, 0x0000390d, 0x0000590d, 0x0000790d, 
-	0x0000990d, 0x0000b90d, 0x0000d90d, 0x0000f90d, 
-	0x0001190d, 0x0001390d, 0x0001590d, 0x0001790d, 
-	0x0001990d, 0x0001b90d, 0x0001d90d, 0x0001f90d, 
-	0x0002190d, 0x0002390d, 0x0002590d, 0x0002790d, 
-	0x0002990d, 0x0002b90d, 0x0002d90d, 0x0002f90d, 
-	0x0003190d, 0x0003390d, 0x0003590d, 0x0003790d, 
-	0x0003990d, 0x0003b90d, 0x0003d90d, 0x0003f90d, 
-	0x0004190d, 0x0004390d, 0x0004590d, 0x0004790d, 
-	0x0004990d, 0x0004b90d, 0x0004d90d, 0x0004f90d, 
-	0x0005190d, 0x0005390d, 0x0005590d, 0x0005790d, 
-	0x0005990d, 0x0005b90d, 0x0005d90d, 0x0005f90d, 
-	0x0006190d, 0x0006390d, 0x0006590d, 0x0006790d, 
-	0x0006990d, 0x0006b90d, 0x0006d90d, 0x0006f90d, 
-	0x0007190d, 0x0007390d, 0x0007590d, 0x0007790d, 
-	0x0007990d, 0x0007b90d, 0x0007d90d, 0x0007f90d, 
-	0x0008190d, 0x0008390d, 0x0008590d, 0x0008790d, 
-	0x0008990d, 0x0008b90d, 0x0008d90d, 0x0008f90d, 
-	0x0009190d, 0x0009390d, 0x0009590d, 0x0009790d, 
-	0x0009990d, 0x0009b90d, 0x0009d90d, 0x0009f90d, 
-	0x000a190d, 0x000a390d, 0x000a590d, 0x000a790d, 
-	0x000a990d, 0x000ab90d, 0x000ad90d, 0x000af90d, 
-	0x000b190d, 0x000b390d, 0x000b590d, 0x000b790d, 
-	0x000b990d, 0x000bb90d, 0x000bd90d, 0x000bf90d, 
-	0x000c190d, 0x000c390d, 0x000c590d, 0x000c790d, 
-	0x000c990d, 0x000cb90d, 0x000cd90d, 0x000cf90d, 
-	0x000d190d, 0x000d390d, 0x000d590d, 0x000d790d, 
-	0x000d990d, 0x000db90d, 0x000dd90d, 0x000df90d, 
-	0x000e190d, 0x000e390d, 0x000e590d, 0x000e790d, 
-	0x000e990d, 0x000eb90d, 0x000ed90d, 0x000ef90d, 
-	0x000f190d, 0x000f390d, 0x000f590d, 0x000f790d, 
-	0x000f990d, 0x000fb90d, 0x000fd90d, 0x000ff90d, 
-	0x0010190d, 0x0010390d, 0x0010590d, 0x0010790d, 
-	0x0010990d, 0x0010b90d, 0x0010d90d, 0x0010f90d, 
-	0x0011190d, 0x0011390d, 0x0011590d, 0x0011790d, 
-	0x0011990d, 0x0011b90d, 0x0011d90d, 0x0011f90d, 
-	0x0012190d, 0x0012390d, 0x0012590d, 0x0012790d, 
-	0x0012990d, 0x0012b90d, 0x0012d90d, 0x0012f90d, 
-	0x0013190d, 0x0013390d, 0x0013590d, 0x0013790d, 
-	0x0013990d, 0x0013b90d, 0x0013d90d, 0x0013f90d, 
-	0x0014190d, 0x0014390d, 0x0014590d, 0x0014790d, 
-	0x0014990d, 0x0014b90d, 0x0014d90d, 0x0014f90d, 
-	0x0015190d, 0x0015390d, 0x0015590d, 0x0015790d, 
-	0x0015990d, 0x0015b90d, 0x0015d90d, 0x0015f90d, 
-	0x0016190d, 0x0016390d, 0x0016590d, 0x0016790d, 
-	0x0016990d, 0x0016b90d, 0x0016d90d, 0x0016f90d, 
-	0x0017190d, 0x0017390d, 0x0017590d, 0x0017790d, 
-	0x0017990d, 0x0017b90d, 0x0017d90d, 0x0017f90d, 
-	0x0018190d, 0x0018390d, 0x0018590d, 0x0018790d, 
-	0x0018990d, 0x0018b90d, 0x0018d90d, 0x0018f90d, 
-	0x0019190d, 0x0019390d, 0x0019590d, 0x0019790d, 
-	0x0019990d, 0x0019b90d, 0x0019d90d, 0x0019f90d, 
-	0x001a190d, 0x001a390d, 0x001a590d, 0x001a790d, 
-	0x001a990d, 0x001ab90d, 0x001ad90d, 0x001af90d, 
-	0x001b190d, 0x001b390d, 0x001b590d, 0x001b790d, 
-	0x001b990d, 0x001bb90d, 0x001bd90d, 0x001bf90d, 
-	0x001c190d, 0x001c390d, 0x001c590d, 0x001c790d, 
-	0x001c990d, 0x001cb90d, 0x001cd90d, 0x001cf90d, 
-	0x001d190d, 0x001d390d, 0x001d590d, 0x001d790d, 
-	0x001d990d, 0x001db90d, 0x001dd90d, 0x001df90d, 
-	0x001e190d, 0x001e390d, 0x001e590d, 0x001e790d, 
-	0x001e990d, 0x001eb90d, 0x001ed90d, 0x001ef90d, 
-	0x001f190d, 0x001f390d, 0x001f590d, 0x001f790d, 
-	0x001f990d, 0x001fb90d, 0x001fd90d, 0x001ff90d, 
-	0x0000050e, 0x0000250e, 0x0000450e, 0x0000650e, 
-	0x0000850e, 0x0000a50e, 0x0000c50e, 0x0000e50e, 
-	0x0001050e, 0x0001250e, 0x0001450e, 0x0001650e, 
-	0x0001850e, 0x0001a50e, 0x0001c50e, 0x0001e50e, 
-	0x0002050e, 0x0002250e, 0x0002450e, 0x0002650e, 
-	0x0002850e, 0x0002a50e, 0x0002c50e, 0x0002e50e, 
-	0x0003050e, 0x0003250e, 0x0003450e, 0x0003650e, 
-	0x0003850e, 0x0003a50e, 0x0003c50e, 0x0003e50e, 
-	0x0004050e, 0x0004250e, 0x0004450e, 0x0004650e, 
-	0x0004850e, 0x0004a50e, 0x0004c50e, 0x0004e50e, 
-	0x0005050e, 0x0005250e, 0x0005450e, 0x0005650e, 
-	0x0005850e, 0x0005a50e, 0x0005c50e, 0x0005e50e, 
-	0x0006050e, 0x0006250e, 0x0006450e, 0x0006650e, 
-	0x0006850e, 0x0006a50e, 0x0006c50e, 0x0006e50e, 
-	0x0007050e, 0x0007250e, 0x0007450e, 0x0007650e, 
-	0x0007850e, 0x0007a50e, 0x0007c50e, 0x0007e50e, 
-	0x0008050e, 0x0008250e, 0x0008450e, 0x0008650e, 
-	0x0008850e, 0x0008a50e, 0x0008c50e, 0x0008e50e, 
-	0x0009050e, 0x0009250e, 0x0009450e, 0x0009650e, 
-	0x0009850e, 0x0009a50e, 0x0009c50e, 0x0009e50e, 
-	0x000a050e, 0x000a250e, 0x000a450e, 0x000a650e, 
-	0x000a850e, 0x000aa50e, 0x000ac50e, 0x000ae50e, 
-	0x000b050e, 0x000b250e, 0x000b450e, 0x000b650e, 
-	0x000b850e, 0x000ba50e, 0x000bc50e, 0x000be50e, 
-	0x000c050e, 0x000c250e, 0x000c450e, 0x000c650e, 
-	0x000c850e, 0x000ca50e, 0x000cc50e, 0x000ce50e, 
-	0x000d050e, 0x000d250e, 0x000d450e, 0x000d650e, 
-	0x000d850e, 0x000da50e, 0x000dc50e, 0x000de50e, 
-	0x000e050e, 0x000e250e, 0x000e450e, 0x000e650e, 
-	0x000e850e, 0x000ea50e, 0x000ec50e, 0x000ee50e, 
-	0x000f050e, 0x000f250e, 0x000f450e, 0x000f650e, 
-	0x000f850e, 0x000fa50e, 0x000fc50e, 0x000fe50e, 
-	0x0010050e, 0x0010250e, 0x0010450e, 0x0010650e, 
-	0x0010850e, 0x0010a50e, 0x0010c50e, 0x0010e50e, 
-	0x0011050e, 0x0011250e, 0x0011450e, 0x0011650e, 
-	0x0011850e, 0x0011a50e, 0x0011c50e, 0x0011e50e, 
-	0x0012050e, 0x0012250e, 0x0012450e, 0x0012650e, 
-	0x0012850e, 0x0012a50e, 0x0012c50e, 0x0012e50e, 
-	0x0013050e, 0x0013250e, 0x0013450e, 0x0013650e, 
-	0x0013850e, 0x0013a50e, 0x0013c50e, 0x0013e50e, 
-	0x0014050e, 0x0014250e, 0x0014450e, 0x0014650e, 
-	0x0014850e, 0x0014a50e, 0x0014c50e, 0x0014e50e, 
-	0x0015050e, 0x0015250e, 0x0015450e, 0x0015650e, 
-	0x0015850e, 0x0015a50e, 0x0015c50e, 0x0015e50e, 
-	0x0016050e, 0x0016250e, 0x0016450e, 0x0016650e, 
-	0x0016850e, 0x0016a50e, 0x0016c50e, 0x0016e50e, 
-	0x0017050e, 0x0017250e, 0x0017450e, 0x0017650e, 
-	0x0017850e, 0x0017a50e, 0x0017c50e, 0x0017e50e, 
-	0x0018050e, 0x0018250e, 0x0018450e, 0x0018650e, 
-	0x0018850e, 0x0018a50e, 0x0018c50e, 0x0018e50e, 
-	0x0019050e, 0x0019250e, 0x0019450e, 0x0019650e, 
-	0x0019850e, 0x0019a50e, 0x0019c50e, 0x0019e50e, 
-	0x001a050e, 0x001a250e, 0x001a450e, 0x001a650e, 
-	0x001a850e, 0x001aa50e, 0x001ac50e, 0x001ae50e, 
-	0x001b050e, 0x001b250e, 0x001b450e, 0x001b650e, 
-	0x001b850e, 0x001ba50e, 0x001bc50e, 0x001be50e, 
-	0x001c050e, 0x001c250e, 0x001c450e, 0x001c650e, 
-	0x001c850e, 0x001ca50e, 0x001cc50e, 0x001ce50e, 
-	0x001d050e, 0x001d250e, 0x001d450e, 0x001d650e, 
-	0x001d850e, 0x001da50e, 0x001dc50e, 0x001de50e, 
-	0x001e050e, 0x001e250e, 0x001e450e, 0x001e650e, 
-	0x001e850e, 0x001ea50e, 0x001ec50e, 0x001ee50e, 
-	0x001f050e, 0x001f250e, 0x001f450e, 0x001f650e, 
-	0x001f850e, 0x001fa50e, 0x001fc50e, 0x001fe50e, 
-	0x0020050e, 0x0020250e, 0x0020450e, 0x0020650e, 
-	0x0020850e, 0x0020a50e, 0x0020c50e, 0x0020e50e, 
-	0x0021050e, 0x0021250e, 0x0021450e, 0x0021650e, 
-	0x0021850e, 0x0021a50e, 0x0021c50e, 0x0021e50e, 
-	0x0022050e, 0x0022250e, 0x0022450e, 0x0022650e, 
-	0x0022850e, 0x0022a50e, 0x0022c50e, 0x0022e50e, 
-	0x0023050e, 0x0023250e, 0x0023450e, 0x0023650e, 
-	0x0023850e, 0x0023a50e, 0x0023c50e, 0x0023e50e, 
-	0x0024050e, 0x0024250e, 0x0024450e, 0x0024650e, 
-	0x0024850e, 0x0024a50e, 0x0024c50e, 0x0024e50e, 
-	0x0025050e, 0x0025250e, 0x0025450e, 0x0025650e, 
-	0x0025850e, 0x0025a50e, 0x0025c50e, 0x0025e50e, 
-	0x0026050e, 0x0026250e, 0x0026450e, 0x0026650e, 
-	0x0026850e, 0x0026a50e, 0x0026c50e, 0x0026e50e, 
-	0x0027050e, 0x0027250e, 0x0027450e, 0x0027650e, 
-	0x0027850e, 0x0027a50e, 0x0027c50e, 0x0027e50e, 
-	0x0028050e, 0x0028250e, 0x0028450e, 0x0028650e, 
-	0x0028850e, 0x0028a50e, 0x0028c50e, 0x0028e50e, 
-	0x0029050e, 0x0029250e, 0x0029450e, 0x0029650e, 
-	0x0029850e, 0x0029a50e, 0x0029c50e, 0x0029e50e, 
-	0x002a050e, 0x002a250e, 0x002a450e, 0x002a650e, 
-	0x002a850e, 0x002aa50e, 0x002ac50e, 0x002ae50e, 
-	0x002b050e, 0x002b250e, 0x002b450e, 0x002b650e, 
-	0x002b850e, 0x002ba50e, 0x002bc50e, 0x002be50e, 
-	0x002c050e, 0x002c250e, 0x002c450e, 0x002c650e, 
-	0x002c850e, 0x002ca50e, 0x002cc50e, 0x002ce50e, 
-	0x002d050e, 0x002d250e, 0x002d450e, 0x002d650e, 
-	0x002d850e, 0x002da50e, 0x002dc50e, 0x002de50e, 
-	0x002e050e, 0x002e250e, 0x002e450e, 0x002e650e, 
-	0x002e850e, 0x002ea50e, 0x002ec50e, 0x002ee50e, 
-	0x002f050e, 0x002f250e, 0x002f450e, 0x002f650e, 
-	0x002f850e, 0x002fa50e, 0x002fc50e, 0x002fe50e, 
-	0x0030050e, 0x0030250e, 0x0030450e, 0x0030650e, 
-	0x0030850e, 0x0030a50e, 0x0030c50e, 0x0030e50e, 
-	0x0031050e, 0x0031250e, 0x0031450e, 0x0031650e, 
-	0x0031850e, 0x0031a50e, 0x0031c50e, 0x0031e50e, 
-	0x0032050e, 0x0032250e, 0x0032450e, 0x0032650e, 
-	0x0032850e, 0x0032a50e, 0x0032c50e, 0x0032e50e, 
-	0x0033050e, 0x0033250e, 0x0033450e, 0x0033650e, 
-	0x0033850e, 0x0033a50e, 0x0033c50e, 0x0033e50e, 
-	0x0034050e, 0x0034250e, 0x0034450e, 0x0034650e, 
-	0x0034850e, 0x0034a50e, 0x0034c50e, 0x0034e50e, 
-	0x0035050e, 0x0035250e, 0x0035450e, 0x0035650e, 
-	0x0035850e, 0x0035a50e, 0x0035c50e, 0x0035e50e, 
-	0x0036050e, 0x0036250e, 0x0036450e, 0x0036650e, 
-	0x0036850e, 0x0036a50e, 0x0036c50e, 0x0036e50e, 
-	0x0037050e, 0x0037250e, 0x0037450e, 0x0037650e, 
-	0x0037850e, 0x0037a50e, 0x0037c50e, 0x0037e50e, 
-	0x0038050e, 0x0038250e, 0x0038450e, 0x0038650e, 
-	0x0038850e, 0x0038a50e, 0x0038c50e, 0x0038e50e, 
-	0x0039050e, 0x0039250e, 0x0039450e, 0x0039650e, 
-	0x0039850e, 0x0039a50e, 0x0039c50e, 0x0039e50e, 
-	0x003a050e, 0x003a250e, 0x003a450e, 0x003a650e, 
-	0x003a850e, 0x003aa50e, 0x003ac50e, 0x003ae50e, 
-	0x003b050e, 0x003b250e, 0x003b450e, 0x003b650e, 
-	0x003b850e, 0x003ba50e, 0x003bc50e, 0x003be50e, 
-	0x003c050e, 0x003c250e, 0x003c450e, 0x003c650e, 
-	0x003c850e, 0x003ca50e, 0x003cc50e, 0x003ce50e, 
-	0x003d050e, 0x003d250e, 0x003d450e, 0x003d650e, 
-	0x003d850e, 0x003da50e, 0x003dc50e, 0x003de50e, 
-	0x003e050e, 0x003e250e, 0x003e450e, 0x003e650e, 
-	0x003e850e, 0x003ea50e, 0x003ec50e, 0x003ee50e, 
-	0x003f050e, 0x003f250e, 0x003f450e, 0x003f650e, 
-	0x003f850e, 0x003fa50e, 0x003fc50e, 0x003fe50e, 
-	0x0000150e, 0x0000350e, 0x0000550e, 0x0000750e, 
-	0x0000950e, 0x0000b50e, 0x0000d50e, 0x0000f50e, 
-	0x0001150e, 0x0001350e, 0x0001550e, 0x0001750e, 
-	0x0001950e, 0x0001b50e, 0x0001d50e, 0x0001f50e, 
-	0x0002150e, 0x0002350e, 0x0002550e, 0x0002750e, 
-	0x0002950e, 0x0002b50e, 0x0002d50e, 0x0002f50e, 
-	0x0003150e, 0x0003350e, 0x0003550e, 0x0003750e, 
-	0x0003950e, 0x0003b50e, 0x0003d50e, 0x0003f50e, 
-	0x0004150e, 0x0004350e, 0x0004550e, 0x0004750e, 
-	0x0004950e, 0x0004b50e, 0x0004d50e, 0x0004f50e, 
-	0x0005150e, 0x0005350e, 0x0005550e, 0x0005750e, 
-	0x0005950e, 0x0005b50e, 0x0005d50e, 0x0005f50e, 
-	0x0006150e, 0x0006350e, 0x0006550e, 0x0006750e, 
-	0x0006950e, 0x0006b50e, 0x0006d50e, 0x0006f50e, 
-	0x0007150e, 0x0007350e, 0x0007550e, 0x0007750e, 
-	0x0007950e, 0x0007b50e, 0x0007d50e, 0x0007f50e, 
-	0x0008150e, 0x0008350e, 0x0008550e, 0x0008750e, 
-	0x0008950e, 0x0008b50e, 0x0008d50e, 0x0008f50e, 
-	0x0009150e, 0x0009350e, 0x0009550e, 0x0009750e, 
-	0x0009950e, 0x0009b50e, 0x0009d50e, 0x0009f50e, 
-	0x000a150e, 0x000a350e, 0x000a550e, 0x000a750e, 
-	0x000a950e, 0x000ab50e, 0x000ad50e, 0x000af50e, 
-	0x000b150e, 0x000b350e, 0x000b550e, 0x000b750e, 
-	0x000b950e, 0x000bb50e, 0x000bd50e, 0x000bf50e, 
-	0x000c150e, 0x000c350e, 0x000c550e, 0x000c750e, 
-	0x000c950e, 0x000cb50e, 0x000cd50e, 0x000cf50e, 
-	0x000d150e, 0x000d350e, 0x000d550e, 0x000d750e, 
-	0x000d950e, 0x000db50e, 0x000dd50e, 0x000df50e, 
-	0x000e150e, 0x000e350e, 0x000e550e, 0x000e750e, 
-	0x000e950e, 0x000eb50e, 0x000ed50e, 0x000ef50e, 
-	0x000f150e, 0x000f350e, 0x000f550e, 0x000f750e, 
-	0x000f950e, 0x000fb50e, 0x000fd50e, 0x000ff50e, 
-	0x0010150e, 0x0010350e, 0x0010550e, 0x0010750e, 
-	0x0010950e, 0x0010b50e, 0x0010d50e, 0x0010f50e, 
-	0x0011150e, 0x0011350e, 0x0011550e, 0x0011750e, 
-	0x0011950e, 0x0011b50e, 0x0011d50e, 0x0011f50e, 
-	0x0012150e, 0x0012350e, 0x0012550e, 0x0012750e, 
-	0x0012950e, 0x0012b50e, 0x0012d50e, 0x0012f50e, 
-	0x0013150e, 0x0013350e, 0x0013550e, 0x0013750e, 
-	0x0013950e, 0x0013b50e, 0x0013d50e, 0x0013f50e, 
-	0x0014150e, 0x0014350e, 0x0014550e, 0x0014750e, 
-	0x0014950e, 0x0014b50e, 0x0014d50e, 0x0014f50e, 
-	0x0015150e, 0x0015350e, 0x0015550e, 0x0015750e, 
-	0x0015950e, 0x0015b50e, 0x0015d50e, 0x0015f50e, 
-	0x0016150e, 0x0016350e, 0x0016550e, 0x0016750e, 
-	0x0016950e, 0x0016b50e, 0x0016d50e, 0x0016f50e, 
-	0x0017150e, 0x0017350e, 0x0017550e, 0x0017750e, 
-	0x0017950e, 0x0017b50e, 0x0017d50e, 0x0017f50e, 
-	0x0018150e, 0x0018350e, 0x0018550e, 0x0018750e, 
-	0x0018950e, 0x0018b50e, 0x0018d50e, 0x0018f50e, 
-	0x0019150e, 0x0019350e, 0x0019550e, 0x0019750e, 
-	0x0019950e, 0x0019b50e, 0x0019d50e, 0x0019f50e, 
-	0x001a150e, 0x001a350e, 0x001a550e, 0x001a750e, 
-	0x001a950e, 0x001ab50e, 0x001ad50e, 0x001af50e, 
-	0x001b150e, 0x001b350e, 0x001b550e, 0x001b750e, 
-	0x001b950e, 0x001bb50e, 0x001bd50e, 0x001bf50e, 
-	0x001c150e, 0x001c350e, 0x001c550e, 0x001c750e, 
-	0x001c950e, 0x001cb50e, 0x001cd50e, 0x001cf50e, 
-	0x001d150e, 0x001d350e, 0x001d550e, 0x001d750e, 
-	0x001d950e, 0x001db50e, 0x001dd50e, 0x001df50e, 
-	0x001e150e, 0x001e350e, 0x001e550e, 0x001e750e, 
-	0x001e950e, 0x001eb50e, 0x001ed50e, 0x001ef50e, 
-	0x001f150e, 0x001f350e, 0x001f550e, 0x001f750e, 
-	0x001f950e, 0x001fb50e, 0x001fd50e, 0x001ff50e, 
-	0x0020150e, 0x0020350e, 0x0020550e, 0x0020750e, 
-	0x0020950e, 0x0020b50e, 0x0020d50e, 0x0020f50e, 
-	0x0021150e, 0x0021350e, 0x0021550e, 0x0021750e, 
-	0x0021950e, 0x0021b50e, 0x0021d50e, 0x0021f50e, 
-	0x0022150e, 0x0022350e, 0x0022550e, 0x0022750e, 
-	0x0022950e, 0x0022b50e, 0x0022d50e, 0x0022f50e, 
-	0x0023150e, 0x0023350e, 0x0023550e, 0x0023750e, 
-	0x0023950e, 0x0023b50e, 0x0023d50e, 0x0023f50e, 
-	0x0024150e, 0x0024350e, 0x0024550e, 0x0024750e, 
-	0x0024950e, 0x0024b50e, 0x0024d50e, 0x0024f50e, 
-	0x0025150e, 0x0025350e, 0x0025550e, 0x0025750e, 
-	0x0025950e, 0x0025b50e, 0x0025d50e, 0x0025f50e, 
-	0x0026150e, 0x0026350e, 0x0026550e, 0x0026750e, 
-	0x0026950e, 0x0026b50e, 0x0026d50e, 0x0026f50e, 
-	0x0027150e, 0x0027350e, 0x0027550e, 0x0027750e, 
-	0x0027950e, 0x0027b50e, 0x0027d50e, 0x0027f50e, 
-	0x0028150e, 0x0028350e, 0x0028550e, 0x0028750e, 
-	0x0028950e, 0x0028b50e, 0x0028d50e, 0x0028f50e, 
-	0x0029150e, 0x0029350e, 0x0029550e, 0x0029750e, 
-	0x0029950e, 0x0029b50e, 0x0029d50e, 0x0029f50e, 
-	0x002a150e, 0x002a350e, 0x002a550e, 0x002a750e, 
-	0x002a950e, 0x002ab50e, 0x002ad50e, 0x002af50e, 
-	0x002b150e, 0x002b350e, 0x002b550e, 0x002b750e, 
-	0x002b950e, 0x002bb50e, 0x002bd50e, 0x002bf50e, 
-	0x002c150e, 0x002c350e, 0x002c550e, 0x002c750e, 
-	0x002c950e, 0x002cb50e, 0x002cd50e, 0x002cf50e, 
-	0x002d150e, 0x002d350e, 0x002d550e, 0x002d750e, 
-	0x002d950e, 0x002db50e, 0x002dd50e, 0x002df50e, 
-	0x002e150e, 0x002e350e, 0x002e550e, 0x002e750e, 
-	0x002e950e, 0x002eb50e, 0x002ed50e, 0x002ef50e, 
-	0x002f150e, 0x002f350e, 0x002f550e, 0x002f750e, 
-	0x002f950e, 0x002fb50e, 0x002fd50e, 0x002ff50e, 
-	0x0030150e, 0x0030350e, 0x0030550e, 0x0030750e, 
-	0x0030950e, 0x0030b50e, 0x0030d50e, 0x0030f50e, 
-	0x0031150e, 0x0031350e, 0x0031550e, 0x0031750e, 
-	0x0031950e, 0x0031b50e, 0x0031d50e, 0x0031f50e, 
-	0x0032150e, 0x0032350e, 0x0032550e, 0x0032750e, 
-	0x0032950e, 0x0032b50e, 0x0032d50e, 0x0032f50e, 
-	0x0033150e, 0x0033350e, 0x0033550e, 0x0033750e, 
-	0x0033950e, 0x0033b50e, 0x0033d50e, 0x0033f50e, 
-	0x0034150e, 0x0034350e, 0x0034550e, 0x0034750e, 
-	0x0034950e, 0x0034b50e, 0x0034d50e, 0x0034f50e, 
-	0x0035150e, 0x0035350e, 0x0035550e, 0x0035750e, 
-	0x0035950e, 0x0035b50e, 0x0035d50e, 0x0035f50e, 
-	0x0036150e, 0x0036350e, 0x0036550e, 0x0036750e, 
-	0x0036950e, 0x0036b50e, 0x0036d50e, 0x0036f50e, 
-	0x0037150e, 0x0037350e, 0x0037550e, 0x0037750e, 
-	0x0037950e, 0x0037b50e, 0x0037d50e, 0x0037f50e, 
-	0x0038150e, 0x0038350e, 0x0038550e, 0x0038750e, 
-	0x0038950e, 0x0038b50e, 0x0038d50e, 0x0038f50e, 
-	0x0039150e, 0x0039350e, 0x0039550e, 0x0039750e, 
-	0x0039950e, 0x0039b50e, 0x0039d50e, 0x0039f50e, 
-	0x003a150e, 0x003a350e, 0x003a550e, 0x003a750e, 
-	0x003a950e, 0x003ab50e, 0x003ad50e, 0x003af50e, 
-	0x003b150e, 0x003b350e, 0x003b550e, 0x003b750e, 
-	0x003b950e, 0x003bb50e, 0x003bd50e, 0x003bf50e, 
-	0x003c150e, 0x003c350e, 0x003c550e, 0x003c750e, 
-	0x003c950e, 0x003cb50e, 0x003cd50e, 0x003cf50e, 
-	0x003d150e, 0x003d350e, 0x003d550e, 0x003d750e, 
-	0x003d950e, 0x003db50e, 0x003dd50e, 0x003df50e, 
-	0x003e150e, 0x003e350e, 0x003e550e, 0x003e750e, 
-	0x003e950e, 0x003eb50e, 0x003ed50e, 0x003ef50e, 
-	0x003f150e, 0x003f350e, 0x003f550e, 0x003f750e, 
-	0x003f950e, 0x003fb50e, 0x003fd50e, 0x003ff50e, 
-	0x00000d0f, 0x00002d0f, 0x00004d0f, 0x00006d0f, 
-	0x00008d0f, 0x0000ad0f, 0x0000cd0f, 0x0000ed0f, 
-	0x00010d0f, 0x00012d0f, 0x00014d0f, 0x00016d0f, 
-	0x00018d0f, 0x0001ad0f, 0x0001cd0f, 0x0001ed0f, 
-	0x00020d0f, 0x00022d0f, 0x00024d0f, 0x00026d0f, 
-	0x00028d0f, 0x0002ad0f, 0x0002cd0f, 0x0002ed0f, 
-	0x00030d0f, 0x00032d0f, 0x00034d0f, 0x00036d0f, 
-	0x00038d0f, 0x0003ad0f, 0x0003cd0f, 0x0003ed0f, 
-	0x00040d0f, 0x00042d0f, 0x00044d0f, 0x00046d0f, 
-	0x00048d0f, 0x0004ad0f, 0x0004cd0f, 0x0004ed0f, 
-	0x00050d0f, 0x00052d0f, 0x00054d0f, 0x00056d0f, 
-	0x00058d0f, 0x0005ad0f, 0x0005cd0f, 0x0005ed0f, 
-	0x00060d0f, 0x00062d0f, 0x00064d0f, 0x00066d0f, 
-	0x00068d0f, 0x0006ad0f, 0x0006cd0f, 0x0006ed0f, 
-	0x00070d0f, 0x00072d0f, 0x00074d0f, 0x00076d0f, 
-	0x00078d0f, 0x0007ad0f, 0x0007cd0f, 0x0007ed0f, 
-	0x00080d0f, 0x00082d0f, 0x00084d0f, 0x00086d0f, 
-	0x00088d0f, 0x0008ad0f, 0x0008cd0f, 0x0008ed0f, 
-	0x00090d0f, 0x00092d0f, 0x00094d0f, 0x00096d0f, 
-	0x00098d0f, 0x0009ad0f, 0x0009cd0f, 0x0009ed0f, 
-	0x000a0d0f, 0x000a2d0f, 0x000a4d0f, 0x000a6d0f, 
-	0x000a8d0f, 0x000aad0f, 0x000acd0f, 0x000aed0f, 
-	0x000b0d0f, 0x000b2d0f, 0x000b4d0f, 0x000b6d0f, 
-	0x000b8d0f, 0x000bad0f, 0x000bcd0f, 0x000bed0f, 
-	0x000c0d0f, 0x000c2d0f, 0x000c4d0f, 0x000c6d0f, 
-	0x000c8d0f, 0x000cad0f, 0x000ccd0f, 0x000ced0f, 
-	0x000d0d0f, 0x000d2d0f, 0x000d4d0f, 0x000d6d0f, 
-	0x000d8d0f, 0x000dad0f, 0x000dcd0f, 0x000ded0f, 
-	0x000e0d0f, 0x000e2d0f, 0x000e4d0f, 0x000e6d0f, 
-	0x000e8d0f, 0x000ead0f, 0x000ecd0f, 0x000eed0f, 
-	0x000f0d0f, 0x000f2d0f, 0x000f4d0f, 0x000f6d0f, 
-	0x000f8d0f, 0x000fad0f, 0x000fcd0f, 0x000fed0f, 
-	0x00100d0f, 0x00102d0f, 0x00104d0f, 0x00106d0f, 
-	0x00108d0f, 0x0010ad0f, 0x0010cd0f, 0x0010ed0f, 
-	0x00110d0f, 0x00112d0f, 0x00114d0f, 0x00116d0f, 
-	0x00118d0f, 0x0011ad0f, 0x0011cd0f, 0x0011ed0f, 
-	0x00120d0f, 0x00122d0f, 0x00124d0f, 0x00126d0f, 
-	0x00128d0f, 0x0012ad0f, 0x0012cd0f, 0x0012ed0f, 
-	0x00130d0f, 0x00132d0f, 0x00134d0f, 0x00136d0f, 
-	0x00138d0f, 0x0013ad0f, 0x0013cd0f, 0x0013ed0f, 
-	0x00140d0f, 0x00142d0f, 0x00144d0f, 0x00146d0f, 
-	0x00148d0f, 0x0014ad0f, 0x0014cd0f, 0x0014ed0f, 
-	0x00150d0f, 0x00152d0f, 0x00154d0f, 0x00156d0f, 
-	0x00158d0f, 0x0015ad0f, 0x0015cd0f, 0x0015ed0f, 
-	0x00160d0f, 0x00162d0f, 0x00164d0f, 0x00166d0f, 
-	0x00168d0f, 0x0016ad0f, 0x0016cd0f, 0x0016ed0f, 
-	0x00170d0f, 0x00172d0f, 0x00174d0f, 0x00176d0f, 
-	0x00178d0f, 0x0017ad0f, 0x0017cd0f, 0x0017ed0f, 
-	0x00180d0f, 0x00182d0f, 0x00184d0f, 0x00186d0f, 
-	0x00188d0f, 0x0018ad0f, 0x0018cd0f, 0x0018ed0f, 
-	0x00190d0f, 0x00192d0f, 0x00194d0f, 0x00196d0f, 
-	0x00198d0f, 0x0019ad0f, 0x0019cd0f, 0x0019ed0f, 
-	0x001a0d0f, 0x001a2d0f, 0x001a4d0f, 0x001a6d0f, 
-	0x001a8d0f, 0x001aad0f, 0x001acd0f, 0x001aed0f, 
-	0x001b0d0f, 0x001b2d0f, 0x001b4d0f, 0x001b6d0f, 
-	0x001b8d0f, 0x001bad0f, 0x001bcd0f, 0x001bed0f, 
-	0x001c0d0f, 0x001c2d0f, 0x001c4d0f, 0x001c6d0f, 
-	0x001c8d0f, 0x001cad0f, 0x001ccd0f, 0x001ced0f, 
-	0x001d0d0f, 0x001d2d0f, 0x001d4d0f, 0x001d6d0f, 
-	0x001d8d0f, 0x001dad0f, 0x001dcd0f, 0x001ded0f, 
-	0x001e0d0f, 0x001e2d0f, 0x001e4d0f, 0x001e6d0f, 
-	0x001e8d0f, 0x001ead0f, 0x001ecd0f, 0x001eed0f, 
-	0x001f0d0f, 0x001f2d0f, 0x001f4d0f, 0x001f6d0f, 
-	0x001f8d0f, 0x001fad0f, 0x001fcd0f, 0x001fed0f, 
-	0x00200d0f, 0x00202d0f, 0x00204d0f, 0x00206d0f, 
-	0x00208d0f, 0x0020ad0f, 0x0020cd0f, 0x0020ed0f, 
-	0x00210d0f, 0x00212d0f, 0x00214d0f, 0x00216d0f, 
-	0x00218d0f, 0x0021ad0f, 0x0021cd0f, 0x0021ed0f, 
-	0x00220d0f, 0x00222d0f, 0x00224d0f, 0x00226d0f, 
-	0x00228d0f, 0x0022ad0f, 0x0022cd0f, 0x0022ed0f, 
-	0x00230d0f, 0x00232d0f, 0x00234d0f, 0x00236d0f, 
-	0x00238d0f, 0x0023ad0f, 0x0023cd0f, 0x0023ed0f, 
-	0x00240d0f, 0x00242d0f, 0x00244d0f, 0x00246d0f, 
-	0x00248d0f, 0x0024ad0f, 0x0024cd0f, 0x0024ed0f, 
-	0x00250d0f, 0x00252d0f, 0x00254d0f, 0x00256d0f, 
-	0x00258d0f, 0x0025ad0f, 0x0025cd0f, 0x0025ed0f, 
-	0x00260d0f, 0x00262d0f, 0x00264d0f, 0x00266d0f, 
-	0x00268d0f, 0x0026ad0f, 0x0026cd0f, 0x0026ed0f, 
-	0x00270d0f, 0x00272d0f, 0x00274d0f, 0x00276d0f, 
-	0x00278d0f, 0x0027ad0f, 0x0027cd0f, 0x0027ed0f, 
-	0x00280d0f, 0x00282d0f, 0x00284d0f, 0x00286d0f, 
-	0x00288d0f, 0x0028ad0f, 0x0028cd0f, 0x0028ed0f, 
-	0x00290d0f, 0x00292d0f, 0x00294d0f, 0x00296d0f, 
-	0x00298d0f, 0x0029ad0f, 0x0029cd0f, 0x0029ed0f, 
-	0x002a0d0f, 0x002a2d0f, 0x002a4d0f, 0x002a6d0f, 
-	0x002a8d0f, 0x002aad0f, 0x002acd0f, 0x002aed0f, 
-	0x002b0d0f, 0x002b2d0f, 0x002b4d0f, 0x002b6d0f, 
-	0x002b8d0f, 0x002bad0f, 0x002bcd0f, 0x002bed0f, 
-	0x002c0d0f, 0x002c2d0f, 0x002c4d0f, 0x002c6d0f, 
-	0x002c8d0f, 0x002cad0f, 0x002ccd0f, 0x002ced0f, 
-	0x002d0d0f, 0x002d2d0f, 0x002d4d0f, 0x002d6d0f, 
-	0x002d8d0f, 0x002dad0f, 0x002dcd0f, 0x002ded0f, 
-	0x002e0d0f, 0x002e2d0f, 0x002e4d0f, 0x002e6d0f, 
-	0x002e8d0f, 0x002ead0f, 0x002ecd0f, 0x002eed0f, 
-	0x002f0d0f, 0x002f2d0f, 0x002f4d0f, 0x002f6d0f, 
-	0x002f8d0f, 0x002fad0f, 0x002fcd0f, 0x002fed0f, 
-	0x00300d0f, 0x00302d0f, 0x00304d0f, 0x00306d0f, 
-	0x00308d0f, 0x0030ad0f, 0x0030cd0f, 0x0030ed0f, 
-	0x00310d0f, 0x00312d0f, 0x00314d0f, 0x00316d0f, 
-	0x00318d0f, 0x0031ad0f, 0x0031cd0f, 0x0031ed0f, 
-	0x00320d0f, 0x00322d0f, 0x00324d0f, 0x00326d0f, 
-	0x00328d0f, 0x0032ad0f, 0x0032cd0f, 0x0032ed0f, 
-	0x00330d0f, 0x00332d0f, 0x00334d0f, 0x00336d0f, 
-	0x00338d0f, 0x0033ad0f, 0x0033cd0f, 0x0033ed0f, 
-	0x00340d0f, 0x00342d0f, 0x00344d0f, 0x00346d0f, 
-	0x00348d0f, 0x0034ad0f, 0x0034cd0f, 0x0034ed0f, 
-	0x00350d0f, 0x00352d0f, 0x00354d0f, 0x00356d0f, 
-	0x00358d0f, 0x0035ad0f, 0x0035cd0f, 0x0035ed0f, 
-	0x00360d0f, 0x00362d0f, 0x00364d0f, 0x00366d0f, 
-	0x00368d0f, 0x0036ad0f, 0x0036cd0f, 0x0036ed0f, 
-	0x00370d0f, 0x00372d0f, 0x00374d0f, 0x00376d0f, 
-	0x00378d0f, 0x0037ad0f, 0x0037cd0f, 0x0037ed0f, 
-	0x00380d0f, 0x00382d0f, 0x00384d0f, 0x00386d0f, 
-	0x00388d0f, 0x0038ad0f, 0x0038cd0f, 0x0038ed0f, 
-	0x00390d0f, 0x00392d0f, 0x00394d0f, 0x00396d0f, 
-	0x00398d0f, 0x0039ad0f, 0x0039cd0f, 0x0039ed0f, 
-	0x003a0d0f, 0x003a2d0f, 0x003a4d0f, 0x003a6d0f, 
-	0x003a8d0f, 0x003aad0f, 0x003acd0f, 0x003aed0f, 
-	0x003b0d0f, 0x003b2d0f, 0x003b4d0f, 0x003b6d0f, 
-	0x003b8d0f, 0x003bad0f, 0x003bcd0f, 0x003bed0f, 
-	0x003c0d0f, 0x003c2d0f, 0x003c4d0f, 0x003c6d0f, 
-	0x003c8d0f, 0x003cad0f, 0x003ccd0f, 0x003ced0f, 
-	0x003d0d0f, 0x003d2d0f, 0x003d4d0f, 0x003d6d0f, 
-	0x003d8d0f, 0x003dad0f, 0x003dcd0f, 0x003ded0f, 
-	0x003e0d0f, 0x003e2d0f, 0x003e4d0f, 0x003e6d0f, 
-	0x003e8d0f, 0x003ead0f, 0x003ecd0f, 0x003eed0f, 
-	0x003f0d0f, 0x003f2d0f, 0x003f4d0f, 0x003f6d0f, 
-	0x003f8d0f, 0x003fad0f, 0x003fcd0f, 0x003fed0f, 
-	0x00400d0f, 0x00402d0f, 0x00404d0f, 0x00406d0f, 
-	0x00408d0f, 0x0040ad0f, 0x0040cd0f, 0x0040ed0f, 
-	0x00410d0f, 0x00412d0f, 0x00414d0f, 0x00416d0f, 
-	0x00418d0f, 0x0041ad0f, 0x0041cd0f, 0x0041ed0f, 
-	0x00420d0f, 0x00422d0f, 0x00424d0f, 0x00426d0f, 
-	0x00428d0f, 0x0042ad0f, 0x0042cd0f, 0x0042ed0f, 
-	0x00430d0f, 0x00432d0f, 0x00434d0f, 0x00436d0f, 
-	0x00438d0f, 0x0043ad0f, 0x0043cd0f, 0x0043ed0f, 
-	0x00440d0f, 0x00442d0f, 0x00444d0f, 0x00446d0f, 
-	0x00448d0f, 0x0044ad0f, 0x0044cd0f, 0x0044ed0f, 
-	0x00450d0f, 0x00452d0f, 0x00454d0f, 0x00456d0f, 
-	0x00458d0f, 0x0045ad0f, 0x0045cd0f, 0x0045ed0f, 
-	0x00460d0f, 0x00462d0f, 0x00464d0f, 0x00466d0f, 
-	0x00468d0f, 0x0046ad0f, 0x0046cd0f, 0x0046ed0f, 
-	0x00470d0f, 0x00472d0f, 0x00474d0f, 0x00476d0f, 
-	0x00478d0f, 0x0047ad0f, 0x0047cd0f, 0x0047ed0f, 
-	0x00480d0f, 0x00482d0f, 0x00484d0f, 0x00486d0f, 
-	0x00488d0f, 0x0048ad0f, 0x0048cd0f, 0x0048ed0f, 
-	0x00490d0f, 0x00492d0f, 0x00494d0f, 0x00496d0f, 
-	0x00498d0f, 0x0049ad0f, 0x0049cd0f, 0x0049ed0f, 
-	0x004a0d0f, 0x004a2d0f, 0x004a4d0f, 0x004a6d0f, 
-	0x004a8d0f, 0x004aad0f, 0x004acd0f, 0x004aed0f, 
-	0x004b0d0f, 0x004b2d0f, 0x004b4d0f, 0x004b6d0f, 
-	0x004b8d0f, 0x004bad0f, 0x004bcd0f, 0x004bed0f, 
-	0x004c0d0f, 0x004c2d0f, 0x004c4d0f, 0x004c6d0f, 
-	0x004c8d0f, 0x004cad0f, 0x004ccd0f, 0x004ced0f, 
-	0x004d0d0f, 0x004d2d0f, 0x004d4d0f, 0x004d6d0f, 
-	0x004d8d0f, 0x004dad0f, 0x004dcd0f, 0x004ded0f, 
-	0x004e0d0f, 0x004e2d0f, 0x004e4d0f, 0x004e6d0f, 
-	0x004e8d0f, 0x004ead0f, 0x004ecd0f, 0x004eed0f, 
-	0x004f0d0f, 0x004f2d0f, 0x004f4d0f, 0x004f6d0f, 
-	0x004f8d0f, 0x004fad0f, 0x004fcd0f, 0x004fed0f, 
-	0x00500d0f, 0x00502d0f, 0x00504d0f, 0x00506d0f, 
-	0x00508d0f, 0x0050ad0f, 0x0050cd0f, 0x0050ed0f, 
-	0x00510d0f, 0x00512d0f, 0x00514d0f, 0x00516d0f, 
-	0x00518d0f, 0x0051ad0f, 0x0051cd0f, 0x0051ed0f, 
-	0x00520d0f, 0x00522d0f, 0x00524d0f, 0x00526d0f, 
-	0x00528d0f, 0x0052ad0f, 0x0052cd0f, 0x0052ed0f, 
-	0x00530d0f, 0x00532d0f, 0x00534d0f, 0x00536d0f, 
-	0x00538d0f, 0x0053ad0f, 0x0053cd0f, 0x0053ed0f, 
-	0x00540d0f, 0x00542d0f, 0x00544d0f, 0x00546d0f, 
-	0x00548d0f, 0x0054ad0f, 0x0054cd0f, 0x0054ed0f, 
-	0x00550d0f, 0x00552d0f, 0x00554d0f, 0x00556d0f, 
-	0x00558d0f, 0x0055ad0f, 0x0055cd0f, 0x0055ed0f, 
-	0x00560d0f, 0x00562d0f, 0x00564d0f, 0x00566d0f, 
-	0x00568d0f, 0x0056ad0f, 0x0056cd0f, 0x0056ed0f, 
-	0x00570d0f, 0x00572d0f, 0x00574d0f, 0x00576d0f, 
-	0x00578d0f, 0x0057ad0f, 0x0057cd0f, 0x0057ed0f, 
-	0x00580d0f, 0x00582d0f, 0x00584d0f, 0x00586d0f, 
-	0x00588d0f, 0x0058ad0f, 0x0058cd0f, 0x0058ed0f, 
-	0x00590d0f, 0x00592d0f, 0x00594d0f, 0x00596d0f, 
-	0x00598d0f, 0x0059ad0f, 0x0059cd0f, 0x0059ed0f, 
-	0x005a0d0f, 0x005a2d0f, 0x005a4d0f, 0x005a6d0f, 
-	0x005a8d0f, 0x005aad0f, 0x005acd0f, 0x005aed0f, 
-	0x005b0d0f, 0x005b2d0f, 0x005b4d0f, 0x005b6d0f, 
-	0x005b8d0f, 0x005bad0f, 0x005bcd0f, 0x005bed0f, 
-	0x005c0d0f, 0x005c2d0f, 0x005c4d0f, 0x005c6d0f, 
-	0x005c8d0f, 0x005cad0f, 0x005ccd0f, 0x005ced0f, 
-	0x005d0d0f, 0x005d2d0f, 0x005d4d0f, 0x005d6d0f, 
-	0x005d8d0f, 0x005dad0f, 0x005dcd0f, 0x005ded0f, 
-	0x005e0d0f, 0x005e2d0f, 0x005e4d0f, 0x005e6d0f, 
-	0x005e8d0f, 0x005ead0f, 0x005ecd0f, 0x005eed0f, 
-	0x005f0d0f, 0x005f2d0f, 0x005f4d0f, 0x005f6d0f, 
-	0x005f8d0f, 0x005fad0f, 0x005fcd0f, 0x005fed0f, 
-	0x00600d0f, 0x00602d0f, 0x00604d0f, 0x00606d0f, 
-	0x00608d0f, 0x0060ad0f, 0x0060cd0f, 0x0060ed0f, 
-	0x00610d0f, 0x00612d0f, 0x00614d0f, 0x00616d0f, 
-	0x00618d0f, 0x0061ad0f, 0x0061cd0f, 0x0061ed0f, 
-	0x00620d0f, 0x00622d0f, 0x00624d0f, 0x00626d0f, 
-	0x00628d0f, 0x0062ad0f, 0x0062cd0f, 0x0062ed0f, 
-	0x00630d0f, 0x00632d0f, 0x00634d0f, 0x00636d0f, 
-	0x00638d0f, 0x0063ad0f, 0x0063cd0f, 0x0063ed0f, 
-	0x00640d0f, 0x00642d0f, 0x00644d0f, 0x00646d0f, 
-	0x00648d0f, 0x0064ad0f, 0x0064cd0f, 0x0064ed0f, 
-	0x00650d0f, 0x00652d0f, 0x00654d0f, 0x00656d0f, 
-	0x00658d0f, 0x0065ad0f, 0x0065cd0f, 0x0065ed0f, 
-	0x00660d0f, 0x00662d0f, 0x00664d0f, 0x00666d0f, 
-	0x00668d0f, 0x0066ad0f, 0x0066cd0f, 0x0066ed0f, 
-	0x00670d0f, 0x00672d0f, 0x00674d0f, 0x00676d0f, 
-	0x00678d0f, 0x0067ad0f, 0x0067cd0f, 0x0067ed0f, 
-	0x00680d0f, 0x00682d0f, 0x00684d0f, 0x00686d0f, 
-	0x00688d0f, 0x0068ad0f, 0x0068cd0f, 0x0068ed0f, 
-	0x00690d0f, 0x00692d0f, 0x00694d0f, 0x00696d0f, 
-	0x00698d0f, 0x0069ad0f, 0x0069cd0f, 0x0069ed0f, 
-	0x006a0d0f, 0x006a2d0f, 0x006a4d0f, 0x006a6d0f, 
-	0x006a8d0f, 0x006aad0f, 0x006acd0f, 0x006aed0f, 
-	0x006b0d0f, 0x006b2d0f, 0x006b4d0f, 0x006b6d0f, 
-	0x006b8d0f, 0x006bad0f, 0x006bcd0f, 0x006bed0f, 
-	0x006c0d0f, 0x006c2d0f, 0x006c4d0f, 0x006c6d0f, 
-	0x006c8d0f, 0x006cad0f, 0x006ccd0f, 0x006ced0f, 
-	0x006d0d0f, 0x006d2d0f, 0x006d4d0f, 0x006d6d0f, 
-	0x006d8d0f, 0x006dad0f, 0x006dcd0f, 0x006ded0f, 
-	0x006e0d0f, 0x006e2d0f, 0x006e4d0f, 0x006e6d0f, 
-	0x006e8d0f, 0x006ead0f, 0x006ecd0f, 0x006eed0f, 
-	0x006f0d0f, 0x006f2d0f, 0x006f4d0f, 0x006f6d0f, 
-	0x006f8d0f, 0x006fad0f, 0x006fcd0f, 0x006fed0f, 
-	0x00700d0f, 0x00702d0f, 0x00704d0f, 0x00706d0f, 
-	0x00708d0f, 0x0070ad0f, 0x0070cd0f, 0x0070ed0f, 
-	0x00710d0f, 0x00712d0f, 0x00714d0f, 0x00716d0f, 
-	0x00718d0f, 0x0071ad0f, 0x0071cd0f, 0x0071ed0f, 
-	0x00720d0f, 0x00722d0f, 0x00724d0f, 0x00726d0f, 
-	0x00728d0f, 0x0072ad0f, 0x0072cd0f, 0x0072ed0f, 
-	0x00730d0f, 0x00732d0f, 0x00734d0f, 0x00736d0f, 
-	0x00738d0f, 0x0073ad0f, 0x0073cd0f, 0x0073ed0f, 
-	0x00740d0f, 0x00742d0f, 0x00744d0f, 0x00746d0f, 
-	0x00748d0f, 0x0074ad0f, 0x0074cd0f, 0x0074ed0f, 
-	0x00750d0f, 0x00752d0f, 0x00754d0f, 0x00756d0f, 
-	0x00758d0f, 0x0075ad0f, 0x0075cd0f, 0x0075ed0f, 
-	0x00760d0f, 0x00762d0f, 0x00764d0f, 0x00766d0f, 
-	0x00768d0f, 0x0076ad0f, 0x0076cd0f, 0x0076ed0f, 
-	0x00770d0f, 0x00772d0f, 0x00774d0f, 0x00776d0f, 
-	0x00778d0f, 0x0077ad0f, 0x0077cd0f, 0x0077ed0f, 
-	0x00780d0f, 0x00782d0f, 0x00784d0f, 0x00786d0f, 
-	0x00788d0f, 0x0078ad0f, 0x0078cd0f, 0x0078ed0f, 
-	0x00790d0f, 0x00792d0f, 0x00794d0f, 0x00796d0f, 
-	0x00798d0f, 0x0079ad0f, 0x0079cd0f, 0x0079ed0f, 
-	0x007a0d0f, 0x007a2d0f, 0x007a4d0f, 0x007a6d0f, 
-	0x007a8d0f, 0x007aad0f, 0x007acd0f, 0x007aed0f, 
-	0x007b0d0f, 0x007b2d0f, 0x007b4d0f, 0x007b6d0f, 
-	0x007b8d0f, 0x007bad0f, 0x007bcd0f, 0x007bed0f, 
-	0x007c0d0f, 0x007c2d0f, 0x007c4d0f, 0x007c6d0f, 
-	0x007c8d0f, 0x007cad0f, 0x007ccd0f, 0x007ced0f, 
-	0x007d0d0f, 0x007d2d0f, 0x007d4d0f, 0x007d6d0f, 
-	0x007d8d0f, 0x007dad0f, 0x007dcd0f, 0x007ded0f, 
-	0x007e0d0f, 0x007e2d0f, 0x007e4d0f, 0x007e6d0f, 
-	0x007e8d0f, 0x007ead0f, 0x007ecd0f, 0x007eed0f, 
-	0x007f0d0f, 0x007f2d0f, 0x007f4d0f, 0x007f6d0f, 
-	0x007f8d0f, 0x007fad0f, 0x007fcd0f, 0x007fed0f, 
-	0x00001d0f, 0x00003d0f, 0x00005d0f, 0x00007d0f, 
-	0x00009d0f, 0x0000bd0f, 0x0000dd0f, 0x0000fd0f, 
-	0x00011d0f, 0x00013d0f, 0x00015d0f, 0x00017d0f, 
-	0x00019d0f, 0x0001bd0f, 0x0001dd0f, 0x0001fd0f, 
-	0x00021d0f, 0x00023d0f, 0x00025d0f, 0x00027d0f, 
-	0x00029d0f, 0x0002bd0f, 0x0002dd0f, 0x0002fd0f, 
-	0x00031d0f, 0x00033d0f, 0x00035d0f, 0x00037d0f, 
-	0x00039d0f, 0x0003bd0f, 0x0003dd0f, 0x0003fd0f, 
-	0x00041d0f, 0x00043d0f, 0x00045d0f, 0x00047d0f, 
-	0x00049d0f, 0x0004bd0f, 0x0004dd0f, 0x0004fd0f, 
-	0x00051d0f, 0x00053d0f, 0x00055d0f, 0x00057d0f, 
-	0x00059d0f, 0x0005bd0f, 0x0005dd0f, 0x0005fd0f, 
-	0x00061d0f, 0x00063d0f, 0x00065d0f, 0x00067d0f, 
-	0x00069d0f, 0x0006bd0f, 0x0006dd0f, 0x0006fd0f, 
-	0x00071d0f, 0x00073d0f, 0x00075d0f, 0x00077d0f, 
-	0x00079d0f, 0x0007bd0f, 0x0007dd0f, 0x0007fd0f, 
-	0x00081d0f, 0x00083d0f, 0x00085d0f, 0x00087d0f, 
-	0x00089d0f, 0x0008bd0f, 0x0008dd0f, 0x0008fd0f, 
-	0x00091d0f, 0x00093d0f, 0x00095d0f, 0x00097d0f, 
-	0x00099d0f, 0x0009bd0f, 0x0009dd0f, 0x0009fd0f, 
-	0x000a1d0f, 0x000a3d0f, 0x000a5d0f, 0x000a7d0f, 
-	0x000a9d0f, 0x000abd0f, 0x000add0f, 0x000afd0f, 
-	0x000b1d0f, 0x000b3d0f, 0x000b5d0f, 0x000b7d0f, 
-	0x000b9d0f, 0x000bbd0f, 0x000bdd0f, 0x000bfd0f, 
-	0x000c1d0f, 0x000c3d0f, 0x000c5d0f, 0x000c7d0f, 
-	0x000c9d0f, 0x000cbd0f, 0x000cdd0f, 0x000cfd0f, 
-	0x000d1d0f, 0x000d3d0f, 0x000d5d0f, 0x000d7d0f, 
-	0x000d9d0f, 0x000dbd0f, 0x000ddd0f, 0x000dfd0f, 
-	0x000e1d0f, 0x000e3d0f, 0x000e5d0f, 0x000e7d0f, 
-	0x000e9d0f, 0x000ebd0f, 0x000edd0f, 0x000efd0f, 
-	0x000f1d0f, 0x000f3d0f, 0x000f5d0f, 0x000f7d0f, 
-	0x000f9d0f, 0x000fbd0f, 0x000fdd0f, 0x000ffd0f, 
-	0x00101d0f, 0x00103d0f, 0x00105d0f, 0x00107d0f, 
-	0x00109d0f, 0x0010bd0f, 0x0010dd0f, 0x0010fd0f, 
-	0x00111d0f, 0x00113d0f, 0x00115d0f, 0x00117d0f, 
-	0x00119d0f, 0x0011bd0f, 0x0011dd0f, 0x0011fd0f, 
-	0x00121d0f, 0x00123d0f, 0x00125d0f, 0x00127d0f, 
-	0x00129d0f, 0x0012bd0f, 0x0012dd0f, 0x0012fd0f, 
-	0x00131d0f, 0x00133d0f, 0x00135d0f, 0x00137d0f, 
-	0x00139d0f, 0x0013bd0f, 0x0013dd0f, 0x0013fd0f, 
-	0x00141d0f, 0x00143d0f, 0x00145d0f, 0x00147d0f, 
-	0x00149d0f, 0x0014bd0f, 0x0014dd0f, 0x0014fd0f, 
-	0x00151d0f, 0x00153d0f, 0x00155d0f, 0x00157d0f, 
-	0x00159d0f, 0x0015bd0f, 0x0015dd0f, 0x0015fd0f, 
-	0x00161d0f, 0x00163d0f, 0x00165d0f, 0x00167d0f, 
-	0x00169d0f, 0x0016bd0f, 0x0016dd0f, 0x0016fd0f, 
-	0x00171d0f, 0x00173d0f, 0x00175d0f, 0x00177d0f, 
-	0x00179d0f, 0x0017bd0f, 0x0017dd0f, 0x0017fd0f, 
-	0x00181d0f, 0x00183d0f, 0x00185d0f, 0x00187d0f, 
-	0x00189d0f, 0x0018bd0f, 0x0018dd0f, 0x0018fd0f, 
-	0x00191d0f, 0x00193d0f, 0x00195d0f, 0x00197d0f, 
-	0x00199d0f, 0x0019bd0f, 0x0019dd0f, 0x0019fd0f, 
-	0x001a1d0f, 0x001a3d0f, 0x001a5d0f, 0x001a7d0f, 
-	0x001a9d0f, 0x001abd0f, 0x001add0f, 0x001afd0f, 
-	0x001b1d0f, 0x001b3d0f, 0x001b5d0f, 0x001b7d0f, 
-	0x001b9d0f, 0x001bbd0f, 0x001bdd0f, 0x001bfd0f, 
-	0x001c1d0f, 0x001c3d0f, 0x001c5d0f, 0x001c7d0f, 
-	0x001c9d0f, 0x001cbd0f, 0x001cdd0f, 0x001cfd0f, 
-	0x001d1d0f, 0x001d3d0f, 0x001d5d0f, 0x001d7d0f, 
-	0x001d9d0f, 0x001dbd0f, 0x001ddd0f, 0x001dfd0f, 
-	0x001e1d0f, 0x001e3d0f, 0x001e5d0f, 0x001e7d0f, 
-	0x001e9d0f, 0x001ebd0f, 0x001edd0f, 0x001efd0f, 
-	0x001f1d0f, 0x001f3d0f, 0x001f5d0f, 0x001f7d0f, 
-	0x001f9d0f, 0x001fbd0f, 0x001fdd0f, 0x001ffd0f, 
-	0x00201d0f, 0x00203d0f, 0x00205d0f, 0x00207d0f, 
-	0x00209d0f, 0x0020bd0f, 0x0020dd0f, 0x0020fd0f, 
-	0x00211d0f, 0x00213d0f, 0x00215d0f, 0x00217d0f, 
-	0x00219d0f, 0x0021bd0f, 0x0021dd0f, 0x0021fd0f, 
-	0x00221d0f, 0x00223d0f, 0x00225d0f, 0x00227d0f, 
-	0x00229d0f, 0x0022bd0f, 0x0022dd0f, 0x0022fd0f, 
-	0x00231d0f, 0x00233d0f, 0x00235d0f, 0x00237d0f, 
-	0x00239d0f, 0x0023bd0f, 0x0023dd0f, 0x0023fd0f, 
-	0x00241d0f, 0x00243d0f, 0x00245d0f, 0x00247d0f, 
-	0x00249d0f, 0x0024bd0f, 0x0024dd0f, 0x0024fd0f, 
-	0x00251d0f, 0x00253d0f, 0x00255d0f, 0x00257d0f, 
-	0x00259d0f, 0x0025bd0f, 0x0025dd0f, 0x0025fd0f, 
-	0x00261d0f, 0x00263d0f, 0x00265d0f, 0x00267d0f, 
-	0x00269d0f, 0x0026bd0f, 0x0026dd0f, 0x0026fd0f, 
-	0x00271d0f, 0x00273d0f, 0x00275d0f, 0x00277d0f, 
-	0x00279d0f, 0x0027bd0f, 0x0027dd0f, 0x0027fd0f, 
-	0x00281d0f, 0x00283d0f, 0x00285d0f, 0x00287d0f, 
-	0x00289d0f, 0x0028bd0f, 0x0028dd0f, 0x0028fd0f, 
-	0x00291d0f, 0x00293d0f, 0x00295d0f, 0x00297d0f, 
-	0x00299d0f, 0x0029bd0f, 0x0029dd0f, 0x0029fd0f, 
-	0x002a1d0f, 0x002a3d0f, 0x002a5d0f, 0x002a7d0f, 
-	0x002a9d0f, 0x002abd0f, 0x002add0f, 0x002afd0f, 
-	0x002b1d0f, 0x002b3d0f, 0x002b5d0f, 0x002b7d0f, 
-	0x002b9d0f, 0x002bbd0f, 0x002bdd0f, 0x002bfd0f, 
-	0x002c1d0f, 0x002c3d0f, 0x002c5d0f, 0x002c7d0f, 
-	0x002c9d0f, 0x002cbd0f, 0x002cdd0f, 0x002cfd0f, 
-	0x002d1d0f, 0x002d3d0f, 0x002d5d0f, 0x002d7d0f, 
-	0x002d9d0f, 0x002dbd0f, 0x002ddd0f, 0x002dfd0f, 
-	0x002e1d0f, 0x002e3d0f, 0x002e5d0f, 0x002e7d0f, 
-	0x002e9d0f, 0x002ebd0f, 0x002edd0f, 0x002efd0f, 
-	0x002f1d0f, 0x002f3d0f, 0x002f5d0f, 0x002f7d0f, 
-	0x002f9d0f, 0x002fbd0f, 0x002fdd0f, 0x002ffd0f, 
-	0x00301d0f, 0x00303d0f, 0x00305d0f, 0x00307d0f, 
-	0x00309d0f, 0x0030bd0f, 0x0030dd0f, 0x0030fd0f, 
-	0x00311d0f, 0x00313d0f, 0x00315d0f, 0x00317d0f, 
-	0x00319d0f, 0x0031bd0f, 0x0031dd0f, 0x0031fd0f, 
-	0x00321d0f, 0x00323d0f, 0x00325d0f, 0x00327d0f, 
-	0x00329d0f, 0x0032bd0f, 0x0032dd0f, 0x0032fd0f, 
-	0x00331d0f, 0x00333d0f, 0x00335d0f, 0x00337d0f, 
-	0x00339d0f, 0x0033bd0f, 0x0033dd0f, 0x0033fd0f, 
-	0x00341d0f, 0x00343d0f, 0x00345d0f, 0x00347d0f, 
-	0x00349d0f, 0x0034bd0f, 0x0034dd0f, 0x0034fd0f, 
-	0x00351d0f, 0x00353d0f, 0x00355d0f, 0x00357d0f, 
-	0x00359d0f, 0x0035bd0f, 0x0035dd0f, 0x0035fd0f, 
-	0x00361d0f, 0x00363d0f, 0x00365d0f, 0x00367d0f, 
-	0x00369d0f, 0x0036bd0f, 0x0036dd0f, 0x0036fd0f, 
-	0x00371d0f, 0x00373d0f, 0x00375d0f, 0x00377d0f, 
-	0x00379d0f, 0x0037bd0f, 0x0037dd0f, 0x0037fd0f, 
-	0x00381d0f, 0x00383d0f, 0x00385d0f, 0x00387d0f, 
-	0x00389d0f, 0x0038bd0f, 0x0038dd0f, 0x0038fd0f, 
-	0x00391d0f, 0x00393d0f, 0x00395d0f, 0x00397d0f, 
-	0x00399d0f, 0x0039bd0f, 0x0039dd0f, 0x0039fd0f, 
-	0x003a1d0f, 0x003a3d0f, 0x003a5d0f, 0x003a7d0f, 
-	0x003a9d0f, 0x003abd0f, 0x003add0f, 0x003afd0f, 
-	0x003b1d0f, 0x003b3d0f, 0x003b5d0f, 0x003b7d0f, 
-	0x003b9d0f, 0x003bbd0f, 0x003bdd0f, 0x003bfd0f, 
-	0x003c1d0f, 0x003c3d0f, 0x003c5d0f, 0x003c7d0f, 
-	0x003c9d0f, 0x003cbd0f, 0x003cdd0f, 0x003cfd0f, 
-	0x003d1d0f, 0x003d3d0f, 0x003d5d0f, 0x003d7d0f, 
-	0x003d9d0f, 0x003dbd0f, 0x003ddd0f, 0x003dfd0f, 
-	0x003e1d0f, 0x003e3d0f, 0x003e5d0f, 0x003e7d0f, 
-	0x003e9d0f, 0x003ebd0f, 0x003edd0f, 0x003efd0f, 
-	0x003f1d0f, 0x003f3d0f, 0x003f5d0f, 0x003f7d0f, 
-	0x003f9d0f, 0x003fbd0f, 0x003fdd0f, 0x003ffd0f, 
-	0x00401d0f, 0x00403d0f, 0x00405d0f, 0x00407d0f, 
-	0x00409d0f, 0x0040bd0f, 0x0040dd0f, 0x0040fd0f, 
-	0x00411d0f, 0x00413d0f, 0x00415d0f, 0x00417d0f, 
-	0x00419d0f, 0x0041bd0f, 0x0041dd0f, 0x0041fd0f, 
-	0x00421d0f, 0x00423d0f, 0x00425d0f, 0x00427d0f, 
-	0x00429d0f, 0x0042bd0f, 0x0042dd0f, 0x0042fd0f, 
-	0x00431d0f, 0x00433d0f, 0x00435d0f, 0x00437d0f, 
-	0x00439d0f, 0x0043bd0f, 0x0043dd0f, 0x0043fd0f, 
-	0x00441d0f, 0x00443d0f, 0x00445d0f, 0x00447d0f, 
-	0x00449d0f, 0x0044bd0f, 0x0044dd0f, 0x0044fd0f, 
-	0x00451d0f, 0x00453d0f, 0x00455d0f, 0x00457d0f, 
-	0x00459d0f, 0x0045bd0f, 0x0045dd0f, 0x0045fd0f, 
-	0x00461d0f, 0x00463d0f, 0x00465d0f, 0x00467d0f, 
-	0x00469d0f, 0x0046bd0f, 0x0046dd0f, 0x0046fd0f, 
-	0x00471d0f, 0x00473d0f, 0x00475d0f, 0x00477d0f, 
-	0x00479d0f, 0x0047bd0f, 0x0047dd0f, 0x0047fd0f, 
-	0x00481d0f, 0x00483d0f, 0x00485d0f, 0x00487d0f, 
-	0x00489d0f, 0x0048bd0f, 0x0048dd0f, 0x0048fd0f, 
-	0x00491d0f, 0x00493d0f, 0x00495d0f, 0x00497d0f, 
-	0x00499d0f, 0x0049bd0f, 0x0049dd0f, 0x0049fd0f, 
-	0x004a1d0f, 0x004a3d0f, 0x004a5d0f, 0x004a7d0f, 
-	0x004a9d0f, 0x004abd0f, 0x004add0f, 0x004afd0f, 
-	0x004b1d0f, 0x004b3d0f, 0x004b5d0f, 0x004b7d0f, 
-	0x004b9d0f, 0x004bbd0f, 0x004bdd0f, 0x004bfd0f, 
-	0x004c1d0f, 0x004c3d0f, 0x004c5d0f, 0x004c7d0f, 
-	0x004c9d0f, 0x004cbd0f, 0x004cdd0f, 0x004cfd0f, 
-	0x004d1d0f, 0x004d3d0f, 0x004d5d0f, 0x004d7d0f, 
-	0x004d9d0f, 0x004dbd0f, 0x004ddd0f, 0x004dfd0f, 
-	0x004e1d0f, 0x004e3d0f, 0x004e5d0f, 0x004e7d0f, 
-	0x004e9d0f, 0x004ebd0f, 0x004edd0f, 0x004efd0f, 
-	0x004f1d0f, 0x004f3d0f, 0x004f5d0f, 0x004f7d0f, 
-	0x004f9d0f, 0x004fbd0f, 0x004fdd0f, 0x004ffd0f, 
-	0x00501d0f, 0x00503d0f, 0x00505d0f, 0x00507d0f, 
-	0x00509d0f, 0x0050bd0f, 0x0050dd0f, 0x0050fd0f, 
-	0x00511d0f, 0x00513d0f, 0x00515d0f, 0x00517d0f, 
-	0x00519d0f, 0x0051bd0f, 0x0051dd0f, 0x0051fd0f, 
-	0x00521d0f, 0x00523d0f, 0x00525d0f, 0x00527d0f, 
-	0x00529d0f, 0x0052bd0f, 0x0052dd0f, 0x0052fd0f, 
-	0x00531d0f, 0x00533d0f, 0x00535d0f, 0x00537d0f, 
-	0x00539d0f, 0x0053bd0f, 0x0053dd0f, 0x0053fd0f, 
-	0x00541d0f, 0x00543d0f, 0x00545d0f, 0x00547d0f, 
-	0x00549d0f, 0x0054bd0f, 0x0054dd0f, 0x0054fd0f, 
-	0x00551d0f, 0x00553d0f, 0x00555d0f, 0x00557d0f, 
-	0x00559d0f, 0x0055bd0f, 0x0055dd0f, 0x0055fd0f, 
-	0x00561d0f, 0x00563d0f, 0x00565d0f, 0x00567d0f, 
-	0x00569d0f, 0x0056bd0f, 0x0056dd0f, 0x0056fd0f, 
-	0x00571d0f, 0x00573d0f, 0x00575d0f, 0x00577d0f, 
-	0x00579d0f, 0x0057bd0f, 0x0057dd0f, 0x0057fd0f, 
-	0x00581d0f, 0x00583d0f, 0x00585d0f, 0x00587d0f, 
-	0x00589d0f, 0x0058bd0f, 0x0058dd0f, 0x0058fd0f, 
-	0x00591d0f, 0x00593d0f, 0x00595d0f, 0x00597d0f, 
-	0x00599d0f, 0x0059bd0f, 0x0059dd0f, 0x0059fd0f, 
-	0x005a1d0f, 0x005a3d0f, 0x005a5d0f, 0x005a7d0f, 
-	0x005a9d0f, 0x005abd0f, 0x005add0f, 0x005afd0f, 
-	0x005b1d0f, 0x005b3d0f, 0x005b5d0f, 0x005b7d0f, 
-	0x005b9d0f, 0x005bbd0f, 0x005bdd0f, 0x005bfd0f, 
-	0x005c1d0f, 0x005c3d0f, 0x005c5d0f, 0x005c7d0f, 
-	0x005c9d0f, 0x005cbd0f, 0x005cdd0f, 0x005cfd0f, 
-	0x005d1d0f, 0x005d3d0f, 0x005d5d0f, 0x005d7d0f, 
-	0x005d9d0f, 0x005dbd0f, 0x005ddd0f, 0x005dfd0f, 
-	0x005e1d0f, 0x005e3d0f, 0x005e5d0f, 0x005e7d0f, 
-	0x005e9d0f, 0x005ebd0f, 0x005edd0f, 0x005efd0f, 
-	0x005f1d0f, 0x005f3d0f, 0x005f5d0f, 0x005f7d0f, 
-	0x005f9d0f, 0x005fbd0f, 0x005fdd0f, 0x005ffd0f, 
-	0x00601d0f, 0x00603d0f, 0x00605d0f, 0x00607d0f, 
-	0x00609d0f, 0x0060bd0f, 0x0060dd0f, 0x0060fd0f, 
-	0x00611d0f, 0x00613d0f, 0x00615d0f, 0x00617d0f, 
-	0x00619d0f, 0x0061bd0f, 0x0061dd0f, 0x0061fd0f, 
-	0x00621d0f, 0x00623d0f, 0x00625d0f, 0x00627d0f, 
-	0x00629d0f, 0x0062bd0f, 0x0062dd0f, 0x0062fd0f, 
-	0x00631d0f, 0x00633d0f, 0x00635d0f, 0x00637d0f, 
-	0x00639d0f, 0x0063bd0f, 0x0063dd0f, 0x0063fd0f, 
-	0x00641d0f, 0x00643d0f, 0x00645d0f, 0x00647d0f, 
-	0x00649d0f, 0x0064bd0f, 0x0064dd0f, 0x0064fd0f, 
-	0x00651d0f, 0x00653d0f, 0x00655d0f, 0x00657d0f, 
-	0x00659d0f, 0x0065bd0f, 0x0065dd0f, 0x0065fd0f, 
-	0x00661d0f, 0x00663d0f, 0x00665d0f, 0x00667d0f, 
-	0x00669d0f, 0x0066bd0f, 0x0066dd0f, 0x0066fd0f, 
-	0x00671d0f, 0x00673d0f, 0x00675d0f, 0x00677d0f, 
-	0x00679d0f, 0x0067bd0f, 0x0067dd0f, 0x0067fd0f, 
-	0x00681d0f, 0x00683d0f, 0x00685d0f, 0x00687d0f, 
-	0x00689d0f, 0x0068bd0f, 0x0068dd0f, 0x0068fd0f, 
-	0x00691d0f, 0x00693d0f, 0x00695d0f, 0x00697d0f, 
-	0x00699d0f, 0x0069bd0f, 0x0069dd0f, 0x0069fd0f, 
-	0x006a1d0f, 0x006a3d0f, 0x006a5d0f, 0x006a7d0f, 
-	0x006a9d0f, 0x006abd0f, 0x006add0f, 0x006afd0f, 
-	0x006b1d0f, 0x006b3d0f, 0x006b5d0f, 0x006b7d0f, 
-	0x006b9d0f, 0x006bbd0f, 0x006bdd0f, 0x006bfd0f, 
-	0x006c1d0f, 0x006c3d0f, 0x006c5d0f, 0x006c7d0f, 
-	0x006c9d0f, 0x006cbd0f, 0x006cdd0f, 0x006cfd0f, 
-	0x006d1d0f, 0x006d3d0f, 0x006d5d0f, 0x006d7d0f, 
-	0x006d9d0f, 0x006dbd0f, 0x006ddd0f, 0x006dfd0f, 
-	0x006e1d0f, 0x006e3d0f, 0x006e5d0f, 0x006e7d0f, 
-	0x006e9d0f, 0x006ebd0f, 0x006edd0f, 0x006efd0f, 
-	0x006f1d0f, 0x006f3d0f, 0x006f5d0f, 0x006f7d0f, 
-	0x006f9d0f, 0x006fbd0f, 0x006fdd0f, 0x006ffd0f, 
-	0x00701d0f, 0x00703d0f, 0x00705d0f, 0x00707d0f, 
-	0x00709d0f, 0x0070bd0f, 0x0070dd0f, 0x0070fd0f, 
-	0x00711d0f, 0x00713d0f, 0x00715d0f, 0x00717d0f, 
-	0x00719d0f, 0x0071bd0f, 0x0071dd0f, 0x0071fd0f, 
-	0x00721d0f, 0x00723d0f, 0x00725d0f, 0x00727d0f, 
-	0x00729d0f, 0x0072bd0f, 0x0072dd0f, 0x0072fd0f, 
-	0x00731d0f, 0x00733d0f, 0x00735d0f, 0x00737d0f, 
-	0x00739d0f, 0x0073bd0f, 0x0073dd0f, 0x0073fd0f, 
-	0x00741d0f, 0x00743d0f, 0x00745d0f, 0x00747d0f, 
-	0x00749d0f, 0x0074bd0f, 0x0074dd0f, 0x0074fd0f, 
-	0x00751d0f, 0x00753d0f, 0x00755d0f, 0x00757d0f, 
-	0x00759d0f, 0x0075bd0f, 0x0075dd0f, 0x0075fd0f, 
-	0x00761d0f, 0x00763d0f, 0x00765d0f, 0x00767d0f, 
-	0x00769d0f, 0x0076bd0f, 0x0076dd0f, 0x0076fd0f, 
-	0x00771d0f, 0x00773d0f, 0x00775d0f, 0x00777d0f, 
-	0x00779d0f, 0x0077bd0f, 0x0077dd0f, 0x0077fd0f, 
-	0x00781d0f, 0x00783d0f, 0x00785d0f, 0x00787d0f, 
-	0x00789d0f, 0x0078bd0f, 0x0078dd0f, 0x0078fd0f, 
-	0x00791d0f, 0x00793d0f, 0x00795d0f, 0x00797d0f, 
-	0x00799d0f, 0x0079bd0f, 0x0079dd0f, 0x0079fd0f, 
-	0x007a1d0f, 0x007a3d0f, 0x007a5d0f, 0x007a7d0f, 
-	0x007a9d0f, 0x007abd0f, 0x007add0f, 0x007afd0f, 
-	0x007b1d0f, 0x007b3d0f, 0x007b5d0f, 0x007b7d0f, 
-	0x007b9d0f, 0x007bbd0f, 0x007bdd0f, 0x007bfd0f, 
-	0x007c1d0f, 0x007c3d0f, 0x007c5d0f, 0x007c7d0f, 
-	0x007c9d0f, 0x007cbd0f, 0x007cdd0f, 0x007cfd0f, 
-	0x007d1d0f, 0x007d3d0f, 0x007d5d0f, 0x007d7d0f, 
-	0x007d9d0f, 0x007dbd0f, 0x007ddd0f, 0x007dfd0f, 
-	0x007e1d0f, 0x007e3d0f, 0x007e5d0f, 0x007e7d0f, 
-	0x007e9d0f, 0x007ebd0f, 0x007edd0f, 0x007efd0f, 
-	0x007f1d0f, 0x007f3d0f, 0x007f5d0f, 0x007f7d0f, 
-	0x007f9d0f, 0x007fbd0f, 0x007fdd0f, 0x007ffd0f, 
-	0x00000310, 0x00002310, 0x00004310, 0x00006310, 
-	0x00008310, 0x0000a310, 0x0000c310, 0x0000e310, 
-	0x00010310, 0x00012310, 0x00014310, 0x00016310, 
-	0x00018310, 0x0001a310, 0x0001c310, 0x0001e310, 
-	0x00020310, 0x00022310, 0x00024310, 0x00026310, 
-	0x00028310, 0x0002a310, 0x0002c310, 0x0002e310, 
-	0x00030310, 0x00032310, 0x00034310, 0x00036310, 
-	0x00038310, 0x0003a310, 0x0003c310, 0x0003e310, 
-	0x00040310, 0x00042310, 0x00044310, 0x00046310, 
-	0x00048310, 0x0004a310, 0x0004c310, 0x0004e310, 
-	0x00050310, 0x00052310, 0x00054310, 0x00056310, 
-	0x00058310, 0x0005a310, 0x0005c310, 0x0005e310, 
-	0x00060310, 0x00062310, 0x00064310, 0x00066310, 
-	0x00068310, 0x0006a310, 0x0006c310, 0x0006e310, 
-	0x00070310, 0x00072310, 0x00074310, 0x00076310, 
-	0x00078310, 0x0007a310, 0x0007c310, 0x0007e310, 
-	0x00080310, 0x00082310, 0x00084310, 0x00086310, 
-	0x00088310, 0x0008a310, 0x0008c310, 0x0008e310, 
-	0x00090310, 0x00092310, 0x00094310, 0x00096310, 
-	0x00098310, 0x0009a310, 0x0009c310, 0x0009e310, 
-	0x000a0310, 0x000a2310, 0x000a4310, 0x000a6310, 
-	0x000a8310, 0x000aa310, 0x000ac310, 0x000ae310, 
-	0x000b0310, 0x000b2310, 0x000b4310, 0x000b6310, 
-	0x000b8310, 0x000ba310, 0x000bc310, 0x000be310, 
-	0x000c0310, 0x000c2310, 0x000c4310, 0x000c6310, 
-	0x000c8310, 0x000ca310, 0x000cc310, 0x000ce310, 
-	0x000d0310, 0x000d2310, 0x000d4310, 0x000d6310, 
-	0x000d8310, 0x000da310, 0x000dc310, 0x000de310, 
-	0x000e0310, 0x000e2310, 0x000e4310, 0x000e6310, 
-	0x000e8310, 0x000ea310, 0x000ec310, 0x000ee310, 
-	0x000f0310, 0x000f2310, 0x000f4310, 0x000f6310, 
-	0x000f8310, 0x000fa310, 0x000fc310, 0x000fe310, 
-	0x00100310, 0x00102310, 0x00104310, 0x00106310, 
-	0x00108310, 0x0010a310, 0x0010c310, 0x0010e310, 
-	0x00110310, 0x00112310, 0x00114310, 0x00116310, 
-	0x00118310, 0x0011a310, 0x0011c310, 0x0011e310, 
-	0x00120310, 0x00122310, 0x00124310, 0x00126310, 
-	0x00128310, 0x0012a310, 0x0012c310, 0x0012e310, 
-	0x00130310, 0x00132310, 0x00134310, 0x00136310, 
-	0x00138310, 0x0013a310, 0x0013c310, 0x0013e310, 
-	0x00140310, 0x00142310, 0x00144310, 0x00146310, 
-	0x00148310, 0x0014a310, 0x0014c310, 0x0014e310, 
-	0x00150310, 0x00152310, 0x00154310, 0x00156310, 
-	0x00158310, 0x0015a310, 0x0015c310, 0x0015e310, 
-	0x00160310, 0x00162310, 0x00164310, 0x00166310, 
-	0x00168310, 0x0016a310, 0x0016c310, 0x0016e310, 
-	0x00170310, 0x00172310, 0x00174310, 0x00176310, 
-	0x00178310, 0x0017a310, 0x0017c310, 0x0017e310, 
-	0x00180310, 0x00182310, 0x00184310, 0x00186310, 
-	0x00188310, 0x0018a310, 0x0018c310, 0x0018e310, 
-	0x00190310, 0x00192310, 0x00194310, 0x00196310, 
-	0x00198310, 0x0019a310, 0x0019c310, 0x0019e310, 
-	0x001a0310, 0x001a2310, 0x001a4310, 0x001a6310, 
-	0x001a8310, 0x001aa310, 0x001ac310, 0x001ae310, 
-	0x001b0310, 0x001b2310, 0x001b4310, 0x001b6310, 
-	0x001b8310, 0x001ba310, 0x001bc310, 0x001be310, 
-	0x001c0310, 0x001c2310, 0x001c4310, 0x001c6310, 
-	0x001c8310, 0x001ca310, 0x001cc310, 0x001ce310, 
-	0x001d0310, 0x001d2310, 0x001d4310, 0x001d6310, 
-	0x001d8310, 0x001da310, 0x001dc310, 0x001de310, 
-	0x001e0310, 0x001e2310, 0x001e4310, 0x001e6310, 
-	0x001e8310, 0x001ea310, 0x001ec310, 0x001ee310, 
-	0x001f0310, 0x001f2310, 0x001f4310, 0x001f6310, 
-	0x001f8310, 0x001fa310, 0x001fc310, 0x001fe310, 
-	0x00200310, 0x00202310, 0x00204310, 0x00206310, 
-	0x00208310, 0x0020a310, 0x0020c310, 0x0020e310, 
-	0x00210310, 0x00212310, 0x00214310, 0x00216310, 
-	0x00218310, 0x0021a310, 0x0021c310, 0x0021e310, 
-	0x00220310, 0x00222310, 0x00224310, 0x00226310, 
-	0x00228310, 0x0022a310, 0x0022c310, 0x0022e310, 
-	0x00230310, 0x00232310, 0x00234310, 0x00236310, 
-	0x00238310, 0x0023a310, 0x0023c310, 0x0023e310, 
-	0x00240310, 0x00242310, 0x00244310, 0x00246310, 
-	0x00248310, 0x0024a310, 0x0024c310, 0x0024e310, 
-	0x00250310, 0x00252310, 0x00254310, 0x00256310, 
-	0x00258310, 0x0025a310, 0x0025c310, 0x0025e310, 
-	0x00260310, 0x00262310, 0x00264310, 0x00266310, 
-	0x00268310, 0x0026a310, 0x0026c310, 0x0026e310, 
-	0x00270310, 0x00272310, 0x00274310, 0x00276310, 
-	0x00278310, 0x0027a310, 0x0027c310, 0x0027e310, 
-	0x00280310, 0x00282310, 0x00284310, 0x00286310, 
-	0x00288310, 0x0028a310, 0x0028c310, 0x0028e310, 
-	0x00290310, 0x00292310, 0x00294310, 0x00296310, 
-	0x00298310, 0x0029a310, 0x0029c310, 0x0029e310, 
-	0x002a0310, 0x002a2310, 0x002a4310, 0x002a6310, 
-	0x002a8310, 0x002aa310, 0x002ac310, 0x002ae310, 
-	0x002b0310, 0x002b2310, 0x002b4310, 0x002b6310, 
-	0x002b8310, 0x002ba310, 0x002bc310, 0x002be310, 
-	0x002c0310, 0x002c2310, 0x002c4310, 0x002c6310, 
-	0x002c8310, 0x002ca310, 0x002cc310, 0x002ce310, 
-	0x002d0310, 0x002d2310, 0x002d4310, 0x002d6310, 
-	0x002d8310, 0x002da310, 0x002dc310, 0x002de310, 
-	0x002e0310, 0x002e2310, 0x002e4310, 0x002e6310, 
-	0x002e8310, 0x002ea310, 0x002ec310, 0x002ee310, 
-	0x002f0310, 0x002f2310, 0x002f4310, 0x002f6310, 
-	0x002f8310, 0x002fa310, 0x002fc310, 0x002fe310, 
-	0x00300310, 0x00302310, 0x00304310, 0x00306310, 
-	0x00308310, 0x0030a310, 0x0030c310, 0x0030e310, 
-	0x00310310, 0x00312310, 0x00314310, 0x00316310, 
-	0x00318310, 0x0031a310, 0x0031c310, 0x0031e310, 
-	0x00320310, 0x00322310, 0x00324310, 0x00326310, 
-	0x00328310, 0x0032a310, 0x0032c310, 0x0032e310, 
-	0x00330310, 0x00332310, 0x00334310, 0x00336310, 
-	0x00338310, 0x0033a310, 0x0033c310, 0x0033e310, 
-	0x00340310, 0x00342310, 0x00344310, 0x00346310, 
-	0x00348310, 0x0034a310, 0x0034c310, 0x0034e310, 
-	0x00350310, 0x00352310, 0x00354310, 0x00356310, 
-	0x00358310, 0x0035a310, 0x0035c310, 0x0035e310, 
-	0x00360310, 0x00362310, 0x00364310, 0x00366310, 
-	0x00368310, 0x0036a310, 0x0036c310, 0x0036e310, 
-	0x00370310, 0x00372310, 0x00374310, 0x00376310, 
-	0x00378310, 0x0037a310, 0x0037c310, 0x0037e310, 
-	0x00380310, 0x00382310, 0x00384310, 0x00386310, 
-	0x00388310, 0x0038a310, 0x0038c310, 0x0038e310, 
-	0x00390310, 0x00392310, 0x00394310, 0x00396310, 
-	0x00398310, 0x0039a310, 0x0039c310, 0x0039e310, 
-	0x003a0310, 0x003a2310, 0x003a4310, 0x003a6310, 
-	0x003a8310, 0x003aa310, 0x003ac310, 0x003ae310, 
-	0x003b0310, 0x003b2310, 0x003b4310, 0x003b6310, 
-	0x003b8310, 0x003ba310, 0x003bc310, 0x003be310, 
-	0x003c0310, 0x003c2310, 0x003c4310, 0x003c6310, 
-	0x003c8310, 0x003ca310, 0x003cc310, 0x003ce310, 
-	0x003d0310, 0x003d2310, 0x003d4310, 0x003d6310, 
-	0x003d8310, 0x003da310, 0x003dc310, 0x003de310, 
-	0x003e0310, 0x003e2310, 0x003e4310, 0x003e6310, 
-	0x003e8310, 0x003ea310, 0x003ec310, 0x003ee310, 
-	0x003f0310, 0x003f2310, 0x003f4310, 0x003f6310, 
-	0x003f8310, 0x003fa310, 0x003fc310, 0x003fe310, 
-	0x00400310, 0x00402310, 0x00404310, 0x00406310, 
-	0x00408310, 0x0040a310, 0x0040c310, 0x0040e310, 
-	0x00410310, 0x00412310, 0x00414310, 0x00416310, 
-	0x00418310, 0x0041a310, 0x0041c310, 0x0041e310, 
-	0x00420310, 0x00422310, 0x00424310, 0x00426310, 
-	0x00428310, 0x0042a310, 0x0042c310, 0x0042e310, 
-	0x00430310, 0x00432310, 0x00434310, 0x00436310, 
-	0x00438310, 0x0043a310, 0x0043c310, 0x0043e310, 
-	0x00440310, 0x00442310, 0x00444310, 0x00446310, 
-	0x00448310, 0x0044a310, 0x0044c310, 0x0044e310, 
-	0x00450310, 0x00452310, 0x00454310, 0x00456310, 
-	0x00458310, 0x0045a310, 0x0045c310, 0x0045e310, 
-	0x00460310, 0x00462310, 0x00464310, 0x00466310, 
-	0x00468310, 0x0046a310, 0x0046c310, 0x0046e310, 
-	0x00470310, 0x00472310, 0x00474310, 0x00476310, 
-	0x00478310, 0x0047a310, 0x0047c310, 0x0047e310, 
-	0x00480310, 0x00482310, 0x00484310, 0x00486310, 
-	0x00488310, 0x0048a310, 0x0048c310, 0x0048e310, 
-	0x00490310, 0x00492310, 0x00494310, 0x00496310, 
-	0x00498310, 0x0049a310, 0x0049c310, 0x0049e310, 
-	0x004a0310, 0x004a2310, 0x004a4310, 0x004a6310, 
-	0x004a8310, 0x004aa310, 0x004ac310, 0x004ae310, 
-	0x004b0310, 0x004b2310, 0x004b4310, 0x004b6310, 
-	0x004b8310, 0x004ba310, 0x004bc310, 0x004be310, 
-	0x004c0310, 0x004c2310, 0x004c4310, 0x004c6310, 
-	0x004c8310, 0x004ca310, 0x004cc310, 0x004ce310, 
-	0x004d0310, 0x004d2310, 0x004d4310, 0x004d6310, 
-	0x004d8310, 0x004da310, 0x004dc310, 0x004de310, 
-	0x004e0310, 0x004e2310, 0x004e4310, 0x004e6310, 
-	0x004e8310, 0x004ea310, 0x004ec310, 0x004ee310, 
-	0x004f0310, 0x004f2310, 0x004f4310, 0x004f6310, 
-	0x004f8310, 0x004fa310, 0x004fc310, 0x004fe310, 
-	0x00500310, 0x00502310, 0x00504310, 0x00506310, 
-	0x00508310, 0x0050a310, 0x0050c310, 0x0050e310, 
-	0x00510310, 0x00512310, 0x00514310, 0x00516310, 
-	0x00518310, 0x0051a310, 0x0051c310, 0x0051e310, 
-	0x00520310, 0x00522310, 0x00524310, 0x00526310, 
-	0x00528310, 0x0052a310, 0x0052c310, 0x0052e310, 
-	0x00530310, 0x00532310, 0x00534310, 0x00536310, 
-	0x00538310, 0x0053a310, 0x0053c310, 0x0053e310, 
-	0x00540310, 0x00542310, 0x00544310, 0x00546310, 
-	0x00548310, 0x0054a310, 0x0054c310, 0x0054e310, 
-	0x00550310, 0x00552310, 0x00554310, 0x00556310, 
-	0x00558310, 0x0055a310, 0x0055c310, 0x0055e310, 
-	0x00560310, 0x00562310, 0x00564310, 0x00566310, 
-	0x00568310, 0x0056a310, 0x0056c310, 0x0056e310, 
-	0x00570310, 0x00572310, 0x00574310, 0x00576310, 
-	0x00578310, 0x0057a310, 0x0057c310, 0x0057e310, 
-	0x00580310, 0x00582310, 0x00584310, 0x00586310, 
-	0x00588310, 0x0058a310, 0x0058c310, 0x0058e310, 
-	0x00590310, 0x00592310, 0x00594310, 0x00596310, 
-	0x00598310, 0x0059a310, 0x0059c310, 0x0059e310, 
-	0x005a0310, 0x005a2310, 0x005a4310, 0x005a6310, 
-	0x005a8310, 0x005aa310, 0x005ac310, 0x005ae310, 
-	0x005b0310, 0x005b2310, 0x005b4310, 0x005b6310, 
-	0x005b8310, 0x005ba310, 0x005bc310, 0x005be310, 
-	0x005c0310, 0x005c2310, 0x005c4310, 0x005c6310, 
-	0x005c8310, 0x005ca310, 0x005cc310, 0x005ce310, 
-	0x005d0310, 0x005d2310, 0x005d4310, 0x005d6310, 
-	0x005d8310, 0x005da310, 0x005dc310, 0x005de310, 
-	0x005e0310, 0x005e2310, 0x005e4310, 0x005e6310, 
-	0x005e8310, 0x005ea310, 0x005ec310, 0x005ee310, 
-	0x005f0310, 0x005f2310, 0x005f4310, 0x005f6310, 
-	0x005f8310, 0x005fa310, 0x005fc310, 0x005fe310, 
-	0x00600310, 0x00602310, 0x00604310, 0x00606310, 
-	0x00608310, 0x0060a310, 0x0060c310, 0x0060e310, 
-	0x00610310, 0x00612310, 0x00614310, 0x00616310, 
-	0x00618310, 0x0061a310, 0x0061c310, 0x0061e310, 
-	0x00620310, 0x00622310, 0x00624310, 0x00626310, 
-	0x00628310, 0x0062a310, 0x0062c310, 0x0062e310, 
-	0x00630310, 0x00632310, 0x00634310, 0x00636310, 
-	0x00638310, 0x0063a310, 0x0063c310, 0x0063e310, 
-	0x00640310, 0x00642310, 0x00644310, 0x00646310, 
-	0x00648310, 0x0064a310, 0x0064c310, 0x0064e310, 
-	0x00650310, 0x00652310, 0x00654310, 0x00656310, 
-	0x00658310, 0x0065a310, 0x0065c310, 0x0065e310, 
-	0x00660310, 0x00662310, 0x00664310, 0x00666310, 
-	0x00668310, 0x0066a310, 0x0066c310, 0x0066e310, 
-	0x00670310, 0x00672310, 0x00674310, 0x00676310, 
-	0x00678310, 0x0067a310, 0x0067c310, 0x0067e310, 
-	0x00680310, 0x00682310, 0x00684310, 0x00686310, 
-	0x00688310, 0x0068a310, 0x0068c310, 0x0068e310, 
-	0x00690310, 0x00692310, 0x00694310, 0x00696310, 
-	0x00698310, 0x0069a310, 0x0069c310, 0x0069e310, 
-	0x006a0310, 0x006a2310, 0x006a4310, 0x006a6310, 
-	0x006a8310, 0x006aa310, 0x006ac310, 0x006ae310, 
-	0x006b0310, 0x006b2310, 0x006b4310, 0x006b6310, 
-	0x006b8310, 0x006ba310, 0x006bc310, 0x006be310, 
-	0x006c0310, 0x006c2310, 0x006c4310, 0x006c6310, 
-	0x006c8310, 0x006ca310, 0x006cc310, 0x006ce310, 
-	0x006d0310, 0x006d2310, 0x006d4310, 0x006d6310, 
-	0x006d8310, 0x006da310, 0x006dc310, 0x006de310, 
-	0x006e0310, 0x006e2310, 0x006e4310, 0x006e6310, 
-	0x006e8310, 0x006ea310, 0x006ec310, 0x006ee310, 
-	0x006f0310, 0x006f2310, 0x006f4310, 0x006f6310, 
-	0x006f8310, 0x006fa310, 0x006fc310, 0x006fe310, 
-	0x00700310, 0x00702310, 0x00704310, 0x00706310, 
-	0x00708310, 0x0070a310, 0x0070c310, 0x0070e310, 
-	0x00710310, 0x00712310, 0x00714310, 0x00716310, 
-	0x00718310, 0x0071a310, 0x0071c310, 0x0071e310, 
-	0x00720310, 0x00722310, 0x00724310, 0x00726310, 
-	0x00728310, 0x0072a310, 0x0072c310, 0x0072e310, 
-	0x00730310, 0x00732310, 0x00734310, 0x00736310, 
-	0x00738310, 0x0073a310, 0x0073c310, 0x0073e310, 
-	0x00740310, 0x00742310, 0x00744310, 0x00746310, 
-	0x00748310, 0x0074a310, 0x0074c310, 0x0074e310, 
-	0x00750310, 0x00752310, 0x00754310, 0x00756310, 
-	0x00758310, 0x0075a310, 0x0075c310, 0x0075e310, 
-	0x00760310, 0x00762310, 0x00764310, 0x00766310, 
-	0x00768310, 0x0076a310, 0x0076c310, 0x0076e310, 
-	0x00770310, 0x00772310, 0x00774310, 0x00776310, 
-	0x00778310, 0x0077a310, 0x0077c310, 0x0077e310, 
-	0x00780310, 0x00782310, 0x00784310, 0x00786310, 
-	0x00788310, 0x0078a310, 0x0078c310, 0x0078e310, 
-	0x00790310, 0x00792310, 0x00794310, 0x00796310, 
-	0x00798310, 0x0079a310, 0x0079c310, 0x0079e310, 
-	0x007a0310, 0x007a2310, 0x007a4310, 0x007a6310, 
-	0x007a8310, 0x007aa310, 0x007ac310, 0x007ae310, 
-	0x007b0310, 0x007b2310, 0x007b4310, 0x007b6310, 
-	0x007b8310, 0x007ba310, 0x007bc310, 0x007be310, 
-	0x007c0310, 0x007c2310, 0x007c4310, 0x007c6310, 
-	0x007c8310, 0x007ca310, 0x007cc310, 0x007ce310, 
-	0x007d0310, 0x007d2310, 0x007d4310, 0x007d6310, 
-	0x007d8310, 0x007da310, 0x007dc310, 0x007de310, 
-	0x007e0310, 0x007e2310, 0x007e4310, 0x007e6310, 
-	0x007e8310, 0x007ea310, 0x007ec310, 0x007ee310, 
-	0x007f0310, 0x007f2310, 0x007f4310, 0x007f6310, 
-	0x007f8310, 0x007fa310, 0x007fc310, 0x007fe310, 
-	0x00800310, 0x00802310, 0x00804310, 0x00806310, 
-	0x00808310, 0x0080a310, 0x0080c310, 0x0080e310, 
-	0x00810310, 0x00812310, 0x00814310, 0x00816310, 
-	0x00818310, 0x0081a310, 0x0081c310, 0x0081e310, 
-	0x00820310, 0x00822310, 0x00824310, 0x00826310, 
-	0x00828310, 0x0082a310, 0x0082c310, 0x0082e310, 
-	0x00830310, 0x00832310, 0x00834310, 0x00836310, 
-	0x00838310, 0x0083a310, 0x0083c310, 0x0083e310, 
-	0x00840310, 0x00842310, 0x00844310, 0x00846310, 
-	0x00848310, 0x0084a310, 0x0084c310, 0x0084e310, 
-	0x00850310, 0x00852310, 0x00854310, 0x00856310, 
-	0x00858310, 0x0085a310, 0x0085c310, 0x0085e310, 
-	0x00860310, 0x00862310, 0x00864310, 0x00866310, 
-	0x00868310, 0x0086a310, 0x0086c310, 0x0086e310, 
-	0x00870310, 0x00872310, 0x00874310, 0x00876310, 
-	0x00878310, 0x0087a310, 0x0087c310, 0x0087e310, 
-	0x00880310, 0x00882310, 0x00884310, 0x00886310, 
-	0x00888310, 0x0088a310, 0x0088c310, 0x0088e310, 
-	0x00890310, 0x00892310, 0x00894310, 0x00896310, 
-	0x00898310, 0x0089a310, 0x0089c310, 0x0089e310, 
-	0x008a0310, 0x008a2310, 0x008a4310, 0x008a6310, 
-	0x008a8310, 0x008aa310, 0x008ac310, 0x008ae310, 
-	0x008b0310, 0x008b2310, 0x008b4310, 0x008b6310, 
-	0x008b8310, 0x008ba310, 0x008bc310, 0x008be310, 
-	0x008c0310, 0x008c2310, 0x008c4310, 0x008c6310, 
-	0x008c8310, 0x008ca310, 0x008cc310, 0x008ce310, 
-	0x008d0310, 0x008d2310, 0x008d4310, 0x008d6310, 
-	0x008d8310, 0x008da310, 0x008dc310, 0x008de310, 
-	0x008e0310, 0x008e2310, 0x008e4310, 0x008e6310, 
-	0x008e8310, 0x008ea310, 0x008ec310, 0x008ee310, 
-	0x008f0310, 0x008f2310, 0x008f4310, 0x008f6310, 
-	0x008f8310, 0x008fa310, 0x008fc310, 0x008fe310, 
-	0x00900310, 0x00902310, 0x00904310, 0x00906310, 
-	0x00908310, 0x0090a310, 0x0090c310, 0x0090e310, 
-	0x00910310, 0x00912310, 0x00914310, 0x00916310, 
-	0x00918310, 0x0091a310, 0x0091c310, 0x0091e310, 
-	0x00920310, 0x00922310, 0x00924310, 0x00926310, 
-	0x00928310, 0x0092a310, 0x0092c310, 0x0092e310, 
-	0x00930310, 0x00932310, 0x00934310, 0x00936310, 
-	0x00938310, 0x0093a310, 0x0093c310, 0x0093e310, 
-	0x00940310, 0x00942310, 0x00944310, 0x00946310, 
-	0x00948310, 0x0094a310, 0x0094c310, 0x0094e310, 
-	0x00950310, 0x00952310, 0x00954310, 0x00956310, 
-	0x00958310, 0x0095a310, 0x0095c310, 0x0095e310, 
-	0x00960310, 0x00962310, 0x00964310, 0x00966310, 
-	0x00968310, 0x0096a310, 0x0096c310, 0x0096e310, 
-	0x00970310, 0x00972310, 0x00974310, 0x00976310, 
-	0x00978310, 0x0097a310, 0x0097c310, 0x0097e310, 
-	0x00980310, 0x00982310, 0x00984310, 0x00986310, 
-	0x00988310, 0x0098a310, 0x0098c310, 0x0098e310, 
-	0x00990310, 0x00992310, 0x00994310, 0x00996310, 
-	0x00998310, 0x0099a310, 0x0099c310, 0x0099e310, 
-	0x009a0310, 0x009a2310, 0x009a4310, 0x009a6310, 
-	0x009a8310, 0x009aa310, 0x009ac310, 0x009ae310, 
-	0x009b0310, 0x009b2310, 0x009b4310, 0x009b6310, 
-	0x009b8310, 0x009ba310, 0x009bc310, 0x009be310, 
-	0x009c0310, 0x009c2310, 0x009c4310, 0x009c6310, 
-	0x009c8310, 0x009ca310, 0x009cc310, 0x009ce310, 
-	0x009d0310, 0x009d2310, 0x009d4310, 0x009d6310, 
-	0x009d8310, 0x009da310, 0x009dc310, 0x009de310, 
-	0x009e0310, 0x009e2310, 0x009e4310, 0x009e6310, 
-	0x009e8310, 0x009ea310, 0x009ec310, 0x009ee310, 
-	0x009f0310, 0x009f2310, 0x009f4310, 0x009f6310, 
-	0x009f8310, 0x009fa310, 0x009fc310, 0x009fe310, 
-	0x00a00310, 0x00a02310, 0x00a04310, 0x00a06310, 
-	0x00a08310, 0x00a0a310, 0x00a0c310, 0x00a0e310, 
-	0x00a10310, 0x00a12310, 0x00a14310, 0x00a16310, 
-	0x00a18310, 0x00a1a310, 0x00a1c310, 0x00a1e310, 
-	0x00a20310, 0x00a22310, 0x00a24310, 0x00a26310, 
-	0x00a28310, 0x00a2a310, 0x00a2c310, 0x00a2e310, 
-	0x00a30310, 0x00a32310, 0x00a34310, 0x00a36310, 
-	0x00a38310, 0x00a3a310, 0x00a3c310, 0x00a3e310, 
-	0x00a40310, 0x00a42310, 0x00a44310, 0x00a46310, 
-	0x00a48310, 0x00a4a310, 0x00a4c310, 0x00a4e310, 
-	0x00a50310, 0x00a52310, 0x00a54310, 0x00a56310, 
-	0x00a58310, 0x00a5a310, 0x00a5c310, 0x00a5e310, 
-	0x00a60310, 0x00a62310, 0x00a64310, 0x00a66310, 
-	0x00a68310, 0x00a6a310, 0x00a6c310, 0x00a6e310, 
-	0x00a70310, 0x00a72310, 0x00a74310, 0x00a76310, 
-	0x00a78310, 0x00a7a310, 0x00a7c310, 0x00a7e310, 
-	0x00a80310, 0x00a82310, 0x00a84310, 0x00a86310, 
-	0x00a88310, 0x00a8a310, 0x00a8c310, 0x00a8e310, 
-	0x00a90310, 0x00a92310, 0x00a94310, 0x00a96310, 
-	0x00a98310, 0x00a9a310, 0x00a9c310, 0x00a9e310, 
-	0x00aa0310, 0x00aa2310, 0x00aa4310, 0x00aa6310, 
-	0x00aa8310, 0x00aaa310, 0x00aac310, 0x00aae310, 
-	0x00ab0310, 0x00ab2310, 0x00ab4310, 0x00ab6310, 
-	0x00ab8310, 0x00aba310, 0x00abc310, 0x00abe310, 
-	0x00ac0310, 0x00ac2310, 0x00ac4310, 0x00ac6310, 
-	0x00ac8310, 0x00aca310, 0x00acc310, 0x00ace310, 
-	0x00ad0310, 0x00ad2310, 0x00ad4310, 0x00ad6310, 
-	0x00ad8310, 0x00ada310, 0x00adc310, 0x00ade310, 
-	0x00ae0310, 0x00ae2310, 0x00ae4310, 0x00ae6310, 
-	0x00ae8310, 0x00aea310, 0x00aec310, 0x00aee310, 
-	0x00af0310, 0x00af2310, 0x00af4310, 0x00af6310, 
-	0x00af8310, 0x00afa310, 0x00afc310, 0x00afe310, 
-	0x00b00310, 0x00b02310, 0x00b04310, 0x00b06310, 
-	0x00b08310, 0x00b0a310, 0x00b0c310, 0x00b0e310, 
-	0x00b10310, 0x00b12310, 0x00b14310, 0x00b16310, 
-	0x00b18310, 0x00b1a310, 0x00b1c310, 0x00b1e310, 
-	0x00b20310, 0x00b22310, 0x00b24310, 0x00b26310, 
-	0x00b28310, 0x00b2a310, 0x00b2c310, 0x00b2e310, 
-	0x00b30310, 0x00b32310, 0x00b34310, 0x00b36310, 
-	0x00b38310, 0x00b3a310, 0x00b3c310, 0x00b3e310, 
-	0x00b40310, 0x00b42310, 0x00b44310, 0x00b46310, 
-	0x00b48310, 0x00b4a310, 0x00b4c310, 0x00b4e310, 
-	0x00b50310, 0x00b52310, 0x00b54310, 0x00b56310, 
-	0x00b58310, 0x00b5a310, 0x00b5c310, 0x00b5e310, 
-	0x00b60310, 0x00b62310, 0x00b64310, 0x00b66310, 
-	0x00b68310, 0x00b6a310, 0x00b6c310, 0x00b6e310, 
-	0x00b70310, 0x00b72310, 0x00b74310, 0x00b76310, 
-	0x00b78310, 0x00b7a310, 0x00b7c310, 0x00b7e310, 
-	0x00b80310, 0x00b82310, 0x00b84310, 0x00b86310, 
-	0x00b88310, 0x00b8a310, 0x00b8c310, 0x00b8e310, 
-	0x00b90310, 0x00b92310, 0x00b94310, 0x00b96310, 
-	0x00b98310, 0x00b9a310, 0x00b9c310, 0x00b9e310, 
-	0x00ba0310, 0x00ba2310, 0x00ba4310, 0x00ba6310, 
-	0x00ba8310, 0x00baa310, 0x00bac310, 0x00bae310, 
-	0x00bb0310, 0x00bb2310, 0x00bb4310, 0x00bb6310, 
-	0x00bb8310, 0x00bba310, 0x00bbc310, 0x00bbe310, 
-	0x00bc0310, 0x00bc2310, 0x00bc4310, 0x00bc6310, 
-	0x00bc8310, 0x00bca310, 0x00bcc310, 0x00bce310, 
-	0x00bd0310, 0x00bd2310, 0x00bd4310, 0x00bd6310, 
-	0x00bd8310, 0x00bda310, 0x00bdc310, 0x00bde310, 
-	0x00be0310, 0x00be2310, 0x00be4310, 0x00be6310, 
-	0x00be8310, 0x00bea310, 0x00bec310, 0x00bee310, 
-	0x00bf0310, 0x00bf2310, 0x00bf4310, 0x00bf6310, 
-	0x00bf8310, 0x00bfa310, 0x00bfc310, 0x00bfe310, 
-	0x00c00310, 0x00c02310, 0x00c04310, 0x00c06310, 
-	0x00c08310, 0x00c0a310, 0x00c0c310, 0x00c0e310, 
-	0x00c10310, 0x00c12310, 0x00c14310, 0x00c16310, 
-	0x00c18310, 0x00c1a310, 0x00c1c310, 0x00c1e310, 
-	0x00c20310, 0x00c22310, 0x00c24310, 0x00c26310, 
-	0x00c28310, 0x00c2a310, 0x00c2c310, 0x00c2e310, 
-	0x00c30310, 0x00c32310, 0x00c34310, 0x00c36310, 
-	0x00c38310, 0x00c3a310, 0x00c3c310, 0x00c3e310, 
-	0x00c40310, 0x00c42310, 0x00c44310, 0x00c46310, 
-	0x00c48310, 0x00c4a310, 0x00c4c310, 0x00c4e310, 
-	0x00c50310, 0x00c52310, 0x00c54310, 0x00c56310, 
-	0x00c58310, 0x00c5a310, 0x00c5c310, 0x00c5e310, 
-	0x00c60310, 0x00c62310, 0x00c64310, 0x00c66310, 
-	0x00c68310, 0x00c6a310, 0x00c6c310, 0x00c6e310, 
-	0x00c70310, 0x00c72310, 0x00c74310, 0x00c76310, 
-	0x00c78310, 0x00c7a310, 0x00c7c310, 0x00c7e310, 
-	0x00c80310, 0x00c82310, 0x00c84310, 0x00c86310, 
-	0x00c88310, 0x00c8a310, 0x00c8c310, 0x00c8e310, 
-	0x00c90310, 0x00c92310, 0x00c94310, 0x00c96310, 
-	0x00c98310, 0x00c9a310, 0x00c9c310, 0x00c9e310, 
-	0x00ca0310, 0x00ca2310, 0x00ca4310, 0x00ca6310, 
-	0x00ca8310, 0x00caa310, 0x00cac310, 0x00cae310, 
-	0x00cb0310, 0x00cb2310, 0x00cb4310, 0x00cb6310, 
-	0x00cb8310, 0x00cba310, 0x00cbc310, 0x00cbe310, 
-	0x00cc0310, 0x00cc2310, 0x00cc4310, 0x00cc6310, 
-	0x00cc8310, 0x00cca310, 0x00ccc310, 0x00cce310, 
-	0x00cd0310, 0x00cd2310, 0x00cd4310, 0x00cd6310, 
-	0x00cd8310, 0x00cda310, 0x00cdc310, 0x00cde310, 
-	0x00ce0310, 0x00ce2310, 0x00ce4310, 0x00ce6310, 
-	0x00ce8310, 0x00cea310, 0x00cec310, 0x00cee310, 
-	0x00cf0310, 0x00cf2310, 0x00cf4310, 0x00cf6310, 
-	0x00cf8310, 0x00cfa310, 0x00cfc310, 0x00cfe310, 
-	0x00d00310, 0x00d02310, 0x00d04310, 0x00d06310, 
-	0x00d08310, 0x00d0a310, 0x00d0c310, 0x00d0e310, 
-	0x00d10310, 0x00d12310, 0x00d14310, 0x00d16310, 
-	0x00d18310, 0x00d1a310, 0x00d1c310, 0x00d1e310, 
-	0x00d20310, 0x00d22310, 0x00d24310, 0x00d26310, 
-	0x00d28310, 0x00d2a310, 0x00d2c310, 0x00d2e310, 
-	0x00d30310, 0x00d32310, 0x00d34310, 0x00d36310, 
-	0x00d38310, 0x00d3a310, 0x00d3c310, 0x00d3e310, 
-	0x00d40310, 0x00d42310, 0x00d44310, 0x00d46310, 
-	0x00d48310, 0x00d4a310, 0x00d4c310, 0x00d4e310, 
-	0x00d50310, 0x00d52310, 0x00d54310, 0x00d56310, 
-	0x00d58310, 0x00d5a310, 0x00d5c310, 0x00d5e310, 
-	0x00d60310, 0x00d62310, 0x00d64310, 0x00d66310, 
-	0x00d68310, 0x00d6a310, 0x00d6c310, 0x00d6e310, 
-	0x00d70310, 0x00d72310, 0x00d74310, 0x00d76310, 
-	0x00d78310, 0x00d7a310, 0x00d7c310, 0x00d7e310, 
-	0x00d80310, 0x00d82310, 0x00d84310, 0x00d86310, 
-	0x00d88310, 0x00d8a310, 0x00d8c310, 0x00d8e310, 
-	0x00d90310, 0x00d92310, 0x00d94310, 0x00d96310, 
-	0x00d98310, 0x00d9a310, 0x00d9c310, 0x00d9e310, 
-	0x00da0310, 0x00da2310, 0x00da4310, 0x00da6310, 
-	0x00da8310, 0x00daa310, 0x00dac310, 0x00dae310, 
-	0x00db0310, 0x00db2310, 0x00db4310, 0x00db6310, 
-	0x00db8310, 0x00dba310, 0x00dbc310, 0x00dbe310, 
-	0x00dc0310, 0x00dc2310, 0x00dc4310, 0x00dc6310, 
-	0x00dc8310, 0x00dca310, 0x00dcc310, 0x00dce310, 
-	0x00dd0310, 0x00dd2310, 0x00dd4310, 0x00dd6310, 
-	0x00dd8310, 0x00dda310, 0x00ddc310, 0x00dde310, 
-	0x00de0310, 0x00de2310, 0x00de4310, 0x00de6310, 
-	0x00de8310, 0x00dea310, 0x00dec310, 0x00dee310, 
-	0x00df0310, 0x00df2310, 0x00df4310, 0x00df6310, 
-	0x00df8310, 0x00dfa310, 0x00dfc310, 0x00dfe310, 
-	0x00e00310, 0x00e02310, 0x00e04310, 0x00e06310, 
-	0x00e08310, 0x00e0a310, 0x00e0c310, 0x00e0e310, 
-	0x00e10310, 0x00e12310, 0x00e14310, 0x00e16310, 
-	0x00e18310, 0x00e1a310, 0x00e1c310, 0x00e1e310, 
-	0x00e20310, 0x00e22310, 0x00e24310, 0x00e26310, 
-	0x00e28310, 0x00e2a310, 0x00e2c310, 0x00e2e310, 
-	0x00e30310, 0x00e32310, 0x00e34310, 0x00e36310, 
-	0x00e38310, 0x00e3a310, 0x00e3c310, 0x00e3e310, 
-	0x00e40310, 0x00e42310, 0x00e44310, 0x00e46310, 
-	0x00e48310, 0x00e4a310, 0x00e4c310, 0x00e4e310, 
-	0x00e50310, 0x00e52310, 0x00e54310, 0x00e56310, 
-	0x00e58310, 0x00e5a310, 0x00e5c310, 0x00e5e310, 
-	0x00e60310, 0x00e62310, 0x00e64310, 0x00e66310, 
-	0x00e68310, 0x00e6a310, 0x00e6c310, 0x00e6e310, 
-	0x00e70310, 0x00e72310, 0x00e74310, 0x00e76310, 
-	0x00e78310, 0x00e7a310, 0x00e7c310, 0x00e7e310, 
-	0x00e80310, 0x00e82310, 0x00e84310, 0x00e86310, 
-	0x00e88310, 0x00e8a310, 0x00e8c310, 0x00e8e310, 
-	0x00e90310, 0x00e92310, 0x00e94310, 0x00e96310, 
-	0x00e98310, 0x00e9a310, 0x00e9c310, 0x00e9e310, 
-	0x00ea0310, 0x00ea2310, 0x00ea4310, 0x00ea6310, 
-	0x00ea8310, 0x00eaa310, 0x00eac310, 0x00eae310, 
-	0x00eb0310, 0x00eb2310, 0x00eb4310, 0x00eb6310, 
-	0x00eb8310, 0x00eba310, 0x00ebc310, 0x00ebe310, 
-	0x00ec0310, 0x00ec2310, 0x00ec4310, 0x00ec6310, 
-	0x00ec8310, 0x00eca310, 0x00ecc310, 0x00ece310, 
-	0x00ed0310, 0x00ed2310, 0x00ed4310, 0x00ed6310, 
-	0x00ed8310, 0x00eda310, 0x00edc310, 0x00ede310, 
-	0x00ee0310, 0x00ee2310, 0x00ee4310, 0x00ee6310, 
-	0x00ee8310, 0x00eea310, 0x00eec310, 0x00eee310, 
-	0x00ef0310, 0x00ef2310, 0x00ef4310, 0x00ef6310, 
-	0x00ef8310, 0x00efa310, 0x00efc310, 0x00efe310, 
-	0x00f00310, 0x00f02310, 0x00f04310, 0x00f06310, 
-	0x00f08310, 0x00f0a310, 0x00f0c310, 0x00f0e310, 
-	0x00f10310, 0x00f12310, 0x00f14310, 0x00f16310, 
-	0x00f18310, 0x00f1a310, 0x00f1c310, 0x00f1e310, 
-	0x00f20310, 0x00f22310, 0x00f24310, 0x00f26310, 
-	0x00f28310, 0x00f2a310, 0x00f2c310, 0x00f2e310, 
-	0x00f30310, 0x00f32310, 0x00f34310, 0x00f36310, 
-	0x00f38310, 0x00f3a310, 0x00f3c310, 0x00f3e310, 
-	0x00f40310, 0x00f42310, 0x00f44310, 0x00f46310, 
-	0x00f48310, 0x00f4a310, 0x00f4c310, 0x00f4e310, 
-	0x00f50310, 0x00f52310, 0x00f54310, 0x00f56310, 
-	0x00f58310, 0x00f5a310, 0x00f5c310, 0x00f5e310, 
-	0x00f60310, 0x00f62310, 0x00f64310, 0x00f66310, 
-	0x00f68310, 0x00f6a310, 0x00f6c310, 0x00f6e310, 
-	0x00f70310, 0x00f72310, 0x00f74310, 0x00f76310, 
-	0x00f78310, 0x00f7a310, 0x00f7c310, 0x00f7e310, 
-	0x00f80310, 0x00f82310, 0x00f84310, 0x00f86310, 
-	0x00f88310, 0x00f8a310, 0x00f8c310, 0x00f8e310, 
-	0x00f90310, 0x00f92310, 0x00f94310, 0x00f96310, 
-	0x00f98310, 0x00f9a310, 0x00f9c310, 0x00f9e310, 
-	0x00fa0310, 0x00fa2310, 0x00fa4310, 0x00fa6310, 
-	0x00fa8310, 0x00faa310, 0x00fac310, 0x00fae310, 
-	0x00fb0310, 0x00fb2310, 0x00fb4310, 0x00fb6310, 
-	0x00fb8310, 0x00fba310, 0x00fbc310, 0x00fbe310, 
-	0x00fc0310, 0x00fc2310, 0x00fc4310, 0x00fc6310, 
-	0x00fc8310, 0x00fca310, 0x00fcc310, 0x00fce310, 
-	0x00fd0310, 0x00fd2310, 0x00fd4310, 0x00fd6310, 
-	0x00fd8310, 0x00fda310, 0x00fdc310, 0x00fde310, 
-	0x00fe0310, 0x00fe2310, 0x00fe4310, 0x00fe6310, 
-	0x00fe8310, 0x00fea310, 0x00fec310, 0x00fee310, 
-	0x00ff0310, 0x00ff2310, 0x00ff4310, 0x00ff6310, 
-	0x00ff8310, 0x00ffa310, 0x00ffc310, 0x00ffe310, 
-	0x00001310, 0x00003310, 0x00005310, 0x00007310, 
-	0x00009310, 0x0000b310, 0x0000d310, 0x0000f310, 
-	0x00011310, 0x00013310, 0x00015310, 0x00017310, 
-	0x00019310, 0x0001b310, 0x0001d310, 0x0001f310, 
-	0x00021310, 0x00023310, 0x00025310, 0x00027310, 
-	0x00029310, 0x0002b310, 0x0002d310, 0x0002f310, 
-	0x00031310, 0x00033310, 0x00035310, 0x00037310, 
-	0x00039310, 0x0003b310, 0x0003d310, 0x0003f310, 
-	0x00041310, 0x00043310, 0x00045310, 0x00047310, 
-	0x00049310, 0x0004b310, 0x0004d310, 0x0004f310, 
-	0x00051310, 0x00053310, 0x00055310, 0x00057310, 
-	0x00059310, 0x0005b310, 0x0005d310, 0x0005f310, 
-	0x00061310, 0x00063310, 0x00065310, 0x00067310, 
-	0x00069310, 0x0006b310, 0x0006d310, 0x0006f310, 
-	0x00071310, 0x00073310, 0x00075310, 0x00077310, 
-	0x00079310, 0x0007b310, 0x0007d310, 0x0007f310, 
-	0x00081310, 0x00083310, 0x00085310, 0x00087310, 
-	0x00089310, 0x0008b310, 0x0008d310, 0x0008f310, 
-	0x00091310, 0x00093310, 0x00095310, 0x00097310, 
-	0x00099310, 0x0009b310, 0x0009d310, 0x0009f310, 
-	0x000a1310, 0x000a3310, 0x000a5310, 0x000a7310, 
-	0x000a9310, 0x000ab310, 0x000ad310, 0x000af310, 
-	0x000b1310, 0x000b3310, 0x000b5310, 0x000b7310, 
-	0x000b9310, 0x000bb310, 0x000bd310, 0x000bf310, 
-	0x000c1310, 0x000c3310, 0x000c5310, 0x000c7310, 
-	0x000c9310, 0x000cb310, 0x000cd310, 0x000cf310, 
-	0x000d1310, 0x000d3310, 0x000d5310, 0x000d7310, 
-	0x000d9310, 0x000db310, 0x000dd310, 0x000df310, 
-	0x000e1310, 0x000e3310, 0x000e5310, 0x000e7310, 
-	0x000e9310, 0x000eb310, 0x000ed310, 0x000ef310, 
-	0x000f1310, 0x000f3310, 0x000f5310, 0x000f7310, 
-	0x000f9310, 0x000fb310, 0x000fd310, 0x000ff310, 
-	0x00101310, 0x00103310, 0x00105310, 0x00107310, 
-	0x00109310, 0x0010b310, 0x0010d310, 0x0010f310, 
-	0x00111310, 0x00113310, 0x00115310, 0x00117310, 
-	0x00119310, 0x0011b310, 0x0011d310, 0x0011f310, 
-	0x00121310, 0x00123310, 0x00125310, 0x00127310, 
-	0x00129310, 0x0012b310, 0x0012d310, 0x0012f310, 
-	0x00131310, 0x00133310, 0x00135310, 0x00137310, 
-	0x00139310, 0x0013b310, 0x0013d310, 0x0013f310, 
-	0x00141310, 0x00143310, 0x00145310, 0x00147310, 
-	0x00149310, 0x0014b310, 0x0014d310, 0x0014f310, 
-	0x00151310, 0x00153310, 0x00155310, 0x00157310, 
-	0x00159310, 0x0015b310, 0x0015d310, 0x0015f310, 
-	0x00161310, 0x00163310, 0x00165310, 0x00167310, 
-	0x00169310, 0x0016b310, 0x0016d310, 0x0016f310, 
-	0x00171310, 0x00173310, 0x00175310, 0x00177310, 
-	0x00179310, 0x0017b310, 0x0017d310, 0x0017f310, 
-	0x00181310, 0x00183310, 0x00185310, 0x00187310, 
-	0x00189310, 0x0018b310, 0x0018d310, 0x0018f310, 
-	0x00191310, 0x00193310, 0x00195310, 0x00197310, 
-	0x00199310, 0x0019b310, 0x0019d310, 0x0019f310, 
-	0x001a1310, 0x001a3310, 0x001a5310, 0x001a7310, 
-	0x001a9310, 0x001ab310, 0x001ad310, 0x001af310, 
-	0x001b1310, 0x001b3310, 0x001b5310, 0x001b7310, 
-	0x001b9310, 0x001bb310, 0x001bd310, 0x001bf310, 
-	0x001c1310, 0x001c3310, 0x001c5310, 0x001c7310, 
-	0x001c9310, 0x001cb310, 0x001cd310, 0x001cf310, 
-	0x001d1310, 0x001d3310, 0x001d5310, 0x001d7310, 
-	0x001d9310, 0x001db310, 0x001dd310, 0x001df310, 
-	0x001e1310, 0x001e3310, 0x001e5310, 0x001e7310, 
-	0x001e9310, 0x001eb310, 0x001ed310, 0x001ef310, 
-	0x001f1310, 0x001f3310, 0x001f5310, 0x001f7310, 
-	0x001f9310, 0x001fb310, 0x001fd310, 0x001ff310, 
-	0x00201310, 0x00203310, 0x00205310, 0x00207310, 
-	0x00209310, 0x0020b310, 0x0020d310, 0x0020f310, 
-	0x00211310, 0x00213310, 0x00215310, 0x00217310, 
-	0x00219310, 0x0021b310, 0x0021d310, 0x0021f310, 
-	0x00221310, 0x00223310, 0x00225310, 0x00227310, 
-	0x00229310, 0x0022b310, 0x0022d310, 0x0022f310, 
-	0x00231310, 0x00233310, 0x00235310, 0x00237310, 
-	0x00239310, 0x0023b310, 0x0023d310, 0x0023f310, 
-	0x00241310, 0x00243310, 0x00245310, 0x00247310, 
-	0x00249310, 0x0024b310, 0x0024d310, 0x0024f310, 
-	0x00251310, 0x00253310, 0x00255310, 0x00257310, 
-	0x00259310, 0x0025b310, 0x0025d310, 0x0025f310, 
-	0x00261310, 0x00263310, 0x00265310, 0x00267310, 
-	0x00269310, 0x0026b310, 0x0026d310, 0x0026f310, 
-	0x00271310, 0x00273310, 0x00275310, 0x00277310, 
-	0x00279310, 0x0027b310, 0x0027d310, 0x0027f310, 
-	0x00281310, 0x00283310, 0x00285310, 0x00287310, 
-	0x00289310, 0x0028b310, 0x0028d310, 0x0028f310, 
-	0x00291310, 0x00293310, 0x00295310, 0x00297310, 
-	0x00299310, 0x0029b310, 0x0029d310, 0x0029f310, 
-	0x002a1310, 0x002a3310, 0x002a5310, 0x002a7310, 
-	0x002a9310, 0x002ab310, 0x002ad310, 0x002af310, 
-	0x002b1310, 0x002b3310, 0x002b5310, 0x002b7310, 
-	0x002b9310, 0x002bb310, 0x002bd310, 0x002bf310, 
-	0x002c1310, 0x002c3310, 0x002c5310, 0x002c7310, 
-	0x002c9310, 0x002cb310, 0x002cd310, 0x002cf310, 
-	0x002d1310, 0x002d3310, 0x002d5310, 0x002d7310, 
-	0x002d9310, 0x002db310, 0x002dd310, 0x002df310, 
-	0x002e1310, 0x002e3310, 0x002e5310, 0x002e7310, 
-	0x002e9310, 0x002eb310, 0x002ed310, 0x002ef310, 
-	0x002f1310, 0x002f3310, 0x002f5310, 0x002f7310, 
-	0x002f9310, 0x002fb310, 0x002fd310, 0x002ff310, 
-	0x00301310, 0x00303310, 0x00305310, 0x00307310, 
-	0x00309310, 0x0030b310, 0x0030d310, 0x0030f310, 
-	0x00311310, 0x00313310, 0x00315310, 0x00317310, 
-	0x00319310, 0x0031b310, 0x0031d310, 0x0031f310, 
-	0x00321310, 0x00323310, 0x00325310, 0x00327310, 
-	0x00329310, 0x0032b310, 0x0032d310, 0x0032f310, 
-	0x00331310, 0x00333310, 0x00335310, 0x00337310, 
-	0x00339310, 0x0033b310, 0x0033d310, 0x0033f310, 
-	0x00341310, 0x00343310, 0x00345310, 0x00347310, 
-	0x00349310, 0x0034b310, 0x0034d310, 0x0034f310, 
-	0x00351310, 0x00353310, 0x00355310, 0x00357310, 
-	0x00359310, 0x0035b310, 0x0035d310, 0x0035f310, 
-	0x00361310, 0x00363310, 0x00365310, 0x00367310, 
-	0x00369310, 0x0036b310, 0x0036d310, 0x0036f310, 
-	0x00371310, 0x00373310, 0x00375310, 0x00377310, 
-	0x00379310, 0x0037b310, 0x0037d310, 0x0037f310, 
-	0x00381310, 0x00383310, 0x00385310, 0x00387310, 
-	0x00389310, 0x0038b310, 0x0038d310, 0x0038f310, 
-	0x00391310, 0x00393310, 0x00395310, 0x00397310, 
-	0x00399310, 0x0039b310, 0x0039d310, 0x0039f310, 
-	0x003a1310, 0x003a3310, 0x003a5310, 0x003a7310, 
-	0x003a9310, 0x003ab310, 0x003ad310, 0x003af310, 
-	0x003b1310, 0x003b3310, 0x003b5310, 0x003b7310, 
-	0x003b9310, 0x003bb310, 0x003bd310, 0x003bf310, 
-	0x003c1310, 0x003c3310, 0x003c5310, 0x003c7310, 
-	0x003c9310, 0x003cb310, 0x003cd310, 0x003cf310, 
-	0x003d1310, 0x003d3310, 0x003d5310, 0x003d7310, 
-	0x003d9310, 0x003db310, 0x003dd310, 0x003df310, 
-	0x003e1310, 0x003e3310, 0x003e5310, 0x003e7310, 
-	0x003e9310, 0x003eb310, 0x003ed310, 0x003ef310, 
-	0x003f1310, 0x003f3310, 0x003f5310, 0x003f7310, 
-	0x003f9310, 0x003fb310, 0x003fd310, 0x003ff310, 
-	0x00401310, 0x00403310, 0x00405310, 0x00407310, 
-	0x00409310, 0x0040b310, 0x0040d310, 0x0040f310, 
-	0x00411310, 0x00413310, 0x00415310, 0x00417310, 
-	0x00419310, 0x0041b310, 0x0041d310, 0x0041f310, 
-	0x00421310, 0x00423310, 0x00425310, 0x00427310, 
-	0x00429310, 0x0042b310, 0x0042d310, 0x0042f310, 
-	0x00431310, 0x00433310, 0x00435310, 0x00437310, 
-	0x00439310, 0x0043b310, 0x0043d310, 0x0043f310, 
-	0x00441310, 0x00443310, 0x00445310, 0x00447310, 
-	0x00449310, 0x0044b310, 0x0044d310, 0x0044f310, 
-	0x00451310, 0x00453310, 0x00455310, 0x00457310, 
-	0x00459310, 0x0045b310, 0x0045d310, 0x0045f310, 
-	0x00461310, 0x00463310, 0x00465310, 0x00467310, 
-	0x00469310, 0x0046b310, 0x0046d310, 0x0046f310, 
-	0x00471310, 0x00473310, 0x00475310, 0x00477310, 
-	0x00479310, 0x0047b310, 0x0047d310, 0x0047f310, 
-	0x00481310, 0x00483310, 0x00485310, 0x00487310, 
-	0x00489310, 0x0048b310, 0x0048d310, 0x0048f310, 
-	0x00491310, 0x00493310, 0x00495310, 0x00497310, 
-	0x00499310, 0x0049b310, 0x0049d310, 0x0049f310, 
-	0x004a1310, 0x004a3310, 0x004a5310, 0x004a7310, 
-	0x004a9310, 0x004ab310, 0x004ad310, 0x004af310, 
-	0x004b1310, 0x004b3310, 0x004b5310, 0x004b7310, 
-	0x004b9310, 0x004bb310, 0x004bd310, 0x004bf310, 
-	0x004c1310, 0x004c3310, 0x004c5310, 0x004c7310, 
-	0x004c9310, 0x004cb310, 0x004cd310, 0x004cf310, 
-	0x004d1310, 0x004d3310, 0x004d5310, 0x004d7310, 
-	0x004d9310, 0x004db310, 0x004dd310, 0x004df310, 
-	0x004e1310, 0x004e3310, 0x004e5310, 0x004e7310, 
-	0x004e9310, 0x004eb310, 0x004ed310, 0x004ef310, 
-	0x004f1310, 0x004f3310, 0x004f5310, 0x004f7310, 
-	0x004f9310, 0x004fb310, 0x004fd310, 0x004ff310, 
-	0x00501310, 0x00503310, 0x00505310, 0x00507310, 
-	0x00509310, 0x0050b310, 0x0050d310, 0x0050f310, 
-	0x00511310, 0x00513310, 0x00515310, 0x00517310, 
-	0x00519310, 0x0051b310, 0x0051d310, 0x0051f310, 
-	0x00521310, 0x00523310, 0x00525310, 0x00527310, 
-	0x00529310, 0x0052b310, 0x0052d310, 0x0052f310, 
-	0x00531310, 0x00533310, 0x00535310, 0x00537310, 
-	0x00539310, 0x0053b310, 0x0053d310, 0x0053f310, 
-	0x00541310, 0x00543310, 0x00545310, 0x00547310, 
-	0x00549310, 0x0054b310, 0x0054d310, 0x0054f310, 
-	0x00551310, 0x00553310, 0x00555310, 0x00557310, 
-	0x00559310, 0x0055b310, 0x0055d310, 0x0055f310, 
-	0x00561310, 0x00563310, 0x00565310, 0x00567310, 
-	0x00569310, 0x0056b310, 0x0056d310, 0x0056f310, 
-	0x00571310, 0x00573310, 0x00575310, 0x00577310, 
-	0x00579310, 0x0057b310, 0x0057d310, 0x0057f310, 
-	0x00581310, 0x00583310, 0x00585310, 0x00587310, 
-	0x00589310, 0x0058b310, 0x0058d310, 0x0058f310, 
-	0x00591310, 0x00593310, 0x00595310, 0x00597310, 
-	0x00599310, 0x0059b310, 0x0059d310, 0x0059f310, 
-	0x005a1310, 0x005a3310, 0x005a5310, 0x005a7310, 
-	0x005a9310, 0x005ab310, 0x005ad310, 0x005af310, 
-	0x005b1310, 0x005b3310, 0x005b5310, 0x005b7310, 
-	0x005b9310, 0x005bb310, 0x005bd310, 0x005bf310, 
-	0x005c1310, 0x005c3310, 0x005c5310, 0x005c7310, 
-	0x005c9310, 0x005cb310, 0x005cd310, 0x005cf310, 
-	0x005d1310, 0x005d3310, 0x005d5310, 0x005d7310, 
-	0x005d9310, 0x005db310, 0x005dd310, 0x005df310, 
-	0x005e1310, 0x005e3310, 0x005e5310, 0x005e7310, 
-	0x005e9310, 0x005eb310, 0x005ed310, 0x005ef310, 
-	0x005f1310, 0x005f3310, 0x005f5310, 0x005f7310, 
-	0x005f9310, 0x005fb310, 0x005fd310, 0x005ff310, 
-	0x00601310, 0x00603310, 0x00605310, 0x00607310, 
-	0x00609310, 0x0060b310, 0x0060d310, 0x0060f310, 
-	0x00611310, 0x00613310, 0x00615310, 0x00617310, 
-	0x00619310, 0x0061b310, 0x0061d310, 0x0061f310, 
-	0x00621310, 0x00623310, 0x00625310, 0x00627310, 
-	0x00629310, 0x0062b310, 0x0062d310, 0x0062f310, 
-	0x00631310, 0x00633310, 0x00635310, 0x00637310, 
-	0x00639310, 0x0063b310, 0x0063d310, 0x0063f310, 
-	0x00641310, 0x00643310, 0x00645310, 0x00647310, 
-	0x00649310, 0x0064b310, 0x0064d310, 0x0064f310, 
-	0x00651310, 0x00653310, 0x00655310, 0x00657310, 
-	0x00659310, 0x0065b310, 0x0065d310, 0x0065f310, 
-	0x00661310, 0x00663310, 0x00665310, 0x00667310, 
-	0x00669310, 0x0066b310, 0x0066d310, 0x0066f310, 
-	0x00671310, 0x00673310, 0x00675310, 0x00677310, 
-	0x00679310, 0x0067b310, 0x0067d310, 0x0067f310, 
-	0x00681310, 0x00683310, 0x00685310, 0x00687310, 
-	0x00689310, 0x0068b310, 0x0068d310, 0x0068f310, 
-	0x00691310, 0x00693310, 0x00695310, 0x00697310, 
-	0x00699310, 0x0069b310, 0x0069d310, 0x0069f310, 
-	0x006a1310, 0x006a3310, 0x006a5310, 0x006a7310, 
-	0x006a9310, 0x006ab310, 0x006ad310, 0x006af310, 
-	0x006b1310, 0x006b3310, 0x006b5310, 0x006b7310, 
-	0x006b9310, 0x006bb310, 0x006bd310, 0x006bf310, 
-	0x006c1310, 0x006c3310, 0x006c5310, 0x006c7310, 
-	0x006c9310, 0x006cb310, 0x006cd310, 0x006cf310, 
-	0x006d1310, 0x006d3310, 0x006d5310, 0x006d7310, 
-	0x006d9310, 0x006db310, 0x006dd310, 0x006df310, 
-	0x006e1310, 0x006e3310, 0x006e5310, 0x006e7310, 
-	0x006e9310, 0x006eb310, 0x006ed310, 0x006ef310, 
-	0x006f1310, 0x006f3310, 0x006f5310, 0x006f7310, 
-	0x006f9310, 0x006fb310, 0x006fd310, 0x006ff310, 
-	0x00701310, 0x00703310, 0x00705310, 0x00707310, 
-	0x00709310, 0x0070b310, 0x0070d310, 0x0070f310, 
-	0x00711310, 0x00713310, 0x00715310, 0x00717310, 
-	0x00719310, 0x0071b310, 0x0071d310, 0x0071f310, 
-	0x00721310, 0x00723310, 0x00725310, 0x00727310, 
-	0x00729310, 0x0072b310, 0x0072d310, 0x0072f310, 
-	0x00731310, 0x00733310, 0x00735310, 0x00737310, 
-	0x00739310, 0x0073b310, 0x0073d310, 0x0073f310, 
-	0x00741310, 0x00743310, 0x00745310, 0x00747310, 
-	0x00749310, 0x0074b310, 0x0074d310, 0x0074f310, 
-	0x00751310, 0x00753310, 0x00755310, 0x00757310, 
-	0x00759310, 0x0075b310, 0x0075d310, 0x0075f310, 
-	0x00761310, 0x00763310, 0x00765310, 0x00767310, 
-	0x00769310, 0x0076b310, 0x0076d310, 0x0076f310, 
-	0x00771310, 0x00773310, 0x00775310, 0x00777310, 
-	0x00779310, 0x0077b310, 0x0077d310, 0x0077f310, 
-	0x00781310, 0x00783310, 0x00785310, 0x00787310, 
-	0x00789310, 0x0078b310, 0x0078d310, 0x0078f310, 
-	0x00791310, 0x00793310, 0x00795310, 0x00797310, 
-	0x00799310, 0x0079b310, 0x0079d310, 0x0079f310, 
-	0x007a1310, 0x007a3310, 0x007a5310, 0x007a7310, 
-	0x007a9310, 0x007ab310, 0x007ad310, 0x007af310, 
-	0x007b1310, 0x007b3310, 0x007b5310, 0x007b7310, 
-	0x007b9310, 0x007bb310, 0x007bd310, 0x007bf310, 
-	0x007c1310, 0x007c3310, 0x007c5310, 0x007c7310, 
-	0x007c9310, 0x007cb310, 0x007cd310, 0x007cf310, 
-	0x007d1310, 0x007d3310, 0x007d5310, 0x007d7310, 
-	0x007d9310, 0x007db310, 0x007dd310, 0x007df310, 
-	0x007e1310, 0x007e3310, 0x007e5310, 0x007e7310, 
-	0x007e9310, 0x007eb310, 0x007ed310, 0x007ef310, 
-	0x007f1310, 0x007f3310, 0x007f5310, 0x007f7310, 
-	0x007f9310, 0x007fb310, 0x007fd310, 0x007ff310, 
-	0x00801310, 0x00803310, 0x00805310, 0x00807310, 
-	0x00809310, 0x0080b310, 0x0080d310, 0x0080f310, 
-	0x00811310, 0x00813310, 0x00815310, 0x00817310, 
-	0x00819310, 0x0081b310, 0x0081d310, 0x0081f310, 
-	0x00821310, 0x00823310, 0x00825310, 0x00827310, 
-	0x00829310, 0x0082b310, 0x0082d310, 0x0082f310, 
-	0x00831310, 0x00833310, 0x00835310, 0x00837310, 
-	0x00839310, 0x0083b310, 0x0083d310, 0x0083f310, 
-	0x00841310, 0x00843310, 0x00845310, 0x00847310, 
-	0x00849310, 0x0084b310, 0x0084d310, 0x0084f310, 
-	0x00851310, 0x00853310, 0x00855310, 0x00857310, 
-	0x00859310, 0x0085b310, 0x0085d310, 0x0085f310, 
-	0x00861310, 0x00863310, 0x00865310, 0x00867310, 
-	0x00869310, 0x0086b310, 0x0086d310, 0x0086f310, 
-	0x00871310, 0x00873310, 0x00875310, 0x00877310, 
-	0x00879310, 0x0087b310, 0x0087d310, 0x0087f310, 
-	0x00881310, 0x00883310, 0x00885310, 0x00887310, 
-	0x00889310, 0x0088b310, 0x0088d310, 0x0088f310, 
-	0x00891310, 0x00893310, 0x00895310, 0x00897310, 
-	0x00899310, 0x0089b310, 0x0089d310, 0x0089f310, 
-	0x008a1310, 0x008a3310, 0x008a5310, 0x008a7310, 
-	0x008a9310, 0x008ab310, 0x008ad310, 0x008af310, 
-	0x008b1310, 0x008b3310, 0x008b5310, 0x008b7310, 
-	0x008b9310, 0x008bb310, 0x008bd310, 0x008bf310, 
-	0x008c1310, 0x008c3310, 0x008c5310, 0x008c7310, 
-	0x008c9310, 0x008cb310, 0x008cd310, 0x008cf310, 
-	0x008d1310, 0x008d3310, 0x008d5310, 0x008d7310, 
-	0x008d9310, 0x008db310, 0x008dd310, 0x008df310, 
-	0x008e1310, 0x008e3310, 0x008e5310, 0x008e7310, 
-	0x008e9310, 0x008eb310, 0x008ed310, 0x008ef310, 
-	0x008f1310, 0x008f3310, 0x008f5310, 0x008f7310, 
-	0x008f9310, 0x008fb310, 0x008fd310, 0x008ff310, 
-	0x00901310, 0x00903310, 0x00905310, 0x00907310, 
-	0x00909310, 0x0090b310, 0x0090d310, 0x0090f310, 
-	0x00911310, 0x00913310, 0x00915310, 0x00917310, 
-	0x00919310, 0x0091b310, 0x0091d310, 0x0091f310, 
-	0x00921310, 0x00923310, 0x00925310, 0x00927310, 
-	0x00929310, 0x0092b310, 0x0092d310, 0x0092f310, 
-	0x00931310, 0x00933310, 0x00935310, 0x00937310, 
-	0x00939310, 0x0093b310, 0x0093d310, 0x0093f310, 
-	0x00941310, 0x00943310, 0x00945310, 0x00947310, 
-	0x00949310, 0x0094b310, 0x0094d310, 0x0094f310, 
-	0x00951310, 0x00953310, 0x00955310, 0x00957310, 
-	0x00959310, 0x0095b310, 0x0095d310, 0x0095f310, 
-	0x00961310, 0x00963310, 0x00965310, 0x00967310, 
-	0x00969310, 0x0096b310, 0x0096d310, 0x0096f310, 
-	0x00971310, 0x00973310, 0x00975310, 0x00977310, 
-	0x00979310, 0x0097b310, 0x0097d310, 0x0097f310, 
-	0x00981310, 0x00983310, 0x00985310, 0x00987310, 
-	0x00989310, 0x0098b310, 0x0098d310, 0x0098f310, 
-	0x00991310, 0x00993310, 0x00995310, 0x00997310, 
-	0x00999310, 0x0099b310, 0x0099d310, 0x0099f310, 
-	0x009a1310, 0x009a3310, 0x009a5310, 0x009a7310, 
-	0x009a9310, 0x009ab310, 0x009ad310, 0x009af310, 
-	0x009b1310, 0x009b3310, 0x009b5310, 0x009b7310, 
-	0x009b9310, 0x009bb310, 0x009bd310, 0x009bf310, 
-	0x009c1310, 0x009c3310, 0x009c5310, 0x009c7310, 
-	0x009c9310, 0x009cb310, 0x009cd310, 0x009cf310, 
-	0x009d1310, 0x009d3310, 0x009d5310, 0x009d7310, 
-	0x009d9310, 0x009db310, 0x009dd310, 0x009df310, 
-	0x009e1310, 0x009e3310, 0x009e5310, 0x009e7310, 
-	0x009e9310, 0x009eb310, 0x009ed310, 0x009ef310, 
-	0x009f1310, 0x009f3310, 0x009f5310, 0x009f7310, 
-	0x009f9310, 0x009fb310, 0x009fd310, 0x009ff310, 
-	0x00a01310, 0x00a03310, 0x00a05310, 0x00a07310, 
-	0x00a09310, 0x00a0b310, 0x00a0d310, 0x00a0f310, 
-	0x00a11310, 0x00a13310, 0x00a15310, 0x00a17310, 
-	0x00a19310, 0x00a1b310, 0x00a1d310, 0x00a1f310, 
-	0x00a21310, 0x00a23310, 0x00a25310, 0x00a27310, 
-	0x00a29310, 0x00a2b310, 0x00a2d310, 0x00a2f310, 
-	0x00a31310, 0x00a33310, 0x00a35310, 0x00a37310, 
-	0x00a39310, 0x00a3b310, 0x00a3d310, 0x00a3f310, 
-	0x00a41310, 0x00a43310, 0x00a45310, 0x00a47310, 
-	0x00a49310, 0x00a4b310, 0x00a4d310, 0x00a4f310, 
-	0x00a51310, 0x00a53310, 0x00a55310, 0x00a57310, 
-	0x00a59310, 0x00a5b310, 0x00a5d310, 0x00a5f310, 
-	0x00a61310, 0x00a63310, 0x00a65310, 0x00a67310, 
-	0x00a69310, 0x00a6b310, 0x00a6d310, 0x00a6f310, 
-	0x00a71310, 0x00a73310, 0x00a75310, 0x00a77310, 
-	0x00a79310, 0x00a7b310, 0x00a7d310, 0x00a7f310, 
-	0x00a81310, 0x00a83310, 0x00a85310, 0x00a87310, 
-	0x00a89310, 0x00a8b310, 0x00a8d310, 0x00a8f310, 
-	0x00a91310, 0x00a93310, 0x00a95310, 0x00a97310, 
-	0x00a99310, 0x00a9b310, 0x00a9d310, 0x00a9f310, 
-	0x00aa1310, 0x00aa3310, 0x00aa5310, 0x00aa7310, 
-	0x00aa9310, 0x00aab310, 0x00aad310, 0x00aaf310, 
-	0x00ab1310, 0x00ab3310, 0x00ab5310, 0x00ab7310, 
-	0x00ab9310, 0x00abb310, 0x00abd310, 0x00abf310, 
-	0x00ac1310, 0x00ac3310, 0x00ac5310, 0x00ac7310, 
-	0x00ac9310, 0x00acb310, 0x00acd310, 0x00acf310, 
-	0x00ad1310, 0x00ad3310, 0x00ad5310, 0x00ad7310, 
-	0x00ad9310, 0x00adb310, 0x00add310, 0x00adf310, 
-	0x00ae1310, 0x00ae3310, 0x00ae5310, 0x00ae7310, 
-	0x00ae9310, 0x00aeb310, 0x00aed310, 0x00aef310, 
-	0x00af1310, 0x00af3310, 0x00af5310, 0x00af7310, 
-	0x00af9310, 0x00afb310, 0x00afd310, 0x00aff310, 
-	0x00b01310, 0x00b03310, 0x00b05310, 0x00b07310, 
-	0x00b09310, 0x00b0b310, 0x00b0d310, 0x00b0f310, 
-	0x00b11310, 0x00b13310, 0x00b15310, 0x00b17310, 
-	0x00b19310, 0x00b1b310, 0x00b1d310, 0x00b1f310, 
-	0x00b21310, 0x00b23310, 0x00b25310, 0x00b27310, 
-	0x00b29310, 0x00b2b310, 0x00b2d310, 0x00b2f310, 
-	0x00b31310, 0x00b33310, 0x00b35310, 0x00b37310, 
-	0x00b39310, 0x00b3b310, 0x00b3d310, 0x00b3f310, 
-	0x00b41310, 0x00b43310, 0x00b45310, 0x00b47310, 
-	0x00b49310, 0x00b4b310, 0x00b4d310, 0x00b4f310, 
-	0x00b51310, 0x00b53310, 0x00b55310, 0x00b57310, 
-	0x00b59310, 0x00b5b310, 0x00b5d310, 0x00b5f310, 
-	0x00b61310, 0x00b63310, 0x00b65310, 0x00b67310, 
-	0x00b69310, 0x00b6b310, 0x00b6d310, 0x00b6f310, 
-	0x00b71310, 0x00b73310, 0x00b75310, 0x00b77310, 
-	0x00b79310, 0x00b7b310, 0x00b7d310, 0x00b7f310, 
-	0x00b81310, 0x00b83310, 0x00b85310, 0x00b87310, 
-	0x00b89310, 0x00b8b310, 0x00b8d310, 0x00b8f310, 
-	0x00b91310, 0x00b93310, 0x00b95310, 0x00b97310, 
-	0x00b99310, 0x00b9b310, 0x00b9d310, 0x00b9f310, 
-	0x00ba1310, 0x00ba3310, 0x00ba5310, 0x00ba7310, 
-	0x00ba9310, 0x00bab310, 0x00bad310, 0x00baf310, 
-	0x00bb1310, 0x00bb3310, 0x00bb5310, 0x00bb7310, 
-	0x00bb9310, 0x00bbb310, 0x00bbd310, 0x00bbf310, 
-	0x00bc1310, 0x00bc3310, 0x00bc5310, 0x00bc7310, 
-	0x00bc9310, 0x00bcb310, 0x00bcd310, 0x00bcf310, 
-	0x00bd1310, 0x00bd3310, 0x00bd5310, 0x00bd7310, 
-	0x00bd9310, 0x00bdb310, 0x00bdd310, 0x00bdf310, 
-	0x00be1310, 0x00be3310, 0x00be5310, 0x00be7310, 
-	0x00be9310, 0x00beb310, 0x00bed310, 0x00bef310, 
-	0x00bf1310, 0x00bf3310, 0x00bf5310, 0x00bf7310, 
-	0x00bf9310, 0x00bfb310, 0x00bfd310, 0x00bff310, 
-	0x00c01310, 0x00c03310, 0x00c05310, 0x00c07310, 
-	0x00c09310, 0x00c0b310, 0x00c0d310, 0x00c0f310, 
-	0x00c11310, 0x00c13310, 0x00c15310, 0x00c17310, 
-	0x00c19310, 0x00c1b310, 0x00c1d310, 0x00c1f310, 
-	0x00c21310, 0x00c23310, 0x00c25310, 0x00c27310, 
-	0x00c29310, 0x00c2b310, 0x00c2d310, 0x00c2f310, 
-	0x00c31310, 0x00c33310, 0x00c35310, 0x00c37310, 
-	0x00c39310, 0x00c3b310, 0x00c3d310, 0x00c3f310, 
-	0x00c41310, 0x00c43310, 0x00c45310, 0x00c47310, 
-	0x00c49310, 0x00c4b310, 0x00c4d310, 0x00c4f310, 
-	0x00c51310, 0x00c53310, 0x00c55310, 0x00c57310, 
-	0x00c59310, 0x00c5b310, 0x00c5d310, 0x00c5f310, 
-	0x00c61310, 0x00c63310, 0x00c65310, 0x00c67310, 
-	0x00c69310, 0x00c6b310, 0x00c6d310, 0x00c6f310, 
-	0x00c71310, 0x00c73310, 0x00c75310, 0x00c77310, 
-	0x00c79310, 0x00c7b310, 0x00c7d310, 0x00c7f310, 
-	0x00c81310, 0x00c83310, 0x00c85310, 0x00c87310, 
-	0x00c89310, 0x00c8b310, 0x00c8d310, 0x00c8f310, 
-	0x00c91310, 0x00c93310, 0x00c95310, 0x00c97310, 
-	0x00c99310, 0x00c9b310, 0x00c9d310, 0x00c9f310, 
-	0x00ca1310, 0x00ca3310, 0x00ca5310, 0x00ca7310, 
-	0x00ca9310, 0x00cab310, 0x00cad310, 0x00caf310, 
-	0x00cb1310, 0x00cb3310, 0x00cb5310, 0x00cb7310, 
-	0x00cb9310, 0x00cbb310, 0x00cbd310, 0x00cbf310, 
-	0x00cc1310, 0x00cc3310, 0x00cc5310, 0x00cc7310, 
-	0x00cc9310, 0x00ccb310, 0x00ccd310, 0x00ccf310, 
-	0x00cd1310, 0x00cd3310, 0x00cd5310, 0x00cd7310, 
-	0x00cd9310, 0x00cdb310, 0x00cdd310, 0x00cdf310, 
-	0x00ce1310, 0x00ce3310, 0x00ce5310, 0x00ce7310, 
-	0x00ce9310, 0x00ceb310, 0x00ced310, 0x00cef310, 
-	0x00cf1310, 0x00cf3310, 0x00cf5310, 0x00cf7310, 
-	0x00cf9310, 0x00cfb310, 0x00cfd310, 0x00cff310, 
-	0x00d01310, 0x00d03310, 0x00d05310, 0x00d07310, 
-	0x00d09310, 0x00d0b310, 0x00d0d310, 0x00d0f310, 
-	0x00d11310, 0x00d13310, 0x00d15310, 0x00d17310, 
-	0x00d19310, 0x00d1b310, 0x00d1d310, 0x00d1f310, 
-	0x00d21310, 0x00d23310, 0x00d25310, 0x00d27310, 
-	0x00d29310, 0x00d2b310, 0x00d2d310, 0x00d2f310, 
-	0x00d31310, 0x00d33310, 0x00d35310, 0x00d37310, 
-	0x00d39310, 0x00d3b310, 0x00d3d310, 0x00d3f310, 
-	0x00d41310, 0x00d43310, 0x00d45310, 0x00d47310, 
-	0x00d49310, 0x00d4b310, 0x00d4d310, 0x00d4f310, 
-	0x00d51310, 0x00d53310, 0x00d55310, 0x00d57310, 
-	0x00d59310, 0x00d5b310, 0x00d5d310, 0x00d5f310, 
-	0x00d61310, 0x00d63310, 0x00d65310, 0x00d67310, 
-	0x00d69310, 0x00d6b310, 0x00d6d310, 0x00d6f310, 
-	0x00d71310, 0x00d73310, 0x00d75310, 0x00d77310, 
-	0x00d79310, 0x00d7b310, 0x00d7d310, 0x00d7f310, 
-	0x00d81310, 0x00d83310, 0x00d85310, 0x00d87310, 
-	0x00d89310, 0x00d8b310, 0x00d8d310, 0x00d8f310, 
-	0x00d91310, 0x00d93310, 0x00d95310, 0x00d97310, 
-	0x00d99310, 0x00d9b310, 0x00d9d310, 0x00d9f310, 
-	0x00da1310, 0x00da3310, 0x00da5310, 0x00da7310, 
-	0x00da9310, 0x00dab310, 0x00dad310, 0x00daf310, 
-	0x00db1310, 0x00db3310, 0x00db5310, 0x00db7310, 
-	0x00db9310, 0x00dbb310, 0x00dbd310, 0x00dbf310, 
-	0x00dc1310, 0x00dc3310, 0x00dc5310, 0x00dc7310, 
-	0x00dc9310, 0x00dcb310, 0x00dcd310, 0x00dcf310, 
-	0x00dd1310, 0x00dd3310, 0x00dd5310, 0x00dd7310, 
-	0x00dd9310, 0x00ddb310, 0x00ddd310, 0x00ddf310, 
-	0x00de1310, 0x00de3310, 0x00de5310, 0x00de7310, 
-	0x00de9310, 0x00deb310, 0x00ded310, 0x00def310, 
-	0x00df1310, 0x00df3310, 0x00df5310, 0x00df7310, 
-	0x00df9310, 0x00dfb310, 0x00dfd310, 0x00dff310, 
-	0x00e01310, 0x00e03310, 0x00e05310, 0x00e07310, 
-	0x00e09310, 0x00e0b310, 0x00e0d310, 0x00e0f310, 
-	0x00e11310, 0x00e13310, 0x00e15310, 0x00e17310, 
-	0x00e19310, 0x00e1b310, 0x00e1d310, 0x00e1f310, 
-	0x00e21310, 0x00e23310, 0x00e25310, 0x00e27310, 
-	0x00e29310, 0x00e2b310, 0x00e2d310, 0x00e2f310, 
-	0x00e31310, 0x00e33310, 0x00e35310, 0x00e37310, 
-	0x00e39310, 0x00e3b310, 0x00e3d310, 0x00e3f310, 
-	0x00e41310, 0x00e43310, 0x00e45310, 0x00e47310, 
-	0x00e49310, 0x00e4b310, 0x00e4d310, 0x00e4f310, 
-	0x00e51310, 0x00e53310, 0x00e55310, 0x00e57310, 
-	0x00e59310, 0x00e5b310, 0x00e5d310, 0x00e5f310, 
-	0x00e61310, 0x00e63310, 0x00e65310, 0x00e67310, 
-	0x00e69310, 0x00e6b310, 0x00e6d310, 0x00e6f310, 
-	0x00e71310, 0x00e73310, 0x00e75310, 0x00e77310, 
-	0x00e79310, 0x00e7b310, 0x00e7d310, 0x00e7f310, 
-	0x00e81310, 0x00e83310, 0x00e85310, 0x00e87310, 
-	0x00e89310, 0x00e8b310, 0x00e8d310, 0x00e8f310, 
-	0x00e91310, 0x00e93310, 0x00e95310, 0x00e97310, 
-	0x00e99310, 0x00e9b310, 0x00e9d310, 0x00e9f310, 
-	0x00ea1310, 0x00ea3310, 0x00ea5310, 0x00ea7310, 
-	0x00ea9310, 0x00eab310, 0x00ead310, 0x00eaf310, 
-	0x00eb1310, 0x00eb3310, 0x00eb5310, 0x00eb7310, 
-	0x00eb9310, 0x00ebb310, 0x00ebd310, 0x00ebf310, 
-	0x00ec1310, 0x00ec3310, 0x00ec5310, 0x00ec7310, 
-	0x00ec9310, 0x00ecb310, 0x00ecd310, 0x00ecf310, 
-	0x00ed1310, 0x00ed3310, 0x00ed5310, 0x00ed7310, 
-	0x00ed9310, 0x00edb310, 0x00edd310, 0x00edf310, 
-	0x00ee1310, 0x00ee3310, 0x00ee5310, 0x00ee7310, 
-	0x00ee9310, 0x00eeb310, 0x00eed310, 0x00eef310, 
-	0x00ef1310, 0x00ef3310, 0x00ef5310, 0x00ef7310, 
-	0x00ef9310, 0x00efb310, 0x00efd310, 0x00eff310, 
-	0x00f01310, 0x00f03310, 0x00f05310, 0x00f07310, 
-	0x00f09310, 0x00f0b310, 0x00f0d310, 0x00f0f310, 
-	0x00f11310, 0x00f13310, 0x00f15310, 0x00f17310, 
-	0x00f19310, 0x00f1b310, 0x00f1d310, 0x00f1f310, 
-	0x00f21310, 0x00f23310, 0x00f25310, 0x00f27310, 
-	0x00f29310, 0x00f2b310, 0x00f2d310, 0x00f2f310, 
-	0x00f31310, 0x00f33310, 0x00f35310, 0x00f37310, 
-	0x00f39310, 0x00f3b310, 0x00f3d310, 0x00f3f310, 
-	0x00f41310, 0x00f43310, 0x00f45310, 0x00f47310, 
-	0x00f49310, 0x00f4b310, 0x00f4d310, 0x00f4f310, 
-	0x00f51310, 0x00f53310, 0x00f55310, 0x00f57310, 
-	0x00f59310, 0x00f5b310, 0x00f5d310, 0x00f5f310, 
-	0x00f61310, 0x00f63310, 0x00f65310, 0x00f67310, 
-	0x00f69310, 0x00f6b310, 0x00f6d310, 0x00f6f310, 
-	0x00f71310, 0x00f73310, 0x00f75310, 0x00f77310, 
-	0x00f79310, 0x00f7b310, 0x00f7d310, 0x00f7f310, 
-	0x00f81310, 0x00f83310, 0x00f85310, 0x00f87310, 
-	0x00f89310, 0x00f8b310, 0x00f8d310, 0x00f8f310, 
-	0x00f91310, 0x00f93310, 0x00f95310, 0x00f97310, 
-	0x00f99310, 0x00f9b310, 0x00f9d310, 0x00f9f310, 
-	0x00fa1310, 0x00fa3310, 0x00fa5310, 0x00fa7310, 
-	0x00fa9310, 0x00fab310, 0x00fad310, 0x00faf310, 
-	0x00fb1310, 0x00fb3310, 0x00fb5310, 0x00fb7310, 
-	0x00fb9310, 0x00fbb310, 0x00fbd310, 0x00fbf310, 
-	0x00fc1310, 0x00fc3310, 0x00fc5310, 0x00fc7310, 
-	0x00fc9310, 0x00fcb310, 0x00fcd310, 0x00fcf310, 
-	0x00fd1310, 0x00fd3310, 0x00fd5310, 0x00fd7310, 
-	0x00fd9310, 0x00fdb310, 0x00fdd310, 0x00fdf310, 
-	0x00fe1310, 0x00fe3310, 0x00fe5310, 0x00fe7310, 
-	0x00fe9310, 0x00feb310, 0x00fed310, 0x00fef310, 
-	0x00ff1310, 0x00ff3310, 0x00ff5310, 0x00ff7310, 
-	0x00ff9310, 0x00ffb310, 0x00ffd310, 0x00fff310, 
-};
-#endif

--- a/src/native/external/zlib-intel/inflate.c
+++ b//dev/null
@@ -1,1549 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common wnext == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-/* function prototypes */
-local int inflateStateCheck OF((z_streamp strm));
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
-                           unsigned copy));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
-                              unsigned len));
-local int inflateStateCheck(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state == Z_NULL || state->strm != strm ||
-        state->mode < HEAD || state->mode > SYNC)
-        return 1;
-    return 0;
-}
-int ZEXPORT inflateResetKeep(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    if (state->wrap)        /* to support ill-conceived Java test suite */
-        strm->adler = state->wrap & 1;
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->flags = -1;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    state->sane = 1;
-    state->back = -1;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->whave = 0;
-    state->wnext = 0;
-    return inflateResetKeep(strm);
-}
-int ZEXPORT inflateReset2(strm, windowBits)
-z_streamp strm;
-int windowBits;
-{
-    int wrap;
-    struct inflate_state FAR *state;
-    /* get the state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    /* extract wrap request from windowBits parameter */
-    if (windowBits < 0) {
-        if (windowBits < -15)
-            return Z_STREAM_ERROR;
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        wrap = (windowBits >> 4) + 5;
-#ifdef GUNZIP
-        if (windowBits < 48)
-            windowBits &= 15;
-#endif
-    }
-    /* set number of window bits, free window if different */
-    if (windowBits && (windowBits < 8 || windowBits > 15))
-        return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
-    }
-    /* update state and reset the rest of it */
-    state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
-}
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    int ret;
-    struct inflate_state FAR *state;
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->strm = strm;
-    state->window = Z_NULL;
-    state->mode = HEAD;     /* to pass state test in inflateReset2() */
-#if defined(ZLIB_X86)
-    x86_check_features();
-#endif
-    ret = inflateReset2(strm, windowBits);
-    if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-        return ret;
-    }
-    if (state->wbits == 0)
-	    state->wbits = 15;
-    if (state->wbits > 0) {
-        state->wsize = 1UL << state->wbits;
-        state->window = (unsigned char FAR *)ZALLOC(strm, state->wsize + 16, 4);
-        if (state->window == Z_NULL) {
-            ZFREE(strm, state);
-            strm->state = Z_NULL;
-            ret = Z_MEM_ERROR;
-        }
-    }
-    state->whave = 0;
-    state->wnext = 0;
-    return ret;
-}
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits < 0) {
-        state->hold = 0;
-        state->bits = 0;
-        return Z_OK;
-    }
-    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += (unsigned)value << state->bits;
-    state->bits += (uInt)bits;
-    return Z_OK;
-}
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-#ifdef MAKEFIXED
-#include <stdio.h>
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-    void makefixed(void);
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
-               state.lencode[low].bits, state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, end, copy)
-z_streamp strm;
-const Bytef *end;
-unsigned copy;
-{
-    struct inflate_state FAR *state;
-    unsigned dist;
-    state = (struct inflate_state FAR *)strm->state;
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->wnext = 0;
-        state->whave = 0;
-    }
-    /* copy state->wsize or less output bytes into the circular window */
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, end - state->wsize, state->wsize);
-        state->wnext = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->wnext;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->wnext, end - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, end - copy, copy);
-            state->wnext = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->wnext += dist;
-            if (state->wnext == state->wsize) state->wnext = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-/* Macros for inflate(): */
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE_CHECK(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)
-#endif
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = state->window + state->wsize + state->wnext; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        state->wnext = (unsigned)(put - (state->window + state->wsize));\
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                if (state->wbits == 0)
-                    state->wbits = 15;
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (state->wbits == 0)
-                state->wbits = len;
-            if (len > 15 || len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            if (state->window == Z_NULL) {
-                RESTORE();
-                state->wsize = 1UL << state->wbits;
-                state->window = (unsigned char FAR *)ZALLOC(strm, state->wsize + 16, 4);
-                if (state->window == Z_NULL) {
-                    ZFREE(strm, state);
-                    strm->state = Z_NULL;
-                    ret = Z_MEM_ERROR;
-                }
-                LOAD();
-            }
-            state->dmax = 1U << len;
-            state->flags = 0;               /* indicate zlib header */
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-                /* fallthrough */
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-                /* fallthrough */
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-                /* fallthrough */
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-                /* fallthrough */
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL &&
-                        (len = state->head->extra_len - state->length) <
-                            state->head->extra_max) {
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if ((state->flags & 0x0200) && (state->wrap & 4))
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-                /* fallthrough */
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-                /* fallthrough */
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-                /* fallthrough */
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-#if defined(USE_PCLMUL_CRC)
-            if (x86_cpu_has_pclmul)
-                crc_fold_init(state->crc);
-#endif
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = ZSWAP32(hold);
-            INITBITS();
-            state->mode = DICT;
-                /* fallthrough */
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-                /* fallthrough */
-        case TYPE:
-            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN_;             /* decode codes */
-                if (flush == Z_TREES) {
-                    DROPBITS(2);
-                    goto inf_leave;
-                }
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY_;
-            if (flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case COPY_:
-            state->mode = COPY;
-                /* fallthrough */
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                unsigned char *end = state->window + (state->wsize * 4);
-                unsigned diff = (unsigned)(end - put);
-                if (copy > have) copy = have;
-                if (copy > diff) {
-                    if (left > 0) {
-                        RESTORE();
-                        window_output_flush(strm);
-                        LOAD();
-                        diff = (unsigned)(end - put);
-                    }
-                    if (copy > diff) copy = diff;
-                }
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-                /* fallthrough */
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-                /* fallthrough */
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (const code FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN_;
-            if (flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case LEN_:
-            state->mode = LEN;
-                /* fallthrough */
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            state->length = (unsigned)here.val;
-            if ((int)(here.op) == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                state->mode = LIT;
-                break;
-            }
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->back = -1;
-                state->mode = TYPE;
-                break;
-            }
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = LENEXT;
-                /* fallthrough */
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->was = state->length;
-            state->mode = DIST;
-                /* fallthrough */
-        case DIST:
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = DISTEXT;
-                /* fallthrough */
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-                /* fallthrough */
-            case MATCH: {
-                unsigned char *end = state->window + (state->wsize * 4);
-                unsigned buf_left = (unsigned)(end - put);
-                copy = state->length;
-		RESTORE();
-                if (copy > buf_left) {
-                    if (strm->avail_out > 0) {
-                        /* relies on RESTORE() above with no changes to those vars */
-                        window_output_flush(strm);
-                        LOAD();
-                        buf_left = (unsigned)(end - put);
-                    }
-                    if (copy > buf_left) copy = buf_left;
-                }
-                if (copy == 0) goto inf_leave;
-                if (state->offset > state->whave + state->wnext) {
-                    if (state->sane) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-                }
-            from = state->window + state->wsize + state->wnext - state->offset;
-            state->length -= copy;
-            if (copy > state->offset) {
-                while (copy > 2) {
-                    *(state->window + state->wsize + state->wnext++) = *from++;
-                    *(state->window + state->wsize + state->wnext++) = *from++;
-                    *(state->window + state->wsize + state->wnext++) = *from++;
-                    copy -= 3;
-                }
-                if (copy) {
-                    *(state->window + state->wsize + state->wnext++) = *from++;
-                    if (copy > 1) {
-                        *(state->window + state->wsize + state->wnext++) = *from;
-                    }
-                }
-            } else {
-                zmemcpy(state->window + state->wsize + state->wnext, from, copy);
-                state->wnext += copy;
-            }
-            LOAD();
-            if (state->length == 0) state->mode = LEN;
-            break;
-        } case LIT:
-            if (put >= state->window + (state->wsize * 4)) {
-                RESTORE();
-                window_output_flush(strm);
-                LOAD();
-            }
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            state->mode = LEN;
-            break;
-        case CHECK:
-            RESTORE();
-            window_output_flush(strm);
-            LOAD();
-            if (strm->avail_out == 0 && state->wnext)
-                goto inf_leave;
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                out = left;
-#ifdef USE_PCLMUL_CRC
-		if (state->flags > 0 && x86_cpu_has_pclmul)
-		    strm->adler = state->check = crc_fold_512to32(state->crc);
-#endif
-                if ((state->wrap & 4) && (
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     ZSWAP32(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-                /* fallthrough */
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-                /* fallthrough */
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-                /* fallthrough */
-        default:
-            return Z_STREAM_ERROR;
-        }
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wnext && strm->avail_out)
-        window_output_flush(strm);
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0) +
-                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-Bytef *dictionary;
-uInt *dictLength;
-{
-    struct inflate_state FAR *state;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    /* copy dictionary */
-    if (state->whave && dictionary != Z_NULL) {
-        zmemcpy(dictionary, state->window + state->wnext,
-                state->whave - state->wnext);
-        zmemcpy(dictionary + state->whave - state->wnext,
-                state->window, state->wnext);
-    }
-    if (dictLength != Z_NULL)
-        *dictLength = state->whave;
-    return Z_OK;
-}
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long dictid, dict_copy, hist_copy;
-    const unsigned char *dict_from, *hist_from;
-    unsigned char *dict_to, *hist_to;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-    /* check for correct dictionary identifier */
-    if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
-        dictid = adler32(dictid, dictionary, dictLength);
-        if (dictid != state->check)
-            return Z_DATA_ERROR;
-    }
-    Tracec(state->wnext != 0, (stderr, "Setting dictionary with unflushed output"));
-    dict_from = dictionary;
-    dict_copy = dictLength;
-    if (dict_copy > state->wsize) {
-        dict_copy = state->wsize;
-        dict_from += (dictLength - dict_copy);
-    }
-    dict_to = state->window + state->wsize - dict_copy;
-    hist_from = state->window + state->wsize - state->whave;
-    hist_copy = state->wsize - dict_copy;
-    if (hist_copy > state->whave)
-        hist_copy = state->whave;
-    hist_to = dict_to - hist_copy;
-    if (hist_copy)
-        zmemcpy(hist_to, hist_from, hist_copy);
-    if (dict_copy)
-        zmemcpy(dict_to, dict_from, dict_copy);
-    state->whave = hist_copy + dict_copy;
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-const unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    int flags;                  /* temporary to save header status */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-    /* check parameters */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    if (state->flags == -1)
-        state->wrap = 0;    /* if no header yet, treat as raw */
-    else
-        state->wrap &= ~4;  /* no point in computing a check value now */
-    flags = state->flags;
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->flags = flags;
-    state->mode = TYPE;
-    return Z_OK;
-}
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize = 0;
-    /* check input */
-    if (inflateStateCheck(source) || dest == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        wsize = 1UL << state->wbits;
-        window = (unsigned char FAR *)ZALLOC(source, wsize + 16, 4);
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-    /* copy state */
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
-    copy->strm = dest;
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        zmemcpy(window, state->window, ((wsize + 16) *4));
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
-int ZEXPORT inflateUndermine(strm, subvert)
-z_streamp strm;
-int subvert;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    state->sane = !subvert;
-    return Z_OK;
-#else
-    (void)subvert;
-    state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
-}
-int ZEXPORT inflateValidate(strm, check)
-z_streamp strm;
-int check;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (check && state->wrap)
-        state->wrap |= 4;
-    else
-        state->wrap &= ~4;
-    return Z_OK;
-}
-long ZEXPORT inflateMark(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm))
-        return -(1L << 16);
-    state = (struct inflate_state FAR *)strm->state;
-    return (long)(((unsigned long)((long)state->back)) << 16) +
-        (state->mode == COPY ? state->length :
-            (state->mode == MATCH ? state->was - state->length : 0));
-}
-unsigned long ZEXPORT inflateCodesUsed(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return (unsigned long)-1;
-    state = (struct inflate_state FAR *)strm->state;
-    return (unsigned long)(state->next - state->codes);
-}

--- a/src/native/external/zlib-intel/inflate.h
+++ b//dev/null
@@ -1,173 +0,0 @@
-/* inflate.h -- internal inflate state definition
- * Copyright (C) 1995-2019 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip decoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GUNZIP
-#endif
-#include "zutil.h"
-#include "x86.h"
-/* Possible inflate modes between inflate() calls */
-typedef enum {
-    HEAD = 16180,   /* i: waiting for magic header */
-    FLAGS,      /* i: waiting for method and flags (gzip) */
-    TIME,       /* i: waiting for modification time (gzip) */
-    OS,         /* i: waiting for extra flags and operating system (gzip) */
-    EXLEN,      /* i: waiting for extra length (gzip) */
-    EXTRA,      /* i: waiting for extra bytes (gzip) */
-    NAME,       /* i: waiting for end of file name (gzip) */
-    COMMENT,    /* i: waiting for end of comment (gzip) */
-    HCRC,       /* i: waiting for header crc (gzip) */
-    DICTID,     /* i: waiting for dictionary check value */
-    DICT,       /* waiting for inflateSetDictionary() call */
-        TYPE,       /* i: waiting for type bits, including last-flag bit */
-        TYPEDO,     /* i: same, but skip check to exit inflate on new block */
-        STORED,     /* i: waiting for stored size (length and complement) */
-        COPY_,      /* i/o: same as COPY below, but only first time in */
-        COPY,       /* i/o: waiting for input or output to copy stored block */
-        TABLE,      /* i: waiting for dynamic block table lengths */
-        LENLENS,    /* i: waiting for code length code lengths */
-        CODELENS,   /* i: waiting for length/lit and distance code lengths */
-            LEN_,       /* i: same as LEN below, but only first time in */
-            LEN,        /* i: waiting for length/lit/eob code */
-            LENEXT,     /* i: waiting for length extra bits */
-            DIST,       /* i: waiting for distance code */
-            DISTEXT,    /* i: waiting for distance extra bits */
-            MATCH,      /* o: waiting for output space to copy string */
-            LIT,        /* o: waiting for output space to write literal */
-    CHECK,      /* i: waiting for 32-bit check value */
-    LENGTH,     /* i: waiting for 32-bit length (gzip) */
-    DONE,       /* finished check, done -- remain here until reset */
-    BAD,        /* got a data error -- remain here until reset */
-    MEM,        /* got an inflate() memory error -- remain here until reset */
-    SYNC        /* looking for synchronization bytes to restart inflate() */
-} inflate_mode;
-/*
-    State transitions between above modes -
-    (most modes can go to BAD or MEM on error -- not shown for clarity)
-    Process header:
-        HEAD -> (gzip) or (zlib) or (raw)
-        (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
-                  HCRC -> TYPE
-        (zlib) -> DICTID or TYPE
-        DICTID -> DICT -> TYPE
-        (raw) -> TYPEDO
-    Read deflate blocks:
-            TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
-            STORED -> COPY_ -> COPY -> TYPE
-            TABLE -> LENLENS -> CODELENS -> LEN_
-            LEN_ -> LEN
-    Read deflate codes in fixed or dynamic block:
-                LEN -> LENEXT or LIT or TYPE
-                LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
-                LIT -> LEN
-    Process trailer:
-        CHECK -> LENGTH -> DONE
- */
-/* State maintained between inflate() calls -- approximately 7K bytes, not
-   including the allocated sliding window, which is up to 32K bytes. */
-struct inflate_state {
-    z_streamp strm;             /* pointer back to this zlib stream */
-    inflate_mode mode;          /* current inflate mode */
-    int last;                   /* true if processing last block */
-    int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,
-                                   bit 2 true to validate check value */
-    int havedict;               /* true if dictionary provided */
-    int flags;                  /* gzip header method and flags, 0 if zlib, or
-                                   -1 if raw or no header yet */
-    unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
-    unsigned long check;        /* protected copy of check value */
-    unsigned long total;        /* protected copy of output count */
-    gz_headerp head;            /* where to save gzip header information */
-        /* sliding window */
-    unsigned wbits;             /* log base 2 of requested window size */
-    unsigned wsize;             /* window size or zero if not using window */
-    unsigned whave;             /* valid bytes in the window */
-    unsigned wnext;             /* window write index */
-    unsigned char FAR *window;  /* allocated sliding window, if needed */
-#if defined(USE_PCLMUL_CRC)
-    unsigned zalign(16) crc[4 * 5];
-#endif
-        /* bit accumulator */
-    unsigned long hold;         /* input bit accumulator */
-    unsigned bits;              /* number of bits in "in" */
-        /* for string and stored block copying */
-    unsigned length;            /* literal or length of data to copy */
-    unsigned offset;            /* distance back to copy string from */
-        /* for table and code decoding */
-    unsigned extra;             /* extra bits needed */
-        /* fixed and dynamic code tables */
-    code const FAR *lencode;    /* starting table for length/literal codes */
-    code const FAR *distcode;   /* starting table for distance codes */
-    unsigned lenbits;           /* index bits for lencode */
-    unsigned distbits;          /* index bits for distcode */
-        /* dynamic table building */
-    unsigned ncode;             /* number of code length code lengths */
-    unsigned nlen;              /* number of length code lengths */
-    unsigned ndist;             /* number of distance code lengths */
-    unsigned have;              /* number of code lengths in lens[] */
-    code FAR *next;             /* next available space in codes[] */
-    unsigned short lens[320];   /* temporary storage for code lengths */
-    unsigned short work[288];   /* work area for code table building */
-    code codes[ENOUGH];         /* space for code tables */
-    int sane;                   /* if false, allow invalid distance too far */
-    int back;                   /* bits back of last unprocessed length/lit */
-    unsigned was;               /* initial length of match */
-};
-static inline void inf_crc_copy(z_streamp strm, unsigned char FAR *const dst,
-        const unsigned char FAR *const src, uInt len)
-{
-    struct inflate_state *const state = (struct inflate_state *const)strm->state;
-#if !defined(NO_GZIP) && defined(USE_PCLMUL_CRC)
-    if (state->flags > 0 && x86_cpu_has_pclmul) {
-        crc_fold_copy(state->crc, dst, src, len);
-        return;
-    }
-#endif
-    zmemcpy(dst, src, len);
-#if !defined(NO_GZIP)
-    if (state->flags > 0)
-        strm->adler = state->check = crc32(state->check, dst, len);
-    else
-#endif
-    if (state->flags == 0)
-        strm->adler = state->check = adler32(state->check, dst, len);
-}
-static inline void window_output_flush(z_streamp strm)
-{
-    struct inflate_state *const state = (struct inflate_state *const)strm->state;
-    size_t woff, roff, copysz;
-    uInt nexto_len;
-    if (state->wnext > strm->avail_out) {
-        nexto_len = strm->avail_out;
-        copysz = state->wnext - strm->avail_out;
-    } else {
-        nexto_len = state->wnext;
-        copysz = 0;
-    }
-    inf_crc_copy(strm, strm->next_out, state->window + state->wsize, nexto_len);
-    strm->avail_out -= nexto_len;
-    strm->next_out += nexto_len;
-    if (state->whave + nexto_len > state->wsize) {
-        woff = 0;
-        roff = nexto_len;
-        copysz += state->wsize;
-    } else {
-        roff = state->wsize - state->whave;
-        woff = state->wsize - state->whave - nexto_len;
-        copysz += state->whave + nexto_len;
-    }
-    memmove(state->window + woff, state->window + roff, copysz);
-    state->wnext -= nexto_len;
-    state->whave += nexto_len;
-    if (state->whave > state->wsize)
-        state->whave = state->wsize;
-}

--- a/src/native/external/zlib-intel/inftrees.c
+++ b//dev/null
@@ -1,272 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "zutil.h"
-#include "inftrees.h"
-#define MAXBITS 15
-const char inflate_copyright[] =
-   " inflate 1.2.13 Copyright 1995-2022 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code here;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    unsigned match;             /* use base and extra for symbol >= match */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        here.op = (unsigned char)64;    /* invalid code marker */
-        here.bits = (unsigned char)1;
-        here.val = (unsigned short)0;
-        *(*table)++ = here;             /* make a table to force an error */
-        *(*table)++ = here;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min < max; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftrees.h
-       for more information.
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        match = 20;
-        break;
-    case LENS:
-        base = lbase;
-        extra = lext;
-        match = 257;
-        break;
-    default:    /* DISTS */
-        base = dbase;
-        extra = dext;
-        match = 0;
-    }
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-    /* check available table space */
-    if ((type == LENS && used > ENOUGH_LENS) ||
-        (type == DISTS && used > ENOUGH_DISTS))
-        return 1;
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        here.bits = (unsigned char)(len - drop);
-        if (work[sym] + 1U < match) {
-            here.op = (unsigned char)0;
-            here.val = work[sym];
-        }
-        else if (work[sym] >= match) {
-            here.op = (unsigned char)(extra[work[sym] - match]);
-            here.val = base[work[sym] - match];
-        }
-        else {
-            here.op = (unsigned char)(32 + 64);         /* end of block */
-            here.val = 0;
-        }
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = here;
-        } while (fill != 0);
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used > ENOUGH_LENS) ||
-                (type == DISTS && used > ENOUGH_DISTS))
-                return 1;
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-    /* fill in remaining table entry if code is incomplete (guaranteed to have
-       at most one remaining entry, since if the code is incomplete, the
-       maximum code length that was allowed to get this far is one bit) */
-    if (huff != 0) {
-        here.op = (unsigned char)64;            /* invalid code marker */
-        here.bits = (unsigned char)(len - drop);
-        here.val = (unsigned short)0;
-        next[huff] = here;
-    }
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}

--- a/src/native/external/zlib-intel/inftrees.h
+++ b//dev/null
@@ -1,56 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));

--- a/src/native/external/zlib-intel/trees.c
+++ b//dev/null
@@ -1,1028 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2021 Jean-loup Gailly
- * detect_data_type() function provided freely by Cosmin Truta, 2006
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-/* @(#) $Id$ */
-/* #define GEN_TREES_H */
-#include "deflate.h"
-#ifdef ZLIB_DEBUG
-#  include <ctype.h>
-#endif
-/* ===========================================================================
- * Constants
- */
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-ZLIB_INTERNAL ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-local const static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-local const static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-local const static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, const ct_data *ltree,
-                              const ct_data *dtree));
-local int  detect_data_type OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned code, int len));
-local void bi_flush       OF((deflate_state *s));
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-#ifndef ZLIB_DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-#else /* !ZLIB_DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef ZLIB_DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !ZLIB_DEBUG */
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = (int)value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* ZLIB_DEBUG */
-/* the arguments must not have side effects */
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-    if (static_init_done) return;
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1 << extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length - 1] = (uch)code;
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1 << extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256 + dist != 512");
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-/* ===========================================================================
- * Generate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef ZLIB_DEBUG
-#    include <stdio.h>
-#  endif
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width) - 1 ? ",\n" : ", "))
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-    fprintf(header, "ZLIB_INTERNAL const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void ZLIB_INTERNAL _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->sym_next = s->matches = 0;
-}
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-        if (n > max_code) continue; /* not a leaf node */
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n - base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
-        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-    Tracev((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length - 1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;        /* move one leaf down the tree */
-        s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes(tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    unsigned code = 0;         /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        code = (code + bl_count[bits - 1]) << 1;
-        next_code[bits] = (ush)code;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
-    }
-}
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-    /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-    } while (s->heap_len >= 2);
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree(s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code + 1].Len = (ush)0xffff; /* guard */
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n + 1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree(s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-    /* tree[max_code + 1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n + 1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except the
-     * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
-     */
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-    return max_blindex;
-}
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes - 1,   5);
-    send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-/* ===========================================================================
- * Send a stored block
- */
-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */
-    bi_windup(s);        /* align on byte boundary */
-    put_short(s, (ush)stored_len);
-    put_short(s, (ush)~stored_len);
-    if (stored_len)
-        zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
-    s->pending += stored_len;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-    s->bits_sent += 2*16;
-    s->bits_sent += stored_len << 3;
-#endif
-}
-/* ===========================================================================
- * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
- */
-void ZLIB_INTERNAL _tr_flush_bits(s)
-    deflate_state *s;
-{
-    bi_flush(s);
-}
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- */
-void ZLIB_INTERNAL _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef ZLIB_DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-}
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and write out the encoded block.
- */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-        /* Check if the file is binary or text */
-        if (s->strm->data_type == Z_UNKNOWN)
-            s->strm->data_type = detect_data_type(s);
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len + 3 + 7) >> 3;
-        static_lenb = (s->static_len + 3 + 7) >> 3;
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->sym_next / 3));
-#ifndef FORCE_STATIC
-        if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)
-#endif
-            opt_lenb = static_lenb;
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len + 4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, last);
-    } else if (static_lenb == opt_lenb) {
-        send_bits(s, (STATIC_TREES<<1) + last, 3);
-        compress_block(s, (const ct_data *)static_ltree,
-                       (const ct_data *)static_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1) + last, 3);
-        send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,
-                       max_blindex + 1);
-        compress_block(s, (const ct_data *)s->dyn_ltree,
-                       (const ct_data *)s->dyn_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-    if (last) {
-        bi_windup(s);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
-           s->compressed_len - 7*last));
-}
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int ZLIB_INTERNAL _tr_tally(s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length - MIN_MATCH or unmatched char (dist==0) */
-{
-    s->sym_buf[s->sym_next++] = (uch)dist;
-    s->sym_buf[s->sym_next++] = (uch)(dist >> 8);
-    s->sym_buf[s->sym_next++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-        s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-    return (s->sym_next == s->sym_end);
-}
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    const ct_data *ltree; /* literal tree */
-    const ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned sx = 0;    /* running index in sym_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-    if (s->sym_next != 0) do {
-        dist = s->sym_buf[sx++] & 0xff;
-        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;
-        lc = s->sym_buf[sx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code + LITERALS + 1, ltree);   /* send length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= (unsigned)base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-        /* Check that the overlay between pending_buf and sym_buf is ok: */
-        Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
-    } while (sx < s->sym_next);
-    send_code(s, END_BLOCK, ltree);
-}
-/* ===========================================================================
- * Check if the data type is TEXT or BINARY, using the following algorithm:
- * - TEXT if the two conditions below are satisfied:
- *    a) There are no non-portable control characters belonging to the
- *       "block list" (0..6, 14..25, 28..31).
- *    b) There is at least one printable character belonging to the
- *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
- * - BINARY otherwise.
- * - The following partially-portable control characters form a
- *   "gray list" that is ignored in this detection algorithm:
- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local int detect_data_type(s)
-    deflate_state *s;
-{
-    /* block_mask is the bit mask of block-listed bytes
-     * set bits 0..6, 14..25, and 28..31
-     * 0xf3ffc07f = binary 11110011111111111100000001111111
-     */
-    unsigned long block_mask = 0xf3ffc07fUL;
-    int n;
-    /* Check for non-textual ("block-listed") bytes. */
-    for (n = 0; n <= 31; n++, block_mask >>= 1)
-        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))
-            return Z_BINARY;
-    /* Check for textual ("allow-listed") bytes. */
-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
-            || s->dyn_ltree[13].Freq != 0)
-        return Z_TEXT;
-    for (n = 32; n < LITERALS; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            return Z_TEXT;
-    /* There are no "block-listed" or "allow-listed" bytes:
-     * this stream either is empty or has tolerated ("gray-listed") bytes only.
-     */
-    return Z_BINARY;
-}
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-ZLIB_INTERNAL void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->bits_sent = (s->bits_sent + 7) & ~7;
-#endif
-}

--- a/src/native/external/zlib-intel/zconf.h
+++ b//dev/null
@@ -1,501 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#ifndef ZCONF_H
-#define ZCONF_H
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_combine_gen     z_crc32_combine_gen
-#  define crc32_combine_gen64   z_crc32_combine_gen64
-#  define crc32_combine_op      z_crc32_combine_op
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-#endif
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-                        /* Type declarations */
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-#ifndef FAR
-#  define FAR
-#endif
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-#ifndef Z_HAVE_UNISTD_H
-#  ifdef __WATCOMC__
-#    define Z_HAVE_UNISTD_H
-#  endif
-#endif
-#ifndef Z_HAVE_UNISTD_H
-#  if defined(_LARGEFILE64_SOURCE) && !defined(_WIN32)
-#    define Z_HAVE_UNISTD_H
-#  endif
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-#endif /* ZCONF_H */

--- a/src/native/external/zlib-intel/zlib.h
+++ b//dev/null
@@ -1,1643 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.13, October 13th, 2022
-  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
-  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
-*/
-#ifndef ZLIB_H
-#define ZLIB_H
-#include "zconf.h"
-#ifdef __cplusplus
-extern "C" {
-#endif
-#define ZLIB_VERSION "1.2.13"
-#define ZLIB_VERNUM 0x12d0
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 13
-#define ZLIB_VER_SUBREVISION 0
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-    This library can optionally read and write gzip and raw deflate streams in
-  memory as well.
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in the case of corrupted input.
-*/
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-struct internal_state;
-typedef struct z_stream_s {
-    z_const Bytef *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
-    Bytef    *next_out; /* next output byte will go here */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
-    z_const char *msg;  /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-    int     data_type;  /* best guess about the data type: binary or text
-                           for deflate, or the decoding state for inflate */
-    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-typedef z_stream FAR *z_streamp;
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-typedef gz_header FAR *gz_headerp;
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
-   Z_NULL on entry to the initialization function, they are set to internal
-   routines that use the standard library functions malloc() and free().
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use by the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-                        /* constants */
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field for deflate() */
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-                        /* basic functions */
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary.  Some output may be provided even if
-    flush is zero.
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending. See deflatePending(),
-  which can be used if desired to determine whether or not there is more output
-  in that case.
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed
-  codes block.
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
-  function must be called again with Z_FINISH and more output space (updated
-  avail_out) but no more input data, until it returns with Z_STREAM_END or an
-  error.  After deflate has returned Z_STREAM_END, the only possible operations
-  on the stream are deflateReset or deflateEnd.
-    Z_FINISH can be used in the first deflate call after deflateInit if all the
-  compression is to be done in a single step.  In order to complete in one
-  call, avail_out must be at least the value returned by deflateBound (see
-  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
-  output space is provided, deflate will not return Z_STREAM_END, and it must
-  be called again as described above.
-    deflate() sets strm->adler to the Adler-32 checksum of all input read
-  so far (that is, total_in bytes).  If a gzip stream is being generated, then
-  strm->adler will be the CRC-32 checksum of the input read so far.  (See
-  deflateInit2 below.)
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
-  considered binary.  This field is only for information purposes and does not
-  affect the compression algorithm in any manner.
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL or the state was inadvertently written over
-  by the application), or Z_BUF_ERROR if no progress is possible (for example
-  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
-  deflate() can be called again with more input and more output space to
-  continue compressing.
-*/
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  In the current version of inflate, the provided input is not
-   read or consumed.  The allocation of a sliding window will be deferred to
-   the first call of inflate (if the decompression does not complete on the
-   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
-   them to use default allocation functions.
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression.
-   Actual decompression will be done by inflate().  So next_in, and avail_in,
-   next_out, and avail_out are unused and unchanged.  The current
-   implementation of inflateInit() does not process any header information --
-   that is deferred until inflate() is called.
-*/
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), then next_in and avail_in are updated
-    accordingly, and processing will resume at this point for the next call of
-    inflate().
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  If the
-  caller of inflate() does not provide both available input and available
-  output space, it is possible that there will be no progress made.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  To assist in this, on return inflate() always sets strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all of the uncompressed data for the
-  operation to complete.  (The size of the uncompressed data may have been
-  saved by the compressor for this purpose.)  The use of Z_FINISH is not
-  required to perform an inflation in one step.  However it may be used to
-  inform inflate that a faster approach can be used for the single inflate()
-  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
-  stream completes, which reduces inflate's memory footprint.  If the stream
-  does not complete, either because not all of the stream is provided or not
-  enough output space is provided, then a sliding window will be allocated and
-  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
-  been used.
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the effects of the flush parameter in this implementation are
-  on the return value of inflate() as noted below, when inflate() returns early
-  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
-  memory for a sliding window when Z_FINISH is used.
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the Adler-32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed Adler-32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained unless inflateGetHeader() is used.  When processing
-  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
-  uncompressed length, modulo 2^32.
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value, in which case strm->msg points to a string with a more specific
-  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL, or the state was inadvertently written over
-  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
-  if no progress was possible or if there was not enough room in the output
-  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is to be attempted.
-*/
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
-   was inconsistent.
-*/
-                        /* Advanced functions */
-/*
-    The following functions are needed only in some special applications.
-*/
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-     This is another version of deflateInit with more compression options.  The
-   fields zalloc, zfree and opaque must be initialized before by the caller.
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-     For the current implementation of deflate(), a windowBits value of 8 (a
-   window size of 256 bytes) is not supported.  As a result, a request for 8
-   will result in 9 (a 512-byte window).  In that case, providing 8 to
-   inflateInit2() will result in an error when the zlib header with 9 is
-   checked against the initialization of inflate().  The remedy is to not use 8
-   with deflateInit2() with this initialization, or at least in that case use 9
-   with inflateInit2().
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute a check value.
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to the appropriate value,
-   if the operating system was determined at compile time.  If a gzip stream is
-   being written, strm->adler is a CRC-32 instead of an Adler-32.
-     For raw deflate or gzip encoding, a request for a 256-byte window is
-   rejected as invalid, since only the zlib header provides a means of
-   transmitting the window size to the decompressor.
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  When using the zlib format, this
-   function must be called immediately after deflateInit, deflateInit2 or
-   deflateReset, and before any call of deflate.  When doing raw deflate, this
-   function must be called either before any call of deflate, or immediately
-   after the completion of a deflate block, i.e. after all input has been
-   consumed and all output has been delivered when using any of the flush
-   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
-   compressor and decompressor must use exactly the same dictionary (see
-   inflateSetDictionary).
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-     Upon return of this function, strm->adler is set to the Adler-32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The Adler-32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   Adler-32 value is not computed and strm->adler is not set.
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if not at a block boundary for raw deflate).  deflateSetDictionary does
-   not perform any compression: this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by deflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If deflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similarly, if dictLength is Z_NULL, then it is not set.
-     deflateGetDictionary() may return a length less than the window size, even
-   when more than the window size in input has been provided. It may return up
-   to 258 bytes less in that case, due to how zlib's implementation of deflate
-   manages the sliding window and lookahead for matches, where matches can be
-   up to 258 bytes long. If the application needs the last window-size bytes of
-   input, then that would need to be saved by the application outside of zlib.
-     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit, but
-   does not free and reallocate the internal compression state.  The stream
-   will leave the compression level and any other attributes that may have been
-   set unchanged.
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2().  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression approach (which is a function of the level) or the
-   strategy is changed, and if there have been any deflate() calls since the
-   state was initialized or reset, then the input available so far is
-   compressed with the old level and strategy using deflate(strm, Z_BLOCK).
-   There are three approaches for the compression levels 0, 1..3, and 4..9
-   respectively.  The new level and strategy will take effect at the next call
-   of deflate().
-     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
-   not have enough output space to complete, then the parameter change will not
-   take effect.  In this case, deflateParams() can be called again with the
-   same parameters and more output space to try again.
-     In order to assure a change in the parameters on the first try, the
-   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
-   request until strm.avail_out is not zero, before calling deflateParams().
-   Then no more input data should be provided before the deflateParams() call.
-   If this is done, the old level and strategy will be applied to the data
-   compressed before deflateParams(), and the new level and strategy will be
-   applied to the the data compressed after deflateParams().
-     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
-   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
-   there was not enough output space to complete the compression of the
-   available input data before a change in the strategy or approach.  Note that
-   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
-   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
-   retried with more output space.
-*/
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().  If that first deflate() call is provided the
-   sourceLen input bytes, an output buffer allocated to the size returned by
-   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
-   to return Z_STREAM_END.  Note that it is possible for the compressed size to
-   be larger than the value returned by deflateBound() if flush options other
-   than Z_FINISH or Z_NO_FLUSH are used.
-*/
-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
-                                       unsigned *pending,
-                                       int *bits));
-/*
-     deflatePending() returns the number of bytes and bits of output that have
-   been generated, but not yet provided in the available output.  The bytes not
-   provided would be due to the available output space having being consumed.
-   The number of bits of output not provided are between 0 and 7, where they
-   await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
-     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
- */
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
-   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
-   source stream state was inconsistent.
-*/
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
-   below), inflate() will *not* automatically decode concatenated gzip members.
-   inflate() will return Z_STREAM_END at the end of the gzip member.  The state
-   would need to be reset to continue decoding a subsequent gzip member.  This
-   *must* be done if there is more data after a gzip member, in order for the
-   decompression to be compliant with the gzip standard (RFC 1952).
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the Adler-32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called at any
-   time to set the dictionary.  If the provided dictionary is smaller than the
-   window and there is already data in the window, then the provided dictionary
-   will amend what's there.  The application must insure that the dictionary
-   that was used for compression is provided.
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by inflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If inflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similarly, if dictLength is Z_NULL, then it is not set.
-     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a possible full flush point (see above
-   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
-   All full flush points have this pattern, but not all occurrences of this
-   pattern are full flush points.
-     inflateSync returns Z_OK if a possible full flush point has been found,
-   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
-   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
-   In the success case, the application may save the current current value of
-   total_in which indicates where valid compressed data was found.  In the
-   error case, the application may repeatedly call inflateSync, providing more
-   input each time, until success or end of the input data.
-*/
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.  If the window size is changed, then the
-   memory allocated for the window is freed, and the window will be reallocated
-   by inflate() if needed.
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-     inflateMark returns the value noted above, or -65536 if the provided
-   source stream state was inconsistent.
-*/
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-     See inflateBack() for the usage of these routines.
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-typedef unsigned (*in_func) OF((void FAR *,
-                                z_const unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is potentially more efficient than
-   inflate() for file i/o applications, in that it avoids copying between the
-   output and the sliding window by simply making the window itself the output
-   buffer.  inflate() can be faster on modern CPUs when used with large
-   buffers.  inflateBack() trusts the application to not change the output
-   buffer passed by the output function, at least until inflateBack() returns.
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the default
-   behavior of inflate(), which expects a zlib header and trailer around the
-   deflate stream.
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero -- buf is ignored in that
-   case -- and inflateBack() will return a buffer error.  inflateBack() will
-   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
-   out() should return zero on success, or non-zero on failure.  If out()
-   returns non-zero, inflateBack() will return with an error.  Neither in() nor
-   out() are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.)  Note that inflateBack()
-   cannot return Z_OK.
-*/
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-    Compiler, assembler, and debug options:
-     8: ZLIB_DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-    Remainder:
-     27-31: 0 (reserved)
- */
-#ifndef Z_SOLO
-                        /* utility functions */
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.  compress() is equivalent to compress2() with a level
-   parameter of Z_DEFAULT_COMPRESSION.
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed data.
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
-   the case where there is not enough room, uncompress() will fill the output
-   buffer with the uncompressed data up to that point.
-*/
-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
-                                    const Bytef *source, uLong *sourceLen));
-/*
-     Same as uncompress, except that sourceLen is a pointer, where the
-   length of the source is *sourceLen.  On return, *sourceLen is the number of
-   source bytes consumed.
-*/
-                        /* gzip file access functions */
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-     Open the gzip (.gz) file at path for reading and decompressing, or
-   compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")
-   but can also include a compression level ("wb9") or a strategy: 'f' for
-   filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",
-   'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression
-   as in "wb9F".  (See the description of deflateInit2 for more information
-   about the strategy parameter.)  'T' will request transparent writing or
-   appending with no compression and not using the gzip format.
-     "a" can be used instead of "w" to request that the gzip stream that will
-   be written be appended to the file.  "+" will result in an error, since
-   reading and writing to the same gzip file is not supported.  The addition of
-   "x" when writing will create the file exclusively, which fails if the file
-   already exists.  On systems that support it, the addition of "e" when
-   reading or writing will set the flag to close the file on an execve() call.
-     These functions, as well as gzip, will read and decode a sequence of gzip
-   streams in a file.  The append function of gzopen() can be used to create
-   such a file.  (Also see gzflush() for another way to do this.)  When
-   appending, gzopen does not test whether the file begins with a gzip stream,
-   nor does it look for the end of the gzip streams to begin appending.  gzopen
-   will simply append a gzip stream to the existing file.
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.  When
-   reading, this will be detected automatically by looking for the magic two-
-   byte gzip header.
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     Associate a gzFile with the file descriptor fd.  File descriptors are
-   obtained from calls like open, dup, creat, pipe or fileno (if the file has
-   been previously opened with fopen).  The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.  If you are using fileno() to get the
-   file descriptor from a FILE *, then you will have to use dup() to avoid
-   double-close()ing the file descriptor.  Both gzclose() and fclose() will
-   close the associated file descriptor, so they need to have different file
-   descriptors.
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions for file to
-   size.  The default buffer size is 8192 bytes.  This function must be called
-   after gzopen() or gzdopen(), and before any other calls that read or write
-   the file.  The buffer memory allocation is always deferred to the first read
-   or write.  Three times that size in buffer space is allocated.  A larger
-   buffer size of, for example, 64K or 128K bytes will noticeably increase the
-   speed of decompression (reading).
-     The new buffer size also affects the maximum length for gzprintf().
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level and strategy for file.  See the
-   description of deflateInit2 for the meaning of these parameters. Previously
-   provided data is flushed before applying the parameter changes.
-     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
-   opened for writing, Z_ERRNO if there is an error writing the flushed data,
-   or Z_MEM_ERROR if there is a memory allocation error.
-*/
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Read and decompress up to len uncompressed bytes from file into buf.  If
-   the input file is not in gzip format, gzread copies the given number of
-   bytes into the buffer directly from the file.
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream.  Any number of gzip streams may be
-   concatenated in the input file, and will all be decompressed by gzread().
-   If something other than a gzip stream is encountered after a gzip stream,
-   that remaining trailing garbage is ignored (and no error is returned).
-     gzread can be used to read a gzip file that is being concurrently written.
-   Upon reaching the end of the input, gzread will return with the available
-   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
-   gzclearerr can be used to clear the end of file indicator in order to permit
-   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
-   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
-   middle of a gzip stream.  Note that gzread does not return -1 in the event
-   of an incomplete gzip stream.  This error is deferred until gzclose(), which
-   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
-   stream.  Alternatively, gzerror can be used before gzclose to detect this
-   case.
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.  If len is too large to fit in an int,
-   then nothing is read, -1 is returned, and the error state is set to
-   Z_STREAM_ERROR.
-*/
-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
-                                     gzFile file));
-/*
-     Read and decompress up to nitems items of size size from file into buf,
-   otherwise operating as gzread() does.  This duplicates the interface of
-   stdio's fread(), with size_t request and return types.  If the library
-   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t
-   is an unsigned integer type that can contain a pointer.
-     gzfread() returns the number of full items read of size size, or zero if
-   the end of the file was reached and a full item could not be read, or if
-   there was an error.  gzerror() must be consulted if zero is returned in
-   order to determine if there was an error.  If the multiplication of size and
-   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
-   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
-     In the event that the end of file is reached and only a partial item is
-   available at the end, i.e. the remaining uncompressed data length is not a
-   multiple of size, then the final partial item is nevertheless read into buf
-   and the end-of-file flag is set.  The length of the partial item read is not
-   provided, but could be inferred from the result of gztell().  This behavior
-   is the same as the behavior of fread() implementations in common libraries,
-   but it prevents the direct use of gzfread() to read a concurrently written
-   file, resetting and retrying on end-of-file, when size is not 1.
-*/
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));
-/*
-     Compress and write the len uncompressed bytes at buf to file. gzwrite
-   returns the number of uncompressed bytes written or 0 in case of error.
-*/
-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
-                                      z_size_t nitems, gzFile file));
-/*
-     Compress and write nitems items of size size from buf to file, duplicating
-   the interface of stdio's fwrite(), with size_t request and return types.  If
-   the library defines size_t, then z_size_t is identical to size_t.  If not,
-   then z_size_t is an unsigned integer type that can contain a pointer.
-     gzfwrite() returns the number of full items written of size size, or zero
-   if there was an error.  If the multiplication of size and nitems overflows,
-   i.e. the product does not fit in a z_size_t, then nothing is written, zero
-   is returned, and the error state is set to Z_STREAM_ERROR.
-*/
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
-/*
-     Convert, format, compress, and write the arguments (...) to file under
-   control of the string format, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or a negative zlib error code in case
-   of error.  The number of uncompressed bytes written is limited to 8191, or
-   one less than the buffer size given to gzbuffer().  The caller should assure
-   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
-   return an error (0) with nothing written.  In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf(),
-   because the secure snprintf() or vsnprintf() functions were not available.
-   This can be determined using zlibCompileFlags().
-*/
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Compress and write the given null-terminated string s to file, excluding
-   the terminating null character.
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Read and decompress bytes from file into buf, until len-1 characters are
-   read, or until a newline character is read and transferred to buf, or an
-   end-of-file condition is encountered.  If any characters are read or if len
-   is one, the string is terminated with a null character.  If no characters
-   are read due to an end-of-file or len is less than one, then the buffer is
-   left untouched.
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Compress and write c, converted to an unsigned char, into file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Read and decompress one byte from file.  gzgetc returns this byte or -1
-   in case of end of file or error.  This is implemented as a macro for speed.
-   As such, it does not do all of the checking the other functions do.  I.e.
-   it does not check to see if file is NULL, nor whether the structure file
-   points to has been clobbered or not.
-*/
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push c back onto the stream for file to be read as the first character on
-   the next read.  At least one character of push-back is always allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flush all pending output to file.  The parameter flush is as in the
-   deflate() function.  The return value is the zlib error number (see function
-   gzerror below).  gzflush is only permitted when writing.
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatenated gzip streams.
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-     Set the starting position to offset relative to whence for the next gzread
-   or gzwrite on file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewind file. This function is supported only for reading.
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).
-*/
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-     Return the starting position for the next gzread or gzwrite on file.
-   This position represents a number of bytes in the uncompressed data stream,
-   and is zero when starting, even if appending or reading a gzip stream from
-   the middle of a file using gzdopen().
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-     Return the current compressed (actual) read or write offset of file.  This
-   offset includes the count of bytes that precede the gzip stream, for example
-   when appending or when using gzdopen() for reading.  When reading, the
-   offset does not include as yet unused buffered input.  This information can
-   be used for a progress indicator.  On error, gzoffset() returns -1.
-*/
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Return true (1) if the end-of-file indicator for file has been set while
-   reading, false (0) otherwise.  Note that the end-of-file indicator is set
-   only if the read tried to go past the end of the input, but came up short.
-   Therefore, just like feof(), gzeof() may return false even if there is no
-   more data to read, in the event that the last read request was for the exact
-   number of bytes remaining in the input file.  This will happen if the input
-   file size is an exact multiple of the buffer size.
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Return true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-     When writing, gzdirect() returns true (1) if transparent writing was
-   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
-   gzdirect() is not needed when writing.  Transparent writing must be
-   explicitly requested, so the application already knows the answer.  When
-   linking statically, using gzdirect() will include all of the zlib code for
-   gzip file reading and decompression, which may not be desired.)
-*/
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flush all pending output for file, if necessary, close file and
-   deallocate the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
-   last read ended in the middle of a gzip stream, or Z_OK on success.
-*/
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Return the error message for the last error which occurred on file.
-   errnum is set to zlib error number.  If an error occurred in the file system
-   and not in the compression library, errnum is set to Z_ERRNO and the
-   application may consult errno to get the exact error code.
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clear the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-#endif /* !Z_SOLO */
-                        /* checksum functions */
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. An Adler-32 value is in the range of a 32-bit
-   unsigned integer. If buf is Z_NULL, this function returns the required
-   initial value for the checksum.
-     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
-   much faster.
-   Usage example:
-     uLong adler = adler32(0L, Z_NULL, 0);
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
-                                    z_size_t len));
-/*
-     Same as adler32(), but with a size_t length.
-*/
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
-*/
-ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.
-   If buf is Z_NULL, this function returns the required initial value for the
-   crc. Pre- and post-conditioning (one's complement) is performed within this
-   function so it shouldn't be done by the application.
-   Usage example:
-     uLong crc = crc32(0L, Z_NULL, 0);
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,
-                                  z_size_t len));
-/*
-     Same as crc32(), but with a size_t length.
-*/
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-/*
-ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));
-     Return the operator corresponding to length len2, to be used with
-   crc32_combine_op().
-*/
-ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));
-/*
-     Give the same result as crc32_combine(), using op in place of len2. op is
-   is generated from len2 by crc32_combine_gen(). This will be faster than
-   crc32_combine() if the generated op is used more than once.
-*/
-                        /* various hacks, don't look :) */
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#ifdef Z_PREFIX_SET
-#  define z_deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define z_inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#else
-#  define deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#endif
-#ifndef Z_SOLO
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#endif
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));
-#endif
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#    define z_crc32_combine_gen z_crc32_combine_gen64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#    define crc32_combine_gen crc32_combine_gen64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
-#endif
-#else /* Z_SOLO */
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
-#endif /* !Z_SOLO */
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));
-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
-#if defined(_WIN32) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
-                                            const char *mode));
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
-                                                  const char *format,
-                                                  va_list va));
-#  endif
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif /* ZLIB_H */

--- a/src/native/external/zlib-intel/zutil.c
+++ b//dev/null
@@ -1,278 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2017 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#include "zutil.h"
-#ifndef Z_SOLO
-#  include "gzguts.h"
-#endif
-z_const char * const z_errmsg[10] = {
-    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
-    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
-    (z_const char *)"",                    /* Z_OK              0  */
-    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
-    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
-    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
-    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
-    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
-    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
-    (z_const char *)""
-};
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-    flags = 0;
-    switch ((int)(sizeof(uInt))) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch ((int)(sizeof(uLong))) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch ((int)(sizeof(voidpf))) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch ((int)(sizeof(z_off_t))) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef ZLIB_DEBUG
-    flags += 1 << 8;
-#endif
-    /*
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-     */
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifdef NO_vsnprintf
-    flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#else
-    flags += 1L << 24;
-#  ifdef NO_snprintf
-    flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-#ifdef ZLIB_DEBUG
-#include <stdlib.h>
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int ZLIB_INTERNAL z_verbose = verbose;
-void ZLIB_INTERNAL z_error(m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-#if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
-    /* The older Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-#ifndef HAVE_MEMCPY
-void ZLIB_INTERNAL zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-int ZLIB_INTERNAL zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-void ZLIB_INTERNAL zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-#ifndef Z_SOLO
-#ifdef SYS16BIT
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-#  define MY_ZCALLOC
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-#define MAX_PTR 10
-/* 10*64K = 640K */
-local int next_ptr = 0;
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf;
-    ulg bsize = (ulg)items*size;
-    (void)opaque;
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
-{
-    int n;
-    (void)opaque;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    Assert(0, "zcfree: ptr not found");
-}
-#endif /* __TURBOC__ */
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-#  define MY_ZCALLOC
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)
-{
-    (void)opaque;
-    return _halloc((long)items, size);
-}
-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
-{
-    (void)opaque;
-    _hfree(ptr);
-}
-#endif /* M_I86 */
-#endif /* SYS16BIT */
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    (void)opaque;
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-void ZLIB_INTERNAL zcfree(opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    (void)opaque;
-    free(ptr);
-}
-#endif /* MY_ZCALLOC */
-#endif /* !Z_SOLO */

--- a/src/native/external/zlib-intel/zutil.h
+++ b//dev/null
@@ -1,253 +0,0 @@
-/* zutil.h -- internal interface and configuration of the compression library
- * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-/* @(#) $Id$ */
-#ifndef ZUTIL_H
-#define ZUTIL_H
-#include "x86.h"
-#ifdef HAVE_HIDDEN
-#  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
-#else
-#  define ZLIB_INTERNAL
-#endif
-#include "zlib.h"
-#if defined(STDC) && !defined(Z_SOLO)
-#  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
-#    include <stddef.h>
-#  endif
-#  include <string.h>
-#  include <stdlib.h>
-#endif
-#ifndef local
-#  define local static
-#endif
-/* since "static" is used to mean two completely different things in C, we
-   define "local" for the non-static meaning of "static", for readability
-   (compile with -Dlocal if your debugger can't find static symbols) */
-typedef unsigned char  uch;
-typedef uch FAR uchf;
-typedef unsigned short ush;
-typedef ush FAR ushf;
-typedef unsigned long  ulg;
-#if !defined(Z_U8) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (ULONG_MAX == 0xffffffffffffffff)
-#    define Z_U8 unsigned long
-#  elif (ULLONG_MAX == 0xffffffffffffffff)
-#    define Z_U8 unsigned long long
-#  elif (UINT_MAX == 0xffffffffffffffff)
-#    define Z_U8 unsigned
-#  endif
-#endif
-extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
-/* (size given to avoid silly warnings with Visual C++) */
-#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
-#define ERR_RETURN(strm,err) \
-  return (strm->msg = ERR_MSG(err), (err))
-/* To be used only when the state is known to be valid */
-        /* common constants */
-#ifndef DEF_WBITS
-#  define DEF_WBITS MAX_WBITS
-#endif
-/* default windowBits for decompression. MAX_WBITS is for compression only */
-#if MAX_MEM_LEVEL >= 8
-#  define DEF_MEM_LEVEL 8
-#else
-#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
-#endif
-/* default memLevel */
-#define STORED_BLOCK 0
-#define STATIC_TREES 1
-#define DYN_TREES    2
-/* The three kinds of block type */
-#define MIN_MATCH  3
-#define MAX_MATCH  258
-/* The minimum and maximum match lengths */
-#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
-        /* target dependencies */
-#if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
-#  define OS_CODE  0x00
-#  ifndef Z_SOLO
-#    if defined(__TURBOC__) || defined(__BORLANDC__)
-#      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
-         /* Allow compilation with ANSI keywords only enabled */
-         void _Cdecl farfree( void *block );
-         void *_Cdecl farmalloc( unsigned long nbytes );
-#      else
-#        include <alloc.h>
-#      endif
-#    else /* MSC or DJGPP */
-#      include <malloc.h>
-#    endif
-#  endif
-#endif
-#ifdef AMIGA
-#  define OS_CODE  1
-#endif
-#if defined(VAXC) || defined(VMS)
-#  define OS_CODE  2
-#  define F_OPEN(name, mode) \
-     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
-#endif
-#ifdef __370__
-#  if __TARGET_LIB__ < 0x20000000
-#    define OS_CODE 4
-#  elif __TARGET_LIB__ < 0x40000000
-#    define OS_CODE 11
-#  else
-#    define OS_CODE 8
-#  endif
-#endif
-#if defined(ATARI) || defined(atarist)
-#  define OS_CODE  5
-#endif
-#ifdef OS2
-#  define OS_CODE  6
-#  if defined(M_I86) && !defined(Z_SOLO)
-#    include <malloc.h>
-#  endif
-#endif
-#if defined(MACOS) || defined(TARGET_OS_MAC)
-#  define OS_CODE  7
-#  ifndef Z_SOLO
-#    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
-#      include <unix.h> /* for fdopen */
-#    else
-#      ifndef fdopen
-#        define fdopen(fd,mode) NULL /* No fdopen() */
-#      endif
-#    endif
-#  endif
-#endif
-#ifdef __acorn
-#  define OS_CODE 13
-#endif
-#if defined(WIN32) && !defined(__CYGWIN__)
-#  define OS_CODE  10
-#endif
-#ifdef _BEOS_
-#  define OS_CODE  16
-#endif
-#ifdef __TOS_OS400__
-#  define OS_CODE 18
-#endif
-#ifdef __APPLE__
-#  define OS_CODE 19
-#endif
-#if defined(_BEOS_) || defined(RISCOS)
-#  define fdopen(fd,mode) NULL /* No fdopen() */
-#endif
-#if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
-#  if defined(_WIN32_WCE)
-#    define fdopen(fd,mode) NULL /* No fdopen() */
-#  else
-#    define fdopen(fd,type)  _fdopen(fd,type)
-#  endif
-#endif
-#if defined(__BORLANDC__) && !defined(MSDOS)
-  #pragma warn -8004
-  #pragma warn -8008
-  #pragma warn -8066
-#endif
-#if defined(__GNUC__)
-#  define zlikely(x)    __builtin_expect(!!(x), 1)
-#  define zunlikely(x)  __builtin_expect(!!(x), 0)
-#else
-#  define zlikely(x)    x
-#  define zunlikely(x)  x
-#endif
-#if defined(_MSC_VER)
-#define zalign(x)        __declspec(align(x))
-#else
-#define zalign(x)        __attribute__((aligned((x))))
-#endif
-#if defined(_MSC_VER)
-#define zalways_inline    __forceinline
-#else
-#define zalways_inline    __attribute__((always_inline))
-#endif
-/* provide prototypes for these when building zlib without LFS */
-#if !defined(_WIN32) && \
-    (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
-    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-    ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
-#endif
-        /* common defaults */
-#ifndef OS_CODE
-#  define OS_CODE  3     /* assume Unix */
-#endif
-#ifndef F_OPEN
-#  define F_OPEN(name, mode) fopen((name), (mode))
-#endif
-         /* functions */
-#if defined(pyr) || defined(Z_SOLO)
-#  define NO_MEMCPY
-#endif
-#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
- /* Use our own functions for small and medium model with MSC <= 5.0.
-  * You may have to use the same strategy for Borland C (untested).
-  * The __SC__ check is for Symantec.
-  */
-#  define NO_MEMCPY
-#endif
-#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
-#  define HAVE_MEMCPY
-#endif
-#ifdef HAVE_MEMCPY
-#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
-#    define zmemcpy _fmemcpy
-#    define zmemcmp _fmemcmp
-#    define zmemzero(dest, len) _fmemset(dest, 0, len)
-#  elif HAVE_INTEL_MEMCPY
-#    include "rte_memcpy.h"
-#    define zmemcpy rte_memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  else
-#    define zmemcpy memcpy
-#    define zmemcmp memcmp
-#    define zmemzero(dest, len) memset(dest, 0, len)
-#  endif
-#else
-   void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
-   int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
-   void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
-#endif
-/* Diagnostic functions */
-#ifdef ZLIB_DEBUG
-#  include <stdio.h>
-   extern int ZLIB_INTERNAL z_verbose;
-   extern void ZLIB_INTERNAL z_error OF((char *m));
-#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
-#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
-#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
-#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
-#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
-#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
-#else
-#  define Assert(cond,msg)
-#  define Trace(x)
-#  define Tracev(x)
-#  define Tracevv(x)
-#  define Tracec(c,x)
-#  define Tracecv(c,x)
-#endif
-#ifndef Z_SOLO
-   voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
-                                    unsigned size));
-   void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
-#endif
-#define ZALLOC(strm, items, size) \
-           (*((strm)->zalloc))((strm)->opaque, (items), (size))
-#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
-#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
-/* Reverse the bytes in a 32-bit value */
-#define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
-                    (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
-#endif /* ZUTIL_H */

--- a/src/native/external/zlib/compress.c
+++ b//dev/null
@@ -1,74 +0,0 @@
-/* compress.c -- compress a memory buffer
- * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#define ZLIB_INTERNAL
-#include "zlib.h"
-/* ===========================================================================
-     Compresses the source buffer into the destination buffer. The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer. Upon entry, destLen is the total size of the
-   destination buffer, which must be at least 0.1% larger than sourceLen plus
-   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-int ZEXPORT compress2(dest, destLen, source, sourceLen, level)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-    int level;
-{
-    z_stream stream;
-    int err;
-    const uInt max = (uInt)-1;
-    uLong left;
-    left = *destLen;
-    *destLen = 0;
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-    err = deflateInit(&stream, level);
-    if (err != Z_OK) return err;
-    stream.next_out = dest;
-    stream.avail_out = 0;
-    stream.next_in = (z_const Bytef *)source;
-    stream.avail_in = 0;
-    do {
-        if (stream.avail_out == 0) {
-            stream.avail_out = left > (uLong)max ? max : (uInt)left;
-            left -= stream.avail_out;
-        }
-        if (stream.avail_in == 0) {
-            stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
-            sourceLen -= stream.avail_in;
-        }
-        err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
-    } while (err == Z_OK);
-    *destLen = stream.total_out;
-    deflateEnd(&stream);
-    return err == Z_STREAM_END ? Z_OK : err;
-}
-/* ===========================================================================
- */
-int ZEXPORT compress(dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
-}
-/* ===========================================================================
-     If the default memLevel or windowBits for deflateInit() is changed, then
-   this function needs to be updated.
- */
-uLong ZEXPORT compressBound(sourceLen)
-    uLong sourceLen;
-{
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13;
-}

--- a/src/native/external/zlib/crc32.c
+++ b//dev/null
@@ -1,1011 +0,0 @@
-/* crc32.c -- compute the CRC-32 of a data stream
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- *
- * This interleaved implementation of a CRC makes use of pipelined multiple
- * arithmetic-logic units, commonly found in modern CPU cores. It is due to
- * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.
- */
-/* @(#) $Id$ */
-/*
-  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
-  protection on the static variables used to control the first-use generation
-  of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should
-  first call get_crc_table() to initialize the tables before allowing more than
-  one thread to use crc32().
-  MAKECRCH can be #defined to write out crc32.h. A main() routine is also
-  produced, so that this one source file can be compiled to an executable.
- */
-#ifdef MAKECRCH
-#  include <stdio.h>
-#  ifndef DYNAMIC_CRC_TABLE
-#    define DYNAMIC_CRC_TABLE
-#  endif /* !DYNAMIC_CRC_TABLE */
-#endif /* MAKECRCH */
-#include "zutil.h"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */
- /*
-  A CRC of a message is computed on N braids of words in the message, where
-  each word consists of W bytes (4 or 8). If N is 3, for example, then three
-  running sparse CRCs are calculated respectively on each braid, at these
-  indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...
-  This is done starting at a word boundary, and continues until as many blocks
-  of N * W bytes as are available have been processed. The results are combined
-  into a single CRC at the end. For this code, N must be in the range 1..6 and
-  W must be 4 or 8. The upper limit on N can be increased if desired by adding
-  more #if blocks, extending the patterns apparent in the code. In addition,
-  crc32.h would need to be regenerated, if the maximum N value is increased.
-  N and W are chosen empirically by benchmarking the execution time on a given
-  processor. The choices for N and W below were based on testing on Intel Kaby
-  Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64
-  Octeon II processors. The Intel, AMD, and ARM processors were all fastest
-  with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.
-  They were all tested with either gcc or clang, all using the -O3 optimization
-  level. Your mileage may vary.
- */
-/* Define N */
-#ifdef Z_TESTN
-#  define N Z_TESTN
-#else
-#  define N 5
-#endif
-#if N < 1 || N > 6
-#  error N must be in 1..6
-#endif
-/*
-  z_crc_t must be at least 32 bits. z_word_t must be at least as long as
-  z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and
-  that bytes are eight bits.
- */
-/*
-  Define W and the associated z_word_t type. If W is not defined, then a
-  braided calculation is not used, and the associated tables and code are not
-  compiled.
- */
-#ifdef Z_TESTW
-#  if Z_TESTW-1 != -1
-#    define W Z_TESTW
-#  endif
-#else
-#  ifdef MAKECRCH
-#    define W 8         /* required for MAKECRCH */
-#  else
-#    if defined(__x86_64__) || defined(__aarch64__)
-#      define W 8
-#    else
-#      define W 4
-#    endif
-#  endif
-#endif
-#ifdef W
-#  if W == 8 && defined(Z_U8)
-     typedef Z_U8 z_word_t;
-#  elif defined(Z_U4)
-#    undef W
-#    define W 4
-     typedef Z_U4 z_word_t;
-#  else
-#    undef W
-#  endif
-#endif
-/* If available, use the ARM processor CRC32 instruction. */
-#if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8
-#  define ARMCRC32
-#endif
-/* Local functions. */
-local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));
-local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));
-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
-    local z_word_t byte_swap OF((z_word_t word));
-#endif
-#if defined(W) && !defined(ARMCRC32)
-    local z_crc_t crc_word OF((z_word_t data));
-    local z_word_t crc_word_big OF((z_word_t data));
-#endif
-#if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
-/*
-  Swap the bytes in a z_word_t to convert between little and big endian. Any
-  self-respecting compiler will optimize this to a single machine byte-swap
-  instruction, if one is available. This assumes that word_t is either 32 bits
-  or 64 bits.
- */
-local z_word_t byte_swap(word)
-    z_word_t word;
-{
-#  if W == 8
-    return
-        (word & 0xff00000000000000) >> 56 |
-        (word & 0xff000000000000) >> 40 |
-        (word & 0xff0000000000) >> 24 |
-        (word & 0xff00000000) >> 8 |
-        (word & 0xff000000) << 8 |
-        (word & 0xff0000) << 24 |
-        (word & 0xff00) << 40 |
-        (word & 0xff) << 56;
-#  else   /* W == 4 */
-    return
-        (word & 0xff000000) >> 24 |
-        (word & 0xff0000) >> 8 |
-        (word & 0xff00) << 8 |
-        (word & 0xff) << 24;
-#  endif
-}
-#endif
-/* CRC polynomial. */
-#define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */
-#ifdef DYNAMIC_CRC_TABLE
-local z_crc_t FAR crc_table[256];
-local z_crc_t FAR x2n_table[32];
-local void make_crc_table OF((void));
-#ifdef W
-   local z_word_t FAR crc_big_table[256];
-   local z_crc_t FAR crc_braid_table[W][256];
-   local z_word_t FAR crc_braid_big_table[W][256];
-   local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));
-#endif
-#ifdef MAKECRCH
-   local void write_table OF((FILE *, const z_crc_t FAR *, int));
-   local void write_table32hi OF((FILE *, const z_word_t FAR *, int));
-   local void write_table64 OF((FILE *, const z_word_t FAR *, int));
-#endif /* MAKECRCH */
-/*
-  Define a once() function depending on the availability of atomics. If this is
-  compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in
-  multiple threads, and if atomics are not available, then get_crc_table() must
-  be called to initialize the tables and must return before any threads are
-  allowed to compute or combine CRCs.
- */
-/* Definition of once functionality. */
-typedef struct once_s once_t;
-local void once OF((once_t *, void (*)(void)));
-/* Check for the availability of atomics. */
-#if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \
-    !defined(__STDC_NO_ATOMICS__)
-#include <stdatomic.h>
-/* Structure for once(), which must be initialized with ONCE_INIT. */
-struct once_s {
-    atomic_flag begun;
-    atomic_int done;
-};
-#define ONCE_INIT {ATOMIC_FLAG_INIT, 0}
-/*
-  Run the provided init() function exactly once, even if multiple threads
-  invoke once() at the same time. The state must be a once_t initialized with
-  ONCE_INIT.
- */
-local void once(state, init)
-    once_t *state;
-    void (*init)(void);
-{
-    if (!atomic_load(&state->done)) {
-        if (atomic_flag_test_and_set(&state->begun))
-            while (!atomic_load(&state->done))
-                ;
-        else {
-            init();
-            atomic_store(&state->done, 1);
-        }
-    }
-}
-#else   /* no atomics */
-/* Structure for once(), which must be initialized with ONCE_INIT. */
-struct once_s {
-    volatile int begun;
-    volatile int done;
-};
-#define ONCE_INIT {0, 0}
-/* Test and set. Alas, not atomic, but tries to minimize the period of
-   vulnerability. */
-local int test_and_set OF((int volatile *));
-local int test_and_set(flag)
-    int volatile *flag;
-{
-    int was;
-    was = *flag;
-    *flag = 1;
-    return was;
-}
-/* Run the provided init() function once. This is not thread-safe. */
-local void once(state, init)
-    once_t *state;
-    void (*init)(void);
-{
-    if (!state->done) {
-        if (test_and_set(&state->begun))
-            while (!state->done)
-                ;
-        else {
-            init();
-            state->done = 1;
-        }
-    }
-}
-#endif
-/* State for once(). */
-local once_t made = ONCE_INIT;
-/*
-  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
-  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
-  Polynomials over GF(2) are represented in binary, one bit per coefficient,
-  with the lowest powers in the most significant bit. Then adding polynomials
-  is just exclusive-or, and multiplying a polynomial by x is a right shift by
-  one. If we call the above polynomial p, and represent a byte as the
-  polynomial q, also with the lowest power in the most significant bit (so the
-  byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,
-  where a mod b means the remainder after dividing a by b.
-  This calculation is done using the shift-register method of multiplying and
-  taking the remainder. The register is initialized to zero, and for each
-  incoming bit, x^32 is added mod p to the register if the bit is a one (where
-  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x
-  (which is shifting right by one and adding x^32 mod p if the bit shifted out
-  is a one). We start with the highest power (least significant bit) of q and
-  repeat for all eight bits of q.
-  The table is simply the CRC of all possible eight bit values. This is all the
-  information needed to generate CRCs on data a byte at a time for all
-  combinations of CRC register values and incoming bytes.
- */
-local void make_crc_table()
-{
-    unsigned i, j, n;
-    z_crc_t p;
-    /* initialize the CRC of bytes tables */
-    for (i = 0; i < 256; i++) {
-        p = i;
-        for (j = 0; j < 8; j++)
-            p = p & 1 ? (p >> 1) ^ POLY : p >> 1;
-        crc_table[i] = p;
-#ifdef W
-        crc_big_table[i] = byte_swap(p);
-#endif
-    }
-    /* initialize the x^2^n mod p(x) table */
-    p = (z_crc_t)1 << 30;         /* x^1 */
-    x2n_table[0] = p;
-    for (n = 1; n < 32; n++)
-        x2n_table[n] = p = multmodp(p, p);
-#ifdef W
-    /* initialize the braiding tables -- needs x2n_table[] */
-    braid(crc_braid_table, crc_braid_big_table, N, W);
-#endif
-#ifdef MAKECRCH
-    {
-        /*
-          The crc32.h header file contains tables for both 32-bit and 64-bit
-          z_word_t's, and so requires a 64-bit type be available. In that case,
-          z_word_t must be defined to be 64-bits. This code then also generates
-          and writes out the tables for the case that z_word_t is 32 bits.
-         */
-#if !defined(W) || W != 8
-#  error Need a 64-bit integer type in order to generate crc32.h.
-#endif
-        FILE *out;
-        int k, n;
-        z_crc_t ltl[8][256];
-        z_word_t big[8][256];
-        out = fopen("crc32.h", "w");
-        if (out == NULL) return;
-        /* write out little-endian CRC table to crc32.h */
-        fprintf(out,
-            "/* crc32.h -- tables for rapid CRC calculation\n"
-            " * Generated automatically by crc32.c\n */\n"
-            "\n"
-            "local const z_crc_t FAR crc_table[] = {\n"
-            "    ");
-        write_table(out, crc_table, 256);
-        fprintf(out,
-            "};\n");
-        /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */
-        fprintf(out,
-            "\n"
-            "#ifdef W\n"
-            "\n"
-            "#if W == 8\n"
-            "\n"
-            "local const z_word_t FAR crc_big_table[] = {\n"
-            "    ");
-        write_table64(out, crc_big_table, 256);
-        fprintf(out,
-            "};\n");
-        /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */
-        fprintf(out,
-            "\n"
-            "#else /* W == 4 */\n"
-            "\n"
-            "local const z_word_t FAR crc_big_table[] = {\n"
-            "    ");
-        write_table32hi(out, crc_big_table, 256);
-        fprintf(out,
-            "};\n"
-            "\n"
-            "#endif\n");
-        /* write out braid tables for each value of N */
-        for (n = 1; n <= 6; n++) {
-            fprintf(out,
-            "\n"
-            "#if N == %d\n", n);
-            /* compute braid tables for this N and 64-bit word_t */
-            braid(ltl, big, n, 8);
-            /* write out braid tables for 64-bit z_word_t to crc32.h */
-            fprintf(out,
-            "\n"
-            "#if W == 8\n"
-            "\n"
-            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
-            for (k = 0; k < 8; k++) {
-                fprintf(out, "   {");
-                write_table(out, ltl[k], 256);
-                fprintf(out, "}%s", k < 7 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
-            for (k = 0; k < 8; k++) {
-                fprintf(out, "   {");
-                write_table64(out, big[k], 256);
-                fprintf(out, "}%s", k < 7 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n");
-            /* compute braid tables for this N and 32-bit word_t */
-            braid(ltl, big, n, 4);
-            /* write out braid tables for 32-bit z_word_t to crc32.h */
-            fprintf(out,
-            "\n"
-            "#else /* W == 4 */\n"
-            "\n"
-            "local const z_crc_t FAR crc_braid_table[][256] = {\n");
-            for (k = 0; k < 4; k++) {
-                fprintf(out, "   {");
-                write_table(out, ltl[k], 256);
-                fprintf(out, "}%s", k < 3 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
-            for (k = 0; k < 4; k++) {
-                fprintf(out, "   {");
-                write_table32hi(out, big[k], 256);
-                fprintf(out, "}%s", k < 3 ? ",\n" : "");
-            }
-            fprintf(out,
-            "};\n"
-            "\n"
-            "#endif\n"
-            "\n"
-            "#endif\n");
-        }
-        fprintf(out,
-            "\n"
-            "#endif\n");
-        /* write out zeros operator table to crc32.h */
-        fprintf(out,
-            "\n"
-            "local const z_crc_t FAR x2n_table[] = {\n"
-            "    ");
-        write_table(out, x2n_table, 32);
-        fprintf(out,
-            "};\n");
-        fclose(out);
-    }
-#endif /* MAKECRCH */
-}
-#ifdef MAKECRCH
-/*
-   Write the 32-bit values in table[0..k-1] to out, five per line in
-   hexadecimal separated by commas.
- */
-local void write_table(out, table, k)
-    FILE *out;
-    const z_crc_t FAR *table;
-    int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
-                (unsigned long)(table[n]),
-                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
-}
-/*
-   Write the high 32-bits of each value in table[0..k-1] to out, five per line
-   in hexadecimal separated by commas.
- */
-local void write_table32hi(out, table, k)
-FILE *out;
-const z_word_t FAR *table;
-int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
-                (unsigned long)(table[n] >> 32),
-                n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
-}
-/*
-  Write the 64-bit values in table[0..k-1] to out, three per line in
-  hexadecimal separated by commas. This assumes that if there is a 64-bit
-  type, then there is also a long long integer type, and it is at least 64
-  bits. If not, then the type cast and format string can be adjusted
-  accordingly.
- */
-local void write_table64(out, table, k)
-    FILE *out;
-    const z_word_t FAR *table;
-    int k;
-{
-    int n;
-    for (n = 0; n < k; n++)
-        fprintf(out, "%s0x%016llx%s", n == 0 || n % 3 ? "" : "    ",
-                (unsigned long long)(table[n]),
-                n == k - 1 ? "" : (n % 3 == 2 ? ",\n" : ", "));
-}
-/* Actually do the deed. */
-int main()
-{
-    make_crc_table();
-    return 0;
-}
-#endif /* MAKECRCH */
-#ifdef W
-/*
-  Generate the little and big-endian braid tables for the given n and z_word_t
-  size w. Each array must have room for w blocks of 256 elements.
- */
-local void braid(ltl, big, n, w)
-    z_crc_t ltl[][256];
-    z_word_t big[][256];
-    int n;
-    int w;
-{
-    int k;
-    z_crc_t i, p, q;
-    for (k = 0; k < w; k++) {
-        p = x2nmodp((n * w + 3 - k) << 3, 0);
-        ltl[k][0] = 0;
-        big[w - 1 - k][0] = 0;
-        for (i = 1; i < 256; i++) {
-            ltl[k][i] = q = multmodp(i << 24, p);
-            big[w - 1 - k][i] = byte_swap(q);
-        }
-    }
-}
-#endif
-#else /* !DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Tables for byte-wise and braided CRC-32 calculations, and a table of powers
- * of x for combining CRC-32s, all made by make_crc_table().
- */
-#include "crc32.h"
-#endif /* DYNAMIC_CRC_TABLE */
-/* ========================================================================
- * Routines used for CRC calculation. Some are also required for the table
- * generation above.
- */
-/*
-  Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,
-  reflected. For speed, this requires that a not be zero.
- */
-local z_crc_t multmodp(a, b)
-    z_crc_t a;
-    z_crc_t b;
-{
-    z_crc_t m, p;
-    m = (z_crc_t)1 << 31;
-    p = 0;
-    for (;;) {
-        if (a & m) {
-            p ^= b;
-            if ((a & (m - 1)) == 0)
-                break;
-        }
-        m >>= 1;
-        b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
-    }
-    return p;
-}
-/*
-  Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been
-  initialized.
- */
-local z_crc_t x2nmodp(n, k)
-    z_off64_t n;
-    unsigned k;
-{
-    z_crc_t p;
-    p = (z_crc_t)1 << 31;           /* x^0 == 1 */
-    while (n) {
-        if (n & 1)
-            p = multmodp(x2n_table[k & 31], p);
-        n >>= 1;
-        k++;
-    }
-    return p;
-}
-/* =========================================================================
- * This function can be used by asm versions of crc32(), and to force the
- * generation of the CRC tables in a threaded application.
- */
-const z_crc_t FAR * ZEXPORT get_crc_table()
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return (const z_crc_t FAR *)crc_table;
-}
-/* =========================================================================
- * Use ARM machine instructions if available. This will compute the CRC about
- * ten times faster than the braided calculation. This code does not check for
- * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will
- * only be defined if the compilation specifies an ARM processor architecture
- * that has the instructions. For example, compiling with -march=armv8.1-a or
- * -march=armv8-a+crc, or -march=native if the compile machine has the crc32
- * instructions.
- */
-#ifdef ARMCRC32
-/*
-   Constants empirically determined to maximize speed. These values are from
-   measurements on a Cortex-A57. Your mileage may vary.
- */
-#define Z_BATCH 3990                /* number of words in a batch */
-#define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */
-#define Z_BATCH_MIN 800             /* fewest words in a final batch */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    z_crc_t val;
-    z_word_t crc1, crc2;
-    const z_word_t *word;
-    z_word_t val0, val1, val2;
-    z_size_t last, last2, i;
-    z_size_t num;
-    /* Return initial CRC, if requested. */
-    if (buf == Z_NULL) return 0;
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    /* Pre-condition the CRC */
-    crc = (~crc) & 0xffffffff;
-    /* Compute the CRC up to a word boundary. */
-    while (len && ((z_size_t)buf & 7) != 0) {
-        len--;
-        val = *buf++;
-        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
-    }
-    /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */
-    word = (z_word_t const *)buf;
-    num = len >> 3;
-    len &= 7;
-    /* Do three interleaved CRCs to realize the throughput of one crc32x
-       instruction per cycle. Each CRC is calculated on Z_BATCH words. The
-       three CRCs are combined into a single CRC after each set of batches. */
-    while (num >= 3 * Z_BATCH) {
-        crc1 = 0;
-        crc2 = 0;
-        for (i = 0; i < Z_BATCH; i++) {
-            val0 = word[i];
-            val1 = word[i + Z_BATCH];
-            val2 = word[i + 2 * Z_BATCH];
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
-        }
-        word += 3 * Z_BATCH;
-        num -= 3 * Z_BATCH;
-        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;
-        crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;
-    }
-    /* Do one last smaller batch with the remaining words, if there are enough
-       to pay for the combination of CRCs. */
-    last = num / 3;
-    if (last >= Z_BATCH_MIN) {
-        last2 = last << 1;
-        crc1 = 0;
-        crc2 = 0;
-        for (i = 0; i < last; i++) {
-            val0 = word[i];
-            val1 = word[i + last];
-            val2 = word[i + last2];
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
-            __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
-        }
-        word += 3 * last;
-        num -= 3 * last;
-        val = x2nmodp(last, 6);
-        crc = multmodp(val, crc) ^ crc1;
-        crc = multmodp(val, crc) ^ crc2;
-    }
-    /* Compute the CRC on any remaining words. */
-    for (i = 0; i < num; i++) {
-        val0 = word[i];
-        __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
-    }
-    word += num;
-    /* Complete the CRC on any remaining bytes. */
-    buf = (const unsigned char FAR *)word;
-    while (len) {
-        len--;
-        val = *buf++;
-        __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
-    }
-    /* Return the CRC, post-conditioned. */
-    return crc ^ 0xffffffff;
-}
-#else
-#ifdef W
-/*
-  Return the CRC of the W bytes in the word_t data, taking the
-  least-significant byte of the word as the first byte of data, without any pre
-  or post conditioning. This is used to combine the CRCs of each braid.
- */
-local z_crc_t crc_word(data)
-    z_word_t data;
-{
-    int k;
-    for (k = 0; k < W; k++)
-        data = (data >> 8) ^ crc_table[data & 0xff];
-    return (z_crc_t)data;
-}
-local z_word_t crc_word_big(data)
-    z_word_t data;
-{
-    int k;
-    for (k = 0; k < W; k++)
-        data = (data << 8) ^
-            crc_big_table[(data >> ((W - 1) << 3)) & 0xff];
-    return data;
-}
-#endif
-/* ========================================================================= */
-unsigned long ZEXPORT crc32_z(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    z_size_t len;
-{
-    /* Return initial CRC, if requested. */
-    if (buf == Z_NULL) return 0;
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    /* Pre-condition the CRC */
-    crc = (~crc) & 0xffffffff;
-#ifdef W
-    /* If provided enough bytes, do a braided CRC calculation. */
-    if (len >= N * W + W - 1) {
-        z_size_t blks;
-        z_word_t const *words;
-        unsigned endian;
-        int k;
-        /* Compute the CRC up to a z_word_t boundary. */
-        while (len && ((z_size_t)buf & (W - 1)) != 0) {
-            len--;
-            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        }
-        /* Compute the CRC on as many N z_word_t blocks as are available. */
-        blks = len / (N * W);
-        len -= blks * N * W;
-        words = (z_word_t const *)buf;
-        /* Do endian check at execution time instead of compile time, since ARM
-           processors can change the endianess at execution time. If the
-           compiler knows what the endianess will be, it can optimize out the
-           check and the unused branch. */
-        endian = 1;
-        if (*(unsigned char *)&endian) {
-            /* Little endian. */
-            z_crc_t crc0;
-            z_word_t word0;
-#if N > 1
-            z_crc_t crc1;
-            z_word_t word1;
-#if N > 2
-            z_crc_t crc2;
-            z_word_t word2;
-#if N > 3
-            z_crc_t crc3;
-            z_word_t word3;
-#if N > 4
-            z_crc_t crc4;
-            z_word_t word4;
-#if N > 5
-            z_crc_t crc5;
-            z_word_t word5;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /* Initialize the CRC for each braid. */
-            crc0 = crc;
-#if N > 1
-            crc1 = 0;
-#if N > 2
-            crc2 = 0;
-#if N > 3
-            crc3 = 0;
-#if N > 4
-            crc4 = 0;
-#if N > 5
-            crc5 = 0;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /*
-              Process the first blks-1 blocks, computing the CRCs on each braid
-              independently.
-             */
-            while (--blks) {
-                /* Load the word for each braid into registers. */
-                word0 = crc0 ^ words[0];
-#if N > 1
-                word1 = crc1 ^ words[1];
-#if N > 2
-                word2 = crc2 ^ words[2];
-#if N > 3
-                word3 = crc3 ^ words[3];
-#if N > 4
-                word4 = crc4 ^ words[4];
-#if N > 5
-                word5 = crc5 ^ words[5];
-#endif
-#endif
-#endif
-#endif
-#endif
-                words += N;
-                /* Compute and update the CRC for each word. The loop should
-                   get unrolled. */
-                crc0 = crc_braid_table[0][word0 & 0xff];
-#if N > 1
-                crc1 = crc_braid_table[0][word1 & 0xff];
-#if N > 2
-                crc2 = crc_braid_table[0][word2 & 0xff];
-#if N > 3
-                crc3 = crc_braid_table[0][word3 & 0xff];
-#if N > 4
-                crc4 = crc_braid_table[0][word4 & 0xff];
-#if N > 5
-                crc5 = crc_braid_table[0][word5 & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                for (k = 1; k < W; k++) {
-                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
-#if N > 1
-                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
-#if N > 2
-                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
-#if N > 3
-                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
-#if N > 4
-                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
-#if N > 5
-                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                }
-            }
-            /*
-              Process the last block, combining the CRCs of the N braids at the
-              same time.
-             */
-            crc = crc_word(crc0 ^ words[0]);
-#if N > 1
-            crc = crc_word(crc1 ^ words[1] ^ crc);
-#if N > 2
-            crc = crc_word(crc2 ^ words[2] ^ crc);
-#if N > 3
-            crc = crc_word(crc3 ^ words[3] ^ crc);
-#if N > 4
-            crc = crc_word(crc4 ^ words[4] ^ crc);
-#if N > 5
-            crc = crc_word(crc5 ^ words[5] ^ crc);
-#endif
-#endif
-#endif
-#endif
-#endif
-            words += N;
-        }
-        else {
-            /* Big endian. */
-            z_word_t crc0, word0, comb;
-#if N > 1
-            z_word_t crc1, word1;
-#if N > 2
-            z_word_t crc2, word2;
-#if N > 3
-            z_word_t crc3, word3;
-#if N > 4
-            z_word_t crc4, word4;
-#if N > 5
-            z_word_t crc5, word5;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /* Initialize the CRC for each braid. */
-            crc0 = byte_swap(crc);
-#if N > 1
-            crc1 = 0;
-#if N > 2
-            crc2 = 0;
-#if N > 3
-            crc3 = 0;
-#if N > 4
-            crc4 = 0;
-#if N > 5
-            crc5 = 0;
-#endif
-#endif
-#endif
-#endif
-#endif
-            /*
-              Process the first blks-1 blocks, computing the CRCs on each braid
-              independently.
-             */
-            while (--blks) {
-                /* Load the word for each braid into registers. */
-                word0 = crc0 ^ words[0];
-#if N > 1
-                word1 = crc1 ^ words[1];
-#if N > 2
-                word2 = crc2 ^ words[2];
-#if N > 3
-                word3 = crc3 ^ words[3];
-#if N > 4
-                word4 = crc4 ^ words[4];
-#if N > 5
-                word5 = crc5 ^ words[5];
-#endif
-#endif
-#endif
-#endif
-#endif
-                words += N;
-                /* Compute and update the CRC for each word. The loop should
-                   get unrolled. */
-                crc0 = crc_braid_big_table[0][word0 & 0xff];
-#if N > 1
-                crc1 = crc_braid_big_table[0][word1 & 0xff];
-#if N > 2
-                crc2 = crc_braid_big_table[0][word2 & 0xff];
-#if N > 3
-                crc3 = crc_braid_big_table[0][word3 & 0xff];
-#if N > 4
-                crc4 = crc_braid_big_table[0][word4 & 0xff];
-#if N > 5
-                crc5 = crc_braid_big_table[0][word5 & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                for (k = 1; k < W; k++) {
-                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
-#if N > 1
-                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
-#if N > 2
-                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
-#if N > 3
-                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
-#if N > 4
-                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
-#if N > 5
-                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
-#endif
-#endif
-#endif
-#endif
-#endif
-                }
-            }
-            /*
-              Process the last block, combining the CRCs of the N braids at the
-              same time.
-             */
-            comb = crc_word_big(crc0 ^ words[0]);
-#if N > 1
-            comb = crc_word_big(crc1 ^ words[1] ^ comb);
-#if N > 2
-            comb = crc_word_big(crc2 ^ words[2] ^ comb);
-#if N > 3
-            comb = crc_word_big(crc3 ^ words[3] ^ comb);
-#if N > 4
-            comb = crc_word_big(crc4 ^ words[4] ^ comb);
-#if N > 5
-            comb = crc_word_big(crc5 ^ words[5] ^ comb);
-#endif
-#endif
-#endif
-#endif
-#endif
-            words += N;
-            crc = byte_swap(comb);
-        }
-        /*
-          Update the pointer to the remaining bytes to process.
-         */
-        buf = (unsigned char const *)words;
-    }
-#endif /* W */
-    /* Complete the computation of the CRC on any remaining bytes. */
-    while (len >= 8) {
-        len -= 8;
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-    }
-    while (len) {
-        len--;
-        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
-    }
-    /* Return the CRC, post-conditioned. */
-    return crc ^ 0xffffffff;
-}
-#endif
-/* ========================================================================= */
-unsigned long ZEXPORT crc32(crc, buf, len)
-    unsigned long crc;
-    const unsigned char FAR *buf;
-    uInt len;
-{
-    return crc32_z(crc, buf, len);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off64_t len2;
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine(crc1, crc2, len2)
-    uLong crc1;
-    uLong crc2;
-    z_off_t len2;
-{
-    return crc32_combine64(crc1, crc2, (z_off64_t)len2);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_gen64(len2)
-    z_off64_t len2;
-{
-#ifdef DYNAMIC_CRC_TABLE
-    once(&made, make_crc_table);
-#endif /* DYNAMIC_CRC_TABLE */
-    return x2nmodp(len2, 3);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_gen(len2)
-    z_off_t len2;
-{
-    return crc32_combine_gen64((z_off64_t)len2);
-}
-/* ========================================================================= */
-uLong ZEXPORT crc32_combine_op(crc1, crc2, op)
-    uLong crc1;
-    uLong crc2;
-    uLong op;
-{
-    return multmodp(op, crc1) ^ (crc2 & 0xffffffff);
-}

--- a/src/native/external/zlib/deflate.c
+++ b//dev/null
@@ -1,1999 +0,0 @@
-/* deflate.c -- compress data using the deflation algorithm
- * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- *  ALGORITHM
- *
- *      The "deflation" process depends on being able to identify portions
- *      of the input text which are identical to earlier input (within a
- *      sliding window trailing behind the input currently being processed).
- *
- *      The most straightforward technique turns out to be the fastest for
- *      most input files: try all possible matches and select the longest.
- *      The key feature of this algorithm is that insertions into the string
- *      dictionary are very simple and thus fast, and deletions are avoided
- *      completely. Insertions are performed at each input character, whereas
- *      string matches are performed only when the previous match ends. So it
- *      is preferable to spend more time in matches to allow very fast string
- *      insertions and avoid deletions. The matching algorithm for small
- *      strings is inspired from that of Rabin & Karp. A brute force approach
- *      is used to find longer strings when a small match has been found.
- *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
- *      (by Leonid Broukhis).
- *         A previous version of this file used a more sophisticated algorithm
- *      (by Fiala and Greene) which is guaranteed to run in linear amortized
- *      time, but has a larger average cost, uses more memory and is patented.
- *      However the F&G algorithm may be faster for some highly redundant
- *      files if the parameter max_chain_length (described below) is too large.
- *
- *  ACKNOWLEDGEMENTS
- *
- *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
- *      I found it in 'freeze' written by Leonid Broukhis.
- *      Thanks to many people for bug reports and testing.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
- *      Available in http://tools.ietf.org/html/rfc1951
- *
- *      A description of the Rabin and Karp algorithm is given in the book
- *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
- *
- *      Fiala,E.R., and Greene,D.H.
- *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
- *
- */
-/* @(#) $Id$ */
-#include "deflate.h"
-const char deflate_copyright[] =
-   " deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-/* ===========================================================================
- *  Function prototypes.
- */
-typedef enum {
-    need_more,      /* block not completed, need more input or more output */
-    block_done,     /* block flush performed */
-    finish_started, /* finish started, need only more output at next deflate */
-    finish_done     /* finish done, accept no more input or output */
-} block_state;
-typedef block_state (*compress_func) OF((deflate_state *s, int flush));
-/* Compression function. Returns the block state after the call. */
-local int deflateStateCheck      OF((z_streamp strm));
-local void slide_hash     OF((deflate_state *s));
-local void fill_window    OF((deflate_state *s));
-local block_state deflate_stored OF((deflate_state *s, int flush));
-local block_state deflate_fast   OF((deflate_state *s, int flush));
-#ifndef FASTEST
-local block_state deflate_slow   OF((deflate_state *s, int flush));
-#endif
-local block_state deflate_rle    OF((deflate_state *s, int flush));
-local block_state deflate_huff   OF((deflate_state *s, int flush));
-local void lm_init        OF((deflate_state *s));
-local void putShortMSB    OF((deflate_state *s, uInt b));
-local void flush_pending  OF((z_streamp strm));
-local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
-local uInt longest_match  OF((deflate_state *s, IPos cur_match));
-#ifdef ZLIB_DEBUG
-local  void check_match OF((deflate_state *s, IPos start, IPos match,
-                            int length));
-#endif
-/* ===========================================================================
- * Local data
- */
-#define NIL 0
-/* Tail of hash chains */
-#ifndef TOO_FAR
-#  define TOO_FAR 4096
-#endif
-/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
-/* Values for max_lazy_match, good_match and max_chain_length, depending on
- * the desired pack level (0..9). The values given below have been tuned to
- * exclude worst case performance for pathological files. Better values may be
- * found for specific files.
- */
-typedef struct config_s {
-   ush good_length; /* reduce lazy search above this match length */
-   ush max_lazy;    /* do not perform lazy search above this match length */
-   ush nice_length; /* quit search above this match length */
-   ush max_chain;
-   compress_func func;
-} config;
-#ifdef FASTEST
-local const config configuration_table[2] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
-#else
-local const config configuration_table[10] = {
-/*      good lazy nice chain */
-/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
-/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
-/* 2 */ {4,    5, 16,    8, deflate_fast},
-/* 3 */ {4,    6, 32,   32, deflate_fast},
-/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
-/* 5 */ {8,   16, 32,   32, deflate_slow},
-/* 6 */ {8,   16, 128, 128, deflate_slow},
-/* 7 */ {8,   32, 128, 256, deflate_slow},
-/* 8 */ {32, 128, 258, 1024, deflate_slow},
-/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
-#endif
-/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
- * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
- * meaning.
- */
-/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
-#define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
-/* ===========================================================================
- * Update a hash value with the given input byte
- * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
- *    characters, so that a running hash key can be computed from the previous
- *    key instead of complete recalculation each time.
- */
-#define UPDATE_HASH(s,h,c) (h = (((h) << s->hash_shift) ^ (c)) & s->hash_mask)
-/* ===========================================================================
- * Insert string str in the dictionary and set match_head to the previous head
- * of the hash chain (the most recent string with same hash key). Return
- * the previous length of the hash chain.
- * If this file is compiled with -DFASTEST, the compression level is forced
- * to 1, and no hash chains are maintained.
- * IN  assertion: all calls to INSERT_STRING are made with consecutive input
- *    characters and the first MIN_MATCH bytes of str are valid (except for
- *    the last MIN_MATCH-1 bytes of the input file).
- */
-#ifdef FASTEST
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#else
-#define INSERT_STRING(s, str, match_head) \
-   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
-    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
-    s->head[s->ins_h] = (Pos)(str))
-#endif
-/* ===========================================================================
- * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
- * prev[] will be initialized on the fly.
- */
-#define CLEAR_HASH(s) \
-    do { \
-        s->head[s->hash_size - 1] = NIL; \
-        zmemzero((Bytef *)s->head, \
-                 (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \
-    } while (0)
-/* ===========================================================================
- * Slide the hash table when sliding the window down (could be avoided with 32
- * bit values at the expense of memory usage). We slide even when level == 0 to
- * keep the hash table consistent if we switch back to level > 0 later.
- */
-local void slide_hash(s)
-    deflate_state *s;
-{
-    unsigned n, m;
-    Posf *p;
-    uInt wsize = s->w_size;
-    n = s->hash_size;
-    p = &s->head[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-    } while (--n);
-    n = wsize;
-#ifndef FASTEST
-    p = &s->prev[n];
-    do {
-        m = *--p;
-        *p = (Pos)(m >= wsize ? m - wsize : NIL);
-        /* If n is not on any hash chain, prev[n] is garbage but
-         * its value will never be used.
-         */
-    } while (--n);
-#endif
-}
-/* ========================================================================= */
-int ZEXPORT deflateInit_(strm, level, version, stream_size)
-    z_streamp strm;
-    int level;
-    const char *version;
-    int stream_size;
-{
-    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
-                         Z_DEFAULT_STRATEGY, version, stream_size);
-    /* To do: ignore strm->next_in if we use it as window */
-}
-/* ========================================================================= */
-int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
-                  version, stream_size)
-    z_streamp strm;
-    int  level;
-    int  method;
-    int  windowBits;
-    int  memLevel;
-    int  strategy;
-    const char *version;
-    int stream_size;
-{
-    deflate_state *s;
-    int wrap = 1;
-    static const char my_version[] = ZLIB_VERSION;
-    if (version == Z_NULL || version[0] != my_version[0] ||
-        stream_size != sizeof(z_stream)) {
-        return Z_VERSION_ERROR;
-    }
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (windowBits < 0) { /* suppress zlib wrapper */
-        wrap = 0;
-        if (windowBits < -15)
-            return Z_STREAM_ERROR;
-        windowBits = -windowBits;
-    }
-#ifdef GZIP
-    else if (windowBits > 15) {
-        wrap = 2;       /* write gzip wrapper instead */
-        windowBits -= 16;
-    }
-#endif
-    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
-        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
-        strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
-        return Z_STREAM_ERROR;
-    }
-    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
-    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
-    if (s == Z_NULL) return Z_MEM_ERROR;
-    strm->state = (struct internal_state FAR *)s;
-    s->strm = strm;
-    s->status = INIT_STATE;     /* to pass state test in deflateReset() */
-    s->wrap = wrap;
-    s->gzhead = Z_NULL;
-    s->w_bits = (uInt)windowBits;
-    s->w_size = 1 << s->w_bits;
-    s->w_mask = s->w_size - 1;
-    s->hash_bits = (uInt)memLevel + 7;
-    s->hash_size = 1 << s->hash_bits;
-    s->hash_mask = s->hash_size - 1;
-    s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
-    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
-    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
-    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
-    s->high_water = 0;      /* nothing written to s->window yet */
-    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
-    /* We overlay pending_buf and sym_buf. This works since the average size
-     * for length/distance pairs over any compressed block is assured to be 31
-     * bits or less.
-     *
-     * Analysis: The longest fixed codes are a length code of 8 bits plus 5
-     * extra bits, for lengths 131 to 257. The longest fixed distance codes are
-     * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
-     * possible fixed-codes length/distance pair is then 31 bits total.
-     *
-     * sym_buf starts one-fourth of the way into pending_buf. So there are
-     * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
-     * in sym_buf is three bytes -- two for the distance and one for the
-     * literal/length. As each symbol is consumed, the pointer to the next
-     * sym_buf value to read moves forward three bytes. From that symbol, up to
-     * 31 bits are written to pending_buf. The closest the written pending_buf
-     * bits gets to the next sym_buf symbol to read is just before the last
-     * code is written. At that time, 31*(n - 2) bits have been written, just
-     * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
-     * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
-     * symbols are written.) The closest the writing gets to what is unread is
-     * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
-     * can range from 128 to 32768.
-     *
-     * Therefore, at a minimum, there are 142 bits of space between what is
-     * written and what is read in the overlain buffers, so the symbols cannot
-     * be overwritten by the compressed data. That space is actually 139 bits,
-     * due to the three-bit fixed-code block header.
-     *
-     * That covers the case where either Z_FIXED is specified, forcing fixed
-     * codes, or when the use of fixed codes is chosen, because that choice
-     * results in a smaller compressed block than dynamic codes. That latter
-     * condition then assures that the above analysis also covers all dynamic
-     * blocks. A dynamic-code block will only be chosen to be emitted if it has
-     * fewer bits than a fixed-code block would for the same set of symbols.
-     * Therefore its average symbol length is assured to be less than 31. So
-     * the compressed data for a dynamic block also cannot overwrite the
-     * symbols from which it is being constructed.
-     */
-    s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);
-    s->pending_buf_size = (ulg)s->lit_bufsize * 4;
-    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
-        s->pending_buf == Z_NULL) {
-        s->status = FINISH_STATE;
-        strm->msg = ERR_MSG(Z_MEM_ERROR);
-        deflateEnd (strm);
-        return Z_MEM_ERROR;
-    }
-    s->sym_buf = s->pending_buf + s->lit_bufsize;
-    s->sym_end = (s->lit_bufsize - 1) * 3;
-    /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
-     * on 16 bit machines and because stored blocks are restricted to
-     * 64K-1 bytes.
-     */
-    s->level = level;
-    s->strategy = strategy;
-    s->method = (Byte)method;
-    return deflateReset(strm);
-}
-/* =========================================================================
- * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
- */
-local int deflateStateCheck(strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    s = strm->state;
-    if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
-#ifdef GZIP
-                                           s->status != GZIP_STATE &&
-#endif
-                                           s->status != EXTRA_STATE &&
-                                           s->status != NAME_STATE &&
-                                           s->status != COMMENT_STATE &&
-                                           s->status != HCRC_STATE &&
-                                           s->status != BUSY_STATE &&
-                                           s->status != FINISH_STATE))
-        return 1;
-    return 0;
-}
-/* ========================================================================= */
-int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)
-    z_streamp strm;
-    const Bytef *dictionary;
-    uInt  dictLength;
-{
-    deflate_state *s;
-    uInt str, n;
-    int wrap;
-    unsigned avail;
-    z_const unsigned char *next;
-    if (deflateStateCheck(strm) || dictionary == Z_NULL)
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    wrap = s->wrap;
-    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
-        return Z_STREAM_ERROR;
-    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
-    if (wrap == 1)
-        strm->adler = adler32(strm->adler, dictionary, dictLength);
-    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
-    /* if dictionary would fill window, just replace the history */
-    if (dictLength >= s->w_size) {
-        if (wrap == 0) {            /* already empty otherwise */
-            CLEAR_HASH(s);
-            s->strstart = 0;
-            s->block_start = 0L;
-            s->insert = 0;
-        }
-        dictionary += dictLength - s->w_size;  /* use the tail */
-        dictLength = s->w_size;
-    }
-    /* insert dictionary into window and hash */
-    avail = strm->avail_in;
-    next = strm->next_in;
-    strm->avail_in = dictLength;
-    strm->next_in = (z_const Bytef *)dictionary;
-    fill_window(s);
-    while (s->lookahead >= MIN_MATCH) {
-        str = s->strstart;
-        n = s->lookahead - (MIN_MATCH-1);
-        do {
-            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-            s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-            s->head[s->ins_h] = (Pos)str;
-            str++;
-        } while (--n);
-        s->strstart = str;
-        s->lookahead = MIN_MATCH-1;
-        fill_window(s);
-    }
-    s->strstart += s->lookahead;
-    s->block_start = (long)s->strstart;
-    s->insert = s->lookahead;
-    s->lookahead = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    strm->next_in = next;
-    strm->avail_in = avail;
-    s->wrap = wrap;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)
-    z_streamp strm;
-    Bytef *dictionary;
-    uInt  *dictLength;
-{
-    deflate_state *s;
-    uInt len;
-    if (deflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    s = strm->state;
-    len = s->strstart + s->lookahead;
-    if (len > s->w_size)
-        len = s->w_size;
-    if (dictionary != Z_NULL && len)
-        zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
-    if (dictLength != Z_NULL)
-        *dictLength = len;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateResetKeep(strm)
-    z_streamp strm;
-{
-    deflate_state *s;
-    if (deflateStateCheck(strm)) {
-        return Z_STREAM_ERROR;
-    }
-    strm->total_in = strm->total_out = 0;
-    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
-    strm->data_type = Z_UNKNOWN;
-    s = (deflate_state *)strm->state;
-    s->pending = 0;
-    s->pending_out = s->pending_buf;
-    if (s->wrap < 0) {
-        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
-    }
-    s->status =
-#ifdef GZIP
-        s->wrap == 2 ? GZIP_STATE :
-#endif
-        INIT_STATE;
-    strm->adler =
-#ifdef GZIP
-        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
-#endif
-        adler32(0L, Z_NULL, 0);
-    s->last_flush = -2;
-    _tr_init(s);
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateReset(strm)
-    z_streamp strm;
-{
-    int ret;
-    ret = deflateResetKeep(strm);
-    if (ret == Z_OK)
-        lm_init(strm->state);
-    return ret;
-}
-/* ========================================================================= */
-int ZEXPORT deflateSetHeader(strm, head)
-    z_streamp strm;
-    gz_headerp head;
-{
-    if (deflateStateCheck(strm) || strm->state->wrap != 2)
-        return Z_STREAM_ERROR;
-    strm->state->gzhead = head;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflatePending(strm, pending, bits)
-    unsigned *pending;
-    int *bits;
-    z_streamp strm;
-{
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    if (pending != Z_NULL)
-        *pending = strm->state->pending;
-    if (bits != Z_NULL)
-        *bits = strm->state->bi_valid;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflatePrime(strm, bits, value)
-    z_streamp strm;
-    int bits;
-    int value;
-{
-    deflate_state *s;
-    int put;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    if (bits < 0 || bits > 16 ||
-        s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
-        return Z_BUF_ERROR;
-    do {
-        put = Buf_size - s->bi_valid;
-        if (put > bits)
-            put = bits;
-        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
-        s->bi_valid += put;
-        _tr_flush_bits(s);
-        value >>= put;
-        bits -= put;
-    } while (bits);
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateParams(strm, level, strategy)
-    z_streamp strm;
-    int level;
-    int strategy;
-{
-    deflate_state *s;
-    compress_func func;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-#ifdef FASTEST
-    if (level != 0) level = 1;
-#else
-    if (level == Z_DEFAULT_COMPRESSION) level = 6;
-#endif
-    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
-        return Z_STREAM_ERROR;
-    }
-    func = configuration_table[s->level].func;
-    if ((strategy != s->strategy || func != configuration_table[level].func) &&
-        s->last_flush != -2) {
-        /* Flush the last buffer: */
-        int err = deflate(strm, Z_BLOCK);
-        if (err == Z_STREAM_ERROR)
-            return err;
-        if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
-            return Z_BUF_ERROR;
-    }
-    if (s->level != level) {
-        if (s->level == 0 && s->matches != 0) {
-            if (s->matches == 1)
-                slide_hash(s);
-            else
-                CLEAR_HASH(s);
-            s->matches = 0;
-        }
-        s->level = level;
-        s->max_lazy_match   = configuration_table[level].max_lazy;
-        s->good_match       = configuration_table[level].good_length;
-        s->nice_match       = configuration_table[level].nice_length;
-        s->max_chain_length = configuration_table[level].max_chain;
-    }
-    s->strategy = strategy;
-    return Z_OK;
-}
-/* ========================================================================= */
-int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
-    z_streamp strm;
-    int good_length;
-    int max_lazy;
-    int nice_length;
-    int max_chain;
-{
-    deflate_state *s;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    s = strm->state;
-    s->good_match = (uInt)good_length;
-    s->max_lazy_match = (uInt)max_lazy;
-    s->nice_match = nice_length;
-    s->max_chain_length = (uInt)max_chain;
-    return Z_OK;
-}
-/* =========================================================================
- * For the default windowBits of 15 and memLevel of 8, this function returns a
- * close to exact, as well as small, upper bound on the compressed size. This
- * is an expansion of ~0.03%, plus a small constant.
- *
- * For any setting other than those defaults for windowBits and memLevel, one
- * of two worst case bounds is returned. This is at most an expansion of ~4% or
- * ~13%, plus a small constant.
- *
- * Both the 0.03% and 4% derive from the overhead of stored blocks. The first
- * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second
- * is for stored blocks of 127 bytes (the worst case memLevel == 1). The
- * expansion results from five bytes of header for each stored block.
- *
- * The larger expansion of 13% results from a window size less than or equal to
- * the symbols buffer size (windowBits <= memLevel + 7). In that case some of
- * the data being compressed may have slid out of the sliding window, impeding
- * a stored block from being emitted. Then the only choice is a fixed or
- * dynamic block, where a fixed block limits the maximum expansion to 9 bits
- * per 8-bit byte, plus 10 bits for every block. The smallest block size for
- * which this can occur is 255 (memLevel == 2).
- *
- * Shifts are used to approximate divisions, for speed.
- */
-uLong ZEXPORT deflateBound(strm, sourceLen)
-    z_streamp strm;
-    uLong sourceLen;
-{
-    deflate_state *s;
-    uLong fixedlen, storelen, wraplen;
-    /* upper bound for fixed blocks with 9-bit literals and length 255
-       (memLevel == 2, which is the lowest that may not use stored blocks) --
-       ~13% overhead plus a small constant */
-    fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +
-               (sourceLen >> 9) + 4;
-    /* upper bound for stored blocks with length 127 (memLevel == 1) --
-       ~4% overhead plus a small constant */
-    storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +
-               (sourceLen >> 11) + 7;
-    /* if can't get parameters, return larger bound plus a zlib wrapper */
-    if (deflateStateCheck(strm))
-        return (fixedlen > storelen ? fixedlen : storelen) + 6;
-    /* compute wrapper length */
-    s = strm->state;
-    switch (s->wrap) {
-    case 0:                                 /* raw deflate */
-        wraplen = 0;
-        break;
-    case 1:                                 /* zlib wrapper */
-        wraplen = 6 + (s->strstart ? 4 : 0);
-        break;
-#ifdef GZIP
-    case 2:                                 /* gzip wrapper */
-        wraplen = 18;
-        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
-            Bytef *str;
-            if (s->gzhead->extra != Z_NULL)
-                wraplen += 2 + s->gzhead->extra_len;
-            str = s->gzhead->name;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            str = s->gzhead->comment;
-            if (str != Z_NULL)
-                do {
-                    wraplen++;
-                } while (*str++);
-            if (s->gzhead->hcrc)
-                wraplen += 2;
-        }
-        break;
-#endif
-    default:                                /* for compiler happiness */
-        wraplen = 6;
-    }
-    /* if not default parameters, return one of the conservative bounds */
-    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
-        return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +
-               wraplen;
-    /* default settings: return tight bound for that case -- ~0.03% overhead
-       plus a small constant */
-    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
-           (sourceLen >> 25) + 13 - 6 + wraplen;
-}
-/* =========================================================================
- * Put a short in the pending buffer. The 16-bit value is put in MSB order.
- * IN assertion: the stream state is correct and there is enough room in
- * pending_buf.
- */
-local void putShortMSB(s, b)
-    deflate_state *s;
-    uInt b;
-{
-    put_byte(s, (Byte)(b >> 8));
-    put_byte(s, (Byte)(b & 0xff));
-}
-/* =========================================================================
- * Flush as much pending output as possible. All deflate() output, except for
- * some deflate_stored() output, goes through this function so some
- * applications may wish to modify it to avoid allocating a large
- * strm->next_out buffer and copying into it. (See also read_buf()).
- */
-local void flush_pending(strm)
-    z_streamp strm;
-{
-    unsigned len;
-    deflate_state *s = strm->state;
-    _tr_flush_bits(s);
-    len = s->pending;
-    if (len > strm->avail_out) len = strm->avail_out;
-    if (len == 0) return;
-    zmemcpy(strm->next_out, s->pending_out, len);
-    strm->next_out  += len;
-    s->pending_out  += len;
-    strm->total_out += len;
-    strm->avail_out -= len;
-    s->pending      -= len;
-    if (s->pending == 0) {
-        s->pending_out = s->pending_buf;
-    }
-}
-/* ===========================================================================
- * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
- */
-#define HCRC_UPDATE(beg) \
-    do { \
-        if (s->gzhead->hcrc && s->pending > (beg)) \
-            strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
-                                s->pending - (beg)); \
-    } while (0)
-/* ========================================================================= */
-int ZEXPORT deflate(strm, flush)
-    z_streamp strm;
-    int flush;
-{
-    int old_flush; /* value of flush param for previous deflate call */
-    deflate_state *s;
-    if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
-        return Z_STREAM_ERROR;
-    }
-    s = strm->state;
-    if (strm->next_out == Z_NULL ||
-        (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
-        (s->status == FINISH_STATE && flush != Z_FINISH)) {
-        ERR_RETURN(strm, Z_STREAM_ERROR);
-    }
-    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
-    old_flush = s->last_flush;
-    s->last_flush = flush;
-    /* Flush as much pending output as possible */
-    if (s->pending != 0) {
-        flush_pending(strm);
-        if (strm->avail_out == 0) {
-            /* Since avail_out is 0, deflate will be called again with
-             * more output space, but possibly with both pending and
-             * avail_in equal to zero. There won't be anything to do,
-             * but this is not an error situation so make sure we
-             * return OK instead of BUF_ERROR at next call of deflate:
-             */
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    /* Make sure there is something to do and avoid duplicate consecutive
-     * flushes. For repeated and useless calls with Z_FINISH, we keep
-     * returning Z_STREAM_END instead of Z_BUF_ERROR.
-     */
-    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
-               flush != Z_FINISH) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-    /* User must not provide more input after the first FINISH: */
-    if (s->status == FINISH_STATE && strm->avail_in != 0) {
-        ERR_RETURN(strm, Z_BUF_ERROR);
-    }
-    /* Write the header */
-    if (s->status == INIT_STATE && s->wrap == 0)
-        s->status = BUSY_STATE;
-    if (s->status == INIT_STATE) {
-        /* zlib header */
-        uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
-        uInt level_flags;
-        if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
-            level_flags = 0;
-        else if (s->level < 6)
-            level_flags = 1;
-        else if (s->level == 6)
-            level_flags = 2;
-        else
-            level_flags = 3;
-        header |= (level_flags << 6);
-        if (s->strstart != 0) header |= PRESET_DICT;
-        header += 31 - (header % 31);
-        putShortMSB(s, header);
-        /* Save the adler32 of the preset dictionary: */
-        if (s->strstart != 0) {
-            putShortMSB(s, (uInt)(strm->adler >> 16));
-            putShortMSB(s, (uInt)(strm->adler & 0xffff));
-        }
-        strm->adler = adler32(0L, Z_NULL, 0);
-        s->status = BUSY_STATE;
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#ifdef GZIP
-    if (s->status == GZIP_STATE) {
-        /* gzip header */
-        strm->adler = crc32(0L, Z_NULL, 0);
-        put_byte(s, 31);
-        put_byte(s, 139);
-        put_byte(s, 8);
-        if (s->gzhead == Z_NULL) {
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, 0);
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, OS_CODE);
-            s->status = BUSY_STATE;
-            /* Compression must start with an empty pending buffer */
-            flush_pending(strm);
-            if (s->pending != 0) {
-                s->last_flush = -1;
-                return Z_OK;
-            }
-        }
-        else {
-            put_byte(s, (s->gzhead->text ? 1 : 0) +
-                     (s->gzhead->hcrc ? 2 : 0) +
-                     (s->gzhead->extra == Z_NULL ? 0 : 4) +
-                     (s->gzhead->name == Z_NULL ? 0 : 8) +
-                     (s->gzhead->comment == Z_NULL ? 0 : 16)
-                     );
-            put_byte(s, (Byte)(s->gzhead->time & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
-            put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
-            put_byte(s, s->level == 9 ? 2 :
-                     (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
-                      4 : 0));
-            put_byte(s, s->gzhead->os & 0xff);
-            if (s->gzhead->extra != Z_NULL) {
-                put_byte(s, s->gzhead->extra_len & 0xff);
-                put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
-            }
-            if (s->gzhead->hcrc)
-                strm->adler = crc32(strm->adler, s->pending_buf,
-                                    s->pending);
-            s->gzindex = 0;
-            s->status = EXTRA_STATE;
-        }
-    }
-    if (s->status == EXTRA_STATE) {
-        if (s->gzhead->extra != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
-            while (s->pending + left > s->pending_buf_size) {
-                uInt copy = s->pending_buf_size - s->pending;
-                zmemcpy(s->pending_buf + s->pending,
-                        s->gzhead->extra + s->gzindex, copy);
-                s->pending = s->pending_buf_size;
-                HCRC_UPDATE(beg);
-                s->gzindex += copy;
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-                beg = 0;
-                left -= copy;
-            }
-            zmemcpy(s->pending_buf + s->pending,
-                    s->gzhead->extra + s->gzindex, left);
-            s->pending += left;
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = NAME_STATE;
-    }
-    if (s->status == NAME_STATE) {
-        if (s->gzhead->name != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->name[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-            s->gzindex = 0;
-        }
-        s->status = COMMENT_STATE;
-    }
-    if (s->status == COMMENT_STATE) {
-        if (s->gzhead->comment != Z_NULL) {
-            ulg beg = s->pending;   /* start of bytes to update crc */
-            int val;
-            do {
-                if (s->pending == s->pending_buf_size) {
-                    HCRC_UPDATE(beg);
-                    flush_pending(strm);
-                    if (s->pending != 0) {
-                        s->last_flush = -1;
-                        return Z_OK;
-                    }
-                    beg = 0;
-                }
-                val = s->gzhead->comment[s->gzindex++];
-                put_byte(s, val);
-            } while (val != 0);
-            HCRC_UPDATE(beg);
-        }
-        s->status = HCRC_STATE;
-    }
-    if (s->status == HCRC_STATE) {
-        if (s->gzhead->hcrc) {
-            if (s->pending + 2 > s->pending_buf_size) {
-                flush_pending(strm);
-                if (s->pending != 0) {
-                    s->last_flush = -1;
-                    return Z_OK;
-                }
-            }
-            put_byte(s, (Byte)(strm->adler & 0xff));
-            put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-            strm->adler = crc32(0L, Z_NULL, 0);
-        }
-        s->status = BUSY_STATE;
-        /* Compression must start with an empty pending buffer */
-        flush_pending(strm);
-        if (s->pending != 0) {
-            s->last_flush = -1;
-            return Z_OK;
-        }
-    }
-#endif
-    /* Start a new block or continue the current one.
-     */
-    if (strm->avail_in != 0 || s->lookahead != 0 ||
-        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
-        block_state bstate;
-        bstate = s->level == 0 ? deflate_stored(s, flush) :
-                 s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
-                 s->strategy == Z_RLE ? deflate_rle(s, flush) :
-                 (*(configuration_table[s->level].func))(s, flush);
-        if (bstate == finish_started || bstate == finish_done) {
-            s->status = FINISH_STATE;
-        }
-        if (bstate == need_more || bstate == finish_started) {
-            if (strm->avail_out == 0) {
-                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
-            }
-            return Z_OK;
-            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
-             * of deflate should use the same flush parameter to make sure
-             * that the flush is complete. So we don't have to output an
-             * empty block here, this will be done at next call. This also
-             * ensures that for a very small output buffer, we emit at most
-             * one empty block.
-             */
-        }
-        if (bstate == block_done) {
-            if (flush == Z_PARTIAL_FLUSH) {
-                _tr_align(s);
-            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
-                _tr_stored_block(s, (char*)0, 0L, 0);
-                /* For a full flush, this empty block will be recognized
-                 * as a special marker by inflate_sync().
-                 */
-                if (flush == Z_FULL_FLUSH) {
-                    CLEAR_HASH(s);             /* forget history */
-                    if (s->lookahead == 0) {
-                        s->strstart = 0;
-                        s->block_start = 0L;
-                        s->insert = 0;
-                    }
-                }
-            }
-            flush_pending(strm);
-            if (strm->avail_out == 0) {
-              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
-              return Z_OK;
-            }
-        }
-    }
-    if (flush != Z_FINISH) return Z_OK;
-    if (s->wrap <= 0) return Z_STREAM_END;
-    /* Write the trailer */
-#ifdef GZIP
-    if (s->wrap == 2) {
-        put_byte(s, (Byte)(strm->adler & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
-        put_byte(s, (Byte)(strm->total_in & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
-        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
-    }
-    else
-#endif
-    {
-        putShortMSB(s, (uInt)(strm->adler >> 16));
-        putShortMSB(s, (uInt)(strm->adler & 0xffff));
-    }
-    flush_pending(strm);
-    /* If avail_out is zero, the application will call deflate again
-     * to flush the rest.
-     */
-    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
-    return s->pending != 0 ? Z_OK : Z_STREAM_END;
-}
-/* ========================================================================= */
-int ZEXPORT deflateEnd(strm)
-    z_streamp strm;
-{
-    int status;
-    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
-    status = strm->state->status;
-    /* Deallocate in reverse order of allocations: */
-    TRY_FREE(strm, strm->state->pending_buf);
-    TRY_FREE(strm, strm->state->head);
-    TRY_FREE(strm, strm->state->prev);
-    TRY_FREE(strm, strm->state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
-}
-/* =========================================================================
- * Copy the source state to the destination state.
- * To simplify the source, this is not supported for 16-bit MSDOS (which
- * doesn't have enough memory anyway to duplicate compression states).
- */
-int ZEXPORT deflateCopy(dest, source)
-    z_streamp dest;
-    z_streamp source;
-{
-#ifdef MAXSEG_64K
-    return Z_STREAM_ERROR;
-#else
-    deflate_state *ds;
-    deflate_state *ss;
-    if (deflateStateCheck(source) || dest == Z_NULL) {
-        return Z_STREAM_ERROR;
-    }
-    ss = source->state;
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
-    if (ds == Z_NULL) return Z_MEM_ERROR;
-    dest->state = (struct internal_state FAR *) ds;
-    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
-    ds->strm = dest;
-    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
-    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
-    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
-    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);
-    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
-        ds->pending_buf == Z_NULL) {
-        deflateEnd (dest);
-        return Z_MEM_ERROR;
-    }
-    /* following zmemcpy do not work for 16-bit MSDOS */
-    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
-    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
-    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
-    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
-    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
-    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;
-    ds->l_desc.dyn_tree = ds->dyn_ltree;
-    ds->d_desc.dyn_tree = ds->dyn_dtree;
-    ds->bl_desc.dyn_tree = ds->bl_tree;
-    return Z_OK;
-#endif /* MAXSEG_64K */
-}
-/* ===========================================================================
- * Read a new buffer from the current input stream, update the adler32
- * and total number of bytes read.  All deflate() input goes through
- * this function so some applications may wish to modify it to avoid
- * allocating a large strm->next_in buffer and copying from it.
- * (See also flush_pending()).
- */
-local unsigned read_buf(strm, buf, size)
-    z_streamp strm;
-    Bytef *buf;
-    unsigned size;
-{
-    unsigned len = strm->avail_in;
-    if (len > size) len = size;
-    if (len == 0) return 0;
-    strm->avail_in  -= len;
-    zmemcpy(buf, strm->next_in, len);
-    if (strm->state->wrap == 1) {
-        strm->adler = adler32(strm->adler, buf, len);
-    }
-#ifdef GZIP
-    else if (strm->state->wrap == 2) {
-        strm->adler = crc32(strm->adler, buf, len);
-    }
-#endif
-    strm->next_in  += len;
-    strm->total_in += len;
-    return len;
-}
-/* ===========================================================================
- * Initialize the "longest match" routines for a new zlib stream
- */
-local void lm_init(s)
-    deflate_state *s;
-{
-    s->window_size = (ulg)2L*s->w_size;
-    CLEAR_HASH(s);
-    /* Set the default configuration parameters:
-     */
-    s->max_lazy_match   = configuration_table[s->level].max_lazy;
-    s->good_match       = configuration_table[s->level].good_length;
-    s->nice_match       = configuration_table[s->level].nice_length;
-    s->max_chain_length = configuration_table[s->level].max_chain;
-    s->strstart = 0;
-    s->block_start = 0L;
-    s->lookahead = 0;
-    s->insert = 0;
-    s->match_length = s->prev_length = MIN_MATCH-1;
-    s->match_available = 0;
-    s->ins_h = 0;
-}
-#ifndef FASTEST
-/* ===========================================================================
- * Set match_start to the longest match starting at the given string and
- * return its length. Matches shorter or equal to prev_length are discarded,
- * in which case the result is equal to prev_length and match_start is
- * garbage.
- * IN assertions: cur_match is the head of the hash chain for the current
- *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
- * OUT assertion: the match length is not greater than s->lookahead.
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    unsigned chain_length = s->max_chain_length;/* max hash chain length */
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                      /* matched string */
-    register int len;                           /* length of current match */
-    int best_len = (int)s->prev_length;         /* best match length so far */
-    int nice_match = s->nice_match;             /* stop if match long enough */
-    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
-        s->strstart - (IPos)MAX_DIST(s) : NIL;
-    /* Stop when cur_match becomes <= limit. To simplify the code,
-     * we prevent matches with the string of window index 0.
-     */
-    Posf *prev = s->prev;
-    uInt wmask = s->w_mask;
-#ifdef UNALIGNED_OK
-    /* Compare two bytes at a time. Note: this is not always beneficial.
-     * Try with and without -DUNALIGNED_OK to check.
-     */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
-    register ush scan_start = *(ushf*)scan;
-    register ush scan_end   = *(ushf*)(scan + best_len - 1);
-#else
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    register Byte scan_end1  = scan[best_len - 1];
-    register Byte scan_end   = scan[best_len];
-#endif
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-    /* Do not waste too much time if we already have a good match: */
-    if (s->prev_length >= s->good_match) {
-        chain_length >>= 2;
-    }
-    /* Do not look for matches beyond the end of the input. This is necessary
-     * to make deflate deterministic.
-     */
-    if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "need lookahead");
-    do {
-        Assert(cur_match < s->strstart, "no future");
-        match = s->window + cur_match;
-        /* Skip to next match if the match length cannot increase
-         * or if the match length is less than 2.  Note that the checks below
-         * for insufficient lookahead only occur occasionally for performance
-         * reasons.  Therefore uninitialized memory will be accessed, and
-         * conditional jumps will be made that depend on those values.
-         * However the length of the match is limited to the lookahead, so
-         * the output of deflate is not affected by the uninitialized values.
-         */
-#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
-        /* This code assumes sizeof(unsigned short) == 2. Do not use
-         * UNALIGNED_OK if your compiler uses a different size.
-         */
-        if (*(ushf*)(match + best_len - 1) != scan_end ||
-            *(ushf*)match != scan_start) continue;
-        /* It is not necessary to compare scan[2] and match[2] since they are
-         * always equal when the other bytes match, given that the hash keys
-         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
-         * strstart + 3, + 5, up to strstart + 257. We check for insufficient
-         * lookahead only every 4th comparison; the 128th check will be made
-         * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is
-         * necessary to put more guard bytes at the end of the window, or
-         * to check more often for insufficient lookahead.
-         */
-        Assert(scan[2] == match[2], "scan[2]?");
-        scan++, match++;
-        do {
-        } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
-                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
-                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
-                 *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
-                 scan < strend);
-        /* The funny "do {}" generates better code on most compilers */
-        /* Here, scan <= window + strstart + 257 */
-        Assert(scan <= s->window + (unsigned)(s->window_size - 1),
-               "wild scan");
-        if (*scan == *match) scan++;
-        len = (MAX_MATCH - 1) - (int)(strend - scan);
-        scan = strend - (MAX_MATCH-1);
-#else /* UNALIGNED_OK */
-        if (match[best_len]     != scan_end  ||
-            match[best_len - 1] != scan_end1 ||
-            *match              != *scan     ||
-            *++match            != scan[1])      continue;
-        /* The check at best_len - 1 can be removed because it will be made
-         * again later. (This heuristic is not always a win.)
-         * It is not necessary to compare scan[2] and match[2] since they
-         * are always equal when the other bytes match, given that
-         * the hash keys are equal and that HASH_BITS >= 8.
-         */
-        scan += 2, match++;
-        Assert(*scan == *match, "match[2]?");
-        /* We check for insufficient lookahead only every 8th comparison;
-         * the 256th check will be made at strstart + 258.
-         */
-        do {
-        } while (*++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 *++scan == *++match && *++scan == *++match &&
-                 scan < strend);
-        Assert(scan <= s->window + (unsigned)(s->window_size - 1),
-               "wild scan");
-        len = MAX_MATCH - (int)(strend - scan);
-        scan = strend - MAX_MATCH;
-#endif /* UNALIGNED_OK */
-        if (len > best_len) {
-            s->match_start = cur_match;
-            best_len = len;
-            if (len >= nice_match) break;
-#ifdef UNALIGNED_OK
-            scan_end = *(ushf*)(scan + best_len - 1);
-#else
-            scan_end1  = scan[best_len - 1];
-            scan_end   = scan[best_len];
-#endif
-        }
-    } while ((cur_match = prev[cur_match & wmask]) > limit
-             && --chain_length != 0);
-    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
-    return s->lookahead;
-}
-#else /* FASTEST */
-/* ---------------------------------------------------------------------------
- * Optimized version for FASTEST only
- */
-local uInt longest_match(s, cur_match)
-    deflate_state *s;
-    IPos cur_match;                             /* current match */
-{
-    register Bytef *scan = s->window + s->strstart; /* current string */
-    register Bytef *match;                       /* matched string */
-    register int len;                           /* length of current match */
-    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
-    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
-     * It is easy to get rid of this optimization if necessary.
-     */
-    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "need lookahead");
-    Assert(cur_match < s->strstart, "no future");
-    match = s->window + cur_match;
-    /* Return failure if the match length is less than 2:
-     */
-    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
-    /* The check at best_len - 1 can be removed because it will be made
-     * again later. (This heuristic is not always a win.)
-     * It is not necessary to compare scan[2] and match[2] since they
-     * are always equal when the other bytes match, given that
-     * the hash keys are equal and that HASH_BITS >= 8.
-     */
-    scan += 2, match += 2;
-    Assert(*scan == *match, "match[2]?");
-    /* We check for insufficient lookahead only every 8th comparison;
-     * the 256th check will be made at strstart + 258.
-     */
-    do {
-    } while (*++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             *++scan == *++match && *++scan == *++match &&
-             scan < strend);
-    Assert(scan <= s->window + (unsigned)(s->window_size - 1), "wild scan");
-    len = MAX_MATCH - (int)(strend - scan);
-    if (len < MIN_MATCH) return MIN_MATCH - 1;
-    s->match_start = cur_match;
-    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
-}
-#endif /* FASTEST */
-#ifdef ZLIB_DEBUG
-#define EQUAL 0
-/* result of memcmp for equal strings */
-/* ===========================================================================
- * Check that the match at match_start is indeed a match.
- */
-local void check_match(s, start, match, length)
-    deflate_state *s;
-    IPos start, match;
-    int length;
-{
-    /* check that the match is indeed a match */
-    if (zmemcmp(s->window + match,
-                s->window + start, length) != EQUAL) {
-        fprintf(stderr, " start %u, match %u, length %d\n",
-                start, match, length);
-        do {
-            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
-        } while (--length != 0);
-        z_error("invalid match");
-    }
-    if (z_verbose > 1) {
-        fprintf(stderr,"\\[%d,%d]", start - match, length);
-        do { putc(s->window[start++], stderr); } while (--length != 0);
-    }
-}
-#else
-#  define check_match(s, start, match, length)
-#endif /* ZLIB_DEBUG */
-/* ===========================================================================
- * Fill the window when the lookahead becomes insufficient.
- * Updates strstart and lookahead.
- *
- * IN assertion: lookahead < MIN_LOOKAHEAD
- * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
- *    At least one byte has been read, or avail_in == 0; reads are
- *    performed for at least two bytes (required for the zip translate_eol
- *    option -- not supported here).
- */
-local void fill_window(s)
-    deflate_state *s;
-{
-    unsigned n;
-    unsigned more;    /* Amount of free space at the end of the window. */
-    uInt wsize = s->w_size;
-    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
-    do {
-        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
-        /* Deal with !@#$% 64K limit: */
-        if (sizeof(int) <= 2) {
-            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
-                more = wsize;
-            } else if (more == (unsigned)(-1)) {
-                /* Very unlikely, but possible on 16 bit machine if
-                 * strstart == 0 && lookahead == 1 (input done a byte at time)
-                 */
-                more--;
-            }
-        }
-        /* If the window is almost full and there is insufficient lookahead,
-         * move the upper half to the lower one to make room in the upper half.
-         */
-        if (s->strstart >= wsize + MAX_DIST(s)) {
-            zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);
-            s->match_start -= wsize;
-            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
-            s->block_start -= (long) wsize;
-            if (s->insert > s->strstart)
-                s->insert = s->strstart;
-            slide_hash(s);
-            more += wsize;
-        }
-        if (s->strm->avail_in == 0) break;
-        /* If there was no sliding:
-         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
-         *    more == window_size - lookahead - strstart
-         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
-         * => more >= window_size - 2*WSIZE + 2
-         * In the BIG_MEM or MMAP case (not yet supported),
-         *   window_size == input_size + MIN_LOOKAHEAD  &&
-         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
-         * Otherwise, window_size == 2*WSIZE so more >= 2.
-         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
-         */
-        Assert(more >= 2, "more < 2");
-        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
-        s->lookahead += n;
-        /* Initialize the hash value now that we have some input: */
-        if (s->lookahead + s->insert >= MIN_MATCH) {
-            uInt str = s->strstart - s->insert;
-            s->ins_h = s->window[str];
-            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
-#if MIN_MATCH != 3
-            Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-            while (s->insert) {
-                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
-#ifndef FASTEST
-                s->prev[str & s->w_mask] = s->head[s->ins_h];
-#endif
-                s->head[s->ins_h] = (Pos)str;
-                str++;
-                s->insert--;
-                if (s->lookahead + s->insert < MIN_MATCH)
-                    break;
-            }
-        }
-        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
-         * but this is not important since only literal bytes will be emitted.
-         */
-    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
-    /* If the WIN_INIT bytes after the end of the current data have never been
-     * written, then zero those bytes in order to avoid memory check reports of
-     * the use of uninitialized (or uninitialised as Julian writes) bytes by
-     * the longest match routines.  Update the high water mark for the next
-     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
-     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
-     */
-    if (s->high_water < s->window_size) {
-        ulg curr = s->strstart + (ulg)(s->lookahead);
-        ulg init;
-        if (s->high_water < curr) {
-            /* Previous high water mark below current data -- zero WIN_INIT
-             * bytes or up to end of window, whichever is less.
-             */
-            init = s->window_size - curr;
-            if (init > WIN_INIT)
-                init = WIN_INIT;
-            zmemzero(s->window + curr, (unsigned)init);
-            s->high_water = curr + init;
-        }
-        else if (s->high_water < (ulg)curr + WIN_INIT) {
-            /* High water mark at or above current data, but below current data
-             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
-             * to end of window, whichever is less.
-             */
-            init = (ulg)curr + WIN_INIT - s->high_water;
-            if (init > s->window_size - s->high_water)
-                init = s->window_size - s->high_water;
-            zmemzero(s->window + s->high_water, (unsigned)init);
-            s->high_water += init;
-        }
-    }
-    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
-           "not enough room for search");
-}
-/* ===========================================================================
- * Flush the current block, with given end-of-file flag.
- * IN assertion: strstart is set to the end of the current match.
- */
-#define FLUSH_BLOCK_ONLY(s, last) { \
-   _tr_flush_block(s, (s->block_start >= 0L ? \
-                   (charf *)&s->window[(unsigned)s->block_start] : \
-                   (charf *)Z_NULL), \
-                (ulg)((long)s->strstart - s->block_start), \
-                (last)); \
-   s->block_start = s->strstart; \
-   flush_pending(s->strm); \
-   Tracev((stderr,"[FLUSH]")); \
-}
-/* Same but force premature exit if necessary. */
-#define FLUSH_BLOCK(s, last) { \
-   FLUSH_BLOCK_ONLY(s, last); \
-   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
-}
-/* Maximum stored block length in deflate format (not including header). */
-#define MAX_STORED 65535
-/* Minimum of a and b. */
-#define MIN(a, b) ((a) > (b) ? (b) : (a))
-/* ===========================================================================
- * Copy without compression as much as possible from the input stream, return
- * the current block state.
- *
- * In case deflateParams() is used to later switch to a non-zero compression
- * level, s->matches (otherwise unused when storing) keeps track of the number
- * of hash table slides to perform. If s->matches is 1, then one hash table
- * slide will be done when switching. If s->matches is 2, the maximum value
- * allowed here, then the hash table will be cleared, since two or more slides
- * is the same as a clear.
- *
- * deflate_stored() is written to minimize the number of times an input byte is
- * copied. It is most efficient with large input and output buffers, which
- * maximizes the opportunities to have a single copy from next_in to next_out.
- */
-local block_state deflate_stored(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    /* Smallest worthy block size when not flushing or finishing. By default
-     * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
-     * large input and output buffers, the stored block size will be larger.
-     */
-    unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
-    /* Copy as many min_block or larger stored blocks directly to next_out as
-     * possible. If flushing, copy the remaining available input to next_out as
-     * stored blocks, if there is enough space.
-     */
-    unsigned len, left, have, last = 0;
-    unsigned used = s->strm->avail_in;
-    do {
-        /* Set len to the maximum size block that we can copy directly with the
-         * available input data and output space. Set left to how much of that
-         * would be copied from what's left in the window.
-         */
-        len = MAX_STORED;       /* maximum deflate stored block length */
-        have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        if (s->strm->avail_out < have)          /* need room for header */
-            break;
-            /* maximum stored block length that will fit in avail_out: */
-        have = s->strm->avail_out - have;
-        left = s->strstart - s->block_start;    /* bytes left in window */
-        if (len > (ulg)left + s->strm->avail_in)
-            len = left + s->strm->avail_in;     /* limit len to the input */
-        if (len > have)
-            len = have;                         /* limit len to the output */
-        /* If the stored block would be less than min_block in length, or if
-         * unable to copy all of the available input when flushing, then try
-         * copying to the window and the pending buffer instead. Also don't
-         * write an empty block when flushing -- deflate() does that.
-         */
-        if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
-                                flush == Z_NO_FLUSH ||
-                                len != left + s->strm->avail_in))
-            break;
-        /* Make a dummy stored block in pending to get the header bytes,
-         * including any pending bits. This also updates the debugging counts.
-         */
-        last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
-        _tr_stored_block(s, (char *)0, 0L, last);
-        /* Replace the lengths in the dummy stored block with len. */
-        s->pending_buf[s->pending - 4] = len;
-        s->pending_buf[s->pending - 3] = len >> 8;
-        s->pending_buf[s->pending - 2] = ~len;
-        s->pending_buf[s->pending - 1] = ~len >> 8;
-        /* Write the stored block header bytes. */
-        flush_pending(s->strm);
-#ifdef ZLIB_DEBUG
-        /* Update debugging counts for the data about to be copied. */
-        s->compressed_len += len << 3;
-        s->bits_sent += len << 3;
-#endif
-        /* Copy uncompressed bytes from the window to next_out. */
-        if (left) {
-            if (left > len)
-                left = len;
-            zmemcpy(s->strm->next_out, s->window + s->block_start, left);
-            s->strm->next_out += left;
-            s->strm->avail_out -= left;
-            s->strm->total_out += left;
-            s->block_start += left;
-            len -= left;
-        }
-        /* Copy uncompressed bytes directly from next_in to next_out, updating
-         * the check value.
-         */
-        if (len) {
-            read_buf(s->strm, s->strm->next_out, len);
-            s->strm->next_out += len;
-            s->strm->avail_out -= len;
-            s->strm->total_out += len;
-        }
-    } while (last == 0);
-    /* Update the sliding window with the last s->w_size bytes of the copied
-     * data, or append all of the copied data to the existing window if less
-     * than s->w_size bytes were copied. Also update the number of bytes to
-     * insert in the hash tables, in the event that deflateParams() switches to
-     * a non-zero compression level.
-     */
-    used -= s->strm->avail_in;      /* number of input bytes directly copied */
-    if (used) {
-        /* If any input was used, then no unused input remains in the window,
-         * therefore s->block_start == s->strstart.
-         */
-        if (used >= s->w_size) {    /* supplant the previous history */
-            s->matches = 2;         /* clear hash */
-            zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
-            s->strstart = s->w_size;
-            s->insert = s->strstart;
-        }
-        else {
-            if (s->window_size - s->strstart <= used) {
-                /* Slide the window down. */
-                s->strstart -= s->w_size;
-                zmemcpy(s->window, s->window + s->w_size, s->strstart);
-                if (s->matches < 2)
-                    s->matches++;   /* add a pending slide_hash() */
-                if (s->insert > s->strstart)
-                    s->insert = s->strstart;
-            }
-            zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
-            s->strstart += used;
-            s->insert += MIN(used, s->w_size - s->insert);
-        }
-        s->block_start = s->strstart;
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-    /* If the last block was written to next_out, then done. */
-    if (last)
-        return finish_done;
-    /* If flushing and all input has been consumed, then done. */
-    if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
-        s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
-        return block_done;
-    /* Fill the window with any remaining input. */
-    have = s->window_size - s->strstart;
-    if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
-        /* Slide the window down. */
-        s->block_start -= s->w_size;
-        s->strstart -= s->w_size;
-        zmemcpy(s->window, s->window + s->w_size, s->strstart);
-        if (s->matches < 2)
-            s->matches++;           /* add a pending slide_hash() */
-        have += s->w_size;          /* more space now */
-        if (s->insert > s->strstart)
-            s->insert = s->strstart;
-    }
-    if (have > s->strm->avail_in)
-        have = s->strm->avail_in;
-    if (have) {
-        read_buf(s->strm, s->window + s->strstart, have);
-        s->strstart += have;
-        s->insert += MIN(have, s->w_size - s->insert);
-    }
-    if (s->high_water < s->strstart)
-        s->high_water = s->strstart;
-    /* There was not enough avail_out to write a complete worthy or flushed
-     * stored block to next_out. Write a stored block to pending instead, if we
-     * have enough input for a worthy block, or if flushing and there is enough
-     * room for the remaining input as a stored block in the pending buffer.
-     */
-    have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
-        /* maximum stored block length that will fit in pending: */
-    have = MIN(s->pending_buf_size - have, MAX_STORED);
-    min_block = MIN(have, s->w_size);
-    left = s->strstart - s->block_start;
-    if (left >= min_block ||
-        ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
-         s->strm->avail_in == 0 && left <= have)) {
-        len = MIN(left, have);
-        last = flush == Z_FINISH && s->strm->avail_in == 0 &&
-               len == left ? 1 : 0;
-        _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
-        s->block_start += len;
-        flush_pending(s->strm);
-    }
-    /* We've done all we can with the available input and output. */
-    return last ? finish_started : need_more;
-}
-/* ===========================================================================
- * Compress as much as possible from the input stream, return the current
- * block state.
- * This function does not perform lazy evaluation of matches and inserts
- * new strings in the dictionary only for unmatched strings or for short
- * matches. It is used only for the fast compression options.
- */
-local block_state deflate_fast(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;       /* head of the hash chain */
-    int bflush;           /* set if current block must be flushed */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* Insert the string window[strstart .. strstart + 2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-        /* Find the longest match, discarding those <= prev_length.
-         * At this point we have always match_length < MIN_MATCH
-         */
-        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-        }
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->match_start, s->match_length);
-            _tr_tally_dist(s, s->strstart - s->match_start,
-                           s->match_length - MIN_MATCH, bflush);
-            s->lookahead -= s->match_length;
-            /* Insert new strings in the hash table only if the match length
-             * is not too large. This saves time but degrades compression.
-             */
-#ifndef FASTEST
-            if (s->match_length <= s->max_insert_length &&
-                s->lookahead >= MIN_MATCH) {
-                s->match_length--; /* string at strstart already in table */
-                do {
-                    s->strstart++;
-                    INSERT_STRING(s, s->strstart, hash_head);
-                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
-                     * always MIN_MATCH bytes ahead.
-                     */
-                } while (--s->match_length != 0);
-                s->strstart++;
-            } else
-#endif
-            {
-                s->strstart += s->match_length;
-                s->match_length = 0;
-                s->ins_h = s->window[s->strstart];
-                UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
-#if MIN_MATCH != 3
-                Call UPDATE_HASH() MIN_MATCH-3 more times
-#endif
-                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
-                 * matter since it will be recomputed at next deflate call.
-                 */
-            }
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit(s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#ifndef FASTEST
-/* ===========================================================================
- * Same as above, but achieves better compression. We use a lazy
- * evaluation for matches: a match is finally adopted only if there is
- * no better match at the next window position.
- */
-local block_state deflate_slow(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    IPos hash_head;          /* head of hash chain */
-    int bflush;              /* set if current block must be flushed */
-    /* Process the input block. */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the next match, plus MIN_MATCH bytes to insert the
-         * string following the next match.
-         */
-        if (s->lookahead < MIN_LOOKAHEAD) {
-            fill_window(s);
-            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* Insert the string window[strstart .. strstart + 2] in the
-         * dictionary, and set hash_head to the head of the hash chain:
-         */
-        hash_head = NIL;
-        if (s->lookahead >= MIN_MATCH) {
-            INSERT_STRING(s, s->strstart, hash_head);
-        }
-        /* Find the longest match, discarding those <= prev_length.
-         */
-        s->prev_length = s->match_length, s->prev_match = s->match_start;
-        s->match_length = MIN_MATCH-1;
-        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
-            s->strstart - hash_head <= MAX_DIST(s)) {
-            /* To simplify the code, we prevent matches with the string
-             * of window index 0 (in particular we have to avoid a match
-             * of the string with itself at the start of the input file).
-             */
-            s->match_length = longest_match (s, hash_head);
-            /* longest_match() sets match_start */
-            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
-#if TOO_FAR <= 32767
-                || (s->match_length == MIN_MATCH &&
-                    s->strstart - s->match_start > TOO_FAR)
-#endif
-                )) {
-                /* If prev_match is also MIN_MATCH, match_start is garbage
-                 * but we will ignore the current match anyway.
-                 */
-                s->match_length = MIN_MATCH-1;
-            }
-        }
-        /* If there was a match at the previous step and the current
-         * match is not better, output the previous match:
-         */
-        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
-            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
-            /* Do not insert strings in hash table beyond this. */
-            check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
-            _tr_tally_dist(s, s->strstart - 1 - s->prev_match,
-                           s->prev_length - MIN_MATCH, bflush);
-            /* Insert in hash table all strings up to the end of the match.
-             * strstart - 1 and strstart are already inserted. If there is not
-             * enough lookahead, the last two strings are not inserted in
-             * the hash table.
-             */
-            s->lookahead -= s->prev_length - 1;
-            s->prev_length -= 2;
-            do {
-                if (++s->strstart <= max_insert) {
-                    INSERT_STRING(s, s->strstart, hash_head);
-                }
-            } while (--s->prev_length != 0);
-            s->match_available = 0;
-            s->match_length = MIN_MATCH-1;
-            s->strstart++;
-            if (bflush) FLUSH_BLOCK(s, 0);
-        } else if (s->match_available) {
-            /* If there was no match at the previous position, output a
-             * single literal. If there was a match but the current match
-             * is longer, truncate the previous match to a single literal.
-             */
-            Tracevv((stderr,"%c", s->window[s->strstart - 1]));
-            _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
-            if (bflush) {
-                FLUSH_BLOCK_ONLY(s, 0);
-            }
-            s->strstart++;
-            s->lookahead--;
-            if (s->strm->avail_out == 0) return need_more;
-        } else {
-            /* There is no previous match to compare with, wait for
-             * the next step to decide.
-             */
-            s->match_available = 1;
-            s->strstart++;
-            s->lookahead--;
-        }
-    }
-    Assert (flush != Z_NO_FLUSH, "no flush?");
-    if (s->match_available) {
-        Tracevv((stderr,"%c", s->window[s->strstart - 1]));
-        _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
-        s->match_available = 0;
-    }
-    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-#endif /* FASTEST */
-/* ===========================================================================
- * For Z_RLE, simply look for runs of bytes, generate matches only of distance
- * one.  Do not maintain a hash table.  (It will be regenerated if this run of
- * deflate switches away from Z_RLE.)
- */
-local block_state deflate_rle(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    uInt prev;              /* byte at distance one to match */
-    Bytef *scan, *strend;   /* scan goes up to strend for length of run */
-    for (;;) {
-        /* Make sure that we always have enough lookahead, except
-         * at the end of the input file. We need MAX_MATCH bytes
-         * for the longest run, plus one for the unrolled loop.
-         */
-        if (s->lookahead <= MAX_MATCH) {
-            fill_window(s);
-            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
-                return need_more;
-            }
-            if (s->lookahead == 0) break; /* flush the current block */
-        }
-        /* See how many times the previous byte repeats */
-        s->match_length = 0;
-        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
-            scan = s->window + s->strstart - 1;
-            prev = *scan;
-            if (prev == *++scan && prev == *++scan && prev == *++scan) {
-                strend = s->window + s->strstart + MAX_MATCH;
-                do {
-                } while (prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         prev == *++scan && prev == *++scan &&
-                         scan < strend);
-                s->match_length = MAX_MATCH - (uInt)(strend - scan);
-                if (s->match_length > s->lookahead)
-                    s->match_length = s->lookahead;
-            }
-            Assert(scan <= s->window + (uInt)(s->window_size - 1),
-                   "wild scan");
-        }
-        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
-        if (s->match_length >= MIN_MATCH) {
-            check_match(s, s->strstart, s->strstart - 1, s->match_length);
-            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
-            s->lookahead -= s->match_length;
-            s->strstart += s->match_length;
-            s->match_length = 0;
-        } else {
-            /* No match, output a literal byte */
-            Tracevv((stderr,"%c", s->window[s->strstart]));
-            _tr_tally_lit(s, s->window[s->strstart], bflush);
-            s->lookahead--;
-            s->strstart++;
-        }
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}
-/* ===========================================================================
- * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
- * (It will be regenerated if this run of deflate switches away from Huffman.)
- */
-local block_state deflate_huff(s, flush)
-    deflate_state *s;
-    int flush;
-{
-    int bflush;             /* set if current block must be flushed */
-    for (;;) {
-        /* Make sure that we have a literal to write. */
-        if (s->lookahead == 0) {
-            fill_window(s);
-            if (s->lookahead == 0) {
-                if (flush == Z_NO_FLUSH)
-                    return need_more;
-                break;      /* flush the current block */
-            }
-        }
-        /* Output a literal byte */
-        s->match_length = 0;
-        Tracevv((stderr,"%c", s->window[s->strstart]));
-        _tr_tally_lit(s, s->window[s->strstart], bflush);
-        s->lookahead--;
-        s->strstart++;
-        if (bflush) FLUSH_BLOCK(s, 0);
-    }
-    s->insert = 0;
-    if (flush == Z_FINISH) {
-        FLUSH_BLOCK(s, 1);
-        return finish_done;
-    }
-    if (s->sym_next)
-        FLUSH_BLOCK(s, 0);
-    return block_done;
-}

--- a/src/native/external/zlib/deflate.h
+++ b//dev/null
@@ -1,283 +0,0 @@
-/* deflate.h -- internal compression state
- * Copyright (C) 1995-2018 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-/* @(#) $Id$ */
-#ifndef DEFLATE_H
-#define DEFLATE_H
-#include "zutil.h"
-/* define NO_GZIP when compiling if you want to disable gzip header and
-   trailer creation by deflate().  NO_GZIP would be used to avoid linking in
-   the crc code when it is not needed.  For shared libraries, gzip encoding
-   should be left enabled. */
-#ifndef NO_GZIP
-#  define GZIP
-#endif
-/* ===========================================================================
- * Internal compression state.
- */
-#define LENGTH_CODES 29
-/* number of length codes, not counting the special END_BLOCK code */
-#define LITERALS  256
-/* number of literal bytes 0..255 */
-#define L_CODES (LITERALS+1+LENGTH_CODES)
-/* number of Literal or Length codes, including the END_BLOCK code */
-#define D_CODES   30
-/* number of distance codes */
-#define BL_CODES  19
-/* number of codes used to transfer the bit lengths */
-#define HEAP_SIZE (2*L_CODES+1)
-/* maximum heap size */
-#define MAX_BITS 15
-/* All codes must not exceed MAX_BITS bits */
-#define Buf_size 16
-/* size of bit buffer in bi_buf */
-#define INIT_STATE    42    /* zlib header -> BUSY_STATE */
-#ifdef GZIP
-#  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */
-#endif
-#define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */
-#define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */
-#define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */
-#define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */
-#define BUSY_STATE   113    /* deflate -> FINISH_STATE */
-#define FINISH_STATE 666    /* stream complete */
-/* Stream status */
-/* Data structure describing a single value and its code string. */
-typedef struct ct_data_s {
-    union {
-        ush  freq;       /* frequency count */
-        ush  code;       /* bit string */
-    } fc;
-    union {
-        ush  dad;        /* father node in Huffman tree */
-        ush  len;        /* length of bit string */
-    } dl;
-} FAR ct_data;
-#define Freq fc.freq
-#define Code fc.code
-#define Dad  dl.dad
-#define Len  dl.len
-typedef struct static_tree_desc_s  static_tree_desc;
-typedef struct tree_desc_s {
-    ct_data *dyn_tree;           /* the dynamic tree */
-    int     max_code;            /* largest code with non zero frequency */
-    const static_tree_desc *stat_desc;  /* the corresponding static tree */
-} FAR tree_desc;
-typedef ush Pos;
-typedef Pos FAR Posf;
-typedef unsigned IPos;
-/* A Pos is an index in the character window. We use short instead of int to
- * save space in the various tables. IPos is used only for parameter passing.
- */
-typedef struct internal_state {
-    z_streamp strm;      /* pointer back to this zlib stream */
-    int   status;        /* as the name implies */
-    Bytef *pending_buf;  /* output still pending */
-    ulg   pending_buf_size; /* size of pending_buf */
-    Bytef *pending_out;  /* next pending byte to output to the stream */
-    ulg   pending;       /* nb of bytes in the pending buffer */
-    int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
-    gz_headerp  gzhead;  /* gzip header information to write */
-    ulg   gzindex;       /* where in extra, name, or comment */
-    Byte  method;        /* can only be DEFLATED */
-    int   last_flush;    /* value of flush param for previous deflate call */
-                /* used by deflate.c: */
-    uInt  w_size;        /* LZ77 window size (32K by default) */
-    uInt  w_bits;        /* log2(w_size)  (8..16) */
-    uInt  w_mask;        /* w_size - 1 */
-    Bytef *window;
-    /* Sliding window. Input bytes are read into the second half of the window,
-     * and move to the first half later to keep a dictionary of at least wSize
-     * bytes. With this organization, matches are limited to a distance of
-     * wSize-MAX_MATCH bytes, but this ensures that IO is always
-     * performed with a length multiple of the block size. Also, it limits
-     * the window size to 64K, which is quite useful on MSDOS.
-     * To do: use the user input buffer as sliding window.
-     */
-    ulg window_size;
-    /* Actual size of window: 2*wSize, except when the user input buffer
-     * is directly used as sliding window.
-     */
-    Posf *prev;
-    /* Link to older string with same hash index. To limit the size of this
-     * array to 64K, this link is maintained only for the last 32K strings.
-     * An index in this array is thus a window index modulo 32K.
-     */
-    Posf *head; /* Heads of the hash chains or NIL. */
-    uInt  ins_h;          /* hash index of string to be inserted */
-    uInt  hash_size;      /* number of elements in hash table */
-    uInt  hash_bits;      /* log2(hash_size) */
-    uInt  hash_mask;      /* hash_size-1 */
-    uInt  hash_shift;
-    /* Number of bits by which ins_h must be shifted at each input
-     * step. It must be such that after MIN_MATCH steps, the oldest
-     * byte no longer takes part in the hash key, that is:
-     *   hash_shift * MIN_MATCH >= hash_bits
-     */
-    long block_start;
-    /* Window position at the beginning of the current output block. Gets
-     * negative when the window is moved backwards.
-     */
-    uInt match_length;           /* length of best match */
-    IPos prev_match;             /* previous match */
-    int match_available;         /* set if previous match exists */
-    uInt strstart;               /* start of string to insert */
-    uInt match_start;            /* start of matching string */
-    uInt lookahead;              /* number of valid bytes ahead in window */
-    uInt prev_length;
-    /* Length of the best match at previous step. Matches not greater than this
-     * are discarded. This is used in the lazy match evaluation.
-     */
-    uInt max_chain_length;
-    /* To speed up deflation, hash chains are never searched beyond this
-     * length.  A higher limit improves compression ratio but degrades the
-     * speed.
-     */
-    uInt max_lazy_match;
-    /* Attempt to find a better match only when the current match is strictly
-     * smaller than this value. This mechanism is used only for compression
-     * levels >= 4.
-     */
-#   define max_insert_length  max_lazy_match
-    /* Insert new strings in the hash table only if the match length is not
-     * greater than this length. This saves time but degrades compression.
-     * max_insert_length is used only for compression levels <= 3.
-     */
-    int level;    /* compression level (1..9) */
-    int strategy; /* favor or force Huffman coding*/
-    uInt good_match;
-    /* Use a faster search when the previous match is longer than this */
-    int nice_match; /* Stop searching when current match exceeds this */
-                /* used by trees.c: */
-    /* Didn't use ct_data typedef below to suppress compiler warning */
-    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
-    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
-    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
-    struct tree_desc_s l_desc;               /* desc. for literal tree */
-    struct tree_desc_s d_desc;               /* desc. for distance tree */
-    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
-    int heap_len;               /* number of elements in the heap */
-    int heap_max;               /* element of largest frequency */
-    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
-     * The same heap array is used to build all trees.
-     */
-    uch depth[2*L_CODES+1];
-    /* Depth of each subtree used as tie breaker for trees of equal frequency
-     */
-    uchf *sym_buf;        /* buffer for distances and literals/lengths */
-    uInt  lit_bufsize;
-    /* Size of match buffer for literals/lengths.  There are 4 reasons for
-     * limiting lit_bufsize to 64K:
-     *   - frequencies can be kept in 16 bit counters
-     *   - if compression is not successful for the first block, all input
-     *     data is still in the window so we can still emit a stored block even
-     *     when input comes from standard input.  (This can also be done for
-     *     all blocks if lit_bufsize is not greater than 32K.)
-     *   - if compression is not successful for a file smaller than 64K, we can
-     *     even emit a stored file instead of a stored block (saving 5 bytes).
-     *     This is applicable only for zip (not gzip or zlib).
-     *   - creating new Huffman trees less frequently may not provide fast
-     *     adaptation to changes in the input data statistics. (Take for
-     *     example a binary file with poorly compressible code followed by
-     *     a highly compressible string table.) Smaller buffer sizes give
-     *     fast adaptation but have of course the overhead of transmitting
-     *     trees more frequently.
-     *   - I can't count above 4
-     */
-    uInt sym_next;      /* running index in sym_buf */
-    uInt sym_end;       /* symbol table full when sym_next reaches this */
-    ulg opt_len;        /* bit length of current block with optimal trees */
-    ulg static_len;     /* bit length of current block with static trees */
-    uInt matches;       /* number of string matches in current block */
-    uInt insert;        /* bytes at end of window left to insert */
-#ifdef ZLIB_DEBUG
-    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
-    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
-#endif
-    ush bi_buf;
-    /* Output buffer. bits are inserted starting at the bottom (least
-     * significant bits).
-     */
-    int bi_valid;
-    /* Number of valid bits in bi_buf.  All bits above the last valid bit
-     * are always zero.
-     */
-    ulg high_water;
-    /* High water mark offset in window for initialized bytes -- bytes above
-     * this are set to zero in order to avoid memory check warnings when
-     * longest match routines access bytes past the input.  This is then
-     * updated to the new high water mark.
-     */
-} FAR deflate_state;
-/* Output a byte on the stream.
- * IN assertion: there is enough room in pending_buf.
- */
-#define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}
-#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
-/* Minimum amount of lookahead, except at the end of the input file.
- * See deflate.c for comments about the MIN_MATCH+1.
- */
-#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
-/* In order to simplify the code, particularly on 16 bit machines, match
- * distances are limited to MAX_DIST instead of WSIZE.
- */
-#define WIN_INIT MAX_MATCH
-/* Number of bytes after end of data in window to initialize in order to avoid
-   memory checker errors from longest match routines */
-        /* in trees.c */
-void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
-int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
-void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
-void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
-                        ulg stored_len, int last));
-#define d_code(dist) \
-   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
-/* Mapping from a distance to a distance code. dist is the distance - 1 and
- * must not have side effects. _dist_code[256] and _dist_code[257] are never
- * used.
- */
-#ifndef ZLIB_DEBUG
-/* Inline versions of _tr_tally for speed: */
-#if defined(GEN_TREES_H) || !defined(STDC)
-  extern uch ZLIB_INTERNAL _length_code[];
-  extern uch ZLIB_INTERNAL _dist_code[];
-#else
-  extern const uch ZLIB_INTERNAL _length_code[];
-  extern const uch ZLIB_INTERNAL _dist_code[];
-#endif
-# define _tr_tally_lit(s, c, flush) \
-  { uch cc = (c); \
-    s->sym_buf[s->sym_next++] = 0; \
-    s->sym_buf[s->sym_next++] = 0; \
-    s->sym_buf[s->sym_next++] = cc; \
-    s->dyn_ltree[cc].Freq++; \
-    flush = (s->sym_next == s->sym_end); \
-   }
-# define _tr_tally_dist(s, distance, length, flush) \
-  { uch len = (uch)(length); \
-    ush dist = (ush)(distance); \
-    s->sym_buf[s->sym_next++] = (uch)dist; \
-    s->sym_buf[s->sym_next++] = (uch)(dist >> 8); \
-    s->sym_buf[s->sym_next++] = len; \
-    dist--; \
-    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
-    s->dyn_dtree[d_code(dist)].Freq++; \
-    flush = (s->sym_next == s->sym_end); \
-  }
-#else
-# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
-# define _tr_tally_dist(s, distance, length, flush) \
-              flush = _tr_tally(s, distance, length)
-#endif
-#endif /* DEFLATE_H */

--- a/src/native/external/zlib/gzlib.c
+++ b//dev/null
@@ -1,564 +0,0 @@
-/* gzlib.c -- zlib functions common to reading and writing gzip files
- * Copyright (C) 2004-2019 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "gzguts.h"
-#if defined(_WIN32) && !defined(__BORLANDC__)
-#  define LSEEK _lseeki64
-#else
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define LSEEK lseek64
-#else
-#  define LSEEK lseek
-#endif
-#endif
-/* Local functions */
-local void gz_reset OF((gz_statep));
-local gzFile gz_open OF((const void *, int, const char *));
-#if defined UNDER_CE
-/* Map the Windows error number in ERROR to a locale-dependent error message
-   string and return a pointer to it.  Typically, the values for ERROR come
-   from GetLastError.
-   The string pointed to shall not be modified by the application, but may be
-   overwritten by a subsequent call to gz_strwinerror
-   The gz_strwinerror function does not change the current setting of
-   GetLastError. */
-char ZLIB_INTERNAL *gz_strwinerror(error)
-     DWORD error;
-{
-    static char buf[1024];
-    wchar_t *msgbuf;
-    DWORD lasterr = GetLastError();
-    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
-        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-        NULL,
-        error,
-        0, /* Default language */
-        (LPVOID)&msgbuf,
-        0,
-        NULL);
-    if (chars != 0) {
-        /* If there is an \r\n appended, zap it.  */
-        if (chars >= 2
-            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
-            chars -= 2;
-            msgbuf[chars] = 0;
-        }
-        if (chars > sizeof (buf) - 1) {
-            chars = sizeof (buf) - 1;
-            msgbuf[chars] = 0;
-        }
-        wcstombs(buf, msgbuf, chars + 1);
-        LocalFree(msgbuf);
-    }
-    else {
-        sprintf(buf, "unknown win32 error (%ld)", error);
-    }
-    SetLastError(lasterr);
-    return buf;
-}
-#endif /* UNDER_CE */
-/* Reset gzip file state */
-local void gz_reset(state)
-    gz_statep state;
-{
-    state->x.have = 0;              /* no output data available */
-    if (state->mode == GZ_READ) {   /* for reading ... */
-        state->eof = 0;             /* not at end of file */
-        state->past = 0;            /* have not read past end yet */
-        state->how = LOOK;          /* look for gzip header */
-    }
-    else                            /* for writing ... */
-        state->reset = 0;           /* no deflateReset pending */
-    state->seek = 0;                /* no seek request pending */
-    gz_error(state, Z_OK, NULL);    /* clear error */
-    state->x.pos = 0;               /* no uncompressed data yet */
-    state->strm.avail_in = 0;       /* no input data yet */
-}
-/* Open a gzip file either by name or file descriptor. */
-local gzFile gz_open(path, fd, mode)
-    const void *path;
-    int fd;
-    const char *mode;
-{
-    gz_statep state;
-    z_size_t len;
-    int oflag;
-#ifdef O_CLOEXEC
-    int cloexec = 0;
-#endif
-#ifdef O_EXCL
-    int exclusive = 0;
-#endif
-    /* check input */
-    if (path == NULL)
-        return NULL;
-    /* allocate gzFile structure to return */
-    state = (gz_statep)malloc(sizeof(gz_state));
-    if (state == NULL)
-        return NULL;
-    state->size = 0;            /* no buffers allocated yet */
-    state->want = GZBUFSIZE;    /* requested buffer size */
-    state->msg = NULL;          /* no error message yet */
-    /* interpret mode */
-    state->mode = GZ_NONE;
-    state->level = Z_DEFAULT_COMPRESSION;
-    state->strategy = Z_DEFAULT_STRATEGY;
-    state->direct = 0;
-    while (*mode) {
-        if (*mode >= '0' && *mode <= '9')
-            state->level = *mode - '0';
-        else
-            switch (*mode) {
-            case 'r':
-                state->mode = GZ_READ;
-                break;
-#ifndef NO_GZCOMPRESS
-            case 'w':
-                state->mode = GZ_WRITE;
-                break;
-            case 'a':
-                state->mode = GZ_APPEND;
-                break;
-#endif
-            case '+':       /* can't read and write at the same time */
-                free(state);
-                return NULL;
-            case 'b':       /* ignore -- will request binary anyway */
-                break;
-#ifdef O_CLOEXEC
-            case 'e':
-                cloexec = 1;
-                break;
-#endif
-#ifdef O_EXCL
-            case 'x':
-                exclusive = 1;
-                break;
-#endif
-            case 'f':
-                state->strategy = Z_FILTERED;
-                break;
-            case 'h':
-                state->strategy = Z_HUFFMAN_ONLY;
-                break;
-            case 'R':
-                state->strategy = Z_RLE;
-                break;
-            case 'F':
-                state->strategy = Z_FIXED;
-                break;
-            case 'T':
-                state->direct = 1;
-                break;
-            default:        /* could consider as an error, but just ignore */
-                ;
-            }
-        mode++;
-    }
-    /* must provide an "r", "w", or "a" */
-    if (state->mode == GZ_NONE) {
-        free(state);
-        return NULL;
-    }
-    /* can't force transparent read */
-    if (state->mode == GZ_READ) {
-        if (state->direct) {
-            free(state);
-            return NULL;
-        }
-        state->direct = 1;      /* for empty file */
-    }
-    /* save the path name for error messages */
-#ifdef WIDECHAR
-    if (fd == -2) {
-        len = wcstombs(NULL, path, 0);
-        if (len == (z_size_t)-1)
-            len = 0;
-    }
-    else
-#endif
-        len = strlen((const char *)path);
-    state->path = (char *)malloc(len + 1);
-    if (state->path == NULL) {
-        free(state);
-        return NULL;
-    }
-#ifdef WIDECHAR
-    if (fd == -2)
-        if (len)
-            wcstombs(state->path, path, len + 1);
-        else
-            *(state->path) = 0;
-    else
-#endif
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-        (void)snprintf(state->path, len + 1, "%s", (const char *)path);
-#else
-        strcpy(state->path, path);
-#endif
-    /* compute the flags for open() */
-    oflag =
-#ifdef O_LARGEFILE
-        O_LARGEFILE |
-#endif
-#ifdef O_BINARY
-        O_BINARY |
-#endif
-#ifdef O_CLOEXEC
-        (cloexec ? O_CLOEXEC : 0) |
-#endif
-        (state->mode == GZ_READ ?
-         O_RDONLY :
-         (O_WRONLY | O_CREAT |
-#ifdef O_EXCL
-          (exclusive ? O_EXCL : 0) |
-#endif
-          (state->mode == GZ_WRITE ?
-           O_TRUNC :
-           O_APPEND)));
-    /* open the file with the appropriate flags (or just use fd) */
-    state->fd = fd > -1 ? fd : (
-#ifdef WIDECHAR
-        fd == -2 ? _wopen(path, oflag, 0666) :
-#endif
-        open((const char *)path, oflag, 0666));
-    if (state->fd == -1) {
-        free(state->path);
-        free(state);
-        return NULL;
-    }
-    if (state->mode == GZ_APPEND) {
-        LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
-        state->mode = GZ_WRITE;         /* simplify later checks */
-    }
-    /* save the current position for rewinding (only if reading) */
-    if (state->mode == GZ_READ) {
-        state->start = LSEEK(state->fd, 0, SEEK_CUR);
-        if (state->start == -1) state->start = 0;
-    }
-    /* initialize stream */
-    gz_reset(state);
-    /* return stream */
-    return (gzFile)state;
-}
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzopen64(path, mode)
-    const char *path;
-    const char *mode;
-{
-    return gz_open(path, -1, mode);
-}
-/* -- see zlib.h -- */
-gzFile ZEXPORT gzdopen(fd, mode)
-    int fd;
-    const char *mode;
-{
-    char *path;         /* identifier for error messages */
-    gzFile gz;
-    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
-        return NULL;
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-    (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
-#else
-    sprintf(path, "<fd:%d>", fd);   /* for debugging */
-#endif
-    gz = gz_open(path, fd, mode);
-    free(path);
-    return gz;
-}
-/* -- see zlib.h -- */
-#ifdef WIDECHAR
-gzFile ZEXPORT gzopen_w(path, mode)
-    const wchar_t *path;
-    const char *mode;
-{
-    return gz_open(path, -2, mode);
-}
-#endif
-/* -- see zlib.h -- */
-int ZEXPORT gzbuffer(file, size)
-    gzFile file;
-    unsigned size;
-{
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-    /* make sure we haven't already allocated memory */
-    if (state->size != 0)
-        return -1;
-    /* check and set requested size */
-    if ((size << 1) < size)
-        return -1;              /* need to be able to double it */
-    if (size < 2)
-        size = 2;               /* need two bytes to check magic header */
-    state->want = size;
-    return 0;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzrewind(file)
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-    /* back up and start over */
-    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
-        return -1;
-    gz_reset(state);
-    return 0;
-}
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzseek64(file, offset, whence)
-    gzFile file;
-    z_off64_t offset;
-    int whence;
-{
-    unsigned n;
-    z_off64_t ret;
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-    /* check that there's no error */
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-    /* can only seek from start or relative to current position */
-    if (whence != SEEK_SET && whence != SEEK_CUR)
-        return -1;
-    /* normalize offset to a SEEK_CUR specification */
-    if (whence == SEEK_SET)
-        offset -= state->x.pos;
-    else if (state->seek)
-        offset += state->skip;
-    state->seek = 0;
-    /* if within raw area while reading, just go there */
-    if (state->mode == GZ_READ && state->how == COPY &&
-            state->x.pos + offset >= 0) {
-        ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);
-        if (ret == -1)
-            return -1;
-        state->x.have = 0;
-        state->eof = 0;
-        state->past = 0;
-        state->seek = 0;
-        gz_error(state, Z_OK, NULL);
-        state->strm.avail_in = 0;
-        state->x.pos += offset;
-        return state->x.pos;
-    }
-    /* calculate skip amount, rewinding if needed for back seek when reading */
-    if (offset < 0) {
-        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
-            return -1;
-        offset += state->x.pos;
-        if (offset < 0)                     /* before start of file! */
-            return -1;
-        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
-            return -1;
-    }
-    /* if reading, skip what's in output buffer (one less gzgetc() check) */
-    if (state->mode == GZ_READ) {
-        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
-            (unsigned)offset : state->x.have;
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        offset -= n;
-    }
-    /* request skip (if not zero) */
-    if (offset) {
-        state->seek = 1;
-        state->skip = offset;
-    }
-    return state->x.pos + offset;
-}
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzseek(file, offset, whence)
-    gzFile file;
-    z_off_t offset;
-    int whence;
-{
-    z_off64_t ret;
-    ret = gzseek64(file, (z_off64_t)offset, whence);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gztell64(file)
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-    /* return position */
-    return state->x.pos + (state->seek ? state->skip : 0);
-}
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gztell(file)
-    gzFile file;
-{
-    z_off64_t ret;
-    ret = gztell64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-/* -- see zlib.h -- */
-z_off64_t ZEXPORT gzoffset64(file)
-    gzFile file;
-{
-    z_off64_t offset;
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return -1;
-    /* compute and return effective offset in file */
-    offset = LSEEK(state->fd, 0, SEEK_CUR);
-    if (offset == -1)
-        return -1;
-    if (state->mode == GZ_READ)             /* reading */
-        offset -= state->strm.avail_in;     /* don't count buffered input */
-    return offset;
-}
-/* -- see zlib.h -- */
-z_off_t ZEXPORT gzoffset(file)
-    gzFile file;
-{
-    z_off64_t ret;
-    ret = gzoffset64(file);
-    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzeof(file)
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return 0;
-    /* return end-of-file state */
-    return state->mode == GZ_READ ? state->past : 0;
-}
-/* -- see zlib.h -- */
-const char * ZEXPORT gzerror(file, errnum)
-    gzFile file;
-    int *errnum;
-{
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return NULL;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return NULL;
-    /* return error information */
-    if (errnum != NULL)
-        *errnum = state->err;
-    return state->err == Z_MEM_ERROR ? "out of memory" :
-                                       (state->msg == NULL ? "" : state->msg);
-}
-/* -- see zlib.h -- */
-void ZEXPORT gzclearerr(file)
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure and check integrity */
-    if (file == NULL)
-        return;
-    state = (gz_statep)file;
-    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
-        return;
-    /* clear error and end-of-file */
-    if (state->mode == GZ_READ) {
-        state->eof = 0;
-        state->past = 0;
-    }
-    gz_error(state, Z_OK, NULL);
-}
-/* Create an error message in allocated memory and set state->err and
-   state->msg accordingly.  Free any previous error message already there.  Do
-   not try to free or allocate space if the error is Z_MEM_ERROR (out of
-   memory).  Simply save the error message as a static string.  If there is an
-   allocation failure constructing the error message, then convert the error to
-   out of memory. */
-void ZLIB_INTERNAL gz_error(state, err, msg)
-    gz_statep state;
-    int err;
-    const char *msg;
-{
-    /* free previously allocated message and clear */
-    if (state->msg != NULL) {
-        if (state->err != Z_MEM_ERROR)
-            free(state->msg);
-        state->msg = NULL;
-    }
-    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
-    if (err != Z_OK && err != Z_BUF_ERROR)
-        state->x.have = 0;
-    /* set error code, and if no message, then done */
-    state->err = err;
-    if (msg == NULL)
-        return;
-    /* for an out of memory error, return literal string when requested */
-    if (err == Z_MEM_ERROR)
-        return;
-    /* construct error message with path */
-    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
-            NULL) {
-        state->err = Z_MEM_ERROR;
-        return;
-    }
-#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
-    (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
-                   "%s%s%s", state->path, ": ", msg);
-#else
-    strcpy(state->msg, state->path);
-    strcat(state->msg, ": ");
-    strcat(state->msg, msg);
-#endif
-}
-#ifndef INT_MAX
-/* portably return maximum value for an int (when limits.h presumed not
-   available) -- we need to do this to cover cases where 2's complement not
-   used, since C standard permits 1's complement and sign-bit representations,
-   otherwise we could just use ((unsigned)-1) >> 1 */
-unsigned ZLIB_INTERNAL gz_intmax()
-{
-    unsigned p, q;
-    p = 1;
-    do {
-        q = p;
-        p <<= 1;
-        p++;
-    } while (p > q);
-    return q >> 1;
-}
-#endif

--- a/src/native/external/zlib/gzread.c
+++ b//dev/null
@@ -1,572 +0,0 @@
-/* gzread.c -- zlib functions for reading gzip files
- * Copyright (C) 2004-2017 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "gzguts.h"
-/* Local functions */
-local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
-local int gz_avail OF((gz_statep));
-local int gz_look OF((gz_statep));
-local int gz_decomp OF((gz_statep));
-local int gz_fetch OF((gz_statep));
-local int gz_skip OF((gz_statep, z_off64_t));
-local z_size_t gz_read OF((gz_statep, voidp, z_size_t));
-/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
-   state->fd, and update state->eof, state->err, and state->msg as appropriate.
-   This function needs to loop on read(), since read() is not guaranteed to
-   read the number of bytes requested, depending on the type of descriptor. */
-local int gz_load(state, buf, len, have)
-    gz_statep state;
-    unsigned char *buf;
-    unsigned len;
-    unsigned *have;
-{
-    int ret;
-    unsigned get, max = ((unsigned)-1 >> 2) + 1;
-    *have = 0;
-    do {
-        get = len - *have;
-        if (get > max)
-            get = max;
-        ret = read(state->fd, buf + *have, get);
-        if (ret <= 0)
-            break;
-        *have += (unsigned)ret;
-    } while (*have < len);
-    if (ret < 0) {
-        gz_error(state, Z_ERRNO, zstrerror());
-        return -1;
-    }
-    if (ret == 0)
-        state->eof = 1;
-    return 0;
-}
-/* Load up input buffer and set eof flag if last data loaded -- return -1 on
-   error, 0 otherwise.  Note that the eof flag is set when the end of the input
-   file is reached, even though there may be unused data in the buffer.  Once
-   that data has been used, no more attempts will be made to read the file.
-   If strm->avail_in != 0, then the current data is moved to the beginning of
-   the input buffer, and then the remainder of the buffer is loaded with the
-   available data from the input file. */
-local int gz_avail(state)
-    gz_statep state;
-{
-    unsigned got;
-    z_streamp strm = &(state->strm);
-    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-    if (state->eof == 0) {
-        if (strm->avail_in) {       /* copy what's there to the start */
-            unsigned char *p = state->in;
-            unsigned const char *q = strm->next_in;
-            unsigned n = strm->avail_in;
-            do {
-                *p++ = *q++;
-            } while (--n);
-        }
-        if (gz_load(state, state->in + strm->avail_in,
-                    state->size - strm->avail_in, &got) == -1)
-            return -1;
-        strm->avail_in += got;
-        strm->next_in = state->in;
-    }
-    return 0;
-}
-/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
-   If this is the first time in, allocate required memory.  state->how will be
-   left unchanged if there is no more input data available, will be set to COPY
-   if there is no gzip header and direct copying will be performed, or it will
-   be set to GZIP for decompression.  If direct copying, then leftover input
-   data from the input buffer will be copied to the output buffer.  In that
-   case, all further file reads will be directly to either the output buffer or
-   a user buffer.  If decompressing, the inflate state will be initialized.
-   gz_look() will return 0 on success or -1 on failure. */
-local int gz_look(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-    /* allocate read buffers and inflate memory */
-    if (state->size == 0) {
-        /* allocate buffers */
-        state->in = (unsigned char *)malloc(state->want);
-        state->out = (unsigned char *)malloc(state->want << 1);
-        if (state->in == NULL || state->out == NULL) {
-            free(state->out);
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        state->size = state->want;
-        /* allocate inflate memory */
-        state->strm.zalloc = Z_NULL;
-        state->strm.zfree = Z_NULL;
-        state->strm.opaque = Z_NULL;
-        state->strm.avail_in = 0;
-        state->strm.next_in = Z_NULL;
-        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
-            free(state->out);
-            free(state->in);
-            state->size = 0;
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-    }
-    /* get at least the magic bytes in the input buffer */
-    if (strm->avail_in < 2) {
-        if (gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0)
-            return 0;
-    }
-    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
-       a logical dilemma here when considering the case of a partially written
-       gzip file, to wit, if a single 31 byte is written, then we cannot tell
-       whether this is a single-byte file, or just a partially written gzip
-       file -- for here we assume that if a gzip file is being written, then
-       the header will be written in a single operation, so that reading a
-       single byte is sufficient indication that it is not a gzip file) */
-    if (strm->avail_in > 1 &&
-            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
-        inflateReset(strm);
-        state->how = GZIP;
-        state->direct = 0;
-        return 0;
-    }
-    /* no gzip header -- if we were decoding gzip before, then this is trailing
-       garbage.  Ignore the trailing garbage and finish. */
-    if (state->direct == 0) {
-        strm->avail_in = 0;
-        state->eof = 1;
-        state->x.have = 0;
-        return 0;
-    }
-    /* doing raw i/o, copy any leftover input to output -- this assumes that
-       the output buffer is larger than the input buffer, which also assures
-       space for gzungetc() */
-    state->x.next = state->out;
-    memcpy(state->x.next, strm->next_in, strm->avail_in);
-    state->x.have = strm->avail_in;
-    strm->avail_in = 0;
-    state->how = COPY;
-    state->direct = 1;
-    return 0;
-}
-/* Decompress from input to the provided next_out and avail_out in the state.
-   On return, state->x.have and state->x.next point to the just decompressed
-   data.  If the gzip stream completes, state->how is reset to LOOK to look for
-   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
-   on success, -1 on failure. */
-local int gz_decomp(state)
-    gz_statep state;
-{
-    int ret = Z_OK;
-    unsigned had;
-    z_streamp strm = &(state->strm);
-    /* fill output buffer up to end of deflate stream */
-    had = strm->avail_out;
-    do {
-        /* get more input for inflate() */
-        if (strm->avail_in == 0 && gz_avail(state) == -1)
-            return -1;
-        if (strm->avail_in == 0) {
-            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
-            break;
-        }
-        /* decompress and handle errors */
-        ret = inflate(strm, Z_NO_FLUSH);
-        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
-            gz_error(state, Z_STREAM_ERROR,
-                     "internal error: inflate stream corrupt");
-            return -1;
-        }
-        if (ret == Z_MEM_ERROR) {
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
-            gz_error(state, Z_DATA_ERROR,
-                     strm->msg == NULL ? "compressed data error" : strm->msg);
-            return -1;
-        }
-    } while (strm->avail_out && ret != Z_STREAM_END);
-    /* update available output */
-    state->x.have = had - strm->avail_out;
-    state->x.next = strm->next_out - state->x.have;
-    /* if the gzip stream completed successfully, look for another */
-    if (ret == Z_STREAM_END)
-        state->how = LOOK;
-    /* good decompression */
-    return 0;
-}
-/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
-   Data is either copied from the input file or decompressed from the input
-   file depending on state->how.  If state->how is LOOK, then a gzip header is
-   looked for to determine whether to copy or decompress.  Returns -1 on error,
-   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
-   end of the input file has been reached and all data has been processed.  */
-local int gz_fetch(state)
-    gz_statep state;
-{
-    z_streamp strm = &(state->strm);
-    do {
-        switch(state->how) {
-        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
-            if (gz_look(state) == -1)
-                return -1;
-            if (state->how == LOOK)
-                return 0;
-            break;
-        case COPY:      /* -> COPY */
-            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
-                    == -1)
-                return -1;
-            state->x.next = state->out;
-            return 0;
-        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
-            strm->avail_out = state->size << 1;
-            strm->next_out = state->out;
-            if (gz_decomp(state) == -1)
-                return -1;
-        }
-    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
-    return 0;
-}
-/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
-local int gz_skip(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    unsigned n;
-    /* skip over len bytes or reach end-of-file, whichever comes first */
-    while (len)
-        /* skip over whatever is in output buffer */
-        if (state->x.have) {
-            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
-                (unsigned)len : state->x.have;
-            state->x.have -= n;
-            state->x.next += n;
-            state->x.pos += n;
-            len -= n;
-        }
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0)
-            break;
-        /* need more data to skip -- load up output buffer */
-        else {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return -1;
-        }
-    return 0;
-}
-/* Read len bytes into buf from file, or less than len up to the end of the
-   input.  Return the number of bytes read.  If zero is returned, either the
-   end of file was reached, or there was an error.  state->err must be
-   consulted in that case to determine which. */
-local z_size_t gz_read(state, buf, len)
-    gz_statep state;
-    voidp buf;
-    z_size_t len;
-{
-    z_size_t got;
-    unsigned n;
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return 0;
-    }
-    /* get len bytes to buf, or less than len if at the end */
-    got = 0;
-    do {
-        /* set n to the maximum amount of len that fits in an unsigned int */
-        n = (unsigned)-1;
-        if (n > len)
-            n = (unsigned)len;
-        /* first just try copying data from the output buffer */
-        if (state->x.have) {
-            if (state->x.have < n)
-                n = state->x.have;
-            memcpy(buf, state->x.next, n);
-            state->x.next += n;
-            state->x.have -= n;
-        }
-        /* output buffer empty -- return if we're at the end of the input */
-        else if (state->eof && state->strm.avail_in == 0) {
-            state->past = 1;        /* tried to read past end */
-            break;
-        }
-        /* need output data -- for small len or new stream load up our output
-           buffer */
-        else if (state->how == LOOK || n < (state->size << 1)) {
-            /* get more output, looking for header if required */
-            if (gz_fetch(state) == -1)
-                return 0;
-            continue;       /* no progress yet -- go back to copy above */
-            /* the copy above assures that we will leave with space in the
-               output buffer, allowing at least one gzungetc() to succeed */
-        }
-        /* large len -- read directly into user buffer */
-        else if (state->how == COPY) {      /* read directly */
-            if (gz_load(state, (unsigned char *)buf, n, &n) == -1)
-                return 0;
-        }
-        /* large len -- decompress directly into user buffer */
-        else {  /* state->how == GZIP */
-            state->strm.avail_out = n;
-            state->strm.next_out = (unsigned char *)buf;
-            if (gz_decomp(state) == -1)
-                return 0;
-            n = state->x.have;
-            state->x.have = 0;
-        }
-        /* update progress */
-        len -= n;
-        buf = (char *)buf + n;
-        got += n;
-        state->x.pos += n;
-    } while (len);
-    /* return number of bytes read into user buffer */
-    return got;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzread(file, buf, len)
-    gzFile file;
-    voidp buf;
-    unsigned len;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids a flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
-        return -1;
-    }
-    /* read len or fewer bytes to buf */
-    len = (unsigned)gz_read(state, buf, len);
-    /* check for an error */
-    if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
-        return -1;
-    /* return the number of bytes read (this is assured to fit in an int) */
-    return (int)len;
-}
-/* -- see zlib.h -- */
-z_size_t ZEXPORT gzfread(buf, size, nitems, file)
-    voidp buf;
-    z_size_t size;
-    z_size_t nitems;
-    gzFile file;
-{
-    z_size_t len;
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-            (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return 0;
-    /* compute bytes to read -- error on overflow */
-    len = nitems * size;
-    if (size && len / size != nitems) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
-        return 0;
-    }
-    /* read len or fewer bytes to buf, return the number of full items read */
-    return len ? gz_read(state, buf, len) / size : 0;
-}
-/* -- see zlib.h -- */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#else
-#  undef gzgetc
-#endif
-int ZEXPORT gzgetc(file)
-    gzFile file;
-{
-    unsigned char buf[1];
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-    /* try output buffer (no need to check for skip request) */
-    if (state->x.have) {
-        state->x.have--;
-        state->x.pos++;
-        return *(state->x.next)++;
-    }
-    /* nothing there -- try gz_read() */
-    return gz_read(state, buf, 1) < 1 ? -1 : buf[0];
-}
-int ZEXPORT gzgetc_(file)
-gzFile file;
-{
-    return gzgetc(file);
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzungetc(c, file)
-    int c;
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return -1;
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return -1;
-    }
-    /* can't push EOF */
-    if (c < 0)
-        return -1;
-    /* if output buffer empty, put byte at end (allows more pushing) */
-    if (state->x.have == 0) {
-        state->x.have = 1;
-        state->x.next = state->out + (state->size << 1) - 1;
-        state->x.next[0] = (unsigned char)c;
-        state->x.pos--;
-        state->past = 0;
-        return c;
-    }
-    /* if no room, give up (must have already done a gzungetc()) */
-    if (state->x.have == (state->size << 1)) {
-        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
-        return -1;
-    }
-    /* slide output data if needed and insert byte before existing data */
-    if (state->x.next == state->out) {
-        unsigned char *src = state->out + state->x.have;
-        unsigned char *dest = state->out + (state->size << 1);
-        while (src > state->out)
-            *--dest = *--src;
-        state->x.next = dest;
-    }
-    state->x.have++;
-    state->x.next--;
-    state->x.next[0] = (unsigned char)c;
-    state->x.pos--;
-    state->past = 0;
-    return c;
-}
-/* -- see zlib.h -- */
-char * ZEXPORT gzgets(file, buf, len)
-    gzFile file;
-    char *buf;
-    int len;
-{
-    unsigned left, n;
-    char *str;
-    unsigned char *eol;
-    gz_statep state;
-    /* check parameters and get internal structure */
-    if (file == NULL || buf == NULL || len < 1)
-        return NULL;
-    state = (gz_statep)file;
-    /* check that we're reading and that there's no (serious) error */
-    if (state->mode != GZ_READ ||
-        (state->err != Z_OK && state->err != Z_BUF_ERROR))
-        return NULL;
-    /* process a skip request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_skip(state, state->skip) == -1)
-            return NULL;
-    }
-    /* copy output bytes up to new line or len - 1, whichever comes first --
-       append a terminating zero to the string (we don't check for a zero in
-       the contents, let the user worry about that) */
-    str = buf;
-    left = (unsigned)len - 1;
-    if (left) do {
-        /* assure that something is in the output buffer */
-        if (state->x.have == 0 && gz_fetch(state) == -1)
-            return NULL;                /* error */
-        if (state->x.have == 0) {       /* end of file */
-            state->past = 1;            /* read past end */
-            break;                      /* return what we have */
-        }
-        /* look for end-of-line in current output buffer */
-        n = state->x.have > left ? left : state->x.have;
-        eol = (unsigned char *)memchr(state->x.next, '\n', n);
-        if (eol != NULL)
-            n = (unsigned)(eol - state->x.next) + 1;
-        /* copy through end-of-line, or remainder if not found */
-        memcpy(buf, state->x.next, n);
-        state->x.have -= n;
-        state->x.next += n;
-        state->x.pos += n;
-        left -= n;
-        buf += n;
-    } while (left && eol == NULL);
-    /* return terminated string, or if nothing, end of file */
-    if (buf == str)
-        return NULL;
-    buf[0] = 0;
-    return str;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzdirect(file)
-    gzFile file;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    /* if the state is not known, but we can find out, then do so (this is
-       mainly for right after a gzopen() or gzdopen()) */
-    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
-        (void)gz_look(state);
-    /* return 1 if transparent, 0 if processing a gzip stream */
-    return state->direct;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_r(file)
-    gzFile file;
-{
-    int ret, err;
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    /* check that we're reading */
-    if (state->mode != GZ_READ)
-        return Z_STREAM_ERROR;
-    /* free memory and close file */
-    if (state->size) {
-        inflateEnd(&(state->strm));
-        free(state->out);
-        free(state->in);
-    }
-    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    ret = close(state->fd);
-    free(state);
-    return ret ? Z_ERRNO : err;
-}

--- a/src/native/external/zlib/gzwrite.c
+++ b//dev/null
@@ -1,591 +0,0 @@
-/* gzwrite.c -- zlib functions for writing gzip files
- * Copyright (C) 2004-2019 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "gzguts.h"
-/* Local functions */
-local int gz_init OF((gz_statep));
-local int gz_comp OF((gz_statep, int));
-local int gz_zero OF((gz_statep, z_off64_t));
-local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));
-/* Initialize state for writing a gzip file.  Mark initialization by setting
-   state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
-   success. */
-local int gz_init(state)
-    gz_statep state;
-{
-    int ret;
-    z_streamp strm = &(state->strm);
-    /* allocate input buffer (double size for gzprintf) */
-    state->in = (unsigned char *)malloc(state->want << 1);
-    if (state->in == NULL) {
-        gz_error(state, Z_MEM_ERROR, "out of memory");
-        return -1;
-    }
-    /* only need output buffer and deflate state if compressing */
-    if (!state->direct) {
-        /* allocate output buffer */
-        state->out = (unsigned char *)malloc(state->want);
-        if (state->out == NULL) {
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        /* allocate deflate memory, set up for gzip compression */
-        strm->zalloc = Z_NULL;
-        strm->zfree = Z_NULL;
-        strm->opaque = Z_NULL;
-        ret = deflateInit2(strm, state->level, Z_DEFLATED,
-                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
-        if (ret != Z_OK) {
-            free(state->out);
-            free(state->in);
-            gz_error(state, Z_MEM_ERROR, "out of memory");
-            return -1;
-        }
-        strm->next_in = NULL;
-    }
-    /* mark state as initialized */
-    state->size = state->want;
-    /* initialize write buffer if compressing */
-    if (!state->direct) {
-        strm->avail_out = state->size;
-        strm->next_out = state->out;
-        state->x.next = strm->next_out;
-    }
-    return 0;
-}
-/* Compress whatever is at avail_in and next_in and write to the output file.
-   Return -1 if there is an error writing to the output file or if gz_init()
-   fails to allocate memory, otherwise 0.  flush is assumed to be a valid
-   deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
-   reset to start a new gzip stream.  If gz->direct is true, then simply write
-   to the output file without compressing, and ignore flush. */
-local int gz_comp(state, flush)
-    gz_statep state;
-    int flush;
-{
-    int ret, writ;
-    unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
-    z_streamp strm = &(state->strm);
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return -1;
-    /* write directly if requested */
-    if (state->direct) {
-        while (strm->avail_in) {
-            put = strm->avail_in > max ? max : strm->avail_in;
-            writ = write(state->fd, strm->next_in, put);
-            if (writ < 0) {
-                gz_error(state, Z_ERRNO, zstrerror());
-                return -1;
-            }
-            strm->avail_in -= (unsigned)writ;
-            strm->next_in += writ;
-        }
-        return 0;
-    }
-    /* check for a pending reset */
-    if (state->reset) {
-        /* don't start a new gzip member unless there is data to write */
-        if (strm->avail_in == 0)
-            return 0;
-        deflateReset(strm);
-        state->reset = 0;
-    }
-    /* run deflate() on provided input until it produces no more output */
-    ret = Z_OK;
-    do {
-        /* write out current buffer contents if full, or if flushing, but if
-           doing Z_FINISH then don't write until we get to Z_STREAM_END */
-        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
-            (flush != Z_FINISH || ret == Z_STREAM_END))) {
-            while (strm->next_out > state->x.next) {
-                put = strm->next_out - state->x.next > (int)max ? max :
-                      (unsigned)(strm->next_out - state->x.next);
-                writ = write(state->fd, state->x.next, put);
-                if (writ < 0) {
-                    gz_error(state, Z_ERRNO, zstrerror());
-                    return -1;
-                }
-                state->x.next += writ;
-            }
-            if (strm->avail_out == 0) {
-                strm->avail_out = state->size;
-                strm->next_out = state->out;
-                state->x.next = state->out;
-            }
-        }
-        /* compress */
-        have = strm->avail_out;
-        ret = deflate(strm, flush);
-        if (ret == Z_STREAM_ERROR) {
-            gz_error(state, Z_STREAM_ERROR,
-                      "internal error: deflate stream corrupt");
-            return -1;
-        }
-        have -= strm->avail_out;
-    } while (have);
-    /* if that completed a deflate stream, allow another to start */
-    if (flush == Z_FINISH)
-        state->reset = 1;
-    /* all done, no errors */
-    return 0;
-}
-/* Compress len zeros to output.  Return -1 on a write error or memory
-   allocation failure by gz_comp(), or 0 on success. */
-local int gz_zero(state, len)
-    gz_statep state;
-    z_off64_t len;
-{
-    int first;
-    unsigned n;
-    z_streamp strm = &(state->strm);
-    /* consume whatever's left in the input buffer */
-    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-        return -1;
-    /* compress len zeros (len guaranteed > 0) */
-    first = 1;
-    while (len) {
-        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
-            (unsigned)len : state->size;
-        if (first) {
-            memset(state->in, 0, n);
-            first = 0;
-        }
-        strm->avail_in = n;
-        strm->next_in = state->in;
-        state->x.pos += n;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return -1;
-        len -= n;
-    }
-    return 0;
-}
-/* Write len bytes from buf to file.  Return the number of bytes written.  If
-   the returned value is less than len, then there was an error. */
-local z_size_t gz_write(state, buf, len)
-    gz_statep state;
-    voidpc buf;
-    z_size_t len;
-{
-    z_size_t put = len;
-    /* if len is zero, avoid unnecessary operations */
-    if (len == 0)
-        return 0;
-    /* allocate memory if this is the first time through */
-    if (state->size == 0 && gz_init(state) == -1)
-        return 0;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return 0;
-    }
-    /* for small len, copy to input buffer, otherwise compress directly */
-    if (len < state->size) {
-        /* copy to input buffer, compress when full */
-        do {
-            unsigned have, copy;
-            if (state->strm.avail_in == 0)
-                state->strm.next_in = state->in;
-            have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
-                              state->in);
-            copy = state->size - have;
-            if (copy > len)
-                copy = (unsigned)len;
-            memcpy(state->in + have, buf, copy);
-            state->strm.avail_in += copy;
-            state->x.pos += copy;
-            buf = (const char *)buf + copy;
-            len -= copy;
-            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-        } while (len);
-    }
-    else {
-        /* consume whatever's left in the input buffer */
-        if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
-            return 0;
-        /* directly compress user buffer to file */
-        state->strm.next_in = (z_const Bytef *)buf;
-        do {
-            unsigned n = (unsigned)-1;
-            if (n > len)
-                n = (unsigned)len;
-            state->strm.avail_in = n;
-            state->x.pos += n;
-            if (gz_comp(state, Z_NO_FLUSH) == -1)
-                return 0;
-            len -= n;
-        } while (len);
-    }
-    /* input was all buffered or compressed */
-    return put;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzwrite(file, buf, len)
-    gzFile file;
-    voidpc buf;
-    unsigned len;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-    /* since an int is returned, make sure len fits in one, otherwise return
-       with an error (this avoids a flaw in the interface) */
-    if ((int)len < 0) {
-        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
-        return 0;
-    }
-    /* write len bytes from buf (the return value will fit in an int) */
-    return (int)gz_write(state, buf, len);
-}
-/* -- see zlib.h -- */
-z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)
-    voidpc buf;
-    z_size_t size;
-    z_size_t nitems;
-    gzFile file;
-{
-    z_size_t len;
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return 0;
-    state = (gz_statep)file;
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return 0;
-    /* compute bytes to read -- error on overflow */
-    len = nitems * size;
-    if (size && len / size != nitems) {
-        gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
-        return 0;
-    }
-    /* write len bytes to buf, return the number of full items written */
-    return len ? gz_write(state, buf, len) / size : 0;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzputc(file, c)
-    gzFile file;
-    int c;
-{
-    unsigned have;
-    unsigned char buf[1];
-    gz_statep state;
-    z_streamp strm;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return -1;
-    }
-    /* try writing to input buffer for speed (state->size == 0 if buffer not
-       initialized) */
-    if (state->size) {
-        if (strm->avail_in == 0)
-            strm->next_in = state->in;
-        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
-        if (have < state->size) {
-            state->in[have] = (unsigned char)c;
-            strm->avail_in++;
-            state->x.pos++;
-            return c & 0xff;
-        }
-    }
-    /* no room in buffer or not initialized, use gz_write() */
-    buf[0] = (unsigned char)c;
-    if (gz_write(state, buf, 1) != 1)
-        return -1;
-    return c & 0xff;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzputs(file, s)
-    gzFile file;
-    const char *s;
-{
-    z_size_t len, put;
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return -1;
-    state = (gz_statep)file;
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return -1;
-    /* write string */
-    len = strlen(s);
-    if ((int)len < 0 || (unsigned)len != len) {
-        gz_error(state, Z_STREAM_ERROR, "string length does not fit in int");
-        return -1;
-    }
-    put = gz_write(state, s, len);
-    return put < len ? -1 : (int)len;
-}
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#include <stdarg.h>
-/* -- see zlib.h -- */
-int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
-{
-    int len;
-    unsigned left;
-    char *next;
-    gz_statep state;
-    z_streamp strm;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return state->err;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-    /* do the printf() into the input buffer, put length in len -- the input
-       buffer is double-sized just for this function, so there is guaranteed to
-       be state->size bytes available after the current contents */
-    if (strm->avail_in == 0)
-        strm->next_in = state->in;
-    next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
-    next[state->size - 1] = 0;
-#ifdef NO_vsnprintf
-#  ifdef HAS_vsprintf_void
-    (void)vsprintf(next, format, va);
-    for (len = 0; len < state->size; len++)
-        if (next[len] == 0) break;
-#  else
-    len = vsprintf(next, format, va);
-#  endif
-#else
-#  ifdef HAS_vsnprintf_void
-    (void)vsnprintf(next, state->size, format, va);
-    len = strlen(next);
-#  else
-    len = vsnprintf(next, state->size, format, va);
-#  endif
-#endif
-    /* check that printf() results fit in buffer */
-    if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
-        return 0;
-    /* update buffer and position, compress first half if past that */
-    strm->avail_in += (unsigned)len;
-    state->x.pos += len;
-    if (strm->avail_in >= state->size) {
-        left = strm->avail_in - state->size;
-        strm->avail_in = state->size;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return state->err;
-        memmove(state->in, state->in + state->size, left);
-        strm->next_in = state->in;
-        strm->avail_in = left;
-    }
-    return len;
-}
-int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
-{
-    va_list va;
-    int ret;
-    va_start(va, format);
-    ret = gzvprintf(file, format, va);
-    va_end(va);
-    return ret;
-}
-#else /* !STDC && !Z_HAVE_STDARG_H */
-/* -- see zlib.h -- */
-int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
-    gzFile file;
-    const char *format;
-    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
-        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
-{
-    unsigned len, left;
-    char *next;
-    gz_statep state;
-    z_streamp strm;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-    /* check that can really pass pointer in ints */
-    if (sizeof(int) != sizeof(void *))
-        return Z_STREAM_ERROR;
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-    /* make sure we have some buffer space */
-    if (state->size == 0 && gz_init(state) == -1)
-        return state->error;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->error;
-    }
-    /* do the printf() into the input buffer, put length in len -- the input
-       buffer is double-sized just for this function, so there is guaranteed to
-       be state->size bytes available after the current contents */
-    if (strm->avail_in == 0)
-        strm->next_in = state->in;
-    next = (char *)(strm->next_in + strm->avail_in);
-    next[state->size - 1] = 0;
-#ifdef NO_snprintf
-#  ifdef HAS_sprintf_void
-    sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
-            a13, a14, a15, a16, a17, a18, a19, a20);
-    for (len = 0; len < size; len++)
-        if (next[len] == 0)
-            break;
-#  else
-    len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
-                  a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#else
-#  ifdef HAS_snprintf_void
-    snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
-             a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-    len = strlen(next);
-#  else
-    len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
-                   a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
-#  endif
-#endif
-    /* check that printf() results fit in buffer */
-    if (len == 0 || len >= state->size || next[state->size - 1] != 0)
-        return 0;
-    /* update buffer and position, compress first half if past that */
-    strm->avail_in += len;
-    state->x.pos += len;
-    if (strm->avail_in >= state->size) {
-        left = strm->avail_in - state->size;
-        strm->avail_in = state->size;
-        if (gz_comp(state, Z_NO_FLUSH) == -1)
-            return state->err;
-        memmove(state->in, state->in + state->size, left);
-        strm->next_in = state->in;
-        strm->avail_in = left;
-    }
-    return (int)len;
-}
-#endif
-/* -- see zlib.h -- */
-int ZEXPORT gzflush(file, flush)
-    gzFile file;
-    int flush;
-{
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-    /* check flush parameter */
-    if (flush < 0 || flush > Z_FINISH)
-        return Z_STREAM_ERROR;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-    /* compress remaining data with requested flush */
-    (void)gz_comp(state, flush);
-    return state->err;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzsetparams(file, level, strategy)
-    gzFile file;
-    int level;
-    int strategy;
-{
-    gz_statep state;
-    z_streamp strm;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    strm = &(state->strm);
-    /* check that we're writing and that there's no error */
-    if (state->mode != GZ_WRITE || state->err != Z_OK)
-        return Z_STREAM_ERROR;
-    /* if no change is requested, then do nothing */
-    if (level == state->level && strategy == state->strategy)
-        return Z_OK;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            return state->err;
-    }
-    /* change compression parameters for subsequent input */
-    if (state->size) {
-        /* flush previous input with previous parameters before changing */
-        if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
-            return state->err;
-        deflateParams(strm, level, strategy);
-    }
-    state->level = level;
-    state->strategy = strategy;
-    return Z_OK;
-}
-/* -- see zlib.h -- */
-int ZEXPORT gzclose_w(file)
-    gzFile file;
-{
-    int ret = Z_OK;
-    gz_statep state;
-    /* get internal structure */
-    if (file == NULL)
-        return Z_STREAM_ERROR;
-    state = (gz_statep)file;
-    /* check that we're writing */
-    if (state->mode != GZ_WRITE)
-        return Z_STREAM_ERROR;
-    /* check for seek request */
-    if (state->seek) {
-        state->seek = 0;
-        if (gz_zero(state, state->skip) == -1)
-            ret = state->err;
-    }
-    /* flush, free memory, and close file */
-    if (gz_comp(state, Z_FINISH) == -1)
-        ret = state->err;
-    if (state->size) {
-        if (!state->direct) {
-            (void)deflateEnd(&(state->strm));
-            free(state->out);
-        }
-        free(state->in);
-    }
-    gz_error(state, Z_OK, NULL);
-    free(state->path);
-    if (close(state->fd) == -1)
-        ret = Z_ERRNO;
-    free(state);
-    return ret;
-}

--- a/src/native/external/zlib/infback.c
+++ b//dev/null
@@ -1,593 +0,0 @@
-/* infback.c -- inflate using a call-back interface
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
-   This code is largely copied from inflate.c.  Normally either infback.o or
-   inflate.o would be linked into an application--not both.  The interface
-   with inffast.c is retained so that optimized assembler-coded versions of
-   inflate_fast() can be used with either inflate.c or infback.c.
- */
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-/* function prototypes */
-local void fixedtables OF((struct inflate_state FAR *state));
-/*
-   strm provides memory allocation functions in zalloc and zfree, or
-   Z_NULL to use the library memory allocation functions.
-   windowBits is in the range 8..15, and window is a user-supplied
-   window and output buffer that is 2**windowBits bytes.
- */
-int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
-z_streamp strm;
-int windowBits;
-unsigned char FAR *window;
-const char *version;
-int stream_size;
-{
-    struct inflate_state FAR *state;
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL || window == Z_NULL ||
-        windowBits < 8 || windowBits > 15)
-        return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-    strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
-                                               sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->dmax = 32768U;
-    state->wbits = (uInt)windowBits;
-    state->wsize = 1U << windowBits;
-    state->window = window;
-    state->wnext = 0;
-    state->whave = 0;
-    state->sane = 1;
-    return Z_OK;
-}
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-/* Macros for inflateBack(): */
-/* Load returned state from inflate_fast() */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-/* Set state from registers for inflate_fast() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-/* Assure that some input is available.  If input is requested, but denied,
-   then return a Z_BUF_ERROR from inflateBack(). */
-#define PULL() \
-    do { \
-        if (have == 0) { \
-            have = in(in_desc, &next); \
-            if (have == 0) { \
-                next = Z_NULL; \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-/* Get a byte of input into the bit accumulator, or return from inflateBack()
-   with an error if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        PULL(); \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflateBack() with
-   an error. */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-/* Assure that some output space is available, by writing out the window
-   if it's full.  If the write fails, return from inflateBack() with a
-   Z_BUF_ERROR. */
-#define ROOM() \
-    do { \
-        if (left == 0) { \
-            put = state->window; \
-            left = state->wsize; \
-            state->whave = left; \
-            if (out(out_desc, put, left)) { \
-                ret = Z_BUF_ERROR; \
-                goto inf_leave; \
-            } \
-        } \
-    } while (0)
-/*
-   strm provides the memory allocation functions and window buffer on input,
-   and provides information on the unused input on return.  For Z_DATA_ERROR
-   returns, strm will also provide an error message.
-   in() and out() are the call-back input and output functions.  When
-   inflateBack() needs more input, it calls in().  When inflateBack() has
-   filled the window with output, or when it completes with data in the
-   window, it calls out() to write out the data.  The application must not
-   change the provided input until in() is called again or inflateBack()
-   returns.  The application must not change the window/output buffer until
-   inflateBack() returns.
-   in() and out() are called with a descriptor parameter provided in the
-   inflateBack() call.  This parameter can be a structure that provides the
-   information required to do the read or write, as well as accumulated
-   information on the input and output such as totals and check values.
-   in() should return zero on failure.  out() should return non-zero on
-   failure.  If either in() or out() fails, than inflateBack() returns a
-   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
-   was in() or out() that caused in the error.  Otherwise,  inflateBack()
-   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
-   error, or Z_MEM_ERROR if it could not allocate memory for the state.
-   inflateBack() can also return Z_STREAM_ERROR if the input parameters
-   are not correct, i.e. strm is Z_NULL or the state was not initialized.
- */
-int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
-z_streamp strm;
-in_func in;
-void FAR *in_desc;
-out_func out;
-void FAR *out_desc;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-    /* Check that the strm exists and that the state was initialized */
-    if (strm == Z_NULL || strm->state == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    /* Reset the state */
-    strm->msg = Z_NULL;
-    state->mode = TYPE;
-    state->last = 0;
-    state->whave = 0;
-    next = strm->next_in;
-    have = next != Z_NULL ? strm->avail_in : 0;
-    hold = 0;
-    bits = 0;
-    put = state->window;
-    left = state->wsize;
-    /* Inflate until end of block marked as last */
-    for (;;)
-        switch (state->mode) {
-        case TYPE:
-            /* determine and dispatch block type */
-            if (state->last) {
-                BYTEBITS();
-                state->mode = DONE;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN;              /* decode codes */
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            /* get and verify stored block length */
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            /* copy stored block from input to output */
-            while (state->length != 0) {
-                copy = state->length;
-                PULL();
-                ROOM();
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            /* get dynamic table entries descriptor */
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            /* get code length code lengths (not a typo) */
-            state->have = 0;
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            /* get length and distance code code lengths */
-            state->have = 0;
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = (unsigned)(state->lens[state->have - 1]);
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (code const FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (code const FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN;
-                /* fallthrough */
-        case LEN:
-            /* use inflate_fast() if we have enough input and output */
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                if (state->whave < state->wsize)
-                    state->whave = state->wsize - left;
-                inflate_fast(strm, state->wsize);
-                LOAD();
-                break;
-            }
-            /* get a literal, length, or end-of-block code */
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            state->length = (unsigned)here.val;
-            /* process literal */
-            if (here.op == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                ROOM();
-                *put++ = (unsigned char)(state->length);
-                left--;
-                state->mode = LEN;
-                break;
-            }
-            /* process end of block */
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->mode = TYPE;
-                break;
-            }
-            /* invalid code */
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            /* length code -- get extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            /* get distance code */
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-            }
-            DROPBITS(here.bits);
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            /* get distance extra bits, if any */
-            state->extra = (unsigned)(here.op) & 15;
-            if (state->extra != 0) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-            }
-            if (state->offset > state->wsize - (state->whave < state->wsize ?
-                                                left : 0)) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            /* copy match from window to output */
-            do {
-                ROOM();
-                copy = state->wsize - state->offset;
-                if (copy < left) {
-                    from = put + copy;
-                    copy = left - copy;
-                }
-                else {
-                    from = put - state->offset;
-                    copy = left;
-                }
-                if (copy > state->length) copy = state->length;
-                state->length -= copy;
-                left -= copy;
-                do {
-                    *put++ = *from++;
-                } while (--copy);
-            } while (state->length != 0);
-            break;
-        case DONE:
-            /* inflate stream terminated properly */
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        default:
-            /* can't happen, but makes compilers happy */
-            ret = Z_STREAM_ERROR;
-            goto inf_leave;
-        }
-    /* Write leftover output and return unused input */
-  inf_leave:
-    if (left < state->wsize) {
-        if (out(out_desc, state->window, state->wsize - left) &&
-            ret == Z_STREAM_END)
-            ret = Z_BUF_ERROR;
-    }
-    strm->next_in = next;
-    strm->avail_in = have;
-    return ret;
-}
-int ZEXPORT inflateBackEnd(strm)
-z_streamp strm;
-{
-    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
-        return Z_STREAM_ERROR;
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}

--- a/src/native/external/zlib/inflate.c
+++ b//dev/null
@@ -1,1496 +0,0 @@
-/* inflate.c -- zlib decompression
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- * Change history:
- *
- * 1.2.beta0    24 Nov 2002
- * - First version -- complete rewrite of inflate to simplify code, avoid
- *   creation of window when not needed, minimize use of window when it is
- *   needed, make inffast.c even faster, implement gzip decoding, and to
- *   improve code readability and style over the previous zlib inflate code
- *
- * 1.2.beta1    25 Nov 2002
- * - Use pointers for available input and output checking in inffast.c
- * - Remove input and output counters in inffast.c
- * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
- * - Remove unnecessary second byte pull from length extra in inffast.c
- * - Unroll direct copy to three copies per loop in inffast.c
- *
- * 1.2.beta2    4 Dec 2002
- * - Change external routine names to reduce potential conflicts
- * - Correct filename to inffixed.h for fixed tables in inflate.c
- * - Make hbuf[] unsigned char to match parameter type in inflate.c
- * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
- *   to avoid negation problem on Alphas (64 bit) in inflate.c
- *
- * 1.2.beta3    22 Dec 2002
- * - Add comments on state->bits assertion in inffast.c
- * - Add comments on op field in inftrees.h
- * - Fix bug in reuse of allocated window after inflateReset()
- * - Remove bit fields--back to byte structure for speed
- * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
- * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
- * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
- * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
- * - Use local copies of stream next and avail values, as well as local bit
- *   buffer and bit count in inflate()--for speed when inflate_fast() not used
- *
- * 1.2.beta4    1 Jan 2003
- * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
- * - Move a comment on output buffer sizes from inffast.c to inflate.c
- * - Add comments in inffast.c to introduce the inflate_fast() routine
- * - Rearrange window copies in inflate_fast() for speed and simplification
- * - Unroll last copy for window match in inflate_fast()
- * - Use local copies of window variables in inflate_fast() for speed
- * - Pull out common wnext == 0 case for speed in inflate_fast()
- * - Make op and len in inflate_fast() unsigned for consistency
- * - Add FAR to lcode and dcode declarations in inflate_fast()
- * - Simplified bad distance check in inflate_fast()
- * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
- *   source file infback.c to provide a call-back interface to inflate for
- *   programs like gzip and unzip -- uses window as output buffer to avoid
- *   window copying
- *
- * 1.2.beta5    1 Jan 2003
- * - Improved inflateBack() interface to allow the caller to provide initial
- *   input in strm.
- * - Fixed stored blocks bug in inflateBack()
- *
- * 1.2.beta6    4 Jan 2003
- * - Added comments in inffast.c on effectiveness of POSTINC
- * - Typecasting all around to reduce compiler warnings
- * - Changed loops from while (1) or do {} while (1) to for (;;), again to
- *   make compilers happy
- * - Changed type of window in inflateBackInit() to unsigned char *
- *
- * 1.2.beta7    27 Jan 2003
- * - Changed many types to unsigned or unsigned short to avoid warnings
- * - Added inflateCopy() function
- *
- * 1.2.0        9 Mar 2003
- * - Changed inflateBack() interface to provide separate opaque descriptors
- *   for the in() and out() functions
- * - Changed inflateBack() argument and in_func typedef to swap the length
- *   and buffer address return values for the input function
- * - Check next_in and next_out for Z_NULL on entry to inflate()
- *
- * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
- */
-#include "zutil.h"
-#include "inftrees.h"
-#include "inflate.h"
-#include "inffast.h"
-#ifdef MAKEFIXED
-#  ifndef BUILDFIXED
-#    define BUILDFIXED
-#  endif
-#endif
-/* function prototypes */
-local int inflateStateCheck OF((z_streamp strm));
-local void fixedtables OF((struct inflate_state FAR *state));
-local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
-                           unsigned copy));
-#ifdef BUILDFIXED
-   void makefixed OF((void));
-#endif
-local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
-                              unsigned len));
-local int inflateStateCheck(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (strm == Z_NULL ||
-        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
-        return 1;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state == Z_NULL || state->strm != strm ||
-        state->mode < HEAD || state->mode > SYNC)
-        return 1;
-    return 0;
-}
-int ZEXPORT inflateResetKeep(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    strm->total_in = strm->total_out = state->total = 0;
-    strm->msg = Z_NULL;
-    if (state->wrap)        /* to support ill-conceived Java test suite */
-        strm->adler = state->wrap & 1;
-    state->mode = HEAD;
-    state->last = 0;
-    state->havedict = 0;
-    state->flags = -1;
-    state->dmax = 32768U;
-    state->head = Z_NULL;
-    state->hold = 0;
-    state->bits = 0;
-    state->lencode = state->distcode = state->next = state->codes;
-    state->sane = 1;
-    state->back = -1;
-    Tracev((stderr, "inflate: reset\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateReset(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    state->wsize = 0;
-    state->whave = 0;
-    state->wnext = 0;
-    return inflateResetKeep(strm);
-}
-int ZEXPORT inflateReset2(strm, windowBits)
-z_streamp strm;
-int windowBits;
-{
-    int wrap;
-    struct inflate_state FAR *state;
-    /* get the state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    /* extract wrap request from windowBits parameter */
-    if (windowBits < 0) {
-        if (windowBits < -15)
-            return Z_STREAM_ERROR;
-        wrap = 0;
-        windowBits = -windowBits;
-    }
-    else {
-        wrap = (windowBits >> 4) + 5;
-#ifdef GUNZIP
-        if (windowBits < 48)
-            windowBits &= 15;
-#endif
-    }
-    /* set number of window bits, free window if different */
-    if (windowBits && (windowBits < 8 || windowBits > 15))
-        return Z_STREAM_ERROR;
-    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
-        ZFREE(strm, state->window);
-        state->window = Z_NULL;
-    }
-    /* update state and reset the rest of it */
-    state->wrap = wrap;
-    state->wbits = (unsigned)windowBits;
-    return inflateReset(strm);
-}
-int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
-z_streamp strm;
-int windowBits;
-const char *version;
-int stream_size;
-{
-    int ret;
-    struct inflate_state FAR *state;
-    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
-        stream_size != (int)(sizeof(z_stream)))
-        return Z_VERSION_ERROR;
-    if (strm == Z_NULL) return Z_STREAM_ERROR;
-    strm->msg = Z_NULL;                 /* in case we return an error */
-    if (strm->zalloc == (alloc_func)0) {
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zalloc = zcalloc;
-        strm->opaque = (voidpf)0;
-#endif
-    }
-    if (strm->zfree == (free_func)0)
-#ifdef Z_SOLO
-        return Z_STREAM_ERROR;
-#else
-        strm->zfree = zcfree;
-#endif
-    state = (struct inflate_state FAR *)
-            ZALLOC(strm, 1, sizeof(struct inflate_state));
-    if (state == Z_NULL) return Z_MEM_ERROR;
-    Tracev((stderr, "inflate: allocated\n"));
-    strm->state = (struct internal_state FAR *)state;
-    state->strm = strm;
-    state->window = Z_NULL;
-    state->mode = HEAD;     /* to pass state test in inflateReset2() */
-    ret = inflateReset2(strm, windowBits);
-    if (ret != Z_OK) {
-        ZFREE(strm, state);
-        strm->state = Z_NULL;
-    }
-    return ret;
-}
-int ZEXPORT inflateInit_(strm, version, stream_size)
-z_streamp strm;
-const char *version;
-int stream_size;
-{
-    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
-}
-int ZEXPORT inflatePrime(strm, bits, value)
-z_streamp strm;
-int bits;
-int value;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (bits < 0) {
-        state->hold = 0;
-        state->bits = 0;
-        return Z_OK;
-    }
-    if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
-    value &= (1L << bits) - 1;
-    state->hold += (unsigned)value << state->bits;
-    state->bits += (uInt)bits;
-    return Z_OK;
-}
-/*
-   Return state with length and distance decoding tables and index sizes set to
-   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
-   If BUILDFIXED is defined, then instead this routine builds the tables the
-   first time it's called, and returns those tables the first time and
-   thereafter.  This reduces the size of the code by about 2K bytes, in
-   exchange for a little execution time.  However, BUILDFIXED should not be
-   used for threaded applications, since the rewriting of the tables and virgin
-   may not be thread-safe.
- */
-local void fixedtables(state)
-struct inflate_state FAR *state;
-{
-#ifdef BUILDFIXED
-    static int virgin = 1;
-    static code *lenfix, *distfix;
-    static code fixed[544];
-    /* build fixed huffman tables if first call (may not be thread safe) */
-    if (virgin) {
-        unsigned sym, bits;
-        static code *next;
-        /* literal/length table */
-        sym = 0;
-        while (sym < 144) state->lens[sym++] = 8;
-        while (sym < 256) state->lens[sym++] = 9;
-        while (sym < 280) state->lens[sym++] = 7;
-        while (sym < 288) state->lens[sym++] = 8;
-        next = fixed;
-        lenfix = next;
-        bits = 9;
-        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
-        /* distance table */
-        sym = 0;
-        while (sym < 32) state->lens[sym++] = 5;
-        distfix = next;
-        bits = 5;
-        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
-        /* do this just once */
-        virgin = 0;
-    }
-#else /* !BUILDFIXED */
-#   include "inffixed.h"
-#endif /* BUILDFIXED */
-    state->lencode = lenfix;
-    state->lenbits = 9;
-    state->distcode = distfix;
-    state->distbits = 5;
-}
-#ifdef MAKEFIXED
-#include <stdio.h>
-/*
-   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
-   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
-   those tables to stdout, which would be piped to inffixed.h.  A small program
-   can simply call makefixed to do this:
-    void makefixed(void);
-    int main(void)
-    {
-        makefixed();
-        return 0;
-    }
-   Then that can be linked with zlib built with MAKEFIXED defined and run:
-    a.out > inffixed.h
- */
-void makefixed()
-{
-    unsigned low, size;
-    struct inflate_state state;
-    fixedtables(&state);
-    puts("    /* inffixed.h -- table for decoding fixed codes");
-    puts("     * Generated automatically by makefixed().");
-    puts("     */");
-    puts("");
-    puts("    /* WARNING: this file should *not* be used by applications.");
-    puts("       It is part of the implementation of this library and is");
-    puts("       subject to change. Applications should only use zlib.h.");
-    puts("     */");
-    puts("");
-    size = 1U << 9;
-    printf("    static const code lenfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 7) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
-               state.lencode[low].bits, state.lencode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-    size = 1U << 5;
-    printf("\n    static const code distfix[%u] = {", size);
-    low = 0;
-    for (;;) {
-        if ((low % 6) == 0) printf("\n        ");
-        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
-               state.distcode[low].val);
-        if (++low == size) break;
-        putchar(',');
-    }
-    puts("\n    };");
-}
-#endif /* MAKEFIXED */
-/*
-   Update the window with the last wsize (normally 32K) bytes written before
-   returning.  If window does not exist yet, create it.  This is only called
-   when a window is already in use, or when output has been written during this
-   inflate call, but the end of the deflate stream has not been reached yet.
-   It is also called to create a window for dictionary data when a dictionary
-   is loaded.
-   Providing output buffers larger than 32K to inflate() should provide a speed
-   advantage, since only the last 32K of output is copied to the sliding window
-   upon return from inflate(), and since all distances after the first 32K of
-   output will fall in the output data, making match copies simpler and faster.
-   The advantage may be dependent on the size of the processor's data caches.
- */
-local int updatewindow(strm, end, copy)
-z_streamp strm;
-const Bytef *end;
-unsigned copy;
-{
-    struct inflate_state FAR *state;
-    unsigned dist;
-    state = (struct inflate_state FAR *)strm->state;
-    /* if it hasn't been done already, allocate space for the window */
-    if (state->window == Z_NULL) {
-        state->window = (unsigned char FAR *)
-                        ZALLOC(strm, 1U << state->wbits,
-                               sizeof(unsigned char));
-        if (state->window == Z_NULL) return 1;
-    }
-    /* if window not in use yet, initialize */
-    if (state->wsize == 0) {
-        state->wsize = 1U << state->wbits;
-        state->wnext = 0;
-        state->whave = 0;
-    }
-    /* copy state->wsize or less output bytes into the circular window */
-    if (copy >= state->wsize) {
-        zmemcpy(state->window, end - state->wsize, state->wsize);
-        state->wnext = 0;
-        state->whave = state->wsize;
-    }
-    else {
-        dist = state->wsize - state->wnext;
-        if (dist > copy) dist = copy;
-        zmemcpy(state->window + state->wnext, end - copy, dist);
-        copy -= dist;
-        if (copy) {
-            zmemcpy(state->window, end - copy, copy);
-            state->wnext = copy;
-            state->whave = state->wsize;
-        }
-        else {
-            state->wnext += dist;
-            if (state->wnext == state->wsize) state->wnext = 0;
-            if (state->whave < state->wsize) state->whave += dist;
-        }
-    }
-    return 0;
-}
-/* Macros for inflate(): */
-/* check function to use adler32() for zlib or crc32() for gzip */
-#ifdef GUNZIP
-#  define UPDATE_CHECK(check, buf, len) \
-    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
-#else
-#  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)
-#endif
-/* check macros for header crc */
-#ifdef GUNZIP
-#  define CRC2(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        check = crc32(check, hbuf, 2); \
-    } while (0)
-#  define CRC4(check, word) \
-    do { \
-        hbuf[0] = (unsigned char)(word); \
-        hbuf[1] = (unsigned char)((word) >> 8); \
-        hbuf[2] = (unsigned char)((word) >> 16); \
-        hbuf[3] = (unsigned char)((word) >> 24); \
-        check = crc32(check, hbuf, 4); \
-    } while (0)
-#endif
-/* Load registers with state in inflate() for speed */
-#define LOAD() \
-    do { \
-        put = strm->next_out; \
-        left = strm->avail_out; \
-        next = strm->next_in; \
-        have = strm->avail_in; \
-        hold = state->hold; \
-        bits = state->bits; \
-    } while (0)
-/* Restore state from registers in inflate() */
-#define RESTORE() \
-    do { \
-        strm->next_out = put; \
-        strm->avail_out = left; \
-        strm->next_in = next; \
-        strm->avail_in = have; \
-        state->hold = hold; \
-        state->bits = bits; \
-    } while (0)
-/* Clear the input bit accumulator */
-#define INITBITS() \
-    do { \
-        hold = 0; \
-        bits = 0; \
-    } while (0)
-/* Get a byte of input into the bit accumulator, or return from inflate()
-   if there is no input available. */
-#define PULLBYTE() \
-    do { \
-        if (have == 0) goto inf_leave; \
-        have--; \
-        hold += (unsigned long)(*next++) << bits; \
-        bits += 8; \
-    } while (0)
-/* Assure that there are at least n bits in the bit accumulator.  If there is
-   not enough available input to do that, then return from inflate(). */
-#define NEEDBITS(n) \
-    do { \
-        while (bits < (unsigned)(n)) \
-            PULLBYTE(); \
-    } while (0)
-/* Return the low n bits of the bit accumulator (n < 16) */
-#define BITS(n) \
-    ((unsigned)hold & ((1U << (n)) - 1))
-/* Remove n bits from the bit accumulator */
-#define DROPBITS(n) \
-    do { \
-        hold >>= (n); \
-        bits -= (unsigned)(n); \
-    } while (0)
-/* Remove zero to seven bits as needed to go to a byte boundary */
-#define BYTEBITS() \
-    do { \
-        hold >>= bits & 7; \
-        bits -= bits & 7; \
-    } while (0)
-/*
-   inflate() uses a state machine to process as much input data and generate as
-   much output data as possible before returning.  The state machine is
-   structured roughly as follows:
-    for (;;) switch (state) {
-    ...
-    case STATEn:
-        if (not enough input data or output space to make progress)
-            return;
-        ... make progress ...
-        state = STATEm;
-        break;
-    ...
-    }
-   so when inflate() is called again, the same case is attempted again, and
-   if the appropriate resources are provided, the machine proceeds to the
-   next state.  The NEEDBITS() macro is usually the way the state evaluates
-   whether it can proceed or should return.  NEEDBITS() does the return if
-   the requested bits are not available.  The typical use of the BITS macros
-   is:
-        NEEDBITS(n);
-        ... do something with BITS(n) ...
-        DROPBITS(n);
-   where NEEDBITS(n) either returns from inflate() if there isn't enough
-   input left to load n bits into the accumulator, or it continues.  BITS(n)
-   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
-   the low n bits off the accumulator.  INITBITS() clears the accumulator
-   and sets the number of available bits to zero.  BYTEBITS() discards just
-   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
-   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
-   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
-   if there is no input available.  The decoding of variable length codes uses
-   PULLBYTE() directly in order to pull just enough bytes to decode the next
-   code, and no more.
-   Some states loop until they get enough input, making sure that enough
-   state information is maintained to continue the loop where it left off
-   if NEEDBITS() returns in the loop.  For example, want, need, and keep
-   would all have to actually be part of the saved state in case NEEDBITS()
-   returns:
-    case STATEw:
-        while (want < need) {
-            NEEDBITS(n);
-            keep[want++] = BITS(n);
-            DROPBITS(n);
-        }
-        state = STATEx;
-    case STATEx:
-   As shown above, if the next state is also the next case, then the break
-   is omitted.
-   A state may also return if there is not enough output space available to
-   complete that state.  Those states are copying stored data, writing a
-   literal byte, and copying a matching string.
-   When returning, a "goto inf_leave" is used to update the total counters,
-   update the check value, and determine whether any progress has been made
-   during that inflate() call in order to return the proper return code.
-   Progress is defined as a change in either strm->avail_in or strm->avail_out.
-   When there is a window, goto inf_leave will update the window with the last
-   output written.  If a goto inf_leave occurs in the middle of decompression
-   and there is no window currently, goto inf_leave will create one and copy
-   output to the window for the next call of inflate().
-   In this implementation, the flush parameter of inflate() only affects the
-   return code (per zlib.h).  inflate() always writes as much as possible to
-   strm->next_out, given the space available and the provided input--the effect
-   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
-   the allocation of and copying into a sliding window until necessary, which
-   provides the effect documented in zlib.h for Z_FINISH when the entire input
-   stream available.  So the only thing the flush parameter actually does is:
-   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
-   will return Z_BUF_ERROR if it has not reached the end of the stream.
- */
-int ZEXPORT inflate(strm, flush)
-z_streamp strm;
-int flush;
-{
-    struct inflate_state FAR *state;
-    z_const unsigned char FAR *next;    /* next input */
-    unsigned char FAR *put;     /* next output */
-    unsigned have, left;        /* available input and output */
-    unsigned long hold;         /* bit buffer */
-    unsigned bits;              /* bits in bit buffer */
-    unsigned in, out;           /* save starting available input and output */
-    unsigned copy;              /* number of stored or match bytes to copy */
-    unsigned char FAR *from;    /* where to copy match bytes from */
-    code here;                  /* current decoding table entry */
-    code last;                  /* parent table entry */
-    unsigned len;               /* length to copy for repeats, bits to drop */
-    int ret;                    /* return code */
-#ifdef GUNZIP
-    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
-#endif
-    static const unsigned short order[19] = /* permutation of code lengths */
-        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
-    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
-        (strm->next_in == Z_NULL && strm->avail_in != 0))
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
-    LOAD();
-    in = have;
-    out = left;
-    ret = Z_OK;
-    for (;;)
-        switch (state->mode) {
-        case HEAD:
-            if (state->wrap == 0) {
-                state->mode = TYPEDO;
-                break;
-            }
-            NEEDBITS(16);
-#ifdef GUNZIP
-            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
-                if (state->wbits == 0)
-                    state->wbits = 15;
-                state->check = crc32(0L, Z_NULL, 0);
-                CRC2(state->check, hold);
-                INITBITS();
-                state->mode = FLAGS;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->done = -1;
-            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
-#else
-            if (
-#endif
-                ((BITS(8) << 8) + (hold >> 8)) % 31) {
-                strm->msg = (char *)"incorrect header check";
-                state->mode = BAD;
-                break;
-            }
-            if (BITS(4) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            DROPBITS(4);
-            len = BITS(4) + 8;
-            if (state->wbits == 0)
-                state->wbits = len;
-            if (len > 15 || len > state->wbits) {
-                strm->msg = (char *)"invalid window size";
-                state->mode = BAD;
-                break;
-            }
-            state->dmax = 1U << len;
-            state->flags = 0;               /* indicate zlib header */
-            Tracev((stderr, "inflate:   zlib header ok\n"));
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = hold & 0x200 ? DICTID : TYPE;
-            INITBITS();
-            break;
-#ifdef GUNZIP
-        case FLAGS:
-            NEEDBITS(16);
-            state->flags = (int)(hold);
-            if ((state->flags & 0xff) != Z_DEFLATED) {
-                strm->msg = (char *)"unknown compression method";
-                state->mode = BAD;
-                break;
-            }
-            if (state->flags & 0xe000) {
-                strm->msg = (char *)"unknown header flags set";
-                state->mode = BAD;
-                break;
-            }
-            if (state->head != Z_NULL)
-                state->head->text = (int)((hold >> 8) & 1);
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = TIME;
-                /* fallthrough */
-        case TIME:
-            NEEDBITS(32);
-            if (state->head != Z_NULL)
-                state->head->time = hold;
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC4(state->check, hold);
-            INITBITS();
-            state->mode = OS;
-                /* fallthrough */
-        case OS:
-            NEEDBITS(16);
-            if (state->head != Z_NULL) {
-                state->head->xflags = (int)(hold & 0xff);
-                state->head->os = (int)(hold >> 8);
-            }
-            if ((state->flags & 0x0200) && (state->wrap & 4))
-                CRC2(state->check, hold);
-            INITBITS();
-            state->mode = EXLEN;
-                /* fallthrough */
-        case EXLEN:
-            if (state->flags & 0x0400) {
-                NEEDBITS(16);
-                state->length = (unsigned)(hold);
-                if (state->head != Z_NULL)
-                    state->head->extra_len = (unsigned)hold;
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    CRC2(state->check, hold);
-                INITBITS();
-            }
-            else if (state->head != Z_NULL)
-                state->head->extra = Z_NULL;
-            state->mode = EXTRA;
-                /* fallthrough */
-        case EXTRA:
-            if (state->flags & 0x0400) {
-                copy = state->length;
-                if (copy > have) copy = have;
-                if (copy) {
-                    if (state->head != Z_NULL &&
-                        state->head->extra != Z_NULL &&
-                        (len = state->head->extra_len - state->length) <
-                            state->head->extra_max) {
-                        zmemcpy(state->head->extra + len, next,
-                                len + copy > state->head->extra_max ?
-                                state->head->extra_max - len : copy);
-                    }
-                    if ((state->flags & 0x0200) && (state->wrap & 4))
-                        state->check = crc32(state->check, next, copy);
-                    have -= copy;
-                    next += copy;
-                    state->length -= copy;
-                }
-                if (state->length) goto inf_leave;
-            }
-            state->length = 0;
-            state->mode = NAME;
-                /* fallthrough */
-        case NAME:
-            if (state->flags & 0x0800) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->name != Z_NULL &&
-                            state->length < state->head->name_max)
-                        state->head->name[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->name = Z_NULL;
-            state->length = 0;
-            state->mode = COMMENT;
-                /* fallthrough */
-        case COMMENT:
-            if (state->flags & 0x1000) {
-                if (have == 0) goto inf_leave;
-                copy = 0;
-                do {
-                    len = (unsigned)(next[copy++]);
-                    if (state->head != Z_NULL &&
-                            state->head->comment != Z_NULL &&
-                            state->length < state->head->comm_max)
-                        state->head->comment[state->length++] = (Bytef)len;
-                } while (len && copy < have);
-                if ((state->flags & 0x0200) && (state->wrap & 4))
-                    state->check = crc32(state->check, next, copy);
-                have -= copy;
-                next += copy;
-                if (len) goto inf_leave;
-            }
-            else if (state->head != Z_NULL)
-                state->head->comment = Z_NULL;
-            state->mode = HCRC;
-                /* fallthrough */
-        case HCRC:
-            if (state->flags & 0x0200) {
-                NEEDBITS(16);
-                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
-                    strm->msg = (char *)"header crc mismatch";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-            }
-            if (state->head != Z_NULL) {
-                state->head->hcrc = (int)((state->flags >> 9) & 1);
-                state->head->done = 1;
-            }
-            strm->adler = state->check = crc32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-            break;
-#endif
-        case DICTID:
-            NEEDBITS(32);
-            strm->adler = state->check = ZSWAP32(hold);
-            INITBITS();
-            state->mode = DICT;
-                /* fallthrough */
-        case DICT:
-            if (state->havedict == 0) {
-                RESTORE();
-                return Z_NEED_DICT;
-            }
-            strm->adler = state->check = adler32(0L, Z_NULL, 0);
-            state->mode = TYPE;
-                /* fallthrough */
-        case TYPE:
-            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case TYPEDO:
-            if (state->last) {
-                BYTEBITS();
-                state->mode = CHECK;
-                break;
-            }
-            NEEDBITS(3);
-            state->last = BITS(1);
-            DROPBITS(1);
-            switch (BITS(2)) {
-            case 0:                             /* stored block */
-                Tracev((stderr, "inflate:     stored block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = STORED;
-                break;
-            case 1:                             /* fixed block */
-                fixedtables(state);
-                Tracev((stderr, "inflate:     fixed codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = LEN_;             /* decode codes */
-                if (flush == Z_TREES) {
-                    DROPBITS(2);
-                    goto inf_leave;
-                }
-                break;
-            case 2:                             /* dynamic block */
-                Tracev((stderr, "inflate:     dynamic codes block%s\n",
-                        state->last ? " (last)" : ""));
-                state->mode = TABLE;
-                break;
-            case 3:
-                strm->msg = (char *)"invalid block type";
-                state->mode = BAD;
-            }
-            DROPBITS(2);
-            break;
-        case STORED:
-            BYTEBITS();                         /* go to byte boundary */
-            NEEDBITS(32);
-            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
-                strm->msg = (char *)"invalid stored block lengths";
-                state->mode = BAD;
-                break;
-            }
-            state->length = (unsigned)hold & 0xffff;
-            Tracev((stderr, "inflate:       stored length %u\n",
-                    state->length));
-            INITBITS();
-            state->mode = COPY_;
-            if (flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case COPY_:
-            state->mode = COPY;
-                /* fallthrough */
-        case COPY:
-            copy = state->length;
-            if (copy) {
-                if (copy > have) copy = have;
-                if (copy > left) copy = left;
-                if (copy == 0) goto inf_leave;
-                zmemcpy(put, next, copy);
-                have -= copy;
-                next += copy;
-                left -= copy;
-                put += copy;
-                state->length -= copy;
-                break;
-            }
-            Tracev((stderr, "inflate:       stored end\n"));
-            state->mode = TYPE;
-            break;
-        case TABLE:
-            NEEDBITS(14);
-            state->nlen = BITS(5) + 257;
-            DROPBITS(5);
-            state->ndist = BITS(5) + 1;
-            DROPBITS(5);
-            state->ncode = BITS(4) + 4;
-            DROPBITS(4);
-#ifndef PKZIP_BUG_WORKAROUND
-            if (state->nlen > 286 || state->ndist > 30) {
-                strm->msg = (char *)"too many length or distance symbols";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracev((stderr, "inflate:       table sizes ok\n"));
-            state->have = 0;
-            state->mode = LENLENS;
-                /* fallthrough */
-        case LENLENS:
-            while (state->have < state->ncode) {
-                NEEDBITS(3);
-                state->lens[order[state->have++]] = (unsigned short)BITS(3);
-                DROPBITS(3);
-            }
-            while (state->have < 19)
-                state->lens[order[state->have++]] = 0;
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 7;
-            ret = inflate_table(CODES, state->lens, 19, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid code lengths set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       code lengths ok\n"));
-            state->have = 0;
-            state->mode = CODELENS;
-                /* fallthrough */
-        case CODELENS:
-            while (state->have < state->nlen + state->ndist) {
-                for (;;) {
-                    here = state->lencode[BITS(state->lenbits)];
-                    if ((unsigned)(here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                if (here.val < 16) {
-                    DROPBITS(here.bits);
-                    state->lens[state->have++] = here.val;
-                }
-                else {
-                    if (here.val == 16) {
-                        NEEDBITS(here.bits + 2);
-                        DROPBITS(here.bits);
-                        if (state->have == 0) {
-                            strm->msg = (char *)"invalid bit length repeat";
-                            state->mode = BAD;
-                            break;
-                        }
-                        len = state->lens[state->have - 1];
-                        copy = 3 + BITS(2);
-                        DROPBITS(2);
-                    }
-                    else if (here.val == 17) {
-                        NEEDBITS(here.bits + 3);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 3 + BITS(3);
-                        DROPBITS(3);
-                    }
-                    else {
-                        NEEDBITS(here.bits + 7);
-                        DROPBITS(here.bits);
-                        len = 0;
-                        copy = 11 + BITS(7);
-                        DROPBITS(7);
-                    }
-                    if (state->have + copy > state->nlen + state->ndist) {
-                        strm->msg = (char *)"invalid bit length repeat";
-                        state->mode = BAD;
-                        break;
-                    }
-                    while (copy--)
-                        state->lens[state->have++] = (unsigned short)len;
-                }
-            }
-            /* handle error breaks in while */
-            if (state->mode == BAD) break;
-            /* check for end-of-block code (better have one) */
-            if (state->lens[256] == 0) {
-                strm->msg = (char *)"invalid code -- missing end-of-block";
-                state->mode = BAD;
-                break;
-            }
-            /* build code tables -- note: do not change the lenbits or distbits
-               values here (9 and 6) without reading the comments in inftrees.h
-               concerning the ENOUGH constants, which depend on those values */
-            state->next = state->codes;
-            state->lencode = (const code FAR *)(state->next);
-            state->lenbits = 9;
-            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
-                                &(state->lenbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid literal/lengths set";
-                state->mode = BAD;
-                break;
-            }
-            state->distcode = (const code FAR *)(state->next);
-            state->distbits = 6;
-            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
-                            &(state->next), &(state->distbits), state->work);
-            if (ret) {
-                strm->msg = (char *)"invalid distances set";
-                state->mode = BAD;
-                break;
-            }
-            Tracev((stderr, "inflate:       codes ok\n"));
-            state->mode = LEN_;
-            if (flush == Z_TREES) goto inf_leave;
-                /* fallthrough */
-        case LEN_:
-            state->mode = LEN;
-                /* fallthrough */
-        case LEN:
-            if (have >= 6 && left >= 258) {
-                RESTORE();
-                inflate_fast(strm, out);
-                LOAD();
-                if (state->mode == TYPE)
-                    state->back = -1;
-                break;
-            }
-            state->back = 0;
-            for (;;) {
-                here = state->lencode[BITS(state->lenbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if (here.op && (here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->lencode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            state->length = (unsigned)here.val;
-            if ((int)(here.op) == 0) {
-                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
-                        "inflate:         literal '%c'\n" :
-                        "inflate:         literal 0x%02x\n", here.val));
-                state->mode = LIT;
-                break;
-            }
-            if (here.op & 32) {
-                Tracevv((stderr, "inflate:         end of block\n"));
-                state->back = -1;
-                state->mode = TYPE;
-                break;
-            }
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid literal/length code";
-                state->mode = BAD;
-                break;
-            }
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = LENEXT;
-                /* fallthrough */
-        case LENEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->length += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-            Tracevv((stderr, "inflate:         length %u\n", state->length));
-            state->was = state->length;
-            state->mode = DIST;
-                /* fallthrough */
-        case DIST:
-            for (;;) {
-                here = state->distcode[BITS(state->distbits)];
-                if ((unsigned)(here.bits) <= bits) break;
-                PULLBYTE();
-            }
-            if ((here.op & 0xf0) == 0) {
-                last = here;
-                for (;;) {
-                    here = state->distcode[last.val +
-                            (BITS(last.bits + last.op) >> last.bits)];
-                    if ((unsigned)(last.bits + here.bits) <= bits) break;
-                    PULLBYTE();
-                }
-                DROPBITS(last.bits);
-                state->back += last.bits;
-            }
-            DROPBITS(here.bits);
-            state->back += here.bits;
-            if (here.op & 64) {
-                strm->msg = (char *)"invalid distance code";
-                state->mode = BAD;
-                break;
-            }
-            state->offset = (unsigned)here.val;
-            state->extra = (unsigned)(here.op) & 15;
-            state->mode = DISTEXT;
-                /* fallthrough */
-        case DISTEXT:
-            if (state->extra) {
-                NEEDBITS(state->extra);
-                state->offset += BITS(state->extra);
-                DROPBITS(state->extra);
-                state->back += state->extra;
-            }
-#ifdef INFLATE_STRICT
-            if (state->offset > state->dmax) {
-                strm->msg = (char *)"invalid distance too far back";
-                state->mode = BAD;
-                break;
-            }
-#endif
-            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
-            state->mode = MATCH;
-                /* fallthrough */
-        case MATCH:
-            if (left == 0) goto inf_leave;
-            copy = out - left;
-            if (state->offset > copy) {         /* copy from window */
-                copy = state->offset - copy;
-                if (copy > state->whave) {
-                    if (state->sane) {
-                        strm->msg = (char *)"invalid distance too far back";
-                        state->mode = BAD;
-                        break;
-                    }
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-                    Trace((stderr, "inflate.c too far\n"));
-                    copy -= state->whave;
-                    if (copy > state->length) copy = state->length;
-                    if (copy > left) copy = left;
-                    left -= copy;
-                    state->length -= copy;
-                    do {
-                        *put++ = 0;
-                    } while (--copy);
-                    if (state->length == 0) state->mode = LEN;
-                    break;
-#endif
-                }
-                if (copy > state->wnext) {
-                    copy -= state->wnext;
-                    from = state->window + (state->wsize - copy);
-                }
-                else
-                    from = state->window + (state->wnext - copy);
-                if (copy > state->length) copy = state->length;
-            }
-            else {                              /* copy from output */
-                from = put - state->offset;
-                copy = state->length;
-            }
-            if (copy > left) copy = left;
-            left -= copy;
-            state->length -= copy;
-            do {
-                *put++ = *from++;
-            } while (--copy);
-            if (state->length == 0) state->mode = LEN;
-            break;
-        case LIT:
-            if (left == 0) goto inf_leave;
-            *put++ = (unsigned char)(state->length);
-            left--;
-            state->mode = LEN;
-            break;
-        case CHECK:
-            if (state->wrap) {
-                NEEDBITS(32);
-                out -= left;
-                strm->total_out += out;
-                state->total += out;
-                if ((state->wrap & 4) && out)
-                    strm->adler = state->check =
-                        UPDATE_CHECK(state->check, put - out, out);
-                out = left;
-                if ((state->wrap & 4) && (
-#ifdef GUNZIP
-                     state->flags ? hold :
-#endif
-                     ZSWAP32(hold)) != state->check) {
-                    strm->msg = (char *)"incorrect data check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   check matches trailer\n"));
-            }
-#ifdef GUNZIP
-            state->mode = LENGTH;
-                /* fallthrough */
-        case LENGTH:
-            if (state->wrap && state->flags) {
-                NEEDBITS(32);
-                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {
-                    strm->msg = (char *)"incorrect length check";
-                    state->mode = BAD;
-                    break;
-                }
-                INITBITS();
-                Tracev((stderr, "inflate:   length matches trailer\n"));
-            }
-#endif
-            state->mode = DONE;
-                /* fallthrough */
-        case DONE:
-            ret = Z_STREAM_END;
-            goto inf_leave;
-        case BAD:
-            ret = Z_DATA_ERROR;
-            goto inf_leave;
-        case MEM:
-            return Z_MEM_ERROR;
-        case SYNC:
-                /* fallthrough */
-        default:
-            return Z_STREAM_ERROR;
-        }
-    /*
-       Return from inflate(), updating the total counts and the check value.
-       If there was no progress during the inflate() call, return a buffer
-       error.  Call updatewindow() to create and/or update the window state.
-       Note: a memory error from inflate() is non-recoverable.
-     */
-  inf_leave:
-    RESTORE();
-    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
-            (state->mode < CHECK || flush != Z_FINISH)))
-        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
-            state->mode = MEM;
-            return Z_MEM_ERROR;
-        }
-    in -= strm->avail_in;
-    out -= strm->avail_out;
-    strm->total_in += in;
-    strm->total_out += out;
-    state->total += out;
-    if ((state->wrap & 4) && out)
-        strm->adler = state->check =
-            UPDATE_CHECK(state->check, strm->next_out - out, out);
-    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
-                      (state->mode == TYPE ? 128 : 0) +
-                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
-    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
-        ret = Z_BUF_ERROR;
-    return ret;
-}
-int ZEXPORT inflateEnd(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm))
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->window != Z_NULL) ZFREE(strm, state->window);
-    ZFREE(strm, strm->state);
-    strm->state = Z_NULL;
-    Tracev((stderr, "inflate: end\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-Bytef *dictionary;
-uInt *dictLength;
-{
-    struct inflate_state FAR *state;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    /* copy dictionary */
-    if (state->whave && dictionary != Z_NULL) {
-        zmemcpy(dictionary, state->window + state->wnext,
-                state->whave - state->wnext);
-        zmemcpy(dictionary + state->whave - state->wnext,
-                state->window, state->wnext);
-    }
-    if (dictLength != Z_NULL)
-        *dictLength = state->whave;
-    return Z_OK;
-}
-int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
-z_streamp strm;
-const Bytef *dictionary;
-uInt dictLength;
-{
-    struct inflate_state FAR *state;
-    unsigned long dictid;
-    int ret;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (state->wrap != 0 && state->mode != DICT)
-        return Z_STREAM_ERROR;
-    /* check for correct dictionary identifier */
-    if (state->mode == DICT) {
-        dictid = adler32(0L, Z_NULL, 0);
-        dictid = adler32(dictid, dictionary, dictLength);
-        if (dictid != state->check)
-            return Z_DATA_ERROR;
-    }
-    /* copy dictionary to window using updatewindow(), which will amend the
-       existing dictionary if appropriate */
-    ret = updatewindow(strm, dictionary + dictLength, dictLength);
-    if (ret) {
-        state->mode = MEM;
-        return Z_MEM_ERROR;
-    }
-    state->havedict = 1;
-    Tracev((stderr, "inflate:   dictionary set\n"));
-    return Z_OK;
-}
-int ZEXPORT inflateGetHeader(strm, head)
-z_streamp strm;
-gz_headerp head;
-{
-    struct inflate_state FAR *state;
-    /* check state */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
-    /* save header structure */
-    state->head = head;
-    head->done = 0;
-    return Z_OK;
-}
-/*
-   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
-   or when out of input.  When called, *have is the number of pattern bytes
-   found in order so far, in 0..3.  On return *have is updated to the new
-   state.  If on return *have equals four, then the pattern was found and the
-   return value is how many bytes were read including the last byte of the
-   pattern.  If *have is less than four, then the pattern has not been found
-   yet and the return value is len.  In the latter case, syncsearch() can be
-   called again with more data and the *have state.  *have is initialized to
-   zero for the first call.
- */
-local unsigned syncsearch(have, buf, len)
-unsigned FAR *have;
-const unsigned char FAR *buf;
-unsigned len;
-{
-    unsigned got;
-    unsigned next;
-    got = *have;
-    next = 0;
-    while (next < len && got < 4) {
-        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
-            got++;
-        else if (buf[next])
-            got = 0;
-        else
-            got = 4 - got;
-        next++;
-    }
-    *have = got;
-    return next;
-}
-int ZEXPORT inflateSync(strm)
-z_streamp strm;
-{
-    unsigned len;               /* number of bytes to look at or looked at */
-    int flags;                  /* temporary to save header status */
-    unsigned long in, out;      /* temporary to save total_in and total_out */
-    unsigned char buf[4];       /* to restore bit buffer to byte string */
-    struct inflate_state FAR *state;
-    /* check parameters */
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
-    /* if first time, start search in bit buffer */
-    if (state->mode != SYNC) {
-        state->mode = SYNC;
-        state->hold <<= state->bits & 7;
-        state->bits -= state->bits & 7;
-        len = 0;
-        while (state->bits >= 8) {
-            buf[len++] = (unsigned char)(state->hold);
-            state->hold >>= 8;
-            state->bits -= 8;
-        }
-        state->have = 0;
-        syncsearch(&(state->have), buf, len);
-    }
-    /* search available input */
-    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
-    strm->avail_in -= len;
-    strm->next_in += len;
-    strm->total_in += len;
-    /* return no joy or set up to restart inflate() on a new block */
-    if (state->have != 4) return Z_DATA_ERROR;
-    if (state->flags == -1)
-        state->wrap = 0;    /* if no header yet, treat as raw */
-    else
-        state->wrap &= ~4;  /* no point in computing a check value now */
-    flags = state->flags;
-    in = strm->total_in;  out = strm->total_out;
-    inflateReset(strm);
-    strm->total_in = in;  strm->total_out = out;
-    state->flags = flags;
-    state->mode = TYPE;
-    return Z_OK;
-}
-/*
-   Returns true if inflate is currently at the end of a block generated by
-   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
-   implementation to provide an additional safety check. PPP uses
-   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
-   block. When decompressing, PPP checks that at the end of input packet,
-   inflate is waiting for these length bytes.
- */
-int ZEXPORT inflateSyncPoint(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    return state->mode == STORED && state->bits == 0;
-}
-int ZEXPORT inflateCopy(dest, source)
-z_streamp dest;
-z_streamp source;
-{
-    struct inflate_state FAR *state;
-    struct inflate_state FAR *copy;
-    unsigned char FAR *window;
-    unsigned wsize;
-    /* check input */
-    if (inflateStateCheck(source) || dest == Z_NULL)
-        return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)source->state;
-    /* allocate space */
-    copy = (struct inflate_state FAR *)
-           ZALLOC(source, 1, sizeof(struct inflate_state));
-    if (copy == Z_NULL) return Z_MEM_ERROR;
-    window = Z_NULL;
-    if (state->window != Z_NULL) {
-        window = (unsigned char FAR *)
-                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
-        if (window == Z_NULL) {
-            ZFREE(source, copy);
-            return Z_MEM_ERROR;
-        }
-    }
-    /* copy state */
-    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
-    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
-    copy->strm = dest;
-    if (state->lencode >= state->codes &&
-        state->lencode <= state->codes + ENOUGH - 1) {
-        copy->lencode = copy->codes + (state->lencode - state->codes);
-        copy->distcode = copy->codes + (state->distcode - state->codes);
-    }
-    copy->next = copy->codes + (state->next - state->codes);
-    if (window != Z_NULL) {
-        wsize = 1U << state->wbits;
-        zmemcpy(window, state->window, wsize);
-    }
-    copy->window = window;
-    dest->state = (struct internal_state FAR *)copy;
-    return Z_OK;
-}
-int ZEXPORT inflateUndermine(strm, subvert)
-z_streamp strm;
-int subvert;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
-    state->sane = !subvert;
-    return Z_OK;
-#else
-    (void)subvert;
-    state->sane = 1;
-    return Z_DATA_ERROR;
-#endif
-}
-int ZEXPORT inflateValidate(strm, check)
-z_streamp strm;
-int check;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
-    state = (struct inflate_state FAR *)strm->state;
-    if (check && state->wrap)
-        state->wrap |= 4;
-    else
-        state->wrap &= ~4;
-    return Z_OK;
-}
-long ZEXPORT inflateMark(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm))
-        return -(1L << 16);
-    state = (struct inflate_state FAR *)strm->state;
-    return (long)(((unsigned long)((long)state->back)) << 16) +
-        (state->mode == COPY ? state->length :
-            (state->mode == MATCH ? state->was - state->length : 0));
-}
-unsigned long ZEXPORT inflateCodesUsed(strm)
-z_streamp strm;
-{
-    struct inflate_state FAR *state;
-    if (inflateStateCheck(strm)) return (unsigned long)-1;
-    state = (struct inflate_state FAR *)strm->state;
-    return (unsigned long)(state->next - state->codes);
-}

--- a/src/native/external/zlib/inftrees.c
+++ b//dev/null
@@ -1,272 +0,0 @@
-/* inftrees.c -- generate Huffman trees for efficient decoding
- * Copyright (C) 1995-2022 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-#include "zutil.h"
-#include "inftrees.h"
-#define MAXBITS 15
-const char inflate_copyright[] =
-   " inflate 1.2.13 Copyright 1995-2022 Mark Adler ";
-/*
-  If you use the zlib library in a product, an acknowledgment is welcome
-  in the documentation of your product. If for some reason you cannot
-  include such an acknowledgment, I would appreciate that you keep this
-  copyright string in the executable of your product.
- */
-/*
-   Build a set of tables to decode the provided canonical Huffman code.
-   The code lengths are lens[0..codes-1].  The result starts at *table,
-   whose indices are 0..2^bits-1.  work is a writable array of at least
-   lens shorts, which is used as a work area.  type is the type of code
-   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
-   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
-   on return points to the next available entry's address.  bits is the
-   requested root table index bits, and on return it is the actual root
-   table index bits.  It will differ if the request is greater than the
-   longest code or if it is less than the shortest code.
- */
-int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
-codetype type;
-unsigned short FAR *lens;
-unsigned codes;
-code FAR * FAR *table;
-unsigned FAR *bits;
-unsigned short FAR *work;
-{
-    unsigned len;               /* a code's length in bits */
-    unsigned sym;               /* index of code symbols */
-    unsigned min, max;          /* minimum and maximum code lengths */
-    unsigned root;              /* number of index bits for root table */
-    unsigned curr;              /* number of index bits for current table */
-    unsigned drop;              /* code bits to drop for sub-table */
-    int left;                   /* number of prefix codes available */
-    unsigned used;              /* code entries in table used */
-    unsigned huff;              /* Huffman code */
-    unsigned incr;              /* for incrementing code, index */
-    unsigned fill;              /* index for replicating entries */
-    unsigned low;               /* low bits for current root entry */
-    unsigned mask;              /* mask for low root bits */
-    code here;                  /* table entry for duplication */
-    code FAR *next;             /* next available space in table */
-    const unsigned short FAR *base;     /* base value table to use */
-    const unsigned short FAR *extra;    /* extra bits table to use */
-    unsigned match;             /* use base and extra for symbol >= match */
-    unsigned short count[MAXBITS+1];    /* number of codes of each length */
-    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
-    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
-        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
-        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
-    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
-        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
-        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};
-    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
-        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
-        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
-        8193, 12289, 16385, 24577, 0, 0};
-    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
-        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
-        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
-        28, 28, 29, 29, 64, 64};
-    /*
-       Process a set of code lengths to create a canonical Huffman code.  The
-       code lengths are lens[0..codes-1].  Each length corresponds to the
-       symbols 0..codes-1.  The Huffman code is generated by first sorting the
-       symbols by length from short to long, and retaining the symbol order
-       for codes with equal lengths.  Then the code starts with all zero bits
-       for the first code of the shortest length, and the codes are integer
-       increments for the same length, and zeros are appended as the length
-       increases.  For the deflate format, these bits are stored backwards
-       from their more natural integer increment ordering, and so when the
-       decoding tables are built in the large loop below, the integer codes
-       are incremented backwards.
-       This routine assumes, but does not check, that all of the entries in
-       lens[] are in the range 0..MAXBITS.  The caller must assure this.
-       1..MAXBITS is interpreted as that code length.  zero means that that
-       symbol does not occur in this code.
-       The codes are sorted by computing a count of codes for each length,
-       creating from that a table of starting indices for each length in the
-       sorted table, and then entering the symbols in order in the sorted
-       table.  The sorted table is work[], with that space being provided by
-       the caller.
-       The length counts are used for other purposes as well, i.e. finding
-       the minimum and maximum length codes, determining if there are any
-       codes at all, checking for a valid set of lengths, and looking ahead
-       at length counts to determine sub-table sizes when building the
-       decoding tables.
-     */
-    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
-    for (len = 0; len <= MAXBITS; len++)
-        count[len] = 0;
-    for (sym = 0; sym < codes; sym++)
-        count[lens[sym]]++;
-    /* bound code lengths, force root to be within code lengths */
-    root = *bits;
-    for (max = MAXBITS; max >= 1; max--)
-        if (count[max] != 0) break;
-    if (root > max) root = max;
-    if (max == 0) {                     /* no symbols to code at all */
-        here.op = (unsigned char)64;    /* invalid code marker */
-        here.bits = (unsigned char)1;
-        here.val = (unsigned short)0;
-        *(*table)++ = here;             /* make a table to force an error */
-        *(*table)++ = here;
-        *bits = 1;
-        return 0;     /* no symbols, but wait for decoding to report error */
-    }
-    for (min = 1; min < max; min++)
-        if (count[min] != 0) break;
-    if (root < min) root = min;
-    /* check for an over-subscribed or incomplete set of lengths */
-    left = 1;
-    for (len = 1; len <= MAXBITS; len++) {
-        left <<= 1;
-        left -= count[len];
-        if (left < 0) return -1;        /* over-subscribed */
-    }
-    if (left > 0 && (type == CODES || max != 1))
-        return -1;                      /* incomplete set */
-    /* generate offsets into symbol table for each length for sorting */
-    offs[1] = 0;
-    for (len = 1; len < MAXBITS; len++)
-        offs[len + 1] = offs[len] + count[len];
-    /* sort symbols by length, by symbol order within each length */
-    for (sym = 0; sym < codes; sym++)
-        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
-    /*
-       Create and fill in decoding tables.  In this loop, the table being
-       filled is at next and has curr index bits.  The code being used is huff
-       with length len.  That code is converted to an index by dropping drop
-       bits off of the bottom.  For codes where len is less than drop + curr,
-       those top drop + curr - len bits are incremented through all values to
-       fill the table with replicated entries.
-       root is the number of index bits for the root table.  When len exceeds
-       root, sub-tables are created pointed to by the root entry with an index
-       of the low root bits of huff.  This is saved in low to check for when a
-       new sub-table should be started.  drop is zero when the root table is
-       being filled, and drop is root when sub-tables are being filled.
-       When a new sub-table is needed, it is necessary to look ahead in the
-       code lengths to determine what size sub-table is needed.  The length
-       counts are used for this, and so count[] is decremented as codes are
-       entered in the tables.
-       used keeps track of how many table entries have been allocated from the
-       provided *table space.  It is checked for LENS and DIST tables against
-       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
-       the initial root table size constants.  See the comments in inftrees.h
-       for more information.
-       sym increments through all symbols, and the loop terminates when
-       all codes of length max, i.e. all codes, have been processed.  This
-       routine permits incomplete codes, so another loop after this one fills
-       in the rest of the decoding tables with invalid code markers.
-     */
-    /* set up for code type */
-    switch (type) {
-    case CODES:
-        base = extra = work;    /* dummy value--not used */
-        match = 20;
-        break;
-    case LENS:
-        base = lbase;
-        extra = lext;
-        match = 257;
-        break;
-    default:    /* DISTS */
-        base = dbase;
-        extra = dext;
-        match = 0;
-    }
-    /* initialize state for loop */
-    huff = 0;                   /* starting code */
-    sym = 0;                    /* starting code symbol */
-    len = min;                  /* starting code length */
-    next = *table;              /* current table to fill in */
-    curr = root;                /* current table index bits */
-    drop = 0;                   /* current bits to drop from code for index */
-    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
-    used = 1U << root;          /* use root table entries */
-    mask = used - 1;            /* mask for comparing low */
-    /* check available table space */
-    if ((type == LENS && used > ENOUGH_LENS) ||
-        (type == DISTS && used > ENOUGH_DISTS))
-        return 1;
-    /* process all codes and make table entries */
-    for (;;) {
-        /* create table entry */
-        here.bits = (unsigned char)(len - drop);
-        if (work[sym] + 1U < match) {
-            here.op = (unsigned char)0;
-            here.val = work[sym];
-        }
-        else if (work[sym] >= match) {
-            here.op = (unsigned char)(extra[work[sym] - match]);
-            here.val = base[work[sym] - match];
-        }
-        else {
-            here.op = (unsigned char)(32 + 64);         /* end of block */
-            here.val = 0;
-        }
-        /* replicate for those indices with low len bits equal to huff */
-        incr = 1U << (len - drop);
-        fill = 1U << curr;
-        min = fill;                 /* save offset to next table */
-        do {
-            fill -= incr;
-            next[(huff >> drop) + fill] = here;
-        } while (fill != 0);
-        /* backwards increment the len-bit code huff */
-        incr = 1U << (len - 1);
-        while (huff & incr)
-            incr >>= 1;
-        if (incr != 0) {
-            huff &= incr - 1;
-            huff += incr;
-        }
-        else
-            huff = 0;
-        /* go to next symbol, update count, len */
-        sym++;
-        if (--(count[len]) == 0) {
-            if (len == max) break;
-            len = lens[work[sym]];
-        }
-        /* create new sub-table if needed */
-        if (len > root && (huff & mask) != low) {
-            /* if first time, transition to sub-tables */
-            if (drop == 0)
-                drop = root;
-            /* increment past last table */
-            next += min;            /* here min is 1 << curr */
-            /* determine length of next table */
-            curr = len - drop;
-            left = (int)(1 << curr);
-            while (curr + drop < max) {
-                left -= count[curr + drop];
-                if (left <= 0) break;
-                curr++;
-                left <<= 1;
-            }
-            /* check for enough space */
-            used += 1U << curr;
-            if ((type == LENS && used > ENOUGH_LENS) ||
-                (type == DISTS && used > ENOUGH_DISTS))
-                return 1;
-            /* point entry in root table to sub-table */
-            low = huff & mask;
-            (*table)[low].op = (unsigned char)curr;
-            (*table)[low].bits = (unsigned char)root;
-            (*table)[low].val = (unsigned short)(next - *table);
-        }
-    }
-    /* fill in remaining table entry if code is incomplete (guaranteed to have
-       at most one remaining entry, since if the code is incomplete, the
-       maximum code length that was allowed to get this far is one bit) */
-    if (huff != 0) {
-        here.op = (unsigned char)64;            /* invalid code marker */
-        here.bits = (unsigned char)(len - drop);
-        here.val = (unsigned short)0;
-        next[huff] = here;
-    }
-    /* set return parameters */
-    *table += used;
-    *bits = root;
-    return 0;
-}

--- a/src/native/external/zlib/inftrees.h
+++ b//dev/null
@@ -1,56 +0,0 @@
-/* inftrees.h -- header to use inftrees.c
- * Copyright (C) 1995-2005, 2010 Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* WARNING: this file should *not* be used by applications. It is
-   part of the implementation of the compression library and is
-   subject to change. Applications should only use zlib.h.
- */
-/* Structure for decoding tables.  Each entry provides either the
-   information needed to do the operation requested by the code that
-   indexed that table entry, or it provides a pointer to another
-   table that indexes more bits of the code.  op indicates whether
-   the entry is a pointer to another table, a literal, a length or
-   distance, an end-of-block, or an invalid code.  For a table
-   pointer, the low four bits of op is the number of index bits of
-   that table.  For a length or distance, the low four bits of op
-   is the number of extra bits to get after the code.  bits is
-   the number of bits in this code or part of the code to drop off
-   of the bit buffer.  val is the actual byte to output in the case
-   of a literal, the base length or distance, or the offset from
-   the current table to the next table.  Each entry is four bytes. */
-typedef struct {
-    unsigned char op;           /* operation, extra bits, table bits */
-    unsigned char bits;         /* bits in this part of the code */
-    unsigned short val;         /* offset in table or code value */
-} code;
-/* op values as set by inflate_table():
-    00000000 - literal
-    0000tttt - table link, tttt != 0 is the number of table index bits
-    0001eeee - length or distance, eeee is the number of extra bits
-    01100000 - end of block
-    01000000 - invalid code
- */
-/* Maximum size of the dynamic table.  The maximum number of code structures is
-   1444, which is the sum of 852 for literal/length codes and 592 for distance
-   codes.  These values were found by exhaustive searches using the program
-   examples/enough.c found in the zlib distribution.  The arguments to that
-   program are the number of symbols, the initial root table size, and the
-   maximum bit length of a code.  "enough 286 9 15" for literal/length codes
-   returns returns 852, and "enough 30 6 15" for distance codes returns 592.
-   The initial root table size (9 or 6) is found in the fifth argument of the
-   inflate_table() calls in inflate.c and infback.c.  If the root table size is
-   changed, then these maximum sizes would be need to be recalculated and
-   updated. */
-#define ENOUGH_LENS 852
-#define ENOUGH_DISTS 592
-#define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
-/* Type of code to build for inflate_table() */
-typedef enum {
-    CODES,
-    LENS,
-    DISTS
-} codetype;
-int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
-                             unsigned codes, code FAR * FAR *table,
-                             unsigned FAR *bits, unsigned short FAR *work));

--- a/src/native/external/zlib/trees.c
+++ b//dev/null
@@ -1,1031 +0,0 @@
-/* trees.c -- output deflated data using Huffman coding
- * Copyright (C) 1995-2021 Jean-loup Gailly
- * detect_data_type() function provided freely by Cosmin Truta, 2006
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/*
- *  ALGORITHM
- *
- *      The "deflation" process uses several Huffman trees. The more
- *      common source values are represented by shorter bit sequences.
- *
- *      Each code tree is stored in a compressed form which is itself
- * a Huffman encoding of the lengths of all the code strings (in
- * ascending order by source values).  The actual code strings are
- * reconstructed from the lengths in the inflate process, as described
- * in the deflate specification.
- *
- *  REFERENCES
- *
- *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
- *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
- *
- *      Storer, James A.
- *          Data Compression:  Methods and Theory, pp. 49-50.
- *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
- *
- *      Sedgewick, R.
- *          Algorithms, p290.
- *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
- */
-/* @(#) $Id$ */
-/* #define GEN_TREES_H */
-#include "deflate.h"
-#ifdef ZLIB_DEBUG
-#  include <ctype.h>
-#endif
-/* ===========================================================================
- * Constants
- */
-#define MAX_BL_BITS 7
-/* Bit length codes must not exceed MAX_BL_BITS bits */
-#define END_BLOCK 256
-/* end of block literal code */
-#define REP_3_6      16
-/* repeat previous bit length 3-6 times (2 bits of repeat count) */
-#define REPZ_3_10    17
-/* repeat a zero length 3-10 times  (3 bits of repeat count) */
-#define REPZ_11_138  18
-/* repeat a zero length 11-138 times  (7 bits of repeat count) */
-local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
-   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
-local const int extra_dbits[D_CODES] /* extra bits for each distance code */
-   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
-local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
-   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
-local const uch bl_order[BL_CODES]
-   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
-/* The lengths of the bit length codes are sent in order of decreasing
- * probability, to avoid transmitting the lengths for unused bit length codes.
- */
-/* ===========================================================================
- * Local data. These are initialized only once.
- */
-#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
-#if defined(GEN_TREES_H) || !defined(STDC)
-/* non ANSI compilers may not accept trees.h */
-local ct_data static_ltree[L_CODES+2];
-/* The static literal tree. Since the bit lengths are imposed, there is no
- * need for the L_CODES extra codes used during heap construction. However
- * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
- * below).
- */
-local ct_data static_dtree[D_CODES];
-/* The static distance tree. (Actually a trivial tree since all codes use
- * 5 bits.)
- */
-uch _dist_code[DIST_CODE_LEN];
-/* Distance codes. The first 256 values correspond to the distances
- * 3 .. 258, the last 256 values correspond to the top 8 bits of
- * the 15 bit distances.
- */
-uch _length_code[MAX_MATCH-MIN_MATCH+1];
-/* length code for each normalized match length (0 == MIN_MATCH) */
-local int base_length[LENGTH_CODES];
-/* First normalized length for each code (0 = MIN_MATCH) */
-local int base_dist[D_CODES];
-/* First normalized distance for each code (0 = distance of 1) */
-#else
-#  include "trees.h"
-#endif /* GEN_TREES_H */
-struct static_tree_desc_s {
-    const ct_data *static_tree;  /* static tree or NULL */
-    const intf *extra_bits;      /* extra bits for each code or NULL */
-    int     extra_base;          /* base index for extra_bits */
-    int     elems;               /* max number of elements in the tree */
-    int     max_length;          /* max bit length for the codes */
-};
-local const static_tree_desc  static_l_desc =
-{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
-local const static_tree_desc  static_d_desc =
-{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
-local const static_tree_desc  static_bl_desc =
-{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
-/* ===========================================================================
- * Local (static) routines in this file.
- */
-local void tr_static_init OF((void));
-local void init_block     OF((deflate_state *s));
-local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
-local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
-local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
-local void build_tree     OF((deflate_state *s, tree_desc *desc));
-local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
-local int  build_bl_tree  OF((deflate_state *s));
-local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
-                              int blcodes));
-local void compress_block OF((deflate_state *s, const ct_data *ltree,
-                              const ct_data *dtree));
-local int  detect_data_type OF((deflate_state *s));
-local unsigned bi_reverse OF((unsigned code, int len));
-local void bi_windup      OF((deflate_state *s));
-local void bi_flush       OF((deflate_state *s));
-#ifdef GEN_TREES_H
-local void gen_trees_header OF((void));
-#endif
-#ifndef ZLIB_DEBUG
-#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
-   /* Send a code of the given tree. c and tree must not have side effects */
-#else /* !ZLIB_DEBUG */
-#  define send_code(s, c, tree) \
-     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
-       send_bits(s, tree[c].Code, tree[c].Len); }
-#endif
-/* ===========================================================================
- * Output a short LSB first on the stream.
- * IN assertion: there is enough room in pendingBuf.
- */
-#define put_short(s, w) { \
-    put_byte(s, (uch)((w) & 0xff)); \
-    put_byte(s, (uch)((ush)(w) >> 8)); \
-}
-/* ===========================================================================
- * Send a value on a given number of bits.
- * IN assertion: length <= 16 and value fits in length bits.
- */
-#ifdef ZLIB_DEBUG
-local void send_bits      OF((deflate_state *s, int value, int length));
-local void send_bits(s, value, length)
-    deflate_state *s;
-    int value;  /* value to send */
-    int length; /* number of bits */
-{
-    Tracevv((stderr," l %2d v %4x ", length, value));
-    Assert(length > 0 && length <= 15, "invalid length");
-    s->bits_sent += (ulg)length;
-    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
-     * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))
-     * unused bits in value.
-     */
-    if (s->bi_valid > (int)Buf_size - length) {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        put_short(s, s->bi_buf);
-        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
-        s->bi_valid += length - Buf_size;
-    } else {
-        s->bi_buf |= (ush)value << s->bi_valid;
-        s->bi_valid += length;
-    }
-}
-#else /* !ZLIB_DEBUG */
-#define send_bits(s, value, length) \
-{ int len = length;\
-  if (s->bi_valid > (int)Buf_size - len) {\
-    int val = (int)value;\
-    s->bi_buf |= (ush)val << s->bi_valid;\
-    put_short(s, s->bi_buf);\
-    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
-    s->bi_valid += len - Buf_size;\
-  } else {\
-    s->bi_buf |= (ush)(value) << s->bi_valid;\
-    s->bi_valid += len;\
-  }\
-}
-#endif /* ZLIB_DEBUG */
-/* the arguments must not have side effects */
-/* ===========================================================================
- * Initialize the various 'constant' tables.
- */
-local void tr_static_init()
-{
-#if defined(GEN_TREES_H) || !defined(STDC)
-    static int static_init_done = 0;
-    int n;        /* iterates over tree elements */
-    int bits;     /* bit counter */
-    int length;   /* length value */
-    int code;     /* code value */
-    int dist;     /* distance index */
-    ush bl_count[MAX_BITS+1];
-    /* number of codes at each bit length for an optimal tree */
-    if (static_init_done) return;
-    /* For some embedded targets, global variables are not initialized: */
-#ifdef NO_INIT_GLOBAL_POINTERS
-    static_l_desc.static_tree = static_ltree;
-    static_l_desc.extra_bits = extra_lbits;
-    static_d_desc.static_tree = static_dtree;
-    static_d_desc.extra_bits = extra_dbits;
-    static_bl_desc.extra_bits = extra_blbits;
-#endif
-    /* Initialize the mapping length (0..255) -> length code (0..28) */
-    length = 0;
-    for (code = 0; code < LENGTH_CODES-1; code++) {
-        base_length[code] = length;
-        for (n = 0; n < (1 << extra_lbits[code]); n++) {
-            _length_code[length++] = (uch)code;
-        }
-    }
-    Assert (length == 256, "tr_static_init: length != 256");
-    /* Note that the length 255 (match length 258) can be represented
-     * in two different ways: code 284 + 5 bits or code 285, so we
-     * overwrite length_code[255] to use the best encoding:
-     */
-    _length_code[length - 1] = (uch)code;
-    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
-    dist = 0;
-    for (code = 0 ; code < 16; code++) {
-        base_dist[code] = dist;
-        for (n = 0; n < (1 << extra_dbits[code]); n++) {
-            _dist_code[dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: dist != 256");
-    dist >>= 7; /* from now on, all distances are divided by 128 */
-    for ( ; code < D_CODES; code++) {
-        base_dist[code] = dist << 7;
-        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
-            _dist_code[256 + dist++] = (uch)code;
-        }
-    }
-    Assert (dist == 256, "tr_static_init: 256 + dist != 512");
-    /* Construct the codes of the static literal tree */
-    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
-    n = 0;
-    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
-    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
-    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
-    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
-    /* Codes 286 and 287 do not exist, but we must include them in the
-     * tree construction to get a canonical Huffman tree (longest code
-     * all ones)
-     */
-    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
-    /* The static distance tree is trivial: */
-    for (n = 0; n < D_CODES; n++) {
-        static_dtree[n].Len = 5;
-        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
-    }
-    static_init_done = 1;
-#  ifdef GEN_TREES_H
-    gen_trees_header();
-#  endif
-#endif /* defined(GEN_TREES_H) || !defined(STDC) */
-}
-/* ===========================================================================
- * Generate the file trees.h describing the static trees.
- */
-#ifdef GEN_TREES_H
-#  ifndef ZLIB_DEBUG
-#    include <stdio.h>
-#  endif
-#  define SEPARATOR(i, last, width) \
-      ((i) == (last)? "\n};\n\n" :    \
-       ((i) % (width) == (width) - 1 ? ",\n" : ", "))
-void gen_trees_header()
-{
-    FILE *header = fopen("trees.h", "w");
-    int i;
-    Assert (header != NULL, "Can't open trees.h");
-    fprintf(header,
-            "/* header created automatically with -DGEN_TREES_H */\n\n");
-    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
-    for (i = 0; i < L_CODES+2; i++) {
-        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
-                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
-    }
-    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
-                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
-    }
-    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
-    for (i = 0; i < DIST_CODE_LEN; i++) {
-        fprintf(header, "%2u%s", _dist_code[i],
-                SEPARATOR(i, DIST_CODE_LEN-1, 20));
-    }
-    fprintf(header,
-        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
-    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
-        fprintf(header, "%2u%s", _length_code[i],
-                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
-    }
-    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
-    for (i = 0; i < LENGTH_CODES; i++) {
-        fprintf(header, "%1u%s", base_length[i],
-                SEPARATOR(i, LENGTH_CODES-1, 20));
-    }
-    fprintf(header, "local const int base_dist[D_CODES] = {\n");
-    for (i = 0; i < D_CODES; i++) {
-        fprintf(header, "%5u%s", base_dist[i],
-                SEPARATOR(i, D_CODES-1, 10));
-    }
-    fclose(header);
-}
-#endif /* GEN_TREES_H */
-/* ===========================================================================
- * Initialize the tree data structures for a new zlib stream.
- */
-void ZLIB_INTERNAL _tr_init(s)
-    deflate_state *s;
-{
-    tr_static_init();
-    s->l_desc.dyn_tree = s->dyn_ltree;
-    s->l_desc.stat_desc = &static_l_desc;
-    s->d_desc.dyn_tree = s->dyn_dtree;
-    s->d_desc.stat_desc = &static_d_desc;
-    s->bl_desc.dyn_tree = s->bl_tree;
-    s->bl_desc.stat_desc = &static_bl_desc;
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = 0L;
-    s->bits_sent = 0L;
-#endif
-    /* Initialize the first block of the first file: */
-    init_block(s);
-}
-/* ===========================================================================
- * Initialize a new block.
- */
-local void init_block(s)
-    deflate_state *s;
-{
-    int n; /* iterates over tree elements */
-    /* Initialize the trees. */
-    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
-    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
-    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
-    s->dyn_ltree[END_BLOCK].Freq = 1;
-    s->opt_len = s->static_len = 0L;
-    s->sym_next = s->matches = 0;
-}
-#define SMALLEST 1
-/* Index within the heap array of least frequent node in the Huffman tree */
-/* ===========================================================================
- * Remove the smallest element from the heap and recreate the heap with
- * one less element. Updates heap and heap_len.
- */
-#define pqremove(s, tree, top) \
-{\
-    top = s->heap[SMALLEST]; \
-    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
-    pqdownheap(s, tree, SMALLEST); \
-}
-/* ===========================================================================
- * Compares to subtrees, using the tree depth as tie breaker when
- * the subtrees have equal frequency. This minimizes the worst case length.
- */
-#define smaller(tree, n, m, depth) \
-   (tree[n].Freq < tree[m].Freq || \
-   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
-/* ===========================================================================
- * Restore the heap property by moving down the tree starting at node k,
- * exchanging a node with the smallest of its two sons if necessary, stopping
- * when the heap property is re-established (each father smaller than its
- * two sons).
- */
-local void pqdownheap(s, tree, k)
-    deflate_state *s;
-    ct_data *tree;  /* the tree to restore */
-    int k;               /* node to move down */
-{
-    int v = s->heap[k];
-    int j = k << 1;  /* left son of k */
-    while (j <= s->heap_len) {
-        /* Set j to the smallest of the two sons: */
-        if (j < s->heap_len &&
-            smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
-            j++;
-        }
-        /* Exit if v is smaller than both sons */
-        if (smaller(tree, v, s->heap[j], s->depth)) break;
-        /* Exchange v with the smallest son */
-        s->heap[k] = s->heap[j];  k = j;
-        /* And continue down the tree, setting j to the left son of k */
-        j <<= 1;
-    }
-    s->heap[k] = v;
-}
-/* ===========================================================================
- * Compute the optimal bit lengths for a tree and update the total bit length
- * for the current block.
- * IN assertion: the fields freq and dad are set, heap[heap_max] and
- *    above are the tree nodes sorted by increasing frequency.
- * OUT assertions: the field len is set to the optimal bit length, the
- *     array bl_count contains the frequencies for each bit length.
- *     The length opt_len is updated; static_len is also updated if stree is
- *     not null.
- */
-local void gen_bitlen(s, desc)
-    deflate_state *s;
-    tree_desc *desc;    /* the tree descriptor */
-{
-    ct_data *tree        = desc->dyn_tree;
-    int max_code         = desc->max_code;
-    const ct_data *stree = desc->stat_desc->static_tree;
-    const intf *extra    = desc->stat_desc->extra_bits;
-    int base             = desc->stat_desc->extra_base;
-    int max_length       = desc->stat_desc->max_length;
-    int h;              /* heap index */
-    int n, m;           /* iterate over the tree elements */
-    int bits;           /* bit length */
-    int xbits;          /* extra bits */
-    ush f;              /* frequency */
-    int overflow = 0;   /* number of elements with bit length too large */
-    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
-    /* In a first pass, compute the optimal bit lengths (which may
-     * overflow in the case of the bit length tree).
-     */
-    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
-    for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
-        n = s->heap[h];
-        bits = tree[tree[n].Dad].Len + 1;
-        if (bits > max_length) bits = max_length, overflow++;
-        tree[n].Len = (ush)bits;
-        /* We overwrite tree[n].Dad which is no longer needed */
-        if (n > max_code) continue; /* not a leaf node */
-        s->bl_count[bits]++;
-        xbits = 0;
-        if (n >= base) xbits = extra[n - base];
-        f = tree[n].Freq;
-        s->opt_len += (ulg)f * (unsigned)(bits + xbits);
-        if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
-    }
-    if (overflow == 0) return;
-    Tracev((stderr,"\nbit length overflow\n"));
-    /* This happens for example on obj2 and pic of the Calgary corpus */
-    /* Find the first bit length which could increase: */
-    do {
-        bits = max_length - 1;
-        while (s->bl_count[bits] == 0) bits--;
-        s->bl_count[bits]--;        /* move one leaf down the tree */
-        s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
-        s->bl_count[max_length]--;
-        /* The brother of the overflow item also moves one step up,
-         * but this does not affect bl_count[max_length]
-         */
-        overflow -= 2;
-    } while (overflow > 0);
-    /* Now recompute all bit lengths, scanning in increasing frequency.
-     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
-     * lengths instead of fixing only the wrong ones. This idea is taken
-     * from 'ar' written by Haruhiko Okumura.)
-     */
-    for (bits = max_length; bits != 0; bits--) {
-        n = s->bl_count[bits];
-        while (n != 0) {
-            m = s->heap[--h];
-            if (m > max_code) continue;
-            if ((unsigned) tree[m].Len != (unsigned) bits) {
-                Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
-                s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
-                tree[m].Len = (ush)bits;
-            }
-            n--;
-        }
-    }
-}
-/* ===========================================================================
- * Generate the codes for a given tree and bit counts (which need not be
- * optimal).
- * IN assertion: the array bl_count contains the bit length statistics for
- * the given tree and the field len is set for all tree elements.
- * OUT assertion: the field code is set for all tree elements of non
- *     zero code length.
- */
-local void gen_codes(tree, max_code, bl_count)
-    ct_data *tree;             /* the tree to decorate */
-    int max_code;              /* largest code with non zero frequency */
-    ushf *bl_count;            /* number of codes at each bit length */
-{
-    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
-    unsigned code = 0;         /* running code value */
-    int bits;                  /* bit index */
-    int n;                     /* code index */
-    /* The distribution counts are first used to generate the code values
-     * without bit reversal.
-     */
-    for (bits = 1; bits <= MAX_BITS; bits++) {
-        code = (code + bl_count[bits - 1]) << 1;
-        next_code[bits] = (ush)code;
-    }
-    /* Check that the bit counts in bl_count are consistent. The last code
-     * must be all ones.
-     */
-    Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
-            "inconsistent bit counts");
-    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
-    for (n = 0;  n <= max_code; n++) {
-        int len = tree[n].Len;
-        if (len == 0) continue;
-        /* Now reverse the bits */
-        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
-        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
-            n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
-    }
-}
-/* ===========================================================================
- * Construct one Huffman tree and assigns the code bit strings and lengths.
- * Update the total bit length for the current block.
- * IN assertion: the field freq is set for all tree elements.
- * OUT assertions: the fields len and code are set to the optimal bit length
- *     and corresponding code. The length opt_len is updated; static_len is
- *     also updated if stree is not null. The field max_code is set.
- */
-local void build_tree(s, desc)
-    deflate_state *s;
-    tree_desc *desc; /* the tree descriptor */
-{
-    ct_data *tree         = desc->dyn_tree;
-    const ct_data *stree  = desc->stat_desc->static_tree;
-    int elems             = desc->stat_desc->elems;
-    int n, m;          /* iterate over heap elements */
-    int max_code = -1; /* largest code with non zero frequency */
-    int node;          /* new node being created */
-    /* Construct the initial heap, with least frequent element in
-     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
-     * heap[0] is not used.
-     */
-    s->heap_len = 0, s->heap_max = HEAP_SIZE;
-    for (n = 0; n < elems; n++) {
-        if (tree[n].Freq != 0) {
-            s->heap[++(s->heap_len)] = max_code = n;
-            s->depth[n] = 0;
-        } else {
-            tree[n].Len = 0;
-        }
-    }
-    /* The pkzip format requires that at least one distance code exists,
-     * and that at least one bit should be sent even if there is only one
-     * possible code. So to avoid special checks later on we force at least
-     * two codes of non zero frequency.
-     */
-    while (s->heap_len < 2) {
-        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
-        tree[node].Freq = 1;
-        s->depth[node] = 0;
-        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
-        /* node is 0 or 1 so it does not have extra bits */
-    }
-    desc->max_code = max_code;
-    /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
-     * establish sub-heaps of increasing lengths:
-     */
-    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
-    /* Construct the Huffman tree by repeatedly combining the least two
-     * frequent nodes.
-     */
-    node = elems;              /* next internal node of the tree */
-    do {
-        pqremove(s, tree, n);  /* n = node of least frequency */
-        m = s->heap[SMALLEST]; /* m = node of next least frequency */
-        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
-        s->heap[--(s->heap_max)] = m;
-        /* Create a new node father of n and m */
-        tree[node].Freq = tree[n].Freq + tree[m].Freq;
-        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
-                                s->depth[n] : s->depth[m]) + 1);
-        tree[n].Dad = tree[m].Dad = (ush)node;
-#ifdef DUMP_BL_TREE
-        if (tree == s->bl_tree) {
-            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
-                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
-        }
-#endif
-        /* and insert the new node in the heap */
-        s->heap[SMALLEST] = node++;
-        pqdownheap(s, tree, SMALLEST);
-    } while (s->heap_len >= 2);
-    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
-    /* At this point, the fields freq and dad are set. We can now
-     * generate the bit lengths.
-     */
-    gen_bitlen(s, (tree_desc *)desc);
-    /* The field len is now set, we can generate the bit codes */
-    gen_codes ((ct_data *)tree, max_code, s->bl_count);
-}
-/* ===========================================================================
- * Scan a literal or distance tree to determine the frequencies of the codes
- * in the bit length tree.
- */
-local void scan_tree(s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree;   /* the tree to be scanned */
-    int max_code;    /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    tree[max_code + 1].Len = (ush)0xffff; /* guard */
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n + 1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            s->bl_tree[curlen].Freq += count;
-        } else if (curlen != 0) {
-            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
-            s->bl_tree[REP_3_6].Freq++;
-        } else if (count <= 10) {
-            s->bl_tree[REPZ_3_10].Freq++;
-        } else {
-            s->bl_tree[REPZ_11_138].Freq++;
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-/* ===========================================================================
- * Send a literal or distance tree in compressed form, using the codes in
- * bl_tree.
- */
-local void send_tree(s, tree, max_code)
-    deflate_state *s;
-    ct_data *tree; /* the tree to be scanned */
-    int max_code;       /* and its largest code of non zero frequency */
-{
-    int n;                     /* iterates over all tree elements */
-    int prevlen = -1;          /* last emitted length */
-    int curlen;                /* length of current code */
-    int nextlen = tree[0].Len; /* length of next code */
-    int count = 0;             /* repeat count of the current code */
-    int max_count = 7;         /* max repeat count */
-    int min_count = 4;         /* min repeat count */
-    /* tree[max_code + 1].Len = -1; */  /* guard already set */
-    if (nextlen == 0) max_count = 138, min_count = 3;
-    for (n = 0; n <= max_code; n++) {
-        curlen = nextlen; nextlen = tree[n + 1].Len;
-        if (++count < max_count && curlen == nextlen) {
-            continue;
-        } else if (count < min_count) {
-            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
-        } else if (curlen != 0) {
-            if (curlen != prevlen) {
-                send_code(s, curlen, s->bl_tree); count--;
-            }
-            Assert(count >= 3 && count <= 6, " 3_6?");
-            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);
-        } else if (count <= 10) {
-            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);
-        } else {
-            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);
-        }
-        count = 0; prevlen = curlen;
-        if (nextlen == 0) {
-            max_count = 138, min_count = 3;
-        } else if (curlen == nextlen) {
-            max_count = 6, min_count = 3;
-        } else {
-            max_count = 7, min_count = 4;
-        }
-    }
-}
-/* ===========================================================================
- * Construct the Huffman tree for the bit lengths and return the index in
- * bl_order of the last bit length code to send.
- */
-local int build_bl_tree(s)
-    deflate_state *s;
-{
-    int max_blindex;  /* index of last bit length code of non zero freq */
-    /* Determine the bit length frequencies for literal and distance trees */
-    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
-    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
-    /* Build the bit length tree: */
-    build_tree(s, (tree_desc *)(&(s->bl_desc)));
-    /* opt_len now includes the length of the tree representations, except the
-     * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
-     */
-    /* Determine the number of bit length codes to send. The pkzip format
-     * requires that at least 4 bit length codes be sent. (appnote.txt says
-     * 3 but the actual value used is 4.)
-     */
-    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
-        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
-    }
-    /* Update opt_len to include the bit length tree and counts */
-    s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;
-    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
-            s->opt_len, s->static_len));
-    return max_blindex;
-}
-/* ===========================================================================
- * Send the header for a block using dynamic Huffman trees: the counts, the
- * lengths of the bit length codes, the literal tree and the distance tree.
- * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
- */
-local void send_all_trees(s, lcodes, dcodes, blcodes)
-    deflate_state *s;
-    int lcodes, dcodes, blcodes; /* number of codes for each tree */
-{
-    int rank;                    /* index in bl_order */
-    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
-    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
-            "too many codes");
-    Tracev((stderr, "\nbl counts: "));
-    send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */
-    send_bits(s, dcodes - 1,   5);
-    send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */
-    for (rank = 0; rank < blcodes; rank++) {
-        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
-        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
-    }
-    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
-    send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */
-    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
-    send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */
-    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
-}
-/* ===========================================================================
- * Send a stored block
- */
-void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */
-    bi_windup(s);        /* align on byte boundary */
-    put_short(s, (ush)stored_len);
-    put_short(s, (ush)~stored_len);
-    if (stored_len)
-        zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
-    s->pending += stored_len;
-#ifdef ZLIB_DEBUG
-    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
-    s->compressed_len += (stored_len + 4) << 3;
-    s->bits_sent += 2*16;
-    s->bits_sent += stored_len << 3;
-#endif
-}
-/* ===========================================================================
- * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
- */
-void ZLIB_INTERNAL _tr_flush_bits(s)
-    deflate_state *s;
-{
-    bi_flush(s);
-}
-/* ===========================================================================
- * Send one empty static block to give enough lookahead for inflate.
- * This takes 10 bits, of which 7 may remain in the bit buffer.
- */
-void ZLIB_INTERNAL _tr_align(s)
-    deflate_state *s;
-{
-    send_bits(s, STATIC_TREES<<1, 3);
-    send_code(s, END_BLOCK, static_ltree);
-#ifdef ZLIB_DEBUG
-    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
-#endif
-    bi_flush(s);
-}
-/* ===========================================================================
- * Determine the best encoding for the current block: dynamic trees, static
- * trees or store, and write out the encoded block.
- */
-void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
-    deflate_state *s;
-    charf *buf;       /* input block, or NULL if too old */
-    ulg stored_len;   /* length of input block */
-    int last;         /* one if this is the last block for a file */
-{
-    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
-    int max_blindex = 0;  /* index of last bit length code of non zero freq */
-    /* Build the Huffman trees unless a stored block is forced */
-    if (s->level > 0) {
-        /* Check if the file is binary or text */
-        if (s->strm->data_type == Z_UNKNOWN)
-            s->strm->data_type = detect_data_type(s);
-        /* Construct the literal and distance trees */
-        build_tree(s, (tree_desc *)(&(s->l_desc)));
-        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        build_tree(s, (tree_desc *)(&(s->d_desc)));
-        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
-                s->static_len));
-        /* At this point, opt_len and static_len are the total bit lengths of
-         * the compressed block data, excluding the tree representations.
-         */
-        /* Build the bit length tree for the above two trees, and get the index
-         * in bl_order of the last bit length code to send.
-         */
-        max_blindex = build_bl_tree(s);
-        /* Determine the best encoding. Compute the block lengths in bytes. */
-        opt_lenb = (s->opt_len + 3 + 7) >> 3;
-        static_lenb = (s->static_len + 3 + 7) >> 3;
-        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
-                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
-                s->sym_next / 3));
-#ifndef FORCE_STATIC
-        if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)
-#endif
-            opt_lenb = static_lenb;
-    } else {
-        Assert(buf != (char*)0, "lost buf");
-        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
-    }
-#ifdef FORCE_STORED
-    if (buf != (char*)0) { /* force stored block */
-#else
-    if (stored_len + 4 <= opt_lenb && buf != (char*)0) {
-                       /* 4: two words for the lengths */
-#endif
-        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
-         * Otherwise we can't have processed more than WSIZE input bytes since
-         * the last block flush, because compression would have been
-         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
-         * transform a block into a stored block.
-         */
-        _tr_stored_block(s, buf, stored_len, last);
-    } else if (static_lenb == opt_lenb) {
-        send_bits(s, (STATIC_TREES<<1) + last, 3);
-        compress_block(s, (const ct_data *)static_ltree,
-                       (const ct_data *)static_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->static_len;
-#endif
-    } else {
-        send_bits(s, (DYN_TREES<<1) + last, 3);
-        send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,
-                       max_blindex + 1);
-        compress_block(s, (const ct_data *)s->dyn_ltree,
-                       (const ct_data *)s->dyn_dtree);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 3 + s->opt_len;
-#endif
-    }
-    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
-    /* The above check is made mod 2^32, for files larger than 512 MB
-     * and uLong implemented on 32 bits.
-     */
-    init_block(s);
-    if (last) {
-        bi_windup(s);
-#ifdef ZLIB_DEBUG
-        s->compressed_len += 7;  /* align on byte boundary */
-#endif
-    }
-    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
-           s->compressed_len - 7*last));
-}
-/* ===========================================================================
- * Save the match info and tally the frequency counts. Return true if
- * the current block must be flushed.
- */
-int ZLIB_INTERNAL _tr_tally(s, dist, lc)
-    deflate_state *s;
-    unsigned dist;  /* distance of matched string */
-    unsigned lc;    /* match length - MIN_MATCH or unmatched char (dist==0) */
-{
-    s->sym_buf[s->sym_next++] = (uch)dist;
-    s->sym_buf[s->sym_next++] = (uch)(dist >> 8);
-    s->sym_buf[s->sym_next++] = (uch)lc;
-    if (dist == 0) {
-        /* lc is the unmatched char */
-        s->dyn_ltree[lc].Freq++;
-    } else {
-        s->matches++;
-        /* Here, lc is the match length - MIN_MATCH */
-        dist--;             /* dist = match distance - 1 */
-        Assert((ush)dist < (ush)MAX_DIST(s) &&
-               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
-               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
-        s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
-        s->dyn_dtree[d_code(dist)].Freq++;
-    }
-    return (s->sym_next == s->sym_end);
-}
-/* ===========================================================================
- * Send the block data compressed using the given Huffman trees
- */
-local void compress_block(s, ltree, dtree)
-    deflate_state *s;
-    const ct_data *ltree; /* literal tree */
-    const ct_data *dtree; /* distance tree */
-{
-    unsigned dist;      /* distance of matched string */
-    int lc;             /* match length or unmatched char (if dist == 0) */
-    unsigned sx = 0;    /* running index in sym_buf */
-    unsigned code;      /* the code to send */
-    int extra;          /* number of extra bits to send */
-    if (s->sym_next != 0) do {
-        dist = s->sym_buf[sx++] & 0xff;
-        dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;
-        lc = s->sym_buf[sx++];
-        if (dist == 0) {
-            send_code(s, lc, ltree); /* send a literal byte */
-            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
-        } else {
-            /* Here, lc is the match length - MIN_MATCH */
-            code = _length_code[lc];
-            send_code(s, code + LITERALS + 1, ltree);   /* send length code */
-            extra = extra_lbits[code];
-            if (extra != 0) {
-                lc -= base_length[code];
-                send_bits(s, lc, extra);       /* send the extra length bits */
-            }
-            dist--; /* dist is now the match distance - 1 */
-            code = d_code(dist);
-            Assert (code < D_CODES, "bad d_code");
-            send_code(s, code, dtree);       /* send the distance code */
-            extra = extra_dbits[code];
-            if (extra != 0) {
-                dist -= (unsigned)base_dist[code];
-                send_bits(s, dist, extra);   /* send the extra distance bits */
-            }
-        } /* literal or match pair ? */
-        /* Check that the overlay between pending_buf and sym_buf is ok: */
-        Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
-    } while (sx < s->sym_next);
-    send_code(s, END_BLOCK, ltree);
-}
-/* ===========================================================================
- * Check if the data type is TEXT or BINARY, using the following algorithm:
- * - TEXT if the two conditions below are satisfied:
- *    a) There are no non-portable control characters belonging to the
- *       "block list" (0..6, 14..25, 28..31).
- *    b) There is at least one printable character belonging to the
- *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
- * - BINARY otherwise.
- * - The following partially-portable control characters form a
- *   "gray list" that is ignored in this detection algorithm:
- *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
- * IN assertion: the fields Freq of dyn_ltree are set.
- */
-local int detect_data_type(s)
-    deflate_state *s;
-{
-    /* block_mask is the bit mask of block-listed bytes
-     * set bits 0..6, 14..25, and 28..31
-     * 0xf3ffc07f = binary 11110011111111111100000001111111
-     */
-    unsigned long block_mask = 0xf3ffc07fUL;
-    int n;
-    /* Check for non-textual ("block-listed") bytes. */
-    for (n = 0; n <= 31; n++, block_mask >>= 1)
-        if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))
-            return Z_BINARY;
-    /* Check for textual ("allow-listed") bytes. */
-    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
-            || s->dyn_ltree[13].Freq != 0)
-        return Z_TEXT;
-    for (n = 32; n < LITERALS; n++)
-        if (s->dyn_ltree[n].Freq != 0)
-            return Z_TEXT;
-    /* There are no "block-listed" or "allow-listed" bytes:
-     * this stream either is empty or has tolerated ("gray-listed") bytes only.
-     */
-    return Z_BINARY;
-}
-/* ===========================================================================
- * Reverse the first len bits of a code, using straightforward code (a faster
- * method would use a table)
- * IN assertion: 1 <= len <= 15
- */
-local unsigned bi_reverse(code, len)
-    unsigned code; /* the value to invert */
-    int len;       /* its bit length */
-{
-    register unsigned res = 0;
-    do {
-        res |= code & 1;
-        code >>= 1, res <<= 1;
-    } while (--len > 0);
-    return res >> 1;
-}
-/* ===========================================================================
- * Flush the bit buffer, keeping at most 7 bits in it.
- */
-local void bi_flush(s)
-    deflate_state *s;
-{
-    if (s->bi_valid == 16) {
-        put_short(s, s->bi_buf);
-        s->bi_buf = 0;
-        s->bi_valid = 0;
-    } else if (s->bi_valid >= 8) {
-        put_byte(s, (Byte)s->bi_buf);
-        s->bi_buf >>= 8;
-        s->bi_valid -= 8;
-    }
-}
-/* ===========================================================================
- * Flush the bit buffer and align the output on a byte boundary
- */
-local void bi_windup(s)
-    deflate_state *s;
-{
-    if (s->bi_valid > 8) {
-        put_short(s, s->bi_buf);
-    } else if (s->bi_valid > 0) {
-        put_byte(s, (Byte)s->bi_buf);
-    }
-    s->bi_buf = 0;
-    s->bi_valid = 0;
-#ifdef ZLIB_DEBUG
-    s->bits_sent = (s->bits_sent + 7) & ~7;
-#endif
-}

--- a/src/native/external/zlib/uncompr.c
+++ b//dev/null
@@ -1,81 +0,0 @@
-/* uncompr.c -- decompress a memory buffer
- * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#define ZLIB_INTERNAL
-#include "zlib.h"
-/* ===========================================================================
-     Decompresses the source buffer into the destination buffer.  *sourceLen is
-   the byte length of the source buffer. Upon entry, *destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data. (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit,
-   *destLen is the size of the decompressed data and *sourceLen is the number
-   of source bytes consumed. Upon return, source + *sourceLen points to the
-   first unused input byte.
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
-   Z_DATA_ERROR if the input data was corrupted, including if the input data is
-   an incomplete zlib stream.
-*/
-int ZEXPORT uncompress2(dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong *sourceLen;
-{
-    z_stream stream;
-    int err;
-    const uInt max = (uInt)-1;
-    uLong len, left;
-    Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
-    len = *sourceLen;
-    if (*destLen) {
-        left = *destLen;
-        *destLen = 0;
-    }
-    else {
-        left = 1;
-        dest = buf;
-    }
-    stream.next_in = (z_const Bytef *)source;
-    stream.avail_in = 0;
-    stream.zalloc = (alloc_func)0;
-    stream.zfree = (free_func)0;
-    stream.opaque = (voidpf)0;
-    err = inflateInit(&stream);
-    if (err != Z_OK) return err;
-    stream.next_out = dest;
-    stream.avail_out = 0;
-    do {
-        if (stream.avail_out == 0) {
-            stream.avail_out = left > (uLong)max ? max : (uInt)left;
-            left -= stream.avail_out;
-        }
-        if (stream.avail_in == 0) {
-            stream.avail_in = len > (uLong)max ? max : (uInt)len;
-            len -= stream.avail_in;
-        }
-        err = inflate(&stream, Z_NO_FLUSH);
-    } while (err == Z_OK);
-    *sourceLen -= len + stream.avail_in;
-    if (dest != buf)
-        *destLen = stream.total_out;
-    else if (stream.total_out && err == Z_BUF_ERROR)
-        left = 1;
-    inflateEnd(&stream);
-    return err == Z_STREAM_END ? Z_OK :
-           err == Z_NEED_DICT ? Z_DATA_ERROR  :
-           err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
-           err;
-}
-int ZEXPORT uncompress(dest, destLen, source, sourceLen)
-    Bytef *dest;
-    uLongf *destLen;
-    const Bytef *source;
-    uLong sourceLen;
-{
-    return uncompress2(dest, destLen, source, &sourceLen);
-}

--- a/src/native/external/zlib/zconf.h
+++ b//dev/null
@@ -1,501 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#ifndef ZCONF_H
-#define ZCONF_H
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-/* all linked symbols and init macros */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define adler32_z             z_adler32_z
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define crc32_combine_gen     z_crc32_combine_gen
-#  define crc32_combine_gen64   z_crc32_combine_gen64
-#  define crc32_combine_op      z_crc32_combine_op
-#  define crc32_z               z_crc32_z
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateGetDictionary  z_deflateGetDictionary
-#  define deflateInit           z_deflateInit
-#  define deflateInit2          z_deflateInit2
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzfread               z_gzfread
-#    define gzfwrite              z_gzfwrite
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzvprintf             z_gzvprintf
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit       z_inflateBackInit
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCodesUsed      z_inflateCodesUsed
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit           z_inflateInit
-#  define inflateInit2          z_inflateInit2
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateValidate       z_inflateValidate
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#    define uncompress2           z_uncompress2
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-#endif
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-#ifdef Z_SOLO
-   typedef unsigned long z_size_t;
-#else
-#  define z_longlong long long
-#  if defined(NO_SIZE_T)
-     typedef unsigned NO_SIZE_T z_size_t;
-#  elif defined(STDC)
-#    include <stddef.h>
-     typedef size_t z_size_t;
-#  else
-     typedef unsigned long z_size_t;
-#  endif
-#  undef z_longlong
-#endif
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
- for small objects.
-*/
-                        /* Type declarations */
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-#ifndef FAR
-#  define FAR
-#endif
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-#ifndef Z_HAVE_UNISTD_H
-#  ifdef __WATCOMC__
-#    define Z_HAVE_UNISTD_H
-#  endif
-#endif
-#ifndef Z_HAVE_UNISTD_H
-#  if defined(_LARGEFILE64_SOURCE) && !defined(_WIN32)
-#    define Z_HAVE_UNISTD_H
-#  endif
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-#endif /* ZCONF_H */

--- a/src/native/external/zlib/zlib.h
+++ b//dev/null
@@ -1,1643 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.13, October 13th, 2022
-  Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
-  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
-*/
-#ifndef ZLIB_H
-#define ZLIB_H
-#include "zconf.h"
-#ifdef __cplusplus
-extern "C" {
-#endif
-#define ZLIB_VERSION "1.2.13"
-#define ZLIB_VERNUM 0x12d0
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 13
-#define ZLIB_VER_SUBREVISION 0
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-    This library can optionally read and write gzip and raw deflate streams in
-  memory as well.
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in the case of corrupted input.
-*/
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-struct internal_state;
-typedef struct z_stream_s {
-    z_const Bytef *next_in;     /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total number of input bytes read so far */
-    Bytef    *next_out; /* next output byte will go here */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total number of bytes output so far */
-    z_const char *msg;  /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-    int     data_type;  /* best guess about the data type: binary or text
-                           for deflate, or the decoding state for inflate */
-    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-typedef z_stream FAR *z_streamp;
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-typedef gz_header FAR *gz_headerp;
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
-   Z_NULL on entry to the initialization function, they are set to internal
-   routines that use the standard library functions malloc() and free().
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use by the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-                        /* constants */
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field for deflate() */
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-                        /* basic functions */
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary.  Some output may be provided even if
-    flush is zero.
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending. See deflatePending(),
-  which can be used if desired to determine whether or not there is more output
-  in that case.
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed
-  codes block.
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
-  function must be called again with Z_FINISH and more output space (updated
-  avail_out) but no more input data, until it returns with Z_STREAM_END or an
-  error.  After deflate has returned Z_STREAM_END, the only possible operations
-  on the stream are deflateReset or deflateEnd.
-    Z_FINISH can be used in the first deflate call after deflateInit if all the
-  compression is to be done in a single step.  In order to complete in one
-  call, avail_out must be at least the value returned by deflateBound (see
-  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
-  output space is provided, deflate will not return Z_STREAM_END, and it must
-  be called again as described above.
-    deflate() sets strm->adler to the Adler-32 checksum of all input read
-  so far (that is, total_in bytes).  If a gzip stream is being generated, then
-  strm->adler will be the CRC-32 checksum of the input read so far.  (See
-  deflateInit2 below.)
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
-  considered binary.  This field is only for information purposes and does not
-  affect the compression algorithm in any manner.
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL or the state was inadvertently written over
-  by the application), or Z_BUF_ERROR if no progress is possible (for example
-  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
-  deflate() can be called again with more input and more output space to
-  continue compressing.
-*/
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  In the current version of inflate, the provided input is not
-   read or consumed.  The allocation of a sliding window will be deferred to
-   the first call of inflate (if the decompression does not complete on the
-   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
-   them to use default allocation functions.
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression.
-   Actual decompression will be done by inflate().  So next_in, and avail_in,
-   next_out, and avail_out are unused and unchanged.  The current
-   implementation of inflateInit() does not process any header information --
-   that is deferred until inflate() is called.
-*/
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), then next_in and avail_in are updated
-    accordingly, and processing will resume at this point for the next call of
-    inflate().
-  - Generate more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  If the
-  caller of inflate() does not provide both available input and available
-  output space, it is possible that there will be no progress made.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  To assist in this, on return inflate() always sets strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all of the uncompressed data for the
-  operation to complete.  (The size of the uncompressed data may have been
-  saved by the compressor for this purpose.)  The use of Z_FINISH is not
-  required to perform an inflation in one step.  However it may be used to
-  inform inflate that a faster approach can be used for the single inflate()
-  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
-  stream completes, which reduces inflate's memory footprint.  If the stream
-  does not complete, either because not all of the stream is provided or not
-  enough output space is provided, then a sliding window will be allocated and
-  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
-  been used.
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the effects of the flush parameter in this implementation are
-  on the return value of inflate() as noted below, when inflate() returns early
-  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
-  memory for a sliding window when Z_FINISH is used.
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the Adler-32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed Adler-32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained unless inflateGetHeader() is used.  When processing
-  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
-  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
-  uncompressed length, modulo 2^32.
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value, in which case strm->msg points to a string with a more specific
-  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL, or the state was inadvertently written over
-  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
-  if no progress was possible or if there was not enough room in the output
-  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is to be attempted.
-*/
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
-   was inconsistent.
-*/
-                        /* Advanced functions */
-/*
-    The following functions are needed only in some special applications.
-*/
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-     This is another version of deflateInit with more compression options.  The
-   fields zalloc, zfree and opaque must be initialized before by the caller.
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-     For the current implementation of deflate(), a windowBits value of 8 (a
-   window size of 256 bytes) is not supported.  As a result, a request for 8
-   will result in 9 (a 512-byte window).  In that case, providing 8 to
-   inflateInit2() will result in an error when the zlib header with 9 is
-   checked against the initialization of inflate().  The remedy is to not use 8
-   with deflateInit2() with this initialization, or at least in that case use 9
-   with inflateInit2().
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute a check value.
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to the appropriate value,
-   if the operating system was determined at compile time.  If a gzip stream is
-   being written, strm->adler is a CRC-32 instead of an Adler-32.
-     For raw deflate or gzip encoding, a request for a 256-byte window is
-   rejected as invalid, since only the zlib header provides a means of
-   transmitting the window size to the decompressor.
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  When using the zlib format, this
-   function must be called immediately after deflateInit, deflateInit2 or
-   deflateReset, and before any call of deflate.  When doing raw deflate, this
-   function must be called either before any call of deflate, or immediately
-   after the completion of a deflate block, i.e. after all input has been
-   consumed and all output has been delivered when using any of the flush
-   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
-   compressor and decompressor must use exactly the same dictionary (see
-   inflateSetDictionary).
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-     Upon return of this function, strm->adler is set to the Adler-32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The Adler-32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   Adler-32 value is not computed and strm->adler is not set.
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if not at a block boundary for raw deflate).  deflateSetDictionary does
-   not perform any compression: this will be done by deflate().
-*/
-ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by deflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If deflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similarly, if dictLength is Z_NULL, then it is not set.
-     deflateGetDictionary() may return a length less than the window size, even
-   when more than the window size in input has been provided. It may return up
-   to 258 bytes less in that case, due to how zlib's implementation of deflate
-   manages the sliding window and lookahead for matches, where matches can be
-   up to 258 bytes long. If the application needs the last window-size bytes of
-   input, then that would need to be saved by the application outside of zlib.
-     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit, but
-   does not free and reallocate the internal compression state.  The stream
-   will leave the compression level and any other attributes that may have been
-   set unchanged.
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2().  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression approach (which is a function of the level) or the
-   strategy is changed, and if there have been any deflate() calls since the
-   state was initialized or reset, then the input available so far is
-   compressed with the old level and strategy using deflate(strm, Z_BLOCK).
-   There are three approaches for the compression levels 0, 1..3, and 4..9
-   respectively.  The new level and strategy will take effect at the next call
-   of deflate().
-     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
-   not have enough output space to complete, then the parameter change will not
-   take effect.  In this case, deflateParams() can be called again with the
-   same parameters and more output space to try again.
-     In order to assure a change in the parameters on the first try, the
-   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
-   request until strm.avail_out is not zero, before calling deflateParams().
-   Then no more input data should be provided before the deflateParams() call.
-   If this is done, the old level and strategy will be applied to the data
-   compressed before deflateParams(), and the new level and strategy will be
-   applied to the the data compressed after deflateParams().
-     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
-   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
-   there was not enough output space to complete the compression of the
-   available input data before a change in the strategy or approach.  Note that
-   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
-   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
-   retried with more output space.
-*/
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().  If that first deflate() call is provided the
-   sourceLen input bytes, an output buffer allocated to the size returned by
-   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
-   to return Z_STREAM_END.  Note that it is possible for the compressed size to
-   be larger than the value returned by deflateBound() if flush options other
-   than Z_FINISH or Z_NO_FLUSH are used.
-*/
-ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
-                                       unsigned *pending,
-                                       int *bits));
-/*
-     deflatePending() returns the number of bytes and bits of output that have
-   been generated, but not yet provided in the available output.  The bytes not
-   provided would be due to the available output space having being consumed.
-   The number of bits of output not provided are between 0 and 7, where they
-   await more bits to join them in order to fill out a full byte.  If pending
-   or bits are Z_NULL, then those values are not set.
-     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
- */
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
-   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
-   source stream state was inconsistent.
-*/
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
-   below), inflate() will *not* automatically decode concatenated gzip members.
-   inflate() will return Z_STREAM_END at the end of the gzip member.  The state
-   would need to be reset to continue decoding a subsequent gzip member.  This
-   *must* be done if there is more data after a gzip member, in order for the
-   decompression to be compliant with the gzip standard (RFC 1952).
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the Adler-32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called at any
-   time to set the dictionary.  If the provided dictionary is smaller than the
-   window and there is already data in the window, then the provided dictionary
-   will amend what's there.  The application must insure that the dictionary
-   that was used for compression is provided.
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
-                                             Bytef *dictionary,
-                                             uInt  *dictLength));
-/*
-     Returns the sliding dictionary being maintained by inflate.  dictLength is
-   set to the number of bytes in the dictionary, and that many bytes are copied
-   to dictionary.  dictionary must have enough space, where 32768 bytes is
-   always enough.  If inflateGetDictionary() is called with dictionary equal to
-   Z_NULL, then only the dictionary length is returned, and nothing is copied.
-   Similarly, if dictLength is Z_NULL, then it is not set.
-     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
-   stream state is inconsistent.
-*/
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a possible full flush point (see above
-   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
-   All full flush points have this pattern, but not all occurrences of this
-   pattern are full flush points.
-     inflateSync returns Z_OK if a possible full flush point has been found,
-   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
-   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
-   In the success case, the application may save the current current value of
-   total_in which indicates where valid compressed data was found.  In the
-   error case, the application may repeatedly call inflateSync, providing more
-   input each time, until success or end of the input data.
-*/
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.  If the window size is changed, then the
-   memory allocated for the window is freed, and the window will be reallocated
-   by inflate() if needed.
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-     inflateMark returns the value noted above, or -65536 if the provided
-   source stream state was inconsistent.
-*/
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-     See inflateBack() for the usage of these routines.
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-typedef unsigned (*in_func) OF((void FAR *,
-                                z_const unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is potentially more efficient than
-   inflate() for file i/o applications, in that it avoids copying between the
-   output and the sliding window by simply making the window itself the output
-   buffer.  inflate() can be faster on modern CPUs when used with large
-   buffers.  inflateBack() trusts the application to not change the output
-   buffer passed by the output function, at least until inflateBack() returns.
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the default
-   behavior of inflate(), which expects a zlib header and trailer around the
-   deflate stream.
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero -- buf is ignored in that
-   case -- and inflateBack() will return a buffer error.  inflateBack() will
-   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
-   out() should return zero on success, or non-zero on failure.  If out()
-   returns non-zero, inflateBack() will return with an error.  Neither in() nor
-   out() are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.)  Note that inflateBack()
-   cannot return Z_OK.
-*/
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-    Compiler, assembler, and debug options:
-     8: ZLIB_DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-    Remainder:
-     27-31: 0 (reserved)
- */
-#ifndef Z_SOLO
-                        /* utility functions */
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.  compress() is equivalent to compress2() with a level
-   parameter of Z_DEFAULT_COMPRESSION.
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed data.
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed data.
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
-   the case where there is not enough room, uncompress() will fill the output
-   buffer with the uncompressed data up to that point.
-*/
-ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
-                                    const Bytef *source, uLong *sourceLen));
-/*
-     Same as uncompress, except that sourceLen is a pointer, where the
-   length of the source is *sourceLen.  On return, *sourceLen is the number of
-   source bytes consumed.
-*/
-                        /* gzip file access functions */
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-     Open the gzip (.gz) file at path for reading and decompressing, or
-   compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")
-   but can also include a compression level ("wb9") or a strategy: 'f' for
-   filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",
-   'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression
-   as in "wb9F".  (See the description of deflateInit2 for more information
-   about the strategy parameter.)  'T' will request transparent writing or
-   appending with no compression and not using the gzip format.
-     "a" can be used instead of "w" to request that the gzip stream that will
-   be written be appended to the file.  "+" will result in an error, since
-   reading and writing to the same gzip file is not supported.  The addition of
-   "x" when writing will create the file exclusively, which fails if the file
-   already exists.  On systems that support it, the addition of "e" when
-   reading or writing will set the flag to close the file on an execve() call.
-     These functions, as well as gzip, will read and decode a sequence of gzip
-   streams in a file.  The append function of gzopen() can be used to create
-   such a file.  (Also see gzflush() for another way to do this.)  When
-   appending, gzopen does not test whether the file begins with a gzip stream,
-   nor does it look for the end of the gzip streams to begin appending.  gzopen
-   will simply append a gzip stream to the existing file.
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.  When
-   reading, this will be detected automatically by looking for the magic two-
-   byte gzip header.
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     Associate a gzFile with the file descriptor fd.  File descriptors are
-   obtained from calls like open, dup, creat, pipe or fileno (if the file has
-   been previously opened with fopen).  The mode parameter is as in gzopen.
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.  If you are using fileno() to get the
-   file descriptor from a FILE *, then you will have to use dup() to avoid
-   double-close()ing the file descriptor.  Both gzclose() and fclose() will
-   close the associated file descriptor, so they need to have different file
-   descriptors.
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions for file to
-   size.  The default buffer size is 8192 bytes.  This function must be called
-   after gzopen() or gzdopen(), and before any other calls that read or write
-   the file.  The buffer memory allocation is always deferred to the first read
-   or write.  Three times that size in buffer space is allocated.  A larger
-   buffer size of, for example, 64K or 128K bytes will noticeably increase the
-   speed of decompression (reading).
-     The new buffer size also affects the maximum length for gzprintf().
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level and strategy for file.  See the
-   description of deflateInit2 for the meaning of these parameters. Previously
-   provided data is flushed before applying the parameter changes.
-     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
-   opened for writing, Z_ERRNO if there is an error writing the flushed data,
-   or Z_MEM_ERROR if there is a memory allocation error.
-*/
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Read and decompress up to len uncompressed bytes from file into buf.  If
-   the input file is not in gzip format, gzread copies the given number of
-   bytes into the buffer directly from the file.
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream.  Any number of gzip streams may be
-   concatenated in the input file, and will all be decompressed by gzread().
-   If something other than a gzip stream is encountered after a gzip stream,
-   that remaining trailing garbage is ignored (and no error is returned).
-     gzread can be used to read a gzip file that is being concurrently written.
-   Upon reaching the end of the input, gzread will return with the available
-   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
-   gzclearerr can be used to clear the end of file indicator in order to permit
-   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
-   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
-   middle of a gzip stream.  Note that gzread does not return -1 in the event
-   of an incomplete gzip stream.  This error is deferred until gzclose(), which
-   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
-   stream.  Alternatively, gzerror can be used before gzclose to detect this
-   case.
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.  If len is too large to fit in an int,
-   then nothing is read, -1 is returned, and the error state is set to
-   Z_STREAM_ERROR.
-*/
-ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
-                                     gzFile file));
-/*
-     Read and decompress up to nitems items of size size from file into buf,
-   otherwise operating as gzread() does.  This duplicates the interface of
-   stdio's fread(), with size_t request and return types.  If the library
-   defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t
-   is an unsigned integer type that can contain a pointer.
-     gzfread() returns the number of full items read of size size, or zero if
-   the end of the file was reached and a full item could not be read, or if
-   there was an error.  gzerror() must be consulted if zero is returned in
-   order to determine if there was an error.  If the multiplication of size and
-   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
-   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
-     In the event that the end of file is reached and only a partial item is
-   available at the end, i.e. the remaining uncompressed data length is not a
-   multiple of size, then the final partial item is nevertheless read into buf
-   and the end-of-file flag is set.  The length of the partial item read is not
-   provided, but could be inferred from the result of gztell().  This behavior
-   is the same as the behavior of fread() implementations in common libraries,
-   but it prevents the direct use of gzfread() to read a concurrently written
-   file, resetting and retrying on end-of-file, when size is not 1.
-*/
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));
-/*
-     Compress and write the len uncompressed bytes at buf to file. gzwrite
-   returns the number of uncompressed bytes written or 0 in case of error.
-*/
-ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
-                                      z_size_t nitems, gzFile file));
-/*
-     Compress and write nitems items of size size from buf to file, duplicating
-   the interface of stdio's fwrite(), with size_t request and return types.  If
-   the library defines size_t, then z_size_t is identical to size_t.  If not,
-   then z_size_t is an unsigned integer type that can contain a pointer.
-     gzfwrite() returns the number of full items written of size size, or zero
-   if there was an error.  If the multiplication of size and nitems overflows,
-   i.e. the product does not fit in a z_size_t, then nothing is written, zero
-   is returned, and the error state is set to Z_STREAM_ERROR.
-*/
-ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
-/*
-     Convert, format, compress, and write the arguments (...) to file under
-   control of the string format, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or a negative zlib error code in case
-   of error.  The number of uncompressed bytes written is limited to 8191, or
-   one less than the buffer size given to gzbuffer().  The caller should assure
-   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
-   return an error (0) with nothing written.  In this case, there may also be a
-   buffer overflow with unpredictable consequences, which is possible only if
-   zlib was compiled with the insecure functions sprintf() or vsprintf(),
-   because the secure snprintf() or vsnprintf() functions were not available.
-   This can be determined using zlibCompileFlags().
-*/
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Compress and write the given null-terminated string s to file, excluding
-   the terminating null character.
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Read and decompress bytes from file into buf, until len-1 characters are
-   read, or until a newline character is read and transferred to buf, or an
-   end-of-file condition is encountered.  If any characters are read or if len
-   is one, the string is terminated with a null character.  If no characters
-   are read due to an end-of-file or len is less than one, then the buffer is
-   left untouched.
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Compress and write c, converted to an unsigned char, into file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Read and decompress one byte from file.  gzgetc returns this byte or -1
-   in case of end of file or error.  This is implemented as a macro for speed.
-   As such, it does not do all of the checking the other functions do.  I.e.
-   it does not check to see if file is NULL, nor whether the structure file
-   points to has been clobbered or not.
-*/
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push c back onto the stream for file to be read as the first character on
-   the next read.  At least one character of push-back is always allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flush all pending output to file.  The parameter flush is as in the
-   deflate() function.  The return value is the zlib error number (see function
-   gzerror below).  gzflush is only permitted when writing.
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatenated gzip streams.
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-     Set the starting position to offset relative to whence for the next gzread
-   or gzwrite on file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewind file. This function is supported only for reading.
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).
-*/
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-     Return the starting position for the next gzread or gzwrite on file.
-   This position represents a number of bytes in the uncompressed data stream,
-   and is zero when starting, even if appending or reading a gzip stream from
-   the middle of a file using gzdopen().
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-     Return the current compressed (actual) read or write offset of file.  This
-   offset includes the count of bytes that precede the gzip stream, for example
-   when appending or when using gzdopen() for reading.  When reading, the
-   offset does not include as yet unused buffered input.  This information can
-   be used for a progress indicator.  On error, gzoffset() returns -1.
-*/
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Return true (1) if the end-of-file indicator for file has been set while
-   reading, false (0) otherwise.  Note that the end-of-file indicator is set
-   only if the read tried to go past the end of the input, but came up short.
-   Therefore, just like feof(), gzeof() may return false even if there is no
-   more data to read, in the event that the last read request was for the exact
-   number of bytes remaining in the input file.  This will happen if the input
-   file size is an exact multiple of the buffer size.
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Return true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-     When writing, gzdirect() returns true (1) if transparent writing was
-   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
-   gzdirect() is not needed when writing.  Transparent writing must be
-   explicitly requested, so the application already knows the answer.  When
-   linking statically, using gzdirect() will include all of the zlib code for
-   gzip file reading and decompression, which may not be desired.)
-*/
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flush all pending output for file, if necessary, close file and
-   deallocate the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
-   last read ended in the middle of a gzip stream, or Z_OK on success.
-*/
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Return the error message for the last error which occurred on file.
-   errnum is set to zlib error number.  If an error occurred in the file system
-   and not in the compression library, errnum is set to Z_ERRNO and the
-   application may consult errno to get the exact error code.
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clear the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-#endif /* !Z_SOLO */
-                        /* checksum functions */
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum. An Adler-32 value is in the range of a 32-bit
-   unsigned integer. If buf is Z_NULL, this function returns the required
-   initial value for the checksum.
-     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
-   much faster.
-   Usage example:
-     uLong adler = adler32(0L, Z_NULL, 0);
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
-                                    z_size_t len));
-/*
-     Same as adler32(), but with a size_t length.
-*/
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
-   that the z_off_t type (like off_t) is a signed integer.  If len2 is
-   negative, the result has no meaning or utility.
-*/
-ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.
-   If buf is Z_NULL, this function returns the required initial value for the
-   crc. Pre- and post-conditioning (one's complement) is performed within this
-   function so it shouldn't be done by the application.
-   Usage example:
-     uLong crc = crc32(0L, Z_NULL, 0);
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,
-                                  z_size_t len));
-/*
-     Same as crc32(), but with a size_t length.
-*/
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-/*
-ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));
-     Return the operator corresponding to length len2, to be used with
-   crc32_combine_op().
-*/
-ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));
-/*
-     Give the same result as crc32_combine(), using op in place of len2. op is
-   is generated from len2 by crc32_combine_gen(). This will be faster than
-   crc32_combine() if the generated op is used more than once.
-*/
-                        /* various hacks, don't look :) */
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#ifdef Z_PREFIX_SET
-#  define z_deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define z_inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define z_inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#else
-#  define deflateInit(strm, level) \
-          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit(strm) \
-          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
-#  define inflateInit2(strm, windowBits) \
-          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
-                        (int)sizeof(z_stream))
-#  define inflateBackInit(strm, windowBits, window) \
-          inflateBackInit_((strm), (windowBits), (window), \
-                           ZLIB_VERSION, (int)sizeof(z_stream))
-#endif
-#ifndef Z_SOLO
-/* gzgetc() macro and its supporting function and exposed data structure.  Note
- * that the real internal state is much larger than the exposed structure.
- * This abbreviated structure exposes just enough for the gzgetc() macro.  The
- * user should not mess with these exposed elements, since their names or
- * behavior could change in the future, perhaps even capriciously.  They can
- * only be used by the gzgetc() macro.  You have been warned.
- */
-struct gzFile_s {
-    unsigned have;
-    unsigned char *next;
-    z_off64_t pos;
-};
-ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
-#ifdef Z_PREFIX_SET
-#  undef z_gzgetc
-#  define z_gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#else
-#  define gzgetc(g) \
-          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
-#endif
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#ifdef Z_LARGE64
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));
-#endif
-#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
-#  ifdef Z_PREFIX_SET
-#    define z_gzopen z_gzopen64
-#    define z_gzseek z_gzseek64
-#    define z_gztell z_gztell64
-#    define z_gzoffset z_gzoffset64
-#    define z_adler32_combine z_adler32_combine64
-#    define z_crc32_combine z_crc32_combine64
-#    define z_crc32_combine_gen z_crc32_combine_gen64
-#  else
-#    define gzopen gzopen64
-#    define gzseek gzseek64
-#    define gztell gztell64
-#    define gzoffset gzoffset64
-#    define adler32_combine adler32_combine64
-#    define crc32_combine crc32_combine64
-#    define crc32_combine_gen crc32_combine_gen64
-#  endif
-#  ifndef Z_LARGE64
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
-#endif
-#else /* Z_SOLO */
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
-#endif /* !Z_SOLO */
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
-ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));
-ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
-ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
-#if defined(_WIN32) && !defined(Z_SOLO)
-ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
-                                            const char *mode));
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
-                                                  const char *format,
-                                                  va_list va));
-#  endif
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif /* ZLIB_H */

--- a/src/native/external/zlib/zutil.c
+++ b//dev/null
@@ -1,278 +0,0 @@
-/* zutil.c -- target dependent utility functions for the compression library
- * Copyright (C) 1995-2017 Jean-loup Gailly
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-/* @(#) $Id$ */
-#include "zutil.h"
-#ifndef Z_SOLO
-#  include "gzguts.h"
-#endif
-z_const char * const z_errmsg[10] = {
-    (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
-    (z_const char *)"stream end",          /* Z_STREAM_END      1  */
-    (z_const char *)"",                    /* Z_OK              0  */
-    (z_const char *)"file error",          /* Z_ERRNO         (-1) */
-    (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
-    (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
-    (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
-    (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
-    (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
-    (z_const char *)""
-};
-const char * ZEXPORT zlibVersion()
-{
-    return ZLIB_VERSION;
-}
-uLong ZEXPORT zlibCompileFlags()
-{
-    uLong flags;
-    flags = 0;
-    switch ((int)(sizeof(uInt))) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
-    default:    flags += 3;
-    }
-    switch ((int)(sizeof(uLong))) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
-    default:    flags += 3 << 2;
-    }
-    switch ((int)(sizeof(voidpf))) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
-    default:    flags += 3 << 4;
-    }
-    switch ((int)(sizeof(z_off_t))) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
-    default:    flags += 3 << 6;
-    }
-#ifdef ZLIB_DEBUG
-    flags += 1 << 8;
-#endif
-    /*
-#if defined(ASMV) || defined(ASMINF)
-    flags += 1 << 9;
-#endif
-     */
-#ifdef ZLIB_WINAPI
-    flags += 1 << 10;
-#endif
-#ifdef BUILDFIXED
-    flags += 1 << 12;
-#endif
-#ifdef DYNAMIC_CRC_TABLE
-    flags += 1 << 13;
-#endif
-#ifdef NO_GZCOMPRESS
-    flags += 1L << 16;
-#endif
-#ifdef NO_GZIP
-    flags += 1L << 17;
-#endif
-#ifdef PKZIP_BUG_WORKAROUND
-    flags += 1L << 20;
-#endif
-#ifdef FASTEST
-    flags += 1L << 21;
-#endif
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifdef NO_vsnprintf
-    flags += 1L << 25;
-#    ifdef HAS_vsprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_vsnprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#else
-    flags += 1L << 24;
-#  ifdef NO_snprintf
-    flags += 1L << 25;
-#    ifdef HAS_sprintf_void
-    flags += 1L << 26;
-#    endif
-#  else
-#    ifdef HAS_snprintf_void
-    flags += 1L << 26;
-#    endif
-#  endif
-#endif
-    return flags;
-}
-#ifdef ZLIB_DEBUG
-#include <stdlib.h>
-#  ifndef verbose
-#    define verbose 0
-#  endif
-int ZLIB_INTERNAL z_verbose = verbose;
-void ZLIB_INTERNAL z_error(m)
-    char *m;
-{
-    fprintf(stderr, "%s\n", m);
-    exit(1);
-}
-#endif
-/* exported to allow conversion of error code to string for compress() and
- * uncompress()
- */
-const char * ZEXPORT zError(err)
-    int err;
-{
-    return ERR_MSG(err);
-}
-#if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
-    /* The older Microsoft C Run-Time Library for Windows CE doesn't have
-     * errno.  We define it as a global variable to simplify porting.
-     * Its value is always 0 and should not be used.
-     */
-    int errno = 0;
-#endif
-#ifndef HAVE_MEMCPY
-void ZLIB_INTERNAL zmemcpy(dest, source, len)
-    Bytef* dest;
-    const Bytef* source;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = *source++; /* ??? to be unrolled */
-    } while (--len != 0);
-}
-int ZLIB_INTERNAL zmemcmp(s1, s2, len)
-    const Bytef* s1;
-    const Bytef* s2;
-    uInt  len;
-{
-    uInt j;
-    for (j = 0; j < len; j++) {
-        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
-    }
-    return 0;
-}
-void ZLIB_INTERNAL zmemzero(dest, len)
-    Bytef* dest;
-    uInt  len;
-{
-    if (len == 0) return;
-    do {
-        *dest++ = 0;  /* ??? to be unrolled */
-    } while (--len != 0);
-}
-#endif
-#ifndef Z_SOLO
-#ifdef SYS16BIT
-#ifdef __TURBOC__
-/* Turbo C in 16-bit mode */
-#  define MY_ZCALLOC
-/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
- * and farmalloc(64K) returns a pointer with an offset of 8, so we
- * must fix the pointer. Warning: the pointer must be put back to its
- * original form in order to free it, use zcfree().
- */
-#define MAX_PTR 10
-/* 10*64K = 640K */
-local int next_ptr = 0;
-typedef struct ptr_table_s {
-    voidpf org_ptr;
-    voidpf new_ptr;
-} ptr_table;
-local ptr_table table[MAX_PTR];
-/* This table is used to remember the original form of pointers
- * to large buffers (64K). Such pointers are normalized with a zero offset.
- * Since MSDOS is not a preemptive multitasking OS, this table is not
- * protected from concurrent access. This hack doesn't work anyway on
- * a protected system like OS/2. Use Microsoft C instead.
- */
-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
-{
-    voidpf buf;
-    ulg bsize = (ulg)items*size;
-    (void)opaque;
-    /* If we allocate less than 65520 bytes, we assume that farmalloc
-     * will return a usable pointer which doesn't have to be normalized.
-     */
-    if (bsize < 65520L) {
-        buf = farmalloc(bsize);
-        if (*(ush*)&buf != 0) return buf;
-    } else {
-        buf = farmalloc(bsize + 16L);
-    }
-    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
-    table[next_ptr].org_ptr = buf;
-    /* Normalize the pointer to seg:0 */
-    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
-    *(ush*)&buf = 0;
-    table[next_ptr++].new_ptr = buf;
-    return buf;
-}
-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
-{
-    int n;
-    (void)opaque;
-    if (*(ush*)&ptr != 0) { /* object < 64K */
-        farfree(ptr);
-        return;
-    }
-    /* Find the original pointer */
-    for (n = 0; n < next_ptr; n++) {
-        if (ptr != table[n].new_ptr) continue;
-        farfree(table[n].org_ptr);
-        while (++n < next_ptr) {
-            table[n-1] = table[n];
-        }
-        next_ptr--;
-        return;
-    }
-    Assert(0, "zcfree: ptr not found");
-}
-#endif /* __TURBOC__ */
-#ifdef M_I86
-/* Microsoft C in 16-bit mode */
-#  define MY_ZCALLOC
-#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
-#  define _halloc  halloc
-#  define _hfree   hfree
-#endif
-voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)
-{
-    (void)opaque;
-    return _halloc((long)items, size);
-}
-void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
-{
-    (void)opaque;
-    _hfree(ptr);
-}
-#endif /* M_I86 */
-#endif /* SYS16BIT */
-#ifndef MY_ZCALLOC /* Any system without a special alloc function */
-#ifndef STDC
-extern voidp  malloc OF((uInt size));
-extern voidp  calloc OF((uInt items, uInt size));
-extern void   free   OF((voidpf ptr));
-#endif
-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    (void)opaque;
-    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                              (voidpf)calloc(items, size);
-}
-void ZLIB_INTERNAL zcfree(opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    (void)opaque;
-    free(ptr);
-}
-#endif /* MY_ZCALLOC */
-#endif /* !Z_SOLO */

--- a/src/native/libs/System.IO.Compression.Native/pal_zlib.c
+++ b//dev/null
@@ -1,172 +0,0 @@
-#include <assert.h>
-#include <stdlib.h>
-#include "pal_zlib.h"
-#ifdef INTERNAL_ZLIB
-    #ifdef  _WIN32
-        #define c_static_assert(e) static_assert((e),"")
-    #endif
-    #ifdef INTERNAL_ZLIB_INTEL
-        #include <external/zlib-intel/zlib.h>
-    #else
-        #include <external/zlib/zlib.h>
-    #endif
-#else
-    #include "pal_utilities.h"
-    #include <zlib.h>
-#endif
-c_static_assert(PAL_Z_NOFLUSH == Z_NO_FLUSH);
-c_static_assert(PAL_Z_FINISH == Z_FINISH);
-c_static_assert(PAL_Z_OK == Z_OK);
-c_static_assert(PAL_Z_STREAMEND == Z_STREAM_END);
-c_static_assert(PAL_Z_STREAMERROR == Z_STREAM_ERROR);
-c_static_assert(PAL_Z_DATAERROR == Z_DATA_ERROR);
-c_static_assert(PAL_Z_MEMERROR == Z_MEM_ERROR);
-c_static_assert(PAL_Z_BUFERROR == Z_BUF_ERROR);
-c_static_assert(PAL_Z_VERSIONERROR == Z_VERSION_ERROR);
-c_static_assert(PAL_Z_NOCOMPRESSION == Z_NO_COMPRESSION);
-c_static_assert(PAL_Z_BESTSPEED == Z_BEST_SPEED);
-c_static_assert(PAL_Z_DEFAULTCOMPRESSION == Z_DEFAULT_COMPRESSION);
-c_static_assert(PAL_Z_DEFAULTSTRATEGY == Z_DEFAULT_STRATEGY);
-c_static_assert(PAL_Z_DEFLATED == Z_DEFLATED);
-/*
-Initializes the PAL_ZStream by creating and setting its underlying z_stream.
-*/
-static int32_t Init(PAL_ZStream* stream)
-{
-    z_stream* zStream = (z_stream*)calloc(1, sizeof(z_stream));
-    stream->internalState = zStream;
-    if (zStream != NULL)
-    {
-        return PAL_Z_OK;
-    }
-    else
-    {
-        return PAL_Z_MEMERROR;
-    }
-}
-/*
-Frees any memory on the PAL_ZStream that was created by Init.
-*/
-static void End(PAL_ZStream* stream)
-{
-    z_stream* zStream = (z_stream*)(stream->internalState);
-    assert(zStream != NULL);
-    if (zStream != NULL)
-    {
-        free(zStream);
-        stream->internalState = NULL;
-    }
-}
-/*
-Transfers the output values from the underlying z_stream to the PAL_ZStream.
-*/
-static void TransferStateToPalZStream(z_stream* from, PAL_ZStream* to)
-{
-    to->nextIn = from->next_in;
-    to->availIn = from->avail_in;
-    to->nextOut = from->next_out;
-    to->availOut = from->avail_out;
-    to->msg = from->msg;
-}
-/*
-Transfers the input values from the PAL_ZStream to the underlying z_stream object.
-*/
-static void TransferStateFromPalZStream(PAL_ZStream* from, z_stream* to)
-{
-    to->next_in = from->nextIn;
-    to->avail_in = from->availIn;
-    to->next_out = from->nextOut;
-    to->avail_out = from->availOut;
-}
-/*
-Gets the current z_stream object for the specified PAL_ZStream.
-This ensures any inputs are transferred from the PAL_ZStream to the underlying z_stream,
-since the current values are always needed.
-*/
-static z_stream* GetCurrentZStream(PAL_ZStream* stream)
-{
-    z_stream* zStream = (z_stream*)(stream->internalState);
-    assert(zStream != NULL);
-    TransferStateFromPalZStream(stream, zStream);
-    return zStream;
-}
-int32_t CompressionNative_DeflateInit2_(
-    PAL_ZStream* stream, int32_t level, int32_t method, int32_t windowBits, int32_t memLevel, int32_t strategy)
-{
-    assert(stream != NULL);
-    int32_t result = Init(stream);
-    if (result == PAL_Z_OK)
-    {
-        z_stream* zStream = GetCurrentZStream(stream);
-        result = deflateInit2(zStream, level, method, windowBits, memLevel, strategy);
-        TransferStateToPalZStream(zStream, stream);
-    }
-    return result;
-}
-int32_t CompressionNative_Deflate(PAL_ZStream* stream, int32_t flush)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = deflate(zStream, flush);
-    TransferStateToPalZStream(zStream, stream);
-    return result;
-}
-int32_t CompressionNative_DeflateReset(PAL_ZStream* stream)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = deflateReset(zStream);
-    TransferStateToPalZStream(zStream, stream);
-    return result;
-}
-int32_t CompressionNative_DeflateEnd(PAL_ZStream* stream)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = deflateEnd(zStream);
-    End(stream);
-    return result;
-}
-int32_t CompressionNative_InflateInit2_(PAL_ZStream* stream, int32_t windowBits)
-{
-    assert(stream != NULL);
-    int32_t result = Init(stream);
-    if (result == PAL_Z_OK)
-    {
-        z_stream* zStream = GetCurrentZStream(stream);
-        result = inflateInit2(zStream, windowBits);
-        TransferStateToPalZStream(zStream, stream);
-    }
-    return result;
-}
-int32_t CompressionNative_Inflate(PAL_ZStream* stream, int32_t flush)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = inflate(zStream, flush);
-    TransferStateToPalZStream(zStream, stream);
-    return result;
-}
-int32_t CompressionNative_InflateReset(PAL_ZStream* stream)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = inflateReset(zStream);
-    TransferStateToPalZStream(zStream, stream);
-    return result;
-}
-int32_t CompressionNative_InflateEnd(PAL_ZStream* stream)
-{
-    assert(stream != NULL);
-    z_stream* zStream = GetCurrentZStream(stream);
-    int32_t result = inflateEnd(zStream);
-    End(stream);
-    return result;
-}
-uint32_t CompressionNative_Crc32(uint32_t crc, uint8_t* buffer, int32_t len)
-{
-    assert(buffer != NULL);
-    unsigned long result = crc32(crc, buffer, len);
-    assert(result <= UINT32_MAX);
-    return (uint32_t)result;
-}

--- a/src/native/libs/System.IO.Compression.Native/zlib_allocator_unix.c
+++ b//dev/null
@@ -1,140 +0,0 @@
-#include <stdbool.h>
-#include <stdint.h>
-#include <external/zlib/zutil.h>
-/* A custom allocator for zlib that provides some defense-in-depth over standard malloc / free.
- * (non-Windows version)
- *
- * 1. When zlib allocates fixed-length data structures for containing stream metadata, we zero
- *    the memory before using it, preventing use of uninitialized memory within these structures.
- *    Ideally we would do this for dynamically-sized buffers as well, but there is a measurable
- *    perf impact to doing this. Zeroing fixed structures seems like a good trade-off here, since
- *    these data structures contain most of the metadata used for managing the variable-length
- *    dynamically allocated buffers.
- *
- * 2. We put a cookie both before and after any allocated memory, which allows us to detect local
- *    buffer overruns on the call to free(). The cookie values are tied to the addresses where
- *    the data is located in memory.
- *
- * 3. We trash the aforementioned cookie on free(), which allows us to detect double-free.
- *
- * If any of these checks fails, the application raises SIGABRT.
- */
-static bool IsMitigationDisabled()
-{
-    enum _MitigationEnablementTristate
-    {
-        MITIGATION_NOT_YET_QUERIED = 0,
-        MITIGATION_DISABLED = 1,
-        MITIGATION_ENABLED = 2 // really, anything other than 0 or 1
-    };
-    static int s_fMitigationEnablementState = MITIGATION_NOT_YET_QUERIED;
-    if (s_fMitigationEnablementState != MITIGATION_NOT_YET_QUERIED)
-    {
-        return (s_fMitigationEnablementState == MITIGATION_DISABLED);
-    }
-    char* pchEnvVar = getenv("DOTNET_SYSTEM_IO_COMPRESSION_DISABLEZLIBMITIGATIONS");
-    bool fMitigationDisabled = (pchEnvVar && (strcmp(pchEnvVar, "1") == 0 || strcmp(pchEnvVar, "true") == 0));
-    __sync_val_compare_and_swap(
-        /* destination: */ &s_fMitigationEnablementState,
-        /* comparand:   */ MITIGATION_NOT_YET_QUERIED,
-        /* exchange:    */ fMitigationDisabled ? MITIGATION_DISABLED : MITIGATION_ENABLED);
-    return IsMitigationDisabled();
-}
-#ifndef MEMORY_ALLOCATION_ALIGNMENT
-#ifdef HOST_64BIT
-#define MEMORY_ALLOCATION_ALIGNMENT 16
-#else
-#define MEMORY_ALLOCATION_ALIGNMENT 8
-#endif
-#endif
-typedef struct _DOTNET_ALLOC_COOKIE
-{
-    void* Address;
-    size_t Size;
-} DOTNET_ALLOC_COOKIE;
-static bool SafeAdd(size_t a, size_t b, size_t* sum)
-{
-    if (SIZE_MAX - a >= b) { *sum = a + b; return true; }
-    else { *sum = 0; return false; }
-}
-static bool SafeMult(size_t a, size_t b, size_t* product)
-{
-    if (SIZE_MAX / a >= b) { *product = a * b; return true; }
-    else { *product = 0; return false; }
-}
-static DOTNET_ALLOC_COOKIE ReadAllocCookieUnaligned(const void* pSrc)
-{
-    DOTNET_ALLOC_COOKIE vCookie;
-    memcpy(&vCookie, pSrc, sizeof(DOTNET_ALLOC_COOKIE));
-    return vCookie;
-}
-static void WriteAllocCookieUnaligned(void* pDest, DOTNET_ALLOC_COOKIE vCookie)
-{
-    memcpy(pDest, &vCookie, sizeof(DOTNET_ALLOC_COOKIE));
-}
-const size_t DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING = (sizeof(DOTNET_ALLOC_COOKIE) + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~((size_t)MEMORY_ALLOCATION_ALIGNMENT  - 1);
-const size_t DOTNET_ALLOC_TRAILER_COOKIE_SIZE = sizeof(DOTNET_ALLOC_COOKIE);
-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    (void)opaque; // unreferenced formal parameter
-    if (IsMitigationDisabled())
-    {
-        return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                                  (voidpf)calloc(items, size);
-    }
-    bool fZeroMemory = (items == 1);
-    size_t cbRequested;
-    if (sizeof(items) + sizeof(size) <= sizeof(cbRequested))
-    {
-        cbRequested = (size_t)items * (size_t)size;
-    }
-    else
-    {
-        if (!SafeMult((size_t)items, (size_t)size, &cbRequested)) { return NULL; }
-    }
-    size_t cbActualAllocationSize;
-    if (!SafeAdd(cbRequested, DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING + DOTNET_ALLOC_TRAILER_COOKIE_SIZE, &cbActualAllocationSize)) { return NULL; }
-    void* pAlloced = (fZeroMemory) ? calloc(1, cbActualAllocationSize) : malloc(cbActualAllocationSize);
-    if (pAlloced == NULL) { return NULL; } // OOM
-    DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)pAlloced;
-    uint8_t* pReturnToCaller = (uint8_t*)pAlloced + DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING;
-    uint8_t* pTrailerCookie = pReturnToCaller + cbRequested;
-    DOTNET_ALLOC_COOKIE vCookie = { 0 };
-    vCookie.Address = pReturnToCaller;
-    vCookie.Size = cbRequested;
-    *pHeaderCookie = vCookie; // aligned
-    WriteAllocCookieUnaligned(pTrailerCookie, vCookie);
-    return pReturnToCaller;
-}
-static void zcfree_trash_cookie(void* pCookie)
-{
-    memset(pCookie, 0, sizeof(DOTNET_ALLOC_COOKIE));
-}
-void ZLIB_INTERNAL zcfree(opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    (void)opaque; // unreferenced formal parameter
-    if (IsMitigationDisabled())
-    {
-        free(ptr);
-        return;
-    }
-    if (ptr == NULL) { return; } // ok to free nullptr
-    DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)((uint8_t*)ptr - DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING);
-    if (pHeaderCookie->Address != ptr) { goto Fail; }
-    size_t cbRequested = pHeaderCookie->Size;
-    uint8_t* pTrailerCookie = (uint8_t*)ptr + cbRequested;
-    DOTNET_ALLOC_COOKIE vTrailerCookie = ReadAllocCookieUnaligned(pTrailerCookie);
-    if (vTrailerCookie.Address != ptr) { goto Fail; }
-    if (vTrailerCookie.Size != cbRequested) { goto Fail; }
-    zcfree_trash_cookie(pHeaderCookie);
-    zcfree_trash_cookie(pTrailerCookie);
-    free(pHeaderCookie);
-    return;
-Fail:
-    abort(); // cookie check failed
-}

--- a/src/native/libs/System.IO.Compression.Native/zlib_allocator_win.c
+++ b//dev/null
@@ -1,161 +0,0 @@
-#include <Windows.h>
-#include <heapapi.h>
-#include <intsafe.h>
-#include <winnt.h>
-#include <crtdbg.h> /* _ASSERTE */
-#ifdef INTERNAL_ZLIB_INTEL
-#include <external/zlib-intel/zutil.h>
-#else
-#include <external/zlib/zutil.h>
-#endif
-/* A custom allocator for zlib that provides some defense-in-depth over standard malloc / free.
- * (Windows-specific version)
- *
- * 1. In 64-bit processes, we use a custom heap rather than relying on the standard process heap.
- *    This should cause zlib's buffers to go into a separate address range from the rest of app
- *    data, making it more difficult for buffer overruns to affect non-zlib-related data structures.
- *
- * 2. When zlib allocates fixed-length data structures for containing stream metadata, we zero
- *    the memory before using it, preventing use of uninitialized memory within these structures.
- *    Ideally we would do this for dynamically-sized buffers as well, but there is a measurable
- *    perf impact to doing this. Zeroing fixed structures seems like a good trade-off here, since
- *    these data structures contain most of the metadata used for managing the variable-length
- *    dynamically allocated buffers.
- *
- * 3. We put a cookie both before and after any allocated memory, which allows us to detect local
- *    buffer overruns on the call to free(). The cookie values are enciphered to make it more
- *    difficult for somebody to guess a correct value.
- *
- * 4. We trash the aforementioned cookie on free(), which allows us to detect double-free.
- *
- * If any of these checks fails, the application terminates immediately, optionally triggering a
- * crash dump. We use a special code that's easy to search for in Watson.
- */
-BOOL IsMitigationDisabled()
-{
-    enum _MitigationEnablementTristate
-    {
-        MITIGATION_NOT_YET_QUERIED = 0,
-        MITIGATION_DISABLED = 1,
-        MITIGATION_ENABLED = 2 // really, anything other than 0 or 1
-    };
-    static long s_fMitigationEnablementState = MITIGATION_NOT_YET_QUERIED;
-    if (s_fMitigationEnablementState != MITIGATION_NOT_YET_QUERIED)
-    {
-        return (s_fMitigationEnablementState == MITIGATION_DISABLED);
-    }
-    CHAR pchBuffer[5]; // enough to hold "true" and a terminator
-    DWORD dwEnvVarLength = GetEnvironmentVariableA("DOTNET_SYSTEM_IO_COMPRESSION_DISABLEZLIBMITIGATIONS", pchBuffer, _countof(pchBuffer));
-    BOOL fMitigationDisabled = (dwEnvVarLength > 0 && dwEnvVarLength < _countof(pchBuffer))
-        && (strcmp(pchBuffer, "1") == 0 || strcmp(pchBuffer, "true") == 0);
-    InterlockedCompareExchange(
-        /* destination: */ &s_fMitigationEnablementState,
-        /* exchange:    */ fMitigationDisabled ? MITIGATION_DISABLED : MITIGATION_ENABLED,
-        /* comparand:   */ MITIGATION_NOT_YET_QUERIED);
-    return IsMitigationDisabled();
-}
-HANDLE GetZlibHeap()
-{
-#ifdef _WIN64
-    static HANDLE s_hPublishedHeap = NULL;
-    if (s_hPublishedHeap != NULL) { return s_hPublishedHeap; }
-    HANDLE hNewHeap = HeapCreate(0, 0, 0);
-    if (hNewHeap != NULL)
-    {
-        if (InterlockedCompareExchangePointer(&s_hPublishedHeap, hNewHeap, NULL) != NULL)
-        {
-            HeapDestroy(hNewHeap); // Somebody published before us. Destroy our heap.
-            hNewHeap = NULL; // Guard against accidental use later in the method.
-        }
-    }
-    else
-    {
-        InterlockedCompareExchangePointer(&s_hPublishedHeap, GetProcessHeap(), NULL);
-    }
-    _ASSERTE(s_hPublishedHeap != NULL);
-    return s_hPublishedHeap;
-#else
-    return GetProcessHeap();
-#endif
-}
-typedef struct _DOTNET_ALLOC_COOKIE
-{
-    PVOID CookieValue;
-    union _Size
-    {
-        SIZE_T RawValue;
-        LPVOID EncodedValue;
-    } Size;
-} DOTNET_ALLOC_COOKIE;
-const SIZE_T DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING = (sizeof(DOTNET_ALLOC_COOKIE) + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~((SIZE_T)MEMORY_ALLOCATION_ALIGNMENT  - 1);
-const SIZE_T DOTNET_ALLOC_TRAILER_COOKIE_SIZE = sizeof(DOTNET_ALLOC_COOKIE);
-voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
-    voidpf opaque;
-    unsigned items;
-    unsigned size;
-{
-    (void)opaque; // suppress C4100 - unreferenced formal parameter
-    if (IsMitigationDisabled())
-    {
-        return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
-                                  (voidpf)calloc(items, size);
-    }
-    DWORD dwFlags = (items == 1) ? HEAP_ZERO_MEMORY : 0;
-    SIZE_T cbRequested;
-    if (sizeof(items) + sizeof(size) <= sizeof(cbRequested))
-    {
-        cbRequested = (SIZE_T)items * (SIZE_T)size;
-    }
-    else
-    {
-        if (FAILED(SIZETMult(items, size, &cbRequested))) { return NULL; }
-    }
-    SIZE_T cbActualAllocationSize;
-    if (FAILED(SIZETAdd(cbRequested, DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING + DOTNET_ALLOC_TRAILER_COOKIE_SIZE, &cbActualAllocationSize))) { return NULL; }
-    LPVOID pAlloced = HeapAlloc(GetZlibHeap(), dwFlags, cbActualAllocationSize);
-    if (pAlloced == NULL) { return NULL; } // OOM
-    DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)pAlloced;
-    pHeaderCookie->CookieValue = EncodePointer(&pHeaderCookie->CookieValue);
-    pHeaderCookie->Size.RawValue = cbRequested;
-    LPBYTE pReturnToCaller = (LPBYTE)pHeaderCookie + DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING;
-    UNALIGNED DOTNET_ALLOC_COOKIE* pTrailerCookie = (UNALIGNED DOTNET_ALLOC_COOKIE*)(pReturnToCaller + cbRequested);
-    pTrailerCookie->CookieValue = EncodePointer(&pTrailerCookie->CookieValue);
-    pTrailerCookie->Size.EncodedValue = EncodePointer((PVOID)cbRequested);
-    return pReturnToCaller;
-}
-FORCEINLINE
-void zcfree_trash_cookie(UNALIGNED DOTNET_ALLOC_COOKIE* pCookie)
-{
-    memset(pCookie, 0, sizeof(*pCookie));
-    pCookie->CookieValue = (PVOID)(SIZE_T)0xDEADBEEF;
-}
-DECLSPEC_NOINLINE
-DECLSPEC_NORETURN
-void zcfree_cookie_check_failed()
-{
-    __fastfail(FAST_FAIL_HEAP_METADATA_CORRUPTION);
-}
-void ZLIB_INTERNAL zcfree(opaque, ptr)
-    voidpf opaque;
-    voidpf ptr;
-{
-    (void)opaque; // suppress C4100 - unreferenced formal parameter
-    if (IsMitigationDisabled())
-    {
-        free(ptr);
-        return;
-    }
-    if (ptr == NULL) { return; } // ok to free nullptr
-    DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)((LPBYTE)ptr - DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING);
-    if (DecodePointer(pHeaderCookie->CookieValue) != &pHeaderCookie->CookieValue) { goto Fail; }
-    SIZE_T cbRequested = pHeaderCookie->Size.RawValue;
-    UNALIGNED DOTNET_ALLOC_COOKIE* pTrailerCookie = (UNALIGNED DOTNET_ALLOC_COOKIE*)((LPBYTE)ptr + cbRequested);
-    if (DecodePointer(pTrailerCookie->CookieValue) != &pTrailerCookie->CookieValue) { goto Fail; }
-    if (DecodePointer(pTrailerCookie->Size.EncodedValue) != (LPVOID)cbRequested) { goto Fail; }
-    zcfree_trash_cookie(pHeaderCookie);
-    zcfree_trash_cookie(pTrailerCookie);
-    if (!HeapFree(GetZlibHeap(), 0, pHeaderCookie)) { goto Fail; }
-    return;
-Fail:
-    zcfree_cookie_check_failed();
-}
