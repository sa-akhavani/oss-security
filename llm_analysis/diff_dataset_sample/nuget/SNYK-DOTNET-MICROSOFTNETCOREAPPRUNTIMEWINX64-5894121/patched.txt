# ====================================================================
# FILE: src/coreclr/inc/clrconfigvalues.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-539 ---
     1| CONFIG_DWORD_INFO(INTERNAL_EnableFullDebug, W("EnableFullDebug"), 0, "Heavy-weight checking for AD boundary violations (AD leaks)")
     2| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchEnabled, W("JitPitchEnabled"), (DWORD)0, "Set it to 1 to enable Jit Pitching")
     3| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMemThreshold, W("JitPitchMemThreshold"), (DWORD)0, "Do Jit Pitching when code heap usage is larger than this (in bytes)")
     4| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMethodSizeThreshold, W("JitPitchMethodSizeThreshold"), (DWORD)0, "Do Jit Pitching for methods whose native code size larger than this (in bytes)")
     5| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchTimeInterval, W("JitPitchTimeInterval"), (DWORD)0, "Time interval between Jit Pitchings in ms")
     6| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchPrintStat, W("JitPitchPrintStat"), (DWORD)0, "Print statistics about Jit Pitching")
     7| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMinVal, W("JitPitchMinVal"), (DWORD)0, "Do Jit Pitching if the value of the inner counter greater than this value (for debugging purpose only)")
     8| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitPitchMaxVal, W("JitPitchMaxVal"), (DWORD)0xffffffff, "Do Jit Pitching the value of the inner counter less then this value (for debuggin purpose only)")
     9| CONFIG_DWORD_INFO(INTERNAL_GetAssemblyIfLoadedIgnoreRidMap, W("GetAssemblyIfLoadedIgnoreRidMap"), 0, "Used to force loader to ignore assemblies cached in the rid-map")
    10| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnBadExit, W("BreakOnBadExit"), 0, "")
    11| CONFIG_STRING_INFO(INTERNAL_BreakOnClassBuild, W("BreakOnClassBuild"), "Very useful for debugging class layout code.")
    12| CONFIG_STRING_INFO(INTERNAL_BreakOnClassLoad, W("BreakOnClassLoad"), "Very useful for debugging class loading code.")
    13| CONFIG_STRING_INFO(INTERNAL_BreakOnComToClrNativeInfoInit, W("BreakOnComToClrNativeInfoInit"), "Throws an assert when native information about a COM -> CLR call are about to be gathered.")
    14| CONFIG_DWORD_INFO(INTERNAL_BreakOnDebugBreak, W("BreakOnDebugBreak"), 0, "Allows an assert in debug builds when a user break is hit")
    15| CONFIG_DWORD_INFO(INTERNAL_BreakOnDILoad, W("BreakOnDILoad"), 0, "Allows an assert when the DI is loaded")
    16| CONFIG_DWORD_INFO(INTERNAL_BreakOnDumpToken, W("BreakOnDumpToken"), 0xffffffff, "Breaks when using internal logging on a particular token value.")
    17| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BreakOnEELoad, W("BreakOnEELoad"), 0, "")
    18| CONFIG_DWORD_INFO(INTERNAL_BreakOnEEShutdown, W("BreakOnEEShutdown"), 0, "")
    19| CONFIG_DWORD_INFO(INTERNAL_BreakOnExceptionInGetThrowable, W("BreakOnExceptionInGetThrowable"), 0, "")
    20| CONFIG_DWORD_INFO(INTERNAL_BreakOnFindMethod, W("BreakOnFindMethod"), 0, "Breaks in findMethodInternal when it searches for the specified token.")
    21| CONFIG_DWORD_INFO(INTERNAL_BreakOnFirstPass, W("BreakOnFirstPass"), 0, "")
    22| CONFIG_DWORD_INFO(INTERNAL_BreakOnHR, W("BreakOnHR"), 0, "Debug.cpp, IfFailxxx use this macro to stop if hr matches ")
    23| CONFIG_STRING_INFO(INTERNAL_BreakOnInstantiation, W("BreakOnInstantiation"), "Very useful for debugging generic class instantiation.")
    24| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropStubSetup, W("BreakOnInteropStubSetup"), "Throws an assert when marshaling stub for the given method is about to be built.")
    25| CONFIG_STRING_INFO(INTERNAL_BreakOnInteropVTableBuild, W("BreakOnInteropVTableBuild"), "Specifies a type name for which an assert should be thrown when building interop v-table.")
    26| CONFIG_STRING_INFO(INTERNAL_BreakOnMethodName, W("BreakOnMethodName"), "Very useful for debugging method override placement code.")
    27| CONFIG_DWORD_INFO(INTERNAL_BreakOnNotify, W("BreakOnNotify"), 0, "")
    28| CONFIG_DWORD_INFO(INTERNAL_BreakOnSecondPass, W("BreakOnSecondPass"), 0, "")
    29| CONFIG_STRING_INFO(INTERNAL_BreakOnStructMarshalSetup, W("BreakOnStructMarshalSetup"), "Throws an assert when field marshalers for the given type with layout are about to be created.")
    30| CONFIG_DWORD_INFO(INTERNAL_BreakOnUEF, W("BreakOnUEF"), 0, "")
    31| CONFIG_DWORD_INFO(INTERNAL_BreakOnUncaughtException, W("BreakOnUncaughtException"), 0, "")
    32| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableDiagnostics, W("EnableDiagnostics"), 1, "Allows the debugger, profiler, and EventPipe diagnostics to be disabled")
    33| CONFIG_DWORD_INFO(INTERNAL_D__FCE, W("D::FCE"), 0, "Allows an assert when crawling the managed stack for an exception handler")
    34| CONFIG_DWORD_INFO(INTERNAL_DbgBreakIfLocksUnavailable, W("DbgBreakIfLocksUnavailable"), 0, "Allows an assert when the debugger can't take a lock ")
    35| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnErr, W("DbgBreakOnErr"), 0, "Allows an assert when we get a failing hresult")
    36| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnMapPatchToDJI, W("DbgBreakOnMapPatchToDJI"), 0, "Allows an assert when mapping a patch to an address")
    37| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnRawInt3, W("DbgBreakOnRawInt3"), 0, "Allows an assert for test coverage for debug break or other int3 breaks")
    38| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSendBreakpoint, W("DbgBreakOnSendBreakpoint"), 0, "Allows an assert when sending a breakpoint to the right side")
    39| CONFIG_DWORD_INFO(INTERNAL_DbgBreakOnSetIP, W("DbgBreakOnSetIP"), 0, "Allows an assert when setting the IP")
    40| CONFIG_DWORD_INFO(INTERNAL_DbgCheckInt3, W("DbgCheckInt3"), 0, "Asserts if the debugger explicitly writes int3 instead of calling SetUnmanagedBreakpoint")
    41| CONFIG_DWORD_INFO(INTERNAL_DbgDACAssertOnMismatch, W("DbgDACAssertOnMismatch"), 0, "Allows an assert when the mscordacwks and mscorwks dll versions don't match")
    42| CONFIG_DWORD_INFO(INTERNAL_DbgDACEnableAssert, W("DbgDACEnableAssert"), 0, "Enables extra validity checking in DAC - assumes target isn't corrupt")
    43| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDACSkipVerifyDlls, W("DbgDACSkipVerifyDlls"), 0, "Allows disabling the check to ensure mscordacwks and mscorwks dll versions match")
    44| CONFIG_DWORD_INFO(INTERNAL_DbgDelayHelper, W("DbgDelayHelper"), 0, "Varies the wait in the helper thread startup for testing race between threads")
    45| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgDisableDynamicSymsCompat, W("DbgDisableDynamicSymsCompat"), 0, "")
    46| CONFIG_DWORD_INFO(INTERNAL_DbgDisableTargetConsistencyAsserts, W("DbgDisableTargetConsistencyAsserts"), 0, "Allows explicitly testing with corrupt targets")
    47| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreads, W("DbgExtraThreads"), 0, "Allows extra unmanaged threads to run and throw debug events for stress testing")
    48| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsCantStop, W("DbgExtraThreadsCantStop"), 0, "Allows extra unmanaged threads in can't stop region to run and throw debug events for stress testing")
    49| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsIB, W("DbgExtraThreadsIB"), 0, "Allows extra in-band unmanaged threads to run and throw debug events for stress testing")
    50| CONFIG_DWORD_INFO(INTERNAL_DbgExtraThreadsOOB, W("DbgExtraThreadsOOB"), 0, "Allows extra out of band unmanaged threads to run and throw debug events for stress testing")
    51| CONFIG_DWORD_INFO(INTERNAL_DbgFaultInHandleIPCEvent, W("DbgFaultInHandleIPCEvent"), 0, "Allows testing the unhandled event filter")
    52| CONFIG_DWORD_INFO(INTERNAL_DbgInjectFEE, W("DbgInjectFEE"), 0, "Allows injecting a fatal execution error for testing Watson")
    53| CONFIG_DWORD_INFO(INTERNAL_DbgLeakCheck, W("DbgLeakCheck"), 0, "Allows checking for leaked Cordb objects")
    54| CONFIG_DWORD_INFO(INTERNAL_DbgNo2ndChance, W("DbgNo2ndChance"), 0, "Allows breaking on (and catching bogus) 2nd chance exceptions")
    55| CONFIG_DWORD_INFO(INTERNAL_DbgNoDebugger, W("DbgNoDebugger"), 0, "Allows breaking if we don't want to lazily initialize the debugger")
    56| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgNoForceContinue, W("DbgNoForceContinue"), 1, "Used to force a continue on longhorn")
    57| CONFIG_DWORD_INFO(INTERNAL_DbgNoOpenMDByFile, W("DbgNoOpenMDByFile"), 0, "Allows opening MD by memory for perf testing")
    58| CONFIG_DWORD_INFO(INTERNAL_DbgOOBinFEEE, W("DbgOOBinFEEE"), 0, "Allows forcing oob breakpoints when a fatal error occurs")
    59| CONFIG_DWORD_INFO(INTERNAL_DbgPingInterop, W("DbgPingInterop"), 0, "Allows checking for deadlocks in interop debugging")
    60| CONFIG_DWORD_INFO(INTERNAL_DbgRace, W("DbgRace"), 0, "Allows pausing for native debug events to get hijicked")
    61| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgRedirect, W("DbgRedirect"), 0, "Allows for redirecting the event pipeline")
    62| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectApplication, W("DbgRedirectApplication"), "Specifies the auxiliary debugger application to launch.")
    63| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectAttachCmd, W("DbgRedirectAttachCmd"), "Specifies command parameters for attaching the auxiliary debugger.")
    64| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCommonCmd, W("DbgRedirectCommonCmd"), "Specifies a command line format string for the auxiliary debugger.")
    65| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DbgRedirectCreateCmd, W("DbgRedirectCreateCmd"), "Specifies command parameters when creating the auxiliary debugger.")
    66| CONFIG_DWORD_INFO(INTERNAL_DbgShortcutCanary, W("DbgShortcutCanary"), 0, "Allows a way to force canary to fail to be able to test failure paths")
    67| CONFIG_DWORD_INFO(INTERNAL_DbgSkipMEOnStep, W("DbgSkipMEOnStep"), 0, "Turns off MethodEnter checks")
    68| CONFIG_DWORD_INFO(INTERNAL_DbgSkipVerCheck, W("DbgSkipVerCheck"), 0, "Allows different RS and LS versions (for servicing work)")
    69| CONFIG_DWORD_INFO(INTERNAL_DbgTC, W("DbgTC"), 0, "Allows checking boundary compression for offset mappings")
    70| CONFIG_DWORD_INFO(INTERNAL_DbgTransportFaultInject, W("DbgTransportFaultInject"), 0, "Allows injecting a fault for testing the debug transport")
    71| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLog, W("DbgTransportLog"), 0 /* LE_None */, "Turns on logging for the debug transport")
    72| CONFIG_DWORD_INFO(INTERNAL_DbgTransportLogClass, W("DbgTransportLogClass"), (DWORD)-1 /* LC_All */, "Mask to control what is logged in DbgTransportLog")
    73| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_DbgTransportProxyAddress, W("DbgTransportProxyAddress"), "Allows specifying the transport proxy address")
    74| CONFIG_DWORD_INFO(INTERNAL_DbgTrapOnSkip, W("DbgTrapOnSkip"), 0, "Allows breaking when we skip a breakpoint")
    75| CONFIG_DWORD_INFO(INTERNAL_DbgWaitTimeout, W("DbgWaitTimeout"), 1, "Specifies the timeout value for waits")
    76| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgWFDETimeout, W("DbgWFDETimeout"), 25, "Specifies the timeout value for wait when waiting for a debug event")
    77| CONFIG_DWORD_INFO(INTERNAL_RaiseExceptionOnAssert, W("RaiseExceptionOnAssert"), 0, "Raise a first chance (if set to 1) or second chance (if set to 2) exception on asserts.")
    78| CONFIG_DWORD_INFO(INTERNAL_DebugBreakOnVerificationFailure, W("DebugBreakOnVerificationFailure"), 0, "Halts the jit on verification failure")
    79| CONFIG_STRING_INFO(INTERNAL_DebuggerBreakPoint, W("DebuggerBreakPoint"), "Allows counting various debug events")
    80| CONFIG_STRING_INFO(INTERNAL_DebugVerify, W("DebugVerify"), "Control for tracing in peverify")
    81| CONFIG_DWORD_INFO(INTERNAL_EncApplyChanges, W("EncApplyChanges"), 0, "Allows breaking when ApplyEditAndContinue is called")
    82| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapComplete, W("EnCBreakOnRemapComplete"), 0, "Allows breaking after N RemapCompletes")
    83| CONFIG_DWORD_INFO(INTERNAL_EnCBreakOnRemapOpportunity, W("EnCBreakOnRemapOpportunity"), 0, "Allows breaking after N RemapOpportunities")
    84| CONFIG_DWORD_INFO(INTERNAL_EncDumpApplyChanges, W("EncDumpApplyChanges"), 0, "Allows dumping edits in delta metadata and il files")
    85| CONFIG_DWORD_INFO(INTERNAL_EncFixupFieldBreak, W("EncFixupFieldBreak"), 0, "Unlikely that this is used anymore.")
    86| CONFIG_DWORD_INFO(INTERNAL_EncJitUpdatedFunction, W("EncJitUpdatedFunction"), 0, "Allows breaking when an updated function is jitted")
    87| CONFIG_DWORD_INFO(INTERNAL_EnCResolveField, W("EnCResolveField"), 0, "Allows breaking when computing the address of an EnC-added field")
    88| CONFIG_DWORD_INFO(INTERNAL_EncResumeInUpdatedFunction, W("EncResumeInUpdatedFunction"), 0, "Allows breaking when execution resumes in a new EnC version of a function")
    89| CONFIG_DWORD_INFO(INTERNAL_DbgAssertOnDebuggeeDebugBreak, W("DbgAssertOnDebuggeeDebugBreak"), 0, "If non-zero causes the managed-only debugger to assert on unhandled breakpoints in the debuggee")
    90| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException, W("UNSUPPORTED_DbgDontResumeThreadsOnUnhandledException"), 0, "If non-zero, then don't try to unsuspend threads after continuing a 2nd-chance native exception")
    91| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DbgSkipStackCheck, W("DbgSkipStackCheck"), 0, "Skip the stack pointer check during stackwalking")
    92| #ifdef DACCESS_COMPILE
    93| CONFIG_DWORD_INFO(INTERNAL_DumpGeneration_IntentionallyCorruptDataFromTarget, W("IntentionallyCorruptDataFromTarget"), 0, "Intentionally fakes bad data retrieved from target to try and break dump generation.")
    94| #endif
    95| CONFIG_DWORD_INFO(UNSUPPORTED_Debugging_RequiredVersion, W("UNSUPPORTED_Debugging_RequiredVersion"), 0, "The lowest ICorDebug version we should attempt to emulate, or 0 for default policy.  Use 2 for CLRv2, 4 for CLRv4, etc.")
    96| #ifdef FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
    97| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MiniMdBufferCapacity, W("MiniMdBufferCapacity"), 64 * 1024, "The max size of the buffer to store mini metadata information for triage- and mini-dumps.")
    98| #endif // FEATURE_MINIMETADATA_IN_TRIAGEDUMPS
    99| CONFIG_DWORD_INFO(INTERNAL_DbgNativeCodeBpBindsAcrossVersions, W("DbgNativeCodeBpBindsAcrossVersions"), 0, "If non-zero causes native breakpoints at offset 0 to bind in all tiered compilation versions of the given method")
   100| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RichDebugInfo, W("RichDebugInfo"), 0, "If non-zero store some additional debug information for each jitted method")
   101| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_OutOfProcessSetContext, W("OutOfProcessSetContext"), 0, "If enabled the debugger will not modify thread contexts in-process.  Enabled by default when CET is enabled for the process.")
   102| CONFIG_DWORD_INFO(INTERNAL_ConditionalContracts, W("ConditionalContracts"), 0, "If ENABLE_CONTRACTS_IMPL is defined, sets whether contracts are conditional. (?)")
   103| CONFIG_DWORD_INFO(INTERNAL_ConsistencyCheck, W("ConsistencyCheck"), 0, "")
   104| CONFIG_DWORD_INFO(INTERNAL_ContinueOnAssert, W("ContinueOnAssert"), 0, "If set, doesn't break on asserts.")
   105| CONFIG_DWORD_INFO(INTERNAL_InjectFatalError, W("InjectFatalError"), 0, "")
   106| CONFIG_DWORD_INFO(INTERNAL_InjectFault, W("InjectFault"), 0, "")
   107| CONFIG_DWORD_INFO(INTERNAL_SuppressChecks, W("SuppressChecks"),0,  "")
   108| #ifdef FEATURE_EH_FUNCLETS
   109| CONFIG_DWORD_INFO(INTERNAL_SuppressLockViolationsOnReentryFromOS, W("SuppressLockViolationsOnReentryFromOS"), 0, "64 bit OOM tests re-enter the CLR via RtlVirtualUnwind.  This indicates whether to suppress resulting locking violations.")
   110| #endif // FEATURE_EH_FUNCLETS
   111| CONFIG_DWORD_INFO(INTERNAL_AssertOnFailFast, W("AssertOnFailFast"), 1, "")
   112| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_legacyCorruptedStateExceptionsPolicy, W("legacyCorruptedStateExceptionsPolicy"), 0, "Enabled Pre-V4 CSE behavior")
   113| CONFIG_DWORD_INFO(INTERNAL_SuppressLostExceptionTypeAssert, W("SuppressLostExceptionTypeAssert"), 0, "")
   114| RETAIL_CONFIG_DWORD_INFO(INTERNAL_UseEntryPointFilter, W("UseEntryPointFilter"), 0, "")
   115| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Corhost_Swallow_Uncaught_Exceptions, W("Corhost_Swallow_Uncaught_Exceptions"), 0, "")
   116| CONFIG_DWORD_INFO(INTERNAL_FastGCCheckStack, W("FastGCCheckStack"), 0, "")
   117| CONFIG_DWORD_INFO(INTERNAL_FastGCStress, W("FastGCStress"), 0, "Reduce the number of GCs done by enabling GCStress")
   118| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCBreakOnOOM, W("GCBreakOnOOM"), 0, "Does a DebugBreak at the soonest time we detect an OOM")
   119| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConcurrent, W("gcConcurrent"), (DWORD)-1, "Enables/Disables concurrent GC")
   120| #ifdef FEATURE_CONSERVATIVE_GC
   121| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcConservative, W("gcConservative"), 0, "Enables/Disables conservative GC")
   122| #endif
   123| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_gcServer, W("gcServer"), 0, "Enables server GC")
   124| CONFIG_STRING_INFO(INTERNAL_GcCoverage, W("GcCoverage"), "Specify a method or regular expression of method names to run with GCStress")
   125| CONFIG_STRING_INFO(INTERNAL_SkipGCCoverage, W("SkipGcCoverage"), "Specify a list of assembly names to skip with GC Coverage")
   126| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StatsUpdatePeriod, W("StatsUpdatePeriod"), 60, "Specifies the interval, in seconds, at which to update the statistics")
   127| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCRetainVM, W("GCRetainVM"), 0, "When set we put the segments that should be deleted on a standby list (instead of releasing them back to the OS) which will be considered to satisfy new segment requests (note that the same thing can be specified via API which is the supported way)")
   128| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCLOHThreshold, W("GCLOHThreshold"), 0, "Specifies the size that will make objects go on LOH")
   129| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_gcAllowVeryLargeObjects, W("gcAllowVeryLargeObjects"), 1, "Allow allocation of 2GB+ objects on GC heap")
   130| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCStress, W("GCStress"), 0, "Trigger GCs at regular intervals")
   131| CONFIG_DWORD_INFO(INTERNAL_GcStressOnDirectCalls, W("GcStressOnDirectCalls"), 0, "Whether to trigger a GC on direct calls")
   132| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_HeapVerify, W("HeapVerify"), 0, "When set verifies the integrity of the managed heap on entry and exit of each GC")
   133| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_GCNumaAware, W("GCNumaAware"), 1, "Specifies if to enable GC NUMA aware")
   134| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCCpuGroup, W("GCCpuGroup"), 0, "Specifies if to enable GC to support CPU groups")
   135| RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCName, W("GCName"), "")
   136| /**
   137|  * This flag allows us to force the runtime to use global allocation context on Windows x86/amd64 instead of thread allocation context just for testing purpose.
   138|  * The flag is unsafe for a subtle reason. Although the access to the g_global_alloc_context is protected under a lock. The implementation of
   139|  * that lock in the JIT helpers are not multi-core safe (in particular, it used and inc instruction without using the LOCK prefix). This is
   140|  * only useful for ad-hoc testing.
   141|  */
   142| CONFIG_DWORD_INFO(INTERNAL_GCUseGlobalAllocationContext, W("GCUseGlobalAllocationContext"), 0, "Force using the global allocation context for testing only")
   143| CONFIG_DWORD_INFO(INTERNAL_JitBreakEmit, W("JitBreakEmit"), (DWORD)-1, "")
   144| CONFIG_DWORD_INFO(INTERNAL_JitDebuggable, W("JitDebuggable"), 0, "")
   145| #if !defined(DEBUG) && !defined(_DEBUG)
   146| #define INTERNAL_JitEnableNoWayAssert_Default 0
   147| #else
   148| #define INTERNAL_JitEnableNoWayAssert_Default 1
   149| #endif
   150| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitEnableNoWayAssert, W("JitEnableNoWayAssert"), INTERNAL_JitEnableNoWayAssert_Default, "")
   151| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JitFramed, W("JitFramed"), 0, "Forces EBP frames")
   152| CONFIG_DWORD_INFO(INTERNAL_JitThrowOnAssertionFailure, W("JitThrowOnAssertionFailure"), 0, "Throw managed exception on assertion failures during JIT instead of failfast")
   153| CONFIG_DWORD_INFO(INTERNAL_JitGCStress, W("JitGCStress"), 0, "GC stress mode for jit")
   154| CONFIG_DWORD_INFO(INTERNAL_JitHeartbeat, W("JitHeartbeat"), 0, "")
   155| CONFIG_DWORD_INFO(INTERNAL_JitHelperLogging, W("JitHelperLogging"), 0, "")
   156| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_JITMinOpts, W("JITMinOpts"), 0, "Forces MinOpts")
   157| RETAIL_CONFIG_STRING_INFO(EXTERNAL_JitName, W("JitName"), "Primary jit to use")
   158| CONFIG_STRING_INFO(INTERNAL_JitPath, W("JitPath"), "Full path to primary jit to use")
   159| #if defined(ALLOW_SXS_JIT)
   160| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitName, W("AltJitName"), "Alternative jit to use, will fall back to primary jit.")
   161| CONFIG_STRING_INFO(INTERNAL_AltJitPath, W("AltJitPath"), "Full path to alternative jit to use")
   162| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJit, W("AltJit"), "Enables AltJit and selectively limits it to the specified methods.")
   163| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitOs, W("AltJitOS"), "Sets target OS for AltJit or uses native one by default. Only applicable for ARM/AMR64 at the moment.")
   164| RETAIL_CONFIG_STRING_INFO(EXTERNAL_AltJitExcludeAssemblies, W("AltJitExcludeAssemblies"), "Do not use AltJit on this semicolon-delimited list of assemblies.")
   165| #endif // defined(ALLOW_SXS_JIT)
   166| #if defined(FEATURE_STACK_SAMPLING)
   167| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEnabled, W("StackSamplingEnabled"), 0, "Is stack sampling based tracking of evolving hot methods enabled.")
   168| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingAfter, W("StackSamplingAfter"), 0, "When to start sampling (for some sort of app steady state), i.e., initial delay for sampling start in milliseconds.")
   169| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingEvery, W("StackSamplingEvery"), 100, "How frequent should thread stacks be sampled in milliseconds.")
   170| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StackSamplingNumMethods, W("StackSamplingNumMethods"), 32, "Number of evolving methods to track as hot and JIT them in the background at a given point of execution.")
   171| #endif // defined(FEATURE_JIT_SAMPLING)
   172| #if defined(ALLOW_SXS_JIT_NGEN)
   173| RETAIL_CONFIG_STRING_INFO(INTERNAL_AltJitNgen, W("AltJitNgen"), "Enables AltJit for NGEN and selectively limits it to the specified methods.")
   174| #endif // defined(ALLOW_SXS_JIT_NGEN)
   175| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitHostMaxSlabCache, W("JitHostMaxSlabCache"), 0x1000000, "Sets jit host max slab cache size, 16MB default")
   176| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitOptimizeType, W("JitOptimizeType"), 0 /* OPT_DEFAULT */, "")
   177| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitPrintInlinedMethods, W("JitPrintInlinedMethods"), 0, "")
   178| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitTelemetry, W("JitTelemetry"), 1, "If non-zero, gather JIT telemetry data")
   179| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogFile, W("JitTimeLogFile"), "If set, gather JIT throughput data and write to this file.")
   180| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitTimeLogCsv, W("JitTimeLogCsv"), "If set, gather JIT throughput data and write to a CSV file. This mode must be used in internal retail builds.")
   181| RETAIL_CONFIG_STRING_INFO(INTERNAL_JitFuncInfoLogFile, W("JitFuncInfoLogFile"), "If set, gather JIT function info and write to this file.")
   182| CONFIG_DWORD_INFO(INTERNAL_JitVerificationDisable, W("JitVerificationDisable"), 0, "")
   183| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitLockWrite, W("JitLockWrite"), 0, "Force all volatile writes to be 'locked'")
   184| CONFIG_STRING_INFO(INTERNAL_TailCallMax, W("TailCallMax"), "")
   185| RETAIL_CONFIG_STRING_INFO(EXTERNAL_TailCallOpt, W("TailCallOpt"), "")
   186| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TailCallLoopOpt, W("TailCallLoopOpt"), 1, "Convert recursive tail calls to loops")
   187| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Jit_NetFx40PInvokeStackResilience, W("NetFx40_PInvokeStackResilience"), (DWORD)-1, "Makes P/Invoke resilient against mismatched signature and calling convention (significant perf penalty).")
   188| #if defined(TARGET_X86)
   189| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 0, "Controls the AltJit behavior of NYI stuff")
   190| #else
   191| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AltJitAssertOnNYI, W("AltJitAssertOnNYI"), 1, "Controls the AltJit behavior of NYI stuff")
   192| #endif
   193| CONFIG_DWORD_INFO(INTERNAL_JitLargeBranches, W("JitLargeBranches"), 0, "Force using the largest conditional branch format")
   194| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_JitRegisterFP, W("JitRegisterFP"), 3, "Control FP enregistration")
   195| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitELTHookEnabled, W("JitELTHookEnabled"), 0, "On ARM, setting this will emit Enter/Leave/TailCall callbacks")
   196| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitMemStats, W("JitMemStats"), 0, "Display JIT memory usage statistics")
   197| RETAIL_CONFIG_DWORD_INFO(INTERNAL_JitVNMapSelBudget, W("JitVNMapSelBudget"), 100, "Max # of MapSelect's considered for a particular top-level invocation.")
   198| #if defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64)
   199| #define EXTERNAL_FeatureSIMD_Default 1
   200| #else // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   201| #define EXTERNAL_FeatureSIMD_Default 0
   202| #endif // !(defined(TARGET_AMD64) || defined(TARGET_X86) || defined(TARGET_ARM64))
   203| RETAIL_CONFIG_DWORD_INFO(INTERNAL_SIMD16ByteOnly, W("SIMD16ByteOnly"), 0, "Limit maximum SIMD vector length to 16 bytes (used by x64_arm64_altjit)")
   204| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TrackDynamicMethodDebugInfo, W("TrackDynamicMethodDebugInfo"), 0, "Specifies whether debug info should be generated and tracked for dynamic methods")
   205| #ifdef FEATURE_MULTICOREJIT
   206| RETAIL_CONFIG_STRING_INFO(INTERNAL_MultiCoreJitProfile, W("MultiCoreJitProfile"), "If set, use the file to store/control multi-core JIT.")
   207| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitProfileWriteDelay, W("MultiCoreJitProfileWriteDelay"), 12, "Set the delay after which the multi-core JIT profile will be written to disk.")
   208| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitMinNumCpus, W("MultiCoreJitMinNumCpus"), 2, "Minimum number of cpus that must be present to allow MultiCoreJit usage.")
   209| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MultiCoreJitNoProfileGather, W("MultiCoreJitNoProfileGather"), 0, "Set to 1 to disable profile gathering (but leave possibly enabled profile usage).")
   210| #endif
   211| #ifdef FEATURE_INTERPRETER
   212| RETAIL_CONFIG_STRING_INFO(INTERNAL_Interpret, W("Interpret"), "Selectively uses the interpreter to execute the specified methods")
   213| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpretExclude, W("InterpretExclude"), "Excludes the specified methods from the set selected by 'Interpret'")
   214| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMin, W("InterpreterMethHashMin"), 0, "Only interpret methods selected by 'Interpret' whose hash is at least this value. or after nth")
   215| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterMethHashMax, W("InterpreterMethHashMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose hash is at most this value")
   216| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMin, W("InterpreterStubMin"), 0, "Only interpret methods selected by 'Interpret' whose stub num is at least this value.")
   217| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterStubMax, W("InterpreterStubMax"), UINT32_MAX, "If non-zero, only interpret methods selected by 'Interpret' whose stub number is at most this value.")
   218| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterJITThreshold, W("InterpreterJITThreshold"), 10, "The number of times a method should be interpreted before being JITted")
   219| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterDoLoopMethods, W("InterpreterDoLoopMethods"), 0, "If set, don't check for loops, start by interpreting *all* methods")
   220| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterUseCaching, W("InterpreterUseCaching"), 1, "If non-zero, use the caching mechanism.")
   221| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterLooseRules, W("InterpreterLooseRules"), 1, "If non-zero, allow ECMA spec violations required by managed C++.")
   222| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterPrintPostMortem, W("InterpreterPrintPostMortem"), 0, "Prints summary information about the execution to the console")
   223| RETAIL_CONFIG_STRING_INFO(INTERNAL_InterpreterLogFile, W("InterpreterLogFile"), "If non-null, append interpreter logging to this file, else use stdout")
   224| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DumpInterpreterStubs, W("DumpInterpreterStubs"), 0, "Prints all interpreter stubs that are created to the console")
   225| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterEntries, W("TraceInterpreterEntries"), 0, "Logs entries to interpreted methods to the console")
   226| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterIL, W("TraceInterpreterIL"), 0, "Logs individual instructions of interpreted methods to the console")
   227| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterOstack, W("TraceInterpreterOstack"), 0, "Logs operand stack after each IL instruction of interpreted methods to the console")
   228| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterVerbose, W("TraceInterpreterVerbose"), 0, "Logs interpreter progress with detailed messages to the console")
   229| CONFIG_DWORD_INFO(INTERNAL_TraceInterpreterJITTransition, W("TraceInterpreterJITTransition"), 0, "Logs when the interpreter determines a method should be JITted")
   230| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ForceInterpreter, W("ForceInterpreter"), 0, "If non-zero, force the interpreter to be used")
   231| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterHWIntrinsicsIsSupportedFalse, W("InterpreterHWIntrinsicsIsSupportedFalse"), 0, "If non-zero, force get_IsSupported to return false for hardware intrinsics") // for internal testing purposes
   232| #endif
   233| RETAIL_CONFIG_DWORD_INFO(INTERNAL_InterpreterFallback, W("InterpreterFallback"), 0, "Fallback to the interpreter when the JIT compiler fails")
   234| CONFIG_DWORD_INFO(INTERNAL_LoaderHeapCallTracing, W("LoaderHeapCallTracing"), 0, "Loader heap troubleshooting")
   235| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CodeHeapReserveForJumpStubs, W("CodeHeapReserveForJumpStubs"), 1, "Percentage of code heap to reserve for jump stubs")
   236| RETAIL_CONFIG_DWORD_INFO(INTERNAL_NGenReserveForJumpStubs, W("NGenReserveForJumpStubs"), 0, "Percentage of ngen image size to reserve for jump stubs")
   237| RETAIL_CONFIG_DWORD_INFO(INTERNAL_BreakOnOutOfMemoryWithinRange, W("BreakOnOutOfMemoryWithinRange"), 0, "Break before out of memory within range exception is thrown")
   238| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogEnable, W("LogEnable"), 0, "Turns on the traditional CLR log.")
   239| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility,  W("LogFacility"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   240| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogFacility2, W("LogFacility2"), 0, "Specifies a facility mask for CLR log. (See 'loglf.h'; VM interprets string value as hex number.) Also used by stresslog.")
   241| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_logFatalError, W("logFatalError"), 1, "Specifies whether EventReporter logs fatal errors in the Windows event log.")
   242| CONFIG_STRING_INFO(INTERNAL_LogFile, W("LogFile"), "Specifies a file name for the CLR log.")
   243| CONFIG_DWORD_INFO(INTERNAL_LogFileAppend, W("LogFileAppend"), 0 , "Specifies whether to append to or replace the CLR log file.")
   244| CONFIG_DWORD_INFO(INTERNAL_LogFlushFile, W("LogFlushFile"), 0 , "Specifies whether to flush the CLR log file on each write.")
   245| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_LogLevel, W("LogLevel"), 0 , "4=10 msgs, 9=1000000, 10=everything")
   246| RETAIL_CONFIG_DWORD_INFO(INTERNAL_LogToConsole, W("LogToConsole"), 0 , "Writes the CLR log to console.")
   247| CONFIG_DWORD_INFO(INTERNAL_LogToDebugger, W("LogToDebugger"), 0 , "Writes the CLR log to debugger (OutputDebugStringA).")
   248| CONFIG_DWORD_INFO(INTERNAL_LogToFile, W("LogToFile"), 0 , "Writes the CLR log to a file.")
   249| CONFIG_DWORD_INFO(INTERNAL_LogWithPid, W("LogWithPid"), FALSE, "Appends pid to filename for the CLR log.")
   250| CONFIG_DWORD_INFO(INTERNAL_MD_ApplyDeltaBreak, W("MD_ApplyDeltaBreak"), 0, "ASSERT when applying EnC")
   251| RETAIL_CONFIG_DWORD_INFO(INTERNAL_AssertOnBadImageFormat, W("AssertOnBadImageFormat"), 0, "ASSERT when invalid MD read")
   252| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_DeltaCheck, W("MD_DeltaCheck"), 1, "Some checks of GUID when applying EnC (?)")
   253| CONFIG_DWORD_INFO(INTERNAL_MD_EncDelta, W("MD_EncDelta"), 0, "Forces EnC Delta format in MD (?)")
   254| RETAIL_CONFIG_DWORD_INFO(INTERNAL_MD_ForceNoColDesSharing, W("MD_ForceNoColDesSharing"), 0, "Don't know - the only usage I could find is #if 0 (?)")
   255| CONFIG_DWORD_INFO(INTERNAL_MD_KeepKnownCA, W("MD_KeepKnownCA"), 0, "Something with known CAs (?)")
   256| CONFIG_DWORD_INFO(INTERNAL_MD_MiniMDBreak, W("MD_MiniMDBreak"), 0, "ASSERT when creating CMiniMdRw class")
   257| CONFIG_DWORD_INFO(INTERNAL_MD_PreSaveBreak, W("MD_PreSaveBreak"), 0, "ASSERT when calling CMiniMdRw::PreSave")
   258| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaBreak, W("MD_RegMetaBreak"), 0, "ASSERT when creating RegMeta class")
   259| CONFIG_DWORD_INFO(INTERNAL_MD_RegMetaDump, W("MD_RegMetaDump"), 0, "Dump MD in 4 functions (?)")
   260| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_DOTNET_MODIFIABLE_ASSEMBLIES, W("MODIFIABLE_ASSEMBLIES"), "Enables hot reload on debug built assemblies with the 'debug' keyword", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue);
   261| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_MD_PreserveDebuggerMetadataMemory, W("MD_PreserveDebuggerMetadataMemory"), 0, "Save all versions of metadata memory in the debugger when debuggee metadata is updated")
   262| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinInitialDuration, W("SpinInitialDuration"), 0x32, "Hex value specifying the first spin duration")
   263| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinBackoffFactor, W("SpinBackoffFactor"), 0x3, "Hex value specifying the growth of each successive spin duration")
   264| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcCap, W("SpinLimitProcCap"), 0xFFFFFFFF, "Hex value specifying the largest value of NumProcs to use when calculating the maximum spin duration")
   265| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitProcFactor, W("SpinLimitProcFactor"), 0x4E20, "Hex value specifying the multiplier on NumProcs to use when calculating the maximum spin duration")
   266| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinLimitConstant, W("SpinLimitConstant"), 0x0, "Hex value specifying the constant to add when calculating the maximum spin duration")
   267| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_SpinRetryCount, W("SpinRetryCount"), 0xA, "Hex value specifying the number of times the entire spin process is repeated (when applicable)")
   268| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Monitor_SpinCount, W("Monitor_SpinCount"), 0x1e, "Hex value specifying the maximum number of spin iterations Monitor may perform upon contention on acquiring the lock before waiting.")
   269| CONFIG_DWORD_INFO(INTERNAL_SymDiffDump, W("SymDiffDump"), 0, "Used to create the map file while binding the assembly. Used by SemanticDiffer")
   270| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_PROFILING, W("CORECLR_ENABLE_PROFILING"), 0, "CoreCLR only: Flag to indicate whether profiling should be enabled for the currently running process.", CLRConfig::LookupOptions::DontPrependPrefix)
   271| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER, W("CORECLR_PROFILER"), "CoreCLR only: Specifies GUID of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   272| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH, W("CORECLR_PROFILER_PATH"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running process", CLRConfig::LookupOptions::DontPrependPrefix)
   273| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_32, W("CORECLR_PROFILER_PATH_32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   274| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_64, W("CORECLR_PROFILER_PATH_64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running 64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   275| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM32, W("CORECLR_PROFILER_PATH_ARM32"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM32 process", CLRConfig::LookupOptions::DontPrependPrefix)
   276| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_PROFILER_PATH_ARM64, W("CORECLR_PROFILER_PATH_ARM64"), "CoreCLR only: Specifies the path to the DLL of profiler to load into currently running ARM64 process", CLRConfig::LookupOptions::DontPrependPrefix)
   277| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_CORECLR_ENABLE_NOTIFICATION_PROFILERS, W("CORECLR_ENABLE_NOTIFICATION_PROFILERS"), 0, "Set to 0 to disable loading notification profilers.", CLRConfig::LookupOptions::DontPrependPrefix)
   278| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS, W("CORECLR_NOTIFICATION_PROFILERS"), "A semi-colon separated list of notification profilers to load into currently running process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   279| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_32, W("CORECLR_NOTIFICATION_PROFILERS_32"), "A semi-colon separated list of notification profilers to load into currently running 32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   280| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_64, W("CORECLR_NOTIFICATION_PROFILERS_64"), "A semi-colon separated list of notification profilers to load into currently running 64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   281| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM32, W("CORECLR_NOTIFICATION_PROFILERS_ARM32"), "A semi-colon separated list of notification profilers to load into currently running ARM32 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   282| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_CORECLR_NOTIFICATION_PROFILERS_ARM64, W("CORECLR_NOTIFICATION_PROFILERS_ARM64"), "A semi-colon separated list of notification profilers to load into currently running ARM64 process in the form \"path={guid}\"", CLRConfig::LookupOptions::DontPrependPrefix)
   283| RETAIL_CONFIG_STRING_INFO_EX(EXTERNAL_ProfAPI_ProfilerCompatibilitySetting, W("ProfAPI_ProfilerCompatibilitySetting"), "Specifies the profiler loading policy (the default is not to load a V2 profiler in V4)", CLRConfig::LookupOptions::TrimWhiteSpaceFromStringValue)
   284| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMinSleepMs, W("ProfAPI_DetachMinSleepMs"), 0, "The minimum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   285| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_DetachMaxSleepMs, W("ProfAPI_DetachMaxSleepMs"), 0, "The maximum time, in milliseconds, the CLR will wait before checking whether a profiler that is in the process of detaching is ready to be unloaded.")
   286| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_RejitOnAttach, W("ProfApi_RejitOnAttach"), 1, "Enables the ability for profilers to rejit methods on attach.")
   287| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ProfAPI_InliningTracking, W("ProfApi_InliningTracking"), 1, "Enables the runtime's tracking of inlining for profiler ReJIT.")
   288| CONFIG_DWORD_INFO(INTERNAL_ProfAPI_EnableRejitDiagnostics, W("ProfAPI_EnableRejitDiagnostics"), 0, "Enable extra dumping to stdout of rejit structures")
   289| CONFIG_DWORD_INFO(INTERNAL_ProfAPIFault, W("ProfAPIFault"), 0, "Test-only bitmask to inject various types of faults in the profapi code")
   290| CONFIG_DWORD_INFO(INTERNAL_TestOnlyAllowedEventMask, W("TestOnlyAllowedEventMask"), 0, "Test-only bitmask to allow profiler tests to override CLR enforcement of COR_PRF_ALLOWABLE_AFTER_ATTACH and COR_PRF_MONITOR_IMMUTABLE")
   291| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableICorProfilerInfo, W("ProfAPI_TestOnlyEnableICorProfilerInfo"), 0, "Test-only flag to allow attaching profiler tests to call ICorProfilerInfo interface, which would otherwise be disallowed for attaching profilers")
   292| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableObjectAllocatedHook, W("TestOnlyEnableObjectAllocatedHook"), 0, "Test-only flag that forces CLR to initialize on startup as if ObjectAllocated callback were requested, to enable post-attach ObjectAllocated functionality.")
   293| CONFIG_DWORD_INFO(INTERNAL_TestOnlyEnableSlowELTHooks, W("TestOnlyEnableSlowELTHooks"), 0, "Test-only flag that forces CLR to initialize on startup as if slow-ELT were requested, to enable post-attach ELT functionality.")
   294| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_ETW_ObjectAllocationEventsPerTypePerSec, W("ETW_ObjectAllocationEventsPerTypePerSec"), "Desired number of GCSampledObjectAllocation ETW events to be logged per type per second.  If 0, then the default built in to the implementation for the enabled event (e.g., High, Low), will be used.")
   295| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ProfAPI_ValidateNGENInstrumentation, W("ProfAPI_ValidateNGENInstrumentation"), 0, "This flag enables additional validations when using the IMetaDataEmit APIs for NGEN'ed images to ensure only supported edits are made.")
   296| #ifdef FEATURE_PERFMAP
   297| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapEnabled, W("PerfMapEnabled"), 0, "This flag is used on Linux to enable writing /tmp/perf-$pid.map. It is disabled by default")
   298| RETAIL_CONFIG_STRING_INFO(EXTERNAL_PerfMapJitDumpPath, W("PerfMapJitDumpPath"), "Specifies a path to write the perf jitdump file. Defaults to /tmp")
   299| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapIgnoreSignal, W("PerfMapIgnoreSignal"), 0, "When perf map is enabled, this option will configure the specified signal to be accepted and ignored as a marker in the perf logs.  It is disabled by default")
   300| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_PerfMapShowOptimizationTiers, W("PerfMapShowOptimizationTiers"), 1, "Shows optimization tiers in the perf map for methods, as part of the symbol name. Useful for seeing separate stack frames for different optimization tiers of each method.")
   301| RETAIL_CONFIG_STRING_INFO(EXTERNAL_NativeImagePerfMapFormat, W("NativeImagePerfMapFormat"), "Specifies the format of native image perfmap files generated by crossgen.  Valid options are RVA or OFFSET.")
   302| #endif
   303| RETAIL_CONFIG_STRING_INFO(EXTERNAL_StartupDelayMS, W("StartupDelayMS"), "")
   304| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLog, W("StressLog"), 0, "Turns on the stress log.")
   305| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_ForceEnc, W("ForceEnc"), 0, "Forces Edit and Continue to be on for all eligible modules.")
   306| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_StressLogSize, W("StressLogSize"), 0, "Stress log size in bytes per thread.")
   307| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_StressLogFilename, W("StressLogFilename"), "Stress log filename for memory mapped stress log.")
   308| CONFIG_DWORD_INFO(INTERNAL_stressSynchronized, W("stressSynchronized"), 0, "Unknown if or where this is used; unless a test is specifically depending on this, it can be removed.")
   309| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TotalStressLogSize, W("TotalStressLogSize"), 0, "Total stress log size in bytes.")
   310| CONFIG_DWORD_INFO(INTERNAL_DiagnosticSuspend, W("DiagnosticSuspend"), 0, "")
   311| CONFIG_DWORD_INFO(INTERNAL_SuspendDeadlockTimeout, W("SuspendDeadlockTimeout"), 40000, "")
   312| CONFIG_DWORD_INFO(INTERNAL_SuspendThreadDeadlockTimeoutMs, W("SuspendThreadDeadlockTimeoutMs"), 2000, "")
   313| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadSuspendInjection, W("INTERNAL_ThreadSuspendInjection"), 1, "Specifies whether to inject activations for thread suspension on Unix")
   314| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DefaultStackSize, W("DefaultStackSize"), 0, "Stack size to use for new VM threads when thread is created with default stack size (dwStackSize == 0).")
   315| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadCountThresholdForGCTrigger, W("Thread_DeadThreadCountThresholdForGCTrigger"), 75, "In the heuristics to clean up dead threads, this threshold must be reached before triggering a GC will be considered. Set to 0 to disable triggering a GC based on dead threads.")
   316| RETAIL_CONFIG_DWORD_INFO(INTERNAL_Thread_DeadThreadGCTriggerPeriodMilliseconds, W("Thread_DeadThreadGCTriggerPeriodMilliseconds"), 1000 * 60 * 30, "In the heuristics to clean up dead threads, this much time must have elapsed since the previous max-generation GC before triggering another GC will be considered")
   317| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_UseAllCpuGroups, W("Thread_UseAllCpuGroups"), 0, "Specifies whether to query and use CPU group information for determining the processor count.")
   318| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Thread_AssignCpuGroups, W("Thread_AssignCpuGroups"), 1, "Specifies whether to automatically distribute threads created by the CLR across CPU Groups. Effective only when Thread_UseAllCpuGroups and GCCpuGroup are enabled.")
   319| RETAIL_CONFIG_DWORD_INFO_EX(EXTERNAL_ProcessorCount, W("PROCESSOR_COUNT"), 0, "Specifies the number of processors available for the process, which is returned by Environment.ProcessorCount", CLRConfig::LookupOptions::ParseIntegerAsBase10)
   320| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPool, W("ThreadPool_UsePortableThreadPool"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one.")
   321| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UsePortableThreadPoolForIO, W("ThreadPool_UsePortableThreadPoolForIO"), 1, "Uses the managed portable thread pool implementation instead of the unmanaged one for async IO.")
   322| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMinWorkerThreads, W("ThreadPool_ForceMinWorkerThreads"), 0, "Overrides the MinThreads setting for the ThreadPool worker pool")
   323| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_ForceMaxWorkerThreads, W("ThreadPool_ForceMaxWorkerThreads"), 0, "Overrides the MaxThreads setting for the ThreadPool worker pool")
   324| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DisableStarvationDetection, W("ThreadPool_DisableStarvationDetection"), 0, "Disables the ThreadPool feature that forces new threads to be added when workitems run for too long")
   325| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_DebugBreakOnWorkerStarvation, W("ThreadPool_DebugBreakOnWorkerStarvation"), 0, "Breaks into the debugger if the ThreadPool detects work queue starvation")
   326| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_EnableWorkerTracking, W("ThreadPool_EnableWorkerTracking"), 0, "Enables extra expensive tracking of how many workers threads are working simultaneously")
   327| #ifdef TARGET_ARM64
   328| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x32, "Maximum number of spins per processor a thread pool worker thread performs before waiting for work")
   329| #else // !TARGET_ARM64
   330| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ThreadPool_UnfairSemaphoreSpinLimit, W("ThreadPool_UnfairSemaphoreSpinLimit"), 0x46, "Maximum number of spins a thread pool worker thread performs before waiting for work")
   331| #endif // TARGET_ARM64
   332| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Disable,                             W("HillClimbing_Disable"),                            0, "Disables hill climbing for thread adjustments in the thread pool");
   333| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WavePeriod,                          W("HillClimbing_WavePeriod"),                         4, "");
   334| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_TargetSignalToNoiseRatio,            W("HillClimbing_TargetSignalToNoiseRatio"),           300, "");
   335| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_ErrorSmoothingFactor,                W("HillClimbing_ErrorSmoothingFactor"),               1, "");
   336| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveMagnitudeMultiplier,             W("HillClimbing_WaveMagnitudeMultiplier"),            100, "");
   337| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxWaveMagnitude,                    W("HillClimbing_MaxWaveMagnitude"),                   20, "");
   338| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_WaveHistorySize,                     W("HillClimbing_WaveHistorySize"),                    8, "");
   339| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_Bias,                                W("HillClimbing_Bias"),                               15, "The 'cost' of a thread.  0 means drive for increased throughput regardless of thread count; higher values bias more against higher thread counts.");
   340| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSecond,                  W("HillClimbing_MaxChangePerSecond"),                 4, "");
   341| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxChangePerSample,                  W("HillClimbing_MaxChangePerSample"),                 20, "");
   342| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_MaxSampleErrorPercent,               W("HillClimbing_MaxSampleErrorPercent"),              15, "");
   343| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalLow,                   W("HillClimbing_SampleIntervalLow"),                  10, "");
   344| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_SampleIntervalHigh,                  W("HillClimbing_SampleIntervalHigh"),                 200, "");
   345| RETAIL_CONFIG_DWORD_INFO(INTERNAL_HillClimbing_GainExponent,                        W("HillClimbing_GainExponent"),                       200, "The exponent to apply to the gain, times 100.  100 means to use linear gain, higher values will enhance large moves and damp small ones.");
   346| #ifdef FEATURE_TIERED_COMPILATION
   347| #ifdef _DEBUG
   348| #define TC_BackgroundWorkerTimeoutMs (100)
   349| #define TC_CallCountThreshold (2)
   350| #define TC_CallCountingDelayMs (1)
   351| #define TC_DelaySingleProcMultiplier (2)
   352| #else // !_DEBUG
   353| #define TC_BackgroundWorkerTimeoutMs (4000)
   354| #define TC_CallCountThreshold (30)
   355| #define TC_CallCountingDelayMs (100)
   356| #define TC_DelaySingleProcMultiplier (10)
   357| #endif // _DEBUG
   358| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredCompilation, W("TieredCompilation"), 1, "Enables tiered compilation")
   359| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_QuickJit, W("TC_QuickJit"), 1, "For methods that would be jitted, enable using quick JIT when appropriate.")
   360| #if defined(TARGET_AMD64) || defined(TARGET_ARM64)
   361| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 1, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
   362| #else // !(defined(TARGET_AMD64) || defined(TARGET_ARM64))
   363| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TC_QuickJitForLoops, W("TC_QuickJitForLoops"), 0, "When quick JIT is enabled, quick JIT may also be used for methods that contain loops.")
   364| #endif // defined(TARGET_AMD64) || defined(TARGET_ARM64)
   365| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TC_AggressiveTiering, W("TC_AggressiveTiering"), 0, "Transition through tiers aggressively.")
   366| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_BackgroundWorkerTimeoutMs, W("TC_BackgroundWorkerTimeoutMs"), TC_BackgroundWorkerTimeoutMs, "How long in milliseconds the background worker thread may remain idle before exiting.")
   367| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountThreshold, W("TC_CallCountThreshold"), TC_CallCountThreshold, "Number of times a method must be called in tier 0 after which it is promoted to the next tier.")
   368| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCountingDelayMs, W("TC_CallCountingDelayMs"), TC_CallCountingDelayMs, "A perpetual delay in milliseconds that is applied to call counting in tier 0 and jitting at higher tiers, while there is startup-like activity.")
   369| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DelaySingleProcMultiplier, W("TC_DelaySingleProcMultiplier"), TC_DelaySingleProcMultiplier, "Multiplier for TC_CallCountingDelayMs that is applied on a single-processor machine or when the process is affinitized to a single processor.")
   370| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_CallCounting, W("TC_CallCounting"), 1, "Enabled by default (only activates when TieredCompilation is also enabled). If disabled immediately backpatches prestub, and likely prevents any promotion to higher tiers")
   371| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_UseCallCountingStubs, W("TC_UseCallCountingStubs"), 1, "Uses call counting stubs for faster call counting.")
   372| RETAIL_CONFIG_DWORD_INFO(INTERNAL_TC_DeleteCallCountingStubsAfter, W("TC_DeleteCallCountingStubsAfter"), 0, "Deletes call counting stubs after this many have completed. Zero to disable deleting.")
   373| #undef TC_BackgroundWorkerTimeoutMs
   374| #undef TC_CallCountThreshold
   375| #undef TC_CallCountingDelayMs
   376| #undef TC_DelaySingleProcMultiplier
   377| #undef TC_DeleteCallCountingStubsAfter
   378| #endif // FEATURE_TIERED_COMPILATION
   379| #ifdef FEATURE_ON_STACK_REPLACEMENT
   380| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_CounterBump, W("OSR_CounterBump"), 1000, "Counter reload value when a patchpoint is hit")
   381| RETAIL_CONFIG_DWORD_INFO(INTERNAL_OSR_HitLimit, W("OSR_HitLimit"), 10, "Number of times a patchpoint must call back to trigger an OSR transition")
   382| CONFIG_DWORD_INFO(INTERNAL_OSR_LowId, W("OSR_LowId"), (DWORD)-1, "Low end of enabled patchpoint range (inclusive)");
   383| CONFIG_DWORD_INFO(INTERNAL_OSR_HighId, W("OSR_HighId"), 10000000, "High end of enabled patchpoint range (inclusive)");
   384| #endif
   385| #ifdef FEATURE_PGO
   386| RETAIL_CONFIG_STRING_INFO(INTERNAL_PGODataPath, W("PGODataPath"), "Read/Write PGO data from/to the indicated file.")
   387| RETAIL_CONFIG_DWORD_INFO(INTERNAL_ReadPGOData, W("ReadPGOData"), 0, "Read PGO data")
   388| RETAIL_CONFIG_DWORD_INFO(INTERNAL_WritePGOData, W("WritePGOData"), 0, "Write PGO data")
   389| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TieredPGO, W("TieredPGO"), 0, "Instrument Tier0 code and make counts available to Tier1")
   390| #endif
   391| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_BackpatchEntryPointSlots, W("BackpatchEntryPointSlots"), 1, "Indicates whether to enable entry point slot backpatching, for instance to avoid making virtual calls through a precode and instead to patch virtual slots for a method when its entry point changes.")
   392| CONFIG_DWORD_INFO(INTERNAL_TypeLoader_InjectInterfaceDuplicates, W("INTERNAL_TypeLoader_InjectInterfaceDuplicates"), 0, "Injects duplicates in interface map for all types.")
   393| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideMonoPct, W("VirtualCallStubCollideMonoPct"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   394| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubCollideWritePct, W("VirtualCallStubCollideWritePct"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   395| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogCounter, W("VirtualCallStubDumpLogCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   396| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubDumpLogIncr, W("VirtualCallStubDumpLogIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   397| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_VirtualCallStubLogging, W("VirtualCallStubLogging"), 0, "Worth keeping, but should be moved into \"#ifdef STUB_LOGGING\" blocks. This goes for most (or all) of the stub logging infrastructure.")
   398| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubMissCount, W("VirtualCallStubMissCount"), 100, "Used only when STUB_LOGGING is defined, which by default is not.")
   399| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheCounter, W("VirtualCallStubResetCacheCounter"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   400| CONFIG_DWORD_INFO(INTERNAL_VirtualCallStubResetCacheIncr, W("VirtualCallStubResetCacheIncr"), 0, "Used only when STUB_LOGGING is defined, which by default is not.")
   401| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DisableWatsonForManagedExceptions, W("DisableWatsonForManagedExceptions"), 0, "Disable Watson and debugger launching for managed exceptions")
   402| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgEnableMiniDump, W("DbgEnableMiniDump"), 0, "Enable unhandled exception crash dump generation")
   403| RETAIL_CONFIG_STRING_INFO(INTERNAL_DbgMiniDumpName, W("DbgMiniDumpName"), "Crash dump name")
   404| RETAIL_CONFIG_DWORD_INFO(INTERNAL_DbgMiniDumpType, W("DbgMiniDumpType"), 0, "Crash dump type: 1 normal, 2 withheap, 3 triage, 4 full")
   405| RETAIL_CONFIG_DWORD_INFO(INTERNAL_CreateDumpDiagnostics, W("CreateDumpDiagnostics"), 0, "Enable crash dump generation diagnostic logging")
   406| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableDumpOnSigTerm, W("EnableDumpOnSigTerm"), 0, "Enable crash dump generation on SIGTERM")
   407| RETAIL_CONFIG_STRING_INFO(INTERNAL_ZapBBInstr, W("ZapBBInstr"), "")
   408| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ZapBBInstrDir, W("ZapBBInstrDir"), "")
   409| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ZapDisable, W("ZapDisable"), 0, "")
   410| RETAIL_CONFIG_STRING_INFO(INTERNAL_NativeImageSearchPaths, W("NativeImageSearchPaths"), "Extra search paths for native composite R2R images")
   411| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ReadyToRun, W("ReadyToRun"), 1, "Enable/disable use of ReadyToRun native code") // On by default for CoreCLR
   412| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunExcludeList, W("ReadyToRunExcludeList"), "List of assemblies that cannot use Ready to Run images")
   413| RETAIL_CONFIG_STRING_INFO(EXTERNAL_ReadyToRunLogFile, W("ReadyToRunLogFile"), "Name of file to log success/failure of using Ready to Run images")
   414| #if defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   415| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableEventLog, W("EnableEventLog"), 0, "Enable/disable use of EnableEventLogging mechanism ") // Off by default
   416| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventSourceFilter, W("EventSourceFilter"), "")
   417| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventNameFilter, W("EventNameFilter"), "")
   418| #endif //defined(FEATURE_EVENT_TRACE) || defined(FEATURE_EVENTSOURCE_XPLAT)
   419| CONFIG_DWORD_INFO(INTERNAL_ExposeExceptionsInCOM, W("ExposeExceptionsInCOM"), 0, "")
   420| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_InteropValidatePinnedObjects, W("InteropValidatePinnedObjects"), 0, "After returning from a managed-to-unmanaged interop call, validate GC heap around objects pinned by IL stubs.")
   421| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_InteropLogArguments, W("InteropLogArguments"), 0, "Log all pinned arguments passed to an interop call")
   422| RETAIL_CONFIG_STRING_INFO(UNSUPPORTED_LogCCWRefCountChange, W("LogCCWRefCountChange"), "Outputs debug information and calls LogCCWRefCountChange_BREAKPOINT when AddRef or Release is called on a CCW.")
   423| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableRCWCleanupOnSTAShutdown, W("EnableRCWCleanupOnSTAShutdown"), 0, "Performs RCW cleanup when STA shutdown is detected using IInitializeSpy in classic processes.")
   424| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EnableEventPipe, W("EnableEventPipe"), 0, "Enable/disable event pipe.  Non-zero values enable tracing.")
   425| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeNetTraceFormat, W("EventPipeNetTraceFormat"), 1, "Enable/disable using the newer nettrace file format.")
   426| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeOutputPath, W("EventPipeOutputPath"), "The full path excluding file name for the trace file that will be written when COMPlus_EnableEventPipe=1")
   427| RETAIL_CONFIG_STRING_INFO(INTERNAL_EventPipeConfig, W("EventPipeConfig"), "Configuration for EventPipe.")
   428| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeRundown, W("EventPipeRundown"), 1, "Enable/disable eventpipe rundown.")
   429| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeCircularMB, W("EventPipeCircularMB"), 1024, "The EventPipe circular buffer size in megabytes.")
   430| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeProcNumbers, W("EventPipeProcNumbers"), 0, "Enable/disable capturing processor numbers in EventPipe event headers")
   431| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeOutputStreaming, W("EventPipeOutputStreaming"), 0, "Enable/disable streaming for trace file set in COMPlus_EventPipeOutputPath.  Non-zero values enable streaming.")
   432| RETAIL_CONFIG_DWORD_INFO(INTERNAL_EventPipeEnableStackwalk, W("EventPipeEnableStackwalk"), 1, "Set to 0 to disable collecting stacks for EventPipe events.")
   433| #ifdef FEATURE_AUTO_TRACE
   434| RETAIL_CONFIG_DWORD_INFO_EX(INTERNAL_AutoTrace_N_Tracers, W("AutoTrace_N_Tracers"), 0, "", CLRConfig::LookupOptions::ParseIntegerAsBase10)
   435| RETAIL_CONFIG_STRING_INFO(INTERNAL_AutoTrace_Command, W("AutoTrace_Command"), "")
   436| #endif // FEATURE_AUTO_TRACE
   437| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisGen, W("GCGenAnalysisGen"), 0, "The generation to trigger generational aware analysis")
   438| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisBytes, W("GCGenAnalysisBytes"), 0, "The number of bytes to trigger generational aware analysis")
   439| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeUSec, W("GCGenAnalysisTimeUSec"), 0, "The number of microseconds to trigger generational aware analysis")
   440| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTimeMSec, W("GCGenAnalysisTimeMSec"), 0, "The number of milliseconds to trigger generational aware analysis")
   441| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisIndex, W("GCGenAnalysisIndex"), 0, "The gc index to trigger generational aware analysis")
   442| RETAIL_CONFIG_STRING_INFO(EXTERNAL_GCGenAnalysisCmd, W("GCGenAnalysisCmd"), "An optional filter to match with the command line used to spawn the process")
   443| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisTrace, W("GCGenAnalysisTrace"), 1, "Enable/Disable capturing a trace")
   444| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_GCGenAnalysisDump, W("GCGenAnalysisDump"), 0, "Enable/Disable capturing a dump")
   445| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DOTNET_DefaultDiagnosticPortSuspend, W("DefaultDiagnosticPortSuspend"), 0, "This sets the deafult diagnostic port to suspend causing the runtime to pause during startup before major subsystems are started.  Resume using the Diagnostics IPC ResumeStartup command on the default diagnostic port.");
   446| RETAIL_CONFIG_STRING_INFO(EXTERNAL_DOTNET_DiagnosticPorts, W("DiagnosticPorts"), "A semicolon delimited list of additional Diagnostic Ports, where a Diagnostic Port is a NamedPipe path without '\\\\.\\pipe\\' on Windows or the full path of Unix Domain Socket on Linux/Unix followed by optional tags, e.g., '<path>,connect,nosuspend;<path>'");
   447| RETAIL_CONFIG_STRING_INFO(INTERNAL_LTTngConfig, W("LTTngConfig"), "Configuration for LTTng.")
   448| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_LTTng, W("LTTng"), 1, "If COMPlus_LTTng is set to 0, this will prevent the LTTng library from being loaded at runtime")
   449| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableWriteXorExecute, W("EnableWriteXorExecute"), 1, "Enable W^X for executable memory.");
   450| #ifdef FEATURE_GDBJIT
   451| CONFIG_STRING_INFO(INTERNAL_GDBJitElfDump, W("GDBJitElfDump"), "Dump ELF for specified method")
   452| #ifdef FEATURE_GDBJIT_FRAME
   453| RETAIL_CONFIG_DWORD_INFO(INTERNAL_GDBJitEmitDebugFrame, W("GDBJitEmitDebugFrame"), TRUE, "Enable .debug_frame generation")
   454| #endif
   455| #endif
   456| #if defined(TARGET_LOONGARCH64)
   457| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  0, "Allows Base+ hardware intrinsics to be disabled")
   458| #else
   459| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableHWIntrinsic,  W("EnableHWIntrinsic"),  1, "Allows Base+ hardware intrinsics to be disabled")
   460| #endif // defined(TARGET_LOONGARCH64)
   461| #if defined(TARGET_AMD64) || defined(TARGET_X86)
   462| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAES,          W("EnableAES"),          1, "Allows AES+ hardware intrinsics to be disabled")
   463| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX,          W("EnableAVX"),          1, "Allows AVX+ hardware intrinsics to be disabled")
   464| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVX2,         W("EnableAVX2"),         1, "Allows AVX2+ hardware intrinsics to be disabled")
   465| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableAVXVNNI,      W("EnableAVXVNNI"),      1, "Allows AVX VNNI+ hardware intrinsics to be disabled")
   466| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI1,         W("EnableBMI1"),         1, "Allows BMI1+ hardware intrinsics to be disabled")
   467| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableBMI2,         W("EnableBMI2"),         1, "Allows BMI2+ hardware intrinsics to be disabled")
   468| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableFMA,          W("EnableFMA"),          1, "Allows FMA+ hardware intrinsics to be disabled")
   469| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableLZCNT,        W("EnableLZCNT"),        1, "Allows LZCNT+ hardware intrinsics to be disabled")
   470| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePCLMULQDQ,    W("EnablePCLMULQDQ"),    1, "Allows PCLMULQDQ+ hardware intrinsics to be disabled")
   471| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableMOVBE,        W("EnableMOVBE"),        1, "Allows MOVBE+ hardware intrinsics to be disabled")
   472| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnablePOPCNT,       W("EnablePOPCNT"),       1, "Allows POPCNT+ hardware intrinsics to be disabled")
   473| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE,          W("EnableSSE"),          1, "Allows SSE+ hardware intrinsics to be disabled")
   474| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE2,         W("EnableSSE2"),         1, "Allows SSE2+ hardware intrinsics to be disabled")
   475| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3,         W("EnableSSE3"),         1, "Allows SSE3+ hardware intrinsics to be disabled")
   476| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE3_4,       W("EnableSSE3_4"),       1, "Allows SSE3+ hardware intrinsics to be disabled")
   477| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE41,        W("EnableSSE41"),        1, "Allows SSE4.1+ hardware intrinsics to be disabled")
   478| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSE42,        W("EnableSSE42"),        1, "Allows SSE4.2+ hardware intrinsics to be disabled")
   479| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableSSSE3,        W("EnableSSSE3"),        1, "Allows SSSE3+ hardware intrinsics to be disabled")
   480| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableX86Serialize, W("EnableX86Serialize"), 1, "Allows X86Serialize+ hardware intrinsics to be disabled")
   481| #elif defined(TARGET_ARM64)
   482| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64AdvSimd, W("EnableArm64AdvSimd"), 1, "Allows Arm64 AdvSimd+ hardware intrinsics to be disabled")
   483| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Aes,     W("EnableArm64Aes"),     1, "Allows Arm64 Aes+ hardware intrinsics to be disabled")
   484| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Atomics, W("EnableArm64Atomics"), 1, "Allows Arm64 Atomics+ hardware intrinsics to be disabled")
   485| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Crc32,   W("EnableArm64Crc32"),   1, "Allows Arm64 Crc32+ hardware intrinsics to be disabled")
   486| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dczva,   W("EnableArm64Dczva"),   1, "Allows Arm64 Dczva+ hardware intrinsics to be disabled")
   487| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Dp,      W("EnableArm64Dp"),      1, "Allows Arm64 Dp+ hardware intrinsics to be disabled")
   488| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rdm,     W("EnableArm64Rdm"),     1, "Allows Arm64 Rdm+ hardware intrinsics to be disabled")
   489| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha1,    W("EnableArm64Sha1"),    1, "Allows Arm64 Sha1+ hardware intrinsics to be disabled")
   490| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Sha256,  W("EnableArm64Sha256"),  1, "Allows Arm64 Sha256+ hardware intrinsics to be disabled")
   491| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_EnableArm64Rcpc,    W("EnableArm64Rcpc"),    1, "Allows Arm64 Rcpc+ hardware intrinsics to be disabled")
   492| #endif
   493| CONFIG_DWORD_INFO(INTERNAL_ActivatePatchSkip, W("ActivatePatchSkip"), 0, "Allows an assert when ActivatePatchSkip is called")
   494| CONFIG_DWORD_INFO(INTERNAL_AlwaysUseMetadataInterfaceMapLayout, W("AlwaysUseMetadataInterfaceMapLayout"), 0, "Used for debugging generic interface map layout.")
   495| CONFIG_DWORD_INFO(INTERNAL_AssertOnUnneededThis, W("AssertOnUnneededThis"), 0, "While the ConfigDWORD is unnecessary, the contained ASSERT should be kept. This may result in some work tracking down violating MethodDescCallSites.")
   496| CONFIG_DWORD_INFO(INTERNAL_AssertStacktrace, W("AssertStacktrace"), 1, "")
   497| CONFIG_DWORD_INFO(INTERNAL_clearNativeImageStress, W("clearNativeImageStress"), 0, "")
   498| CONFIG_DWORD_INFO(INTERNAL_CPUFamily, W("CPUFamily"), 0xFFFFFFFF, "")
   499| CONFIG_DWORD_INFO(INTERNAL_CPUFeatures, W("CPUFeatures"), 0xFFFFFFFF, "")
   500| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableConfigCache, W("DisableConfigCache"), 0, "Used to disable the \"probabilistic\" config cache, which walks through the appropriate config registry keys on init and probabilistically keeps track of which exist.")
   501| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_DisableStackwalkCache, W("DisableStackwalkCache"), 0, "")
   502| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_DoubleArrayToLargeObjectHeap, W("DoubleArrayToLargeObjectHeap"), 0, "Controls double[] placement")
   503| CONFIG_STRING_INFO(INTERNAL_DumpOnClassLoad, W("DumpOnClassLoad"), "Dumps information about loaded class to log.")
   504| CONFIG_DWORD_INFO(INTERNAL_ExpandAllOnLoad, W("ExpandAllOnLoad"), 0, "")
   505| CONFIG_DWORD_INFO(INTERNAL_ForceRelocs, W("ForceRelocs"), 0, "")
   506| CONFIG_DWORD_INFO(INTERNAL_GenerateLongJumpDispatchStubRatio, W("GenerateLongJumpDispatchStubRatio"), 0, "Useful for testing VSD on AMD64")
   507| CONFIG_DWORD_INFO(INTERNAL_HashStack, W("HashStack"), 0, "")
   508| CONFIG_DWORD_INFO(INTERNAL_HostManagerConfig, W("HostManagerConfig"), (DWORD)-1, "")
   509| CONFIG_DWORD_INFO(INTERNAL_HostTestThreadAbort, W("HostTestThreadAbort"), 0, "")
   510| CONFIG_STRING_INFO(INTERNAL_InvokeHalt, W("InvokeHalt"), "Throws an assert when the given method is invoked through reflection.")
   511| CONFIG_DWORD_INFO(INTERNAL_MaxStubUnwindInfoSegmentSize, W("MaxStubUnwindInfoSegmentSize"), 0, "")
   512| CONFIG_DWORD_INFO(INTERNAL_MessageDebugOut, W("MessageDebugOut"), 0, "")
   513| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NativeImageRequire, W("NativeImageRequire"), 0, "")
   514| CONFIG_DWORD_INFO(INTERNAL_NestedEhOom, W("NestedEhOom"), 0, "")
   515| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_NoProcedureSplitting, W("NoProcedureSplitting"), 0, "")
   516| CONFIG_DWORD_INFO(INTERNAL_PauseOnLoad, W("PauseOnLoad"), 0, "Stops in SystemDomain::init. I think it can be removed.")
   517| CONFIG_DWORD_INFO(INTERNAL_PerfAllocsSizeThreshold, W("PerfAllocsSizeThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   518| CONFIG_DWORD_INFO(INTERNAL_PerfNumAllocsThreshold, W("PerfNumAllocsThreshold"), 0x3FFFFFFF, "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   519| CONFIG_STRING_INFO(INTERNAL_PerfTypesToLog, W("PerfTypesToLog"), "Log facility LF_GCALLOC logs object allocations. This flag controls which ones also log stacktraces. Predates ClrProfiler.")
   520| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_Prepopulate1, W("Prepopulate1"), 1, "")
   521| CONFIG_STRING_INFO(INTERNAL_PrestubGC, W("PrestubGC"), "")
   522| CONFIG_STRING_INFO(INTERNAL_PrestubHalt, W("PrestubHalt"), "")
   523| RETAIL_CONFIG_STRING_INFO(EXTERNAL_RestrictedGCStressExe, W("RestrictedGCStressExe"), "")
   524| CONFIG_DWORD_INFO(INTERNAL_ReturnSourceTypeForTesting, W("ReturnSourceTypeForTesting"), 0, "Allows returning the (internal only) source type of an IL to Native mapping for debugging purposes")
   525| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_RSStressLog, W("RSStressLog"), 0, "Allows turning on logging for RS startup")
   526| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnNewIndex, W("SBDumpOnNewIndex"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   527| CONFIG_DWORD_INFO(INTERNAL_SBDumpOnResize, W("SBDumpOnResize"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   528| CONFIG_DWORD_INFO(INTERNAL_SBDumpStyle, W("SBDumpStyle"), 0, "Used for Syncblock debugging. It's been a while since any of those have been used.")
   529| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SleepOnExit, W("SleepOnExit"), 0, "Used for lrak detection. I'd say deprecated by umdh.")
   530| CONFIG_DWORD_INFO(INTERNAL_StubLinkerUnwindInfoVerificationOn, W("StubLinkerUnwindInfoVerificationOn"), 0, "")
   531| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_SuccessExit, W("SuccessExit"), 0, "")
   532| RETAIL_CONFIG_DWORD_INFO(UNSUPPORTED_TestDataConsistency, W("TestDataConsistency"), FALSE, "Allows ensuring the left side is not holding locks (and may thus be in an inconsistent state) when inspection occurs")
   533| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_ThreadGuardPages, W("ThreadGuardPages"), 0, "")
   534| #ifdef _DEBUG
   535| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_TraceWrap, W("TraceWrap"), 0, "")
   536| #endif
   537| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseMethodDataCache, W("UseMethodDataCache"), FALSE, "Used during feature development; may now be removed.")
   538| RETAIL_CONFIG_DWORD_INFO(EXTERNAL_UseParentMethodData, W("UseParentMethodData"), TRUE, "Used during feature development; may now be removed.")
   539| CONFIG_DWORD_INFO(INTERNAL_VerifierOff, W("VerifierOff"), 0, "")


# ====================================================================
# FILE: src/coreclr/jit/lclvars.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5963 ---
     1| /*XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
     2| XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
     3| XX                                                                           XX
     4| XX                           LclVarsInfo                                     XX
     5| XX                                                                           XX
     6| XX   The variables to be used by the code generator.                         XX
     7| XX                                                                           XX
     8| XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
     9| XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    10| */
    11| #include "jitpch.h"
    12| #ifdef _MSC_VER
    13| #pragma hdrstop
    14| #endif
    15| #include "emit.h"
    16| #include "register_arg_convention.h"
    17| #include "jitstd/algorithm.h"
    18| #include "patchpointinfo.h"
    19| /*****************************************************************************/
    20| #ifdef DEBUG
    21| #if DOUBLE_ALIGN
    22| /* static */
    23| unsigned Compiler::s_lvaDoubleAlignedProcsCount = 0;
    24| #endif
    25| #endif
    26| /*****************************************************************************/
    27| void Compiler::lvaInit()
    28| {
    29|     /* We haven't allocated stack variables yet */
    30|     lvaRefCountState = RCS_INVALID;
    31|     lvaGenericsContextInUse = false;
    32|     lvaTrackedToVarNumSize = 0;
    33|     lvaTrackedToVarNum     = nullptr;
    34|     lvaTrackedFixed = false; // false: We can still add new tracked variables
    35|     lvaDoneFrameLayout = NO_FRAME_LAYOUT;
    36| #if !defined(FEATURE_EH_FUNCLETS)
    37|     lvaShadowSPslotsVar = BAD_VAR_NUM;
    38| #endif // !FEATURE_EH_FUNCLETS
    39|     lvaInlinedPInvokeFrameVar = BAD_VAR_NUM;
    40|     lvaReversePInvokeFrameVar = BAD_VAR_NUM;
    41| #if FEATURE_FIXED_OUT_ARGS
    42|     lvaPInvokeFrameRegSaveVar = BAD_VAR_NUM;
    43|     lvaOutgoingArgSpaceVar    = BAD_VAR_NUM;
    44|     lvaOutgoingArgSpaceSize   = PhasedVar<unsigned>();
    45| #endif // FEATURE_FIXED_OUT_ARGS
    46| #ifdef JIT32_GCENCODER
    47|     lvaLocAllocSPvar = BAD_VAR_NUM;
    48| #endif // JIT32_GCENCODER
    49|     lvaNewObjArrayArgs  = BAD_VAR_NUM;
    50|     lvaGSSecurityCookie = BAD_VAR_NUM;
    51| #ifdef TARGET_X86
    52|     lvaVarargsBaseOfStkArgs = BAD_VAR_NUM;
    53| #endif // TARGET_X86
    54|     lvaVarargsHandleArg = BAD_VAR_NUM;
    55|     lvaStubArgumentVar  = BAD_VAR_NUM;
    56|     lvaArg0Var          = BAD_VAR_NUM;
    57|     lvaMonAcquired      = BAD_VAR_NUM;
    58|     lvaRetAddrVar       = BAD_VAR_NUM;
    59|     lvaInlineeReturnSpillTemp = BAD_VAR_NUM;
    60|     gsShadowVarInfo = nullptr;
    61| #if defined(FEATURE_EH_FUNCLETS)
    62|     lvaPSPSym = BAD_VAR_NUM;
    63| #endif
    64| #if FEATURE_SIMD
    65|     lvaSIMDInitTempVarNum = BAD_VAR_NUM;
    66| #endif // FEATURE_SIMD
    67|     lvaCurEpoch = 0;
    68|     structPromotionHelper = new (this, CMK_Generic) StructPromotionHelper(this);
    69| }
    70| /*****************************************************************************/
    71| void Compiler::lvaInitTypeRef()
    72| {
    73|     /* x86 args look something like this:
    74|         [this ptr] [hidden return buffer] [declared arguments]* [generic context] [var arg cookie]
    75|        x64 is closer to the native ABI:
    76|         [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*
    77|         (Note: prior to .NET Framework 4.5.1 for Windows 8.1 (but not .NET Framework 4.5.1 "downlevel"),
    78|         the "hidden return buffer" came before the "this ptr". Now, the "this ptr" comes first. This
    79|         is different from the C++ order, where the "hidden return buffer" always comes first.)
    80|        ARM and ARM64 are the same as the current x64 convention:
    81|         [this ptr] [hidden return buffer] [generic context] [var arg cookie] [declared arguments]*
    82|        Key difference:
    83|            The var arg cookie and generic context are swapped with respect to the user arguments
    84|     */
    85|     /* Set compArgsCount and compLocalsCount */
    86|     info.compArgsCount = info.compMethodInfo->args.numArgs;
    87|     if (!info.compIsStatic)
    88|     {
    89|         info.compArgsCount++;
    90|     }
    91|     else
    92|     {
    93|         info.compThisArg = BAD_VAR_NUM;
    94|     }
    95|     info.compILargsCount = info.compArgsCount;
    96| #ifdef FEATURE_SIMD
    97|     if (info.compRetNativeType == TYP_STRUCT)
    98|     {
    99|         var_types structType = impNormStructType(info.compMethodInfo->args.retTypeClass);
   100|         info.compRetType     = structType;
   101|     }
   102| #endif // FEATURE_SIMD
   103|     const bool hasRetBuffArg = impMethodInfo_hasRetBuffArg(info.compMethodInfo, info.compCallConv);
   104|     if (!hasRetBuffArg && varTypeIsStruct(info.compRetNativeType))
   105|     {
   106|         CORINFO_CLASS_HANDLE retClsHnd = info.compMethodInfo->args.retTypeClass;
   107|         Compiler::structPassingKind howToReturnStruct;
   108|         var_types returnType = getReturnTypeForStruct(retClsHnd, info.compCallConv, &howToReturnStruct);
   109|         if ((howToReturnStruct == SPK_PrimitiveType) || (howToReturnStruct == SPK_EnclosingType))
   110|         {
   111|             assert(returnType != TYP_UNKNOWN);
   112|             assert(returnType != TYP_STRUCT);
   113|             info.compRetNativeType = returnType;
   114|             if ((returnType == TYP_LONG) && (compLongUsed == false))
   115|             {
   116|                 compLongUsed = true;
   117|             }
   118|             else if (((returnType == TYP_FLOAT) || (returnType == TYP_DOUBLE)) && (compFloatingPointUsed == false))
   119|             {
   120|                 compFloatingPointUsed = true;
   121|             }
   122|         }
   123|     }
   124|     if (hasRetBuffArg)
   125|     {
   126|         info.compArgsCount++;
   127|     }
   128|     else
   129|     {
   130|         info.compRetBuffArg = BAD_VAR_NUM;
   131|     }
   132|     /* There is a 'hidden' cookie pushed last when the
   133|        calling convention is varargs */
   134|     if (info.compIsVarArgs)
   135|     {
   136|         info.compArgsCount++;
   137|     }
   138|     if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
   139|     {
   140|         info.compArgsCount++;
   141|     }
   142|     else
   143|     {
   144|         info.compTypeCtxtArg = BAD_VAR_NUM;
   145|     }
   146|     lvaCount = info.compLocalsCount = info.compArgsCount + info.compMethodInfo->locals.numArgs;
   147|     info.compILlocalsCount = info.compILargsCount + info.compMethodInfo->locals.numArgs;
   148|     /* Now allocate the variable descriptor table */
   149|     if (compIsForInlining())
   150|     {
   151|         lvaTable    = impInlineInfo->InlinerCompiler->lvaTable;
   152|         lvaCount    = impInlineInfo->InlinerCompiler->lvaCount;
   153|         lvaTableCnt = impInlineInfo->InlinerCompiler->lvaTableCnt;
   154|         return;
   155|     }
   156|     lvaTableCnt = lvaCount * 2;
   157|     if (lvaTableCnt < 16)
   158|     {
   159|         lvaTableCnt = 16;
   160|     }
   161|     lvaTable         = getAllocator(CMK_LvaTable).allocate<LclVarDsc>(lvaTableCnt);
   162|     size_t tableSize = lvaTableCnt * sizeof(*lvaTable);
   163|     memset(lvaTable, 0, tableSize);
   164|     for (unsigned i = 0; i < lvaTableCnt; i++)
   165|     {
   166|         new (&lvaTable[i], jitstd::placement_t()) LclVarDsc(); // call the constructor.
   167|     }
   168|     InitVarDscInfo varDscInfo;
   169| #ifdef TARGET_X86
   170|     switch (info.compCallConv)
   171|     {
   172|         case CorInfoCallConvExtension::Thiscall:
   173|             varDscInfo.Init(lvaTable, hasRetBuffArg, 1, 0);
   174|             break;
   175|         case CorInfoCallConvExtension::C:
   176|         case CorInfoCallConvExtension::Stdcall:
   177|         case CorInfoCallConvExtension::CMemberFunction:
   178|         case CorInfoCallConvExtension::StdcallMemberFunction:
   179|             varDscInfo.Init(lvaTable, hasRetBuffArg, 0, 0);
   180|             break;
   181|         case CorInfoCallConvExtension::Managed:
   182|         case CorInfoCallConvExtension::Fastcall:
   183|         case CorInfoCallConvExtension::FastcallMemberFunction:
   184|         default:
   185|             varDscInfo.Init(lvaTable, hasRetBuffArg, MAX_REG_ARG, MAX_FLOAT_REG_ARG);
   186|             break;
   187|     }
   188| #else
   189|     varDscInfo.Init(lvaTable, hasRetBuffArg, MAX_REG_ARG, MAX_FLOAT_REG_ARG);
   190| #endif
   191|     lvaInitArgs(&varDscInfo);
   192|     unsigned                varNum    = varDscInfo.varNum;
   193|     LclVarDsc*              varDsc    = varDscInfo.varDsc;
   194|     CORINFO_ARG_LIST_HANDLE localsSig = info.compMethodInfo->locals.args;
   195| #ifdef TARGET_ARM
   196|     compHasSplitParam = varDscInfo.hasSplitParam;
   197| #endif
   198|     for (unsigned i = 0; i < info.compMethodInfo->locals.numArgs;
   199|          i++, varNum++, varDsc++, localsSig = info.compCompHnd->getArgNext(localsSig))
   200|     {
   201|         CORINFO_CLASS_HANDLE typeHnd;
   202|         CorInfoTypeWithMod   corInfoTypeWithMod =
   203|             info.compCompHnd->getArgType(&info.compMethodInfo->locals, localsSig, &typeHnd);
   204|         CorInfoType corInfoType = strip(corInfoTypeWithMod);
   205|         lvaInitVarDsc(varDsc, varNum, corInfoType, typeHnd, localsSig, &info.compMethodInfo->locals);
   206|         if ((corInfoTypeWithMod & CORINFO_TYPE_MOD_PINNED) != 0)
   207|         {
   208|             if ((corInfoType == CORINFO_TYPE_CLASS) || (corInfoType == CORINFO_TYPE_BYREF))
   209|             {
   210|                 JITDUMP("Setting lvPinned for V%02u\n", varNum);
   211|                 varDsc->lvPinned = 1;
   212|                 if (opts.IsOSR())
   213|                 {
   214|                     varDsc->lvImplicitlyReferenced = 1;
   215|                 }
   216|             }
   217|             else
   218|             {
   219|                 JITDUMP("Ignoring pin for non-GC type V%02u\n", varNum);
   220|             }
   221|         }
   222|         varDsc->lvOnFrame = true; // The final home for this local variable might be our local stack frame
   223|         if (corInfoType == CORINFO_TYPE_CLASS)
   224|         {
   225|             CORINFO_CLASS_HANDLE clsHnd = info.compCompHnd->getArgClass(&info.compMethodInfo->locals, localsSig);
   226|             lvaSetClass(varNum, clsHnd);
   227|         }
   228|     }
   229|     if ( // If there already exist unsafe buffers, don't mark more structs as unsafe
   230|         !getNeedsGSSecurityCookie() &&
   231|         !opts.compDbgEnC && compStressCompile(STRESS_UNSAFE_BUFFER_CHECKS, 25))
   232|     {
   233|         setNeedsGSSecurityCookie();
   234|         compGSReorderStackLayout = true;
   235|         for (unsigned i = 0; i < lvaCount; i++)
   236|         {
   237|             if ((lvaTable[i].lvType == TYP_STRUCT) && compStressCompile(STRESS_GENERIC_VARN, 60))
   238|             {
   239|                 lvaTable[i].lvIsUnsafeBuffer = true;
   240|             }
   241|         }
   242|     }
   243|     if (opts.IsOSR())
   244|     {
   245|         for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
   246|         {
   247|             LclVarDsc* const varDsc = lvaGetDesc(lclNum);
   248|             varDsc->lvIsOSRLocal    = true;
   249|             if (info.compPatchpointInfo->IsExposed(lclNum))
   250|             {
   251|                 JITDUMP("-- V%02u is OSR exposed\n", lclNum);
   252|                 varDsc->lvHasLdAddrOp = 1;
   253|                 if (!varTypeIsStruct(varDsc) && !varTypeIsSIMD(varDsc))
   254|                 {
   255|                     lvaSetVarAddrExposed(lclNum DEBUGARG(AddressExposedReason::OSR_EXPOSED));
   256|                 }
   257|                 varDsc->lvImplicitlyReferenced = 1;
   258|             }
   259|         }
   260|     }
   261|     if (getNeedsGSSecurityCookie())
   262|     {
   263|         unsigned   dummy         = lvaGrabTempWithImplicitUse(false DEBUGARG("GSCookie dummy"));
   264|         LclVarDsc* gsCookieDummy = lvaGetDesc(dummy);
   265|         gsCookieDummy->lvType    = TYP_INT;
   266|         gsCookieDummy->lvIsTemp  = true; // It is not alive at all, set the flag to prevent zero-init.
   267|         lvaSetVarDoNotEnregister(dummy DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
   268|     }
   269|     lvaAllocOutgoingArgSpaceVar();
   270| #ifdef DEBUG
   271|     if (verbose)
   272|     {
   273|         lvaTableDump(INITIAL_FRAME_LAYOUT);
   274|     }
   275| #endif
   276| }
   277| /*****************************************************************************/
   278| void Compiler::lvaInitArgs(InitVarDscInfo* varDscInfo)
   279| {
   280|     compArgSize = 0;
   281| #if defined(TARGET_ARM) && defined(PROFILING_SUPPORTED)
   282|     if (compIsProfilerHookNeeded())
   283|     {
   284|         codeGen->regSet.rsMaskPreSpillRegArg |= RBM_ARG_REGS;
   285|     }
   286| #endif
   287|     /* Is there a "this" pointer ? */
   288|     lvaInitThisPtr(varDscInfo);
   289|     unsigned numUserArgsToSkip = 0;
   290|     unsigned numUserArgs       = info.compMethodInfo->args.numArgs;
   291| #if !defined(TARGET_ARM)
   292|     if (TargetOS::IsWindows && callConvIsInstanceMethodCallConv(info.compCallConv))
   293|     {
   294|         assert(numUserArgs >= 1);
   295|         lvaInitUserArgs(varDscInfo, 0, 1);
   296|         numUserArgsToSkip++;
   297|         numUserArgs--;
   298|         lvaInitRetBuffArg(varDscInfo, false);
   299|     }
   300|     else
   301| #endif
   302|     {
   303|         /* If we have a hidden return-buffer parameter, that comes here */
   304|         lvaInitRetBuffArg(varDscInfo, true);
   305|     }
   306| #if USER_ARGS_COME_LAST
   307|     lvaInitGenericsCtxt(varDscInfo);
   308|     /* If the method is varargs, process the varargs cookie */
   309|     lvaInitVarArgsHandle(varDscInfo);
   310| #endif
   311|     lvaInitUserArgs(varDscInfo, numUserArgsToSkip, numUserArgs);
   312| #if !USER_ARGS_COME_LAST
   313|     lvaInitGenericsCtxt(varDscInfo);
   314|     /* If the method is varargs, process the varargs cookie */
   315|     lvaInitVarArgsHandle(varDscInfo);
   316| #endif
   317|     noway_assert(varDscInfo->varNum == info.compArgsCount);
   318|     assert(varDscInfo->intRegArgNum <= MAX_REG_ARG);
   319|     codeGen->intRegState.rsCalleeRegArgCount   = varDscInfo->intRegArgNum;
   320|     codeGen->floatRegState.rsCalleeRegArgCount = varDscInfo->floatRegArgNum;
   321| #if FEATURE_FASTTAILCALL
   322|     info.compArgStackSize = varDscInfo->stackArgSize;
   323| #endif // FEATURE_FASTTAILCALL
   324|     noway_assert((compArgSize % TARGET_POINTER_SIZE) == 0);
   325| #ifdef TARGET_X86
   326|     /* We can not pass more than 2^16 dwords as arguments as the "ret"
   327|        instruction can only pop 2^16 arguments. Could be handled correctly
   328|        but it will be very difficult for fully interruptible code */
   329|     if (compArgSize != (size_t)(unsigned short)compArgSize)
   330|         IMPL_LIMITATION("Too many arguments for the \"ret\" instruction to pop");
   331| #endif
   332| }
   333| /*****************************************************************************/
   334| void Compiler::lvaInitThisPtr(InitVarDscInfo* varDscInfo)
   335| {
   336|     LclVarDsc* varDsc = varDscInfo->varDsc;
   337|     if (!info.compIsStatic)
   338|     {
   339|         varDsc->lvIsParam = 1;
   340|         varDsc->lvIsPtr   = 1;
   341|         lvaArg0Var = info.compThisArg = varDscInfo->varNum;
   342|         noway_assert(info.compThisArg == 0);
   343|         if (eeIsValueClass(info.compClassHnd))
   344|         {
   345|             varDsc->lvType = TYP_BYREF;
   346| #ifdef FEATURE_SIMD
   347|             CorInfoType simdBaseJitType = CORINFO_TYPE_UNDEF;
   348|             var_types   type            = impNormStructType(info.compClassHnd, &simdBaseJitType);
   349|             if (simdBaseJitType != CORINFO_TYPE_UNDEF)
   350|             {
   351|                 assert(varTypeIsSIMD(type));
   352|                 varDsc->lvSIMDType = true;
   353|                 varDsc->SetSimdBaseJitType(simdBaseJitType);
   354|                 varDsc->lvExactSize = genTypeSize(type);
   355|             }
   356| #endif // FEATURE_SIMD
   357|         }
   358|         else
   359|         {
   360|             varDsc->lvType = TYP_REF;
   361|             lvaSetClass(varDscInfo->varNum, info.compClassHnd);
   362|         }
   363|         varDsc->lvIsRegArg = 1;
   364|         noway_assert(varDscInfo->intRegArgNum == 0);
   365|         varDsc->SetArgReg(genMapRegArgNumToRegNum(varDscInfo->allocRegArg(TYP_INT), varDsc->TypeGet()));
   366| #if FEATURE_MULTIREG_ARGS
   367|         varDsc->SetOtherArgReg(REG_NA);
   368| #endif
   369|         varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
   370| #ifdef DEBUG
   371|         if (verbose)
   372|         {
   373|             printf("'this'    passed in register %s\n", getRegName(varDsc->GetArgReg()));
   374|         }
   375| #endif
   376|         compArgSize += TARGET_POINTER_SIZE;
   377|         varDscInfo->varNum++;
   378|         varDscInfo->varDsc++;
   379|     }
   380| }
   381| /*****************************************************************************/
   382| void Compiler::lvaInitRetBuffArg(InitVarDscInfo* varDscInfo, bool useFixedRetBufReg)
   383| {
   384|     LclVarDsc* varDsc        = varDscInfo->varDsc;
   385|     bool       hasRetBuffArg = impMethodInfo_hasRetBuffArg(info.compMethodInfo, info.compCallConv);
   386|     noway_assert(hasRetBuffArg == varDscInfo->hasRetBufArg);
   387|     if (hasRetBuffArg)
   388|     {
   389|         info.compRetBuffArg = varDscInfo->varNum;
   390|         varDsc->lvType      = TYP_BYREF;
   391|         varDsc->lvIsParam   = 1;
   392|         varDsc->lvIsRegArg  = 0;
   393|         if (useFixedRetBufReg && hasFixedRetBuffReg())
   394|         {
   395|             varDsc->lvIsRegArg = 1;
   396|             varDsc->SetArgReg(theFixedRetBuffReg());
   397|         }
   398|         else if (varDscInfo->canEnreg(TYP_INT))
   399|         {
   400|             varDsc->lvIsRegArg     = 1;
   401|             unsigned retBuffArgNum = varDscInfo->allocRegArg(TYP_INT);
   402|             varDsc->SetArgReg(genMapIntRegArgNumToRegNum(retBuffArgNum));
   403|         }
   404| #if FEATURE_MULTIREG_ARGS
   405|         varDsc->SetOtherArgReg(REG_NA);
   406| #endif
   407|         varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
   408| #ifdef FEATURE_SIMD
   409|         if (varTypeIsSIMD(info.compRetType))
   410|         {
   411|             varDsc->lvSIMDType = true;
   412|             CorInfoType simdBaseJitType =
   413|                 getBaseJitTypeAndSizeOfSIMDType(info.compMethodInfo->args.retTypeClass, &varDsc->lvExactSize);
   414|             varDsc->SetSimdBaseJitType(simdBaseJitType);
   415|             assert(varDsc->GetSimdBaseType() != TYP_UNKNOWN);
   416|         }
   417| #endif // FEATURE_SIMD
   418|         assert(!varDsc->lvIsRegArg || isValidIntArgReg(varDsc->GetArgReg()));
   419| #ifdef DEBUG
   420|         if (varDsc->lvIsRegArg && verbose)
   421|         {
   422|             printf("'__retBuf'  passed in register %s\n", getRegName(varDsc->GetArgReg()));
   423|         }
   424| #endif
   425|         /* Update the total argument size, count and varDsc */
   426|         compArgSize += TARGET_POINTER_SIZE;
   427|         varDscInfo->varNum++;
   428|         varDscInfo->varDsc++;
   429|     }
   430| }
   431| void Compiler::lvaInitUserArgs(InitVarDscInfo* varDscInfo, unsigned skipArgs, unsigned takeArgs)
   432| {
   433| #if defined(TARGET_X86)
   434|     if (info.compIsVarArgs)
   435|     {
   436|         varDscInfo->maxIntRegArgNum = varDscInfo->intRegArgNum;
   437|     }
   438| #elif defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI)
   439|     varDscInfo->floatRegArgNum = varDscInfo->intRegArgNum;
   440| #endif // TARGET*
   441|     CORINFO_ARG_LIST_HANDLE argLst = info.compMethodInfo->args.args;
   442|     const unsigned argSigLen = info.compMethodInfo->args.numArgs;
   443|     const int64_t numUserArgs = min(takeArgs, (argSigLen - (int64_t)skipArgs));
   444|     if (numUserArgs <= 0)
   445|     {
   446|         return;
   447|     }
   448| #ifdef TARGET_ARM
   449|     regMaskTP doubleAlignMask = RBM_NONE;
   450| #endif // TARGET_ARM
   451|     for (unsigned i = 0; i < skipArgs; i++, argLst = info.compCompHnd->getArgNext(argLst))
   452|     {
   453|         ;
   454|     }
   455|     for (unsigned i = 0; i < numUserArgs;
   456|          i++, varDscInfo->varNum++, varDscInfo->varDsc++, argLst = info.compCompHnd->getArgNext(argLst))
   457|     {
   458|         LclVarDsc*           varDsc  = varDscInfo->varDsc;
   459|         CORINFO_CLASS_HANDLE typeHnd = nullptr;
   460|         CorInfoTypeWithMod corInfoType = info.compCompHnd->getArgType(&info.compMethodInfo->args, argLst, &typeHnd);
   461|         varDsc->lvIsParam              = 1;
   462|         lvaInitVarDsc(varDsc, varDscInfo->varNum, strip(corInfoType), typeHnd, argLst, &info.compMethodInfo->args);
   463|         if (strip(corInfoType) == CORINFO_TYPE_CLASS)
   464|         {
   465|             CORINFO_CLASS_HANDLE clsHnd = info.compCompHnd->getArgClass(&info.compMethodInfo->args, argLst);
   466|             lvaSetClass(varDscInfo->varNum, clsHnd);
   467|         }
   468|         var_types argType = mangleVarArgsType(varDsc->TypeGet());
   469|         var_types origArgType = argType;
   470|         bool     isSoftFPPreSpill = opts.compUseSoftFP && varTypeIsFloating(varDsc->TypeGet());
   471|         unsigned argSize          = eeGetArgSize(argLst, &info.compMethodInfo->args);
   472|         unsigned cSlots =
   473|             (argSize + TARGET_POINTER_SIZE - 1) / TARGET_POINTER_SIZE; // the total number of slots of this argument
   474|         bool      isHfaArg = false;
   475|         var_types hfaType  = TYP_UNDEF;
   476|         if (((TargetOS::IsUnix && TargetArchitecture::IsArm64) || !info.compIsVarArgs) && !opts.compUseSoftFP)
   477|         {
   478|             if (varTypeIsStruct(argType))
   479|             {
   480|                 hfaType  = GetHfaType(typeHnd);
   481|                 isHfaArg = varTypeIsValidHfaType(hfaType);
   482|             }
   483|         }
   484|         else if (info.compIsVarArgs)
   485|         {
   486|             if (TargetOS::IsUnix)
   487|             {
   488|                 NYI("InitUserArgs for Vararg callee is not yet implemented on non Windows targets.");
   489|             }
   490|         }
   491|         if (isHfaArg)
   492|         {
   493|             argType = hfaType; // TODO-Cleanup: remove this assignment and mark `argType` as const.
   494|             varDsc->SetHfaType(hfaType);
   495|             cSlots = varDsc->lvHfaSlots();
   496|         }
   497|         unsigned cSlotsToEnregister = cSlots;
   498| #if defined(TARGET_ARM64)
   499|         if (compFeatureArgSplit())
   500|         {
   501|             if (this->info.compIsVarArgs && argType == TYP_STRUCT)
   502|             {
   503|                 if (varDscInfo->canEnreg(TYP_INT, 1) &&     // The beginning of the struct can go in a register
   504|                     !varDscInfo->canEnreg(TYP_INT, cSlots)) // The end of the struct can't fit in a register
   505|                 {
   506|                     cSlotsToEnregister = 1; // Force the split
   507|                 }
   508|             }
   509|         }
   510| #endif // defined(TARGET_ARM64)
   511| #ifdef TARGET_ARM
   512|         unsigned cAlign;
   513|         bool     preSpill = info.compIsVarArgs || isSoftFPPreSpill;
   514|         switch (origArgType)
   515|         {
   516|             case TYP_STRUCT:
   517|                 assert(varDsc->lvSize() == argSize);
   518|                 cAlign = varDsc->lvStructDoubleAlign ? 2 : 1;
   519|                 if (!isHfaArg)
   520|                 {
   521|                     cSlotsToEnregister = 1; // HFAs must be totally enregistered or not, but other structs can be split.
   522|                     preSpill           = true;
   523|                 }
   524|                 break;
   525|             case TYP_DOUBLE:
   526|             case TYP_LONG:
   527|                 cAlign = 2;
   528|                 break;
   529|             default:
   530|                 cAlign = 1;
   531|                 break;
   532|         }
   533|         if (isRegParamType(argType))
   534|         {
   535|             compArgSize += varDscInfo->alignReg(argType, cAlign) * REGSIZE_BYTES;
   536|         }
   537|         if (argType == TYP_STRUCT)
   538|         {
   539|             if (varDscInfo->canEnreg(TYP_INT, 1) &&       // The beginning of the struct can go in a register
   540|                 !varDscInfo->canEnreg(TYP_INT, cSlots) && // The end of the struct can't fit in a register
   541|                 varDscInfo->existAnyFloatStackArgs())     // There's at least one stack-based FP arg already
   542|             {
   543|                 varDscInfo->setAllRegArgUsed(TYP_INT); // Prevent all future use of integer registers
   544|                 preSpill = false;                      // This struct won't be prespilled, since it will go on the stack
   545|             }
   546|         }
   547|         if (preSpill)
   548|         {
   549|             for (unsigned ix = 0; ix < cSlots; ix++)
   550|             {
   551|                 if (!varDscInfo->canEnreg(TYP_INT, ix + 1))
   552|                 {
   553|                     break;
   554|                 }
   555|                 regMaskTP regMask = genMapArgNumToRegMask(varDscInfo->regArgNum(TYP_INT) + ix, TYP_INT);
   556|                 if (cAlign == 2)
   557|                 {
   558|                     doubleAlignMask |= regMask;
   559|                 }
   560|                 codeGen->regSet.rsMaskPreSpillRegArg |= regMask;
   561|             }
   562|         }
   563| #else // !TARGET_ARM
   564| #if defined(UNIX_AMD64_ABI)
   565|         SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR structDesc;
   566|         if (varTypeIsStruct(argType))
   567|         {
   568|             assert(typeHnd != nullptr);
   569|             eeGetSystemVAmd64PassStructInRegisterDescriptor(typeHnd, &structDesc);
   570|             if (structDesc.passedInRegisters)
   571|             {
   572|                 unsigned intRegCount   = 0;
   573|                 unsigned floatRegCount = 0;
   574|                 for (unsigned int i = 0; i < structDesc.eightByteCount; i++)
   575|                 {
   576|                     if (structDesc.IsIntegralSlot(i))
   577|                     {
   578|                         intRegCount++;
   579|                     }
   580|                     else if (structDesc.IsSseSlot(i))
   581|                     {
   582|                         floatRegCount++;
   583|                     }
   584|                     else
   585|                     {
   586|                         assert(false && "Invalid eightbyte classification type.");
   587|                         break;
   588|                     }
   589|                 }
   590|                 if (intRegCount != 0 && !varDscInfo->canEnreg(TYP_INT, intRegCount))
   591|                 {
   592|                     structDesc.passedInRegisters = false; // No register to enregister the eightbytes.
   593|                 }
   594|                 if (floatRegCount != 0 && !varDscInfo->canEnreg(TYP_FLOAT, floatRegCount))
   595|                 {
   596|                     structDesc.passedInRegisters = false; // No register to enregister the eightbytes.
   597|                 }
   598|             }
   599|         }
   600| #endif // UNIX_AMD64_ABI
   601| #endif // !TARGET_ARM
   602|         varDsc->lvOnFrame = true;
   603|         bool canPassArgInRegisters = false;
   604| #if defined(UNIX_AMD64_ABI)
   605|         if (varTypeIsStruct(argType))
   606|         {
   607|             canPassArgInRegisters = structDesc.passedInRegisters;
   608|         }
   609|         else
   610| #elif defined(TARGET_X86)
   611|         if (varTypeIsStruct(argType) && isTrivialPointerSizedStruct(typeHnd))
   612|         {
   613|             canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, cSlotsToEnregister);
   614|         }
   615|         else
   616| #elif defined(TARGET_LOONGARCH64)
   617|         uint32_t  floatFlags          = STRUCT_NO_FLOAT_FIELD;
   618|         var_types argRegTypeInStruct1 = TYP_UNKNOWN;
   619|         var_types argRegTypeInStruct2 = TYP_UNKNOWN;
   620|         if ((strip(corInfoType) == CORINFO_TYPE_VALUECLASS) && (argSize <= MAX_PASS_MULTIREG_BYTES))
   621|         {
   622|             floatFlags = info.compCompHnd->getLoongArch64PassStructInRegisterFlags(typeHnd);
   623|         }
   624|         if ((floatFlags & STRUCT_HAS_FLOAT_FIELDS_MASK) != 0)
   625|         {
   626|             assert(varTypeIsStruct(argType));
   627|             int floatNum = 0;
   628|             if ((floatFlags & STRUCT_FLOAT_FIELD_ONLY_ONE) != 0)
   629|             {
   630|                 assert(argSize <= 8);
   631|                 assert(varDsc->lvExactSize <= argSize);
   632|                 floatNum              = 1;
   633|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
   634|                 argRegTypeInStruct1 = (varDsc->lvExactSize == 8) ? TYP_DOUBLE : TYP_FLOAT;
   635|             }
   636|             else if ((floatFlags & STRUCT_FLOAT_FIELD_ONLY_TWO) != 0)
   637|             {
   638|                 floatNum              = 2;
   639|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 2);
   640|                 argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
   641|                 argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
   642|             }
   643|             else if ((floatFlags & STRUCT_FLOAT_FIELD_FIRST) != 0)
   644|             {
   645|                 floatNum              = 1;
   646|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
   647|                 canPassArgInRegisters = canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1);
   648|                 argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
   649|                 argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_LONG : TYP_INT;
   650|             }
   651|             else if ((floatFlags & STRUCT_FLOAT_FIELD_SECOND) != 0)
   652|             {
   653|                 floatNum              = 1;
   654|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_DOUBLE, 1);
   655|                 canPassArgInRegisters = canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1);
   656|                 argRegTypeInStruct1 = (floatFlags & STRUCT_FIRST_FIELD_SIZE_IS8) ? TYP_LONG : TYP_INT;
   657|                 argRegTypeInStruct2 = (floatFlags & STRUCT_SECOND_FIELD_SIZE_IS8) ? TYP_DOUBLE : TYP_FLOAT;
   658|             }
   659|             assert((floatNum == 1) || (floatNum == 2));
   660|             if (!canPassArgInRegisters)
   661|             {
   662|                 canPassArgInRegisters = varDscInfo->canEnreg(argType, cSlotsToEnregister);
   663|                 argRegTypeInStruct1 = TYP_UNKNOWN;
   664|                 argRegTypeInStruct2 = TYP_UNKNOWN;
   665|                 if (cSlotsToEnregister == 2)
   666|                 {
   667|                     if (!canPassArgInRegisters && varDscInfo->canEnreg(TYP_I_IMPL, 1))
   668|                     {
   669|                         argRegTypeInStruct1   = TYP_I_IMPL;
   670|                         canPassArgInRegisters = true;
   671|                     }
   672|                 }
   673|             }
   674|         }
   675|         else
   676| #endif // defined(TARGET_LOONGARCH64)
   677|         {
   678|             canPassArgInRegisters = varDscInfo->canEnreg(argType, cSlotsToEnregister);
   679| #if defined(TARGET_LOONGARCH64)
   680|             if (!canPassArgInRegisters && varTypeIsFloating(argType))
   681|             {
   682|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, cSlotsToEnregister);
   683|                 argType               = canPassArgInRegisters ? TYP_I_IMPL : argType;
   684|             }
   685|             if (!canPassArgInRegisters && (cSlots > 1))
   686|             {
   687|                 canPassArgInRegisters = varDscInfo->canEnreg(TYP_I_IMPL, 1);
   688|                 argRegTypeInStruct1   = canPassArgInRegisters ? TYP_I_IMPL : TYP_UNKNOWN;
   689|             }
   690| #endif
   691|         }
   692|         if (canPassArgInRegisters)
   693|         {
   694|             /* Another register argument */
   695|             unsigned firstAllocatedRegArgNum = 0;
   696| #if FEATURE_MULTIREG_ARGS
   697|             varDsc->SetOtherArgReg(REG_NA);
   698| #endif // FEATURE_MULTIREG_ARGS
   699| #if defined(UNIX_AMD64_ABI)
   700|             unsigned  secondAllocatedRegArgNum = 0;
   701|             var_types firstEightByteType       = TYP_UNDEF;
   702|             var_types secondEightByteType      = TYP_UNDEF;
   703|             if (varTypeIsStruct(argType))
   704|             {
   705|                 if (structDesc.eightByteCount >= 1)
   706|                 {
   707|                     firstEightByteType      = GetEightByteType(structDesc, 0);
   708|                     firstAllocatedRegArgNum = varDscInfo->allocRegArg(firstEightByteType, 1);
   709|                 }
   710|             }
   711|             else
   712| #elif defined(TARGET_LOONGARCH64)
   713|             if (argRegTypeInStruct1 != TYP_UNKNOWN)
   714|             {
   715|                 firstAllocatedRegArgNum = varDscInfo->allocRegArg(argRegTypeInStruct1, 1);
   716|             }
   717|             else
   718| #endif // defined(TARGET_LOONGARCH64)
   719|             {
   720|                 firstAllocatedRegArgNum = varDscInfo->allocRegArg(argType, cSlots);
   721|             }
   722|             if (isHfaArg)
   723|             {
   724|                 if (varDsc->lvHfaSlots() != 1)
   725|                 {
   726|                     varDsc->lvIsMultiRegArg = true;
   727|                 }
   728|             }
   729|             varDsc->lvIsRegArg = 1;
   730| #if FEATURE_MULTIREG_ARGS
   731| #ifdef TARGET_ARM64
   732|             if (argType == TYP_STRUCT)
   733|             {
   734|                 varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
   735|                 if (cSlots == 2)
   736|                 {
   737|                     varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_I_IMPL));
   738|                     varDsc->lvIsMultiRegArg = true;
   739|                 }
   740|             }
   741| #elif defined(UNIX_AMD64_ABI)
   742|             if (varTypeIsStruct(argType))
   743|             {
   744|                 varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, firstEightByteType));
   745|                 if (structDesc.eightByteCount >= 2)
   746|                 {
   747|                     secondEightByteType      = GetEightByteType(structDesc, 1);
   748|                     secondAllocatedRegArgNum = varDscInfo->allocRegArg(secondEightByteType, 1);
   749|                     varDsc->lvIsMultiRegArg  = true;
   750|                 }
   751|                 if (secondEightByteType != TYP_UNDEF)
   752|                 {
   753|                     varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, secondEightByteType));
   754|                 }
   755|             }
   756| #elif defined(TARGET_LOONGARCH64)
   757|             if (argType == TYP_STRUCT)
   758|             {
   759|                 if (argRegTypeInStruct1 != TYP_UNKNOWN)
   760|                 {
   761|                     varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, argRegTypeInStruct1));
   762|                     varDsc->lvIs4Field1 = (genTypeSize(argRegTypeInStruct1) == 4) ? 1 : 0;
   763|                     if (argRegTypeInStruct2 != TYP_UNKNOWN)
   764|                     {
   765|                         unsigned secondAllocatedRegArgNum = varDscInfo->allocRegArg(argRegTypeInStruct2, 1);
   766|                         varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, argRegTypeInStruct2));
   767|                         varDsc->lvIs4Field2 = (genTypeSize(argRegTypeInStruct2) == 4) ? 1 : 0;
   768|                     }
   769|                     else if (cSlots > 1)
   770|                     {
   771|                         varDsc->lvIsSplit = 1;
   772|                         varDsc->SetOtherArgReg(REG_STK);
   773|                         varDscInfo->setAllRegArgUsed(argRegTypeInStruct1);
   774| #if FEATURE_FASTTAILCALL
   775|                         varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
   776| #endif
   777|                     }
   778|                 }
   779|                 else
   780|                 {
   781|                     varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
   782|                     if (cSlots == 2)
   783|                     {
   784|                         varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_I_IMPL));
   785|                     }
   786|                 }
   787|             }
   788| #else  // ARM32
   789|             if (varTypeIsStruct(argType))
   790|             {
   791|                 varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, TYP_I_IMPL));
   792|             }
   793| #endif // ARM32
   794|             else
   795| #endif // FEATURE_MULTIREG_ARGS
   796|             {
   797|                 varDsc->SetArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, argType));
   798|             }
   799| #ifdef TARGET_ARM
   800|             if (varDsc->TypeGet() == TYP_LONG)
   801|             {
   802|                 varDsc->SetOtherArgReg(genMapRegArgNumToRegNum(firstAllocatedRegArgNum + 1, TYP_INT));
   803|             }
   804| #if FEATURE_FASTTAILCALL
   805|             if (!varTypeUsesFloatReg(argType))
   806|             {
   807|                 unsigned firstRegArgNum = genMapIntRegNumToRegArgNum(varDsc->GetArgReg());
   808|                 unsigned lastRegArgNum  = firstRegArgNum + cSlots - 1;
   809|                 if (lastRegArgNum >= varDscInfo->maxIntRegArgNum)
   810|                 {
   811|                     assert(varDscInfo->stackArgSize == 0);
   812|                     unsigned numEnregistered = varDscInfo->maxIntRegArgNum - firstRegArgNum;
   813|                     varDsc->SetStackOffset(-(int)numEnregistered * REGSIZE_BYTES);
   814|                     varDscInfo->stackArgSize += (cSlots - numEnregistered) * REGSIZE_BYTES;
   815|                     varDscInfo->hasSplitParam = true;
   816|                     JITDUMP("set user arg V%02u offset to %d\n", varDscInfo->varNum, varDsc->GetStackOffset());
   817|                 }
   818|             }
   819| #endif
   820| #endif // TARGET_ARM
   821| #ifdef DEBUG
   822|             if (verbose)
   823|             {
   824|                 printf("Arg #%u    passed in register(s) ", varDscInfo->varNum);
   825| #if defined(UNIX_AMD64_ABI)
   826|                 if (varTypeIsStruct(argType))
   827|                 {
   828|                     if (firstEightByteType == TYP_UNDEF)
   829|                     {
   830|                         printf("firstEightByte: <not used>");
   831|                     }
   832|                     else
   833|                     {
   834|                         printf("firstEightByte: %s",
   835|                                getRegName(genMapRegArgNumToRegNum(firstAllocatedRegArgNum, firstEightByteType)));
   836|                     }
   837|                     if (secondEightByteType == TYP_UNDEF)
   838|                     {
   839|                         printf(", secondEightByte: <not used>");
   840|                     }
   841|                     else
   842|                     {
   843|                         printf(", secondEightByte: %s",
   844|                                getRegName(genMapRegArgNumToRegNum(secondAllocatedRegArgNum, secondEightByteType)));
   845|                     }
   846|                 }
   847|                 else
   848| #endif // defined(UNIX_AMD64_ABI)
   849|                 {
   850|                     bool     isFloat   = varTypeUsesFloatReg(argType);
   851|                     unsigned regArgNum = genMapRegNumToRegArgNum(varDsc->GetArgReg(), argType);
   852|                     for (unsigned ix = 0; ix < cSlots; ix++, regArgNum++)
   853|                     {
   854|                         if (ix > 0)
   855|                         {
   856|                             printf(",");
   857|                         }
   858|                         if (!isFloat && (regArgNum >= varDscInfo->maxIntRegArgNum)) // a struct has been split between
   859|                         {
   860|                             printf(" stack slots:%d", cSlots - ix);
   861|                             break;
   862|                         }
   863| #ifdef TARGET_ARM
   864|                         if (isFloat)
   865|                         {
   866|                             if (argType == TYP_DOUBLE)
   867|                             {
   868|                                 printf("%s/%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)),
   869|                                        getRegName(genMapRegArgNumToRegNum(regArgNum + 1, argType)));
   870|                                 assert(ix + 1 < cSlots);
   871|                                 ++ix;
   872|                                 ++regArgNum;
   873|                             }
   874|                             else
   875|                             {
   876|                                 printf("%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)));
   877|                             }
   878|                         }
   879|                         else
   880| #endif // TARGET_ARM
   881|                         {
   882|                             printf("%s", getRegName(genMapRegArgNumToRegNum(regArgNum, argType)));
   883|                         }
   884|                     }
   885|                 }
   886|                 printf("\n");
   887|             }
   888| #endif    // DEBUG
   889|         } // end if (canPassArgInRegisters)
   890|         else
   891|         {
   892| #if defined(TARGET_ARM)
   893|             varDscInfo->setAllRegArgUsed(argType);
   894|             if (varTypeUsesFloatReg(argType))
   895|             {
   896|                 varDscInfo->setAnyFloatStackArgs();
   897|             }
   898| #elif defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
   899|             varDscInfo->setAllRegArgUsed(argType);
   900| #endif // TARGET_XXX
   901| #if FEATURE_FASTTAILCALL
   902| #ifdef TARGET_ARM
   903|             unsigned argAlignment = cAlign * TARGET_POINTER_SIZE;
   904| #else
   905|             unsigned argAlignment = eeGetArgSizeAlignment(origArgType, (hfaType == TYP_FLOAT));
   906|             assert(compMacOsArm64Abi() || ((varDscInfo->stackArgSize % argAlignment) == 0));
   907| #endif
   908|             varDscInfo->stackArgSize = roundUp(varDscInfo->stackArgSize, argAlignment);
   909|             JITDUMP("set user arg V%02u offset to %u\n", varDscInfo->varNum, varDscInfo->stackArgSize);
   910|             varDsc->SetStackOffset(varDscInfo->stackArgSize);
   911|             varDscInfo->stackArgSize += argSize;
   912| #endif // FEATURE_FASTTAILCALL
   913|         }
   914| #ifdef UNIX_AMD64_ABI
   915|         compArgSize += roundUp(argSize, TARGET_POINTER_SIZE);
   916| #else  // !UNIX_AMD64_ABI
   917|         compArgSize += argSize;
   918| #endif // !UNIX_AMD64_ABI
   919|         if (info.compIsVarArgs || isSoftFPPreSpill)
   920|         {
   921| #if defined(TARGET_X86)
   922|             varDsc->SetStackOffset(compArgSize);
   923| #else  // !TARGET_X86
   924|             lvaSetVarAddrExposed(varDscInfo->varNum DEBUGARG(AddressExposedReason::TOO_CONSERVATIVE));
   925| #endif // !TARGET_X86
   926|         }
   927|     }
   928|     compArgSize = GetOutgoingArgByteSize(compArgSize);
   929| #ifdef TARGET_ARM
   930|     if (doubleAlignMask != RBM_NONE)
   931|     {
   932|         assert(RBM_ARG_REGS == 0xF);
   933|         assert((doubleAlignMask & RBM_ARG_REGS) == doubleAlignMask);
   934|         if (doubleAlignMask != RBM_NONE && doubleAlignMask != RBM_ARG_REGS)
   935|         {
   936|             assert((doubleAlignMask == 0b0011) || (doubleAlignMask == 0b1100) ||
   937|                    (doubleAlignMask == 0b0111) /* || 0b1111 is if'ed out */);
   938|             bool startsAtR0 = (doubleAlignMask & 1) == 1;
   939|             bool r2XorR3    = ((codeGen->regSet.rsMaskPreSpillRegArg & RBM_R2) == 0) !=
   940|                            ((codeGen->regSet.rsMaskPreSpillRegArg & RBM_R3) == 0);
   941|             if (startsAtR0 && r2XorR3)
   942|             {
   943|                 codeGen->regSet.rsMaskPreSpillAlign =
   944|                     (~codeGen->regSet.rsMaskPreSpillRegArg & ~doubleAlignMask) & RBM_ARG_REGS;
   945|             }
   946|         }
   947|     }
   948| #endif // TARGET_ARM
   949| }
   950| /*****************************************************************************/
   951| void Compiler::lvaInitGenericsCtxt(InitVarDscInfo* varDscInfo)
   952| {
   953|     if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
   954|     {
   955|         info.compTypeCtxtArg = varDscInfo->varNum;
   956|         LclVarDsc* varDsc = varDscInfo->varDsc;
   957|         varDsc->lvIsParam = 1;
   958|         varDsc->lvType    = TYP_I_IMPL;
   959|         if (varDscInfo->canEnreg(TYP_I_IMPL))
   960|         {
   961|             /* Another register argument */
   962|             varDsc->lvIsRegArg = 1;
   963|             varDsc->SetArgReg(genMapRegArgNumToRegNum(varDscInfo->regArgNum(TYP_INT), varDsc->TypeGet()));
   964| #if FEATURE_MULTIREG_ARGS
   965|             varDsc->SetOtherArgReg(REG_NA);
   966| #endif
   967|             varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
   968|             varDscInfo->intRegArgNum++;
   969| #ifdef DEBUG
   970|             if (verbose)
   971|             {
   972|                 printf("'GenCtxt'   passed in register %s\n", getRegName(varDsc->GetArgReg()));
   973|             }
   974| #endif
   975|         }
   976|         else
   977|         {
   978|             varDsc->lvOnFrame = true;
   979| #if FEATURE_FASTTAILCALL
   980|             varDsc->SetStackOffset(varDscInfo->stackArgSize);
   981|             varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
   982| #endif // FEATURE_FASTTAILCALL
   983|         }
   984|         compArgSize += TARGET_POINTER_SIZE;
   985| #if defined(TARGET_X86)
   986|         if (info.compIsVarArgs)
   987|             varDsc->SetStackOffset(compArgSize);
   988| #endif // TARGET_X86
   989|         varDscInfo->varNum++;
   990|         varDscInfo->varDsc++;
   991|     }
   992| }
   993| /*****************************************************************************/
   994| void Compiler::lvaInitVarArgsHandle(InitVarDscInfo* varDscInfo)
   995| {
   996|     if (info.compIsVarArgs)
   997|     {
   998|         lvaVarargsHandleArg = varDscInfo->varNum;
   999|         LclVarDsc* varDsc = varDscInfo->varDsc;
  1000|         varDsc->lvType    = TYP_I_IMPL;
  1001|         varDsc->lvIsParam = 1;
  1002| #if defined(TARGET_X86)
  1003|         varDsc->lvImplicitlyReferenced = 1;
  1004| #endif // TARGET_X86
  1005|         lvaSetVarDoNotEnregister(lvaVarargsHandleArg DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
  1006|         assert(mostRecentlyActivePhase == PHASE_PRE_IMPORT);
  1007|         if (varDscInfo->canEnreg(TYP_I_IMPL))
  1008|         {
  1009|             /* Another register argument */
  1010|             unsigned varArgHndArgNum = varDscInfo->allocRegArg(TYP_I_IMPL);
  1011|             varDsc->lvIsRegArg = 1;
  1012|             varDsc->SetArgReg(genMapRegArgNumToRegNum(varArgHndArgNum, TYP_I_IMPL));
  1013| #if FEATURE_MULTIREG_ARGS
  1014|             varDsc->SetOtherArgReg(REG_NA);
  1015| #endif
  1016|             varDsc->lvOnFrame = true; // The final home for this incoming register might be our local stack frame
  1017| #ifdef TARGET_ARM
  1018|             for (unsigned ix = varArgHndArgNum; ix < ArrLen(intArgMasks); ix++)
  1019|             {
  1020|                 codeGen->regSet.rsMaskPreSpillRegArg |= intArgMasks[ix];
  1021|             }
  1022| #endif // TARGET_ARM
  1023| #ifdef DEBUG
  1024|             if (verbose)
  1025|             {
  1026|                 printf("'VarArgHnd' passed in register %s\n", getRegName(varDsc->GetArgReg()));
  1027|             }
  1028| #endif // DEBUG
  1029|         }
  1030|         else
  1031|         {
  1032|             varDsc->lvOnFrame = true;
  1033| #if FEATURE_FASTTAILCALL
  1034|             varDsc->SetStackOffset(varDscInfo->stackArgSize);
  1035|             varDscInfo->stackArgSize += TARGET_POINTER_SIZE;
  1036| #endif // FEATURE_FASTTAILCALL
  1037|         }
  1038|         /* Update the total argument size, count and varDsc */
  1039|         compArgSize += TARGET_POINTER_SIZE;
  1040|         varDscInfo->varNum++;
  1041|         varDscInfo->varDsc++;
  1042| #if defined(TARGET_X86)
  1043|         varDsc->SetStackOffset(compArgSize);
  1044|         lvaVarargsBaseOfStkArgs                  = lvaGrabTemp(false DEBUGARG("Varargs BaseOfStkArgs"));
  1045|         lvaTable[lvaVarargsBaseOfStkArgs].lvType = TYP_I_IMPL;
  1046| #endif // TARGET_X86
  1047|     }
  1048| }
  1049| /*****************************************************************************/
  1050| void Compiler::lvaInitVarDsc(LclVarDsc*              varDsc,
  1051|                              unsigned                varNum,
  1052|                              CorInfoType             corInfoType,
  1053|                              CORINFO_CLASS_HANDLE    typeHnd,
  1054|                              CORINFO_ARG_LIST_HANDLE varList,
  1055|                              CORINFO_SIG_INFO*       varSig)
  1056| {
  1057|     noway_assert(varDsc == lvaGetDesc(varNum));
  1058|     switch (corInfoType)
  1059|     {
  1060|         case CORINFO_TYPE_PTR:
  1061|         case CORINFO_TYPE_BYREF:
  1062|         case CORINFO_TYPE_CLASS:
  1063|         case CORINFO_TYPE_STRING:
  1064|         case CORINFO_TYPE_VAR:
  1065|         case CORINFO_TYPE_REFANY:
  1066|             varDsc->lvIsPtr = 1;
  1067|             break;
  1068|         default:
  1069|             break;
  1070|     }
  1071|     var_types type = JITtype2varType(corInfoType);
  1072|     if (varTypeIsFloating(type))
  1073|     {
  1074|         compFloatingPointUsed = true;
  1075|     }
  1076|     if (typeHnd != NO_CLASS_HANDLE)
  1077|     {
  1078|         varDsc->lvOverlappingFields = StructHasOverlappingFields(info.compCompHnd->getClassAttribs(typeHnd));
  1079|     }
  1080| #if FEATURE_IMPLICIT_BYREFS
  1081|     varDsc->lvIsImplicitByRef = 0;
  1082| #endif // FEATURE_IMPLICIT_BYREFS
  1083| #ifdef TARGET_LOONGARCH64
  1084|     varDsc->lvIs4Field1 = 0;
  1085|     varDsc->lvIs4Field2 = 0;
  1086|     varDsc->lvIsSplit   = 0;
  1087| #endif // TARGET_LOONGARCH64
  1088|     if (GlobalJitOptions::compFeatureHfa)
  1089|     {
  1090|         varDsc->SetHfaType(TYP_UNDEF);
  1091|     }
  1092|     if ((varTypeIsStruct(type)))
  1093|     {
  1094|         lvaSetStruct(varNum, typeHnd, typeHnd != NO_CLASS_HANDLE);
  1095|         if (info.compIsVarArgs)
  1096|         {
  1097|             lvaSetStructUsedAsVarArg(varNum);
  1098|         }
  1099|     }
  1100|     else
  1101|     {
  1102|         varDsc->lvType = type;
  1103|     }
  1104|     if (type == TYP_BOOL)
  1105|     {
  1106|         varDsc->lvIsBoolean = true;
  1107|     }
  1108| #ifdef DEBUG
  1109|     varDsc->SetStackOffset(BAD_STK_OFFS);
  1110| #endif
  1111| #if FEATURE_MULTIREG_ARGS
  1112|     varDsc->SetOtherArgReg(REG_NA);
  1113| #endif // FEATURE_MULTIREG_ARGS
  1114| }
  1115| /*****************************************************************************
  1116|  * Returns our internal varNum for a given IL variable.
  1117|  * Asserts assume it is called after lvaTable[] has been set up.
  1118|  */
  1119| unsigned Compiler::compMapILvarNum(unsigned ILvarNum)
  1120| {
  1121|     noway_assert(ILvarNum < info.compILlocalsCount || ILvarNum > unsigned(ICorDebugInfo::UNKNOWN_ILNUM));
  1122|     unsigned varNum;
  1123|     if (ILvarNum == (unsigned)ICorDebugInfo::VARARGS_HND_ILNUM)
  1124|     {
  1125|         noway_assert(info.compIsVarArgs);
  1126|         varNum = lvaVarargsHandleArg;
  1127|         noway_assert(lvaTable[varNum].lvIsParam);
  1128|     }
  1129|     else if (ILvarNum == (unsigned)ICorDebugInfo::RETBUF_ILNUM)
  1130|     {
  1131|         noway_assert(info.compRetBuffArg != BAD_VAR_NUM);
  1132|         varNum = info.compRetBuffArg;
  1133|     }
  1134|     else if (ILvarNum == (unsigned)ICorDebugInfo::TYPECTXT_ILNUM)
  1135|     {
  1136|         noway_assert(info.compTypeCtxtArg >= 0);
  1137|         varNum = unsigned(info.compTypeCtxtArg);
  1138|     }
  1139|     else if (ILvarNum < info.compILargsCount)
  1140|     {
  1141|         varNum = compMapILargNum(ILvarNum);
  1142|         noway_assert(lvaTable[varNum].lvIsParam);
  1143|     }
  1144|     else if (ILvarNum < info.compILlocalsCount)
  1145|     {
  1146|         unsigned lclNum = ILvarNum - info.compILargsCount;
  1147|         varNum          = info.compArgsCount + lclNum;
  1148|         noway_assert(!lvaTable[varNum].lvIsParam);
  1149|     }
  1150|     else
  1151|     {
  1152|         unreached();
  1153|     }
  1154|     noway_assert(varNum < info.compLocalsCount);
  1155|     return varNum;
  1156| }
  1157| /*****************************************************************************
  1158|  * Returns the IL variable number given our internal varNum.
  1159|  * Special return values are VARG_ILNUM, RETBUF_ILNUM, TYPECTXT_ILNUM.
  1160|  *
  1161|  * Returns UNKNOWN_ILNUM if it can't be mapped.
  1162|  */
  1163| unsigned Compiler::compMap2ILvarNum(unsigned varNum) const
  1164| {
  1165|     if (compIsForInlining())
  1166|     {
  1167|         return impInlineInfo->InlinerCompiler->compMap2ILvarNum(varNum);
  1168|     }
  1169|     noway_assert(varNum < lvaCount);
  1170|     if (varNum == info.compRetBuffArg)
  1171|     {
  1172|         return (unsigned)ICorDebugInfo::RETBUF_ILNUM;
  1173|     }
  1174|     if (info.compIsVarArgs && varNum == lvaVarargsHandleArg)
  1175|     {
  1176|         return (unsigned)ICorDebugInfo::VARARGS_HND_ILNUM;
  1177|     }
  1178|     if ((info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE) && varNum == (unsigned)info.compTypeCtxtArg)
  1179|     {
  1180|         return (unsigned)ICorDebugInfo::TYPECTXT_ILNUM;
  1181|     }
  1182| #if FEATURE_FIXED_OUT_ARGS
  1183|     if (varNum == lvaOutgoingArgSpaceVar)
  1184|     {
  1185|         return (unsigned)ICorDebugInfo::UNKNOWN_ILNUM; // Cannot be mapped
  1186|     }
  1187| #endif // FEATURE_FIXED_OUT_ARGS
  1188|     if ((info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE) && varNum > (unsigned)info.compTypeCtxtArg)
  1189|     {
  1190|         varNum--;
  1191|     }
  1192|     if (info.compIsVarArgs && varNum > lvaVarargsHandleArg)
  1193|     {
  1194|         varNum--;
  1195|     }
  1196|     /* Is there a hidden argument for the return buffer.
  1197|        Note that this code works because if the RetBuffArg is not present,
  1198|        compRetBuffArg will be BAD_VAR_NUM */
  1199|     if (info.compRetBuffArg != BAD_VAR_NUM && varNum > info.compRetBuffArg)
  1200|     {
  1201|         varNum--;
  1202|     }
  1203|     if (varNum >= info.compLocalsCount)
  1204|     {
  1205|         return (unsigned)ICorDebugInfo::UNKNOWN_ILNUM; // Cannot be mapped
  1206|     }
  1207|     return varNum;
  1208| }
  1209| /*****************************************************************************
  1210|  * Returns true if variable "varNum" may be address-exposed.
  1211|  */
  1212| bool Compiler::lvaVarAddrExposed(unsigned varNum) const
  1213| {
  1214|     const LclVarDsc* varDsc = lvaGetDesc(varNum);
  1215|     return varDsc->IsAddressExposed();
  1216| }
  1217| /*****************************************************************************
  1218|  * Returns true iff variable "varNum" should not be enregistered (or one of several reasons).
  1219|  */
  1220| bool Compiler::lvaVarDoNotEnregister(unsigned varNum)
  1221| {
  1222|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  1223|     return varDsc->lvDoNotEnregister;
  1224| }
  1225| void Compiler::lvSetMinOptsDoNotEnreg()
  1226| {
  1227|     JITDUMP("compEnregLocals() is false, setting doNotEnreg flag for all locals.");
  1228|     assert(!compEnregLocals());
  1229|     for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
  1230|     {
  1231|         lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NoRegVars));
  1232|     }
  1233| }
  1234| /*****************************************************************************
  1235|  * Returns the handle to the class of the local variable varNum
  1236|  */
  1237| CORINFO_CLASS_HANDLE Compiler::lvaGetStruct(unsigned varNum)
  1238| {
  1239|     const LclVarDsc* varDsc = lvaGetDesc(varNum);
  1240|     return varDsc->GetStructHnd();
  1241| }
  1242| bool Compiler::lvaFieldOffsetCmp::operator()(const lvaStructFieldInfo& field1, const lvaStructFieldInfo& field2)
  1243| {
  1244|     return field1.fldOffset < field2.fldOffset;
  1245| }
  1246| Compiler::StructPromotionHelper::StructPromotionHelper(Compiler* compiler)
  1247|     : compiler(compiler)
  1248|     , structPromotionInfo()
  1249| #ifdef DEBUG
  1250|     , retypedFieldsMap(compiler->getAllocator(CMK_DebugOnly))
  1251| #endif // DEBUG
  1252| {
  1253| }
  1254| bool Compiler::StructPromotionHelper::TryPromoteStructVar(unsigned lclNum)
  1255| {
  1256|     if (CanPromoteStructVar(lclNum))
  1257|     {
  1258| #if 0
  1259|             static int structPromoVarNum = 0;
  1260|             structPromoVarNum++;
  1261|             if (atoi(getenv("structpromovarnumlo")) <= structPromoVarNum && structPromoVarNum <= atoi(getenv("structpromovarnumhi")))
  1262| #endif // 0
  1263|         if (ShouldPromoteStructVar(lclNum))
  1264|         {
  1265|             PromoteStructVar(lclNum);
  1266|             return true;
  1267|         }
  1268|     }
  1269|     return false;
  1270| }
  1271| #ifdef DEBUG
  1272| void Compiler::StructPromotionHelper::CheckRetypedAsScalar(CORINFO_FIELD_HANDLE fieldHnd, var_types requestedType)
  1273| {
  1274|     assert(retypedFieldsMap.Lookup(fieldHnd));
  1275|     assert(retypedFieldsMap[fieldHnd] == requestedType);
  1276| }
  1277| #endif // DEBUG
  1278| bool Compiler::StructPromotionHelper::CanPromoteStructType(CORINFO_CLASS_HANDLE typeHnd)
  1279| {
  1280|     assert(typeHnd != nullptr);
  1281|     if (!compiler->eeIsValueClass(typeHnd))
  1282|     {
  1283|         return false;
  1284|     }
  1285|     if (structPromotionInfo.typeHnd == typeHnd)
  1286|     {
  1287|         return structPromotionInfo.canPromote;
  1288|     }
  1289|     structPromotionInfo = lvaStructPromotionInfo(typeHnd);
  1290|     CLANG_FORMAT_COMMENT_ANCHOR;
  1291| #if defined(FEATURE_SIMD)
  1292| #if defined(TARGET_XARCH)
  1293|     const int MaxOffset = MAX_NumOfFieldsInPromotableStruct * YMM_REGSIZE_BYTES;
  1294| #elif defined(TARGET_ARM64)
  1295|     const int MaxOffset      = MAX_NumOfFieldsInPromotableStruct * FP_REGSIZE_BYTES;
  1296| #endif // defined(TARGET_XARCH) || defined(TARGET_ARM64)
  1297| #else  // !FEATURE_SIMD
  1298|     const int MaxOffset = MAX_NumOfFieldsInPromotableStruct * sizeof(double);
  1299| #endif // !FEATURE_SIMD
  1300|     assert((BYTE)MaxOffset == MaxOffset); // because lvaStructFieldInfo.fldOffset is byte-sized
  1301|     assert((BYTE)MAX_NumOfFieldsInPromotableStruct ==
  1302|            MAX_NumOfFieldsInPromotableStruct); // because lvaStructFieldInfo.fieldCnt is byte-sized
  1303|     bool containsGCpointers = false;
  1304|     COMP_HANDLE compHandle = compiler->info.compCompHnd;
  1305|     unsigned structSize = compHandle->getClassSize(typeHnd);
  1306|     if (structSize > MaxOffset)
  1307|     {
  1308|         return false; // struct is too large
  1309|     }
  1310|     unsigned fieldCnt = compHandle->getClassNumInstanceFields(typeHnd);
  1311|     if (fieldCnt == 0 || fieldCnt > MAX_NumOfFieldsInPromotableStruct)
  1312|     {
  1313|         return false; // struct must have between 1 and MAX_NumOfFieldsInPromotableStruct fields
  1314|     }
  1315|     structPromotionInfo.fieldCnt = (unsigned char)fieldCnt;
  1316|     DWORD typeFlags              = compHandle->getClassAttribs(typeHnd);
  1317|     bool overlappingFields = StructHasOverlappingFields(typeFlags);
  1318|     if (overlappingFields)
  1319|     {
  1320|         return false;
  1321|     }
  1322|     if (StructHasCustomLayout(typeFlags) && compiler->IsHfa(typeHnd))
  1323|     {
  1324|         return false;
  1325|     }
  1326| #ifdef TARGET_ARM
  1327|     unsigned structAlignment = roundUp(compHandle->getClassAlignmentRequirement(typeHnd), TARGET_POINTER_SIZE);
  1328| #endif // TARGET_ARM
  1329|     if (StructHasCustomLayout(typeFlags) && ((typeFlags & CORINFO_FLG_CONTAINS_GC_PTR) == 0))
  1330|     {
  1331|         structPromotionInfo.customLayout = true;
  1332|     }
  1333|     if (StructHasDontDigFieldsFlagSet(typeFlags))
  1334|     {
  1335|         return CanConstructAndPromoteField(&structPromotionInfo);
  1336|     }
  1337|     unsigned fieldsSize = 0;
  1338|     for (BYTE ordinal = 0; ordinal < fieldCnt; ++ordinal)
  1339|     {
  1340|         CORINFO_FIELD_HANDLE fieldHnd       = compHandle->getFieldInClass(typeHnd, ordinal);
  1341|         structPromotionInfo.fields[ordinal] = GetFieldInfo(fieldHnd, ordinal);
  1342|         const lvaStructFieldInfo& fieldInfo = structPromotionInfo.fields[ordinal];
  1343|         noway_assert(fieldInfo.fldOffset < structSize);
  1344|         if (fieldInfo.fldSize == 0)
  1345|         {
  1346|             return false;
  1347|         }
  1348|         if ((fieldInfo.fldOffset % fieldInfo.fldSize) != 0)
  1349|         {
  1350|             return false;
  1351|         }
  1352|         if (varTypeIsGC(fieldInfo.fldType))
  1353|         {
  1354|             containsGCpointers = true;
  1355|         }
  1356|         noway_assert(fieldInfo.fldOffset + fieldInfo.fldSize <= structSize);
  1357|         fieldsSize += fieldInfo.fldSize;
  1358| #ifdef TARGET_ARM
  1359|         if (fieldInfo.fldSize > structAlignment)
  1360|         {
  1361|             return false;
  1362|         }
  1363| #endif // TARGET_ARM
  1364|     }
  1365|     noway_assert((containsGCpointers == false) ||
  1366|                  ((typeFlags & (CORINFO_FLG_CONTAINS_GC_PTR | CORINFO_FLG_BYREF_LIKE)) != 0));
  1367|     assert(!overlappingFields);
  1368|     if (fieldsSize != structSize)
  1369|     {
  1370|         structPromotionInfo.containsHoles = true;
  1371|     }
  1372|     structPromotionInfo.canPromote = true;
  1373|     return true;
  1374| }
  1375| bool Compiler::StructPromotionHelper::CanConstructAndPromoteField(lvaStructPromotionInfo* structPromotionInfo)
  1376| {
  1377|     const CORINFO_CLASS_HANDLE typeHnd    = structPromotionInfo->typeHnd;
  1378|     const COMP_HANDLE          compHandle = compiler->info.compCompHnd;
  1379|     const DWORD                typeFlags  = compHandle->getClassAttribs(typeHnd);
  1380|     if (structPromotionInfo->fieldCnt != 1)
  1381|     {
  1382|         return false;
  1383|     }
  1384|     if ((typeFlags & CORINFO_FLG_CONTAINS_GC_PTR) == 0)
  1385|     {
  1386|         return false;
  1387|     }
  1388|     const unsigned structSize = compHandle->getClassSize(typeHnd);
  1389|     if (structSize != TARGET_POINTER_SIZE)
  1390|     {
  1391|         return false;
  1392|     }
  1393|     assert(!structPromotionInfo->containsHoles);
  1394|     assert(!structPromotionInfo->customLayout);
  1395|     lvaStructFieldInfo& fldInfo = structPromotionInfo->fields[0];
  1396|     fldInfo.fldHnd = compHandle->getFieldInClass(typeHnd, 0);
  1397|     fldInfo.fldTypeHnd = 0;
  1398|     fldInfo.fldOffset  = 0;
  1399|     fldInfo.fldOrdinal = 0;
  1400|     fldInfo.fldSize    = TARGET_POINTER_SIZE;
  1401|     fldInfo.fldType    = TYP_REF;
  1402|     structPromotionInfo->canPromote = true;
  1403|     return true;
  1404| }
  1405| bool Compiler::StructPromotionHelper::CanPromoteStructVar(unsigned lclNum)
  1406| {
  1407|     LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
  1408|     assert(varTypeIsStruct(varDsc));
  1409|     assert(!varDsc->lvPromoted); // Don't ask again :)
  1410|     if (varDsc->lvIsUsedInSIMDIntrinsic())
  1411|     {
  1412|         JITDUMP("  struct promotion of V%02u is disabled because lvIsUsedInSIMDIntrinsic()\n", lclNum);
  1413|         return false;
  1414|     }
  1415|     if (varDsc->lvIsParam && compiler->compGSReorderStackLayout)
  1416|     {
  1417|         JITDUMP("  struct promotion of V%02u is disabled because lvIsParam and compGSReorderStackLayout\n", lclNum);
  1418|         return false;
  1419|     }
  1420|     if (!compiler->lvaEnregMultiRegVars && varDsc->lvIsMultiRegArgOrRet())
  1421|     {
  1422|         JITDUMP("  struct promotion of V%02u is disabled because lvIsMultiRegArgOrRet()\n", lclNum);
  1423|         return false;
  1424|     }
  1425|     if (compiler->lvaIsOSRLocal(lclNum) && compiler->info.compPatchpointInfo->IsExposed(lclNum))
  1426|     {
  1427|         JITDUMP("  struct promotion of V%02u is disabled because it is an exposed OSR local\n", lclNum);
  1428|         return false;
  1429|     }
  1430|     CORINFO_CLASS_HANDLE typeHnd = varDsc->GetStructHnd();
  1431|     assert(typeHnd != NO_CLASS_HANDLE);
  1432|     bool canPromote = CanPromoteStructType(typeHnd);
  1433|     if (canPromote && varDsc->lvIsMultiRegArgOrRet())
  1434|     {
  1435|         unsigned fieldCnt = structPromotionInfo.fieldCnt;
  1436|         if (fieldCnt > MAX_MULTIREG_COUNT)
  1437|         {
  1438|             canPromote = false;
  1439|         }
  1440| #if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
  1441|         else
  1442|         {
  1443|             for (unsigned i = 0; canPromote && (i < fieldCnt); i++)
  1444|             {
  1445|                 var_types fieldType = structPromotionInfo.fields[i].fldType;
  1446|                 if (varDsc->lvIsParam && (varDsc->lvIsHfa() != varTypeUsesFloatReg(fieldType)))
  1447|                 {
  1448|                     canPromote = false;
  1449|                 }
  1450| #if defined(FEATURE_SIMD)
  1451|                 else if ((fieldCnt > 1) && varTypeIsStruct(fieldType) &&
  1452|                          !compiler->isOpaqueSIMDType(structPromotionInfo.fields[i].fldTypeHnd))
  1453|                 {
  1454|                     canPromote = false;
  1455|                 }
  1456| #endif // FEATURE_SIMD
  1457|             }
  1458|         }
  1459| #elif defined(UNIX_AMD64_ABI)
  1460|         else
  1461|         {
  1462|             SortStructFields();
  1463|             SYSTEMV_AMD64_CORINFO_STRUCT_REG_PASSING_DESCRIPTOR structDesc;
  1464|             compiler->eeGetSystemVAmd64PassStructInRegisterDescriptor(typeHnd, &structDesc);
  1465|             unsigned regCount = structDesc.eightByteCount;
  1466|             if ((structPromotionInfo.fieldCnt == 1) && varTypeIsSIMD(structPromotionInfo.fields[0].fldType))
  1467|             {
  1468|             }
  1469|             else if (structPromotionInfo.fieldCnt != regCount)
  1470|             {
  1471|                 canPromote = false;
  1472|             }
  1473|             else
  1474|             {
  1475|                 for (unsigned i = 0; canPromote && (i < regCount); i++)
  1476|                 {
  1477|                     lvaStructFieldInfo* fieldInfo = &(structPromotionInfo.fields[i]);
  1478|                     var_types           fieldType = fieldInfo->fldType;
  1479|                     if (varTypeIsSIMD(fieldType))
  1480|                     {
  1481|                         canPromote = false;
  1482|                     }
  1483|                     else if (varTypeUsesFloatReg(fieldType) !=
  1484|                              (structDesc.eightByteClassifications[i] == SystemVClassificationTypeSSE))
  1485|                     {
  1486|                         canPromote = false;
  1487|                     }
  1488|                 }
  1489|             }
  1490|         }
  1491| #endif // UNIX_AMD64_ABI
  1492|     }
  1493|     return canPromote;
  1494| }
  1495| bool Compiler::StructPromotionHelper::ShouldPromoteStructVar(unsigned lclNum)
  1496| {
  1497|     LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
  1498|     assert(varTypeIsStruct(varDsc));
  1499|     assert(varDsc->GetStructHnd() == structPromotionInfo.typeHnd);
  1500|     assert(structPromotionInfo.canPromote);
  1501|     bool shouldPromote = true;
  1502|     if (structPromotionInfo.fieldCnt > 3 && !varDsc->lvFieldAccessed)
  1503|     {
  1504|         JITDUMP("Not promoting promotable struct local V%02u: #fields = %d, fieldAccessed = %d.\n", lclNum,
  1505|                 structPromotionInfo.fieldCnt, varDsc->lvFieldAccessed);
  1506|         shouldPromote = false;
  1507|     }
  1508|     else if (varDsc->lvIsMultiRegRet && structPromotionInfo.containsHoles && structPromotionInfo.customLayout)
  1509|     {
  1510|         JITDUMP("Not promoting multi-reg returned struct local V%02u with holes.\n", lclNum);
  1511|         shouldPromote = false;
  1512|     }
  1513| #if defined(TARGET_AMD64) || defined(TARGET_ARM64) || defined(TARGET_ARM) || defined(TARGET_LOONGARCH64)
  1514|     else if ((structPromotionInfo.fieldCnt == 1) && varTypeIsFloating(structPromotionInfo.fields[0].fldType))
  1515|     {
  1516|         JITDUMP("Not promoting promotable struct local V%02u: #fields = %d because it is a struct with "
  1517|                 "single float field.\n",
  1518|                 lclNum, structPromotionInfo.fieldCnt);
  1519|         shouldPromote = false;
  1520|     }
  1521| #if defined(TARGET_LOONGARCH64)
  1522|     else if ((structPromotionInfo.fieldCnt == 2) && (varTypeIsFloating(structPromotionInfo.fields[0].fldType) ||
  1523|                                                      varTypeIsFloating(structPromotionInfo.fields[1].fldType)))
  1524|     {
  1525|         JITDUMP("Not promoting promotable struct local V%02u: #fields = %d because it is a struct with "
  1526|                 "float field(s).\n",
  1527|                 lclNum, structPromotionInfo.fieldCnt);
  1528|         shouldPromote = false;
  1529|     }
  1530| #endif
  1531| #endif // TARGET_AMD64 || TARGET_ARM64 || TARGET_ARM || TARGET_LOONGARCH64
  1532|     else if (varDsc->lvIsParam && !compiler->lvaIsImplicitByRefLocal(lclNum) && !varDsc->lvIsHfa())
  1533|     {
  1534| #if FEATURE_MULTIREG_STRUCT_PROMOTE
  1535|         if (compiler->lvaIsMultiregStruct(varDsc, compiler->info.compIsVarArgs))
  1536|         {
  1537|             if (structPromotionInfo.containsHoles && structPromotionInfo.customLayout)
  1538|             {
  1539|                 JITDUMP("Not promoting multi-reg struct local V%02u with holes.\n", lclNum);
  1540|                 shouldPromote = false;
  1541|             }
  1542|             else if ((structPromotionInfo.fieldCnt != 2) &&
  1543|                      !((structPromotionInfo.fieldCnt == 1) && varTypeIsSIMD(structPromotionInfo.fields[0].fldType)))
  1544|             {
  1545|                 JITDUMP("Not promoting multireg struct local V%02u, because lvIsParam is true, #fields != 2 and it's "
  1546|                         "not a single SIMD.\n",
  1547|                         lclNum);
  1548|                 shouldPromote = false;
  1549|             }
  1550|         }
  1551|         else
  1552| #endif // !FEATURE_MULTIREG_STRUCT_PROMOTE
  1553|             if (structPromotionInfo.fieldCnt != 1)
  1554|         {
  1555|             JITDUMP("Not promoting promotable struct local V%02u, because lvIsParam is true and #fields = "
  1556|                     "%d.\n",
  1557|                     lclNum, structPromotionInfo.fieldCnt);
  1558|             shouldPromote = false;
  1559|         }
  1560|     }
  1561|     else if ((lclNum == compiler->genReturnLocal) && (structPromotionInfo.fieldCnt > 1))
  1562|     {
  1563|         shouldPromote = false;
  1564|     }
  1565| #if defined(DEBUG)
  1566|     else if (compiler->compPromoteFewerStructs(lclNum))
  1567|     {
  1568|         JITDUMP("Not promoting promotable struct local V%02u, because of STRESS_PROMOTE_FEWER_STRUCTS\n", lclNum);
  1569|         shouldPromote = false;
  1570|     }
  1571| #endif
  1572|     CLANG_FORMAT_COMMENT_ANCHOR;
  1573|     return shouldPromote;
  1574| }
  1575| void Compiler::StructPromotionHelper::SortStructFields()
  1576| {
  1577|     if (!structPromotionInfo.fieldsSorted)
  1578|     {
  1579|         jitstd::sort(structPromotionInfo.fields, structPromotionInfo.fields + structPromotionInfo.fieldCnt,
  1580|                      lvaFieldOffsetCmp());
  1581|         structPromotionInfo.fieldsSorted = true;
  1582|     }
  1583| }
  1584| Compiler::lvaStructFieldInfo Compiler::StructPromotionHelper::GetFieldInfo(CORINFO_FIELD_HANDLE fieldHnd, BYTE ordinal)
  1585| {
  1586|     lvaStructFieldInfo fieldInfo;
  1587|     fieldInfo.fldHnd = fieldHnd;
  1588|     unsigned fldOffset  = compiler->info.compCompHnd->getFieldOffset(fieldInfo.fldHnd);
  1589|     fieldInfo.fldOffset = (BYTE)fldOffset;
  1590|     fieldInfo.fldOrdinal = ordinal;
  1591|     CorInfoType corType  = compiler->info.compCompHnd->getFieldType(fieldInfo.fldHnd, &fieldInfo.fldTypeHnd);
  1592|     fieldInfo.fldType    = JITtype2varType(corType);
  1593|     fieldInfo.fldSize    = genTypeSize(fieldInfo.fldType);
  1594| #ifdef FEATURE_SIMD
  1595|     if (compiler->usesSIMDTypes() && (fieldInfo.fldSize == 0) && compiler->isSIMDorHWSIMDClass(fieldInfo.fldTypeHnd))
  1596|     {
  1597|         unsigned    simdSize;
  1598|         CorInfoType simdBaseJitType = compiler->getBaseJitTypeAndSizeOfSIMDType(fieldInfo.fldTypeHnd, &simdSize);
  1599|         if (simdBaseJitType != CORINFO_TYPE_UNDEF)
  1600|         {
  1601|             if ((simdSize >= compiler->minSIMDStructBytes()) && (simdSize <= compiler->maxSIMDStructBytes()))
  1602|             {
  1603|                 fieldInfo.fldType = compiler->getSIMDTypeForSize(simdSize);
  1604|                 fieldInfo.fldSize = simdSize;
  1605| #ifdef DEBUG
  1606|                 retypedFieldsMap.Set(fieldInfo.fldHnd, fieldInfo.fldType, RetypedAsScalarFieldsMap::Overwrite);
  1607| #endif // DEBUG
  1608|             }
  1609|         }
  1610|     }
  1611| #endif // FEATURE_SIMD
  1612|     if (fieldInfo.fldSize == 0)
  1613|     {
  1614|         TryPromoteStructField(fieldInfo);
  1615|     }
  1616|     return fieldInfo;
  1617| }
  1618| bool Compiler::StructPromotionHelper::TryPromoteStructField(lvaStructFieldInfo& fieldInfo)
  1619| {
  1620|     if (fieldInfo.fldType != TYP_STRUCT)
  1621|     {
  1622|         return false;
  1623|     }
  1624|     COMP_HANDLE compHandle = compiler->info.compCompHnd;
  1625|     if (compHandle->getClassNumInstanceFields(fieldInfo.fldTypeHnd) != 1)
  1626|     {
  1627|         return false;
  1628|     }
  1629|     CORINFO_FIELD_HANDLE innerFieldHndl   = compHandle->getFieldInClass(fieldInfo.fldTypeHnd, 0);
  1630|     unsigned             innerFieldOffset = compHandle->getFieldOffset(innerFieldHndl);
  1631|     if (innerFieldOffset != 0)
  1632|     {
  1633|         return false;
  1634|     }
  1635|     CorInfoType fieldCorType = compHandle->getFieldType(innerFieldHndl);
  1636|     var_types   fieldVarType = JITtype2varType(fieldCorType);
  1637|     unsigned    fieldSize    = genTypeSize(fieldVarType);
  1638|     if (fieldSize == 0 || fieldSize > TARGET_POINTER_SIZE || varTypeIsFloating(fieldVarType))
  1639|     {
  1640|         JITDUMP("Promotion blocked: struct contains struct field with one field,"
  1641|                 " but that field has invalid size or type.\n");
  1642|         return false;
  1643|     }
  1644|     if (fieldSize != TARGET_POINTER_SIZE)
  1645|     {
  1646|         unsigned outerFieldOffset = compHandle->getFieldOffset(fieldInfo.fldHnd);
  1647|         if ((outerFieldOffset % fieldSize) != 0)
  1648|         {
  1649|             JITDUMP("Promotion blocked: struct contains struct field with one field,"
  1650|                     " but the outer struct offset %u is not a multiple of the inner field size %u.\n",
  1651|                     outerFieldOffset, fieldSize);
  1652|             return false;
  1653|         }
  1654|     }
  1655|     unsigned innerStructSize = compHandle->getClassSize(fieldInfo.fldTypeHnd);
  1656|     if (fieldSize != innerStructSize)
  1657|     {
  1658|         JITDUMP("Promotion blocked: struct contains struct field with one field,"
  1659|                 " but that field is not the same size as its parent.\n");
  1660|         return false;
  1661|     }
  1662|     fieldInfo.fldType = fieldVarType;
  1663|     fieldInfo.fldSize = fieldSize;
  1664| #ifdef DEBUG
  1665|     retypedFieldsMap.Set(fieldInfo.fldHnd, fieldInfo.fldType, RetypedAsScalarFieldsMap::Overwrite);
  1666| #endif // DEBUG
  1667|     return true;
  1668| }
  1669| void Compiler::StructPromotionHelper::PromoteStructVar(unsigned lclNum)
  1670| {
  1671|     LclVarDsc* varDsc = compiler->lvaGetDesc(lclNum);
  1672|     assert(!varDsc->lvRegStruct);
  1673|     assert(varDsc->GetStructHnd() == structPromotionInfo.typeHnd);
  1674|     assert(structPromotionInfo.canPromote);
  1675|     varDsc->lvFieldCnt      = structPromotionInfo.fieldCnt;
  1676|     varDsc->lvFieldLclStart = compiler->lvaCount;
  1677|     varDsc->lvPromoted      = true;
  1678|     varDsc->lvContainsHoles = structPromotionInfo.containsHoles;
  1679|     varDsc->lvCustomLayout  = structPromotionInfo.customLayout;
  1680| #ifdef DEBUG
  1681|     varDsc->lvKeepType = 1;
  1682| #endif
  1683| #ifdef DEBUG
  1684|     if (compiler->verbose)
  1685|     {
  1686|         printf("\nPromoting struct local V%02u (%s):", lclNum, compiler->eeGetClassName(varDsc->GetStructHnd()));
  1687|     }
  1688| #endif
  1689|     SortStructFields();
  1690|     for (unsigned index = 0; index < structPromotionInfo.fieldCnt; ++index)
  1691|     {
  1692|         const lvaStructFieldInfo* pFieldInfo = &structPromotionInfo.fields[index];
  1693|         if (varTypeUsesFloatReg(pFieldInfo->fldType))
  1694|         {
  1695|             compiler->compFloatingPointUsed = true;
  1696|         }
  1697| #ifdef DEBUG
  1698|         char buf[200];
  1699|         sprintf_s(buf, sizeof(buf), "%s V%02u.%s (fldOffset=0x%x)", "field", lclNum,
  1700|                   compiler->eeGetFieldName(pFieldInfo->fldHnd), pFieldInfo->fldOffset);
  1701|         size_t len  = strlen(buf) + 1;
  1702|         char*  bufp = compiler->getAllocator(CMK_DebugOnly).allocate<char>(len);
  1703|         strcpy_s(bufp, len, buf);
  1704|         if (index > 0)
  1705|         {
  1706|             noway_assert(pFieldInfo->fldOffset > (pFieldInfo - 1)->fldOffset);
  1707|         }
  1708| #endif
  1709|         const unsigned varNum = compiler->lvaGrabTemp(false DEBUGARG(bufp));
  1710|         varDsc = compiler->lvaGetDesc(lclNum);
  1711|         LclVarDsc* fieldVarDsc       = compiler->lvaGetDesc(varNum);
  1712|         fieldVarDsc->lvType          = pFieldInfo->fldType;
  1713|         fieldVarDsc->lvExactSize     = pFieldInfo->fldSize;
  1714|         fieldVarDsc->lvIsStructField = true;
  1715|         fieldVarDsc->lvFieldHnd      = pFieldInfo->fldHnd;
  1716|         fieldVarDsc->lvFldOffset     = pFieldInfo->fldOffset;
  1717|         fieldVarDsc->lvFldOrdinal    = pFieldInfo->fldOrdinal;
  1718|         fieldVarDsc->lvParentLcl     = lclNum;
  1719|         fieldVarDsc->lvIsParam       = varDsc->lvIsParam;
  1720|         fieldVarDsc->lvIsOSRLocal    = varDsc->lvIsOSRLocal;
  1721|         if (fieldVarDsc->lvType == TYP_LONG)
  1722|         {
  1723|             compiler->compLongUsed = true;
  1724|         }
  1725| #if FEATURE_IMPLICIT_BYREFS
  1726|         fieldVarDsc->lvIsImplicitByRef = 0;
  1727| #endif // FEATURE_IMPLICIT_BYREFS
  1728|         if (varDsc->lvIsRegArg)
  1729|         {
  1730|             fieldVarDsc->lvIsRegArg = true;
  1731|             regNumber parentArgReg  = varDsc->GetArgReg();
  1732| #if FEATURE_MULTIREG_ARGS
  1733|             if (!compiler->lvaIsImplicitByRefLocal(lclNum))
  1734|             {
  1735| #ifdef UNIX_AMD64_ABI
  1736|                 if (varTypeIsSIMD(fieldVarDsc) && (varDsc->lvFieldCnt == 1))
  1737|                 {
  1738|                     fieldVarDsc->SetArgReg(parentArgReg);
  1739|                     fieldVarDsc->SetOtherArgReg(varDsc->GetOtherArgReg());
  1740|                 }
  1741|                 else
  1742| #endif // UNIX_AMD64_ABI
  1743|                 {
  1744|                     regNumber fieldRegNum;
  1745|                     if (index == 0)
  1746|                     {
  1747|                         fieldRegNum = parentArgReg;
  1748|                     }
  1749|                     else if (varDsc->lvIsHfa())
  1750|                     {
  1751|                         unsigned regIncrement = fieldVarDsc->lvFldOrdinal;
  1752| #ifdef TARGET_ARM
  1753|                         if (varDsc->GetHfaType() == TYP_DOUBLE)
  1754|                         {
  1755|                             regIncrement *= 2;
  1756|                         }
  1757| #endif // TARGET_ARM
  1758|                         fieldRegNum = (regNumber)(parentArgReg + regIncrement);
  1759|                     }
  1760|                     else
  1761|                     {
  1762|                         assert(index == 1);
  1763|                         fieldRegNum = varDsc->GetOtherArgReg();
  1764|                     }
  1765|                     fieldVarDsc->SetArgReg(fieldRegNum);
  1766|                 }
  1767|             }
  1768|             else
  1769| #endif // FEATURE_MULTIREG_ARGS && defined(FEATURE_SIMD)
  1770|             {
  1771|                 fieldVarDsc->SetArgReg(parentArgReg);
  1772|             }
  1773|         }
  1774| #ifdef FEATURE_SIMD
  1775|         if (varTypeIsSIMD(pFieldInfo->fldType))
  1776|         {
  1777|             fieldVarDsc->lvExactSize = 0;
  1778|             compiler->lvaSetStruct(varNum, pFieldInfo->fldTypeHnd, false);
  1779|             fieldVarDsc->lvRegStruct = true;
  1780|         }
  1781| #endif // FEATURE_SIMD
  1782| #ifdef DEBUG
  1783|         fieldVarDsc->lvKeepType = 1;
  1784| #endif
  1785|     }
  1786| }
  1787| unsigned Compiler::lvaGetFieldLocal(const LclVarDsc* varDsc, unsigned int fldOffset)
  1788| {
  1789|     noway_assert(varTypeIsStruct(varDsc));
  1790|     noway_assert(varDsc->lvPromoted);
  1791|     for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
  1792|     {
  1793|         noway_assert(lvaTable[i].lvIsStructField);
  1794|         noway_assert(lvaTable[i].lvParentLcl == (unsigned)(varDsc - lvaTable));
  1795|         if (lvaTable[i].lvFldOffset == fldOffset)
  1796|         {
  1797|             return i;
  1798|         }
  1799|     }
  1800|     return BAD_VAR_NUM;
  1801| }
  1802| /*****************************************************************************
  1803|  *
  1804|  *  Set the local var "varNum" as address-exposed.
  1805|  *  If this is a promoted struct, label it's fields the same way.
  1806|  */
  1807| void Compiler::lvaSetVarAddrExposed(unsigned varNum DEBUGARG(AddressExposedReason reason))
  1808| {
  1809|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  1810|     varDsc->SetAddressExposed(true DEBUGARG(reason));
  1811|     if (varDsc->lvPromoted)
  1812|     {
  1813|         noway_assert(varTypeIsStruct(varDsc));
  1814|         for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
  1815|         {
  1816|             noway_assert(lvaTable[i].lvIsStructField);
  1817|             lvaTable[i].SetAddressExposed(true DEBUGARG(AddressExposedReason::PARENT_EXPOSED));
  1818|             lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::AddrExposed));
  1819|         }
  1820|     }
  1821|     lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::AddrExposed));
  1822| }
  1823| void Compiler::lvaSetHiddenBufferStructArg(unsigned varNum)
  1824| {
  1825|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  1826| #ifdef DEBUG
  1827|     varDsc->SetHiddenBufferStructArg(true);
  1828| #endif
  1829|     if (varDsc->lvPromoted)
  1830|     {
  1831|         noway_assert(varTypeIsStruct(varDsc));
  1832|         for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
  1833|         {
  1834|             noway_assert(lvaTable[i].lvIsStructField);
  1835| #ifdef DEBUG
  1836|             lvaTable[i].SetHiddenBufferStructArg(true);
  1837| #endif
  1838|             lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::HiddenBufferStructArg));
  1839|         }
  1840|     }
  1841|     lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::HiddenBufferStructArg));
  1842| }
  1843| void Compiler::lvaSetVarLiveInOutOfHandler(unsigned varNum)
  1844| {
  1845|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  1846|     varDsc->lvLiveInOutOfHndlr = 1;
  1847|     if (varDsc->lvPromoted)
  1848|     {
  1849|         noway_assert(varTypeIsStruct(varDsc));
  1850|         for (unsigned i = varDsc->lvFieldLclStart; i < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++i)
  1851|         {
  1852|             noway_assert(lvaTable[i].lvIsStructField);
  1853|             lvaTable[i].lvLiveInOutOfHndlr = 1;
  1854|             if (!lvaEnregEHVars || !lvaTable[i].lvSingleDefRegCandidate || lvaTable[i].lvRefCnt() <= 1)
  1855|             {
  1856|                 lvaSetVarDoNotEnregister(i DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
  1857|             }
  1858|         }
  1859|     }
  1860|     if (!lvaEnregEHVars || !varDsc->lvSingleDefRegCandidate || varDsc->lvRefCnt() <= 1)
  1861|     {
  1862|         lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
  1863|     }
  1864| #ifdef JIT32_GCENCODER
  1865|     else if (lvaKeepAliveAndReportThis() && (varNum == info.compThisArg))
  1866|     {
  1867|         lvaSetVarDoNotEnregister(varNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
  1868|     }
  1869| #endif // JIT32_GCENCODER
  1870| }
  1871| /*****************************************************************************
  1872|  *
  1873|  *  Record that the local var "varNum" should not be enregistered (for one of several reasons.)
  1874|  */
  1875| void Compiler::lvaSetVarDoNotEnregister(unsigned varNum DEBUGARG(DoNotEnregisterReason reason))
  1876| {
  1877|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  1878|     const bool wasAlreadyMarkedDoNotEnreg = (varDsc->lvDoNotEnregister == 1);
  1879|     varDsc->lvDoNotEnregister             = 1;
  1880| #ifdef DEBUG
  1881|     if (!wasAlreadyMarkedDoNotEnreg)
  1882|     {
  1883|         varDsc->SetDoNotEnregReason(reason);
  1884|     }
  1885|     if (verbose)
  1886|     {
  1887|         printf("\nLocal V%02u should not be enregistered because: ", varNum);
  1888|     }
  1889|     switch (reason)
  1890|     {
  1891|         case DoNotEnregisterReason::AddrExposed:
  1892|             JITDUMP("it is address exposed\n");
  1893|             assert(varDsc->IsAddressExposed());
  1894|             break;
  1895|         case DoNotEnregisterReason::HiddenBufferStructArg:
  1896|             JITDUMP("it is hidden buffer struct arg\n");
  1897|             assert(varDsc->IsHiddenBufferStructArg());
  1898|             break;
  1899|         case DoNotEnregisterReason::DontEnregStructs:
  1900|             JITDUMP("struct enregistration is disabled\n");
  1901|             assert(varTypeIsStruct(varDsc));
  1902|             break;
  1903|         case DoNotEnregisterReason::NotRegSizeStruct:
  1904|             JITDUMP("struct size does not match reg size\n");
  1905|             assert(varTypeIsStruct(varDsc));
  1906|             break;
  1907|         case DoNotEnregisterReason::LocalField:
  1908|             JITDUMP("was accessed as a local field\n");
  1909|             break;
  1910|         case DoNotEnregisterReason::VMNeedsStackAddr:
  1911|             JITDUMP("VM needs stack addr\n");
  1912|             break;
  1913|         case DoNotEnregisterReason::LiveInOutOfHandler:
  1914|             JITDUMP("live in/out of a handler\n");
  1915|             varDsc->lvLiveInOutOfHndlr = 1;
  1916|             break;
  1917|         case DoNotEnregisterReason::BlockOp:
  1918|             JITDUMP("written/read in a block op\n");
  1919|             break;
  1920|         case DoNotEnregisterReason::IsStructArg:
  1921|             if (varTypeIsStruct(varDsc))
  1922|             {
  1923|                 JITDUMP("it is a struct arg\n");
  1924|             }
  1925|             else
  1926|             {
  1927|                 JITDUMP("it is reinterpreted as a struct arg\n");
  1928|             }
  1929|             break;
  1930|         case DoNotEnregisterReason::DepField:
  1931|             JITDUMP("field of a dependently promoted struct\n");
  1932|             assert(varDsc->lvIsStructField && (lvaGetParentPromotionType(varNum) != PROMOTION_TYPE_INDEPENDENT));
  1933|             break;
  1934|         case DoNotEnregisterReason::NoRegVars:
  1935|             JITDUMP("opts.compFlags & CLFLG_REGVAR is not set\n");
  1936|             assert(!compEnregLocals());
  1937|             break;
  1938|         case DoNotEnregisterReason::MinOptsGC:
  1939|             JITDUMP("it is a GC Ref and we are compiling MinOpts\n");
  1940|             assert(!JitConfig.JitMinOptsTrackGCrefs() && varTypeIsGC(varDsc->TypeGet()));
  1941|             break;
  1942| #if !defined(TARGET_64BIT)
  1943|         case DoNotEnregisterReason::LongParamField:
  1944|             JITDUMP("it is a decomposed field of a long parameter\n");
  1945|             break;
  1946| #endif
  1947| #ifdef JIT32_GCENCODER
  1948|         case DoNotEnregisterReason::PinningRef:
  1949|             JITDUMP("pinning ref\n");
  1950|             assert(varDsc->lvPinned);
  1951|             break;
  1952| #endif
  1953|         case DoNotEnregisterReason::LclAddrNode:
  1954|             JITDUMP("LclAddrVar/Fld takes the address of this node\n");
  1955|             break;
  1956|         case DoNotEnregisterReason::CastTakesAddr:
  1957|             JITDUMP("cast takes addr\n");
  1958|             break;
  1959|         case DoNotEnregisterReason::StoreBlkSrc:
  1960|             JITDUMP("the local is used as store block src\n");
  1961|             break;
  1962|         case DoNotEnregisterReason::OneAsgRetyping:
  1963|             JITDUMP("OneAsg forbids enreg\n");
  1964|             break;
  1965|         case DoNotEnregisterReason::SwizzleArg:
  1966|             JITDUMP("SwizzleArg\n");
  1967|             break;
  1968|         case DoNotEnregisterReason::BlockOpRet:
  1969|             JITDUMP("return uses a block op\n");
  1970|             break;
  1971|         case DoNotEnregisterReason::ReturnSpCheck:
  1972|             JITDUMP("Used for SP check\n");
  1973|             break;
  1974|         case DoNotEnregisterReason::SimdUserForcesDep:
  1975|             JITDUMP("Promoted struct used by a SIMD/HWI node\n");
  1976|             break;
  1977|         default:
  1978|             unreached();
  1979|             break;
  1980|     }
  1981| #endif
  1982| }
  1983| bool Compiler::lvaIsImplicitByRefLocal(unsigned lclNum) const
  1984| {
  1985| #if FEATURE_IMPLICIT_BYREFS
  1986|     LclVarDsc* varDsc = lvaGetDesc(lclNum);
  1987|     if (varDsc->lvIsImplicitByRef)
  1988|     {
  1989|         assert(varDsc->lvIsParam);
  1990|         assert(varTypeIsStruct(varDsc) || (varDsc->TypeGet() == TYP_BYREF));
  1991|         return true;
  1992|     }
  1993| #endif // FEATURE_IMPLICIT_BYREFS
  1994|     return false;
  1995| }
  1996| bool Compiler::lvaIsLocalImplicitlyAccessedByRef(unsigned lclNum) const
  1997| {
  1998|     if (lvaGetDesc(lclNum)->lvIsStructField)
  1999|     {
  2000|         return lvaIsImplicitByRefLocal(lvaGetDesc(lclNum)->lvParentLcl);
  2001|     }
  2002|     return lvaIsImplicitByRefLocal(lclNum);
  2003| }
  2004| bool Compiler::lvaIsMultiregStruct(LclVarDsc* varDsc, bool isVarArg)
  2005| {
  2006|     if (varTypeIsStruct(varDsc->TypeGet()))
  2007|     {
  2008|         CORINFO_CLASS_HANDLE clsHnd = varDsc->GetStructHnd();
  2009|         structPassingKind    howToPassStruct;
  2010|         var_types type = getArgTypeForStruct(clsHnd, &howToPassStruct, isVarArg, varDsc->lvExactSize);
  2011|         if (howToPassStruct == SPK_ByValueAsHfa)
  2012|         {
  2013|             assert(type == TYP_STRUCT);
  2014|             return true;
  2015|         }
  2016| #if defined(UNIX_AMD64_ABI) || defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  2017|         if (howToPassStruct == SPK_ByValue)
  2018|         {
  2019|             assert(type == TYP_STRUCT);
  2020|             return true;
  2021|         }
  2022| #endif
  2023|     }
  2024|     return false;
  2025| }
  2026| /*****************************************************************************
  2027|  * Set the lvClass for a local variable of a struct type */
  2028| void Compiler::lvaSetStruct(unsigned varNum, CORINFO_CLASS_HANDLE typeHnd, bool unsafeValueClsCheck)
  2029| {
  2030|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  2031|     if (varDsc->lvType == TYP_UNDEF)
  2032|     {
  2033|         varDsc->lvType = TYP_STRUCT;
  2034|     }
  2035|     if (varDsc->GetLayout() == nullptr)
  2036|     {
  2037|         ClassLayout* layout = typGetObjLayout(typeHnd);
  2038|         varDsc->SetLayout(layout);
  2039|         assert(varDsc->lvExactSize == 0);
  2040|         varDsc->lvExactSize = layout->GetSize();
  2041|         assert(varDsc->lvExactSize != 0);
  2042|         if (layout->IsValueClass())
  2043|         {
  2044|             CorInfoType simdBaseJitType = CORINFO_TYPE_UNDEF;
  2045|             varDsc->lvType              = impNormStructType(typeHnd, &simdBaseJitType);
  2046| #if FEATURE_IMPLICIT_BYREFS
  2047|             if (varDsc->lvIsParam && !varDsc->lvIsStructField)
  2048|             {
  2049|                 structPassingKind howToReturnStruct;
  2050|                 getArgTypeForStruct(typeHnd, &howToReturnStruct, this->info.compIsVarArgs, varDsc->lvExactSize);
  2051|                 if (howToReturnStruct == SPK_ByReference)
  2052|                 {
  2053|                     JITDUMP("Marking V%02i as a byref parameter\n", varNum);
  2054|                     varDsc->lvIsImplicitByRef = 1;
  2055|                 }
  2056|             }
  2057| #endif // FEATURE_IMPLICIT_BYREFS
  2058| #if FEATURE_SIMD
  2059|             if (simdBaseJitType != CORINFO_TYPE_UNDEF)
  2060|             {
  2061|                 assert(varTypeIsSIMD(varDsc));
  2062|                 varDsc->lvSIMDType = true;
  2063|                 varDsc->SetSimdBaseJitType(simdBaseJitType);
  2064|             }
  2065| #endif // FEATURE_SIMD
  2066|             if (GlobalJitOptions::compFeatureHfa)
  2067|             {
  2068|                 if (varDsc->lvExactSize <= MAX_PASS_MULTIREG_BYTES)
  2069|                 {
  2070|                     var_types hfaType = GetHfaType(typeHnd);
  2071|                     if (varTypeIsValidHfaType(hfaType))
  2072|                     {
  2073|                         varDsc->SetHfaType(hfaType);
  2074|                         assert(!layout->HasGCPtr());
  2075|                         assert((varDsc->lvExactSize % genTypeSize(hfaType)) == 0);
  2076|                         assert((varDsc->lvExactSize / genTypeSize(hfaType)) <= MAX_ARG_REG_COUNT);
  2077|                     }
  2078|                 }
  2079|             }
  2080|         }
  2081|     }
  2082|     else
  2083|     {
  2084| #if FEATURE_SIMD
  2085|         assert(!varTypeIsSIMD(varDsc) || (varDsc->GetSimdBaseType() != TYP_UNKNOWN));
  2086| #endif // FEATURE_SIMD
  2087|         ClassLayout* layout = typGetObjLayout(typeHnd);
  2088|         assert(ClassLayout::AreCompatible(varDsc->GetLayout(), layout));
  2089|         varDsc->SetLayout(layout);
  2090|         assert(varDsc->lvExactSize != 0);
  2091|     }
  2092| #ifndef TARGET_64BIT
  2093|     bool fDoubleAlignHint = false;
  2094| #ifdef TARGET_X86
  2095|     fDoubleAlignHint = true;
  2096| #endif
  2097|     if (info.compCompHnd->getClassAlignmentRequirement(typeHnd, fDoubleAlignHint) == 8)
  2098|     {
  2099| #ifdef DEBUG
  2100|         if (verbose)
  2101|         {
  2102|             printf("Marking struct in V%02i with double align flag\n", varNum);
  2103|         }
  2104| #endif
  2105|         varDsc->lvStructDoubleAlign = 1;
  2106|     }
  2107| #endif // not TARGET_64BIT
  2108|     unsigned classAttribs = info.compCompHnd->getClassAttribs(typeHnd);
  2109|     varDsc->lvOverlappingFields = StructHasOverlappingFields(classAttribs);
  2110|     if (unsafeValueClsCheck && (classAttribs & CORINFO_FLG_UNSAFE_VALUECLASS) && !opts.compDbgEnC)
  2111|     {
  2112|         setNeedsGSSecurityCookie();
  2113|         compGSReorderStackLayout = true;
  2114|         varDsc->lvIsUnsafeBuffer = true;
  2115|     }
  2116| #ifdef DEBUG
  2117|     if (JitConfig.EnableExtraSuperPmiQueries())
  2118|     {
  2119|         makeExtraStructQueries(typeHnd, 2);
  2120|     }
  2121| #endif // DEBUG
  2122| }
  2123| #ifdef DEBUG
  2124| void Compiler::makeExtraStructQueries(CORINFO_CLASS_HANDLE structHandle, int level)
  2125| {
  2126|     if (level <= 0)
  2127|     {
  2128|         return;
  2129|     }
  2130|     assert(structHandle != NO_CLASS_HANDLE);
  2131|     (void)typGetObjLayout(structHandle);
  2132|     DWORD typeFlags = info.compCompHnd->getClassAttribs(structHandle);
  2133|     if (StructHasDontDigFieldsFlagSet(typeFlags))
  2134|     {
  2135|         return;
  2136|     }
  2137|     unsigned fieldCnt = info.compCompHnd->getClassNumInstanceFields(structHandle);
  2138|     impNormStructType(structHandle);
  2139| #ifdef TARGET_ARMARCH
  2140|     GetHfaType(structHandle);
  2141| #endif
  2142|     for (unsigned int i = 0; i < fieldCnt; i++)
  2143|     {
  2144|         CORINFO_FIELD_HANDLE fieldHandle      = info.compCompHnd->getFieldInClass(structHandle, i);
  2145|         unsigned             fldOffset        = info.compCompHnd->getFieldOffset(fieldHandle);
  2146|         CORINFO_CLASS_HANDLE fieldClassHandle = NO_CLASS_HANDLE;
  2147|         CorInfoType          fieldCorType     = info.compCompHnd->getFieldType(fieldHandle, &fieldClassHandle);
  2148|         var_types            fieldVarType     = JITtype2varType(fieldCorType);
  2149|         if (fieldClassHandle != NO_CLASS_HANDLE)
  2150|         {
  2151|             if (varTypeIsStruct(fieldVarType))
  2152|             {
  2153|                 makeExtraStructQueries(fieldClassHandle, level - 1);
  2154|             }
  2155|         }
  2156|     }
  2157| }
  2158| #endif // DEBUG
  2159| void Compiler::lvaSetStructUsedAsVarArg(unsigned varNum)
  2160| {
  2161|     if (GlobalJitOptions::compFeatureHfa && TargetOS::IsWindows)
  2162|     {
  2163| #if defined(TARGET_ARM64)
  2164|         LclVarDsc* varDsc = lvaGetDesc(varNum);
  2165|         varDsc->SetHfaType(TYP_UNDEF);
  2166| #endif // defined(TARGET_ARM64)
  2167|     }
  2168| }
  2169| void Compiler::lvaSetClass(unsigned varNum, CORINFO_CLASS_HANDLE clsHnd, bool isExact)
  2170| {
  2171|     noway_assert(varNum < lvaCount);
  2172|     if (compIsForImportOnly())
  2173|     {
  2174|         return;
  2175|     }
  2176|     if (clsHnd != NO_CLASS_HANDLE && !isExact && JitConfig.JitEnableExactDevirtualization())
  2177|     {
  2178|         CORINFO_CLASS_HANDLE exactClass;
  2179|         if (info.compCompHnd->getExactClasses(clsHnd, 1, &exactClass) == 1)
  2180|         {
  2181|             isExact = true;
  2182|             clsHnd  = exactClass;
  2183|         }
  2184|     }
  2185|     assert(clsHnd != nullptr);
  2186|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  2187|     assert(varDsc->lvType == TYP_REF);
  2188|     assert(varDsc->lvClassHnd == NO_CLASS_HANDLE);
  2189|     assert(!varDsc->lvClassIsExact);
  2190|     JITDUMP("\nlvaSetClass: setting class for V%02i to (%p) %s %s\n", varNum, dspPtr(clsHnd), eeGetClassName(clsHnd),
  2191|             isExact ? " [exact]" : "");
  2192|     varDsc->lvClassHnd     = clsHnd;
  2193|     varDsc->lvClassIsExact = isExact;
  2194| }
  2195| void Compiler::lvaSetClass(unsigned varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)
  2196| {
  2197|     bool                 isExact   = false;
  2198|     bool                 isNonNull = false;
  2199|     CORINFO_CLASS_HANDLE clsHnd    = gtGetClassHandle(tree, &isExact, &isNonNull);
  2200|     if (clsHnd != nullptr)
  2201|     {
  2202|         lvaSetClass(varNum, clsHnd, isExact);
  2203|     }
  2204|     else if (stackHnd != nullptr)
  2205|     {
  2206|         lvaSetClass(varNum, stackHnd);
  2207|     }
  2208|     else
  2209|     {
  2210|         lvaSetClass(varNum, impGetObjectClass());
  2211|     }
  2212| }
  2213| void Compiler::lvaUpdateClass(unsigned varNum, CORINFO_CLASS_HANDLE clsHnd, bool isExact)
  2214| {
  2215|     assert(varNum < lvaCount);
  2216|     if (compIsForImportOnly())
  2217|     {
  2218|         return;
  2219|     }
  2220|     assert(clsHnd != nullptr);
  2221|     LclVarDsc* varDsc = lvaGetDesc(varNum);
  2222|     assert(varDsc->lvType == TYP_REF);
  2223|     assert(varDsc->lvClassHnd != NO_CLASS_HANDLE);
  2224|     assert(varDsc->lvSingleDef);
  2225|     const bool isNewClass   = (clsHnd != varDsc->lvClassHnd);
  2226|     bool       shouldUpdate = false;
  2227|     if (!varDsc->lvClassIsExact && isNewClass)
  2228|     {
  2229|         shouldUpdate = !!info.compCompHnd->isMoreSpecificType(varDsc->lvClassHnd, clsHnd);
  2230|     }
  2231|     else if (isExact && !varDsc->lvClassIsExact && !isNewClass)
  2232|     {
  2233|         shouldUpdate = true;
  2234|     }
  2235| #if DEBUG
  2236|     if (isNewClass || (isExact != varDsc->lvClassIsExact))
  2237|     {
  2238|         JITDUMP("\nlvaUpdateClass:%s Updating class for V%02u", shouldUpdate ? "" : " NOT", varNum);
  2239|         JITDUMP(" from (%p) %s%s", dspPtr(varDsc->lvClassHnd), eeGetClassName(varDsc->lvClassHnd),
  2240|                 varDsc->lvClassIsExact ? " [exact]" : "");
  2241|         JITDUMP(" to (%p) %s%s\n", dspPtr(clsHnd), eeGetClassName(clsHnd), isExact ? " [exact]" : "");
  2242|     }
  2243| #endif // DEBUG
  2244|     if (shouldUpdate)
  2245|     {
  2246|         varDsc->lvClassHnd     = clsHnd;
  2247|         varDsc->lvClassIsExact = isExact;
  2248| #if DEBUG
  2249|         varDsc->lvClassInfoUpdated = true;
  2250| #endif // DEBUG
  2251|     }
  2252|     return;
  2253| }
  2254| void Compiler::lvaUpdateClass(unsigned varNum, GenTree* tree, CORINFO_CLASS_HANDLE stackHnd)
  2255| {
  2256|     bool                 isExact   = false;
  2257|     bool                 isNonNull = false;
  2258|     CORINFO_CLASS_HANDLE clsHnd    = gtGetClassHandle(tree, &isExact, &isNonNull);
  2259|     if (clsHnd != nullptr)
  2260|     {
  2261|         lvaUpdateClass(varNum, clsHnd, isExact);
  2262|     }
  2263|     else if (stackHnd != nullptr)
  2264|     {
  2265|         lvaUpdateClass(varNum, stackHnd);
  2266|     }
  2267| }
  2268| unsigned Compiler::lvaLclSize(unsigned varNum)
  2269| {
  2270|     assert(varNum < lvaCount);
  2271|     var_types varType = lvaTable[varNum].TypeGet();
  2272|     switch (varType)
  2273|     {
  2274|         case TYP_STRUCT:
  2275|         case TYP_BLK:
  2276|             return lvaTable[varNum].lvSize();
  2277|         case TYP_LCLBLK:
  2278| #if FEATURE_FIXED_OUT_ARGS
  2279|             noway_assert(varNum == lvaOutgoingArgSpaceVar);
  2280|             return lvaOutgoingArgSpaceSize;
  2281| #else // FEATURE_FIXED_OUT_ARGS
  2282|             assert(!"Unknown size");
  2283|             NO_WAY("Target doesn't support TYP_LCLBLK");
  2284| #endif // FEATURE_FIXED_OUT_ARGS
  2285|         default: // This must be a primitive var. Fall out of switch statement
  2286|             break;
  2287|     }
  2288| #ifdef TARGET_64BIT
  2289|     if (lvaTable[varNum].lvQuirkToLong)
  2290|     {
  2291|         noway_assert(lvaTable[varNum].IsAddressExposed());
  2292|         return genTypeStSz(TYP_LONG) * sizeof(int); // return 8  (2 * 4)
  2293|     }
  2294| #endif
  2295|     return genTypeStSz(varType) * sizeof(int);
  2296| }
  2297| unsigned Compiler::lvaLclExactSize(unsigned varNum)
  2298| {
  2299|     assert(varNum < lvaCount);
  2300|     var_types varType = lvaTable[varNum].TypeGet();
  2301|     switch (varType)
  2302|     {
  2303|         case TYP_STRUCT:
  2304|         case TYP_BLK:
  2305|             return lvaTable[varNum].lvExactSize;
  2306|         case TYP_LCLBLK:
  2307| #if FEATURE_FIXED_OUT_ARGS
  2308|             noway_assert(lvaOutgoingArgSpaceSize >= 0);
  2309|             noway_assert(varNum == lvaOutgoingArgSpaceVar);
  2310|             return lvaOutgoingArgSpaceSize;
  2311| #else // FEATURE_FIXED_OUT_ARGS
  2312|             assert(!"Unknown size");
  2313|             NO_WAY("Target doesn't support TYP_LCLBLK");
  2314| #endif // FEATURE_FIXED_OUT_ARGS
  2315|         default: // This must be a primitive var. Fall out of switch statement
  2316|             break;
  2317|     }
  2318|     return genTypeSize(varType);
  2319| }
  2320| weight_t BasicBlock::getCalledCount(Compiler* comp)
  2321| {
  2322|     weight_t calledCount = comp->fgCalledCount;
  2323|     if (calledCount == 0)
  2324|     {
  2325|         if (comp->fgIsUsingProfileWeights())
  2326|         {
  2327|             calledCount = 1;
  2328|         }
  2329|         else
  2330|         {
  2331|             calledCount = comp->fgFirstBB->bbWeight;
  2332|             if (calledCount == 0)
  2333|             {
  2334|                 calledCount = BB_UNITY_WEIGHT;
  2335|             }
  2336|         }
  2337|     }
  2338|     return calledCount;
  2339| }
  2340| weight_t BasicBlock::getBBWeight(Compiler* comp)
  2341| {
  2342|     if (this->bbWeight == BB_ZERO_WEIGHT)
  2343|     {
  2344|         return BB_ZERO_WEIGHT;
  2345|     }
  2346|     else
  2347|     {
  2348|         weight_t calledCount = getCalledCount(comp);
  2349|         weight_t fullResult = this->bbWeight * BB_UNITY_WEIGHT / calledCount;
  2350|         return fullResult;
  2351|     }
  2352| }
  2353| class LclVarDsc_SmallCode_Less
  2354| {
  2355|     const LclVarDsc* m_lvaTable;
  2356|     INDEBUG(unsigned m_lvaCount;)
  2357| public:
  2358|     LclVarDsc_SmallCode_Less(const LclVarDsc* lvaTable DEBUGARG(unsigned lvaCount))
  2359|         : m_lvaTable(lvaTable)
  2360| #ifdef DEBUG
  2361|         , m_lvaCount(lvaCount)
  2362| #endif
  2363|     {
  2364|     }
  2365|     bool operator()(unsigned n1, unsigned n2)
  2366|     {
  2367|         assert(n1 < m_lvaCount);
  2368|         assert(n2 < m_lvaCount);
  2369|         const LclVarDsc* dsc1 = &m_lvaTable[n1];
  2370|         const LclVarDsc* dsc2 = &m_lvaTable[n2];
  2371|         assert(dsc1->lvTracked);
  2372|         assert(dsc2->lvTracked);
  2373|         assert(!dsc1->lvRegister);
  2374|         assert(!dsc2->lvRegister);
  2375|         unsigned weight1 = dsc1->lvRefCnt();
  2376|         unsigned weight2 = dsc2->lvRefCnt();
  2377| #ifndef TARGET_ARM
  2378|         const bool isFloat1 = isFloatRegType(dsc1->lvType);
  2379|         const bool isFloat2 = isFloatRegType(dsc2->lvType);
  2380|         if (isFloat1 != isFloat2)
  2381|         {
  2382|             if ((weight2 != 0) && isFloat1)
  2383|             {
  2384|                 return false;
  2385|             }
  2386|             if ((weight1 != 0) && isFloat2)
  2387|             {
  2388|                 return true;
  2389|             }
  2390|         }
  2391| #endif
  2392|         if (weight1 != weight2)
  2393|         {
  2394|             return weight1 > weight2;
  2395|         }
  2396|         if (dsc1->lvRefCntWtd() != dsc2->lvRefCntWtd())
  2397|         {
  2398|             return dsc1->lvRefCntWtd() > dsc2->lvRefCntWtd();
  2399|         }
  2400|         if (weight1 != 0)
  2401|         {
  2402|             if (dsc1->lvIsRegArg)
  2403|             {
  2404|                 weight1 += 2 * BB_UNITY_WEIGHT_UNSIGNED;
  2405|             }
  2406|             if (varTypeIsGC(dsc1->TypeGet()))
  2407|             {
  2408|                 weight1 += BB_UNITY_WEIGHT_UNSIGNED / 2;
  2409|             }
  2410|         }
  2411|         if (weight2 != 0)
  2412|         {
  2413|             if (dsc2->lvIsRegArg)
  2414|             {
  2415|                 weight2 += 2 * BB_UNITY_WEIGHT_UNSIGNED;
  2416|             }
  2417|             if (varTypeIsGC(dsc2->TypeGet()))
  2418|             {
  2419|                 weight2 += BB_UNITY_WEIGHT_UNSIGNED / 2;
  2420|             }
  2421|         }
  2422|         if (weight1 != weight2)
  2423|         {
  2424|             return weight1 > weight2;
  2425|         }
  2426|         return dsc1 < dsc2;
  2427|     }
  2428| };
  2429| class LclVarDsc_BlendedCode_Less
  2430| {
  2431|     const LclVarDsc* m_lvaTable;
  2432|     INDEBUG(unsigned m_lvaCount;)
  2433| public:
  2434|     LclVarDsc_BlendedCode_Less(const LclVarDsc* lvaTable DEBUGARG(unsigned lvaCount))
  2435|         : m_lvaTable(lvaTable)
  2436| #ifdef DEBUG
  2437|         , m_lvaCount(lvaCount)
  2438| #endif
  2439|     {
  2440|     }
  2441|     bool operator()(unsigned n1, unsigned n2)
  2442|     {
  2443|         assert(n1 < m_lvaCount);
  2444|         assert(n2 < m_lvaCount);
  2445|         const LclVarDsc* dsc1 = &m_lvaTable[n1];
  2446|         const LclVarDsc* dsc2 = &m_lvaTable[n2];
  2447|         assert(dsc1->lvTracked);
  2448|         assert(dsc2->lvTracked);
  2449|         assert(!dsc1->lvRegister);
  2450|         assert(!dsc2->lvRegister);
  2451|         weight_t weight1 = dsc1->lvRefCntWtd();
  2452|         weight_t weight2 = dsc2->lvRefCntWtd();
  2453| #ifndef TARGET_ARM
  2454|         const bool isFloat1 = isFloatRegType(dsc1->lvType);
  2455|         const bool isFloat2 = isFloatRegType(dsc2->lvType);
  2456|         if (isFloat1 != isFloat2)
  2457|         {
  2458|             if (!Compiler::fgProfileWeightsEqual(weight2, 0) && isFloat1)
  2459|             {
  2460|                 return false;
  2461|             }
  2462|             if (!Compiler::fgProfileWeightsEqual(weight1, 0) && isFloat2)
  2463|             {
  2464|                 return true;
  2465|             }
  2466|         }
  2467| #endif
  2468|         if (!Compiler::fgProfileWeightsEqual(weight1, 0) && dsc1->lvIsRegArg)
  2469|         {
  2470|             weight1 += 2 * BB_UNITY_WEIGHT;
  2471|         }
  2472|         if (!Compiler::fgProfileWeightsEqual(weight2, 0) && dsc2->lvIsRegArg)
  2473|         {
  2474|             weight2 += 2 * BB_UNITY_WEIGHT;
  2475|         }
  2476|         if (!Compiler::fgProfileWeightsEqual(weight1, weight2))
  2477|         {
  2478|             return weight1 > weight2;
  2479|         }
  2480|         if (dsc1->lvRefCnt() != dsc2->lvRefCnt())
  2481|         {
  2482|             return dsc1->lvRefCnt() > dsc2->lvRefCnt();
  2483|         }
  2484|         if (varTypeIsGC(dsc1->TypeGet()) != varTypeIsGC(dsc2->TypeGet()))
  2485|         {
  2486|             return varTypeIsGC(dsc1->TypeGet());
  2487|         }
  2488|         return dsc1 < dsc2;
  2489|     }
  2490| };
  2491| /*****************************************************************************
  2492|  *
  2493|  *  Sort the local variable table by refcount and assign tracking indices.
  2494|  */
  2495| void Compiler::lvaSortByRefCount()
  2496| {
  2497|     lvaTrackedCount             = 0;
  2498|     lvaTrackedCountInSizeTUnits = 0;
  2499| #ifdef DEBUG
  2500|     VarSetOps::AssignNoCopy(this, lvaTrackedVars, VarSetOps::MakeEmpty(this));
  2501| #endif
  2502|     if (lvaCount == 0)
  2503|     {
  2504|         return;
  2505|     }
  2506|     /* We'll sort the variables by ref count - allocate the sorted table */
  2507|     if (lvaTrackedToVarNumSize < lvaCount)
  2508|     {
  2509|         lvaTrackedToVarNumSize = lvaCount;
  2510|         lvaTrackedToVarNum     = new (getAllocator(CMK_LvaTable)) unsigned[lvaTrackedToVarNumSize];
  2511|     }
  2512|     unsigned  trackedCount = 0;
  2513|     unsigned* tracked      = lvaTrackedToVarNum;
  2514|     for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++)
  2515|     {
  2516|         LclVarDsc* varDsc = lvaGetDesc(lclNum);
  2517|         varDsc->lvTracked = 1;
  2518|         if (varDsc->lvRefCnt() == 0)
  2519|         {
  2520|             varDsc->lvTracked = 0;
  2521|             varDsc->setLvRefCntWtd(0);
  2522|         }
  2523| #if !defined(TARGET_64BIT)
  2524|         if (varTypeIsLong(varDsc) && varDsc->lvPromoted)
  2525|         {
  2526|             varDsc->lvTracked = 0;
  2527|         }
  2528| #endif // !defined(TARGET_64BIT)
  2529|         if (varDsc->IsAddressExposed())
  2530|         {
  2531|             varDsc->lvTracked = 0;
  2532|             assert(varDsc->lvType != TYP_STRUCT ||
  2533|                    varDsc->lvDoNotEnregister); // For structs, should have set this when we set m_addrExposed.
  2534|         }
  2535|         if (varTypeIsStruct(varDsc))
  2536|         {
  2537|             if (varDsc->lvPromoted)
  2538|             {
  2539|                 varDsc->lvTracked = 0;
  2540|             }
  2541|             else if (!varDsc->IsEnregisterableType())
  2542|             {
  2543|                 lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NotRegSizeStruct));
  2544|             }
  2545|             else if (varDsc->lvType == TYP_STRUCT)
  2546|             {
  2547|                 if (!varDsc->lvRegStruct && !compEnregStructLocals())
  2548|                 {
  2549|                     lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::DontEnregStructs));
  2550|                 }
  2551|                 else if (varDsc->lvIsMultiRegArgOrRet())
  2552|                 {
  2553|                     lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::IsStructArg));
  2554|                 }
  2555| #if defined(TARGET_ARM)
  2556|                 else if (varDsc->lvIsParam)
  2557|                 {
  2558|                     lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::IsStructArg));
  2559|                 }
  2560| #endif // TARGET_ARM
  2561|             }
  2562|         }
  2563|         if (varDsc->lvIsStructField && (lvaGetParentPromotionType(lclNum) != PROMOTION_TYPE_INDEPENDENT))
  2564|         {
  2565|             lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::DepField));
  2566|         }
  2567|         if (varDsc->lvPinned)
  2568|         {
  2569|             varDsc->lvTracked = 0;
  2570| #ifdef JIT32_GCENCODER
  2571|             lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::PinningRef));
  2572| #endif
  2573|         }
  2574|         if (opts.MinOpts() && !JitConfig.JitMinOptsTrackGCrefs() && varTypeIsGC(varDsc->TypeGet()))
  2575|         {
  2576|             varDsc->lvTracked = 0;
  2577|             lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::MinOptsGC));
  2578|         }
  2579|         if (!compEnregLocals())
  2580|         {
  2581|             lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::NoRegVars));
  2582|         }
  2583| #if defined(JIT32_GCENCODER) && defined(FEATURE_EH_FUNCLETS)
  2584|         if (lvaIsOriginalThisArg(lclNum) && (info.compMethodInfo->options & CORINFO_GENERICS_CTXT_FROM_THIS) != 0)
  2585|         {
  2586|             varDsc->lvTracked = 0;
  2587|         }
  2588| #endif
  2589|         if (opts.MinOpts() && compHndBBtabCount > 0)
  2590|         {
  2591|             lvaSetVarDoNotEnregister(lclNum DEBUGARG(DoNotEnregisterReason::LiveInOutOfHandler));
  2592|         }
  2593|         else
  2594|         {
  2595|             var_types type = genActualType(varDsc->TypeGet());
  2596|             switch (type)
  2597|             {
  2598|                 case TYP_FLOAT:
  2599|                 case TYP_DOUBLE:
  2600|                 case TYP_INT:
  2601|                 case TYP_LONG:
  2602|                 case TYP_REF:
  2603|                 case TYP_BYREF:
  2604| #ifdef FEATURE_SIMD
  2605|                 case TYP_SIMD8:
  2606|                 case TYP_SIMD12:
  2607|                 case TYP_SIMD16:
  2608|                 case TYP_SIMD32:
  2609| #endif // FEATURE_SIMD
  2610|                 case TYP_STRUCT:
  2611|                     break;
  2612|                 case TYP_UNDEF:
  2613|                 case TYP_UNKNOWN:
  2614|                     noway_assert(!"lvType not set correctly");
  2615|                     varDsc->lvType = TYP_INT;
  2616|                     FALLTHROUGH;
  2617|                 default:
  2618|                     varDsc->lvTracked = 0;
  2619|             }
  2620|         }
  2621|         if (varDsc->lvTracked)
  2622|         {
  2623|             tracked[trackedCount++] = lclNum;
  2624|         }
  2625|     }
  2626|     if (compCodeOpt() == SMALL_CODE)
  2627|     {
  2628|         jitstd::sort(tracked, tracked + trackedCount, LclVarDsc_SmallCode_Less(lvaTable DEBUGARG(lvaCount)));
  2629|     }
  2630|     else
  2631|     {
  2632|         jitstd::sort(tracked, tracked + trackedCount, LclVarDsc_BlendedCode_Less(lvaTable DEBUGARG(lvaCount)));
  2633|     }
  2634|     lvaTrackedCount = min((unsigned)JitConfig.JitMaxLocalsToTrack(), trackedCount);
  2635|     JITDUMP("Tracked variable (%u out of %u) table:\n", lvaTrackedCount, lvaCount);
  2636|     for (unsigned varIndex = 0; varIndex < lvaTrackedCount; varIndex++)
  2637|     {
  2638|         LclVarDsc* varDsc = lvaGetDesc(tracked[varIndex]);
  2639|         assert(varDsc->lvTracked);
  2640|         varDsc->lvVarIndex = static_cast<unsigned short>(varIndex);
  2641|         INDEBUG(if (verbose) { gtDispLclVar(tracked[varIndex]); })
  2642|         JITDUMP(" [%6s]: refCnt = %4u, refCntWtd = %6s\n", varTypeName(varDsc->TypeGet()), varDsc->lvRefCnt(),
  2643|                 refCntWtd2str(varDsc->lvRefCntWtd()));
  2644|     }
  2645|     JITDUMP("\n");
  2646|     for (unsigned varIndex = lvaTrackedCount; varIndex < trackedCount; varIndex++)
  2647|     {
  2648|         LclVarDsc* varDsc = lvaGetDesc(tracked[varIndex]);
  2649|         assert(varDsc->lvTracked);
  2650|         varDsc->lvTracked = 0;
  2651|     }
  2652|     lvaCurEpoch++;
  2653|     lvaTrackedCountInSizeTUnits =
  2654|         roundUp((unsigned)lvaTrackedCount, (unsigned)(sizeof(size_t) * 8)) / unsigned(sizeof(size_t) * 8);
  2655| #ifdef DEBUG
  2656|     VarSetOps::AssignNoCopy(this, lvaTrackedVars, VarSetOps::MakeFull(this));
  2657| #endif
  2658| }
  2659| /*****************************************************************************
  2660|  *
  2661|  *  This is called by lvaMarkLclRefs to disqualify a variable from being
  2662|  *  considered by optAddCopies()
  2663|  */
  2664| void LclVarDsc::lvaDisqualifyVar()
  2665| {
  2666|     this->lvDisqualify = true;
  2667|     this->lvSingleDef  = false;
  2668|     this->lvDefStmt    = nullptr;
  2669| }
  2670| #ifdef FEATURE_SIMD
  2671| var_types LclVarDsc::GetSimdBaseType() const
  2672| {
  2673|     CorInfoType simdBaseJitType = GetSimdBaseJitType();
  2674|     if (simdBaseJitType == CORINFO_TYPE_UNDEF)
  2675|     {
  2676|         return TYP_UNKNOWN;
  2677|     }
  2678|     return JitType2PreciseVarType(simdBaseJitType);
  2679| }
  2680| #endif // FEATURE_SIMD
  2681| unsigned LclVarDsc::lvSize() const // Size needed for storage representation. Only used for structs or TYP_BLK.
  2682| {
  2683|     assert(varTypeIsStruct(lvType) || (lvType == TYP_BLK) || (lvPromoted && lvUnusedStruct));
  2684|     if (lvIsParam)
  2685|     {
  2686|         assert(varTypeIsStruct(lvType));
  2687|         const bool     isFloatHfa       = (lvIsHfa() && (GetHfaType() == TYP_FLOAT));
  2688|         const unsigned argSizeAlignment = Compiler::eeGetArgSizeAlignment(lvType, isFloatHfa);
  2689|         return roundUp(lvExactSize, argSizeAlignment);
  2690|     }
  2691| #if defined(FEATURE_SIMD) && !defined(TARGET_64BIT)
  2692|     if (lvType == TYP_SIMD12)
  2693|     {
  2694|         assert(!lvIsParam);
  2695|         assert(lvExactSize == 12);
  2696|         return 16;
  2697|     }
  2698| #endif // defined(FEATURE_SIMD) && !defined(TARGET_64BIT)
  2699|     return roundUp(lvExactSize, TARGET_POINTER_SIZE);
  2700| }
  2701| /**********************************************************************************
  2702| * Get stack size of the varDsc.
  2703| */
  2704| size_t LclVarDsc::lvArgStackSize() const
  2705| {
  2706|     assert(!this->lvIsRegArg);
  2707|     size_t stackSize = 0;
  2708|     if (varTypeIsStruct(this))
  2709|     {
  2710| #if defined(WINDOWS_AMD64_ABI)
  2711|         stackSize = TARGET_POINTER_SIZE;
  2712| #elif defined(TARGET_ARM64) || defined(UNIX_AMD64_ABI) || defined(TARGET_LOONGARCH64)
  2713|         stackSize = this->lvSize();
  2714| #if defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  2715|         if ((stackSize > TARGET_POINTER_SIZE * 2) && (!this->lvIsHfa()))
  2716|         {
  2717|             stackSize = TARGET_POINTER_SIZE;
  2718|         }
  2719| #endif // defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  2720| #else // !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI !TARGET_LOONGARCH64
  2721|         NYI("Unsupported target.");
  2722|         unreached();
  2723| #endif //  !TARGET_ARM64 !WINDOWS_AMD64_ABI !UNIX_AMD64_ABI
  2724|     }
  2725|     else
  2726|     {
  2727|         stackSize = TARGET_POINTER_SIZE;
  2728|     }
  2729|     return stackSize;
  2730| }
  2731| var_types LclVarDsc::GetRegisterType(const GenTreeLclVarCommon* tree) const
  2732| {
  2733|     var_types targetType = tree->TypeGet();
  2734|     if (targetType == TYP_STRUCT)
  2735|     {
  2736|         ClassLayout* layout;
  2737|         if (tree->OperIs(GT_LCL_FLD, GT_STORE_LCL_FLD))
  2738|         {
  2739|             layout = tree->AsLclFld()->GetLayout();
  2740|         }
  2741|         else
  2742|         {
  2743|             assert((TypeGet() == TYP_STRUCT) && tree->OperIs(GT_LCL_VAR, GT_STORE_LCL_VAR));
  2744|             layout = GetLayout();
  2745|         }
  2746|         targetType = layout->GetRegisterType();
  2747|     }
  2748| #ifdef DEBUG
  2749|     if ((targetType != TYP_UNDEF) && tree->OperIs(GT_STORE_LCL_VAR) && lvNormalizeOnStore())
  2750|     {
  2751|         const bool phiStore = (tree->gtGetOp1()->OperIsNonPhiLocal() == false);
  2752|         assert(phiStore || targetType == genActualType(TypeGet()));
  2753|     }
  2754| #endif
  2755|     return targetType;
  2756| }
  2757| var_types LclVarDsc::GetRegisterType() const
  2758| {
  2759|     if (TypeGet() != TYP_STRUCT)
  2760|     {
  2761| #if !defined(TARGET_64BIT)
  2762|         if (TypeGet() == TYP_LONG)
  2763|         {
  2764|             return TYP_UNDEF;
  2765|         }
  2766| #endif
  2767|         return TypeGet();
  2768|     }
  2769|     assert(m_layout != nullptr);
  2770|     return m_layout->GetRegisterType();
  2771| }
  2772| var_types LclVarDsc::GetStackSlotHomeType() const
  2773| {
  2774|     if (varTypeIsSmall(TypeGet()))
  2775|     {
  2776|         if (compMacOsArm64Abi() && lvIsParam && !lvIsRegArg)
  2777|         {
  2778|             return GetRegisterType();
  2779|         }
  2780|         if (lvIsOSRLocal && lvIsStructField)
  2781|         {
  2782| #if defined(TARGET_X86)
  2783|             unreached();
  2784| #else
  2785|             return GetRegisterType();
  2786| #endif
  2787|         }
  2788|     }
  2789|     return genActualType(GetRegisterType());
  2790| }
  2791| bool LclVarDsc::CanBeReplacedWithItsField(Compiler* comp) const
  2792| {
  2793|     if (!lvPromoted)
  2794|     {
  2795|         return false;
  2796|     }
  2797|     if (comp->lvaGetPromotionType(this) != Compiler::PROMOTION_TYPE_INDEPENDENT)
  2798|     {
  2799|         return false;
  2800|     }
  2801|     if (lvFieldCnt != 1)
  2802|     {
  2803|         return false;
  2804|     }
  2805|     if (lvContainsHoles)
  2806|     {
  2807|         return false;
  2808|     }
  2809| #if defined(FEATURE_SIMD)
  2810|     LclVarDsc* fieldDsc = comp->lvaGetDesc(lvFieldLclStart);
  2811|     if (varTypeIsSIMD(fieldDsc))
  2812|     {
  2813|         return false;
  2814|     }
  2815| #endif // FEATURE_SIMD
  2816|     return true;
  2817| }
  2818| void Compiler::lvaMarkLclRefs(GenTree* tree, BasicBlock* block, Statement* stmt, bool isRecompute)
  2819| {
  2820|     const weight_t weight = block->getBBWeight(this);
  2821|     /* Is this a call to unmanaged code ? */
  2822|     if (tree->IsCall() && compMethodRequiresPInvokeFrame())
  2823|     {
  2824|         assert((!opts.ShouldUsePInvokeHelpers()) || (info.compLvFrameListRoot == BAD_VAR_NUM));
  2825|         if (!opts.ShouldUsePInvokeHelpers())
  2826|         {
  2827|             /* Get the special variable descriptor */
  2828|             LclVarDsc* varDsc = lvaGetDesc(info.compLvFrameListRoot);
  2829|             /* Increment the ref counts twice */
  2830|             varDsc->incRefCnts(weight, this);
  2831|             varDsc->incRefCnts(weight, this);
  2832|         }
  2833|     }
  2834|     if (!isRecompute)
  2835|     {
  2836|         /* Is this an assignment? */
  2837|         if (tree->OperIs(GT_ASG))
  2838|         {
  2839|             GenTree* op1 = tree->AsOp()->gtOp1;
  2840|             GenTree* op2 = tree->AsOp()->gtOp2;
  2841|             /* Is this an assignment to a local variable? */
  2842|             if (op1->gtOper == GT_LCL_VAR)
  2843|             {
  2844|                 LclVarDsc* varDsc = lvaGetDesc(op1->AsLclVarCommon());
  2845|                 if (varDsc->lvPinned && varDsc->lvAllDefsAreNoGc)
  2846|                 {
  2847|                     if (!op2->IsNotGcDef())
  2848|                     {
  2849|                         varDsc->lvAllDefsAreNoGc = false;
  2850|                     }
  2851|                 }
  2852|                 if (op2->gtType != TYP_BOOL)
  2853|                 {
  2854|                     /* Only simple assignments allowed for booleans */
  2855|                     if (tree->gtOper != GT_ASG)
  2856|                     {
  2857|                         goto NOT_BOOL;
  2858|                     }
  2859|                     /* Is the RHS clearly a boolean value? */
  2860|                     switch (op2->gtOper)
  2861|                     {
  2862|                         case GT_CNS_INT:
  2863|                             if (op2->AsIntCon()->gtIconVal == 0)
  2864|                             {
  2865|                                 break;
  2866|                             }
  2867|                             if (op2->AsIntCon()->gtIconVal == 1)
  2868|                             {
  2869|                                 break;
  2870|                             }
  2871|                             FALLTHROUGH;
  2872|                         default:
  2873|                             if (op2->OperIsCompare())
  2874|                             {
  2875|                                 break;
  2876|                             }
  2877|                         NOT_BOOL:
  2878|                             varDsc->lvIsBoolean = false;
  2879|                             break;
  2880|                     }
  2881|                 }
  2882|             }
  2883|         }
  2884|     }
  2885|     if (tree->OperIsLocalAddr())
  2886|     {
  2887|         LclVarDsc* varDsc = lvaGetDesc(tree->AsLclVarCommon());
  2888|         assert(varDsc->IsAddressExposed());
  2889|         varDsc->incRefCnts(weight, this);
  2890|         return;
  2891|     }
  2892|     if ((tree->gtOper != GT_LCL_VAR) && (tree->gtOper != GT_LCL_FLD))
  2893|     {
  2894|         return;
  2895|     }
  2896|     /* This must be a local variable reference */
  2897|     if ((tree->gtFlags & GTF_VAR_CONTEXT) != 0)
  2898|     {
  2899|         assert(tree->OperIs(GT_LCL_VAR));
  2900|         if (!lvaGenericsContextInUse)
  2901|         {
  2902|             JITDUMP("-- generic context in use at [%06u]\n", dspTreeID(tree));
  2903|             lvaGenericsContextInUse = true;
  2904|         }
  2905|     }
  2906|     assert((tree->gtOper == GT_LCL_VAR) || (tree->gtOper == GT_LCL_FLD));
  2907|     unsigned lclNum = tree->AsLclVarCommon()->GetLclNum();
  2908|     LclVarDsc* varDsc = lvaGetDesc(lclNum);
  2909|     /* Increment the reference counts */
  2910|     varDsc->incRefCnts(weight, this);
  2911| #ifdef DEBUG
  2912|     if (varDsc->lvIsStructField)
  2913|     {
  2914|         LclVarDsc* parentStruct = lvaGetDesc(varDsc->lvParentLcl);
  2915|         assert(!parentStruct->lvUndoneStructPromotion);
  2916|     }
  2917| #endif
  2918|     if (!isRecompute)
  2919|     {
  2920|         if (lvaVarAddrExposed(lclNum))
  2921|         {
  2922|             varDsc->lvIsBoolean      = false;
  2923|             varDsc->lvAllDefsAreNoGc = false;
  2924|         }
  2925|         if (tree->gtOper == GT_LCL_FLD)
  2926|         {
  2927|             varDsc->lvaDisqualifyVar();
  2928|             return;
  2929|         }
  2930|         if (fgDomsComputed && IsDominatedByExceptionalEntry(block))
  2931|         {
  2932|             SetVolatileHint(varDsc);
  2933|         }
  2934|         /* Record if the variable has a single def or not */
  2935|         if (!varDsc->lvDisqualify) // If this variable is already disqualified, we can skip this
  2936|         {
  2937|             if (tree->gtFlags & GTF_VAR_DEF) // Is this is a def of our variable
  2938|             {
  2939|                 /*
  2940|                    If we have one of these cases:
  2941|                        1.    We have already seen a definition (i.e lvSingleDef is true)
  2942|                        2. or info.CompInitMem is true (thus this would be the second definition)
  2943|                        3. or we have an assignment inside QMARK-COLON trees
  2944|                        4. or we have an update form of assignment (i.e. +=, -=, *=)
  2945|                    Then we must disqualify this variable for use in optAddCopies()
  2946|                    Note that all parameters start out with lvSingleDef set to true
  2947|                 */
  2948|                 if ((varDsc->lvSingleDef == true) || (info.compInitMem == true) || (tree->gtFlags & GTF_COLON_COND) ||
  2949|                     (tree->gtFlags & GTF_VAR_USEASG))
  2950|                 {
  2951|                     varDsc->lvaDisqualifyVar();
  2952|                 }
  2953|                 else
  2954|                 {
  2955|                     varDsc->lvSingleDef = true;
  2956|                     varDsc->lvDefStmt   = stmt;
  2957|                 }
  2958|             }
  2959|             else // otherwise this is a ref of our variable
  2960|             {
  2961|                 if (BlockSetOps::MayBeUninit(varDsc->lvRefBlks))
  2962|                 {
  2963|                     BlockSetOps::AssignNoCopy(this, varDsc->lvRefBlks, BlockSetOps::MakeEmpty(this));
  2964|                 }
  2965|                 BlockSetOps::AddElemD(this, varDsc->lvRefBlks, block->bbNum);
  2966|             }
  2967|         }
  2968|         if (!varDsc->lvDisqualifySingleDefRegCandidate) // If this var is already disqualified, we can skip this
  2969|         {
  2970|             if (tree->gtFlags & GTF_VAR_DEF) // Is this is a def of our variable
  2971|             {
  2972|                 bool bbInALoop  = (block->bbFlags & BBF_BACKWARD_JUMP) != 0;
  2973|                 bool bbIsReturn = block->bbJumpKind == BBJ_RETURN;
  2974|                 bool needsExplicitZeroInit = fgVarNeedsExplicitZeroInit(lclNum, bbInALoop, bbIsReturn);
  2975|                 if (varDsc->lvSingleDefRegCandidate || needsExplicitZeroInit)
  2976|                 {
  2977| #ifdef DEBUG
  2978|                     if (needsExplicitZeroInit)
  2979|                     {
  2980|                         varDsc->lvSingleDefDisqualifyReason = 'Z';
  2981|                         JITDUMP("V%02u needs explicit zero init. Disqualified as a single-def register candidate.\n",
  2982|                                 lclNum);
  2983|                     }
  2984|                     else
  2985|                     {
  2986|                         varDsc->lvSingleDefDisqualifyReason = 'M';
  2987|                         JITDUMP("V%02u has multiple definitions. Disqualified as a single-def register candidate.\n",
  2988|                                 lclNum);
  2989|                     }
  2990| #endif // DEBUG
  2991|                     varDsc->lvSingleDefRegCandidate           = false;
  2992|                     varDsc->lvDisqualifySingleDefRegCandidate = true;
  2993|                 }
  2994|                 else if (!varDsc->lvDoNotEnregister)
  2995|                 {
  2996|                     CLANG_FORMAT_COMMENT_ANCHOR;
  2997| #if FEATURE_PARTIAL_SIMD_CALLEE_SAVE
  2998|                     if (!varTypeNeedsPartialCalleeSave(varDsc->GetRegisterType()))
  2999| #endif
  3000|                     {
  3001|                         varDsc->lvSingleDefRegCandidate = true;
  3002|                         JITDUMP("Marking EH Var V%02u as a register candidate.\n", lclNum);
  3003|                     }
  3004|                 }
  3005|             }
  3006|         }
  3007|         bool allowStructs = false;
  3008| #ifdef UNIX_AMD64_ABI
  3009|         allowStructs = varTypeIsStruct(varDsc);
  3010| #endif // UNIX_AMD64_ABI
  3011|         /* Variables must be used as the same type throughout the method */
  3012|         noway_assert(varDsc->lvType == TYP_UNDEF || tree->gtType == TYP_UNKNOWN || allowStructs ||
  3013|                      genActualType(varDsc->TypeGet()) == genActualType(tree->gtType) ||
  3014|                      (tree->gtType == TYP_BYREF && varDsc->TypeGet() == TYP_I_IMPL) ||
  3015|                      (tree->gtType == TYP_I_IMPL && varDsc->TypeGet() == TYP_BYREF) || (tree->gtFlags & GTF_VAR_CAST) ||
  3016|                      (varTypeIsFloating(varDsc) && varTypeIsFloating(tree)) ||
  3017|                      (varTypeIsStruct(varDsc) == varTypeIsStruct(tree)));
  3018|         /* Remember the type of the reference */
  3019|         if (tree->gtType == TYP_UNKNOWN || varDsc->lvType == TYP_UNDEF)
  3020|         {
  3021|             varDsc->lvType = tree->gtType;
  3022|             noway_assert(genActualType(varDsc->TypeGet()) == tree->gtType); // no truncation
  3023|         }
  3024| #ifdef DEBUG
  3025|         if (tree->gtFlags & GTF_VAR_CAST)
  3026|         {
  3027|             if (tree->TypeGet() != TYP_STRUCT)
  3028|             {
  3029|                 unsigned treeSize = genTypeSize(tree->TypeGet());
  3030|                 unsigned varSize  = genTypeSize(varDsc->TypeGet());
  3031|                 if (varDsc->TypeGet() == TYP_STRUCT)
  3032|                 {
  3033|                     varSize = varDsc->lvSize();
  3034|                 }
  3035|                 assert(treeSize <= varSize);
  3036|             }
  3037|         }
  3038| #endif
  3039|     }
  3040| }
  3041| bool Compiler::IsDominatedByExceptionalEntry(BasicBlock* block)
  3042| {
  3043|     assert(fgDomsComputed);
  3044|     return block->IsDominatedByExceptionalEntryFlag();
  3045| }
  3046| void Compiler::SetVolatileHint(LclVarDsc* varDsc)
  3047| {
  3048|     varDsc->lvVolatileHint = true;
  3049| }
  3050| void Compiler::lvaMarkLocalVars(BasicBlock* block, bool isRecompute)
  3051| {
  3052|     class MarkLocalVarsVisitor final : public GenTreeVisitor<MarkLocalVarsVisitor>
  3053|     {
  3054|     private:
  3055|         BasicBlock* m_block;
  3056|         Statement*  m_stmt;
  3057|         bool        m_isRecompute;
  3058|     public:
  3059|         enum
  3060|         {
  3061|             DoPreOrder = true,
  3062|         };
  3063|         MarkLocalVarsVisitor(Compiler* compiler, BasicBlock* block, Statement* stmt, bool isRecompute)
  3064|             : GenTreeVisitor<MarkLocalVarsVisitor>(compiler), m_block(block), m_stmt(stmt), m_isRecompute(isRecompute)
  3065|         {
  3066|         }
  3067|         Compiler::fgWalkResult PreOrderVisit(GenTree** use, GenTree* user)
  3068|         {
  3069|             assert(!m_isRecompute);
  3070|             m_compiler->lvaMarkLclRefs(*use, m_block, m_stmt, m_isRecompute);
  3071|             return WALK_CONTINUE;
  3072|         }
  3073|     };
  3074|     JITDUMP("\n*** %s local variables in block " FMT_BB " (weight=%s)\n", isRecompute ? "recomputing" : "marking",
  3075|             block->bbNum, refCntWtd2str(block->getBBWeight(this)));
  3076|     for (Statement* const stmt : block->NonPhiStatements())
  3077|     {
  3078|         MarkLocalVarsVisitor visitor(this, block, stmt, isRecompute);
  3079|         DISPSTMT(stmt);
  3080|         visitor.WalkTree(stmt->GetRootNodePointer(), nullptr);
  3081|     }
  3082| }
  3083| PhaseStatus Compiler::lvaMarkLocalVars()
  3084| {
  3085|     JITDUMP("\n*************** In lvaMarkLocalVars()");
  3086|     if (compMethodRequiresPInvokeFrame())
  3087|     {
  3088|         assert((!opts.ShouldUsePInvokeHelpers()) || (info.compLvFrameListRoot == BAD_VAR_NUM));
  3089|         if (!opts.ShouldUsePInvokeHelpers())
  3090|         {
  3091|             noway_assert(info.compLvFrameListRoot >= info.compLocalsCount && info.compLvFrameListRoot < lvaCount);
  3092|         }
  3093|     }
  3094|     unsigned const lvaCountOrig = lvaCount;
  3095| #if !defined(FEATURE_EH_FUNCLETS)
  3096|     if (ehNeedsShadowSPslots())
  3097|     {
  3098|         unsigned slotsNeeded = 1;
  3099|         unsigned handlerNestingLevel = ehMaxHndNestingCount;
  3100|         if (opts.compDbgEnC && (handlerNestingLevel < (unsigned)MAX_EnC_HANDLER_NESTING_LEVEL))
  3101|             handlerNestingLevel = (unsigned)MAX_EnC_HANDLER_NESTING_LEVEL;
  3102|         slotsNeeded += handlerNestingLevel;
  3103|         slotsNeeded++;
  3104|         slotsNeeded++;
  3105|         lvaShadowSPslotsVar           = lvaGrabTempWithImplicitUse(false DEBUGARG("lvaShadowSPslotsVar"));
  3106|         LclVarDsc* shadowSPslotsVar   = lvaGetDesc(lvaShadowSPslotsVar);
  3107|         shadowSPslotsVar->lvType      = TYP_BLK;
  3108|         shadowSPslotsVar->lvExactSize = (slotsNeeded * TARGET_POINTER_SIZE);
  3109|     }
  3110| #endif // !FEATURE_EH_FUNCLETS
  3111|     if (!IsTargetAbi(CORINFO_NATIVEAOT_ABI))
  3112|     {
  3113| #if defined(FEATURE_EH_FUNCLETS)
  3114|         if (ehNeedsPSPSym())
  3115|         {
  3116|             lvaPSPSym            = lvaGrabTempWithImplicitUse(false DEBUGARG("PSPSym"));
  3117|             LclVarDsc* lclPSPSym = lvaGetDesc(lvaPSPSym);
  3118|             lclPSPSym->lvType    = TYP_I_IMPL;
  3119|             lvaSetVarDoNotEnregister(lvaPSPSym DEBUGARG(DoNotEnregisterReason::VMNeedsStackAddr));
  3120|         }
  3121| #endif // FEATURE_EH_FUNCLETS
  3122| #ifdef JIT32_GCENCODER
  3123|         if (compLocallocUsed)
  3124|         {
  3125|             lvaLocAllocSPvar         = lvaGrabTempWithImplicitUse(false DEBUGARG("LocAllocSPvar"));
  3126|             LclVarDsc* locAllocSPvar = lvaGetDesc(lvaLocAllocSPvar);
  3127|             locAllocSPvar->lvType    = TYP_I_IMPL;
  3128|         }
  3129| #endif // JIT32_GCENCODER
  3130|     }
  3131|     lvaRefCountState = RCS_NORMAL;
  3132| #if defined(DEBUG)
  3133|     const bool setSlotNumbers = true;
  3134| #else
  3135|     const bool setSlotNumbers = opts.compScopeInfo && (info.compVarScopesCount > 0);
  3136| #endif // defined(DEBUG)
  3137|     const bool isRecompute = false;
  3138|     lvaComputeRefCounts(isRecompute, setSlotNumbers);
  3139|     if (!PreciseRefCountsRequired())
  3140|     {
  3141|         return (lvaCount != lvaCountOrig) ? PhaseStatus::MODIFIED_EVERYTHING : PhaseStatus::MODIFIED_NOTHING;
  3142|     }
  3143|     const bool reportParamTypeArg = lvaReportParamTypeArg();
  3144|     if (lvaKeepAliveAndReportThis())
  3145|     {
  3146|         lvaGetDesc(0u)->lvImplicitlyReferenced = reportParamTypeArg;
  3147|     }
  3148|     else if (lvaReportParamTypeArg())
  3149|     {
  3150|         assert(info.compTypeCtxtArg != (int)BAD_VAR_NUM);
  3151|         lvaGetDesc(info.compTypeCtxtArg)->lvImplicitlyReferenced = reportParamTypeArg;
  3152|     }
  3153|     assert(PreciseRefCountsRequired());
  3154|     return (lvaCount != lvaCountOrig) ? PhaseStatus::MODIFIED_EVERYTHING : PhaseStatus::MODIFIED_NOTHING;
  3155| }
  3156| void Compiler::lvaComputeRefCounts(bool isRecompute, bool setSlotNumbers)
  3157| {
  3158|     JITDUMP("\n*** lvaComputeRefCounts ***\n");
  3159|     unsigned   lclNum = 0;
  3160|     LclVarDsc* varDsc = nullptr;
  3161|     if (!PreciseRefCountsRequired())
  3162|     {
  3163|         if (isRecompute)
  3164|         {
  3165| #if defined(DEBUG)
  3166|             for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  3167|             {
  3168|                 const bool isSpecialVarargsParam = varDsc->lvIsParam && raIsVarargsStackArg(lclNum);
  3169|                 if (isSpecialVarargsParam)
  3170|                 {
  3171|                     assert(varDsc->lvRefCnt() == 0);
  3172|                 }
  3173|                 else
  3174|                 {
  3175|                     assert(varDsc->lvImplicitlyReferenced);
  3176|                 }
  3177|                 assert(!varDsc->lvTracked);
  3178|             }
  3179| #endif // defined (DEBUG)
  3180|             return;
  3181|         }
  3182|         for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  3183|         {
  3184|             varDsc->setLvRefCnt(0);
  3185|             varDsc->setLvRefCntWtd(BB_ZERO_WEIGHT);
  3186|             const bool isSpecialVarargsParam = varDsc->lvIsParam && raIsVarargsStackArg(lclNum);
  3187|             if (!isSpecialVarargsParam)
  3188|             {
  3189|                 varDsc->lvImplicitlyReferenced = 1;
  3190|             }
  3191|             varDsc->lvTracked = 0;
  3192|             if (setSlotNumbers)
  3193|             {
  3194|                 varDsc->lvSlotNum = lclNum;
  3195|             }
  3196|             assert((varDsc->lvType != TYP_UNDEF) && (varDsc->lvType != TYP_VOID) && (varDsc->lvType != TYP_UNKNOWN));
  3197|         }
  3198|         lvaCurEpoch++;
  3199|         lvaTrackedCount             = 0;
  3200|         lvaTrackedCountInSizeTUnits = 0;
  3201|         return;
  3202|     }
  3203|     for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  3204|     {
  3205|         varDsc->setLvRefCnt(0);
  3206|         varDsc->setLvRefCntWtd(BB_ZERO_WEIGHT);
  3207|         if (setSlotNumbers)
  3208|         {
  3209|             varDsc->lvSlotNum = lclNum;
  3210|         }
  3211|         if (!isRecompute)
  3212|         {
  3213|             varDsc->lvSingleDef             = varDsc->lvIsParam;
  3214|             varDsc->lvSingleDefRegCandidate = varDsc->lvIsParam;
  3215|             varDsc->lvAllDefsAreNoGc = (varDsc->lvImplicitlyReferenced == false);
  3216|         }
  3217|     }
  3218|     const bool oldLvaGenericsContextInUse = lvaGenericsContextInUse;
  3219|     lvaGenericsContextInUse               = false;
  3220|     JITDUMP("\n*** lvaComputeRefCounts -- explicit counts ***\n");
  3221|     for (BasicBlock* const block : Blocks())
  3222|     {
  3223|         if (block->IsLIR())
  3224|         {
  3225|             assert(isRecompute);
  3226|             const weight_t weight = block->getBBWeight(this);
  3227|             for (GenTree* node : LIR::AsRange(block))
  3228|             {
  3229|                 switch (node->OperGet())
  3230|                 {
  3231|                     case GT_LCL_VAR:
  3232|                     case GT_LCL_FLD:
  3233|                     case GT_LCL_VAR_ADDR:
  3234|                     case GT_LCL_FLD_ADDR:
  3235|                     case GT_STORE_LCL_VAR:
  3236|                     case GT_STORE_LCL_FLD:
  3237|                     {
  3238|                         LclVarDsc* varDsc = lvaGetDesc(node->AsLclVarCommon());
  3239|                         if (varDsc->lvLiveInOutOfHndlr && !varDsc->lvDoNotEnregister &&
  3240|                             ((node->gtFlags & GTF_VAR_DEF) != 0))
  3241|                         {
  3242|                             varDsc->incRefCnts(0, this);
  3243|                         }
  3244|                         else
  3245|                         {
  3246|                             varDsc->incRefCnts(weight, this);
  3247|                         }
  3248|                         if ((node->gtFlags & GTF_VAR_CONTEXT) != 0)
  3249|                         {
  3250|                             assert(node->OperIs(GT_LCL_VAR));
  3251|                             lvaGenericsContextInUse = true;
  3252|                         }
  3253|                         break;
  3254|                     }
  3255|                     default:
  3256|                         break;
  3257|                 }
  3258|             }
  3259|         }
  3260|         else
  3261|         {
  3262|             lvaMarkLocalVars(block, isRecompute);
  3263|         }
  3264|     }
  3265|     if (oldLvaGenericsContextInUse && !lvaGenericsContextInUse)
  3266|     {
  3267|         JITDUMP("\n** Generics context no longer in use\n");
  3268|     }
  3269|     else if (lvaGenericsContextInUse && !oldLvaGenericsContextInUse)
  3270|     {
  3271|         assert(!"unexpected new use of generics context");
  3272|     }
  3273|     JITDUMP("\n*** lvaComputeRefCounts -- implicit counts ***\n");
  3274|     for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  3275|     {
  3276|         if (varDsc->lvIsRegArg)
  3277|         {
  3278|             if ((lclNum < info.compArgsCount) && (varDsc->lvRefCnt() > 0))
  3279|             {
  3280|                 varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
  3281|                 varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
  3282|             }
  3283|             if (varDsc->lvIsStructField)
  3284|             {
  3285|                 varDsc->incRefCnts(BB_UNITY_WEIGHT, this);
  3286|             }
  3287|         }
  3288|         if (compJmpOpUsed && varDsc->lvIsParam && (varDsc->lvRefCnt() == 0))
  3289|         {
  3290|             if (!raIsVarargsStackArg(lclNum))
  3291|             {
  3292|                 varDsc->lvImplicitlyReferenced = 1;
  3293|             }
  3294|         }
  3295|         if (varDsc->lvPinned && varDsc->lvAllDefsAreNoGc)
  3296|         {
  3297|             varDsc->lvPinned = 0;
  3298|             JITDUMP("V%02u was unpinned as all def candidates were local.\n", lclNum);
  3299|         }
  3300|     }
  3301| }
  3302| void Compiler::lvaAllocOutgoingArgSpaceVar()
  3303| {
  3304| #if FEATURE_FIXED_OUT_ARGS
  3305|     if (lvaOutgoingArgSpaceVar == BAD_VAR_NUM)
  3306|     {
  3307|         lvaOutgoingArgSpaceVar = lvaGrabTemp(false DEBUGARG("OutgoingArgSpace"));
  3308|         lvaTable[lvaOutgoingArgSpaceVar].lvType                 = TYP_LCLBLK;
  3309|         lvaTable[lvaOutgoingArgSpaceVar].lvImplicitlyReferenced = 1;
  3310|     }
  3311|     noway_assert(lvaOutgoingArgSpaceVar >= info.compLocalsCount && lvaOutgoingArgSpaceVar < lvaCount);
  3312| #endif // FEATURE_FIXED_OUT_ARGS
  3313| }
  3314| inline void Compiler::lvaIncrementFrameSize(unsigned size)
  3315| {
  3316|     if (size > MAX_FrameSize || compLclFrameSize + size > MAX_FrameSize)
  3317|     {
  3318|         BADCODE("Frame size overflow");
  3319|     }
  3320|     compLclFrameSize += size;
  3321| }
  3322| /****************************************************************************
  3323| *
  3324| *  Return true if absolute offsets of temps are larger than vars, or in other
  3325| *  words, did we allocate temps before of after vars.  The /GS buffer overrun
  3326| *  checks want temps to be at low stack addresses than buffers
  3327| */
  3328| bool Compiler::lvaTempsHaveLargerOffsetThanVars()
  3329| {
  3330| #ifdef TARGET_ARM
  3331|     return false;
  3332| #else
  3333|     if (compGSReorderStackLayout)
  3334|     {
  3335|         return codeGen->isFramePointerUsed();
  3336|     }
  3337|     else
  3338|     {
  3339|         return true;
  3340|     }
  3341| #endif
  3342| }
  3343| /****************************************************************************
  3344| *
  3345| *  Return an upper bound estimate for the size of the compiler spill temps
  3346| *
  3347| */
  3348| unsigned Compiler::lvaGetMaxSpillTempSize()
  3349| {
  3350|     unsigned result = 0;
  3351|     if (codeGen->regSet.hasComputedTmpSize())
  3352|     {
  3353|         result = codeGen->regSet.tmpGetTotalSize();
  3354|     }
  3355|     else
  3356|     {
  3357|         result = MAX_SPILL_TEMP_SIZE;
  3358|     }
  3359|     return result;
  3360| }
  3361| /*****************************************************************************
  3362|  *
  3363|  *  Compute stack frame offsets for arguments, locals and optionally temps.
  3364|  *
  3365|  *  The frame is laid out as follows for x86:
  3366|  *
  3367|  *              ESP frames
  3368|  *
  3369|  *      |                       |
  3370|  *      |-----------------------|
  3371|  *      |       incoming        |
  3372|  *      |       arguments       |
  3373|  *      |-----------------------| <---- Virtual '0'
  3374|  *      |    return address     |
  3375|  *      +=======================+
  3376|  *      |Callee saved registers |
  3377|  *      |-----------------------|
  3378|  *      |       Temps           |
  3379|  *      |-----------------------|
  3380|  *      |       Variables       |
  3381|  *      |-----------------------| <---- Ambient ESP
  3382|  *      |   Arguments for the   |
  3383|  *      ~    next function      ~
  3384|  *      |                       |
  3385|  *      |       |               |
  3386|  *      |       | Stack grows   |
  3387|  *              | downward
  3388|  *              V
  3389|  *
  3390|  *
  3391|  *              EBP frames
  3392|  *
  3393|  *      |                       |
  3394|  *      |-----------------------|
  3395|  *      |       incoming        |
  3396|  *      |       arguments       |
  3397|  *      |-----------------------| <---- Virtual '0'
  3398|  *      |    return address     |
  3399|  *      +=======================+
  3400|  *      |    incoming EBP       |
  3401|  *      |-----------------------| <---- EBP
  3402|  *      |Callee saved registers |
  3403|  *      |-----------------------|
  3404|  *      |   security object     |
  3405|  *      |-----------------------|
  3406|  *      |     ParamTypeArg      |
  3407|  *      |-----------------------|
  3408|  *      |  Last-executed-filter |
  3409|  *      |-----------------------|
  3410|  *      |                       |
  3411|  *      ~      Shadow SPs       ~
  3412|  *      |                       |
  3413|  *      |-----------------------|
  3414|  *      |                       |
  3415|  *      ~      Variables        ~
  3416|  *      |                       |
  3417|  *      ~-----------------------|
  3418|  *      |       Temps           |
  3419|  *      |-----------------------|
  3420|  *      |       localloc        |
  3421|  *      |-----------------------| <---- Ambient ESP
  3422|  *      |   Arguments for the   |
  3423|  *      |    next function      ~
  3424|  *      |                       |
  3425|  *      |       |               |
  3426|  *      |       | Stack grows   |
  3427|  *              | downward
  3428|  *              V
  3429|  *
  3430|  *
  3431|  *  The frame is laid out as follows for x64:
  3432|  *
  3433|  *              RSP frames
  3434|  *      |                       |
  3435|  *      |-----------------------|
  3436|  *      |       incoming        |
  3437|  *      |       arguments       |
  3438|  *      |-----------------------|
  3439|  *      |   4 fixed incoming    |
  3440|  *      |    argument slots     |
  3441|  *      |-----------------------| <---- Caller's SP & Virtual '0'
  3442|  *      |    return address     |
  3443|  *      +=======================+
  3444|  *      | Callee saved Int regs |
  3445|  *      -------------------------
  3446|  *      |        Padding        | <---- this padding (0 or 8 bytes) is to ensure flt registers are saved at a mem location aligned at 16-bytes
  3447|  *      |                       |       so that we can save 128-bit callee saved xmm regs using performant "movaps" instruction instead of "movups"
  3448|  *      -------------------------
  3449|  *      | Callee saved Flt regs | <----- entire 128-bits of callee saved xmm registers are stored here
  3450|  *      |-----------------------|
  3451|  *      |         Temps         |
  3452|  *      |-----------------------|
  3453|  *      |       Variables       |
  3454|  *      |-----------------------|
  3455|  *      |   Arguments for the   |
  3456|  *      ~    next function      ~
  3457|  *      |                       |
  3458|  *      |-----------------------|
  3459|  *      |   4 fixed outgoing    |
  3460|  *      |    argument slots     |
  3461|  *      |-----------------------| <---- Ambient RSP
  3462|  *      |       |               |
  3463|  *      ~       | Stack grows   ~
  3464|  *      |       | downward      |
  3465|  *              V
  3466|  *
  3467|  *
  3468|  *              RBP frames
  3469|  *      |                       |
  3470|  *      |-----------------------|
  3471|  *      |       incoming        |
  3472|  *      |       arguments       |
  3473|  *      |-----------------------|
  3474|  *      |   4 fixed incoming    |
  3475|  *      |    argument slots     |
  3476|  *      |-----------------------| <---- Caller's SP & Virtual '0'
  3477|  *      |    return address     |
  3478|  *      +=======================+
  3479|  *      | Callee saved Int regs |
  3480|  *      -------------------------
  3481|  *      |        Padding        |
  3482|  *      -------------------------
  3483|  *      | Callee saved Flt regs |
  3484|  *      |-----------------------|
  3485|  *      |   security object     |
  3486|  *      |-----------------------|
  3487|  *      |     ParamTypeArg      |
  3488|  *      |-----------------------|
  3489|  *      |                       |
  3490|  *      |                       |
  3491|  *      ~       Variables       ~
  3492|  *      |                       |
  3493|  *      |                       |
  3494|  *      |-----------------------|
  3495|  *      |        Temps          |
  3496|  *      |-----------------------|
  3497|  *      |                       |
  3498|  *      ~       localloc        ~   // not in frames with EH
  3499|  *      |                       |
  3500|  *      |-----------------------|
  3501|  *      |        PSPSym         |   // only in frames with EH (thus no localloc)
  3502|  *      |                       |
  3503|  *      |-----------------------| <---- RBP in localloc frames (max 240 bytes from Initial-SP)
  3504|  *      |   Arguments for the   |
  3505|  *      ~    next function      ~
  3506|  *      |                       |
  3507|  *      |-----------------------|
  3508|  *      |   4 fixed outgoing    |
  3509|  *      |    argument slots     |
  3510|  *      |-----------------------| <---- Ambient RSP (before localloc, this is Initial-SP)
  3511|  *      |       |               |
  3512|  *      ~       | Stack grows   ~
  3513|  *      |       | downward      |
  3514|  *              V
  3515|  *
  3516|  *
  3517|  *  The frame is laid out as follows for ARM (this is a general picture; details may differ for different conditions):
  3518|  *
  3519|  *              SP frames
  3520|  *      |                       |
  3521|  *      |-----------------------|
  3522|  *      |       incoming        |
  3523|  *      |       arguments       |
  3524|  *      +=======================+ <---- Caller's SP
  3525|  *      |  Pre-spill registers  |
  3526|  *      |-----------------------| <---- Virtual '0'
  3527|  *      |Callee saved registers |
  3528|  *      |-----------------------|
  3529|  *      ~ possible double align ~
  3530|  *      |-----------------------|
  3531|  *      |   security object     |
  3532|  *      |-----------------------|
  3533|  *      |     ParamTypeArg      |
  3534|  *      |-----------------------|
  3535|  *      |  possible GS cookie   |
  3536|  *      |-----------------------|
  3537|  *      |       Variables       |
  3538|  *      |-----------------------|
  3539|  *      |  possible GS cookie   |
  3540|  *      |-----------------------|
  3541|  *      |        Temps          |
  3542|  *      |-----------------------|
  3543|  *      |   Stub Argument Var   |
  3544|  *      |-----------------------|
  3545|  *      |Inlined PInvoke Frame V|
  3546|  *      |-----------------------|
  3547|  *      ~ possible double align ~
  3548|  *      |-----------------------|
  3549|  *      |   Arguments for the   |
  3550|  *      ~    next function      ~
  3551|  *      |                       |
  3552|  *      |-----------------------| <---- Ambient SP
  3553|  *      |       |               |
  3554|  *      ~       | Stack grows   ~
  3555|  *      |       | downward      |
  3556|  *              V
  3557|  *
  3558|  *
  3559|  *              FP / R11 frames
  3560|  *      |                       |
  3561|  *      |-----------------------|
  3562|  *      |       incoming        |
  3563|  *      |       arguments       |
  3564|  *      +=======================+ <---- Caller's SP
  3565|  *      |  Pre-spill registers  |
  3566|  *      |-----------------------| <---- Virtual '0'
  3567|  *      |Callee saved registers |
  3568|  *      |-----------------------|
  3569|  *      |        PSPSym         |   // Only for frames with EH, which means FP-based frames
  3570|  *      |-----------------------|
  3571|  *      ~ possible double align ~
  3572|  *      |-----------------------|
  3573|  *      |   security object     |
  3574|  *      |-----------------------|
  3575|  *      |     ParamTypeArg      |
  3576|  *      |-----------------------|
  3577|  *      |  possible GS cookie   |
  3578|  *      |-----------------------|
  3579|  *      |       Variables       |
  3580|  *      |-----------------------|
  3581|  *      |  possible GS cookie   |
  3582|  *      |-----------------------|
  3583|  *      |        Temps          |
  3584|  *      |-----------------------|
  3585|  *      |   Stub Argument Var   |
  3586|  *      |-----------------------|
  3587|  *      |Inlined PInvoke Frame V|
  3588|  *      |-----------------------|
  3589|  *      ~ possible double align ~
  3590|  *      |-----------------------|
  3591|  *      |       localloc        |
  3592|  *      |-----------------------|
  3593|  *      |   Arguments for the   |
  3594|  *      ~    next function      ~
  3595|  *      |                       |
  3596|  *      |-----------------------| <---- Ambient SP
  3597|  *      |       |               |
  3598|  *      ~       | Stack grows   ~
  3599|  *      |       | downward      |
  3600|  *              V
  3601|  *
  3602|  *
  3603|  *  The frame is laid out as follows for ARM64 (this is a general picture; details may differ for different conditions):
  3604|  *  NOTE: SP must be 16-byte aligned, so there may be alignment slots in the frame.
  3605|  *  We will often save and establish a frame pointer to create better ETW stack walks.
  3606|  *
  3607|  *              SP frames
  3608|  *      |                       |
  3609|  *      |-----------------------|
  3610|  *      |       incoming        |
  3611|  *      |       arguments       |
  3612|  *      +=======================+ <---- Caller's SP
  3613|  *      |         homed         | // this is only needed if reg argument need to be homed, e.g., for varargs
  3614|  *      |   register arguments  |
  3615|  *      |-----------------------| <---- Virtual '0'
  3616|  *      |Callee saved registers |
  3617|  *      |   except fp/lr        |
  3618|  *      |-----------------------|
  3619|  *      |   security object     |
  3620|  *      |-----------------------|
  3621|  *      |     ParamTypeArg      |
  3622|  *      |-----------------------|
  3623|  *      |  possible GS cookie   |
  3624|  *      |-----------------------|
  3625|  *      |       Variables       |
  3626|  *      |-----------------------|
  3627|  *      |  possible GS cookie   |
  3628|  *      |-----------------------|
  3629|  *      |        Temps          |
  3630|  *      |-----------------------|
  3631|  *      |   Stub Argument Var   |
  3632|  *      |-----------------------|
  3633|  *      |Inlined PInvoke Frame V|
  3634|  *      |-----------------------|
  3635|  *      |      Saved LR         |
  3636|  *      |-----------------------|
  3637|  *      |      Saved FP         | <---- Frame pointer
  3638|  *      |-----------------------|
  3639|  *      |  Stack arguments for  |
  3640|  *      |   the next function   |
  3641|  *      |-----------------------| <---- SP
  3642|  *      |       |               |
  3643|  *      ~       | Stack grows   ~
  3644|  *      |       | downward      |
  3645|  *              V
  3646|  *
  3647|  *
  3648|  *              FP (R29 / x29) frames
  3649|  *      |                       |
  3650|  *      |-----------------------|
  3651|  *      |       incoming        |
  3652|  *      |       arguments       |
  3653|  *      +=======================+ <---- Caller's SP
  3654|  *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs
  3655|  *      |   register arguments  |
  3656|  *      |-----------------------| <---- Virtual '0'
  3657|  *      |Callee saved registers |
  3658|  *      |   except fp/lr        |
  3659|  *      |-----------------------|
  3660|  *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames
  3661|  *      |-----------------------|
  3662|  *      |   security object     |
  3663|  *      |-----------------------|
  3664|  *      |     ParamTypeArg      |
  3665|  *      |-----------------------|
  3666|  *      |  possible GS cookie   |
  3667|  *      |-----------------------|
  3668|  *      |       Variables       |
  3669|  *      |-----------------------|
  3670|  *      |  possible GS cookie   |
  3671|  *      |-----------------------|
  3672|  *      |        Temps          |
  3673|  *      |-----------------------|
  3674|  *      |   Stub Argument Var   |
  3675|  *      |-----------------------|
  3676|  *      |Inlined PInvoke Frame V|
  3677|  *      |-----------------------|
  3678|  *      |      Saved LR         |
  3679|  *      |-----------------------|
  3680|  *      |      Saved FP         | <---- Frame pointer
  3681|  *      |-----------------------|
  3682|  *      ~       localloc        ~
  3683|  *      |-----------------------|
  3684|  *      |  Stack arguments for  |
  3685|  *      |   the next function   |
  3686|  *      |-----------------------| <---- Ambient SP
  3687|  *      |       |               |
  3688|  *      ~       | Stack grows   ~
  3689|  *      |       | downward      |
  3690|  *              V
  3691|  *
  3692|  *
  3693|  *              FP (R29 / x29) frames where FP/LR are stored at the top of the frame (frames requiring GS that have localloc)
  3694|  *      |                       |
  3695|  *      |-----------------------|
  3696|  *      |       incoming        |
  3697|  *      |       arguments       |
  3698|  *      +=======================+ <---- Caller's SP
  3699|  *      |     optional homed    | // this is only needed if reg argument need to be homed, e.g., for varargs
  3700|  *      |   register arguments  |
  3701|  *      |-----------------------| <---- Virtual '0'
  3702|  *      |      Saved LR         |
  3703|  *      |-----------------------|
  3704|  *      |      Saved FP         | <---- Frame pointer
  3705|  *      |-----------------------|
  3706|  *      |Callee saved registers |
  3707|  *      |-----------------------|
  3708|  *      |        PSPSym         | // Only for frames with EH, which requires FP-based frames
  3709|  *      |-----------------------|
  3710|  *      |   security object     |
  3711|  *      |-----------------------|
  3712|  *      |     ParamTypeArg      |
  3713|  *      |-----------------------|
  3714|  *      |  possible GS cookie   |
  3715|  *      |-----------------------|
  3716|  *      |       Variables       |
  3717|  *      |-----------------------|
  3718|  *      |  possible GS cookie   |
  3719|  *      |-----------------------|
  3720|  *      |        Temps          |
  3721|  *      |-----------------------|
  3722|  *      |   Stub Argument Var   |
  3723|  *      |-----------------------|
  3724|  *      |Inlined PInvoke Frame V|
  3725|  *      |-----------------------|
  3726|  *      ~       localloc        ~
  3727|  *      |-----------------------|
  3728|  *      |  Stack arguments for  |
  3729|  *      |   the next function   |
  3730|  *      |-----------------------| <---- Ambient SP
  3731|  *      |       |               |
  3732|  *      ~       | Stack grows   ~
  3733|  *      |       | downward      |
  3734|  *              V
  3735|  *
  3736|  *
  3737|  *  Doing this all in one pass is 'hard'.  So instead we do it in 2 basic passes:
  3738|  *    1. Assign all the offsets relative to the Virtual '0'. Offsets above (the
  3739|  *      incoming arguments) are positive. Offsets below (everything else) are
  3740|  *      negative.  This pass also calcuates the total frame size (between Caller's
  3741|  *      SP/return address and the Ambient SP).
  3742|  *    2. Figure out where to place the frame pointer, and then adjust the offsets
  3743|  *      as needed for the final stack size and whether the offset is frame pointer
  3744|  *      relative or stack pointer relative.
  3745|  *
  3746|  */
  3747| void Compiler::lvaAssignFrameOffsets(FrameLayoutState curState)
  3748| {
  3749|     noway_assert((lvaDoneFrameLayout < curState) || (curState == REGALLOC_FRAME_LAYOUT));
  3750|     lvaDoneFrameLayout = curState;
  3751| #ifdef DEBUG
  3752|     if (verbose)
  3753|     {
  3754|         printf("*************** In lvaAssignFrameOffsets");
  3755|         if (curState == INITIAL_FRAME_LAYOUT)
  3756|         {
  3757|             printf("(INITIAL_FRAME_LAYOUT)");
  3758|         }
  3759|         else if (curState == PRE_REGALLOC_FRAME_LAYOUT)
  3760|         {
  3761|             printf("(PRE_REGALLOC_FRAME_LAYOUT)");
  3762|         }
  3763|         else if (curState == REGALLOC_FRAME_LAYOUT)
  3764|         {
  3765|             printf("(REGALLOC_FRAME_LAYOUT)");
  3766|         }
  3767|         else if (curState == TENTATIVE_FRAME_LAYOUT)
  3768|         {
  3769|             printf("(TENTATIVE_FRAME_LAYOUT)");
  3770|         }
  3771|         else if (curState == FINAL_FRAME_LAYOUT)
  3772|         {
  3773|             printf("(FINAL_FRAME_LAYOUT)");
  3774|         }
  3775|         else
  3776|         {
  3777|             printf("(UNKNOWN)");
  3778|             unreached();
  3779|         }
  3780|         printf("\n");
  3781|     }
  3782| #endif
  3783| #if FEATURE_FIXED_OUT_ARGS
  3784|     assert(lvaOutgoingArgSpaceVar != BAD_VAR_NUM);
  3785| #endif // FEATURE_FIXED_OUT_ARGS
  3786|     /*-------------------------------------------------------------------------
  3787|      *
  3788|      * First process the arguments.
  3789|      *
  3790|      *-------------------------------------------------------------------------
  3791|      */
  3792|     lvaAssignVirtualFrameOffsetsToArgs();
  3793|     /*-------------------------------------------------------------------------
  3794|      *
  3795|      * Now compute stack offsets for any variables that don't live in registers
  3796|      *
  3797|      *-------------------------------------------------------------------------
  3798|      */
  3799|     lvaAssignVirtualFrameOffsetsToLocals();
  3800|     lvaAlignFrame();
  3801|     /*-------------------------------------------------------------------------
  3802|      *
  3803|      * Now patch the offsets
  3804|      *
  3805|      *-------------------------------------------------------------------------
  3806|      */
  3807|     lvaFixVirtualFrameOffsets();
  3808|     lvaAssignFrameOffsetsToPromotedStructs();
  3809|     /*-------------------------------------------------------------------------
  3810|      *
  3811|      * Finalize
  3812|      *
  3813|      *-------------------------------------------------------------------------
  3814|      */
  3815|     if (curState < FINAL_FRAME_LAYOUT)
  3816|     {
  3817|         codeGen->resetFramePointerUsedWritePhase();
  3818|     }
  3819| }
  3820| /*****************************************************************************
  3821|  *  lvaFixVirtualFrameOffsets() : Now that everything has a virtual offset,
  3822|  *  determine the final value for the frame pointer (if needed) and then
  3823|  *  adjust all the offsets appropriately.
  3824|  *
  3825|  *  This routine fixes virtual offset to be relative to frame pointer or SP
  3826|  *  based on whether varDsc->lvFramePointerBased is true or false respectively.
  3827|  */
  3828| void Compiler::lvaFixVirtualFrameOffsets()
  3829| {
  3830|     LclVarDsc* varDsc;
  3831| #if defined(FEATURE_EH_FUNCLETS) && defined(TARGET_AMD64)
  3832|     if (lvaPSPSym != BAD_VAR_NUM)
  3833|     {
  3834|         varDsc = lvaGetDesc(lvaPSPSym);
  3835|         assert(varDsc->lvFramePointerBased); // We always access it RBP-relative.
  3836|         assert(!varDsc->lvMustInit);         // It is never "must init".
  3837|         varDsc->SetStackOffset(codeGen->genCallerSPtoInitialSPdelta() + lvaLclSize(lvaOutgoingArgSpaceVar));
  3838|         if (opts.IsOSR())
  3839|         {
  3840|             varDsc->SetStackOffset(varDsc->GetStackOffset() - info.compPatchpointInfo->TotalFrameSize());
  3841|         }
  3842|     }
  3843| #endif
  3844|     int delta = 0;
  3845| #ifdef TARGET_XARCH
  3846|     delta += REGSIZE_BYTES; // pushed PC (return address) for x86/x64
  3847|     JITDUMP("--- delta bump %d for RA\n", REGSIZE_BYTES);
  3848|     if (codeGen->doubleAlignOrFramePointerUsed())
  3849|     {
  3850|         JITDUMP("--- delta bump %d for FP\n", REGSIZE_BYTES);
  3851|         delta += REGSIZE_BYTES; // pushed EBP (frame pointer)
  3852|     }
  3853| #endif
  3854|     if (!codeGen->isFramePointerUsed())
  3855|     {
  3856|         JITDUMP("--- delta bump %d for RSP frame\n", codeGen->genTotalFrameSize());
  3857|         delta += codeGen->genTotalFrameSize();
  3858|     }
  3859| #if defined(TARGET_ARM)
  3860|     else
  3861|     {
  3862|         delta += 2 * REGSIZE_BYTES;
  3863|     }
  3864| #elif defined(TARGET_AMD64) || defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  3865|     else
  3866|     {
  3867|         JITDUMP("--- delta bump %d for FP frame\n", codeGen->genTotalFrameSize() - codeGen->genSPtoFPdelta());
  3868|         delta += codeGen->genTotalFrameSize() - codeGen->genSPtoFPdelta();
  3869|     }
  3870| #endif // TARGET_AMD64 || TARGET_ARM64 || TARGET_LOONGARCH64
  3871|     if (opts.IsOSR())
  3872|     {
  3873| #if defined(TARGET_AMD64) || defined(TARGET_ARM64)
  3874|         JITDUMP("--- delta bump %d for OSR + Tier0 frame\n", info.compPatchpointInfo->TotalFrameSize());
  3875|         delta += info.compPatchpointInfo->TotalFrameSize();
  3876| #endif
  3877|     }
  3878|     JITDUMP("--- virtual stack offset to actual stack offset delta is %d\n", delta);
  3879|     unsigned lclNum;
  3880|     for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  3881|     {
  3882|         bool doAssignStkOffs = true;
  3883|         noway_assert(!varDsc->lvFramePointerBased || codeGen->doubleAlignOrFramePointerUsed());
  3884|         if (varDsc->lvIsStructField)
  3885|         {
  3886|             LclVarDsc*       parentvarDsc  = lvaGetDesc(varDsc->lvParentLcl);
  3887|             lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
  3888| #if defined(TARGET_X86)
  3889|             if ((!varDsc->lvIsParam || parentvarDsc->lvIsParam) && promotionType == PROMOTION_TYPE_DEPENDENT)
  3890| #else
  3891|             if (!varDsc->lvIsParam && promotionType == PROMOTION_TYPE_DEPENDENT)
  3892| #endif
  3893|             {
  3894|                 doAssignStkOffs = false; // Assigned later in lvaAssignFrameOffsetsToPromotedStructs()
  3895|             }
  3896|         }
  3897|         if (!varDsc->lvOnFrame)
  3898|         {
  3899|             if (!varDsc->lvIsParam
  3900| #if !defined(TARGET_AMD64)
  3901|                 || (varDsc->lvIsRegArg
  3902| #if defined(TARGET_ARM) && defined(PROFILING_SUPPORTED)
  3903|                     && compIsProfilerHookNeeded() &&
  3904|                     !lvaIsPreSpilled(lclNum, codeGen->regSet.rsMaskPreSpillRegs(false)) // We need assign stack offsets
  3905| #endif
  3906|                     )
  3907| #endif // !defined(TARGET_AMD64)
  3908|                     )
  3909|             {
  3910|                 doAssignStkOffs = false; // Not on frame or an incoming stack arg
  3911|             }
  3912|         }
  3913|         if (doAssignStkOffs)
  3914|         {
  3915|             JITDUMP("-- V%02u was %d, now %d\n", lclNum, varDsc->GetStackOffset(), varDsc->GetStackOffset() + delta);
  3916|             varDsc->SetStackOffset(varDsc->GetStackOffset() + delta);
  3917| #if DOUBLE_ALIGN
  3918|             if (genDoubleAlign() && !codeGen->isFramePointerUsed())
  3919|             {
  3920|                 if (varDsc->lvFramePointerBased)
  3921|                 {
  3922|                     varDsc->SetStackOffset(varDsc->GetStackOffset() - delta);
  3923|                     varDsc->SetStackOffset(varDsc->GetStackOffset() +
  3924|                                            (2 * TARGET_POINTER_SIZE)); // return address and pushed EBP
  3925|                     noway_assert(varDsc->GetStackOffset() >= FIRST_ARG_STACK_OFFS);
  3926|                 }
  3927|             }
  3928| #endif
  3929|             assert(codeGen->isFramePointerUsed() || varDsc->GetStackOffset() >= 0);
  3930|         }
  3931|     }
  3932|     assert(codeGen->regSet.tmpAllFree());
  3933|     for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
  3934|     {
  3935|         temp->tdAdjustTempOffs(delta);
  3936|     }
  3937|     lvaCachedGenericContextArgOffs += delta;
  3938| #if FEATURE_FIXED_OUT_ARGS
  3939|     if (lvaOutgoingArgSpaceVar != BAD_VAR_NUM)
  3940|     {
  3941|         varDsc = lvaGetDesc(lvaOutgoingArgSpaceVar);
  3942|         varDsc->SetStackOffset(0);
  3943|         varDsc->lvFramePointerBased = false;
  3944|         varDsc->lvMustInit          = false;
  3945|     }
  3946| #endif // FEATURE_FIXED_OUT_ARGS
  3947| #if defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  3948|     assert(codeGen->isFramePointerUsed());
  3949|     if (lvaRetAddrVar != BAD_VAR_NUM)
  3950|     {
  3951|         lvaTable[lvaRetAddrVar].SetStackOffset(REGSIZE_BYTES);
  3952|     }
  3953| #endif // TARGET_ARM64 || TARGET_LOONGARCH64
  3954| }
  3955| #ifdef TARGET_ARM
  3956| bool Compiler::lvaIsPreSpilled(unsigned lclNum, regMaskTP preSpillMask)
  3957| {
  3958|     const LclVarDsc& desc = lvaTable[lclNum];
  3959|     return desc.lvIsRegArg && (preSpillMask & genRegMask(desc.GetArgReg()));
  3960| }
  3961| #endif // TARGET_ARM
  3962| void Compiler::lvaUpdateArgWithInitialReg(LclVarDsc* varDsc)
  3963| {
  3964|     noway_assert(varDsc->lvIsParam);
  3965|     if (varDsc->lvIsRegCandidate())
  3966|     {
  3967|         varDsc->SetRegNum(varDsc->GetArgInitReg());
  3968|     }
  3969| }
  3970| void Compiler::lvaUpdateArgsWithInitialReg()
  3971| {
  3972|     if (!compLSRADone)
  3973|     {
  3974|         return;
  3975|     }
  3976|     for (unsigned lclNum = 0; lclNum < info.compArgsCount; lclNum++)
  3977|     {
  3978|         LclVarDsc* varDsc = lvaGetDesc(lclNum);
  3979|         if (varDsc->lvPromotedStruct())
  3980|         {
  3981|             for (unsigned fieldVarNum = varDsc->lvFieldLclStart;
  3982|                  fieldVarNum < varDsc->lvFieldLclStart + varDsc->lvFieldCnt; ++fieldVarNum)
  3983|             {
  3984|                 LclVarDsc* fieldVarDsc = lvaGetDesc(fieldVarNum);
  3985|                 lvaUpdateArgWithInitialReg(fieldVarDsc);
  3986|             }
  3987|         }
  3988|         else
  3989|         {
  3990|             lvaUpdateArgWithInitialReg(varDsc);
  3991|         }
  3992|     }
  3993| }
  3994| /*****************************************************************************
  3995|  *  lvaAssignVirtualFrameOffsetsToArgs() : Assign virtual stack offsets to the
  3996|  *  arguments, and implicit arguments (this ptr, return buffer, generics,
  3997|  *  and varargs).
  3998|  */
  3999| void Compiler::lvaAssignVirtualFrameOffsetsToArgs()
  4000| {
  4001|     unsigned lclNum  = 0;
  4002|     int      argOffs = 0;
  4003| #ifdef UNIX_AMD64_ABI
  4004|     int callerArgOffset = 0;
  4005| #endif // UNIX_AMD64_ABI
  4006|     /*
  4007|         Assign stack offsets to arguments (in reverse order of passing).
  4008|         This means that if we pass arguments left->right, we start at
  4009|         the end of the list and work backwards, for right->left we start
  4010|         with the first argument and move forward.
  4011|         This is all relative to our Virtual '0'
  4012|      */
  4013|     if (info.compArgOrder == Target::ARG_ORDER_L2R)
  4014|     {
  4015|         argOffs = compArgSize;
  4016|     }
  4017|     /* Update the argOffs to reflect arguments that are passed in registers */
  4018|     noway_assert(codeGen->intRegState.rsCalleeRegArgCount <= MAX_REG_ARG);
  4019|     noway_assert(compMacOsArm64Abi() || compArgSize >= codeGen->intRegState.rsCalleeRegArgCount * REGSIZE_BYTES);
  4020|     if (info.compArgOrder == Target::ARG_ORDER_L2R)
  4021|     {
  4022|         argOffs -= codeGen->intRegState.rsCalleeRegArgCount * REGSIZE_BYTES;
  4023|     }
  4024|     lvaUpdateArgsWithInitialReg();
  4025|     /* Is there a "this" argument? */
  4026|     if (!info.compIsStatic)
  4027|     {
  4028|         noway_assert(lclNum == info.compThisArg);
  4029| #ifndef TARGET_X86
  4030|         argOffs =
  4031|             lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4032| #endif // TARGET_X86
  4033|         lclNum++;
  4034|     }
  4035|     unsigned userArgsToSkip = 0;
  4036| #if !defined(TARGET_ARM)
  4037|     if (TargetOS::IsWindows && callConvIsInstanceMethodCallConv(info.compCallConv))
  4038|     {
  4039| #ifdef TARGET_X86
  4040|         if (!lvaTable[lclNum].lvIsRegArg)
  4041|         {
  4042|             argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs);
  4043|         }
  4044| #elif !defined(UNIX_AMD64_ABI)
  4045|         argOffs              = lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs);
  4046| #endif // TARGET_X86
  4047|         lclNum++;
  4048|         userArgsToSkip++;
  4049|     }
  4050| #endif
  4051|     /* if we have a hidden buffer parameter, that comes here */
  4052|     if (info.compRetBuffArg != BAD_VAR_NUM)
  4053|     {
  4054|         noway_assert(lclNum == info.compRetBuffArg);
  4055|         argOffs =
  4056|             lvaAssignVirtualFrameOffsetToArg(lclNum, REGSIZE_BYTES, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4057|         lclNum++;
  4058|     }
  4059| #if USER_ARGS_COME_LAST
  4060|     if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
  4061|     {
  4062|         noway_assert(lclNum == (unsigned)info.compTypeCtxtArg);
  4063|         argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
  4064|                                                    argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4065|     }
  4066|     if (info.compIsVarArgs)
  4067|     {
  4068|         argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
  4069|                                                    argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4070|     }
  4071| #endif // USER_ARGS_COME_LAST
  4072|     CORINFO_ARG_LIST_HANDLE argLst    = info.compMethodInfo->args.args;
  4073|     unsigned                argSigLen = info.compMethodInfo->args.numArgs;
  4074|     assert(userArgsToSkip <= argSigLen);
  4075|     argSigLen -= userArgsToSkip;
  4076|     for (unsigned i = 0; i < userArgsToSkip; i++, argLst = info.compCompHnd->getArgNext(argLst))
  4077|     {
  4078|         ;
  4079|     }
  4080| #ifdef TARGET_ARM
  4081|     unsigned argLcls = 0;
  4082|     regMaskTP preSpillMask = codeGen->regSet.rsMaskPreSpillRegs(false);
  4083|     regMaskTP tempMask     = RBM_NONE;
  4084|     for (unsigned i = 0, preSpillLclNum = lclNum; i < argSigLen; ++i, ++preSpillLclNum)
  4085|     {
  4086|         if (lvaIsPreSpilled(preSpillLclNum, preSpillMask))
  4087|         {
  4088|             unsigned argSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
  4089|             argOffs          = lvaAssignVirtualFrameOffsetToArg(preSpillLclNum, argSize, argOffs);
  4090|             argLcls++;
  4091|             tempMask |= ((((1 << (roundUp(argSize, TARGET_POINTER_SIZE) / REGSIZE_BYTES))) - 1)
  4092|                          << lvaTable[preSpillLclNum].GetArgReg());
  4093|             if (tempMask == preSpillMask)
  4094|             {
  4095|                 break;
  4096|             }
  4097|         }
  4098|         argLst = info.compCompHnd->getArgNext(argLst);
  4099|     }
  4100|     argLst = info.compMethodInfo->args.args;
  4101|     for (unsigned i = 0, stkLclNum = lclNum; i < argSigLen; ++i, ++stkLclNum)
  4102|     {
  4103|         if (!lvaIsPreSpilled(stkLclNum, preSpillMask))
  4104|         {
  4105|             const unsigned argSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
  4106|             argOffs                = lvaAssignVirtualFrameOffsetToArg(stkLclNum, argSize, argOffs);
  4107|             argLcls++;
  4108|         }
  4109|         argLst = info.compCompHnd->getArgNext(argLst);
  4110|     }
  4111|     lclNum += argLcls;
  4112| #else  // !TARGET_ARM
  4113|     for (unsigned i = 0; i < argSigLen; i++)
  4114|     {
  4115|         unsigned argumentSize = eeGetArgSize(argLst, &info.compMethodInfo->args);
  4116|         assert(compMacOsArm64Abi() || argumentSize % TARGET_POINTER_SIZE == 0);
  4117|         argOffs =
  4118|             lvaAssignVirtualFrameOffsetToArg(lclNum++, argumentSize, argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4119|         argLst = info.compCompHnd->getArgNext(argLst);
  4120|     }
  4121| #endif // !TARGET_ARM
  4122| #if !USER_ARGS_COME_LAST
  4123|     if (info.compMethodInfo->args.callConv & CORINFO_CALLCONV_PARAMTYPE)
  4124|     {
  4125|         noway_assert(lclNum == (unsigned)info.compTypeCtxtArg);
  4126|         argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
  4127|                                                    argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4128|     }
  4129|     if (info.compIsVarArgs)
  4130|     {
  4131|         argOffs = lvaAssignVirtualFrameOffsetToArg(lclNum++, REGSIZE_BYTES,
  4132|                                                    argOffs UNIX_AMD64_ABI_ONLY_ARG(&callerArgOffset));
  4133|     }
  4134| #endif // USER_ARGS_COME_LAST
  4135| }
  4136| #ifdef UNIX_AMD64_ABI
  4137| int Compiler::lvaAssignVirtualFrameOffsetToArg(unsigned lclNum,
  4138|                                                unsigned argSize,
  4139|                                                int argOffs UNIX_AMD64_ABI_ONLY_ARG(int* callerArgOffset))
  4140| {
  4141|     noway_assert(lclNum < info.compArgsCount);
  4142|     noway_assert(argSize);
  4143|     if (info.compArgOrder == Target::ARG_ORDER_L2R)
  4144|     {
  4145|         argOffs -= argSize;
  4146|     }
  4147|     unsigned fieldVarNum = BAD_VAR_NUM;
  4148|     LclVarDsc* varDsc = lvaGetDesc(lclNum);
  4149|     noway_assert(varDsc->lvIsParam);
  4150|     if (varDsc->lvIsRegArg)
  4151|     {
  4152|         if (varDsc->lvOnFrame)
  4153|         {
  4154|             varDsc->SetStackOffset(argOffs);
  4155|         }
  4156|         else
  4157|         {
  4158|             varDsc->SetStackOffset(0);
  4159|         }
  4160|     }
  4161|     else
  4162|     {
  4163|         varDsc->SetStackOffset(*callerArgOffset);
  4164|         if (argSize > TARGET_POINTER_SIZE)
  4165|         {
  4166|             *callerArgOffset += (int)roundUp(argSize, TARGET_POINTER_SIZE);
  4167|         }
  4168|         else
  4169|         {
  4170|             *callerArgOffset += TARGET_POINTER_SIZE;
  4171|         }
  4172|     }
  4173|     if (varDsc->lvPromotedStruct())
  4174|     {
  4175|         unsigned firstFieldNum = varDsc->lvFieldLclStart;
  4176|         int      offset        = varDsc->GetStackOffset();
  4177|         for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
  4178|         {
  4179|             LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
  4180|             fieldVarDsc->SetStackOffset(offset + fieldVarDsc->lvFldOffset);
  4181|         }
  4182|     }
  4183|     if (info.compArgOrder == Target::ARG_ORDER_R2L && !varDsc->lvIsRegArg)
  4184|     {
  4185|         argOffs += argSize;
  4186|     }
  4187|     return argOffs;
  4188| }
  4189| #else // !UNIX_AMD64_ABI
  4190| int Compiler::lvaAssignVirtualFrameOffsetToArg(unsigned lclNum,
  4191|                                                unsigned argSize,
  4192|                                                int argOffs UNIX_AMD64_ABI_ONLY_ARG(int* callerArgOffset))
  4193| {
  4194|     noway_assert(lclNum < info.compArgsCount);
  4195|     noway_assert(argSize);
  4196|     if (info.compArgOrder == Target::ARG_ORDER_L2R)
  4197|     {
  4198|         argOffs -= argSize;
  4199|     }
  4200|     unsigned fieldVarNum = BAD_VAR_NUM;
  4201|     LclVarDsc* varDsc = lvaGetDesc(lclNum);
  4202|     noway_assert(varDsc->lvIsParam);
  4203|     if (varDsc->lvIsRegArg)
  4204|     {
  4205|         /* Argument is passed in a register, don't count it
  4206|          * when updating the current offset on the stack */
  4207|         CLANG_FORMAT_COMMENT_ANCHOR;
  4208| #if !defined(TARGET_ARMARCH) && !defined(TARGET_LOONGARCH64)
  4209| #if DEBUG
  4210|         noway_assert(argSize == TARGET_POINTER_SIZE);
  4211| #endif // DEBUG
  4212| #endif
  4213| #if defined(TARGET_X86)
  4214|         argOffs += TARGET_POINTER_SIZE;
  4215| #elif defined(TARGET_AMD64)
  4216|         varDsc->SetStackOffset(argOffs);
  4217|         argOffs += TARGET_POINTER_SIZE;
  4218| #elif defined(TARGET_ARM64)
  4219|         if (compFeatureArgSplit() && this->info.compIsVarArgs)
  4220|         {
  4221|             if (varDsc->lvType == TYP_STRUCT && varDsc->GetOtherArgReg() >= MAX_REG_ARG &&
  4222|                 varDsc->GetOtherArgReg() != REG_NA)
  4223|             {
  4224|                 varDsc->SetStackOffset(varDsc->GetStackOffset() + TARGET_POINTER_SIZE);
  4225|                 argOffs += TARGET_POINTER_SIZE;
  4226|             }
  4227|         }
  4228| #elif defined(TARGET_ARM)
  4229|         regMaskTP regMask = genRegMask(varDsc->GetArgReg());
  4230|         if (codeGen->regSet.rsMaskPreSpillRegArg & regMask)
  4231|         {
  4232|             if (codeGen->regSet.rsMaskPreSpillAlign != RBM_NONE)
  4233|             {
  4234|                 assert(genCountBits(codeGen->regSet.rsMaskPreSpillAlign) == 1);
  4235|                 if (regMask > codeGen->regSet.rsMaskPreSpillAlign)
  4236|                 {
  4237|                     if (!BitsBetween(codeGen->regSet.rsMaskPreSpillRegArg, regMask,
  4238|                                      codeGen->regSet.rsMaskPreSpillAlign))
  4239|                     {
  4240|                         argOffs += TARGET_POINTER_SIZE;
  4241|                     }
  4242|                 }
  4243|             }
  4244|             switch (varDsc->lvType)
  4245|             {
  4246|                 case TYP_STRUCT:
  4247|                     if (!varDsc->lvStructDoubleAlign)
  4248|                     {
  4249|                         break;
  4250|                     }
  4251|                     FALLTHROUGH;
  4252|                 case TYP_DOUBLE:
  4253|                 case TYP_LONG:
  4254|                 {
  4255|                     int prevRegsSize =
  4256|                         genCountBits(codeGen->regSet.rsMaskPreSpillRegArg & (regMask - 1)) * TARGET_POINTER_SIZE;
  4257|                     if (argOffs < prevRegsSize)
  4258|                     {
  4259|                         argOffs = roundUp((unsigned)argOffs, 2 * TARGET_POINTER_SIZE);
  4260|                     }
  4261|                     assert(argOffs == prevRegsSize);
  4262|                 }
  4263|                 break;
  4264|                 default:
  4265|                     break;
  4266|             }
  4267|             varDsc->SetStackOffset(argOffs);
  4268|             argOffs += argSize;
  4269|         }
  4270| #elif defined(TARGET_LOONGARCH64)
  4271|         if (varDsc->lvIsSplit)
  4272|         {
  4273|             assert((varDsc->lvType == TYP_STRUCT) && (varDsc->GetOtherArgReg() == REG_STK));
  4274|             varDsc->SetStackOffset(varDsc->GetStackOffset() + TARGET_POINTER_SIZE);
  4275|             argOffs += TARGET_POINTER_SIZE;
  4276|         }
  4277| #else // TARGET*
  4278| #error Unsupported or unset target architecture
  4279| #endif // TARGET*
  4280|     }
  4281|     else
  4282|     {
  4283| #if defined(TARGET_ARM)
  4284|         int sizeofPreSpillRegArgs = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * REGSIZE_BYTES;
  4285|         if (argOffs < sizeofPreSpillRegArgs)
  4286|         {
  4287|             CLANG_FORMAT_COMMENT_ANCHOR;
  4288| #ifdef PROFILING_SUPPORTED
  4289|             if (!compIsProfilerHookNeeded())
  4290| #endif
  4291|             {
  4292|                 bool cond = ((info.compIsVarArgs || opts.compUseSoftFP) &&
  4293|                              ((varDsc->lvType == TYP_STRUCT && varDsc->lvStructDoubleAlign) ||
  4294|                               (varDsc->lvType == TYP_DOUBLE) || (varDsc->lvType == TYP_LONG))) ||
  4295|                             (codeGen->regSet.rsMaskPreSpillAlign & genRegMask(REG_ARG_LAST));
  4296|                 noway_assert(cond);
  4297|                 noway_assert(sizeofPreSpillRegArgs <=
  4298|                              argOffs + TARGET_POINTER_SIZE); // at most one register of alignment
  4299|             }
  4300|             argOffs = sizeofPreSpillRegArgs;
  4301|         }
  4302|         noway_assert(argOffs >= sizeofPreSpillRegArgs);
  4303|         int argOffsWithoutPreSpillRegArgs = argOffs - sizeofPreSpillRegArgs;
  4304|         switch (varDsc->lvType)
  4305|         {
  4306|             case TYP_STRUCT:
  4307|                 if (!varDsc->lvStructDoubleAlign)
  4308|                     break;
  4309|                 FALLTHROUGH;
  4310|             case TYP_DOUBLE:
  4311|             case TYP_LONG:
  4312|                 argOffs =
  4313|                     roundUp((unsigned)argOffsWithoutPreSpillRegArgs, 2 * TARGET_POINTER_SIZE) + sizeofPreSpillRegArgs;
  4314|                 break;
  4315|             default:
  4316|                 break;
  4317|         }
  4318| #endif // TARGET_ARM
  4319|         const bool     isFloatHfa   = (varDsc->lvIsHfa() && (varDsc->GetHfaType() == TYP_FLOAT));
  4320|         const unsigned argAlignment = eeGetArgSizeAlignment(varDsc->lvType, isFloatHfa);
  4321|         if (compMacOsArm64Abi())
  4322|         {
  4323|             argOffs = roundUp(argOffs, argAlignment);
  4324|         }
  4325|         assert((argSize % argAlignment) == 0);
  4326|         assert((argOffs % argAlignment) == 0);
  4327|         varDsc->SetStackOffset(argOffs);
  4328|     }
  4329|     CLANG_FORMAT_COMMENT_ANCHOR;
  4330| #if !defined(TARGET_64BIT)
  4331|     if ((varDsc->TypeGet() == TYP_LONG) && varDsc->lvPromoted)
  4332|     {
  4333|         noway_assert(varDsc->lvFieldCnt == 2);
  4334|         fieldVarNum = varDsc->lvFieldLclStart;
  4335|         lvaTable[fieldVarNum].SetStackOffset(varDsc->GetStackOffset());
  4336|         lvaTable[fieldVarNum + 1].SetStackOffset(varDsc->GetStackOffset() + genTypeSize(TYP_INT));
  4337|     }
  4338|     else
  4339| #endif // !defined(TARGET_64BIT)
  4340|         if (varDsc->lvPromotedStruct())
  4341|     {
  4342|         unsigned firstFieldNum = varDsc->lvFieldLclStart;
  4343|         for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
  4344|         {
  4345|             LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
  4346|             JITDUMP("Adjusting offset of dependent V%02u of arg V%02u: parent %u field %u net %u\n", lclNum,
  4347|                     firstFieldNum + i, varDsc->GetStackOffset(), fieldVarDsc->lvFldOffset,
  4348|                     varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
  4349|             fieldVarDsc->SetStackOffset(varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
  4350|         }
  4351|     }
  4352|     if (info.compArgOrder == Target::ARG_ORDER_R2L && !varDsc->lvIsRegArg)
  4353|     {
  4354|         argOffs += argSize;
  4355|     }
  4356|     return argOffs;
  4357| }
  4358| #endif // !UNIX_AMD64_ABI
  4359| void Compiler::lvaAssignVirtualFrameOffsetsToLocals()
  4360| {
  4361|     int stkOffs              = 0;
  4362|     int originalFrameStkOffs = 0;
  4363|     int originalFrameSize    = 0;
  4364|     if (lvaDoneFrameLayout <= PRE_REGALLOC_FRAME_LAYOUT)
  4365|     {
  4366|         codeGen->setFramePointerUsed(codeGen->isFramePointerRequired());
  4367|     }
  4368| #ifdef TARGET_ARM64
  4369|     if (opts.compJitSaveFpLrWithCalleeSavedRegisters == 0)
  4370|     {
  4371|         codeGen->SetSaveFpLrWithAllCalleeSavedRegisters((getNeedsGSSecurityCookie() && compLocallocUsed) ||
  4372|                                                         opts.compDbgEnC || compStressCompile(STRESS_GENERIC_VARN, 20));
  4373|     }
  4374|     else if (opts.compJitSaveFpLrWithCalleeSavedRegisters == 1)
  4375|     {
  4376|         codeGen->SetSaveFpLrWithAllCalleeSavedRegisters(false); // Disable using new frames
  4377|     }
  4378|     else if ((opts.compJitSaveFpLrWithCalleeSavedRegisters == 2) || (opts.compJitSaveFpLrWithCalleeSavedRegisters == 3))
  4379|     {
  4380|         codeGen->SetSaveFpLrWithAllCalleeSavedRegisters(true); // Force using new frames
  4381|     }
  4382| #endif // TARGET_ARM64
  4383| #ifdef TARGET_XARCH
  4384|     stkOffs -= TARGET_POINTER_SIZE; // return address;
  4385|     if (lvaRetAddrVar != BAD_VAR_NUM)
  4386|     {
  4387|         lvaTable[lvaRetAddrVar].SetStackOffset(stkOffs);
  4388|     }
  4389| #endif
  4390|     if (opts.IsOSR())
  4391|     {
  4392|         originalFrameSize    = info.compPatchpointInfo->TotalFrameSize();
  4393|         originalFrameStkOffs = stkOffs;
  4394|         stkOffs -= originalFrameSize;
  4395|     }
  4396| #ifdef TARGET_XARCH
  4397|     if (codeGen->doubleAlignOrFramePointerUsed())
  4398|     {
  4399|         stkOffs -= REGSIZE_BYTES;
  4400|     }
  4401| #endif
  4402|     int  preSpillSize    = 0;
  4403|     bool mustDoubleAlign = false;
  4404| #ifdef TARGET_ARM
  4405|     mustDoubleAlign = true;
  4406|     preSpillSize    = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * REGSIZE_BYTES;
  4407| #else // !TARGET_ARM
  4408| #if DOUBLE_ALIGN
  4409|     if (genDoubleAlign())
  4410|     {
  4411|         mustDoubleAlign = true; // X86 only
  4412|     }
  4413| #endif
  4414| #endif // !TARGET_ARM
  4415| #ifdef TARGET_ARM64
  4416|     int initialStkOffs = 0;
  4417|     if (info.compIsVarArgs)
  4418|     {
  4419|         initialStkOffs = MAX_REG_ARG * REGSIZE_BYTES;
  4420|         stkOffs -= initialStkOffs;
  4421|     }
  4422|     if (codeGen->IsSaveFpLrWithAllCalleeSavedRegisters() ||
  4423|         !isFramePointerUsed()) // Note that currently we always have a frame pointer
  4424|     {
  4425|         stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;
  4426|     }
  4427|     else
  4428|     {
  4429|         assert(compCalleeRegsPushed >= 2);
  4430|         stkOffs -= (compCalleeRegsPushed - 2) * REGSIZE_BYTES;
  4431|     }
  4432| #elif defined(TARGET_LOONGARCH64)
  4433|     assert(compCalleeRegsPushed >= 2);
  4434|     stkOffs -= (compCalleeRegsPushed - 2) * REGSIZE_BYTES;
  4435| #else // !TARGET_LOONGARCH64
  4436| #ifdef TARGET_ARM
  4437|     if (lvaRetAddrVar != BAD_VAR_NUM)
  4438|     {
  4439|         lvaTable[lvaRetAddrVar].SetStackOffset(stkOffs - REGSIZE_BYTES);
  4440|     }
  4441| #endif
  4442|     stkOffs -= compCalleeRegsPushed * REGSIZE_BYTES;
  4443| #endif // !TARGET_LOONGARCH64
  4444|     compLclFrameSize = 0;
  4445| #ifdef TARGET_AMD64
  4446|     if (doesMethodHavePatchpoints() || doesMethodHavePartialCompilationPatchpoints())
  4447|     {
  4448|         const unsigned regsPushed    = compCalleeRegsPushed + (codeGen->isFramePointerUsed() ? 1 : 0);
  4449|         const unsigned extraSlots    = genCountBits(RBM_OSR_INT_CALLEE_SAVED) - regsPushed;
  4450|         const unsigned extraSlotSize = extraSlots * REGSIZE_BYTES;
  4451|         JITDUMP("\nMethod has patchpoints and has %u callee saves.\n"
  4452|                 "Reserving %u extra slots (%u bytes) for potential OSR method callee saves\n",
  4453|                 regsPushed, extraSlots, extraSlotSize);
  4454|         stkOffs -= extraSlotSize;
  4455|         lvaIncrementFrameSize(extraSlotSize);
  4456|     }
  4457|     const unsigned calleeFPRegsSavedSize = genCountBits(compCalleeFPRegsSavedMask) * XMM_REGSIZE_BYTES;
  4458|     const int offsetForAlign = -(stkOffs + originalFrameSize);
  4459|     if ((calleeFPRegsSavedSize > 0) && ((offsetForAlign % XMM_REGSIZE_BYTES) != 0))
  4460|     {
  4461|         int alignPad = (int)AlignmentPad((unsigned)offsetForAlign, XMM_REGSIZE_BYTES);
  4462|         assert(alignPad != 0);
  4463|         stkOffs -= alignPad;
  4464|         lvaIncrementFrameSize(alignPad);
  4465|     }
  4466|     stkOffs -= calleeFPRegsSavedSize;
  4467|     lvaIncrementFrameSize(calleeFPRegsSavedSize);
  4468|     if (compVSQuirkStackPaddingNeeded > 0)
  4469|     {
  4470| #ifdef DEBUG
  4471|         if (verbose)
  4472|         {
  4473|             printf("\nAdding VS quirk stack padding of %d bytes between save-reg area and locals\n",
  4474|                    compVSQuirkStackPaddingNeeded);
  4475|         }
  4476| #endif // DEBUG
  4477|         stkOffs -= compVSQuirkStackPaddingNeeded;
  4478|         lvaIncrementFrameSize(compVSQuirkStackPaddingNeeded);
  4479|     }
  4480| #endif // TARGET_AMD64
  4481|     if (lvaMonAcquired != BAD_VAR_NUM)
  4482|     {
  4483|         if (opts.IsOSR())
  4484|         {
  4485|             assert(info.compPatchpointInfo->HasMonitorAcquired());
  4486|             int originalOffset = info.compPatchpointInfo->MonitorAcquiredOffset();
  4487|             int offset         = originalFrameStkOffs + originalOffset;
  4488|             JITDUMP(
  4489|                 "---OSR--- V%02u (on tier0 frame, monitor acquired) tier0 FP-rel offset %d tier0 frame offset %d new "
  4490|                 "virt offset %d\n",
  4491|                 lvaMonAcquired, originalOffset, originalFrameStkOffs, offset);
  4492|             lvaTable[lvaMonAcquired].SetStackOffset(offset);
  4493|         }
  4494|         else
  4495|         {
  4496|             stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaMonAcquired, lvaLclSize(lvaMonAcquired), stkOffs);
  4497|         }
  4498|     }
  4499| #if defined(FEATURE_EH_FUNCLETS) && (defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64))
  4500|     if (lvaPSPSym != BAD_VAR_NUM)
  4501|     {
  4502|         noway_assert(codeGen->isFramePointerUsed()); // We need an explicit frame pointer
  4503|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);
  4504|     }
  4505| #endif // FEATURE_EH_FUNCLETS && (TARGET_ARMARCH || TARGET_LOONGARCH64)
  4506|     if (mustDoubleAlign)
  4507|     {
  4508|         if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  4509|         {
  4510|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4511|             stkOffs -= TARGET_POINTER_SIZE;
  4512|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4513|             stkOffs -= TARGET_POINTER_SIZE;
  4514|         }
  4515|         else // FINAL_FRAME_LAYOUT
  4516|         {
  4517|             if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
  4518|             {
  4519|                 lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4520|                 stkOffs -= TARGET_POINTER_SIZE;
  4521|             }
  4522|             noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
  4523|         }
  4524|     }
  4525| #ifdef JIT32_GCENCODER
  4526|     if (lvaLocAllocSPvar != BAD_VAR_NUM)
  4527|     {
  4528|         noway_assert(codeGen->isFramePointerUsed()); // else offsets of locals of frameless methods will be incorrect
  4529|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaLocAllocSPvar, TARGET_POINTER_SIZE, stkOffs);
  4530|     }
  4531| #endif // JIT32_GCENCODER
  4532|     if (lvaReportParamTypeArg())
  4533|     {
  4534| #ifdef JIT32_GCENCODER
  4535|         noway_assert(codeGen->isFramePointerUsed());
  4536| #endif
  4537|         if (opts.IsOSR())
  4538|         {
  4539|             PatchpointInfo* ppInfo = info.compPatchpointInfo;
  4540|             assert(ppInfo->HasGenericContextArgOffset());
  4541|             const int originalOffset       = ppInfo->GenericContextArgOffset();
  4542|             lvaCachedGenericContextArgOffs = originalFrameStkOffs + originalOffset;
  4543|         }
  4544|         else
  4545|         {
  4546|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4547|             stkOffs -= TARGET_POINTER_SIZE;
  4548|             lvaCachedGenericContextArgOffs = stkOffs;
  4549|         }
  4550|     }
  4551| #ifndef JIT32_GCENCODER
  4552|     else if (lvaKeepAliveAndReportThis())
  4553|     {
  4554|         bool canUseExistingSlot = false;
  4555|         if (opts.IsOSR())
  4556|         {
  4557|             PatchpointInfo* ppInfo = info.compPatchpointInfo;
  4558|             if (ppInfo->HasKeptAliveThis())
  4559|             {
  4560|                 const int originalOffset       = ppInfo->KeptAliveThisOffset();
  4561|                 lvaCachedGenericContextArgOffs = originalFrameStkOffs + originalOffset;
  4562|                 canUseExistingSlot             = true;
  4563|             }
  4564|         }
  4565|         if (!canUseExistingSlot)
  4566|         {
  4567|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4568|             stkOffs -= TARGET_POINTER_SIZE;
  4569|             lvaCachedGenericContextArgOffs = stkOffs;
  4570|         }
  4571|     }
  4572| #endif
  4573| #if !defined(FEATURE_EH_FUNCLETS)
  4574|     /* If we need space for slots for shadow SP, reserve it now */
  4575|     if (ehNeedsShadowSPslots())
  4576|     {
  4577|         noway_assert(codeGen->isFramePointerUsed()); // else offsets of locals of frameless methods will be incorrect
  4578|         if (!lvaReportParamTypeArg())
  4579|         {
  4580| #ifndef JIT32_GCENCODER
  4581|             if (!lvaKeepAliveAndReportThis())
  4582| #endif
  4583|             {
  4584|                 lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4585|                 stkOffs -= TARGET_POINTER_SIZE;
  4586|             }
  4587|         }
  4588|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaShadowSPslotsVar, lvaLclSize(lvaShadowSPslotsVar), stkOffs);
  4589|     }
  4590| #endif // !FEATURE_EH_FUNCLETS
  4591|     if (compGSReorderStackLayout)
  4592|     {
  4593|         assert(getNeedsGSSecurityCookie());
  4594|         if (!opts.IsOSR() || !info.compPatchpointInfo->HasSecurityCookie())
  4595|         {
  4596|             stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaGSSecurityCookie, lvaLclSize(lvaGSSecurityCookie), stkOffs);
  4597|         }
  4598|     }
  4599|     /*
  4600|         If we're supposed to track lifetimes of pointer temps, we'll
  4601|         assign frame offsets in the following order:
  4602|             non-pointer local variables (also untracked pointer variables)
  4603|                 pointer local variables
  4604|                 pointer temps
  4605|             non-pointer temps
  4606|      */
  4607|     enum Allocation
  4608|     {
  4609|         ALLOC_NON_PTRS                 = 0x1, // assign offsets to non-ptr
  4610|         ALLOC_PTRS                     = 0x2, // Second pass, assign offsets to tracked ptrs
  4611|         ALLOC_UNSAFE_BUFFERS           = 0x4,
  4612|         ALLOC_UNSAFE_BUFFERS_WITH_PTRS = 0x8
  4613|     };
  4614|     UINT alloc_order[5];
  4615|     unsigned int cur = 0;
  4616|     if (compGSReorderStackLayout)
  4617|     {
  4618|         noway_assert(getNeedsGSSecurityCookie());
  4619|         if (codeGen->isFramePointerUsed())
  4620|         {
  4621|             alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;
  4622|             alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
  4623|         }
  4624|     }
  4625|     bool tempsAllocated = false;
  4626|     if (lvaTempsHaveLargerOffsetThanVars() && !codeGen->isFramePointerUsed())
  4627|     {
  4628|         noway_assert(!tempsAllocated);
  4629|         stkOffs        = lvaAllocateTemps(stkOffs, mustDoubleAlign);
  4630|         tempsAllocated = true;
  4631|     }
  4632|     alloc_order[cur++] = ALLOC_NON_PTRS;
  4633|     if (opts.compDbgEnC)
  4634|     {
  4635|         /* We will use just one pass, and assign offsets to all variables */
  4636|         alloc_order[cur - 1] |= ALLOC_PTRS;
  4637|         noway_assert(compGSReorderStackLayout == false);
  4638|     }
  4639|     else
  4640|     {
  4641|         alloc_order[cur++] = ALLOC_PTRS;
  4642|     }
  4643|     if (!codeGen->isFramePointerUsed() && compGSReorderStackLayout)
  4644|     {
  4645|         alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
  4646|         alloc_order[cur++] = ALLOC_UNSAFE_BUFFERS;
  4647|     }
  4648|     alloc_order[cur] = 0;
  4649|     noway_assert(cur < ArrLen(alloc_order));
  4650|     UINT assignMore             = 0xFFFFFFFF;
  4651|     bool have_LclVarDoubleAlign = false;
  4652|     for (cur = 0; alloc_order[cur]; cur++)
  4653|     {
  4654|         if ((assignMore & alloc_order[cur]) == 0)
  4655|         {
  4656|             continue;
  4657|         }
  4658|         assignMore = 0;
  4659|         unsigned   lclNum;
  4660|         LclVarDsc* varDsc;
  4661|         for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  4662|         {
  4663|             /* Ignore field locals of the promotion type PROMOTION_TYPE_FIELD_DEPENDENT.
  4664|                In other words, we will not calculate the "base" address of the struct local if
  4665|                the promotion type is PROMOTION_TYPE_FIELD_DEPENDENT.
  4666|             */
  4667|             if (lvaIsFieldOfDependentlyPromotedStruct(varDsc))
  4668|             {
  4669|                 continue;
  4670|             }
  4671| #if FEATURE_FIXED_OUT_ARGS
  4672|             if (lclNum == lvaOutgoingArgSpaceVar)
  4673|             {
  4674|                 continue;
  4675|             }
  4676| #endif
  4677|             bool allocateOnFrame = varDsc->lvOnFrame;
  4678|             if (varDsc->lvRegister && (lvaDoneFrameLayout == REGALLOC_FRAME_LAYOUT) &&
  4679|                 ((varDsc->TypeGet() != TYP_LONG) || (varDsc->GetOtherReg() != REG_STK)))
  4680|             {
  4681|                 allocateOnFrame = false;
  4682|             }
  4683|             if (lvaIsOSRLocal(lclNum))
  4684|             {
  4685|                 if (varDsc->lvIsStructField)
  4686|                 {
  4687|                     const unsigned parentLclNum         = varDsc->lvParentLcl;
  4688|                     const int      parentOriginalOffset = info.compPatchpointInfo->Offset(parentLclNum);
  4689|                     const int      offset = originalFrameStkOffs + parentOriginalOffset + varDsc->lvFldOffset;
  4690|                     JITDUMP("---OSR--- V%02u (promoted field of V%02u; on tier0 frame) tier0 FP-rel offset %d tier0 "
  4691|                             "frame offset %d field offset %d new virt offset "
  4692|                             "%d\n",
  4693|                             lclNum, parentLclNum, parentOriginalOffset, originalFrameStkOffs, varDsc->lvFldOffset,
  4694|                             offset);
  4695|                     lvaTable[lclNum].SetStackOffset(offset);
  4696|                 }
  4697|                 else
  4698|                 {
  4699|                     const int originalOffset = info.compPatchpointInfo->Offset(lclNum);
  4700|                     const int offset         = originalFrameStkOffs + originalOffset;
  4701|                     JITDUMP(
  4702|                         "---OSR--- V%02u (on tier0 frame) tier0 FP-rel offset %d tier0 frame offset %d new virt offset "
  4703|                         "%d\n",
  4704|                         lclNum, originalOffset, originalFrameStkOffs, offset);
  4705|                     lvaTable[lclNum].SetStackOffset(offset);
  4706|                 }
  4707|                 continue;
  4708|             }
  4709|             /* Ignore variables that are not on the stack frame */
  4710|             if (!allocateOnFrame)
  4711|             {
  4712|                 /* For EnC, all variables have to be allocated space on the
  4713|                    stack, even though they may actually be enregistered. This
  4714|                    way, the frame layout can be directly inferred from the
  4715|                    locals-sig.
  4716|                  */
  4717|                 if (!opts.compDbgEnC)
  4718|                 {
  4719|                     continue;
  4720|                 }
  4721|                 else if (lclNum >= info.compLocalsCount)
  4722|                 { // ignore temps for EnC
  4723|                     continue;
  4724|                 }
  4725|             }
  4726|             else if (lvaGSSecurityCookie == lclNum && getNeedsGSSecurityCookie())
  4727|             {
  4728|                 if (opts.IsOSR() && info.compPatchpointInfo->HasSecurityCookie())
  4729|                 {
  4730|                     int originalOffset = info.compPatchpointInfo->SecurityCookieOffset();
  4731|                     int offset         = originalFrameStkOffs + originalOffset;
  4732|                     JITDUMP("---OSR--- V%02u (on tier0 frame, security cookie) tier0 FP-rel offset %d tier0 frame "
  4733|                             "offset %d new "
  4734|                             "virt offset %d\n",
  4735|                             lclNum, originalOffset, originalFrameStkOffs, offset);
  4736|                     lvaTable[lclNum].SetStackOffset(offset);
  4737|                 }
  4738|                 continue;
  4739|             }
  4740|             if (
  4741| #if defined(FEATURE_EH_FUNCLETS)
  4742|                 lclNum == lvaPSPSym ||
  4743| #else
  4744|                 lclNum == lvaShadowSPslotsVar ||
  4745| #endif // FEATURE_EH_FUNCLETS
  4746| #ifdef JIT32_GCENCODER
  4747|                 lclNum == lvaLocAllocSPvar ||
  4748| #endif // JIT32_GCENCODER
  4749|                 lclNum == lvaRetAddrVar)
  4750|             {
  4751|                 assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
  4752|                 continue;
  4753|             }
  4754|             if (lclNum == lvaMonAcquired)
  4755|             {
  4756|                 continue;
  4757|             }
  4758|             if (lclNum == lvaStubArgumentVar)
  4759|             {
  4760| #ifdef JIT32_GCENCODER
  4761|                 noway_assert(codeGen->isFramePointerUsed());
  4762| #endif
  4763|                 continue;
  4764|             }
  4765|             if (lclNum == lvaInlinedPInvokeFrameVar)
  4766|             {
  4767|                 noway_assert(codeGen->isFramePointerUsed());
  4768|                 continue;
  4769|             }
  4770|             if (varDsc->lvIsParam)
  4771|             {
  4772| #if defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI)
  4773|                 assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
  4774|                 continue;
  4775| #else // !TARGET_AMD64
  4776|                 if (!varDsc->lvIsRegArg)
  4777|                 {
  4778|                     continue;
  4779|                 }
  4780| #ifdef TARGET_ARM64
  4781|                 if (info.compIsVarArgs && varDsc->GetArgReg() != theFixedRetBuffArgNum())
  4782|                 {
  4783|                     const unsigned regArgNum = genMapIntRegNumToRegArgNum(varDsc->GetArgReg());
  4784|                     varDsc->SetStackOffset(-initialStkOffs + regArgNum * REGSIZE_BYTES);
  4785|                     continue;
  4786|                 }
  4787| #endif
  4788| #ifdef TARGET_ARM
  4789|                 if ((codeGen->regSet.rsMaskPreSpillRegs(false) & genRegMask(varDsc->GetArgReg())) != 0)
  4790|                 {
  4791|                     assert(varDsc->GetStackOffset() != BAD_STK_OFFS);
  4792|                     continue;
  4793|                 }
  4794| #endif
  4795| #endif // !TARGET_AMD64
  4796|             }
  4797|             /* Make sure the type is appropriate */
  4798|             if (varDsc->lvIsUnsafeBuffer && compGSReorderStackLayout)
  4799|             {
  4800|                 if (varDsc->lvIsPtr)
  4801|                 {
  4802|                     if ((alloc_order[cur] & ALLOC_UNSAFE_BUFFERS_WITH_PTRS) == 0)
  4803|                     {
  4804|                         assignMore |= ALLOC_UNSAFE_BUFFERS_WITH_PTRS;
  4805|                         continue;
  4806|                     }
  4807|                 }
  4808|                 else
  4809|                 {
  4810|                     if ((alloc_order[cur] & ALLOC_UNSAFE_BUFFERS) == 0)
  4811|                     {
  4812|                         assignMore |= ALLOC_UNSAFE_BUFFERS;
  4813|                         continue;
  4814|                     }
  4815|                 }
  4816|             }
  4817|             else if (varTypeIsGC(varDsc->TypeGet()) && varDsc->lvTracked)
  4818|             {
  4819|                 if ((alloc_order[cur] & ALLOC_PTRS) == 0)
  4820|                 {
  4821|                     assignMore |= ALLOC_PTRS;
  4822|                     continue;
  4823|                 }
  4824|             }
  4825|             else
  4826|             {
  4827|                 if ((alloc_order[cur] & ALLOC_NON_PTRS) == 0)
  4828|                 {
  4829|                     assignMore |= ALLOC_NON_PTRS;
  4830|                     continue;
  4831|                 }
  4832|             }
  4833|             /* Need to align the offset? */
  4834|             if (mustDoubleAlign && (varDsc->lvType == TYP_DOUBLE // Align doubles for ARM and x86
  4835| #ifdef TARGET_ARM
  4836|                                     || varDsc->lvType == TYP_LONG // Align longs for ARM
  4837| #endif
  4838| #ifndef TARGET_64BIT
  4839|                                     || varDsc->lvStructDoubleAlign // Align when lvStructDoubleAlign is true
  4840| #endif                                                             // !TARGET_64BIT
  4841|                                     ))
  4842|             {
  4843|                 noway_assert((compLclFrameSize % TARGET_POINTER_SIZE) == 0);
  4844|                 if ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) && !have_LclVarDoubleAlign)
  4845|                 {
  4846|                     lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4847|                     stkOffs -= TARGET_POINTER_SIZE;
  4848|                 }
  4849|                 else
  4850|                 {
  4851|                     if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
  4852|                     {
  4853|                         lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4854|                         stkOffs -= TARGET_POINTER_SIZE;
  4855|                     }
  4856|                     noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
  4857|                 }
  4858|                 have_LclVarDoubleAlign = true;
  4859|             }
  4860|             stkOffs = lvaAllocLocalAndSetVirtualOffset(lclNum, lvaLclSize(lclNum), stkOffs);
  4861| #if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
  4862|             if (varDsc->lvIsRegArg && varDsc->lvPromotedStruct())
  4863|             {
  4864|                 unsigned firstFieldNum = varDsc->lvFieldLclStart;
  4865|                 for (unsigned i = 0; i < varDsc->lvFieldCnt; i++)
  4866|                 {
  4867|                     LclVarDsc* fieldVarDsc = lvaGetDesc(firstFieldNum + i);
  4868|                     fieldVarDsc->SetStackOffset(varDsc->GetStackOffset() + fieldVarDsc->lvFldOffset);
  4869|                 }
  4870|             }
  4871| #ifdef TARGET_ARM
  4872|             else if (varDsc->lvIsRegArg && varDsc->lvPromoted)
  4873|             {
  4874|                 assert(varTypeIsLong(varDsc) && (varDsc->lvFieldCnt == 2));
  4875|                 unsigned fieldVarNum = varDsc->lvFieldLclStart;
  4876|                 lvaTable[fieldVarNum].SetStackOffset(varDsc->GetStackOffset());
  4877|                 lvaTable[fieldVarNum + 1].SetStackOffset(varDsc->GetStackOffset() + 4);
  4878|             }
  4879| #endif // TARGET_ARM
  4880| #endif // TARGET_ARM64 || TARGET_LOONGARCH64
  4881|         }
  4882|     }
  4883|     if (getNeedsGSSecurityCookie() && !compGSReorderStackLayout)
  4884|     {
  4885|         if (!opts.IsOSR() || !info.compPatchpointInfo->HasSecurityCookie())
  4886|         {
  4887|             stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaGSSecurityCookie, lvaLclSize(lvaGSSecurityCookie), stkOffs);
  4888|         }
  4889|     }
  4890|     if (tempsAllocated == false)
  4891|     {
  4892|         /*-------------------------------------------------------------------------
  4893|          *
  4894|          * Now the temps
  4895|          *
  4896|          *-------------------------------------------------------------------------
  4897|          */
  4898|         stkOffs = lvaAllocateTemps(stkOffs, mustDoubleAlign);
  4899|     }
  4900|     /*-------------------------------------------------------------------------
  4901|      *
  4902|      * Now do some final stuff
  4903|      *
  4904|      *-------------------------------------------------------------------------
  4905|      */
  4906|     if (lvaStubArgumentVar != BAD_VAR_NUM)
  4907|     {
  4908| #ifdef JIT32_GCENCODER
  4909|         noway_assert(codeGen->isFramePointerUsed());
  4910| #endif
  4911|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaStubArgumentVar, lvaLclSize(lvaStubArgumentVar), stkOffs);
  4912|     }
  4913|     if (lvaInlinedPInvokeFrameVar != BAD_VAR_NUM)
  4914|     {
  4915|         noway_assert(codeGen->isFramePointerUsed());
  4916|         stkOffs =
  4917|             lvaAllocLocalAndSetVirtualOffset(lvaInlinedPInvokeFrameVar, lvaLclSize(lvaInlinedPInvokeFrameVar), stkOffs);
  4918|     }
  4919|     if (mustDoubleAlign)
  4920|     {
  4921|         if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  4922|         {
  4923|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4924|             stkOffs -= TARGET_POINTER_SIZE;
  4925|             if (have_LclVarDoubleAlign)
  4926|             {
  4927|                 lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4928|                 stkOffs -= TARGET_POINTER_SIZE;
  4929|             }
  4930|         }
  4931|         else // FINAL_FRAME_LAYOUT
  4932|         {
  4933|             if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
  4934|             {
  4935|                 lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  4936|                 stkOffs -= TARGET_POINTER_SIZE;
  4937|             }
  4938|             noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
  4939|         }
  4940|     }
  4941| #if defined(FEATURE_EH_FUNCLETS) && defined(TARGET_AMD64)
  4942|     if (lvaPSPSym != BAD_VAR_NUM)
  4943|     {
  4944|         noway_assert(codeGen->isFramePointerUsed()); // We need an explicit frame pointer
  4945|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaPSPSym, TARGET_POINTER_SIZE, stkOffs);
  4946|     }
  4947| #endif // FEATURE_EH_FUNCLETS && defined(TARGET_AMD64)
  4948| #ifdef TARGET_ARM64
  4949|     if (!codeGen->IsSaveFpLrWithAllCalleeSavedRegisters() &&
  4950|         isFramePointerUsed()) // Note that currently we always have a frame pointer
  4951|     {
  4952|         stkOffs -= 2 * REGSIZE_BYTES;
  4953|     }
  4954| #endif // TARGET_ARM64
  4955| #if defined(TARGET_LOONGARCH64)
  4956|     assert(isFramePointerUsed()); // Note that currently we always have a frame pointer
  4957|     stkOffs -= 2 * REGSIZE_BYTES;
  4958| #endif // TARGET_LOONGARCH64
  4959| #if FEATURE_FIXED_OUT_ARGS
  4960|     if (lvaOutgoingArgSpaceSize > 0)
  4961|     {
  4962| #if defined(TARGET_AMD64) && !defined(UNIX_AMD64_ABI) // No 4 slots for outgoing params on System V.
  4963|         noway_assert(lvaOutgoingArgSpaceSize >= (4 * TARGET_POINTER_SIZE));
  4964| #endif
  4965|         noway_assert((lvaOutgoingArgSpaceSize % TARGET_POINTER_SIZE) == 0);
  4966|         stkOffs = lvaAllocLocalAndSetVirtualOffset(lvaOutgoingArgSpaceVar, lvaLclSize(lvaOutgoingArgSpaceVar), stkOffs);
  4967|     }
  4968| #endif // FEATURE_FIXED_OUT_ARGS
  4969|     int pushedCount = compCalleeRegsPushed;
  4970| #ifdef TARGET_ARM64
  4971|     if (info.compIsVarArgs)
  4972|     {
  4973|         pushedCount += MAX_REG_ARG;
  4974|     }
  4975| #endif
  4976| #ifdef TARGET_XARCH
  4977|     if (codeGen->doubleAlignOrFramePointerUsed())
  4978|     {
  4979|         pushedCount += 1; // pushed EBP (frame pointer)
  4980|     }
  4981|     pushedCount += 1; // pushed PC (return address)
  4982| #endif
  4983|     noway_assert(compLclFrameSize + originalFrameSize ==
  4984|                  (unsigned)-(stkOffs + (pushedCount * (int)TARGET_POINTER_SIZE)));
  4985| }
  4986| int Compiler::lvaAllocLocalAndSetVirtualOffset(unsigned lclNum, unsigned size, int stkOffs)
  4987| {
  4988|     noway_assert(lclNum != BAD_VAR_NUM);
  4989| #ifdef TARGET_64BIT
  4990|     if ((size >= 8) && ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || ((stkOffs % 8) != 0)
  4991| #if defined(FEATURE_SIMD) && ALIGN_SIMD_TYPES
  4992|                         || lclVarIsSIMDType(lclNum)
  4993| #endif
  4994|                             ))
  4995|     {
  4996|         assert(stkOffs <= 0);
  4997|         unsigned pad = 0;
  4998| #if defined(FEATURE_SIMD) && ALIGN_SIMD_TYPES
  4999|         if (lclVarIsSIMDType(lclNum) && !lvaIsImplicitByRefLocal(lclNum))
  5000|         {
  5001|             int alignment = getSIMDTypeAlignment(lvaTable[lclNum].lvType);
  5002|             if (stkOffs % alignment != 0)
  5003|             {
  5004|                 if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  5005|                 {
  5006|                     pad = alignment - 1;
  5007|                 }
  5008|                 else
  5009|                 {
  5010|                     pad = alignment + (stkOffs % alignment); // +1 to +(alignment-1) bytes
  5011|                 }
  5012|             }
  5013|         }
  5014|         else
  5015| #endif // FEATURE_SIMD && ALIGN_SIMD_TYPES
  5016|         {
  5017|             if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  5018|             {
  5019|                 pad = 7;
  5020|             }
  5021|             else
  5022|             {
  5023|                 pad = 8 + (stkOffs % 8); // +1 to +7 bytes
  5024|             }
  5025|         }
  5026|         lvaIncrementFrameSize(pad);
  5027|         stkOffs -= pad;
  5028| #ifdef DEBUG
  5029|         if (verbose)
  5030|         {
  5031|             printf("Pad ");
  5032|             gtDispLclVar(lclNum, /*pad*/ false);
  5033|             printf(", size=%d, stkOffs=%c0x%x, pad=%d\n", size, stkOffs < 0 ? '-' : '+',
  5034|                    stkOffs < 0 ? -stkOffs : stkOffs, pad);
  5035|         }
  5036| #endif
  5037|     }
  5038| #endif // TARGET_64BIT
  5039|     /* Reserve space on the stack by bumping the frame size */
  5040|     lvaIncrementFrameSize(size);
  5041|     stkOffs -= size;
  5042|     lvaTable[lclNum].SetStackOffset(stkOffs);
  5043| #ifdef DEBUG
  5044|     if (verbose)
  5045|     {
  5046|         printf("Assign ");
  5047|         gtDispLclVar(lclNum, /*pad*/ false);
  5048|         printf(", size=%d, stkOffs=%c0x%x\n", size, stkOffs < 0 ? '-' : '+', stkOffs < 0 ? -stkOffs : stkOffs);
  5049|     }
  5050| #endif
  5051|     return stkOffs;
  5052| }
  5053| #ifdef TARGET_AMD64
  5054| /*****************************************************************************
  5055|  *  lvaIsCalleeSavedIntRegCountEven() :  returns true if the number of integer registers
  5056|  *  pushed onto stack is even including RBP if used as frame pointer
  5057|  *
  5058|  *  Note that this excludes return address (PC) pushed by caller.  To know whether
  5059|  *  the SP offset after pushing integer registers is aligned, we need to take
  5060|  *  negation of this routine.
  5061|  */
  5062| bool Compiler::lvaIsCalleeSavedIntRegCountEven()
  5063| {
  5064|     unsigned regsPushed = compCalleeRegsPushed + (codeGen->isFramePointerUsed() ? 1 : 0);
  5065|     return (regsPushed % (16 / REGSIZE_BYTES)) == 0;
  5066| }
  5067| #endif // TARGET_AMD64
  5068| /*****************************************************************************
  5069|  *  lvaAlignFrame() :  After allocating everything on the frame, reserve any
  5070|  *  extra space needed to keep the frame aligned
  5071|  */
  5072| void Compiler::lvaAlignFrame()
  5073| {
  5074| #if defined(TARGET_AMD64)
  5075|     if ((compLclFrameSize % 8) != 0)
  5076|     {
  5077|         lvaIncrementFrameSize(8 - (compLclFrameSize % 8));
  5078|     }
  5079|     else if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  5080|     {
  5081|         lvaIncrementFrameSize(8);
  5082|     }
  5083|     assert((compLclFrameSize % 8) == 0);
  5084|     bool regPushedCountAligned = lvaIsCalleeSavedIntRegCountEven();
  5085|     bool lclFrameSizeAligned   = (compLclFrameSize % 16) == 0;
  5086|     CLANG_FORMAT_COMMENT_ANCHOR;
  5087| #ifdef UNIX_AMD64_ABI
  5088|     bool stackNeedsAlignment = (compLclFrameSize != 0 || opts.compNeedToAlignFrame);
  5089| #else  // !UNIX_AMD64_ABI
  5090|     bool stackNeedsAlignment = compLclFrameSize != 0;
  5091| #endif // !UNIX_AMD64_ABI
  5092|     if ((!codeGen->isFramePointerUsed() && (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)) ||
  5093|         (stackNeedsAlignment && (regPushedCountAligned == lclFrameSizeAligned)))
  5094|     {
  5095|         lvaIncrementFrameSize(REGSIZE_BYTES);
  5096|     }
  5097| #elif defined(TARGET_ARM64) || defined(TARGET_LOONGARCH64)
  5098|     if ((compLclFrameSize % 8) != 0)
  5099|     {
  5100|         lvaIncrementFrameSize(8 - (compLclFrameSize % 8));
  5101|     }
  5102|     else if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  5103|     {
  5104|         lvaIncrementFrameSize(8);
  5105|     }
  5106|     assert((compLclFrameSize % 8) == 0);
  5107|     bool regPushedCountAligned = (compCalleeRegsPushed % (16 / REGSIZE_BYTES)) == 0;
  5108|     bool lclFrameSizeAligned   = (compLclFrameSize % 16) == 0;
  5109|     if ((lvaDoneFrameLayout != FINAL_FRAME_LAYOUT) || (regPushedCountAligned != lclFrameSizeAligned))
  5110|     {
  5111|         lvaIncrementFrameSize(REGSIZE_BYTES);
  5112|     }
  5113| #elif defined(TARGET_ARM)
  5114|     bool lclFrameSizeAligned   = (compLclFrameSize % sizeof(double)) == 0;
  5115|     bool regPushedCountAligned = ((compCalleeRegsPushed + genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true))) %
  5116|                                   (sizeof(double) / TARGET_POINTER_SIZE)) == 0;
  5117|     if (regPushedCountAligned != lclFrameSizeAligned)
  5118|     {
  5119|         lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  5120|     }
  5121| #elif defined(TARGET_X86)
  5122| #if DOUBLE_ALIGN
  5123|     if (genDoubleAlign())
  5124|     {
  5125|         if (compLclFrameSize == 0)
  5126|         {
  5127|             lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  5128|         }
  5129|     }
  5130| #endif
  5131|     if (STACK_ALIGN > REGSIZE_BYTES)
  5132|     {
  5133|         if (lvaDoneFrameLayout != FINAL_FRAME_LAYOUT)
  5134|         {
  5135|             lvaIncrementFrameSize(STACK_ALIGN - REGSIZE_BYTES);
  5136|         }
  5137|         int  adjustFrameSize = compLclFrameSize;
  5138| #if defined(UNIX_X86_ABI)
  5139|         bool isEbpPushed     = codeGen->isFramePointerUsed();
  5140| #if DOUBLE_ALIGN
  5141|         isEbpPushed |= genDoubleAlign();
  5142| #endif
  5143|         int adjustCount = compCalleeRegsPushed + 1 + (isEbpPushed ? 1 : 0);
  5144|         adjustFrameSize += (adjustCount * REGSIZE_BYTES) % STACK_ALIGN;
  5145| #endif
  5146|         if ((adjustFrameSize % STACK_ALIGN) != 0)
  5147|         {
  5148|             lvaIncrementFrameSize(STACK_ALIGN - (adjustFrameSize % STACK_ALIGN));
  5149|         }
  5150|     }
  5151| #else
  5152|     NYI("TARGET specific lvaAlignFrame");
  5153| #endif // !TARGET_AMD64
  5154| }
  5155| /*****************************************************************************
  5156|  *  lvaAssignFrameOffsetsToPromotedStructs() :  Assign offsets to fields
  5157|  *  within a promoted struct (worker for lvaAssignFrameOffsets).
  5158|  */
  5159| void Compiler::lvaAssignFrameOffsetsToPromotedStructs()
  5160| {
  5161|     LclVarDsc* varDsc = lvaTable;
  5162|     for (unsigned lclNum = 0; lclNum < lvaCount; lclNum++, varDsc++)
  5163|     {
  5164|         CLANG_FORMAT_COMMENT_ANCHOR;
  5165| #if defined(UNIX_AMD64_ABI) || defined(TARGET_ARM) || defined(TARGET_X86)
  5166|         const bool mustProcessParams = true;
  5167| #else
  5168|         const bool mustProcessParams = opts.IsOSR();
  5169| #endif // defined(UNIX_AMD64_ABI) || defined(TARGET_ARM) || defined(TARGET_X86)
  5170|         if (varDsc->lvIsStructField && (!varDsc->lvIsParam || mustProcessParams))
  5171|         {
  5172|             LclVarDsc*       parentvarDsc  = lvaGetDesc(varDsc->lvParentLcl);
  5173|             lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
  5174|             if (promotionType == PROMOTION_TYPE_INDEPENDENT)
  5175|             {
  5176|                 continue;
  5177|             }
  5178|             else
  5179|             {
  5180|                 noway_assert(promotionType == PROMOTION_TYPE_DEPENDENT);
  5181|                 noway_assert(varDsc->lvOnFrame);
  5182|                 if (parentvarDsc->lvOnFrame)
  5183|                 {
  5184|                     JITDUMP("Adjusting offset of dependent V%02u of V%02u: parent %u field %u net %u\n", lclNum,
  5185|                             varDsc->lvParentLcl, parentvarDsc->GetStackOffset(), varDsc->lvFldOffset,
  5186|                             parentvarDsc->GetStackOffset() + varDsc->lvFldOffset);
  5187|                     varDsc->SetStackOffset(parentvarDsc->GetStackOffset() + varDsc->lvFldOffset);
  5188|                 }
  5189|                 else
  5190|                 {
  5191|                     varDsc->lvOnFrame = false;
  5192|                     noway_assert(varDsc->lvRefCnt() == 0);
  5193|                 }
  5194|             }
  5195|         }
  5196|     }
  5197| }
  5198| /*****************************************************************************
  5199|  *  lvaAllocateTemps() :  Assign virtual offsets to temps (always negative).
  5200|  */
  5201| int Compiler::lvaAllocateTemps(int stkOffs, bool mustDoubleAlign)
  5202| {
  5203|     unsigned spillTempSize = 0;
  5204|     if (lvaDoneFrameLayout == FINAL_FRAME_LAYOUT)
  5205|     {
  5206|         int preSpillSize = 0;
  5207| #ifdef TARGET_ARM
  5208|         preSpillSize = genCountBits(codeGen->regSet.rsMaskPreSpillRegs(true)) * TARGET_POINTER_SIZE;
  5209| #endif
  5210|         /* Allocate temps */
  5211|         assert(codeGen->regSet.tmpAllFree());
  5212|         for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
  5213|         {
  5214|             var_types tempType = temp->tdTempType();
  5215|             unsigned  size     = temp->tdTempSize();
  5216|             /* Figure out and record the stack offset of the temp */
  5217|             /* Need to align the offset? */
  5218|             CLANG_FORMAT_COMMENT_ANCHOR;
  5219| #ifdef TARGET_64BIT
  5220|             if (varTypeIsGC(tempType) && ((stkOffs % TARGET_POINTER_SIZE) != 0))
  5221|             {
  5222|                 int alignPad = (int)AlignmentPad((unsigned)-stkOffs, TARGET_POINTER_SIZE);
  5223|                 spillTempSize += alignPad;
  5224|                 lvaIncrementFrameSize(alignPad);
  5225|                 stkOffs -= alignPad;
  5226|                 noway_assert((stkOffs % TARGET_POINTER_SIZE) == 0);
  5227|             }
  5228| #endif
  5229|             if (mustDoubleAlign && (tempType == TYP_DOUBLE)) // Align doubles for x86 and ARM
  5230|             {
  5231|                 noway_assert((compLclFrameSize % TARGET_POINTER_SIZE) == 0);
  5232|                 if (((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) != 0)
  5233|                 {
  5234|                     spillTempSize += TARGET_POINTER_SIZE;
  5235|                     lvaIncrementFrameSize(TARGET_POINTER_SIZE);
  5236|                     stkOffs -= TARGET_POINTER_SIZE;
  5237|                 }
  5238|                 noway_assert(((stkOffs + preSpillSize) % (2 * TARGET_POINTER_SIZE)) == 0);
  5239|             }
  5240|             spillTempSize += size;
  5241|             lvaIncrementFrameSize(size);
  5242|             stkOffs -= size;
  5243|             temp->tdSetTempOffs(stkOffs);
  5244|         }
  5245| #ifdef TARGET_ARM
  5246|         noway_assert(spillTempSize <= lvaGetMaxSpillTempSize());
  5247| #endif
  5248|     }
  5249|     else // We haven't run codegen, so there are no Spill temps yet!
  5250|     {
  5251|         unsigned size = lvaGetMaxSpillTempSize();
  5252|         lvaIncrementFrameSize(size);
  5253|         stkOffs -= size;
  5254|     }
  5255|     return stkOffs;
  5256| }
  5257| #ifdef DEBUG
  5258| /*****************************************************************************
  5259|  *
  5260|  *  Dump the register a local is in right now. It is only the current location, since the location changes and it
  5261|  *  is updated throughout code generation based on LSRA register assignments.
  5262|  */
  5263| void Compiler::lvaDumpRegLocation(unsigned lclNum)
  5264| {
  5265|     const LclVarDsc* varDsc = lvaGetDesc(lclNum);
  5266| #ifdef TARGET_ARM
  5267|     if (varDsc->TypeGet() == TYP_DOUBLE)
  5268|     {
  5269|         printf("%3s:%-3s    ", getRegName(varDsc->GetRegNum()), getRegName(REG_NEXT(varDsc->GetRegNum())));
  5270|     }
  5271|     else
  5272| #endif // TARGET_ARM
  5273|     {
  5274|         printf("%3s        ", getRegName(varDsc->GetRegNum()));
  5275|     }
  5276| }
  5277| /*****************************************************************************
  5278|  *
  5279|  *  Dump the frame location assigned to a local.
  5280|  *  It's the home location, even though the variable doesn't always live
  5281|  *  in its home location.
  5282|  */
  5283| void Compiler::lvaDumpFrameLocation(unsigned lclNum)
  5284| {
  5285|     int       offset;
  5286|     regNumber baseReg;
  5287| #ifdef TARGET_ARM
  5288|     offset = lvaFrameAddress(lclNum, compLocallocUsed, &baseReg, 0, /* isFloatUsage */ false);
  5289| #else
  5290|     bool EBPbased;
  5291|     offset  = lvaFrameAddress(lclNum, &EBPbased);
  5292|     baseReg = EBPbased ? REG_FPBASE : REG_SPBASE;
  5293| #endif
  5294|     printf("[%2s%1s%02XH]  ", getRegName(baseReg), (offset < 0 ? "-" : "+"), (offset < 0 ? -offset : offset));
  5295| }
  5296| /*****************************************************************************
  5297|  *
  5298|  *  dump a single lvaTable entry
  5299|  */
  5300| void Compiler::lvaDumpEntry(unsigned lclNum, FrameLayoutState curState, size_t refCntWtdWidth)
  5301| {
  5302|     LclVarDsc* varDsc = lvaGetDesc(lclNum);
  5303|     var_types  type   = varDsc->TypeGet();
  5304|     if (curState == INITIAL_FRAME_LAYOUT)
  5305|     {
  5306|         printf(";  ");
  5307|         gtDispLclVar(lclNum);
  5308|         printf(" %7s ", varTypeName(type));
  5309|         gtDispLclVarStructType(lclNum);
  5310|     }
  5311|     else
  5312|     {
  5313|         if (varDsc->lvRefCnt() == 0)
  5314|         {
  5315|             printf(";* ");
  5316|         }
  5317| #if FEATURE_FIXED_OUT_ARGS
  5318|         else if ((lclNum == lvaOutgoingArgSpaceVar) && lvaOutgoingArgSpaceSize.HasFinalValue() &&
  5319|                  (lvaOutgoingArgSpaceSize == 0))
  5320|         {
  5321|             printf(";# ");
  5322|         }
  5323| #endif // FEATURE_FIXED_OUT_ARGS
  5324|         else
  5325|         {
  5326|             printf(";  ");
  5327|         }
  5328|         gtDispLclVar(lclNum);
  5329|         printf("[V%02u", lclNum);
  5330|         if (varDsc->lvTracked)
  5331|         {
  5332|             printf(",T%02u]", varDsc->lvVarIndex);
  5333|         }
  5334|         else
  5335|         {
  5336|             printf("    ]");
  5337|         }
  5338|         printf(" (%3u,%*s)", varDsc->lvRefCnt(), (int)refCntWtdWidth, refCntWtd2str(varDsc->lvRefCntWtd()));
  5339|         printf(" %7s ", varTypeName(type));
  5340|         if (genTypeSize(type) == 0)
  5341|         {
  5342|             printf("(%2d) ", lvaLclSize(lclNum));
  5343|         }
  5344|         else
  5345|         {
  5346|             printf(" ->  ");
  5347|         }
  5348|         if ((varDsc->lvRefCnt() == 0) && !varDsc->lvImplicitlyReferenced)
  5349|         {
  5350|             printf("zero-ref   ");
  5351|         }
  5352|         else if (varDsc->lvRegister != 0)
  5353|         {
  5354|             lvaDumpRegLocation(lclNum);
  5355|         }
  5356|         else if (varDsc->lvOnFrame == 0)
  5357|         {
  5358|             printf("registers  ");
  5359|         }
  5360|         else
  5361|         {
  5362|             if (lvaDoneFrameLayout != NO_FRAME_LAYOUT)
  5363|             {
  5364|                 lvaDumpFrameLocation(lclNum);
  5365|             }
  5366|         }
  5367|     }
  5368|     if (varDsc->lvIsHfa())
  5369|     {
  5370|         printf(" HFA(%s) ", varTypeName(varDsc->GetHfaType()));
  5371|     }
  5372|     if (varDsc->lvDoNotEnregister)
  5373|     {
  5374|         printf(" do-not-enreg[");
  5375|         if (varDsc->IsAddressExposed())
  5376|         {
  5377|             printf("X");
  5378|         }
  5379|         if (varDsc->IsHiddenBufferStructArg())
  5380|         {
  5381|             printf("H");
  5382|         }
  5383|         if (varTypeIsStruct(varDsc))
  5384|         {
  5385|             printf("S");
  5386|         }
  5387|         if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::VMNeedsStackAddr)
  5388|         {
  5389|             printf("V");
  5390|         }
  5391|         if (lvaEnregEHVars && varDsc->lvLiveInOutOfHndlr)
  5392|         {
  5393|             printf("%c", varDsc->lvSingleDefDisqualifyReason);
  5394|         }
  5395|         if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::LocalField)
  5396|         {
  5397|             printf("F");
  5398|         }
  5399|         if (varDsc->GetDoNotEnregReason() == DoNotEnregisterReason::BlockOp)
  5400|         {
  5401|             printf("B");
  5402|         }
  5403|         if (varDsc->lvIsMultiRegArg)
  5404|         {
  5405|             printf("A");
  5406|         }
  5407|         if (varDsc->lvIsMultiRegRet)
  5408|         {
  5409|             printf("R");
  5410|         }
  5411| #ifdef JIT32_GCENCODER
  5412|         if (varDsc->lvPinned)
  5413|             printf("P");
  5414| #endif // JIT32_GCENCODER
  5415|         printf("]");
  5416|     }
  5417|     if (varDsc->lvIsMultiRegArg)
  5418|     {
  5419|         printf(" multireg-arg");
  5420|     }
  5421|     if (varDsc->lvIsMultiRegRet)
  5422|     {
  5423|         printf(" multireg-ret");
  5424|     }
  5425|     if (varDsc->lvMustInit)
  5426|     {
  5427|         printf(" must-init");
  5428|     }
  5429|     if (varDsc->IsAddressExposed())
  5430|     {
  5431|         printf(" addr-exposed");
  5432|     }
  5433|     if (varDsc->IsHiddenBufferStructArg())
  5434|     {
  5435|         printf(" hidden-struct-arg");
  5436|     }
  5437|     if (varDsc->lvHasLdAddrOp)
  5438|     {
  5439|         printf(" ld-addr-op");
  5440|     }
  5441|     if (lvaIsOriginalThisArg(lclNum))
  5442|     {
  5443|         printf(" this");
  5444|     }
  5445|     if (varDsc->lvPinned)
  5446|     {
  5447|         printf(" pinned");
  5448|     }
  5449|     if (varDsc->lvClassHnd != NO_CLASS_HANDLE)
  5450|     {
  5451|         printf(" class-hnd");
  5452|     }
  5453|     if (varDsc->lvClassIsExact)
  5454|     {
  5455|         printf(" exact");
  5456|     }
  5457|     if (varDsc->lvLiveInOutOfHndlr)
  5458|     {
  5459|         printf(" EH-live");
  5460|     }
  5461|     if (varDsc->lvSpillAtSingleDef)
  5462|     {
  5463|         printf(" spill-single-def");
  5464|     }
  5465|     else if (varDsc->lvSingleDefRegCandidate)
  5466|     {
  5467|         printf(" single-def");
  5468|     }
  5469|     if (lvaIsOSRLocal(lclNum) && varDsc->lvOnFrame)
  5470|     {
  5471|         printf(" tier0-frame");
  5472|     }
  5473| #ifndef TARGET_64BIT
  5474|     if (varDsc->lvStructDoubleAlign)
  5475|         printf(" double-align");
  5476| #endif // !TARGET_64BIT
  5477|     if (varDsc->lvOverlappingFields)
  5478|     {
  5479|         printf(" overlapping-fields");
  5480|     }
  5481|     if (compGSReorderStackLayout && !varDsc->lvRegister)
  5482|     {
  5483|         if (varDsc->lvIsPtr)
  5484|         {
  5485|             printf(" ptr");
  5486|         }
  5487|         if (varDsc->lvIsUnsafeBuffer)
  5488|         {
  5489|             printf(" unsafe-buffer");
  5490|         }
  5491|     }
  5492|     if (varDsc->lvIsStructField)
  5493|     {
  5494|         LclVarDsc* parentvarDsc = lvaGetDesc(varDsc->lvParentLcl);
  5495| #if !defined(TARGET_64BIT)
  5496|         if (varTypeIsLong(parentvarDsc))
  5497|         {
  5498|             bool isLo = (lclNum == parentvarDsc->lvFieldLclStart);
  5499|             printf(" V%02u.%s(offs=0x%02x)", varDsc->lvParentLcl, isLo ? "lo" : "hi", isLo ? 0 : genTypeSize(TYP_INT));
  5500|         }
  5501|         else
  5502| #endif // !defined(TARGET_64BIT)
  5503|         {
  5504|             CORINFO_CLASS_HANDLE typeHnd = parentvarDsc->GetStructHnd();
  5505|             CORINFO_FIELD_HANDLE fldHnd  = info.compCompHnd->getFieldInClass(typeHnd, varDsc->lvFldOrdinal);
  5506|             printf(" V%02u.%s(offs=0x%02x)", varDsc->lvParentLcl, eeGetFieldName(fldHnd), varDsc->lvFldOffset);
  5507|             lvaPromotionType promotionType = lvaGetPromotionType(parentvarDsc);
  5508|             switch (promotionType)
  5509|             {
  5510|                 case PROMOTION_TYPE_NONE:
  5511|                     printf(" P-NONE");
  5512|                     break;
  5513|                 case PROMOTION_TYPE_DEPENDENT:
  5514|                     printf(" P-DEP");
  5515|                     break;
  5516|                 case PROMOTION_TYPE_INDEPENDENT:
  5517|                     printf(" P-INDEP");
  5518|                     break;
  5519|             }
  5520|         }
  5521|     }
  5522|     if (varDsc->lvReason != nullptr)
  5523|     {
  5524|         printf(" \"%s\"", varDsc->lvReason);
  5525|     }
  5526|     printf("\n");
  5527| }
  5528| /*****************************************************************************
  5529| *
  5530| *  dump the lvaTable
  5531| */
  5532| void Compiler::lvaTableDump(FrameLayoutState curState)
  5533| {
  5534|     if (curState == NO_FRAME_LAYOUT)
  5535|     {
  5536|         curState = lvaDoneFrameLayout;
  5537|         if (curState == NO_FRAME_LAYOUT)
  5538|         {
  5539|             curState = INITIAL_FRAME_LAYOUT;
  5540|         }
  5541|     }
  5542|     if (curState == INITIAL_FRAME_LAYOUT)
  5543|     {
  5544|         printf("; Initial");
  5545|     }
  5546|     else if (curState == PRE_REGALLOC_FRAME_LAYOUT)
  5547|     {
  5548|         printf("; Pre-RegAlloc");
  5549|     }
  5550|     else if (curState == REGALLOC_FRAME_LAYOUT)
  5551|     {
  5552|         printf("; RegAlloc");
  5553|     }
  5554|     else if (curState == TENTATIVE_FRAME_LAYOUT)
  5555|     {
  5556|         printf("; Tentative");
  5557|     }
  5558|     else if (curState == FINAL_FRAME_LAYOUT)
  5559|     {
  5560|         printf("; Final");
  5561|     }
  5562|     else
  5563|     {
  5564|         printf("UNKNOWN FrameLayoutState!");
  5565|         unreached();
  5566|     }
  5567|     printf(" local variable assignments\n");
  5568|     printf(";\n");
  5569|     unsigned   lclNum;
  5570|     LclVarDsc* varDsc;
  5571|     size_t refCntWtdWidth = 6; // Use 6 as the minimum width
  5572|     if (curState != INITIAL_FRAME_LAYOUT) // don't need this info for INITIAL_FRAME_LAYOUT
  5573|     {
  5574|         for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  5575|         {
  5576|             size_t width = strlen(refCntWtd2str(varDsc->lvRefCntWtd()));
  5577|             if (width > refCntWtdWidth)
  5578|             {
  5579|                 refCntWtdWidth = width;
  5580|             }
  5581|         }
  5582|     }
  5583|     for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  5584|     {
  5585|         lvaDumpEntry(lclNum, curState, refCntWtdWidth);
  5586|     }
  5587|     assert(codeGen->regSet.tmpAllFree());
  5588|     for (TempDsc* temp = codeGen->regSet.tmpListBeg(); temp != nullptr; temp = codeGen->regSet.tmpListNxt(temp))
  5589|     {
  5590|         printf(";  TEMP_%02u %26s%*s%7s  -> ", -temp->tdTempNum(), " ", refCntWtdWidth, " ",
  5591|                varTypeName(temp->tdTempType()));
  5592|         int offset = temp->tdTempOffs();
  5593|         printf(" [%2s%1s0x%02X]\n", isFramePointerUsed() ? STR_FPBASE : STR_SPBASE, (offset < 0 ? "-" : "+"),
  5594|                (offset < 0 ? -offset : offset));
  5595|     }
  5596|     if (curState >= TENTATIVE_FRAME_LAYOUT)
  5597|     {
  5598|         printf(";\n");
  5599|         printf("; Lcl frame size = %d\n", compLclFrameSize);
  5600|     }
  5601| }
  5602| #endif // DEBUG
  5603| /*****************************************************************************
  5604|  *
  5605|  *  Conservatively estimate the layout of the stack frame.
  5606|  *
  5607|  *  This function is only used before final frame layout. It conservatively estimates the
  5608|  *  number of callee-saved registers that must be saved, then calls lvaAssignFrameOffsets().
  5609|  *  To do final frame layout, the callee-saved registers are known precisely, so
  5610|  *  lvaAssignFrameOffsets() is called directly.
  5611|  *
  5612|  *  Returns the (conservative, that is, overly large) estimated size of the frame,
  5613|  *  including the callee-saved registers. This is only used by the emitter during code
  5614|  *  generation when estimating the size of the offset of instructions accessing temps,
  5615|  *  and only if temps have a larger offset than variables.
  5616|  */
  5617| unsigned Compiler::lvaFrameSize(FrameLayoutState curState)
  5618| {
  5619|     assert(curState < FINAL_FRAME_LAYOUT);
  5620|     unsigned result;
  5621|     /* Layout the stack frame conservatively.
  5622|        Assume all callee-saved registers are spilled to stack */
  5623|     compCalleeRegsPushed = CNT_CALLEE_SAVED;
  5624| #if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
  5625|     if (compFloatingPointUsed)
  5626|         compCalleeRegsPushed += CNT_CALLEE_SAVED_FLOAT;
  5627|     compCalleeRegsPushed++; // we always push LR/RA.  See genPushCalleeSavedRegisters
  5628| #elif defined(TARGET_AMD64)
  5629|     if (compFloatingPointUsed)
  5630|     {
  5631|         compCalleeFPRegsSavedMask = RBM_FLT_CALLEE_SAVED;
  5632|     }
  5633|     else
  5634|     {
  5635|         compCalleeFPRegsSavedMask = RBM_NONE;
  5636|     }
  5637| #endif
  5638| #if DOUBLE_ALIGN
  5639|     if (genDoubleAlign())
  5640|     {
  5641|         compCalleeRegsPushed++;
  5642|     }
  5643| #endif
  5644| #ifdef TARGET_XARCH
  5645|     if (codeGen->isFramePointerUsed())
  5646|     {
  5647|         compCalleeRegsPushed--;
  5648|     }
  5649| #endif
  5650|     lvaAssignFrameOffsets(curState);
  5651|     unsigned calleeSavedRegMaxSz = CALLEE_SAVED_REG_MAXSZ;
  5652| #if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
  5653|     if (compFloatingPointUsed)
  5654|     {
  5655|         calleeSavedRegMaxSz += CALLEE_SAVED_FLOAT_MAXSZ;
  5656|     }
  5657|     calleeSavedRegMaxSz += REGSIZE_BYTES; // we always push LR/RA.  See genPushCalleeSavedRegisters
  5658| #endif
  5659|     result = compLclFrameSize + calleeSavedRegMaxSz;
  5660|     return result;
  5661| }
  5662| int Compiler::lvaGetSPRelativeOffset(unsigned varNum)
  5663| {
  5664|     assert(!compLocallocUsed);
  5665|     assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
  5666|     const LclVarDsc* varDsc = lvaGetDesc(varNum);
  5667|     assert(varDsc->lvOnFrame);
  5668|     int spRelativeOffset;
  5669|     if (varDsc->lvFramePointerBased)
  5670|     {
  5671|         spRelativeOffset = varDsc->GetStackOffset() + codeGen->genSPtoFPdelta();
  5672|     }
  5673|     else
  5674|     {
  5675|         spRelativeOffset = varDsc->GetStackOffset();
  5676|     }
  5677|     assert(spRelativeOffset >= 0);
  5678|     return spRelativeOffset;
  5679| }
  5680| /*****************************************************************************
  5681|  *
  5682|  *  Return the caller-SP-relative stack offset of a local/parameter.
  5683|  *  Requires the local to be on the stack and frame layout to be complete.
  5684|  */
  5685| int Compiler::lvaGetCallerSPRelativeOffset(unsigned varNum)
  5686| {
  5687|     assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
  5688|     const LclVarDsc* varDsc = lvaGetDesc(varNum);
  5689|     assert(varDsc->lvOnFrame);
  5690|     return lvaToCallerSPRelativeOffset(varDsc->GetStackOffset(), varDsc->lvFramePointerBased);
  5691| }
  5692| int Compiler::lvaToCallerSPRelativeOffset(int offset, bool isFpBased, bool forRootFrame) const
  5693| {
  5694|     assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
  5695|     if (isFpBased)
  5696|     {
  5697|         offset += codeGen->genCallerSPtoFPdelta();
  5698|     }
  5699|     else
  5700|     {
  5701|         offset += codeGen->genCallerSPtoInitialSPdelta();
  5702|     }
  5703| #if defined(TARGET_AMD64) || defined(TARGET_ARM64)
  5704|     if (forRootFrame && opts.IsOSR())
  5705|     {
  5706|         const PatchpointInfo* const ppInfo = info.compPatchpointInfo;
  5707| #if defined(TARGET_AMD64)
  5708|         const int adjustment = ppInfo->TotalFrameSize() + REGSIZE_BYTES;
  5709| #elif defined(TARGET_ARM64)
  5710|         const int adjustment = ppInfo->TotalFrameSize();
  5711| #endif
  5712|         offset -= adjustment;
  5713|     }
  5714| #else
  5715|     assert(!opts.IsOSR());
  5716| #endif
  5717|     return offset;
  5718| }
  5719| /*****************************************************************************
  5720|  *
  5721|  *  Return the Initial-SP-relative stack offset of a local/parameter.
  5722|  *  Requires the local to be on the stack and frame layout to be complete.
  5723|  */
  5724| int Compiler::lvaGetInitialSPRelativeOffset(unsigned varNum)
  5725| {
  5726|     assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
  5727|     const LclVarDsc* varDsc = lvaGetDesc(varNum);
  5728|     assert(varDsc->lvOnFrame);
  5729|     return lvaToInitialSPRelativeOffset(varDsc->GetStackOffset(), varDsc->lvFramePointerBased);
  5730| }
  5731| int Compiler::lvaToInitialSPRelativeOffset(unsigned offset, bool isFpBased)
  5732| {
  5733|     assert(lvaDoneFrameLayout == FINAL_FRAME_LAYOUT);
  5734| #ifdef TARGET_AMD64
  5735|     if (isFpBased)
  5736|     {
  5737|         assert(codeGen->isFramePointerUsed());
  5738|         offset += codeGen->genSPtoFPdelta();
  5739|     }
  5740|     else
  5741|     {
  5742|     }
  5743| #else  // !TARGET_AMD64
  5744|     NYI("lvaToInitialSPRelativeOffset");
  5745| #endif // !TARGET_AMD64
  5746|     return offset;
  5747| }
  5748| /*****************************************************************************/
  5749| #ifdef DEBUG
  5750| /*****************************************************************************
  5751|  *  Pick a padding size at "random" for the local.
  5752|  *  0 means that it should not be converted to a GT_LCL_FLD
  5753|  */
  5754| static unsigned LCL_FLD_PADDING(unsigned lclNum)
  5755| {
  5756|     if (lclNum % 2)
  5757|     {
  5758|         return 0;
  5759|     }
  5760|     unsigned size = lclNum % 7;
  5761|     return size;
  5762| }
  5763| /*****************************************************************************
  5764|  *
  5765|  *  Callback for fgWalkAllTreesPre()
  5766|  *  Convert as many GT_LCL_VAR's to GT_LCL_FLD's
  5767|  */
  5768| /* static */
  5769| /*
  5770|     The stress mode does 2 passes.
  5771|     In the first pass we will mark the locals where we CAN't apply the stress mode.
  5772|     In the second pass we will do the appropriate morphing wherever we've not determined we can't do it.
  5773| */
  5774| Compiler::fgWalkResult Compiler::lvaStressLclFldCB(GenTree** pTree, fgWalkData* data)
  5775| {
  5776|     GenTree*   tree = *pTree;
  5777|     genTreeOps oper = tree->OperGet();
  5778|     GenTree*   lcl;
  5779|     switch (oper)
  5780|     {
  5781|         case GT_LCL_VAR:
  5782|         case GT_LCL_VAR_ADDR:
  5783|             lcl = tree;
  5784|             break;
  5785|         case GT_ADDR:
  5786|             if (tree->AsOp()->gtOp1->gtOper != GT_LCL_VAR)
  5787|             {
  5788|                 return WALK_CONTINUE;
  5789|             }
  5790|             lcl = tree->AsOp()->gtOp1;
  5791|             break;
  5792|         default:
  5793|             return WALK_CONTINUE;
  5794|     }
  5795|     noway_assert(lcl->OperIs(GT_LCL_VAR, GT_LCL_VAR_ADDR));
  5796|     Compiler* const  pComp      = ((lvaStressLclFldArgs*)data->pCallbackData)->m_pCompiler;
  5797|     const bool       bFirstPass = ((lvaStressLclFldArgs*)data->pCallbackData)->m_bFirstPass;
  5798|     const unsigned   lclNum     = lcl->AsLclVarCommon()->GetLclNum();
  5799|     var_types        type       = lcl->TypeGet();
  5800|     LclVarDsc* const varDsc     = pComp->lvaGetDesc(lclNum);
  5801|     if (varDsc->lvNoLclFldStress)
  5802|     {
  5803|         return WALK_SKIP_SUBTREES;
  5804|     }
  5805|     if (bFirstPass)
  5806|     {
  5807|         if (varDsc->lvIsParam || lclNum >= pComp->info.compLocalsCount)
  5808|         {
  5809|             varDsc->lvNoLclFldStress = true;
  5810|             return WALK_SKIP_SUBTREES;
  5811|         }
  5812|         if (pComp->lvaIsOSRLocal(lclNum))
  5813|         {
  5814|             varDsc->lvNoLclFldStress = true;
  5815|             return WALK_SKIP_SUBTREES;
  5816|         }
  5817|         if (pComp->doesMethodHavePatchpoints() || pComp->doesMethodHavePartialCompilationPatchpoints())
  5818|         {
  5819|             varDsc->lvNoLclFldStress = true;
  5820|             return WALK_SKIP_SUBTREES;
  5821|         }
  5822|         if (varDsc->lvKeepType)
  5823|         {
  5824|             varDsc->lvNoLclFldStress = true;
  5825|             return WALK_SKIP_SUBTREES;
  5826|         }
  5827|         if (!varTypeIsArithmetic(type))
  5828|         {
  5829|             varDsc->lvNoLclFldStress = true;
  5830|             return WALK_SKIP_SUBTREES;
  5831|         }
  5832|         if ((varDsc->lvType != lcl->gtType) && (varDsc->lvType != TYP_BLK))
  5833|         {
  5834|             varDsc->lvNoLclFldStress = true;
  5835|             return WALK_SKIP_SUBTREES;
  5836|         }
  5837|         var_types varType = varDsc->TypeGet();
  5838|         if (varType != TYP_BLK && genTypeSize(varType) != genTypeSize(genActualType(varType)))
  5839|         {
  5840|             varDsc->lvNoLclFldStress = true;
  5841|             return WALK_SKIP_SUBTREES;
  5842|         }
  5843|         unsigned padding = LCL_FLD_PADDING(lclNum);
  5844|         if (padding == 0)
  5845|         {
  5846|             varDsc->lvNoLclFldStress = true;
  5847|             return WALK_SKIP_SUBTREES;
  5848|         }
  5849|     }
  5850|     else
  5851|     {
  5852|         noway_assert((varDsc->lvType == lcl->gtType) || (varDsc->lvType == TYP_BLK));
  5853|         var_types varType = varDsc->TypeGet();
  5854|         unsigned padding = LCL_FLD_PADDING(lclNum);
  5855| #if defined(TARGET_ARMARCH) || defined(TARGET_LOONGARCH64)
  5856|         unsigned alignment = 1;
  5857|         pComp->codeGen->InferOpSizeAlign(lcl, &alignment);
  5858|         alignment = roundUp(alignment, TARGET_POINTER_SIZE);
  5859|         padding   = roundUp(padding, alignment);
  5860| #endif // TARGET_ARMARCH || TARGET_LOONGARCH64
  5861|         if (varType != TYP_BLK)
  5862|         {
  5863|             varDsc->lvExactSize = roundUp(padding + pComp->lvaLclSize(lclNum), TARGET_POINTER_SIZE);
  5864|             varDsc->lvType      = TYP_BLK;
  5865|             pComp->lvaSetVarAddrExposed(lclNum DEBUGARG(AddressExposedReason::STRESS_LCL_FLD));
  5866|         }
  5867|         tree->gtFlags |= GTF_GLOB_REF;
  5868|         /* Now morph the tree appropriately */
  5869|         if (oper == GT_LCL_VAR)
  5870|         {
  5871|             /* Change lclVar(lclNum) to lclFld(lclNum,padding) */
  5872|             tree->ChangeOper(GT_LCL_FLD);
  5873|             tree->AsLclFld()->SetLclOffs(padding);
  5874|         }
  5875|         else if (oper == GT_LCL_VAR_ADDR)
  5876|         {
  5877|             tree->ChangeOper(GT_LCL_FLD_ADDR);
  5878|             tree->AsLclFld()->SetLclOffs(padding);
  5879|         }
  5880|         else
  5881|         {
  5882|             /* Change addr(lclVar) to addr(lclVar)+padding */
  5883|             noway_assert(oper == GT_ADDR);
  5884|             GenTree* paddingTree = pComp->gtNewIconNode(padding);
  5885|             GenTree* newAddr     = pComp->gtNewOperNode(GT_ADD, tree->gtType, tree, paddingTree);
  5886|             *pTree = newAddr;
  5887|             lcl->gtType = TYP_BLK;
  5888|         }
  5889|     }
  5890|     return WALK_SKIP_SUBTREES;
  5891| }
  5892| /*****************************************************************************/
  5893| void Compiler::lvaStressLclFld()
  5894| {
  5895|     if (!compStressCompile(STRESS_LCL_FLDS, 5))
  5896|     {
  5897|         return;
  5898|     }
  5899|     lvaStressLclFldArgs Args;
  5900|     Args.m_pCompiler  = this;
  5901|     Args.m_bFirstPass = true;
  5902|     fgWalkAllTreesPre(lvaStressLclFldCB, &Args);
  5903|     Args.m_bFirstPass = false;
  5904|     fgWalkAllTreesPre(lvaStressLclFldCB, &Args);
  5905| }
  5906| #endif // DEBUG
  5907| /*****************************************************************************
  5908|  *
  5909|  *  A little routine that displays a local variable bitset.
  5910|  *  'set' is mask of variables that have to be displayed
  5911|  *  'allVars' is the complete set of interesting variables (blank space is
  5912|  *    inserted if its corresponding bit is not in 'set').
  5913|  */
  5914| #ifdef DEBUG
  5915| void Compiler::lvaDispVarSet(VARSET_VALARG_TP set)
  5916| {
  5917|     VARSET_TP allVars(VarSetOps::MakeEmpty(this));
  5918|     lvaDispVarSet(set, allVars);
  5919| }
  5920| void Compiler::lvaDispVarSet(VARSET_VALARG_TP set, VARSET_VALARG_TP allVars)
  5921| {
  5922|     printf("{");
  5923|     bool needSpace = false;
  5924|     for (unsigned index = 0; index < lvaTrackedCount; index++)
  5925|     {
  5926|         if (VarSetOps::IsMember(this, set, index))
  5927|         {
  5928|             unsigned   lclNum;
  5929|             LclVarDsc* varDsc;
  5930|             /* Look for the matching variable */
  5931|             for (lclNum = 0, varDsc = lvaTable; lclNum < lvaCount; lclNum++, varDsc++)
  5932|             {
  5933|                 if ((varDsc->lvVarIndex == index) && varDsc->lvTracked)
  5934|                 {
  5935|                     break;
  5936|                 }
  5937|             }
  5938|             if (needSpace)
  5939|             {
  5940|                 printf(" ");
  5941|             }
  5942|             else
  5943|             {
  5944|                 needSpace = true;
  5945|             }
  5946|             printf("V%02u", lclNum);
  5947|         }
  5948|         else if (VarSetOps::IsMember(this, allVars, index))
  5949|         {
  5950|             if (needSpace)
  5951|             {
  5952|                 printf(" ");
  5953|             }
  5954|             else
  5955|             {
  5956|                 needSpace = true;
  5957|             }
  5958|             printf("   ");
  5959|         }
  5960|     }
  5961|     printf("}");
  5962| }
  5963| #endif // DEBUG


# ====================================================================
# FILE: src/coreclr/vm/perfinfo.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-90 ---
     1| #include "common.h"
     2| #if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
     3| #include "perfinfo.h"
     4| #include "pal.h"
     5| PerfInfo::PerfInfo(int pid, const char* basePath)
     6|   : m_Stream(nullptr)
     7| {
     8|     LIMITED_METHOD_CONTRACT;
     9|     SString path;
    10|     path.Printf("%s/perfinfo-%d.map", basePath, pid);
    11|     OpenFile(path);
    12| }
    13| void PerfInfo::LogImage(PEAssembly* pPEAssembly, WCHAR* guid)
    14| {
    15|     CONTRACTL
    16|     {
    17|         THROWS;
    18|         GC_NOTRIGGER;
    19|         MODE_PREEMPTIVE;
    20|         PRECONDITION(pPEAssembly != nullptr);
    21|         PRECONDITION(guid != nullptr);
    22|     } CONTRACTL_END;
    23|     SString value;
    24|     const SString& path = pPEAssembly->GetPath();
    25|     if (path.IsEmpty())
    26|     {
    27|         return;
    28|     }
    29|     SIZE_T baseAddr = 0;
    30|     if (pPEAssembly->IsReadyToRun())
    31|     {
    32|         PEImageLayout *pLoadedLayout = pPEAssembly->GetLoadedLayout();
    33|         if (pLoadedLayout)
    34|         {
    35|             baseAddr = (SIZE_T)pLoadedLayout->GetBase();
    36|         }
    37|     }
    38|     value.Printf("%S%c%S%c%p", path.GetUnicode(), sDelimiter, guid, sDelimiter, baseAddr);
    39|     SString command;
    40|     command.Printf("%s", "ImageLoad");
    41|     WriteLine(command, value);
    42| }
    43| void PerfInfo::WriteLine(SString& type, SString& value)
    44| {
    45|     CONTRACTL
    46|     {
    47|         THROWS;
    48|         GC_NOTRIGGER;
    49|         MODE_PREEMPTIVE;
    50|     } CONTRACTL_END;
    51|     if (m_Stream == nullptr)
    52|     {
    53|         return;
    54|     }
    55|     SString line;
    56|     line.Printf("%S%c%S%c\n",
    57|             type.GetUnicode(), sDelimiter, value.GetUnicode(), sDelimiter);
    58|     EX_TRY
    59|     {
    60|         const char* strLine = line.GetUTF8();
    61|         ULONG inCount = line.GetCount();
    62|         ULONG outCount;
    63|         m_Stream->Write(strLine, inCount, &outCount);
    64|         if (inCount != outCount)
    65|         {
    66|         }
    67|     }
    68|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
    69| }
    70| void PerfInfo::OpenFile(SString& path)
    71| {
    72|     STANDARD_VM_CONTRACT;
    73|     m_Stream = new (nothrow) CFileStream();
    74|     if (m_Stream != nullptr)
    75|     {
    76|         HRESULT hr = m_Stream->OpenForWrite(path.GetUnicode());
    77|         if (FAILED(hr))
    78|         {
    79|             delete m_Stream;
    80|             m_Stream = nullptr;
    81|         }
    82|     }
    83| }
    84| PerfInfo::~PerfInfo()
    85| {
    86|     LIMITED_METHOD_CONTRACT;
    87|     delete m_Stream;
    88|     m_Stream = nullptr;
    89| }
    90| #endif


# ====================================================================
# FILE: src/coreclr/vm/perfinfo.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| #ifndef PERFINFO_H
     2| #define PERFINFO_H
     3| #include "sstring.h"
     4| #include "fstream.h"
     5| /*
     6|    A perfinfo-%d.map is created for every process that is created with manage code, the %d
     7|    being repaced with the process ID.
     8|    Every line in the perfinfo-%d.map is a type and value, separated by sDelimiter character: type;value
     9|    type represents what the user might want to do with its given value. value has a format chosen by
    10|    the user for parsing later on.
    11| */
    12| class PerfInfo {
    13| public:
    14|     PerfInfo(int pid, const char* basePath);
    15|     ~PerfInfo();
    16|     void LogImage(PEAssembly* pPEAssembly, WCHAR* guid);
    17| private:
    18|     CFileStream* m_Stream;
    19|     const char sDelimiter = ';';
    20|     void OpenFile(SString& path);
    21|     void WriteLine(SString& type, SString& value);
    22| };
    23| #endif


# ====================================================================
# FILE: src/coreclr/vm/perfmap.cpp
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-364 ---
     1| #include "common.h"
     2| #if defined(FEATURE_PERFMAP) && !defined(DACCESS_COMPILE)
     3| #include <clrconfignocache.h>
     4| #include "perfmap.h"
     5| #include "perfinfo.h"
     6| #include "pal.h"
     7| #define FMT_CODE_ADDR "%p"
     8| #ifndef __ANDROID__
     9| #define TEMP_DIRECTORY_PATH "/tmp"
    10| #else
    11| #define TEMP_DIRECTORY_PATH "/data/local/tmp"
    12| #endif
    13| Volatile<bool> PerfMap::s_enabled = false;
    14| PerfMap * PerfMap::s_Current = nullptr;
    15| bool PerfMap::s_ShowOptimizationTiers = false;
    16| unsigned PerfMap::s_StubsMapped = 0;
    17| enum 
    18| {
    19|     DISABLED,
    20|     ALL,
    21|     JITDUMP,
    22|     PERFMAP
    23| };
    24| void PerfMap::Initialize()
    25| {
    26|     LIMITED_METHOD_CONTRACT;
    27|     const DWORD perfMapEnabled = CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapEnabled);
    28|     if (perfMapEnabled == DISABLED)
    29|     {
    30|         return;
    31|     }
    32|     char tempPathBuffer[MAX_LONGPATH+1];
    33|     const char* tempPath = InternalConstructPath(tempPathBuffer, sizeof(tempPathBuffer));
    34|     if (perfMapEnabled == ALL || perfMapEnabled == PERFMAP)
    35|     {
    36|         int currentPid = GetCurrentProcessId();
    37|         s_Current = new PerfMap(currentPid, tempPath);
    38|         int signalNum = (int) CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapIgnoreSignal);
    39|         if (signalNum > 0)
    40|         {
    41|             PAL_IgnoreProfileSignal(signalNum);
    42|         }
    43|     }
    44|     if (perfMapEnabled == ALL || perfMapEnabled == JITDUMP)
    45|     {
    46|         PAL_PerfJitDump_Start(tempPath);
    47|     }
    48|     if (CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_PerfMapShowOptimizationTiers) != 0)
    49|     {
    50|         s_ShowOptimizationTiers = true;
    51|     }
    52|     s_enabled = true;
    53| }
    54| const char * PerfMap::InternalConstructPath(char *tmpBuf, int lenBuf)
    55| {
    56|     DWORD len = GetEnvironmentVariableA("DOTNET_PerfMapJitDumpPath", tmpBuf, lenBuf);
    57|     if (len == 0)
    58|     {
    59|         len = GetEnvironmentVariableA("COMPlus_PerfMapJitDumpPath", tmpBuf, lenBuf);
    60|     }
    61|     if (len == 0 || // GetEnvironmentVariableA returns 0 if the variable is not found, 
    62|         len >= lenBuf) // or the length of the string not including the null terminator on success.
    63|     {
    64|         return TEMP_DIRECTORY_PATH;
    65|     }
    66|     return tmpBuf;
    67| }
    68| void PerfMap::Destroy()
    69| {
    70|     LIMITED_METHOD_CONTRACT;
    71|     if (s_enabled)
    72|     {
    73|         s_enabled = false;
    74|         PAL_PerfJitDump_Finish();
    75|     }
    76| }
    77| PerfMap::PerfMap(int pid, const char* path)
    78| {
    79|     LIMITED_METHOD_CONTRACT;
    80|     m_ErrorEncountered = false;
    81|     SString pathFile;
    82|     pathFile.Printf("%s/perf-%d.map", path, pid);
    83|     OpenFile(pathFile);
    84|     m_PerfInfo = new PerfInfo(pid, path);
    85| }
    86| PerfMap::PerfMap()
    87|   : m_FileStream(nullptr)
    88|   , m_PerfInfo(nullptr)
    89| {
    90|     LIMITED_METHOD_CONTRACT;
    91|     m_ErrorEncountered = false;
    92| }
    93| PerfMap::~PerfMap()
    94| {
    95|     LIMITED_METHOD_CONTRACT;
    96|     delete m_FileStream;
    97|     m_FileStream = nullptr;
    98|     delete m_PerfInfo;
    99|     m_PerfInfo = nullptr;
   100| }
   101| void PerfMap::OpenFile(SString& path)
   102| {
   103|     STANDARD_VM_CONTRACT;
   104|     m_FileStream = new (nothrow) CFileStream();
   105|     if(m_FileStream != nullptr)
   106|     {
   107|         HRESULT hr = m_FileStream->OpenForWrite(path.GetUnicode());
   108|         if(FAILED(hr))
   109|         {
   110|             delete m_FileStream;
   111|             m_FileStream = nullptr;
   112|         }
   113|     }
   114| }
   115| void PerfMap::WriteLine(SString& line)
   116| {
   117|     STANDARD_VM_CONTRACT;
   118|     if (m_FileStream == nullptr || m_ErrorEncountered)
   119|     {
   120|         return;
   121|     }
   122|     EX_TRY
   123|     {
   124|         const char * strLine = line.GetUTF8();
   125|         ULONG inCount = line.GetCount();
   126|         ULONG outCount;
   127|         m_FileStream->Write(strLine, inCount, &outCount);
   128|         if (inCount != outCount)
   129|         {
   130|             m_ErrorEncountered = true;
   131|         }
   132|     }
   133|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   134| }
   135| void PerfMap::LogImageLoad(PEAssembly * pPEAssembly)
   136| {
   137|     if (s_enabled && s_Current != nullptr)
   138|     {
   139|         s_Current->LogImage(pPEAssembly);
   140|     }
   141| }
   142| void PerfMap::LogImage(PEAssembly * pPEAssembly)
   143| {
   144|     CONTRACTL{
   145|         THROWS;
   146|         GC_NOTRIGGER;
   147|         MODE_PREEMPTIVE;
   148|         PRECONDITION(pPEAssembly != nullptr);
   149|     } CONTRACTL_END;
   150|     if (m_FileStream == nullptr || m_ErrorEncountered)
   151|     {
   152|         return;
   153|     }
   154|     EX_TRY
   155|     {
   156|         WCHAR wszSignature[39];
   157|         GetNativeImageSignature(pPEAssembly, wszSignature, ARRAY_SIZE(wszSignature));
   158|         m_PerfInfo->LogImage(pPEAssembly, wszSignature);
   159|     }
   160|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   161| }
   162| void PerfMap::LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig)
   163| {
   164|     LIMITED_METHOD_CONTRACT;
   165|     CONTRACTL{
   166|         THROWS;
   167|         GC_NOTRIGGER;
   168|         MODE_PREEMPTIVE;
   169|         PRECONDITION(pMethod != nullptr);
   170|         PRECONDITION(pCode != nullptr);
   171|         PRECONDITION(codeSize > 0);
   172|     } CONTRACTL_END;
   173|     if (!s_enabled)
   174|     {
   175|         return;
   176|     }
   177|     const char *optimizationTier = nullptr;
   178|     if (s_ShowOptimizationTiers)
   179|     {
   180|         optimizationTier = PrepareCodeConfig::GetJitOptimizationTierStr(pConfig, pMethod);
   181|     }
   182|     EX_TRY
   183|     {
   184|         SString name;
   185|         pMethod->GetFullMethodInfo(name);
   186|         if (optimizationTier != nullptr && s_ShowOptimizationTiers)
   187|         {
   188|             name.AppendPrintf("[%s]", optimizationTier);
   189|         }
   190|         SString line;
   191|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
   192|         if(s_Current != nullptr)
   193|         {
   194|             s_Current->WriteLine(line);
   195|         }
   196|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
   197|     }
   198|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   199| }
   200| void PerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode)
   201| {
   202|     LIMITED_METHOD_CONTRACT;
   203|     if (!s_enabled)
   204|     {
   205|         return;
   206|     }
   207|     EECodeInfo codeInfo(pCode);
   208|     _ASSERTE(codeInfo.IsValid());
   209|     IJitManager::MethodRegionInfo methodRegionInfo;
   210|     codeInfo.GetMethodRegionInfo(&methodRegionInfo);
   211|     EX_TRY
   212|     {
   213|         SString name;
   214|         pMethod->GetFullMethodInfo(name);
   215|         if (s_ShowOptimizationTiers)
   216|         {
   217|             name.Append(W("[PreJIT]"));
   218|         }
   219|         if (methodRegionInfo.hotSize > 0)
   220|         {
   221|             PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.hotStartAddress, methodRegionInfo.hotSize, name.GetUTF8(), nullptr, nullptr);
   222|         }
   223|         if (methodRegionInfo.coldSize > 0)
   224|         {
   225|             if (s_ShowOptimizationTiers)
   226|             {
   227|                 pMethod->GetFullMethodInfo(name);
   228|                 name.Append(W("[PreJit-cold]"));
   229|             }
   230|             PAL_PerfJitDump_LogMethod((void*)methodRegionInfo.coldStartAddress, methodRegionInfo.coldSize, name.GetUTF8(), nullptr, nullptr);
   231|         }
   232|     }
   233|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   234| }
   235| void PerfMap::LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize)
   236| {
   237|     LIMITED_METHOD_CONTRACT;
   238|     if (!s_enabled)
   239|     {
   240|         return;
   241|     }
   242|     EX_TRY
   243|     {
   244|         if(!stubOwner)
   245|         {
   246|             stubOwner = "?";
   247|         }
   248|         if(!stubType)
   249|         {
   250|             stubType = "?";
   251|         }
   252|         SString name;
   253|         name.Printf("stub<%d> %s<%s>", ++(s_StubsMapped), stubType, stubOwner);
   254|         SString line;
   255|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
   256|         if(s_Current != nullptr)
   257|         {
   258|             s_Current->WriteLine(line);
   259|         }
   260|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
   261|     }
   262|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   263| }
   264| void PerfMap::GetNativeImageSignature(PEAssembly * pPEAssembly, WCHAR * pwszSig, unsigned int nSigSize)
   265| {
   266|     CONTRACTL{
   267|         PRECONDITION(pPEAssembly != nullptr);
   268|         PRECONDITION(pwszSig != nullptr);
   269|         PRECONDITION(nSigSize >= 39);
   270|     } CONTRACTL_END;
   271|     GUID mvid;
   272|     pPEAssembly->GetMVID(&mvid);
   273|     if(!StringFromGUID2(mvid, pwszSig, nSigSize))
   274|     {
   275|         pwszSig[0] = '\0';
   276|     }
   277| }
   278| NativeImagePerfMap::NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath)
   279|   : PerfMap()
   280| {
   281|     STANDARD_VM_CONTRACT;
   282|     LPCUTF8 lpcSimpleName = pAssembly->GetSimpleName();
   283|     WCHAR wszSignature[39];
   284|     GetNativeImageSignature(pAssembly->GetPEAssembly(), wszSignature, ARRAY_SIZE(wszSignature));
   285|     SString sDestPerfMapPath;
   286|     sDestPerfMapPath.Printf("%S%s.ni.%S.map", pDestPath, lpcSimpleName, wszSignature);
   287|     OpenFile(sDestPerfMapPath);
   288|     m_EmitRVAs = true;
   289|     CLRConfigStringHolder wszFormat(CLRConfig::GetConfigValue(CLRConfig::EXTERNAL_NativeImagePerfMapFormat));
   290|     if(wszFormat != NULL && (wcsncmp(wszFormat, strOFFSET, wcslen(strOFFSET)) == 0))
   291|     {
   292|         m_EmitRVAs = false;
   293|     }
   294| }
   295| void NativeImagePerfMap::LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier)
   296| {
   297|     CONTRACTL{
   298|         THROWS;
   299|         GC_NOTRIGGER;
   300|         MODE_PREEMPTIVE;
   301|         PRECONDITION(pMethod != nullptr);
   302|         PRECONDITION(pCode != nullptr);
   303|         PRECONDITION(codeSize > 0);
   304|     } CONTRACTL_END;
   305|     EX_TRY
   306|     {
   307|         SString name;
   308|         pMethod->GetFullMethodInfo(name);
   309|         if (optimizationTier != nullptr && s_ShowOptimizationTiers)
   310|         {
   311|             name.AppendPrintf("[%s]", optimizationTier);
   312|         }
   313|         SString line;
   314|         line.Printf(FMT_CODE_ADDR " %x %s\n", pCode, codeSize, name.GetUTF8());
   315|         if (s_Current != nullptr)
   316|         {
   317|             s_Current->WriteLine(line);
   318|         }
   319|         PAL_PerfJitDump_LogMethod((void*)pCode, codeSize, name.GetUTF8(), nullptr, nullptr);
   320|     }
   321|     EX_CATCH{} EX_END_CATCH(SwallowAllExceptions);
   322| }
   323| void NativeImagePerfMap::LogDataForModule(Module * pModule)
   324| {
   325|     STANDARD_VM_CONTRACT;
   326|     PEImageLayout * pLoadedLayout = pModule->GetPEAssembly()->GetLoadedLayout();
   327|     _ASSERTE(pLoadedLayout != nullptr);
   328|     ReadyToRunInfo::MethodIterator mi(pModule->GetReadyToRunInfo());
   329|     while (mi.Next())
   330|     {
   331|         MethodDesc* hotDesc = mi.GetMethodDesc();
   332|         LogPreCompiledMethod(hotDesc, mi.GetMethodStartAddress(), pLoadedLayout, "ReadyToRun");
   333|     }
   334| }
   335| void NativeImagePerfMap::LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier)
   336| {
   337|     STANDARD_VM_CONTRACT;
   338|     _ASSERTE(pLoadedLayout != nullptr);
   339|     SIZE_T baseAddr = (SIZE_T)pLoadedLayout->GetBase();
   340|     EECodeInfo codeInfo(pCode);
   341|     _ASSERTE(codeInfo.IsValid());
   342|     IJitManager::MethodRegionInfo methodRegionInfo;
   343|     codeInfo.GetMethodRegionInfo(&methodRegionInfo);
   344|     PCODE addr;
   345|     if (methodRegionInfo.hotSize > 0)
   346|     {
   347|         addr = (PCODE)methodRegionInfo.hotStartAddress - baseAddr;
   348|         if (!m_EmitRVAs)
   349|         {
   350|             addr = pLoadedLayout->RvaToOffset(addr);
   351|         }
   352|         LogMethod(pMethod, addr, methodRegionInfo.hotSize, optimizationTier);
   353|     }
   354|     if (methodRegionInfo.coldSize > 0)
   355|     {
   356|         addr = (PCODE)methodRegionInfo.coldStartAddress - baseAddr;
   357|         if (!m_EmitRVAs)
   358|         {
   359|             addr = pLoadedLayout->RvaToOffset(addr);
   360|         }
   361|         LogMethod(pMethod, addr, methodRegionInfo.coldSize, optimizationTier);
   362|     }
   363| }
   364| #endif // FEATURE_PERFMAP && !DACCESS_COMPILE


# ====================================================================
# FILE: src/coreclr/vm/perfmap.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| #ifndef PERFPID_H
     2| #define PERFPID_H
     3| #include "sstring.h"
     4| #include "fstream.h"
     5| #include "volatile.h"
     6| class PerfInfo;
     7| class PerfMap
     8| {
     9| private:
    10|     static Volatile<bool> s_enabled;
    11|     static unsigned s_StubsMapped;
    12|     CFileStream * m_FileStream;
    13|     PerfInfo* m_PerfInfo;
    14|     bool m_ErrorEncountered;
    15|     PerfMap(int pid, const char* path);
    16|     static const char* InternalConstructPath(char *tmpBuf, int lenBuf);
    17| protected:
    18|     static bool s_ShowOptimizationTiers;
    19|     static PerfMap * s_Current;
    20|     PerfMap();
    21|     ~PerfMap();
    22|     void OpenFile(SString& path);
    23|     void LogImage(PEAssembly * pPEAssembly);
    24|     static void GetNativeImageSignature(PEAssembly * pPEAssembly, WCHAR * pwszSig, unsigned int nSigSize);
    25| public:
    26|     void WriteLine(SString & line);
    27|     static void Initialize();
    28|     static void LogImageLoad(PEAssembly * pPEAssembly);
    29|     static void LogJITCompiledMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, PrepareCodeConfig *pConfig);
    30|     static void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode);
    31|     static void LogStubs(const char* stubType, const char* stubOwner, PCODE pCode, size_t codeSize);
    32|     static void Destroy();
    33| };
    34| class NativeImagePerfMap : PerfMap
    35| {
    36| private:
    37|     const WCHAR *strOFFSET = W("OFFSET");
    38|     bool m_EmitRVAs;
    39|     void LogMethod(MethodDesc * pMethod, PCODE pCode, size_t codeSize, const char *optimizationTier);
    40|     void LogPreCompiledMethod(MethodDesc * pMethod, PCODE pCode, PEImageLayout *pLoadedLayout, const char *optimizationTier);
    41| public:
    42|     NativeImagePerfMap(Assembly * pAssembly, BSTR pDestPath);
    43|     void LogDataForModule(Module * pModule);
    44| };
    45| #endif // PERFPID_H


# ====================================================================
# FILE: src/coreclr/vm/syncblk.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1114 ---
     1| #ifndef _SYNCBLK_H_
     2| #define _SYNCBLK_H_
     3| #include "util.hpp"
     4| #include "slist.h"
     5| #include "crst.h"
     6| #include "vars.hpp"
     7| #ifdef TARGET_X86
     8| #include <pshpack4.h>
     9| #endif // TARGET_X86
    10| class SyncBlock;
    11| class SyncBlockCache;
    12| class SyncTableEntry;
    13| class SyncBlockArray;
    14| class AwareLock;
    15| class Thread;
    16| class AppDomain;
    17| #ifdef EnC_SUPPORTED
    18| class EnCSyncBlockInfo;
    19| typedef DPTR(EnCSyncBlockInfo) PTR_EnCSyncBlockInfo;
    20| #endif // EnC_SUPPORTED
    21| #include "eventstore.hpp"
    22| #include "eventstore.hpp"
    23| #include "synch.h"
    24| #define BIT_SBLK_UNUSED                     0x80000000
    25| #define BIT_SBLK_FINALIZER_RUN              0x40000000
    26| #define BIT_SBLK_GC_RESERVE                 0x20000000
    27| #define BIT_SBLK_SPIN_LOCK                  0x10000000
    28| #define BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX    0x08000000
    29| #define SBLK_MASK_LOCK_THREADID             0x0000FFFF   // special value of 0 + 65535 thread ids
    30| #define SBLK_MASK_LOCK_RECLEVEL             0x003F0000   // 64 recursion levels
    31| #define SBLK_LOCK_RECLEVEL_INC              0x00010000   // each level is this much higher than the previous one
    32| #define SBLK_RECLEVEL_SHIFT                 16           // shift right this much to get recursion level
    33| #define BIT_SBLK_IS_HASHCODE            0x04000000
    34| #define HASHCODE_BITS                   26
    35| #define MASK_HASHCODE                   ((1<<HASHCODE_BITS)-1)
    36| #define SYNCBLOCKINDEX_BITS             26
    37| #define MASK_SYNCBLOCKINDEX             ((1<<SYNCBLOCKINDEX_BITS)-1)
    38| #define     BIT_SBLK_SPIN_COUNT         1000
    39| #ifdef HOST_64BIT
    40| #define SIZEOF_OBJHEADER    8
    41| #else // !HOST_64BIT
    42| #define SIZEOF_OBJHEADER    4
    43| #endif // !HOST_64BIT
    44| inline void InitializeSpinConstants()
    45| {
    46|     WRAPPER_NO_CONTRACT;
    47| #if !defined(DACCESS_COMPILE)
    48|     g_SpinConstants.dwInitialDuration = g_pConfig->SpinInitialDuration();
    49|     g_SpinConstants.dwMaximumDuration = min(g_pConfig->SpinLimitProcCap(), g_SystemInfo.dwNumberOfProcessors) * g_pConfig->SpinLimitProcFactor() + g_pConfig->SpinLimitConstant();
    50|     g_SpinConstants.dwBackoffFactor   = g_pConfig->SpinBackoffFactor();
    51|     g_SpinConstants.dwRepetitions     = g_pConfig->SpinRetryCount();
    52|     g_SpinConstants.dwMonitorSpinCount = g_SpinConstants.dwMaximumDuration == 0 ? 0 : g_pConfig->MonitorSpinCount();
    53| #endif
    54| }
    55| typedef DPTR(class AwareLock) PTR_AwareLock;
    56| class AwareLock
    57| {
    58|     friend class CheckAsmOffsets;
    59|     friend class SyncBlockCache;
    60|     friend class SyncBlock;
    61| public:
    62|     enum EnterHelperResult {
    63|         EnterHelperResult_Entered,
    64|         EnterHelperResult_Contention,
    65|         EnterHelperResult_UseSlowPath
    66|     };
    67|     enum LeaveHelperAction {
    68|         LeaveHelperAction_None,
    69|         LeaveHelperAction_Signal,
    70|         LeaveHelperAction_Yield,
    71|         LeaveHelperAction_Contention,
    72|         LeaveHelperAction_Error,
    73|     };
    74| private:
    75|     class LockState
    76|     {
    77|     private:
    78|         static const UINT32 IsLockedMask = (UINT32)1 << 0; // bit 0
    79|         static const UINT32 ShouldNotPreemptWaitersMask = (UINT32)1 << 1; // bit 1
    80|         static const UINT32 SpinnerCountIncrement = (UINT32)1 << 2;
    81|         static const UINT32 SpinnerCountMask = (UINT32)0x7 << 2; // bits 2-4
    82|         static const UINT32 IsWaiterSignaledToWakeMask = (UINT32)1 << 5; // bit 5
    83|         static const UINT8 WaiterCountShift = 6;
    84|         static const UINT32 WaiterCountIncrement = (UINT32)1 << WaiterCountShift;
    85|         static const UINT32 WaiterCountMask = (UINT32)-1 >> WaiterCountShift << WaiterCountShift; // bits 6-31
    86|     private:
    87|         UINT32 m_state;
    88|     public:
    89|         LockState(UINT32 state = 0) : m_state(state)
    90|         {
    91|             LIMITED_METHOD_CONTRACT;
    92|         }
    93|     public:
    94|         UINT32 GetState() const
    95|         {
    96|             LIMITED_METHOD_CONTRACT;
    97|             return m_state;
    98|         }
    99|         UINT32 GetMonitorHeldState() const
   100|         {
   101|             LIMITED_METHOD_CONTRACT;
   102|             static_assert_no_msg(IsLockedMask == 1);
   103|             static_assert_no_msg(WaiterCountShift >= 1);
   104|             UINT32 state = m_state;
   105|             return (state & IsLockedMask) + (state >> WaiterCountShift << 1);
   106|         }
   107|     public:
   108|         bool IsUnlockedWithNoWaiters() const
   109|         {
   110|             LIMITED_METHOD_CONTRACT;
   111|             return !(m_state & (IsLockedMask + WaiterCountMask));
   112|         }
   113|         void InitializeToLockedWithNoWaiters()
   114|         {
   115|             LIMITED_METHOD_CONTRACT;
   116|             _ASSERTE(!m_state);
   117|             m_state = IsLockedMask;
   118|         }
   119|     public:
   120|         bool IsLocked() const
   121|         {
   122|             LIMITED_METHOD_CONTRACT;
   123|             return !!(m_state & IsLockedMask);
   124|         }
   125|     private:
   126|         void InvertIsLocked()
   127|         {
   128|             LIMITED_METHOD_CONTRACT;
   129|             m_state ^= IsLockedMask;
   130|         }
   131|     public:
   132|         bool ShouldNotPreemptWaiters() const
   133|         {
   134|             LIMITED_METHOD_CONTRACT;
   135|             return !!(m_state & ShouldNotPreemptWaitersMask);
   136|         }
   137|     private:
   138|         void InvertShouldNotPreemptWaiters()
   139|         {
   140|             WRAPPER_NO_CONTRACT;
   141|             m_state ^= ShouldNotPreemptWaitersMask;
   142|             _ASSERTE(!ShouldNotPreemptWaiters() || HasAnyWaiters());
   143|         }
   144|         bool ShouldNonWaiterAttemptToAcquireLock() const
   145|         {
   146|             WRAPPER_NO_CONTRACT;
   147|             _ASSERTE(!ShouldNotPreemptWaiters() || HasAnyWaiters());
   148|             return !(m_state & (IsLockedMask + ShouldNotPreemptWaitersMask));
   149|         }
   150|     public:
   151|         bool HasAnySpinners() const
   152|         {
   153|             LIMITED_METHOD_CONTRACT;
   154|             return !!(m_state & SpinnerCountMask);
   155|         }
   156|     private:
   157|         bool TryIncrementSpinnerCount()
   158|         {
   159|             WRAPPER_NO_CONTRACT;
   160|             LockState newState = m_state + SpinnerCountIncrement;
   161|             if (newState.HasAnySpinners()) // overflow check
   162|             {
   163|                 m_state = newState;
   164|                 return true;
   165|             }
   166|             return false;
   167|         }
   168|         void DecrementSpinnerCount()
   169|         {
   170|             WRAPPER_NO_CONTRACT;
   171|             _ASSERTE(HasAnySpinners());
   172|             m_state -= SpinnerCountIncrement;
   173|         }
   174|     public:
   175|         bool IsWaiterSignaledToWake() const
   176|         {
   177|             LIMITED_METHOD_CONTRACT;
   178|             return !!(m_state & IsWaiterSignaledToWakeMask);
   179|         }
   180|     private:
   181|         void InvertIsWaiterSignaledToWake()
   182|         {
   183|             LIMITED_METHOD_CONTRACT;
   184|             m_state ^= IsWaiterSignaledToWakeMask;
   185|         }
   186|     public:
   187|         bool HasAnyWaiters() const
   188|         {
   189|             LIMITED_METHOD_CONTRACT;
   190|             return m_state >= WaiterCountIncrement;
   191|         }
   192|     private:
   193|         void IncrementWaiterCount()
   194|         {
   195|             LIMITED_METHOD_CONTRACT;
   196|             _ASSERTE(m_state + WaiterCountIncrement >= WaiterCountIncrement);
   197|             m_state += WaiterCountIncrement;
   198|         }
   199|         void DecrementWaiterCount()
   200|         {
   201|             WRAPPER_NO_CONTRACT;
   202|             _ASSERTE(HasAnyWaiters());
   203|             m_state -= WaiterCountIncrement;
   204|         }
   205|     private:
   206|         bool NeedToSignalWaiter() const
   207|         {
   208|             WRAPPER_NO_CONTRACT;
   209|             return HasAnyWaiters() && !(m_state & (SpinnerCountMask + IsWaiterSignaledToWakeMask));
   210|         }
   211|     private:
   212|         operator UINT32() const
   213|         {
   214|             LIMITED_METHOD_CONTRACT;
   215|             return m_state;
   216|         }
   217|         LockState &operator =(UINT32 state)
   218|         {
   219|             LIMITED_METHOD_CONTRACT;
   220|             m_state = state;
   221|             return *this;
   222|         }
   223|     public:
   224|         LockState VolatileLoadWithoutBarrier() const
   225|         {
   226|             WRAPPER_NO_CONTRACT;
   227|             return ::VolatileLoadWithoutBarrier(&m_state);
   228|         }
   229|         LockState VolatileLoad() const
   230|         {
   231|             WRAPPER_NO_CONTRACT;
   232|             return ::VolatileLoad(&m_state);
   233|         }
   234|     private:
   235|         LockState CompareExchange(LockState toState, LockState fromState)
   236|         {
   237|             LIMITED_METHOD_CONTRACT;
   238| #if defined(TARGET_WINDOWS) && defined(TARGET_ARM64)
   239|             return (UINT32)FastInterlockedCompareExchange((LONG *)&m_state, (LONG)toState, (LONG)fromState);
   240| #else
   241|             return (UINT32)InterlockedCompareExchange((LONG *)&m_state, (LONG)toState, (LONG)fromState);
   242| #endif
   243|         }
   244|         LockState CompareExchangeAcquire(LockState toState, LockState fromState)
   245|         {
   246|             LIMITED_METHOD_CONTRACT;
   247| #if defined(TARGET_WINDOWS) && defined(TARGET_ARM64)
   248|             return (UINT32)FastInterlockedCompareExchangeAcquire((LONG *)&m_state, (LONG)toState, (LONG)fromState);
   249| #else
   250|             return (UINT32)InterlockedCompareExchangeAcquire((LONG *)&m_state, (LONG)toState, (LONG)fromState);
   251| #endif
   252|         }
   253|     public:
   254|         bool InterlockedTryLock();
   255|         bool InterlockedTryLock(LockState state);
   256|         bool InterlockedUnlock();
   257|         bool InterlockedTrySetShouldNotPreemptWaitersIfNecessary(AwareLock *awareLock);
   258|         bool InterlockedTrySetShouldNotPreemptWaitersIfNecessary(AwareLock *awareLock, LockState state);
   259|         EnterHelperResult InterlockedTry_LockOrRegisterSpinner(LockState state);
   260|         EnterHelperResult InterlockedTry_LockAndUnregisterSpinner();
   261|         bool InterlockedUnregisterSpinner_TryLock();
   262|         bool InterlockedTryLock_Or_RegisterWaiter(AwareLock *awareLock, LockState state);
   263|         void InterlockedUnregisterWaiter();
   264|         bool InterlockedTry_LockAndUnregisterWaiterAndObserveWakeSignal(AwareLock *awareLock);
   265|         bool InterlockedObserveWakeSignal_Try_LockAndUnregisterWaiter(AwareLock *awareLock);
   266|     };
   267|     friend class LockState;
   268| private:
   269|     LockState m_lockState;
   270|     ULONG           m_Recursion;
   271|     PTR_Thread      m_HoldingThread;
   272|     LONG            m_TransientPrecious;
   273|     DWORD           m_dwSyncIndex;
   274|     CLREvent        m_SemEvent;
   275|     DWORD m_waiterStarvationStartTimeMs;
   276|     static const DWORD WaiterStarvationDurationMsBeforeStoppingPreemptingWaiters = 100;
   277|     AwareLock(DWORD indx)
   278|         : m_Recursion(0),
   279| #ifndef DACCESS_COMPILE
   280|           m_HoldingThread(NULL),
   281| #endif // DACCESS_COMPILE
   282|           m_TransientPrecious(0),
   283|           m_dwSyncIndex(indx),
   284|           m_waiterStarvationStartTimeMs(0)
   285|     {
   286|         LIMITED_METHOD_CONTRACT;
   287|     }
   288|     ~AwareLock()
   289|     {
   290|         LIMITED_METHOD_CONTRACT;
   291|     }
   292| #if defined(ENABLE_CONTRACTS_IMPL)
   293|     void * GetPtrForLockContract()
   294|     {
   295|         return (void *) this;
   296|     }
   297| #endif // defined(ENABLE_CONTRACTS_IMPL)
   298| public:
   299|     UINT32 GetLockState() const
   300|     {
   301|         WRAPPER_NO_CONTRACT;
   302|         return m_lockState.VolatileLoadWithoutBarrier().GetState();
   303|     }
   304|     bool IsUnlockedWithNoWaiters() const
   305|     {
   306|         WRAPPER_NO_CONTRACT;
   307|         return m_lockState.VolatileLoadWithoutBarrier().IsUnlockedWithNoWaiters();
   308|     }
   309|     UINT32 GetMonitorHeldStateVolatile() const
   310|     {
   311|         WRAPPER_NO_CONTRACT;
   312|         return m_lockState.VolatileLoad().GetMonitorHeldState();
   313|     }
   314|     ULONG GetRecursionLevel() const
   315|     {
   316|         LIMITED_METHOD_CONTRACT;
   317|         return m_Recursion;
   318|     }
   319|     PTR_Thread GetHoldingThread() const
   320|     {
   321|         LIMITED_METHOD_CONTRACT;
   322|         return m_HoldingThread;
   323|     }
   324| private:
   325|     void ResetWaiterStarvationStartTime();
   326|     void RecordWaiterStarvationStartTime();
   327|     bool ShouldStopPreemptingWaiters() const;
   328| private: // friend access is required for this unsafe function
   329|     void InitializeToLockedWithNoWaiters(ULONG recursionLevel, PTR_Thread holdingThread)
   330|     {
   331|         WRAPPER_NO_CONTRACT;
   332|         m_lockState.InitializeToLockedWithNoWaiters();
   333|         m_Recursion = recursionLevel;
   334|         m_HoldingThread = holdingThread;
   335|     }
   336| public:
   337|     static void SpinWait(const YieldProcessorNormalizationInfo &normalizationInfo, DWORD spinIteration);
   338|     bool TryEnterHelper(Thread* pCurThread);
   339|     EnterHelperResult TryEnterBeforeSpinLoopHelper(Thread *pCurThread);
   340|     EnterHelperResult TryEnterInsideSpinLoopHelper(Thread *pCurThread);
   341|     bool TryEnterAfterSpinLoopHelper(Thread *pCurThread);
   342|     AwareLock::LeaveHelperAction LeaveHelper(Thread* pCurThread);
   343|     void    Enter();
   344|     BOOL    TryEnter(INT32 timeOut = 0);
   345|     BOOL    EnterEpilog(Thread *pCurThread, INT32 timeOut = INFINITE);
   346|     BOOL    EnterEpilogHelper(Thread *pCurThread, INT32 timeOut);
   347|     BOOL    Leave();
   348|     void    Signal()
   349|     {
   350|         WRAPPER_NO_CONTRACT;
   351|         m_SemEvent.SetMonitorEvent();
   352|         m_lockState.InterlockedTrySetShouldNotPreemptWaitersIfNecessary(this);
   353|     }
   354|     void    AllocLockSemEvent();
   355|     LONG    LeaveCompletely();
   356|     BOOL    OwnedByCurrentThread();
   357|     void    IncrementTransientPrecious()
   358|     {
   359|         LIMITED_METHOD_CONTRACT;
   360|         InterlockedIncrement(&m_TransientPrecious);
   361|         _ASSERTE(m_TransientPrecious > 0);
   362|     }
   363|     void    DecrementTransientPrecious()
   364|     {
   365|         LIMITED_METHOD_CONTRACT;
   366|         _ASSERTE(m_TransientPrecious > 0);
   367|         InterlockedDecrement(&m_TransientPrecious);
   368|     }
   369|     DWORD GetSyncBlockIndex();
   370|     void SetPrecious();
   371|     inline OBJECTREF GetOwningObject();
   372|     inline PTR_Thread GetOwningThread()
   373|     {
   374|         LIMITED_METHOD_CONTRACT;
   375|         return m_HoldingThread;
   376|     }
   377| };
   378| #ifdef FEATURE_COMINTEROP
   379| class ComCallWrapper;
   380| class ComClassFactory;
   381| struct RCW;
   382| class RCWHolder;
   383| typedef DPTR(class ComCallWrapper)        PTR_ComCallWrapper;
   384| #include "shash.h"
   385| #endif // FEATURE_COMINTEROP
   386| using ManagedObjectComWrapperByIdMap = MapSHash<INT64, void*>;
   387| class InteropSyncBlockInfo
   388| {
   389|     friend class RCWHolder;
   390|     friend class ClrDataAccess;
   391| public:
   392| #ifndef TARGET_UNIX
   393|     static SLIST_HEADER s_InteropInfoStandbyList;
   394| #endif // !TARGET_UNIX
   395|     InteropSyncBlockInfo()
   396|     {
   397|         LIMITED_METHOD_CONTRACT;
   398|         ZeroMemory(this, sizeof(InteropSyncBlockInfo));
   399| #if defined(FEATURE_COMWRAPPERS)
   400|         m_managedObjectComWrapperLock.Init(CrstManagedObjectWrapperMap, CRST_UNSAFE_COOPGC);
   401| #endif // FEATURE_COMWRAPPERS
   402|     }
   403| #ifndef DACCESS_COMPILE
   404|     ~InteropSyncBlockInfo();
   405| #endif
   406| #ifndef TARGET_UNIX
   407|     static void FlushStandbyList();
   408| #endif // !TARGET_UNIX
   409| #ifdef FEATURE_COMINTEROP
   410| #ifndef DACCESS_COMPILE
   411|     RCW* GetRawRCW()
   412|     {
   413|         LIMITED_METHOD_CONTRACT;
   414|         return (RCW *)((size_t)m_pRCW & ~1);
   415|     }
   416|     RCW* GetRCWAndIncrementUseCount();
   417|     void SetRawRCW(RCW* pRCW);
   418|     bool RCWWasUsed()
   419|     {
   420|         LIMITED_METHOD_CONTRACT;
   421|         return (m_pRCW != NULL);
   422|     }
   423| #else // !DACCESS_COMPILE
   424|     TADDR DacGetRawRCW()
   425|     {
   426|         return (TADDR)((size_t)m_pRCW & ~1);
   427|     }
   428| #endif // DACCESS_COMPILE
   429| #ifndef DACCESS_COMPILE
   430|     void SetCCW(ComCallWrapper* pCCW)
   431|     {
   432|         LIMITED_METHOD_CONTRACT;
   433|         if (pCCW == NULL)
   434|             pCCW = (ComCallWrapper*) 0x1;
   435|         m_pCCW = pCCW;
   436|     }
   437| #endif // !DACCESS_COMPILE
   438|     PTR_ComCallWrapper GetCCW()
   439|     {
   440|         LIMITED_METHOD_DAC_CONTRACT;
   441|         if (m_pCCW == (PTR_ComCallWrapper)0x1)
   442|             return NULL;
   443|         return m_pCCW;
   444|     }
   445|     bool CCWWasUsed()
   446|     {
   447|         LIMITED_METHOD_CONTRACT;
   448|         if (m_pCCW == NULL)
   449|             return false;
   450|         return true;
   451|     }
   452| #ifdef FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
   453|     void SetComClassFactory(ComClassFactory* pCCF)
   454|     {
   455|         LIMITED_METHOD_CONTRACT;
   456|         if (pCCF == NULL)
   457|             pCCF = (ComClassFactory*)0x1;
   458|         m_pCCF = pCCF;
   459|     }
   460|     ComClassFactory* GetComClassFactory()
   461|     {
   462|         LIMITED_METHOD_CONTRACT;
   463|         if (m_pCCF == (ComClassFactory*)0x1)
   464|             return NULL;
   465|         return m_pCCF;
   466|     }
   467|     bool CCFWasUsed()
   468|     {
   469|         LIMITED_METHOD_CONTRACT;
   470|         if (m_pCCF == NULL)
   471|             return false;
   472|         return true;
   473|     }
   474| #endif // FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
   475| #endif // FEATURE_COMINTEROP
   476| #if !defined(DACCESS_COMPILE)
   477|     bool SetUMEntryThunk(void* pUMEntryThunk)
   478|     {
   479|         WRAPPER_NO_CONTRACT;
   480|         return (InterlockedCompareExchangeT(&m_pUMEntryThunk,
   481|                                                     pUMEntryThunk,
   482|                                                     NULL) == NULL);
   483|     }
   484|     void FreeUMEntryThunk();
   485| #endif // DACCESS_COMPILE
   486|     void* GetUMEntryThunk()
   487|     {
   488|         LIMITED_METHOD_CONTRACT;
   489|         return m_pUMEntryThunk;
   490|     }
   491| private:
   492|     void*               m_pUMEntryThunk;
   493| #ifdef FEATURE_COMINTEROP
   494|     PTR_ComCallWrapper  m_pCCW;
   495| #ifdef FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
   496|     ComClassFactory*    m_pCCF;
   497| #endif // FEATURE_COMINTEROP_UNMANAGED_ACTIVATION
   498| public:
   499| #ifndef DACCESS_COMPILE
   500|     RCW*                m_pRCW;
   501| #else
   502|     TADDR               m_pRCW;
   503| #endif
   504| #endif // FEATURE_COMINTEROP
   505| #if defined(FEATURE_COMWRAPPERS)
   506| public:
   507|     bool TryGetManagedObjectComWrapper(_In_ INT64 wrapperId, _Out_ void** mocw)
   508|     {
   509|         LIMITED_METHOD_DAC_CONTRACT;
   510|         *mocw = NULL;
   511|         if (m_managedObjectComWrapperMap == NULL)
   512|             return false;
   513|         CrstHolder lock(&m_managedObjectComWrapperLock);
   514|         return m_managedObjectComWrapperMap->Lookup(wrapperId, mocw);
   515|     }
   516| #ifndef DACCESS_COMPILE
   517|     bool TrySetManagedObjectComWrapper(_In_ INT64 wrapperId, _In_ void* mocw, _In_ void* curr = NULL)
   518|     {
   519|         LIMITED_METHOD_CONTRACT;
   520|         if (m_managedObjectComWrapperMap == NULL)
   521|         {
   522|             NewHolder<ManagedObjectComWrapperByIdMap> map = new ManagedObjectComWrapperByIdMap();
   523|             if (InterlockedCompareExchangeT((ManagedObjectComWrapperByIdMap**)&m_managedObjectComWrapperMap, (ManagedObjectComWrapperByIdMap *)map, NULL) == NULL)
   524|             {
   525|                 map.SuppressRelease();
   526|             }
   527|             _ASSERTE(m_managedObjectComWrapperMap != NULL);
   528|         }
   529|         CrstHolder lock(&m_managedObjectComWrapperLock);
   530|         if (m_managedObjectComWrapperMap->LookupPtr(wrapperId) != curr)
   531|             return false;
   532|         m_managedObjectComWrapperMap->Add(wrapperId, mocw);
   533|         return true;
   534|     }
   535|     using ClearWrappersCallback = void(void* mocw);
   536|     void ClearManagedObjectComWrappers(ClearWrappersCallback* callback)
   537|     {
   538|         LIMITED_METHOD_CONTRACT;
   539|         if (m_managedObjectComWrapperMap == NULL)
   540|             return;
   541|         CQuickArrayList<void*> localList;
   542|         {
   543|             CrstHolder lock(&m_managedObjectComWrapperLock);
   544|             if (callback != NULL)
   545|             {
   546|                 ManagedObjectComWrapperByIdMap::Iterator iter = m_managedObjectComWrapperMap->Begin();
   547|                 while (iter != m_managedObjectComWrapperMap->End())
   548|                 {
   549|                     localList.Push(iter->Value());
   550|                     ++iter;
   551|                 }
   552|             }
   553|             m_managedObjectComWrapperMap->RemoveAll();
   554|         }
   555|         for (SIZE_T i = 0; i < localList.Size(); i++)
   556|             callback(localList[i]);
   557|     }
   558|     using EnumWrappersCallback = bool(void* mocw, void* cxt);
   559|     void EnumManagedObjectComWrappers(EnumWrappersCallback* callback, void* cxt)
   560|     {
   561|         LIMITED_METHOD_CONTRACT;
   562|         _ASSERTE(callback != NULL);
   563|         if (m_managedObjectComWrapperMap == NULL)
   564|             return;
   565|         CrstHolder lock(&m_managedObjectComWrapperLock);
   566|         ManagedObjectComWrapperByIdMap::Iterator iter = m_managedObjectComWrapperMap->Begin();
   567|         while (iter != m_managedObjectComWrapperMap->End())
   568|         {
   569|             if (!callback(iter->Value(), cxt))
   570|                 break;
   571|             ++iter;
   572|         }
   573|     }
   574| #endif // !DACCESS_COMPILE
   575|     bool TryGetExternalComObjectContext(_Out_ void** eoc)
   576|     {
   577|         LIMITED_METHOD_DAC_CONTRACT;
   578|         *eoc = m_externalComObjectContext;
   579|         return (*eoc != NULL);
   580|     }
   581| #ifndef DACCESS_COMPILE
   582|     bool TrySetExternalComObjectContext(_In_ void* eoc, _In_ void* curr = NULL)
   583|     {
   584|         LIMITED_METHOD_CONTRACT;
   585|         return (InterlockedCompareExchangeT(
   586|                         &m_externalComObjectContext,
   587|                         eoc,
   588|                         curr) == curr);
   589|     }
   590| #endif // !DACCESS_COMPILE
   591| private:
   592|     void* m_externalComObjectContext;
   593|     CrstExplicitInit m_managedObjectComWrapperLock;
   594|     NewHolder<ManagedObjectComWrapperByIdMap> m_managedObjectComWrapperMap;
   595| #endif // FEATURE_COMWRAPPERS
   596| #ifdef FEATURE_OBJCMARSHAL
   597| public:
   598| #ifndef DACCESS_COMPILE
   599|     PTR_VOID AllocTaggedMemory(_Out_ size_t* memoryInSizeT)
   600|     {
   601|         LIMITED_METHOD_CONTRACT;
   602|         _ASSERTE(memoryInSizeT != NULL);
   603|         *memoryInSizeT = GetTaggedMemorySizeInBytes() / sizeof(SIZE_T);
   604|         m_taggedMemory = m_taggedAlloc;
   605|         return m_taggedMemory;
   606|     }
   607| #endif // !DACCESS_COMPILE
   608|     PTR_VOID GetTaggedMemory()
   609|     {
   610|         LIMITED_METHOD_CONTRACT;
   611|         return m_taggedMemory;
   612|     }
   613|     size_t GetTaggedMemorySizeInBytes()
   614|     {
   615|         LIMITED_METHOD_CONTRACT;
   616|         return ARRAY_SIZE(m_taggedAlloc);
   617|     }
   618| private:
   619|     PTR_VOID m_taggedMemory;
   620|     BYTE m_taggedAlloc[2 * sizeof(void*)];
   621| #endif // FEATURE_OBJCMARSHAL
   622| };
   623| typedef DPTR(InteropSyncBlockInfo) PTR_InteropSyncBlockInfo;
   624| typedef DPTR(SyncBlock) PTR_SyncBlock;
   625| class SyncBlock
   626| {
   627|     friend class ObjHeader;
   628|     friend class SyncBlockCache;
   629|     friend struct ThreadQueue;
   630| #ifdef DACCESS_COMPILE
   631|     friend class ClrDataAccess;
   632| #endif
   633|     friend class CheckAsmOffsets;
   634|   protected:
   635|     AwareLock  m_Monitor;                    // the actual monitor
   636|   public:
   637|     PTR_InteropSyncBlockInfo    m_pInteropInfo;
   638|   protected:
   639| #ifdef EnC_SUPPORTED
   640|     PTR_EnCSyncBlockInfo m_pEnCInfo;
   641| #endif // EnC_SUPPORTED
   642|     SLink       m_Link;
   643|     DWORD m_dwHashCode;
   644|     WCHAR m_BSTRTrailByte;
   645|   public:
   646|     SyncBlock(DWORD indx)
   647|         : m_Monitor(indx)
   648| #ifdef EnC_SUPPORTED
   649|         , m_pEnCInfo(PTR_NULL)
   650| #endif // EnC_SUPPORTED
   651|         , m_dwHashCode(0)
   652|         , m_BSTRTrailByte(0)
   653|     {
   654|         LIMITED_METHOD_CONTRACT;
   655|         m_pInteropInfo = NULL;
   656|         _ASSERTE((((size_t) &m_Monitor) & 3) == 0);
   657|     }
   658|     DWORD GetSyncBlockIndex()
   659|     {
   660|         LIMITED_METHOD_CONTRACT;
   661|         return m_Monitor.GetSyncBlockIndex();
   662|     }
   663|    void SetPrecious()
   664|    {
   665|        WRAPPER_NO_CONTRACT;
   666|        m_Monitor.SetPrecious();
   667|    }
   668|    BOOL IsPrecious()
   669|    {
   670|        LIMITED_METHOD_CONTRACT;
   671|        return (m_Monitor.m_dwSyncIndex & SyncBlockPrecious) != 0;
   672|    }
   673|     BOOL IsIDisposable()
   674|     {
   675|         WRAPPER_NO_CONTRACT;
   676|         return (!IsPrecious() &&
   677|                 m_Monitor.IsUnlockedWithNoWaiters() &&
   678|                 m_Monitor.m_TransientPrecious == 0);
   679|     }
   680|     InteropSyncBlockInfo* GetInteropInfo()
   681|     {
   682|         CONTRACT (InteropSyncBlockInfo*)
   683|         {
   684|             THROWS;
   685|             GC_TRIGGERS;
   686|             MODE_ANY;
   687|             POSTCONDITION(CheckPointer(RETVAL));
   688|         }
   689|         CONTRACT_END;
   690|         if (!m_pInteropInfo)
   691|         {
   692|             NewHolder<InteropSyncBlockInfo> pInteropInfo;
   693| #ifndef TARGET_UNIX
   694|             pInteropInfo = (InteropSyncBlockInfo *)InterlockedPopEntrySList(&InteropSyncBlockInfo::s_InteropInfoStandbyList);
   695|             if (pInteropInfo != NULL)
   696|             {
   697|                 new (pInteropInfo) InteropSyncBlockInfo();
   698|             }
   699|             else
   700| #endif // !TARGET_UNIX
   701|             {
   702|                 pInteropInfo = new InteropSyncBlockInfo();
   703|             }
   704|             if (SetInteropInfo(pInteropInfo))
   705|                 pInteropInfo.SuppressRelease();
   706|         }
   707|         RETURN m_pInteropInfo;
   708|     }
   709|     PTR_InteropSyncBlockInfo GetInteropInfoNoCreate()
   710|     {
   711|         CONTRACT (PTR_InteropSyncBlockInfo)
   712|         {
   713|             NOTHROW;
   714|             GC_NOTRIGGER;
   715|             MODE_ANY;
   716|             SUPPORTS_DAC;
   717|             POSTCONDITION(CheckPointer(RETVAL, NULL_OK));
   718|         }
   719|         CONTRACT_END;
   720|         RETURN m_pInteropInfo;
   721|     }
   722|     bool SetInteropInfo(InteropSyncBlockInfo* pInteropInfo);
   723| #ifdef EnC_SUPPORTED
   724|     PTR_EnCSyncBlockInfo GetEnCInfo()
   725|     {
   726|         LIMITED_METHOD_DAC_CONTRACT;
   727|         return m_pEnCInfo;
   728|     }
   729|     void SetEnCInfo(EnCSyncBlockInfo *pEnCInfo);
   730| #endif // EnC_SUPPORTED
   731|     DWORD GetHashCode()
   732|     {
   733|         LIMITED_METHOD_CONTRACT;
   734|         return m_dwHashCode;
   735|     }
   736|     DWORD SetHashCode(DWORD hashCode)
   737|     {
   738|         WRAPPER_NO_CONTRACT;
   739|         DWORD result = InterlockedCompareExchange((LONG*)&m_dwHashCode, hashCode, 0);
   740|         if (result == 0)
   741|         {
   742|             SetPrecious();
   743|             return hashCode;
   744|         }
   745|         else
   746|             return result;
   747|     }
   748|     void *operator new (size_t sz, void* p)
   749|     {
   750|         LIMITED_METHOD_CONTRACT;
   751|         return p ;
   752|     }
   753|     void operator delete(void *p)
   754|     {
   755|         LIMITED_METHOD_CONTRACT;
   756|     }
   757|     void EnterMonitor()
   758|     {
   759|         WRAPPER_NO_CONTRACT;
   760|         m_Monitor.Enter();
   761|     }
   762|     BOOL TryEnterMonitor(INT32 timeOut = 0)
   763|     {
   764|         WRAPPER_NO_CONTRACT;
   765|         return m_Monitor.TryEnter(timeOut);
   766|     }
   767|     BOOL LeaveMonitor()
   768|     {
   769|         WRAPPER_NO_CONTRACT;
   770|         return m_Monitor.Leave();
   771|     }
   772|     AwareLock* GetMonitor()
   773|     {
   774|         WRAPPER_NO_CONTRACT;
   775|         SUPPORTS_DAC;
   776| #ifndef DACCESS_COMPILE
   777|         SetPrecious();
   778| #endif
   779|         return &m_Monitor;
   780|     }
   781|     AwareLock* QuickGetMonitor()
   782|     {
   783|         LIMITED_METHOD_CONTRACT;
   784|         return &m_Monitor;
   785|     }
   786|     BOOL DoesCurrentThreadOwnMonitor()
   787|     {
   788|         WRAPPER_NO_CONTRACT;
   789|         return m_Monitor.OwnedByCurrentThread();
   790|     }
   791|     LONG LeaveMonitorCompletely()
   792|     {
   793|         WRAPPER_NO_CONTRACT;
   794|         return m_Monitor.LeaveCompletely();
   795|     }
   796|     BOOL Wait(INT32 timeOut);
   797|     void Pulse();
   798|     void PulseAll();
   799|     enum
   800|     {
   801|         SyncBlockPrecious   = 0x80000000,
   802|     };
   803|     BOOL HasCOMBstrTrailByte()
   804|     {
   805|         LIMITED_METHOD_CONTRACT;
   806|         return (m_BSTRTrailByte!=0);
   807|     }
   808|     WCHAR GetCOMBstrTrailByte()
   809|     {
   810|         return m_BSTRTrailByte;
   811|     }
   812|     void SetCOMBstrTrailByte(WCHAR trailByte)
   813|     {
   814|         WRAPPER_NO_CONTRACT;
   815|         m_BSTRTrailByte = trailByte;
   816|         SetPrecious();
   817|     }
   818|   protected:
   819|     void InitState(ULONG recursionLevel, PTR_Thread holdingThread)
   820|     {
   821|         WRAPPER_NO_CONTRACT;
   822|         m_Monitor.InitializeToLockedWithNoWaiters(recursionLevel, holdingThread);
   823|     }
   824| #if defined(ENABLE_CONTRACTS_IMPL)
   825|     void * GetPtrForLockContract()
   826|     {
   827|         return m_Monitor.GetPtrForLockContract();
   828|     }
   829| #endif // defined(ENABLE_CONTRACTS_IMPL)
   830| };
   831| class SyncTableEntry
   832| {
   833|   public:
   834|     PTR_SyncBlock    m_SyncBlock;
   835|     VolatilePtr<Object, PTR_Object> m_Object;
   836|     static PTR_SyncTableEntry GetSyncTableEntry();
   837| #ifndef DACCESS_COMPILE
   838|     static SyncTableEntry*& GetSyncTableEntryByRef();
   839| #endif
   840| };
   841| #ifdef _DEBUG
   842| extern void DumpSyncBlockCache();
   843| #endif
   844| typedef DPTR(SyncBlockCache) PTR_SyncBlockCache;
   845| class SyncBlockCache
   846| {
   847| #ifdef DACCESS_COMPILE
   848|     friend class ClrDataAccess;
   849| #endif
   850|     friend class SyncBlock;
   851|   private:
   852|     PTR_SLink   m_pCleanupBlockList;    // list of sync blocks that need cleanup
   853|     SLink*      m_FreeBlockList;        // list of free sync blocks
   854|     Crst        m_CacheLock;            // cache lock
   855|     DWORD       m_FreeCount;            // count of active sync blocks
   856|     DWORD       m_ActiveCount;          // number active
   857|     SyncBlockArray *m_SyncBlocks;       // Array of new SyncBlocks.
   858|     DWORD       m_FreeSyncBlock;        // Next Free Syncblock in the array
   859|     DWORD       m_FreeSyncTableIndex;   // We allocate a large array of SyncTableEntry structures.
   860|     size_t      m_FreeSyncTableList;    // index of the first free SyncTableEntry in our free list.
   861|     DWORD       m_SyncTableSize;
   862|     SyncTableEntry *m_OldSyncTables;    // Next old SyncTable
   863|     BOOL        m_bSyncBlockCleanupInProgress;  // A flag indicating if sync block cleanup is in progress.
   864|     DWORD*      m_EphemeralBitmap;      // card table for ephemeral scanning
   865|     BOOL        GCWeakPtrScanElement(int elindex, HANDLESCANPROC scanProc, LPARAM lp1, LPARAM lp2, BOOL& cleanup);
   866|     void SetCard (size_t card);
   867|     void ClearCard (size_t card);
   868|     BOOL CardSetP (size_t card);
   869|     void CardTableSetBit (size_t idx);
   870|     void Grow();
   871|   public:
   872|     SPTR_DECL(SyncBlockCache, s_pSyncBlockCache);
   873|     static SyncBlockCache*& GetSyncBlockCache();
   874|     void *operator new(size_t size, void *pInPlace)
   875|     {
   876|         LIMITED_METHOD_CONTRACT;
   877|         return pInPlace;
   878|     }
   879|     void operator delete(void *p)
   880|     {
   881|         LIMITED_METHOD_CONTRACT;
   882|     }
   883|     SyncBlockCache();
   884|     ~SyncBlockCache();
   885|     static void Attach();
   886|     static void Detach();
   887|     void DoDetach();
   888|     static void Start();
   889|     static void Stop();
   890|     SyncBlock* GetNextFreeSyncBlock();
   891|     SyncBlock* GetNextCleanupSyncBlock();
   892|     void    InsertCleanupSyncBlock(SyncBlock* psb);
   893|     DWORD   NewSyncBlockSlot(Object *obj);
   894|     void    DeleteSyncBlock(SyncBlock *sb);
   895|     void    DeleteSyncBlockMemory(SyncBlock *sb);
   896|     void    GCDeleteSyncBlock(SyncBlock *sb);
   897|     void    GCWeakPtrScan(HANDLESCANPROC scanProc, uintptr_t lp1, uintptr_t lp2);
   898|     void    GCDone(BOOL demoting, int max_gen);
   899|     void    CleanupSyncBlocks();
   900|     int GetTableEntryCount()
   901|     {
   902|         LIMITED_METHOD_CONTRACT;
   903|         return m_FreeSyncTableIndex - 1;
   904|     }
   905|     BOOL    IsSyncBlockCleanupInProgress()
   906|     {
   907|         LIMITED_METHOD_CONTRACT;
   908|         return m_bSyncBlockCleanupInProgress;
   909|     }
   910|     DWORD GetActiveCount()
   911|     {
   912|         return m_ActiveCount;
   913|     }
   914|     class LockHolder : public CrstHolder
   915|     {
   916|     public:
   917|         LockHolder(SyncBlockCache *pCache)
   918|             : CrstHolder(&pCache->m_CacheLock)
   919|         {
   920|             CONTRACTL
   921|             {
   922|                 NOTHROW;
   923|                 GC_NOTRIGGER;
   924|                 MODE_ANY;
   925|                 CAN_TAKE_LOCK;
   926|             }
   927|             CONTRACTL_END;
   928|         }
   929|     };
   930|     friend class LockHolder;
   931| #ifdef _DEBUG
   932|     friend void DumpSyncBlockCache();
   933| #endif
   934| #ifdef VERIFY_HEAP
   935|     void    VerifySyncTableEntry();
   936| #endif
   937| };
   938| class ObjHeader
   939| {
   940|     friend class CheckAsmOffsets;
   941|   private:
   942| #ifdef HOST_64BIT
   943|     DWORD    m_alignpad;
   944| #endif // HOST_64BIT
   945|     Volatile<DWORD> m_SyncBlockValue;      // the Index and the Bits
   946| #if defined(HOST_64BIT) && defined(_DEBUG)
   947|     void IllegalAlignPad();
   948| #endif // HOST_64BIT && _DEBUG
   949|     INCONTRACT(void * GetPtrForLockContract());
   950|   public:
   951|     FORCEINLINE DWORD GetHeaderSyncBlockIndex()
   952|     {
   953|         LIMITED_METHOD_DAC_CONTRACT;
   954| #if defined(HOST_64BIT) && defined(_DEBUG) && !defined(DACCESS_COMPILE)
   955|         if (m_alignpad != 0)
   956|             IllegalAlignPad();
   957| #endif // HOST_64BIT && _DEBUG && !DACCESS_COMPILE
   958|         DWORD value = m_SyncBlockValue.LoadWithoutBarrier();
   959|         if ((value & (BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE)) != BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX)
   960|             return 0;
   961|         return value & MASK_SYNCBLOCKINDEX;
   962|     }
   963|     void SetIndex(DWORD indx)
   964|     {
   965|         CONTRACTL
   966|         {
   967|             INSTANCE_CHECK;
   968|             NOTHROW;
   969|             GC_NOTRIGGER;
   970|             FORBID_FAULT;
   971|             MODE_ANY;
   972|             PRECONDITION(GetHeaderSyncBlockIndex() == 0);
   973|             PRECONDITION(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
   974|         }
   975|         CONTRACTL_END
   976|         LONG newValue;
   977|         LONG oldValue;
   978|         while (TRUE) {
   979|             oldValue = m_SyncBlockValue.LoadWithoutBarrier();
   980|             _ASSERTE(GetHeaderSyncBlockIndex() == 0);
   981|             newValue = (indx |
   982|                 (oldValue & ~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX)));
   983|             if (InterlockedCompareExchange((LONG*)&m_SyncBlockValue,
   984|                                              newValue,
   985|                                              oldValue)
   986|                 == oldValue)
   987|             {
   988|                 return;
   989|             }
   990|         }
   991|     }
   992|     void ResetIndex()
   993|     {
   994|         LIMITED_METHOD_CONTRACT;
   995|         _ASSERTE(m_SyncBlockValue & BIT_SBLK_SPIN_LOCK);
   996|         InterlockedAnd((LONG*)&m_SyncBlockValue, ~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX));
   997|     }
   998|     void GCResetIndex()
   999|     {
  1000|         LIMITED_METHOD_CONTRACT;
  1001|         m_SyncBlockValue.RawValue() &=~(BIT_SBLK_IS_HASH_OR_SYNCBLKINDEX | BIT_SBLK_IS_HASHCODE | MASK_SYNCBLOCKINDEX);
  1002|     }
  1003|     void SetBit(DWORD bit)
  1004|     {
  1005|         LIMITED_METHOD_CONTRACT;
  1006|         _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
  1007|         InterlockedOr((LONG*)&m_SyncBlockValue, bit);
  1008|     }
  1009|     void ClrBit(DWORD bit)
  1010|     {
  1011|         LIMITED_METHOD_CONTRACT;
  1012|         _ASSERTE((bit & MASK_SYNCBLOCKINDEX) == 0);
  1013|         InterlockedAnd((LONG*)&m_SyncBlockValue, ~bit);
  1014|     }
  1015|     void SetGCBit()
  1016|     {
  1017|         LIMITED_METHOD_CONTRACT;
  1018|         m_SyncBlockValue.RawValue() |= BIT_SBLK_GC_RESERVE;
  1019|     }
  1020|     void ClrGCBit()
  1021|     {
  1022|         LIMITED_METHOD_CONTRACT;
  1023|         m_SyncBlockValue.RawValue() &= ~BIT_SBLK_GC_RESERVE;
  1024|     }
  1025|     DWORD GetBits()
  1026|     {
  1027|         LIMITED_METHOD_CONTRACT;
  1028|         SUPPORTS_DAC;
  1029| #if defined(HOST_64BIT) && defined(_DEBUG) && !defined(DACCESS_COMPILE)
  1030|         if (m_alignpad != 0)
  1031|             IllegalAlignPad();
  1032| #endif // HOST_64BIT && _DEBUG && !DACCESS_COMPILE
  1033|         return m_SyncBlockValue.LoadWithoutBarrier();
  1034|     }
  1035|     DWORD SetBits(DWORD newBits, DWORD oldBits)
  1036|     {
  1037|         LIMITED_METHOD_CONTRACT;
  1038|         _ASSERTE((oldBits & BIT_SBLK_SPIN_LOCK) == 0);
  1039|         DWORD result = InterlockedCompareExchange((LONG*)&m_SyncBlockValue, newBits, oldBits);
  1040|         return result;
  1041|     }
  1042| #ifdef _DEBUG
  1043|     BOOL HasEmptySyncBlockInfo()
  1044|     {
  1045|         WRAPPER_NO_CONTRACT;
  1046|         return m_SyncBlockValue.LoadWithoutBarrier() == 0;
  1047|     }
  1048| #endif
  1049|     BOOL HasSyncBlockIndex()
  1050|     {
  1051|         LIMITED_METHOD_DAC_CONTRACT;
  1052|         return (GetHeaderSyncBlockIndex() != 0);
  1053|     }
  1054|     SyncBlock *GetSyncBlock();
  1055|     PTR_SyncBlock PassiveGetSyncBlock()
  1056|     {
  1057|         LIMITED_METHOD_DAC_CONTRACT;
  1058|         return g_pSyncTable [(int)GetHeaderSyncBlockIndex()].m_SyncBlock;
  1059|     }
  1060|     DWORD GetSyncBlockIndex();
  1061|     void EnterObjMonitor();
  1062|     BOOL TryEnterObjMonitor(INT32 timeOut = 0);
  1063|     AwareLock::EnterHelperResult EnterObjMonitorHelper(Thread* pCurThread);
  1064|     AwareLock::EnterHelperResult EnterObjMonitorHelperSpin(Thread* pCurThread);
  1065|     BOOL LeaveObjMonitor();
  1066|     BOOL LeaveObjMonitorAtException();
  1067|     AwareLock::LeaveHelperAction LeaveObjMonitorHelper(Thread* pCurThread);
  1068|     BOOL GetThreadOwningMonitorLock(DWORD *pThreadId, DWORD *pAcquisitionCount);
  1069|     PTR_Object GetBaseObject()
  1070|     {
  1071|         LIMITED_METHOD_DAC_CONTRACT;
  1072|         return dac_cast<PTR_Object>(dac_cast<TADDR>(this + 1));
  1073|     }
  1074|     BOOL Wait(INT32 timeOut);
  1075|     void Pulse();
  1076|     void PulseAll();
  1077|     void EnterSpinLock();
  1078|     void ReleaseSpinLock();
  1079|     BOOL Validate (BOOL bVerifySyncBlkIndex = TRUE);
  1080| };
  1081| typedef DPTR(class ObjHeader) PTR_ObjHeader;
  1082| #define ENTER_SPIN_LOCK(pOh)        \
  1083|     pOh->EnterSpinLock();
  1084| #define LEAVE_SPIN_LOCK(pOh)        \
  1085|     pOh->ReleaseSpinLock();
  1086| #ifdef DACCESS_COMPILE
  1087| typedef void (*FP_TQ_THREAD_ENUMERATION_CALLBACK)(PTR_Thread pThread, VOID* pUserData);
  1088| #endif
  1089| struct ThreadQueue
  1090| {
  1091|     static PTR_WaitEventLink WaitEventLinkForLink(PTR_SLink pLink);
  1092|     static WaitEventLink *DequeueThread(SyncBlock *psb);
  1093|     static void          EnqueueThread(WaitEventLink *pWaitEventLink, SyncBlock *psb);
  1094|     static BOOL          RemoveThread (Thread *pThread, SyncBlock *psb);
  1095| #ifdef DACCESS_COMPILE
  1096|     static void          EnumerateThreads(SyncBlock *psb,
  1097|                                           FP_TQ_THREAD_ENUMERATION_CALLBACK pCallbackFunction,
  1098|                                           void* pUserData);
  1099| #endif
  1100| };
  1101| inline void AwareLock::SetPrecious()
  1102| {
  1103|     LIMITED_METHOD_CONTRACT;
  1104|     m_dwSyncIndex |= SyncBlock::SyncBlockPrecious;
  1105| }
  1106| inline DWORD AwareLock::GetSyncBlockIndex()
  1107| {
  1108|     LIMITED_METHOD_CONTRACT;
  1109|     return (m_dwSyncIndex & ~SyncBlock::SyncBlockPrecious);
  1110| }
  1111| #ifdef TARGET_X86
  1112| #include <poppack.h>
  1113| #endif // TARGET_X86
  1114| #endif // _SYNCBLK_H_


# ====================================================================
# FILE: src/libraries/Common/src/System/Net/Http/X509ResourceClient.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-251 ---
     1| using System.Diagnostics;
     2| using System.Diagnostics.CodeAnalysis;
     3| using System.IO;
     4| using System.Reflection;
     5| using System.Threading;
     6| using System.Threading.Tasks;
     7| namespace System.Net.Http
     8| {
     9|     internal static partial class X509ResourceClient
    10|     {
    11|         private const long DefaultAiaDownloadLimit = 100 * 1024 * 1024;
    12|         private static long AiaDownloadLimit { get; } = GetValue("System.Security.Cryptography.AiaDownloadLimit", DefaultAiaDownloadLimit);
    13|         private static readonly Func<string, CancellationToken, bool, ValueTask<byte[]?>>? s_downloadBytes = CreateDownloadBytesFunc();
    14|         static partial void ReportNoClient();
    15|         static partial void ReportNegativeTimeout();
    16|         static partial void ReportDownloadStart(long totalMillis, string uri);
    17|         static partial void ReportDownloadStop(int bytesDownloaded);
    18|         static partial void ReportRedirectsExceeded();
    19|         static partial void ReportRedirected(Uri newUri);
    20|         static partial void ReportRedirectNotFollowed(Uri redirectUri);
    21|         internal static byte[]? DownloadAsset(string uri, TimeSpan downloadTimeout)
    22|         {
    23|             ValueTask<byte[]?> task = DownloadAssetCore(uri, downloadTimeout, async: false);
    24|             Debug.Assert(task.IsCompletedSuccessfully);
    25|             return task.Result;
    26|         }
    27|         internal static Task<byte[]?> DownloadAssetAsync(string uri, TimeSpan downloadTimeout)
    28|         {
    29|             ValueTask<byte[]?> task = DownloadAssetCore(uri, downloadTimeout, async: true);
    30|             return task.AsTask();
    31|         }
    32|         private static async ValueTask<byte[]?> DownloadAssetCore(string uri, TimeSpan downloadTimeout, bool async)
    33|         {
    34|             if (s_downloadBytes is null)
    35|             {
    36|                 ReportNoClient();
    37|                 return null;
    38|             }
    39|             if (downloadTimeout <= TimeSpan.Zero)
    40|             {
    41|                 ReportNegativeTimeout();
    42|                 return null;
    43|             }
    44|             long totalMillis = (long)downloadTimeout.TotalMilliseconds;
    45|             ReportDownloadStart(totalMillis, uri);
    46|             CancellationTokenSource? cts = totalMillis > int.MaxValue ? null : new CancellationTokenSource((int)totalMillis);
    47|             byte[]? ret = null;
    48|             try
    49|             {
    50|                 ret = await s_downloadBytes(uri, cts?.Token ?? default, async).ConfigureAwait(false);
    51|                 return ret;
    52|             }
    53|             catch { }
    54|             finally
    55|             {
    56|                 cts?.Dispose();
    57|                 ReportDownloadStop(ret?.Length ?? 0);
    58|             }
    59|             return null;
    60|         }
    61|         private static Func<string, CancellationToken, bool, ValueTask<byte[]?>>? CreateDownloadBytesFunc()
    62|         {
    63|             try
    64|             {
    65|                 Type? socketsHttpHandlerType = Type.GetType("System.Net.Http.SocketsHttpHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    66|                 Type? httpMessageHandlerType = Type.GetType("System.Net.Http.HttpMessageHandler, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    67|                 Type? httpClientType = Type.GetType("System.Net.Http.HttpClient, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    68|                 Type? httpRequestMessageType = Type.GetType("System.Net.Http.HttpRequestMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    69|                 Type? httpResponseMessageType = Type.GetType("System.Net.Http.HttpResponseMessage, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    70|                 Type? httpResponseHeadersType = Type.GetType("System.Net.Http.Headers.HttpResponseHeaders, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    71|                 Type? httpContentType = Type.GetType("System.Net.Http.HttpContent, System.Net.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", throwOnError: false);
    72|                 if (socketsHttpHandlerType == null || httpMessageHandlerType == null || httpClientType == null || httpRequestMessageType == null ||
    73|                     httpResponseMessageType == null || httpResponseHeadersType == null || httpContentType == null)
    74|                 {
    75|                     Debug.Fail("Unable to load required type.");
    76|                     return null;
    77|                 }
    78|                 [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode",
    79|                    Justification = "The type HttpResponseMessage is a reference type")]
    80|                 [return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
    81|                 static Type GetTaskOfHttpResponseMessageType([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] Type? httpResponseMessageType) => typeof(Task<>).MakeGenericType(httpResponseMessageType!);
    82|                 Type taskOfHttpResponseMessageType = GetTaskOfHttpResponseMessageType(httpResponseMessageType);
    83|                 ConstructorInfo? socketsHttpHandlerCtor = socketsHttpHandlerType.GetConstructor(Type.EmptyTypes);
    84|                 PropertyInfo? pooledConnectionIdleTimeoutProp = socketsHttpHandlerType.GetProperty("PooledConnectionIdleTimeout");
    85|                 PropertyInfo? allowAutoRedirectProp = socketsHttpHandlerType.GetProperty("AllowAutoRedirect");
    86|                 ConstructorInfo? httpClientCtor = httpClientType.GetConstructor(new Type[] { httpMessageHandlerType });
    87|                 PropertyInfo? requestUriProp = httpRequestMessageType.GetProperty("RequestUri");
    88|                 ConstructorInfo? httpRequestMessageCtor = httpRequestMessageType.GetConstructor(Type.EmptyTypes);
    89|                 MethodInfo? sendMethod = httpClientType.GetMethod("Send", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
    90|                 MethodInfo? sendAsyncMethod = httpClientType.GetMethod("SendAsync", new Type[] { httpRequestMessageType, typeof(CancellationToken) });
    91|                 PropertyInfo? maxResponseContentBufferSizeProp = httpClientType.GetProperty("MaxResponseContentBufferSize");
    92|                 PropertyInfo? responseContentProp = httpResponseMessageType.GetProperty("Content");
    93|                 PropertyInfo? responseStatusCodeProp = httpResponseMessageType.GetProperty("StatusCode");
    94|                 PropertyInfo? responseHeadersProp = httpResponseMessageType.GetProperty("Headers");
    95|                 PropertyInfo? responseHeadersLocationProp = httpResponseHeadersType.GetProperty("Location");
    96|                 MethodInfo? readAsStreamMethod = httpContentType.GetMethod("ReadAsStream", Type.EmptyTypes);
    97|                 PropertyInfo? taskOfHttpResponseMessageResultProp = taskOfHttpResponseMessageType.GetProperty("Result");
    98|                 if (socketsHttpHandlerCtor == null || pooledConnectionIdleTimeoutProp == null ||
    99|                     allowAutoRedirectProp == null || httpClientCtor == null ||
   100|                     requestUriProp == null || httpRequestMessageCtor == null ||
   101|                     sendMethod == null || sendAsyncMethod == null || maxResponseContentBufferSizeProp == null ||
   102|                     responseContentProp == null || responseStatusCodeProp == null ||
   103|                     responseHeadersProp == null || responseHeadersLocationProp == null ||
   104|                     readAsStreamMethod == null || taskOfHttpResponseMessageResultProp == null)
   105|                 {
   106|                     Debug.Fail("Unable to load required members.");
   107|                     return null;
   108|                 }
   109|                 const int PooledConnectionIdleTimeoutSeconds = 15;
   110|                 const int MaxRedirections = 10;
   111|                 object? socketsHttpHandler = socketsHttpHandlerCtor.Invoke(null);
   112|                 pooledConnectionIdleTimeoutProp.SetValue(socketsHttpHandler, TimeSpan.FromSeconds(PooledConnectionIdleTimeoutSeconds));
   113|                 allowAutoRedirectProp.SetValue(socketsHttpHandler, false);
   114|                 object? httpClient = httpClientCtor.Invoke(new object?[] { socketsHttpHandler });
   115|                 maxResponseContentBufferSizeProp.SetValue(httpClient, AiaDownloadLimit);
   116|                 return async (string uriString, CancellationToken cancellationToken, bool async) =>
   117|                 {
   118|                     Uri uri = new Uri(uriString);
   119|                     if (!IsAllowedScheme(uri.Scheme))
   120|                     {
   121|                         return null;
   122|                     }
   123|                     object requestMessage = httpRequestMessageCtor.Invoke(null);
   124|                     requestUriProp.SetValue(requestMessage, uri);
   125|                     object responseMessage;
   126|                     if (async)
   127|                     {
   128|                         Task sendTask = (Task)sendAsyncMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   129|                         await sendTask.ConfigureAwait(false);
   130|                         responseMessage = taskOfHttpResponseMessageResultProp.GetValue(sendTask)!;
   131|                     }
   132|                     else
   133|                     {
   134|                         responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   135|                     }
   136|                     int redirections = 0;
   137|                     Uri? redirectUri;
   138|                     bool hasRedirect;
   139|                     while (true)
   140|                     {
   141|                         int statusCode = (int)responseStatusCodeProp.GetValue(responseMessage)!;
   142|                         object responseHeaders = responseHeadersProp.GetValue(responseMessage)!;
   143|                         Uri? location = (Uri?)responseHeadersLocationProp.GetValue(responseHeaders);
   144|                         redirectUri = GetUriForRedirect((Uri)requestUriProp.GetValue(requestMessage)!, statusCode, location, out hasRedirect);
   145|                         if (redirectUri == null)
   146|                         {
   147|                             break;
   148|                         }
   149|                         ((IDisposable)responseMessage).Dispose();
   150|                         redirections++;
   151|                         if (redirections > MaxRedirections)
   152|                         {
   153|                             ReportRedirectsExceeded();
   154|                             return null;
   155|                         }
   156|                         ReportRedirected(redirectUri);
   157|                         requestMessage = httpRequestMessageCtor.Invoke(null);
   158|                         requestUriProp.SetValue(requestMessage, redirectUri);
   159|                         if (async)
   160|                         {
   161|                             Task sendTask = (Task)sendAsyncMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   162|                             await sendTask.ConfigureAwait(false);
   163|                             responseMessage = taskOfHttpResponseMessageResultProp.GetValue(sendTask)!;
   164|                         }
   165|                         else
   166|                         {
   167|                             responseMessage = sendMethod.Invoke(httpClient, new object[] { requestMessage, cancellationToken })!;
   168|                         }
   169|                     }
   170|                     if (hasRedirect && redirectUri == null)
   171|                     {
   172|                         return null;
   173|                     }
   174|                     object content = responseContentProp.GetValue(responseMessage)!;
   175|                     using Stream responseStream = (Stream)readAsStreamMethod.Invoke(content, null)!;
   176|                     var result = new MemoryStream();
   177|                     if (async)
   178|                     {
   179|                         await responseStream.CopyToAsync(result).ConfigureAwait(false);
   180|                     }
   181|                     else
   182|                     {
   183|                         responseStream.CopyTo(result);
   184|                     }
   185|                     ((IDisposable)responseMessage).Dispose();
   186|                     return result.ToArray();
   187|                 };
   188|             }
   189|             catch
   190|             {
   191|                 return null;
   192|             }
   193|         }
   194|         private static Uri? GetUriForRedirect(Uri requestUri, int statusCode, Uri? location, out bool hasRedirect)
   195|         {
   196|             if (!IsRedirectStatusCode(statusCode))
   197|             {
   198|                 hasRedirect = false;
   199|                 return null;
   200|             }
   201|             hasRedirect = true;
   202|             if (location == null)
   203|             {
   204|                 return null;
   205|             }
   206|             if (!location.IsAbsoluteUri)
   207|             {
   208|                 location = new Uri(requestUri, location);
   209|             }
   210|             string requestFragment = requestUri.Fragment;
   211|             if (!string.IsNullOrEmpty(requestFragment))
   212|             {
   213|                 string redirectFragment = location.Fragment;
   214|                 if (string.IsNullOrEmpty(redirectFragment))
   215|                 {
   216|                     location = new UriBuilder(location) { Fragment = requestFragment }.Uri;
   217|                 }
   218|             }
   219|             if (!IsAllowedScheme(location.Scheme))
   220|             {
   221|                 ReportRedirectNotFollowed(location);
   222|                 return null;
   223|             }
   224|             return location;
   225|         }
   226|         private static bool IsRedirectStatusCode(int statusCode)
   227|         {
   228|             return (statusCode >= 300 && statusCode <= 303) || statusCode == 307 || statusCode == 308;
   229|         }
   230|         private static bool IsAllowedScheme(string scheme)
   231|         {
   232|             return string.Equals(scheme, "http", StringComparison.OrdinalIgnoreCase);
   233|         }
   234|         private static long GetValue(string name, long defaultValue)
   235|         {
   236|             object? data = AppContext.GetData(name);
   237|             if (data is null)
   238|             {
   239|                 return defaultValue;
   240|             }
   241|             try
   242|             {
   243|                 return Convert.ToInt64(data);
   244|             }
   245|             catch
   246|             {
   247|                 return defaultValue;
   248|             }
   249|         }
   250|     }
   251| }


# ====================================================================
# FILE: src/libraries/System.DirectoryServices.AccountManagement/src/System/DirectoryServices/AccountManagement/interopt.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-376 ---
     1| using System;
     2| using System.Runtime.InteropServices;
     3| #pragma warning disable CS0618 // Type or member is obsolete
     4| namespace System.DirectoryServices.AccountManagement
     5| {
     6|     internal static class Constants
     7|     {
     8|         internal static byte[] GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE = new byte[] { 0x22, 0xb7, 0x0c, 0x67, 0xd5, 0x6e, 0x4e, 0xfb, 0x91, 0xe9, 0x30, 0x0f, 0xca, 0x3d, 0xc1, 0xaa };
     9|     }
    10|     internal static class UnsafeNativeMethods
    11|     {
    12|         public static int ADsOpenObject(string path, string userName, string password, int flags, [In, Out] ref Guid iid, [Out, MarshalAs(UnmanagedType.Interface)] out object ppObject)
    13|         {
    14|             IntPtr ppObjPtr = IntPtr.Zero;
    15|             try
    16|             {
    17|                 int hr = Interop.Activeds.ADsOpenObject(path, userName, password, flags, ref iid, out ppObjPtr);
    18|                 ppObject = Marshal.GetObjectForIUnknown(ppObjPtr);
    19|                 return hr;
    20|             }
    21|             catch (EntryPointNotFoundException)
    22|             {
    23|                 throw new InvalidOperationException(SR.AdsiNotInstalled);
    24|             }
    25|             finally
    26|             {
    27|                 if (ppObjPtr != IntPtr.Zero)
    28|                 {
    29|                     Marshal.Release(ppObjPtr);
    30|                 }
    31|             }
    32|         }
    33|         internal enum ADS_PASSWORD_ENCODING_ENUM
    34|         {
    35|             ADS_PASSWORD_ENCODE_REQUIRE_SSL = 0,
    36|             ADS_PASSWORD_ENCODE_CLEAR = 1
    37|         }
    38|         internal enum ADS_OPTION_ENUM
    39|         {
    40|             ADS_OPTION_SERVERNAME = 0,
    41|             ADS_OPTION_REFERRALS = 1,
    42|             ADS_OPTION_PAGE_SIZE = 2,
    43|             ADS_OPTION_SECURITY_MASK = 3,
    44|             ADS_OPTION_MUTUAL_AUTH_STATUS = 4,
    45|             ADS_OPTION_QUOTA = 5,
    46|             ADS_OPTION_PASSWORD_PORTNUMBER = 6,
    47|             ADS_OPTION_PASSWORD_METHOD = 7,
    48|             ADS_OPTION_ACCUMULATIVE_MODIFICATION = 8,
    49|             ADS_OPTION_SKIP_SID_LOOKUP = 9
    50|         }
    51|         [ComImport, Guid("7E99C0A2-F935-11D2-BA96-00C04FB6D0D1"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    52|         public interface IADsDNWithBinary
    53|         {
    54|             object BinaryValue { get; set; }
    55|             string DNString { get; set; }
    56|         }
    57|         [ComImport, Guid("9068270b-0939-11D1-8be1-00c04fd8d503"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    58|         public interface IADsLargeInteger
    59|         {
    60|             int HighPart { get; set; }
    61|             int LowPart { get; set; }
    62|         }
    63|         [ComImport, Guid("927971f5-0939-11d1-8be1-00c04fd8d503")]
    64|         public class ADsLargeInteger
    65|         {
    66|         }
    67|         [ComImport, Guid("46f14fda-232b-11d1-a808-00c04fd8d5a8"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    68|         public interface IAdsObjectOptions
    69|         {
    70|             [return: MarshalAs(UnmanagedType.Struct)]
    71|             object GetOption(
    72|                 [In]
    73|                 int option);
    74|             void PutOption(
    75|                 [In]
    76|                 int option,
    77|                 [In, MarshalAs(UnmanagedType.Struct)]
    78|                 object vProp);
    79|         }
    80|         [ComImport, Guid("FD8256D0-FD15-11CE-ABC4-02608C9E7553"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
    81|         public interface IADs
    82|         {
    83|             string Name
    84|             {
    85|                 [return: MarshalAs(UnmanagedType.BStr)]
    86|                 get;
    87|             }
    88|             string Class
    89|             {
    90|                 [return: MarshalAs(UnmanagedType.BStr)]
    91|                 get;
    92|             }
    93|             string GUID
    94|             {
    95|                 [return: MarshalAs(UnmanagedType.BStr)]
    96|                 get;
    97|             }
    98|             string ADsPath
    99|             {
   100|                 [return: MarshalAs(UnmanagedType.BStr)]
   101|                 get;
   102|             }
   103|             string Parent
   104|             {
   105|                 [return: MarshalAs(UnmanagedType.BStr)]
   106|                 get;
   107|             }
   108|             string Schema
   109|             {
   110|                 [return: MarshalAs(UnmanagedType.BStr)]
   111|                 get;
   112|             }
   113|             void GetInfo();
   114|             void SetInfo();
   115|             [return: MarshalAs(UnmanagedType.Struct)]
   116|             object Get(
   117|                 [In, MarshalAs(UnmanagedType.BStr)]
   118|                 string bstrName);
   119|             void Put(
   120|                 [In, MarshalAs(UnmanagedType.BStr)]
   121|                 string bstrName,
   122|                 [In, MarshalAs(UnmanagedType.Struct)]
   123|                 object vProp);
   124|             [return: MarshalAs(UnmanagedType.Struct)]
   125|             object GetEx(
   126|                 [In, MarshalAs(UnmanagedType.BStr)]
   127|                 string bstrName);
   128|             void PutEx(
   129|                 [In, MarshalAs(UnmanagedType.U4)]
   130|                 int lnControlCode,
   131|                 [In, MarshalAs(UnmanagedType.BStr)]
   132|                 string bstrName,
   133|                 [In, MarshalAs(UnmanagedType.Struct)]
   134|                 object vProp);
   135|             void GetInfoEx(
   136|                 [In, MarshalAs(UnmanagedType.Struct)]
   137|                 object vProperties,
   138|                 [In, MarshalAs(UnmanagedType.U4)]
   139|                 int lnReserved);
   140|         }
   141|         [ComImport, Guid("27636b00-410f-11cf-b1ff-02608c9e7553"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
   142|         public interface IADsGroup
   143|         {
   144|             string Name
   145|             {
   146|                 [return: MarshalAs(UnmanagedType.BStr)]
   147|                 get;
   148|             }
   149|             string Class
   150|             {
   151|                 [return: MarshalAs(UnmanagedType.BStr)]
   152|                 get;
   153|             }
   154|             string GUID
   155|             {
   156|                 [return: MarshalAs(UnmanagedType.BStr)]
   157|                 get;
   158|             }
   159|             string ADsPath
   160|             {
   161|                 [return: MarshalAs(UnmanagedType.BStr)]
   162|                 get;
   163|             }
   164|             string Parent
   165|             {
   166|                 [return: MarshalAs(UnmanagedType.BStr)]
   167|                 get;
   168|             }
   169|             string Schema
   170|             {
   171|                 [return: MarshalAs(UnmanagedType.BStr)]
   172|                 get;
   173|             }
   174|             void GetInfo();
   175|             void SetInfo();
   176|             [return: MarshalAs(UnmanagedType.Struct)]
   177|             object Get(
   178|                 [In, MarshalAs(UnmanagedType.BStr)]
   179|                 string bstrName);
   180|             void Put(
   181|                 [In, MarshalAs(UnmanagedType.BStr)]
   182|                 string bstrName,
   183|                 [In, MarshalAs(UnmanagedType.Struct)]
   184|                 object vProp);
   185|             [return: MarshalAs(UnmanagedType.Struct)]
   186|             object GetEx(
   187|                 [In, MarshalAs(UnmanagedType.BStr)]
   188|                 string bstrName);
   189|             void PutEx(
   190|                 [In, MarshalAs(UnmanagedType.U4)]
   191|                 int lnControlCode,
   192|                 [In, MarshalAs(UnmanagedType.BStr)]
   193|                 string bstrName,
   194|                 [In, MarshalAs(UnmanagedType.Struct)]
   195|                 object vProp);
   196|             void GetInfoEx(
   197|                 [In, MarshalAs(UnmanagedType.Struct)]
   198|                 object vProperties,
   199|                 [In, MarshalAs(UnmanagedType.U4)]
   200|                 int lnReserved);
   201|             string Description
   202|             {
   203|                 [return: MarshalAs(UnmanagedType.BStr)]
   204|                 get;
   205|                 [param: MarshalAs(UnmanagedType.BStr)]
   206|                 set;
   207|             }
   208|             IADsMembers Members();
   209|             bool IsMember([In, MarshalAs(UnmanagedType.BStr)] string bstrMember);
   210|             void Add([In, MarshalAs(UnmanagedType.BStr)] string bstrNewItem);
   211|             void Remove([In, MarshalAs(UnmanagedType.BStr)] string bstrItemToBeRemoved);
   212|         }
   213|         [ComImport, Guid("451a0030-72ec-11cf-b03b-00aa006e0975"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
   214|         public interface IADsMembers
   215|         {
   216|             int Count
   217|             {
   218|                 [return: MarshalAs(UnmanagedType.U4)]
   219|                 get;
   220|             }
   221|             object _NewEnum
   222|             {
   223|                 [return: MarshalAs(UnmanagedType.Interface)]
   224|                 get;
   225|             }
   226|             object Filter
   227|             {
   228|                 [return: MarshalAs(UnmanagedType.Struct)]
   229|                 get;
   230|                 [param: MarshalAs(UnmanagedType.Struct)]
   231|                 set;
   232|             }
   233|         }
   234|         [ComImport, Guid("080d0d78-f421-11d0-a36e-00c04fb950dc")]
   235|         public class Pathname
   236|         {
   237|         }
   238|         [ComImport, Guid("d592aed4-f420-11d0-a36e-00c04fb950dc"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsDual)]
   239|         public interface IADsPathname
   240|         {
   241|             void Set(
   242|                 [In, MarshalAs(UnmanagedType.BStr)] string bstrADsPath,
   243|                 [In, MarshalAs(UnmanagedType.U4)]  int lnSetType
   244|                 );
   245|             void SetDisplayType(
   246|                 [In, MarshalAs(UnmanagedType.U4)] int lnDisplayType
   247|                 );
   248|             [return: MarshalAs(UnmanagedType.BStr)]
   249|             string Retrieve(
   250|                 [In, MarshalAs(UnmanagedType.U4)] int lnFormatType
   251|                 );
   252|             [return: MarshalAs(UnmanagedType.U4)]
   253|             int GetNumElements();
   254|             [return: MarshalAs(UnmanagedType.BStr)]
   255|             string
   256|             GetElement(
   257|                 [In, MarshalAs(UnmanagedType.U4)]  int lnElementIndex
   258|                 );
   259|             void AddLeafElement(
   260|                 [In, MarshalAs(UnmanagedType.BStr)] string bstrLeafElement
   261|                 );
   262|             void RemoveLeafElement();
   263|             [return: MarshalAs(UnmanagedType.Struct)]
   264|             object CopyPath();
   265|             [return: MarshalAs(UnmanagedType.BStr)]
   266|             string GetEscapedElement(
   267|                 [In, MarshalAs(UnmanagedType.U4)] int lnReserved,
   268|                 [In, MarshalAs(UnmanagedType.BStr)] string bstrInStr
   269|                 );
   270|             int EscapedMode
   271|             {
   272|                 [return: MarshalAs(UnmanagedType.U4)]
   273|                 get;
   274|                 [param: MarshalAs(UnmanagedType.U4)]
   275|                 set;
   276|             }
   277|         }
   278|         /*
   279|         typedef enum
   280|         {
   281|           DsRole_RoleStandaloneWorkstation,
   282|           DsRole_RoleMemberWorkstation,
   283|           DsRole_RoleStandaloneServer,
   284|           DsRole_RoleMemberServer,
   285|           DsRole_RoleBackupDomainController,
   286|           DsRole_RolePrimaryDomainController,
   287|           DsRole_WorkstationWithSharedAccountDomain,
   288|           DsRole_ServerWithSharedAccountDomain,
   289|           DsRole_MemberWorkstationWithSharedAccountDomain,
   290|           DsRole_MemberServerWithSharedAccountDomain
   291|         }DSROLE_MACHINE_ROLE;
   292|         */
   293|         public enum DSROLE_MACHINE_ROLE
   294|         {
   295|             DsRole_RoleStandaloneWorkstation,
   296|             DsRole_RoleMemberWorkstation,
   297|             DsRole_RoleStandaloneServer,
   298|             DsRole_RoleMemberServer,
   299|             DsRole_RoleBackupDomainController,
   300|             DsRole_RolePrimaryDomainController,
   301|             DsRole_WorkstationWithSharedAccountDomain,
   302|             DsRole_ServerWithSharedAccountDomain,
   303|             DsRole_MemberWorkstationWithSharedAccountDomain,
   304|             DsRole_MemberServerWithSharedAccountDomain
   305|         }
   306|         /*
   307|          typedef struct _DSROLE_PRIMARY_DOMAIN_INFO_BASIC {
   308|          DSROLE_MACHINE_ROLE MachineRole;
   309|          ULONG Flags;
   310|          LPWSTR DomainNameFlat;
   311|          LPWSTR DomainNameDns;
   312|          LPWSTR DomainForestName;
   313|          GUID DomainGuid;
   314|          } DSROLE_PRIMARY_DOMAIN_INFO_BASIC,  *PDSROLE_PRIMARY_DOMAIN_INFO_BASIC;
   315|          */
   316|         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
   317|         public sealed class DSROLE_PRIMARY_DOMAIN_INFO_BASIC
   318|         {
   319|             public DSROLE_MACHINE_ROLE MachineRole;
   320|             public uint Flags;
   321|             [MarshalAs(UnmanagedType.LPWStr)]
   322|             public string DomainNameFlat;
   323|             [MarshalAs(UnmanagedType.LPWStr)]
   324|             public string DomainNameDns;
   325|             [MarshalAs(UnmanagedType.LPWStr)]
   326|             public string DomainForestName;
   327|             public Guid DomainGuid;
   328|         }
   329|         /*typedef struct _DOMAIN_CONTROLLER_INFO {
   330|             LPTSTR DomainControllerName;
   331|             LPTSTR DomainControllerAddress;
   332|             ULONG DomainControllerAddressType;
   333|             GUID DomainGuid;
   334|             LPTSTR DomainName;
   335|             LPTSTR DnsForestName;
   336|             ULONG Flags;
   337|             LPTSTR DcSiteName;
   338|             LPTSTR ClientSiteName;
   339|         } DOMAIN_CONTROLLER_INFO, *PDOMAIN_CONTROLLER_INFO; */
   340|         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
   341|         public sealed class DomainControllerInfo
   342|         {
   343|             public string DomainControllerName;
   344|             public string DomainControllerAddress;
   345|             public int DomainControllerAddressType;
   346|             public Guid DomainGuid;
   347|             public string DomainName;
   348|             public string DnsForestName;
   349|             public int Flags;
   350|             public string DcSiteName;
   351|             public string ClientSiteName;
   352|         }
   353|         /* typedef struct _WKSTA_INFO_100 {
   354|                 DWORD wki100_platform_id;
   355|                 LMSTR wki100_computername;
   356|                 LMSTR wki100_langroup;
   357|                 DWORD wki100_ver_major;
   358|                 DWORD wki100_ver_minor;
   359|         } WKSTA_INFO_100, *PWKSTA_INFO_100; */
   360|         [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
   361|         public sealed class WKSTA_INFO_100
   362|         {
   363|             public int wki100_platform_id;
   364|             public string wki100_computername;
   365|             public string wki100_langroup;
   366|             public int wki100_ver_major;
   367|             public int wki100_ver_minor;
   368|         };
   369|         [StructLayout(LayoutKind.Sequential)]
   370|         public struct POLICY_ACCOUNT_DOMAIN_INFO
   371|         {
   372|             public Interop.UNICODE_INTPTR_STRING DomainName;
   373|             public IntPtr DomainSid;
   374|         }
   375|     }
   376| }


# ====================================================================
# FILE: src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/ConcurrencyLimiter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-373 ---
     1| using System.Collections.Generic;
     2| using System.Diagnostics;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Threading.Tasks;
     5| namespace System.Threading.RateLimiting
     6| {
     7|     public sealed class ConcurrencyLimiter : RateLimiter
     8|     {
     9|         private int _permitCount;
    10|         private int _queueCount;
    11|         private long? _idleSince = Stopwatch.GetTimestamp();
    12|         private bool _disposed;
    13|         private long _failedLeasesCount;
    14|         private long _successfulLeasesCount;
    15|         private readonly ConcurrencyLimiterOptions _options;
    16|         private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
    17|         private static readonly ConcurrencyLease SuccessfulLease = new ConcurrencyLease(true, null, 0);
    18|         private static readonly ConcurrencyLease FailedLease = new ConcurrencyLease(false, null, 0);
    19|         private static readonly ConcurrencyLease QueueLimitLease = new ConcurrencyLease(false, null, 0, "Queue limit reached");
    20|         private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
    21|         private object Lock => _queue;
    22|         public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
    23|         public ConcurrencyLimiter(ConcurrencyLimiterOptions options)
    24|         {
    25|             if (options is null)
    26|             {
    27|                 throw new ArgumentNullException(nameof(options));
    28|             }
    29|             if (options.PermitLimit <= 0)
    30|             {
    31|                 throw new ArgumentException($"{nameof(options.PermitLimit)} must be set to a value greater than 0.", nameof(options));
    32|             }
    33|             if (options.QueueLimit < 0)
    34|             {
    35|                 throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
    36|             }
    37|             _options = new ConcurrencyLimiterOptions
    38|             {
    39|                 PermitLimit = options.PermitLimit,
    40|                 QueueProcessingOrder = options.QueueProcessingOrder,
    41|                 QueueLimit = options.QueueLimit
    42|             };
    43|             _permitCount = _options.PermitLimit;
    44|         }
    45|         public override RateLimiterStatistics? GetStatistics()
    46|         {
    47|             ThrowIfDisposed();
    48|             return new RateLimiterStatistics()
    49|             {
    50|                 CurrentAvailablePermits = _permitCount,
    51|                 CurrentQueuedCount = _queueCount,
    52|                 TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
    53|                 TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
    54|             };
    55|         }
    56|         protected override RateLimitLease AttemptAcquireCore(int permitCount)
    57|         {
    58|             if (permitCount > _options.PermitLimit)
    59|             {
    60|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
    61|             }
    62|             ThrowIfDisposed();
    63|             if (permitCount == 0)
    64|             {
    65|                 if (_permitCount > 0)
    66|                 {
    67|                     Interlocked.Increment(ref _successfulLeasesCount);
    68|                     return SuccessfulLease;
    69|                 }
    70|                 Interlocked.Increment(ref _failedLeasesCount);
    71|                 return FailedLease;
    72|             }
    73|             if (_permitCount >= permitCount)
    74|             {
    75|                 lock (Lock)
    76|                 {
    77|                     if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
    78|                     {
    79|                         return lease;
    80|                     }
    81|                 }
    82|             }
    83|             Interlocked.Increment(ref _failedLeasesCount);
    84|             return FailedLease;
    85|         }
    86|         protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
    87|         {
    88|             if (permitCount > _options.PermitLimit)
    89|             {
    90|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
    91|             }
    92|             if (permitCount == 0 && _permitCount > 0 && !_disposed)
    93|             {
    94|                 Interlocked.Increment(ref _successfulLeasesCount);
    95|                 return new ValueTask<RateLimitLease>(SuccessfulLease);
    96|             }
    97|             using var disposer = default(RequestRegistration.Disposer);
    98|             lock (Lock)
    99|             {
   100|                 if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
   101|                 {
   102|                     return new ValueTask<RateLimitLease>(lease);
   103|                 }
   104|                 Debug.Assert(_options.QueueLimit >= _queueCount);
   105|                 if (_options.QueueLimit - _queueCount < permitCount)
   106|                 {
   107|                     if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
   108|                     {
   109|                         do
   110|                         {
   111|                             RequestRegistration oldestRequest = _queue.DequeueHead();
   112|                             _queueCount -= oldestRequest.Count;
   113|                             Debug.Assert(_queueCount >= 0);
   114|                             if (!oldestRequest.TrySetResult(FailedLease))
   115|                             {
   116|                                 if (!oldestRequest.QueueCountModified)
   117|                                 {
   118|                                     oldestRequest.QueueCountModified = true;
   119|                                 }
   120|                                 else
   121|                                 {
   122|                                     _queueCount += oldestRequest.Count;
   123|                                 }
   124|                             }
   125|                             else
   126|                             {
   127|                                 Interlocked.Increment(ref _failedLeasesCount);
   128|                             }
   129|                             disposer.Add(oldestRequest);
   130|                         }
   131|                         while (_options.QueueLimit - _queueCount < permitCount);
   132|                     }
   133|                     else
   134|                     {
   135|                         Interlocked.Increment(ref _failedLeasesCount);
   136|                         return new ValueTask<RateLimitLease>(QueueLimitLease);
   137|                     }
   138|                 }
   139|                 var request = new RequestRegistration(permitCount, this, cancellationToken);
   140|                 _queue.EnqueueTail(request);
   141|                 _queueCount += permitCount;
   142|                 Debug.Assert(_queueCount <= _options.QueueLimit);
   143|                 return new ValueTask<RateLimitLease>(request.Task);
   144|             }
   145|         }
   146|         private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
   147|         {
   148|             ThrowIfDisposed();
   149|             if (_permitCount >= permitCount && _permitCount != 0)
   150|             {
   151|                 if (permitCount == 0)
   152|                 {
   153|                     Interlocked.Increment(ref _successfulLeasesCount);
   154|                     lease = SuccessfulLease;
   155|                     return true;
   156|                 }
   157|                 if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
   158|                 {
   159|                     _idleSince = null;
   160|                     _permitCount -= permitCount;
   161|                     Debug.Assert(_permitCount >= 0);
   162|                     Interlocked.Increment(ref _successfulLeasesCount);
   163|                     lease = new ConcurrencyLease(true, this, permitCount);
   164|                     return true;
   165|                 }
   166|             }
   167|             lease = null;
   168|             return false;
   169|         }
   170| #if DEBUG
   171|         internal event Action? ReleasePreHook;
   172|         internal event Action? ReleasePostHook;
   173| #endif
   174|         private void Release(int releaseCount)
   175|         {
   176|             using var disposer = default(RequestRegistration.Disposer);
   177|             lock (Lock)
   178|             {
   179|                 if (_disposed)
   180|                 {
   181|                     return;
   182|                 }
   183|                 _permitCount += releaseCount;
   184|                 Debug.Assert(_permitCount <= _options.PermitLimit);
   185| #if DEBUG
   186|                 ReleasePreHook?.Invoke();
   187| #endif
   188|                 while (_queue.Count > 0)
   189|                 {
   190|                     RequestRegistration nextPendingRequest =
   191|                         _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   192|                         ? _queue.PeekHead()
   193|                         : _queue.PeekTail();
   194|                     if (nextPendingRequest.Task.IsCompleted)
   195|                     {
   196|                         nextPendingRequest =
   197|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   198|                             ? _queue.DequeueHead()
   199|                             : _queue.DequeueTail();
   200|                         disposer.Add(nextPendingRequest);
   201|                         continue;
   202|                     }
   203| #if DEBUG
   204|                     ReleasePostHook?.Invoke();
   205| #endif
   206|                     if (_permitCount >= nextPendingRequest.Count)
   207|                     {
   208|                         nextPendingRequest =
   209|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   210|                             ? _queue.DequeueHead()
   211|                             : _queue.DequeueTail();
   212|                         _permitCount -= nextPendingRequest.Count;
   213|                         _queueCount -= nextPendingRequest.Count;
   214|                         Debug.Assert(_permitCount >= 0);
   215|                         ConcurrencyLease lease = nextPendingRequest.Count == 0 ? SuccessfulLease : new ConcurrencyLease(true, this, nextPendingRequest.Count);
   216|                         if (!nextPendingRequest.TrySetResult(lease))
   217|                         {
   218|                             _permitCount += nextPendingRequest.Count;
   219|                             if (!nextPendingRequest.QueueCountModified)
   220|                             {
   221|                                 nextPendingRequest.QueueCountModified = true;
   222|                             }
   223|                             else
   224|                             {
   225|                                 _queueCount += nextPendingRequest.Count;
   226|                             }
   227|                         }
   228|                         else
   229|                         {
   230|                             Interlocked.Increment(ref _successfulLeasesCount);
   231|                         }
   232|                         disposer.Add(nextPendingRequest);
   233|                         Debug.Assert(_queueCount >= 0);
   234|                     }
   235|                     else
   236|                     {
   237|                         break;
   238|                     }
   239|                 }
   240|                 if (_permitCount == _options.PermitLimit)
   241|                 {
   242|                     Debug.Assert(_idleSince is null);
   243|                     _idleSince = Stopwatch.GetTimestamp();
   244|                 }
   245|             }
   246|         }
   247|         protected override void Dispose(bool disposing)
   248|         {
   249|             if (!disposing)
   250|             {
   251|                 return;
   252|             }
   253|             using var disposer = default(RequestRegistration.Disposer);
   254|             lock (Lock)
   255|             {
   256|                 if (_disposed)
   257|                 {
   258|                     return;
   259|                 }
   260|                 _disposed = true;
   261|                 while (_queue.Count > 0)
   262|                 {
   263|                     RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   264|                         ? _queue.DequeueHead()
   265|                         : _queue.DequeueTail();
   266|                     disposer.Add(next);
   267|                     next.TrySetResult(FailedLease);
   268|                 }
   269|             }
   270|         }
   271|         protected override ValueTask DisposeAsyncCore()
   272|         {
   273|             Dispose(true);
   274|             return default;
   275|         }
   276|         private void ThrowIfDisposed()
   277|         {
   278|             if (_disposed)
   279|             {
   280|                 throw new ObjectDisposedException(nameof(ConcurrencyLimiter));
   281|             }
   282|         }
   283|         private sealed class ConcurrencyLease : RateLimitLease
   284|         {
   285|             private static readonly string[] s_allMetadataNames = new[] { MetadataName.ReasonPhrase.Name };
   286|             private bool _disposed;
   287|             private readonly ConcurrencyLimiter? _limiter;
   288|             private readonly int _count;
   289|             private readonly string? _reason;
   290|             public ConcurrencyLease(bool isAcquired, ConcurrencyLimiter? limiter, int count, string? reason = null)
   291|             {
   292|                 IsAcquired = isAcquired;
   293|                 _limiter = limiter;
   294|                 _count = count;
   295|                 _reason = reason;
   296|                 Debug.Assert(count == 0 ? limiter is null : true);
   297|             }
   298|             public override bool IsAcquired { get; }
   299|             public override IEnumerable<string> MetadataNames => s_allMetadataNames;
   300|             public override bool TryGetMetadata(string metadataName, out object? metadata)
   301|             {
   302|                 if (_reason is not null && metadataName == MetadataName.ReasonPhrase.Name)
   303|                 {
   304|                     metadata = _reason;
   305|                     return true;
   306|                 }
   307|                 metadata = default;
   308|                 return false;
   309|             }
   310|             protected override void Dispose(bool disposing)
   311|             {
   312|                 if (_disposed)
   313|                 {
   314|                     return;
   315|                 }
   316|                 _disposed = true;
   317|                 _limiter?.Release(_count);
   318|             }
   319|         }
   320|         private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
   321|         {
   322|             private readonly CancellationToken _cancellationToken;
   323|             private CancellationTokenRegistration _cancellationTokenRegistration;
   324|             public bool QueueCountModified { get; set; }
   325|             private RequestRegistration? _next;
   326|             public RequestRegistration(int permitCount, ConcurrencyLimiter limiter, CancellationToken cancellationToken)
   327|                 : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
   328|             {
   329|                 Count = permitCount;
   330|                 _cancellationToken = cancellationToken;
   331|                 if (cancellationToken.CanBeCanceled)
   332| #if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
   333|                     _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
   334| #else
   335|                     _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
   336| #endif
   337|             }
   338|             public int Count { get; }
   339|             private static void Cancel(object? state)
   340|             {
   341|                 if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
   342|                 {
   343|                     var limiter = (ConcurrencyLimiter)registration.Task.AsyncState!;
   344|                     lock (limiter.Lock)
   345|                     {
   346|                         if (!registration.QueueCountModified)
   347|                         {
   348|                             limiter._queueCount -= registration.Count;
   349|                             registration.QueueCountModified = true;
   350|                         }
   351|                     }
   352|                 }
   353|             }
   354|             public struct Disposer : IDisposable
   355|             {
   356|                 private RequestRegistration? _next;
   357|                 public void Add(RequestRegistration request)
   358|                 {
   359|                     request._next = _next;
   360|                     _next = request;
   361|                 }
   362|                 public void Dispose()
   363|                 {
   364|                     for (var current = _next; current is not null; current = current._next)
   365|                     {
   366|                         current._cancellationTokenRegistration.Dispose();
   367|                     }
   368|                     _next = null;
   369|                 }
   370|             }
   371|         }
   372|     }
   373| }


# ====================================================================
# FILE: src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/FixedWindowRateLimiter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-390 ---
     1| // Licensed to the .NET Foundation under one or more agreements.
     2| using System.Collections.Generic;
     3| using System.Diagnostics;
     4| using System.Diagnostics.CodeAnalysis;
     5| using System.Threading.Tasks;
     6| namespace System.Threading.RateLimiting
     7| {
     8|     public sealed class FixedWindowRateLimiter : ReplenishingRateLimiter
     9|     {
    10|         private int _permitCount;
    11|         private int _queueCount;
    12|         private long _lastReplenishmentTick;
    13|         private long? _idleSince;
    14|         private bool _disposed;
    15|         private long _failedLeasesCount;
    16|         private long _successfulLeasesCount;
    17|         private readonly Timer? _renewTimer;
    18|         private readonly FixedWindowRateLimiterOptions _options;
    19|         private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
    20|         private object Lock => _queue;
    21|         private static readonly RateLimitLease SuccessfulLease = new FixedWindowLease(true, null);
    22|         private static readonly RateLimitLease FailedLease = new FixedWindowLease(false, null);
    23|         private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
    24|         public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
    25|         public override bool IsAutoReplenishing => _options.AutoReplenishment;
    26|         public override TimeSpan ReplenishmentPeriod => _options.Window;
    27|         public FixedWindowRateLimiter(FixedWindowRateLimiterOptions options)
    28|         {
    29|             if (options is null)
    30|             {
    31|                 throw new ArgumentNullException(nameof(options));
    32|             }
    33|             if (options.PermitLimit <= 0)
    34|             {
    35|                 throw new ArgumentException($"{nameof(options.PermitLimit)} must be set to a value greater than 0.", nameof(options));
    36|             }
    37|             if (options.QueueLimit < 0)
    38|             {
    39|                 throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
    40|             }
    41|             if (options.Window <= TimeSpan.Zero)
    42|             {
    43|                 throw new ArgumentException($"{nameof(options.Window)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
    44|             }
    45|             _options = new FixedWindowRateLimiterOptions
    46|             {
    47|                 PermitLimit = options.PermitLimit,
    48|                 QueueProcessingOrder = options.QueueProcessingOrder,
    49|                 QueueLimit = options.QueueLimit,
    50|                 Window = options.Window,
    51|                 AutoReplenishment = options.AutoReplenishment
    52|             };
    53|             _permitCount = options.PermitLimit;
    54|             _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
    55|             if (_options.AutoReplenishment)
    56|             {
    57|                 _renewTimer = new Timer(Replenish, this, _options.Window, _options.Window);
    58|             }
    59|         }
    60|         public override RateLimiterStatistics? GetStatistics()
    61|         {
    62|             ThrowIfDisposed();
    63|             return new RateLimiterStatistics()
    64|             {
    65|                 CurrentAvailablePermits = _permitCount,
    66|                 CurrentQueuedCount = _queueCount,
    67|                 TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
    68|                 TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
    69|             };
    70|         }
    71|         protected override RateLimitLease AttemptAcquireCore(int permitCount)
    72|         {
    73|             if (permitCount > _options.PermitLimit)
    74|             {
    75|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
    76|             }
    77|             if (permitCount == 0 && !_disposed)
    78|             {
    79|                 if (_permitCount > 0)
    80|                 {
    81|                     Interlocked.Increment(ref _successfulLeasesCount);
    82|                     return SuccessfulLease;
    83|                 }
    84|                 Interlocked.Increment(ref _failedLeasesCount);
    85|                 return CreateFailedWindowLease(permitCount);
    86|             }
    87|             lock (Lock)
    88|             {
    89|                 if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
    90|                 {
    91|                     return lease;
    92|                 }
    93|                 Interlocked.Increment(ref _failedLeasesCount);
    94|                 return CreateFailedWindowLease(permitCount);
    95|             }
    96|         }
    97|         protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
    98|         {
    99|             if (permitCount > _options.PermitLimit)
   100|             {
   101|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
   102|             }
   103|             ThrowIfDisposed();
   104|             if (permitCount == 0 && _permitCount > 0)
   105|             {
   106|                 Interlocked.Increment(ref _successfulLeasesCount);
   107|                 return new ValueTask<RateLimitLease>(SuccessfulLease);
   108|             }
   109|             using var disposer = default(RequestRegistration.Disposer);
   110|             lock (Lock)
   111|             {
   112|                 if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
   113|                 {
   114|                     return new ValueTask<RateLimitLease>(lease);
   115|                 }
   116|                 Debug.Assert(_options.QueueLimit >= _queueCount);
   117|                 if (_options.QueueLimit - _queueCount < permitCount)
   118|                 {
   119|                     if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
   120|                     {
   121|                         do
   122|                         {
   123|                             RequestRegistration oldestRequest = _queue.DequeueHead();
   124|                             _queueCount -= oldestRequest.Count;
   125|                             Debug.Assert(_queueCount >= 0);
   126|                             if (!oldestRequest.TrySetResult(FailedLease))
   127|                             {
   128|                                 if (!oldestRequest.QueueCountModified)
   129|                                 {
   130|                                     oldestRequest.QueueCountModified = true;
   131|                                 }
   132|                                 else
   133|                                 {
   134|                                     _queueCount += oldestRequest.Count;
   135|                                 }
   136|                             }
   137|                             else
   138|                             {
   139|                                 Interlocked.Increment(ref _failedLeasesCount);
   140|                             }
   141|                             disposer.Add(oldestRequest);
   142|                         }
   143|                         while (_options.QueueLimit - _queueCount < permitCount);
   144|                     }
   145|                     else
   146|                     {
   147|                         Interlocked.Increment(ref _failedLeasesCount);
   148|                         return new ValueTask<RateLimitLease>(CreateFailedWindowLease(permitCount));
   149|                     }
   150|                 }
   151|                 var registration = new RequestRegistration(permitCount, this, cancellationToken);
   152|                 _queue.EnqueueTail(registration);
   153|                 _queueCount += permitCount;
   154|                 Debug.Assert(_queueCount <= _options.QueueLimit);
   155|                 return new ValueTask<RateLimitLease>(registration.Task);
   156|             }
   157|         }
   158|         private RateLimitLease CreateFailedWindowLease(int permitCount)
   159|         {
   160|             int replenishAmount = permitCount - _permitCount + _queueCount;
   161|             int replenishWindow = Math.Max(replenishAmount / _options.PermitLimit, 1);
   162|             return new FixedWindowLease(false, TimeSpan.FromTicks(_options.Window.Ticks * replenishWindow));
   163|         }
   164|         private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
   165|         {
   166|             ThrowIfDisposed();
   167|             if (_permitCount >= permitCount && _permitCount != 0)
   168|             {
   169|                 if (permitCount == 0)
   170|                 {
   171|                     Interlocked.Increment(ref _successfulLeasesCount);
   172|                     lease = SuccessfulLease;
   173|                     return true;
   174|                 }
   175|                 if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
   176|                 {
   177|                     _idleSince = null;
   178|                     _permitCount -= permitCount;
   179|                     Debug.Assert(_permitCount >= 0);
   180|                     Interlocked.Increment(ref _successfulLeasesCount);
   181|                     lease = SuccessfulLease;
   182|                     return true;
   183|                 }
   184|             }
   185|             lease = null;
   186|             return false;
   187|         }
   188|         public override bool TryReplenish()
   189|         {
   190|             if (_options.AutoReplenishment)
   191|             {
   192|                 return false;
   193|             }
   194|             Replenish(this);
   195|             return true;
   196|         }
   197|         private static void Replenish(object? state)
   198|         {
   199|             FixedWindowRateLimiter limiter = (state as FixedWindowRateLimiter)!;
   200|             Debug.Assert(limiter is not null);
   201|             long nowTicks = Stopwatch.GetTimestamp();
   202|             limiter!.ReplenishInternal(nowTicks);
   203|         }
   204|         private void ReplenishInternal(long nowTicks)
   205|         {
   206|             using var disposer = default(RequestRegistration.Disposer);
   207|             lock (Lock)
   208|             {
   209|                 if (_disposed)
   210|                 {
   211|                     return;
   212|                 }
   213|                 if (((nowTicks - _lastReplenishmentTick) * TickFrequency) < _options.Window.Ticks && !_options.AutoReplenishment)
   214|                 {
   215|                     return;
   216|                 }
   217|                 _lastReplenishmentTick = nowTicks;
   218|                 int availablePermitCounters = _permitCount;
   219|                 if (availablePermitCounters >= _options.PermitLimit)
   220|                 {
   221|                     return;
   222|                 }
   223|                 _permitCount = _options.PermitLimit;
   224|                 while (_queue.Count > 0)
   225|                 {
   226|                     RequestRegistration nextPendingRequest =
   227|                           _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   228|                           ? _queue.PeekHead()
   229|                           : _queue.PeekTail();
   230|                     if (nextPendingRequest.Task.IsCompleted)
   231|                     {
   232|                         nextPendingRequest =
   233|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   234|                             ? _queue.DequeueHead()
   235|                             : _queue.DequeueTail();
   236|                         disposer.Add(nextPendingRequest);
   237|                     }
   238|                     else if (_permitCount >= nextPendingRequest.Count)
   239|                     {
   240|                         nextPendingRequest =
   241|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   242|                             ? _queue.DequeueHead()
   243|                             : _queue.DequeueTail();
   244|                         _queueCount -= nextPendingRequest.Count;
   245|                         _permitCount -= nextPendingRequest.Count;
   246|                         Debug.Assert(_permitCount >= 0);
   247|                         if (!nextPendingRequest.TrySetResult(SuccessfulLease))
   248|                         {
   249|                             _permitCount += nextPendingRequest.Count;
   250|                             if (!nextPendingRequest.QueueCountModified)
   251|                             {
   252|                                 nextPendingRequest.QueueCountModified = true;
   253|                             }
   254|                             else
   255|                             {
   256|                                 _queueCount += nextPendingRequest.Count;
   257|                             }
   258|                         }
   259|                         else
   260|                         {
   261|                             Interlocked.Increment(ref _successfulLeasesCount);
   262|                         }
   263|                         disposer.Add(nextPendingRequest);
   264|                         Debug.Assert(_queueCount >= 0);
   265|                     }
   266|                     else
   267|                     {
   268|                         break;
   269|                     }
   270|                 }
   271|                 if (_permitCount == _options.PermitLimit)
   272|                 {
   273|                     Debug.Assert(_idleSince is null);
   274|                     _idleSince = Stopwatch.GetTimestamp();
   275|                 }
   276|             }
   277|         }
   278|         protected override void Dispose(bool disposing)
   279|         {
   280|             if (!disposing)
   281|             {
   282|                 return;
   283|             }
   284|             using var disposer = default(RequestRegistration.Disposer);
   285|             lock (Lock)
   286|             {
   287|                 if (_disposed)
   288|                 {
   289|                     return;
   290|                 }
   291|                 _disposed = true;
   292|                 _renewTimer?.Dispose();
   293|                 while (_queue.Count > 0)
   294|                 {
   295|                     RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   296|                         ? _queue.DequeueHead()
   297|                         : _queue.DequeueTail();
   298|                     disposer.Add(next);
   299|                     next.TrySetResult(FailedLease);
   300|                 }
   301|             }
   302|         }
   303|         protected override ValueTask DisposeAsyncCore()
   304|         {
   305|             Dispose(true);
   306|             return default;
   307|         }
   308|         private void ThrowIfDisposed()
   309|         {
   310|             if (_disposed)
   311|             {
   312|                 throw new ObjectDisposedException(nameof(FixedWindowRateLimiter));
   313|             }
   314|         }
   315|         private sealed class FixedWindowLease : RateLimitLease
   316|         {
   317|             private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
   318|             private readonly TimeSpan? _retryAfter;
   319|             public FixedWindowLease(bool isAcquired, TimeSpan? retryAfter)
   320|             {
   321|                 IsAcquired = isAcquired;
   322|                 _retryAfter = retryAfter;
   323|             }
   324|             public override bool IsAcquired { get; }
   325|             public override IEnumerable<string> MetadataNames => s_allMetadataNames;
   326|             public override bool TryGetMetadata(string metadataName, out object? metadata)
   327|             {
   328|                 if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
   329|                 {
   330|                     metadata = _retryAfter.Value;
   331|                     return true;
   332|                 }
   333|                 metadata = default;
   334|                 return false;
   335|             }
   336|         }
   337|         private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
   338|         {
   339|             private readonly CancellationToken _cancellationToken;
   340|             private CancellationTokenRegistration _cancellationTokenRegistration;
   341|             public bool QueueCountModified { get; set; }
   342|             private RequestRegistration? _next;
   343|             public RequestRegistration(int permitCount, FixedWindowRateLimiter limiter, CancellationToken cancellationToken)
   344|                 : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
   345|             {
   346|                 Count = permitCount;
   347|                 _cancellationToken = cancellationToken;
   348|                 if (cancellationToken.CanBeCanceled)
   349| #if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
   350|                     _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
   351| #else
   352|                     _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
   353| #endif
   354|             }
   355|             public int Count { get; }
   356|             private static void Cancel(object? state)
   357|             {
   358|                 if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
   359|                 {
   360|                     var limiter = (FixedWindowRateLimiter)registration.Task.AsyncState!;
   361|                     lock (limiter.Lock)
   362|                     {
   363|                         if (!registration.QueueCountModified)
   364|                         {
   365|                             limiter._queueCount -= registration.Count;
   366|                             registration.QueueCountModified = true;
   367|                         }
   368|                     }
   369|                 }
   370|             }
   371|             public struct Disposer : IDisposable
   372|             {
   373|                 private RequestRegistration? _next;
   374|                 public void Add(RequestRegistration request)
   375|                 {
   376|                     request._next = _next;
   377|                     _next = request;
   378|                 }
   379|                 public void Dispose()
   380|                 {
   381|                     for (var current = _next; current is not null; current = current._next)
   382|                     {
   383|                         current._cancellationTokenRegistration.Dispose();
   384|                     }
   385|                     _next = null;
   386|                 }
   387|             }
   388|         }
   389|     }
   390| }


# ====================================================================
# FILE: src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/SlidingWindowRateLimiter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-397 ---
     1| // Licensed to the .NET Foundation under one or more agreements.
     2| using System.Collections.Generic;
     3| using System.Diagnostics;
     4| using System.Diagnostics.CodeAnalysis;
     5| using System.Threading.Tasks;
     6| namespace System.Threading.RateLimiting
     7| {
     8|     public sealed class SlidingWindowRateLimiter : ReplenishingRateLimiter
     9|     {
    10|         private int _permitCount;
    11|         private int _queueCount;
    12|         private int[] _requestsPerSegment;
    13|         private int _currentSegmentIndex;
    14|         private long _lastReplenishmentTick;
    15|         private long? _idleSince;
    16|         private bool _disposed;
    17|         private long _failedLeasesCount;
    18|         private long _successfulLeasesCount;
    19|         private readonly Timer? _renewTimer;
    20|         private readonly SlidingWindowRateLimiterOptions _options;
    21|         private readonly TimeSpan _replenishmentPeriod;
    22|         private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
    23|         private object Lock => _queue;
    24|         private static readonly RateLimitLease SuccessfulLease = new SlidingWindowLease(true, null);
    25|         private static readonly RateLimitLease FailedLease = new SlidingWindowLease(false, null);
    26|         private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
    27|         public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
    28|         public override bool IsAutoReplenishing => _options.AutoReplenishment;
    29|         public override TimeSpan ReplenishmentPeriod => _replenishmentPeriod;
    30|         public SlidingWindowRateLimiter(SlidingWindowRateLimiterOptions options)
    31|         {
    32|             if (options is null)
    33|             {
    34|                 throw new ArgumentNullException(nameof(options));
    35|             }
    36|             if (options.PermitLimit <= 0 || options.SegmentsPerWindow <= 0)
    37|             {
    38|                 throw new ArgumentException($"Both {nameof(options.PermitLimit)} and {nameof(options.SegmentsPerWindow)} must be set to values greater than 0.", nameof(options));
    39|             }
    40|             if (options.QueueLimit < 0)
    41|             {
    42|                 throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
    43|             }
    44|             if (options.Window <= TimeSpan.Zero)
    45|             {
    46|                 throw new ArgumentException($"{nameof(options.Window)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
    47|             }
    48|             _options = new SlidingWindowRateLimiterOptions
    49|             {
    50|                 PermitLimit = options.PermitLimit,
    51|                 QueueProcessingOrder = options.QueueProcessingOrder,
    52|                 QueueLimit = options.QueueLimit,
    53|                 Window = options.Window,
    54|                 SegmentsPerWindow = options.SegmentsPerWindow,
    55|                 AutoReplenishment = options.AutoReplenishment
    56|             };
    57|             _permitCount = options.PermitLimit;
    58|             _replenishmentPeriod = new TimeSpan(_options.Window.Ticks / _options.SegmentsPerWindow);
    59|             _requestsPerSegment = new int[options.SegmentsPerWindow];
    60|             _currentSegmentIndex = 0;
    61|             _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
    62|             if (_options.AutoReplenishment)
    63|             {
    64|                 _renewTimer = new Timer(Replenish, this, ReplenishmentPeriod, ReplenishmentPeriod);
    65|             }
    66|         }
    67|         public override RateLimiterStatistics? GetStatistics()
    68|         {
    69|             ThrowIfDisposed();
    70|             return new RateLimiterStatistics()
    71|             {
    72|                 CurrentAvailablePermits = _permitCount,
    73|                 CurrentQueuedCount = _queueCount,
    74|                 TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
    75|                 TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
    76|             };
    77|         }
    78|         protected override RateLimitLease AttemptAcquireCore(int permitCount)
    79|         {
    80|             if (permitCount > _options.PermitLimit)
    81|             {
    82|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
    83|             }
    84|             if (permitCount == 0 && !_disposed)
    85|             {
    86|                 if (_permitCount > 0)
    87|                 {
    88|                     Interlocked.Increment(ref _successfulLeasesCount);
    89|                     return SuccessfulLease;
    90|                 }
    91|                 Interlocked.Increment(ref _failedLeasesCount);
    92|                 return FailedLease;
    93|             }
    94|             lock (Lock)
    95|             {
    96|                 if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
    97|                 {
    98|                     return lease;
    99|                 }
   100|                 Interlocked.Increment(ref _failedLeasesCount);
   101|                 return FailedLease;
   102|             }
   103|         }
   104|         protected override ValueTask<RateLimitLease> AcquireAsyncCore(int permitCount, CancellationToken cancellationToken = default)
   105|         {
   106|             if (permitCount > _options.PermitLimit)
   107|             {
   108|                 throw new ArgumentOutOfRangeException(nameof(permitCount), permitCount, SR.Format(SR.PermitLimitExceeded, permitCount, _options.PermitLimit));
   109|             }
   110|             ThrowIfDisposed();
   111|             if (permitCount == 0 && _permitCount > 0)
   112|             {
   113|                 Interlocked.Increment(ref _successfulLeasesCount);
   114|                 return new ValueTask<RateLimitLease>(SuccessfulLease);
   115|             }
   116|             using var disposer = default(RequestRegistration.Disposer);
   117|             lock (Lock)
   118|             {
   119|                 if (TryLeaseUnsynchronized(permitCount, out RateLimitLease? lease))
   120|                 {
   121|                     return new ValueTask<RateLimitLease>(lease);
   122|                 }
   123|                 Debug.Assert(_options.QueueLimit >= _queueCount);
   124|                 if (_options.QueueLimit - _queueCount < permitCount)
   125|                 {
   126|                     if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && permitCount <= _options.QueueLimit)
   127|                     {
   128|                         do
   129|                         {
   130|                             RequestRegistration oldestRequest = _queue.DequeueHead();
   131|                             _queueCount -= oldestRequest.Count;
   132|                             Debug.Assert(_queueCount >= 0);
   133|                             if (!oldestRequest.TrySetResult(FailedLease))
   134|                             {
   135|                                 if (!oldestRequest.QueueCountModified)
   136|                                 {
   137|                                     oldestRequest.QueueCountModified = true;
   138|                                 }
   139|                                 else
   140|                                 {
   141|                                     _queueCount += oldestRequest.Count;
   142|                                 }
   143|                             }
   144|                             else
   145|                             {
   146|                                 Interlocked.Increment(ref _failedLeasesCount);
   147|                             }
   148|                             disposer.Add(oldestRequest);
   149|                         }
   150|                         while (_options.QueueLimit - _queueCount < permitCount);
   151|                     }
   152|                     else
   153|                     {
   154|                         Interlocked.Increment(ref _failedLeasesCount);
   155|                         return new ValueTask<RateLimitLease>(FailedLease);
   156|                     }
   157|                 }
   158|                 var registration = new RequestRegistration(permitCount, this, cancellationToken);
   159|                 _queue.EnqueueTail(registration);
   160|                 _queueCount += permitCount;
   161|                 Debug.Assert(_queueCount <= _options.QueueLimit);
   162|                 return new ValueTask<RateLimitLease>(registration.Task);
   163|             }
   164|         }
   165|         private bool TryLeaseUnsynchronized(int permitCount, [NotNullWhen(true)] out RateLimitLease? lease)
   166|         {
   167|             ThrowIfDisposed();
   168|             if (_permitCount >= permitCount && _permitCount != 0)
   169|             {
   170|                 if (permitCount == 0)
   171|                 {
   172|                     Interlocked.Increment(ref _successfulLeasesCount);
   173|                     lease = SuccessfulLease;
   174|                     return true;
   175|                 }
   176|                 if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
   177|                 {
   178|                     _idleSince = null;
   179|                     _requestsPerSegment[_currentSegmentIndex] += permitCount;
   180|                     _permitCount -= permitCount;
   181|                     Debug.Assert(_permitCount >= 0);
   182|                     Interlocked.Increment(ref _successfulLeasesCount);
   183|                     lease = SuccessfulLease;
   184|                     return true;
   185|                 }
   186|             }
   187|             lease = null;
   188|             return false;
   189|         }
   190|         public override bool TryReplenish()
   191|         {
   192|             if (_options.AutoReplenishment)
   193|             {
   194|                 return false;
   195|             }
   196|             Replenish(this);
   197|             return true;
   198|         }
   199|         private static void Replenish(object? state)
   200|         {
   201|             SlidingWindowRateLimiter limiter = (state as SlidingWindowRateLimiter)!;
   202|             Debug.Assert(limiter is not null);
   203|             long nowTicks = Stopwatch.GetTimestamp();
   204|             limiter!.ReplenishInternal(nowTicks);
   205|         }
   206|         private void ReplenishInternal(long nowTicks)
   207|         {
   208|             using var disposer = default(RequestRegistration.Disposer);
   209|             lock (Lock)
   210|             {
   211|                 if (_disposed)
   212|                 {
   213|                     return;
   214|                 }
   215|                 if (((nowTicks - _lastReplenishmentTick) * TickFrequency) < ReplenishmentPeriod.Ticks && !_options.AutoReplenishment)
   216|                 {
   217|                     return;
   218|                 }
   219|                 _lastReplenishmentTick = nowTicks;
   220|                 _currentSegmentIndex = (_currentSegmentIndex + 1) % _options.SegmentsPerWindow;
   221|                 int oldSegmentPermitCount = _requestsPerSegment[_currentSegmentIndex];
   222|                 _requestsPerSegment[_currentSegmentIndex] = 0;
   223|                 if (oldSegmentPermitCount == 0)
   224|                 {
   225|                     return;
   226|                 }
   227|                 _permitCount += oldSegmentPermitCount;
   228|                 Debug.Assert(_permitCount <= _options.PermitLimit);
   229|                 while (_queue.Count > 0)
   230|                 {
   231|                     RequestRegistration nextPendingRequest =
   232|                           _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   233|                           ? _queue.PeekHead()
   234|                           : _queue.PeekTail();
   235|                     if (nextPendingRequest.Task.IsCompleted)
   236|                     {
   237|                         nextPendingRequest =
   238|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   239|                             ? _queue.DequeueHead()
   240|                             : _queue.DequeueTail();
   241|                         disposer.Add(nextPendingRequest);
   242|                     }
   243|                     else if (_permitCount >= nextPendingRequest.Count)
   244|                     {
   245|                         nextPendingRequest =
   246|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   247|                             ? _queue.DequeueHead()
   248|                             : _queue.DequeueTail();
   249|                         _queueCount -= nextPendingRequest.Count;
   250|                         _permitCount -= nextPendingRequest.Count;
   251|                         _requestsPerSegment[_currentSegmentIndex] += nextPendingRequest.Count;
   252|                         Debug.Assert(_permitCount >= 0);
   253|                         if (!nextPendingRequest.TrySetResult(SuccessfulLease))
   254|                         {
   255|                             _permitCount += nextPendingRequest.Count;
   256|                             _requestsPerSegment[_currentSegmentIndex] -= nextPendingRequest.Count;
   257|                             if (!nextPendingRequest.QueueCountModified)
   258|                             {
   259|                                 nextPendingRequest.QueueCountModified = true;
   260|                             }
   261|                             else
   262|                             {
   263|                                 _queueCount += nextPendingRequest.Count;
   264|                             }
   265|                         }
   266|                         else
   267|                         {
   268|                             Interlocked.Increment(ref _successfulLeasesCount);
   269|                         }
   270|                         disposer.Add(nextPendingRequest);
   271|                         Debug.Assert(_queueCount >= 0);
   272|                     }
   273|                     else
   274|                     {
   275|                         break;
   276|                     }
   277|                 }
   278|                 if (_permitCount == _options.PermitLimit)
   279|                 {
   280|                     Debug.Assert(_idleSince is null);
   281|                     _idleSince = Stopwatch.GetTimestamp();
   282|                 }
   283|             }
   284|         }
   285|         protected override void Dispose(bool disposing)
   286|         {
   287|             if (!disposing)
   288|             {
   289|                 return;
   290|             }
   291|             using var disposer = default(RequestRegistration.Disposer);
   292|             lock (Lock)
   293|             {
   294|                 if (_disposed)
   295|                 {
   296|                     return;
   297|                 }
   298|                 _disposed = true;
   299|                 _renewTimer?.Dispose();
   300|                 while (_queue.Count > 0)
   301|                 {
   302|                     RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   303|                         ? _queue.DequeueHead()
   304|                         : _queue.DequeueTail();
   305|                     disposer.Add(next);
   306|                     next.TrySetResult(FailedLease);
   307|                 }
   308|             }
   309|         }
   310|         protected override ValueTask DisposeAsyncCore()
   311|         {
   312|             Dispose(true);
   313|             return default;
   314|         }
   315|         private void ThrowIfDisposed()
   316|         {
   317|             if (_disposed)
   318|             {
   319|                 throw new ObjectDisposedException(nameof(SlidingWindowRateLimiter));
   320|             }
   321|         }
   322|         private sealed class SlidingWindowLease : RateLimitLease
   323|         {
   324|             private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
   325|             private readonly TimeSpan? _retryAfter;
   326|             public SlidingWindowLease(bool isAcquired, TimeSpan? retryAfter)
   327|             {
   328|                 IsAcquired = isAcquired;
   329|                 _retryAfter = retryAfter;
   330|             }
   331|             public override bool IsAcquired { get; }
   332|             public override IEnumerable<string> MetadataNames => s_allMetadataNames;
   333|             public override bool TryGetMetadata(string metadataName, out object? metadata)
   334|             {
   335|                 if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
   336|                 {
   337|                     metadata = _retryAfter.Value;
   338|                     return true;
   339|                 }
   340|                 metadata = default;
   341|                 return false;
   342|             }
   343|         }
   344|         private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
   345|         {
   346|             private readonly CancellationToken _cancellationToken;
   347|             private CancellationTokenRegistration _cancellationTokenRegistration;
   348|             public bool QueueCountModified { get; set; }
   349|             private RequestRegistration? _next;
   350|             public RequestRegistration(int permitCount, SlidingWindowRateLimiter limiter, CancellationToken cancellationToken)
   351|                 : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
   352|             {
   353|                 Count = permitCount;
   354|                 _cancellationToken = cancellationToken;
   355|                 if (cancellationToken.CanBeCanceled)
   356| #if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
   357|                     _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
   358| #else
   359|                     _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
   360| #endif
   361|             }
   362|             public int Count { get; }
   363|             private static void Cancel(object? state)
   364|             {
   365|                 if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
   366|                 {
   367|                     var limiter = (SlidingWindowRateLimiter)registration.Task.AsyncState!;
   368|                     lock (limiter.Lock)
   369|                     {
   370|                         if (!registration.QueueCountModified)
   371|                         {
   372|                             limiter._queueCount -= registration.Count;
   373|                             registration.QueueCountModified = true;
   374|                         }
   375|                     }
   376|                 }
   377|             }
   378|             public struct Disposer : IDisposable
   379|             {
   380|                 private RequestRegistration? _next;
   381|                 public void Add(RequestRegistration request)
   382|                 {
   383|                     request._next = _next;
   384|                     _next = request;
   385|                 }
   386|                 public void Dispose()
   387|                 {
   388|                     for (var current = _next; current is not null; current = current._next)
   389|                     {
   390|                         current._cancellationTokenRegistration.Dispose();
   391|                     }
   392|                     _next = null;
   393|                 }
   394|             }
   395|         }
   396|     }
   397| }


# ====================================================================
# FILE: src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-399 ---
     1| using System.Collections.Generic;
     2| using System.Diagnostics;
     3| using System.Diagnostics.CodeAnalysis;
     4| using System.Threading.Tasks;
     5| namespace System.Threading.RateLimiting
     6| {
     7|     public sealed class TokenBucketRateLimiter : ReplenishingRateLimiter
     8|     {
     9|         private double _tokenCount;
    10|         private int _queueCount;
    11|         private long _lastReplenishmentTick;
    12|         private long? _idleSince;
    13|         private bool _disposed;
    14|         private long _failedLeasesCount;
    15|         private long _successfulLeasesCount;
    16|         private readonly double _fillRate;
    17|         private readonly Timer? _renewTimer;
    18|         private readonly TokenBucketRateLimiterOptions _options;
    19|         private readonly Deque<RequestRegistration> _queue = new Deque<RequestRegistration>();
    20|         private object Lock => _queue;
    21|         private static readonly RateLimitLease SuccessfulLease = new TokenBucketLease(true, null);
    22|         private static readonly RateLimitLease FailedLease = new TokenBucketLease(false, null);
    23|         private static readonly double TickFrequency = (double)TimeSpan.TicksPerSecond / Stopwatch.Frequency;
    24|         public override TimeSpan? IdleDuration => _idleSince is null ? null : new TimeSpan((long)((Stopwatch.GetTimestamp() - _idleSince) * TickFrequency));
    25|         public override bool IsAutoReplenishing => _options.AutoReplenishment;
    26|         public override TimeSpan ReplenishmentPeriod => _options.ReplenishmentPeriod;
    27|         public TokenBucketRateLimiter(TokenBucketRateLimiterOptions options)
    28|         {
    29|             if (options is null)
    30|             {
    31|                 throw new ArgumentNullException(nameof(options));
    32|             }
    33|             if (options.TokenLimit <= 0 || options.TokensPerPeriod <= 0)
    34|             {
    35|                 throw new ArgumentException($"Both {nameof(options.TokenLimit)} and {nameof(options.TokensPerPeriod)} must be set to values greater than 0.", nameof(options));
    36|             }
    37|             if (options.QueueLimit < 0)
    38|             {
    39|                 throw new ArgumentException($"{nameof(options.QueueLimit)} must be set to a value greater than or equal to 0.", nameof(options));
    40|             }
    41|             if (options.ReplenishmentPeriod <= TimeSpan.Zero)
    42|             {
    43|                 throw new ArgumentException($"{nameof(options.ReplenishmentPeriod)} must be set to a value greater than TimeSpan.Zero.", nameof(options));
    44|             }
    45|             _options = new TokenBucketRateLimiterOptions
    46|             {
    47|                 TokenLimit = options.TokenLimit,
    48|                 QueueProcessingOrder = options.QueueProcessingOrder,
    49|                 QueueLimit = options.QueueLimit,
    50|                 ReplenishmentPeriod = options.ReplenishmentPeriod,
    51|                 TokensPerPeriod = options.TokensPerPeriod,
    52|                 AutoReplenishment = options.AutoReplenishment
    53|             };
    54|             _tokenCount = options.TokenLimit;
    55|             _fillRate = (double)options.TokensPerPeriod / options.ReplenishmentPeriod.Ticks;
    56|             _idleSince = _lastReplenishmentTick = Stopwatch.GetTimestamp();
    57|             if (_options.AutoReplenishment)
    58|             {
    59|                 _renewTimer = new Timer(Replenish, this, _options.ReplenishmentPeriod, _options.ReplenishmentPeriod);
    60|             }
    61|         }
    62|         public override RateLimiterStatistics? GetStatistics()
    63|         {
    64|             ThrowIfDisposed();
    65|             return new RateLimiterStatistics()
    66|             {
    67|                 CurrentAvailablePermits = (long)_tokenCount,
    68|                 CurrentQueuedCount = _queueCount,
    69|                 TotalFailedLeases = Interlocked.Read(ref _failedLeasesCount),
    70|                 TotalSuccessfulLeases = Interlocked.Read(ref _successfulLeasesCount),
    71|             };
    72|         }
    73|         protected override RateLimitLease AttemptAcquireCore(int tokenCount)
    74|         {
    75|             if (tokenCount > _options.TokenLimit)
    76|             {
    77|                 throw new ArgumentOutOfRangeException(nameof(tokenCount), tokenCount, SR.Format(SR.TokenLimitExceeded, tokenCount, _options.TokenLimit));
    78|             }
    79|             if (tokenCount == 0 && !_disposed)
    80|             {
    81|                 if (_tokenCount > 0)
    82|                 {
    83|                     Interlocked.Increment(ref _successfulLeasesCount);
    84|                     return SuccessfulLease;
    85|                 }
    86|                 Interlocked.Increment(ref _failedLeasesCount);
    87|                 return CreateFailedTokenLease(tokenCount);
    88|             }
    89|             lock (Lock)
    90|             {
    91|                 if (TryLeaseUnsynchronized(tokenCount, out RateLimitLease? lease))
    92|                 {
    93|                     return lease;
    94|                 }
    95|                 Interlocked.Increment(ref _failedLeasesCount);
    96|                 return CreateFailedTokenLease(tokenCount);
    97|             }
    98|         }
    99|         protected override ValueTask<RateLimitLease> AcquireAsyncCore(int tokenCount, CancellationToken cancellationToken = default)
   100|         {
   101|             if (tokenCount > _options.TokenLimit)
   102|             {
   103|                 throw new ArgumentOutOfRangeException(nameof(tokenCount), tokenCount, SR.Format(SR.TokenLimitExceeded, tokenCount, _options.TokenLimit));
   104|             }
   105|             ThrowIfDisposed();
   106|             if (tokenCount == 0 && _tokenCount > 0)
   107|             {
   108|                 Interlocked.Increment(ref _successfulLeasesCount);
   109|                 return new ValueTask<RateLimitLease>(SuccessfulLease);
   110|             }
   111|             using var disposer = default(RequestRegistration.Disposer);
   112|             lock (Lock)
   113|             {
   114|                 if (TryLeaseUnsynchronized(tokenCount, out RateLimitLease? lease))
   115|                 {
   116|                     return new ValueTask<RateLimitLease>(lease);
   117|                 }
   118|                 Debug.Assert(_options.QueueLimit >= _queueCount);
   119|                 if (_options.QueueLimit - _queueCount < tokenCount)
   120|                 {
   121|                     if (_options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst && tokenCount <= _options.QueueLimit)
   122|                     {
   123|                         do
   124|                         {
   125|                             RequestRegistration oldestRequest = _queue.DequeueHead();
   126|                             _queueCount -= oldestRequest.Count;
   127|                             Debug.Assert(_queueCount >= 0);
   128|                             if (!oldestRequest.TrySetResult(FailedLease))
   129|                             {
   130|                                 if (!oldestRequest.QueueCountModified)
   131|                                 {
   132|                                     oldestRequest.QueueCountModified = true;
   133|                                 }
   134|                                 else
   135|                                 {
   136|                                     _queueCount += oldestRequest.Count;
   137|                                 }
   138|                             }
   139|                             else
   140|                             {
   141|                                 Interlocked.Increment(ref _failedLeasesCount);
   142|                             }
   143|                             disposer.Add(oldestRequest);
   144|                         }
   145|                         while (_options.QueueLimit - _queueCount < tokenCount);
   146|                     }
   147|                     else
   148|                     {
   149|                         Interlocked.Increment(ref _failedLeasesCount);
   150|                         return new ValueTask<RateLimitLease>(CreateFailedTokenLease(tokenCount));
   151|                     }
   152|                 }
   153|                 var registration = new RequestRegistration(tokenCount, this, cancellationToken);
   154|                 _queue.EnqueueTail(registration);
   155|                 _queueCount += tokenCount;
   156|                 Debug.Assert(_queueCount <= _options.QueueLimit);
   157|                 return new ValueTask<RateLimitLease>(registration.Task);
   158|             }
   159|         }
   160|         private RateLimitLease CreateFailedTokenLease(int tokenCount)
   161|         {
   162|             int replenishAmount = tokenCount - (int)_tokenCount + _queueCount;
   163|             Debug.Assert(_options.TokensPerPeriod > 0);
   164|             int replenishPeriods = Math.Max(replenishAmount / _options.TokensPerPeriod, 1);
   165|             return new TokenBucketLease(false, TimeSpan.FromTicks(_options.ReplenishmentPeriod.Ticks * replenishPeriods));
   166|         }
   167|         private bool TryLeaseUnsynchronized(int tokenCount, [NotNullWhen(true)] out RateLimitLease? lease)
   168|         {
   169|             ThrowIfDisposed();
   170|             if (_tokenCount >= tokenCount && _tokenCount != 0)
   171|             {
   172|                 if (tokenCount == 0)
   173|                 {
   174|                     Interlocked.Increment(ref _successfulLeasesCount);
   175|                     lease = SuccessfulLease;
   176|                     return true;
   177|                 }
   178|                 if (_queueCount == 0 || (_queueCount > 0 && _options.QueueProcessingOrder == QueueProcessingOrder.NewestFirst))
   179|                 {
   180|                     _idleSince = null;
   181|                     _tokenCount -= tokenCount;
   182|                     Debug.Assert(_tokenCount >= 0);
   183|                     Interlocked.Increment(ref _successfulLeasesCount);
   184|                     lease = SuccessfulLease;
   185|                     return true;
   186|                 }
   187|             }
   188|             lease = null;
   189|             return false;
   190|         }
   191|         public override bool TryReplenish()
   192|         {
   193|             if (_options.AutoReplenishment)
   194|             {
   195|                 return false;
   196|             }
   197|             Replenish(this);
   198|             return true;
   199|         }
   200|         private static void Replenish(object? state)
   201|         {
   202|             TokenBucketRateLimiter limiter = (state as TokenBucketRateLimiter)!;
   203|             Debug.Assert(limiter is not null);
   204|             long nowTicks = Stopwatch.GetTimestamp();
   205|             limiter!.ReplenishInternal(nowTicks);
   206|         }
   207|         private void ReplenishInternal(long nowTicks)
   208|         {
   209|             using var disposer = default(RequestRegistration.Disposer);
   210|             lock (Lock)
   211|             {
   212|                 if (_disposed)
   213|                 {
   214|                     return;
   215|                 }
   216|                 if (_tokenCount == _options.TokenLimit)
   217|                 {
   218|                     return;
   219|                 }
   220|                 double add;
   221|                 if (_options.AutoReplenishment)
   222|                 {
   223|                     add = _options.TokensPerPeriod;
   224|                 }
   225|                 else
   226|                 {
   227|                     add = _fillRate * (nowTicks - _lastReplenishmentTick) * TickFrequency;
   228|                 }
   229|                 _tokenCount = Math.Min(_options.TokenLimit, _tokenCount + add);
   230|                 _lastReplenishmentTick = nowTicks;
   231|                 Deque<RequestRegistration> queue = _queue;
   232|                 Debug.Assert(_tokenCount <= _options.TokenLimit);
   233|                 while (queue.Count > 0)
   234|                 {
   235|                     RequestRegistration nextPendingRequest =
   236|                           _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   237|                           ? queue.PeekHead()
   238|                           : queue.PeekTail();
   239|                     if (nextPendingRequest.Task.IsCompleted)
   240|                     {
   241|                         nextPendingRequest =
   242|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   243|                             ? queue.DequeueHead()
   244|                             : queue.DequeueTail();
   245|                         disposer.Add(nextPendingRequest);
   246|                     }
   247|                     else if (_tokenCount >= nextPendingRequest.Count)
   248|                     {
   249|                         nextPendingRequest =
   250|                             _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   251|                             ? queue.DequeueHead()
   252|                             : queue.DequeueTail();
   253|                         _queueCount -= nextPendingRequest.Count;
   254|                         _tokenCount -= nextPendingRequest.Count;
   255|                         Debug.Assert(_tokenCount >= 0);
   256|                         if (!nextPendingRequest.TrySetResult(SuccessfulLease))
   257|                         {
   258|                             _tokenCount += nextPendingRequest.Count;
   259|                             if (!nextPendingRequest.QueueCountModified)
   260|                             {
   261|                                 nextPendingRequest.QueueCountModified = true;
   262|                             }
   263|                             else
   264|                             {
   265|                                 _queueCount += nextPendingRequest.Count;
   266|                             }
   267|                         }
   268|                         else
   269|                         {
   270|                             Interlocked.Increment(ref _successfulLeasesCount);
   271|                         }
   272|                         disposer.Add(nextPendingRequest);
   273|                         Debug.Assert(_queueCount >= 0);
   274|                     }
   275|                     else
   276|                     {
   277|                         break;
   278|                     }
   279|                 }
   280|                 if (_tokenCount == _options.TokenLimit)
   281|                 {
   282|                     Debug.Assert(_idleSince is null);
   283|                     _idleSince = Stopwatch.GetTimestamp();
   284|                 }
   285|             }
   286|         }
   287|         protected override void Dispose(bool disposing)
   288|         {
   289|             if (!disposing)
   290|             {
   291|                 return;
   292|             }
   293|             using var disposer = default(RequestRegistration.Disposer);
   294|             lock (Lock)
   295|             {
   296|                 if (_disposed)
   297|                 {
   298|                     return;
   299|                 }
   300|                 _disposed = true;
   301|                 _renewTimer?.Dispose();
   302|                 while (_queue.Count > 0)
   303|                 {
   304|                     RequestRegistration next = _options.QueueProcessingOrder == QueueProcessingOrder.OldestFirst
   305|                         ? _queue.DequeueHead()
   306|                         : _queue.DequeueTail();
   307|                     disposer.Add(next);
   308|                     next.TrySetResult(FailedLease);
   309|                 }
   310|             }
   311|         }
   312|         protected override ValueTask DisposeAsyncCore()
   313|         {
   314|             Dispose(true);
   315|             return default;
   316|         }
   317|         private void ThrowIfDisposed()
   318|         {
   319|             if (_disposed)
   320|             {
   321|                 throw new ObjectDisposedException(nameof(TokenBucketRateLimiter));
   322|             }
   323|         }
   324|         private sealed class TokenBucketLease : RateLimitLease
   325|         {
   326|             private static readonly string[] s_allMetadataNames = new[] { MetadataName.RetryAfter.Name };
   327|             private readonly TimeSpan? _retryAfter;
   328|             public TokenBucketLease(bool isAcquired, TimeSpan? retryAfter)
   329|             {
   330|                 IsAcquired = isAcquired;
   331|                 _retryAfter = retryAfter;
   332|             }
   333|             public override bool IsAcquired { get; }
   334|             public override IEnumerable<string> MetadataNames => s_allMetadataNames;
   335|             public override bool TryGetMetadata(string metadataName, out object? metadata)
   336|             {
   337|                 if (metadataName == MetadataName.RetryAfter.Name && _retryAfter.HasValue)
   338|                 {
   339|                     metadata = _retryAfter.Value;
   340|                     return true;
   341|                 }
   342|                 metadata = default;
   343|                 return false;
   344|             }
   345|         }
   346|         private sealed class RequestRegistration : TaskCompletionSource<RateLimitLease>
   347|         {
   348|             private readonly CancellationToken _cancellationToken;
   349|             private CancellationTokenRegistration _cancellationTokenRegistration;
   350|             public bool QueueCountModified { get; set; }
   351|             private RequestRegistration? _next;
   352|             public RequestRegistration(int permitCount, TokenBucketRateLimiter limiter, CancellationToken cancellationToken)
   353|                 : base(limiter, TaskCreationOptions.RunContinuationsAsynchronously)
   354|             {
   355|                 Count = permitCount;
   356|                 _cancellationToken = cancellationToken;
   357|                 if (cancellationToken.CanBeCanceled)
   358| #if NETCOREAPP || NETSTANDARD2_1_OR_GREATER
   359|                     _cancellationTokenRegistration = cancellationToken.UnsafeRegister(Cancel, this);
   360| #else
   361|                     _cancellationTokenRegistration = cancellationToken.Register(Cancel, this);
   362| #endif
   363|             }
   364|             public int Count { get; }
   365|             private static void Cancel(object? state)
   366|             {
   367|                 if (state is RequestRegistration registration && registration.TrySetCanceled(registration._cancellationToken))
   368|                 {
   369|                     var limiter = (TokenBucketRateLimiter)registration.Task.AsyncState!;
   370|                     lock (limiter.Lock)
   371|                     {
   372|                         if (!registration.QueueCountModified)
   373|                         {
   374|                             limiter._queueCount -= registration.Count;
   375|                             registration.QueueCountModified = true;
   376|                         }
   377|                     }
   378|                 }
   379|             }
   380|             public struct Disposer : IDisposable
   381|             {
   382|                 private RequestRegistration? _next;
   383|                 public void Add(RequestRegistration request)
   384|                 {
   385|                     request._next = _next;
   386|                     _next = request;
   387|                 }
   388|                 public void Dispose()
   389|                 {
   390|                     for (var current = _next; current is not null; current = current._next)
   391|                     {
   392|                         current._cancellationTokenRegistration.Dispose();
   393|                     }
   394|                     _next = null;
   395|                 }
   396|             }
   397|         }
   398|     }
   399| }


# ====================================================================
# FILE: src/mono/mono/mini/driver.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2798 ---
     1| /**
     2|  * \file
     3|  * The new mono JIT compiler.
     4|  *
     5|  * Author:
     6|  *   Paolo Molaro (lupus@ximian.com)
     7|  *   Dietmar Maurer (dietmar@ximian.com)
     8|  *
     9|  * (C) 2002-2003 Ximian, Inc.
    10|  * (C) 2003-2006 Novell, Inc.
    11|  * Licensed under the MIT license. See LICENSE file in the project root for full license information.
    12|  */
    13| #include <config.h>
    14| #include <signal.h>
    15| #if HAVE_SCHED_SETAFFINITY
    16| #include <sched.h>
    17| #endif
    18| #ifdef HAVE_UNISTD_H
    19| #include <unistd.h>
    20| #endif
    21| #include <mono/metadata/assembly-internals.h>
    22| #include <mono/metadata/image-internals.h>
    23| #include <mono/metadata/loader.h>
    24| #include <mono/metadata/tabledefs.h>
    25| #include <mono/metadata/class.h>
    26| #include <mono/metadata/object.h>
    27| #include <mono/metadata/exception.h>
    28| #include <mono/metadata/opcodes.h>
    29| #include <mono/metadata/mono-endian.h>
    30| #include <mono/metadata/tokentype.h>
    31| #include <mono/metadata/reflection-internals.h>
    32| #include <mono/metadata/tabledefs.h>
    33| #include <mono/metadata/threads.h>
    34| #include <mono/metadata/marshal.h>
    35| #include <mono/metadata/appdomain.h>
    36| #include <mono/metadata/debug-helpers.h>
    37| #include <mono/metadata/profiler-private.h>
    38| #include <mono/metadata/mono-config.h>
    39| #include <mono/metadata/environment.h>
    40| #include <mono/metadata/verify.h>
    41| #include <mono/metadata/mono-debug.h>
    42| #include <mono/metadata/gc-internals.h>
    43| #include <mono/metadata/coree.h>
    44| #include "mono/utils/mono-counters.h"
    45| #include "mono/utils/mono-hwcap.h"
    46| #include "mono/utils/mono-logger-internals.h"
    47| #include "mono/utils/options.h"
    48| #include "mono/metadata/w32handle.h"
    49| #include "mono/metadata/callspec.h"
    50| #include "mono/metadata/custom-attrs-internals.h"
    51| #include <mono/utils/w32subset.h>
    52| #include <mono/metadata/components.h>
    53| #include <mono/mini/debugger-agent-external.h>
    54| #include "mini.h"
    55| #include <mono/jit/jit.h>
    56| #include "aot-compiler.h"
    57| #include "aot-runtime.h"
    58| #include "mini-runtime.h"
    59| #include "interp/interp.h"
    60| #include <string.h>
    61| #include <ctype.h>
    62| #include <locale.h>
    63| #if TARGET_OSX
    64| #   include <sys/resource.h>
    65| #endif
    66| static FILE *mini_stats_fd;
    67| static void mini_usage (void);
    68| static void mono_runtime_set_execution_mode (int mode);
    69| static void mono_runtime_set_execution_mode_full (int mode, gboolean override);
    70| static int mono_jit_exec_internal (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[]);
    71| #ifdef HOST_WIN32
    72| /* Need this to determine whether to detach console */
    73| #include <mono/metadata/cil-coff.h>
    74| /* This turns off command line globbing under win32 */
    75| int _CRT_glob = 0;
    76| #endif
    77| typedef void (*OptFunc) (const char *p);
    78| #undef OPTFLAG
    79| #define MSGSTRFIELD(line) MSGSTRFIELD1(line)
    80| #define MSGSTRFIELD1(line) str##line
    81| static const struct msgstr_t {
    82| #define OPTFLAG(id,shift,name,desc) char MSGSTRFIELD(__LINE__) [sizeof (name) + sizeof (desc)];
    83| #include "optflags-def.h"
    84| #undef OPTFLAG
    85| } opstr = {
    86| #define OPTFLAG(id,shift,name,desc) name "\0" desc,
    87| #include "optflags-def.h"
    88| #undef OPTFLAG
    89| };
    90| static const gint16 opt_names [] = {
    91| #define OPTFLAG(id,shift,name,desc) offsetof (struct msgstr_t, MSGSTRFIELD(__LINE__)),
    92| #include "optflags-def.h"
    93| #undef OPTFLAG
    94| };
    95| #define optflag_get_name(id) ((const char*)&opstr + opt_names [(id)])
    96| #define optflag_get_desc(id) (optflag_get_name(id) + 1 + strlen (optflag_get_name(id)))
    97| #define DEFAULT_OPTIMIZATIONS (	\
    98| 	MONO_OPT_PEEPHOLE |	\
    99| 	MONO_OPT_CFOLD |	\
   100| 	MONO_OPT_INLINE |       \
   101| 	MONO_OPT_CONSPROP |     \
   102| 	MONO_OPT_COPYPROP |     \
   103| 	MONO_OPT_DEADCE |       \
   104| 	MONO_OPT_BRANCH |	\
   105| 	MONO_OPT_LINEARS |	\
   106| 	MONO_OPT_INTRINS |  \
   107| 	MONO_OPT_LOOP |  \
   108| 	MONO_OPT_EXCEPTION |  \
   109|     MONO_OPT_CMOV |  \
   110| 	MONO_OPT_GSHARED |	\
   111| 	MONO_OPT_SIMD |	\
   112| 	MONO_OPT_ALIAS_ANALYSIS	| \
   113| 	MONO_OPT_AOT | \
   114| 	MONO_OPT_FLOAT32)
   115| #define EXCLUDED_FROM_ALL (MONO_OPT_PRECOMP | MONO_OPT_UNSAFE | MONO_OPT_GSHAREDVT)
   116| static char *mono_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend);
   117| static char *mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend);
   118| static guint32
   119| parse_optimizations (guint32 opt, const char* p, gboolean cpu_opts)
   120| {
   121| 	guint32 exclude = 0;
   122| 	const char *n;
   123| 	int i, invert;
   124| 	char **parts, **ptr;
   125| 	/* Initialize the hwcap module if necessary. */
   126| 	mono_hwcap_init ();
   127| 	/* call out to cpu detection code here that sets the defaults ... */
   128| 	if (cpu_opts) {
   129| #ifndef MONO_CROSS_COMPILE
   130| 		opt |= mono_arch_cpu_optimizations (&exclude);
   131| 		opt &= ~exclude;
   132| #endif
   133| 	}
   134| 	if (!p)
   135| 		return opt;
   136| 	parts = g_strsplit (p, ",", -1);
   137| 	for (ptr = parts; ptr && *ptr; ptr ++) {
   138| 		char *arg = *ptr;
   139| 		char *parg = arg;
   140| 		if (*parg == '-') {
   141| 			parg++;
   142| 			invert = TRUE;
   143| 		} else {
   144| 			invert = FALSE;
   145| 		}
   146| 		for (i = 0; i < G_N_ELEMENTS (opt_names) && optflag_get_name (i); ++i) {
   147| 			n = optflag_get_name (i);
   148| 			if (!strcmp (parg, n)) {
   149| 				if (invert)
   150| 					opt &= ~ (1 << i);
   151| 				else
   152| 					opt |= 1 << i;
   153| 				break;
   154| 			}
   155| 		}
   156| 		if (i == G_N_ELEMENTS (opt_names) || !optflag_get_name (i)) {
   157| 			if (strncmp (parg, "all", 3) == 0) {
   158| 				if (invert)
   159| 					opt = 0;
   160| 				else
   161| 					opt = ~(EXCLUDED_FROM_ALL | exclude);
   162| 			} else {
   163| 				fprintf (stderr, "Invalid optimization name `%s'\n", parg);
   164| 				exit (1);
   165| 			}
   166| 		}
   167| 		g_free (arg);
   168| 	}
   169| 	g_free (parts);
   170| 	return opt;
   171| }
   172| static gboolean
   173| parse_debug_options (const char* p)
   174| {
   175| 	MonoDebugOptions *opt = mini_get_debug_options ();
   176| 	opt->enabled = TRUE;
   177| 	do {
   178| 		if (!*p) {
   179| 			fprintf (stderr, "Syntax error; expected debug option name\n");
   180| 			return FALSE;
   181| 		}
   182| 		if (!strncmp (p, "casts", 5)) {
   183| 			opt->better_cast_details = TRUE;
   184| 			p += 5;
   185| 		} else if (!strncmp (p, "mdb-optimizations", 17)) {
   186| 			opt->mdb_optimizations = TRUE;
   187| 			p += 17;
   188| 		} else if (!strncmp (p, "ignore", 6)) {
   189| 			opt->enabled = FALSE;
   190| 			p += 6;
   191| 		} else {
   192| 			fprintf (stderr, "Invalid debug option `%s', use --help-debug for details\n", p);
   193| 			return FALSE;
   194| 		}
   195| 		if (*p == ',') {
   196| 			p++;
   197| 			if (!*p) {
   198| 				fprintf (stderr, "Syntax error; expected debug option name\n");
   199| 				return FALSE;
   200| 			}
   201| 		}
   202| 	} while (*p);
   203| 	return TRUE;
   204| }
   205| typedef struct {
   206| 	char name [6];
   207| 	char desc [18];
   208| 	MonoGraphOptions value;
   209| } GraphName;
   210| static const GraphName
   211| graph_names [] = {
   212| 	{"cfg",      "Control Flow",                            MONO_GRAPH_CFG},
   213| 	{"dtree",    "Dominator Tree",                          MONO_GRAPH_DTREE},
   214| 	{"code",     "CFG showing code",                        MONO_GRAPH_CFG_CODE},
   215| 	{"ssa",      "CFG after SSA",                           MONO_GRAPH_CFG_SSA},
   216| 	{"optc",     "CFG after IR opts",                       MONO_GRAPH_CFG_OPTCODE}
   217| };
   218| static MonoGraphOptions
   219| mono_parse_graph_options (const char* p)
   220| {
   221| 	const char *n;
   222| 	size_t i, len;
   223| 	for (i = 0; i < G_N_ELEMENTS (graph_names); ++i) {
   224| 		n = graph_names [i].name;
   225| 		len = strlen (n);
   226| 		if (strncmp (p, n, len) == 0)
   227| 			return graph_names [i].value;
   228| 	}
   229| 	fprintf (stderr, "Invalid graph name provided: %s\n", p);
   230| 	exit (1);
   231| }
   232| /**
   233|  * mono_parse_default_optimizations:
   234|  */
   235| int
   236| mono_parse_default_optimizations (const char* p)
   237| {
   238| 	guint32 opt;
   239| 	opt = parse_optimizations (DEFAULT_OPTIMIZATIONS, p, TRUE);
   240| 	return opt;
   241| }
   242| char*
   243| mono_opt_descr (guint32 flags) {
   244| 	GString *str = g_string_new ("");
   245| 	int i;
   246| 	gboolean need_comma;
   247| 	need_comma = FALSE;
   248| 	for (i = 0; i < G_N_ELEMENTS (opt_names); ++i) {
   249| 		if (flags & (1 << i) && optflag_get_name (i)) {
   250| 			if (need_comma)
   251| 				g_string_append_c (str, ',');
   252| 			g_string_append (str, optflag_get_name (i));
   253| 			need_comma = TRUE;
   254| 		}
   255| 	}
   256| 	return g_string_free (str, FALSE);
   257| }
   258| static const guint32
   259| opt_sets [] = {
   260|        0,
   261|        MONO_OPT_PEEPHOLE,
   262|        MONO_OPT_BRANCH,
   263|        MONO_OPT_CFOLD,
   264|        MONO_OPT_FCMOV,
   265|        MONO_OPT_ALIAS_ANALYSIS,
   266| #ifdef MONO_ARCH_SIMD_INTRINSICS
   267|        MONO_OPT_SIMD | MONO_OPT_INTRINS,
   268|        MONO_OPT_SSE2,
   269|        MONO_OPT_SIMD | MONO_OPT_SSE2 | MONO_OPT_INTRINS,
   270| #endif
   271|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_INTRINS,
   272|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_INTRINS | MONO_OPT_ALIAS_ANALYSIS,
   273|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS,
   274|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP,
   275|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_CFOLD,
   276|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE,
   277|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_ALIAS_ANALYSIS,
   278|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS,
   279|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_TAILCALL,
   280|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_SSA,
   281|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION,
   282|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_CMOV,
   283|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_ABCREM,
   284|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_LINEARS | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_ABCREM,
   285|        MONO_OPT_BRANCH | MONO_OPT_PEEPHOLE | MONO_OPT_COPYPROP | MONO_OPT_CONSPROP | MONO_OPT_DEADCE | MONO_OPT_LOOP | MONO_OPT_INLINE | MONO_OPT_INTRINS | MONO_OPT_EXCEPTION | MONO_OPT_CMOV,
   286|        DEFAULT_OPTIMIZATIONS,
   287| };
   288| static const guint32
   289| interp_opt_sets [] = {
   290| 	INTERP_OPT_NONE,
   291| 	INTERP_OPT_INLINE,
   292| 	INTERP_OPT_CPROP,
   293| 	INTERP_OPT_SUPER_INSTRUCTIONS,
   294| 	INTERP_OPT_INLINE | INTERP_OPT_CPROP,
   295| 	INTERP_OPT_INLINE | INTERP_OPT_SUPER_INSTRUCTIONS,
   296| 	INTERP_OPT_CPROP | INTERP_OPT_SUPER_INSTRUCTIONS,
   297| 	INTERP_OPT_INLINE | INTERP_OPT_CPROP | INTERP_OPT_SUPER_INSTRUCTIONS | INTERP_OPT_BBLOCKS,
   298| };
   299| static const char* const
   300| interp_opflags_names [] = {
   301| 	"inline",
   302| 	"cprop",
   303| 	"super-insn",
   304| 	"bblocks"
   305| };
   306| static const char*
   307| interp_optflag_get_name (guint32 i)
   308| {
   309| 	g_assert (i < G_N_ELEMENTS (interp_opflags_names));
   310| 	return interp_opflags_names [i];
   311| }
   312| static char*
   313| interp_opt_descr (guint32 flags)
   314| {
   315| 	GString *str = g_string_new ("");
   316| 	int i;
   317| 	gboolean need_comma;
   318| 	need_comma = FALSE;
   319| 	for (i = 0; i < G_N_ELEMENTS (interp_opflags_names); ++i) {
   320| 		if (flags & (1 << i) && interp_optflag_get_name (i)) {
   321| 			if (need_comma)
   322| 				g_string_append_c (str, ',');
   323| 			g_string_append (str, interp_optflag_get_name (i));
   324| 			need_comma = TRUE;
   325| 		}
   326| 	}
   327| 	return g_string_free (str, FALSE);
   328| }
   329| typedef int (*TestMethod) (void);
   330| #if 0
   331| static void
   332| domain_dump_native_code (MonoDomain *domain) {
   333| }
   334| #endif
   335| static gboolean do_regression_retries;
   336| static int regression_test_skip_index;
   337| static gboolean
   338| method_should_be_regression_tested (MonoMethod *method, gboolean interp)
   339| {
   340| 	ERROR_DECL (error);
   341| 	if (strncmp (method->name, "test_", 5) != 0)
   342| 		return FALSE;
   343| 	static gboolean filter_method_init = FALSE;
   344| 	static const char *filter_method = NULL;
   345| 	if (!filter_method_init) {
   346| 		filter_method = g_getenv ("REGRESSION_FILTER_METHOD");
   347| 		filter_method_init = TRUE;
   348| 	}
   349| 	if (filter_method) {
   350| 		const char *name = filter_method;
   351| 		if ((strchr (name, '.') > name) || strchr (name, ':')) {
   352| 			MonoMethodDesc *desc = mono_method_desc_new (name, TRUE);
   353| 			gboolean res = mono_method_desc_full_match (desc, method);
   354| 			mono_method_desc_free (desc);
   355| 			return res;
   356| 		} else {
   357| 			return strcmp (method->name, name) == 0;
   358| 		}
   359| 	}
   360| 	MonoCustomAttrInfo* ainfo = mono_custom_attrs_from_method_checked (method, error);
   361| 	mono_error_cleanup (error);
   362| 	if (!ainfo)
   363| 		return TRUE;
   364| 	int j;
   365| 	for (j = 0; j < ainfo->num_attrs; ++j) {
   366| 		MonoCustomAttrEntry *centry = &ainfo->attrs [j];
   367| 		if (centry->ctor == NULL)
   368| 			continue;
   369| 		MonoClass *klass = centry->ctor->klass;
   370| 		if (strcmp (m_class_get_name (klass), "CategoryAttribute") || mono_method_signature_internal (centry->ctor)->param_count != 1)
   371| 			continue;
   372| 		MonoDecodeCustomAttr *decoded_args = mono_reflection_create_custom_attr_data_args_noalloc (mono_defaults.corlib, centry->ctor, centry->data, centry->data_size, error);
   373| 		if (!is_ok (error))
   374| 			continue;
   375| 		const char *arg = (const char*)decoded_args->typed_args[0]->value.primitive;
   376| 		mono_metadata_decode_value (arg, &arg);
   377| 		char *utf8_str = (char*)arg; //this points into image memory that is constant
   378| 		mono_reflection_free_custom_attr_data_args_noalloc (decoded_args);
   379| 		if (interp && !strcmp (utf8_str, "!INTERPRETER")) {
   380| 			g_print ("skip %s...\n", method->name);
   381| 			return FALSE;
   382| 		}
   383| #if HOST_WASM
   384| 		if (!strcmp (utf8_str, "!WASM")) {
   385| 			g_print ("skip %s...\n", method->name);
   386| 			return FALSE;
   387| 		}
   388| #endif
   389| 		if (mono_aot_mode == MONO_AOT_MODE_FULL && !strcmp (utf8_str, "!FULLAOT")) {
   390| 			g_print ("skip %s...\n", method->name);
   391| 			return FALSE;
   392| 		}
   393| 		if ((mono_aot_mode == MONO_AOT_MODE_INTERP_LLVMONLY || mono_aot_mode == MONO_AOT_MODE_LLVMONLY_INTERP) && !strcmp (utf8_str, "!BITCODE")) {
   394| 			g_print ("skip %s...\n", method->name);
   395| 			return FALSE;
   396| 		}
   397| 	}
   398| 	return TRUE;
   399| }
   400| static void
   401| mini_regression_step (MonoImage *image, int verbose, int *total_run, int *total,
   402| 					  guint32 opt_flags, GTimer *timer)
   403| {
   404| 	int result, expected, failed, cfailed, run, code_size;
   405| 	double elapsed, comp_time, start_time;
   406| 	char *n;
   407| 	mono_set_defaults (verbose, opt_flags);
   408| 	n = mono_opt_descr (opt_flags);
   409| 	g_print ("Test run: image=%s, opts=%s\n", mono_image_get_filename (image), n);
   410| 	g_free (n);
   411| 	cfailed = failed = run = code_size = 0;
   412| 	comp_time = elapsed = 0.0;
   413| 	int local_skip_index = 0;
   414| 	MonoJitMemoryManager *jit_mm = get_default_jit_mm ();
   415| 	g_hash_table_destroy (jit_mm->jit_trampoline_hash);
   416| 	jit_mm->jit_trampoline_hash = g_hash_table_new (mono_aligned_addr_hash, NULL);
   417| 	mono_internal_hash_table_destroy (&(jit_mm->jit_code_hash));
   418| 	mono_jit_code_hash_init (&(jit_mm->jit_code_hash));
   419| 	g_timer_start (timer);
   420| 	if (mini_stats_fd)
   421| 		fprintf (mini_stats_fd, "[");
   422| 	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
   423| 		ERROR_DECL (error);
   424| 		MonoMethod *method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
   425| 		if (!method) {
   426| 			mono_error_cleanup (error); /* FIXME don't swallow the error */
   427| 			continue;
   428| 		}
   429| 		if (method_should_be_regression_tested (method, FALSE)) {
   430| 			MonoCompile *cfg = NULL;
   431| 			TestMethod func = NULL;
   432| 			expected = atoi (method->name + 5);
   433| 			run++;
   434| 			start_time = g_timer_elapsed (timer, NULL);
   435| #ifdef DISABLE_JIT
   436| #ifdef MONO_USE_AOT_COMPILER
   437| 			error_init_reuse (error);
   438| 			func = (TestMethod)mono_aot_get_method (method, error);
   439| 			mono_error_cleanup (error);
   440| #else
   441| 			g_error ("No JIT or AOT available, regression testing not possible!");
   442| #endif
   443| #else
   444| 			comp_time -= start_time;
   445| 			cfg = mini_method_compile (method, mono_get_optimizations_for_method (method, opt_flags), JIT_FLAG_RUN_CCTORS, 0, -1);
   446| 			comp_time += g_timer_elapsed (timer, NULL);
   447| 			if (cfg->exception_type == MONO_EXCEPTION_NONE) {
   448| #ifdef MONO_USE_AOT_COMPILER
   449| 				error_init_reuse (error);
   450| 				func = (TestMethod)mono_aot_get_method (method, error);
   451| 				mono_error_cleanup (error);
   452| 				if (!func) {
   453| 					func = (TestMethod)MINI_ADDR_TO_FTNPTR (cfg->native_code);
   454| 				}
   455| #else
   456| 				func = (TestMethod)(gpointer)cfg->native_code;
   457| 				func = MINI_ADDR_TO_FTNPTR (func);
   458| #endif
   459| 				func = (TestMethod)mono_create_ftnptr ((gpointer)func);
   460| 			}
   461| #endif
   462| 			if (func) {
   463| 				if (do_regression_retries) {
   464| 					++local_skip_index;
   465| 					if(local_skip_index <= regression_test_skip_index)
   466| 						continue;
   467| 					++regression_test_skip_index;
   468| 				}
   469| 				if (verbose >= 2)
   470| 					g_print ("Running '%s' ...\n", method->name);
   471| #if HOST_WASM
   472| 				int (*func_2)(int) = (int (*)(int))(void*)func;
   473| 				result = func_2 (-1);
   474| #else
   475| 				result = func ();
   476| #endif
   477| 				if (result != expected) {
   478| 					failed++;
   479| 					g_print ("Test '%s' failed result (got %d, expected %d).\n", method->name, result, expected);
   480| 				}
   481| 				if (cfg) {
   482| 					code_size += cfg->code_len;
   483| 					mono_destroy_compile (cfg);
   484| 				}
   485| 			} else {
   486| 				cfailed++;
   487| 				g_print ("Test '%s' failed compilation.\n", method->name);
   488| 			}
   489| 			if (mini_stats_fd)
   490| 				fprintf (mini_stats_fd, "%f, ",
   491| 						g_timer_elapsed (timer, NULL) - start_time);
   492| 		}
   493| 	}
   494| 	if (mini_stats_fd)
   495| 		fprintf (mini_stats_fd, "],\n");
   496| 	g_timer_stop (timer);
   497| 	elapsed = g_timer_elapsed (timer, NULL);
   498| 	if (failed > 0 || cfailed > 0){
   499| 		g_print ("Results: total tests: %d, failed: %d, cfailed: %d (pass: %.2f%%)\n",
   500| 				run, failed, cfailed, 100.0*(run-failed-cfailed)/run);
   501| 	} else {
   502| 		g_print ("Results: total tests: %d, all pass \n",  run);
   503| 	}
   504| 	g_print ("Elapsed time: %f secs (%f, %f), Code size: %d\n\n", elapsed,
   505| 			elapsed - comp_time, comp_time, code_size);
   506| 	*total += failed + cfailed;
   507| 	*total_run += run;
   508| }
   509| static int
   510| mini_regression (MonoImage *image, int verbose, int *total_run)
   511| {
   512| 	MonoMethod *method;
   513| 	char *n;
   514| 	GTimer *timer = g_timer_new ();
   515| 	guint32 exclude = 0;
   516| 	int total;
   517| 	/* Note: mono_hwcap_init () called in mono_init () before we get here. */
   518| 	mono_arch_cpu_optimizations (&exclude);
   519| 	if (mini_stats_fd) {
   520| 		fprintf (mini_stats_fd, "$stattitle = \'Mono Benchmark Results (various optimizations)\';\n");
   521| 		fprintf (mini_stats_fd, "$graph->set_legend(qw(");
   522| 		for (guint32 opt = 0; opt < G_N_ELEMENTS (opt_sets); opt++) {
   523| 			guint32 opt_flags = opt_sets [opt];
   524| 			n = mono_opt_descr (opt_flags);
   525| 			if (!n [0])
   526| 				n = (char *)"none";
   527| 			if (opt)
   528| 				fprintf (mini_stats_fd, " ");
   529| 			fprintf (mini_stats_fd, "%s", n);
   530| 		}
   531| 		fprintf (mini_stats_fd, "));\n");
   532| 		fprintf (mini_stats_fd, "@data = (\n");
   533| 		fprintf (mini_stats_fd, "[");
   534| 	}
   535| 	/* load the metadata */
   536| 	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
   537| 		ERROR_DECL (error);
   538| 		method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
   539| 		if (!method) {
   540| 			mono_error_cleanup (error);
   541| 			continue;
   542| 		}
   543| 		mono_class_init_internal (method->klass);
   544| 		if (!strncmp (method->name, "test_", 5) && mini_stats_fd) {
   545| 			fprintf (mini_stats_fd, "\"%s\",", method->name);
   546| 		}
   547| 	}
   548| 	if (mini_stats_fd)
   549| 		fprintf (mini_stats_fd, "],\n");
   550| 	total = 0;
   551| 	*total_run = 0;
   552| 	if (mono_do_single_method_regression) {
   553| 		GSList *iter;
   554| 		mini_regression_step (image, verbose, total_run, &total,
   555| 				0, timer);
   556| 		if (total)
   557| 			return total;
   558| 		g_print ("Single method regression: %d methods\n", g_slist_length (mono_single_method_list));
   559| 		for (iter = mono_single_method_list; iter; iter = g_slist_next (iter)) {
   560| 			char *method_name;
   561| 			mono_current_single_method = (MonoMethod *)iter->data;
   562| 			method_name = mono_method_full_name (mono_current_single_method, TRUE);
   563| 			g_print ("Current single method: %s\n", method_name);
   564| 			g_free (method_name);
   565| 			mini_regression_step (image, verbose, total_run, &total,
   566| 								  0, timer);
   567| 			if (total)
   568| 				return total;
   569| 		}
   570| 	} else {
   571| 		for (guint32 opt = 0; opt < G_N_ELEMENTS (opt_sets); ++opt) {
   572| 			/* aot-tests.cs need OPT_INTRINS enabled */
   573| 			if (!strcmp ("aot-tests", image->assembly_name))
   574| 				if (!(opt_sets [opt] & MONO_OPT_INTRINS))
   575| 					continue;
   576| 			if ((mono_aot_mode == MONO_AOT_MODE_FULL || mono_aot_mode == MONO_AOT_MODE_LLVMONLY_INTERP) && opt_sets [opt] != DEFAULT_OPTIMIZATIONS) {
   577| 				continue;
   578| 			}
   579| 			mini_regression_step (image, verbose, total_run, &total,
   580| 								  opt_sets [opt] & ~exclude, timer);
   581| 		}
   582| 	}
   583| 	if (mini_stats_fd) {
   584| 		fprintf (mini_stats_fd, ");\n");
   585| 		fflush (mini_stats_fd);
   586| 	}
   587| 	g_timer_destroy (timer);
   588| 	return total;
   589| }
   590| static int
   591| mini_regression_list (int verbose, int count, char *images [])
   592| {
   593| 	int i, total, total_run, run;
   594| 	MonoAssembly *ass;
   595| 	total_run =  total = 0;
   596| 	for (i = 0; i < count; ++i) {
   597| 		MonoAssemblyOpenRequest req;
   598| 		mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
   599| 		ass = mono_assembly_request_open (images [i], &req, NULL);
   600| 		if (!ass) {
   601| 			g_warning ("failed to load assembly: %s", images [i]);
   602| 			continue;
   603| 		}
   604| 		total += mini_regression (mono_assembly_get_image_internal (ass), verbose, &run);
   605| 		total_run += run;
   606| 	}
   607| 	if (total > 0){
   608| 		g_print ("Overall results: tests: %d, failed: %d, opt combinations: %d (pass: %.2f%%)\n",
   609| 			 total_run, total, (int)G_N_ELEMENTS (opt_sets), 100.0*(total_run-total)/total_run);
   610| 	} else {
   611| 		g_print ("Overall results: tests: %d, 100%% pass, opt combinations: %d\n",
   612| 			 total_run, (int)G_N_ELEMENTS (opt_sets));
   613| 	}
   614| 	return total;
   615| }
   616| static void
   617| interp_regression_step (MonoImage *image, int verbose, int *total_run, int *total, const guint32 *opt_flags, GTimer *timer)
   618| {
   619| 	int result, expected, failed, cfailed, run;
   620| 	double elapsed, transform_time;
   621| 	MonoObject *result_obj;
   622| 	int local_skip_index = 0;
   623| 	const char *n = NULL;
   624| 	if (opt_flags) {
   625| 		mini_get_interp_callbacks ()->set_optimizations (*opt_flags);
   626| 		n = interp_opt_descr (*opt_flags);
   627| 	} else {
   628| 		n = mono_interp_opts_string;
   629| 	}
   630| 	g_print ("Test run: image=%s, opts=%s\n", mono_image_get_filename (image), n);
   631| 	cfailed = failed = run = 0;
   632| 	transform_time = elapsed = 0.0;
   633| 	mini_get_interp_callbacks ()->invalidate_transformed ();
   634| 	g_timer_start (timer);
   635| 	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
   636| 		ERROR_DECL (error);
   637| 		MonoMethod *method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
   638| 		if (!method) {
   639| 			mono_error_cleanup (error); /* FIXME don't swallow the error */
   640| 			continue;
   641| 		}
   642| 		if (method_should_be_regression_tested (method, TRUE)) {
   643| 			ERROR_DECL (interp_error);
   644| 			MonoObject *exc = NULL;
   645| 			if (do_regression_retries) {
   646| 				++local_skip_index;
   647| 				if(local_skip_index <= regression_test_skip_index)
   648| 					continue;
   649| 				++regression_test_skip_index;
   650| 			}
   651| 			result_obj = mini_get_interp_callbacks ()->runtime_invoke (method, NULL, NULL, &exc, interp_error);
   652| 			if (!is_ok (interp_error)) {
   653| 				cfailed++;
   654| 				g_print ("Test '%s' execution failed.\n", method->name);
   655| 			} else if (exc != NULL) {
   656| 				g_print ("Exception in Test '%s' occurred:\n", method->name);
   657| 				mono_object_describe (exc);
   658| 				run++;
   659| 				failed++;
   660| 			} else {
   661| 				result = *(gint32 *) mono_object_unbox_internal (result_obj);
   662| 				expected = atoi (method->name + 5);  // FIXME: oh no.
   663| 				run++;
   664| 				if (result != expected) {
   665| 					failed++;
   666| 					g_print ("Test '%s' failed result (got %d, expected %d).\n", method->name, result, expected);
   667| 				}
   668| 			}
   669| 		}
   670| 	}
   671| 	g_timer_stop (timer);
   672| 	elapsed = g_timer_elapsed (timer, NULL);
   673| 	if (failed > 0 || cfailed > 0){
   674| 		g_print ("Results: total tests: %d, failed: %d, cfailed: %d (pass: %.2f%%)\n",
   675| 				run, failed, cfailed, 100.0*(run-failed-cfailed)/run);
   676| 	} else {
   677| 		g_print ("Results: total tests: %d, all pass \n",  run);
   678| 	}
   679| 	g_print ("Elapsed time: %f secs (%f, %f)\n\n", elapsed,
   680| 			elapsed - transform_time, transform_time);
   681| 	*total += failed + cfailed;
   682| 	*total_run += run;
   683| }
   684| static int
   685| interp_regression (MonoImage *image, int verbose, int *total_run)
   686| {
   687| 	MonoMethod *method;
   688| 	GTimer *timer = g_timer_new ();
   689| 	int total;
   690| 	/* load the metadata */
   691| 	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
   692| 		ERROR_DECL (error);
   693| 		method = mono_get_method_checked (image, MONO_TOKEN_METHOD_DEF | (i + 1), NULL, NULL, error);
   694| 		if (!method) {
   695| 			mono_error_cleanup (error);
   696| 			continue;
   697| 		}
   698| 		mono_class_init_internal (method->klass);
   699| 	}
   700| 	total = 0;
   701| 	*total_run = 0;
   702| 	if (mono_interp_opts_string) {
   703| 		/* explicit option requested*/
   704| 		interp_regression_step (image, verbose, total_run, &total, NULL, timer);
   705| 	} else {
   706| 		for (int opt = 0; opt < G_N_ELEMENTS (interp_opt_sets); ++opt)
   707| 			interp_regression_step (image, verbose, total_run, &total, &interp_opt_sets [opt], timer);
   708| 	}
   709| 	g_timer_destroy (timer);
   710| 	return total;
   711| }
   712| /* TODO: merge this code with the regression harness of the JIT */
   713| static int
   714| mono_interp_regression_list (int verbose, int count, char *images [])
   715| {
   716| 	int i, total, total_run, run;
   717| 	total_run = total = 0;
   718| 	for (i = 0; i < count; ++i) {
   719| 		MonoAssemblyOpenRequest req;
   720| 		mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
   721| 		MonoAssembly *ass = mono_assembly_request_open (images [i], &req, NULL);
   722| 		if (!ass) {
   723| 			g_warning ("failed to load assembly: %s", images [i]);
   724| 			continue;
   725| 		}
   726| 		total += interp_regression (mono_assembly_get_image_internal (ass), verbose, &run);
   727| 		total_run += run;
   728| 	}
   729| 	if (total > 0) {
   730| 		g_print ("Overall results: tests: %d, failed: %d (pass: %.2f%%)\n", total_run, total, 100.0*(total_run-total)/total_run);
   731| 	} else {
   732| 		g_print ("Overall results: tests: %d, 100%% pass\n", total_run);
   733| 	}
   734| 	return total;
   735| }
   736| #ifdef MONO_JIT_INFO_TABLE_TEST
   737| typedef struct _JitInfoData
   738| {
   739| 	guint start;
   740| 	guint length;
   741| 	MonoJitInfo *ji;
   742| 	struct _JitInfoData *next;
   743| } JitInfoData;
   744| typedef struct
   745| {
   746| 	guint start;
   747| 	guint length;
   748| 	int num_datas;
   749| 	JitInfoData *data;
   750| } Region;
   751| typedef struct
   752| {
   753| 	int num_datas;
   754| 	int num_regions;
   755| 	Region *regions;
   756| 	int num_frees;
   757| 	JitInfoData *frees;
   758| } ThreadData;
   759| static int num_threads;
   760| static ThreadData *thread_datas;
   761| static MonoDomain *test_domain;
   762| static JitInfoData*
   763| alloc_random_data (Region *region)
   764| {
   765| 	JitInfoData **data;
   766| 	JitInfoData *prev;
   767| 	guint prev_end;
   768| 	guint next_start;
   769| 	guint max_len;
   770| 	JitInfoData *d;
   771| 	int num_retries = 0;
   772| 	int pos, i;
   773|  restart:
   774| 	prev = NULL;
   775| 	data = &region->data;
   776| 	pos = random () % (region->num_datas + 1);
   777| 	i = 0;
   778| 	while (*data != NULL) {
   779| 		if (i++ == pos)
   780| 			break;
   781| 		prev = *data;
   782| 		data = &(*data)->next;
   783| 	}
   784| 	if (prev == NULL)
   785| 		g_assert (*data == region->data);
   786| 	else
   787| 		g_assert (prev->next == *data);
   788| 	if (prev == NULL)
   789| 		prev_end = region->start;
   790| 	else
   791| 		prev_end = prev->start + prev->length;
   792| 	if (*data == NULL)
   793| 		next_start = region->start + region->length;
   794| 	else
   795| 		next_start = (*data)->start;
   796| 	g_assert (prev_end <= next_start);
   797| 	max_len = next_start - prev_end;
   798| 	if (max_len < 128) {
   799| 		if (++num_retries >= 10)
   800| 			return NULL;
   801| 		goto restart;
   802| 	}
   803| 	if (max_len > 1024)
   804| 		max_len = 1024;
   805| 	d = g_new0 (JitInfoData, 1);
   806| 	d->start = prev_end + random () % (max_len / 2);
   807| 	d->length = random () % MIN (max_len, next_start - d->start) + 1;
   808| 	g_assert (d->start >= prev_end && d->start + d->length <= next_start);
   809| 	d->ji = g_new0 (MonoJitInfo, 1);
   810| 	d->ji->d.method = (MonoMethod*) 0xABadBabe;
   811| 	d->ji->code_start = (gpointer)(gulong) d->start;
   812| 	d->ji->code_size = d->length;
   813| 	d->ji->cas_inited = 1;	/* marks an allocated jit info */
   814| 	d->next = *data;
   815| 	*data = d;
   816| 	++region->num_datas;
   817| 	return d;
   818| }
   819| static JitInfoData**
   820| choose_random_data (Region *region)
   821| {
   822| 	int n;
   823| 	int i;
   824| 	JitInfoData **d;
   825| 	g_assert (region->num_datas > 0);
   826| 	n = random () % region->num_datas;
   827| 	for (d = &region->data, i = 0;
   828| 	     i < n;
   829| 	     d = &(*d)->next, ++i)
   830| 		;
   831| 	return d;
   832| }
   833| static Region*
   834| choose_random_region (ThreadData *td)
   835| {
   836| 	return &td->regions [random () % td->num_regions];
   837| }
   838| static ThreadData*
   839| choose_random_thread (void)
   840| {
   841| 	return &thread_datas [random () % num_threads];
   842| }
   843| static void
   844| free_jit_info_data (ThreadData *td, JitInfoData *free)
   845| {
   846| 	free->next = td->frees;
   847| 	td->frees = free;
   848| 	if (++td->num_frees >= 1000) {
   849| 		int i;
   850| 		for (i = 0; i < 500; ++i)
   851| 			free = free->next;
   852| 		while (free->next != NULL) {
   853| 			JitInfoData *next = free->next->next;
   854| 			g_free (free->next);
   855| 			free->next = next;
   856| 			--td->num_frees;
   857| 		}
   858| 	}
   859| }
   860| #define NUM_THREADS		8
   861| #define REGIONS_PER_THREAD	10
   862| #define REGION_SIZE		0x10000
   863| #define MAX_ADDR		(REGION_SIZE * REGIONS_PER_THREAD * NUM_THREADS)
   864| #define MODE_ALLOC	1
   865| #define MODE_FREE	2
   866| static void
   867| test_thread_func (gpointer void_arg)
   868| {
   869| 	ThreadData* td = (ThreadData*)void_arg;
   870| 	int mode = MODE_ALLOC;
   871| 	int i = 0;
   872| 	gulong lookup_successes = 0, lookup_failures = 0;
   873| 	int thread_num = (int)(td - thread_datas);
   874| 	gboolean modify_thread = thread_num < NUM_THREADS / 2; /* only half of the threads modify the table */
   875| 	for (;;) {
   876| 		int alloc;
   877| 		int lookup = 1;
   878| 		if (td->num_datas == 0) {
   879| 			lookup = 0;
   880| 			alloc = 1;
   881| 		} else if (modify_thread && random () % 1000 < 5) {
   882| 			lookup = 0;
   883| 			if (mode == MODE_ALLOC)
   884| 				alloc = (random () % 100) < 70;
   885| 			else if (mode == MODE_FREE)
   886| 				alloc = (random () % 100) < 30;
   887| 		}
   888| 		if (lookup) {
   889| 			/* modify threads sometimes look up their own jit infos */
   890| 			if (modify_thread && random () % 10 < 5) {
   891| 				Region *region = choose_random_region (td);
   892| 				if (region->num_datas > 0) {
   893| 					JitInfoData **data = choose_random_data (region);
   894| 					guint pos = (*data)->start + random () % (*data)->length;
   895| 					MonoJitInfo *ji;
   896| 					ji = mono_jit_info_table_find_internal ((char*)(gsize)pos, TRUE, FALSE);
   897| 					g_assert (ji->cas_inited);
   898| 					g_assert ((*data)->ji == ji);
   899| 				}
   900| 			} else {
   901| 				int pos = random () % MAX_ADDR;
   902| 				char *addr = (char*)(uintptr_t)pos;
   903| 				MonoJitInfo *ji;
   904| 				ji = mono_jit_info_table_find_internal (addr, TRUE, FALSE);
   905| 				/*
   906| 				 * FIXME: We are actually not allowed
   907| 				 * to do this.  By the time we examine
   908| 				 * the ji another thread might already
   909| 				 * have removed it.
   910| 				 */
   911| 				if (ji != NULL) {
   912| 					g_assert (addr >= (char*)ji->code_start && addr < (char*)ji->code_start + ji->code_size);
   913| 					++lookup_successes;
   914| 				} else
   915| 					++lookup_failures;
   916| 			}
   917| 		} else if (alloc) {
   918| 			JitInfoData *data = alloc_random_data (choose_random_region (td));
   919| 			if (data != NULL) {
   920| 				mono_jit_info_table_add (domain, data->ji);
   921| 				++td->num_datas;
   922| 			}
   923| 		} else {
   924| 			Region *region = choose_random_region (td);
   925| 			if (region->num_datas > 0) {
   926| 				JitInfoData **data = choose_random_data (region);
   927| 				JitInfoData *free;
   928| 				mono_jit_info_table_remove (domain, (*data)->ji);
   929| 				free = *data;
   930| 				*data = (*data)->next;
   931| 				free_jit_info_data (td, free);
   932| 				--region->num_datas;
   933| 				--td->num_datas;
   934| 			}
   935| 		}
   936| 		if (++i % 100000 == 0) {
   937| 			int j;
   938| 			g_print ("num datas %d (%ld - %ld): %d", (int)(td - thread_datas),
   939| 				 lookup_successes, lookup_failures, td->num_datas);
   940| 			for (j = 0; j < td->num_regions; ++j)
   941| 				g_print ("  %d", td->regions [j].num_datas);
   942| 			g_print ("\n");
   943| 		}
   944| 		if (td->num_datas < 100)
   945| 			mode = MODE_ALLOC;
   946| 		else if (td->num_datas > 2000)
   947| 			mode = MODE_FREE;
   948| 	}
   949| }
   950| /*
   951| static void
   952| small_id_thread_func (gpointer arg)
   953| {
   954| 	MonoThread *thread = mono_thread_current ();
   955| 	MonoThreadHazardPointers *hp = mono_hazard_pointer_get ();
   956| 	g_print ("my small id is %d\n", (int)thread->small_id);
   957| 	mono_hazard_pointer_clear (hp, 1);
   958| 	sleep (3);
   959| 	g_print ("done %d\n", (int)thread->small_id);
   960| }
   961| */
   962| static void
   963| jit_info_table_test (MonoDomain *domain)
   964| {
   965| 	ERROR_DECL (error);
   966| 	int i;
   967| 	g_print ("testing jit_info_table\n");
   968| 	num_threads = NUM_THREADS;
   969| 	thread_datas = g_new0 (ThreadData, num_threads);
   970| 	for (i = 0; i < num_threads; ++i) {
   971| 		int j;
   972| 		thread_datas [i].num_regions = REGIONS_PER_THREAD;
   973| 		thread_datas [i].regions = g_new0 (Region, REGIONS_PER_THREAD);
   974| 		for (j = 0; j < REGIONS_PER_THREAD; ++j) {
   975| 			thread_datas [i].regions [j].start = (num_threads * j + i) * REGION_SIZE;
   976| 			thread_datas [i].regions [j].length = REGION_SIZE;
   977| 		}
   978| 	}
   979| 	test_domain = domain;
   980| 	/*
   981| 	for (i = 0; i < 72; ++i)
   982| 		mono_thread_create (small_id_thread_func, NULL);
   983| 	sleep (2);
   984| 	*/
   985| 	for (i = 0; i < num_threads; ++i) {
   986| 		mono_thread_create_checked ((MonoThreadStart)test_thread_func, &thread_datas [i], error);
   987| 		mono_error_assert_ok (error);
   988| 	}
   989| }
   990| #endif
   991| enum {
   992| 	DO_BENCH,
   993| 	DO_REGRESSION,
   994| 	DO_SINGLE_METHOD_REGRESSION,
   995| 	DO_COMPILE,
   996| 	DO_EXEC,
   997| 	DO_DRAW,
   998| 	DO_DEBUGGER
   999| };
  1000| typedef struct CompileAllThreadArgs {
  1001| 	MonoAssembly *ass;
  1002| 	int verbose;
  1003| 	guint32 opts;
  1004| 	guint32 recompilation_times;
  1005| } CompileAllThreadArgs;
  1006| static void
  1007| compile_all_methods_thread_main_inner (CompileAllThreadArgs *args)
  1008| {
  1009| 	MonoAssembly *ass = args->ass;
  1010| 	int verbose = args->verbose;
  1011| 	MonoImage *image = mono_assembly_get_image_internal (ass);
  1012| 	MonoMethod *method;
  1013| 	MonoCompile *cfg;
  1014| 	int count = 0, fail_count = 0;
  1015| 	for (guint32 i = 0; i < table_info_get_rows (&image->tables [MONO_TABLE_METHOD]); ++i) {
  1016| 		ERROR_DECL (error);
  1017| 		guint32 token = MONO_TOKEN_METHOD_DEF | (i + 1);
  1018| 		MonoMethodSignature *sig;
  1019| 		if (mono_metadata_has_generic_params (image, token))
  1020| 			continue;
  1021| 		method = mono_get_method_checked (image, token, NULL, NULL, error);
  1022| 		if (!method) {
  1023| 			mono_error_cleanup (error); /* FIXME don't swallow the error */
  1024| 			continue;
  1025| 		}
  1026| 		if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
  1027| 		    (method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL) ||
  1028| 		    (method->iflags & METHOD_IMPL_ATTRIBUTE_RUNTIME) ||
  1029| 		    (method->flags & METHOD_ATTRIBUTE_ABSTRACT))
  1030| 			continue;
  1031| 		if (mono_class_is_gtd (method->klass))
  1032| 			continue;
  1033| 		sig = mono_method_signature_internal (method);
  1034| 		if (!sig) {
  1035| 			char * desc = mono_method_full_name (method, TRUE);
  1036| 			g_print ("Could not retrieve method signature for %s\n", desc);
  1037| 			g_free (desc);
  1038| 			fail_count ++;
  1039| 			continue;
  1040| 		}
  1041| 		if (sig->has_type_parameters)
  1042| 			continue;
  1043| 		count++;
  1044| 		if (verbose) {
  1045| 			char * desc = mono_method_full_name (method, TRUE);
  1046| 			g_print ("Compiling %d %s\n", count, desc);
  1047| 			g_free (desc);
  1048| 		}
  1049| 		if (mono_use_interpreter) {
  1050| 			mini_get_interp_callbacks ()->create_method_pointer (method, TRUE, error);
  1051| 			if (verbose && !is_ok (error))
  1052| 				g_print ("Compilation of %s failed\n", mono_method_full_name (method, TRUE));
  1053| 		} else {
  1054| 			cfg = mini_method_compile (method, mono_get_optimizations_for_method (method, args->opts), (JitFlags)JIT_FLAG_DISCARD_RESULTS, 0, -1);
  1055| 			if (cfg->exception_type != MONO_EXCEPTION_NONE) {
  1056| 				const char *msg = cfg->exception_message;
  1057| 				if (cfg->exception_type == MONO_EXCEPTION_MONO_ERROR)
  1058| 					msg = mono_error_get_message (cfg->error);
  1059| 				g_print ("Compilation of %s failed with exception '%s':\n", mono_method_full_name (cfg->method, TRUE), msg);
  1060| 				fail_count ++;
  1061| 			}
  1062| 			mono_destroy_compile (cfg);
  1063| 		}
  1064| 	}
  1065| 	if (fail_count)
  1066| 		exit (1);
  1067| }
  1068| static void
  1069| compile_all_methods_thread_main (gpointer void_args)
  1070| {
  1071| 	CompileAllThreadArgs *args = (CompileAllThreadArgs*)void_args;
  1072| 	guint32 i;
  1073| 	for (i = 0; i < args->recompilation_times; ++i)
  1074| 		compile_all_methods_thread_main_inner (args);
  1075| }
  1076| static void
  1077| compile_all_methods (MonoAssembly *ass, int verbose, guint32 opts, guint32 recompilation_times)
  1078| {
  1079| 	ERROR_DECL (error);
  1080| 	CompileAllThreadArgs args;
  1081| 	args.ass = ass;
  1082| 	args.verbose = verbose;
  1083| 	args.opts = opts;
  1084| 	args.recompilation_times = recompilation_times;
  1085| 	/*
  1086| 	 * Need to create a mono thread since compilation might trigger
  1087| 	 * running of managed code.
  1088| 	 */
  1089| 	mono_thread_create_checked ((MonoThreadStart)compile_all_methods_thread_main, &args, error);
  1090| 	mono_error_assert_ok (error);
  1091| 	mono_thread_manage_internal ();
  1092| }
  1093| /**
  1094|  * mono_jit_exec:
  1095|  * \param assembly reference to an assembly
  1096|  * \param argc argument count
  1097|  * \param argv argument vector
  1098|  * Start execution of a program.
  1099|  */
  1100| int
  1101| mono_jit_exec (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[])
  1102| {
  1103| 	int rv;
  1104| 	MONO_ENTER_GC_UNSAFE;
  1105| 	rv = mono_jit_exec_internal (domain, assembly, argc, argv);
  1106| 	MONO_EXIT_GC_UNSAFE;
  1107| 	return rv;
  1108| }
  1109| int
  1110| mono_jit_exec_internal (MonoDomain *domain, MonoAssembly *assembly, int argc, char *argv[])
  1111| {
  1112| 	MONO_REQ_GC_UNSAFE_MODE;
  1113| 	ERROR_DECL (error);
  1114| 	MonoImage *image = mono_assembly_get_image_internal (assembly);
  1115|     if (!mono_runtime_run_module_cctor(image, error)) {
  1116|         g_print ("Failed to run module constructor due to %s\n", mono_error_get_message (error));
  1117|         return 1;
  1118|     }
  1119| 	MonoMethod *method;
  1120| 	guint32 entry = mono_image_get_entry_point (image);
  1121| 	if (!entry) {
  1122| 		g_print ("Assembly '%s' doesn't have an entry point.\n", mono_image_get_filename (image));
  1123| 		/* FIXME: remove this silly requirement. */
  1124| 		mono_environment_exitcode_set (1);
  1125| 		return 1;
  1126| 	}
  1127| 	method = mono_get_method_checked (image, entry, NULL, NULL, error);
  1128| 	if (method == NULL){
  1129| 		g_print ("The entry point method could not be loaded due to %s\n", mono_error_get_message (error));
  1130| 		mono_error_cleanup (error);
  1131| 		mono_environment_exitcode_set (1);
  1132| 		return 1;
  1133| 	}
  1134| 	if (mono_llvm_only) {
  1135| 		MonoObject *exc = NULL;
  1136| 		int res;
  1137| 		res = mono_runtime_try_run_main (method, argc, argv, &exc);
  1138| 		if (exc) {
  1139| 			mono_unhandled_exception_internal (exc);
  1140| 			mono_invoke_unhandled_exception_hook (exc);
  1141| 			g_assert_not_reached ();
  1142| 		}
  1143| 		return res;
  1144| 	} else {
  1145| 		int res = mono_runtime_run_main_checked (method, argc, argv, error);
  1146| 		if (!is_ok (error)) {
  1147| 			MonoException *ex = mono_error_convert_to_exception (error);
  1148| 			if (ex) {
  1149| 				mono_unhandled_exception_internal (&ex->object);
  1150| 				mono_invoke_unhandled_exception_hook (&ex->object);
  1151| 				g_assert_not_reached ();
  1152| 			}
  1153| 		}
  1154| 		return res;
  1155| 	}
  1156| }
  1157| typedef struct
  1158| {
  1159| 	MonoDomain *domain;
  1160| 	const char *file;
  1161| 	int argc;
  1162| 	char **argv;
  1163| 	guint32 opts;
  1164| 	char *aot_options;
  1165| } MainThreadArgs;
  1166| static void main_thread_handler (gpointer user_data)
  1167| {
  1168| 	MainThreadArgs *main_args = (MainThreadArgs *)user_data;
  1169| 	MonoAssembly *assembly;
  1170| 	if (mono_compile_aot) {
  1171| 		int i, res;
  1172| 		gpointer *aot_state = NULL;
  1173| 		/* Treat the other arguments as assemblies to compile too */
  1174| 		for (i = 0; i < main_args->argc; ++i) {
  1175| 			assembly = mono_domain_assembly_open_internal (mono_alc_get_default (), main_args->argv [i]);
  1176| 			if (!assembly) {
  1177| 				fprintf (stderr, "Can not open image %s\n", main_args->argv [i]);
  1178| 				exit (1);
  1179| 			}
  1180| 			/* Check that the assembly loaded matches the filename */
  1181| 			{
  1182| 				MonoImageOpenStatus status;
  1183| 				MonoImage *img;
  1184| 				img = mono_image_open (main_args->argv [i], &status);
  1185| 				if (img && g_strcasecmp (img->name, assembly->image->name)) {
  1186| 					fprintf (stderr, "Error: Loaded assembly '%s' doesn't match original file name '%s'. Set MONO_PATH to the assembly's location.\n", assembly->image->name, img->name);
  1187| 					exit (1);
  1188| 				}
  1189| 			}
  1190| 			res = mono_compile_assembly (assembly, main_args->opts, main_args->aot_options, &aot_state);
  1191| 			if (res != 0) {
  1192| 				fprintf (stderr, "AOT of image %s failed.\n", main_args->argv [i]);
  1193| 				exit (1);
  1194| 			}
  1195| 		}
  1196| 		if (aot_state) {
  1197| 			res = mono_compile_deferred_assemblies (main_args->opts, main_args->aot_options, &aot_state);
  1198| 			if (res != 0) {
  1199| 				fprintf (stderr, "AOT of mode-specific deferred assemblies failed.\n");
  1200| 				exit (1);
  1201| 			}
  1202| 		}
  1203| 	} else {
  1204| 		assembly = mono_domain_assembly_open_internal (mono_alc_get_default (), main_args->file);
  1205| 		if (!assembly){
  1206| 			fprintf (stderr, "Can not open image %s\n", main_args->file);
  1207| 			exit (1);
  1208| 		}
  1209| 		/*
  1210| 		 * This must be done in a thread managed by mono since it can invoke
  1211| 		 * managed code.
  1212| 		 */
  1213| 		if (main_args->opts & MONO_OPT_PRECOMP)
  1214| 			mono_precompile_assemblies ();
  1215| 		mono_jit_exec (main_args->domain, assembly, main_args->argc, main_args->argv);
  1216| 	}
  1217| }
  1218| static int
  1219| load_agent (MonoDomain *domain, char *desc)
  1220| {
  1221| 	ERROR_DECL (error);
  1222| 	char* col = strchr (desc, ':');
  1223| 	char *agent, *args;
  1224| 	MonoAssembly *agent_assembly;
  1225| 	MonoImage *image;
  1226| 	MonoMethod *method;
  1227| 	guint32 entry;
  1228| 	MonoArray *main_args;
  1229| 	gpointer pa [1];
  1230| 	MonoImageOpenStatus open_status;
  1231| 	if (col) {
  1232| 		agent = (char *)g_memdup (desc, GPTRDIFF_TO_UINT (col - desc + 1));
  1233| 		agent [col - desc] = '\0';
  1234| 		args = col + 1;
  1235| 	} else {
  1236| 		agent = g_strdup (desc);
  1237| 		args = NULL;
  1238| 	}
  1239| 	MonoAssemblyOpenRequest req;
  1240| 	mono_assembly_request_prepare_open (&req, mono_alc_get_default ());
  1241| 	agent_assembly = mono_assembly_request_open (agent, &req, &open_status);
  1242| 	if (!agent_assembly) {
  1243| 		fprintf (stderr, "Cannot open agent assembly '%s': %s.\n", agent, mono_image_strerror (open_status));
  1244| 		g_free (agent);
  1245| 		return 2;
  1246| 	}
  1247| 	/*
  1248| 	 * Can't use mono_jit_exec (), as it sets things which might confuse the
  1249| 	 * real Main method.
  1250| 	 */
  1251| 	image = mono_assembly_get_image_internal (agent_assembly);
  1252| 	entry = mono_image_get_entry_point (image);
  1253| 	if (!entry) {
  1254| 		g_print ("Assembly '%s' doesn't have an entry point.\n", mono_image_get_filename (image));
  1255| 		g_free (agent);
  1256| 		return 1;
  1257| 	}
  1258| 	method = mono_get_method_checked (image, entry, NULL, NULL, error);
  1259| 	if (method == NULL){
  1260| 		g_print ("The entry point method of assembly '%s' could not be loaded due to %s\n", agent, mono_error_get_message (error));
  1261| 		mono_error_cleanup (error);
  1262| 		g_free (agent);
  1263| 		return 1;
  1264| 	}
  1265| 	mono_thread_set_main (mono_thread_current ());
  1266| 	if (args) {
  1267| 		main_args = (MonoArray*)mono_array_new_checked (mono_defaults.string_class, 1, error);
  1268| 		if (main_args) {
  1269| 			MonoString *str = mono_string_new_checked (args, error);
  1270| 			if (str)
  1271| 				mono_array_set_internal (main_args, MonoString*, 0, str);
  1272| 		}
  1273| 	} else {
  1274| 		main_args = (MonoArray*)mono_array_new_checked (mono_defaults.string_class, 0, error);
  1275| 	}
  1276| 	if (!main_args) {
  1277| 		g_print ("Could not allocate array for main args of assembly '%s' due to %s\n", agent, mono_error_get_message (error));
  1278| 		mono_error_cleanup (error);
  1279| 		g_free (agent);
  1280| 		return 1;
  1281| 	}
  1282| 	pa [0] = main_args;
  1283| 	/* Pass NULL as 'exc' so unhandled exceptions abort the runtime */
  1284| 	mono_runtime_invoke_checked (method, NULL, pa, error);
  1285| 	if (!is_ok (error)) {
  1286| 		g_print ("The entry point method of assembly '%s' could not execute due to %s\n", agent, mono_error_get_message (error));
  1287| 		mono_error_cleanup (error);
  1288| 		g_free (agent);
  1289| 		return 1;
  1290| 	}
  1291| 	g_free (agent);
  1292| 	return 0;
  1293| }
  1294| static void
  1295| mini_usage_jitdeveloper (void)
  1296| {
  1297| 	int i;
  1298| 	fprintf (stdout,
  1299| 		 "Runtime and JIT debugging options:\n"
  1300| 		 "    --apply-bindings=FILE  Apply assembly bindings from FILE (only for AOT)\n"
  1301| 		 "    --breakonex            Inserts a breakpoint on exceptions\n"
  1302| 		 "    --break METHOD         Inserts a breakpoint at METHOD entry\n"
  1303| 		 "    --break-at-bb METHOD N Inserts a breakpoint in METHOD at BB N\n"
  1304| 		 "    --compile METHOD       Just compile METHOD in assembly\n"
  1305| 		 "    --compile-all=N        Compiles all the methods in the assembly multiple times (default: 1)\n"
  1306| 		 "    --ncompile N           Number of times to compile METHOD (default: 1)\n"
  1307| 		 "    --print-vtable         Print the vtable of all used classes\n"
  1308| 		 "    --regression           Runs the regression test contained in the assembly\n"
  1309| 		 "    --single-method=OPTS   Runs regressions with only one method optimized with OPTS at any time\n"
  1310| 		 "    --statfile FILE        Sets the stat file to FILE\n"
  1311| 		 "    --stats                Print statistics about the JIT operations\n"
  1312| 		 "    --inject-async-exc METHOD OFFSET Inject an asynchronous exception at METHOD\n"
  1313| 		 "    --verify-all           Run the verifier on all assemblies and methods\n"
  1314| 		 "    --full-aot             Avoid JITting any code\n"
  1315| 		 "    --llvmonly             Use LLVM compiled code only\n"
  1316| 		 "    --agent=ASSEMBLY[:ARG] Loads the specific agent assembly and executes its Main method with the given argument before loading the main assembly.\n"
  1317| 		 "    --no-x86-stack-align   Don't align stack on x86\n"
  1318| 		 "\n"
  1319| 		 "The options supported by MONO_DEBUG can also be passed on the command line.\n"
  1320| 		 "\n"
  1321| 		 "Other options:\n"
  1322| 		 "    --graph[=TYPE] METHOD  Draws a graph of the specified method:\n");
  1323| 	for (i = 0; i < G_N_ELEMENTS (graph_names); ++i) {
  1324| 		fprintf (stdout, "                           %-10s %s\n", graph_names [i].name, graph_names [i].desc);
  1325| 	}
  1326| }
  1327| static void
  1328| mini_usage_list_opt (void)
  1329| {
  1330| 	int i;
  1331| 	for (i = 0; i < G_N_ELEMENTS (opt_names); ++i)
  1332| 		fprintf (stdout, "                           %-10s %s\n", optflag_get_name (i), optflag_get_desc (i));
  1333| }
  1334| static void
  1335| mini_usage (void)
  1336| {
  1337| 	fprintf (stdout,
  1338| 		"Usage is: mono [options] program [program-options]\n"
  1339| 		"\n"
  1340| 		"Development:\n"
  1341| 		"    --aot[=<options>]      Compiles the assembly to native code\n"
  1342| 		"    --debug=ignore         Disable debugging support (on by default)\n"
  1343| 		"    --debug=[<options>]    Disable debugging support or enable debugging extras, use --help-debug for details\n"
  1344|  		"    --debugger-agent=options Enable the debugger agent\n"
  1345| 		"    --profile[=profiler]   Runs in profiling mode with the specified profiler module\n"
  1346| 		"    --trace[=EXPR]         Enable tracing, use --help-trace for details\n"
  1347| #ifdef __linux__
  1348| 		"    --jitmap               Output a jit method map to /tmp/perf-PID.map\n"
  1349| #endif
  1350| #ifdef ENABLE_JIT_DUMP
  1351| 		"    --jitdump              Output a jitdump file to /tmp/jit-PID.dump\n"
  1352| #endif
  1353| 		"    --help-devel           Shows more options available to developers\n"
  1354| 		"\n"
  1355| 		"Runtime:\n"
  1356| 		"    --config FILE          Loads FILE as the Mono config\n"
  1357| 		"    --verbose, -v          Increases the verbosity level\n"
  1358| 		"    --help, -h             Show usage information\n"
  1359| 		"    --version, -V          Show version information\n"
  1360| 		"    --version=number       Show version number\n"
  1361| 		"    --runtime=VERSION      Use the VERSION runtime, instead of autodetecting\n"
  1362| 		"    --optimize=OPT         Turns on or off a specific optimization\n"
  1363| 		"                           Use --list-opt to get a list of optimizations\n"
  1364| 		"    --attach=OPTIONS       Pass OPTIONS to the attach agent in the runtime.\n"
  1365| 		"                           Currently the only supported option is 'disable'.\n"
  1366| 		"    --llvm, --nollvm       Controls whenever the runtime uses LLVM to compile code.\n"
  1367| 	        "    --gc=[sgen,boehm]      Select SGen or Boehm GC (runs mono or mono-sgen)\n"
  1368| #ifdef TARGET_OSX
  1369| 		"    --arch=[32,64]         Select architecture (runs mono32 or mono64)\n"
  1370| #endif
  1371| #ifdef HOST_WIN32
  1372| 	        "    --mixed-mode           Enable mixed-mode image support.\n"
  1373| #endif
  1374| 		"    --handlers             Install custom handlers, use --help-handlers for details.\n"
  1375| 		"    --aot-path=PATH        List of additional directories to search for AOT images.\n"
  1376| 	  );
  1377| 	g_print ("\nOptions:\n");
  1378| 	mono_options_print_usage ();
  1379| }
  1380| static void
  1381| mini_trace_usage (void)
  1382| {
  1383| 	fprintf (stdout,
  1384| 		 "Tracing options:\n"
  1385| 		 "   --trace[=EXPR]        Trace every call, optional EXPR controls the scope\n"
  1386| 		 "\n"
  1387| 		 "EXPR is composed of:\n"
  1388| 		 "    all                  All assemblies\n"
  1389| 		 "    none                 No assemblies\n"
  1390| 		 "    program              Entry point assembly\n"
  1391| 		 "    assembly             Specifies an assembly\n"
  1392| 		 "    wrapper              All wrappers bridging native and managed code\n"
  1393| 		 "    M:Type:Method        Specifies a method\n"
  1394| 		 "    N:Namespace          Specifies a namespace\n"
  1395| 		 "    T:Type               Specifies a type\n"
  1396| 		 "    E:Type               Specifies stack traces for an exception type\n"
  1397| 		 "    EXPR                 Includes expression\n"
  1398| 		 "    -EXPR                Excludes expression\n"
  1399| 		 "    EXPR,EXPR            Multiple expressions\n"
  1400| 		 "    disabled             Don't print any output until toggled via SIGUSR2\n");
  1401| }
  1402| static void
  1403| mini_debug_usage (void)
  1404| {
  1405| 	fprintf (stdout,
  1406| 		 "Debugging options:\n"
  1407| 		 "   --debug[=OPTIONS]     Disable debugging support or enable debugging extras, optional OPTIONS is a comma\n"
  1408| 		 "                         separated list of options\n"
  1409| 		 "\n"
  1410| 		 "OPTIONS is composed of:\n"
  1411| 		 "    ignore               Disable debugging support (on by default).\n"
  1412| 		 "    casts                Enable more detailed InvalidCastException messages.\n"
  1413| 		 "    mdb-optimizations    Disable some JIT optimizations which are normally\n"
  1414| 		 "                         disabled when running inside the debugger.\n"
  1415| 		 "                         This is useful if you plan to attach to the running\n"
  1416| 		 "                         process with the debugger.\n");
  1417| }
  1418| #if defined(MONO_ARCH_ARCHITECTURE)
  1419| /* Redefine MONO_ARCHITECTURE to include more information */
  1420| #undef MONO_ARCHITECTURE
  1421| #define MONO_ARCHITECTURE MONO_ARCH_ARCHITECTURE
  1422| #endif
  1423| static char *
  1424| mono_get_version_info (void)
  1425| {
  1426| 	GString *output;
  1427| 	output = g_string_new ("");
  1428| #ifdef MONO_KEYWORD_THREAD
  1429| 	g_string_append_printf (output, "\tTLS:           __thread\n");
  1430| #else
  1431| 	g_string_append_printf (output, "\tTLS:           \n");
  1432| #endif /* MONO_KEYWORD_THREAD */
  1433| #ifdef MONO_ARCH_SIGSEGV_ON_ALTSTACK
  1434| 	g_string_append_printf (output, "\tSIGSEGV:       altstack\n");
  1435| #else
  1436| 	g_string_append_printf (output, "\tSIGSEGV:       normal\n");
  1437| #endif
  1438| 	g_string_append_printf (output, "\tArchitecture:  %s\n", MONO_ARCHITECTURE);
  1439| 	g_string_append_printf (output, "\tDisabled:      %s\n", DISABLED_FEATURES);
  1440| 	g_string_append_printf (output, "\tMisc:          ");
  1441| #ifdef MONO_SMALL_CONFIG
  1442| 	g_string_append_printf (output, "smallconfig ");
  1443| #endif
  1444| #if !defined(DISABLE_SDB)
  1445| 	g_string_append_printf (output, "softdebug ");
  1446| #endif
  1447| 	g_string_append_printf (output, "\n");
  1448| #ifndef DISABLE_INTERPRETER
  1449| 	g_string_append_printf (output, "\tInterpreter:   yes\n");
  1450| #else
  1451| 	g_string_append_printf (output, "\tInterpreter:   no\n");
  1452| #endif
  1453| #ifdef MONO_ARCH_LLVM_SUPPORTED
  1454| #ifdef ENABLE_LLVM
  1455| 	g_string_append_printf (output, "\tLLVM:          yes(%d)\n", LLVM_API_VERSION);
  1456| #else
  1457| 	g_string_append_printf (output, "\tLLVM:          supported, not enabled.\n");
  1458| #endif
  1459| #endif
  1460| 	mono_threads_suspend_policy_init ();
  1461| 	g_string_append_printf (output, "\tSuspend:       %s\n", mono_threads_suspend_policy_name (mono_threads_suspend_policy ()));
  1462| 	return g_string_free (output, FALSE);
  1463| }
  1464| #ifndef MONO_ARCH_AOT_SUPPORTED
  1465| #define error_if_aot_unsupported() do {fprintf (stderr, "AOT compilation is not supported on this platform.\n"); exit (1);} while (0)
  1466| #else
  1467| #define error_if_aot_unsupported()
  1468| #endif
  1469| static gboolean enable_debugging;
  1470| static void
  1471| enable_runtime_stats (void)
  1472| {
  1473| 	mono_counters_enable (-1);
  1474| 	mono_atomic_store_bool (&mono_stats.enabled, TRUE);
  1475| 	mono_atomic_store_bool (&mono_jit_stats.enabled, TRUE);
  1476| }
  1477| static MonoMethodDesc *
  1478| parse_qualified_method_name (char *method_name)
  1479| {
  1480| 	if (strlen (method_name) == 0) {
  1481| 		g_printerr ("Couldn't parse empty method name.");
  1482| 		exit (1);
  1483| 	}
  1484| 	MonoMethodDesc *result = mono_method_desc_new (method_name, TRUE);
  1485| 	if (!result) {
  1486| 		g_printerr ("Couldn't parse method name: %s\n", method_name);
  1487| 		exit (1);
  1488| 	}
  1489| 	return result;
  1490| }
  1491| /**
  1492|  * mono_jit_parse_options:
  1493|  *
  1494|  * Process the command line options in \p argv as done by the runtime executable.
  1495|  * This should be called before \c mono_jit_init.
  1496|  */
  1497| void
  1498| mono_jit_parse_options (int argc, char * argv[])
  1499| {
  1500| 	ERROR_DECL (error);
  1501| 	int i;
  1502| 	char *trace_options = NULL;
  1503| 	int mini_verbose_level = 0;
  1504| 	guint32 opt;
  1505| 	/* Make a copy since mono_options_parse_options () modifies argv */
  1506| 	char **copy_argv = g_new0 (char*, argc);
  1507| 	memcpy (copy_argv, argv, sizeof (char*) * argc);
  1508| 	argv = copy_argv;
  1509| 	mono_options_parse_options ((const char**)argv, argc, &argc, error);
  1510| 	if (!is_ok (error)) {
  1511| 		g_printerr ("%s", mono_error_get_message (error));
  1512| 		mono_error_cleanup (error);
  1513| 	}
  1514| 	/*
  1515| 	 * Some options have no effect here, since they influence the behavior of
  1516| 	 * mono_main ().
  1517| 	 */
  1518| 	opt = mono_parse_default_optimizations (NULL);
  1519| 	/* FIXME: Avoid code duplication */
  1520| 	for (i = 0; i < argc; ++i) {
  1521| 		if (argv [i] [0] != '-')
  1522| 			break;
  1523| 		if (strncmp (argv [i], "--debugger-agent=", 17) == 0) {
  1524| 			MonoDebugOptions *debug_opt = mini_get_debug_options ();
  1525| 			mono_debugger_agent_parse_options (g_strdup (argv [i] + 17));
  1526| 			debug_opt ->mdb_optimizations = TRUE;
  1527| 			enable_debugging = TRUE;
  1528| 		} else if (!strcmp (argv [i], "--soft-breakpoints")) {
  1529| 			MonoDebugOptions *debug_opt  = mini_get_debug_options ();
  1530| 			debug_opt ->soft_breakpoints = TRUE;
  1531| 			debug_opt ->explicit_null_checks = TRUE;
  1532| 		} else if (strncmp (argv [i], "--optimize=", 11) == 0) {
  1533| 			opt = parse_optimizations (opt, argv [i] + 11, TRUE);
  1534| 			mono_set_optimizations (opt);
  1535| 		} else if (strncmp (argv [i], "-O=", 3) == 0) {
  1536| 			opt = parse_optimizations (opt, argv [i] + 3, TRUE);
  1537| 			mono_set_optimizations (opt);
  1538| 		} else if (strcmp (argv [i], "--trace") == 0) {
  1539| 			trace_options = (char*)"";
  1540| 		} else if (strncmp (argv [i], "--trace=", 8) == 0) {
  1541| 			trace_options = &argv [i][8];
  1542| 		} else if (strcmp (argv [i], "--verbose") == 0 || strcmp (argv [i], "-v") == 0) {
  1543| 			mini_verbose_level++;
  1544| 		} else if (strcmp (argv [i], "--breakonex") == 0) {
  1545| 			MonoDebugOptions *debug_opt = mini_get_debug_options ();
  1546| 			debug_opt->break_on_exc = TRUE;
  1547| 		} else if (strcmp (argv [i], "--stats") == 0) {
  1548| 			enable_runtime_stats ();
  1549| 		} else if (strncmp (argv [i], "--stats=", 8) == 0) {
  1550| 			enable_runtime_stats ();
  1551| 			if (mono_stats_method_desc)
  1552| 				g_free (mono_stats_method_desc);
  1553| 			mono_stats_method_desc = parse_qualified_method_name (argv [i] + 8);
  1554| 		} else if (strcmp (argv [i], "--break") == 0) {
  1555| 			if (i+1 >= argc){
  1556| 				fprintf (stderr, "Missing method name in --break command line option\n");
  1557| 				exit (1);
  1558| 			}
  1559| 			if (!mono_debugger_insert_breakpoint (argv [++i], FALSE))
  1560| 				fprintf (stderr, "Error: invalid method name '%s'\n", argv [i]);
  1561| 		} else if (strncmp (argv[i], "--gc-params=", 12) == 0) {
  1562| 			mono_gc_params_set (argv[i] + 12);
  1563| 		} else if (strncmp (argv[i], "--gc-debug=", 11) == 0) {
  1564| 			mono_gc_debug_set (argv[i] + 11);
  1565| 		} else if (strcmp (argv [i], "--llvm") == 0) {
  1566| #ifndef MONO_ARCH_LLVM_SUPPORTED
  1567| 			fprintf (stderr, "Mono Warning: --llvm not supported on this platform.\n");
  1568| #elif !defined(ENABLE_LLVM)
  1569| 			fprintf (stderr, "Mono Warning: --llvm not enabled in this runtime.\n");
  1570| #else
  1571| 			mono_use_llvm = TRUE;
  1572| #endif
  1573| 		} else if (strcmp (argv [i], "--profile") == 0) {
  1574| 			mini_add_profiler_argument (NULL);
  1575| 		} else if (strncmp (argv [i], "--profile=", 10) == 0) {
  1576| 			mini_add_profiler_argument (argv [i] + 10);
  1577| 		} else if (argv [i][0] == '-' && argv [i][1] == '-' && mini_parse_debug_option (argv [i] + 2)) {
  1578| 		} else {
  1579| 			fprintf (stderr, "Unsupported command line option: '%s'\n", argv [i]);
  1580| 			exit (1);
  1581| 		}
  1582| 	}
  1583| 	if (trace_options != NULL) {
  1584| 		/*
  1585| 		 * Need to call this before mini_init () so we can trace methods
  1586| 		 * compiled there too.
  1587| 		 */
  1588| 		mono_jit_trace_calls = mono_trace_set_options (trace_options);
  1589| 		if (mono_jit_trace_calls == NULL)
  1590| 			exit (1);
  1591| 	}
  1592| 	if (mini_verbose_level)
  1593| 		mono_set_verbose_level (mini_verbose_level);
  1594| 	/* Free the copy */
  1595| 	g_free (argv);
  1596| }
  1597| static void
  1598| mono_set_use_smp (int use_smp)
  1599| {
  1600| #if HAVE_SCHED_SETAFFINITY
  1601| 	if (!use_smp) {
  1602| 		unsigned long proc_mask = 1;
  1603| 		sched_setaffinity (getpid(), sizeof (unsigned long), (const cpu_set_t *)&proc_mask);
  1604| 	}
  1605| #endif
  1606| }
  1607| static void
  1608| switch_gc (char* argv[], const char* target_gc)
  1609| {
  1610| 	GString *path;
  1611| 	if (!strcmp (mono_gc_get_gc_name (), target_gc)) {
  1612| 		return;
  1613| 	}
  1614| 	path = g_string_new (argv [0]);
  1615| 	/*Running mono without any argument*/
  1616| 	if (strstr (argv [0], "-sgen"))
  1617| 		g_string_truncate (path, path->len - 5);
  1618| 	else if (strstr (argv [0], "-boehm"))
  1619| 		g_string_truncate (path, path->len - 6);
  1620| 	g_string_append_c (path, '-');
  1621| 	g_string_append (path, target_gc);
  1622| #ifdef HAVE_EXECVP
  1623| 	execvp (path->str, argv);
  1624| 	fprintf (stderr, "Error: Failed to switch to %s gc. mono-%s is not installed.\n", target_gc, target_gc);
  1625| #else
  1626| 	fprintf (stderr, "Error: --gc=<NAME> option not supported on this platform.\n");
  1627| #endif
  1628| }
  1629| #ifdef TARGET_OSX
  1630| /*
  1631|  * tries to increase the minimum number of files, if the number is below 1024
  1632|  */
  1633| static void
  1634| darwin_change_default_file_handles ()
  1635| {
  1636| 	struct rlimit limit;
  1637| 	if (getrlimit (RLIMIT_NOFILE, &limit) == 0){
  1638| 		if (limit.rlim_cur < 1024){
  1639| 			limit.rlim_cur = MAX(1024,limit.rlim_cur);
  1640| 			setrlimit (RLIMIT_NOFILE, &limit);
  1641| 		}
  1642| 	}
  1643| }
  1644| static void
  1645| switch_arch (char* argv[], const char* target_arch)
  1646| {
  1647| 	GString *path;
  1648| 	gsize arch_offset;
  1649| 	if ((strcmp (target_arch, "32") == 0 && strcmp (MONO_ARCHITECTURE, "x86") == 0) ||
  1650| 		(strcmp (target_arch, "64") == 0 && strcmp (MONO_ARCHITECTURE, "amd64") == 0)) {
  1651| 		return; /* matching arch loaded */
  1652| 	}
  1653| 	path = g_string_new (argv [0]);
  1654| 	arch_offset = path->len -2; /* last two characters */
  1655| 	/* Remove arch suffix if present */
  1656| 	if (strstr (&path->str[arch_offset], "32") || strstr (&path->str[arch_offset], "64")) {
  1657| 		g_string_truncate (path, arch_offset);
  1658| 	}
  1659| 	g_string_append (path, target_arch);
  1660| 	if (execvp (path->str, argv) < 0) {
  1661| 		fprintf (stderr, "Error: --arch=%s Failed to switch to '%s'.\n", target_arch, path->str);
  1662| 		exit (1);
  1663| 	}
  1664| }
  1665| #endif
  1666| #define MONO_HANDLERS_ARGUMENT "--handlers="
  1667| #define MONO_HANDLERS_ARGUMENT_LEN STRING_LENGTH(MONO_HANDLERS_ARGUMENT)
  1668| static void
  1669| apply_root_domain_configuration_file_bindings (MonoDomain *domain, char *root_domain_configuration_file)
  1670| {
  1671| 	g_assert_not_reached ();
  1672| }
  1673| static void
  1674| mono_check_interp_supported (void)
  1675| {
  1676| #ifdef MONO_CROSS_COMPILE
  1677| 	g_error ("--interpreter on cross-compile runtimes not supported\n");
  1678| #endif
  1679| #ifndef MONO_ARCH_INTERPRETER_SUPPORTED
  1680| 	g_error ("--interpreter not supported on this architecture.\n");
  1681| #endif
  1682| }
  1683| static int
  1684| mono_exec_regression_internal (int verbose_level, int count, char *images [], gboolean single_method)
  1685| {
  1686| 	mono_do_single_method_regression = single_method;
  1687| 	if (mono_use_interpreter) {
  1688| 		if (mono_interp_regression_list (verbose_level, count, images)) {
  1689| 			g_print ("Regression ERRORS!\n");
  1690| 			return 1;
  1691| 		}
  1692| 		return 0;
  1693| 	}
  1694| 	if (mini_regression_list (verbose_level, count, images)) {
  1695| 		g_print ("Regression ERRORS!\n");
  1696| 		return 1;
  1697| 	}
  1698| 	return 0;
  1699| }
  1700| /**
  1701|  * Returns TRUE for success, FALSE for failure.
  1702|  */
  1703| gboolean
  1704| mono_regression_test_step (int verbose_level, const char *image, const char *method_name)
  1705| {
  1706| 	if (method_name) {
  1707| 	} else {
  1708| 		do_regression_retries = TRUE;
  1709| 	}
  1710| 	char *images[] = {
  1711| 		(char*)image,
  1712| 		NULL
  1713| 	};
  1714| 	return mono_exec_regression_internal (verbose_level, 1, images, FALSE) == 0;
  1715| }
  1716| #ifdef ENABLE_ICALL_SYMBOL_MAP
  1717| /* Print the icall table as JSON */
  1718| static void
  1719| print_icall_table (void)
  1720| {
  1721| 	printf ("[\n{ \"klass\": \"\", \"icalls\": [");
  1722| #define NOHANDLES(inner) inner
  1723| #define HANDLES(id, name, func, ...)	printf ("\t,{ \"name\": \"%s\", \"func\": \"%s_raw\", \"handles\": true }\n", name, #func);
  1724| #define HANDLES_REUSE_WRAPPER		HANDLES
  1725| #define MONO_HANDLE_REGISTER_ICALL(...) /* nothing  */
  1726| #define ICALL_TYPE(id,name,first) printf ("]},\n { \"klass\":\"%s\", \"icalls\": [{} ", name);
  1727| #define ICALL(id,name,func) printf ("\t,{ \"name\": \"%s\", \"func\": \"%s\", \"handles\": false }\n", name, #func);
  1728| #include <mono/metadata/icall-def.h>
  1729| 	printf ("]}\n]\n");
  1730| }
  1731| #endif
  1732| /**
  1733|  * mono_main:
  1734|  * \param argc number of arguments in the argv array
  1735|  * \param argv array of strings containing the startup arguments
  1736|  * Launches the Mono JIT engine and parses all the command line options
  1737|  * in the same way that the mono command line VM would.
  1738|  */
  1739| int
  1740| mono_main (int argc, char* argv[])
  1741| {
  1742| 	MainThreadArgs main_args;
  1743| 	MonoAssembly *assembly;
  1744| 	MonoMethodDesc *desc;
  1745| 	MonoMethod *method;
  1746| 	MonoDomain *domain;
  1747| 	MonoImageOpenStatus open_status;
  1748| 	const char* aname, *mname = NULL;
  1749| 	int i;
  1750| #ifndef DISABLE_JIT
  1751| 	int count = 1;
  1752| 	MonoGraphOptions mono_graph_options = (MonoGraphOptions)0;
  1753| #endif
  1754| 	guint32 opt, action = DO_EXEC, recompilation_times = 1;
  1755| 	int mini_verbose_level = 0;
  1756| 	char *trace_options = NULL;
  1757| 	char *aot_options = NULL;
  1758| 	GPtrArray *agents = NULL;
  1759| 	char *extra_bindings_config_file = NULL;
  1760| #ifdef MONO_JIT_INFO_TABLE_TEST
  1761| 	int test_jit_info_table = FALSE;
  1762| #endif
  1763| #ifdef HOST_WIN32
  1764| 	int mixed_mode = FALSE;
  1765| #endif
  1766| 	ERROR_DECL (error);
  1767| #ifdef MOONLIGHT
  1768| #ifndef HOST_WIN32
  1769| 	/* stdout defaults to block buffering if it's not writing to a terminal, which
  1770| 	 * happens with our test harness: we redirect stdout to capture it. Force line
  1771| 	 * buffering in all cases. */
  1772| 	setlinebuf (stdout);
  1773| #endif
  1774| #endif
  1775| 	setlocale (LC_ALL, "");
  1776| #if TARGET_OSX
  1777| 	darwin_change_default_file_handles ();
  1778| #endif
  1779| 	if (g_hasenv ("MONO_NO_SMP"))
  1780| 		mono_set_use_smp (FALSE);
  1781| 	g_log_set_always_fatal (G_LOG_LEVEL_ERROR);
  1782| 	g_log_set_fatal_mask (G_LOG_DOMAIN, G_LOG_LEVEL_ERROR);
  1783| 	opt = mono_parse_default_optimizations (NULL);
  1784| 	enable_debugging = TRUE;
  1785| 	mono_options_parse_options ((const char**)argv + 1, argc - 1, &argc, error);
  1786| 	argc ++;
  1787| 	if (!is_ok (error)) {
  1788| 		g_printerr ("%s", mono_error_get_message (error));
  1789| 		mono_error_cleanup (error);
  1790| 		return 1;
  1791| 	}
  1792| 	for (i = 1; i < argc; ++i) {
  1793| 		if (argv [i] [0] != '-')
  1794| 			break;
  1795| 		if (strcmp (argv [i], "--regression") == 0) {
  1796| 			action = DO_REGRESSION;
  1797| 		} else if (strncmp (argv [i], "--single-method=", 16) == 0) {
  1798| 			char *full_opts = g_strdup_printf ("-all,%s", argv [i] + 16);
  1799| 			action = DO_SINGLE_METHOD_REGRESSION;
  1800| 			mono_single_method_regression_opt = parse_optimizations (opt, full_opts, TRUE);
  1801| 			g_free (full_opts);
  1802| 		} else if (strcmp (argv [i], "--verbose") == 0 || strcmp (argv [i], "-v") == 0) {
  1803| 			mini_verbose_level++;
  1804| 		} else if (strcmp (argv [i], "--version=number") == 0) {
  1805| 			g_print ("%s\n", VERSION);
  1806| 			return 0;
  1807| 		} else if (strcmp (argv [i], "--version") == 0 || strcmp (argv [i], "-V") == 0) {
  1808| 			char *build = mono_get_runtime_build_info ();
  1809| 			char *gc_descr;
  1810| 			g_print ("Mono JIT compiler version %s\nCopyright (C) Novell, Inc, Xamarin Inc and Contributors. www.mono-project.com\n", build);
  1811| 			g_free (build);
  1812| 			char *info = mono_get_version_info ();
  1813| 			g_print (info);
  1814| 			g_free (info);
  1815| 			gc_descr = mono_gc_get_description ();
  1816| 			g_print ("\tGC:            %s\n", gc_descr);
  1817| 			g_free (gc_descr);
  1818| 			return 0;
  1819| 		} else if (strcmp (argv [i], "--help") == 0 || strcmp (argv [i], "-h") == 0) {
  1820| 			mini_usage ();
  1821| 			return 0;
  1822| 		} else if (strcmp (argv [i], "--help-trace") == 0){
  1823| 			mini_trace_usage ();
  1824| 			return 0;
  1825| 		} else if (strcmp (argv [i], "--help-devel") == 0){
  1826| 			mini_usage_jitdeveloper ();
  1827| 			return 0;
  1828| 		} else if (strcmp (argv [i], "--help-debug") == 0){
  1829| 			mini_debug_usage ();
  1830| 			return 0;
  1831| 		} else if (strcmp (argv [i], "--list-opt") == 0){
  1832| 			mini_usage_list_opt ();
  1833| 			return 0;
  1834| 		} else if (strncmp (argv [i], "--statfile", 10) == 0) {
  1835| 			if (i + 1 >= argc){
  1836| 				fprintf (stderr, "error: --statfile requires a filename argument\n");
  1837| 				return 1;
  1838| 			}
  1839| 			mini_stats_fd = fopen (argv [++i], "w+");
  1840| 		} else if (strncmp (argv [i], "--optimize=", 11) == 0) {
  1841| 			opt = parse_optimizations (opt, argv [i] + 11, TRUE);
  1842| 		} else if (strncmp (argv [i], "-O=", 3) == 0) {
  1843| 			opt = parse_optimizations (opt, argv [i] + 3, TRUE);
  1844| 		} else if (strncmp (argv [i], "--bisect=", 9) == 0) {
  1845| 			char *param = argv [i] + 9;
  1846| 			char *sep = strchr (param, ':');
  1847| 			if (!sep) {
  1848| 				fprintf (stderr, "Error: --bisect requires OPT:FILENAME\n");
  1849| 				return 1;
  1850| 			}
  1851| 			char *bisect_opt_string = g_strndup (param, sep - param);
  1852| 			guint32 bisect_opt = parse_optimizations (0, bisect_opt_string, FALSE);
  1853| 			g_free (bisect_opt_string);
  1854| 			mono_set_bisect_methods (bisect_opt, sep + 1);
  1855| 		} else if (strcmp (argv [i], "--gc=sgen") == 0) {
  1856| 			switch_gc (argv, "sgen");
  1857| 		} else if (strcmp (argv [i], "--gc=boehm") == 0) {
  1858| 			switch_gc (argv, "boehm");
  1859| 		} else if (strncmp (argv[i], "--gc-params=", 12) == 0) {
  1860| 			mono_gc_params_set (argv[i] + 12);
  1861| 		} else if (strncmp (argv[i], "--gc-debug=", 11) == 0) {
  1862| 			mono_gc_debug_set (argv[i] + 11);
  1863| 		}
  1864| #ifdef TARGET_OSX
  1865| 		else if (strcmp (argv [i], "--arch=32") == 0) {
  1866| 			switch_arch (argv, "32");
  1867| 		} else if (strcmp (argv [i], "--arch=64") == 0) {
  1868| 			switch_arch (argv, "64");
  1869| 		}
  1870| #endif
  1871| 		else if (strcmp (argv [i], "--config") == 0) {
  1872| 			if (i +1 >= argc){
  1873| 				fprintf (stderr, "error: --config requires a filename argument\n");
  1874| 				return 1;
  1875| 			}
  1876| 			++i;
  1877| #ifdef HOST_WIN32
  1878| 		} else if (strcmp (argv [i], "--mixed-mode") == 0) {
  1879| 			mixed_mode = TRUE;
  1880| #endif
  1881| #ifndef DISABLE_JIT
  1882| 		} else if (strcmp (argv [i], "--ncompile") == 0) {
  1883| 			if (i + 1 >= argc){
  1884| 				fprintf (stderr, "error: --ncompile requires an argument\n");
  1885| 				return 1;
  1886| 			}
  1887| 			count = atoi (argv [++i]);
  1888| 			action = DO_BENCH;
  1889| #endif
  1890| 		} else if (strcmp (argv [i], "--trace") == 0) {
  1891| 			trace_options = (char*)"";
  1892| 		} else if (strncmp (argv [i], "--trace=", 8) == 0) {
  1893| 			trace_options = &argv [i][8];
  1894| 		} else if (strcmp (argv [i], "--breakonex") == 0) {
  1895| 			MonoDebugOptions *debug_opt = mini_get_debug_options ();
  1896| 			debug_opt->break_on_exc = TRUE;
  1897| 		} else if (strcmp (argv [i], "--break") == 0) {
  1898| 			if (i+1 >= argc){
  1899| 				fprintf (stderr, "Missing method name in --break command line option\n");
  1900| 				return 1;
  1901| 			}
  1902| 			if (!mono_debugger_insert_breakpoint (argv [++i], FALSE))
  1903| 				fprintf (stderr, "Error: invalid method name '%s'\n", argv [i]);
  1904| 		} else if (strcmp (argv [i], "--break-at-bb") == 0) {
  1905| 			if (i + 2 >= argc) {
  1906| 				fprintf (stderr, "Missing method name or bb num in --break-at-bb command line option.");
  1907| 				return 1;
  1908| 			}
  1909| 			mono_break_at_bb_method = mono_method_desc_new (argv [++i], TRUE);
  1910| 			if (mono_break_at_bb_method == NULL) {
  1911| 				fprintf (stderr, "Method name is in a bad format in --break-at-bb command line option.");
  1912| 				return 1;
  1913| 			}
  1914| 			mono_break_at_bb_bb_num = atoi (argv [++i]);
  1915| 		} else if (strcmp (argv [i], "--inject-async-exc") == 0) {
  1916| 			if (i + 2 >= argc) {
  1917| 				fprintf (stderr, "Missing method name or position in --inject-async-exc command line option\n");
  1918| 				return 1;
  1919| 			}
  1920| 			mono_inject_async_exc_method = mono_method_desc_new (argv [++i], TRUE);
  1921| 			if (mono_inject_async_exc_method == NULL) {
  1922| 				fprintf (stderr, "Method name is in a bad format in --inject-async-exc command line option\n");
  1923| 				return 1;
  1924| 			}
  1925| 			mono_inject_async_exc_pos = atoi (argv [++i]);
  1926| 		} else if (strcmp (argv [i], "--verify-all") == 0) {
  1927| 			g_warning ("--verify-all is obsolete, ignoring");
  1928| 		} else if (strcmp (argv [i], "--full-aot") == 0) {
  1929| 			mono_jit_set_aot_mode (MONO_AOT_MODE_FULL);
  1930| 		} else if (strcmp (argv [i], "--hybrid-aot") == 0) {
  1931| 			mono_jit_set_aot_mode (MONO_AOT_MODE_HYBRID);
  1932| 		} else if (strcmp (argv [i], "--full-aot-interp") == 0) {
  1933| 			mono_jit_set_aot_mode (MONO_AOT_MODE_INTERP);
  1934| 		} else if (strcmp (argv [i], "--llvmonly") == 0) {
  1935| 			/* Same as llvmonly-interp */
  1936| 			mono_jit_set_aot_mode (MONO_AOT_MODE_LLVMONLY_INTERP);
  1937| 		} else if (strcmp (argv [i], "--llvmonly-interp") == 0) {
  1938| 			mono_jit_set_aot_mode (MONO_AOT_MODE_LLVMONLY_INTERP);
  1939| 		} else if (strcmp (argv [i], "--print-vtable") == 0) {
  1940| 			mono_print_vtable = TRUE;
  1941| 		} else if (strcmp (argv [i], "--stats") == 0) {
  1942| 			enable_runtime_stats ();
  1943| 		} else if (strncmp (argv [i], "--stats=", 8) == 0) {
  1944| 			enable_runtime_stats ();
  1945| 			if (mono_stats_method_desc)
  1946| 				g_free (mono_stats_method_desc);
  1947| 			mono_stats_method_desc = parse_qualified_method_name (argv [i] + 8);
  1948| #ifndef DISABLE_AOT
  1949| 		} else if (strcmp (argv [i], "--aot") == 0) {
  1950| 			error_if_aot_unsupported ();
  1951| 			mono_compile_aot = TRUE;
  1952| 		} else if (strncmp (argv [i], "--aot=", 6) == 0) {
  1953| 			error_if_aot_unsupported ();
  1954| 			mono_compile_aot = TRUE;
  1955| 			if (aot_options) {
  1956| 				char *tmp = g_strdup_printf ("%s,%s", aot_options, &argv [i][6]);
  1957| 				g_free (aot_options);
  1958| 				aot_options = tmp;
  1959| 			} else {
  1960| 				aot_options = g_strdup (&argv [i][6]);
  1961| 			}
  1962| #endif
  1963| 		} else if (strncmp (argv [i], "--apply-bindings=", 17) == 0) {
  1964| 			extra_bindings_config_file = &argv[i][17];
  1965| 		} else if (strncmp (argv [i], "--aot-path=", 11) == 0) {
  1966| 			char **splitted;
  1967| 			splitted = g_strsplit (argv [i] + 11, G_SEARCHPATH_SEPARATOR_S, 1000);
  1968| 			while (*splitted) {
  1969| 				char *tmp = *splitted;
  1970| 				mono_aot_paths = g_list_append (mono_aot_paths, g_strdup (tmp));
  1971| 				g_free (tmp);
  1972| 				splitted++;
  1973| 			}
  1974| 		} else if (strncmp (argv [i], "--compile-all=", 14) == 0) {
  1975| 			action = DO_COMPILE;
  1976| 			recompilation_times = atoi (argv [i] + 14);
  1977| 		} else if (strcmp (argv [i], "--compile-all") == 0) {
  1978| 			action = DO_COMPILE;
  1979| 		} else if (strncmp (argv [i], "--runtime=", 10) == 0) {
  1980| 		} else if (strcmp (argv [i], "--jitmap") == 0) {
  1981| 			mono_enable_jit_map ();
  1982| #ifdef ENABLE_JIT_DUMP
  1983| 		} else if (strcmp (argv [i], "--jitdump") == 0) {
  1984| 			mono_enable_jit_dump ();
  1985| #endif
  1986| 		} else if (strcmp (argv [i], "--profile") == 0) {
  1987| 			mini_add_profiler_argument (NULL);
  1988| 		} else if (strncmp (argv [i], "--profile=", 10) == 0) {
  1989| 			mini_add_profiler_argument (argv [i] + 10);
  1990| 		} else if (strncmp (argv [i], "--agent=", 8) == 0) {
  1991| 			if (agents == NULL)
  1992| 				agents = g_ptr_array_new ();
  1993| 			g_ptr_array_add (agents, argv [i] + 8);
  1994| 		} else if (strncmp (argv [i], "--attach=", 9) == 0) {
  1995| 			g_warning ("--attach= option no longer supported.");
  1996| 		} else if (strcmp (argv [i], "--compile") == 0) {
  1997| 			if (i + 1 >= argc){
  1998| 				fprintf (stderr, "error: --compile option requires a method name argument\n");
  1999| 				return 1;
  2000| 			}
  2001| 			mname = argv [++i];
  2002| 			action = DO_BENCH;
  2003| #ifndef DISABLE_JIT
  2004| 		} else if (strncmp (argv [i], "--graph=", 8) == 0) {
  2005| 			if (i + 1 >= argc){
  2006| 				fprintf (stderr, "error: --graph option requires a method name argument\n");
  2007| 				return 1;
  2008| 			}
  2009| 			mono_graph_options = mono_parse_graph_options (argv [i] + 8);
  2010| 			mname = argv [++i];
  2011| 			action = DO_DRAW;
  2012| 		} else if (strcmp (argv [i], "--graph") == 0) {
  2013| 			if (i + 1 >= argc){
  2014| 				fprintf (stderr, "error: --graph option requires a method name argument\n");
  2015| 				return 1;
  2016| 			}
  2017| 			mname = argv [++i];
  2018| 			mono_graph_options = MONO_GRAPH_CFG;
  2019| 			action = DO_DRAW;
  2020| #endif
  2021| 		} else if (strcmp (argv [i], "--debug") == 0) {
  2022| 			enable_debugging = TRUE;
  2023| 		} else if (strncmp (argv [i], "--debug=", 8) == 0) {
  2024| 			enable_debugging = TRUE;
  2025| 			if (!parse_debug_options (argv [i] + 8))
  2026| 				return 1;
  2027| 			MonoDebugOptions *debug_opt = mini_get_debug_options ();
  2028| 			if (!debug_opt->enabled) {
  2029| 				enable_debugging = FALSE;
  2030| 			}
  2031| 		} else if (strncmp (argv [i], "--debugger-agent=", 17) == 0) {
  2032| 			MonoDebugOptions *debug_opt = mini_get_debug_options ();
  2033| 			mono_debugger_agent_parse_options (g_strdup (argv [i] + 17));
  2034| 			debug_opt->mdb_optimizations = TRUE;
  2035| 			enable_debugging = TRUE;
  2036| 		} else if (strcmp (argv [i], "--security") == 0) {
  2037| 			fprintf (stderr, "error: --security is obsolete.");
  2038| 			return 1;
  2039| 		} else if (strncmp (argv [i], "--security=", 11) == 0) {
  2040| 			if (strcmp (argv [i] + 11, "core-clr") == 0) {
  2041| 				fprintf (stderr, "error: --security=core-clr is obsolete.");
  2042| 				return 1;
  2043| 			} else if (strcmp (argv [i] + 11, "core-clr-test") == 0) {
  2044| 				fprintf (stderr, "error: --security=core-clr-test is obsolete.");
  2045| 				return 1;
  2046| 			} else if (strcmp (argv [i] + 11, "cas") == 0) {
  2047| 				fprintf (stderr, "error: --security=cas is obsolete.");
  2048| 				return 1;
  2049| 			} else if (strcmp (argv [i] + 11, "validil") == 0) {
  2050| 				fprintf (stderr, "error: --security=validil is obsolete.");
  2051| 				return 1;
  2052| 			} else if (strcmp (argv [i] + 11, "verifiable") == 0) {
  2053| 				fprintf (stderr, "error: --securty=verifiable is obsolete.");
  2054| 				return 1;
  2055| 			} else {
  2056| 				fprintf (stderr, "error: --security= option has invalid argument (cas, core-clr, verifiable or validil)\n");
  2057| 				return 1;
  2058| 			}
  2059| 		} else if (strcmp (argv [i], "--desktop") == 0) {
  2060| 			mono_gc_set_desktop_mode ();
  2061| 			/* Put more desktop-specific optimizations here */
  2062| 		} else if (strcmp (argv [i], "--server") == 0){
  2063| 		} else if (strcmp (argv [i], "--inside-mdb") == 0) {
  2064| 			action = DO_DEBUGGER;
  2065| 		} else if (strncmp (argv [i], "--wapi=", 7) == 0) {
  2066| 			fprintf (stderr, "--wapi= option no longer supported\n.");
  2067| 			return 1;
  2068| 		} else if (strcmp (argv [i], "--no-x86-stack-align") == 0) {
  2069| 			mono_do_x86_stack_align = FALSE;
  2070| #ifdef MONO_JIT_INFO_TABLE_TEST
  2071| 		} else if (strcmp (argv [i], "--test-jit-info-table") == 0) {
  2072| 			test_jit_info_table = TRUE;
  2073| #endif
  2074| 		} else if (strcmp (argv [i], "--llvm") == 0) {
  2075| #ifndef MONO_ARCH_LLVM_SUPPORTED
  2076| 			fprintf (stderr, "Mono Warning: --llvm not supported on this platform.\n");
  2077| #elif !defined(ENABLE_LLVM)
  2078| 			fprintf (stderr, "Mono Warning: --llvm not enabled in this runtime.\n");
  2079| #else
  2080| 			mono_use_llvm = TRUE;
  2081| #endif
  2082| 		} else if (strcmp (argv [i], "--nollvm") == 0){
  2083| 			mono_use_llvm = FALSE;
  2084| 		} else if (strcmp (argv [i], "--ffast-math") == 0){
  2085| 			mono_use_fast_math = TRUE;
  2086| 		} else if ((strcmp (argv [i], "--interpreter") == 0) || !strcmp (argv [i], "--interp")) {
  2087| 			mono_runtime_set_execution_mode (MONO_EE_MODE_INTERP);
  2088| 		} else if (strncmp (argv [i], "--interp=", 9) == 0) {
  2089| 			mono_runtime_set_execution_mode_full (MONO_EE_MODE_INTERP, FALSE);
  2090| 			mono_interp_opts_string = argv [i] + 9;
  2091| 		} else if (strcmp (argv [i], "--print-icall-table") == 0) {
  2092| #ifdef ENABLE_ICALL_SYMBOL_MAP
  2093| 			print_icall_table ();
  2094| 			exit (0);
  2095| #else
  2096| 			fprintf (stderr, "--print-icall-table requires a runtime configured with the --enable-icall-symbol-map option.\n");
  2097| 			exit (1);
  2098| #endif
  2099| 		} else if (strncmp (argv [i], "--assembly-loader=", strlen("--assembly-loader=")) == 0) {
  2100| 			gchar *arg = argv [i] + strlen ("--assembly-loader=");
  2101| 			if (strcmp (arg, "strict") == 0)
  2102| 				mono_loader_set_strict_assembly_name_check (TRUE);
  2103| 			else if (strcmp (arg, "legacy") == 0)
  2104| 				mono_loader_set_strict_assembly_name_check (FALSE);
  2105| 			else
  2106| 				fprintf (stderr, "Warning: unknown argument to --assembly-loader. Should be \"strict\" or \"legacy\"\n");
  2107| 		} else if (strncmp (argv [i], MONO_HANDLERS_ARGUMENT, MONO_HANDLERS_ARGUMENT_LEN) == 0) {
  2108| 			if (!mono_runtime_install_custom_handlers (argv[i] + MONO_HANDLERS_ARGUMENT_LEN)) {
  2109| 				fprintf (stderr, "error: " MONO_HANDLERS_ARGUMENT ", one or more unknown handlers: '%s'\n", argv [i]);
  2110| 				return 1;
  2111| 			}
  2112| 		} else if (strcmp (argv [i], "--help-handlers") == 0) {
  2113| 			mono_runtime_install_custom_handlers_usage ();
  2114| 			return 0;
  2115| 		} else if (strncmp (argv [i], "--response=", 11) == 0){
  2116| 			gchar *response_content;
  2117| 			gchar *response_options;
  2118| 			gsize response_content_len;
  2119| 			if (!g_file_get_contents (&argv[i][11], &response_content, &response_content_len, NULL)){
  2120| 				fprintf (stderr, "The specified response file can not be read\n");
  2121| 				exit (1);
  2122| 			}
  2123| 			response_options = response_content;
  2124| 			if (response_content_len >= 3 && response_content [0] == '\xef' && response_content [1] == '\xbb' && response_content [2] == '\xbf') {
  2125| 				response_content_len -= 3;
  2126| 				response_options += 3;
  2127| 			}
  2128| 			if (response_content_len == 0) {
  2129| 				fprintf (stderr, "The specified response file is empty\n");
  2130| 				exit (1);
  2131| 			}
  2132| 			int orig_argc = argc;
  2133| 			mono_parse_response_options (response_options, &argc, &argv, FALSE);
  2134| 			g_free (response_content);
  2135| 			/* Parse newly added options */
  2136| 			int n = argc;
  2137| 			mono_options_parse_options ((const char**)(argv + orig_argc), argc - orig_argc, &n, error);
  2138| 			if (!is_ok (error)) {
  2139| 				g_printerr ("%s", mono_error_get_message (error));
  2140| 				mono_error_cleanup (error);
  2141| 				return 1;
  2142| 			}
  2143| 			argc -= (argc - orig_argc) - n;
  2144| 		} else if (argv [i][0] == '-' && argv [i][1] == '-' && mini_parse_debug_option (argv [i] + 2)) {
  2145| 		} else if (strcmp (argv [i], "--use-map-jit") == 0){
  2146| 			mono_setmmapjit (TRUE);
  2147| 		} else {
  2148| 			fprintf (stderr, "Unknown command line option: '%s'\n", argv [i]);
  2149| 			return 1;
  2150| 		}
  2151| 	}
  2152| #if defined(MONO_ARCH_DISABLE_HW_TRAPS)
  2153| 	{
  2154| 		MonoDebugOptions *opt = mini_get_debug_options ();
  2155| 		opt->explicit_null_checks = TRUE;
  2156| 	}
  2157| #endif
  2158| 	if (!argv [i]) {
  2159| 		mini_usage ();
  2160| 		return 1;
  2161| 	}
  2162| 	if (g_hasenv ("MONO_XDEBUG"))
  2163| 		enable_debugging = TRUE;
  2164| #ifdef MONO_CROSS_COMPILE
  2165| 	if (!mono_compile_aot) {
  2166| 		fprintf (stderr, "This mono runtime is compiled for cross-compiling. Only the --aot option is supported.\n");
  2167| 		exit (1);
  2168| 	}
  2169| #if TARGET_SIZEOF_VOID_P == 4 && (defined(TARGET_ARM64) || defined(TARGET_AMD64)) && !defined(MONO_ARCH_ILP32)
  2170| 	fprintf (stderr, "Can't cross-compile on 32-bit platforms to 64-bit architecture.\n");
  2171| 	exit (1);
  2172| #endif
  2173| #endif
  2174| 	mono_counters_init ();
  2175| #ifndef HOST_WIN32
  2176| 	mono_w32handle_init ();
  2177| #endif
  2178| 	if (trace_options != NULL){
  2179| 		/*
  2180| 		 * Need to call this before mini_init () so we can trace methods
  2181| 		 * compiled there too.
  2182| 		 */
  2183| 		mono_jit_trace_calls = mono_trace_set_options (trace_options);
  2184| 		if (mono_jit_trace_calls == NULL)
  2185| 			exit (1);
  2186| 	}
  2187| #ifdef DISABLE_JIT
  2188| 	if (!mono_aot_only && !mono_use_interpreter) {
  2189| 		fprintf (stderr, "This runtime has been configured with --enable-minimal=jit, so the --full-aot command line option is required.\n");
  2190| 		exit (1);
  2191| 	}
  2192| #endif
  2193| 	if (action == DO_DEBUGGER) {
  2194| 		enable_debugging = TRUE;
  2195| 		g_print ("The Mono Debugger is no longer supported.\n");
  2196| 		return 1;
  2197| 	} else if (enable_debugging)
  2198| 		mono_debug_init (MONO_DEBUG_FORMAT_MONO);
  2199| #ifdef HOST_WIN32
  2200| 	if (mixed_mode)
  2201| 		mono_load_coree (argv [i]);
  2202| #endif
  2203| 	mono_set_defaults (mini_verbose_level, opt);
  2204| 	domain = mini_init (argv [i]);
  2205| 	mono_gc_set_stack_end (&domain);
  2206| 	if (agents) {
  2207| 		for (guint agent_idx = 0; agent_idx < agents->len; ++agent_idx) {
  2208| 			int res = load_agent (domain, (char*)g_ptr_array_index (agents, agent_idx));
  2209| 			if (res) {
  2210| 				g_ptr_array_free (agents, TRUE);
  2211| 				mini_cleanup (domain);
  2212| 				return 1;
  2213| 			}
  2214| 		}
  2215| 		g_ptr_array_free (agents, TRUE);
  2216| 	}
  2217| 	switch (action) {
  2218| 	case DO_SINGLE_METHOD_REGRESSION:
  2219| 	case DO_REGRESSION:
  2220| 		 return mono_exec_regression_internal (mini_verbose_level, argc -i, argv + i, action == DO_SINGLE_METHOD_REGRESSION);
  2221| 	case DO_BENCH:
  2222| 		if (argc - i != 1 || mname == NULL) {
  2223| 			g_print ("Usage: mini --ncompile num --compile method assembly\n");
  2224| 			mini_cleanup (domain);
  2225| 			return 1;
  2226| 		}
  2227| 		aname = argv [i];
  2228| 		break;
  2229| 	case DO_COMPILE:
  2230| 		if (argc - i != 1) {
  2231| 			mini_usage ();
  2232| 			mini_cleanup (domain);
  2233| 			return 1;
  2234| 		}
  2235| 		aname = argv [i];
  2236| 		break;
  2237| 	case DO_DRAW:
  2238| 		if (argc - i != 1 || mname == NULL) {
  2239| 			mini_usage ();
  2240| 			mini_cleanup (domain);
  2241| 			return 1;
  2242| 		}
  2243| 		aname = argv [i];
  2244| 		break;
  2245| 	default:
  2246| 		if (argc - i < 1) {
  2247| 			mini_usage ();
  2248| 			mini_cleanup (domain);
  2249| 			return 1;
  2250| 		}
  2251| 		aname = argv [i];
  2252| 		break;
  2253| 	}
  2254| #ifdef MONO_JIT_INFO_TABLE_TEST
  2255| 	if (test_jit_info_table)
  2256| 		jit_info_table_test (domain);
  2257| #endif
  2258| 	if (mono_compile_aot && extra_bindings_config_file != NULL) {
  2259| 		apply_root_domain_configuration_file_bindings (domain, extra_bindings_config_file);
  2260| 	}
  2261| 	MonoAssemblyOpenRequest open_req;
  2262| 	mono_assembly_request_prepare_open (&open_req, mono_alc_get_default ());
  2263| 	assembly = mono_assembly_request_open (aname, &open_req, &open_status);
  2264| 	if (!assembly && !mono_compile_aot) {
  2265| 		fprintf (stderr, "Cannot open assembly '%s': %s.\n", aname, mono_image_strerror (open_status));
  2266| 		mini_cleanup (domain);
  2267| 		return 2;
  2268| 	}
  2269| 	mono_callspec_set_assembly (assembly);
  2270| 	if (mono_compile_aot || action == DO_EXEC) {
  2271| 		const char *version_error;
  2272| 		version_error = mono_check_corlib_version ();
  2273| 		if (version_error) {
  2274| 			fprintf (stderr, "Corlib not in sync with this runtime: %s\n", version_error);
  2275| 			fprintf (stderr, "Loaded from: %s\n",
  2276| 				mono_defaults.corlib? mono_image_get_filename (mono_defaults.corlib): "unknown");
  2277| 			fprintf (stderr, "Download a newer corlib or a newer runtime at http://www.mono-project.com/download.\n");
  2278| 			exit (1);
  2279| 		}
  2280| #if defined(HOST_WIN32) && HAVE_API_SUPPORT_WIN32_CONSOLE
  2281| 		/* Detach console when executing IMAGE_SUBSYSTEM_WINDOWS_GUI on win32 */
  2282| 		if (!enable_debugging && !mono_compile_aot && mono_assembly_get_image_internal (assembly)->image_info->cli_header.nt.pe_subsys_required == IMAGE_SUBSYSTEM_WINDOWS_GUI)
  2283| 			FreeConsole ();
  2284| #endif
  2285| 		main_args.domain = domain;
  2286| 		main_args.file = aname;
  2287| 		main_args.argc = argc - i;
  2288| 		main_args.argv = argv + i;
  2289| 		main_args.opts = opt;
  2290| 		main_args.aot_options = aot_options;
  2291| 		main_thread_handler (&main_args);
  2292| 		mono_thread_manage_internal ();
  2293| 		mini_cleanup (domain);
  2294| 		/* Look up return value from System.Environment.ExitCode */
  2295| 		i = mono_environment_exitcode_get ();
  2296| 		return i;
  2297| 	} else if (action == DO_COMPILE) {
  2298| 		compile_all_methods (assembly, mini_verbose_level, opt, recompilation_times);
  2299| 		mini_cleanup (domain);
  2300| 		return 0;
  2301| 	} else if (action == DO_DEBUGGER) {
  2302| 		return 1;
  2303| 	}
  2304| 	desc = mono_method_desc_new (mname, 0);
  2305| 	if (!desc) {
  2306| 		g_print ("Invalid method name %s\n", mname);
  2307| 		mini_cleanup (domain);
  2308| 		return 3;
  2309| 	}
  2310| 	method = mono_method_desc_search_in_image (desc, mono_assembly_get_image_internal (assembly));
  2311| 	if (!method) {
  2312| 		g_print ("Cannot find method %s\n", mname);
  2313| 		mini_cleanup (domain);
  2314| 		return 3;
  2315| 	}
  2316| #ifndef DISABLE_JIT
  2317| 	MonoCompile *cfg;
  2318| 	if (action == DO_DRAW) {
  2319| 		int part = 0;
  2320| 		switch (mono_graph_options) {
  2321| 		case MONO_GRAPH_DTREE:
  2322| 			part = 1;
  2323| 			opt |= MONO_OPT_LOOP;
  2324| 			break;
  2325| 		case MONO_GRAPH_CFG_CODE:
  2326| 			part = 1;
  2327| 			break;
  2328| 		case MONO_GRAPH_CFG_SSA:
  2329| 			part = 2;
  2330| 			break;
  2331| 		case MONO_GRAPH_CFG_OPTCODE:
  2332| 			part = 3;
  2333| 			break;
  2334| 		default:
  2335| 			break;
  2336| 		}
  2337| 		if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
  2338| 			(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL)) {
  2339| 			MonoMethod *nm;
  2340| 			nm = mono_marshal_get_native_wrapper (method, TRUE, FALSE);
  2341| 			cfg = mini_method_compile (nm, opt, (JitFlags)0, part, -1);
  2342| 		}
  2343| 		else
  2344| 			cfg = mini_method_compile (method, opt, (JitFlags)0, part, -1);
  2345| 		if ((mono_graph_options & MONO_GRAPH_CFG_SSA) && !(cfg->comp_done & MONO_COMP_SSA)) {
  2346| 			g_warning ("no SSA info available (use -O=deadce)");
  2347| 			return 1;
  2348| 		}
  2349| 		mono_draw_graph (cfg, mono_graph_options);
  2350| 		mono_destroy_compile (cfg);
  2351| 	} else if (action == DO_BENCH) {
  2352| 		if (mini_stats_fd) {
  2353| 			const char *n;
  2354| 			double no_opt_time = 0.0;
  2355| 			GTimer *timer = g_timer_new ();
  2356| 			fprintf (mini_stats_fd, "$stattitle = \'Compilations times for %s\';\n",
  2357| 				 mono_method_full_name (method, TRUE));
  2358| 			fprintf (mini_stats_fd, "@data = (\n");
  2359| 			fprintf (mini_stats_fd, "[");
  2360| 			for (i = 0; i < G_N_ELEMENTS (opt_sets); i++) {
  2361| 				opt = opt_sets [i];
  2362| 				n = mono_opt_descr (opt);
  2363| 				if (!n [0])
  2364| 					n = "none";
  2365| 				fprintf (mini_stats_fd, "\"%s\",", n);
  2366| 			}
  2367| 			fprintf (mini_stats_fd, "],\n[");
  2368| 			for (i = 0; i < G_N_ELEMENTS (opt_sets); i++) {
  2369| 				int j;
  2370| 				double elapsed;
  2371| 				opt = opt_sets [i];
  2372| 				g_timer_start (timer);
  2373| 				for (j = 0; j < count; ++j) {
  2374| 					cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
  2375| 					mono_destroy_compile (cfg);
  2376| 				}
  2377| 				g_timer_stop (timer);
  2378| 				elapsed = g_timer_elapsed (timer, NULL);
  2379| 				if (!opt)
  2380| 					no_opt_time = elapsed;
  2381| 				fprintf (mini_stats_fd, "%f, ", elapsed);
  2382| 			}
  2383| 			fprintf (mini_stats_fd, "]");
  2384| 			if (no_opt_time > 0.0) {
  2385| 				fprintf (mini_stats_fd, ", \n[");
  2386| 				for (i = 0; i < G_N_ELEMENTS (opt_sets); i++)
  2387| 					fprintf (mini_stats_fd, "%f,", no_opt_time);
  2388| 				fprintf (mini_stats_fd, "]");
  2389| 			}
  2390| 			fprintf (mini_stats_fd, ");\n");
  2391| 		} else {
  2392| 			for (i = 0; i < count; ++i) {
  2393| 				if ((method->iflags & METHOD_IMPL_ATTRIBUTE_INTERNAL_CALL) ||
  2394| 					(method->flags & METHOD_ATTRIBUTE_PINVOKE_IMPL))
  2395| 					method = mono_marshal_get_native_wrapper (method, TRUE, FALSE);
  2396| 				cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
  2397| 				mono_destroy_compile (cfg);
  2398| 			}
  2399| 		}
  2400| 	} else {
  2401| 		cfg = mini_method_compile (method, opt, (JitFlags)0, 0, -1);
  2402| 		mono_destroy_compile (cfg);
  2403| 	}
  2404| #endif
  2405| 	mini_cleanup (domain);
  2406|  	return 0;
  2407| }
  2408| /**
  2409|  * mono_jit_init:
  2410|  * \param root_domain_name Friendly name to give to the initial domain
  2411|  *
  2412|  * \returns the \c MonoDomain representing the domain where the assembly
  2413|  * was loaded.
  2414|  */
  2415| MonoDomain *
  2416| mono_jit_init (const char *root_domain_name)
  2417| {
  2418| 	MonoDomain *ret = mini_init (root_domain_name);
  2419| 	MONO_ENTER_GC_SAFE_UNBALANCED; //once it is not executing any managed code yet, it's safe to run the gc
  2420| 	return ret;
  2421| }
  2422| /**
  2423|  * mono_jit_init_version:
  2424|  * \param root_domain_name Friendly name to give to the initial domain
  2425|  * \param runtime_version ignored
  2426|  *
  2427|  * Deprecated. Use mono_jit_init instead.
  2428|  *
  2429|  * \returns the \c MonoDomain representing the domain where the assembly
  2430|  * was loaded.
  2431|  */
  2432| MonoDomain *
  2433| mono_jit_init_version (const char *root_domain_name, const char *runtime_version)
  2434| {
  2435| 	MonoDomain *ret = mini_init (root_domain_name);
  2436| 	MONO_ENTER_GC_SAFE_UNBALANCED; //once it is not executing any managed code yet, it's safe to run the gc
  2437| 	return ret;
  2438| }
  2439| MonoDomain *
  2440| mono_jit_init_version_for_test_only (const char *root_domain_name, const char *runtime_version)
  2441| {
  2442| 	MonoDomain *ret = mini_init (root_domain_name);
  2443| 	return ret;
  2444| }
  2445| /**
  2446|  * mono_jit_cleanup:
  2447|  */
  2448| void
  2449| mono_jit_cleanup (MonoDomain *domain)
  2450| {
  2451| 	MONO_STACKDATA (dummy);
  2452| 	(void) mono_threads_enter_gc_unsafe_region_unbalanced_internal (&dummy);
  2453| 	mono_thread_manage_internal ();
  2454| 	mini_cleanup (domain);
  2455| }
  2456| void
  2457| mono_jit_set_aot_only (gboolean val)
  2458| {
  2459| 	mono_aot_only = val;
  2460| 	mono_ee_features.use_aot_trampolines = val;
  2461| }
  2462| static void
  2463| mono_runtime_set_execution_mode_full (int mode, gboolean override)
  2464| {
  2465| 	static gboolean mode_initialized = FALSE;
  2466| 	if (mode_initialized && !override)
  2467| 		return;
  2468| 	mode_initialized = TRUE;
  2469| 	memset (&mono_ee_features, 0, sizeof (mono_ee_features));
  2470| 	switch (mode) {
  2471| 	case MONO_AOT_MODE_FULL:
  2472| 		mono_aot_only = TRUE;
  2473| 		mono_ee_features.use_aot_trampolines = TRUE;
  2474| 		break;
  2475| 	case MONO_AOT_MODE_HYBRID:
  2476| 		mono_set_generic_sharing_vt_supported (TRUE);
  2477| 		mono_set_partial_sharing_supported (TRUE);
  2478| 		break;
  2479| 	case MONO_AOT_MODE_INTERP:
  2480| 		mono_aot_only = TRUE;
  2481| 		mono_use_interpreter = TRUE;
  2482| 		mono_ee_features.use_aot_trampolines = TRUE;
  2483| 		break;
  2484| 	case MONO_AOT_MODE_INTERP_LLVMONLY:
  2485| 		mono_aot_only = TRUE;
  2486| 		mono_use_interpreter = TRUE;
  2487| 		mono_llvm_only = TRUE;
  2488| 		mono_ee_features.force_use_interpreter = TRUE;
  2489| 		break;
  2490| 	case MONO_AOT_MODE_LLVMONLY:
  2491| 	case MONO_AOT_MODE_LLVMONLY_INTERP:
  2492| 		mono_aot_only = TRUE;
  2493| 		mono_use_interpreter = TRUE;
  2494| 		mono_llvm_only = TRUE;
  2495| 		break;
  2496| 	case MONO_AOT_MODE_INTERP_ONLY:
  2497| 		mono_check_interp_supported ();
  2498| 		mono_use_interpreter = TRUE;
  2499| 		mono_ee_features.force_use_interpreter = TRUE;
  2500| 		break;
  2501| 	case MONO_AOT_MODE_NORMAL:
  2502| 	case MONO_AOT_MODE_NONE:
  2503| 		break;
  2504| 	default:
  2505| 		g_error ("Unknown execution-mode %d", mode);
  2506| 	}
  2507| }
  2508| static void
  2509| mono_runtime_set_execution_mode (int mode)
  2510| {
  2511| 	mono_runtime_set_execution_mode_full (mode, TRUE);
  2512| }
  2513| /**
  2514|  * mono_jit_set_aot_mode:
  2515|  */
  2516| void
  2517| mono_jit_set_aot_mode (MonoAotMode mode)
  2518| {
  2519| 	/* we don't want to set mono_aot_mode twice */
  2520| 	static gboolean inited;
  2521| 	g_assert (!inited);
  2522| 	mono_aot_mode = mode;
  2523| 	inited = TRUE;
  2524| 	mono_runtime_set_execution_mode (mode);
  2525| }
  2526| mono_bool
  2527| mono_jit_aot_compiling (void)
  2528| {
  2529| 	return mono_compile_aot;
  2530| }
  2531| /**
  2532|  * mono_jit_set_trace_options:
  2533|  * \param options string representing the trace options
  2534|  * Set the options of the tracing engine. This function can be called before initializing
  2535|  * the mono runtime. See the --trace mono(1) manpage for the options format.
  2536|  *
  2537|  * \returns TRUE if the options were parsed and set correctly, FALSE otherwise.
  2538|  */
  2539| gboolean
  2540| mono_jit_set_trace_options (const char* options)
  2541| {
  2542| 	MonoCallSpec *trace_opt = mono_trace_set_options (options);
  2543| 	if (trace_opt == NULL)
  2544| 		return FALSE;
  2545| 	mono_jit_trace_calls = trace_opt;
  2546| 	return TRUE;
  2547| }
  2548| /**
  2549|  * mono_set_signal_chaining:
  2550|  *
  2551|  * Enable/disable signal chaining. This should be called before \c mono_jit_init.
  2552|  * If signal chaining is enabled, the runtime saves the original signal handlers before
  2553|  * installing its own handlers, and calls the original ones in the following cases:
  2554|  * - a \c SIGSEGV / \c SIGABRT signal received while executing native (i.e. not JITted) code.
  2555|  * - \c SIGPROF
  2556|  * - \c SIGFPE
  2557|  * - \c SIGQUIT
  2558|  * - \c SIGUSR2
  2559|  * Signal chaining only works on POSIX platforms.
  2560|  */
  2561| void
  2562| mono_set_signal_chaining (gboolean chain_signals)
  2563| {
  2564| 	mono_do_signal_chaining = chain_signals;
  2565| }
  2566| /**
  2567|  * mono_set_crash_chaining:
  2568|  *
  2569|  * Enable/disable crash chaining due to signals. When a fatal signal is delivered and
  2570|  * Mono doesn't know how to handle it, it will invoke the crash handler. If chrash chaining
  2571|  * is enabled, it will first print its crash information and then try to chain with the native handler.
  2572|  */
  2573| void
  2574| mono_set_crash_chaining (gboolean chain_crashes)
  2575| {
  2576| 	mono_do_crash_chaining = chain_crashes;
  2577| }
  2578| /**
  2579|  * mono_parse_options_from:
  2580|  * \param options string containing strings
  2581|  * \param ref_argc pointer to the \c argc variable that might be updated
  2582|  * \param ref_argv pointer to the \c argv string vector variable that might be updated
  2583|  *
  2584|  * This function parses the contents of the \c MONO_ENV_OPTIONS
  2585|  * environment variable as if they were parsed by a command shell
  2586|  * splitting the contents by spaces into different elements of the
  2587|  * \p argv vector.  This method supports quoting with both the " and '
  2588|  * characters.  Inside quoting, spaces and tabs are significant,
  2589|  * otherwise, they are considered argument separators.
  2590|  *
  2591|  * The \ character can be used to escape the next character which will
  2592|  * be added to the current element verbatim.  Typically this is used
  2593|  * inside quotes.   If the quotes are not balanced, this method
  2594|  *
  2595|  * If the environment variable is empty, no changes are made
  2596|  * to the values pointed by \p ref_argc and \p ref_argv.
  2597|  *
  2598|  * Otherwise the \p ref_argv is modified to point to a new array that contains
  2599|  * all the previous elements contained in the vector, plus the values parsed.
  2600|  * The \p argc is updated to match the new number of parameters.
  2601|  *
  2602|  * \returns The value NULL is returned on success, otherwise a \c g_strdup allocated
  2603|  * string is returned (this is an alias to \c malloc under normal circumstances) that
  2604|  * contains the error message that happened during parsing.
  2605|  */
  2606| char *
  2607| mono_parse_options_from (const char *options, int *ref_argc, char **ref_argv [])
  2608| {
  2609| 	return mono_parse_options (options, ref_argc, ref_argv, TRUE);
  2610| }
  2611| static void
  2612| merge_parsed_options (GPtrArray *parsed_options, int *ref_argc, char **ref_argv [], gboolean prepend)
  2613| {
  2614| 	int argc = *ref_argc;
  2615| 	char **argv = *ref_argv;
  2616| 	if (parsed_options->len > 0){
  2617| 		int new_argc = parsed_options->len + argc;
  2618| 		char **new_argv = g_new (char *, new_argc + 1);
  2619| 		guint i;
  2620| 		new_argv [0] = argv [0];
  2621| 		i = 1;
  2622| 		if (prepend){
  2623| 			/* First the environment variable settings, to allow the command line options to override */
  2624| 			for (i = 0; i < parsed_options->len; i++)
  2625| 				new_argv [i+1] = (char *)g_ptr_array_index (parsed_options, i);
  2626| 			i++;
  2627| 		}
  2628| 		for (int j = 1; j < argc; j++)
  2629| 			new_argv [i++] = argv [j];
  2630| 		if (!prepend){
  2631| 			for (guint j = 0; j < parsed_options->len; j++)
  2632| 				new_argv [i++] = (char *)g_ptr_array_index (parsed_options, j);
  2633| 		}
  2634| 		new_argv [i] = NULL;
  2635| 		*ref_argc = new_argc;
  2636| 		*ref_argv = new_argv;
  2637| 	}
  2638| }
  2639| static char *
  2640| mono_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
  2641| {
  2642| 	if (options == NULL)
  2643| 		return NULL;
  2644| 	GPtrArray *array = g_ptr_array_new ();
  2645| 	GString *buffer = g_string_new ("");
  2646| 	const char *p;
  2647| 	gboolean in_quotes = FALSE;
  2648| 	char quote_char = '\0';
  2649| 	for (p = options; *p; p++){
  2650| 		switch (*p){
  2651| 		case ' ': case '\t': case '\n':
  2652| 			if (!in_quotes) {
  2653| 				if (buffer->len != 0){
  2654| 					g_ptr_array_add (array, g_strdup (buffer->str));
  2655| 					g_string_truncate (buffer, 0);
  2656| 				}
  2657| 			} else {
  2658| 				g_string_append_c (buffer, *p);
  2659| 			}
  2660| 			break;
  2661| 		case '\\':
  2662| 			if (p [1]){
  2663| 				g_string_append_c (buffer, p [1]);
  2664| 				p++;
  2665| 			}
  2666| 			break;
  2667| 		case '\'':
  2668| 		case '"':
  2669| 			if (in_quotes) {
  2670| 				if (quote_char == *p)
  2671| 					in_quotes = FALSE;
  2672| 				else
  2673| 					g_string_append_c (buffer, *p);
  2674| 			} else {
  2675| 				in_quotes = TRUE;
  2676| 				quote_char = *p;
  2677| 			}
  2678| 			break;
  2679| 		default:
  2680| 			g_string_append_c (buffer, *p);
  2681| 			break;
  2682| 		}
  2683| 	}
  2684| 	if (in_quotes)
  2685| 		return g_strdup_printf ("Unmatched quotes in value: [%s]\n", options);
  2686| 	if (buffer->len != 0)
  2687| 		g_ptr_array_add (array, g_strdup (buffer->str));
  2688| 	g_string_free (buffer, TRUE);
  2689| 	merge_parsed_options (array, ref_argc, ref_argv, prepend);
  2690| 	g_ptr_array_free (array, TRUE);
  2691| 	return NULL;
  2692| }
  2693| #if defined(HOST_WIN32) && HAVE_API_SUPPORT_WIN32_COMMAND_LINE_TO_ARGV
  2694| #include <shellapi.h>
  2695| static char *
  2696| mono_win32_parse_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
  2697| {
  2698| 	int argc;
  2699| 	gunichar2 **argv;
  2700| 	gunichar2 *optionsw;
  2701| 	if (!options)
  2702| 		return NULL;
  2703| 	GPtrArray *array = g_ptr_array_new ();
  2704| 	optionsw = g_utf8_to_utf16 (options, -1, NULL, NULL, NULL);
  2705| 	if (optionsw) {
  2706| 		gunichar2 *p;
  2707| 		gboolean in_quotes = FALSE;
  2708| 		gunichar2 quote_char = L'\0';
  2709| 		for (p = optionsw; *p; p++){
  2710| 			switch (*p){
  2711| 			case L'\n':
  2712| 				if (!in_quotes)
  2713| 					*p = L' ';
  2714| 				break;
  2715| 			case L'\'':
  2716| 			case L'"':
  2717| 				if (in_quotes) {
  2718| 					if (quote_char == *p)
  2719| 						in_quotes = FALSE;
  2720| 				} else {
  2721| 					in_quotes = TRUE;
  2722| 					quote_char = *p;
  2723| 				}
  2724| 				break;
  2725| 			}
  2726| 		}
  2727| 		argv = CommandLineToArgvW (optionsw, &argc);
  2728| 		if (argv) {
  2729| 			for (int i = 0; i < argc; i++)
  2730| 				g_ptr_array_add (array, g_utf16_to_utf8 (argv[i], -1, NULL, NULL, NULL));
  2731| 			LocalFree (argv);
  2732| 		}
  2733| 		g_free (optionsw);
  2734| 	}
  2735| 	merge_parsed_options (array, ref_argc, ref_argv, prepend);
  2736| 	g_ptr_array_free (array, TRUE);
  2737| 	return NULL;
  2738| }
  2739| static char *
  2740| mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
  2741| {
  2742| 	return mono_win32_parse_options (options, ref_argc, ref_argv, prepend);
  2743| }
  2744| #else
  2745| static char *
  2746| mono_parse_response_options (const char *options, int *ref_argc, char **ref_argv [], gboolean prepend)
  2747| {
  2748| 	return mono_parse_options (options, ref_argc, ref_argv, prepend);
  2749| }
  2750| #endif
  2751| /**
  2752|  * mono_parse_env_options:
  2753|  * \param ref_argc pointer to the \c argc variable that might be updated
  2754|  * \param ref_argv pointer to the \c argv string vector variable that might be updated
  2755|  *
  2756|  * This function parses the contents of the \c MONO_ENV_OPTIONS
  2757|  * environment variable as if they were parsed by a command shell
  2758|  * splitting the contents by spaces into different elements of the
  2759|  * \p argv vector.  This method supports quoting with both the " and '
  2760|  * characters.  Inside quoting, spaces and tabs are significant,
  2761|  * otherwise, they are considered argument separators.
  2762|  *
  2763|  * The \ character can be used to escape the next character which will
  2764|  * be added to the current element verbatim.  Typically this is used
  2765|  * inside quotes.   If the quotes are not balanced, this method
  2766|  *
  2767|  * If the environment variable is empty, no changes are made
  2768|  * to the values pointed by \p ref_argc and \p ref_argv.
  2769|  *
  2770|  * Otherwise the \p ref_argv is modified to point to a new array that contains
  2771|  * all the previous elements contained in the vector, plus the values parsed.
  2772|  * The \p argc is updated to match the new number of parameters.
  2773|  *
  2774|  * If there is an error parsing, this method will terminate the process by
  2775|  * calling exit(1).
  2776|  *
  2777|  * An alternative to this method that allows an arbitrary string to be parsed
  2778|  * and does not exit on error is the `api:mono_parse_options_from`.
  2779|  */
  2780| void
  2781| mono_parse_env_options (int *ref_argc, char **ref_argv [])
  2782| {
  2783| 	char *ret;
  2784| 	char *env_options = g_getenv ("MONO_ENV_OPTIONS");
  2785| 	if (env_options == NULL)
  2786| 		return;
  2787| 	ret = mono_parse_options_from (env_options, ref_argc, ref_argv);
  2788| 	g_free (env_options);
  2789| 	if (ret == NULL)
  2790| 		return;
  2791| 	fprintf (stderr, "%s", ret);
  2792| 	exit (1);
  2793| }
  2794| MonoDebugOptions *
  2795| get_mini_debug_options (void)
  2796| {
  2797| 	return &mini_debug_options;
  2798| }


# ====================================================================
# FILE: src/mono/mono/utils/mono-context.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-576 ---
     1| /**
     2|  * \file
     3|  * plat independent machine state definitions
     4|  *
     5|  *
     6|  * Copyright (c) 2011 Novell, Inc (http://www.novell.com)
     7|  * Licensed under the MIT license. See LICENSE file in the project root for full license information.
     8|  */
     9| #include <mono/utils/mono-sigcontext.h>
    10| #ifdef HAVE_UCONTEXT_H
    11| #include <ucontext.h>
    12| #endif
    13| #if ((defined(__i386__) || defined(_M_IX86)) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_X86))
    14| #include <mono/utils/mono-context.h>
    15| #ifdef HOST_WIN32
    16| #include <windows.h>
    17| #endif
    18| #ifdef __sun
    19| #define REG_EAX EAX
    20| #define REG_EBX EBX
    21| #define REG_ECX ECX
    22| #define REG_EDX EDX
    23| #define REG_EBP EBP
    24| #define REG_ESP ESP
    25| #define REG_ESI ESI
    26| #define REG_EDI EDI
    27| #define REG_EIP EIP
    28| #endif
    29| void
    30| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
    31| {
    32| #if defined (HOST_WATCHOS)
    33| 	printf("WARNING: mono_arch_sigctx_to_monoctx() called!\n");
    34| 	mctx->eax = 0xDEADBEEF;
    35| 	mctx->ebx = 0xDEADBEEF;
    36| 	mctx->ecx = 0xDEADBEEF;
    37| 	mctx->edx = 0xDEADBEEF;
    38| 	mctx->ebp = 0xDEADBEEF;
    39| 	mctx->esp = 0xDEADBEEF;
    40| 	mctx->esi = 0xDEADBEEF;
    41| 	mctx->edi = 0xDEADBEEF;
    42| 	mctx->eip = 0xDEADBEEF;
    43| #elif MONO_CROSS_COMPILE
    44| 	g_assert_not_reached ();
    45| #elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
    46| 	ucontext_t *ctx = (ucontext_t*)sigctx;
    47| 	mctx->eax = UCONTEXT_REG_EAX (ctx);
    48| 	mctx->ebx = UCONTEXT_REG_EBX (ctx);
    49| 	mctx->ecx = UCONTEXT_REG_ECX (ctx);
    50| 	mctx->edx = UCONTEXT_REG_EDX (ctx);
    51| 	mctx->ebp = UCONTEXT_REG_EBP (ctx);
    52| 	mctx->esp = UCONTEXT_REG_ESP (ctx);
    53| 	mctx->esi = UCONTEXT_REG_ESI (ctx);
    54| 	mctx->edi = UCONTEXT_REG_EDI (ctx);
    55| 	mctx->eip = UCONTEXT_REG_EIP (ctx);
    56| #ifdef UCONTEXT_HAS_XMM
    57| 	if (UCONTEXT_HAS_XMM (ctx)) {
    58| 		mctx->fregs [0] = UCONTEXT_REG_XMM0 (ctx);
    59| 		mctx->fregs [1] = UCONTEXT_REG_XMM1 (ctx);
    60| 		mctx->fregs [2] = UCONTEXT_REG_XMM2 (ctx);
    61| 		mctx->fregs [3] = UCONTEXT_REG_XMM3 (ctx);
    62| 		mctx->fregs [4] = UCONTEXT_REG_XMM4 (ctx);
    63| 		mctx->fregs [5] = UCONTEXT_REG_XMM5 (ctx);
    64| 		mctx->fregs [6] = UCONTEXT_REG_XMM6 (ctx);
    65| 		mctx->fregs [7] = UCONTEXT_REG_XMM7 (ctx);
    66| 	}
    67| #endif
    68| #elif defined(HOST_WIN32)
    69| 	CONTEXT *context = (CONTEXT*)sigctx;
    70| 	mctx->eip = context->Eip;
    71| 	mctx->edi = context->Edi;
    72| 	mctx->esi = context->Esi;
    73| 	mctx->ebx = context->Ebx;
    74| 	mctx->edx = context->Edx;
    75| 	mctx->ecx = context->Ecx;
    76| 	mctx->eax = context->Eax;
    77| 	mctx->ebp = context->Ebp;
    78| 	mctx->esp = context->Esp;
    79| #else
    80| 	struct sigcontext *ctx = (struct sigcontext *)sigctx;
    81| 	mctx->eax = ctx->SC_EAX;
    82| 	mctx->ebx = ctx->SC_EBX;
    83| 	mctx->ecx = ctx->SC_ECX;
    84| 	mctx->edx = ctx->SC_EDX;
    85| 	mctx->ebp = ctx->SC_EBP;
    86| 	mctx->esp = ctx->SC_ESP;
    87| 	mctx->esi = ctx->SC_ESI;
    88| 	mctx->edi = ctx->SC_EDI;
    89| 	mctx->eip = ctx->SC_EIP;
    90| #endif
    91| }
    92| void
    93| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
    94| {
    95| #if defined(HOST_WATCHOS)
    96| 	printf("WARNING: mono_arch_monoctx_to_sigctx() called!\n");
    97| #elif MONO_CROSS_COMPILE
    98| 	g_assert_not_reached ();
    99| #elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
   100| 	ucontext_t *ctx = (ucontext_t*)sigctx;
   101| 	UCONTEXT_REG_EAX (ctx) = mctx->eax;
   102| 	UCONTEXT_REG_EBX (ctx) = mctx->ebx;
   103| 	UCONTEXT_REG_ECX (ctx) = mctx->ecx;
   104| 	UCONTEXT_REG_EDX (ctx) = mctx->edx;
   105| 	UCONTEXT_REG_EBP (ctx) = mctx->ebp;
   106| 	UCONTEXT_REG_ESP (ctx) = mctx->esp;
   107| 	UCONTEXT_REG_ESI (ctx) = mctx->esi;
   108| 	UCONTEXT_REG_EDI (ctx) = mctx->edi;
   109| 	UCONTEXT_REG_EIP (ctx) = mctx->eip;
   110| #ifdef UCONTEXT_HAS_XMM
   111| 	if (UCONTEXT_HAS_XMM (ctx)) {
   112| 		UCONTEXT_REG_XMM0 (ctx) = mctx->fregs [0];
   113| 		UCONTEXT_REG_XMM1 (ctx) = mctx->fregs [1];
   114| 		UCONTEXT_REG_XMM2 (ctx) = mctx->fregs [2];
   115| 		UCONTEXT_REG_XMM3 (ctx) = mctx->fregs [3];
   116| 		UCONTEXT_REG_XMM4 (ctx) = mctx->fregs [4];
   117| 		UCONTEXT_REG_XMM5 (ctx) = mctx->fregs [5];
   118| 		UCONTEXT_REG_XMM6 (ctx) = mctx->fregs [6];
   119| 		UCONTEXT_REG_XMM7 (ctx) = mctx->fregs [7];
   120| 	}
   121| #endif
   122| #elif defined(HOST_WIN32)
   123| 	CONTEXT *context = (CONTEXT*)sigctx;
   124| 	context->Eip = mctx->eip;
   125| 	context->Edi = mctx->edi;
   126| 	context->Esi = mctx->esi;
   127| 	context->Ebx = mctx->ebx;
   128| 	context->Edx = mctx->edx;
   129| 	context->Ecx = mctx->ecx;
   130| 	context->Eax = mctx->eax;
   131| 	context->Ebp = mctx->ebp;
   132| 	context->Esp = mctx->esp;
   133| #else
   134| 	struct sigcontext *ctx = (struct sigcontext *)sigctx;
   135| 	ctx->SC_EAX = mctx->eax;
   136| 	ctx->SC_EBX = mctx->ebx;
   137| 	ctx->SC_ECX = mctx->ecx;
   138| 	ctx->SC_EDX = mctx->edx;
   139| 	ctx->SC_EBP = mctx->ebp;
   140| 	ctx->SC_ESP = mctx->esp;
   141| 	ctx->SC_ESI = mctx->esi;
   142| 	ctx->SC_EDI = mctx->edi;
   143| 	ctx->SC_EIP = mctx->eip;
   144| #endif
   145| }
   146| #elif ((defined(__x86_64__) || defined(_M_X64)) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_AMD64))
   147| #include <mono/utils/mono-context.h>
   148| #ifdef HOST_WIN32
   149| #include <windows.h>
   150| #include <mono/utils/w32subset.h>
   151| #endif
   152| void
   153| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   154| {
   155| #ifdef MONO_CROSS_COMPILE
   156| 	g_assert_not_reached ();
   157| #elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
   158| 	ucontext_t *ctx = (ucontext_t*)sigctx;
   159| 	mctx->gregs [AMD64_RAX] = UCONTEXT_REG_RAX (ctx);
   160| 	mctx->gregs [AMD64_RBX] = UCONTEXT_REG_RBX (ctx);
   161| 	mctx->gregs [AMD64_RCX] = UCONTEXT_REG_RCX (ctx);
   162| 	mctx->gregs [AMD64_RDX] = UCONTEXT_REG_RDX (ctx);
   163| 	mctx->gregs [AMD64_RBP] = UCONTEXT_REG_RBP (ctx);
   164| 	mctx->gregs [AMD64_RSP] = UCONTEXT_REG_RSP (ctx);
   165| 	mctx->gregs [AMD64_RSI] = UCONTEXT_REG_RSI (ctx);
   166| 	mctx->gregs [AMD64_RDI] = UCONTEXT_REG_RDI (ctx);
   167| 	mctx->gregs [AMD64_R8] = UCONTEXT_REG_R8 (ctx);
   168| 	mctx->gregs [AMD64_R9] = UCONTEXT_REG_R9 (ctx);
   169| 	mctx->gregs [AMD64_R10] = UCONTEXT_REG_R10 (ctx);
   170| 	mctx->gregs [AMD64_R11] = UCONTEXT_REG_R11 (ctx);
   171| 	mctx->gregs [AMD64_R12] = UCONTEXT_REG_R12 (ctx);
   172| 	mctx->gregs [AMD64_R13] = UCONTEXT_REG_R13 (ctx);
   173| 	mctx->gregs [AMD64_R14] = UCONTEXT_REG_R14 (ctx);
   174| 	mctx->gregs [AMD64_R15] = UCONTEXT_REG_R15 (ctx);
   175| 	mctx->gregs [AMD64_RIP] = UCONTEXT_REG_RIP (ctx);
   176| #ifdef UCONTEXT_HAS_XMM
   177| 	if (UCONTEXT_HAS_XMM (ctx)) {
   178| 		mctx->fregs [0] = UCONTEXT_REG_XMM0 (ctx);
   179| 		mctx->fregs [1] = UCONTEXT_REG_XMM1 (ctx);
   180| 		mctx->fregs [2] = UCONTEXT_REG_XMM2 (ctx);
   181| 		mctx->fregs [3] = UCONTEXT_REG_XMM3 (ctx);
   182| 		mctx->fregs [4] = UCONTEXT_REG_XMM4 (ctx);
   183| 		mctx->fregs [5] = UCONTEXT_REG_XMM5 (ctx);
   184| 		mctx->fregs [6] = UCONTEXT_REG_XMM6 (ctx);
   185| 		mctx->fregs [7] = UCONTEXT_REG_XMM7 (ctx);
   186| 		mctx->fregs [8] = UCONTEXT_REG_XMM8 (ctx);
   187| 		mctx->fregs [9] = UCONTEXT_REG_XMM9 (ctx);
   188| 		mctx->fregs [10] = UCONTEXT_REG_XMM10 (ctx);
   189| 		mctx->fregs [11] = UCONTEXT_REG_XMM11 (ctx);
   190| 		mctx->fregs [12] = UCONTEXT_REG_XMM12 (ctx);
   191| 		mctx->fregs [13] = UCONTEXT_REG_XMM13 (ctx);
   192| 		mctx->fregs [14] = UCONTEXT_REG_XMM14 (ctx);
   193| 		mctx->fregs [15] = UCONTEXT_REG_XMM15 (ctx);
   194| 	}
   195| #endif
   196| #elif defined(HOST_WIN32)
   197| 	CONTEXT *context = (CONTEXT*)sigctx;
   198| 	mctx->gregs [AMD64_RIP] = context->Rip;
   199| 	mctx->gregs [AMD64_RAX] = context->Rax;
   200| 	mctx->gregs [AMD64_RCX] = context->Rcx;
   201| 	mctx->gregs [AMD64_RDX] = context->Rdx;
   202| 	mctx->gregs [AMD64_RBX] = context->Rbx;
   203| 	mctx->gregs [AMD64_RSP] = context->Rsp;
   204| 	mctx->gregs [AMD64_RBP] = context->Rbp;
   205| 	mctx->gregs [AMD64_RSI] = context->Rsi;
   206| 	mctx->gregs [AMD64_RDI] = context->Rdi;
   207| 	mctx->gregs [AMD64_R8] = context->R8;
   208| 	mctx->gregs [AMD64_R9] = context->R9;
   209| 	mctx->gregs [AMD64_R10] = context->R10;
   210| 	mctx->gregs [AMD64_R11] = context->R11;
   211| 	mctx->gregs [AMD64_R12] = context->R12;
   212| 	mctx->gregs [AMD64_R13] = context->R13;
   213| 	mctx->gregs [AMD64_R14] = context->R14;
   214| 	mctx->gregs [AMD64_R15] = context->R15;
   215| 	memcpy (&(mctx->fregs [AMD64_XMM0]), &(context->Xmm0), sizeof (MonoContextSimdReg));
   216| 	memcpy (&(mctx->fregs [AMD64_XMM1]), &(context->Xmm1), sizeof (MonoContextSimdReg));
   217| 	memcpy (&(mctx->fregs [AMD64_XMM2]), &(context->Xmm2), sizeof (MonoContextSimdReg));
   218| 	memcpy (&(mctx->fregs [AMD64_XMM3]), &(context->Xmm3), sizeof (MonoContextSimdReg));
   219| 	memcpy (&(mctx->fregs [AMD64_XMM4]), &(context->Xmm4), sizeof (MonoContextSimdReg));
   220| 	memcpy (&(mctx->fregs [AMD64_XMM5]), &(context->Xmm5), sizeof (MonoContextSimdReg));
   221| 	memcpy (&(mctx->fregs [AMD64_XMM6]), &(context->Xmm6), sizeof (MonoContextSimdReg));
   222| 	memcpy (&(mctx->fregs [AMD64_XMM7]), &(context->Xmm7), sizeof (MonoContextSimdReg));
   223| 	memcpy (&(mctx->fregs [AMD64_XMM8]), &(context->Xmm8), sizeof (MonoContextSimdReg));
   224| 	memcpy (&(mctx->fregs [AMD64_XMM9]), &(context->Xmm9), sizeof (MonoContextSimdReg));
   225| 	memcpy (&(mctx->fregs [AMD64_XMM10]), &(context->Xmm10), sizeof (MonoContextSimdReg));
   226| 	memcpy (&(mctx->fregs [AMD64_XMM11]), &(context->Xmm11), sizeof (MonoContextSimdReg));
   227| 	memcpy (&(mctx->fregs [AMD64_XMM12]), &(context->Xmm12), sizeof (MonoContextSimdReg));
   228| 	memcpy (&(mctx->fregs [AMD64_XMM13]), &(context->Xmm13), sizeof (MonoContextSimdReg));
   229| 	memcpy (&(mctx->fregs [AMD64_XMM14]), &(context->Xmm14), sizeof (MonoContextSimdReg));
   230| 	memcpy (&(mctx->fregs [AMD64_XMM15]), &(context->Xmm15), sizeof (MonoContextSimdReg));
   231| #ifdef MONO_HAVE_SIMD_REG_AVX
   232| #if HAVE_API_SUPPORT_WIN32_CONTEXT_XSTATE
   233| 	DWORD64 features = 0;
   234| 	if (((context->ContextFlags & CONTEXT_XSTATE) != 0) && (GetXStateFeaturesMask (context, &features) == TRUE) && ((features & XSTATE_MASK_AVX) != 0)) {
   235| 		DWORD feature_len = 0;
   236| 		PM128A ymm = (PM128A)LocateXStateFeature (context, XSTATE_AVX, &feature_len);
   237| #ifdef ENABLE_CHECKED_BUILD
   238| 		g_assert (ymm);
   239| 		g_assert (feature_len == (sizeof (MonoContextSimdReg) * AMD64_XMM_NREG));
   240| #endif
   241| 		memcpy (&(mctx->fregs [AMD64_XMM_NREG]), ymm, feature_len);
   242| 	} else {
   243| 		memset (&(mctx->fregs [AMD64_XMM_NREG]), 0, sizeof (MonoContextSimdReg) * AMD64_XMM_NREG);
   244| 	}
   245| #else
   246| 	memset (&(mctx->fregs [AMD64_XMM_NREG]), 0, sizeof (MonoContextSimdReg) * AMD64_XMM_NREG);
   247| #endif
   248| #endif
   249| #elif defined(__HAIKU__)
   250| 	struct sigcontext *ctx = (struct sigcontext *)sigctx;
   251| 	mctx->gregs [AMD64_RIP] = ctx->regs.rip;
   252| 	mctx->gregs [AMD64_RAX] = ctx->regs.rax;
   253| 	mctx->gregs [AMD64_RCX] = ctx->regs.rcx;
   254| 	mctx->gregs [AMD64_RDX] = ctx->regs.rdx;
   255| 	mctx->gregs [AMD64_RBX] = ctx->regs.rbx;
   256| 	mctx->gregs [AMD64_RSP] = ctx->regs.rsp;
   257| 	mctx->gregs [AMD64_RBP] = ctx->regs.rbp;
   258| 	mctx->gregs [AMD64_RSI] = ctx->regs.rsi;
   259| 	mctx->gregs [AMD64_RDI] = ctx->regs.rdi;
   260| 	mctx->gregs [AMD64_R8] = ctx->regs.r8;
   261| 	mctx->gregs [AMD64_R9] = ctx->regs.r9;
   262| 	mctx->gregs [AMD64_R10] = ctx->regs.r10;
   263| 	mctx->gregs [AMD64_R11] = ctx->regs.r11;
   264| 	mctx->gregs [AMD64_R12] = ctx->regs.r12;
   265| 	mctx->gregs [AMD64_R13] = ctx->regs.r13;
   266| 	mctx->gregs [AMD64_R14] = ctx->regs.r14;
   267| 	mctx->gregs [AMD64_R15] = ctx->regs.r15;
   268| #else
   269| 	g_assert_not_reached ();
   270| #endif
   271| }
   272| void
   273| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
   274| {
   275| #ifdef MONO_CROSS_COMPILE
   276| 	g_assert_not_reached ();
   277| #elif defined(MONO_SIGNAL_USE_UCONTEXT_T)
   278| 	ucontext_t *ctx = (ucontext_t*)sigctx;
   279| 	UCONTEXT_REG_RAX (ctx) = mctx->gregs [AMD64_RAX];
   280| 	UCONTEXT_REG_RBX (ctx) = mctx->gregs [AMD64_RBX];
   281| 	UCONTEXT_REG_RCX (ctx) = mctx->gregs [AMD64_RCX];
   282| 	UCONTEXT_REG_RDX (ctx) = mctx->gregs [AMD64_RDX];
   283| 	UCONTEXT_REG_RBP (ctx) = mctx->gregs [AMD64_RBP];
   284| 	UCONTEXT_REG_RSP (ctx) = mctx->gregs [AMD64_RSP];
   285| 	UCONTEXT_REG_RSI (ctx) = mctx->gregs [AMD64_RSI];
   286| 	UCONTEXT_REG_RDI (ctx) = mctx->gregs [AMD64_RDI];
   287| 	UCONTEXT_REG_R8 (ctx) = mctx->gregs [AMD64_R8];
   288| 	UCONTEXT_REG_R9 (ctx) = mctx->gregs [AMD64_R9];
   289| 	UCONTEXT_REG_R10 (ctx) = mctx->gregs [AMD64_R10];
   290| 	UCONTEXT_REG_R11 (ctx) = mctx->gregs [AMD64_R11];
   291| 	UCONTEXT_REG_R12 (ctx) = mctx->gregs [AMD64_R12];
   292| 	UCONTEXT_REG_R13 (ctx) = mctx->gregs [AMD64_R13];
   293| 	UCONTEXT_REG_R14 (ctx) = mctx->gregs [AMD64_R14];
   294| 	UCONTEXT_REG_R15 (ctx) = mctx->gregs [AMD64_R15];
   295| 	UCONTEXT_REG_RIP (ctx) = mctx->gregs [AMD64_RIP];
   296| #ifdef UCONTEXT_HAS_XMM
   297| 	if (UCONTEXT_HAS_XMM (ctx)) {
   298| 		UCONTEXT_REG_XMM0 (ctx) = mctx->fregs [0];
   299| 		UCONTEXT_REG_XMM1 (ctx) = mctx->fregs [1];
   300| 		UCONTEXT_REG_XMM2 (ctx) = mctx->fregs [2];
   301| 		UCONTEXT_REG_XMM3 (ctx) = mctx->fregs [3];
   302| 		UCONTEXT_REG_XMM4 (ctx) = mctx->fregs [4];
   303| 		UCONTEXT_REG_XMM5 (ctx) = mctx->fregs [5];
   304| 		UCONTEXT_REG_XMM6 (ctx) = mctx->fregs [6];
   305| 		UCONTEXT_REG_XMM7 (ctx) = mctx->fregs [7];
   306| 		UCONTEXT_REG_XMM8 (ctx) = mctx->fregs [8];
   307| 		UCONTEXT_REG_XMM9 (ctx) = mctx->fregs [9];
   308| 		UCONTEXT_REG_XMM10 (ctx) = mctx->fregs [10];
   309| 		UCONTEXT_REG_XMM11 (ctx) = mctx->fregs [11];
   310| 		UCONTEXT_REG_XMM12 (ctx) = mctx->fregs [12];
   311| 		UCONTEXT_REG_XMM13 (ctx) = mctx->fregs [13];
   312| 		UCONTEXT_REG_XMM14 (ctx) = mctx->fregs [14];
   313| 		UCONTEXT_REG_XMM15 (ctx) = mctx->fregs [15];
   314| 	}
   315| #endif
   316| #elif defined(HOST_WIN32)
   317| 	CONTEXT *context = (CONTEXT*)sigctx;
   318| 	context->Rip = mctx->gregs [AMD64_RIP];
   319| 	context->Rax = mctx->gregs [AMD64_RAX];
   320| 	context->Rcx = mctx->gregs [AMD64_RCX];
   321| 	context->Rdx = mctx->gregs [AMD64_RDX];
   322| 	context->Rbx = mctx->gregs [AMD64_RBX];
   323| 	context->Rsp = mctx->gregs [AMD64_RSP];
   324| 	context->Rbp = mctx->gregs [AMD64_RBP];
   325| 	context->Rsi = mctx->gregs [AMD64_RSI];
   326| 	context->Rdi = mctx->gregs [AMD64_RDI];
   327| 	context->R8 = mctx->gregs [AMD64_R8];
   328| 	context->R9 = mctx->gregs [AMD64_R9];
   329| 	context->R10 = mctx->gregs [AMD64_R10];
   330| 	context->R11 = mctx->gregs [AMD64_R11];
   331| 	context->R12 = mctx->gregs [AMD64_R12];
   332| 	context->R13 = mctx->gregs [AMD64_R13];
   333| 	context->R14 = mctx->gregs [AMD64_R14];
   334| 	context->R15 = mctx->gregs [AMD64_R15];
   335| 	memcpy (&(context->Xmm0), &(mctx->fregs [AMD64_XMM0]), sizeof (MonoContextSimdReg));
   336| 	memcpy (&(context->Xmm1), &(mctx->fregs [AMD64_XMM1]), sizeof (MonoContextSimdReg));
   337| 	memcpy (&(context->Xmm2), &(mctx->fregs [AMD64_XMM2]), sizeof (MonoContextSimdReg));
   338| 	memcpy (&(context->Xmm3), &(mctx->fregs [AMD64_XMM3]), sizeof (MonoContextSimdReg));
   339| 	memcpy (&(context->Xmm4), &(mctx->fregs [AMD64_XMM4]), sizeof (MonoContextSimdReg));
   340| 	memcpy (&(context->Xmm5), &(mctx->fregs [AMD64_XMM5]), sizeof (MonoContextSimdReg));
   341| 	memcpy (&(context->Xmm6), &(mctx->fregs [AMD64_XMM6]), sizeof (MonoContextSimdReg));
   342| 	memcpy (&(context->Xmm7), &(mctx->fregs [AMD64_XMM7]), sizeof (MonoContextSimdReg));
   343| 	memcpy (&(context->Xmm8), &(mctx->fregs [AMD64_XMM8]), sizeof (MonoContextSimdReg));
   344| 	memcpy (&(context->Xmm9), &(mctx->fregs [AMD64_XMM9]), sizeof (MonoContextSimdReg));
   345| 	memcpy (&(context->Xmm10), &(mctx->fregs [AMD64_XMM10]), sizeof (MonoContextSimdReg));
   346| 	memcpy (&(context->Xmm11), &(mctx->fregs [AMD64_XMM11]), sizeof (MonoContextSimdReg));
   347| 	memcpy (&(context->Xmm12), &(mctx->fregs [AMD64_XMM12]), sizeof (MonoContextSimdReg));
   348| 	memcpy (&(context->Xmm13), &(mctx->fregs [AMD64_XMM13]), sizeof (MonoContextSimdReg));
   349| 	memcpy (&(context->Xmm14), &(mctx->fregs [AMD64_XMM14]), sizeof (MonoContextSimdReg));
   350| 	memcpy (&(context->Xmm15), &(mctx->fregs [AMD64_XMM15]), sizeof (MonoContextSimdReg));
   351| #elif defined(__HAIKU__)
   352| 	struct sigcontext *ctx = (struct sigcontext *)sigctx;
   353| 	ctx->regs.rip = mctx->gregs [AMD64_RIP];
   354| 	ctx->regs.rax = mctx->gregs [AMD64_RAX];
   355| 	ctx->regs.rcx = mctx->gregs [AMD64_RCX];
   356| 	ctx->regs.rdx = mctx->gregs [AMD64_RDX];
   357| 	ctx->regs.rbx = mctx->gregs [AMD64_RBX];
   358| 	ctx->regs.rsp = mctx->gregs [AMD64_RSP];
   359| 	ctx->regs.rbp = mctx->gregs [AMD64_RBP];
   360| 	ctx->regs.rsi = mctx->gregs [AMD64_RSI];
   361| 	ctx->regs.rdi = mctx->gregs [AMD64_RDI];
   362| 	ctx->regs.r8 = mctx->gregs [AMD64_R8];
   363| 	ctx->regs.r9 = mctx->gregs [AMD64_R9];
   364| 	ctx->regs.r10 = mctx->gregs [AMD64_R10];
   365| 	ctx->regs.r11 = mctx->gregs [AMD64_R11];
   366| 	ctx->regs.r12 = mctx->gregs [AMD64_R12];
   367| 	ctx->regs.r13 = mctx->gregs [AMD64_R13];
   368| 	ctx->regs.r14 = mctx->gregs [AMD64_R14];
   369| 	ctx->regs.r15 = mctx->gregs [AMD64_R15];
   370| #else
   371| 	g_assert_not_reached ();
   372| #endif
   373| }
   374| #elif defined(__s390x__)
   375| #include <mono/utils/mono-context.h>
   376| /*------------------------------------------------------------------*/
   377| /*                                                                  */
   378| /* Name		- mono_arch_sigctx_to_monoctx.                      */
   379| /*                                                                  */
   380| /* Function	- Called from the signal handler to convert signal  */
   381| /*                context to MonoContext.                           */
   382| /*                                                                  */
   383| /*------------------------------------------------------------------*/
   384| void
   385| mono_sigctx_to_monoctx (void *ctx, MonoContext *mctx)
   386| {
   387| 	memcpy (mctx, ctx, sizeof(MonoContext));
   388| }
   389| /*========================= End of Function ========================*/
   390| /*------------------------------------------------------------------*/
   391| /*                                                                  */
   392| /* Name		- mono_arch_monoctx_to_sigctx.                      */
   393| /*                                                                  */
   394| /* Function	- Convert MonoContext structure to signal context.  */
   395| /*                                                                  */
   396| /*------------------------------------------------------------------*/
   397| void
   398| mono_monoctx_to_sigctx (MonoContext *mctx, void *ctx)
   399| {
   400| 	memcpy (ctx, mctx, sizeof(MonoContext));
   401| }
   402| /*========================= End of Function ========================*/
   403| #elif (defined(__arm__) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_ARM))
   404| #include <mono/utils/mono-context.h>
   405| #include <mono/arch/arm/arm-codegen.h>
   406| #include <mono/arch/arm/arm-vfp-codegen.h>
   407| #ifdef HOST_WIN32
   408| #include <windows.h>
   409| #endif
   410| void
   411| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   412| {
   413| #ifdef MONO_CROSS_COMPILE
   414| 	g_assert_not_reached ();
   415| #elif defined(HOST_WIN32)
   416| 	CONTEXT *context = (CONTEXT*)sigctx;
   417| 	mctx->pc = context->Pc;
   418| 	mctx->cpsr = context->Cpsr;
   419| 	memcpy (&mctx->regs, &context->R0, sizeof (DWORD) * 16);
   420| 	/* Why are we only copying 16 registers?! There are 32! */
   421| 	memcpy (&mctx->fregs, &context->D, sizeof (double) * 16);
   422| #else
   423| 	arm_ucontext *my_uc = (arm_ucontext*)sigctx;
   424| 	mctx->pc = UCONTEXT_REG_PC (my_uc);
   425| 	mctx->regs [ARMREG_SP] = UCONTEXT_REG_SP (my_uc);
   426| 	mctx->cpsr = UCONTEXT_REG_CPSR (my_uc);
   427| 	memcpy (&mctx->regs, &UCONTEXT_REG_R0 (my_uc), sizeof (host_mgreg_t) * 16);
   428| #ifdef UCONTEXT_REG_VFPREGS
   429| 	memcpy (&mctx->fregs, UCONTEXT_REG_VFPREGS (my_uc), sizeof (double) * 16);
   430| #endif
   431| #endif
   432| }
   433| void
   434| mono_monoctx_to_sigctx (MonoContext *mctx, void *ctx)
   435| {
   436| #ifdef MONO_CROSS_COMPILE
   437| 	g_assert_not_reached ();
   438| #elif defined(HOST_WIN32)
   439| 	CONTEXT *context = (CONTEXT*)ctx;
   440| 	context->Pc = mctx->pc;
   441| 	context->Cpsr = mctx->cpsr;
   442| 	memcpy (&context->R0, &mctx->regs, sizeof (DWORD) * 16);
   443| 	/* Why are we only copying 16 registers?! There are 32! */
   444| 	memcpy (&context->D, &mctx->fregs, sizeof (double) * 16);
   445| #else
   446| 	arm_ucontext *my_uc = (arm_ucontext*)ctx;
   447| 	UCONTEXT_REG_PC (my_uc) = mctx->pc;
   448| 	UCONTEXT_REG_SP (my_uc) = mctx->regs [ARMREG_SP];
   449| 	UCONTEXT_REG_CPSR (my_uc) = mctx->cpsr;
   450| 	/* The upper registers are not guaranteed to be valid */
   451| 	memcpy (&UCONTEXT_REG_R0 (my_uc), &mctx->regs, sizeof (host_mgreg_t) * 12);
   452| #ifdef UCONTEXT_REG_VFPREGS
   453| 	memcpy (UCONTEXT_REG_VFPREGS (my_uc), &mctx->fregs, sizeof (double) * 16);
   454| #endif
   455| #endif
   456| }
   457| #elif (defined(__aarch64__) && !defined(MONO_CROSS_COMPILE)) || (defined(TARGET_ARM64))
   458| #include <mono/utils/mono-context.h>
   459| #include <mono/utils/ftnptr.h>
   460| void
   461| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   462| {
   463| #ifdef MONO_CROSS_COMPILE
   464| 	g_assert_not_reached ();
   465| #else
   466| 	memcpy (mctx->regs, UCONTEXT_GREGS (sigctx), sizeof (host_mgreg_t) * 31);
   467| 	mctx->pc = UCONTEXT_REG_PC (sigctx);
   468| 	mctx->regs [ARMREG_SP] = UCONTEXT_REG_SP (sigctx);
   469| #ifdef UCONTEXT_REG_LR
   470| 	mctx->regs [ARMREG_LR] = UCONTEXT_REG_LR (sigctx);
   471| #endif
   472| #ifdef MONO_ARCH_ENABLE_PTRAUTH
   473| 	mctx->regs [ARMREG_FP] = (host_mgreg_t)ptrauth_strip ((void*)mctx->regs [ARMREG_FP], ptrauth_key_frame_pointer);
   474| #endif
   475| #ifdef __linux__
   476| 	struct fpsimd_context *fpctx = (struct fpsimd_context*)&((ucontext_t*)sigctx)->uc_mcontext.__reserved;
   477| 	size_t size = 0;
   478| 	do {
   479| 		struct fpsimd_context *fpctx_temp = (struct fpsimd_context*)&(((ucontext_t*)sigctx)->uc_mcontext.__reserved[size]);
   480| 		if (fpctx_temp->head.magic == FPSIMD_MAGIC)
   481| 		{
   482| 			g_assert (fpctx_temp->head.size >= sizeof (struct fpsimd_context));
   483| 			g_assert (size + fpctx_temp->head.size <= sizeof (((ucontext_t*)sigctx)->uc_mcontext.__reserved));
   484| 			fpctx = fpctx_temp;
   485| 			break;
   486| 		}
   487| 		if (fpctx_temp->head.size == 0)
   488| 			break;
   489| 		size += fpctx_temp->head.size;
   490| 	} while (size + sizeof (struct fpsimd_context) <= sizeof (((ucontext_t*)sigctx)->uc_mcontext.__reserved));
   491| 	if (fpctx->head.magic == FPSIMD_MAGIC)
   492| 		for (int i = 0; i < 32; ++i)
   493| 			mctx->fregs [i] = fpctx->vregs [i];
   494| 	else
   495| 		for (int i = 0; i < 32; ++i)
   496| 			mctx->fregs [i] = 0;
   497| #endif
   498| 	/* FIXME: apple */
   499| #endif
   500| }
   501| void
   502| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
   503| {
   504| #ifdef MONO_CROSS_COMPILE
   505| 	g_assert_not_reached ();
   506| #else
   507| #ifdef MONO_ARCH_ENABLE_PTRAUTH
   508| 	memcpy (UCONTEXT_GREGS (sigctx), mctx->regs, sizeof (host_mgreg_t) * 31);
   509| 	UCONTEXT_REG_SET_PC (sigctx, (gpointer)mctx->pc);
   510| 	UCONTEXT_REG_SET_SP (sigctx, mctx->regs [ARMREG_SP]);
   511| #else
   512| 	memcpy (UCONTEXT_GREGS (sigctx), mctx->regs, sizeof (host_mgreg_t) * 31);
   513| 	UCONTEXT_REG_SET_PC (sigctx, mctx->pc);
   514| 	UCONTEXT_REG_SET_SP (sigctx, mctx->regs [ARMREG_SP]);
   515| #endif
   516| #endif
   517| }
   518| #elif (((defined(__ppc__) || defined(__powerpc__) || defined(__ppc64__)) && !defined(MONO_CROSS_COMPILE))) || (defined(TARGET_POWERPC))
   519| #include <mono/utils/mono-context.h>
   520| #include <mono/mini/mini-ppc.h>
   521| void
   522| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   523| {
   524| 	os_ucontext *uc = (os_ucontext*)sigctx;
   525| 	mctx->sc_ir = UCONTEXT_REG_NIP(uc);
   526| 	mctx->sc_sp = UCONTEXT_REG_Rn(uc, 1);
   527| 	memcpy (&mctx->regs, &UCONTEXT_REG_Rn(uc, 0), sizeof (host_mgreg_t) * MONO_MAX_IREGS);
   528| 	memcpy (&mctx->fregs, &UCONTEXT_REG_FPRn(uc, 0), sizeof (double) * MONO_MAX_FREGS);
   529| }
   530| void
   531| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
   532| {
   533| 	os_ucontext *uc = (os_ucontext*)sigctx;
   534| 	memcpy (&UCONTEXT_REG_Rn(uc, 0), &mctx->regs, sizeof (host_mgreg_t) * MONO_MAX_IREGS);
   535| 	memcpy (&UCONTEXT_REG_FPRn(uc, 0), &mctx->fregs, sizeof (double) * MONO_MAX_FREGS);
   536| 	/* The valid values for pc and sp are stored here and not in regs array */
   537| 	UCONTEXT_REG_NIP(uc) = mctx->sc_ir;
   538| 	UCONTEXT_REG_Rn(uc, 1) = mctx->sc_sp;
   539| }
   540| #elif defined (TARGET_WASM)
   541| #include <mono/utils/mono-context.h>
   542| void
   543| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   544| {
   545| 	g_error ("MonoContext not supported");
   546| }
   547| void
   548| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
   549| {
   550| 	g_error ("MonoContext not supported");
   551| }
   552| #elif ((defined (HOST_RISCV) || defined (HOST_RISCV64)) && !defined (MONO_CROSS_COMPILE)) || defined (TARGET_RISCV)
   553| #include <mono/utils/mono-context.h>
   554| void
   555| mono_sigctx_to_monoctx (void *sigctx, MonoContext *mctx)
   556| {
   557| #ifdef MONO_CROSS_COMPILE
   558| 	g_assert_not_reached ();
   559| #else
   560| 	ucontext_t *uctx = sigctx;
   561| 	memcpy (&mctx->gregs, &uctx->uc_mcontext.__gregs, sizeof (host_mgreg_t) * G_N_ELEMENTS (mctx->gregs));
   562| 	memcpy (&mctx->fregs, &uctx->uc_mcontext.__fpregs, sizeof (double) * G_N_ELEMENTS (mctx->fregs));
   563| #endif
   564| }
   565| void
   566| mono_monoctx_to_sigctx (MonoContext *mctx, void *sigctx)
   567| {
   568| #ifdef MONO_CROSS_COMPILE
   569| 	g_assert_not_reached ();
   570| #else
   571| 	ucontext_t *uctx = sigctx;
   572| 	memcpy (&uctx->uc_mcontext.__gregs, &mctx->gregs, sizeof (host_mgreg_t) * G_N_ELEMENTS (mctx->gregs));
   573| 	memcpy (&uctx->uc_mcontext.__fpregs, &mctx->fregs, sizeof (double) * G_N_ELEMENTS (mctx->fregs));
   574| #endif
   575| }
   576| #endif /* #if defined(__i386__) */


# ====================================================================
# FILE: src/native/eventpipe/ds-ipc-pal-namedpipe.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-805 ---
     1| #ifdef FEATURE_PERFTRACING_STANDALONE_PAL
     2| #define EP_NO_RT_DEPENDENCY
     3| #endif
     4| #include "ds-rt-config.h"
     5| #ifdef ENABLE_PERFTRACING
     6| #ifdef HOST_WIN32
     7| #define DS_IMPL_IPC_PAL_NAMEDPIPE_GETTER_SETTER
     8| #include "ds-ipc-pal-namedpipe.h"
     9| #include <assert.h>
    10| #include <stdlib.h>
    11| #include <stdio.h>
    12| #ifndef FEATURE_PERFTRACING_STANDALONE_PAL
    13| #include "ds-rt.h"
    14| #else
    15| #ifndef ep_raise_error_if_nok
    16| #define ep_raise_error_if_nok(expr) do { if (!(expr)) goto ep_on_error; } while (0)
    17| #endif
    18| #ifndef ep_raise_error
    19| #define ep_raise_error() do { goto ep_on_error; } while (0)
    20| #endif
    21| #ifndef ep_exit_error_handler
    22| #define ep_exit_error_handler() do { goto ep_on_exit; } while (0)
    23| #endif
    24| #ifndef EP_ASSERT
    25| #define EP_ASSERT assert
    26| #endif
    27| #ifndef DS_ENTER_BLOCKING_PAL_SECTION
    28| #define DS_ENTER_BLOCKING_PAL_SECTION
    29| #endif
    30| #ifndef DS_EXIT_BLOCKING_PAL_SECTION
    31| #define DS_EXIT_BLOCKING_PAL_SECTION
    32| #endif
    33| #undef ep_rt_object_alloc
    34| #define ep_rt_object_alloc(obj_type) ((obj_type *)calloc(1, sizeof(obj_type)))
    35| static
    36| inline
    37| void
    38| ep_rt_object_free (void *ptr)
    39| {
    40| 	if (ptr)
    41| 		free (ptr);
    42| }
    43| #endif /* !FEATURE_PERFTRACING_STANDALONE_PAL */
    44| static HANDLE _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
    45| /*
    46|  * Forward declares of all static functions.
    47|  */
    48| static
    49| void
    50| ipc_stream_free_func (void *object);
    51| static
    52| bool
    53| ipc_stream_read_func (
    54| 	void *object,
    55| 	uint8_t *buffer,
    56| 	uint32_t bytes_to_read,
    57| 	uint32_t *bytes_read,
    58| 	uint32_t timeout_ms);
    59| static
    60| bool
    61| ipc_stream_write_func (
    62| 	void *object,
    63| 	const uint8_t *buffer,
    64| 	uint32_t bytes_to_write,
    65| 	uint32_t *bytes_written,
    66| 	uint32_t timeout_ms);
    67| static
    68| bool
    69| ipc_stream_flush_func (void *object);
    70| static
    71| bool
    72| ipc_stream_close_func (void *object);
    73| static
    74| void
    75| ipc_close_ownership_handle (
    76|     ds_ipc_error_callback_func callback);
    77| static
    78| bool
    79| ipc_createpipe_helper (
    80| 	DiagnosticsIpc *ipc,
    81| 	bool ensure_pipe_creation,
    82| 	ds_ipc_error_callback_func callback);
    83| static
    84| DiagnosticsIpcStream *
    85| ipc_stream_alloc (
    86| 	HANDLE pipe,
    87| 	DiagnosticsIpcConnectionMode mode);
    88| /*
    89|  * DiagnosticsIpc.
    90|  */
    91| bool
    92| ds_ipc_pal_init (void)
    93| {
    94| 	return true;
    95| }
    96| bool
    97| ds_ipc_pal_shutdown (ds_ipc_error_callback_func callback)
    98| {
    99|     ipc_close_ownership_handle(callback);
   100| 	return true;
   101| }
   102| DiagnosticsIpc *
   103| ds_ipc_alloc (
   104| 	const ep_char8_t *ipc_name,
   105| 	DiagnosticsIpcConnectionMode mode,
   106| 	ds_ipc_error_callback_func callback)
   107| {
   108| 	int32_t characters_written = -1;
   109| 	DiagnosticsIpc *instance = ep_rt_object_alloc (DiagnosticsIpc);
   110| 	ep_raise_error_if_nok (instance != NULL);
   111| 	instance->mode = mode;
   112| 	instance->is_listening = false;
   113| 	instance->overlap.hEvent = INVALID_HANDLE_VALUE;
   114| 	instance->pipe = INVALID_HANDLE_VALUE;
   115| 	if (ipc_name) {
   116| 		characters_written = sprintf_s (
   117| 			(char *)&instance->pipe_name,
   118| 			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
   119| 			(const char *)"\\\\.\\pipe\\%s",
   120| 			ipc_name);
   121| 	} else {
   122| 		characters_written = sprintf_s (
   123| 			(char *)&instance->pipe_name,
   124| 			(size_t)DS_IPC_WIN32_MAX_NAMED_PIPE_LEN,
   125| 			(const char *)"\\\\.\\pipe\\dotnet-diagnostic-%d",
   126| 			GetCurrentProcessId ());
   127| 	}
   128| 	if (characters_written <= 0 || characters_written >= DS_IPC_WIN32_MAX_NAMED_PIPE_LEN) {
   129| 		if (callback)
   130| 			callback ("Failed to generate the named pipe name", characters_written);
   131| 		ep_raise_error ();
   132| 	}
   133| ep_on_exit:
   134| 	return instance;
   135| ep_on_error:
   136| 	ds_ipc_free (instance);
   137| 	instance = NULL;
   138| 	ep_exit_error_handler ();
   139| }
   140| void
   141| ds_ipc_free (DiagnosticsIpc *ipc)
   142| {
   143| 	if (!ipc)
   144| 		return;
   145| 	ds_ipc_close (ipc, false, NULL);
   146| 	ep_rt_object_free (ipc);
   147| }
   148| int32_t
   149| ds_ipc_poll (
   150| 	DiagnosticsIpcPollHandle *poll_handles_data,
   151| 	size_t poll_handles_data_len,
   152| 	uint32_t timeout_ms,
   153| 	ds_ipc_error_callback_func callback)
   154| {
   155| 	EP_ASSERT (poll_handles_data != NULL);
   156| 	int32_t result = 1;
   157| 	EP_ASSERT (poll_handles_data_len <= MAXIMUM_WAIT_OBJECTS);
   158| 	HANDLE handles [MAXIMUM_WAIT_OBJECTS];
   159| 	for (size_t i = 0; i < poll_handles_data_len; ++i) {
   160| 		poll_handles_data [i].events = 0; // ignore any input on events.
   161| 		if (poll_handles_data [i].ipc) {
   162| 			EP_ASSERT (poll_handles_data [i].ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   163| 			handles [i] = poll_handles_data [i].ipc->overlap.hEvent;
   164| 		} else {
   165| 			bool success = true;
   166| 			DWORD bytes_read = 1;
   167| 			if (!poll_handles_data [i].stream->is_test_reading) {
   168| 				success = ReadFile (
   169| 					poll_handles_data [i].stream->pipe,                                   // handle
   170| 					NULL,                                                                 // null buffer
   171| 					0,                                                                    // read 0 bytesd
   172| 					&bytes_read,                                                          // dummy variable
   173| 					&poll_handles_data [i].stream->overlap);    // overlap object to use
   174| 				poll_handles_data [i].stream->is_test_reading = true;
   175| 				if (!success) {
   176| 					DWORD error = GetLastError ();
   177| 					switch (error) {
   178| 					case ERROR_IO_PENDING:
   179| 						handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   180| 						break;
   181| 					case ERROR_PIPE_NOT_CONNECTED:
   182| 						poll_handles_data [i].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   183| 						result = -1;
   184| 						ep_raise_error ();
   185| 					default:
   186| 						if (callback)
   187| 							callback ("0 byte async read on client connection failed", error);
   188| 						result = -1;
   189| 						ep_raise_error ();
   190| 					}
   191| 				} else {
   192| 					handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   193| 				}
   194| 			} else {
   195| 				handles [i] = poll_handles_data [i].stream->overlap.hEvent;
   196| 			}
   197| 		}
   198| 	}
   199| 	DWORD wait = WAIT_FAILED;
   200| 	DS_ENTER_BLOCKING_PAL_SECTION;
   201| 	wait = WaitForMultipleObjects (
   202| 		(DWORD)poll_handles_data_len,      // count
   203| 		handles,                           // handles
   204| 		false,                             // don't wait all
   205| 		(DWORD)timeout_ms);
   206| 	DS_EXIT_BLOCKING_PAL_SECTION;
   207| 	if (wait == WAIT_TIMEOUT) {
   208| 		result = 0;
   209| 		ep_raise_error ();
   210| 	}
   211| 	if (wait == WAIT_FAILED) {
   212| 		if (callback)
   213| 			callback ("WaitForMultipleObjects failed", GetLastError());
   214| 		result = -1;
   215| 		ep_raise_error ();
   216| 	}
   217| 	DWORD index = wait - WAIT_OBJECT_0;
   218| 	if (index < 0 || index > (poll_handles_data_len - 1)) {
   219| 		DWORD abandonedIndex = wait - WAIT_ABANDONED_0;
   220| 		if (abandonedIndex > 0 || abandonedIndex < (poll_handles_data_len - 1)) {
   221| 			poll_handles_data [abandonedIndex].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   222| 			result = -1;
   223| 			ep_raise_error ();
   224| 		} else {
   225| 			if (callback)
   226| 				callback ("WaitForMultipleObjects failed", GetLastError());
   227| 			result = -1;
   228| 			ep_raise_error ();
   229| 		}
   230| 	}
   231| 	if (!poll_handles_data [index].ipc) {
   232| 		DWORD dummy = 0;
   233| 		BOOL success = GetOverlappedResult(
   234| 			poll_handles_data [index].stream->pipe,
   235| 			&poll_handles_data [index].stream->overlap,
   236| 			&dummy,
   237| 			false);
   238| 		if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
   239| 			dummy = 0;
   240| 			DS_ENTER_BLOCKING_PAL_SECTION;
   241| 			success = GetOverlappedResult(
   242| 				poll_handles_data [index].stream->pipe,
   243| 				&poll_handles_data [index].stream->overlap,
   244| 				&dummy,
   245| 				true);
   246| 			DS_EXIT_BLOCKING_PAL_SECTION;
   247| 		}
   248| 		poll_handles_data [index].stream->is_test_reading = false;
   249| 		if (!success) {
   250| 			DWORD error = GetLastError();
   251| 			if (error == ERROR_PIPE_NOT_CONNECTED || error == ERROR_BROKEN_PIPE) {
   252| 				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_HANGUP;
   253| 			} else {
   254| 				if (callback)
   255| 					callback ("Client connection error", error);
   256| 				poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_ERR;
   257| 				result = -1;
   258| 				ep_raise_error ();
   259| 			}
   260| 		} else {
   261| 			poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
   262| 		}
   263| 	} else {
   264| 		poll_handles_data [index].events = (uint8_t)DS_IPC_POLL_EVENTS_SIGNALED;
   265| 	}
   266| 	result = 1;
   267| ep_on_exit:
   268| 	return result;
   269| ep_on_error:
   270| 	if (result == 1)
   271| 		result = -1;
   272| 	ep_exit_error_handler ();
   273| }
   274| static
   275| bool
   276| ipc_createpipe_helper (
   277| 	DiagnosticsIpc *ipc,
   278| 	bool ensure_pipe_creation,
   279| 	ds_ipc_error_callback_func callback)
   280| {
   281| 	bool result = false;
   282| 	EP_ASSERT (ipc != NULL);
   283| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   284| 	if (ipc->mode != DS_IPC_CONNECTION_MODE_LISTEN) {
   285| 		if (callback)
   286| 			callback ("Cannot call Listen on a client connection", -1);
   287| 		return false;
   288| 	}
   289| 	if (ipc->is_listening)
   290| 		return true;
   291|     if (!ensure_pipe_creation && _ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
   292|     {
   293|         if (callback)
   294| 			callback ("Can't ensure we have ownership of the pipe. Disallowing creation.", -1);
   295| 		return false;
   296|     }
   297|     if (ensure_pipe_creation && _ipc_listen_ownership_handle != INVALID_HANDLE_VALUE)
   298|     {
   299|         if (callback)
   300| 			callback ("Inconsistent state - pipe sentinel already in use for listen.", -1);
   301| 		return false;
   302|     }
   303|     EP_ASSERT (ipc->pipe == INVALID_HANDLE_VALUE);
   304| 	const uint32_t in_buffer_size = 16 * 1024;
   305| 	const uint32_t out_buffer_size = 16 * 1024;
   306| 	DWORD creationFlags = PIPE_ACCESS_DUPLEX    // read/write access
   307|                 | FILE_FLAG_OVERLAPPED;	        // async listening.
   308| 	if (ensure_pipe_creation)
   309| 	{
   310| 		creationFlags |= FILE_FLAG_FIRST_PIPE_INSTANCE;
   311| 	}
   312| 	DS_ENTER_BLOCKING_PAL_SECTION;
   313| 	ipc->pipe = CreateNamedPipeA (
   314| 		ipc->pipe_name,                                             // pipe name
   315| 		creationFlags,
   316| 		PIPE_TYPE_BYTE | PIPE_WAIT | PIPE_REJECT_REMOTE_CLIENTS,    // message type pipe, message-read and blocking mode
   317| 		PIPE_UNLIMITED_INSTANCES,                                   // max. instances
   318| 		out_buffer_size,                                            // output buffer size
   319| 		in_buffer_size,                                             // input buffer size
   320| 		0,                                                          // default client time-out
   321| 		NULL);                                                      // default security attribute
   322| 	DS_EXIT_BLOCKING_PAL_SECTION;
   323| 	if (ipc->pipe == INVALID_HANDLE_VALUE) {
   324| 		if (callback)
   325| 			callback ("Failed to create an instance of a named pipe.", GetLastError());
   326| 		ep_raise_error ();
   327| 	}
   328|     if (ensure_pipe_creation)
   329| 	{
   330| 	    EP_ASSERT (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE);
   331|         bool createdSentinel = DuplicateHandle(
   332|                                     GetCurrentProcess(),
   333|                                     ipc->pipe,
   334|                                     GetCurrentProcess(),
   335|                                     &_ipc_listen_ownership_handle,
   336|                                     0,
   337|                                     FALSE,
   338|                                     DUPLICATE_SAME_ACCESS);
   339|         if (!createdSentinel)
   340|         {
   341|             if (callback)
   342| 			    callback ("Failed to ownership sentinel.", GetLastError());
   343|             ep_raise_error();
   344|         }
   345| 	}
   346| 	EP_ASSERT (ipc->overlap.hEvent == INVALID_HANDLE_VALUE);
   347| 	ipc->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
   348| 	if (!ipc->overlap.hEvent) {
   349| 		if (callback)
   350| 			callback ("Failed to create overlap event", GetLastError());
   351| 		ep_raise_error ();
   352| 	}
   353| 	if (ConnectNamedPipe (ipc->pipe, &ipc->overlap) == FALSE) {
   354| 		const DWORD error_code = GetLastError ();
   355| 		switch (error_code) {
   356| 		case ERROR_IO_PENDING:
   357| 		case ERROR_PIPE_CONNECTED:
   358| 			break;
   359| 		default:
   360| 			if (callback)
   361| 				callback ("A client process failed to connect.", error_code);
   362| 			ep_raise_error ();
   363| 		}
   364| 	}
   365| 	ipc->is_listening = true;
   366| 	result = true;
   367| ep_on_exit:
   368| 	return result;
   369| ep_on_error:
   370| 	ds_ipc_close (ipc, false, callback);
   371|     if (ensure_pipe_creation)
   372|         ipc_close_ownership_handle(callback);
   373| 	result = false;
   374| 	ep_exit_error_handler ();
   375| }
   376| bool
   377| ds_ipc_listen (
   378| 	DiagnosticsIpc *ipc,
   379| 	ds_ipc_error_callback_func callback)
   380| {
   381| 	return ipc_createpipe_helper(ipc, true, callback);
   382| }
   383| DiagnosticsIpcStream *
   384| ds_ipc_accept (
   385| 	DiagnosticsIpc *ipc,
   386| 	ds_ipc_error_callback_func callback)
   387| {
   388| 	EP_ASSERT (ipc != NULL);
   389| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN);
   390| 	DiagnosticsIpcStream *stream = NULL;
   391| 	DWORD dummy = 0;
   392| 	BOOL success = GetOverlappedResult (
   393| 		ipc->pipe,      // handle
   394| 		&ipc->overlap,  // overlapped
   395| 		&dummy,         // throw-away dword
   396| 		false);         // wait till event signals
   397| 	if (!success && GetLastError () == ERROR_IO_INCOMPLETE) {
   398| 		dummy = 0;
   399| 		DS_ENTER_BLOCKING_PAL_SECTION;
   400| 		success = GetOverlappedResult (
   401| 			ipc->pipe,      // handle
   402| 			&ipc->overlap,  // overlapped
   403| 			&dummy,         // throw-away dword
   404| 			true);          // wait till event signals
   405| 		DS_EXIT_BLOCKING_PAL_SECTION;
   406| 	}
   407| 	if (!success) {
   408| 		if (callback)
   409| 			callback ("Failed to GetOverlappedResults for NamedPipe server", GetLastError());
   410| 		CloseHandle (ipc->pipe);
   411| 	} else {
   412| 		stream = ipc_stream_alloc (ipc->pipe, DS_IPC_CONNECTION_MODE_LISTEN);
   413| 		ep_raise_error_if_nok (stream != NULL);
   414| 	}
   415| 	ipc->pipe = INVALID_HANDLE_VALUE;
   416| 	ipc->is_listening = false;
   417| 	CloseHandle (ipc->overlap.hEvent);
   418| 	memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   419| 	ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
   420| 	ep_raise_error_if_nok (ipc_createpipe_helper (ipc, false, callback));
   421| ep_on_exit:
   422| 	return stream;
   423| ep_on_error:
   424| 	ds_ipc_stream_free (stream);
   425| 	stream = NULL;
   426| 	ep_exit_error_handler ();
   427| }
   428| DiagnosticsIpcStream *
   429| ds_ipc_connect (
   430| 	DiagnosticsIpc *ipc,
   431| 	uint32_t timeout_ms,
   432| 	ds_ipc_error_callback_func callback,
   433| 	bool *timed_out)
   434| {
   435| 	EP_ASSERT (ipc != NULL);
   436| 	EP_ASSERT (timed_out != NULL);
   437| 	EP_ASSERT (ipc->mode == DS_IPC_CONNECTION_MODE_CONNECT);
   438| 	DiagnosticsIpcStream *stream = NULL;
   439| 	HANDLE pipe = INVALID_HANDLE_VALUE;
   440| 	if (ipc->mode != DS_IPC_CONNECTION_MODE_CONNECT) {
   441| 		if (callback)
   442| 			callback ("Cannot call connect on a server connection", 0);
   443| 		ep_raise_error ();
   444| 	}
   445| 	DS_ENTER_BLOCKING_PAL_SECTION;
   446| 	pipe = CreateFileA(
   447| 		ipc->pipe_name,         // pipe name
   448| 		PIPE_ACCESS_DUPLEX,     // read/write access
   449| 		0,                      // no sharing
   450| 		NULL,                   // default security attributes
   451| 		OPEN_EXISTING,          // opens existing pipe
   452| 		FILE_FLAG_OVERLAPPED,   // overlapped
   453| 		NULL);                  // no template file
   454| 	DS_EXIT_BLOCKING_PAL_SECTION;
   455| 	if (pipe == INVALID_HANDLE_VALUE) {
   456| 		if (callback)
   457| 			callback ("Failed to connect to named pipe.", GetLastError ());
   458| 		ep_raise_error ();
   459| 	}
   460| 	stream = ipc_stream_alloc (pipe, ipc->mode);
   461| 	ep_raise_error_if_nok (stream);
   462| 	pipe = INVALID_HANDLE_VALUE;
   463| ep_on_exit:
   464| 	return stream;
   465| ep_on_error:
   466| 	ds_ipc_stream_free (stream);
   467| 	stream = NULL;
   468| 	if (pipe != INVALID_HANDLE_VALUE) {
   469| 		CloseHandle (pipe);
   470| 	}
   471| 	ep_exit_error_handler ();
   472| }
   473| void
   474| ipc_close_ownership_handle (
   475|     ds_ipc_error_callback_func callback)
   476| {
   477|     if (_ipc_listen_ownership_handle == INVALID_HANDLE_VALUE)
   478|         return;
   479|     const BOOL success_close_pipe = CloseHandle(_ipc_listen_ownership_handle);
   480|     if (success_close_pipe != TRUE)
   481|     {
   482|         if (callback)
   483|             callback ("Failed to IPC ownership sentinel handle", GetLastError());
   484|         return;
   485|     }
   486|     _ipc_listen_ownership_handle = INVALID_HANDLE_VALUE;
   487| }
   488| void
   489| ds_ipc_close (
   490| 	DiagnosticsIpc *ipc,
   491| 	bool is_shutdown,
   492| 	ds_ipc_error_callback_func callback)
   493| {
   494| 	EP_ASSERT (ipc != NULL);
   495| 	if (is_shutdown) {
   496| 		if (callback)
   497| 			callback ("Closing without cleaning underlying handles", 100);
   498| 		return;
   499| 	}
   500| 	if (ipc->pipe != INVALID_HANDLE_VALUE) {
   501| 		if (ipc->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
   502| 			BOOL success_disconnect = FALSE;
   503| 			DS_ENTER_BLOCKING_PAL_SECTION;
   504| 			success_disconnect = DisconnectNamedPipe (ipc->pipe);
   505| 			DS_EXIT_BLOCKING_PAL_SECTION;
   506| 			if (success_disconnect != TRUE && callback)
   507| 				callback ("Failed to disconnect NamedPipe", GetLastError());
   508| 		}
   509| 		const BOOL success_close_pipe = CloseHandle (ipc->pipe);
   510| 		if (success_close_pipe != TRUE && callback)
   511| 			callback ("Failed to close pipe handle", GetLastError());
   512| 		ipc->pipe = INVALID_HANDLE_VALUE;
   513| 	}
   514| 	if (ipc->overlap.hEvent != INVALID_HANDLE_VALUE) {
   515| 		const BOOL success_close_event = CloseHandle (ipc->overlap.hEvent);
   516| 		if (success_close_event != TRUE && callback)
   517| 			callback ("Failed to close overlap event handle", GetLastError());
   518| 		memset(&ipc->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   519| 		ipc->overlap.hEvent = INVALID_HANDLE_VALUE;
   520| 	}
   521| }
   522| int32_t
   523| ds_ipc_to_string (
   524| 	DiagnosticsIpc *ipc,
   525| 	ep_char8_t *buffer,
   526| 	uint32_t buffer_len)
   527| {
   528| 	EP_ASSERT (ipc != NULL);
   529| 	EP_ASSERT (buffer != NULL);
   530| 	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
   531| 	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc->pipe, (int32_t)(size_t)ipc->overlap.hEvent);
   532| 	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
   533| }
   534| /*
   535|  * DiagnosticsIpcStream.
   536|  */
   537| static
   538| void
   539| ipc_stream_free_func (void *object)
   540| {
   541| 	EP_ASSERT (object != NULL);
   542| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   543| 	ds_ipc_stream_free (ipc_stream);
   544| }
   545| static
   546| bool
   547| ipc_stream_read_func (
   548| 	void *object,
   549| 	uint8_t *buffer,
   550| 	uint32_t bytes_to_read,
   551| 	uint32_t *bytes_read,
   552| 	uint32_t timeout_ms)
   553| {
   554| 	EP_ASSERT (object != NULL);
   555| 	EP_ASSERT (buffer != NULL);
   556| 	EP_ASSERT (bytes_read != NULL);
   557| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   558| 	DWORD read = 0;
   559| 	LPOVERLAPPED overlap = &ipc_stream->overlap;
   560| 	bool success = ReadFile (
   561| 		ipc_stream->pipe,   // handle to pipe
   562| 		buffer,             // buffer to receive data
   563| 		bytes_to_read,      // size of buffer
   564| 		&read,              // number of bytes read
   565| 		overlap) != FALSE;  // overlapped I/O
   566| 	if (!success) {
   567| 		DWORD error = GetLastError ();
   568| 		if (error == ERROR_IO_PENDING) {
   569| 			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
   570| 				DS_ENTER_BLOCKING_PAL_SECTION;
   571| 				success = GetOverlappedResult (
   572| 					ipc_stream->pipe,   // pipe
   573| 					overlap,            // overlapped
   574| 					&read,              // out actual number of bytes read
   575| 					true) != FALSE;     // block until async IO completes
   576| 				DS_EXIT_BLOCKING_PAL_SECTION;
   577| 			} else {
   578| 				DS_ENTER_BLOCKING_PAL_SECTION;
   579| 				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
   580| 				if (wait == WAIT_OBJECT_0) {
   581| 					success = GetOverlappedResult (
   582| 						ipc_stream->pipe,   // pipe
   583| 						overlap,            // overlapped
   584| 						&read,              // out actual number of bytes read
   585| 						true) != FALSE;     // block until async IO completes
   586| 				} else {
   587| 					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
   588| 						success = GetOverlappedResult (
   589| 							ipc_stream->pipe,   // pipe
   590| 							overlap,            // overlapped
   591| 							&read,              // out actual number of bytes read
   592| 							true) != FALSE;     // block until async IO completes
   593| 					}
   594| 				}
   595| 				DS_EXIT_BLOCKING_PAL_SECTION;
   596| 			}
   597| 		}
   598| 	}
   599| 	*bytes_read = (uint32_t)read;
   600| 	return success;
   601| }
   602| static
   603| bool
   604| ipc_stream_write_func (
   605| 	void *object,
   606| 	const uint8_t *buffer,
   607| 	uint32_t bytes_to_write,
   608| 	uint32_t *bytes_written,
   609| 	uint32_t timeout_ms)
   610| {
   611| 	EP_ASSERT (object != NULL);
   612| 	EP_ASSERT (buffer != NULL);
   613| 	EP_ASSERT (bytes_written != NULL);
   614| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   615| 	DWORD written = 0;
   616| 	LPOVERLAPPED overlap = &ipc_stream->overlap;
   617| 	bool success = WriteFile (
   618| 		ipc_stream->pipe,   // handle to pipe
   619| 		buffer,             // buffer to write from
   620| 		bytes_to_write,     // number of bytes to write
   621| 		&written,           // number of bytes written
   622| 		overlap) != FALSE;  // overlapped I/O
   623| 	if (!success) {
   624| 		DWORD error = GetLastError ();
   625| 		if (error == ERROR_IO_PENDING) {
   626| 			if (timeout_ms == DS_IPC_TIMEOUT_INFINITE) {
   627| 				DS_ENTER_BLOCKING_PAL_SECTION;
   628| 				success = GetOverlappedResult (
   629| 					ipc_stream->pipe,   // pipe
   630| 					overlap,            // overlapped
   631| 					&written,           // out actual number of bytes written
   632| 					true) != FALSE;     // block until async IO completes
   633| 				DS_EXIT_BLOCKING_PAL_SECTION;
   634| 			} else {
   635| 				DS_ENTER_BLOCKING_PAL_SECTION;
   636| 				DWORD wait = WaitForSingleObject (ipc_stream->overlap.hEvent, (DWORD)timeout_ms);
   637| 				if (wait == WAIT_OBJECT_0) {
   638| 					success = GetOverlappedResult (
   639| 						ipc_stream->pipe,   // pipe
   640| 						overlap,            // overlapped
   641| 						&written,           // out actual number of bytes written
   642| 						true) != FALSE;     // block until async IO completes
   643| 				} else {
   644| 					if (CancelIoEx (ipc_stream->pipe, overlap) != FALSE) {
   645| 						success = GetOverlappedResult (
   646| 							ipc_stream->pipe,   // pipe
   647| 							overlap,            // overlapped
   648| 							&written,           // out actual number of bytes written
   649| 							true) != FALSE;         // block until async IO completes
   650| 					}
   651| 				}
   652| 				DS_EXIT_BLOCKING_PAL_SECTION;
   653| 			}
   654| 		}
   655| 	}
   656| 	*bytes_written = (uint32_t)written;
   657| 	return success;
   658| }
   659| static
   660| bool
   661| ipc_stream_flush_func (void *object)
   662| {
   663| 	EP_ASSERT (object != NULL);
   664| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   665| 	bool success = false;
   666| 	DS_ENTER_BLOCKING_PAL_SECTION;
   667| 	success = FlushFileBuffers (ipc_stream->pipe) != FALSE;
   668| 	DS_EXIT_BLOCKING_PAL_SECTION;
   669| 	return success;
   670| }
   671| static
   672| bool
   673| ipc_stream_close_func (void *object)
   674| {
   675| 	EP_ASSERT (object != NULL);
   676| 	DiagnosticsIpcStream *ipc_stream = (DiagnosticsIpcStream *)object;
   677| 	return ds_ipc_stream_close (ipc_stream, NULL);
   678| }
   679| static IpcStreamVtable ipc_stream_vtable = {
   680| 	ipc_stream_free_func,
   681| 	ipc_stream_read_func,
   682| 	ipc_stream_write_func,
   683| 	ipc_stream_flush_func,
   684| 	ipc_stream_close_func };
   685| static
   686| DiagnosticsIpcStream *
   687| ipc_stream_alloc (
   688| 	HANDLE pipe,
   689| 	DiagnosticsIpcConnectionMode mode)
   690| {
   691| 	DiagnosticsIpcStream *instance = ep_rt_object_alloc (DiagnosticsIpcStream);
   692| 	ep_raise_error_if_nok (instance != NULL);
   693| 	instance->stream.vtable = &ipc_stream_vtable;
   694| 	instance->pipe = pipe;
   695| 	instance->mode = mode;
   696| 	instance->overlap.hEvent = CreateEventW (NULL, true, false, NULL);
   697| ep_on_exit:
   698| 	return instance;
   699| ep_on_error:
   700| 	ds_ipc_stream_free (instance);
   701| 	instance = NULL;
   702| 	ep_exit_error_handler ();
   703| }
   704| int32_t
   705| ds_ipc_stream_get_handle_int32_t (DiagnosticsIpcStream *ipc_stream)
   706| {
   707| 	return (int32_t)(size_t)ipc_stream->pipe;
   708| }
   709| IpcStream *
   710| ds_ipc_stream_get_stream_ref (DiagnosticsIpcStream *ipc_stream)
   711| {
   712| 	return &ipc_stream->stream;
   713| }
   714| void
   715| ds_ipc_stream_free (DiagnosticsIpcStream *ipc_stream)
   716| {
   717| 	if (!ipc_stream)
   718| 		return;
   719| 	ds_ipc_stream_close (ipc_stream, NULL);
   720| 	ep_rt_object_free (ipc_stream);
   721| }
   722| bool
   723| ds_ipc_stream_read (
   724| 	DiagnosticsIpcStream *ipc_stream,
   725| 	uint8_t *buffer,
   726| 	uint32_t bytes_to_read,
   727| 	uint32_t *bytes_read,
   728| 	uint32_t timeout_ms)
   729| {
   730| 	return ipc_stream_read_func (
   731| 		ipc_stream,
   732| 		buffer,
   733| 		bytes_to_read,
   734| 		bytes_read,
   735| 		timeout_ms);
   736| }
   737| bool
   738| ds_ipc_stream_write (
   739| 	DiagnosticsIpcStream *ipc_stream,
   740| 	const uint8_t *buffer,
   741| 	uint32_t bytes_to_write,
   742| 	uint32_t *bytes_written,
   743| 	uint32_t timeout_ms)
   744| {
   745| 	return ipc_stream_write_func (
   746| 		ipc_stream,
   747| 		buffer,
   748| 		bytes_to_write,
   749| 		bytes_written,
   750| 		timeout_ms);
   751| }
   752| bool
   753| ds_ipc_stream_flush (DiagnosticsIpcStream *ipc_stream)
   754| {
   755| 	return ipc_stream_flush_func (ipc_stream);
   756| }
   757| bool
   758| ds_ipc_stream_close (
   759| 	DiagnosticsIpcStream *ipc_stream,
   760| 	ds_ipc_error_callback_func callback)
   761| {
   762| 	EP_ASSERT (ipc_stream != NULL);
   763| 	if (ipc_stream->pipe != INVALID_HANDLE_VALUE) {
   764| 		ds_ipc_stream_flush (ipc_stream);
   765| 		if (ipc_stream->mode == DS_IPC_CONNECTION_MODE_LISTEN) {
   766| 			BOOL success_disconnect = FALSE;
   767| 			DS_ENTER_BLOCKING_PAL_SECTION;
   768| 			success_disconnect = DisconnectNamedPipe (ipc_stream->pipe);
   769| 			DS_EXIT_BLOCKING_PAL_SECTION;
   770| 			if (success_disconnect != TRUE && callback)
   771| 				callback ("Failed to disconnect NamedPipe", GetLastError());
   772| 		}
   773| 		const BOOL success_close_pipe = CloseHandle (ipc_stream->pipe);
   774| 		if (success_close_pipe != TRUE && callback)
   775| 			callback ("Failed to close pipe handle", GetLastError());
   776| 		ipc_stream->pipe = INVALID_HANDLE_VALUE;
   777| 	}
   778| 	if (ipc_stream->overlap.hEvent != INVALID_HANDLE_VALUE) {
   779| 		const BOOL success_close_event = CloseHandle (ipc_stream->overlap.hEvent);
   780| 		if (success_close_event != TRUE && callback)
   781| 			callback ("Failed to close overlapped event handle", GetLastError());
   782| 		memset(&ipc_stream->overlap, 0, sizeof(OVERLAPPED)); // clear the overlapped objects state
   783| 		ipc_stream->overlap.hEvent = INVALID_HANDLE_VALUE;
   784| 	}
   785| 	ipc_stream->is_test_reading = false;
   786| 	return true;
   787| }
   788| int32_t
   789| ds_ipc_stream_to_string (
   790| 	DiagnosticsIpcStream *ipc_stream,
   791| 	ep_char8_t *buffer,
   792| 	uint32_t buffer_len)
   793| {
   794| 	EP_ASSERT (ipc_stream != NULL);
   795| 	EP_ASSERT (buffer != NULL);
   796| 	EP_ASSERT (buffer_len <= DS_IPC_MAX_TO_STRING_LEN);
   797| 	int32_t result = sprintf_s (buffer, buffer_len, "{ _hPipe = %d, _oOverlap.hEvent = %d }", (int32_t)(size_t)ipc_stream->pipe, (int32_t)(size_t)ipc_stream->overlap.hEvent);
   798| 	return (result > 0 && result < (int32_t)buffer_len) ? result : 0;
   799| }
   800| #endif /* HOST_WIN32 */
   801| #endif /* ENABLE_PERFTRACING */
   802| #ifndef DS_INCLUDE_SOURCE_FILES
   803| extern const char quiet_linker_empty_file_warning_diagnostics_ipc_win32;
   804| const char quiet_linker_empty_file_warning_diagnostics_ipc_win32 = 0;
   805| #endif


# ====================================================================
# FILE: src/native/external/zlib-intel/compress.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| /* compress.c -- compress a memory buffer
     2|  * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #define ZLIB_INTERNAL
     7| #include "zlib.h"
     8| /* ===========================================================================
     9|      Compresses the source buffer into the destination buffer. The level
    10|    parameter has the same meaning as in deflateInit.  sourceLen is the byte
    11|    length of the source buffer. Upon entry, destLen is the total size of the
    12|    destination buffer, which must be at least 0.1% larger than sourceLen plus
    13|    12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
    14|      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
    15|    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
    16|    Z_STREAM_ERROR if the level parameter is invalid.
    17| */
    18| int ZEXPORT compress2(dest, destLen, source, sourceLen, level)
    19|     Bytef *dest;
    20|     uLongf *destLen;
    21|     const Bytef *source;
    22|     uLong sourceLen;
    23|     int level;
    24| {
    25|     z_stream stream;
    26|     int err;
    27|     const uInt max = (uInt)-1;
    28|     uLong left;
    29|     left = *destLen;
    30|     *destLen = 0;
    31|     stream.zalloc = (alloc_func)0;
    32|     stream.zfree = (free_func)0;
    33|     stream.opaque = (voidpf)0;
    34|     err = deflateInit(&stream, level);
    35|     if (err != Z_OK) return err;
    36|     stream.next_out = dest;
    37|     stream.avail_out = 0;
    38|     stream.next_in = (z_const Bytef *)source;
    39|     stream.avail_in = 0;
    40|     do {
    41|         if (stream.avail_out == 0) {
    42|             stream.avail_out = left > (uLong)max ? max : (uInt)left;
    43|             left -= stream.avail_out;
    44|         }
    45|         if (stream.avail_in == 0) {
    46|             stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
    47|             sourceLen -= stream.avail_in;
    48|         }
    49|         err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
    50|     } while (err == Z_OK);
    51|     *destLen = stream.total_out;
    52|     deflateEnd(&stream);
    53|     return err == Z_STREAM_END ? Z_OK : err;
    54| }
    55| /* ===========================================================================
    56|  */
    57| int ZEXPORT compress(dest, destLen, source, sourceLen)
    58|     Bytef *dest;
    59|     uLongf *destLen;
    60|     const Bytef *source;
    61|     uLong sourceLen;
    62| {
    63|     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
    64| }
    65| /* ===========================================================================
    66|      If the default memLevel or windowBits for deflateInit() is changed, then
    67|    this function needs to be updated.
    68|  */
    69| uLong ZEXPORT compressBound(sourceLen)
    70|     uLong sourceLen;
    71| {
    72|     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
    73|            (sourceLen >> 25) + 13;
    74| }


# ====================================================================
# FILE: src/native/external/zlib-intel/crc32.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1011 ---
     1| /* crc32.c -- compute the CRC-32 of a data stream
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  *
     5|  * This interleaved implementation of a CRC makes use of pipelined multiple
     6|  * arithmetic-logic units, commonly found in modern CPU cores. It is due to
     7|  * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.
     8|  */
     9| /* @(#) $Id$ */
    10| /*
    11|   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
    12|   protection on the static variables used to control the first-use generation
    13|   of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should
    14|   first call get_crc_table() to initialize the tables before allowing more than
    15|   one thread to use crc32().
    16|   MAKECRCH can be #defined to write out crc32.h. A main() routine is also
    17|   produced, so that this one source file can be compiled to an executable.
    18|  */
    19| #ifdef MAKECRCH
    20| #  include <stdio.h>
    21| #  ifndef DYNAMIC_CRC_TABLE
    22| #    define DYNAMIC_CRC_TABLE
    23| #  endif /* !DYNAMIC_CRC_TABLE */
    24| #endif /* MAKECRCH */
    25| #include "zutil.h"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */
    26|  /*
    27|   A CRC of a message is computed on N braids of words in the message, where
    28|   each word consists of W bytes (4 or 8). If N is 3, for example, then three
    29|   running sparse CRCs are calculated respectively on each braid, at these
    30|   indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...
    31|   This is done starting at a word boundary, and continues until as many blocks
    32|   of N * W bytes as are available have been processed. The results are combined
    33|   into a single CRC at the end. For this code, N must be in the range 1..6 and
    34|   W must be 4 or 8. The upper limit on N can be increased if desired by adding
    35|   more #if blocks, extending the patterns apparent in the code. In addition,
    36|   crc32.h would need to be regenerated, if the maximum N value is increased.
    37|   N and W are chosen empirically by benchmarking the execution time on a given
    38|   processor. The choices for N and W below were based on testing on Intel Kaby
    39|   Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64
    40|   Octeon II processors. The Intel, AMD, and ARM processors were all fastest
    41|   with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.
    42|   They were all tested with either gcc or clang, all using the -O3 optimization
    43|   level. Your mileage may vary.
    44|  */
    45| /* Define N */
    46| #ifdef Z_TESTN
    47| #  define N Z_TESTN
    48| #else
    49| #  define N 5
    50| #endif
    51| #if N < 1 || N > 6
    52| #  error N must be in 1..6
    53| #endif
    54| /*
    55|   z_crc_t must be at least 32 bits. z_word_t must be at least as long as
    56|   z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and
    57|   that bytes are eight bits.
    58|  */
    59| /*
    60|   Define W and the associated z_word_t type. If W is not defined, then a
    61|   braided calculation is not used, and the associated tables and code are not
    62|   compiled.
    63|  */
    64| #ifdef Z_TESTW
    65| #  if Z_TESTW-1 != -1
    66| #    define W Z_TESTW
    67| #  endif
    68| #else
    69| #  ifdef MAKECRCH
    70| #    define W 8         /* required for MAKECRCH */
    71| #  else
    72| #    if defined(__x86_64__) || defined(__aarch64__)
    73| #      define W 8
    74| #    else
    75| #      define W 4
    76| #    endif
    77| #  endif
    78| #endif
    79| #ifdef W
    80| #  if W == 8 && defined(Z_U8)
    81|      typedef Z_U8 z_word_t;
    82| #  elif defined(Z_U4)
    83| #    undef W
    84| #    define W 4
    85|      typedef Z_U4 z_word_t;
    86| #  else
    87| #    undef W
    88| #  endif
    89| #endif
    90| /* If available, use the ARM processor CRC32 instruction. */
    91| #if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8
    92| #  define ARMCRC32
    93| #endif
    94| /* Local functions. */
    95| local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));
    96| local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));
    97| #if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
    98|     local z_word_t byte_swap OF((z_word_t word));
    99| #endif
   100| #if defined(W) && !defined(ARMCRC32)
   101|     local z_crc_t crc_word OF((z_word_t data));
   102|     local z_word_t crc_word_big OF((z_word_t data));
   103| #endif
   104| #if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
   105| /*
   106|   Swap the bytes in a z_word_t to convert between little and big endian. Any
   107|   self-respecting compiler will optimize this to a single machine byte-swap
   108|   instruction, if one is available. This assumes that word_t is either 32 bits
   109|   or 64 bits.
   110|  */
   111| local z_word_t byte_swap(word)
   112|     z_word_t word;
   113| {
   114| #  if W == 8
   115|     return
   116|         (word & 0xff00000000000000) >> 56 |
   117|         (word & 0xff000000000000) >> 40 |
   118|         (word & 0xff0000000000) >> 24 |
   119|         (word & 0xff00000000) >> 8 |
   120|         (word & 0xff000000) << 8 |
   121|         (word & 0xff0000) << 24 |
   122|         (word & 0xff00) << 40 |
   123|         (word & 0xff) << 56;
   124| #  else   /* W == 4 */
   125|     return
   126|         (word & 0xff000000) >> 24 |
   127|         (word & 0xff0000) >> 8 |
   128|         (word & 0xff00) << 8 |
   129|         (word & 0xff) << 24;
   130| #  endif
   131| }
   132| #endif
   133| /* CRC polynomial. */
   134| #define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */
   135| #ifdef DYNAMIC_CRC_TABLE
   136| local z_crc_t FAR crc_table[256];
   137| local z_crc_t FAR x2n_table[32];
   138| local void make_crc_table OF((void));
   139| #ifdef W
   140|    local z_word_t FAR crc_big_table[256];
   141|    local z_crc_t FAR crc_braid_table[W][256];
   142|    local z_word_t FAR crc_braid_big_table[W][256];
   143|    local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));
   144| #endif
   145| #ifdef MAKECRCH
   146|    local void write_table OF((FILE *, const z_crc_t FAR *, int));
   147|    local void write_table32hi OF((FILE *, const z_word_t FAR *, int));
   148|    local void write_table64 OF((FILE *, const z_word_t FAR *, int));
   149| #endif /* MAKECRCH */
   150| /*
   151|   Define a once() function depending on the availability of atomics. If this is
   152|   compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in
   153|   multiple threads, and if atomics are not available, then get_crc_table() must
   154|   be called to initialize the tables and must return before any threads are
   155|   allowed to compute or combine CRCs.
   156|  */
   157| /* Definition of once functionality. */
   158| typedef struct once_s once_t;
   159| local void once OF((once_t *, void (*)(void)));
   160| /* Check for the availability of atomics. */
   161| #if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \
   162|     !defined(__STDC_NO_ATOMICS__)
   163| #include <stdatomic.h>
   164| /* Structure for once(), which must be initialized with ONCE_INIT. */
   165| struct once_s {
   166|     atomic_flag begun;
   167|     atomic_int done;
   168| };
   169| #define ONCE_INIT {ATOMIC_FLAG_INIT, 0}
   170| /*
   171|   Run the provided init() function exactly once, even if multiple threads
   172|   invoke once() at the same time. The state must be a once_t initialized with
   173|   ONCE_INIT.
   174|  */
   175| local void once(state, init)
   176|     once_t *state;
   177|     void (*init)(void);
   178| {
   179|     if (!atomic_load(&state->done)) {
   180|         if (atomic_flag_test_and_set(&state->begun))
   181|             while (!atomic_load(&state->done))
   182|                 ;
   183|         else {
   184|             init();
   185|             atomic_store(&state->done, 1);
   186|         }
   187|     }
   188| }
   189| #else   /* no atomics */
   190| /* Structure for once(), which must be initialized with ONCE_INIT. */
   191| struct once_s {
   192|     volatile int begun;
   193|     volatile int done;
   194| };
   195| #define ONCE_INIT {0, 0}
   196| /* Test and set. Alas, not atomic, but tries to minimize the period of
   197|    vulnerability. */
   198| local int test_and_set OF((int volatile *));
   199| local int test_and_set(flag)
   200|     int volatile *flag;
   201| {
   202|     int was;
   203|     was = *flag;
   204|     *flag = 1;
   205|     return was;
   206| }
   207| /* Run the provided init() function once. This is not thread-safe. */
   208| local void once(state, init)
   209|     once_t *state;
   210|     void (*init)(void);
   211| {
   212|     if (!state->done) {
   213|         if (test_and_set(&state->begun))
   214|             while (!state->done)
   215|                 ;
   216|         else {
   217|             init();
   218|             state->done = 1;
   219|         }
   220|     }
   221| }
   222| #endif
   223| /* State for once(). */
   224| local once_t made = ONCE_INIT;
   225| /*
   226|   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
   227|   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
   228|   Polynomials over GF(2) are represented in binary, one bit per coefficient,
   229|   with the lowest powers in the most significant bit. Then adding polynomials
   230|   is just exclusive-or, and multiplying a polynomial by x is a right shift by
   231|   one. If we call the above polynomial p, and represent a byte as the
   232|   polynomial q, also with the lowest power in the most significant bit (so the
   233|   byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,
   234|   where a mod b means the remainder after dividing a by b.
   235|   This calculation is done using the shift-register method of multiplying and
   236|   taking the remainder. The register is initialized to zero, and for each
   237|   incoming bit, x^32 is added mod p to the register if the bit is a one (where
   238|   x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x
   239|   (which is shifting right by one and adding x^32 mod p if the bit shifted out
   240|   is a one). We start with the highest power (least significant bit) of q and
   241|   repeat for all eight bits of q.
   242|   The table is simply the CRC of all possible eight bit values. This is all the
   243|   information needed to generate CRCs on data a byte at a time for all
   244|   combinations of CRC register values and incoming bytes.
   245|  */
   246| local void make_crc_table()
   247| {
   248|     unsigned i, j, n;
   249|     z_crc_t p;
   250|     /* initialize the CRC of bytes tables */
   251|     for (i = 0; i < 256; i++) {
   252|         p = i;
   253|         for (j = 0; j < 8; j++)
   254|             p = p & 1 ? (p >> 1) ^ POLY : p >> 1;
   255|         crc_table[i] = p;
   256| #ifdef W
   257|         crc_big_table[i] = byte_swap(p);
   258| #endif
   259|     }
   260|     /* initialize the x^2^n mod p(x) table */
   261|     p = (z_crc_t)1 << 30;         /* x^1 */
   262|     x2n_table[0] = p;
   263|     for (n = 1; n < 32; n++)
   264|         x2n_table[n] = p = multmodp(p, p);
   265| #ifdef W
   266|     /* initialize the braiding tables -- needs x2n_table[] */
   267|     braid(crc_braid_table, crc_braid_big_table, N, W);
   268| #endif
   269| #ifdef MAKECRCH
   270|     {
   271|         /*
   272|           The crc32.h header file contains tables for both 32-bit and 64-bit
   273|           z_word_t's, and so requires a 64-bit type be available. In that case,
   274|           z_word_t must be defined to be 64-bits. This code then also generates
   275|           and writes out the tables for the case that z_word_t is 32 bits.
   276|          */
   277| #if !defined(W) || W != 8
   278| #  error Need a 64-bit integer type in order to generate crc32.h.
   279| #endif
   280|         FILE *out;
   281|         int k, n;
   282|         z_crc_t ltl[8][256];
   283|         z_word_t big[8][256];
   284|         out = fopen("crc32.h", "w");
   285|         if (out == NULL) return;
   286|         /* write out little-endian CRC table to crc32.h */
   287|         fprintf(out,
   288|             "/* crc32.h -- tables for rapid CRC calculation\n"
   289|             " * Generated automatically by crc32.c\n */\n"
   290|             "\n"
   291|             "local const z_crc_t FAR crc_table[] = {\n"
   292|             "    ");
   293|         write_table(out, crc_table, 256);
   294|         fprintf(out,
   295|             "};\n");
   296|         /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */
   297|         fprintf(out,
   298|             "\n"
   299|             "#ifdef W\n"
   300|             "\n"
   301|             "#if W == 8\n"
   302|             "\n"
   303|             "local const z_word_t FAR crc_big_table[] = {\n"
   304|             "    ");
   305|         write_table64(out, crc_big_table, 256);
   306|         fprintf(out,
   307|             "};\n");
   308|         /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */
   309|         fprintf(out,
   310|             "\n"
   311|             "#else /* W == 4 */\n"
   312|             "\n"
   313|             "local const z_word_t FAR crc_big_table[] = {\n"
   314|             "    ");
   315|         write_table32hi(out, crc_big_table, 256);
   316|         fprintf(out,
   317|             "};\n"
   318|             "\n"
   319|             "#endif\n");
   320|         /* write out braid tables for each value of N */
   321|         for (n = 1; n <= 6; n++) {
   322|             fprintf(out,
   323|             "\n"
   324|             "#if N == %d\n", n);
   325|             /* compute braid tables for this N and 64-bit word_t */
   326|             braid(ltl, big, n, 8);
   327|             /* write out braid tables for 64-bit z_word_t to crc32.h */
   328|             fprintf(out,
   329|             "\n"
   330|             "#if W == 8\n"
   331|             "\n"
   332|             "local const z_crc_t FAR crc_braid_table[][256] = {\n");
   333|             for (k = 0; k < 8; k++) {
   334|                 fprintf(out, "   {");
   335|                 write_table(out, ltl[k], 256);
   336|                 fprintf(out, "}%s", k < 7 ? ",\n" : "");
   337|             }
   338|             fprintf(out,
   339|             "};\n"
   340|             "\n"
   341|             "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
   342|             for (k = 0; k < 8; k++) {
   343|                 fprintf(out, "   {");
   344|                 write_table64(out, big[k], 256);
   345|                 fprintf(out, "}%s", k < 7 ? ",\n" : "");
   346|             }
   347|             fprintf(out,
   348|             "};\n");
   349|             /* compute braid tables for this N and 32-bit word_t */
   350|             braid(ltl, big, n, 4);
   351|             /* write out braid tables for 32-bit z_word_t to crc32.h */
   352|             fprintf(out,
   353|             "\n"
   354|             "#else /* W == 4 */\n"
   355|             "\n"
   356|             "local const z_crc_t FAR crc_braid_table[][256] = {\n");
   357|             for (k = 0; k < 4; k++) {
   358|                 fprintf(out, "   {");
   359|                 write_table(out, ltl[k], 256);
   360|                 fprintf(out, "}%s", k < 3 ? ",\n" : "");
   361|             }
   362|             fprintf(out,
   363|             "};\n"
   364|             "\n"
   365|             "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
   366|             for (k = 0; k < 4; k++) {
   367|                 fprintf(out, "   {");
   368|                 write_table32hi(out, big[k], 256);
   369|                 fprintf(out, "}%s", k < 3 ? ",\n" : "");
   370|             }
   371|             fprintf(out,
   372|             "};\n"
   373|             "\n"
   374|             "#endif\n"
   375|             "\n"
   376|             "#endif\n");
   377|         }
   378|         fprintf(out,
   379|             "\n"
   380|             "#endif\n");
   381|         /* write out zeros operator table to crc32.h */
   382|         fprintf(out,
   383|             "\n"
   384|             "local const z_crc_t FAR x2n_table[] = {\n"
   385|             "    ");
   386|         write_table(out, x2n_table, 32);
   387|         fprintf(out,
   388|             "};\n");
   389|         fclose(out);
   390|     }
   391| #endif /* MAKECRCH */
   392| }
   393| #ifdef MAKECRCH
   394| /*
   395|    Write the 32-bit values in table[0..k-1] to out, five per line in
   396|    hexadecimal separated by commas.
   397|  */
   398| local void write_table(out, table, k)
   399|     FILE *out;
   400|     const z_crc_t FAR *table;
   401|     int k;
   402| {
   403|     int n;
   404|     for (n = 0; n < k; n++)
   405|         fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
   406|                 (unsigned long)(table[n]),
   407|                 n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
   408| }
   409| /*
   410|    Write the high 32-bits of each value in table[0..k-1] to out, five per line
   411|    in hexadecimal separated by commas.
   412|  */
   413| local void write_table32hi(out, table, k)
   414| FILE *out;
   415| const z_word_t FAR *table;
   416| int k;
   417| {
   418|     int n;
   419|     for (n = 0; n < k; n++)
   420|         fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
   421|                 (unsigned long)(table[n] >> 32),
   422|                 n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
   423| }
   424| /*
   425|   Write the 64-bit values in table[0..k-1] to out, three per line in
   426|   hexadecimal separated by commas. This assumes that if there is a 64-bit
   427|   type, then there is also a long long integer type, and it is at least 64
   428|   bits. If not, then the type cast and format string can be adjusted
   429|   accordingly.
   430|  */
   431| local void write_table64(out, table, k)
   432|     FILE *out;
   433|     const z_word_t FAR *table;
   434|     int k;
   435| {
   436|     int n;
   437|     for (n = 0; n < k; n++)
   438|         fprintf(out, "%s0x%016llx%s", n == 0 || n % 3 ? "" : "    ",
   439|                 (unsigned long long)(table[n]),
   440|                 n == k - 1 ? "" : (n % 3 == 2 ? ",\n" : ", "));
   441| }
   442| /* Actually do the deed. */
   443| int main()
   444| {
   445|     make_crc_table();
   446|     return 0;
   447| }
   448| #endif /* MAKECRCH */
   449| #ifdef W
   450| /*
   451|   Generate the little and big-endian braid tables for the given n and z_word_t
   452|   size w. Each array must have room for w blocks of 256 elements.
   453|  */
   454| local void braid(ltl, big, n, w)
   455|     z_crc_t ltl[][256];
   456|     z_word_t big[][256];
   457|     int n;
   458|     int w;
   459| {
   460|     int k;
   461|     z_crc_t i, p, q;
   462|     for (k = 0; k < w; k++) {
   463|         p = x2nmodp((n * w + 3 - k) << 3, 0);
   464|         ltl[k][0] = 0;
   465|         big[w - 1 - k][0] = 0;
   466|         for (i = 1; i < 256; i++) {
   467|             ltl[k][i] = q = multmodp(i << 24, p);
   468|             big[w - 1 - k][i] = byte_swap(q);
   469|         }
   470|     }
   471| }
   472| #endif
   473| #else /* !DYNAMIC_CRC_TABLE */
   474| /* ========================================================================
   475|  * Tables for byte-wise and braided CRC-32 calculations, and a table of powers
   476|  * of x for combining CRC-32s, all made by make_crc_table().
   477|  */
   478| #include "crc32.h"
   479| #endif /* DYNAMIC_CRC_TABLE */
   480| /* ========================================================================
   481|  * Routines used for CRC calculation. Some are also required for the table
   482|  * generation above.
   483|  */
   484| /*
   485|   Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,
   486|   reflected. For speed, this requires that a not be zero.
   487|  */
   488| local z_crc_t multmodp(a, b)
   489|     z_crc_t a;
   490|     z_crc_t b;
   491| {
   492|     z_crc_t m, p;
   493|     m = (z_crc_t)1 << 31;
   494|     p = 0;
   495|     for (;;) {
   496|         if (a & m) {
   497|             p ^= b;
   498|             if ((a & (m - 1)) == 0)
   499|                 break;
   500|         }
   501|         m >>= 1;
   502|         b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
   503|     }
   504|     return p;
   505| }
   506| /*
   507|   Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been
   508|   initialized.
   509|  */
   510| local z_crc_t x2nmodp(n, k)
   511|     z_off64_t n;
   512|     unsigned k;
   513| {
   514|     z_crc_t p;
   515|     p = (z_crc_t)1 << 31;           /* x^0 == 1 */
   516|     while (n) {
   517|         if (n & 1)
   518|             p = multmodp(x2n_table[k & 31], p);
   519|         n >>= 1;
   520|         k++;
   521|     }
   522|     return p;
   523| }
   524| /* =========================================================================
   525|  * This function can be used by asm versions of crc32(), and to force the
   526|  * generation of the CRC tables in a threaded application.
   527|  */
   528| const z_crc_t FAR * ZEXPORT get_crc_table()
   529| {
   530| #ifdef DYNAMIC_CRC_TABLE
   531|     once(&made, make_crc_table);
   532| #endif /* DYNAMIC_CRC_TABLE */
   533|     return (const z_crc_t FAR *)crc_table;
   534| }
   535| /* =========================================================================
   536|  * Use ARM machine instructions if available. This will compute the CRC about
   537|  * ten times faster than the braided calculation. This code does not check for
   538|  * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will
   539|  * only be defined if the compilation specifies an ARM processor architecture
   540|  * that has the instructions. For example, compiling with -march=armv8.1-a or
   541|  * -march=armv8-a+crc, or -march=native if the compile machine has the crc32
   542|  * instructions.
   543|  */
   544| #ifdef ARMCRC32
   545| /*
   546|    Constants empirically determined to maximize speed. These values are from
   547|    measurements on a Cortex-A57. Your mileage may vary.
   548|  */
   549| #define Z_BATCH 3990                /* number of words in a batch */
   550| #define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */
   551| #define Z_BATCH_MIN 800             /* fewest words in a final batch */
   552| unsigned long ZEXPORT crc32_z(crc, buf, len)
   553|     unsigned long crc;
   554|     const unsigned char FAR *buf;
   555|     z_size_t len;
   556| {
   557|     z_crc_t val;
   558|     z_word_t crc1, crc2;
   559|     const z_word_t *word;
   560|     z_word_t val0, val1, val2;
   561|     z_size_t last, last2, i;
   562|     z_size_t num;
   563|     /* Return initial CRC, if requested. */
   564|     if (buf == Z_NULL) return 0;
   565| #ifdef DYNAMIC_CRC_TABLE
   566|     once(&made, make_crc_table);
   567| #endif /* DYNAMIC_CRC_TABLE */
   568|     /* Pre-condition the CRC */
   569|     crc = (~crc) & 0xffffffff;
   570|     /* Compute the CRC up to a word boundary. */
   571|     while (len && ((z_size_t)buf & 7) != 0) {
   572|         len--;
   573|         val = *buf++;
   574|         __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
   575|     }
   576|     /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */
   577|     word = (z_word_t const *)buf;
   578|     num = len >> 3;
   579|     len &= 7;
   580|     /* Do three interleaved CRCs to realize the throughput of one crc32x
   581|        instruction per cycle. Each CRC is calculated on Z_BATCH words. The
   582|        three CRCs are combined into a single CRC after each set of batches. */
   583|     while (num >= 3 * Z_BATCH) {
   584|         crc1 = 0;
   585|         crc2 = 0;
   586|         for (i = 0; i < Z_BATCH; i++) {
   587|             val0 = word[i];
   588|             val1 = word[i + Z_BATCH];
   589|             val2 = word[i + 2 * Z_BATCH];
   590|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   591|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
   592|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
   593|         }
   594|         word += 3 * Z_BATCH;
   595|         num -= 3 * Z_BATCH;
   596|         crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;
   597|         crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;
   598|     }
   599|     /* Do one last smaller batch with the remaining words, if there are enough
   600|        to pay for the combination of CRCs. */
   601|     last = num / 3;
   602|     if (last >= Z_BATCH_MIN) {
   603|         last2 = last << 1;
   604|         crc1 = 0;
   605|         crc2 = 0;
   606|         for (i = 0; i < last; i++) {
   607|             val0 = word[i];
   608|             val1 = word[i + last];
   609|             val2 = word[i + last2];
   610|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   611|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
   612|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
   613|         }
   614|         word += 3 * last;
   615|         num -= 3 * last;
   616|         val = x2nmodp(last, 6);
   617|         crc = multmodp(val, crc) ^ crc1;
   618|         crc = multmodp(val, crc) ^ crc2;
   619|     }
   620|     /* Compute the CRC on any remaining words. */
   621|     for (i = 0; i < num; i++) {
   622|         val0 = word[i];
   623|         __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   624|     }
   625|     word += num;
   626|     /* Complete the CRC on any remaining bytes. */
   627|     buf = (const unsigned char FAR *)word;
   628|     while (len) {
   629|         len--;
   630|         val = *buf++;
   631|         __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
   632|     }
   633|     /* Return the CRC, post-conditioned. */
   634|     return crc ^ 0xffffffff;
   635| }
   636| #else
   637| #ifdef W
   638| /*
   639|   Return the CRC of the W bytes in the word_t data, taking the
   640|   least-significant byte of the word as the first byte of data, without any pre
   641|   or post conditioning. This is used to combine the CRCs of each braid.
   642|  */
   643| local z_crc_t crc_word(data)
   644|     z_word_t data;
   645| {
   646|     int k;
   647|     for (k = 0; k < W; k++)
   648|         data = (data >> 8) ^ crc_table[data & 0xff];
   649|     return (z_crc_t)data;
   650| }
   651| local z_word_t crc_word_big(data)
   652|     z_word_t data;
   653| {
   654|     int k;
   655|     for (k = 0; k < W; k++)
   656|         data = (data << 8) ^
   657|             crc_big_table[(data >> ((W - 1) << 3)) & 0xff];
   658|     return data;
   659| }
   660| #endif
   661| /* ========================================================================= */
   662| unsigned long ZEXPORT crc32_z(crc, buf, len)
   663|     unsigned long crc;
   664|     const unsigned char FAR *buf;
   665|     z_size_t len;
   666| {
   667|     /* Return initial CRC, if requested. */
   668|     if (buf == Z_NULL) return 0;
   669| #ifdef DYNAMIC_CRC_TABLE
   670|     once(&made, make_crc_table);
   671| #endif /* DYNAMIC_CRC_TABLE */
   672|     /* Pre-condition the CRC */
   673|     crc = (~crc) & 0xffffffff;
   674| #ifdef W
   675|     /* If provided enough bytes, do a braided CRC calculation. */
   676|     if (len >= N * W + W - 1) {
   677|         z_size_t blks;
   678|         z_word_t const *words;
   679|         unsigned endian;
   680|         int k;
   681|         /* Compute the CRC up to a z_word_t boundary. */
   682|         while (len && ((z_size_t)buf & (W - 1)) != 0) {
   683|             len--;
   684|             crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   685|         }
   686|         /* Compute the CRC on as many N z_word_t blocks as are available. */
   687|         blks = len / (N * W);
   688|         len -= blks * N * W;
   689|         words = (z_word_t const *)buf;
   690|         /* Do endian check at execution time instead of compile time, since ARM
   691|            processors can change the endianess at execution time. If the
   692|            compiler knows what the endianess will be, it can optimize out the
   693|            check and the unused branch. */
   694|         endian = 1;
   695|         if (*(unsigned char *)&endian) {
   696|             /* Little endian. */
   697|             z_crc_t crc0;
   698|             z_word_t word0;
   699| #if N > 1
   700|             z_crc_t crc1;
   701|             z_word_t word1;
   702| #if N > 2
   703|             z_crc_t crc2;
   704|             z_word_t word2;
   705| #if N > 3
   706|             z_crc_t crc3;
   707|             z_word_t word3;
   708| #if N > 4
   709|             z_crc_t crc4;
   710|             z_word_t word4;
   711| #if N > 5
   712|             z_crc_t crc5;
   713|             z_word_t word5;
   714| #endif
   715| #endif
   716| #endif
   717| #endif
   718| #endif
   719|             /* Initialize the CRC for each braid. */
   720|             crc0 = crc;
   721| #if N > 1
   722|             crc1 = 0;
   723| #if N > 2
   724|             crc2 = 0;
   725| #if N > 3
   726|             crc3 = 0;
   727| #if N > 4
   728|             crc4 = 0;
   729| #if N > 5
   730|             crc5 = 0;
   731| #endif
   732| #endif
   733| #endif
   734| #endif
   735| #endif
   736|             /*
   737|               Process the first blks-1 blocks, computing the CRCs on each braid
   738|               independently.
   739|              */
   740|             while (--blks) {
   741|                 /* Load the word for each braid into registers. */
   742|                 word0 = crc0 ^ words[0];
   743| #if N > 1
   744|                 word1 = crc1 ^ words[1];
   745| #if N > 2
   746|                 word2 = crc2 ^ words[2];
   747| #if N > 3
   748|                 word3 = crc3 ^ words[3];
   749| #if N > 4
   750|                 word4 = crc4 ^ words[4];
   751| #if N > 5
   752|                 word5 = crc5 ^ words[5];
   753| #endif
   754| #endif
   755| #endif
   756| #endif
   757| #endif
   758|                 words += N;
   759|                 /* Compute and update the CRC for each word. The loop should
   760|                    get unrolled. */
   761|                 crc0 = crc_braid_table[0][word0 & 0xff];
   762| #if N > 1
   763|                 crc1 = crc_braid_table[0][word1 & 0xff];
   764| #if N > 2
   765|                 crc2 = crc_braid_table[0][word2 & 0xff];
   766| #if N > 3
   767|                 crc3 = crc_braid_table[0][word3 & 0xff];
   768| #if N > 4
   769|                 crc4 = crc_braid_table[0][word4 & 0xff];
   770| #if N > 5
   771|                 crc5 = crc_braid_table[0][word5 & 0xff];
   772| #endif
   773| #endif
   774| #endif
   775| #endif
   776| #endif
   777|                 for (k = 1; k < W; k++) {
   778|                     crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
   779| #if N > 1
   780|                     crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
   781| #if N > 2
   782|                     crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
   783| #if N > 3
   784|                     crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
   785| #if N > 4
   786|                     crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
   787| #if N > 5
   788|                     crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
   789| #endif
   790| #endif
   791| #endif
   792| #endif
   793| #endif
   794|                 }
   795|             }
   796|             /*
   797|               Process the last block, combining the CRCs of the N braids at the
   798|               same time.
   799|              */
   800|             crc = crc_word(crc0 ^ words[0]);
   801| #if N > 1
   802|             crc = crc_word(crc1 ^ words[1] ^ crc);
   803| #if N > 2
   804|             crc = crc_word(crc2 ^ words[2] ^ crc);
   805| #if N > 3
   806|             crc = crc_word(crc3 ^ words[3] ^ crc);
   807| #if N > 4
   808|             crc = crc_word(crc4 ^ words[4] ^ crc);
   809| #if N > 5
   810|             crc = crc_word(crc5 ^ words[5] ^ crc);
   811| #endif
   812| #endif
   813| #endif
   814| #endif
   815| #endif
   816|             words += N;
   817|         }
   818|         else {
   819|             /* Big endian. */
   820|             z_word_t crc0, word0, comb;
   821| #if N > 1
   822|             z_word_t crc1, word1;
   823| #if N > 2
   824|             z_word_t crc2, word2;
   825| #if N > 3
   826|             z_word_t crc3, word3;
   827| #if N > 4
   828|             z_word_t crc4, word4;
   829| #if N > 5
   830|             z_word_t crc5, word5;
   831| #endif
   832| #endif
   833| #endif
   834| #endif
   835| #endif
   836|             /* Initialize the CRC for each braid. */
   837|             crc0 = byte_swap(crc);
   838| #if N > 1
   839|             crc1 = 0;
   840| #if N > 2
   841|             crc2 = 0;
   842| #if N > 3
   843|             crc3 = 0;
   844| #if N > 4
   845|             crc4 = 0;
   846| #if N > 5
   847|             crc5 = 0;
   848| #endif
   849| #endif
   850| #endif
   851| #endif
   852| #endif
   853|             /*
   854|               Process the first blks-1 blocks, computing the CRCs on each braid
   855|               independently.
   856|              */
   857|             while (--blks) {
   858|                 /* Load the word for each braid into registers. */
   859|                 word0 = crc0 ^ words[0];
   860| #if N > 1
   861|                 word1 = crc1 ^ words[1];
   862| #if N > 2
   863|                 word2 = crc2 ^ words[2];
   864| #if N > 3
   865|                 word3 = crc3 ^ words[3];
   866| #if N > 4
   867|                 word4 = crc4 ^ words[4];
   868| #if N > 5
   869|                 word5 = crc5 ^ words[5];
   870| #endif
   871| #endif
   872| #endif
   873| #endif
   874| #endif
   875|                 words += N;
   876|                 /* Compute and update the CRC for each word. The loop should
   877|                    get unrolled. */
   878|                 crc0 = crc_braid_big_table[0][word0 & 0xff];
   879| #if N > 1
   880|                 crc1 = crc_braid_big_table[0][word1 & 0xff];
   881| #if N > 2
   882|                 crc2 = crc_braid_big_table[0][word2 & 0xff];
   883| #if N > 3
   884|                 crc3 = crc_braid_big_table[0][word3 & 0xff];
   885| #if N > 4
   886|                 crc4 = crc_braid_big_table[0][word4 & 0xff];
   887| #if N > 5
   888|                 crc5 = crc_braid_big_table[0][word5 & 0xff];
   889| #endif
   890| #endif
   891| #endif
   892| #endif
   893| #endif
   894|                 for (k = 1; k < W; k++) {
   895|                     crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
   896| #if N > 1
   897|                     crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
   898| #if N > 2
   899|                     crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
   900| #if N > 3
   901|                     crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
   902| #if N > 4
   903|                     crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
   904| #if N > 5
   905|                     crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
   906| #endif
   907| #endif
   908| #endif
   909| #endif
   910| #endif
   911|                 }
   912|             }
   913|             /*
   914|               Process the last block, combining the CRCs of the N braids at the
   915|               same time.
   916|              */
   917|             comb = crc_word_big(crc0 ^ words[0]);
   918| #if N > 1
   919|             comb = crc_word_big(crc1 ^ words[1] ^ comb);
   920| #if N > 2
   921|             comb = crc_word_big(crc2 ^ words[2] ^ comb);
   922| #if N > 3
   923|             comb = crc_word_big(crc3 ^ words[3] ^ comb);
   924| #if N > 4
   925|             comb = crc_word_big(crc4 ^ words[4] ^ comb);
   926| #if N > 5
   927|             comb = crc_word_big(crc5 ^ words[5] ^ comb);
   928| #endif
   929| #endif
   930| #endif
   931| #endif
   932| #endif
   933|             words += N;
   934|             crc = byte_swap(comb);
   935|         }
   936|         /*
   937|           Update the pointer to the remaining bytes to process.
   938|          */
   939|         buf = (unsigned char const *)words;
   940|     }
   941| #endif /* W */
   942|     /* Complete the computation of the CRC on any remaining bytes. */
   943|     while (len >= 8) {
   944|         len -= 8;
   945|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   946|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   947|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   948|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   949|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   950|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   951|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   952|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   953|     }
   954|     while (len) {
   955|         len--;
   956|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   957|     }
   958|     /* Return the CRC, post-conditioned. */
   959|     return crc ^ 0xffffffff;
   960| }
   961| #endif
   962| /* ========================================================================= */
   963| unsigned long ZEXPORT crc32(crc, buf, len)
   964|     unsigned long crc;
   965|     const unsigned char FAR *buf;
   966|     uInt len;
   967| {
   968|     return crc32_z(crc, buf, len);
   969| }
   970| /* ========================================================================= */
   971| uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
   972|     uLong crc1;
   973|     uLong crc2;
   974|     z_off64_t len2;
   975| {
   976| #ifdef DYNAMIC_CRC_TABLE
   977|     once(&made, make_crc_table);
   978| #endif /* DYNAMIC_CRC_TABLE */
   979|     return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);
   980| }
   981| /* ========================================================================= */
   982| uLong ZEXPORT crc32_combine(crc1, crc2, len2)
   983|     uLong crc1;
   984|     uLong crc2;
   985|     z_off_t len2;
   986| {
   987|     return crc32_combine64(crc1, crc2, (z_off64_t)len2);
   988| }
   989| /* ========================================================================= */
   990| uLong ZEXPORT crc32_combine_gen64(len2)
   991|     z_off64_t len2;
   992| {
   993| #ifdef DYNAMIC_CRC_TABLE
   994|     once(&made, make_crc_table);
   995| #endif /* DYNAMIC_CRC_TABLE */
   996|     return x2nmodp(len2, 3);
   997| }
   998| /* ========================================================================= */
   999| uLong ZEXPORT crc32_combine_gen(len2)
  1000|     z_off_t len2;
  1001| {
  1002|     return crc32_combine_gen64((z_off64_t)len2);
  1003| }
  1004| /* ========================================================================= */
  1005| uLong ZEXPORT crc32_combine_op(crc1, crc2, op)
  1006|     uLong crc1;
  1007|     uLong crc2;
  1008|     uLong op;
  1009| {
  1010|     return multmodp(op, crc1) ^ (crc2 & 0xffffffff);
  1011| }


# ====================================================================
# FILE: src/native/external/zlib-intel/deflate.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1849 ---
     1| /* deflate.c -- compress data using the deflation algorithm
     2|  * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /*
     6|  *  ALGORITHM
     7|  *
     8|  *      The "deflation" process depends on being able to identify portions
     9|  *      of the input text which are identical to earlier input (within a
    10|  *      sliding window trailing behind the input currently being processed).
    11|  *
    12|  *      The most straightforward technique turns out to be the fastest for
    13|  *      most input files: try all possible matches and select the longest.
    14|  *      The key feature of this algorithm is that insertions into the string
    15|  *      dictionary are very simple and thus fast, and deletions are avoided
    16|  *      completely. Insertions are performed at each input character, whereas
    17|  *      string matches are performed only when the previous match ends. So it
    18|  *      is preferable to spend more time in matches to allow very fast string
    19|  *      insertions and avoid deletions. The matching algorithm for small
    20|  *      strings is inspired from that of Rabin & Karp. A brute force approach
    21|  *      is used to find longer strings when a small match has been found.
    22|  *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
    23|  *      (by Leonid Broukhis).
    24|  *         A previous version of this file used a more sophisticated algorithm
    25|  *      (by Fiala and Greene) which is guaranteed to run in linear amortized
    26|  *      time, but has a larger average cost, uses more memory and is patented.
    27|  *      However the F&G algorithm may be faster for some highly redundant
    28|  *      files if the parameter max_chain_length (described below) is too large.
    29|  *
    30|  *  ACKNOWLEDGEMENTS
    31|  *
    32|  *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
    33|  *      I found it in 'freeze' written by Leonid Broukhis.
    34|  *      Thanks to many people for bug reports and testing.
    35|  *
    36|  *  REFERENCES
    37|  *
    38|  *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
    39|  *      Available in http://tools.ietf.org/html/rfc1951
    40|  *
    41|  *      A description of the Rabin and Karp algorithm is given in the book
    42|  *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
    43|  *
    44|  *      Fiala,E.R., and Greene,D.H.
    45|  *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
    46|  *
    47|  */
    48| /* @(#) $Id$ */
    49| #include "deflate.h"
    50| const char deflate_copyright[] =
    51|    " deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler ";
    52| /*
    53|   If you use the zlib library in a product, an acknowledgment is welcome
    54|   in the documentation of your product. If for some reason you cannot
    55|   include such an acknowledgment, I would appreciate that you keep this
    56|   copyright string in the executable of your product.
    57|  */
    58| /* ===========================================================================
    59|  *  Function prototypes.
    60|  */
    61| typedef block_state (*compress_func) OF((deflate_state *s, int flush));
    62| /* Compression function. Returns the block state after the call. */
    63| local int deflateStateCheck      OF((z_streamp strm));
    64| local void slide_hash     OF((deflate_state *s));
    65| local void slide_hash_c     OF((deflate_state *s));
    66| #ifdef USE_SSE_SLIDE
    67| extern void slide_hash_sse(deflate_state *s);
    68| #endif
    69| local block_state deflate_stored OF((deflate_state *s, int flush));
    70| local block_state deflate_fast   OF((deflate_state *s, int flush));
    71| #ifndef FASTEST
    72| local block_state deflate_slow   OF((deflate_state *s, int flush));
    73| #endif
    74| #ifdef USE_QUICK
    75| block_state deflate_quick OF((deflate_state *s, int flush));
    76| #endif
    77| #ifdef USE_MEDIUM
    78| block_state deflate_medium OF((deflate_state *s, int flush));
    79| #endif
    80| local block_state deflate_rle    OF((deflate_state *s, int flush));
    81| local block_state deflate_huff   OF((deflate_state *s, int flush));
    82| local void lm_init        OF((deflate_state *s));
    83| local void putShortMSB    OF((deflate_state *s, uInt b));
    84| local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
    85| ZLIB_INTERNAL void fill_window(deflate_state *s);
    86| /* ===========================================================================
    87|  * Local data
    88|  */
    89| #ifndef TOO_FAR
    90| #  define TOO_FAR 4096
    91| #endif
    92| /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
    93| /* Values for max_lazy_match, good_match and max_chain_length, depending on
    94|  * the desired pack level (0..9). The values given below have been tuned to
    95|  * exclude worst case performance for pathological files. Better values may be
    96|  * found for specific files.
    97|  */
    98| typedef struct config_s {
    99|    ush good_length; /* reduce lazy search above this match length */
   100|    ush max_lazy;    /* do not perform lazy search above this match length */
   101|    ush nice_length; /* quit search above this match length */
   102|    ush max_chain;
   103|    compress_func func;
   104| } config;
   105| #ifdef FASTEST
   106| local const config configuration_table[2] = {
   107| /*      good lazy nice chain */
   108| /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
   109| /* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
   110| #else
   111| local const config configuration_table[10] = {
   112| /*      good lazy nice chain */
   113| /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
   114| #ifdef USE_QUICK
   115| /* 1 */ {4,    4,  8,    4, deflate_quick},
   116| /* 1 */ {4,    4,  8,    4, deflate_fast},
   117| /* 3 */ {4,    6, 32,   32, deflate_fast},
   118| #else
   119| /* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
   120| /* 2 */ {4,    5, 16,    8, deflate_fast},
   121| /* 3 */ {4,    6, 32,   32, deflate_fast},
   122| #endif
   123| #ifdef USE_MEDIUM
   124| /* 4 */ {4,    4, 16,   16, deflate_medium},  /* lazy matches */
   125| /* 5 */ {8,   16, 32,   32, deflate_medium},
   126| /* 6 */ {8,   16, 128, 128, deflate_medium},
   127| #else
   128| /* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
   129| /* 5 */ {8,   16, 32,   32, deflate_slow},
   130| /* 6 */ {8,   16, 128, 128, deflate_slow},
   131| #endif
   132| /* 7 */ {8,   32, 128, 256, deflate_slow},
   133| /* 8 */ {32, 128, 258, 1024, deflate_slow},
   134| /* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
   135| #endif
   136| /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
   137|  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
   138|  * meaning.
   139|  */
   140| /* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
   141| #define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
   142| /* ===========================================================================
   143|  * Insert string str in the dictionary and set match_head to the previous head
   144|  * of the hash chain (the most recent string with same hash key). Return
   145|  * the previous length of the hash chain.
   146|  * If this file is compiled with -DFASTEST, the compression level is forced
   147|  * to 1, and no hash chains are maintained.
   148|  * IN  assertion: all calls to INSERT_STRING are made with consecutive input
   149|  *    characters and the first MIN_MATCH bytes of str are valid (except for
   150|  *    the last MIN_MATCH-1 bytes of the input file).
   151|  */
   152| #ifdef FASTEST
   153| #define INSERT_STRING(s, str, match_head) \
   154|    (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
   155|     match_head = s->head[s->ins_h], \
   156|     s->head[s->ins_h] = (Pos)(str))
   157| #else
   158| #define INSERT_STRING(s, str, match_head) \
   159|    (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
   160|     match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
   161|     s->head[s->ins_h] = (Pos)(str))
   162| #endif
   163| /* ===========================================================================
   164|  * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
   165|  * prev[] will be initialized on the fly.
   166|  */
   167| #define CLEAR_HASH(s) \
   168|     do { \
   169|         s->head[s->hash_size - 1] = NIL; \
   170|         zmemzero((Bytef *)s->head, \
   171|                  (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \
   172|     } while (0)
   173| /* ===========================================================================
   174|  * Slide the hash table when sliding the window down (could be avoided with 32
   175|  * bit values at the expense of memory usage). We slide even when level == 0 to
   176|  * keep the hash table consistent if we switch back to level > 0 later.
   177|  */
   178| local void slide_hash_c(s)
   179|     deflate_state *s;
   180| {
   181|     unsigned n, m;
   182|     Posf *p;
   183|     uInt wsize = s->w_size;
   184|     n = s->hash_size;
   185|     p = &s->head[n];
   186|     do {
   187|         m = *--p;
   188|         *p = (Pos)(m >= wsize ? m - wsize : NIL);
   189|     } while (--n);
   190|     n = wsize;
   191| #ifndef FASTEST
   192|     p = &s->prev[n];
   193|     do {
   194|         m = *--p;
   195|         *p = (Pos)(m >= wsize ? m - wsize : NIL);
   196|         /* If n is not on any hash chain, prev[n] is garbage but
   197|          * its value will never be used.
   198|          */
   199|     } while (--n);
   200| #endif
   201| }
   202| local void slide_hash(deflate_state *s)
   203| {
   204| #ifdef USE_SSE_SLIDE
   205|     if (x86_cpu_has_sse2)
   206|         slide_hash_sse(s);
   207|     else
   208| #endif
   209|         slide_hash_c(s);
   210| }
   211| /* ========================================================================= */
   212| int ZEXPORT deflateInit_(strm, level, version, stream_size)
   213|     z_streamp strm;
   214|     int level;
   215|     const char *version;
   216|     int stream_size;
   217| {
   218|     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
   219|                          Z_DEFAULT_STRATEGY, version, stream_size);
   220|     /* To do: ignore strm->next_in if we use it as window */
   221| }
   222| /* ========================================================================= */
   223| int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
   224|                   version, stream_size)
   225|     z_streamp strm;
   226|     int  level;
   227|     int  method;
   228|     int  windowBits;
   229|     int  memLevel;
   230|     int  strategy;
   231|     const char *version;
   232|     int stream_size;
   233| {
   234|     unsigned window_padding = 0;
   235|     deflate_state *s;
   236|     int wrap = 1;
   237|     static const char my_version[] = ZLIB_VERSION;
   238|     if (version == Z_NULL || version[0] != my_version[0] ||
   239|         stream_size != sizeof(z_stream)) {
   240|         return Z_VERSION_ERROR;
   241|     }
   242|     if (strm == Z_NULL) return Z_STREAM_ERROR;
   243|     strm->msg = Z_NULL;
   244|     if (strm->zalloc == (alloc_func)0) {
   245| #ifdef Z_SOLO
   246|         return Z_STREAM_ERROR;
   247| #else
   248|         strm->zalloc = zcalloc;
   249|         strm->opaque = (voidpf)0;
   250| #endif
   251|     }
   252|     if (strm->zfree == (free_func)0)
   253| #ifdef Z_SOLO
   254|         return Z_STREAM_ERROR;
   255| #else
   256|         strm->zfree = zcfree;
   257| #endif
   258| #if defined(ZLIB_X86)
   259|     x86_check_features();
   260| #endif
   261| #ifdef FASTEST
   262|     if (level != 0) level = 1;
   263| #else
   264|     if (level == Z_DEFAULT_COMPRESSION) level = 6;
   265| #endif
   266|     if (windowBits < 0) { /* suppress zlib wrapper */
   267|         wrap = 0;
   268|         if (windowBits < -15)
   269|             return Z_STREAM_ERROR;
   270|         windowBits = -windowBits;
   271|     }
   272| #ifdef GZIP
   273|     else if (windowBits > 15) {
   274|         wrap = 2;       /* write gzip wrapper instead */
   275|         windowBits -= 16;
   276|     }
   277| #endif
   278|     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
   279|         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
   280|         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
   281|         return Z_STREAM_ERROR;
   282|     }
   283|     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
   284| #ifdef USE_QUICK
   285|     if (level == 1 && windowBits > 13)
   286|         windowBits = 13;
   287| #endif
   288|     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
   289|     if (s == Z_NULL) return Z_MEM_ERROR;
   290|     strm->state = (struct internal_state FAR *)s;
   291|     s->strm = strm;
   292|     s->status = INIT_STATE;     /* to pass state test in deflateReset() */
   293|     s->wrap = wrap;
   294|     s->gzhead = Z_NULL;
   295|     s->w_bits = (uInt)windowBits;
   296|     s->w_size = 1 << s->w_bits;
   297|     s->w_mask = s->w_size - 1;
   298|     s->hash_bits = (uInt)memLevel + 7;
   299|     s->hash_size = 1 << s->hash_bits;
   300|     s->hash_mask = s->hash_size - 1;
   301|     s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
   302| #if defined(USE_PCLMUL_CRC)
   303|     window_padding = 8;
   304| #endif
   305|     s->window = (Bytef *) ZALLOC(strm, s->w_size + window_padding, 2*sizeof(Byte));
   306|     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
   307|     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
   308|     s->high_water = 0;      /* nothing written to s->window yet */
   309|     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
   310|     /* We overlay pending_buf and sym_buf. This works since the average size
   311|      * for length/distance pairs over any compressed block is assured to be 31
   312|      * bits or less.
   313|      *
   314|      * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   315|      * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   316|      * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   317|      * possible fixed-codes length/distance pair is then 31 bits total.
   318|      *
   319|      * sym_buf starts one-fourth of the way into pending_buf. So there are
   320|      * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   321|      * in sym_buf is three bytes -- two for the distance and one for the
   322|      * literal/length. As each symbol is consumed, the pointer to the next
   323|      * sym_buf value to read moves forward three bytes. From that symbol, up to
   324|      * 31 bits are written to pending_buf. The closest the written pending_buf
   325|      * bits gets to the next sym_buf symbol to read is just before the last
   326|      * code is written. At that time, 31*(n - 2) bits have been written, just
   327|      * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
   328|      * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
   329|      * symbols are written.) The closest the writing gets to what is unread is
   330|      * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
   331|      * can range from 128 to 32768.
   332|      *
   333|      * Therefore, at a minimum, there are 142 bits of space between what is
   334|      * written and what is read in the overlain buffers, so the symbols cannot
   335|      * be overwritten by the compressed data. That space is actually 139 bits,
   336|      * due to the three-bit fixed-code block header.
   337|      *
   338|      * That covers the case where either Z_FIXED is specified, forcing fixed
   339|      * codes, or when the use of fixed codes is chosen, because that choice
   340|      * results in a smaller compressed block than dynamic codes. That latter
   341|      * condition then assures that the above analysis also covers all dynamic
   342|      * blocks. A dynamic-code block will only be chosen to be emitted if it has
   343|      * fewer bits than a fixed-code block would for the same set of symbols.
   344|      * Therefore its average symbol length is assured to be less than 31. So
   345|      * the compressed data for a dynamic block also cannot overwrite the
   346|      * symbols from which it is being constructed.
   347|      */
   348|     s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);
   349|     s->pending_buf_size = (ulg)s->lit_bufsize * 4;
   350|     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
   351|         s->pending_buf == Z_NULL) {
   352|         s->status = FINISH_STATE;
   353|         strm->msg = ERR_MSG(Z_MEM_ERROR);
   354|         deflateEnd (strm);
   355|         return Z_MEM_ERROR;
   356|     }
   357|     s->sym_buf = s->pending_buf + s->lit_bufsize;
   358|     s->sym_end = (s->lit_bufsize - 1) * 3;
   359|     /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   360|      * on 16 bit machines and because stored blocks are restricted to
   361|      * 64K-1 bytes.
   362|      */
   363|     s->level = level;
   364|     s->strategy = strategy;
   365|     s->method = (Byte)method;
   366|     return deflateReset(strm);
   367| }
   368| /* =========================================================================
   369|  * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
   370|  */
   371| local int deflateStateCheck(strm)
   372|     z_streamp strm;
   373| {
   374|     deflate_state *s;
   375|     if (strm == Z_NULL ||
   376|         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
   377|         return 1;
   378|     s = strm->state;
   379|     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
   380| #ifdef GZIP
   381|                                            s->status != GZIP_STATE &&
   382| #endif
   383|                                            s->status != EXTRA_STATE &&
   384|                                            s->status != NAME_STATE &&
   385|                                            s->status != COMMENT_STATE &&
   386|                                            s->status != HCRC_STATE &&
   387|                                            s->status != BUSY_STATE &&
   388|                                            s->status != FINISH_STATE))
   389|         return 1;
   390|     return 0;
   391| }
   392| /* ========================================================================= */
   393| int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)
   394|     z_streamp strm;
   395|     const Bytef *dictionary;
   396|     uInt  dictLength;
   397| {
   398|     deflate_state *s;
   399|     uInt str, n;
   400|     int wrap;
   401|     unsigned avail;
   402|     z_const unsigned char *next;
   403|     if (deflateStateCheck(strm) || dictionary == Z_NULL)
   404|         return Z_STREAM_ERROR;
   405|     s = strm->state;
   406|     wrap = s->wrap;
   407|     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
   408|         return Z_STREAM_ERROR;
   409|     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
   410|     if (wrap == 1)
   411|         strm->adler = adler32(strm->adler, dictionary, dictLength);
   412|     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
   413|     /* if dictionary would fill window, just replace the history */
   414|     if (dictLength >= s->w_size) {
   415|         if (wrap == 0) {            /* already empty otherwise */
   416|             CLEAR_HASH(s);
   417|             s->strstart = 0;
   418|             s->block_start = 0L;
   419|             s->insert = 0;
   420|         }
   421|         dictionary += dictLength - s->w_size;  /* use the tail */
   422|         dictLength = s->w_size;
   423|     }
   424|     /* insert dictionary into window and hash */
   425|     avail = strm->avail_in;
   426|     next = strm->next_in;
   427|     strm->avail_in = dictLength;
   428|     strm->next_in = (z_const Bytef *)dictionary;
   429|     fill_window(s);
   430|     while (s->lookahead >= MIN_MATCH) {
   431|         str = s->strstart;
   432|         n = s->lookahead - (MIN_MATCH-1);
   433|         do {
   434|             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
   435| #ifndef FASTEST
   436|             s->prev[str & s->w_mask] = s->head[s->ins_h];
   437| #endif
   438|             s->head[s->ins_h] = (Pos)str;
   439|             str++;
   440|         } while (--n);
   441|         s->strstart = str;
   442|         s->lookahead = MIN_MATCH-1;
   443|         fill_window(s);
   444|     }
   445|     s->strstart += s->lookahead;
   446|     s->block_start = (long)s->strstart;
   447|     s->insert = s->lookahead;
   448|     s->lookahead = 0;
   449|     s->match_length = s->prev_length = MIN_MATCH-1;
   450|     s->match_available = 0;
   451|     strm->next_in = next;
   452|     strm->avail_in = avail;
   453|     s->wrap = wrap;
   454|     return Z_OK;
   455| }
   456| /* ========================================================================= */
   457| int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)
   458|     z_streamp strm;
   459|     Bytef *dictionary;
   460|     uInt  *dictLength;
   461| {
   462|     deflate_state *s;
   463|     uInt len;
   464|     if (deflateStateCheck(strm))
   465|         return Z_STREAM_ERROR;
   466|     s = strm->state;
   467|     len = s->strstart + s->lookahead;
   468|     if (len > s->w_size)
   469|         len = s->w_size;
   470|     if (dictionary != Z_NULL && len)
   471|         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
   472|     if (dictLength != Z_NULL)
   473|         *dictLength = len;
   474|     return Z_OK;
   475| }
   476| /* ========================================================================= */
   477| int ZEXPORT deflateResetKeep(strm)
   478|     z_streamp strm;
   479| {
   480|     deflate_state *s;
   481|     if (deflateStateCheck(strm)) {
   482|         return Z_STREAM_ERROR;
   483|     }
   484|     strm->total_in = strm->total_out = 0;
   485|     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
   486|     strm->data_type = Z_UNKNOWN;
   487|     s = (deflate_state *)strm->state;
   488|     s->pending = 0;
   489|     s->pending_out = s->pending_buf;
   490|     if (s->wrap < 0) {
   491|         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
   492|     }
   493|     s->status =
   494| #ifdef GZIP
   495|         s->wrap == 2 ? GZIP_STATE :
   496| #endif
   497|         INIT_STATE;
   498|     strm->adler =
   499| #ifdef GZIP
   500|         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
   501| #endif
   502|         adler32(0L, Z_NULL, 0);
   503|     s->last_flush = -2;
   504| #if defined(USE_PCLMUL_CRC)
   505|     if (x86_cpu_has_pclmul) {
   506|         crc_fold_init(s->crc0);
   507|     }
   508| #endif
   509|     _tr_init(s);
   510|     return Z_OK;
   511| }
   512| /* ========================================================================= */
   513| int ZEXPORT deflateReset(strm)
   514|     z_streamp strm;
   515| {
   516|     int ret;
   517|     ret = deflateResetKeep(strm);
   518|     if (ret == Z_OK)
   519|         lm_init(strm->state);
   520|     return ret;
   521| }
   522| /* ========================================================================= */
   523| int ZEXPORT deflateSetHeader(strm, head)
   524|     z_streamp strm;
   525|     gz_headerp head;
   526| {
   527|     if (deflateStateCheck(strm) || strm->state->wrap != 2)
   528|         return Z_STREAM_ERROR;
   529|     strm->state->gzhead = head;
   530|     return Z_OK;
   531| }
   532| /* ========================================================================= */
   533| int ZEXPORT deflatePending(strm, pending, bits)
   534|     unsigned *pending;
   535|     int *bits;
   536|     z_streamp strm;
   537| {
   538|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   539|     if (pending != Z_NULL)
   540|         *pending = strm->state->pending;
   541|     if (bits != Z_NULL)
   542|         *bits = strm->state->bi_valid;
   543|     return Z_OK;
   544| }
   545| /* ========================================================================= */
   546| int ZEXPORT deflatePrime(strm, bits, value)
   547|     z_streamp strm;
   548|     int bits;
   549|     int value;
   550| {
   551|     deflate_state *s;
   552|     int put;
   553|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   554|     s = strm->state;
   555|     if (bits < 0 || bits > 16 ||
   556|         s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
   557|         return Z_BUF_ERROR;
   558|     do {
   559|         put = Buf_size - s->bi_valid;
   560|         if (put > bits)
   561|             put = bits;
   562|         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
   563|         s->bi_valid += put;
   564|         _tr_flush_bits(s);
   565|         value >>= put;
   566|         bits -= put;
   567|     } while (bits);
   568|     return Z_OK;
   569| }
   570| /* ========================================================================= */
   571| int ZEXPORT deflateParams(strm, level, strategy)
   572|     z_streamp strm;
   573|     int level;
   574|     int strategy;
   575| {
   576|     deflate_state *s;
   577|     compress_func func;
   578|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   579|     s = strm->state;
   580| #ifdef FASTEST
   581|     if (level != 0) level = 1;
   582| #else
   583|     if (level == Z_DEFAULT_COMPRESSION) level = 6;
   584| #endif
   585|     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
   586|         return Z_STREAM_ERROR;
   587|     }
   588|     func = configuration_table[s->level].func;
   589|     if ((strategy != s->strategy || func != configuration_table[level].func) &&
   590|         s->last_flush != -2) {
   591|         /* Flush the last buffer: */
   592|         int err = deflate(strm, Z_BLOCK);
   593|         if (err == Z_STREAM_ERROR)
   594|             return err;
   595|         if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
   596|             return Z_BUF_ERROR;
   597|     }
   598|     if (s->level != level) {
   599|         if (s->level == 0 && s->matches != 0) {
   600|             if (s->matches == 1)
   601|                 slide_hash(s);
   602|             else
   603|                 CLEAR_HASH(s);
   604|             s->matches = 0;
   605|         }
   606|         s->level = level;
   607|         s->max_lazy_match   = configuration_table[level].max_lazy;
   608|         s->good_match       = configuration_table[level].good_length;
   609|         s->nice_match       = configuration_table[level].nice_length;
   610|         s->max_chain_length = configuration_table[level].max_chain;
   611|     }
   612|     s->strategy = strategy;
   613|     return Z_OK;
   614| }
   615| /* ========================================================================= */
   616| int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
   617|     z_streamp strm;
   618|     int good_length;
   619|     int max_lazy;
   620|     int nice_length;
   621|     int max_chain;
   622| {
   623|     deflate_state *s;
   624|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   625|     s = strm->state;
   626|     s->good_match = (uInt)good_length;
   627|     s->max_lazy_match = (uInt)max_lazy;
   628|     s->nice_match = nice_length;
   629|     s->max_chain_length = (uInt)max_chain;
   630|     return Z_OK;
   631| }
   632| /* =========================================================================
   633|  * For the default windowBits of 15 and memLevel of 8, this function returns a
   634|  * close to exact, as well as small, upper bound on the compressed size. This
   635|  * is an expansion of ~0.03%, plus a small constant.
   636|  *
   637|  * For any setting other than those defaults for windowBits and memLevel, one
   638|  * of two worst case bounds is returned. This is at most an expansion of ~4% or
   639|  * ~13%, plus a small constant.
   640|  *
   641|  * Both the 0.03% and 4% derive from the overhead of stored blocks. The first
   642|  * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second
   643|  * is for stored blocks of 127 bytes (the worst case memLevel == 1). The
   644|  * expansion results from five bytes of header for each stored block.
   645|  *
   646|  * The larger expansion of 13% results from a window size less than or equal to
   647|  * the symbols buffer size (windowBits <= memLevel + 7). In that case some of
   648|  * the data being compressed may have slid out of the sliding window, impeding
   649|  * a stored block from being emitted. Then the only choice is a fixed or
   650|  * dynamic block, where a fixed block limits the maximum expansion to 9 bits
   651|  * per 8-bit byte, plus 10 bits for every block. The smallest block size for
   652|  * which this can occur is 255 (memLevel == 2).
   653|  *
   654|  * Shifts are used to approximate divisions, for speed.
   655|  */
   656| uLong ZEXPORT deflateBound(strm, sourceLen)
   657|     z_streamp strm;
   658|     uLong sourceLen;
   659| {
   660|     deflate_state *s;
   661|     uLong fixedlen, storelen, wraplen;
   662|     /* upper bound for fixed blocks with 9-bit literals and length 255
   663|        (memLevel == 2, which is the lowest that may not use stored blocks) --
   664|        ~13% overhead plus a small constant */
   665|     fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +
   666|                (sourceLen >> 9) + 4;
   667|     /* upper bound for stored blocks with length 127 (memLevel == 1) --
   668|        ~4% overhead plus a small constant */
   669|     storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +
   670|                (sourceLen >> 11) + 7;
   671|     /* if can't get parameters, return larger bound plus a zlib wrapper */
   672|     if (deflateStateCheck(strm))
   673|         return (fixedlen > storelen ? fixedlen : storelen) + 6;
   674|     /* compute wrapper length */
   675|     s = strm->state;
   676|     switch (s->wrap) {
   677|     case 0:                                 /* raw deflate */
   678|         wraplen = 0;
   679|         break;
   680|     case 1:                                 /* zlib wrapper */
   681|         wraplen = 6 + (s->strstart ? 4 : 0);
   682|         break;
   683| #ifdef GZIP
   684|     case 2:                                 /* gzip wrapper */
   685|         wraplen = 18;
   686|         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
   687|             Bytef *str;
   688|             if (s->gzhead->extra != Z_NULL)
   689|                 wraplen += 2 + s->gzhead->extra_len;
   690|             str = s->gzhead->name;
   691|             if (str != Z_NULL)
   692|                 do {
   693|                     wraplen++;
   694|                 } while (*str++);
   695|             str = s->gzhead->comment;
   696|             if (str != Z_NULL)
   697|                 do {
   698|                     wraplen++;
   699|                 } while (*str++);
   700|             if (s->gzhead->hcrc)
   701|                 wraplen += 2;
   702|         }
   703|         break;
   704| #endif
   705|     default:                                /* for compiler happiness */
   706|         wraplen = 6;
   707|     }
   708|     /* if not default parameters, return one of the conservative bounds */
   709|     if (s->w_bits != 15 || s->hash_bits != 8 + 7)
   710|         return (s->w_bits <= s->hash_bits ? fixedlen : storelen) + wraplen;
   711|     /* default settings: return tight bound for that case -- ~0.03% overhead
   712|        plus a small constant */
   713|     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
   714|            (sourceLen >> 25) + 13 - 6 + wraplen;
   715| }
   716| /* =========================================================================
   717|  * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   718|  * IN assertion: the stream state is correct and there is enough room in
   719|  * pending_buf.
   720|  */
   721| local void putShortMSB(s, b)
   722|     deflate_state *s;
   723|     uInt b;
   724| {
   725|     put_byte(s, (Byte)(b >> 8));
   726|     put_byte(s, (Byte)(b & 0xff));
   727| }
   728| /* =========================================================================
   729|  * Flush as much pending output as possible. All deflate() output, except for
   730|  * some deflate_stored() output, goes through this function so some
   731|  * applications may wish to modify it to avoid allocating a large
   732|  * strm->next_out buffer and copying into it. (See also read_buf()).
   733|  */
   734| ZLIB_INTERNAL void flush_pending(strm)
   735|     z_streamp strm;
   736| {
   737|     unsigned len;
   738|     deflate_state *s = strm->state;
   739|     _tr_flush_bits(s);
   740|     len = s->pending;
   741|     if (len > strm->avail_out) len = strm->avail_out;
   742|     if (len == 0) return;
   743|     zmemcpy(strm->next_out, s->pending_out, len);
   744|     strm->next_out  += len;
   745|     s->pending_out  += len;
   746|     strm->total_out += len;
   747|     strm->avail_out -= len;
   748|     s->pending      -= len;
   749|     if (s->pending == 0) {
   750|         s->pending_out = s->pending_buf;
   751|     }
   752| }
   753| /* ===========================================================================
   754|  * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
   755|  */
   756| #define HCRC_UPDATE(beg) \
   757|     do { \
   758|         if (s->gzhead->hcrc && s->pending > (beg)) \
   759|             strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
   760|                                 s->pending - (beg)); \
   761|     } while (0)
   762| /* ========================================================================= */
   763| int ZEXPORT deflate(strm, flush)
   764|     z_streamp strm;
   765|     int flush;
   766| {
   767|     int old_flush; /* value of flush param for previous deflate call */
   768|     deflate_state *s;
   769|     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
   770|         return Z_STREAM_ERROR;
   771|     }
   772|     s = strm->state;
   773|     if (strm->next_out == Z_NULL ||
   774|         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
   775|         (s->status == FINISH_STATE && flush != Z_FINISH)) {
   776|         ERR_RETURN(strm, Z_STREAM_ERROR);
   777|     }
   778|     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
   779|     old_flush = s->last_flush;
   780|     s->last_flush = flush;
   781|     /* Flush as much pending output as possible */
   782|     if (s->pending != 0) {
   783|         flush_pending(strm);
   784|         if (strm->avail_out == 0) {
   785|             /* Since avail_out is 0, deflate will be called again with
   786|              * more output space, but possibly with both pending and
   787|              * avail_in equal to zero. There won't be anything to do,
   788|              * but this is not an error situation so make sure we
   789|              * return OK instead of BUF_ERROR at next call of deflate:
   790|              */
   791|             s->last_flush = -1;
   792|             return Z_OK;
   793|         }
   794|     /* Make sure there is something to do and avoid duplicate consecutive
   795|      * flushes. For repeated and useless calls with Z_FINISH, we keep
   796|      * returning Z_STREAM_END instead of Z_BUF_ERROR.
   797|      */
   798|     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
   799|                flush != Z_FINISH) {
   800|         ERR_RETURN(strm, Z_BUF_ERROR);
   801|     }
   802|     /* User must not provide more input after the first FINISH: */
   803|     if (s->status == FINISH_STATE && strm->avail_in != 0) {
   804|         ERR_RETURN(strm, Z_BUF_ERROR);
   805|     }
   806|     /* Write the header */
   807|     if (s->status == INIT_STATE && s->wrap == 0)
   808|         s->status = BUSY_STATE;
   809|     if (s->status == INIT_STATE) {
   810|         /* zlib header */
   811|         uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
   812|         uInt level_flags;
   813|         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
   814|             level_flags = 0;
   815|         else if (s->level < 6)
   816|             level_flags = 1;
   817|         else if (s->level == 6)
   818|             level_flags = 2;
   819|         else
   820|             level_flags = 3;
   821|         header |= (level_flags << 6);
   822|         if (s->strstart != 0) header |= PRESET_DICT;
   823|         header += 31 - (header % 31);
   824|         putShortMSB(s, header);
   825|         /* Save the adler32 of the preset dictionary: */
   826|         if (s->strstart != 0) {
   827|             putShortMSB(s, (uInt)(strm->adler >> 16));
   828|             putShortMSB(s, (uInt)(strm->adler & 0xffff));
   829|         }
   830|         strm->adler = adler32(0L, Z_NULL, 0);
   831|         s->status = BUSY_STATE;
   832|         /* Compression must start with an empty pending buffer */
   833|         flush_pending(strm);
   834|         if (s->pending != 0) {
   835|             s->last_flush = -1;
   836|             return Z_OK;
   837|         }
   838|     }
   839| #ifdef GZIP
   840|     if (s->status == GZIP_STATE) {
   841|         /* gzip header */
   842|         strm->adler = crc32(0L, Z_NULL, 0);
   843|         put_byte(s, 31);
   844|         put_byte(s, 139);
   845|         put_byte(s, 8);
   846|         if (s->gzhead == Z_NULL) {
   847|             put_byte(s, 0);
   848|             put_byte(s, 0);
   849|             put_byte(s, 0);
   850|             put_byte(s, 0);
   851|             put_byte(s, 0);
   852|             put_byte(s, s->level == 9 ? 2 :
   853|                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
   854|                       4 : 0));
   855|             put_byte(s, OS_CODE);
   856|             s->status = BUSY_STATE;
   857|             /* Compression must start with an empty pending buffer */
   858|             flush_pending(strm);
   859|             if (s->pending != 0) {
   860|                 s->last_flush = -1;
   861|                 return Z_OK;
   862|             }
   863|         }
   864|         else {
   865|             put_byte(s, (s->gzhead->text ? 1 : 0) +
   866|                      (s->gzhead->hcrc ? 2 : 0) +
   867|                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
   868|                      (s->gzhead->name == Z_NULL ? 0 : 8) +
   869|                      (s->gzhead->comment == Z_NULL ? 0 : 16)
   870|                      );
   871|             put_byte(s, (Byte)(s->gzhead->time & 0xff));
   872|             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
   873|             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
   874|             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
   875|             put_byte(s, s->level == 9 ? 2 :
   876|                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
   877|                       4 : 0));
   878|             put_byte(s, s->gzhead->os & 0xff);
   879|             if (s->gzhead->extra != Z_NULL) {
   880|                 put_byte(s, s->gzhead->extra_len & 0xff);
   881|                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
   882|             }
   883|             if (s->gzhead->hcrc)
   884|                 strm->adler = crc32(strm->adler, s->pending_buf,
   885|                                     s->pending);
   886|             s->gzindex = 0;
   887|             s->status = EXTRA_STATE;
   888|         }
   889|     }
   890|     if (s->status == EXTRA_STATE) {
   891|         if (s->gzhead->extra != Z_NULL) {
   892|             ulg beg = s->pending;   /* start of bytes to update crc */
   893|             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
   894|             while (s->pending + left > s->pending_buf_size) {
   895|                 uInt copy = s->pending_buf_size - s->pending;
   896|                 zmemcpy(s->pending_buf + s->pending,
   897|                         s->gzhead->extra + s->gzindex, copy);
   898|                 s->pending = s->pending_buf_size;
   899|                 HCRC_UPDATE(beg);
   900|                 s->gzindex += copy;
   901|                 flush_pending(strm);
   902|                 if (s->pending != 0) {
   903|                     s->last_flush = -1;
   904|                     return Z_OK;
   905|                 }
   906|                 beg = 0;
   907|                 left -= copy;
   908|             }
   909|             zmemcpy(s->pending_buf + s->pending,
   910|                     s->gzhead->extra + s->gzindex, left);
   911|             s->pending += left;
   912|             HCRC_UPDATE(beg);
   913|             s->gzindex = 0;
   914|         }
   915|         s->status = NAME_STATE;
   916|     }
   917|     if (s->status == NAME_STATE) {
   918|         if (s->gzhead->name != Z_NULL) {
   919|             ulg beg = s->pending;   /* start of bytes to update crc */
   920|             int val;
   921|             do {
   922|                 if (s->pending == s->pending_buf_size) {
   923|                     HCRC_UPDATE(beg);
   924|                     flush_pending(strm);
   925|                     if (s->pending != 0) {
   926|                         s->last_flush = -1;
   927|                         return Z_OK;
   928|                     }
   929|                     beg = 0;
   930|                 }
   931|                 val = s->gzhead->name[s->gzindex++];
   932|                 put_byte(s, val);
   933|             } while (val != 0);
   934|             HCRC_UPDATE(beg);
   935|             s->gzindex = 0;
   936|         }
   937|         s->status = COMMENT_STATE;
   938|     }
   939|     if (s->status == COMMENT_STATE) {
   940|         if (s->gzhead->comment != Z_NULL) {
   941|             ulg beg = s->pending;   /* start of bytes to update crc */
   942|             int val;
   943|             do {
   944|                 if (s->pending == s->pending_buf_size) {
   945|                     HCRC_UPDATE(beg);
   946|                     flush_pending(strm);
   947|                     if (s->pending != 0) {
   948|                         s->last_flush = -1;
   949|                         return Z_OK;
   950|                     }
   951|                     beg = 0;
   952|                 }
   953|                 val = s->gzhead->comment[s->gzindex++];
   954|                 put_byte(s, val);
   955|             } while (val != 0);
   956|             HCRC_UPDATE(beg);
   957|         }
   958|         s->status = HCRC_STATE;
   959|     }
   960|     if (s->status == HCRC_STATE) {
   961|         if (s->gzhead->hcrc) {
   962|             if (s->pending + 2 > s->pending_buf_size) {
   963|                 flush_pending(strm);
   964|                 if (s->pending != 0) {
   965|                     s->last_flush = -1;
   966|                     return Z_OK;
   967|                 }
   968|             }
   969|             put_byte(s, (Byte)(strm->adler & 0xff));
   970|             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
   971|             strm->adler = crc32(0L, Z_NULL, 0);
   972|         }
   973|         s->status = BUSY_STATE;
   974|         /* Compression must start with an empty pending buffer */
   975|         flush_pending(strm);
   976|         if (s->pending != 0) {
   977|             s->last_flush = -1;
   978|             return Z_OK;
   979|         }
   980|     }
   981| #endif
   982|     /* Start a new block or continue the current one.
   983|      */
   984|     if (strm->avail_in != 0 || s->lookahead != 0 ||
   985|         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
   986|         block_state bstate;
   987|         if (s->level == 0)
   988|             bstate = deflate_stored(s, flush);
   989| 	else if (s->strategy == Z_HUFFMAN_ONLY)
   990|             bstate = deflate_huff(s, flush);
   991|         else if (s->strategy == Z_RLE)
   992|             bstate = deflate_rle(s, flush);
   993|         else if (s->level == 1 && !x86_cpu_has_sse42)
   994|             bstate = deflate_fast(s, flush);
   995|         else
   996| 	    bstate = (*configuration_table[s->level].func)(s, flush);
   997|         if (bstate == finish_started || bstate == finish_done) {
   998|             s->status = FINISH_STATE;
   999|         }
  1000|         if (bstate == need_more || bstate == finish_started) {
  1001|             if (strm->avail_out == 0) {
  1002|                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
  1003|             }
  1004|             return Z_OK;
  1005|             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
  1006|              * of deflate should use the same flush parameter to make sure
  1007|              * that the flush is complete. So we don't have to output an
  1008|              * empty block here, this will be done at next call. This also
  1009|              * ensures that for a very small output buffer, we emit at most
  1010|              * one empty block.
  1011|              */
  1012|         }
  1013|         if (bstate == block_done) {
  1014|             if (flush == Z_PARTIAL_FLUSH) {
  1015|                 _tr_align(s);
  1016|             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
  1017|                 _tr_stored_block(s, (char*)0, 0L, 0);
  1018|                 /* For a full flush, this empty block will be recognized
  1019|                  * as a special marker by inflate_sync().
  1020|                  */
  1021|                 if (flush == Z_FULL_FLUSH) {
  1022|                     CLEAR_HASH(s);             /* forget history */
  1023|                     if (s->lookahead == 0) {
  1024|                         s->strstart = 0;
  1025|                         s->block_start = 0L;
  1026|                         s->insert = 0;
  1027|                     }
  1028|                 }
  1029|             }
  1030|             flush_pending(strm);
  1031|             if (strm->avail_out == 0) {
  1032|               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
  1033|               return Z_OK;
  1034|             }
  1035|         }
  1036|     }
  1037|     if (flush != Z_FINISH) return Z_OK;
  1038|     if (s->wrap <= 0) return Z_STREAM_END;
  1039|     /* Write the trailer */
  1040| #ifdef GZIP
  1041|     if (s->wrap == 2) {
  1042| #if defined(USE_PCLMUL_CRC)
  1043|         if (x86_cpu_has_pclmul) {
  1044|             s->strm->adler = crc_fold_512to32(s->crc0);
  1045|         }
  1046| #endif
  1047|         put_byte(s, (Byte)(strm->adler & 0xff));
  1048|         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
  1049|         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
  1050|         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
  1051|         put_byte(s, (Byte)(strm->total_in & 0xff));
  1052|         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
  1053|         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
  1054|         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
  1055|     }
  1056|     else
  1057| #endif
  1058|     {
  1059|         putShortMSB(s, (uInt)(strm->adler >> 16));
  1060|         putShortMSB(s, (uInt)(strm->adler & 0xffff));
  1061|     }
  1062|     flush_pending(strm);
  1063|     /* If avail_out is zero, the application will call deflate again
  1064|      * to flush the rest.
  1065|      */
  1066|     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
  1067|     return s->pending != 0 ? Z_OK : Z_STREAM_END;
  1068| }
  1069| /* ========================================================================= */
  1070| int ZEXPORT deflateEnd(strm)
  1071|     z_streamp strm;
  1072| {
  1073|     int status;
  1074|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  1075|     status = strm->state->status;
  1076|     /* Deallocate in reverse order of allocations: */
  1077|     TRY_FREE(strm, strm->state->pending_buf);
  1078|     TRY_FREE(strm, strm->state->head);
  1079|     TRY_FREE(strm, strm->state->prev);
  1080|     TRY_FREE(strm, strm->state->window);
  1081|     ZFREE(strm, strm->state);
  1082|     strm->state = Z_NULL;
  1083|     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
  1084| }
  1085| /* =========================================================================
  1086|  * Copy the source state to the destination state.
  1087|  * To simplify the source, this is not supported for 16-bit MSDOS (which
  1088|  * doesn't have enough memory anyway to duplicate compression states).
  1089|  */
  1090| int ZEXPORT deflateCopy(dest, source)
  1091|     z_streamp dest;
  1092|     z_streamp source;
  1093| {
  1094| #ifdef MAXSEG_64K
  1095|     return Z_STREAM_ERROR;
  1096| #else
  1097|     deflate_state *ds;
  1098|     deflate_state *ss;
  1099|     if (deflateStateCheck(source) || dest == Z_NULL) {
  1100|         return Z_STREAM_ERROR;
  1101|     }
  1102|     ss = source->state;
  1103|     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
  1104|     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
  1105|     if (ds == Z_NULL) return Z_MEM_ERROR;
  1106|     dest->state = (struct internal_state FAR *) ds;
  1107|     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
  1108|     ds->strm = dest;
  1109|     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
  1110|     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
  1111|     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
  1112|     ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);
  1113|     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
  1114|         ds->pending_buf == Z_NULL) {
  1115|         deflateEnd (dest);
  1116|         return Z_MEM_ERROR;
  1117|     }
  1118|     /* following zmemcpy do not work for 16-bit MSDOS */
  1119|     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
  1120|     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
  1121|     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
  1122|     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
  1123|     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
  1124|     ds->sym_buf = ds->pending_buf + ds->lit_bufsize;
  1125|     ds->l_desc.dyn_tree = ds->dyn_ltree;
  1126|     ds->d_desc.dyn_tree = ds->dyn_dtree;
  1127|     ds->bl_desc.dyn_tree = ds->bl_tree;
  1128|     return Z_OK;
  1129| #endif /* MAXSEG_64K */
  1130| }
  1131| /* ===========================================================================
  1132|  * Read a new buffer from the current input stream, update the adler32
  1133|  * and total number of bytes read.  All deflate() input goes through
  1134|  * this function so some applications may wish to modify it to avoid
  1135|  * allocating a large strm->next_in buffer and copying from it.
  1136|  * (See also flush_pending()).
  1137|  */
  1138| local unsigned read_buf(strm, buf, size)
  1139|     z_streamp strm;
  1140|     Bytef *buf;
  1141|     unsigned size;
  1142| {
  1143|     unsigned len = strm->avail_in;
  1144|     if (len > size) len = size;
  1145|     if (len == 0) return 0;
  1146|     strm->avail_in  -= len;
  1147| #ifdef GZIP
  1148|     if (strm->state->wrap == 2) {
  1149| #if defined(USE_PCLMUL_CRC)
  1150|         if (x86_cpu_has_pclmul) {
  1151|             crc_fold_copy(strm->state->crc0, buf, strm->next_in, len);
  1152|         } else
  1153| #endif
  1154|         {
  1155|             zmemcpy(buf, strm->next_in, len);
  1156|             strm->adler = crc32(strm->adler, buf, len);
  1157|         }
  1158|     } else
  1159| #endif
  1160|     {
  1161|         zmemcpy(buf, strm->next_in, len);
  1162|         if (strm->state->wrap == 1)
  1163|             strm->adler = adler32(strm->adler, buf, len);
  1164|     }
  1165|     strm->next_in  += len;
  1166|     strm->total_in += len;
  1167|     return len;
  1168| }
  1169| /* ===========================================================================
  1170|  * Initialize the "longest match" routines for a new zlib stream
  1171|  */
  1172| local void lm_init(s)
  1173|     deflate_state *s;
  1174| {
  1175|     s->window_size = (ulg)2L*s->w_size;
  1176|     CLEAR_HASH(s);
  1177|     /* Set the default configuration parameters:
  1178|      */
  1179|     s->max_lazy_match   = configuration_table[s->level].max_lazy;
  1180|     s->good_match       = configuration_table[s->level].good_length;
  1181|     s->nice_match       = configuration_table[s->level].nice_length;
  1182|     s->max_chain_length = configuration_table[s->level].max_chain;
  1183|     s->strstart = 0;
  1184|     s->block_start = 0L;
  1185|     s->lookahead = 0;
  1186|     s->insert = 0;
  1187|     s->match_length = s->prev_length = MIN_MATCH-1;
  1188|     s->match_available = 0;
  1189|     s->ins_h = 0;
  1190| }
  1191| #ifdef ZLIB_DEBUG
  1192| #define EQUAL 0
  1193| /* result of memcmp for equal strings */
  1194| /* ===========================================================================
  1195|  * Check that the match at match_start is indeed a match.
  1196|  */
  1197| ZLIB_INTERNAL void check_match(s, start, match, length)
  1198|     deflate_state *s;
  1199|     IPos start, match;
  1200|     int length;
  1201| {
  1202|     /* check that the match is indeed a match */
  1203|     if (zmemcmp(s->window + match,
  1204|                 s->window + start, length) != EQUAL) {
  1205|         fprintf(stderr, " start %u, match %u, length %d\n",
  1206|                 start, match, length);
  1207|         do {
  1208|             fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
  1209|         } while (--length != 0);
  1210|         z_error("invalid match");
  1211|     }
  1212|     if (z_verbose > 1) {
  1213|         fprintf(stderr,"\\[%d,%d]", start - match, length);
  1214|         do { putc(s->window[start++], stderr); } while (--length != 0);
  1215|     }
  1216| }
  1217| #endif /* ZLIB_DEBUG */
  1218| /* ===========================================================================
  1219|  * Fill the window when the lookahead becomes insufficient.
  1220|  * Updates strstart and lookahead.
  1221|  *
  1222|  * IN assertion: lookahead < MIN_LOOKAHEAD
  1223|  * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
  1224|  *    At least one byte has been read, or avail_in == 0; reads are
  1225|  *    performed for at least two bytes (required for the zip translate_eol
  1226|  *    option -- not supported here).
  1227|  */
  1228| ZLIB_INTERNAL void fill_window(s)
  1229|     deflate_state *s;
  1230| {
  1231|     unsigned n;
  1232|     unsigned more;    /* Amount of free space at the end of the window. */
  1233|     uInt wsize = s->w_size;
  1234|     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
  1235|     do {
  1236|         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
  1237|         /* Deal with !@#$% 64K limit: */
  1238|         if (sizeof(int) <= 2) {
  1239|             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
  1240|                 more = wsize;
  1241|             } else if (more == (unsigned)(-1)) {
  1242|                 /* Very unlikely, but possible on 16 bit machine if
  1243|                  * strstart == 0 && lookahead == 1 (input done a byte at time)
  1244|                  */
  1245|                 more--;
  1246|             }
  1247|         }
  1248|         /* If the window is almost full and there is insufficient lookahead,
  1249|          * move the upper half to the lower one to make room in the upper half.
  1250|          */
  1251|         if (s->strstart >= wsize + MAX_DIST(s)) {
  1252|             zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);
  1253|             s->match_start -= wsize;
  1254|             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
  1255|             s->block_start -= (long) wsize;
  1256|             if (s->insert > s->strstart)
  1257|                 s->insert = s->strstart;
  1258|             slide_hash(s);
  1259|             more += wsize;
  1260|         }
  1261|         if (s->strm->avail_in == 0) break;
  1262|         /* If there was no sliding:
  1263|          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
  1264|          *    more == window_size - lookahead - strstart
  1265|          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
  1266|          * => more >= window_size - 2*WSIZE + 2
  1267|          * In the BIG_MEM or MMAP case (not yet supported),
  1268|          *   window_size == input_size + MIN_LOOKAHEAD  &&
  1269|          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
  1270|          * Otherwise, window_size == 2*WSIZE so more >= 2.
  1271|          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
  1272|          */
  1273|         Assert(more >= 2, "more < 2");
  1274|         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
  1275|         s->lookahead += n;
  1276|         /* Initialize the hash value now that we have some input: */
  1277|         if (s->lookahead + s->insert >= MIN_MATCH) {
  1278|             uInt str = s->strstart - s->insert;
  1279| #ifdef USE_CRC_HASH
  1280| 	    if (!x86_cpu_has_sse42)
  1281| #endif
  1282|             {
  1283|                 s->ins_h = s->window[str];
  1284|                 UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
  1285| #if MIN_MATCH != 3
  1286|             Call UPDATE_HASH() MIN_MATCH-3 more times
  1287| #endif
  1288|             }
  1289|             while (s->insert) {
  1290|                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
  1291| #ifndef FASTEST
  1292|                 s->prev[str & s->w_mask] = s->head[s->ins_h];
  1293| #endif
  1294|                 s->head[s->ins_h] = (Pos)str;
  1295|                 str++;
  1296|                 s->insert--;
  1297|                 if (s->lookahead + s->insert < MIN_MATCH)
  1298|                     break;
  1299|             }
  1300|         }
  1301|         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
  1302|          * but this is not important since only literal bytes will be emitted.
  1303|          */
  1304|     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
  1305|     /* If the WIN_INIT bytes after the end of the current data have never been
  1306|      * written, then zero those bytes in order to avoid memory check reports of
  1307|      * the use of uninitialized (or uninitialised as Julian writes) bytes by
  1308|      * the longest match routines.  Update the high water mark for the next
  1309|      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
  1310|      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
  1311|      */
  1312|     if (s->high_water < s->window_size) {
  1313|         ulg curr = s->strstart + (ulg)(s->lookahead);
  1314|         ulg init;
  1315|         if (s->high_water < curr) {
  1316|             /* Previous high water mark below current data -- zero WIN_INIT
  1317|              * bytes or up to end of window, whichever is less.
  1318|              */
  1319|             init = s->window_size - curr;
  1320|             if (init > WIN_INIT)
  1321|                 init = WIN_INIT;
  1322|             zmemzero(s->window + curr, (unsigned)init);
  1323|             s->high_water = curr + init;
  1324|         }
  1325|         else if (s->high_water < (ulg)curr + WIN_INIT) {
  1326|             /* High water mark at or above current data, but below current data
  1327|              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  1328|              * to end of window, whichever is less.
  1329|              */
  1330|             init = (ulg)curr + WIN_INIT - s->high_water;
  1331|             if (init > s->window_size - s->high_water)
  1332|                 init = s->window_size - s->high_water;
  1333|             zmemzero(s->window + s->high_water, (unsigned)init);
  1334|             s->high_water += init;
  1335|         }
  1336|     }
  1337|     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  1338|            "not enough room for search");
  1339| }
  1340| /* Maximum stored block length in deflate format (not including header). */
  1341| #define MAX_STORED 65535
  1342| /* Minimum of a and b. */
  1343| #define MIN(a, b) ((a) > (b) ? (b) : (a))
  1344| /* ===========================================================================
  1345|  * Copy without compression as much as possible from the input stream, return
  1346|  * the current block state.
  1347|  *
  1348|  * In case deflateParams() is used to later switch to a non-zero compression
  1349|  * level, s->matches (otherwise unused when storing) keeps track of the number
  1350|  * of hash table slides to perform. If s->matches is 1, then one hash table
  1351|  * slide will be done when switching. If s->matches is 2, the maximum value
  1352|  * allowed here, then the hash table will be cleared, since two or more slides
  1353|  * is the same as a clear.
  1354|  *
  1355|  * deflate_stored() is written to minimize the number of times an input byte is
  1356|  * copied. It is most efficient with large input and output buffers, which
  1357|  * maximizes the opportunities to have a single copy from next_in to next_out.
  1358|  */
  1359| local block_state deflate_stored(s, flush)
  1360|     deflate_state *s;
  1361|     int flush;
  1362| {
  1363|     /* Smallest worthy block size when not flushing or finishing. By default
  1364|      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
  1365|      * large input and output buffers, the stored block size will be larger.
  1366|      */
  1367|     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
  1368|     /* Copy as many min_block or larger stored blocks directly to next_out as
  1369|      * possible. If flushing, copy the remaining available input to next_out as
  1370|      * stored blocks, if there is enough space.
  1371|      */
  1372|     unsigned len, left, have, last = 0;
  1373|     unsigned used = s->strm->avail_in;
  1374|     do {
  1375|         /* Set len to the maximum size block that we can copy directly with the
  1376|          * available input data and output space. Set left to how much of that
  1377|          * would be copied from what's left in the window.
  1378|          */
  1379|         len = MAX_STORED;       /* maximum deflate stored block length */
  1380|         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
  1381|         if (s->strm->avail_out < have)          /* need room for header */
  1382|             break;
  1383|             /* maximum stored block length that will fit in avail_out: */
  1384|         have = s->strm->avail_out - have;
  1385|         left = s->strstart - s->block_start;    /* bytes left in window */
  1386|         if (len > (ulg)left + s->strm->avail_in)
  1387|             len = left + s->strm->avail_in;     /* limit len to the input */
  1388|         if (len > have)
  1389|             len = have;                         /* limit len to the output */
  1390|         /* If the stored block would be less than min_block in length, or if
  1391|          * unable to copy all of the available input when flushing, then try
  1392|          * copying to the window and the pending buffer instead. Also don't
  1393|          * write an empty block when flushing -- deflate() does that.
  1394|          */
  1395|         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
  1396|                                 flush == Z_NO_FLUSH ||
  1397|                                 len != left + s->strm->avail_in))
  1398|             break;
  1399|         /* Make a dummy stored block in pending to get the header bytes,
  1400|          * including any pending bits. This also updates the debugging counts.
  1401|          */
  1402|         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
  1403|         _tr_stored_block(s, (char *)0, 0L, last);
  1404|         /* Replace the lengths in the dummy stored block with len. */
  1405|         s->pending_buf[s->pending - 4] = len;
  1406|         s->pending_buf[s->pending - 3] = len >> 8;
  1407|         s->pending_buf[s->pending - 2] = ~len;
  1408|         s->pending_buf[s->pending - 1] = ~len >> 8;
  1409|         /* Write the stored block header bytes. */
  1410|         flush_pending(s->strm);
  1411| #ifdef ZLIB_DEBUG
  1412|         /* Update debugging counts for the data about to be copied. */
  1413|         s->compressed_len += len << 3;
  1414|         s->bits_sent += len << 3;
  1415| #endif
  1416|         /* Copy uncompressed bytes from the window to next_out. */
  1417|         if (left) {
  1418|             if (left > len)
  1419|                 left = len;
  1420|             zmemcpy(s->strm->next_out, s->window + s->block_start, left);
  1421|             s->strm->next_out += left;
  1422|             s->strm->avail_out -= left;
  1423|             s->strm->total_out += left;
  1424|             s->block_start += left;
  1425|             len -= left;
  1426|         }
  1427|         /* Copy uncompressed bytes directly from next_in to next_out, updating
  1428|          * the check value.
  1429|          */
  1430|         if (len) {
  1431|             read_buf(s->strm, s->strm->next_out, len);
  1432|             s->strm->next_out += len;
  1433|             s->strm->avail_out -= len;
  1434|             s->strm->total_out += len;
  1435|         }
  1436|     } while (last == 0);
  1437|     /* Update the sliding window with the last s->w_size bytes of the copied
  1438|      * data, or append all of the copied data to the existing window if less
  1439|      * than s->w_size bytes were copied. Also update the number of bytes to
  1440|      * insert in the hash tables, in the event that deflateParams() switches to
  1441|      * a non-zero compression level.
  1442|      */
  1443|     used -= s->strm->avail_in;      /* number of input bytes directly copied */
  1444|     if (used) {
  1445|         /* If any input was used, then no unused input remains in the window,
  1446|          * therefore s->block_start == s->strstart.
  1447|          */
  1448|         if (used >= s->w_size) {    /* supplant the previous history */
  1449|             s->matches = 2;         /* clear hash */
  1450|             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
  1451|             s->strstart = s->w_size;
  1452|             s->insert = s->strstart;
  1453|         }
  1454|         else {
  1455|             if (s->window_size - s->strstart <= used) {
  1456|                 /* Slide the window down. */
  1457|                 s->strstart -= s->w_size;
  1458|                 zmemcpy(s->window, s->window + s->w_size, s->strstart);
  1459|                 if (s->matches < 2)
  1460|                     s->matches++;   /* add a pending slide_hash() */
  1461|                 if (s->insert > s->strstart)
  1462|                     s->insert = s->strstart;
  1463|             }
  1464|             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
  1465|             s->strstart += used;
  1466|             s->insert += MIN(used, s->w_size - s->insert);
  1467|         }
  1468|         s->block_start = s->strstart;
  1469|     }
  1470|     if (s->high_water < s->strstart)
  1471|         s->high_water = s->strstart;
  1472|     /* If the last block was written to next_out, then done. */
  1473|     if (last)
  1474|         return finish_done;
  1475|     /* If flushing and all input has been consumed, then done. */
  1476|     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
  1477|         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
  1478|         return block_done;
  1479|     /* Fill the window with any remaining input. */
  1480|     have = s->window_size - s->strstart;
  1481|     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
  1482|         /* Slide the window down. */
  1483|         s->block_start -= s->w_size;
  1484|         s->strstart -= s->w_size;
  1485|         zmemcpy(s->window, s->window + s->w_size, s->strstart);
  1486|         if (s->matches < 2)
  1487|             s->matches++;           /* add a pending slide_hash() */
  1488|         have += s->w_size;          /* more space now */
  1489|         if (s->insert > s->strstart)
  1490|             s->insert = s->strstart;
  1491|     }
  1492|     if (have > s->strm->avail_in)
  1493|         have = s->strm->avail_in;
  1494|     if (have) {
  1495|         read_buf(s->strm, s->window + s->strstart, have);
  1496|         s->strstart += have;
  1497|         s->insert += MIN(have, s->w_size - s->insert);
  1498|     }
  1499|     if (s->high_water < s->strstart)
  1500|         s->high_water = s->strstart;
  1501|     /* There was not enough avail_out to write a complete worthy or flushed
  1502|      * stored block to next_out. Write a stored block to pending instead, if we
  1503|      * have enough input for a worthy block, or if flushing and there is enough
  1504|      * room for the remaining input as a stored block in the pending buffer.
  1505|      */
  1506|     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
  1507|         /* maximum stored block length that will fit in pending: */
  1508|     have = MIN(s->pending_buf_size - have, MAX_STORED);
  1509|     min_block = MIN(have, s->w_size);
  1510|     left = s->strstart - s->block_start;
  1511|     if (left >= min_block ||
  1512|         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
  1513|          s->strm->avail_in == 0 && left <= have)) {
  1514|         len = MIN(left, have);
  1515|         last = flush == Z_FINISH && s->strm->avail_in == 0 &&
  1516|                len == left ? 1 : 0;
  1517|         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
  1518|         s->block_start += len;
  1519|         flush_pending(s->strm);
  1520|     }
  1521|     /* We've done all we can with the available input and output. */
  1522|     return last ? finish_started : need_more;
  1523| }
  1524| /* ===========================================================================
  1525|  * Compress as much as possible from the input stream, return the current
  1526|  * block state.
  1527|  * This function does not perform lazy evaluation of matches and inserts
  1528|  * new strings in the dictionary only for unmatched strings or for short
  1529|  * matches. It is used only for the fast compression options.
  1530|  */
  1531| local block_state deflate_fast(s, flush)
  1532|     deflate_state *s;
  1533|     int flush;
  1534| {
  1535|     IPos hash_head;       /* head of the hash chain */
  1536|     int bflush;           /* set if current block must be flushed */
  1537|     for (;;) {
  1538|         /* Make sure that we always have enough lookahead, except
  1539|          * at the end of the input file. We need MAX_MATCH bytes
  1540|          * for the next match, plus MIN_MATCH bytes to insert the
  1541|          * string following the next match.
  1542|          */
  1543|         if (s->lookahead < MIN_LOOKAHEAD) {
  1544|             fill_window(s);
  1545|             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
  1546|                 return need_more;
  1547|             }
  1548|             if (s->lookahead == 0) break; /* flush the current block */
  1549|         }
  1550|         /* Insert the string window[strstart .. strstart + 2] in the
  1551|          * dictionary, and set hash_head to the head of the hash chain:
  1552|          */
  1553|         hash_head = NIL;
  1554|         if (s->lookahead >= MIN_MATCH) {
  1555|             INSERT_STRING(s, s->strstart, hash_head);
  1556|         }
  1557|         /* Find the longest match, discarding those <= prev_length.
  1558|          * At this point we have always match_length < MIN_MATCH
  1559|          */
  1560|         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
  1561|             /* To simplify the code, we prevent matches with the string
  1562|              * of window index 0 (in particular we have to avoid a match
  1563|              * of the string with itself at the start of the input file).
  1564|              */
  1565|             s->match_length = longest_match (s, hash_head);
  1566|             /* longest_match() sets match_start */
  1567|         }
  1568|         if (s->match_length >= MIN_MATCH) {
  1569|             check_match(s, s->strstart, s->match_start, s->match_length);
  1570|             _tr_tally_dist(s, s->strstart - s->match_start,
  1571|                            s->match_length - MIN_MATCH, bflush);
  1572|             s->lookahead -= s->match_length;
  1573|             /* Insert new strings in the hash table only if the match length
  1574|              * is not too large. This saves time but degrades compression.
  1575|              */
  1576| #ifndef FASTEST
  1577|             if (s->match_length <= s->max_insert_length &&
  1578|                 s->lookahead >= MIN_MATCH) {
  1579|                 s->match_length--; /* string at strstart already in table */
  1580|                 do {
  1581|                     s->strstart++;
  1582|                     INSERT_STRING(s, s->strstart, hash_head);
  1583|                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
  1584|                      * always MIN_MATCH bytes ahead.
  1585|                      */
  1586|                 } while (--s->match_length != 0);
  1587|                 s->strstart++;
  1588|             } else
  1589| #endif
  1590|             {
  1591|                 s->strstart += s->match_length;
  1592|                 s->match_length = 0;
  1593| #ifdef USE_CRC_HASH
  1594|                 if (!x86_cpu_has_sse42)
  1595| #endif
  1596|                 {
  1597|                     s->ins_h = s->window[s->strstart];
  1598|                     UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
  1599| #if MIN_MATCH != 3
  1600|                 Call UPDATE_HASH() MIN_MATCH-3 more times
  1601| #endif
  1602|                 }
  1603|                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
  1604|                  * matter since it will be recomputed at next deflate call.
  1605|                  */
  1606|             }
  1607|         } else {
  1608|             /* No match, output a literal byte */
  1609|             Tracevv((stderr,"%c", s->window[s->strstart]));
  1610|             _tr_tally_lit(s, s->window[s->strstart], bflush);
  1611|             s->lookahead--;
  1612|             s->strstart++;
  1613|         }
  1614|         if (bflush) FLUSH_BLOCK(s, 0);
  1615|     }
  1616|     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
  1617|     if (flush == Z_FINISH) {
  1618|         FLUSH_BLOCK(s, 1);
  1619|         return finish_done;
  1620|     }
  1621|     if (s->sym_next)
  1622|         FLUSH_BLOCK(s, 0);
  1623|     return block_done;
  1624| }
  1625| #ifndef FASTEST
  1626| /* ===========================================================================
  1627|  * Same as above, but achieves better compression. We use a lazy
  1628|  * evaluation for matches: a match is finally adopted only if there is
  1629|  * no better match at the next window position.
  1630|  */
  1631| local block_state deflate_slow(s, flush)
  1632|     deflate_state *s;
  1633|     int flush;
  1634| {
  1635|     IPos hash_head;          /* head of hash chain */
  1636|     int bflush;              /* set if current block must be flushed */
  1637|     /* Process the input block. */
  1638|     for (;;) {
  1639|         /* Make sure that we always have enough lookahead, except
  1640|          * at the end of the input file. We need MAX_MATCH bytes
  1641|          * for the next match, plus MIN_MATCH bytes to insert the
  1642|          * string following the next match.
  1643|          */
  1644|         if (s->lookahead < MIN_LOOKAHEAD) {
  1645|             fill_window(s);
  1646|             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
  1647|                 return need_more;
  1648|             }
  1649|             if (s->lookahead == 0) break; /* flush the current block */
  1650|         }
  1651|         /* Insert the string window[strstart .. strstart + 2] in the
  1652|          * dictionary, and set hash_head to the head of the hash chain:
  1653|          */
  1654|         hash_head = NIL;
  1655|         if (s->lookahead >= MIN_MATCH) {
  1656|             INSERT_STRING(s, s->strstart, hash_head);
  1657|         }
  1658|         /* Find the longest match, discarding those <= prev_length.
  1659|          */
  1660|         s->prev_length = s->match_length, s->prev_match = s->match_start;
  1661|         s->match_length = MIN_MATCH-1;
  1662|         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
  1663|             s->strstart - hash_head <= MAX_DIST(s)) {
  1664|             /* To simplify the code, we prevent matches with the string
  1665|              * of window index 0 (in particular we have to avoid a match
  1666|              * of the string with itself at the start of the input file).
  1667|              */
  1668|             s->match_length = longest_match (s, hash_head);
  1669|             /* longest_match() sets match_start */
  1670|             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
  1671| #if TOO_FAR <= 32767
  1672|                 || (s->match_length == MIN_MATCH &&
  1673|                     s->strstart - s->match_start > TOO_FAR)
  1674| #endif
  1675|                 )) {
  1676|                 /* If prev_match is also MIN_MATCH, match_start is garbage
  1677|                  * but we will ignore the current match anyway.
  1678|                  */
  1679|                 s->match_length = MIN_MATCH-1;
  1680|             }
  1681|         }
  1682|         /* If there was a match at the previous step and the current
  1683|          * match is not better, output the previous match:
  1684|          */
  1685|         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
  1686|             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
  1687|             /* Do not insert strings in hash table beyond this. */
  1688|             check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
  1689|             _tr_tally_dist(s, s->strstart - 1 - s->prev_match,
  1690|                            s->prev_length - MIN_MATCH, bflush);
  1691|             /* Insert in hash table all strings up to the end of the match.
  1692|              * strstart - 1 and strstart are already inserted. If there is not
  1693|              * enough lookahead, the last two strings are not inserted in
  1694|              * the hash table.
  1695|              */
  1696|             s->lookahead -= s->prev_length - 1;
  1697|             s->prev_length -= 2;
  1698|             do {
  1699|                 if (++s->strstart <= max_insert) {
  1700|                     INSERT_STRING(s, s->strstart, hash_head);
  1701|                 }
  1702|             } while (--s->prev_length != 0);
  1703|             s->match_available = 0;
  1704|             s->match_length = MIN_MATCH-1;
  1705|             s->strstart++;
  1706|             if (bflush) FLUSH_BLOCK(s, 0);
  1707|         } else if (s->match_available) {
  1708|             /* If there was no match at the previous position, output a
  1709|              * single literal. If there was a match but the current match
  1710|              * is longer, truncate the previous match to a single literal.
  1711|              */
  1712|             Tracevv((stderr,"%c", s->window[s->strstart - 1]));
  1713|             _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
  1714|             if (bflush) {
  1715|                 FLUSH_BLOCK_ONLY(s, 0);
  1716|             }
  1717|             s->strstart++;
  1718|             s->lookahead--;
  1719|             if (s->strm->avail_out == 0) return need_more;
  1720|         } else {
  1721|             /* There is no previous match to compare with, wait for
  1722|              * the next step to decide.
  1723|              */
  1724|             s->match_available = 1;
  1725|             s->strstart++;
  1726|             s->lookahead--;
  1727|         }
  1728|     }
  1729|     Assert (flush != Z_NO_FLUSH, "no flush?");
  1730|     if (s->match_available) {
  1731|         Tracevv((stderr,"%c", s->window[s->strstart - 1]));
  1732|         _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
  1733|         s->match_available = 0;
  1734|     }
  1735|     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
  1736|     if (flush == Z_FINISH) {
  1737|         FLUSH_BLOCK(s, 1);
  1738|         return finish_done;
  1739|     }
  1740|     if (s->sym_next)
  1741|         FLUSH_BLOCK(s, 0);
  1742|     return block_done;
  1743| }
  1744| #endif /* FASTEST */
  1745| /* ===========================================================================
  1746|  * For Z_RLE, simply look for runs of bytes, generate matches only of distance
  1747|  * one.  Do not maintain a hash table.  (It will be regenerated if this run of
  1748|  * deflate switches away from Z_RLE.)
  1749|  */
  1750| local block_state deflate_rle(s, flush)
  1751|     deflate_state *s;
  1752|     int flush;
  1753| {
  1754|     int bflush;             /* set if current block must be flushed */
  1755|     uInt prev;              /* byte at distance one to match */
  1756|     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
  1757|     for (;;) {
  1758|         /* Make sure that we always have enough lookahead, except
  1759|          * at the end of the input file. We need MAX_MATCH bytes
  1760|          * for the longest run, plus one for the unrolled loop.
  1761|          */
  1762|         if (s->lookahead <= MAX_MATCH) {
  1763|             fill_window(s);
  1764|             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
  1765|                 return need_more;
  1766|             }
  1767|             if (s->lookahead == 0) break; /* flush the current block */
  1768|         }
  1769|         /* See how many times the previous byte repeats */
  1770|         s->match_length = 0;
  1771|         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
  1772|             scan = s->window + s->strstart - 1;
  1773|             prev = *scan;
  1774|             if (prev == *++scan && prev == *++scan && prev == *++scan) {
  1775|                 strend = s->window + s->strstart + MAX_MATCH;
  1776|                 do {
  1777|                 } while (prev == *++scan && prev == *++scan &&
  1778|                          prev == *++scan && prev == *++scan &&
  1779|                          prev == *++scan && prev == *++scan &&
  1780|                          prev == *++scan && prev == *++scan &&
  1781|                          scan < strend);
  1782|                 s->match_length = MAX_MATCH - (uInt)(strend - scan);
  1783|                 if (s->match_length > s->lookahead)
  1784|                     s->match_length = s->lookahead;
  1785|             }
  1786|             Assert(scan <= s->window + (uInt)(s->window_size - 1),
  1787|                    "wild scan");
  1788|         }
  1789|         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
  1790|         if (s->match_length >= MIN_MATCH) {
  1791|             check_match(s, s->strstart, s->strstart - 1, s->match_length);
  1792|             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
  1793|             s->lookahead -= s->match_length;
  1794|             s->strstart += s->match_length;
  1795|             s->match_length = 0;
  1796|         } else {
  1797|             /* No match, output a literal byte */
  1798|             Tracevv((stderr,"%c", s->window[s->strstart]));
  1799|             _tr_tally_lit(s, s->window[s->strstart], bflush);
  1800|             s->lookahead--;
  1801|             s->strstart++;
  1802|         }
  1803|         if (bflush) FLUSH_BLOCK(s, 0);
  1804|     }
  1805|     s->insert = 0;
  1806|     if (flush == Z_FINISH) {
  1807|         FLUSH_BLOCK(s, 1);
  1808|         return finish_done;
  1809|     }
  1810|     if (s->sym_next)
  1811|         FLUSH_BLOCK(s, 0);
  1812|     return block_done;
  1813| }
  1814| /* ===========================================================================
  1815|  * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
  1816|  * (It will be regenerated if this run of deflate switches away from Huffman.)
  1817|  */
  1818| local block_state deflate_huff(s, flush)
  1819|     deflate_state *s;
  1820|     int flush;
  1821| {
  1822|     int bflush;             /* set if current block must be flushed */
  1823|     for (;;) {
  1824|         /* Make sure that we have a literal to write. */
  1825|         if (s->lookahead == 0) {
  1826|             fill_window(s);
  1827|             if (s->lookahead == 0) {
  1828|                 if (flush == Z_NO_FLUSH)
  1829|                     return need_more;
  1830|                 break;      /* flush the current block */
  1831|             }
  1832|         }
  1833|         /* Output a literal byte */
  1834|         s->match_length = 0;
  1835|         Tracevv((stderr,"%c", s->window[s->strstart]));
  1836|         _tr_tally_lit(s, s->window[s->strstart], bflush);
  1837|         s->lookahead--;
  1838|         s->strstart++;
  1839|         if (bflush) FLUSH_BLOCK(s, 0);
  1840|     }
  1841|     s->insert = 0;
  1842|     if (flush == Z_FINISH) {
  1843|         FLUSH_BLOCK(s, 1);
  1844|         return finish_done;
  1845|     }
  1846|     if (s->sym_next)
  1847|         FLUSH_BLOCK(s, 0);
  1848|     return block_done;
  1849| }


# ====================================================================
# FILE: src/native/external/zlib-intel/deflate_quick.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2332 ---
     1| /*
     2|  * The deflate_quick deflate strategy, designed to be used when cycles are
     3|  * at a premium.
     4|  *
     5|  * Copyright (C) 2013 Intel Corporation. All rights reserved.
     6|  * Authors:
     7|  *  Wajdi Feghali   <wajdi.k.feghali@intel.com>
     8|  *  Jim Guilford    <james.guilford@intel.com>
     9|  *  Vinodh Gopal    <vinodh.gopal@intel.com>
    10|  * 	Erdinc Ozturk   <erdinc.ozturk@intel.com>
    11|  *  Jim Kukunas     <james.t.kukunas@linux.intel.com>
    12|  *
    13|  * For conditions of distribution and use, see copyright notice in zlib.h
    14|  */
    15| #include "deflate.h"
    16| #if defined(USE_QUICK)
    17| #include <immintrin.h>
    18| #ifndef _MSC_VER
    19| local inline long compare258(z_const unsigned char *z_const src0,
    20|         z_const unsigned char *z_const src1)
    21| {
    22|     long ax, dx, cx;
    23|     __m128i xmm_src0;
    24|     ax = 16;
    25|     dx = 16;
    26|     __asm__ __volatile__ (
    27|     "1:"
    28|         "movdqu     -16(%[src0], %[ax]), %[xmm_src0]\n\t"
    29|         "pcmpestri  $0x18, -16(%[src1], %[ax]), %[xmm_src0]\n\t"
    30|         "jc         2f\n\t"
    31|         "add        $16, %[ax]\n\t"
    32|         "movdqu     -16(%[src0], %[ax]), %[xmm_src0]\n\t"
    33|         "pcmpestri  $0x18, -16(%[src1], %[ax]), %[xmm_src0]\n\t"
    34|         "jc         2f\n\t"
    35|         "add        $16, %[ax]\n\t"
    36|         "cmp        $256 + 16, %[ax]\n\t"
    37|         "jb         1b\n\t"
    38| #ifdef X86
    39|         "movzwl     -16(%[src0], %[ax]), %[dx]\n\t"
    40| #else
    41|         "movzwq     -16(%[src0], %[ax]), %[dx]\n\t"
    42| #endif
    43|         "xorw       -16(%[src1], %[ax]), %%dx\n\t"
    44|         "jnz        3f\n\t"
    45|         "add        $2, %[ax]\n\t"
    46|         "jmp        4f\n\t"
    47|     "3:\n\t"
    48|         "rep; bsf   %[dx], %[cx]\n\t"
    49|         "shr        $3, %[cx]\n\t"
    50|     "2:"
    51|         "add        %[cx], %[ax]\n\t"
    52|     "4:"
    53|     : [ax] "+a" (ax),
    54|       [cx] "+c" (cx),
    55|       [dx] "+d" (dx),
    56|       [xmm_src0] "=x" (xmm_src0)
    57|     : [src0] "r" (src0),
    58|       [src1] "r" (src1)
    59|     : "cc"
    60|     );
    61|     return ax - 16;
    62| }
    63| #else
    64| #include <nmmintrin.h>
    65| local inline long compare258(z_const unsigned char *z_const src0,
    66|         z_const unsigned char *z_const src1)
    67| {
    68|     long cnt;
    69|     cnt = 0;
    70|     do {
    71| #define mode  _SIDD_UBYTE_OPS | _SIDD_CMP_EQUAL_EACH | _SIDD_NEGATIVE_POLARITY
    72|         int ret;
    73|         __m128i xmm_src0, xmm_src1;
    74|         xmm_src0 = _mm_loadu_si128((__m128i *)(src0 + cnt));
    75|         xmm_src1 = _mm_loadu_si128((__m128i *)(src1 + cnt));
    76|         ret = _mm_cmpestri(xmm_src0, 16, xmm_src1, 16, mode);
    77|         if (_mm_cmpestrc(xmm_src0, 16, xmm_src1, 16, mode)) {
    78|             cnt += ret;
    79|             break;
    80|         }
    81|         cnt += 16;
    82|         xmm_src0 = _mm_loadu_si128((__m128i *)(src0 + cnt));
    83|         xmm_src1 = _mm_loadu_si128((__m128i *)(src1 + cnt));
    84|         ret = _mm_cmpestri(xmm_src0, 16, xmm_src1, 16, mode);
    85|         if (_mm_cmpestrc(xmm_src0, 16, xmm_src1, 16, mode)) {
    86|             cnt += ret;
    87|             break;
    88|         }
    89|         cnt += 16;
    90|     } while (cnt < 256);
    91|     if (*(unsigned short *)(src0 + cnt) == *(unsigned short *)(src1 + cnt)) {
    92|         cnt += 2;
    93|     } else if (*(src0 + cnt) == *(src1 + cnt)) {
    94|         cnt++;
    95|     }
    96|     return cnt;
    97| }
    98| #endif
    99| local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1];
   100| local z_const unsigned quick_dist_codes[8192];
   101| local inline void quick_send_bits(deflate_state *z_const s, z_const int value,
   102|         z_const int length)
   103| {
   104|     unsigned code, out, w, b;
   105|     out = s->bi_buf;
   106|     w = s->bi_valid;
   107|     code = value << s->bi_valid;
   108|     out |= code;
   109|     w += length;
   110|     if (s->pending + 4 >= s->pending_buf_size)
   111|         flush_pending(s->strm);
   112|     *(unsigned *)(s->pending_buf + s->pending) = out;
   113|     b = w >> 3;
   114|     s->pending += b;
   115|     s->bi_buf =  out >> (b << 3);
   116|     s->bi_valid = w - (b << 3);
   117| }
   118| local inline void static_emit_ptr(deflate_state *z_const s, z_const int lc,
   119|         z_const unsigned dist)
   120| {
   121|     unsigned code, len;
   122|     code = quick_len_codes[lc] >> 8;
   123|     len =  quick_len_codes[lc] & 0xFF;
   124|     quick_send_bits(s, code, len);
   125|     code = quick_dist_codes[dist-1] >> 8;
   126|     len  = quick_dist_codes[dist-1] & 0xFF;
   127|     quick_send_bits(s, code, len);
   128| }
   129| z_const ct_data static_ltree[L_CODES+2];
   130| local inline void static_emit_lit(deflate_state *z_const s,z_const int lit)
   131| {
   132|     quick_send_bits(s, static_ltree[lit].Code, static_ltree[lit].Len);
   133|     Tracecv(isgraph(lit), (stderr," '%c' ", lit));
   134| }
   135| local void static_emit_tree(deflate_state *z_const s,
   136|         z_const int flush)
   137| {
   138|     unsigned last;
   139|     last = flush == Z_FINISH ? 1 : 0;
   140|     send_bits(s, (STATIC_TREES<<1)+ last, 3);
   141| }
   142| local void static_emit_end_block(deflate_state *z_const s,
   143|         int last)
   144| {
   145|     send_code(s, END_BLOCK, static_ltree);
   146|     if (last)
   147|         bi_windup(s);
   148|     s->block_start = s->strstart;
   149|     flush_pending(s->strm);
   150| }
   151| local inline Pos quick_insert_string(deflate_state *z_const s, z_const Pos str)
   152| {
   153|     Pos ret;
   154|     unsigned h = 0;
   155| #ifndef _MSC_VER
   156|     __asm__ __volatile__ (
   157|         "crc32l (%[window], %[str], 1), %0\n\t"
   158|     : "+r" (h)
   159|     : [window] "r" (s->window),
   160|       [str] "r" ((long)str)
   161|     );
   162| #else
   163|     h = _mm_crc32_u32(h, *(unsigned *)(s->window + str));
   164| #endif
   165|     ret = s->head[h & s->hash_mask];
   166|     s->head[h & s->hash_mask] = str;
   167|     return ret;
   168| }
   169| block_state deflate_quick(deflate_state *s, int flush)
   170| {
   171|     IPos hash_head;
   172|     unsigned dist, match_len;
   173|     static_emit_tree(s, flush);
   174|     do {
   175|         if (s->lookahead < MIN_LOOKAHEAD) {
   176|             fill_window(s);
   177|             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
   178|                 static_emit_end_block(s, 0);
   179|                 return need_more;
   180|             }
   181|             if (s->lookahead == 0)
   182|                 break;
   183|         }
   184|         if (s->lookahead >= MIN_MATCH) {
   185|             hash_head = quick_insert_string(s, s->strstart);
   186|             dist = s->strstart - hash_head;
   187|             if ((dist-1) < (s->w_size - 1)) {
   188|                 match_len = compare258(s->window + s->strstart, s->window + s->strstart - dist);
   189|                 if (match_len >= MIN_MATCH) {
   190|                     if (match_len > s->lookahead)
   191|                         match_len = s->lookahead;
   192|                     static_emit_ptr(s, match_len - MIN_MATCH, s->strstart - hash_head);
   193|                     s->lookahead -= match_len;
   194|                     s->strstart += match_len;
   195|                     continue;
   196|                 }
   197|             }
   198|         }
   199|         static_emit_lit(s, s->window[s->strstart]);
   200|         s->strstart++;
   201|         s->lookahead--;
   202|     } while (s->strm->avail_out != 0);
   203|     if (s->strm->avail_out == 0 && flush != Z_FINISH)
   204|         return need_more;
   205|     s->insert = s->strstart < MIN_MATCH - 1 ? s->strstart : MIN_MATCH-1;
   206|     if (flush == Z_FINISH) {
   207|         static_emit_end_block(s, 1);
   208|         if (s->strm->avail_out == 0)
   209|             return finish_started;
   210|         else
   211|             return finish_done;
   212|     }
   213|     static_emit_end_block(s, 0);
   214|     return block_done;
   215| }
   216| local z_const unsigned quick_len_codes[MAX_MATCH-MIN_MATCH+1] = {
   217| 	0x00004007, 0x00002007, 0x00006007, 0x00001007, 
   218| 	0x00005007, 0x00003007, 0x00007007, 0x00000807, 
   219| 	0x00004808, 0x0000c808, 0x00002808, 0x0000a808, 
   220| 	0x00006808, 0x0000e808, 0x00001808, 0x00009808, 
   221| 	0x00005809, 0x0000d809, 0x00015809, 0x0001d809, 
   222| 	0x00003809, 0x0000b809, 0x00013809, 0x0001b809, 
   223| 	0x00007809, 0x0000f809, 0x00017809, 0x0001f809, 
   224| 	0x00000409, 0x00008409, 0x00010409, 0x00018409, 
   225| 	0x0000440a, 0x0000c40a, 0x0001440a, 0x0001c40a, 
   226| 	0x0002440a, 0x0002c40a, 0x0003440a, 0x0003c40a, 
   227| 	0x0000240a, 0x0000a40a, 0x0001240a, 0x0001a40a, 
   228| 	0x0002240a, 0x0002a40a, 0x0003240a, 0x0003a40a, 
   229| 	0x0000640a, 0x0000e40a, 0x0001640a, 0x0001e40a, 
   230| 	0x0002640a, 0x0002e40a, 0x0003640a, 0x0003e40a, 
   231| 	0x0000140a, 0x0000940a, 0x0001140a, 0x0001940a, 
   232| 	0x0002140a, 0x0002940a, 0x0003140a, 0x0003940a, 
   233| 	0x0000540b, 0x0000d40b, 0x0001540b, 0x0001d40b, 
   234| 	0x0002540b, 0x0002d40b, 0x0003540b, 0x0003d40b, 
   235| 	0x0004540b, 0x0004d40b, 0x0005540b, 0x0005d40b, 
   236| 	0x0006540b, 0x0006d40b, 0x0007540b, 0x0007d40b, 
   237| 	0x0000340b, 0x0000b40b, 0x0001340b, 0x0001b40b, 
   238| 	0x0002340b, 0x0002b40b, 0x0003340b, 0x0003b40b, 
   239| 	0x0004340b, 0x0004b40b, 0x0005340b, 0x0005b40b, 
   240| 	0x0006340b, 0x0006b40b, 0x0007340b, 0x0007b40b, 
   241| 	0x0000740b, 0x0000f40b, 0x0001740b, 0x0001f40b, 
   242| 	0x0002740b, 0x0002f40b, 0x0003740b, 0x0003f40b, 
   243| 	0x0004740b, 0x0004f40b, 0x0005740b, 0x0005f40b, 
   244| 	0x0006740b, 0x0006f40b, 0x0007740b, 0x0007f40b, 
   245| 	0x0000030c, 0x0001030c, 0x0002030c, 0x0003030c, 
   246| 	0x0004030c, 0x0005030c, 0x0006030c, 0x0007030c, 
   247| 	0x0008030c, 0x0009030c, 0x000a030c, 0x000b030c, 
   248| 	0x000c030c, 0x000d030c, 0x000e030c, 0x000f030c, 
   249| 	0x0000830d, 0x0001830d, 0x0002830d, 0x0003830d, 
   250| 	0x0004830d, 0x0005830d, 0x0006830d, 0x0007830d, 
   251| 	0x0008830d, 0x0009830d, 0x000a830d, 0x000b830d, 
   252| 	0x000c830d, 0x000d830d, 0x000e830d, 0x000f830d, 
   253| 	0x0010830d, 0x0011830d, 0x0012830d, 0x0013830d, 
   254| 	0x0014830d, 0x0015830d, 0x0016830d, 0x0017830d, 
   255| 	0x0018830d, 0x0019830d, 0x001a830d, 0x001b830d, 
   256| 	0x001c830d, 0x001d830d, 0x001e830d, 0x001f830d, 
   257| 	0x0000430d, 0x0001430d, 0x0002430d, 0x0003430d, 
   258| 	0x0004430d, 0x0005430d, 0x0006430d, 0x0007430d, 
   259| 	0x0008430d, 0x0009430d, 0x000a430d, 0x000b430d, 
   260| 	0x000c430d, 0x000d430d, 0x000e430d, 0x000f430d, 
   261| 	0x0010430d, 0x0011430d, 0x0012430d, 0x0013430d, 
   262| 	0x0014430d, 0x0015430d, 0x0016430d, 0x0017430d, 
   263| 	0x0018430d, 0x0019430d, 0x001a430d, 0x001b430d, 
   264| 	0x001c430d, 0x001d430d, 0x001e430d, 0x001f430d, 
   265| 	0x0000c30d, 0x0001c30d, 0x0002c30d, 0x0003c30d, 
   266| 	0x0004c30d, 0x0005c30d, 0x0006c30d, 0x0007c30d, 
   267| 	0x0008c30d, 0x0009c30d, 0x000ac30d, 0x000bc30d, 
   268| 	0x000cc30d, 0x000dc30d, 0x000ec30d, 0x000fc30d, 
   269| 	0x0010c30d, 0x0011c30d, 0x0012c30d, 0x0013c30d, 
   270| 	0x0014c30d, 0x0015c30d, 0x0016c30d, 0x0017c30d, 
   271| 	0x0018c30d, 0x0019c30d, 0x001ac30d, 0x001bc30d, 
   272| 	0x001cc30d, 0x001dc30d, 0x001ec30d, 0x001fc30d, 
   273| 	0x0000230d, 0x0001230d, 0x0002230d, 0x0003230d, 
   274| 	0x0004230d, 0x0005230d, 0x0006230d, 0x0007230d, 
   275| 	0x0008230d, 0x0009230d, 0x000a230d, 0x000b230d, 
   276| 	0x000c230d, 0x000d230d, 0x000e230d, 0x000f230d, 
   277| 	0x0010230d, 0x0011230d, 0x0012230d, 0x0013230d, 
   278| 	0x0014230d, 0x0015230d, 0x0016230d, 0x0017230d, 
   279| 	0x0018230d, 0x0019230d, 0x001a230d, 0x001b230d, 
   280| 	0x001c230d, 0x001d230d, 0x001e230d, 0x0000a308, 
   281| };
   282| local z_const unsigned quick_dist_codes[8192] = {
   283| 	0x00000005, 0x00001005, 0x00000805, 0x00001805, 
   284| 	0x00000406, 0x00002406, 0x00001406, 0x00003406, 
   285| 	0x00000c07, 0x00002c07, 0x00004c07, 0x00006c07, 
   286| 	0x00001c07, 0x00003c07, 0x00005c07, 0x00007c07, 
   287| 	0x00000208, 0x00002208, 0x00004208, 0x00006208, 
   288| 	0x00008208, 0x0000a208, 0x0000c208, 0x0000e208, 
   289| 	0x00001208, 0x00003208, 0x00005208, 0x00007208, 
   290| 	0x00009208, 0x0000b208, 0x0000d208, 0x0000f208, 
   291| 	0x00000a09, 0x00002a09, 0x00004a09, 0x00006a09, 
   292| 	0x00008a09, 0x0000aa09, 0x0000ca09, 0x0000ea09, 
   293| 	0x00010a09, 0x00012a09, 0x00014a09, 0x00016a09, 
   294| 	0x00018a09, 0x0001aa09, 0x0001ca09, 0x0001ea09, 
   295| 	0x00001a09, 0x00003a09, 0x00005a09, 0x00007a09, 
   296| 	0x00009a09, 0x0000ba09, 0x0000da09, 0x0000fa09, 
   297| 	0x00011a09, 0x00013a09, 0x00015a09, 0x00017a09, 
   298| 	0x00019a09, 0x0001ba09, 0x0001da09, 0x0001fa09, 
   299| 	0x0000060a, 0x0000260a, 0x0000460a, 0x0000660a, 
   300| 	0x0000860a, 0x0000a60a, 0x0000c60a, 0x0000e60a, 
   301| 	0x0001060a, 0x0001260a, 0x0001460a, 0x0001660a, 
   302| 	0x0001860a, 0x0001a60a, 0x0001c60a, 0x0001e60a, 
   303| 	0x0002060a, 0x0002260a, 0x0002460a, 0x0002660a, 
   304| 	0x0002860a, 0x0002a60a, 0x0002c60a, 0x0002e60a, 
   305| 	0x0003060a, 0x0003260a, 0x0003460a, 0x0003660a, 
   306| 	0x0003860a, 0x0003a60a, 0x0003c60a, 0x0003e60a, 
   307| 	0x0000160a, 0x0000360a, 0x0000560a, 0x0000760a, 
   308| 	0x0000960a, 0x0000b60a, 0x0000d60a, 0x0000f60a, 
   309| 	0x0001160a, 0x0001360a, 0x0001560a, 0x0001760a, 
   310| 	0x0001960a, 0x0001b60a, 0x0001d60a, 0x0001f60a, 
   311| 	0x0002160a, 0x0002360a, 0x0002560a, 0x0002760a, 
   312| 	0x0002960a, 0x0002b60a, 0x0002d60a, 0x0002f60a, 
   313| 	0x0003160a, 0x0003360a, 0x0003560a, 0x0003760a, 
   314| 	0x0003960a, 0x0003b60a, 0x0003d60a, 0x0003f60a, 
   315| 	0x00000e0b, 0x00002e0b, 0x00004e0b, 0x00006e0b, 
   316| 	0x00008e0b, 0x0000ae0b, 0x0000ce0b, 0x0000ee0b, 
   317| 	0x00010e0b, 0x00012e0b, 0x00014e0b, 0x00016e0b, 
   318| 	0x00018e0b, 0x0001ae0b, 0x0001ce0b, 0x0001ee0b, 
   319| 	0x00020e0b, 0x00022e0b, 0x00024e0b, 0x00026e0b, 
   320| 	0x00028e0b, 0x0002ae0b, 0x0002ce0b, 0x0002ee0b, 
   321| 	0x00030e0b, 0x00032e0b, 0x00034e0b, 0x00036e0b, 
   322| 	0x00038e0b, 0x0003ae0b, 0x0003ce0b, 0x0003ee0b, 
   323| 	0x00040e0b, 0x00042e0b, 0x00044e0b, 0x00046e0b, 
   324| 	0x00048e0b, 0x0004ae0b, 0x0004ce0b, 0x0004ee0b, 
   325| 	0x00050e0b, 0x00052e0b, 0x00054e0b, 0x00056e0b, 
   326| 	0x00058e0b, 0x0005ae0b, 0x0005ce0b, 0x0005ee0b, 
   327| 	0x00060e0b, 0x00062e0b, 0x00064e0b, 0x00066e0b, 
   328| 	0x00068e0b, 0x0006ae0b, 0x0006ce0b, 0x0006ee0b, 
   329| 	0x00070e0b, 0x00072e0b, 0x00074e0b, 0x00076e0b, 
   330| 	0x00078e0b, 0x0007ae0b, 0x0007ce0b, 0x0007ee0b, 
   331| 	0x00001e0b, 0x00003e0b, 0x00005e0b, 0x00007e0b, 
   332| 	0x00009e0b, 0x0000be0b, 0x0000de0b, 0x0000fe0b, 
   333| 	0x00011e0b, 0x00013e0b, 0x00015e0b, 0x00017e0b, 
   334| 	0x00019e0b, 0x0001be0b, 0x0001de0b, 0x0001fe0b, 
   335| 	0x00021e0b, 0x00023e0b, 0x00025e0b, 0x00027e0b, 
   336| 	0x00029e0b, 0x0002be0b, 0x0002de0b, 0x0002fe0b, 
   337| 	0x00031e0b, 0x00033e0b, 0x00035e0b, 0x00037e0b, 
   338| 	0x00039e0b, 0x0003be0b, 0x0003de0b, 0x0003fe0b, 
   339| 	0x00041e0b, 0x00043e0b, 0x00045e0b, 0x00047e0b, 
   340| 	0x00049e0b, 0x0004be0b, 0x0004de0b, 0x0004fe0b, 
   341| 	0x00051e0b, 0x00053e0b, 0x00055e0b, 0x00057e0b, 
   342| 	0x00059e0b, 0x0005be0b, 0x0005de0b, 0x0005fe0b, 
   343| 	0x00061e0b, 0x00063e0b, 0x00065e0b, 0x00067e0b, 
   344| 	0x00069e0b, 0x0006be0b, 0x0006de0b, 0x0006fe0b, 
   345| 	0x00071e0b, 0x00073e0b, 0x00075e0b, 0x00077e0b, 
   346| 	0x00079e0b, 0x0007be0b, 0x0007de0b, 0x0007fe0b, 
   347| 	0x0000010c, 0x0000210c, 0x0000410c, 0x0000610c, 
   348| 	0x0000810c, 0x0000a10c, 0x0000c10c, 0x0000e10c, 
   349| 	0x0001010c, 0x0001210c, 0x0001410c, 0x0001610c, 
   350| 	0x0001810c, 0x0001a10c, 0x0001c10c, 0x0001e10c, 
   351| 	0x0002010c, 0x0002210c, 0x0002410c, 0x0002610c, 
   352| 	0x0002810c, 0x0002a10c, 0x0002c10c, 0x0002e10c, 
   353| 	0x0003010c, 0x0003210c, 0x0003410c, 0x0003610c, 
   354| 	0x0003810c, 0x0003a10c, 0x0003c10c, 0x0003e10c, 
   355| 	0x0004010c, 0x0004210c, 0x0004410c, 0x0004610c, 
   356| 	0x0004810c, 0x0004a10c, 0x0004c10c, 0x0004e10c, 
   357| 	0x0005010c, 0x0005210c, 0x0005410c, 0x0005610c, 
   358| 	0x0005810c, 0x0005a10c, 0x0005c10c, 0x0005e10c, 
   359| 	0x0006010c, 0x0006210c, 0x0006410c, 0x0006610c, 
   360| 	0x0006810c, 0x0006a10c, 0x0006c10c, 0x0006e10c, 
   361| 	0x0007010c, 0x0007210c, 0x0007410c, 0x0007610c, 
   362| 	0x0007810c, 0x0007a10c, 0x0007c10c, 0x0007e10c, 
   363| 	0x0008010c, 0x0008210c, 0x0008410c, 0x0008610c, 
   364| 	0x0008810c, 0x0008a10c, 0x0008c10c, 0x0008e10c, 
   365| 	0x0009010c, 0x0009210c, 0x0009410c, 0x0009610c, 
   366| 	0x0009810c, 0x0009a10c, 0x0009c10c, 0x0009e10c, 
   367| 	0x000a010c, 0x000a210c, 0x000a410c, 0x000a610c, 
   368| 	0x000a810c, 0x000aa10c, 0x000ac10c, 0x000ae10c, 
   369| 	0x000b010c, 0x000b210c, 0x000b410c, 0x000b610c, 
   370| 	0x000b810c, 0x000ba10c, 0x000bc10c, 0x000be10c, 
   371| 	0x000c010c, 0x000c210c, 0x000c410c, 0x000c610c, 
   372| 	0x000c810c, 0x000ca10c, 0x000cc10c, 0x000ce10c, 
   373| 	0x000d010c, 0x000d210c, 0x000d410c, 0x000d610c, 
   374| 	0x000d810c, 0x000da10c, 0x000dc10c, 0x000de10c, 
   375| 	0x000e010c, 0x000e210c, 0x000e410c, 0x000e610c, 
   376| 	0x000e810c, 0x000ea10c, 0x000ec10c, 0x000ee10c, 
   377| 	0x000f010c, 0x000f210c, 0x000f410c, 0x000f610c, 
   378| 	0x000f810c, 0x000fa10c, 0x000fc10c, 0x000fe10c, 
   379| 	0x0000110c, 0x0000310c, 0x0000510c, 0x0000710c, 
   380| 	0x0000910c, 0x0000b10c, 0x0000d10c, 0x0000f10c, 
   381| 	0x0001110c, 0x0001310c, 0x0001510c, 0x0001710c, 
   382| 	0x0001910c, 0x0001b10c, 0x0001d10c, 0x0001f10c, 
   383| 	0x0002110c, 0x0002310c, 0x0002510c, 0x0002710c, 
   384| 	0x0002910c, 0x0002b10c, 0x0002d10c, 0x0002f10c, 
   385| 	0x0003110c, 0x0003310c, 0x0003510c, 0x0003710c, 
   386| 	0x0003910c, 0x0003b10c, 0x0003d10c, 0x0003f10c, 
   387| 	0x0004110c, 0x0004310c, 0x0004510c, 0x0004710c, 
   388| 	0x0004910c, 0x0004b10c, 0x0004d10c, 0x0004f10c, 
   389| 	0x0005110c, 0x0005310c, 0x0005510c, 0x0005710c, 
   390| 	0x0005910c, 0x0005b10c, 0x0005d10c, 0x0005f10c, 
   391| 	0x0006110c, 0x0006310c, 0x0006510c, 0x0006710c, 
   392| 	0x0006910c, 0x0006b10c, 0x0006d10c, 0x0006f10c, 
   393| 	0x0007110c, 0x0007310c, 0x0007510c, 0x0007710c, 
   394| 	0x0007910c, 0x0007b10c, 0x0007d10c, 0x0007f10c, 
   395| 	0x0008110c, 0x0008310c, 0x0008510c, 0x0008710c, 
   396| 	0x0008910c, 0x0008b10c, 0x0008d10c, 0x0008f10c, 
   397| 	0x0009110c, 0x0009310c, 0x0009510c, 0x0009710c, 
   398| 	0x0009910c, 0x0009b10c, 0x0009d10c, 0x0009f10c, 
   399| 	0x000a110c, 0x000a310c, 0x000a510c, 0x000a710c, 
   400| 	0x000a910c, 0x000ab10c, 0x000ad10c, 0x000af10c, 
   401| 	0x000b110c, 0x000b310c, 0x000b510c, 0x000b710c, 
   402| 	0x000b910c, 0x000bb10c, 0x000bd10c, 0x000bf10c, 
   403| 	0x000c110c, 0x000c310c, 0x000c510c, 0x000c710c, 
   404| 	0x000c910c, 0x000cb10c, 0x000cd10c, 0x000cf10c, 
   405| 	0x000d110c, 0x000d310c, 0x000d510c, 0x000d710c, 
   406| 	0x000d910c, 0x000db10c, 0x000dd10c, 0x000df10c, 
   407| 	0x000e110c, 0x000e310c, 0x000e510c, 0x000e710c, 
   408| 	0x000e910c, 0x000eb10c, 0x000ed10c, 0x000ef10c, 
   409| 	0x000f110c, 0x000f310c, 0x000f510c, 0x000f710c, 
   410| 	0x000f910c, 0x000fb10c, 0x000fd10c, 0x000ff10c, 
   411| 	0x0000090d, 0x0000290d, 0x0000490d, 0x0000690d, 
   412| 	0x0000890d, 0x0000a90d, 0x0000c90d, 0x0000e90d, 
   413| 	0x0001090d, 0x0001290d, 0x0001490d, 0x0001690d, 
   414| 	0x0001890d, 0x0001a90d, 0x0001c90d, 0x0001e90d, 
   415| 	0x0002090d, 0x0002290d, 0x0002490d, 0x0002690d, 
   416| 	0x0002890d, 0x0002a90d, 0x0002c90d, 0x0002e90d, 
   417| 	0x0003090d, 0x0003290d, 0x0003490d, 0x0003690d, 
   418| 	0x0003890d, 0x0003a90d, 0x0003c90d, 0x0003e90d, 
   419| 	0x0004090d, 0x0004290d, 0x0004490d, 0x0004690d, 
   420| 	0x0004890d, 0x0004a90d, 0x0004c90d, 0x0004e90d, 
   421| 	0x0005090d, 0x0005290d, 0x0005490d, 0x0005690d, 
   422| 	0x0005890d, 0x0005a90d, 0x0005c90d, 0x0005e90d, 
   423| 	0x0006090d, 0x0006290d, 0x0006490d, 0x0006690d, 
   424| 	0x0006890d, 0x0006a90d, 0x0006c90d, 0x0006e90d, 
   425| 	0x0007090d, 0x0007290d, 0x0007490d, 0x0007690d, 
   426| 	0x0007890d, 0x0007a90d, 0x0007c90d, 0x0007e90d, 
   427| 	0x0008090d, 0x0008290d, 0x0008490d, 0x0008690d, 
   428| 	0x0008890d, 0x0008a90d, 0x0008c90d, 0x0008e90d, 
   429| 	0x0009090d, 0x0009290d, 0x0009490d, 0x0009690d, 
   430| 	0x0009890d, 0x0009a90d, 0x0009c90d, 0x0009e90d, 
   431| 	0x000a090d, 0x000a290d, 0x000a490d, 0x000a690d, 
   432| 	0x000a890d, 0x000aa90d, 0x000ac90d, 0x000ae90d, 
   433| 	0x000b090d, 0x000b290d, 0x000b490d, 0x000b690d, 
   434| 	0x000b890d, 0x000ba90d, 0x000bc90d, 0x000be90d, 
   435| 	0x000c090d, 0x000c290d, 0x000c490d, 0x000c690d, 
   436| 	0x000c890d, 0x000ca90d, 0x000cc90d, 0x000ce90d, 
   437| 	0x000d090d, 0x000d290d, 0x000d490d, 0x000d690d, 
   438| 	0x000d890d, 0x000da90d, 0x000dc90d, 0x000de90d, 
   439| 	0x000e090d, 0x000e290d, 0x000e490d, 0x000e690d, 
   440| 	0x000e890d, 0x000ea90d, 0x000ec90d, 0x000ee90d, 
   441| 	0x000f090d, 0x000f290d, 0x000f490d, 0x000f690d, 
   442| 	0x000f890d, 0x000fa90d, 0x000fc90d, 0x000fe90d, 
   443| 	0x0010090d, 0x0010290d, 0x0010490d, 0x0010690d, 
   444| 	0x0010890d, 0x0010a90d, 0x0010c90d, 0x0010e90d, 
   445| 	0x0011090d, 0x0011290d, 0x0011490d, 0x0011690d, 
   446| 	0x0011890d, 0x0011a90d, 0x0011c90d, 0x0011e90d, 
   447| 	0x0012090d, 0x0012290d, 0x0012490d, 0x0012690d, 
   448| 	0x0012890d, 0x0012a90d, 0x0012c90d, 0x0012e90d, 
   449| 	0x0013090d, 0x0013290d, 0x0013490d, 0x0013690d, 
   450| 	0x0013890d, 0x0013a90d, 0x0013c90d, 0x0013e90d, 
   451| 	0x0014090d, 0x0014290d, 0x0014490d, 0x0014690d, 
   452| 	0x0014890d, 0x0014a90d, 0x0014c90d, 0x0014e90d, 
   453| 	0x0015090d, 0x0015290d, 0x0015490d, 0x0015690d, 
   454| 	0x0015890d, 0x0015a90d, 0x0015c90d, 0x0015e90d, 
   455| 	0x0016090d, 0x0016290d, 0x0016490d, 0x0016690d, 
   456| 	0x0016890d, 0x0016a90d, 0x0016c90d, 0x0016e90d, 
   457| 	0x0017090d, 0x0017290d, 0x0017490d, 0x0017690d, 
   458| 	0x0017890d, 0x0017a90d, 0x0017c90d, 0x0017e90d, 
   459| 	0x0018090d, 0x0018290d, 0x0018490d, 0x0018690d, 
   460| 	0x0018890d, 0x0018a90d, 0x0018c90d, 0x0018e90d, 
   461| 	0x0019090d, 0x0019290d, 0x0019490d, 0x0019690d, 
   462| 	0x0019890d, 0x0019a90d, 0x0019c90d, 0x0019e90d, 
   463| 	0x001a090d, 0x001a290d, 0x001a490d, 0x001a690d, 
   464| 	0x001a890d, 0x001aa90d, 0x001ac90d, 0x001ae90d, 
   465| 	0x001b090d, 0x001b290d, 0x001b490d, 0x001b690d, 
   466| 	0x001b890d, 0x001ba90d, 0x001bc90d, 0x001be90d, 
   467| 	0x001c090d, 0x001c290d, 0x001c490d, 0x001c690d, 
   468| 	0x001c890d, 0x001ca90d, 0x001cc90d, 0x001ce90d, 
   469| 	0x001d090d, 0x001d290d, 0x001d490d, 0x001d690d, 
   470| 	0x001d890d, 0x001da90d, 0x001dc90d, 0x001de90d, 
   471| 	0x001e090d, 0x001e290d, 0x001e490d, 0x001e690d, 
   472| 	0x001e890d, 0x001ea90d, 0x001ec90d, 0x001ee90d, 
   473| 	0x001f090d, 0x001f290d, 0x001f490d, 0x001f690d, 
   474| 	0x001f890d, 0x001fa90d, 0x001fc90d, 0x001fe90d, 
   475| 	0x0000190d, 0x0000390d, 0x0000590d, 0x0000790d, 
   476| 	0x0000990d, 0x0000b90d, 0x0000d90d, 0x0000f90d, 
   477| 	0x0001190d, 0x0001390d, 0x0001590d, 0x0001790d, 
   478| 	0x0001990d, 0x0001b90d, 0x0001d90d, 0x0001f90d, 
   479| 	0x0002190d, 0x0002390d, 0x0002590d, 0x0002790d, 
   480| 	0x0002990d, 0x0002b90d, 0x0002d90d, 0x0002f90d, 
   481| 	0x0003190d, 0x0003390d, 0x0003590d, 0x0003790d, 
   482| 	0x0003990d, 0x0003b90d, 0x0003d90d, 0x0003f90d, 
   483| 	0x0004190d, 0x0004390d, 0x0004590d, 0x0004790d, 
   484| 	0x0004990d, 0x0004b90d, 0x0004d90d, 0x0004f90d, 
   485| 	0x0005190d, 0x0005390d, 0x0005590d, 0x0005790d, 
   486| 	0x0005990d, 0x0005b90d, 0x0005d90d, 0x0005f90d, 
   487| 	0x0006190d, 0x0006390d, 0x0006590d, 0x0006790d, 
   488| 	0x0006990d, 0x0006b90d, 0x0006d90d, 0x0006f90d, 
   489| 	0x0007190d, 0x0007390d, 0x0007590d, 0x0007790d, 
   490| 	0x0007990d, 0x0007b90d, 0x0007d90d, 0x0007f90d, 
   491| 	0x0008190d, 0x0008390d, 0x0008590d, 0x0008790d, 
   492| 	0x0008990d, 0x0008b90d, 0x0008d90d, 0x0008f90d, 
   493| 	0x0009190d, 0x0009390d, 0x0009590d, 0x0009790d, 
   494| 	0x0009990d, 0x0009b90d, 0x0009d90d, 0x0009f90d, 
   495| 	0x000a190d, 0x000a390d, 0x000a590d, 0x000a790d, 
   496| 	0x000a990d, 0x000ab90d, 0x000ad90d, 0x000af90d, 
   497| 	0x000b190d, 0x000b390d, 0x000b590d, 0x000b790d, 
   498| 	0x000b990d, 0x000bb90d, 0x000bd90d, 0x000bf90d, 
   499| 	0x000c190d, 0x000c390d, 0x000c590d, 0x000c790d, 
   500| 	0x000c990d, 0x000cb90d, 0x000cd90d, 0x000cf90d, 
   501| 	0x000d190d, 0x000d390d, 0x000d590d, 0x000d790d, 
   502| 	0x000d990d, 0x000db90d, 0x000dd90d, 0x000df90d, 
   503| 	0x000e190d, 0x000e390d, 0x000e590d, 0x000e790d, 
   504| 	0x000e990d, 0x000eb90d, 0x000ed90d, 0x000ef90d, 
   505| 	0x000f190d, 0x000f390d, 0x000f590d, 0x000f790d, 
   506| 	0x000f990d, 0x000fb90d, 0x000fd90d, 0x000ff90d, 
   507| 	0x0010190d, 0x0010390d, 0x0010590d, 0x0010790d, 
   508| 	0x0010990d, 0x0010b90d, 0x0010d90d, 0x0010f90d, 
   509| 	0x0011190d, 0x0011390d, 0x0011590d, 0x0011790d, 
   510| 	0x0011990d, 0x0011b90d, 0x0011d90d, 0x0011f90d, 
   511| 	0x0012190d, 0x0012390d, 0x0012590d, 0x0012790d, 
   512| 	0x0012990d, 0x0012b90d, 0x0012d90d, 0x0012f90d, 
   513| 	0x0013190d, 0x0013390d, 0x0013590d, 0x0013790d, 
   514| 	0x0013990d, 0x0013b90d, 0x0013d90d, 0x0013f90d, 
   515| 	0x0014190d, 0x0014390d, 0x0014590d, 0x0014790d, 
   516| 	0x0014990d, 0x0014b90d, 0x0014d90d, 0x0014f90d, 
   517| 	0x0015190d, 0x0015390d, 0x0015590d, 0x0015790d, 
   518| 	0x0015990d, 0x0015b90d, 0x0015d90d, 0x0015f90d, 
   519| 	0x0016190d, 0x0016390d, 0x0016590d, 0x0016790d, 
   520| 	0x0016990d, 0x0016b90d, 0x0016d90d, 0x0016f90d, 
   521| 	0x0017190d, 0x0017390d, 0x0017590d, 0x0017790d, 
   522| 	0x0017990d, 0x0017b90d, 0x0017d90d, 0x0017f90d, 
   523| 	0x0018190d, 0x0018390d, 0x0018590d, 0x0018790d, 
   524| 	0x0018990d, 0x0018b90d, 0x0018d90d, 0x0018f90d, 
   525| 	0x0019190d, 0x0019390d, 0x0019590d, 0x0019790d, 
   526| 	0x0019990d, 0x0019b90d, 0x0019d90d, 0x0019f90d, 
   527| 	0x001a190d, 0x001a390d, 0x001a590d, 0x001a790d, 
   528| 	0x001a990d, 0x001ab90d, 0x001ad90d, 0x001af90d, 
   529| 	0x001b190d, 0x001b390d, 0x001b590d, 0x001b790d, 
   530| 	0x001b990d, 0x001bb90d, 0x001bd90d, 0x001bf90d, 
   531| 	0x001c190d, 0x001c390d, 0x001c590d, 0x001c790d, 
   532| 	0x001c990d, 0x001cb90d, 0x001cd90d, 0x001cf90d, 
   533| 	0x001d190d, 0x001d390d, 0x001d590d, 0x001d790d, 
   534| 	0x001d990d, 0x001db90d, 0x001dd90d, 0x001df90d, 
   535| 	0x001e190d, 0x001e390d, 0x001e590d, 0x001e790d, 
   536| 	0x001e990d, 0x001eb90d, 0x001ed90d, 0x001ef90d, 
   537| 	0x001f190d, 0x001f390d, 0x001f590d, 0x001f790d, 
   538| 	0x001f990d, 0x001fb90d, 0x001fd90d, 0x001ff90d, 
   539| 	0x0000050e, 0x0000250e, 0x0000450e, 0x0000650e, 
   540| 	0x0000850e, 0x0000a50e, 0x0000c50e, 0x0000e50e, 
   541| 	0x0001050e, 0x0001250e, 0x0001450e, 0x0001650e, 
   542| 	0x0001850e, 0x0001a50e, 0x0001c50e, 0x0001e50e, 
   543| 	0x0002050e, 0x0002250e, 0x0002450e, 0x0002650e, 
   544| 	0x0002850e, 0x0002a50e, 0x0002c50e, 0x0002e50e, 
   545| 	0x0003050e, 0x0003250e, 0x0003450e, 0x0003650e, 
   546| 	0x0003850e, 0x0003a50e, 0x0003c50e, 0x0003e50e, 
   547| 	0x0004050e, 0x0004250e, 0x0004450e, 0x0004650e, 
   548| 	0x0004850e, 0x0004a50e, 0x0004c50e, 0x0004e50e, 
   549| 	0x0005050e, 0x0005250e, 0x0005450e, 0x0005650e, 
   550| 	0x0005850e, 0x0005a50e, 0x0005c50e, 0x0005e50e, 
   551| 	0x0006050e, 0x0006250e, 0x0006450e, 0x0006650e, 
   552| 	0x0006850e, 0x0006a50e, 0x0006c50e, 0x0006e50e, 
   553| 	0x0007050e, 0x0007250e, 0x0007450e, 0x0007650e, 
   554| 	0x0007850e, 0x0007a50e, 0x0007c50e, 0x0007e50e, 
   555| 	0x0008050e, 0x0008250e, 0x0008450e, 0x0008650e, 
   556| 	0x0008850e, 0x0008a50e, 0x0008c50e, 0x0008e50e, 
   557| 	0x0009050e, 0x0009250e, 0x0009450e, 0x0009650e, 
   558| 	0x0009850e, 0x0009a50e, 0x0009c50e, 0x0009e50e, 
   559| 	0x000a050e, 0x000a250e, 0x000a450e, 0x000a650e, 
   560| 	0x000a850e, 0x000aa50e, 0x000ac50e, 0x000ae50e, 
   561| 	0x000b050e, 0x000b250e, 0x000b450e, 0x000b650e, 
   562| 	0x000b850e, 0x000ba50e, 0x000bc50e, 0x000be50e, 
   563| 	0x000c050e, 0x000c250e, 0x000c450e, 0x000c650e, 
   564| 	0x000c850e, 0x000ca50e, 0x000cc50e, 0x000ce50e, 
   565| 	0x000d050e, 0x000d250e, 0x000d450e, 0x000d650e, 
   566| 	0x000d850e, 0x000da50e, 0x000dc50e, 0x000de50e, 
   567| 	0x000e050e, 0x000e250e, 0x000e450e, 0x000e650e, 
   568| 	0x000e850e, 0x000ea50e, 0x000ec50e, 0x000ee50e, 
   569| 	0x000f050e, 0x000f250e, 0x000f450e, 0x000f650e, 
   570| 	0x000f850e, 0x000fa50e, 0x000fc50e, 0x000fe50e, 
   571| 	0x0010050e, 0x0010250e, 0x0010450e, 0x0010650e, 
   572| 	0x0010850e, 0x0010a50e, 0x0010c50e, 0x0010e50e, 
   573| 	0x0011050e, 0x0011250e, 0x0011450e, 0x0011650e, 
   574| 	0x0011850e, 0x0011a50e, 0x0011c50e, 0x0011e50e, 
   575| 	0x0012050e, 0x0012250e, 0x0012450e, 0x0012650e, 
   576| 	0x0012850e, 0x0012a50e, 0x0012c50e, 0x0012e50e, 
   577| 	0x0013050e, 0x0013250e, 0x0013450e, 0x0013650e, 
   578| 	0x0013850e, 0x0013a50e, 0x0013c50e, 0x0013e50e, 
   579| 	0x0014050e, 0x0014250e, 0x0014450e, 0x0014650e, 
   580| 	0x0014850e, 0x0014a50e, 0x0014c50e, 0x0014e50e, 
   581| 	0x0015050e, 0x0015250e, 0x0015450e, 0x0015650e, 
   582| 	0x0015850e, 0x0015a50e, 0x0015c50e, 0x0015e50e, 
   583| 	0x0016050e, 0x0016250e, 0x0016450e, 0x0016650e, 
   584| 	0x0016850e, 0x0016a50e, 0x0016c50e, 0x0016e50e, 
   585| 	0x0017050e, 0x0017250e, 0x0017450e, 0x0017650e, 
   586| 	0x0017850e, 0x0017a50e, 0x0017c50e, 0x0017e50e, 
   587| 	0x0018050e, 0x0018250e, 0x0018450e, 0x0018650e, 
   588| 	0x0018850e, 0x0018a50e, 0x0018c50e, 0x0018e50e, 
   589| 	0x0019050e, 0x0019250e, 0x0019450e, 0x0019650e, 
   590| 	0x0019850e, 0x0019a50e, 0x0019c50e, 0x0019e50e, 
   591| 	0x001a050e, 0x001a250e, 0x001a450e, 0x001a650e, 
   592| 	0x001a850e, 0x001aa50e, 0x001ac50e, 0x001ae50e, 
   593| 	0x001b050e, 0x001b250e, 0x001b450e, 0x001b650e, 
   594| 	0x001b850e, 0x001ba50e, 0x001bc50e, 0x001be50e, 
   595| 	0x001c050e, 0x001c250e, 0x001c450e, 0x001c650e, 
   596| 	0x001c850e, 0x001ca50e, 0x001cc50e, 0x001ce50e, 
   597| 	0x001d050e, 0x001d250e, 0x001d450e, 0x001d650e, 
   598| 	0x001d850e, 0x001da50e, 0x001dc50e, 0x001de50e, 
   599| 	0x001e050e, 0x001e250e, 0x001e450e, 0x001e650e, 
   600| 	0x001e850e, 0x001ea50e, 0x001ec50e, 0x001ee50e, 
   601| 	0x001f050e, 0x001f250e, 0x001f450e, 0x001f650e, 
   602| 	0x001f850e, 0x001fa50e, 0x001fc50e, 0x001fe50e, 
   603| 	0x0020050e, 0x0020250e, 0x0020450e, 0x0020650e, 
   604| 	0x0020850e, 0x0020a50e, 0x0020c50e, 0x0020e50e, 
   605| 	0x0021050e, 0x0021250e, 0x0021450e, 0x0021650e, 
   606| 	0x0021850e, 0x0021a50e, 0x0021c50e, 0x0021e50e, 
   607| 	0x0022050e, 0x0022250e, 0x0022450e, 0x0022650e, 
   608| 	0x0022850e, 0x0022a50e, 0x0022c50e, 0x0022e50e, 
   609| 	0x0023050e, 0x0023250e, 0x0023450e, 0x0023650e, 
   610| 	0x0023850e, 0x0023a50e, 0x0023c50e, 0x0023e50e, 
   611| 	0x0024050e, 0x0024250e, 0x0024450e, 0x0024650e, 
   612| 	0x0024850e, 0x0024a50e, 0x0024c50e, 0x0024e50e, 
   613| 	0x0025050e, 0x0025250e, 0x0025450e, 0x0025650e, 
   614| 	0x0025850e, 0x0025a50e, 0x0025c50e, 0x0025e50e, 
   615| 	0x0026050e, 0x0026250e, 0x0026450e, 0x0026650e, 
   616| 	0x0026850e, 0x0026a50e, 0x0026c50e, 0x0026e50e, 
   617| 	0x0027050e, 0x0027250e, 0x0027450e, 0x0027650e, 
   618| 	0x0027850e, 0x0027a50e, 0x0027c50e, 0x0027e50e, 
   619| 	0x0028050e, 0x0028250e, 0x0028450e, 0x0028650e, 
   620| 	0x0028850e, 0x0028a50e, 0x0028c50e, 0x0028e50e, 
   621| 	0x0029050e, 0x0029250e, 0x0029450e, 0x0029650e, 
   622| 	0x0029850e, 0x0029a50e, 0x0029c50e, 0x0029e50e, 
   623| 	0x002a050e, 0x002a250e, 0x002a450e, 0x002a650e, 
   624| 	0x002a850e, 0x002aa50e, 0x002ac50e, 0x002ae50e, 
   625| 	0x002b050e, 0x002b250e, 0x002b450e, 0x002b650e, 
   626| 	0x002b850e, 0x002ba50e, 0x002bc50e, 0x002be50e, 
   627| 	0x002c050e, 0x002c250e, 0x002c450e, 0x002c650e, 
   628| 	0x002c850e, 0x002ca50e, 0x002cc50e, 0x002ce50e, 
   629| 	0x002d050e, 0x002d250e, 0x002d450e, 0x002d650e, 
   630| 	0x002d850e, 0x002da50e, 0x002dc50e, 0x002de50e, 
   631| 	0x002e050e, 0x002e250e, 0x002e450e, 0x002e650e, 
   632| 	0x002e850e, 0x002ea50e, 0x002ec50e, 0x002ee50e, 
   633| 	0x002f050e, 0x002f250e, 0x002f450e, 0x002f650e, 
   634| 	0x002f850e, 0x002fa50e, 0x002fc50e, 0x002fe50e, 
   635| 	0x0030050e, 0x0030250e, 0x0030450e, 0x0030650e, 
   636| 	0x0030850e, 0x0030a50e, 0x0030c50e, 0x0030e50e, 
   637| 	0x0031050e, 0x0031250e, 0x0031450e, 0x0031650e, 
   638| 	0x0031850e, 0x0031a50e, 0x0031c50e, 0x0031e50e, 
   639| 	0x0032050e, 0x0032250e, 0x0032450e, 0x0032650e, 
   640| 	0x0032850e, 0x0032a50e, 0x0032c50e, 0x0032e50e, 
   641| 	0x0033050e, 0x0033250e, 0x0033450e, 0x0033650e, 
   642| 	0x0033850e, 0x0033a50e, 0x0033c50e, 0x0033e50e, 
   643| 	0x0034050e, 0x0034250e, 0x0034450e, 0x0034650e, 
   644| 	0x0034850e, 0x0034a50e, 0x0034c50e, 0x0034e50e, 
   645| 	0x0035050e, 0x0035250e, 0x0035450e, 0x0035650e, 
   646| 	0x0035850e, 0x0035a50e, 0x0035c50e, 0x0035e50e, 
   647| 	0x0036050e, 0x0036250e, 0x0036450e, 0x0036650e, 
   648| 	0x0036850e, 0x0036a50e, 0x0036c50e, 0x0036e50e, 
   649| 	0x0037050e, 0x0037250e, 0x0037450e, 0x0037650e, 
   650| 	0x0037850e, 0x0037a50e, 0x0037c50e, 0x0037e50e, 
   651| 	0x0038050e, 0x0038250e, 0x0038450e, 0x0038650e, 
   652| 	0x0038850e, 0x0038a50e, 0x0038c50e, 0x0038e50e, 
   653| 	0x0039050e, 0x0039250e, 0x0039450e, 0x0039650e, 
   654| 	0x0039850e, 0x0039a50e, 0x0039c50e, 0x0039e50e, 
   655| 	0x003a050e, 0x003a250e, 0x003a450e, 0x003a650e, 
   656| 	0x003a850e, 0x003aa50e, 0x003ac50e, 0x003ae50e, 
   657| 	0x003b050e, 0x003b250e, 0x003b450e, 0x003b650e, 
   658| 	0x003b850e, 0x003ba50e, 0x003bc50e, 0x003be50e, 
   659| 	0x003c050e, 0x003c250e, 0x003c450e, 0x003c650e, 
   660| 	0x003c850e, 0x003ca50e, 0x003cc50e, 0x003ce50e, 
   661| 	0x003d050e, 0x003d250e, 0x003d450e, 0x003d650e, 
   662| 	0x003d850e, 0x003da50e, 0x003dc50e, 0x003de50e, 
   663| 	0x003e050e, 0x003e250e, 0x003e450e, 0x003e650e, 
   664| 	0x003e850e, 0x003ea50e, 0x003ec50e, 0x003ee50e, 
   665| 	0x003f050e, 0x003f250e, 0x003f450e, 0x003f650e, 
   666| 	0x003f850e, 0x003fa50e, 0x003fc50e, 0x003fe50e, 
   667| 	0x0000150e, 0x0000350e, 0x0000550e, 0x0000750e, 
   668| 	0x0000950e, 0x0000b50e, 0x0000d50e, 0x0000f50e, 
   669| 	0x0001150e, 0x0001350e, 0x0001550e, 0x0001750e, 
   670| 	0x0001950e, 0x0001b50e, 0x0001d50e, 0x0001f50e, 
   671| 	0x0002150e, 0x0002350e, 0x0002550e, 0x0002750e, 
   672| 	0x0002950e, 0x0002b50e, 0x0002d50e, 0x0002f50e, 
   673| 	0x0003150e, 0x0003350e, 0x0003550e, 0x0003750e, 
   674| 	0x0003950e, 0x0003b50e, 0x0003d50e, 0x0003f50e, 
   675| 	0x0004150e, 0x0004350e, 0x0004550e, 0x0004750e, 
   676| 	0x0004950e, 0x0004b50e, 0x0004d50e, 0x0004f50e, 
   677| 	0x0005150e, 0x0005350e, 0x0005550e, 0x0005750e, 
   678| 	0x0005950e, 0x0005b50e, 0x0005d50e, 0x0005f50e, 
   679| 	0x0006150e, 0x0006350e, 0x0006550e, 0x0006750e, 
   680| 	0x0006950e, 0x0006b50e, 0x0006d50e, 0x0006f50e, 
   681| 	0x0007150e, 0x0007350e, 0x0007550e, 0x0007750e, 
   682| 	0x0007950e, 0x0007b50e, 0x0007d50e, 0x0007f50e, 
   683| 	0x0008150e, 0x0008350e, 0x0008550e, 0x0008750e, 
   684| 	0x0008950e, 0x0008b50e, 0x0008d50e, 0x0008f50e, 
   685| 	0x0009150e, 0x0009350e, 0x0009550e, 0x0009750e, 
   686| 	0x0009950e, 0x0009b50e, 0x0009d50e, 0x0009f50e, 
   687| 	0x000a150e, 0x000a350e, 0x000a550e, 0x000a750e, 
   688| 	0x000a950e, 0x000ab50e, 0x000ad50e, 0x000af50e, 
   689| 	0x000b150e, 0x000b350e, 0x000b550e, 0x000b750e, 
   690| 	0x000b950e, 0x000bb50e, 0x000bd50e, 0x000bf50e, 
   691| 	0x000c150e, 0x000c350e, 0x000c550e, 0x000c750e, 
   692| 	0x000c950e, 0x000cb50e, 0x000cd50e, 0x000cf50e, 
   693| 	0x000d150e, 0x000d350e, 0x000d550e, 0x000d750e, 
   694| 	0x000d950e, 0x000db50e, 0x000dd50e, 0x000df50e, 
   695| 	0x000e150e, 0x000e350e, 0x000e550e, 0x000e750e, 
   696| 	0x000e950e, 0x000eb50e, 0x000ed50e, 0x000ef50e, 
   697| 	0x000f150e, 0x000f350e, 0x000f550e, 0x000f750e, 
   698| 	0x000f950e, 0x000fb50e, 0x000fd50e, 0x000ff50e, 
   699| 	0x0010150e, 0x0010350e, 0x0010550e, 0x0010750e, 
   700| 	0x0010950e, 0x0010b50e, 0x0010d50e, 0x0010f50e, 
   701| 	0x0011150e, 0x0011350e, 0x0011550e, 0x0011750e, 
   702| 	0x0011950e, 0x0011b50e, 0x0011d50e, 0x0011f50e, 
   703| 	0x0012150e, 0x0012350e, 0x0012550e, 0x0012750e, 
   704| 	0x0012950e, 0x0012b50e, 0x0012d50e, 0x0012f50e, 
   705| 	0x0013150e, 0x0013350e, 0x0013550e, 0x0013750e, 
   706| 	0x0013950e, 0x0013b50e, 0x0013d50e, 0x0013f50e, 
   707| 	0x0014150e, 0x0014350e, 0x0014550e, 0x0014750e, 
   708| 	0x0014950e, 0x0014b50e, 0x0014d50e, 0x0014f50e, 
   709| 	0x0015150e, 0x0015350e, 0x0015550e, 0x0015750e, 
   710| 	0x0015950e, 0x0015b50e, 0x0015d50e, 0x0015f50e, 
   711| 	0x0016150e, 0x0016350e, 0x0016550e, 0x0016750e, 
   712| 	0x0016950e, 0x0016b50e, 0x0016d50e, 0x0016f50e, 
   713| 	0x0017150e, 0x0017350e, 0x0017550e, 0x0017750e, 
   714| 	0x0017950e, 0x0017b50e, 0x0017d50e, 0x0017f50e, 
   715| 	0x0018150e, 0x0018350e, 0x0018550e, 0x0018750e, 
   716| 	0x0018950e, 0x0018b50e, 0x0018d50e, 0x0018f50e, 
   717| 	0x0019150e, 0x0019350e, 0x0019550e, 0x0019750e, 
   718| 	0x0019950e, 0x0019b50e, 0x0019d50e, 0x0019f50e, 
   719| 	0x001a150e, 0x001a350e, 0x001a550e, 0x001a750e, 
   720| 	0x001a950e, 0x001ab50e, 0x001ad50e, 0x001af50e, 
   721| 	0x001b150e, 0x001b350e, 0x001b550e, 0x001b750e, 
   722| 	0x001b950e, 0x001bb50e, 0x001bd50e, 0x001bf50e, 
   723| 	0x001c150e, 0x001c350e, 0x001c550e, 0x001c750e, 
   724| 	0x001c950e, 0x001cb50e, 0x001cd50e, 0x001cf50e, 
   725| 	0x001d150e, 0x001d350e, 0x001d550e, 0x001d750e, 
   726| 	0x001d950e, 0x001db50e, 0x001dd50e, 0x001df50e, 
   727| 	0x001e150e, 0x001e350e, 0x001e550e, 0x001e750e, 
   728| 	0x001e950e, 0x001eb50e, 0x001ed50e, 0x001ef50e, 
   729| 	0x001f150e, 0x001f350e, 0x001f550e, 0x001f750e, 
   730| 	0x001f950e, 0x001fb50e, 0x001fd50e, 0x001ff50e, 
   731| 	0x0020150e, 0x0020350e, 0x0020550e, 0x0020750e, 
   732| 	0x0020950e, 0x0020b50e, 0x0020d50e, 0x0020f50e, 
   733| 	0x0021150e, 0x0021350e, 0x0021550e, 0x0021750e, 
   734| 	0x0021950e, 0x0021b50e, 0x0021d50e, 0x0021f50e, 
   735| 	0x0022150e, 0x0022350e, 0x0022550e, 0x0022750e, 
   736| 	0x0022950e, 0x0022b50e, 0x0022d50e, 0x0022f50e, 
   737| 	0x0023150e, 0x0023350e, 0x0023550e, 0x0023750e, 
   738| 	0x0023950e, 0x0023b50e, 0x0023d50e, 0x0023f50e, 
   739| 	0x0024150e, 0x0024350e, 0x0024550e, 0x0024750e, 
   740| 	0x0024950e, 0x0024b50e, 0x0024d50e, 0x0024f50e, 
   741| 	0x0025150e, 0x0025350e, 0x0025550e, 0x0025750e, 
   742| 	0x0025950e, 0x0025b50e, 0x0025d50e, 0x0025f50e, 
   743| 	0x0026150e, 0x0026350e, 0x0026550e, 0x0026750e, 
   744| 	0x0026950e, 0x0026b50e, 0x0026d50e, 0x0026f50e, 
   745| 	0x0027150e, 0x0027350e, 0x0027550e, 0x0027750e, 
   746| 	0x0027950e, 0x0027b50e, 0x0027d50e, 0x0027f50e, 
   747| 	0x0028150e, 0x0028350e, 0x0028550e, 0x0028750e, 
   748| 	0x0028950e, 0x0028b50e, 0x0028d50e, 0x0028f50e, 
   749| 	0x0029150e, 0x0029350e, 0x0029550e, 0x0029750e, 
   750| 	0x0029950e, 0x0029b50e, 0x0029d50e, 0x0029f50e, 
   751| 	0x002a150e, 0x002a350e, 0x002a550e, 0x002a750e, 
   752| 	0x002a950e, 0x002ab50e, 0x002ad50e, 0x002af50e, 
   753| 	0x002b150e, 0x002b350e, 0x002b550e, 0x002b750e, 
   754| 	0x002b950e, 0x002bb50e, 0x002bd50e, 0x002bf50e, 
   755| 	0x002c150e, 0x002c350e, 0x002c550e, 0x002c750e, 
   756| 	0x002c950e, 0x002cb50e, 0x002cd50e, 0x002cf50e, 
   757| 	0x002d150e, 0x002d350e, 0x002d550e, 0x002d750e, 
   758| 	0x002d950e, 0x002db50e, 0x002dd50e, 0x002df50e, 
   759| 	0x002e150e, 0x002e350e, 0x002e550e, 0x002e750e, 
   760| 	0x002e950e, 0x002eb50e, 0x002ed50e, 0x002ef50e, 
   761| 	0x002f150e, 0x002f350e, 0x002f550e, 0x002f750e, 
   762| 	0x002f950e, 0x002fb50e, 0x002fd50e, 0x002ff50e, 
   763| 	0x0030150e, 0x0030350e, 0x0030550e, 0x0030750e, 
   764| 	0x0030950e, 0x0030b50e, 0x0030d50e, 0x0030f50e, 
   765| 	0x0031150e, 0x0031350e, 0x0031550e, 0x0031750e, 
   766| 	0x0031950e, 0x0031b50e, 0x0031d50e, 0x0031f50e, 
   767| 	0x0032150e, 0x0032350e, 0x0032550e, 0x0032750e, 
   768| 	0x0032950e, 0x0032b50e, 0x0032d50e, 0x0032f50e, 
   769| 	0x0033150e, 0x0033350e, 0x0033550e, 0x0033750e, 
   770| 	0x0033950e, 0x0033b50e, 0x0033d50e, 0x0033f50e, 
   771| 	0x0034150e, 0x0034350e, 0x0034550e, 0x0034750e, 
   772| 	0x0034950e, 0x0034b50e, 0x0034d50e, 0x0034f50e, 
   773| 	0x0035150e, 0x0035350e, 0x0035550e, 0x0035750e, 
   774| 	0x0035950e, 0x0035b50e, 0x0035d50e, 0x0035f50e, 
   775| 	0x0036150e, 0x0036350e, 0x0036550e, 0x0036750e, 
   776| 	0x0036950e, 0x0036b50e, 0x0036d50e, 0x0036f50e, 
   777| 	0x0037150e, 0x0037350e, 0x0037550e, 0x0037750e, 
   778| 	0x0037950e, 0x0037b50e, 0x0037d50e, 0x0037f50e, 
   779| 	0x0038150e, 0x0038350e, 0x0038550e, 0x0038750e, 
   780| 	0x0038950e, 0x0038b50e, 0x0038d50e, 0x0038f50e, 
   781| 	0x0039150e, 0x0039350e, 0x0039550e, 0x0039750e, 
   782| 	0x0039950e, 0x0039b50e, 0x0039d50e, 0x0039f50e, 
   783| 	0x003a150e, 0x003a350e, 0x003a550e, 0x003a750e, 
   784| 	0x003a950e, 0x003ab50e, 0x003ad50e, 0x003af50e, 
   785| 	0x003b150e, 0x003b350e, 0x003b550e, 0x003b750e, 
   786| 	0x003b950e, 0x003bb50e, 0x003bd50e, 0x003bf50e, 
   787| 	0x003c150e, 0x003c350e, 0x003c550e, 0x003c750e, 
   788| 	0x003c950e, 0x003cb50e, 0x003cd50e, 0x003cf50e, 
   789| 	0x003d150e, 0x003d350e, 0x003d550e, 0x003d750e, 
   790| 	0x003d950e, 0x003db50e, 0x003dd50e, 0x003df50e, 
   791| 	0x003e150e, 0x003e350e, 0x003e550e, 0x003e750e, 
   792| 	0x003e950e, 0x003eb50e, 0x003ed50e, 0x003ef50e, 
   793| 	0x003f150e, 0x003f350e, 0x003f550e, 0x003f750e, 
   794| 	0x003f950e, 0x003fb50e, 0x003fd50e, 0x003ff50e, 
   795| 	0x00000d0f, 0x00002d0f, 0x00004d0f, 0x00006d0f, 
   796| 	0x00008d0f, 0x0000ad0f, 0x0000cd0f, 0x0000ed0f, 
   797| 	0x00010d0f, 0x00012d0f, 0x00014d0f, 0x00016d0f, 
   798| 	0x00018d0f, 0x0001ad0f, 0x0001cd0f, 0x0001ed0f, 
   799| 	0x00020d0f, 0x00022d0f, 0x00024d0f, 0x00026d0f, 
   800| 	0x00028d0f, 0x0002ad0f, 0x0002cd0f, 0x0002ed0f, 
   801| 	0x00030d0f, 0x00032d0f, 0x00034d0f, 0x00036d0f, 
   802| 	0x00038d0f, 0x0003ad0f, 0x0003cd0f, 0x0003ed0f, 
   803| 	0x00040d0f, 0x00042d0f, 0x00044d0f, 0x00046d0f, 
   804| 	0x00048d0f, 0x0004ad0f, 0x0004cd0f, 0x0004ed0f, 
   805| 	0x00050d0f, 0x00052d0f, 0x00054d0f, 0x00056d0f, 
   806| 	0x00058d0f, 0x0005ad0f, 0x0005cd0f, 0x0005ed0f, 
   807| 	0x00060d0f, 0x00062d0f, 0x00064d0f, 0x00066d0f, 
   808| 	0x00068d0f, 0x0006ad0f, 0x0006cd0f, 0x0006ed0f, 
   809| 	0x00070d0f, 0x00072d0f, 0x00074d0f, 0x00076d0f, 
   810| 	0x00078d0f, 0x0007ad0f, 0x0007cd0f, 0x0007ed0f, 
   811| 	0x00080d0f, 0x00082d0f, 0x00084d0f, 0x00086d0f, 
   812| 	0x00088d0f, 0x0008ad0f, 0x0008cd0f, 0x0008ed0f, 
   813| 	0x00090d0f, 0x00092d0f, 0x00094d0f, 0x00096d0f, 
   814| 	0x00098d0f, 0x0009ad0f, 0x0009cd0f, 0x0009ed0f, 
   815| 	0x000a0d0f, 0x000a2d0f, 0x000a4d0f, 0x000a6d0f, 
   816| 	0x000a8d0f, 0x000aad0f, 0x000acd0f, 0x000aed0f, 
   817| 	0x000b0d0f, 0x000b2d0f, 0x000b4d0f, 0x000b6d0f, 
   818| 	0x000b8d0f, 0x000bad0f, 0x000bcd0f, 0x000bed0f, 
   819| 	0x000c0d0f, 0x000c2d0f, 0x000c4d0f, 0x000c6d0f, 
   820| 	0x000c8d0f, 0x000cad0f, 0x000ccd0f, 0x000ced0f, 
   821| 	0x000d0d0f, 0x000d2d0f, 0x000d4d0f, 0x000d6d0f, 
   822| 	0x000d8d0f, 0x000dad0f, 0x000dcd0f, 0x000ded0f, 
   823| 	0x000e0d0f, 0x000e2d0f, 0x000e4d0f, 0x000e6d0f, 
   824| 	0x000e8d0f, 0x000ead0f, 0x000ecd0f, 0x000eed0f, 
   825| 	0x000f0d0f, 0x000f2d0f, 0x000f4d0f, 0x000f6d0f, 
   826| 	0x000f8d0f, 0x000fad0f, 0x000fcd0f, 0x000fed0f, 
   827| 	0x00100d0f, 0x00102d0f, 0x00104d0f, 0x00106d0f, 
   828| 	0x00108d0f, 0x0010ad0f, 0x0010cd0f, 0x0010ed0f, 
   829| 	0x00110d0f, 0x00112d0f, 0x00114d0f, 0x00116d0f, 
   830| 	0x00118d0f, 0x0011ad0f, 0x0011cd0f, 0x0011ed0f, 
   831| 	0x00120d0f, 0x00122d0f, 0x00124d0f, 0x00126d0f, 
   832| 	0x00128d0f, 0x0012ad0f, 0x0012cd0f, 0x0012ed0f, 
   833| 	0x00130d0f, 0x00132d0f, 0x00134d0f, 0x00136d0f, 
   834| 	0x00138d0f, 0x0013ad0f, 0x0013cd0f, 0x0013ed0f, 
   835| 	0x00140d0f, 0x00142d0f, 0x00144d0f, 0x00146d0f, 
   836| 	0x00148d0f, 0x0014ad0f, 0x0014cd0f, 0x0014ed0f, 
   837| 	0x00150d0f, 0x00152d0f, 0x00154d0f, 0x00156d0f, 
   838| 	0x00158d0f, 0x0015ad0f, 0x0015cd0f, 0x0015ed0f, 
   839| 	0x00160d0f, 0x00162d0f, 0x00164d0f, 0x00166d0f, 
   840| 	0x00168d0f, 0x0016ad0f, 0x0016cd0f, 0x0016ed0f, 
   841| 	0x00170d0f, 0x00172d0f, 0x00174d0f, 0x00176d0f, 
   842| 	0x00178d0f, 0x0017ad0f, 0x0017cd0f, 0x0017ed0f, 
   843| 	0x00180d0f, 0x00182d0f, 0x00184d0f, 0x00186d0f, 
   844| 	0x00188d0f, 0x0018ad0f, 0x0018cd0f, 0x0018ed0f, 
   845| 	0x00190d0f, 0x00192d0f, 0x00194d0f, 0x00196d0f, 
   846| 	0x00198d0f, 0x0019ad0f, 0x0019cd0f, 0x0019ed0f, 
   847| 	0x001a0d0f, 0x001a2d0f, 0x001a4d0f, 0x001a6d0f, 
   848| 	0x001a8d0f, 0x001aad0f, 0x001acd0f, 0x001aed0f, 
   849| 	0x001b0d0f, 0x001b2d0f, 0x001b4d0f, 0x001b6d0f, 
   850| 	0x001b8d0f, 0x001bad0f, 0x001bcd0f, 0x001bed0f, 
   851| 	0x001c0d0f, 0x001c2d0f, 0x001c4d0f, 0x001c6d0f, 
   852| 	0x001c8d0f, 0x001cad0f, 0x001ccd0f, 0x001ced0f, 
   853| 	0x001d0d0f, 0x001d2d0f, 0x001d4d0f, 0x001d6d0f, 
   854| 	0x001d8d0f, 0x001dad0f, 0x001dcd0f, 0x001ded0f, 
   855| 	0x001e0d0f, 0x001e2d0f, 0x001e4d0f, 0x001e6d0f, 
   856| 	0x001e8d0f, 0x001ead0f, 0x001ecd0f, 0x001eed0f, 
   857| 	0x001f0d0f, 0x001f2d0f, 0x001f4d0f, 0x001f6d0f, 
   858| 	0x001f8d0f, 0x001fad0f, 0x001fcd0f, 0x001fed0f, 
   859| 	0x00200d0f, 0x00202d0f, 0x00204d0f, 0x00206d0f, 
   860| 	0x00208d0f, 0x0020ad0f, 0x0020cd0f, 0x0020ed0f, 
   861| 	0x00210d0f, 0x00212d0f, 0x00214d0f, 0x00216d0f, 
   862| 	0x00218d0f, 0x0021ad0f, 0x0021cd0f, 0x0021ed0f, 
   863| 	0x00220d0f, 0x00222d0f, 0x00224d0f, 0x00226d0f, 
   864| 	0x00228d0f, 0x0022ad0f, 0x0022cd0f, 0x0022ed0f, 
   865| 	0x00230d0f, 0x00232d0f, 0x00234d0f, 0x00236d0f, 
   866| 	0x00238d0f, 0x0023ad0f, 0x0023cd0f, 0x0023ed0f, 
   867| 	0x00240d0f, 0x00242d0f, 0x00244d0f, 0x00246d0f, 
   868| 	0x00248d0f, 0x0024ad0f, 0x0024cd0f, 0x0024ed0f, 
   869| 	0x00250d0f, 0x00252d0f, 0x00254d0f, 0x00256d0f, 
   870| 	0x00258d0f, 0x0025ad0f, 0x0025cd0f, 0x0025ed0f, 
   871| 	0x00260d0f, 0x00262d0f, 0x00264d0f, 0x00266d0f, 
   872| 	0x00268d0f, 0x0026ad0f, 0x0026cd0f, 0x0026ed0f, 
   873| 	0x00270d0f, 0x00272d0f, 0x00274d0f, 0x00276d0f, 
   874| 	0x00278d0f, 0x0027ad0f, 0x0027cd0f, 0x0027ed0f, 
   875| 	0x00280d0f, 0x00282d0f, 0x00284d0f, 0x00286d0f, 
   876| 	0x00288d0f, 0x0028ad0f, 0x0028cd0f, 0x0028ed0f, 
   877| 	0x00290d0f, 0x00292d0f, 0x00294d0f, 0x00296d0f, 
   878| 	0x00298d0f, 0x0029ad0f, 0x0029cd0f, 0x0029ed0f, 
   879| 	0x002a0d0f, 0x002a2d0f, 0x002a4d0f, 0x002a6d0f, 
   880| 	0x002a8d0f, 0x002aad0f, 0x002acd0f, 0x002aed0f, 
   881| 	0x002b0d0f, 0x002b2d0f, 0x002b4d0f, 0x002b6d0f, 
   882| 	0x002b8d0f, 0x002bad0f, 0x002bcd0f, 0x002bed0f, 
   883| 	0x002c0d0f, 0x002c2d0f, 0x002c4d0f, 0x002c6d0f, 
   884| 	0x002c8d0f, 0x002cad0f, 0x002ccd0f, 0x002ced0f, 
   885| 	0x002d0d0f, 0x002d2d0f, 0x002d4d0f, 0x002d6d0f, 
   886| 	0x002d8d0f, 0x002dad0f, 0x002dcd0f, 0x002ded0f, 
   887| 	0x002e0d0f, 0x002e2d0f, 0x002e4d0f, 0x002e6d0f, 
   888| 	0x002e8d0f, 0x002ead0f, 0x002ecd0f, 0x002eed0f, 
   889| 	0x002f0d0f, 0x002f2d0f, 0x002f4d0f, 0x002f6d0f, 
   890| 	0x002f8d0f, 0x002fad0f, 0x002fcd0f, 0x002fed0f, 
   891| 	0x00300d0f, 0x00302d0f, 0x00304d0f, 0x00306d0f, 
   892| 	0x00308d0f, 0x0030ad0f, 0x0030cd0f, 0x0030ed0f, 
   893| 	0x00310d0f, 0x00312d0f, 0x00314d0f, 0x00316d0f, 
   894| 	0x00318d0f, 0x0031ad0f, 0x0031cd0f, 0x0031ed0f, 
   895| 	0x00320d0f, 0x00322d0f, 0x00324d0f, 0x00326d0f, 
   896| 	0x00328d0f, 0x0032ad0f, 0x0032cd0f, 0x0032ed0f, 
   897| 	0x00330d0f, 0x00332d0f, 0x00334d0f, 0x00336d0f, 
   898| 	0x00338d0f, 0x0033ad0f, 0x0033cd0f, 0x0033ed0f, 
   899| 	0x00340d0f, 0x00342d0f, 0x00344d0f, 0x00346d0f, 
   900| 	0x00348d0f, 0x0034ad0f, 0x0034cd0f, 0x0034ed0f, 
   901| 	0x00350d0f, 0x00352d0f, 0x00354d0f, 0x00356d0f, 
   902| 	0x00358d0f, 0x0035ad0f, 0x0035cd0f, 0x0035ed0f, 
   903| 	0x00360d0f, 0x00362d0f, 0x00364d0f, 0x00366d0f, 
   904| 	0x00368d0f, 0x0036ad0f, 0x0036cd0f, 0x0036ed0f, 
   905| 	0x00370d0f, 0x00372d0f, 0x00374d0f, 0x00376d0f, 
   906| 	0x00378d0f, 0x0037ad0f, 0x0037cd0f, 0x0037ed0f, 
   907| 	0x00380d0f, 0x00382d0f, 0x00384d0f, 0x00386d0f, 
   908| 	0x00388d0f, 0x0038ad0f, 0x0038cd0f, 0x0038ed0f, 
   909| 	0x00390d0f, 0x00392d0f, 0x00394d0f, 0x00396d0f, 
   910| 	0x00398d0f, 0x0039ad0f, 0x0039cd0f, 0x0039ed0f, 
   911| 	0x003a0d0f, 0x003a2d0f, 0x003a4d0f, 0x003a6d0f, 
   912| 	0x003a8d0f, 0x003aad0f, 0x003acd0f, 0x003aed0f, 
   913| 	0x003b0d0f, 0x003b2d0f, 0x003b4d0f, 0x003b6d0f, 
   914| 	0x003b8d0f, 0x003bad0f, 0x003bcd0f, 0x003bed0f, 
   915| 	0x003c0d0f, 0x003c2d0f, 0x003c4d0f, 0x003c6d0f, 
   916| 	0x003c8d0f, 0x003cad0f, 0x003ccd0f, 0x003ced0f, 
   917| 	0x003d0d0f, 0x003d2d0f, 0x003d4d0f, 0x003d6d0f, 
   918| 	0x003d8d0f, 0x003dad0f, 0x003dcd0f, 0x003ded0f, 
   919| 	0x003e0d0f, 0x003e2d0f, 0x003e4d0f, 0x003e6d0f, 
   920| 	0x003e8d0f, 0x003ead0f, 0x003ecd0f, 0x003eed0f, 
   921| 	0x003f0d0f, 0x003f2d0f, 0x003f4d0f, 0x003f6d0f, 
   922| 	0x003f8d0f, 0x003fad0f, 0x003fcd0f, 0x003fed0f, 
   923| 	0x00400d0f, 0x00402d0f, 0x00404d0f, 0x00406d0f, 
   924| 	0x00408d0f, 0x0040ad0f, 0x0040cd0f, 0x0040ed0f, 
   925| 	0x00410d0f, 0x00412d0f, 0x00414d0f, 0x00416d0f, 
   926| 	0x00418d0f, 0x0041ad0f, 0x0041cd0f, 0x0041ed0f, 
   927| 	0x00420d0f, 0x00422d0f, 0x00424d0f, 0x00426d0f, 
   928| 	0x00428d0f, 0x0042ad0f, 0x0042cd0f, 0x0042ed0f, 
   929| 	0x00430d0f, 0x00432d0f, 0x00434d0f, 0x00436d0f, 
   930| 	0x00438d0f, 0x0043ad0f, 0x0043cd0f, 0x0043ed0f, 
   931| 	0x00440d0f, 0x00442d0f, 0x00444d0f, 0x00446d0f, 
   932| 	0x00448d0f, 0x0044ad0f, 0x0044cd0f, 0x0044ed0f, 
   933| 	0x00450d0f, 0x00452d0f, 0x00454d0f, 0x00456d0f, 
   934| 	0x00458d0f, 0x0045ad0f, 0x0045cd0f, 0x0045ed0f, 
   935| 	0x00460d0f, 0x00462d0f, 0x00464d0f, 0x00466d0f, 
   936| 	0x00468d0f, 0x0046ad0f, 0x0046cd0f, 0x0046ed0f, 
   937| 	0x00470d0f, 0x00472d0f, 0x00474d0f, 0x00476d0f, 
   938| 	0x00478d0f, 0x0047ad0f, 0x0047cd0f, 0x0047ed0f, 
   939| 	0x00480d0f, 0x00482d0f, 0x00484d0f, 0x00486d0f, 
   940| 	0x00488d0f, 0x0048ad0f, 0x0048cd0f, 0x0048ed0f, 
   941| 	0x00490d0f, 0x00492d0f, 0x00494d0f, 0x00496d0f, 
   942| 	0x00498d0f, 0x0049ad0f, 0x0049cd0f, 0x0049ed0f, 
   943| 	0x004a0d0f, 0x004a2d0f, 0x004a4d0f, 0x004a6d0f, 
   944| 	0x004a8d0f, 0x004aad0f, 0x004acd0f, 0x004aed0f, 
   945| 	0x004b0d0f, 0x004b2d0f, 0x004b4d0f, 0x004b6d0f, 
   946| 	0x004b8d0f, 0x004bad0f, 0x004bcd0f, 0x004bed0f, 
   947| 	0x004c0d0f, 0x004c2d0f, 0x004c4d0f, 0x004c6d0f, 
   948| 	0x004c8d0f, 0x004cad0f, 0x004ccd0f, 0x004ced0f, 
   949| 	0x004d0d0f, 0x004d2d0f, 0x004d4d0f, 0x004d6d0f, 
   950| 	0x004d8d0f, 0x004dad0f, 0x004dcd0f, 0x004ded0f, 
   951| 	0x004e0d0f, 0x004e2d0f, 0x004e4d0f, 0x004e6d0f, 
   952| 	0x004e8d0f, 0x004ead0f, 0x004ecd0f, 0x004eed0f, 
   953| 	0x004f0d0f, 0x004f2d0f, 0x004f4d0f, 0x004f6d0f, 
   954| 	0x004f8d0f, 0x004fad0f, 0x004fcd0f, 0x004fed0f, 
   955| 	0x00500d0f, 0x00502d0f, 0x00504d0f, 0x00506d0f, 
   956| 	0x00508d0f, 0x0050ad0f, 0x0050cd0f, 0x0050ed0f, 
   957| 	0x00510d0f, 0x00512d0f, 0x00514d0f, 0x00516d0f, 
   958| 	0x00518d0f, 0x0051ad0f, 0x0051cd0f, 0x0051ed0f, 
   959| 	0x00520d0f, 0x00522d0f, 0x00524d0f, 0x00526d0f, 
   960| 	0x00528d0f, 0x0052ad0f, 0x0052cd0f, 0x0052ed0f, 
   961| 	0x00530d0f, 0x00532d0f, 0x00534d0f, 0x00536d0f, 
   962| 	0x00538d0f, 0x0053ad0f, 0x0053cd0f, 0x0053ed0f, 
   963| 	0x00540d0f, 0x00542d0f, 0x00544d0f, 0x00546d0f, 
   964| 	0x00548d0f, 0x0054ad0f, 0x0054cd0f, 0x0054ed0f, 
   965| 	0x00550d0f, 0x00552d0f, 0x00554d0f, 0x00556d0f, 
   966| 	0x00558d0f, 0x0055ad0f, 0x0055cd0f, 0x0055ed0f, 
   967| 	0x00560d0f, 0x00562d0f, 0x00564d0f, 0x00566d0f, 
   968| 	0x00568d0f, 0x0056ad0f, 0x0056cd0f, 0x0056ed0f, 
   969| 	0x00570d0f, 0x00572d0f, 0x00574d0f, 0x00576d0f, 
   970| 	0x00578d0f, 0x0057ad0f, 0x0057cd0f, 0x0057ed0f, 
   971| 	0x00580d0f, 0x00582d0f, 0x00584d0f, 0x00586d0f, 
   972| 	0x00588d0f, 0x0058ad0f, 0x0058cd0f, 0x0058ed0f, 
   973| 	0x00590d0f, 0x00592d0f, 0x00594d0f, 0x00596d0f, 
   974| 	0x00598d0f, 0x0059ad0f, 0x0059cd0f, 0x0059ed0f, 
   975| 	0x005a0d0f, 0x005a2d0f, 0x005a4d0f, 0x005a6d0f, 
   976| 	0x005a8d0f, 0x005aad0f, 0x005acd0f, 0x005aed0f, 
   977| 	0x005b0d0f, 0x005b2d0f, 0x005b4d0f, 0x005b6d0f, 
   978| 	0x005b8d0f, 0x005bad0f, 0x005bcd0f, 0x005bed0f, 
   979| 	0x005c0d0f, 0x005c2d0f, 0x005c4d0f, 0x005c6d0f, 
   980| 	0x005c8d0f, 0x005cad0f, 0x005ccd0f, 0x005ced0f, 
   981| 	0x005d0d0f, 0x005d2d0f, 0x005d4d0f, 0x005d6d0f, 
   982| 	0x005d8d0f, 0x005dad0f, 0x005dcd0f, 0x005ded0f, 
   983| 	0x005e0d0f, 0x005e2d0f, 0x005e4d0f, 0x005e6d0f, 
   984| 	0x005e8d0f, 0x005ead0f, 0x005ecd0f, 0x005eed0f, 
   985| 	0x005f0d0f, 0x005f2d0f, 0x005f4d0f, 0x005f6d0f, 
   986| 	0x005f8d0f, 0x005fad0f, 0x005fcd0f, 0x005fed0f, 
   987| 	0x00600d0f, 0x00602d0f, 0x00604d0f, 0x00606d0f, 
   988| 	0x00608d0f, 0x0060ad0f, 0x0060cd0f, 0x0060ed0f, 
   989| 	0x00610d0f, 0x00612d0f, 0x00614d0f, 0x00616d0f, 
   990| 	0x00618d0f, 0x0061ad0f, 0x0061cd0f, 0x0061ed0f, 
   991| 	0x00620d0f, 0x00622d0f, 0x00624d0f, 0x00626d0f, 
   992| 	0x00628d0f, 0x0062ad0f, 0x0062cd0f, 0x0062ed0f, 
   993| 	0x00630d0f, 0x00632d0f, 0x00634d0f, 0x00636d0f, 
   994| 	0x00638d0f, 0x0063ad0f, 0x0063cd0f, 0x0063ed0f, 
   995| 	0x00640d0f, 0x00642d0f, 0x00644d0f, 0x00646d0f, 
   996| 	0x00648d0f, 0x0064ad0f, 0x0064cd0f, 0x0064ed0f, 
   997| 	0x00650d0f, 0x00652d0f, 0x00654d0f, 0x00656d0f, 
   998| 	0x00658d0f, 0x0065ad0f, 0x0065cd0f, 0x0065ed0f, 
   999| 	0x00660d0f, 0x00662d0f, 0x00664d0f, 0x00666d0f, 
  1000| 	0x00668d0f, 0x0066ad0f, 0x0066cd0f, 0x0066ed0f, 
  1001| 	0x00670d0f, 0x00672d0f, 0x00674d0f, 0x00676d0f, 
  1002| 	0x00678d0f, 0x0067ad0f, 0x0067cd0f, 0x0067ed0f, 
  1003| 	0x00680d0f, 0x00682d0f, 0x00684d0f, 0x00686d0f, 
  1004| 	0x00688d0f, 0x0068ad0f, 0x0068cd0f, 0x0068ed0f, 
  1005| 	0x00690d0f, 0x00692d0f, 0x00694d0f, 0x00696d0f, 
  1006| 	0x00698d0f, 0x0069ad0f, 0x0069cd0f, 0x0069ed0f, 
  1007| 	0x006a0d0f, 0x006a2d0f, 0x006a4d0f, 0x006a6d0f, 
  1008| 	0x006a8d0f, 0x006aad0f, 0x006acd0f, 0x006aed0f, 
  1009| 	0x006b0d0f, 0x006b2d0f, 0x006b4d0f, 0x006b6d0f, 
  1010| 	0x006b8d0f, 0x006bad0f, 0x006bcd0f, 0x006bed0f, 
  1011| 	0x006c0d0f, 0x006c2d0f, 0x006c4d0f, 0x006c6d0f, 
  1012| 	0x006c8d0f, 0x006cad0f, 0x006ccd0f, 0x006ced0f, 
  1013| 	0x006d0d0f, 0x006d2d0f, 0x006d4d0f, 0x006d6d0f, 
  1014| 	0x006d8d0f, 0x006dad0f, 0x006dcd0f, 0x006ded0f, 
  1015| 	0x006e0d0f, 0x006e2d0f, 0x006e4d0f, 0x006e6d0f, 
  1016| 	0x006e8d0f, 0x006ead0f, 0x006ecd0f, 0x006eed0f, 
  1017| 	0x006f0d0f, 0x006f2d0f, 0x006f4d0f, 0x006f6d0f, 
  1018| 	0x006f8d0f, 0x006fad0f, 0x006fcd0f, 0x006fed0f, 
  1019| 	0x00700d0f, 0x00702d0f, 0x00704d0f, 0x00706d0f, 
  1020| 	0x00708d0f, 0x0070ad0f, 0x0070cd0f, 0x0070ed0f, 
  1021| 	0x00710d0f, 0x00712d0f, 0x00714d0f, 0x00716d0f, 
  1022| 	0x00718d0f, 0x0071ad0f, 0x0071cd0f, 0x0071ed0f, 
  1023| 	0x00720d0f, 0x00722d0f, 0x00724d0f, 0x00726d0f, 
  1024| 	0x00728d0f, 0x0072ad0f, 0x0072cd0f, 0x0072ed0f, 
  1025| 	0x00730d0f, 0x00732d0f, 0x00734d0f, 0x00736d0f, 
  1026| 	0x00738d0f, 0x0073ad0f, 0x0073cd0f, 0x0073ed0f, 
  1027| 	0x00740d0f, 0x00742d0f, 0x00744d0f, 0x00746d0f, 
  1028| 	0x00748d0f, 0x0074ad0f, 0x0074cd0f, 0x0074ed0f, 
  1029| 	0x00750d0f, 0x00752d0f, 0x00754d0f, 0x00756d0f, 
  1030| 	0x00758d0f, 0x0075ad0f, 0x0075cd0f, 0x0075ed0f, 
  1031| 	0x00760d0f, 0x00762d0f, 0x00764d0f, 0x00766d0f, 
  1032| 	0x00768d0f, 0x0076ad0f, 0x0076cd0f, 0x0076ed0f, 
  1033| 	0x00770d0f, 0x00772d0f, 0x00774d0f, 0x00776d0f, 
  1034| 	0x00778d0f, 0x0077ad0f, 0x0077cd0f, 0x0077ed0f, 
  1035| 	0x00780d0f, 0x00782d0f, 0x00784d0f, 0x00786d0f, 
  1036| 	0x00788d0f, 0x0078ad0f, 0x0078cd0f, 0x0078ed0f, 
  1037| 	0x00790d0f, 0x00792d0f, 0x00794d0f, 0x00796d0f, 
  1038| 	0x00798d0f, 0x0079ad0f, 0x0079cd0f, 0x0079ed0f, 
  1039| 	0x007a0d0f, 0x007a2d0f, 0x007a4d0f, 0x007a6d0f, 
  1040| 	0x007a8d0f, 0x007aad0f, 0x007acd0f, 0x007aed0f, 
  1041| 	0x007b0d0f, 0x007b2d0f, 0x007b4d0f, 0x007b6d0f, 
  1042| 	0x007b8d0f, 0x007bad0f, 0x007bcd0f, 0x007bed0f, 
  1043| 	0x007c0d0f, 0x007c2d0f, 0x007c4d0f, 0x007c6d0f, 
  1044| 	0x007c8d0f, 0x007cad0f, 0x007ccd0f, 0x007ced0f, 
  1045| 	0x007d0d0f, 0x007d2d0f, 0x007d4d0f, 0x007d6d0f, 
  1046| 	0x007d8d0f, 0x007dad0f, 0x007dcd0f, 0x007ded0f, 
  1047| 	0x007e0d0f, 0x007e2d0f, 0x007e4d0f, 0x007e6d0f, 
  1048| 	0x007e8d0f, 0x007ead0f, 0x007ecd0f, 0x007eed0f, 
  1049| 	0x007f0d0f, 0x007f2d0f, 0x007f4d0f, 0x007f6d0f, 
  1050| 	0x007f8d0f, 0x007fad0f, 0x007fcd0f, 0x007fed0f, 
  1051| 	0x00001d0f, 0x00003d0f, 0x00005d0f, 0x00007d0f, 
  1052| 	0x00009d0f, 0x0000bd0f, 0x0000dd0f, 0x0000fd0f, 
  1053| 	0x00011d0f, 0x00013d0f, 0x00015d0f, 0x00017d0f, 
  1054| 	0x00019d0f, 0x0001bd0f, 0x0001dd0f, 0x0001fd0f, 
  1055| 	0x00021d0f, 0x00023d0f, 0x00025d0f, 0x00027d0f, 
  1056| 	0x00029d0f, 0x0002bd0f, 0x0002dd0f, 0x0002fd0f, 
  1057| 	0x00031d0f, 0x00033d0f, 0x00035d0f, 0x00037d0f, 
  1058| 	0x00039d0f, 0x0003bd0f, 0x0003dd0f, 0x0003fd0f, 
  1059| 	0x00041d0f, 0x00043d0f, 0x00045d0f, 0x00047d0f, 
  1060| 	0x00049d0f, 0x0004bd0f, 0x0004dd0f, 0x0004fd0f, 
  1061| 	0x00051d0f, 0x00053d0f, 0x00055d0f, 0x00057d0f, 
  1062| 	0x00059d0f, 0x0005bd0f, 0x0005dd0f, 0x0005fd0f, 
  1063| 	0x00061d0f, 0x00063d0f, 0x00065d0f, 0x00067d0f, 
  1064| 	0x00069d0f, 0x0006bd0f, 0x0006dd0f, 0x0006fd0f, 
  1065| 	0x00071d0f, 0x00073d0f, 0x00075d0f, 0x00077d0f, 
  1066| 	0x00079d0f, 0x0007bd0f, 0x0007dd0f, 0x0007fd0f, 
  1067| 	0x00081d0f, 0x00083d0f, 0x00085d0f, 0x00087d0f, 
  1068| 	0x00089d0f, 0x0008bd0f, 0x0008dd0f, 0x0008fd0f, 
  1069| 	0x00091d0f, 0x00093d0f, 0x00095d0f, 0x00097d0f, 
  1070| 	0x00099d0f, 0x0009bd0f, 0x0009dd0f, 0x0009fd0f, 
  1071| 	0x000a1d0f, 0x000a3d0f, 0x000a5d0f, 0x000a7d0f, 
  1072| 	0x000a9d0f, 0x000abd0f, 0x000add0f, 0x000afd0f, 
  1073| 	0x000b1d0f, 0x000b3d0f, 0x000b5d0f, 0x000b7d0f, 
  1074| 	0x000b9d0f, 0x000bbd0f, 0x000bdd0f, 0x000bfd0f, 
  1075| 	0x000c1d0f, 0x000c3d0f, 0x000c5d0f, 0x000c7d0f, 
  1076| 	0x000c9d0f, 0x000cbd0f, 0x000cdd0f, 0x000cfd0f, 
  1077| 	0x000d1d0f, 0x000d3d0f, 0x000d5d0f, 0x000d7d0f, 
  1078| 	0x000d9d0f, 0x000dbd0f, 0x000ddd0f, 0x000dfd0f, 
  1079| 	0x000e1d0f, 0x000e3d0f, 0x000e5d0f, 0x000e7d0f, 
  1080| 	0x000e9d0f, 0x000ebd0f, 0x000edd0f, 0x000efd0f, 
  1081| 	0x000f1d0f, 0x000f3d0f, 0x000f5d0f, 0x000f7d0f, 
  1082| 	0x000f9d0f, 0x000fbd0f, 0x000fdd0f, 0x000ffd0f, 
  1083| 	0x00101d0f, 0x00103d0f, 0x00105d0f, 0x00107d0f, 
  1084| 	0x00109d0f, 0x0010bd0f, 0x0010dd0f, 0x0010fd0f, 
  1085| 	0x00111d0f, 0x00113d0f, 0x00115d0f, 0x00117d0f, 
  1086| 	0x00119d0f, 0x0011bd0f, 0x0011dd0f, 0x0011fd0f, 
  1087| 	0x00121d0f, 0x00123d0f, 0x00125d0f, 0x00127d0f, 
  1088| 	0x00129d0f, 0x0012bd0f, 0x0012dd0f, 0x0012fd0f, 
  1089| 	0x00131d0f, 0x00133d0f, 0x00135d0f, 0x00137d0f, 
  1090| 	0x00139d0f, 0x0013bd0f, 0x0013dd0f, 0x0013fd0f, 
  1091| 	0x00141d0f, 0x00143d0f, 0x00145d0f, 0x00147d0f, 
  1092| 	0x00149d0f, 0x0014bd0f, 0x0014dd0f, 0x0014fd0f, 
  1093| 	0x00151d0f, 0x00153d0f, 0x00155d0f, 0x00157d0f, 
  1094| 	0x00159d0f, 0x0015bd0f, 0x0015dd0f, 0x0015fd0f, 
  1095| 	0x00161d0f, 0x00163d0f, 0x00165d0f, 0x00167d0f, 
  1096| 	0x00169d0f, 0x0016bd0f, 0x0016dd0f, 0x0016fd0f, 
  1097| 	0x00171d0f, 0x00173d0f, 0x00175d0f, 0x00177d0f, 
  1098| 	0x00179d0f, 0x0017bd0f, 0x0017dd0f, 0x0017fd0f, 
  1099| 	0x00181d0f, 0x00183d0f, 0x00185d0f, 0x00187d0f, 
  1100| 	0x00189d0f, 0x0018bd0f, 0x0018dd0f, 0x0018fd0f, 
  1101| 	0x00191d0f, 0x00193d0f, 0x00195d0f, 0x00197d0f, 
  1102| 	0x00199d0f, 0x0019bd0f, 0x0019dd0f, 0x0019fd0f, 
  1103| 	0x001a1d0f, 0x001a3d0f, 0x001a5d0f, 0x001a7d0f, 
  1104| 	0x001a9d0f, 0x001abd0f, 0x001add0f, 0x001afd0f, 
  1105| 	0x001b1d0f, 0x001b3d0f, 0x001b5d0f, 0x001b7d0f, 
  1106| 	0x001b9d0f, 0x001bbd0f, 0x001bdd0f, 0x001bfd0f, 
  1107| 	0x001c1d0f, 0x001c3d0f, 0x001c5d0f, 0x001c7d0f, 
  1108| 	0x001c9d0f, 0x001cbd0f, 0x001cdd0f, 0x001cfd0f, 
  1109| 	0x001d1d0f, 0x001d3d0f, 0x001d5d0f, 0x001d7d0f, 
  1110| 	0x001d9d0f, 0x001dbd0f, 0x001ddd0f, 0x001dfd0f, 
  1111| 	0x001e1d0f, 0x001e3d0f, 0x001e5d0f, 0x001e7d0f, 
  1112| 	0x001e9d0f, 0x001ebd0f, 0x001edd0f, 0x001efd0f, 
  1113| 	0x001f1d0f, 0x001f3d0f, 0x001f5d0f, 0x001f7d0f, 
  1114| 	0x001f9d0f, 0x001fbd0f, 0x001fdd0f, 0x001ffd0f, 
  1115| 	0x00201d0f, 0x00203d0f, 0x00205d0f, 0x00207d0f, 
  1116| 	0x00209d0f, 0x0020bd0f, 0x0020dd0f, 0x0020fd0f, 
  1117| 	0x00211d0f, 0x00213d0f, 0x00215d0f, 0x00217d0f, 
  1118| 	0x00219d0f, 0x0021bd0f, 0x0021dd0f, 0x0021fd0f, 
  1119| 	0x00221d0f, 0x00223d0f, 0x00225d0f, 0x00227d0f, 
  1120| 	0x00229d0f, 0x0022bd0f, 0x0022dd0f, 0x0022fd0f, 
  1121| 	0x00231d0f, 0x00233d0f, 0x00235d0f, 0x00237d0f, 
  1122| 	0x00239d0f, 0x0023bd0f, 0x0023dd0f, 0x0023fd0f, 
  1123| 	0x00241d0f, 0x00243d0f, 0x00245d0f, 0x00247d0f, 
  1124| 	0x00249d0f, 0x0024bd0f, 0x0024dd0f, 0x0024fd0f, 
  1125| 	0x00251d0f, 0x00253d0f, 0x00255d0f, 0x00257d0f, 
  1126| 	0x00259d0f, 0x0025bd0f, 0x0025dd0f, 0x0025fd0f, 
  1127| 	0x00261d0f, 0x00263d0f, 0x00265d0f, 0x00267d0f, 
  1128| 	0x00269d0f, 0x0026bd0f, 0x0026dd0f, 0x0026fd0f, 
  1129| 	0x00271d0f, 0x00273d0f, 0x00275d0f, 0x00277d0f, 
  1130| 	0x00279d0f, 0x0027bd0f, 0x0027dd0f, 0x0027fd0f, 
  1131| 	0x00281d0f, 0x00283d0f, 0x00285d0f, 0x00287d0f, 
  1132| 	0x00289d0f, 0x0028bd0f, 0x0028dd0f, 0x0028fd0f, 
  1133| 	0x00291d0f, 0x00293d0f, 0x00295d0f, 0x00297d0f, 
  1134| 	0x00299d0f, 0x0029bd0f, 0x0029dd0f, 0x0029fd0f, 
  1135| 	0x002a1d0f, 0x002a3d0f, 0x002a5d0f, 0x002a7d0f, 
  1136| 	0x002a9d0f, 0x002abd0f, 0x002add0f, 0x002afd0f, 
  1137| 	0x002b1d0f, 0x002b3d0f, 0x002b5d0f, 0x002b7d0f, 
  1138| 	0x002b9d0f, 0x002bbd0f, 0x002bdd0f, 0x002bfd0f, 
  1139| 	0x002c1d0f, 0x002c3d0f, 0x002c5d0f, 0x002c7d0f, 
  1140| 	0x002c9d0f, 0x002cbd0f, 0x002cdd0f, 0x002cfd0f, 
  1141| 	0x002d1d0f, 0x002d3d0f, 0x002d5d0f, 0x002d7d0f, 
  1142| 	0x002d9d0f, 0x002dbd0f, 0x002ddd0f, 0x002dfd0f, 
  1143| 	0x002e1d0f, 0x002e3d0f, 0x002e5d0f, 0x002e7d0f, 
  1144| 	0x002e9d0f, 0x002ebd0f, 0x002edd0f, 0x002efd0f, 
  1145| 	0x002f1d0f, 0x002f3d0f, 0x002f5d0f, 0x002f7d0f, 
  1146| 	0x002f9d0f, 0x002fbd0f, 0x002fdd0f, 0x002ffd0f, 
  1147| 	0x00301d0f, 0x00303d0f, 0x00305d0f, 0x00307d0f, 
  1148| 	0x00309d0f, 0x0030bd0f, 0x0030dd0f, 0x0030fd0f, 
  1149| 	0x00311d0f, 0x00313d0f, 0x00315d0f, 0x00317d0f, 
  1150| 	0x00319d0f, 0x0031bd0f, 0x0031dd0f, 0x0031fd0f, 
  1151| 	0x00321d0f, 0x00323d0f, 0x00325d0f, 0x00327d0f, 
  1152| 	0x00329d0f, 0x0032bd0f, 0x0032dd0f, 0x0032fd0f, 
  1153| 	0x00331d0f, 0x00333d0f, 0x00335d0f, 0x00337d0f, 
  1154| 	0x00339d0f, 0x0033bd0f, 0x0033dd0f, 0x0033fd0f, 
  1155| 	0x00341d0f, 0x00343d0f, 0x00345d0f, 0x00347d0f, 
  1156| 	0x00349d0f, 0x0034bd0f, 0x0034dd0f, 0x0034fd0f, 
  1157| 	0x00351d0f, 0x00353d0f, 0x00355d0f, 0x00357d0f, 
  1158| 	0x00359d0f, 0x0035bd0f, 0x0035dd0f, 0x0035fd0f, 
  1159| 	0x00361d0f, 0x00363d0f, 0x00365d0f, 0x00367d0f, 
  1160| 	0x00369d0f, 0x0036bd0f, 0x0036dd0f, 0x0036fd0f, 
  1161| 	0x00371d0f, 0x00373d0f, 0x00375d0f, 0x00377d0f, 
  1162| 	0x00379d0f, 0x0037bd0f, 0x0037dd0f, 0x0037fd0f, 
  1163| 	0x00381d0f, 0x00383d0f, 0x00385d0f, 0x00387d0f, 
  1164| 	0x00389d0f, 0x0038bd0f, 0x0038dd0f, 0x0038fd0f, 
  1165| 	0x00391d0f, 0x00393d0f, 0x00395d0f, 0x00397d0f, 
  1166| 	0x00399d0f, 0x0039bd0f, 0x0039dd0f, 0x0039fd0f, 
  1167| 	0x003a1d0f, 0x003a3d0f, 0x003a5d0f, 0x003a7d0f, 
  1168| 	0x003a9d0f, 0x003abd0f, 0x003add0f, 0x003afd0f, 
  1169| 	0x003b1d0f, 0x003b3d0f, 0x003b5d0f, 0x003b7d0f, 
  1170| 	0x003b9d0f, 0x003bbd0f, 0x003bdd0f, 0x003bfd0f, 
  1171| 	0x003c1d0f, 0x003c3d0f, 0x003c5d0f, 0x003c7d0f, 
  1172| 	0x003c9d0f, 0x003cbd0f, 0x003cdd0f, 0x003cfd0f, 
  1173| 	0x003d1d0f, 0x003d3d0f, 0x003d5d0f, 0x003d7d0f, 
  1174| 	0x003d9d0f, 0x003dbd0f, 0x003ddd0f, 0x003dfd0f, 
  1175| 	0x003e1d0f, 0x003e3d0f, 0x003e5d0f, 0x003e7d0f, 
  1176| 	0x003e9d0f, 0x003ebd0f, 0x003edd0f, 0x003efd0f, 
  1177| 	0x003f1d0f, 0x003f3d0f, 0x003f5d0f, 0x003f7d0f, 
  1178| 	0x003f9d0f, 0x003fbd0f, 0x003fdd0f, 0x003ffd0f, 
  1179| 	0x00401d0f, 0x00403d0f, 0x00405d0f, 0x00407d0f, 
  1180| 	0x00409d0f, 0x0040bd0f, 0x0040dd0f, 0x0040fd0f, 
  1181| 	0x00411d0f, 0x00413d0f, 0x00415d0f, 0x00417d0f, 
  1182| 	0x00419d0f, 0x0041bd0f, 0x0041dd0f, 0x0041fd0f, 
  1183| 	0x00421d0f, 0x00423d0f, 0x00425d0f, 0x00427d0f, 
  1184| 	0x00429d0f, 0x0042bd0f, 0x0042dd0f, 0x0042fd0f, 
  1185| 	0x00431d0f, 0x00433d0f, 0x00435d0f, 0x00437d0f, 
  1186| 	0x00439d0f, 0x0043bd0f, 0x0043dd0f, 0x0043fd0f, 
  1187| 	0x00441d0f, 0x00443d0f, 0x00445d0f, 0x00447d0f, 
  1188| 	0x00449d0f, 0x0044bd0f, 0x0044dd0f, 0x0044fd0f, 
  1189| 	0x00451d0f, 0x00453d0f, 0x00455d0f, 0x00457d0f, 
  1190| 	0x00459d0f, 0x0045bd0f, 0x0045dd0f, 0x0045fd0f, 
  1191| 	0x00461d0f, 0x00463d0f, 0x00465d0f, 0x00467d0f, 
  1192| 	0x00469d0f, 0x0046bd0f, 0x0046dd0f, 0x0046fd0f, 
  1193| 	0x00471d0f, 0x00473d0f, 0x00475d0f, 0x00477d0f, 
  1194| 	0x00479d0f, 0x0047bd0f, 0x0047dd0f, 0x0047fd0f, 
  1195| 	0x00481d0f, 0x00483d0f, 0x00485d0f, 0x00487d0f, 
  1196| 	0x00489d0f, 0x0048bd0f, 0x0048dd0f, 0x0048fd0f, 
  1197| 	0x00491d0f, 0x00493d0f, 0x00495d0f, 0x00497d0f, 
  1198| 	0x00499d0f, 0x0049bd0f, 0x0049dd0f, 0x0049fd0f, 
  1199| 	0x004a1d0f, 0x004a3d0f, 0x004a5d0f, 0x004a7d0f, 
  1200| 	0x004a9d0f, 0x004abd0f, 0x004add0f, 0x004afd0f, 
  1201| 	0x004b1d0f, 0x004b3d0f, 0x004b5d0f, 0x004b7d0f, 
  1202| 	0x004b9d0f, 0x004bbd0f, 0x004bdd0f, 0x004bfd0f, 
  1203| 	0x004c1d0f, 0x004c3d0f, 0x004c5d0f, 0x004c7d0f, 
  1204| 	0x004c9d0f, 0x004cbd0f, 0x004cdd0f, 0x004cfd0f, 
  1205| 	0x004d1d0f, 0x004d3d0f, 0x004d5d0f, 0x004d7d0f, 
  1206| 	0x004d9d0f, 0x004dbd0f, 0x004ddd0f, 0x004dfd0f, 
  1207| 	0x004e1d0f, 0x004e3d0f, 0x004e5d0f, 0x004e7d0f, 
  1208| 	0x004e9d0f, 0x004ebd0f, 0x004edd0f, 0x004efd0f, 
  1209| 	0x004f1d0f, 0x004f3d0f, 0x004f5d0f, 0x004f7d0f, 
  1210| 	0x004f9d0f, 0x004fbd0f, 0x004fdd0f, 0x004ffd0f, 
  1211| 	0x00501d0f, 0x00503d0f, 0x00505d0f, 0x00507d0f, 
  1212| 	0x00509d0f, 0x0050bd0f, 0x0050dd0f, 0x0050fd0f, 
  1213| 	0x00511d0f, 0x00513d0f, 0x00515d0f, 0x00517d0f, 
  1214| 	0x00519d0f, 0x0051bd0f, 0x0051dd0f, 0x0051fd0f, 
  1215| 	0x00521d0f, 0x00523d0f, 0x00525d0f, 0x00527d0f, 
  1216| 	0x00529d0f, 0x0052bd0f, 0x0052dd0f, 0x0052fd0f, 
  1217| 	0x00531d0f, 0x00533d0f, 0x00535d0f, 0x00537d0f, 
  1218| 	0x00539d0f, 0x0053bd0f, 0x0053dd0f, 0x0053fd0f, 
  1219| 	0x00541d0f, 0x00543d0f, 0x00545d0f, 0x00547d0f, 
  1220| 	0x00549d0f, 0x0054bd0f, 0x0054dd0f, 0x0054fd0f, 
  1221| 	0x00551d0f, 0x00553d0f, 0x00555d0f, 0x00557d0f, 
  1222| 	0x00559d0f, 0x0055bd0f, 0x0055dd0f, 0x0055fd0f, 
  1223| 	0x00561d0f, 0x00563d0f, 0x00565d0f, 0x00567d0f, 
  1224| 	0x00569d0f, 0x0056bd0f, 0x0056dd0f, 0x0056fd0f, 
  1225| 	0x00571d0f, 0x00573d0f, 0x00575d0f, 0x00577d0f, 
  1226| 	0x00579d0f, 0x0057bd0f, 0x0057dd0f, 0x0057fd0f, 
  1227| 	0x00581d0f, 0x00583d0f, 0x00585d0f, 0x00587d0f, 
  1228| 	0x00589d0f, 0x0058bd0f, 0x0058dd0f, 0x0058fd0f, 
  1229| 	0x00591d0f, 0x00593d0f, 0x00595d0f, 0x00597d0f, 
  1230| 	0x00599d0f, 0x0059bd0f, 0x0059dd0f, 0x0059fd0f, 
  1231| 	0x005a1d0f, 0x005a3d0f, 0x005a5d0f, 0x005a7d0f, 
  1232| 	0x005a9d0f, 0x005abd0f, 0x005add0f, 0x005afd0f, 
  1233| 	0x005b1d0f, 0x005b3d0f, 0x005b5d0f, 0x005b7d0f, 
  1234| 	0x005b9d0f, 0x005bbd0f, 0x005bdd0f, 0x005bfd0f, 
  1235| 	0x005c1d0f, 0x005c3d0f, 0x005c5d0f, 0x005c7d0f, 
  1236| 	0x005c9d0f, 0x005cbd0f, 0x005cdd0f, 0x005cfd0f, 
  1237| 	0x005d1d0f, 0x005d3d0f, 0x005d5d0f, 0x005d7d0f, 
  1238| 	0x005d9d0f, 0x005dbd0f, 0x005ddd0f, 0x005dfd0f, 
  1239| 	0x005e1d0f, 0x005e3d0f, 0x005e5d0f, 0x005e7d0f, 
  1240| 	0x005e9d0f, 0x005ebd0f, 0x005edd0f, 0x005efd0f, 
  1241| 	0x005f1d0f, 0x005f3d0f, 0x005f5d0f, 0x005f7d0f, 
  1242| 	0x005f9d0f, 0x005fbd0f, 0x005fdd0f, 0x005ffd0f, 
  1243| 	0x00601d0f, 0x00603d0f, 0x00605d0f, 0x00607d0f, 
  1244| 	0x00609d0f, 0x0060bd0f, 0x0060dd0f, 0x0060fd0f, 
  1245| 	0x00611d0f, 0x00613d0f, 0x00615d0f, 0x00617d0f, 
  1246| 	0x00619d0f, 0x0061bd0f, 0x0061dd0f, 0x0061fd0f, 
  1247| 	0x00621d0f, 0x00623d0f, 0x00625d0f, 0x00627d0f, 
  1248| 	0x00629d0f, 0x0062bd0f, 0x0062dd0f, 0x0062fd0f, 
  1249| 	0x00631d0f, 0x00633d0f, 0x00635d0f, 0x00637d0f, 
  1250| 	0x00639d0f, 0x0063bd0f, 0x0063dd0f, 0x0063fd0f, 
  1251| 	0x00641d0f, 0x00643d0f, 0x00645d0f, 0x00647d0f, 
  1252| 	0x00649d0f, 0x0064bd0f, 0x0064dd0f, 0x0064fd0f, 
  1253| 	0x00651d0f, 0x00653d0f, 0x00655d0f, 0x00657d0f, 
  1254| 	0x00659d0f, 0x0065bd0f, 0x0065dd0f, 0x0065fd0f, 
  1255| 	0x00661d0f, 0x00663d0f, 0x00665d0f, 0x00667d0f, 
  1256| 	0x00669d0f, 0x0066bd0f, 0x0066dd0f, 0x0066fd0f, 
  1257| 	0x00671d0f, 0x00673d0f, 0x00675d0f, 0x00677d0f, 
  1258| 	0x00679d0f, 0x0067bd0f, 0x0067dd0f, 0x0067fd0f, 
  1259| 	0x00681d0f, 0x00683d0f, 0x00685d0f, 0x00687d0f, 
  1260| 	0x00689d0f, 0x0068bd0f, 0x0068dd0f, 0x0068fd0f, 
  1261| 	0x00691d0f, 0x00693d0f, 0x00695d0f, 0x00697d0f, 
  1262| 	0x00699d0f, 0x0069bd0f, 0x0069dd0f, 0x0069fd0f, 
  1263| 	0x006a1d0f, 0x006a3d0f, 0x006a5d0f, 0x006a7d0f, 
  1264| 	0x006a9d0f, 0x006abd0f, 0x006add0f, 0x006afd0f, 
  1265| 	0x006b1d0f, 0x006b3d0f, 0x006b5d0f, 0x006b7d0f, 
  1266| 	0x006b9d0f, 0x006bbd0f, 0x006bdd0f, 0x006bfd0f, 
  1267| 	0x006c1d0f, 0x006c3d0f, 0x006c5d0f, 0x006c7d0f, 
  1268| 	0x006c9d0f, 0x006cbd0f, 0x006cdd0f, 0x006cfd0f, 
  1269| 	0x006d1d0f, 0x006d3d0f, 0x006d5d0f, 0x006d7d0f, 
  1270| 	0x006d9d0f, 0x006dbd0f, 0x006ddd0f, 0x006dfd0f, 
  1271| 	0x006e1d0f, 0x006e3d0f, 0x006e5d0f, 0x006e7d0f, 
  1272| 	0x006e9d0f, 0x006ebd0f, 0x006edd0f, 0x006efd0f, 
  1273| 	0x006f1d0f, 0x006f3d0f, 0x006f5d0f, 0x006f7d0f, 
  1274| 	0x006f9d0f, 0x006fbd0f, 0x006fdd0f, 0x006ffd0f, 
  1275| 	0x00701d0f, 0x00703d0f, 0x00705d0f, 0x00707d0f, 
  1276| 	0x00709d0f, 0x0070bd0f, 0x0070dd0f, 0x0070fd0f, 
  1277| 	0x00711d0f, 0x00713d0f, 0x00715d0f, 0x00717d0f, 
  1278| 	0x00719d0f, 0x0071bd0f, 0x0071dd0f, 0x0071fd0f, 
  1279| 	0x00721d0f, 0x00723d0f, 0x00725d0f, 0x00727d0f, 
  1280| 	0x00729d0f, 0x0072bd0f, 0x0072dd0f, 0x0072fd0f, 
  1281| 	0x00731d0f, 0x00733d0f, 0x00735d0f, 0x00737d0f, 
  1282| 	0x00739d0f, 0x0073bd0f, 0x0073dd0f, 0x0073fd0f, 
  1283| 	0x00741d0f, 0x00743d0f, 0x00745d0f, 0x00747d0f, 
  1284| 	0x00749d0f, 0x0074bd0f, 0x0074dd0f, 0x0074fd0f, 
  1285| 	0x00751d0f, 0x00753d0f, 0x00755d0f, 0x00757d0f, 
  1286| 	0x00759d0f, 0x0075bd0f, 0x0075dd0f, 0x0075fd0f, 
  1287| 	0x00761d0f, 0x00763d0f, 0x00765d0f, 0x00767d0f, 
  1288| 	0x00769d0f, 0x0076bd0f, 0x0076dd0f, 0x0076fd0f, 
  1289| 	0x00771d0f, 0x00773d0f, 0x00775d0f, 0x00777d0f, 
  1290| 	0x00779d0f, 0x0077bd0f, 0x0077dd0f, 0x0077fd0f, 
  1291| 	0x00781d0f, 0x00783d0f, 0x00785d0f, 0x00787d0f, 
  1292| 	0x00789d0f, 0x0078bd0f, 0x0078dd0f, 0x0078fd0f, 
  1293| 	0x00791d0f, 0x00793d0f, 0x00795d0f, 0x00797d0f, 
  1294| 	0x00799d0f, 0x0079bd0f, 0x0079dd0f, 0x0079fd0f, 
  1295| 	0x007a1d0f, 0x007a3d0f, 0x007a5d0f, 0x007a7d0f, 
  1296| 	0x007a9d0f, 0x007abd0f, 0x007add0f, 0x007afd0f, 
  1297| 	0x007b1d0f, 0x007b3d0f, 0x007b5d0f, 0x007b7d0f, 
  1298| 	0x007b9d0f, 0x007bbd0f, 0x007bdd0f, 0x007bfd0f, 
  1299| 	0x007c1d0f, 0x007c3d0f, 0x007c5d0f, 0x007c7d0f, 
  1300| 	0x007c9d0f, 0x007cbd0f, 0x007cdd0f, 0x007cfd0f, 
  1301| 	0x007d1d0f, 0x007d3d0f, 0x007d5d0f, 0x007d7d0f, 
  1302| 	0x007d9d0f, 0x007dbd0f, 0x007ddd0f, 0x007dfd0f, 
  1303| 	0x007e1d0f, 0x007e3d0f, 0x007e5d0f, 0x007e7d0f, 
  1304| 	0x007e9d0f, 0x007ebd0f, 0x007edd0f, 0x007efd0f, 
  1305| 	0x007f1d0f, 0x007f3d0f, 0x007f5d0f, 0x007f7d0f, 
  1306| 	0x007f9d0f, 0x007fbd0f, 0x007fdd0f, 0x007ffd0f, 
  1307| 	0x00000310, 0x00002310, 0x00004310, 0x00006310, 
  1308| 	0x00008310, 0x0000a310, 0x0000c310, 0x0000e310, 
  1309| 	0x00010310, 0x00012310, 0x00014310, 0x00016310, 
  1310| 	0x00018310, 0x0001a310, 0x0001c310, 0x0001e310, 
  1311| 	0x00020310, 0x00022310, 0x00024310, 0x00026310, 
  1312| 	0x00028310, 0x0002a310, 0x0002c310, 0x0002e310, 
  1313| 	0x00030310, 0x00032310, 0x00034310, 0x00036310, 
  1314| 	0x00038310, 0x0003a310, 0x0003c310, 0x0003e310, 
  1315| 	0x00040310, 0x00042310, 0x00044310, 0x00046310, 
  1316| 	0x00048310, 0x0004a310, 0x0004c310, 0x0004e310, 
  1317| 	0x00050310, 0x00052310, 0x00054310, 0x00056310, 
  1318| 	0x00058310, 0x0005a310, 0x0005c310, 0x0005e310, 
  1319| 	0x00060310, 0x00062310, 0x00064310, 0x00066310, 
  1320| 	0x00068310, 0x0006a310, 0x0006c310, 0x0006e310, 
  1321| 	0x00070310, 0x00072310, 0x00074310, 0x00076310, 
  1322| 	0x00078310, 0x0007a310, 0x0007c310, 0x0007e310, 
  1323| 	0x00080310, 0x00082310, 0x00084310, 0x00086310, 
  1324| 	0x00088310, 0x0008a310, 0x0008c310, 0x0008e310, 
  1325| 	0x00090310, 0x00092310, 0x00094310, 0x00096310, 
  1326| 	0x00098310, 0x0009a310, 0x0009c310, 0x0009e310, 
  1327| 	0x000a0310, 0x000a2310, 0x000a4310, 0x000a6310, 
  1328| 	0x000a8310, 0x000aa310, 0x000ac310, 0x000ae310, 
  1329| 	0x000b0310, 0x000b2310, 0x000b4310, 0x000b6310, 
  1330| 	0x000b8310, 0x000ba310, 0x000bc310, 0x000be310, 
  1331| 	0x000c0310, 0x000c2310, 0x000c4310, 0x000c6310, 
  1332| 	0x000c8310, 0x000ca310, 0x000cc310, 0x000ce310, 
  1333| 	0x000d0310, 0x000d2310, 0x000d4310, 0x000d6310, 
  1334| 	0x000d8310, 0x000da310, 0x000dc310, 0x000de310, 
  1335| 	0x000e0310, 0x000e2310, 0x000e4310, 0x000e6310, 
  1336| 	0x000e8310, 0x000ea310, 0x000ec310, 0x000ee310, 
  1337| 	0x000f0310, 0x000f2310, 0x000f4310, 0x000f6310, 
  1338| 	0x000f8310, 0x000fa310, 0x000fc310, 0x000fe310, 
  1339| 	0x00100310, 0x00102310, 0x00104310, 0x00106310, 
  1340| 	0x00108310, 0x0010a310, 0x0010c310, 0x0010e310, 
  1341| 	0x00110310, 0x00112310, 0x00114310, 0x00116310, 
  1342| 	0x00118310, 0x0011a310, 0x0011c310, 0x0011e310, 
  1343| 	0x00120310, 0x00122310, 0x00124310, 0x00126310, 
  1344| 	0x00128310, 0x0012a310, 0x0012c310, 0x0012e310, 
  1345| 	0x00130310, 0x00132310, 0x00134310, 0x00136310, 
  1346| 	0x00138310, 0x0013a310, 0x0013c310, 0x0013e310, 
  1347| 	0x00140310, 0x00142310, 0x00144310, 0x00146310, 
  1348| 	0x00148310, 0x0014a310, 0x0014c310, 0x0014e310, 
  1349| 	0x00150310, 0x00152310, 0x00154310, 0x00156310, 
  1350| 	0x00158310, 0x0015a310, 0x0015c310, 0x0015e310, 
  1351| 	0x00160310, 0x00162310, 0x00164310, 0x00166310, 
  1352| 	0x00168310, 0x0016a310, 0x0016c310, 0x0016e310, 
  1353| 	0x00170310, 0x00172310, 0x00174310, 0x00176310, 
  1354| 	0x00178310, 0x0017a310, 0x0017c310, 0x0017e310, 
  1355| 	0x00180310, 0x00182310, 0x00184310, 0x00186310, 
  1356| 	0x00188310, 0x0018a310, 0x0018c310, 0x0018e310, 
  1357| 	0x00190310, 0x00192310, 0x00194310, 0x00196310, 
  1358| 	0x00198310, 0x0019a310, 0x0019c310, 0x0019e310, 
  1359| 	0x001a0310, 0x001a2310, 0x001a4310, 0x001a6310, 
  1360| 	0x001a8310, 0x001aa310, 0x001ac310, 0x001ae310, 
  1361| 	0x001b0310, 0x001b2310, 0x001b4310, 0x001b6310, 
  1362| 	0x001b8310, 0x001ba310, 0x001bc310, 0x001be310, 
  1363| 	0x001c0310, 0x001c2310, 0x001c4310, 0x001c6310, 
  1364| 	0x001c8310, 0x001ca310, 0x001cc310, 0x001ce310, 
  1365| 	0x001d0310, 0x001d2310, 0x001d4310, 0x001d6310, 
  1366| 	0x001d8310, 0x001da310, 0x001dc310, 0x001de310, 
  1367| 	0x001e0310, 0x001e2310, 0x001e4310, 0x001e6310, 
  1368| 	0x001e8310, 0x001ea310, 0x001ec310, 0x001ee310, 
  1369| 	0x001f0310, 0x001f2310, 0x001f4310, 0x001f6310, 
  1370| 	0x001f8310, 0x001fa310, 0x001fc310, 0x001fe310, 
  1371| 	0x00200310, 0x00202310, 0x00204310, 0x00206310, 
  1372| 	0x00208310, 0x0020a310, 0x0020c310, 0x0020e310, 
  1373| 	0x00210310, 0x00212310, 0x00214310, 0x00216310, 
  1374| 	0x00218310, 0x0021a310, 0x0021c310, 0x0021e310, 
  1375| 	0x00220310, 0x00222310, 0x00224310, 0x00226310, 
  1376| 	0x00228310, 0x0022a310, 0x0022c310, 0x0022e310, 
  1377| 	0x00230310, 0x00232310, 0x00234310, 0x00236310, 
  1378| 	0x00238310, 0x0023a310, 0x0023c310, 0x0023e310, 
  1379| 	0x00240310, 0x00242310, 0x00244310, 0x00246310, 
  1380| 	0x00248310, 0x0024a310, 0x0024c310, 0x0024e310, 
  1381| 	0x00250310, 0x00252310, 0x00254310, 0x00256310, 
  1382| 	0x00258310, 0x0025a310, 0x0025c310, 0x0025e310, 
  1383| 	0x00260310, 0x00262310, 0x00264310, 0x00266310, 
  1384| 	0x00268310, 0x0026a310, 0x0026c310, 0x0026e310, 
  1385| 	0x00270310, 0x00272310, 0x00274310, 0x00276310, 
  1386| 	0x00278310, 0x0027a310, 0x0027c310, 0x0027e310, 
  1387| 	0x00280310, 0x00282310, 0x00284310, 0x00286310, 
  1388| 	0x00288310, 0x0028a310, 0x0028c310, 0x0028e310, 
  1389| 	0x00290310, 0x00292310, 0x00294310, 0x00296310, 
  1390| 	0x00298310, 0x0029a310, 0x0029c310, 0x0029e310, 
  1391| 	0x002a0310, 0x002a2310, 0x002a4310, 0x002a6310, 
  1392| 	0x002a8310, 0x002aa310, 0x002ac310, 0x002ae310, 
  1393| 	0x002b0310, 0x002b2310, 0x002b4310, 0x002b6310, 
  1394| 	0x002b8310, 0x002ba310, 0x002bc310, 0x002be310, 
  1395| 	0x002c0310, 0x002c2310, 0x002c4310, 0x002c6310, 
  1396| 	0x002c8310, 0x002ca310, 0x002cc310, 0x002ce310, 
  1397| 	0x002d0310, 0x002d2310, 0x002d4310, 0x002d6310, 
  1398| 	0x002d8310, 0x002da310, 0x002dc310, 0x002de310, 
  1399| 	0x002e0310, 0x002e2310, 0x002e4310, 0x002e6310, 
  1400| 	0x002e8310, 0x002ea310, 0x002ec310, 0x002ee310, 
  1401| 	0x002f0310, 0x002f2310, 0x002f4310, 0x002f6310, 
  1402| 	0x002f8310, 0x002fa310, 0x002fc310, 0x002fe310, 
  1403| 	0x00300310, 0x00302310, 0x00304310, 0x00306310, 
  1404| 	0x00308310, 0x0030a310, 0x0030c310, 0x0030e310, 
  1405| 	0x00310310, 0x00312310, 0x00314310, 0x00316310, 
  1406| 	0x00318310, 0x0031a310, 0x0031c310, 0x0031e310, 
  1407| 	0x00320310, 0x00322310, 0x00324310, 0x00326310, 
  1408| 	0x00328310, 0x0032a310, 0x0032c310, 0x0032e310, 
  1409| 	0x00330310, 0x00332310, 0x00334310, 0x00336310, 
  1410| 	0x00338310, 0x0033a310, 0x0033c310, 0x0033e310, 
  1411| 	0x00340310, 0x00342310, 0x00344310, 0x00346310, 
  1412| 	0x00348310, 0x0034a310, 0x0034c310, 0x0034e310, 
  1413| 	0x00350310, 0x00352310, 0x00354310, 0x00356310, 
  1414| 	0x00358310, 0x0035a310, 0x0035c310, 0x0035e310, 
  1415| 	0x00360310, 0x00362310, 0x00364310, 0x00366310, 
  1416| 	0x00368310, 0x0036a310, 0x0036c310, 0x0036e310, 
  1417| 	0x00370310, 0x00372310, 0x00374310, 0x00376310, 
  1418| 	0x00378310, 0x0037a310, 0x0037c310, 0x0037e310, 
  1419| 	0x00380310, 0x00382310, 0x00384310, 0x00386310, 
  1420| 	0x00388310, 0x0038a310, 0x0038c310, 0x0038e310, 
  1421| 	0x00390310, 0x00392310, 0x00394310, 0x00396310, 
  1422| 	0x00398310, 0x0039a310, 0x0039c310, 0x0039e310, 
  1423| 	0x003a0310, 0x003a2310, 0x003a4310, 0x003a6310, 
  1424| 	0x003a8310, 0x003aa310, 0x003ac310, 0x003ae310, 
  1425| 	0x003b0310, 0x003b2310, 0x003b4310, 0x003b6310, 
  1426| 	0x003b8310, 0x003ba310, 0x003bc310, 0x003be310, 
  1427| 	0x003c0310, 0x003c2310, 0x003c4310, 0x003c6310, 
  1428| 	0x003c8310, 0x003ca310, 0x003cc310, 0x003ce310, 
  1429| 	0x003d0310, 0x003d2310, 0x003d4310, 0x003d6310, 
  1430| 	0x003d8310, 0x003da310, 0x003dc310, 0x003de310, 
  1431| 	0x003e0310, 0x003e2310, 0x003e4310, 0x003e6310, 
  1432| 	0x003e8310, 0x003ea310, 0x003ec310, 0x003ee310, 
  1433| 	0x003f0310, 0x003f2310, 0x003f4310, 0x003f6310, 
  1434| 	0x003f8310, 0x003fa310, 0x003fc310, 0x003fe310, 
  1435| 	0x00400310, 0x00402310, 0x00404310, 0x00406310, 
  1436| 	0x00408310, 0x0040a310, 0x0040c310, 0x0040e310, 
  1437| 	0x00410310, 0x00412310, 0x00414310, 0x00416310, 
  1438| 	0x00418310, 0x0041a310, 0x0041c310, 0x0041e310, 
  1439| 	0x00420310, 0x00422310, 0x00424310, 0x00426310, 
  1440| 	0x00428310, 0x0042a310, 0x0042c310, 0x0042e310, 
  1441| 	0x00430310, 0x00432310, 0x00434310, 0x00436310, 
  1442| 	0x00438310, 0x0043a310, 0x0043c310, 0x0043e310, 
  1443| 	0x00440310, 0x00442310, 0x00444310, 0x00446310, 
  1444| 	0x00448310, 0x0044a310, 0x0044c310, 0x0044e310, 
  1445| 	0x00450310, 0x00452310, 0x00454310, 0x00456310, 
  1446| 	0x00458310, 0x0045a310, 0x0045c310, 0x0045e310, 
  1447| 	0x00460310, 0x00462310, 0x00464310, 0x00466310, 
  1448| 	0x00468310, 0x0046a310, 0x0046c310, 0x0046e310, 
  1449| 	0x00470310, 0x00472310, 0x00474310, 0x00476310, 
  1450| 	0x00478310, 0x0047a310, 0x0047c310, 0x0047e310, 
  1451| 	0x00480310, 0x00482310, 0x00484310, 0x00486310, 
  1452| 	0x00488310, 0x0048a310, 0x0048c310, 0x0048e310, 
  1453| 	0x00490310, 0x00492310, 0x00494310, 0x00496310, 
  1454| 	0x00498310, 0x0049a310, 0x0049c310, 0x0049e310, 
  1455| 	0x004a0310, 0x004a2310, 0x004a4310, 0x004a6310, 
  1456| 	0x004a8310, 0x004aa310, 0x004ac310, 0x004ae310, 
  1457| 	0x004b0310, 0x004b2310, 0x004b4310, 0x004b6310, 
  1458| 	0x004b8310, 0x004ba310, 0x004bc310, 0x004be310, 
  1459| 	0x004c0310, 0x004c2310, 0x004c4310, 0x004c6310, 
  1460| 	0x004c8310, 0x004ca310, 0x004cc310, 0x004ce310, 
  1461| 	0x004d0310, 0x004d2310, 0x004d4310, 0x004d6310, 
  1462| 	0x004d8310, 0x004da310, 0x004dc310, 0x004de310, 
  1463| 	0x004e0310, 0x004e2310, 0x004e4310, 0x004e6310, 
  1464| 	0x004e8310, 0x004ea310, 0x004ec310, 0x004ee310, 
  1465| 	0x004f0310, 0x004f2310, 0x004f4310, 0x004f6310, 
  1466| 	0x004f8310, 0x004fa310, 0x004fc310, 0x004fe310, 
  1467| 	0x00500310, 0x00502310, 0x00504310, 0x00506310, 
  1468| 	0x00508310, 0x0050a310, 0x0050c310, 0x0050e310, 
  1469| 	0x00510310, 0x00512310, 0x00514310, 0x00516310, 
  1470| 	0x00518310, 0x0051a310, 0x0051c310, 0x0051e310, 
  1471| 	0x00520310, 0x00522310, 0x00524310, 0x00526310, 
  1472| 	0x00528310, 0x0052a310, 0x0052c310, 0x0052e310, 
  1473| 	0x00530310, 0x00532310, 0x00534310, 0x00536310, 
  1474| 	0x00538310, 0x0053a310, 0x0053c310, 0x0053e310, 
  1475| 	0x00540310, 0x00542310, 0x00544310, 0x00546310, 
  1476| 	0x00548310, 0x0054a310, 0x0054c310, 0x0054e310, 
  1477| 	0x00550310, 0x00552310, 0x00554310, 0x00556310, 
  1478| 	0x00558310, 0x0055a310, 0x0055c310, 0x0055e310, 
  1479| 	0x00560310, 0x00562310, 0x00564310, 0x00566310, 
  1480| 	0x00568310, 0x0056a310, 0x0056c310, 0x0056e310, 
  1481| 	0x00570310, 0x00572310, 0x00574310, 0x00576310, 
  1482| 	0x00578310, 0x0057a310, 0x0057c310, 0x0057e310, 
  1483| 	0x00580310, 0x00582310, 0x00584310, 0x00586310, 
  1484| 	0x00588310, 0x0058a310, 0x0058c310, 0x0058e310, 
  1485| 	0x00590310, 0x00592310, 0x00594310, 0x00596310, 
  1486| 	0x00598310, 0x0059a310, 0x0059c310, 0x0059e310, 
  1487| 	0x005a0310, 0x005a2310, 0x005a4310, 0x005a6310, 
  1488| 	0x005a8310, 0x005aa310, 0x005ac310, 0x005ae310, 
  1489| 	0x005b0310, 0x005b2310, 0x005b4310, 0x005b6310, 
  1490| 	0x005b8310, 0x005ba310, 0x005bc310, 0x005be310, 
  1491| 	0x005c0310, 0x005c2310, 0x005c4310, 0x005c6310, 
  1492| 	0x005c8310, 0x005ca310, 0x005cc310, 0x005ce310, 
  1493| 	0x005d0310, 0x005d2310, 0x005d4310, 0x005d6310, 
  1494| 	0x005d8310, 0x005da310, 0x005dc310, 0x005de310, 
  1495| 	0x005e0310, 0x005e2310, 0x005e4310, 0x005e6310, 
  1496| 	0x005e8310, 0x005ea310, 0x005ec310, 0x005ee310, 
  1497| 	0x005f0310, 0x005f2310, 0x005f4310, 0x005f6310, 
  1498| 	0x005f8310, 0x005fa310, 0x005fc310, 0x005fe310, 
  1499| 	0x00600310, 0x00602310, 0x00604310, 0x00606310, 
  1500| 	0x00608310, 0x0060a310, 0x0060c310, 0x0060e310, 
  1501| 	0x00610310, 0x00612310, 0x00614310, 0x00616310, 
  1502| 	0x00618310, 0x0061a310, 0x0061c310, 0x0061e310, 
  1503| 	0x00620310, 0x00622310, 0x00624310, 0x00626310, 
  1504| 	0x00628310, 0x0062a310, 0x0062c310, 0x0062e310, 
  1505| 	0x00630310, 0x00632310, 0x00634310, 0x00636310, 
  1506| 	0x00638310, 0x0063a310, 0x0063c310, 0x0063e310, 
  1507| 	0x00640310, 0x00642310, 0x00644310, 0x00646310, 
  1508| 	0x00648310, 0x0064a310, 0x0064c310, 0x0064e310, 
  1509| 	0x00650310, 0x00652310, 0x00654310, 0x00656310, 
  1510| 	0x00658310, 0x0065a310, 0x0065c310, 0x0065e310, 
  1511| 	0x00660310, 0x00662310, 0x00664310, 0x00666310, 
  1512| 	0x00668310, 0x0066a310, 0x0066c310, 0x0066e310, 
  1513| 	0x00670310, 0x00672310, 0x00674310, 0x00676310, 
  1514| 	0x00678310, 0x0067a310, 0x0067c310, 0x0067e310, 
  1515| 	0x00680310, 0x00682310, 0x00684310, 0x00686310, 
  1516| 	0x00688310, 0x0068a310, 0x0068c310, 0x0068e310, 
  1517| 	0x00690310, 0x00692310, 0x00694310, 0x00696310, 
  1518| 	0x00698310, 0x0069a310, 0x0069c310, 0x0069e310, 
  1519| 	0x006a0310, 0x006a2310, 0x006a4310, 0x006a6310, 
  1520| 	0x006a8310, 0x006aa310, 0x006ac310, 0x006ae310, 
  1521| 	0x006b0310, 0x006b2310, 0x006b4310, 0x006b6310, 
  1522| 	0x006b8310, 0x006ba310, 0x006bc310, 0x006be310, 
  1523| 	0x006c0310, 0x006c2310, 0x006c4310, 0x006c6310, 
  1524| 	0x006c8310, 0x006ca310, 0x006cc310, 0x006ce310, 
  1525| 	0x006d0310, 0x006d2310, 0x006d4310, 0x006d6310, 
  1526| 	0x006d8310, 0x006da310, 0x006dc310, 0x006de310, 
  1527| 	0x006e0310, 0x006e2310, 0x006e4310, 0x006e6310, 
  1528| 	0x006e8310, 0x006ea310, 0x006ec310, 0x006ee310, 
  1529| 	0x006f0310, 0x006f2310, 0x006f4310, 0x006f6310, 
  1530| 	0x006f8310, 0x006fa310, 0x006fc310, 0x006fe310, 
  1531| 	0x00700310, 0x00702310, 0x00704310, 0x00706310, 
  1532| 	0x00708310, 0x0070a310, 0x0070c310, 0x0070e310, 
  1533| 	0x00710310, 0x00712310, 0x00714310, 0x00716310, 
  1534| 	0x00718310, 0x0071a310, 0x0071c310, 0x0071e310, 
  1535| 	0x00720310, 0x00722310, 0x00724310, 0x00726310, 
  1536| 	0x00728310, 0x0072a310, 0x0072c310, 0x0072e310, 
  1537| 	0x00730310, 0x00732310, 0x00734310, 0x00736310, 
  1538| 	0x00738310, 0x0073a310, 0x0073c310, 0x0073e310, 
  1539| 	0x00740310, 0x00742310, 0x00744310, 0x00746310, 
  1540| 	0x00748310, 0x0074a310, 0x0074c310, 0x0074e310, 
  1541| 	0x00750310, 0x00752310, 0x00754310, 0x00756310, 
  1542| 	0x00758310, 0x0075a310, 0x0075c310, 0x0075e310, 
  1543| 	0x00760310, 0x00762310, 0x00764310, 0x00766310, 
  1544| 	0x00768310, 0x0076a310, 0x0076c310, 0x0076e310, 
  1545| 	0x00770310, 0x00772310, 0x00774310, 0x00776310, 
  1546| 	0x00778310, 0x0077a310, 0x0077c310, 0x0077e310, 
  1547| 	0x00780310, 0x00782310, 0x00784310, 0x00786310, 
  1548| 	0x00788310, 0x0078a310, 0x0078c310, 0x0078e310, 
  1549| 	0x00790310, 0x00792310, 0x00794310, 0x00796310, 
  1550| 	0x00798310, 0x0079a310, 0x0079c310, 0x0079e310, 
  1551| 	0x007a0310, 0x007a2310, 0x007a4310, 0x007a6310, 
  1552| 	0x007a8310, 0x007aa310, 0x007ac310, 0x007ae310, 
  1553| 	0x007b0310, 0x007b2310, 0x007b4310, 0x007b6310, 
  1554| 	0x007b8310, 0x007ba310, 0x007bc310, 0x007be310, 
  1555| 	0x007c0310, 0x007c2310, 0x007c4310, 0x007c6310, 
  1556| 	0x007c8310, 0x007ca310, 0x007cc310, 0x007ce310, 
  1557| 	0x007d0310, 0x007d2310, 0x007d4310, 0x007d6310, 
  1558| 	0x007d8310, 0x007da310, 0x007dc310, 0x007de310, 
  1559| 	0x007e0310, 0x007e2310, 0x007e4310, 0x007e6310, 
  1560| 	0x007e8310, 0x007ea310, 0x007ec310, 0x007ee310, 
  1561| 	0x007f0310, 0x007f2310, 0x007f4310, 0x007f6310, 
  1562| 	0x007f8310, 0x007fa310, 0x007fc310, 0x007fe310, 
  1563| 	0x00800310, 0x00802310, 0x00804310, 0x00806310, 
  1564| 	0x00808310, 0x0080a310, 0x0080c310, 0x0080e310, 
  1565| 	0x00810310, 0x00812310, 0x00814310, 0x00816310, 
  1566| 	0x00818310, 0x0081a310, 0x0081c310, 0x0081e310, 
  1567| 	0x00820310, 0x00822310, 0x00824310, 0x00826310, 
  1568| 	0x00828310, 0x0082a310, 0x0082c310, 0x0082e310, 
  1569| 	0x00830310, 0x00832310, 0x00834310, 0x00836310, 
  1570| 	0x00838310, 0x0083a310, 0x0083c310, 0x0083e310, 
  1571| 	0x00840310, 0x00842310, 0x00844310, 0x00846310, 
  1572| 	0x00848310, 0x0084a310, 0x0084c310, 0x0084e310, 
  1573| 	0x00850310, 0x00852310, 0x00854310, 0x00856310, 
  1574| 	0x00858310, 0x0085a310, 0x0085c310, 0x0085e310, 
  1575| 	0x00860310, 0x00862310, 0x00864310, 0x00866310, 
  1576| 	0x00868310, 0x0086a310, 0x0086c310, 0x0086e310, 
  1577| 	0x00870310, 0x00872310, 0x00874310, 0x00876310, 
  1578| 	0x00878310, 0x0087a310, 0x0087c310, 0x0087e310, 
  1579| 	0x00880310, 0x00882310, 0x00884310, 0x00886310, 
  1580| 	0x00888310, 0x0088a310, 0x0088c310, 0x0088e310, 
  1581| 	0x00890310, 0x00892310, 0x00894310, 0x00896310, 
  1582| 	0x00898310, 0x0089a310, 0x0089c310, 0x0089e310, 
  1583| 	0x008a0310, 0x008a2310, 0x008a4310, 0x008a6310, 
  1584| 	0x008a8310, 0x008aa310, 0x008ac310, 0x008ae310, 
  1585| 	0x008b0310, 0x008b2310, 0x008b4310, 0x008b6310, 
  1586| 	0x008b8310, 0x008ba310, 0x008bc310, 0x008be310, 
  1587| 	0x008c0310, 0x008c2310, 0x008c4310, 0x008c6310, 
  1588| 	0x008c8310, 0x008ca310, 0x008cc310, 0x008ce310, 
  1589| 	0x008d0310, 0x008d2310, 0x008d4310, 0x008d6310, 
  1590| 	0x008d8310, 0x008da310, 0x008dc310, 0x008de310, 
  1591| 	0x008e0310, 0x008e2310, 0x008e4310, 0x008e6310, 
  1592| 	0x008e8310, 0x008ea310, 0x008ec310, 0x008ee310, 
  1593| 	0x008f0310, 0x008f2310, 0x008f4310, 0x008f6310, 
  1594| 	0x008f8310, 0x008fa310, 0x008fc310, 0x008fe310, 
  1595| 	0x00900310, 0x00902310, 0x00904310, 0x00906310, 
  1596| 	0x00908310, 0x0090a310, 0x0090c310, 0x0090e310, 
  1597| 	0x00910310, 0x00912310, 0x00914310, 0x00916310, 
  1598| 	0x00918310, 0x0091a310, 0x0091c310, 0x0091e310, 
  1599| 	0x00920310, 0x00922310, 0x00924310, 0x00926310, 
  1600| 	0x00928310, 0x0092a310, 0x0092c310, 0x0092e310, 
  1601| 	0x00930310, 0x00932310, 0x00934310, 0x00936310, 
  1602| 	0x00938310, 0x0093a310, 0x0093c310, 0x0093e310, 
  1603| 	0x00940310, 0x00942310, 0x00944310, 0x00946310, 
  1604| 	0x00948310, 0x0094a310, 0x0094c310, 0x0094e310, 
  1605| 	0x00950310, 0x00952310, 0x00954310, 0x00956310, 
  1606| 	0x00958310, 0x0095a310, 0x0095c310, 0x0095e310, 
  1607| 	0x00960310, 0x00962310, 0x00964310, 0x00966310, 
  1608| 	0x00968310, 0x0096a310, 0x0096c310, 0x0096e310, 
  1609| 	0x00970310, 0x00972310, 0x00974310, 0x00976310, 
  1610| 	0x00978310, 0x0097a310, 0x0097c310, 0x0097e310, 
  1611| 	0x00980310, 0x00982310, 0x00984310, 0x00986310, 
  1612| 	0x00988310, 0x0098a310, 0x0098c310, 0x0098e310, 
  1613| 	0x00990310, 0x00992310, 0x00994310, 0x00996310, 
  1614| 	0x00998310, 0x0099a310, 0x0099c310, 0x0099e310, 
  1615| 	0x009a0310, 0x009a2310, 0x009a4310, 0x009a6310, 
  1616| 	0x009a8310, 0x009aa310, 0x009ac310, 0x009ae310, 
  1617| 	0x009b0310, 0x009b2310, 0x009b4310, 0x009b6310, 
  1618| 	0x009b8310, 0x009ba310, 0x009bc310, 0x009be310, 
  1619| 	0x009c0310, 0x009c2310, 0x009c4310, 0x009c6310, 
  1620| 	0x009c8310, 0x009ca310, 0x009cc310, 0x009ce310, 
  1621| 	0x009d0310, 0x009d2310, 0x009d4310, 0x009d6310, 
  1622| 	0x009d8310, 0x009da310, 0x009dc310, 0x009de310, 
  1623| 	0x009e0310, 0x009e2310, 0x009e4310, 0x009e6310, 
  1624| 	0x009e8310, 0x009ea310, 0x009ec310, 0x009ee310, 
  1625| 	0x009f0310, 0x009f2310, 0x009f4310, 0x009f6310, 
  1626| 	0x009f8310, 0x009fa310, 0x009fc310, 0x009fe310, 
  1627| 	0x00a00310, 0x00a02310, 0x00a04310, 0x00a06310, 
  1628| 	0x00a08310, 0x00a0a310, 0x00a0c310, 0x00a0e310, 
  1629| 	0x00a10310, 0x00a12310, 0x00a14310, 0x00a16310, 
  1630| 	0x00a18310, 0x00a1a310, 0x00a1c310, 0x00a1e310, 
  1631| 	0x00a20310, 0x00a22310, 0x00a24310, 0x00a26310, 
  1632| 	0x00a28310, 0x00a2a310, 0x00a2c310, 0x00a2e310, 
  1633| 	0x00a30310, 0x00a32310, 0x00a34310, 0x00a36310, 
  1634| 	0x00a38310, 0x00a3a310, 0x00a3c310, 0x00a3e310, 
  1635| 	0x00a40310, 0x00a42310, 0x00a44310, 0x00a46310, 
  1636| 	0x00a48310, 0x00a4a310, 0x00a4c310, 0x00a4e310, 
  1637| 	0x00a50310, 0x00a52310, 0x00a54310, 0x00a56310, 
  1638| 	0x00a58310, 0x00a5a310, 0x00a5c310, 0x00a5e310, 
  1639| 	0x00a60310, 0x00a62310, 0x00a64310, 0x00a66310, 
  1640| 	0x00a68310, 0x00a6a310, 0x00a6c310, 0x00a6e310, 
  1641| 	0x00a70310, 0x00a72310, 0x00a74310, 0x00a76310, 
  1642| 	0x00a78310, 0x00a7a310, 0x00a7c310, 0x00a7e310, 
  1643| 	0x00a80310, 0x00a82310, 0x00a84310, 0x00a86310, 
  1644| 	0x00a88310, 0x00a8a310, 0x00a8c310, 0x00a8e310, 
  1645| 	0x00a90310, 0x00a92310, 0x00a94310, 0x00a96310, 
  1646| 	0x00a98310, 0x00a9a310, 0x00a9c310, 0x00a9e310, 
  1647| 	0x00aa0310, 0x00aa2310, 0x00aa4310, 0x00aa6310, 
  1648| 	0x00aa8310, 0x00aaa310, 0x00aac310, 0x00aae310, 
  1649| 	0x00ab0310, 0x00ab2310, 0x00ab4310, 0x00ab6310, 
  1650| 	0x00ab8310, 0x00aba310, 0x00abc310, 0x00abe310, 
  1651| 	0x00ac0310, 0x00ac2310, 0x00ac4310, 0x00ac6310, 
  1652| 	0x00ac8310, 0x00aca310, 0x00acc310, 0x00ace310, 
  1653| 	0x00ad0310, 0x00ad2310, 0x00ad4310, 0x00ad6310, 
  1654| 	0x00ad8310, 0x00ada310, 0x00adc310, 0x00ade310, 
  1655| 	0x00ae0310, 0x00ae2310, 0x00ae4310, 0x00ae6310, 
  1656| 	0x00ae8310, 0x00aea310, 0x00aec310, 0x00aee310, 
  1657| 	0x00af0310, 0x00af2310, 0x00af4310, 0x00af6310, 
  1658| 	0x00af8310, 0x00afa310, 0x00afc310, 0x00afe310, 
  1659| 	0x00b00310, 0x00b02310, 0x00b04310, 0x00b06310, 
  1660| 	0x00b08310, 0x00b0a310, 0x00b0c310, 0x00b0e310, 
  1661| 	0x00b10310, 0x00b12310, 0x00b14310, 0x00b16310, 
  1662| 	0x00b18310, 0x00b1a310, 0x00b1c310, 0x00b1e310, 
  1663| 	0x00b20310, 0x00b22310, 0x00b24310, 0x00b26310, 
  1664| 	0x00b28310, 0x00b2a310, 0x00b2c310, 0x00b2e310, 
  1665| 	0x00b30310, 0x00b32310, 0x00b34310, 0x00b36310, 
  1666| 	0x00b38310, 0x00b3a310, 0x00b3c310, 0x00b3e310, 
  1667| 	0x00b40310, 0x00b42310, 0x00b44310, 0x00b46310, 
  1668| 	0x00b48310, 0x00b4a310, 0x00b4c310, 0x00b4e310, 
  1669| 	0x00b50310, 0x00b52310, 0x00b54310, 0x00b56310, 
  1670| 	0x00b58310, 0x00b5a310, 0x00b5c310, 0x00b5e310, 
  1671| 	0x00b60310, 0x00b62310, 0x00b64310, 0x00b66310, 
  1672| 	0x00b68310, 0x00b6a310, 0x00b6c310, 0x00b6e310, 
  1673| 	0x00b70310, 0x00b72310, 0x00b74310, 0x00b76310, 
  1674| 	0x00b78310, 0x00b7a310, 0x00b7c310, 0x00b7e310, 
  1675| 	0x00b80310, 0x00b82310, 0x00b84310, 0x00b86310, 
  1676| 	0x00b88310, 0x00b8a310, 0x00b8c310, 0x00b8e310, 
  1677| 	0x00b90310, 0x00b92310, 0x00b94310, 0x00b96310, 
  1678| 	0x00b98310, 0x00b9a310, 0x00b9c310, 0x00b9e310, 
  1679| 	0x00ba0310, 0x00ba2310, 0x00ba4310, 0x00ba6310, 
  1680| 	0x00ba8310, 0x00baa310, 0x00bac310, 0x00bae310, 
  1681| 	0x00bb0310, 0x00bb2310, 0x00bb4310, 0x00bb6310, 
  1682| 	0x00bb8310, 0x00bba310, 0x00bbc310, 0x00bbe310, 
  1683| 	0x00bc0310, 0x00bc2310, 0x00bc4310, 0x00bc6310, 
  1684| 	0x00bc8310, 0x00bca310, 0x00bcc310, 0x00bce310, 
  1685| 	0x00bd0310, 0x00bd2310, 0x00bd4310, 0x00bd6310, 
  1686| 	0x00bd8310, 0x00bda310, 0x00bdc310, 0x00bde310, 
  1687| 	0x00be0310, 0x00be2310, 0x00be4310, 0x00be6310, 
  1688| 	0x00be8310, 0x00bea310, 0x00bec310, 0x00bee310, 
  1689| 	0x00bf0310, 0x00bf2310, 0x00bf4310, 0x00bf6310, 
  1690| 	0x00bf8310, 0x00bfa310, 0x00bfc310, 0x00bfe310, 
  1691| 	0x00c00310, 0x00c02310, 0x00c04310, 0x00c06310, 
  1692| 	0x00c08310, 0x00c0a310, 0x00c0c310, 0x00c0e310, 
  1693| 	0x00c10310, 0x00c12310, 0x00c14310, 0x00c16310, 
  1694| 	0x00c18310, 0x00c1a310, 0x00c1c310, 0x00c1e310, 
  1695| 	0x00c20310, 0x00c22310, 0x00c24310, 0x00c26310, 
  1696| 	0x00c28310, 0x00c2a310, 0x00c2c310, 0x00c2e310, 
  1697| 	0x00c30310, 0x00c32310, 0x00c34310, 0x00c36310, 
  1698| 	0x00c38310, 0x00c3a310, 0x00c3c310, 0x00c3e310, 
  1699| 	0x00c40310, 0x00c42310, 0x00c44310, 0x00c46310, 
  1700| 	0x00c48310, 0x00c4a310, 0x00c4c310, 0x00c4e310, 
  1701| 	0x00c50310, 0x00c52310, 0x00c54310, 0x00c56310, 
  1702| 	0x00c58310, 0x00c5a310, 0x00c5c310, 0x00c5e310, 
  1703| 	0x00c60310, 0x00c62310, 0x00c64310, 0x00c66310, 
  1704| 	0x00c68310, 0x00c6a310, 0x00c6c310, 0x00c6e310, 
  1705| 	0x00c70310, 0x00c72310, 0x00c74310, 0x00c76310, 
  1706| 	0x00c78310, 0x00c7a310, 0x00c7c310, 0x00c7e310, 
  1707| 	0x00c80310, 0x00c82310, 0x00c84310, 0x00c86310, 
  1708| 	0x00c88310, 0x00c8a310, 0x00c8c310, 0x00c8e310, 
  1709| 	0x00c90310, 0x00c92310, 0x00c94310, 0x00c96310, 
  1710| 	0x00c98310, 0x00c9a310, 0x00c9c310, 0x00c9e310, 
  1711| 	0x00ca0310, 0x00ca2310, 0x00ca4310, 0x00ca6310, 
  1712| 	0x00ca8310, 0x00caa310, 0x00cac310, 0x00cae310, 
  1713| 	0x00cb0310, 0x00cb2310, 0x00cb4310, 0x00cb6310, 
  1714| 	0x00cb8310, 0x00cba310, 0x00cbc310, 0x00cbe310, 
  1715| 	0x00cc0310, 0x00cc2310, 0x00cc4310, 0x00cc6310, 
  1716| 	0x00cc8310, 0x00cca310, 0x00ccc310, 0x00cce310, 
  1717| 	0x00cd0310, 0x00cd2310, 0x00cd4310, 0x00cd6310, 
  1718| 	0x00cd8310, 0x00cda310, 0x00cdc310, 0x00cde310, 
  1719| 	0x00ce0310, 0x00ce2310, 0x00ce4310, 0x00ce6310, 
  1720| 	0x00ce8310, 0x00cea310, 0x00cec310, 0x00cee310, 
  1721| 	0x00cf0310, 0x00cf2310, 0x00cf4310, 0x00cf6310, 
  1722| 	0x00cf8310, 0x00cfa310, 0x00cfc310, 0x00cfe310, 
  1723| 	0x00d00310, 0x00d02310, 0x00d04310, 0x00d06310, 
  1724| 	0x00d08310, 0x00d0a310, 0x00d0c310, 0x00d0e310, 
  1725| 	0x00d10310, 0x00d12310, 0x00d14310, 0x00d16310, 
  1726| 	0x00d18310, 0x00d1a310, 0x00d1c310, 0x00d1e310, 
  1727| 	0x00d20310, 0x00d22310, 0x00d24310, 0x00d26310, 
  1728| 	0x00d28310, 0x00d2a310, 0x00d2c310, 0x00d2e310, 
  1729| 	0x00d30310, 0x00d32310, 0x00d34310, 0x00d36310, 
  1730| 	0x00d38310, 0x00d3a310, 0x00d3c310, 0x00d3e310, 
  1731| 	0x00d40310, 0x00d42310, 0x00d44310, 0x00d46310, 
  1732| 	0x00d48310, 0x00d4a310, 0x00d4c310, 0x00d4e310, 
  1733| 	0x00d50310, 0x00d52310, 0x00d54310, 0x00d56310, 
  1734| 	0x00d58310, 0x00d5a310, 0x00d5c310, 0x00d5e310, 
  1735| 	0x00d60310, 0x00d62310, 0x00d64310, 0x00d66310, 
  1736| 	0x00d68310, 0x00d6a310, 0x00d6c310, 0x00d6e310, 
  1737| 	0x00d70310, 0x00d72310, 0x00d74310, 0x00d76310, 
  1738| 	0x00d78310, 0x00d7a310, 0x00d7c310, 0x00d7e310, 
  1739| 	0x00d80310, 0x00d82310, 0x00d84310, 0x00d86310, 
  1740| 	0x00d88310, 0x00d8a310, 0x00d8c310, 0x00d8e310, 
  1741| 	0x00d90310, 0x00d92310, 0x00d94310, 0x00d96310, 
  1742| 	0x00d98310, 0x00d9a310, 0x00d9c310, 0x00d9e310, 
  1743| 	0x00da0310, 0x00da2310, 0x00da4310, 0x00da6310, 
  1744| 	0x00da8310, 0x00daa310, 0x00dac310, 0x00dae310, 
  1745| 	0x00db0310, 0x00db2310, 0x00db4310, 0x00db6310, 
  1746| 	0x00db8310, 0x00dba310, 0x00dbc310, 0x00dbe310, 
  1747| 	0x00dc0310, 0x00dc2310, 0x00dc4310, 0x00dc6310, 
  1748| 	0x00dc8310, 0x00dca310, 0x00dcc310, 0x00dce310, 
  1749| 	0x00dd0310, 0x00dd2310, 0x00dd4310, 0x00dd6310, 
  1750| 	0x00dd8310, 0x00dda310, 0x00ddc310, 0x00dde310, 
  1751| 	0x00de0310, 0x00de2310, 0x00de4310, 0x00de6310, 
  1752| 	0x00de8310, 0x00dea310, 0x00dec310, 0x00dee310, 
  1753| 	0x00df0310, 0x00df2310, 0x00df4310, 0x00df6310, 
  1754| 	0x00df8310, 0x00dfa310, 0x00dfc310, 0x00dfe310, 
  1755| 	0x00e00310, 0x00e02310, 0x00e04310, 0x00e06310, 
  1756| 	0x00e08310, 0x00e0a310, 0x00e0c310, 0x00e0e310, 
  1757| 	0x00e10310, 0x00e12310, 0x00e14310, 0x00e16310, 
  1758| 	0x00e18310, 0x00e1a310, 0x00e1c310, 0x00e1e310, 
  1759| 	0x00e20310, 0x00e22310, 0x00e24310, 0x00e26310, 
  1760| 	0x00e28310, 0x00e2a310, 0x00e2c310, 0x00e2e310, 
  1761| 	0x00e30310, 0x00e32310, 0x00e34310, 0x00e36310, 
  1762| 	0x00e38310, 0x00e3a310, 0x00e3c310, 0x00e3e310, 
  1763| 	0x00e40310, 0x00e42310, 0x00e44310, 0x00e46310, 
  1764| 	0x00e48310, 0x00e4a310, 0x00e4c310, 0x00e4e310, 
  1765| 	0x00e50310, 0x00e52310, 0x00e54310, 0x00e56310, 
  1766| 	0x00e58310, 0x00e5a310, 0x00e5c310, 0x00e5e310, 
  1767| 	0x00e60310, 0x00e62310, 0x00e64310, 0x00e66310, 
  1768| 	0x00e68310, 0x00e6a310, 0x00e6c310, 0x00e6e310, 
  1769| 	0x00e70310, 0x00e72310, 0x00e74310, 0x00e76310, 
  1770| 	0x00e78310, 0x00e7a310, 0x00e7c310, 0x00e7e310, 
  1771| 	0x00e80310, 0x00e82310, 0x00e84310, 0x00e86310, 
  1772| 	0x00e88310, 0x00e8a310, 0x00e8c310, 0x00e8e310, 
  1773| 	0x00e90310, 0x00e92310, 0x00e94310, 0x00e96310, 
  1774| 	0x00e98310, 0x00e9a310, 0x00e9c310, 0x00e9e310, 
  1775| 	0x00ea0310, 0x00ea2310, 0x00ea4310, 0x00ea6310, 
  1776| 	0x00ea8310, 0x00eaa310, 0x00eac310, 0x00eae310, 
  1777| 	0x00eb0310, 0x00eb2310, 0x00eb4310, 0x00eb6310, 
  1778| 	0x00eb8310, 0x00eba310, 0x00ebc310, 0x00ebe310, 
  1779| 	0x00ec0310, 0x00ec2310, 0x00ec4310, 0x00ec6310, 
  1780| 	0x00ec8310, 0x00eca310, 0x00ecc310, 0x00ece310, 
  1781| 	0x00ed0310, 0x00ed2310, 0x00ed4310, 0x00ed6310, 
  1782| 	0x00ed8310, 0x00eda310, 0x00edc310, 0x00ede310, 
  1783| 	0x00ee0310, 0x00ee2310, 0x00ee4310, 0x00ee6310, 
  1784| 	0x00ee8310, 0x00eea310, 0x00eec310, 0x00eee310, 
  1785| 	0x00ef0310, 0x00ef2310, 0x00ef4310, 0x00ef6310, 
  1786| 	0x00ef8310, 0x00efa310, 0x00efc310, 0x00efe310, 
  1787| 	0x00f00310, 0x00f02310, 0x00f04310, 0x00f06310, 
  1788| 	0x00f08310, 0x00f0a310, 0x00f0c310, 0x00f0e310, 
  1789| 	0x00f10310, 0x00f12310, 0x00f14310, 0x00f16310, 
  1790| 	0x00f18310, 0x00f1a310, 0x00f1c310, 0x00f1e310, 
  1791| 	0x00f20310, 0x00f22310, 0x00f24310, 0x00f26310, 
  1792| 	0x00f28310, 0x00f2a310, 0x00f2c310, 0x00f2e310, 
  1793| 	0x00f30310, 0x00f32310, 0x00f34310, 0x00f36310, 
  1794| 	0x00f38310, 0x00f3a310, 0x00f3c310, 0x00f3e310, 
  1795| 	0x00f40310, 0x00f42310, 0x00f44310, 0x00f46310, 
  1796| 	0x00f48310, 0x00f4a310, 0x00f4c310, 0x00f4e310, 
  1797| 	0x00f50310, 0x00f52310, 0x00f54310, 0x00f56310, 
  1798| 	0x00f58310, 0x00f5a310, 0x00f5c310, 0x00f5e310, 
  1799| 	0x00f60310, 0x00f62310, 0x00f64310, 0x00f66310, 
  1800| 	0x00f68310, 0x00f6a310, 0x00f6c310, 0x00f6e310, 
  1801| 	0x00f70310, 0x00f72310, 0x00f74310, 0x00f76310, 
  1802| 	0x00f78310, 0x00f7a310, 0x00f7c310, 0x00f7e310, 
  1803| 	0x00f80310, 0x00f82310, 0x00f84310, 0x00f86310, 
  1804| 	0x00f88310, 0x00f8a310, 0x00f8c310, 0x00f8e310, 
  1805| 	0x00f90310, 0x00f92310, 0x00f94310, 0x00f96310, 
  1806| 	0x00f98310, 0x00f9a310, 0x00f9c310, 0x00f9e310, 
  1807| 	0x00fa0310, 0x00fa2310, 0x00fa4310, 0x00fa6310, 
  1808| 	0x00fa8310, 0x00faa310, 0x00fac310, 0x00fae310, 
  1809| 	0x00fb0310, 0x00fb2310, 0x00fb4310, 0x00fb6310, 
  1810| 	0x00fb8310, 0x00fba310, 0x00fbc310, 0x00fbe310, 
  1811| 	0x00fc0310, 0x00fc2310, 0x00fc4310, 0x00fc6310, 
  1812| 	0x00fc8310, 0x00fca310, 0x00fcc310, 0x00fce310, 
  1813| 	0x00fd0310, 0x00fd2310, 0x00fd4310, 0x00fd6310, 
  1814| 	0x00fd8310, 0x00fda310, 0x00fdc310, 0x00fde310, 
  1815| 	0x00fe0310, 0x00fe2310, 0x00fe4310, 0x00fe6310, 
  1816| 	0x00fe8310, 0x00fea310, 0x00fec310, 0x00fee310, 
  1817| 	0x00ff0310, 0x00ff2310, 0x00ff4310, 0x00ff6310, 
  1818| 	0x00ff8310, 0x00ffa310, 0x00ffc310, 0x00ffe310, 
  1819| 	0x00001310, 0x00003310, 0x00005310, 0x00007310, 
  1820| 	0x00009310, 0x0000b310, 0x0000d310, 0x0000f310, 
  1821| 	0x00011310, 0x00013310, 0x00015310, 0x00017310, 
  1822| 	0x00019310, 0x0001b310, 0x0001d310, 0x0001f310, 
  1823| 	0x00021310, 0x00023310, 0x00025310, 0x00027310, 
  1824| 	0x00029310, 0x0002b310, 0x0002d310, 0x0002f310, 
  1825| 	0x00031310, 0x00033310, 0x00035310, 0x00037310, 
  1826| 	0x00039310, 0x0003b310, 0x0003d310, 0x0003f310, 
  1827| 	0x00041310, 0x00043310, 0x00045310, 0x00047310, 
  1828| 	0x00049310, 0x0004b310, 0x0004d310, 0x0004f310, 
  1829| 	0x00051310, 0x00053310, 0x00055310, 0x00057310, 
  1830| 	0x00059310, 0x0005b310, 0x0005d310, 0x0005f310, 
  1831| 	0x00061310, 0x00063310, 0x00065310, 0x00067310, 
  1832| 	0x00069310, 0x0006b310, 0x0006d310, 0x0006f310, 
  1833| 	0x00071310, 0x00073310, 0x00075310, 0x00077310, 
  1834| 	0x00079310, 0x0007b310, 0x0007d310, 0x0007f310, 
  1835| 	0x00081310, 0x00083310, 0x00085310, 0x00087310, 
  1836| 	0x00089310, 0x0008b310, 0x0008d310, 0x0008f310, 
  1837| 	0x00091310, 0x00093310, 0x00095310, 0x00097310, 
  1838| 	0x00099310, 0x0009b310, 0x0009d310, 0x0009f310, 
  1839| 	0x000a1310, 0x000a3310, 0x000a5310, 0x000a7310, 
  1840| 	0x000a9310, 0x000ab310, 0x000ad310, 0x000af310, 
  1841| 	0x000b1310, 0x000b3310, 0x000b5310, 0x000b7310, 
  1842| 	0x000b9310, 0x000bb310, 0x000bd310, 0x000bf310, 
  1843| 	0x000c1310, 0x000c3310, 0x000c5310, 0x000c7310, 
  1844| 	0x000c9310, 0x000cb310, 0x000cd310, 0x000cf310, 
  1845| 	0x000d1310, 0x000d3310, 0x000d5310, 0x000d7310, 
  1846| 	0x000d9310, 0x000db310, 0x000dd310, 0x000df310, 
  1847| 	0x000e1310, 0x000e3310, 0x000e5310, 0x000e7310, 
  1848| 	0x000e9310, 0x000eb310, 0x000ed310, 0x000ef310, 
  1849| 	0x000f1310, 0x000f3310, 0x000f5310, 0x000f7310, 
  1850| 	0x000f9310, 0x000fb310, 0x000fd310, 0x000ff310, 
  1851| 	0x00101310, 0x00103310, 0x00105310, 0x00107310, 
  1852| 	0x00109310, 0x0010b310, 0x0010d310, 0x0010f310, 
  1853| 	0x00111310, 0x00113310, 0x00115310, 0x00117310, 
  1854| 	0x00119310, 0x0011b310, 0x0011d310, 0x0011f310, 
  1855| 	0x00121310, 0x00123310, 0x00125310, 0x00127310, 
  1856| 	0x00129310, 0x0012b310, 0x0012d310, 0x0012f310, 
  1857| 	0x00131310, 0x00133310, 0x00135310, 0x00137310, 
  1858| 	0x00139310, 0x0013b310, 0x0013d310, 0x0013f310, 
  1859| 	0x00141310, 0x00143310, 0x00145310, 0x00147310, 
  1860| 	0x00149310, 0x0014b310, 0x0014d310, 0x0014f310, 
  1861| 	0x00151310, 0x00153310, 0x00155310, 0x00157310, 
  1862| 	0x00159310, 0x0015b310, 0x0015d310, 0x0015f310, 
  1863| 	0x00161310, 0x00163310, 0x00165310, 0x00167310, 
  1864| 	0x00169310, 0x0016b310, 0x0016d310, 0x0016f310, 
  1865| 	0x00171310, 0x00173310, 0x00175310, 0x00177310, 
  1866| 	0x00179310, 0x0017b310, 0x0017d310, 0x0017f310, 
  1867| 	0x00181310, 0x00183310, 0x00185310, 0x00187310, 
  1868| 	0x00189310, 0x0018b310, 0x0018d310, 0x0018f310, 
  1869| 	0x00191310, 0x00193310, 0x00195310, 0x00197310, 
  1870| 	0x00199310, 0x0019b310, 0x0019d310, 0x0019f310, 
  1871| 	0x001a1310, 0x001a3310, 0x001a5310, 0x001a7310, 
  1872| 	0x001a9310, 0x001ab310, 0x001ad310, 0x001af310, 
  1873| 	0x001b1310, 0x001b3310, 0x001b5310, 0x001b7310, 
  1874| 	0x001b9310, 0x001bb310, 0x001bd310, 0x001bf310, 
  1875| 	0x001c1310, 0x001c3310, 0x001c5310, 0x001c7310, 
  1876| 	0x001c9310, 0x001cb310, 0x001cd310, 0x001cf310, 
  1877| 	0x001d1310, 0x001d3310, 0x001d5310, 0x001d7310, 
  1878| 	0x001d9310, 0x001db310, 0x001dd310, 0x001df310, 
  1879| 	0x001e1310, 0x001e3310, 0x001e5310, 0x001e7310, 
  1880| 	0x001e9310, 0x001eb310, 0x001ed310, 0x001ef310, 
  1881| 	0x001f1310, 0x001f3310, 0x001f5310, 0x001f7310, 
  1882| 	0x001f9310, 0x001fb310, 0x001fd310, 0x001ff310, 
  1883| 	0x00201310, 0x00203310, 0x00205310, 0x00207310, 
  1884| 	0x00209310, 0x0020b310, 0x0020d310, 0x0020f310, 
  1885| 	0x00211310, 0x00213310, 0x00215310, 0x00217310, 
  1886| 	0x00219310, 0x0021b310, 0x0021d310, 0x0021f310, 
  1887| 	0x00221310, 0x00223310, 0x00225310, 0x00227310, 
  1888| 	0x00229310, 0x0022b310, 0x0022d310, 0x0022f310, 
  1889| 	0x00231310, 0x00233310, 0x00235310, 0x00237310, 
  1890| 	0x00239310, 0x0023b310, 0x0023d310, 0x0023f310, 
  1891| 	0x00241310, 0x00243310, 0x00245310, 0x00247310, 
  1892| 	0x00249310, 0x0024b310, 0x0024d310, 0x0024f310, 
  1893| 	0x00251310, 0x00253310, 0x00255310, 0x00257310, 
  1894| 	0x00259310, 0x0025b310, 0x0025d310, 0x0025f310, 
  1895| 	0x00261310, 0x00263310, 0x00265310, 0x00267310, 
  1896| 	0x00269310, 0x0026b310, 0x0026d310, 0x0026f310, 
  1897| 	0x00271310, 0x00273310, 0x00275310, 0x00277310, 
  1898| 	0x00279310, 0x0027b310, 0x0027d310, 0x0027f310, 
  1899| 	0x00281310, 0x00283310, 0x00285310, 0x00287310, 
  1900| 	0x00289310, 0x0028b310, 0x0028d310, 0x0028f310, 
  1901| 	0x00291310, 0x00293310, 0x00295310, 0x00297310, 
  1902| 	0x00299310, 0x0029b310, 0x0029d310, 0x0029f310, 
  1903| 	0x002a1310, 0x002a3310, 0x002a5310, 0x002a7310, 
  1904| 	0x002a9310, 0x002ab310, 0x002ad310, 0x002af310, 
  1905| 	0x002b1310, 0x002b3310, 0x002b5310, 0x002b7310, 
  1906| 	0x002b9310, 0x002bb310, 0x002bd310, 0x002bf310, 
  1907| 	0x002c1310, 0x002c3310, 0x002c5310, 0x002c7310, 
  1908| 	0x002c9310, 0x002cb310, 0x002cd310, 0x002cf310, 
  1909| 	0x002d1310, 0x002d3310, 0x002d5310, 0x002d7310, 
  1910| 	0x002d9310, 0x002db310, 0x002dd310, 0x002df310, 
  1911| 	0x002e1310, 0x002e3310, 0x002e5310, 0x002e7310, 
  1912| 	0x002e9310, 0x002eb310, 0x002ed310, 0x002ef310, 
  1913| 	0x002f1310, 0x002f3310, 0x002f5310, 0x002f7310, 
  1914| 	0x002f9310, 0x002fb310, 0x002fd310, 0x002ff310, 
  1915| 	0x00301310, 0x00303310, 0x00305310, 0x00307310, 
  1916| 	0x00309310, 0x0030b310, 0x0030d310, 0x0030f310, 
  1917| 	0x00311310, 0x00313310, 0x00315310, 0x00317310, 
  1918| 	0x00319310, 0x0031b310, 0x0031d310, 0x0031f310, 
  1919| 	0x00321310, 0x00323310, 0x00325310, 0x00327310, 
  1920| 	0x00329310, 0x0032b310, 0x0032d310, 0x0032f310, 
  1921| 	0x00331310, 0x00333310, 0x00335310, 0x00337310, 
  1922| 	0x00339310, 0x0033b310, 0x0033d310, 0x0033f310, 
  1923| 	0x00341310, 0x00343310, 0x00345310, 0x00347310, 
  1924| 	0x00349310, 0x0034b310, 0x0034d310, 0x0034f310, 
  1925| 	0x00351310, 0x00353310, 0x00355310, 0x00357310, 
  1926| 	0x00359310, 0x0035b310, 0x0035d310, 0x0035f310, 
  1927| 	0x00361310, 0x00363310, 0x00365310, 0x00367310, 
  1928| 	0x00369310, 0x0036b310, 0x0036d310, 0x0036f310, 
  1929| 	0x00371310, 0x00373310, 0x00375310, 0x00377310, 
  1930| 	0x00379310, 0x0037b310, 0x0037d310, 0x0037f310, 
  1931| 	0x00381310, 0x00383310, 0x00385310, 0x00387310, 
  1932| 	0x00389310, 0x0038b310, 0x0038d310, 0x0038f310, 
  1933| 	0x00391310, 0x00393310, 0x00395310, 0x00397310, 
  1934| 	0x00399310, 0x0039b310, 0x0039d310, 0x0039f310, 
  1935| 	0x003a1310, 0x003a3310, 0x003a5310, 0x003a7310, 
  1936| 	0x003a9310, 0x003ab310, 0x003ad310, 0x003af310, 
  1937| 	0x003b1310, 0x003b3310, 0x003b5310, 0x003b7310, 
  1938| 	0x003b9310, 0x003bb310, 0x003bd310, 0x003bf310, 
  1939| 	0x003c1310, 0x003c3310, 0x003c5310, 0x003c7310, 
  1940| 	0x003c9310, 0x003cb310, 0x003cd310, 0x003cf310, 
  1941| 	0x003d1310, 0x003d3310, 0x003d5310, 0x003d7310, 
  1942| 	0x003d9310, 0x003db310, 0x003dd310, 0x003df310, 
  1943| 	0x003e1310, 0x003e3310, 0x003e5310, 0x003e7310, 
  1944| 	0x003e9310, 0x003eb310, 0x003ed310, 0x003ef310, 
  1945| 	0x003f1310, 0x003f3310, 0x003f5310, 0x003f7310, 
  1946| 	0x003f9310, 0x003fb310, 0x003fd310, 0x003ff310, 
  1947| 	0x00401310, 0x00403310, 0x00405310, 0x00407310, 
  1948| 	0x00409310, 0x0040b310, 0x0040d310, 0x0040f310, 
  1949| 	0x00411310, 0x00413310, 0x00415310, 0x00417310, 
  1950| 	0x00419310, 0x0041b310, 0x0041d310, 0x0041f310, 
  1951| 	0x00421310, 0x00423310, 0x00425310, 0x00427310, 
  1952| 	0x00429310, 0x0042b310, 0x0042d310, 0x0042f310, 
  1953| 	0x00431310, 0x00433310, 0x00435310, 0x00437310, 
  1954| 	0x00439310, 0x0043b310, 0x0043d310, 0x0043f310, 
  1955| 	0x00441310, 0x00443310, 0x00445310, 0x00447310, 
  1956| 	0x00449310, 0x0044b310, 0x0044d310, 0x0044f310, 
  1957| 	0x00451310, 0x00453310, 0x00455310, 0x00457310, 
  1958| 	0x00459310, 0x0045b310, 0x0045d310, 0x0045f310, 
  1959| 	0x00461310, 0x00463310, 0x00465310, 0x00467310, 
  1960| 	0x00469310, 0x0046b310, 0x0046d310, 0x0046f310, 
  1961| 	0x00471310, 0x00473310, 0x00475310, 0x00477310, 
  1962| 	0x00479310, 0x0047b310, 0x0047d310, 0x0047f310, 
  1963| 	0x00481310, 0x00483310, 0x00485310, 0x00487310, 
  1964| 	0x00489310, 0x0048b310, 0x0048d310, 0x0048f310, 
  1965| 	0x00491310, 0x00493310, 0x00495310, 0x00497310, 
  1966| 	0x00499310, 0x0049b310, 0x0049d310, 0x0049f310, 
  1967| 	0x004a1310, 0x004a3310, 0x004a5310, 0x004a7310, 
  1968| 	0x004a9310, 0x004ab310, 0x004ad310, 0x004af310, 
  1969| 	0x004b1310, 0x004b3310, 0x004b5310, 0x004b7310, 
  1970| 	0x004b9310, 0x004bb310, 0x004bd310, 0x004bf310, 
  1971| 	0x004c1310, 0x004c3310, 0x004c5310, 0x004c7310, 
  1972| 	0x004c9310, 0x004cb310, 0x004cd310, 0x004cf310, 
  1973| 	0x004d1310, 0x004d3310, 0x004d5310, 0x004d7310, 
  1974| 	0x004d9310, 0x004db310, 0x004dd310, 0x004df310, 
  1975| 	0x004e1310, 0x004e3310, 0x004e5310, 0x004e7310, 
  1976| 	0x004e9310, 0x004eb310, 0x004ed310, 0x004ef310, 
  1977| 	0x004f1310, 0x004f3310, 0x004f5310, 0x004f7310, 
  1978| 	0x004f9310, 0x004fb310, 0x004fd310, 0x004ff310, 
  1979| 	0x00501310, 0x00503310, 0x00505310, 0x00507310, 
  1980| 	0x00509310, 0x0050b310, 0x0050d310, 0x0050f310, 
  1981| 	0x00511310, 0x00513310, 0x00515310, 0x00517310, 
  1982| 	0x00519310, 0x0051b310, 0x0051d310, 0x0051f310, 
  1983| 	0x00521310, 0x00523310, 0x00525310, 0x00527310, 
  1984| 	0x00529310, 0x0052b310, 0x0052d310, 0x0052f310, 
  1985| 	0x00531310, 0x00533310, 0x00535310, 0x00537310, 
  1986| 	0x00539310, 0x0053b310, 0x0053d310, 0x0053f310, 
  1987| 	0x00541310, 0x00543310, 0x00545310, 0x00547310, 
  1988| 	0x00549310, 0x0054b310, 0x0054d310, 0x0054f310, 
  1989| 	0x00551310, 0x00553310, 0x00555310, 0x00557310, 
  1990| 	0x00559310, 0x0055b310, 0x0055d310, 0x0055f310, 
  1991| 	0x00561310, 0x00563310, 0x00565310, 0x00567310, 
  1992| 	0x00569310, 0x0056b310, 0x0056d310, 0x0056f310, 
  1993| 	0x00571310, 0x00573310, 0x00575310, 0x00577310, 
  1994| 	0x00579310, 0x0057b310, 0x0057d310, 0x0057f310, 
  1995| 	0x00581310, 0x00583310, 0x00585310, 0x00587310, 
  1996| 	0x00589310, 0x0058b310, 0x0058d310, 0x0058f310, 
  1997| 	0x00591310, 0x00593310, 0x00595310, 0x00597310, 
  1998| 	0x00599310, 0x0059b310, 0x0059d310, 0x0059f310, 
  1999| 	0x005a1310, 0x005a3310, 0x005a5310, 0x005a7310, 
  2000| 	0x005a9310, 0x005ab310, 0x005ad310, 0x005af310, 
  2001| 	0x005b1310, 0x005b3310, 0x005b5310, 0x005b7310, 
  2002| 	0x005b9310, 0x005bb310, 0x005bd310, 0x005bf310, 
  2003| 	0x005c1310, 0x005c3310, 0x005c5310, 0x005c7310, 
  2004| 	0x005c9310, 0x005cb310, 0x005cd310, 0x005cf310, 
  2005| 	0x005d1310, 0x005d3310, 0x005d5310, 0x005d7310, 
  2006| 	0x005d9310, 0x005db310, 0x005dd310, 0x005df310, 
  2007| 	0x005e1310, 0x005e3310, 0x005e5310, 0x005e7310, 
  2008| 	0x005e9310, 0x005eb310, 0x005ed310, 0x005ef310, 
  2009| 	0x005f1310, 0x005f3310, 0x005f5310, 0x005f7310, 
  2010| 	0x005f9310, 0x005fb310, 0x005fd310, 0x005ff310, 
  2011| 	0x00601310, 0x00603310, 0x00605310, 0x00607310, 
  2012| 	0x00609310, 0x0060b310, 0x0060d310, 0x0060f310, 
  2013| 	0x00611310, 0x00613310, 0x00615310, 0x00617310, 
  2014| 	0x00619310, 0x0061b310, 0x0061d310, 0x0061f310, 
  2015| 	0x00621310, 0x00623310, 0x00625310, 0x00627310, 
  2016| 	0x00629310, 0x0062b310, 0x0062d310, 0x0062f310, 
  2017| 	0x00631310, 0x00633310, 0x00635310, 0x00637310, 
  2018| 	0x00639310, 0x0063b310, 0x0063d310, 0x0063f310, 
  2019| 	0x00641310, 0x00643310, 0x00645310, 0x00647310, 
  2020| 	0x00649310, 0x0064b310, 0x0064d310, 0x0064f310, 
  2021| 	0x00651310, 0x00653310, 0x00655310, 0x00657310, 
  2022| 	0x00659310, 0x0065b310, 0x0065d310, 0x0065f310, 
  2023| 	0x00661310, 0x00663310, 0x00665310, 0x00667310, 
  2024| 	0x00669310, 0x0066b310, 0x0066d310, 0x0066f310, 
  2025| 	0x00671310, 0x00673310, 0x00675310, 0x00677310, 
  2026| 	0x00679310, 0x0067b310, 0x0067d310, 0x0067f310, 
  2027| 	0x00681310, 0x00683310, 0x00685310, 0x00687310, 
  2028| 	0x00689310, 0x0068b310, 0x0068d310, 0x0068f310, 
  2029| 	0x00691310, 0x00693310, 0x00695310, 0x00697310, 
  2030| 	0x00699310, 0x0069b310, 0x0069d310, 0x0069f310, 
  2031| 	0x006a1310, 0x006a3310, 0x006a5310, 0x006a7310, 
  2032| 	0x006a9310, 0x006ab310, 0x006ad310, 0x006af310, 
  2033| 	0x006b1310, 0x006b3310, 0x006b5310, 0x006b7310, 
  2034| 	0x006b9310, 0x006bb310, 0x006bd310, 0x006bf310, 
  2035| 	0x006c1310, 0x006c3310, 0x006c5310, 0x006c7310, 
  2036| 	0x006c9310, 0x006cb310, 0x006cd310, 0x006cf310, 
  2037| 	0x006d1310, 0x006d3310, 0x006d5310, 0x006d7310, 
  2038| 	0x006d9310, 0x006db310, 0x006dd310, 0x006df310, 
  2039| 	0x006e1310, 0x006e3310, 0x006e5310, 0x006e7310, 
  2040| 	0x006e9310, 0x006eb310, 0x006ed310, 0x006ef310, 
  2041| 	0x006f1310, 0x006f3310, 0x006f5310, 0x006f7310, 
  2042| 	0x006f9310, 0x006fb310, 0x006fd310, 0x006ff310, 
  2043| 	0x00701310, 0x00703310, 0x00705310, 0x00707310, 
  2044| 	0x00709310, 0x0070b310, 0x0070d310, 0x0070f310, 
  2045| 	0x00711310, 0x00713310, 0x00715310, 0x00717310, 
  2046| 	0x00719310, 0x0071b310, 0x0071d310, 0x0071f310, 
  2047| 	0x00721310, 0x00723310, 0x00725310, 0x00727310, 
  2048| 	0x00729310, 0x0072b310, 0x0072d310, 0x0072f310, 
  2049| 	0x00731310, 0x00733310, 0x00735310, 0x00737310, 
  2050| 	0x00739310, 0x0073b310, 0x0073d310, 0x0073f310, 
  2051| 	0x00741310, 0x00743310, 0x00745310, 0x00747310, 
  2052| 	0x00749310, 0x0074b310, 0x0074d310, 0x0074f310, 
  2053| 	0x00751310, 0x00753310, 0x00755310, 0x00757310, 
  2054| 	0x00759310, 0x0075b310, 0x0075d310, 0x0075f310, 
  2055| 	0x00761310, 0x00763310, 0x00765310, 0x00767310, 
  2056| 	0x00769310, 0x0076b310, 0x0076d310, 0x0076f310, 
  2057| 	0x00771310, 0x00773310, 0x00775310, 0x00777310, 
  2058| 	0x00779310, 0x0077b310, 0x0077d310, 0x0077f310, 
  2059| 	0x00781310, 0x00783310, 0x00785310, 0x00787310, 
  2060| 	0x00789310, 0x0078b310, 0x0078d310, 0x0078f310, 
  2061| 	0x00791310, 0x00793310, 0x00795310, 0x00797310, 
  2062| 	0x00799310, 0x0079b310, 0x0079d310, 0x0079f310, 
  2063| 	0x007a1310, 0x007a3310, 0x007a5310, 0x007a7310, 
  2064| 	0x007a9310, 0x007ab310, 0x007ad310, 0x007af310, 
  2065| 	0x007b1310, 0x007b3310, 0x007b5310, 0x007b7310, 
  2066| 	0x007b9310, 0x007bb310, 0x007bd310, 0x007bf310, 
  2067| 	0x007c1310, 0x007c3310, 0x007c5310, 0x007c7310, 
  2068| 	0x007c9310, 0x007cb310, 0x007cd310, 0x007cf310, 
  2069| 	0x007d1310, 0x007d3310, 0x007d5310, 0x007d7310, 
  2070| 	0x007d9310, 0x007db310, 0x007dd310, 0x007df310, 
  2071| 	0x007e1310, 0x007e3310, 0x007e5310, 0x007e7310, 
  2072| 	0x007e9310, 0x007eb310, 0x007ed310, 0x007ef310, 
  2073| 	0x007f1310, 0x007f3310, 0x007f5310, 0x007f7310, 
  2074| 	0x007f9310, 0x007fb310, 0x007fd310, 0x007ff310, 
  2075| 	0x00801310, 0x00803310, 0x00805310, 0x00807310, 
  2076| 	0x00809310, 0x0080b310, 0x0080d310, 0x0080f310, 
  2077| 	0x00811310, 0x00813310, 0x00815310, 0x00817310, 
  2078| 	0x00819310, 0x0081b310, 0x0081d310, 0x0081f310, 
  2079| 	0x00821310, 0x00823310, 0x00825310, 0x00827310, 
  2080| 	0x00829310, 0x0082b310, 0x0082d310, 0x0082f310, 
  2081| 	0x00831310, 0x00833310, 0x00835310, 0x00837310, 
  2082| 	0x00839310, 0x0083b310, 0x0083d310, 0x0083f310, 
  2083| 	0x00841310, 0x00843310, 0x00845310, 0x00847310, 
  2084| 	0x00849310, 0x0084b310, 0x0084d310, 0x0084f310, 
  2085| 	0x00851310, 0x00853310, 0x00855310, 0x00857310, 
  2086| 	0x00859310, 0x0085b310, 0x0085d310, 0x0085f310, 
  2087| 	0x00861310, 0x00863310, 0x00865310, 0x00867310, 
  2088| 	0x00869310, 0x0086b310, 0x0086d310, 0x0086f310, 
  2089| 	0x00871310, 0x00873310, 0x00875310, 0x00877310, 
  2090| 	0x00879310, 0x0087b310, 0x0087d310, 0x0087f310, 
  2091| 	0x00881310, 0x00883310, 0x00885310, 0x00887310, 
  2092| 	0x00889310, 0x0088b310, 0x0088d310, 0x0088f310, 
  2093| 	0x00891310, 0x00893310, 0x00895310, 0x00897310, 
  2094| 	0x00899310, 0x0089b310, 0x0089d310, 0x0089f310, 
  2095| 	0x008a1310, 0x008a3310, 0x008a5310, 0x008a7310, 
  2096| 	0x008a9310, 0x008ab310, 0x008ad310, 0x008af310, 
  2097| 	0x008b1310, 0x008b3310, 0x008b5310, 0x008b7310, 
  2098| 	0x008b9310, 0x008bb310, 0x008bd310, 0x008bf310, 
  2099| 	0x008c1310, 0x008c3310, 0x008c5310, 0x008c7310, 
  2100| 	0x008c9310, 0x008cb310, 0x008cd310, 0x008cf310, 
  2101| 	0x008d1310, 0x008d3310, 0x008d5310, 0x008d7310, 
  2102| 	0x008d9310, 0x008db310, 0x008dd310, 0x008df310, 
  2103| 	0x008e1310, 0x008e3310, 0x008e5310, 0x008e7310, 
  2104| 	0x008e9310, 0x008eb310, 0x008ed310, 0x008ef310, 
  2105| 	0x008f1310, 0x008f3310, 0x008f5310, 0x008f7310, 
  2106| 	0x008f9310, 0x008fb310, 0x008fd310, 0x008ff310, 
  2107| 	0x00901310, 0x00903310, 0x00905310, 0x00907310, 
  2108| 	0x00909310, 0x0090b310, 0x0090d310, 0x0090f310, 
  2109| 	0x00911310, 0x00913310, 0x00915310, 0x00917310, 
  2110| 	0x00919310, 0x0091b310, 0x0091d310, 0x0091f310, 
  2111| 	0x00921310, 0x00923310, 0x00925310, 0x00927310, 
  2112| 	0x00929310, 0x0092b310, 0x0092d310, 0x0092f310, 
  2113| 	0x00931310, 0x00933310, 0x00935310, 0x00937310, 
  2114| 	0x00939310, 0x0093b310, 0x0093d310, 0x0093f310, 
  2115| 	0x00941310, 0x00943310, 0x00945310, 0x00947310, 
  2116| 	0x00949310, 0x0094b310, 0x0094d310, 0x0094f310, 
  2117| 	0x00951310, 0x00953310, 0x00955310, 0x00957310, 
  2118| 	0x00959310, 0x0095b310, 0x0095d310, 0x0095f310, 
  2119| 	0x00961310, 0x00963310, 0x00965310, 0x00967310, 
  2120| 	0x00969310, 0x0096b310, 0x0096d310, 0x0096f310, 
  2121| 	0x00971310, 0x00973310, 0x00975310, 0x00977310, 
  2122| 	0x00979310, 0x0097b310, 0x0097d310, 0x0097f310, 
  2123| 	0x00981310, 0x00983310, 0x00985310, 0x00987310, 
  2124| 	0x00989310, 0x0098b310, 0x0098d310, 0x0098f310, 
  2125| 	0x00991310, 0x00993310, 0x00995310, 0x00997310, 
  2126| 	0x00999310, 0x0099b310, 0x0099d310, 0x0099f310, 
  2127| 	0x009a1310, 0x009a3310, 0x009a5310, 0x009a7310, 
  2128| 	0x009a9310, 0x009ab310, 0x009ad310, 0x009af310, 
  2129| 	0x009b1310, 0x009b3310, 0x009b5310, 0x009b7310, 
  2130| 	0x009b9310, 0x009bb310, 0x009bd310, 0x009bf310, 
  2131| 	0x009c1310, 0x009c3310, 0x009c5310, 0x009c7310, 
  2132| 	0x009c9310, 0x009cb310, 0x009cd310, 0x009cf310, 
  2133| 	0x009d1310, 0x009d3310, 0x009d5310, 0x009d7310, 
  2134| 	0x009d9310, 0x009db310, 0x009dd310, 0x009df310, 
  2135| 	0x009e1310, 0x009e3310, 0x009e5310, 0x009e7310, 
  2136| 	0x009e9310, 0x009eb310, 0x009ed310, 0x009ef310, 
  2137| 	0x009f1310, 0x009f3310, 0x009f5310, 0x009f7310, 
  2138| 	0x009f9310, 0x009fb310, 0x009fd310, 0x009ff310, 
  2139| 	0x00a01310, 0x00a03310, 0x00a05310, 0x00a07310, 
  2140| 	0x00a09310, 0x00a0b310, 0x00a0d310, 0x00a0f310, 
  2141| 	0x00a11310, 0x00a13310, 0x00a15310, 0x00a17310, 
  2142| 	0x00a19310, 0x00a1b310, 0x00a1d310, 0x00a1f310, 
  2143| 	0x00a21310, 0x00a23310, 0x00a25310, 0x00a27310, 
  2144| 	0x00a29310, 0x00a2b310, 0x00a2d310, 0x00a2f310, 
  2145| 	0x00a31310, 0x00a33310, 0x00a35310, 0x00a37310, 
  2146| 	0x00a39310, 0x00a3b310, 0x00a3d310, 0x00a3f310, 
  2147| 	0x00a41310, 0x00a43310, 0x00a45310, 0x00a47310, 
  2148| 	0x00a49310, 0x00a4b310, 0x00a4d310, 0x00a4f310, 
  2149| 	0x00a51310, 0x00a53310, 0x00a55310, 0x00a57310, 
  2150| 	0x00a59310, 0x00a5b310, 0x00a5d310, 0x00a5f310, 
  2151| 	0x00a61310, 0x00a63310, 0x00a65310, 0x00a67310, 
  2152| 	0x00a69310, 0x00a6b310, 0x00a6d310, 0x00a6f310, 
  2153| 	0x00a71310, 0x00a73310, 0x00a75310, 0x00a77310, 
  2154| 	0x00a79310, 0x00a7b310, 0x00a7d310, 0x00a7f310, 
  2155| 	0x00a81310, 0x00a83310, 0x00a85310, 0x00a87310, 
  2156| 	0x00a89310, 0x00a8b310, 0x00a8d310, 0x00a8f310, 
  2157| 	0x00a91310, 0x00a93310, 0x00a95310, 0x00a97310, 
  2158| 	0x00a99310, 0x00a9b310, 0x00a9d310, 0x00a9f310, 
  2159| 	0x00aa1310, 0x00aa3310, 0x00aa5310, 0x00aa7310, 
  2160| 	0x00aa9310, 0x00aab310, 0x00aad310, 0x00aaf310, 
  2161| 	0x00ab1310, 0x00ab3310, 0x00ab5310, 0x00ab7310, 
  2162| 	0x00ab9310, 0x00abb310, 0x00abd310, 0x00abf310, 
  2163| 	0x00ac1310, 0x00ac3310, 0x00ac5310, 0x00ac7310, 
  2164| 	0x00ac9310, 0x00acb310, 0x00acd310, 0x00acf310, 
  2165| 	0x00ad1310, 0x00ad3310, 0x00ad5310, 0x00ad7310, 
  2166| 	0x00ad9310, 0x00adb310, 0x00add310, 0x00adf310, 
  2167| 	0x00ae1310, 0x00ae3310, 0x00ae5310, 0x00ae7310, 
  2168| 	0x00ae9310, 0x00aeb310, 0x00aed310, 0x00aef310, 
  2169| 	0x00af1310, 0x00af3310, 0x00af5310, 0x00af7310, 
  2170| 	0x00af9310, 0x00afb310, 0x00afd310, 0x00aff310, 
  2171| 	0x00b01310, 0x00b03310, 0x00b05310, 0x00b07310, 
  2172| 	0x00b09310, 0x00b0b310, 0x00b0d310, 0x00b0f310, 
  2173| 	0x00b11310, 0x00b13310, 0x00b15310, 0x00b17310, 
  2174| 	0x00b19310, 0x00b1b310, 0x00b1d310, 0x00b1f310, 
  2175| 	0x00b21310, 0x00b23310, 0x00b25310, 0x00b27310, 
  2176| 	0x00b29310, 0x00b2b310, 0x00b2d310, 0x00b2f310, 
  2177| 	0x00b31310, 0x00b33310, 0x00b35310, 0x00b37310, 
  2178| 	0x00b39310, 0x00b3b310, 0x00b3d310, 0x00b3f310, 
  2179| 	0x00b41310, 0x00b43310, 0x00b45310, 0x00b47310, 
  2180| 	0x00b49310, 0x00b4b310, 0x00b4d310, 0x00b4f310, 
  2181| 	0x00b51310, 0x00b53310, 0x00b55310, 0x00b57310, 
  2182| 	0x00b59310, 0x00b5b310, 0x00b5d310, 0x00b5f310, 
  2183| 	0x00b61310, 0x00b63310, 0x00b65310, 0x00b67310, 
  2184| 	0x00b69310, 0x00b6b310, 0x00b6d310, 0x00b6f310, 
  2185| 	0x00b71310, 0x00b73310, 0x00b75310, 0x00b77310, 
  2186| 	0x00b79310, 0x00b7b310, 0x00b7d310, 0x00b7f310, 
  2187| 	0x00b81310, 0x00b83310, 0x00b85310, 0x00b87310, 
  2188| 	0x00b89310, 0x00b8b310, 0x00b8d310, 0x00b8f310, 
  2189| 	0x00b91310, 0x00b93310, 0x00b95310, 0x00b97310, 
  2190| 	0x00b99310, 0x00b9b310, 0x00b9d310, 0x00b9f310, 
  2191| 	0x00ba1310, 0x00ba3310, 0x00ba5310, 0x00ba7310, 
  2192| 	0x00ba9310, 0x00bab310, 0x00bad310, 0x00baf310, 
  2193| 	0x00bb1310, 0x00bb3310, 0x00bb5310, 0x00bb7310, 
  2194| 	0x00bb9310, 0x00bbb310, 0x00bbd310, 0x00bbf310, 
  2195| 	0x00bc1310, 0x00bc3310, 0x00bc5310, 0x00bc7310, 
  2196| 	0x00bc9310, 0x00bcb310, 0x00bcd310, 0x00bcf310, 
  2197| 	0x00bd1310, 0x00bd3310, 0x00bd5310, 0x00bd7310, 
  2198| 	0x00bd9310, 0x00bdb310, 0x00bdd310, 0x00bdf310, 
  2199| 	0x00be1310, 0x00be3310, 0x00be5310, 0x00be7310, 
  2200| 	0x00be9310, 0x00beb310, 0x00bed310, 0x00bef310, 
  2201| 	0x00bf1310, 0x00bf3310, 0x00bf5310, 0x00bf7310, 
  2202| 	0x00bf9310, 0x00bfb310, 0x00bfd310, 0x00bff310, 
  2203| 	0x00c01310, 0x00c03310, 0x00c05310, 0x00c07310, 
  2204| 	0x00c09310, 0x00c0b310, 0x00c0d310, 0x00c0f310, 
  2205| 	0x00c11310, 0x00c13310, 0x00c15310, 0x00c17310, 
  2206| 	0x00c19310, 0x00c1b310, 0x00c1d310, 0x00c1f310, 
  2207| 	0x00c21310, 0x00c23310, 0x00c25310, 0x00c27310, 
  2208| 	0x00c29310, 0x00c2b310, 0x00c2d310, 0x00c2f310, 
  2209| 	0x00c31310, 0x00c33310, 0x00c35310, 0x00c37310, 
  2210| 	0x00c39310, 0x00c3b310, 0x00c3d310, 0x00c3f310, 
  2211| 	0x00c41310, 0x00c43310, 0x00c45310, 0x00c47310, 
  2212| 	0x00c49310, 0x00c4b310, 0x00c4d310, 0x00c4f310, 
  2213| 	0x00c51310, 0x00c53310, 0x00c55310, 0x00c57310, 
  2214| 	0x00c59310, 0x00c5b310, 0x00c5d310, 0x00c5f310, 
  2215| 	0x00c61310, 0x00c63310, 0x00c65310, 0x00c67310, 
  2216| 	0x00c69310, 0x00c6b310, 0x00c6d310, 0x00c6f310, 
  2217| 	0x00c71310, 0x00c73310, 0x00c75310, 0x00c77310, 
  2218| 	0x00c79310, 0x00c7b310, 0x00c7d310, 0x00c7f310, 
  2219| 	0x00c81310, 0x00c83310, 0x00c85310, 0x00c87310, 
  2220| 	0x00c89310, 0x00c8b310, 0x00c8d310, 0x00c8f310, 
  2221| 	0x00c91310, 0x00c93310, 0x00c95310, 0x00c97310, 
  2222| 	0x00c99310, 0x00c9b310, 0x00c9d310, 0x00c9f310, 
  2223| 	0x00ca1310, 0x00ca3310, 0x00ca5310, 0x00ca7310, 
  2224| 	0x00ca9310, 0x00cab310, 0x00cad310, 0x00caf310, 
  2225| 	0x00cb1310, 0x00cb3310, 0x00cb5310, 0x00cb7310, 
  2226| 	0x00cb9310, 0x00cbb310, 0x00cbd310, 0x00cbf310, 
  2227| 	0x00cc1310, 0x00cc3310, 0x00cc5310, 0x00cc7310, 
  2228| 	0x00cc9310, 0x00ccb310, 0x00ccd310, 0x00ccf310, 
  2229| 	0x00cd1310, 0x00cd3310, 0x00cd5310, 0x00cd7310, 
  2230| 	0x00cd9310, 0x00cdb310, 0x00cdd310, 0x00cdf310, 
  2231| 	0x00ce1310, 0x00ce3310, 0x00ce5310, 0x00ce7310, 
  2232| 	0x00ce9310, 0x00ceb310, 0x00ced310, 0x00cef310, 
  2233| 	0x00cf1310, 0x00cf3310, 0x00cf5310, 0x00cf7310, 
  2234| 	0x00cf9310, 0x00cfb310, 0x00cfd310, 0x00cff310, 
  2235| 	0x00d01310, 0x00d03310, 0x00d05310, 0x00d07310, 
  2236| 	0x00d09310, 0x00d0b310, 0x00d0d310, 0x00d0f310, 
  2237| 	0x00d11310, 0x00d13310, 0x00d15310, 0x00d17310, 
  2238| 	0x00d19310, 0x00d1b310, 0x00d1d310, 0x00d1f310, 
  2239| 	0x00d21310, 0x00d23310, 0x00d25310, 0x00d27310, 
  2240| 	0x00d29310, 0x00d2b310, 0x00d2d310, 0x00d2f310, 
  2241| 	0x00d31310, 0x00d33310, 0x00d35310, 0x00d37310, 
  2242| 	0x00d39310, 0x00d3b310, 0x00d3d310, 0x00d3f310, 
  2243| 	0x00d41310, 0x00d43310, 0x00d45310, 0x00d47310, 
  2244| 	0x00d49310, 0x00d4b310, 0x00d4d310, 0x00d4f310, 
  2245| 	0x00d51310, 0x00d53310, 0x00d55310, 0x00d57310, 
  2246| 	0x00d59310, 0x00d5b310, 0x00d5d310, 0x00d5f310, 
  2247| 	0x00d61310, 0x00d63310, 0x00d65310, 0x00d67310, 
  2248| 	0x00d69310, 0x00d6b310, 0x00d6d310, 0x00d6f310, 
  2249| 	0x00d71310, 0x00d73310, 0x00d75310, 0x00d77310, 
  2250| 	0x00d79310, 0x00d7b310, 0x00d7d310, 0x00d7f310, 
  2251| 	0x00d81310, 0x00d83310, 0x00d85310, 0x00d87310, 
  2252| 	0x00d89310, 0x00d8b310, 0x00d8d310, 0x00d8f310, 
  2253| 	0x00d91310, 0x00d93310, 0x00d95310, 0x00d97310, 
  2254| 	0x00d99310, 0x00d9b310, 0x00d9d310, 0x00d9f310, 
  2255| 	0x00da1310, 0x00da3310, 0x00da5310, 0x00da7310, 
  2256| 	0x00da9310, 0x00dab310, 0x00dad310, 0x00daf310, 
  2257| 	0x00db1310, 0x00db3310, 0x00db5310, 0x00db7310, 
  2258| 	0x00db9310, 0x00dbb310, 0x00dbd310, 0x00dbf310, 
  2259| 	0x00dc1310, 0x00dc3310, 0x00dc5310, 0x00dc7310, 
  2260| 	0x00dc9310, 0x00dcb310, 0x00dcd310, 0x00dcf310, 
  2261| 	0x00dd1310, 0x00dd3310, 0x00dd5310, 0x00dd7310, 
  2262| 	0x00dd9310, 0x00ddb310, 0x00ddd310, 0x00ddf310, 
  2263| 	0x00de1310, 0x00de3310, 0x00de5310, 0x00de7310, 
  2264| 	0x00de9310, 0x00deb310, 0x00ded310, 0x00def310, 
  2265| 	0x00df1310, 0x00df3310, 0x00df5310, 0x00df7310, 
  2266| 	0x00df9310, 0x00dfb310, 0x00dfd310, 0x00dff310, 
  2267| 	0x00e01310, 0x00e03310, 0x00e05310, 0x00e07310, 
  2268| 	0x00e09310, 0x00e0b310, 0x00e0d310, 0x00e0f310, 
  2269| 	0x00e11310, 0x00e13310, 0x00e15310, 0x00e17310, 
  2270| 	0x00e19310, 0x00e1b310, 0x00e1d310, 0x00e1f310, 
  2271| 	0x00e21310, 0x00e23310, 0x00e25310, 0x00e27310, 
  2272| 	0x00e29310, 0x00e2b310, 0x00e2d310, 0x00e2f310, 
  2273| 	0x00e31310, 0x00e33310, 0x00e35310, 0x00e37310, 
  2274| 	0x00e39310, 0x00e3b310, 0x00e3d310, 0x00e3f310, 
  2275| 	0x00e41310, 0x00e43310, 0x00e45310, 0x00e47310, 
  2276| 	0x00e49310, 0x00e4b310, 0x00e4d310, 0x00e4f310, 
  2277| 	0x00e51310, 0x00e53310, 0x00e55310, 0x00e57310, 
  2278| 	0x00e59310, 0x00e5b310, 0x00e5d310, 0x00e5f310, 
  2279| 	0x00e61310, 0x00e63310, 0x00e65310, 0x00e67310, 
  2280| 	0x00e69310, 0x00e6b310, 0x00e6d310, 0x00e6f310, 
  2281| 	0x00e71310, 0x00e73310, 0x00e75310, 0x00e77310, 
  2282| 	0x00e79310, 0x00e7b310, 0x00e7d310, 0x00e7f310, 
  2283| 	0x00e81310, 0x00e83310, 0x00e85310, 0x00e87310, 
  2284| 	0x00e89310, 0x00e8b310, 0x00e8d310, 0x00e8f310, 
  2285| 	0x00e91310, 0x00e93310, 0x00e95310, 0x00e97310, 
  2286| 	0x00e99310, 0x00e9b310, 0x00e9d310, 0x00e9f310, 
  2287| 	0x00ea1310, 0x00ea3310, 0x00ea5310, 0x00ea7310, 
  2288| 	0x00ea9310, 0x00eab310, 0x00ead310, 0x00eaf310, 
  2289| 	0x00eb1310, 0x00eb3310, 0x00eb5310, 0x00eb7310, 
  2290| 	0x00eb9310, 0x00ebb310, 0x00ebd310, 0x00ebf310, 
  2291| 	0x00ec1310, 0x00ec3310, 0x00ec5310, 0x00ec7310, 
  2292| 	0x00ec9310, 0x00ecb310, 0x00ecd310, 0x00ecf310, 
  2293| 	0x00ed1310, 0x00ed3310, 0x00ed5310, 0x00ed7310, 
  2294| 	0x00ed9310, 0x00edb310, 0x00edd310, 0x00edf310, 
  2295| 	0x00ee1310, 0x00ee3310, 0x00ee5310, 0x00ee7310, 
  2296| 	0x00ee9310, 0x00eeb310, 0x00eed310, 0x00eef310, 
  2297| 	0x00ef1310, 0x00ef3310, 0x00ef5310, 0x00ef7310, 
  2298| 	0x00ef9310, 0x00efb310, 0x00efd310, 0x00eff310, 
  2299| 	0x00f01310, 0x00f03310, 0x00f05310, 0x00f07310, 
  2300| 	0x00f09310, 0x00f0b310, 0x00f0d310, 0x00f0f310, 
  2301| 	0x00f11310, 0x00f13310, 0x00f15310, 0x00f17310, 
  2302| 	0x00f19310, 0x00f1b310, 0x00f1d310, 0x00f1f310, 
  2303| 	0x00f21310, 0x00f23310, 0x00f25310, 0x00f27310, 
  2304| 	0x00f29310, 0x00f2b310, 0x00f2d310, 0x00f2f310, 
  2305| 	0x00f31310, 0x00f33310, 0x00f35310, 0x00f37310, 
  2306| 	0x00f39310, 0x00f3b310, 0x00f3d310, 0x00f3f310, 
  2307| 	0x00f41310, 0x00f43310, 0x00f45310, 0x00f47310, 
  2308| 	0x00f49310, 0x00f4b310, 0x00f4d310, 0x00f4f310, 
  2309| 	0x00f51310, 0x00f53310, 0x00f55310, 0x00f57310, 
  2310| 	0x00f59310, 0x00f5b310, 0x00f5d310, 0x00f5f310, 
  2311| 	0x00f61310, 0x00f63310, 0x00f65310, 0x00f67310, 
  2312| 	0x00f69310, 0x00f6b310, 0x00f6d310, 0x00f6f310, 
  2313| 	0x00f71310, 0x00f73310, 0x00f75310, 0x00f77310, 
  2314| 	0x00f79310, 0x00f7b310, 0x00f7d310, 0x00f7f310, 
  2315| 	0x00f81310, 0x00f83310, 0x00f85310, 0x00f87310, 
  2316| 	0x00f89310, 0x00f8b310, 0x00f8d310, 0x00f8f310, 
  2317| 	0x00f91310, 0x00f93310, 0x00f95310, 0x00f97310, 
  2318| 	0x00f99310, 0x00f9b310, 0x00f9d310, 0x00f9f310, 
  2319| 	0x00fa1310, 0x00fa3310, 0x00fa5310, 0x00fa7310, 
  2320| 	0x00fa9310, 0x00fab310, 0x00fad310, 0x00faf310, 
  2321| 	0x00fb1310, 0x00fb3310, 0x00fb5310, 0x00fb7310, 
  2322| 	0x00fb9310, 0x00fbb310, 0x00fbd310, 0x00fbf310, 
  2323| 	0x00fc1310, 0x00fc3310, 0x00fc5310, 0x00fc7310, 
  2324| 	0x00fc9310, 0x00fcb310, 0x00fcd310, 0x00fcf310, 
  2325| 	0x00fd1310, 0x00fd3310, 0x00fd5310, 0x00fd7310, 
  2326| 	0x00fd9310, 0x00fdb310, 0x00fdd310, 0x00fdf310, 
  2327| 	0x00fe1310, 0x00fe3310, 0x00fe5310, 0x00fe7310, 
  2328| 	0x00fe9310, 0x00feb310, 0x00fed310, 0x00fef310, 
  2329| 	0x00ff1310, 0x00ff3310, 0x00ff5310, 0x00ff7310, 
  2330| 	0x00ff9310, 0x00ffb310, 0x00ffd310, 0x00fff310, 
  2331| };
  2332| #endif


# ====================================================================
# FILE: src/native/external/zlib-intel/inflate.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1549 ---
     1| /* inflate.c -- zlib decompression
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /*
     6|  * Change history:
     7|  *
     8|  * 1.2.beta0    24 Nov 2002
     9|  * - First version -- complete rewrite of inflate to simplify code, avoid
    10|  *   creation of window when not needed, minimize use of window when it is
    11|  *   needed, make inffast.c even faster, implement gzip decoding, and to
    12|  *   improve code readability and style over the previous zlib inflate code
    13|  *
    14|  * 1.2.beta1    25 Nov 2002
    15|  * - Use pointers for available input and output checking in inffast.c
    16|  * - Remove input and output counters in inffast.c
    17|  * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
    18|  * - Remove unnecessary second byte pull from length extra in inffast.c
    19|  * - Unroll direct copy to three copies per loop in inffast.c
    20|  *
    21|  * 1.2.beta2    4 Dec 2002
    22|  * - Change external routine names to reduce potential conflicts
    23|  * - Correct filename to inffixed.h for fixed tables in inflate.c
    24|  * - Make hbuf[] unsigned char to match parameter type in inflate.c
    25|  * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
    26|  *   to avoid negation problem on Alphas (64 bit) in inflate.c
    27|  *
    28|  * 1.2.beta3    22 Dec 2002
    29|  * - Add comments on state->bits assertion in inffast.c
    30|  * - Add comments on op field in inftrees.h
    31|  * - Fix bug in reuse of allocated window after inflateReset()
    32|  * - Remove bit fields--back to byte structure for speed
    33|  * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
    34|  * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
    35|  * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
    36|  * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
    37|  * - Use local copies of stream next and avail values, as well as local bit
    38|  *   buffer and bit count in inflate()--for speed when inflate_fast() not used
    39|  *
    40|  * 1.2.beta4    1 Jan 2003
    41|  * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
    42|  * - Move a comment on output buffer sizes from inffast.c to inflate.c
    43|  * - Add comments in inffast.c to introduce the inflate_fast() routine
    44|  * - Rearrange window copies in inflate_fast() for speed and simplification
    45|  * - Unroll last copy for window match in inflate_fast()
    46|  * - Use local copies of window variables in inflate_fast() for speed
    47|  * - Pull out common wnext == 0 case for speed in inflate_fast()
    48|  * - Make op and len in inflate_fast() unsigned for consistency
    49|  * - Add FAR to lcode and dcode declarations in inflate_fast()
    50|  * - Simplified bad distance check in inflate_fast()
    51|  * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
    52|  *   source file infback.c to provide a call-back interface to inflate for
    53|  *   programs like gzip and unzip -- uses window as output buffer to avoid
    54|  *   window copying
    55|  *
    56|  * 1.2.beta5    1 Jan 2003
    57|  * - Improved inflateBack() interface to allow the caller to provide initial
    58|  *   input in strm.
    59|  * - Fixed stored blocks bug in inflateBack()
    60|  *
    61|  * 1.2.beta6    4 Jan 2003
    62|  * - Added comments in inffast.c on effectiveness of POSTINC
    63|  * - Typecasting all around to reduce compiler warnings
    64|  * - Changed loops from while (1) or do {} while (1) to for (;;), again to
    65|  *   make compilers happy
    66|  * - Changed type of window in inflateBackInit() to unsigned char *
    67|  *
    68|  * 1.2.beta7    27 Jan 2003
    69|  * - Changed many types to unsigned or unsigned short to avoid warnings
    70|  * - Added inflateCopy() function
    71|  *
    72|  * 1.2.0        9 Mar 2003
    73|  * - Changed inflateBack() interface to provide separate opaque descriptors
    74|  *   for the in() and out() functions
    75|  * - Changed inflateBack() argument and in_func typedef to swap the length
    76|  *   and buffer address return values for the input function
    77|  * - Check next_in and next_out for Z_NULL on entry to inflate()
    78|  *
    79|  * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
    80|  */
    81| #include "zutil.h"
    82| #include "inftrees.h"
    83| #include "inflate.h"
    84| #include "inffast.h"
    85| #ifdef MAKEFIXED
    86| #  ifndef BUILDFIXED
    87| #    define BUILDFIXED
    88| #  endif
    89| #endif
    90| /* function prototypes */
    91| local int inflateStateCheck OF((z_streamp strm));
    92| local void fixedtables OF((struct inflate_state FAR *state));
    93| local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
    94|                            unsigned copy));
    95| #ifdef BUILDFIXED
    96|    void makefixed OF((void));
    97| #endif
    98| local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
    99|                               unsigned len));
   100| local int inflateStateCheck(strm)
   101| z_streamp strm;
   102| {
   103|     struct inflate_state FAR *state;
   104|     if (strm == Z_NULL ||
   105|         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
   106|         return 1;
   107|     state = (struct inflate_state FAR *)strm->state;
   108|     if (state == Z_NULL || state->strm != strm ||
   109|         state->mode < HEAD || state->mode > SYNC)
   110|         return 1;
   111|     return 0;
   112| }
   113| int ZEXPORT inflateResetKeep(strm)
   114| z_streamp strm;
   115| {
   116|     struct inflate_state FAR *state;
   117|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   118|     state = (struct inflate_state FAR *)strm->state;
   119|     strm->total_in = strm->total_out = state->total = 0;
   120|     strm->msg = Z_NULL;
   121|     if (state->wrap)        /* to support ill-conceived Java test suite */
   122|         strm->adler = state->wrap & 1;
   123|     state->mode = HEAD;
   124|     state->last = 0;
   125|     state->havedict = 0;
   126|     state->flags = -1;
   127|     state->dmax = 32768U;
   128|     state->head = Z_NULL;
   129|     state->hold = 0;
   130|     state->bits = 0;
   131|     state->lencode = state->distcode = state->next = state->codes;
   132|     state->sane = 1;
   133|     state->back = -1;
   134|     Tracev((stderr, "inflate: reset\n"));
   135|     return Z_OK;
   136| }
   137| int ZEXPORT inflateReset(strm)
   138| z_streamp strm;
   139| {
   140|     struct inflate_state FAR *state;
   141|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   142|     state = (struct inflate_state FAR *)strm->state;
   143|     state->whave = 0;
   144|     state->wnext = 0;
   145|     return inflateResetKeep(strm);
   146| }
   147| int ZEXPORT inflateReset2(strm, windowBits)
   148| z_streamp strm;
   149| int windowBits;
   150| {
   151|     int wrap;
   152|     struct inflate_state FAR *state;
   153|     /* get the state */
   154|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   155|     state = (struct inflate_state FAR *)strm->state;
   156|     /* extract wrap request from windowBits parameter */
   157|     if (windowBits < 0) {
   158|         if (windowBits < -15)
   159|             return Z_STREAM_ERROR;
   160|         wrap = 0;
   161|         windowBits = -windowBits;
   162|     }
   163|     else {
   164|         wrap = (windowBits >> 4) + 5;
   165| #ifdef GUNZIP
   166|         if (windowBits < 48)
   167|             windowBits &= 15;
   168| #endif
   169|     }
   170|     /* set number of window bits, free window if different */
   171|     if (windowBits && (windowBits < 8 || windowBits > 15))
   172|         return Z_STREAM_ERROR;
   173|     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
   174|         ZFREE(strm, state->window);
   175|         state->window = Z_NULL;
   176|     }
   177|     /* update state and reset the rest of it */
   178|     state->wrap = wrap;
   179|     state->wbits = (unsigned)windowBits;
   180|     return inflateReset(strm);
   181| }
   182| int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
   183| z_streamp strm;
   184| int windowBits;
   185| const char *version;
   186| int stream_size;
   187| {
   188|     int ret;
   189|     struct inflate_state FAR *state;
   190|     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
   191|         stream_size != (int)(sizeof(z_stream)))
   192|         return Z_VERSION_ERROR;
   193|     if (strm == Z_NULL) return Z_STREAM_ERROR;
   194|     strm->msg = Z_NULL;                 /* in case we return an error */
   195|     if (strm->zalloc == (alloc_func)0) {
   196| #ifdef Z_SOLO
   197|         return Z_STREAM_ERROR;
   198| #else
   199|         strm->zalloc = zcalloc;
   200|         strm->opaque = (voidpf)0;
   201| #endif
   202|     }
   203|     if (strm->zfree == (free_func)0)
   204| #ifdef Z_SOLO
   205|         return Z_STREAM_ERROR;
   206| #else
   207|         strm->zfree = zcfree;
   208| #endif
   209|     state = (struct inflate_state FAR *)
   210|             ZALLOC(strm, 1, sizeof(struct inflate_state));
   211|     if (state == Z_NULL) return Z_MEM_ERROR;
   212|     Tracev((stderr, "inflate: allocated\n"));
   213|     strm->state = (struct internal_state FAR *)state;
   214|     state->strm = strm;
   215|     state->window = Z_NULL;
   216|     state->mode = HEAD;     /* to pass state test in inflateReset2() */
   217| #if defined(ZLIB_X86)
   218|     x86_check_features();
   219| #endif
   220|     ret = inflateReset2(strm, windowBits);
   221|     if (ret != Z_OK) {
   222|         ZFREE(strm, state);
   223|         strm->state = Z_NULL;
   224|         return ret;
   225|     }
   226|     if (state->wbits == 0)
   227| 	    state->wbits = 15;
   228|     if (state->wbits > 0) {
   229|         state->wsize = 1UL << state->wbits;
   230|         state->window = (unsigned char FAR *)ZALLOC(strm, state->wsize + 16, 4);
   231|         if (state->window == Z_NULL) {
   232|             ZFREE(strm, state);
   233|             strm->state = Z_NULL;
   234|             ret = Z_MEM_ERROR;
   235|         }
   236|     }
   237|     state->whave = 0;
   238|     state->wnext = 0;
   239|     return ret;
   240| }
   241| int ZEXPORT inflateInit_(strm, version, stream_size)
   242| z_streamp strm;
   243| const char *version;
   244| int stream_size;
   245| {
   246|     return inflateInit2_(strm, DEF_WBITS, version, stream_size);
   247| }
   248| int ZEXPORT inflatePrime(strm, bits, value)
   249| z_streamp strm;
   250| int bits;
   251| int value;
   252| {
   253|     struct inflate_state FAR *state;
   254|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   255|     state = (struct inflate_state FAR *)strm->state;
   256|     if (bits < 0) {
   257|         state->hold = 0;
   258|         state->bits = 0;
   259|         return Z_OK;
   260|     }
   261|     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
   262|     value &= (1L << bits) - 1;
   263|     state->hold += (unsigned)value << state->bits;
   264|     state->bits += (uInt)bits;
   265|     return Z_OK;
   266| }
   267| /*
   268|    Return state with length and distance decoding tables and index sizes set to
   269|    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   270|    If BUILDFIXED is defined, then instead this routine builds the tables the
   271|    first time it's called, and returns those tables the first time and
   272|    thereafter.  This reduces the size of the code by about 2K bytes, in
   273|    exchange for a little execution time.  However, BUILDFIXED should not be
   274|    used for threaded applications, since the rewriting of the tables and virgin
   275|    may not be thread-safe.
   276|  */
   277| local void fixedtables(state)
   278| struct inflate_state FAR *state;
   279| {
   280| #ifdef BUILDFIXED
   281|     static int virgin = 1;
   282|     static code *lenfix, *distfix;
   283|     static code fixed[544];
   284|     /* build fixed huffman tables if first call (may not be thread safe) */
   285|     if (virgin) {
   286|         unsigned sym, bits;
   287|         static code *next;
   288|         /* literal/length table */
   289|         sym = 0;
   290|         while (sym < 144) state->lens[sym++] = 8;
   291|         while (sym < 256) state->lens[sym++] = 9;
   292|         while (sym < 280) state->lens[sym++] = 7;
   293|         while (sym < 288) state->lens[sym++] = 8;
   294|         next = fixed;
   295|         lenfix = next;
   296|         bits = 9;
   297|         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
   298|         /* distance table */
   299|         sym = 0;
   300|         while (sym < 32) state->lens[sym++] = 5;
   301|         distfix = next;
   302|         bits = 5;
   303|         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
   304|         /* do this just once */
   305|         virgin = 0;
   306|     }
   307| #else /* !BUILDFIXED */
   308| #   include "inffixed.h"
   309| #endif /* BUILDFIXED */
   310|     state->lencode = lenfix;
   311|     state->lenbits = 9;
   312|     state->distcode = distfix;
   313|     state->distbits = 5;
   314| }
   315| #ifdef MAKEFIXED
   316| #include <stdio.h>
   317| /*
   318|    Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   319|    defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   320|    those tables to stdout, which would be piped to inffixed.h.  A small program
   321|    can simply call makefixed to do this:
   322|     void makefixed(void);
   323|     int main(void)
   324|     {
   325|         makefixed();
   326|         return 0;
   327|     }
   328|    Then that can be linked with zlib built with MAKEFIXED defined and run:
   329|     a.out > inffixed.h
   330|  */
   331| void makefixed()
   332| {
   333|     unsigned low, size;
   334|     struct inflate_state state;
   335|     fixedtables(&state);
   336|     puts("    /* inffixed.h -- table for decoding fixed codes");
   337|     puts("     * Generated automatically by makefixed().");
   338|     puts("     */");
   339|     puts("");
   340|     puts("    /* WARNING: this file should *not* be used by applications.");
   341|     puts("       It is part of the implementation of this library and is");
   342|     puts("       subject to change. Applications should only use zlib.h.");
   343|     puts("     */");
   344|     puts("");
   345|     size = 1U << 9;
   346|     printf("    static const code lenfix[%u] = {", size);
   347|     low = 0;
   348|     for (;;) {
   349|         if ((low % 7) == 0) printf("\n        ");
   350|         printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
   351|                state.lencode[low].bits, state.lencode[low].val);
   352|         if (++low == size) break;
   353|         putchar(',');
   354|     }
   355|     puts("\n    };");
   356|     size = 1U << 5;
   357|     printf("\n    static const code distfix[%u] = {", size);
   358|     low = 0;
   359|     for (;;) {
   360|         if ((low % 6) == 0) printf("\n        ");
   361|         printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
   362|                state.distcode[low].val);
   363|         if (++low == size) break;
   364|         putchar(',');
   365|     }
   366|     puts("\n    };");
   367| }
   368| #endif /* MAKEFIXED */
   369| /*
   370|    Update the window with the last wsize (normally 32K) bytes written before
   371|    returning.  If window does not exist yet, create it.  This is only called
   372|    when a window is already in use, or when output has been written during this
   373|    inflate call, but the end of the deflate stream has not been reached yet.
   374|    It is also called to create a window for dictionary data when a dictionary
   375|    is loaded.
   376|    Providing output buffers larger than 32K to inflate() should provide a speed
   377|    advantage, since only the last 32K of output is copied to the sliding window
   378|    upon return from inflate(), and since all distances after the first 32K of
   379|    output will fall in the output data, making match copies simpler and faster.
   380|    The advantage may be dependent on the size of the processor's data caches.
   381|  */
   382| local int updatewindow(strm, end, copy)
   383| z_streamp strm;
   384| const Bytef *end;
   385| unsigned copy;
   386| {
   387|     struct inflate_state FAR *state;
   388|     unsigned dist;
   389|     state = (struct inflate_state FAR *)strm->state;
   390|     /* if it hasn't been done already, allocate space for the window */
   391|     if (state->window == Z_NULL) {
   392|         state->window = (unsigned char FAR *)
   393|                         ZALLOC(strm, 1U << state->wbits,
   394|                                sizeof(unsigned char));
   395|         if (state->window == Z_NULL) return 1;
   396|     }
   397|     /* if window not in use yet, initialize */
   398|     if (state->wsize == 0) {
   399|         state->wsize = 1U << state->wbits;
   400|         state->wnext = 0;
   401|         state->whave = 0;
   402|     }
   403|     /* copy state->wsize or less output bytes into the circular window */
   404|     if (copy >= state->wsize) {
   405|         zmemcpy(state->window, end - state->wsize, state->wsize);
   406|         state->wnext = 0;
   407|         state->whave = state->wsize;
   408|     }
   409|     else {
   410|         dist = state->wsize - state->wnext;
   411|         if (dist > copy) dist = copy;
   412|         zmemcpy(state->window + state->wnext, end - copy, dist);
   413|         copy -= dist;
   414|         if (copy) {
   415|             zmemcpy(state->window, end - copy, copy);
   416|             state->wnext = copy;
   417|             state->whave = state->wsize;
   418|         }
   419|         else {
   420|             state->wnext += dist;
   421|             if (state->wnext == state->wsize) state->wnext = 0;
   422|             if (state->whave < state->wsize) state->whave += dist;
   423|         }
   424|     }
   425|     return 0;
   426| }
   427| /* Macros for inflate(): */
   428| /* check function to use adler32() for zlib or crc32() for gzip */
   429| #ifdef GUNZIP
   430| #  define UPDATE_CHECK(check, buf, len) \
   431|     (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
   432| #else
   433| #  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)
   434| #endif
   435| /* check macros for header crc */
   436| #ifdef GUNZIP
   437| #  define CRC2(check, word) \
   438|     do { \
   439|         hbuf[0] = (unsigned char)(word); \
   440|         hbuf[1] = (unsigned char)((word) >> 8); \
   441|         check = crc32(check, hbuf, 2); \
   442|     } while (0)
   443| #  define CRC4(check, word) \
   444|     do { \
   445|         hbuf[0] = (unsigned char)(word); \
   446|         hbuf[1] = (unsigned char)((word) >> 8); \
   447|         hbuf[2] = (unsigned char)((word) >> 16); \
   448|         hbuf[3] = (unsigned char)((word) >> 24); \
   449|         check = crc32(check, hbuf, 4); \
   450|     } while (0)
   451| #endif
   452| /* Load registers with state in inflate() for speed */
   453| #define LOAD() \
   454|     do { \
   455|         put = state->window + state->wsize + state->wnext; \
   456|         left = strm->avail_out; \
   457|         next = strm->next_in; \
   458|         have = strm->avail_in; \
   459|         hold = state->hold; \
   460|         bits = state->bits; \
   461|     } while (0)
   462| /* Restore state from registers in inflate() */
   463| #define RESTORE() \
   464|     do { \
   465|         state->wnext = (unsigned)(put - (state->window + state->wsize));\
   466|         strm->avail_out = left; \
   467|         strm->next_in = next; \
   468|         strm->avail_in = have; \
   469|         state->hold = hold; \
   470|         state->bits = bits; \
   471|     } while (0)
   472| /* Clear the input bit accumulator */
   473| #define INITBITS() \
   474|     do { \
   475|         hold = 0; \
   476|         bits = 0; \
   477|     } while (0)
   478| /* Get a byte of input into the bit accumulator, or return from inflate()
   479|    if there is no input available. */
   480| #define PULLBYTE() \
   481|     do { \
   482|         if (have == 0) goto inf_leave; \
   483|         have--; \
   484|         hold += (unsigned long)(*next++) << bits; \
   485|         bits += 8; \
   486|     } while (0)
   487| /* Assure that there are at least n bits in the bit accumulator.  If there is
   488|    not enough available input to do that, then return from inflate(). */
   489| #define NEEDBITS(n) \
   490|     do { \
   491|         while (bits < (unsigned)(n)) \
   492|             PULLBYTE(); \
   493|     } while (0)
   494| /* Return the low n bits of the bit accumulator (n < 16) */
   495| #define BITS(n) \
   496|     ((unsigned)hold & ((1U << (n)) - 1))
   497| /* Remove n bits from the bit accumulator */
   498| #define DROPBITS(n) \
   499|     do { \
   500|         hold >>= (n); \
   501|         bits -= (unsigned)(n); \
   502|     } while (0)
   503| /* Remove zero to seven bits as needed to go to a byte boundary */
   504| #define BYTEBITS() \
   505|     do { \
   506|         hold >>= bits & 7; \
   507|         bits -= bits & 7; \
   508|     } while (0)
   509| /*
   510|    inflate() uses a state machine to process as much input data and generate as
   511|    much output data as possible before returning.  The state machine is
   512|    structured roughly as follows:
   513|     for (;;) switch (state) {
   514|     ...
   515|     case STATEn:
   516|         if (not enough input data or output space to make progress)
   517|             return;
   518|         ... make progress ...
   519|         state = STATEm;
   520|         break;
   521|     ...
   522|     }
   523|    so when inflate() is called again, the same case is attempted again, and
   524|    if the appropriate resources are provided, the machine proceeds to the
   525|    next state.  The NEEDBITS() macro is usually the way the state evaluates
   526|    whether it can proceed or should return.  NEEDBITS() does the return if
   527|    the requested bits are not available.  The typical use of the BITS macros
   528|    is:
   529|         NEEDBITS(n);
   530|         ... do something with BITS(n) ...
   531|         DROPBITS(n);
   532|    where NEEDBITS(n) either returns from inflate() if there isn't enough
   533|    input left to load n bits into the accumulator, or it continues.  BITS(n)
   534|    gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   535|    the low n bits off the accumulator.  INITBITS() clears the accumulator
   536|    and sets the number of available bits to zero.  BYTEBITS() discards just
   537|    enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   538|    and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
   539|    NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   540|    if there is no input available.  The decoding of variable length codes uses
   541|    PULLBYTE() directly in order to pull just enough bytes to decode the next
   542|    code, and no more.
   543|    Some states loop until they get enough input, making sure that enough
   544|    state information is maintained to continue the loop where it left off
   545|    if NEEDBITS() returns in the loop.  For example, want, need, and keep
   546|    would all have to actually be part of the saved state in case NEEDBITS()
   547|    returns:
   548|     case STATEw:
   549|         while (want < need) {
   550|             NEEDBITS(n);
   551|             keep[want++] = BITS(n);
   552|             DROPBITS(n);
   553|         }
   554|         state = STATEx;
   555|     case STATEx:
   556|    As shown above, if the next state is also the next case, then the break
   557|    is omitted.
   558|    A state may also return if there is not enough output space available to
   559|    complete that state.  Those states are copying stored data, writing a
   560|    literal byte, and copying a matching string.
   561|    When returning, a "goto inf_leave" is used to update the total counters,
   562|    update the check value, and determine whether any progress has been made
   563|    during that inflate() call in order to return the proper return code.
   564|    Progress is defined as a change in either strm->avail_in or strm->avail_out.
   565|    When there is a window, goto inf_leave will update the window with the last
   566|    output written.  If a goto inf_leave occurs in the middle of decompression
   567|    and there is no window currently, goto inf_leave will create one and copy
   568|    output to the window for the next call of inflate().
   569|    In this implementation, the flush parameter of inflate() only affects the
   570|    return code (per zlib.h).  inflate() always writes as much as possible to
   571|    strm->next_out, given the space available and the provided input--the effect
   572|    documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   573|    the allocation of and copying into a sliding window until necessary, which
   574|    provides the effect documented in zlib.h for Z_FINISH when the entire input
   575|    stream available.  So the only thing the flush parameter actually does is:
   576|    when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   577|    will return Z_BUF_ERROR if it has not reached the end of the stream.
   578|  */
   579| int ZEXPORT inflate(strm, flush)
   580| z_streamp strm;
   581| int flush;
   582| {
   583|     struct inflate_state FAR *state;
   584|     z_const unsigned char FAR *next;    /* next input */
   585|     unsigned char FAR *put;     /* next output */
   586|     unsigned have, left;        /* available input and output */
   587|     unsigned long hold;         /* bit buffer */
   588|     unsigned bits;              /* bits in bit buffer */
   589|     unsigned in, out;           /* save starting available input and output */
   590|     unsigned copy;              /* number of stored or match bytes to copy */
   591|     unsigned char FAR *from;    /* where to copy match bytes from */
   592|     code here;                  /* current decoding table entry */
   593|     code last;                  /* parent table entry */
   594|     unsigned len;               /* length to copy for repeats, bits to drop */
   595|     int ret;                    /* return code */
   596| #ifdef GUNZIP
   597|     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
   598| #endif
   599|     static const unsigned short order[19] = /* permutation of code lengths */
   600|         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
   601|     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
   602|         (strm->next_in == Z_NULL && strm->avail_in != 0))
   603|         return Z_STREAM_ERROR;
   604|     state = (struct inflate_state FAR *)strm->state;
   605|     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
   606|     LOAD();
   607|     in = have;
   608|     out = left;
   609|     ret = Z_OK;
   610|     for (;;)
   611|         switch (state->mode) {
   612|         case HEAD:
   613|             if (state->wrap == 0) {
   614|                 state->mode = TYPEDO;
   615|                 break;
   616|             }
   617|             NEEDBITS(16);
   618| #ifdef GUNZIP
   619|             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
   620|                 if (state->wbits == 0)
   621|                     state->wbits = 15;
   622|                 state->check = crc32(0L, Z_NULL, 0);
   623|                 CRC2(state->check, hold);
   624|                 INITBITS();
   625|                 state->mode = FLAGS;
   626|                 break;
   627|             }
   628|             if (state->head != Z_NULL)
   629|                 state->head->done = -1;
   630|             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
   631| #else
   632|             if (
   633| #endif
   634|                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
   635|                 strm->msg = (char *)"incorrect header check";
   636|                 state->mode = BAD;
   637|                 break;
   638|             }
   639|             if (BITS(4) != Z_DEFLATED) {
   640|                 strm->msg = (char *)"unknown compression method";
   641|                 state->mode = BAD;
   642|                 break;
   643|             }
   644|             DROPBITS(4);
   645|             len = BITS(4) + 8;
   646|             if (state->wbits == 0)
   647|                 state->wbits = len;
   648|             if (len > 15 || len > state->wbits) {
   649|                 strm->msg = (char *)"invalid window size";
   650|                 state->mode = BAD;
   651|                 break;
   652|             }
   653|             if (state->window == Z_NULL) {
   654|                 RESTORE();
   655|                 state->wsize = 1UL << state->wbits;
   656|                 state->window = (unsigned char FAR *)ZALLOC(strm, state->wsize + 16, 4);
   657|                 if (state->window == Z_NULL) {
   658|                     ZFREE(strm, state);
   659|                     strm->state = Z_NULL;
   660|                     ret = Z_MEM_ERROR;
   661|                 }
   662|                 LOAD();
   663|             }
   664|             state->dmax = 1U << len;
   665|             state->flags = 0;               /* indicate zlib header */
   666|             Tracev((stderr, "inflate:   zlib header ok\n"));
   667|             strm->adler = state->check = adler32(0L, Z_NULL, 0);
   668|             state->mode = hold & 0x200 ? DICTID : TYPE;
   669|             INITBITS();
   670|             break;
   671| #ifdef GUNZIP
   672|         case FLAGS:
   673|             NEEDBITS(16);
   674|             state->flags = (int)(hold);
   675|             if ((state->flags & 0xff) != Z_DEFLATED) {
   676|                 strm->msg = (char *)"unknown compression method";
   677|                 state->mode = BAD;
   678|                 break;
   679|             }
   680|             if (state->flags & 0xe000) {
   681|                 strm->msg = (char *)"unknown header flags set";
   682|                 state->mode = BAD;
   683|                 break;
   684|             }
   685|             if (state->head != Z_NULL)
   686|                 state->head->text = (int)((hold >> 8) & 1);
   687|             if ((state->flags & 0x0200) && (state->wrap & 4))
   688|                 CRC2(state->check, hold);
   689|             INITBITS();
   690|             state->mode = TIME;
   691|                 /* fallthrough */
   692|         case TIME:
   693|             NEEDBITS(32);
   694|             if (state->head != Z_NULL)
   695|                 state->head->time = hold;
   696|             if ((state->flags & 0x0200) && (state->wrap & 4))
   697|                 CRC4(state->check, hold);
   698|             INITBITS();
   699|             state->mode = OS;
   700|                 /* fallthrough */
   701|         case OS:
   702|             NEEDBITS(16);
   703|             if (state->head != Z_NULL) {
   704|                 state->head->xflags = (int)(hold & 0xff);
   705|                 state->head->os = (int)(hold >> 8);
   706|             }
   707|             if ((state->flags & 0x0200) && (state->wrap & 4))
   708|                 CRC2(state->check, hold);
   709|             INITBITS();
   710|             state->mode = EXLEN;
   711|                 /* fallthrough */
   712|         case EXLEN:
   713|             if (state->flags & 0x0400) {
   714|                 NEEDBITS(16);
   715|                 state->length = (unsigned)(hold);
   716|                 if (state->head != Z_NULL)
   717|                     state->head->extra_len = (unsigned)hold;
   718|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   719|                     CRC2(state->check, hold);
   720|                 INITBITS();
   721|             }
   722|             else if (state->head != Z_NULL)
   723|                 state->head->extra = Z_NULL;
   724|             state->mode = EXTRA;
   725|                 /* fallthrough */
   726|         case EXTRA:
   727|             if (state->flags & 0x0400) {
   728|                 copy = state->length;
   729|                 if (copy > have) copy = have;
   730|                 if (copy) {
   731|                     if (state->head != Z_NULL &&
   732|                         state->head->extra != Z_NULL &&
   733|                         (len = state->head->extra_len - state->length) <
   734|                             state->head->extra_max) {
   735|                         zmemcpy(state->head->extra + len, next,
   736|                                 len + copy > state->head->extra_max ?
   737|                                 state->head->extra_max - len : copy);
   738|                     }
   739|                     if ((state->flags & 0x0200) && (state->wrap & 4))
   740|                         state->check = crc32(state->check, next, copy);
   741|                     have -= copy;
   742|                     next += copy;
   743|                     state->length -= copy;
   744|                 }
   745|                 if (state->length) goto inf_leave;
   746|             }
   747|             state->length = 0;
   748|             state->mode = NAME;
   749|                 /* fallthrough */
   750|         case NAME:
   751|             if (state->flags & 0x0800) {
   752|                 if (have == 0) goto inf_leave;
   753|                 copy = 0;
   754|                 do {
   755|                     len = (unsigned)(next[copy++]);
   756|                     if (state->head != Z_NULL &&
   757|                             state->head->name != Z_NULL &&
   758|                             state->length < state->head->name_max)
   759|                         state->head->name[state->length++] = (Bytef)len;
   760|                 } while (len && copy < have);
   761|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   762|                     state->check = crc32(state->check, next, copy);
   763|                 have -= copy;
   764|                 next += copy;
   765|                 if (len) goto inf_leave;
   766|             }
   767|             else if (state->head != Z_NULL)
   768|                 state->head->name = Z_NULL;
   769|             state->length = 0;
   770|             state->mode = COMMENT;
   771|                 /* fallthrough */
   772|         case COMMENT:
   773|             if (state->flags & 0x1000) {
   774|                 if (have == 0) goto inf_leave;
   775|                 copy = 0;
   776|                 do {
   777|                     len = (unsigned)(next[copy++]);
   778|                     if (state->head != Z_NULL &&
   779|                             state->head->comment != Z_NULL &&
   780|                             state->length < state->head->comm_max)
   781|                         state->head->comment[state->length++] = (Bytef)len;
   782|                 } while (len && copy < have);
   783|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   784|                     state->check = crc32(state->check, next, copy);
   785|                 have -= copy;
   786|                 next += copy;
   787|                 if (len) goto inf_leave;
   788|             }
   789|             else if (state->head != Z_NULL)
   790|                 state->head->comment = Z_NULL;
   791|             state->mode = HCRC;
   792|                 /* fallthrough */
   793|         case HCRC:
   794|             if (state->flags & 0x0200) {
   795|                 NEEDBITS(16);
   796|                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
   797|                     strm->msg = (char *)"header crc mismatch";
   798|                     state->mode = BAD;
   799|                     break;
   800|                 }
   801|                 INITBITS();
   802|             }
   803|             if (state->head != Z_NULL) {
   804|                 state->head->hcrc = (int)((state->flags >> 9) & 1);
   805|                 state->head->done = 1;
   806|             }
   807|             strm->adler = state->check = crc32(0L, Z_NULL, 0);
   808| #if defined(USE_PCLMUL_CRC)
   809|             if (x86_cpu_has_pclmul)
   810|                 crc_fold_init(state->crc);
   811| #endif
   812|             state->mode = TYPE;
   813|             break;
   814| #endif
   815|         case DICTID:
   816|             NEEDBITS(32);
   817|             strm->adler = state->check = ZSWAP32(hold);
   818|             INITBITS();
   819|             state->mode = DICT;
   820|                 /* fallthrough */
   821|         case DICT:
   822|             if (state->havedict == 0) {
   823|                 RESTORE();
   824|                 return Z_NEED_DICT;
   825|             }
   826|             strm->adler = state->check = adler32(0L, Z_NULL, 0);
   827|             state->mode = TYPE;
   828|                 /* fallthrough */
   829|         case TYPE:
   830|             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
   831|                 /* fallthrough */
   832|         case TYPEDO:
   833|             if (state->last) {
   834|                 BYTEBITS();
   835|                 state->mode = CHECK;
   836|                 break;
   837|             }
   838|             NEEDBITS(3);
   839|             state->last = BITS(1);
   840|             DROPBITS(1);
   841|             switch (BITS(2)) {
   842|             case 0:                             /* stored block */
   843|                 Tracev((stderr, "inflate:     stored block%s\n",
   844|                         state->last ? " (last)" : ""));
   845|                 state->mode = STORED;
   846|                 break;
   847|             case 1:                             /* fixed block */
   848|                 fixedtables(state);
   849|                 Tracev((stderr, "inflate:     fixed codes block%s\n",
   850|                         state->last ? " (last)" : ""));
   851|                 state->mode = LEN_;             /* decode codes */
   852|                 if (flush == Z_TREES) {
   853|                     DROPBITS(2);
   854|                     goto inf_leave;
   855|                 }
   856|                 break;
   857|             case 2:                             /* dynamic block */
   858|                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
   859|                         state->last ? " (last)" : ""));
   860|                 state->mode = TABLE;
   861|                 break;
   862|             case 3:
   863|                 strm->msg = (char *)"invalid block type";
   864|                 state->mode = BAD;
   865|             }
   866|             DROPBITS(2);
   867|             break;
   868|         case STORED:
   869|             BYTEBITS();                         /* go to byte boundary */
   870|             NEEDBITS(32);
   871|             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
   872|                 strm->msg = (char *)"invalid stored block lengths";
   873|                 state->mode = BAD;
   874|                 break;
   875|             }
   876|             state->length = (unsigned)hold & 0xffff;
   877|             Tracev((stderr, "inflate:       stored length %u\n",
   878|                     state->length));
   879|             INITBITS();
   880|             state->mode = COPY_;
   881|             if (flush == Z_TREES) goto inf_leave;
   882|                 /* fallthrough */
   883|         case COPY_:
   884|             state->mode = COPY;
   885|                 /* fallthrough */
   886|         case COPY:
   887|             copy = state->length;
   888|             if (copy) {
   889|                 unsigned char *end = state->window + (state->wsize * 4);
   890|                 unsigned diff = (unsigned)(end - put);
   891|                 if (copy > have) copy = have;
   892|                 if (copy > diff) {
   893|                     if (left > 0) {
   894|                         RESTORE();
   895|                         window_output_flush(strm);
   896|                         LOAD();
   897|                         diff = (unsigned)(end - put);
   898|                     }
   899|                     if (copy > diff) copy = diff;
   900|                 }
   901|                 if (copy == 0) goto inf_leave;
   902|                 zmemcpy(put, next, copy);
   903|                 have -= copy;
   904|                 next += copy;
   905|                 put += copy;
   906|                 state->length -= copy;
   907|                 break;
   908|             }
   909|             Tracev((stderr, "inflate:       stored end\n"));
   910|             state->mode = TYPE;
   911|             break;
   912|         case TABLE:
   913|             NEEDBITS(14);
   914|             state->nlen = BITS(5) + 257;
   915|             DROPBITS(5);
   916|             state->ndist = BITS(5) + 1;
   917|             DROPBITS(5);
   918|             state->ncode = BITS(4) + 4;
   919|             DROPBITS(4);
   920| #ifndef PKZIP_BUG_WORKAROUND
   921|             if (state->nlen > 286 || state->ndist > 30) {
   922|                 strm->msg = (char *)"too many length or distance symbols";
   923|                 state->mode = BAD;
   924|                 break;
   925|             }
   926| #endif
   927|             Tracev((stderr, "inflate:       table sizes ok\n"));
   928|             state->have = 0;
   929|             state->mode = LENLENS;
   930|                 /* fallthrough */
   931|         case LENLENS:
   932|             while (state->have < state->ncode) {
   933|                 NEEDBITS(3);
   934|                 state->lens[order[state->have++]] = (unsigned short)BITS(3);
   935|                 DROPBITS(3);
   936|             }
   937|             while (state->have < 19)
   938|                 state->lens[order[state->have++]] = 0;
   939|             state->next = state->codes;
   940|             state->lencode = (const code FAR *)(state->next);
   941|             state->lenbits = 7;
   942|             ret = inflate_table(CODES, state->lens, 19, &(state->next),
   943|                                 &(state->lenbits), state->work);
   944|             if (ret) {
   945|                 strm->msg = (char *)"invalid code lengths set";
   946|                 state->mode = BAD;
   947|                 break;
   948|             }
   949|             Tracev((stderr, "inflate:       code lengths ok\n"));
   950|             state->have = 0;
   951|             state->mode = CODELENS;
   952|                 /* fallthrough */
   953|         case CODELENS:
   954|             while (state->have < state->nlen + state->ndist) {
   955|                 for (;;) {
   956|                     here = state->lencode[BITS(state->lenbits)];
   957|                     if ((unsigned)(here.bits) <= bits) break;
   958|                     PULLBYTE();
   959|                 }
   960|                 if (here.val < 16) {
   961|                     DROPBITS(here.bits);
   962|                     state->lens[state->have++] = here.val;
   963|                 }
   964|                 else {
   965|                     if (here.val == 16) {
   966|                         NEEDBITS(here.bits + 2);
   967|                         DROPBITS(here.bits);
   968|                         if (state->have == 0) {
   969|                             strm->msg = (char *)"invalid bit length repeat";
   970|                             state->mode = BAD;
   971|                             break;
   972|                         }
   973|                         len = state->lens[state->have - 1];
   974|                         copy = 3 + BITS(2);
   975|                         DROPBITS(2);
   976|                     }
   977|                     else if (here.val == 17) {
   978|                         NEEDBITS(here.bits + 3);
   979|                         DROPBITS(here.bits);
   980|                         len = 0;
   981|                         copy = 3 + BITS(3);
   982|                         DROPBITS(3);
   983|                     }
   984|                     else {
   985|                         NEEDBITS(here.bits + 7);
   986|                         DROPBITS(here.bits);
   987|                         len = 0;
   988|                         copy = 11 + BITS(7);
   989|                         DROPBITS(7);
   990|                     }
   991|                     if (state->have + copy > state->nlen + state->ndist) {
   992|                         strm->msg = (char *)"invalid bit length repeat";
   993|                         state->mode = BAD;
   994|                         break;
   995|                     }
   996|                     while (copy--)
   997|                         state->lens[state->have++] = (unsigned short)len;
   998|                 }
   999|             }
  1000|             /* handle error breaks in while */
  1001|             if (state->mode == BAD) break;
  1002|             /* check for end-of-block code (better have one) */
  1003|             if (state->lens[256] == 0) {
  1004|                 strm->msg = (char *)"invalid code -- missing end-of-block";
  1005|                 state->mode = BAD;
  1006|                 break;
  1007|             }
  1008|             /* build code tables -- note: do not change the lenbits or distbits
  1009|                values here (9 and 6) without reading the comments in inftrees.h
  1010|                concerning the ENOUGH constants, which depend on those values */
  1011|             state->next = state->codes;
  1012|             state->lencode = (const code FAR *)(state->next);
  1013|             state->lenbits = 9;
  1014|             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
  1015|                                 &(state->lenbits), state->work);
  1016|             if (ret) {
  1017|                 strm->msg = (char *)"invalid literal/lengths set";
  1018|                 state->mode = BAD;
  1019|                 break;
  1020|             }
  1021|             state->distcode = (const code FAR *)(state->next);
  1022|             state->distbits = 6;
  1023|             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
  1024|                             &(state->next), &(state->distbits), state->work);
  1025|             if (ret) {
  1026|                 strm->msg = (char *)"invalid distances set";
  1027|                 state->mode = BAD;
  1028|                 break;
  1029|             }
  1030|             Tracev((stderr, "inflate:       codes ok\n"));
  1031|             state->mode = LEN_;
  1032|             if (flush == Z_TREES) goto inf_leave;
  1033|                 /* fallthrough */
  1034|         case LEN_:
  1035|             state->mode = LEN;
  1036|                 /* fallthrough */
  1037|         case LEN:
  1038|             if (have >= 6 && left >= 258) {
  1039|                 RESTORE();
  1040|                 inflate_fast(strm, out);
  1041|                 LOAD();
  1042|                 if (state->mode == TYPE)
  1043|                     state->back = -1;
  1044|                 break;
  1045|             }
  1046|             state->back = 0;
  1047|             for (;;) {
  1048|                 here = state->lencode[BITS(state->lenbits)];
  1049|                 if ((unsigned)(here.bits) <= bits) break;
  1050|                 PULLBYTE();
  1051|             }
  1052|             if (here.op && (here.op & 0xf0) == 0) {
  1053|                 last = here;
  1054|                 for (;;) {
  1055|                     here = state->lencode[last.val +
  1056|                             (BITS(last.bits + last.op) >> last.bits)];
  1057|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
  1058|                     PULLBYTE();
  1059|                 }
  1060|                 DROPBITS(last.bits);
  1061|                 state->back += last.bits;
  1062|             }
  1063|             DROPBITS(here.bits);
  1064|             state->back += here.bits;
  1065|             state->length = (unsigned)here.val;
  1066|             if ((int)(here.op) == 0) {
  1067|                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
  1068|                         "inflate:         literal '%c'\n" :
  1069|                         "inflate:         literal 0x%02x\n", here.val));
  1070|                 state->mode = LIT;
  1071|                 break;
  1072|             }
  1073|             if (here.op & 32) {
  1074|                 Tracevv((stderr, "inflate:         end of block\n"));
  1075|                 state->back = -1;
  1076|                 state->mode = TYPE;
  1077|                 break;
  1078|             }
  1079|             if (here.op & 64) {
  1080|                 strm->msg = (char *)"invalid literal/length code";
  1081|                 state->mode = BAD;
  1082|                 break;
  1083|             }
  1084|             state->extra = (unsigned)(here.op) & 15;
  1085|             state->mode = LENEXT;
  1086|                 /* fallthrough */
  1087|         case LENEXT:
  1088|             if (state->extra) {
  1089|                 NEEDBITS(state->extra);
  1090|                 state->length += BITS(state->extra);
  1091|                 DROPBITS(state->extra);
  1092|                 state->back += state->extra;
  1093|             }
  1094|             Tracevv((stderr, "inflate:         length %u\n", state->length));
  1095|             state->was = state->length;
  1096|             state->mode = DIST;
  1097|                 /* fallthrough */
  1098|         case DIST:
  1099|             for (;;) {
  1100|                 here = state->distcode[BITS(state->distbits)];
  1101|                 if ((unsigned)(here.bits) <= bits) break;
  1102|                 PULLBYTE();
  1103|             }
  1104|             if ((here.op & 0xf0) == 0) {
  1105|                 last = here;
  1106|                 for (;;) {
  1107|                     here = state->distcode[last.val +
  1108|                             (BITS(last.bits + last.op) >> last.bits)];
  1109|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
  1110|                     PULLBYTE();
  1111|                 }
  1112|                 DROPBITS(last.bits);
  1113|                 state->back += last.bits;
  1114|             }
  1115|             DROPBITS(here.bits);
  1116|             state->back += here.bits;
  1117|             if (here.op & 64) {
  1118|                 strm->msg = (char *)"invalid distance code";
  1119|                 state->mode = BAD;
  1120|                 break;
  1121|             }
  1122|             state->offset = (unsigned)here.val;
  1123|             state->extra = (unsigned)(here.op) & 15;
  1124|             state->mode = DISTEXT;
  1125|                 /* fallthrough */
  1126|         case DISTEXT:
  1127|             if (state->extra) {
  1128|                 NEEDBITS(state->extra);
  1129|                 state->offset += BITS(state->extra);
  1130|                 DROPBITS(state->extra);
  1131|                 state->back += state->extra;
  1132|             }
  1133| #ifdef INFLATE_STRICT
  1134|             if (state->offset > state->dmax) {
  1135|                 strm->msg = (char *)"invalid distance too far back";
  1136|                 state->mode = BAD;
  1137|                 break;
  1138|             }
  1139| #endif
  1140|             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
  1141|             state->mode = MATCH;
  1142|                 /* fallthrough */
  1143|             case MATCH: {
  1144|                 unsigned char *end = state->window + (state->wsize * 4);
  1145|                 unsigned buf_left = (unsigned)(end - put);
  1146|                 copy = state->length;
  1147| 		RESTORE();
  1148|                 if (copy > buf_left) {
  1149|                     if (strm->avail_out > 0) {
  1150|                         /* relies on RESTORE() above with no changes to those vars */
  1151|                         window_output_flush(strm);
  1152|                         LOAD();
  1153|                         buf_left = (unsigned)(end - put);
  1154|                     }
  1155|                     if (copy > buf_left) copy = buf_left;
  1156|                 }
  1157|                 if (copy == 0) goto inf_leave;
  1158|                 if (state->offset > state->whave + state->wnext) {
  1159|                     if (state->sane) {
  1160|                         strm->msg = (char *)"invalid distance too far back";
  1161|                         state->mode = BAD;
  1162|                         break;
  1163|                     }
  1164|                 }
  1165|             from = state->window + state->wsize + state->wnext - state->offset;
  1166|             state->length -= copy;
  1167|             if (copy > state->offset) {
  1168|                 while (copy > 2) {
  1169|                     *(state->window + state->wsize + state->wnext++) = *from++;
  1170|                     *(state->window + state->wsize + state->wnext++) = *from++;
  1171|                     *(state->window + state->wsize + state->wnext++) = *from++;
  1172|                     copy -= 3;
  1173|                 }
  1174|                 if (copy) {
  1175|                     *(state->window + state->wsize + state->wnext++) = *from++;
  1176|                     if (copy > 1) {
  1177|                         *(state->window + state->wsize + state->wnext++) = *from;
  1178|                     }
  1179|                 }
  1180|             } else {
  1181|                 zmemcpy(state->window + state->wsize + state->wnext, from, copy);
  1182|                 state->wnext += copy;
  1183|             }
  1184|             LOAD();
  1185|             if (state->length == 0) state->mode = LEN;
  1186|             break;
  1187|         } case LIT:
  1188|             if (put >= state->window + (state->wsize * 4)) {
  1189|                 RESTORE();
  1190|                 window_output_flush(strm);
  1191|                 LOAD();
  1192|             }
  1193|             if (left == 0) goto inf_leave;
  1194|             *put++ = (unsigned char)(state->length);
  1195|             state->mode = LEN;
  1196|             break;
  1197|         case CHECK:
  1198|             RESTORE();
  1199|             window_output_flush(strm);
  1200|             LOAD();
  1201|             if (strm->avail_out == 0 && state->wnext)
  1202|                 goto inf_leave;
  1203|             if (state->wrap) {
  1204|                 NEEDBITS(32);
  1205|                 out -= left;
  1206|                 strm->total_out += out;
  1207|                 state->total += out;
  1208|                 out = left;
  1209| #ifdef USE_PCLMUL_CRC
  1210| 		if (state->flags > 0 && x86_cpu_has_pclmul)
  1211| 		    strm->adler = state->check = crc_fold_512to32(state->crc);
  1212| #endif
  1213|                 if ((state->wrap & 4) && (
  1214| #ifdef GUNZIP
  1215|                      state->flags ? hold :
  1216| #endif
  1217|                      ZSWAP32(hold)) != state->check) {
  1218|                     strm->msg = (char *)"incorrect data check";
  1219|                     state->mode = BAD;
  1220|                     break;
  1221|                 }
  1222|                 INITBITS();
  1223|                 Tracev((stderr, "inflate:   check matches trailer\n"));
  1224|             }
  1225| #ifdef GUNZIP
  1226|             state->mode = LENGTH;
  1227|                 /* fallthrough */
  1228|         case LENGTH:
  1229|             if (state->wrap && state->flags) {
  1230|                 NEEDBITS(32);
  1231|                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {
  1232|                     strm->msg = (char *)"incorrect length check";
  1233|                     state->mode = BAD;
  1234|                     break;
  1235|                 }
  1236|                 INITBITS();
  1237|                 Tracev((stderr, "inflate:   length matches trailer\n"));
  1238|             }
  1239| #endif
  1240|             state->mode = DONE;
  1241|                 /* fallthrough */
  1242|         case DONE:
  1243|             ret = Z_STREAM_END;
  1244|             goto inf_leave;
  1245|         case BAD:
  1246|             ret = Z_DATA_ERROR;
  1247|             goto inf_leave;
  1248|         case MEM:
  1249|             return Z_MEM_ERROR;
  1250|         case SYNC:
  1251|                 /* fallthrough */
  1252|         default:
  1253|             return Z_STREAM_ERROR;
  1254|         }
  1255|     /*
  1256|        Return from inflate(), updating the total counts and the check value.
  1257|        If there was no progress during the inflate() call, return a buffer
  1258|        error.  Call updatewindow() to create and/or update the window state.
  1259|        Note: a memory error from inflate() is non-recoverable.
  1260|      */
  1261|   inf_leave:
  1262|     RESTORE();
  1263|     if (state->wnext && strm->avail_out)
  1264|         window_output_flush(strm);
  1265|     in -= strm->avail_in;
  1266|     out -= strm->avail_out;
  1267|     strm->total_in += in;
  1268|     strm->total_out += out;
  1269|     state->total += out;
  1270|     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
  1271|                       (state->mode == TYPE ? 128 : 0) +
  1272|                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
  1273|     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
  1274|         ret = Z_BUF_ERROR;
  1275|     return ret;
  1276| }
  1277| int ZEXPORT inflateEnd(strm)
  1278| z_streamp strm;
  1279| {
  1280|     struct inflate_state FAR *state;
  1281|     if (inflateStateCheck(strm))
  1282|         return Z_STREAM_ERROR;
  1283|     state = (struct inflate_state FAR *)strm->state;
  1284|     if (state->window != Z_NULL) ZFREE(strm, state->window);
  1285|     ZFREE(strm, strm->state);
  1286|     strm->state = Z_NULL;
  1287|     Tracev((stderr, "inflate: end\n"));
  1288|     return Z_OK;
  1289| }
  1290| int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
  1291| z_streamp strm;
  1292| Bytef *dictionary;
  1293| uInt *dictLength;
  1294| {
  1295|     struct inflate_state FAR *state;
  1296|     /* check state */
  1297|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1298|     state = (struct inflate_state FAR *)strm->state;
  1299|     /* copy dictionary */
  1300|     if (state->whave && dictionary != Z_NULL) {
  1301|         zmemcpy(dictionary, state->window + state->wnext,
  1302|                 state->whave - state->wnext);
  1303|         zmemcpy(dictionary + state->whave - state->wnext,
  1304|                 state->window, state->wnext);
  1305|     }
  1306|     if (dictLength != Z_NULL)
  1307|         *dictLength = state->whave;
  1308|     return Z_OK;
  1309| }
  1310| int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
  1311| z_streamp strm;
  1312| const Bytef *dictionary;
  1313| uInt dictLength;
  1314| {
  1315|     struct inflate_state FAR *state;
  1316|     unsigned long dictid, dict_copy, hist_copy;
  1317|     const unsigned char *dict_from, *hist_from;
  1318|     unsigned char *dict_to, *hist_to;
  1319|     /* check state */
  1320|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1321|     state = (struct inflate_state FAR *)strm->state;
  1322|     if (state->wrap != 0 && state->mode != DICT)
  1323|         return Z_STREAM_ERROR;
  1324|     /* check for correct dictionary identifier */
  1325|     if (state->mode == DICT) {
  1326|         dictid = adler32(0L, Z_NULL, 0);
  1327|         dictid = adler32(dictid, dictionary, dictLength);
  1328|         if (dictid != state->check)
  1329|             return Z_DATA_ERROR;
  1330|     }
  1331|     Tracec(state->wnext != 0, (stderr, "Setting dictionary with unflushed output"));
  1332|     dict_from = dictionary;
  1333|     dict_copy = dictLength;
  1334|     if (dict_copy > state->wsize) {
  1335|         dict_copy = state->wsize;
  1336|         dict_from += (dictLength - dict_copy);
  1337|     }
  1338|     dict_to = state->window + state->wsize - dict_copy;
  1339|     hist_from = state->window + state->wsize - state->whave;
  1340|     hist_copy = state->wsize - dict_copy;
  1341|     if (hist_copy > state->whave)
  1342|         hist_copy = state->whave;
  1343|     hist_to = dict_to - hist_copy;
  1344|     if (hist_copy)
  1345|         zmemcpy(hist_to, hist_from, hist_copy);
  1346|     if (dict_copy)
  1347|         zmemcpy(dict_to, dict_from, dict_copy);
  1348|     state->whave = hist_copy + dict_copy;
  1349|     state->havedict = 1;
  1350|     Tracev((stderr, "inflate:   dictionary set\n"));
  1351|     return Z_OK;
  1352| }
  1353| int ZEXPORT inflateGetHeader(strm, head)
  1354| z_streamp strm;
  1355| gz_headerp head;
  1356| {
  1357|     struct inflate_state FAR *state;
  1358|     /* check state */
  1359|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1360|     state = (struct inflate_state FAR *)strm->state;
  1361|     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
  1362|     /* save header structure */
  1363|     state->head = head;
  1364|     head->done = 0;
  1365|     return Z_OK;
  1366| }
  1367| /*
  1368|    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
  1369|    or when out of input.  When called, *have is the number of pattern bytes
  1370|    found in order so far, in 0..3.  On return *have is updated to the new
  1371|    state.  If on return *have equals four, then the pattern was found and the
  1372|    return value is how many bytes were read including the last byte of the
  1373|    pattern.  If *have is less than four, then the pattern has not been found
  1374|    yet and the return value is len.  In the latter case, syncsearch() can be
  1375|    called again with more data and the *have state.  *have is initialized to
  1376|    zero for the first call.
  1377|  */
  1378| local unsigned syncsearch(have, buf, len)
  1379| unsigned FAR *have;
  1380| const unsigned char FAR *buf;
  1381| unsigned len;
  1382| {
  1383|     unsigned got;
  1384|     unsigned next;
  1385|     got = *have;
  1386|     next = 0;
  1387|     while (next < len && got < 4) {
  1388|         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
  1389|             got++;
  1390|         else if (buf[next])
  1391|             got = 0;
  1392|         else
  1393|             got = 4 - got;
  1394|         next++;
  1395|     }
  1396|     *have = got;
  1397|     return next;
  1398| }
  1399| int ZEXPORT inflateSync(strm)
  1400| z_streamp strm;
  1401| {
  1402|     unsigned len;               /* number of bytes to look at or looked at */
  1403|     int flags;                  /* temporary to save header status */
  1404|     unsigned long in, out;      /* temporary to save total_in and total_out */
  1405|     unsigned char buf[4];       /* to restore bit buffer to byte string */
  1406|     struct inflate_state FAR *state;
  1407|     /* check parameters */
  1408|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1409|     state = (struct inflate_state FAR *)strm->state;
  1410|     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
  1411|     /* if first time, start search in bit buffer */
  1412|     if (state->mode != SYNC) {
  1413|         state->mode = SYNC;
  1414|         state->hold <<= state->bits & 7;
  1415|         state->bits -= state->bits & 7;
  1416|         len = 0;
  1417|         while (state->bits >= 8) {
  1418|             buf[len++] = (unsigned char)(state->hold);
  1419|             state->hold >>= 8;
  1420|             state->bits -= 8;
  1421|         }
  1422|         state->have = 0;
  1423|         syncsearch(&(state->have), buf, len);
  1424|     }
  1425|     /* search available input */
  1426|     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
  1427|     strm->avail_in -= len;
  1428|     strm->next_in += len;
  1429|     strm->total_in += len;
  1430|     /* return no joy or set up to restart inflate() on a new block */
  1431|     if (state->have != 4) return Z_DATA_ERROR;
  1432|     if (state->flags == -1)
  1433|         state->wrap = 0;    /* if no header yet, treat as raw */
  1434|     else
  1435|         state->wrap &= ~4;  /* no point in computing a check value now */
  1436|     flags = state->flags;
  1437|     in = strm->total_in;  out = strm->total_out;
  1438|     inflateReset(strm);
  1439|     strm->total_in = in;  strm->total_out = out;
  1440|     state->flags = flags;
  1441|     state->mode = TYPE;
  1442|     return Z_OK;
  1443| }
  1444| /*
  1445|    Returns true if inflate is currently at the end of a block generated by
  1446|    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  1447|    implementation to provide an additional safety check. PPP uses
  1448|    Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
  1449|    block. When decompressing, PPP checks that at the end of input packet,
  1450|    inflate is waiting for these length bytes.
  1451|  */
  1452| int ZEXPORT inflateSyncPoint(strm)
  1453| z_streamp strm;
  1454| {
  1455|     struct inflate_state FAR *state;
  1456|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1457|     state = (struct inflate_state FAR *)strm->state;
  1458|     return state->mode == STORED && state->bits == 0;
  1459| }
  1460| int ZEXPORT inflateCopy(dest, source)
  1461| z_streamp dest;
  1462| z_streamp source;
  1463| {
  1464|     struct inflate_state FAR *state;
  1465|     struct inflate_state FAR *copy;
  1466|     unsigned char FAR *window;
  1467|     unsigned wsize = 0;
  1468|     /* check input */
  1469|     if (inflateStateCheck(source) || dest == Z_NULL)
  1470|         return Z_STREAM_ERROR;
  1471|     state = (struct inflate_state FAR *)source->state;
  1472|     /* allocate space */
  1473|     copy = (struct inflate_state FAR *)
  1474|            ZALLOC(source, 1, sizeof(struct inflate_state));
  1475|     if (copy == Z_NULL) return Z_MEM_ERROR;
  1476|     window = Z_NULL;
  1477|     if (state->window != Z_NULL) {
  1478|         wsize = 1UL << state->wbits;
  1479|         window = (unsigned char FAR *)ZALLOC(source, wsize + 16, 4);
  1480|         if (window == Z_NULL) {
  1481|             ZFREE(source, copy);
  1482|             return Z_MEM_ERROR;
  1483|         }
  1484|     }
  1485|     /* copy state */
  1486|     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
  1487|     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
  1488|     copy->strm = dest;
  1489|     if (state->lencode >= state->codes &&
  1490|         state->lencode <= state->codes + ENOUGH - 1) {
  1491|         copy->lencode = copy->codes + (state->lencode - state->codes);
  1492|         copy->distcode = copy->codes + (state->distcode - state->codes);
  1493|     }
  1494|     copy->next = copy->codes + (state->next - state->codes);
  1495|     if (window != Z_NULL) {
  1496|         zmemcpy(window, state->window, ((wsize + 16) *4));
  1497|     }
  1498|     copy->window = window;
  1499|     dest->state = (struct internal_state FAR *)copy;
  1500|     return Z_OK;
  1501| }
  1502| int ZEXPORT inflateUndermine(strm, subvert)
  1503| z_streamp strm;
  1504| int subvert;
  1505| {
  1506|     struct inflate_state FAR *state;
  1507|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1508|     state = (struct inflate_state FAR *)strm->state;
  1509| #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  1510|     state->sane = !subvert;
  1511|     return Z_OK;
  1512| #else
  1513|     (void)subvert;
  1514|     state->sane = 1;
  1515|     return Z_DATA_ERROR;
  1516| #endif
  1517| }
  1518| int ZEXPORT inflateValidate(strm, check)
  1519| z_streamp strm;
  1520| int check;
  1521| {
  1522|     struct inflate_state FAR *state;
  1523|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1524|     state = (struct inflate_state FAR *)strm->state;
  1525|     if (check && state->wrap)
  1526|         state->wrap |= 4;
  1527|     else
  1528|         state->wrap &= ~4;
  1529|     return Z_OK;
  1530| }
  1531| long ZEXPORT inflateMark(strm)
  1532| z_streamp strm;
  1533| {
  1534|     struct inflate_state FAR *state;
  1535|     if (inflateStateCheck(strm))
  1536|         return -(1L << 16);
  1537|     state = (struct inflate_state FAR *)strm->state;
  1538|     return (long)(((unsigned long)((long)state->back)) << 16) +
  1539|         (state->mode == COPY ? state->length :
  1540|             (state->mode == MATCH ? state->was - state->length : 0));
  1541| }
  1542| unsigned long ZEXPORT inflateCodesUsed(strm)
  1543| z_streamp strm;
  1544| {
  1545|     struct inflate_state FAR *state;
  1546|     if (inflateStateCheck(strm)) return (unsigned long)-1;
  1547|     state = (struct inflate_state FAR *)strm->state;
  1548|     return (unsigned long)(state->next - state->codes);
  1549| }


# ====================================================================
# FILE: src/native/external/zlib-intel/inflate.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-173 ---
     1| /* inflate.h -- internal inflate state definition
     2|  * Copyright (C) 1995-2019 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* WARNING: this file should *not* be used by applications. It is
     6|    part of the implementation of the compression library and is
     7|    subject to change. Applications should only use zlib.h.
     8|  */
     9| /* define NO_GZIP when compiling if you want to disable gzip header and
    10|    trailer decoding by inflate().  NO_GZIP would be used to avoid linking in
    11|    the crc code when it is not needed.  For shared libraries, gzip decoding
    12|    should be left enabled. */
    13| #ifndef NO_GZIP
    14| #  define GUNZIP
    15| #endif
    16| #include "zutil.h"
    17| #include "x86.h"
    18| /* Possible inflate modes between inflate() calls */
    19| typedef enum {
    20|     HEAD = 16180,   /* i: waiting for magic header */
    21|     FLAGS,      /* i: waiting for method and flags (gzip) */
    22|     TIME,       /* i: waiting for modification time (gzip) */
    23|     OS,         /* i: waiting for extra flags and operating system (gzip) */
    24|     EXLEN,      /* i: waiting for extra length (gzip) */
    25|     EXTRA,      /* i: waiting for extra bytes (gzip) */
    26|     NAME,       /* i: waiting for end of file name (gzip) */
    27|     COMMENT,    /* i: waiting for end of comment (gzip) */
    28|     HCRC,       /* i: waiting for header crc (gzip) */
    29|     DICTID,     /* i: waiting for dictionary check value */
    30|     DICT,       /* waiting for inflateSetDictionary() call */
    31|         TYPE,       /* i: waiting for type bits, including last-flag bit */
    32|         TYPEDO,     /* i: same, but skip check to exit inflate on new block */
    33|         STORED,     /* i: waiting for stored size (length and complement) */
    34|         COPY_,      /* i/o: same as COPY below, but only first time in */
    35|         COPY,       /* i/o: waiting for input or output to copy stored block */
    36|         TABLE,      /* i: waiting for dynamic block table lengths */
    37|         LENLENS,    /* i: waiting for code length code lengths */
    38|         CODELENS,   /* i: waiting for length/lit and distance code lengths */
    39|             LEN_,       /* i: same as LEN below, but only first time in */
    40|             LEN,        /* i: waiting for length/lit/eob code */
    41|             LENEXT,     /* i: waiting for length extra bits */
    42|             DIST,       /* i: waiting for distance code */
    43|             DISTEXT,    /* i: waiting for distance extra bits */
    44|             MATCH,      /* o: waiting for output space to copy string */
    45|             LIT,        /* o: waiting for output space to write literal */
    46|     CHECK,      /* i: waiting for 32-bit check value */
    47|     LENGTH,     /* i: waiting for 32-bit length (gzip) */
    48|     DONE,       /* finished check, done -- remain here until reset */
    49|     BAD,        /* got a data error -- remain here until reset */
    50|     MEM,        /* got an inflate() memory error -- remain here until reset */
    51|     SYNC        /* looking for synchronization bytes to restart inflate() */
    52| } inflate_mode;
    53| /*
    54|     State transitions between above modes -
    55|     (most modes can go to BAD or MEM on error -- not shown for clarity)
    56|     Process header:
    57|         HEAD -> (gzip) or (zlib) or (raw)
    58|         (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->
    59|                   HCRC -> TYPE
    60|         (zlib) -> DICTID or TYPE
    61|         DICTID -> DICT -> TYPE
    62|         (raw) -> TYPEDO
    63|     Read deflate blocks:
    64|             TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK
    65|             STORED -> COPY_ -> COPY -> TYPE
    66|             TABLE -> LENLENS -> CODELENS -> LEN_
    67|             LEN_ -> LEN
    68|     Read deflate codes in fixed or dynamic block:
    69|                 LEN -> LENEXT or LIT or TYPE
    70|                 LENEXT -> DIST -> DISTEXT -> MATCH -> LEN
    71|                 LIT -> LEN
    72|     Process trailer:
    73|         CHECK -> LENGTH -> DONE
    74|  */
    75| /* State maintained between inflate() calls -- approximately 7K bytes, not
    76|    including the allocated sliding window, which is up to 32K bytes. */
    77| struct inflate_state {
    78|     z_streamp strm;             /* pointer back to this zlib stream */
    79|     inflate_mode mode;          /* current inflate mode */
    80|     int last;                   /* true if processing last block */
    81|     int wrap;                   /* bit 0 true for zlib, bit 1 true for gzip,
    82|                                    bit 2 true to validate check value */
    83|     int havedict;               /* true if dictionary provided */
    84|     int flags;                  /* gzip header method and flags, 0 if zlib, or
    85|                                    -1 if raw or no header yet */
    86|     unsigned dmax;              /* zlib header max distance (INFLATE_STRICT) */
    87|     unsigned long check;        /* protected copy of check value */
    88|     unsigned long total;        /* protected copy of output count */
    89|     gz_headerp head;            /* where to save gzip header information */
    90|         /* sliding window */
    91|     unsigned wbits;             /* log base 2 of requested window size */
    92|     unsigned wsize;             /* window size or zero if not using window */
    93|     unsigned whave;             /* valid bytes in the window */
    94|     unsigned wnext;             /* window write index */
    95|     unsigned char FAR *window;  /* allocated sliding window, if needed */
    96| #if defined(USE_PCLMUL_CRC)
    97|     unsigned zalign(16) crc[4 * 5];
    98| #endif
    99|         /* bit accumulator */
   100|     unsigned long hold;         /* input bit accumulator */
   101|     unsigned bits;              /* number of bits in "in" */
   102|         /* for string and stored block copying */
   103|     unsigned length;            /* literal or length of data to copy */
   104|     unsigned offset;            /* distance back to copy string from */
   105|         /* for table and code decoding */
   106|     unsigned extra;             /* extra bits needed */
   107|         /* fixed and dynamic code tables */
   108|     code const FAR *lencode;    /* starting table for length/literal codes */
   109|     code const FAR *distcode;   /* starting table for distance codes */
   110|     unsigned lenbits;           /* index bits for lencode */
   111|     unsigned distbits;          /* index bits for distcode */
   112|         /* dynamic table building */
   113|     unsigned ncode;             /* number of code length code lengths */
   114|     unsigned nlen;              /* number of length code lengths */
   115|     unsigned ndist;             /* number of distance code lengths */
   116|     unsigned have;              /* number of code lengths in lens[] */
   117|     code FAR *next;             /* next available space in codes[] */
   118|     unsigned short lens[320];   /* temporary storage for code lengths */
   119|     unsigned short work[288];   /* work area for code table building */
   120|     code codes[ENOUGH];         /* space for code tables */
   121|     int sane;                   /* if false, allow invalid distance too far */
   122|     int back;                   /* bits back of last unprocessed length/lit */
   123|     unsigned was;               /* initial length of match */
   124| };
   125| static inline void inf_crc_copy(z_streamp strm, unsigned char FAR *const dst,
   126|         const unsigned char FAR *const src, uInt len)
   127| {
   128|     struct inflate_state *const state = (struct inflate_state *const)strm->state;
   129| #if !defined(NO_GZIP) && defined(USE_PCLMUL_CRC)
   130|     if (state->flags > 0 && x86_cpu_has_pclmul) {
   131|         crc_fold_copy(state->crc, dst, src, len);
   132|         return;
   133|     }
   134| #endif
   135|     zmemcpy(dst, src, len);
   136| #if !defined(NO_GZIP)
   137|     if (state->flags > 0)
   138|         strm->adler = state->check = crc32(state->check, dst, len);
   139|     else
   140| #endif
   141|     if (state->flags == 0)
   142|         strm->adler = state->check = adler32(state->check, dst, len);
   143| }
   144| static inline void window_output_flush(z_streamp strm)
   145| {
   146|     struct inflate_state *const state = (struct inflate_state *const)strm->state;
   147|     size_t woff, roff, copysz;
   148|     uInt nexto_len;
   149|     if (state->wnext > strm->avail_out) {
   150|         nexto_len = strm->avail_out;
   151|         copysz = state->wnext - strm->avail_out;
   152|     } else {
   153|         nexto_len = state->wnext;
   154|         copysz = 0;
   155|     }
   156|     inf_crc_copy(strm, strm->next_out, state->window + state->wsize, nexto_len);
   157|     strm->avail_out -= nexto_len;
   158|     strm->next_out += nexto_len;
   159|     if (state->whave + nexto_len > state->wsize) {
   160|         woff = 0;
   161|         roff = nexto_len;
   162|         copysz += state->wsize;
   163|     } else {
   164|         roff = state->wsize - state->whave;
   165|         woff = state->wsize - state->whave - nexto_len;
   166|         copysz += state->whave + nexto_len;
   167|     }
   168|     memmove(state->window + woff, state->window + roff, copysz);
   169|     state->wnext -= nexto_len;
   170|     state->whave += nexto_len;
   171|     if (state->whave > state->wsize)
   172|         state->whave = state->wsize;
   173| }


# ====================================================================
# FILE: src/native/external/zlib-intel/inftrees.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-272 ---
     1| /* inftrees.c -- generate Huffman trees for efficient decoding
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| #include "zutil.h"
     6| #include "inftrees.h"
     7| #define MAXBITS 15
     8| const char inflate_copyright[] =
     9|    " inflate 1.2.13 Copyright 1995-2022 Mark Adler ";
    10| /*
    11|   If you use the zlib library in a product, an acknowledgment is welcome
    12|   in the documentation of your product. If for some reason you cannot
    13|   include such an acknowledgment, I would appreciate that you keep this
    14|   copyright string in the executable of your product.
    15|  */
    16| /*
    17|    Build a set of tables to decode the provided canonical Huffman code.
    18|    The code lengths are lens[0..codes-1].  The result starts at *table,
    19|    whose indices are 0..2^bits-1.  work is a writable array of at least
    20|    lens shorts, which is used as a work area.  type is the type of code
    21|    to be generated, CODES, LENS, or DISTS.  On return, zero is success,
    22|    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
    23|    on return points to the next available entry's address.  bits is the
    24|    requested root table index bits, and on return it is the actual root
    25|    table index bits.  It will differ if the request is greater than the
    26|    longest code or if it is less than the shortest code.
    27|  */
    28| int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
    29| codetype type;
    30| unsigned short FAR *lens;
    31| unsigned codes;
    32| code FAR * FAR *table;
    33| unsigned FAR *bits;
    34| unsigned short FAR *work;
    35| {
    36|     unsigned len;               /* a code's length in bits */
    37|     unsigned sym;               /* index of code symbols */
    38|     unsigned min, max;          /* minimum and maximum code lengths */
    39|     unsigned root;              /* number of index bits for root table */
    40|     unsigned curr;              /* number of index bits for current table */
    41|     unsigned drop;              /* code bits to drop for sub-table */
    42|     int left;                   /* number of prefix codes available */
    43|     unsigned used;              /* code entries in table used */
    44|     unsigned huff;              /* Huffman code */
    45|     unsigned incr;              /* for incrementing code, index */
    46|     unsigned fill;              /* index for replicating entries */
    47|     unsigned low;               /* low bits for current root entry */
    48|     unsigned mask;              /* mask for low root bits */
    49|     code here;                  /* table entry for duplication */
    50|     code FAR *next;             /* next available space in table */
    51|     const unsigned short FAR *base;     /* base value table to use */
    52|     const unsigned short FAR *extra;    /* extra bits table to use */
    53|     unsigned match;             /* use base and extra for symbol >= match */
    54|     unsigned short count[MAXBITS+1];    /* number of codes of each length */
    55|     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    56|     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
    57|         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    58|         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    59|     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
    60|         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
    61|         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};
    62|     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
    63|         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    64|         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    65|         8193, 12289, 16385, 24577, 0, 0};
    66|     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
    67|         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
    68|         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
    69|         28, 28, 29, 29, 64, 64};
    70|     /*
    71|        Process a set of code lengths to create a canonical Huffman code.  The
    72|        code lengths are lens[0..codes-1].  Each length corresponds to the
    73|        symbols 0..codes-1.  The Huffman code is generated by first sorting the
    74|        symbols by length from short to long, and retaining the symbol order
    75|        for codes with equal lengths.  Then the code starts with all zero bits
    76|        for the first code of the shortest length, and the codes are integer
    77|        increments for the same length, and zeros are appended as the length
    78|        increases.  For the deflate format, these bits are stored backwards
    79|        from their more natural integer increment ordering, and so when the
    80|        decoding tables are built in the large loop below, the integer codes
    81|        are incremented backwards.
    82|        This routine assumes, but does not check, that all of the entries in
    83|        lens[] are in the range 0..MAXBITS.  The caller must assure this.
    84|        1..MAXBITS is interpreted as that code length.  zero means that that
    85|        symbol does not occur in this code.
    86|        The codes are sorted by computing a count of codes for each length,
    87|        creating from that a table of starting indices for each length in the
    88|        sorted table, and then entering the symbols in order in the sorted
    89|        table.  The sorted table is work[], with that space being provided by
    90|        the caller.
    91|        The length counts are used for other purposes as well, i.e. finding
    92|        the minimum and maximum length codes, determining if there are any
    93|        codes at all, checking for a valid set of lengths, and looking ahead
    94|        at length counts to determine sub-table sizes when building the
    95|        decoding tables.
    96|      */
    97|     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    98|     for (len = 0; len <= MAXBITS; len++)
    99|         count[len] = 0;
   100|     for (sym = 0; sym < codes; sym++)
   101|         count[lens[sym]]++;
   102|     /* bound code lengths, force root to be within code lengths */
   103|     root = *bits;
   104|     for (max = MAXBITS; max >= 1; max--)
   105|         if (count[max] != 0) break;
   106|     if (root > max) root = max;
   107|     if (max == 0) {                     /* no symbols to code at all */
   108|         here.op = (unsigned char)64;    /* invalid code marker */
   109|         here.bits = (unsigned char)1;
   110|         here.val = (unsigned short)0;
   111|         *(*table)++ = here;             /* make a table to force an error */
   112|         *(*table)++ = here;
   113|         *bits = 1;
   114|         return 0;     /* no symbols, but wait for decoding to report error */
   115|     }
   116|     for (min = 1; min < max; min++)
   117|         if (count[min] != 0) break;
   118|     if (root < min) root = min;
   119|     /* check for an over-subscribed or incomplete set of lengths */
   120|     left = 1;
   121|     for (len = 1; len <= MAXBITS; len++) {
   122|         left <<= 1;
   123|         left -= count[len];
   124|         if (left < 0) return -1;        /* over-subscribed */
   125|     }
   126|     if (left > 0 && (type == CODES || max != 1))
   127|         return -1;                      /* incomplete set */
   128|     /* generate offsets into symbol table for each length for sorting */
   129|     offs[1] = 0;
   130|     for (len = 1; len < MAXBITS; len++)
   131|         offs[len + 1] = offs[len] + count[len];
   132|     /* sort symbols by length, by symbol order within each length */
   133|     for (sym = 0; sym < codes; sym++)
   134|         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
   135|     /*
   136|        Create and fill in decoding tables.  In this loop, the table being
   137|        filled is at next and has curr index bits.  The code being used is huff
   138|        with length len.  That code is converted to an index by dropping drop
   139|        bits off of the bottom.  For codes where len is less than drop + curr,
   140|        those top drop + curr - len bits are incremented through all values to
   141|        fill the table with replicated entries.
   142|        root is the number of index bits for the root table.  When len exceeds
   143|        root, sub-tables are created pointed to by the root entry with an index
   144|        of the low root bits of huff.  This is saved in low to check for when a
   145|        new sub-table should be started.  drop is zero when the root table is
   146|        being filled, and drop is root when sub-tables are being filled.
   147|        When a new sub-table is needed, it is necessary to look ahead in the
   148|        code lengths to determine what size sub-table is needed.  The length
   149|        counts are used for this, and so count[] is decremented as codes are
   150|        entered in the tables.
   151|        used keeps track of how many table entries have been allocated from the
   152|        provided *table space.  It is checked for LENS and DIST tables against
   153|        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   154|        the initial root table size constants.  See the comments in inftrees.h
   155|        for more information.
   156|        sym increments through all symbols, and the loop terminates when
   157|        all codes of length max, i.e. all codes, have been processed.  This
   158|        routine permits incomplete codes, so another loop after this one fills
   159|        in the rest of the decoding tables with invalid code markers.
   160|      */
   161|     /* set up for code type */
   162|     switch (type) {
   163|     case CODES:
   164|         base = extra = work;    /* dummy value--not used */
   165|         match = 20;
   166|         break;
   167|     case LENS:
   168|         base = lbase;
   169|         extra = lext;
   170|         match = 257;
   171|         break;
   172|     default:    /* DISTS */
   173|         base = dbase;
   174|         extra = dext;
   175|         match = 0;
   176|     }
   177|     /* initialize state for loop */
   178|     huff = 0;                   /* starting code */
   179|     sym = 0;                    /* starting code symbol */
   180|     len = min;                  /* starting code length */
   181|     next = *table;              /* current table to fill in */
   182|     curr = root;                /* current table index bits */
   183|     drop = 0;                   /* current bits to drop from code for index */
   184|     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
   185|     used = 1U << root;          /* use root table entries */
   186|     mask = used - 1;            /* mask for comparing low */
   187|     /* check available table space */
   188|     if ((type == LENS && used > ENOUGH_LENS) ||
   189|         (type == DISTS && used > ENOUGH_DISTS))
   190|         return 1;
   191|     /* process all codes and make table entries */
   192|     for (;;) {
   193|         /* create table entry */
   194|         here.bits = (unsigned char)(len - drop);
   195|         if (work[sym] + 1U < match) {
   196|             here.op = (unsigned char)0;
   197|             here.val = work[sym];
   198|         }
   199|         else if (work[sym] >= match) {
   200|             here.op = (unsigned char)(extra[work[sym] - match]);
   201|             here.val = base[work[sym] - match];
   202|         }
   203|         else {
   204|             here.op = (unsigned char)(32 + 64);         /* end of block */
   205|             here.val = 0;
   206|         }
   207|         /* replicate for those indices with low len bits equal to huff */
   208|         incr = 1U << (len - drop);
   209|         fill = 1U << curr;
   210|         min = fill;                 /* save offset to next table */
   211|         do {
   212|             fill -= incr;
   213|             next[(huff >> drop) + fill] = here;
   214|         } while (fill != 0);
   215|         /* backwards increment the len-bit code huff */
   216|         incr = 1U << (len - 1);
   217|         while (huff & incr)
   218|             incr >>= 1;
   219|         if (incr != 0) {
   220|             huff &= incr - 1;
   221|             huff += incr;
   222|         }
   223|         else
   224|             huff = 0;
   225|         /* go to next symbol, update count, len */
   226|         sym++;
   227|         if (--(count[len]) == 0) {
   228|             if (len == max) break;
   229|             len = lens[work[sym]];
   230|         }
   231|         /* create new sub-table if needed */
   232|         if (len > root && (huff & mask) != low) {
   233|             /* if first time, transition to sub-tables */
   234|             if (drop == 0)
   235|                 drop = root;
   236|             /* increment past last table */
   237|             next += min;            /* here min is 1 << curr */
   238|             /* determine length of next table */
   239|             curr = len - drop;
   240|             left = (int)(1 << curr);
   241|             while (curr + drop < max) {
   242|                 left -= count[curr + drop];
   243|                 if (left <= 0) break;
   244|                 curr++;
   245|                 left <<= 1;
   246|             }
   247|             /* check for enough space */
   248|             used += 1U << curr;
   249|             if ((type == LENS && used > ENOUGH_LENS) ||
   250|                 (type == DISTS && used > ENOUGH_DISTS))
   251|                 return 1;
   252|             /* point entry in root table to sub-table */
   253|             low = huff & mask;
   254|             (*table)[low].op = (unsigned char)curr;
   255|             (*table)[low].bits = (unsigned char)root;
   256|             (*table)[low].val = (unsigned short)(next - *table);
   257|         }
   258|     }
   259|     /* fill in remaining table entry if code is incomplete (guaranteed to have
   260|        at most one remaining entry, since if the code is incomplete, the
   261|        maximum code length that was allowed to get this far is one bit) */
   262|     if (huff != 0) {
   263|         here.op = (unsigned char)64;            /* invalid code marker */
   264|         here.bits = (unsigned char)(len - drop);
   265|         here.val = (unsigned short)0;
   266|         next[huff] = here;
   267|     }
   268|     /* set return parameters */
   269|     *table += used;
   270|     *bits = root;
   271|     return 0;
   272| }


# ====================================================================
# FILE: src/native/external/zlib-intel/inftrees.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| /* inftrees.h -- header to use inftrees.c
     2|  * Copyright (C) 1995-2005, 2010 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* WARNING: this file should *not* be used by applications. It is
     6|    part of the implementation of the compression library and is
     7|    subject to change. Applications should only use zlib.h.
     8|  */
     9| /* Structure for decoding tables.  Each entry provides either the
    10|    information needed to do the operation requested by the code that
    11|    indexed that table entry, or it provides a pointer to another
    12|    table that indexes more bits of the code.  op indicates whether
    13|    the entry is a pointer to another table, a literal, a length or
    14|    distance, an end-of-block, or an invalid code.  For a table
    15|    pointer, the low four bits of op is the number of index bits of
    16|    that table.  For a length or distance, the low four bits of op
    17|    is the number of extra bits to get after the code.  bits is
    18|    the number of bits in this code or part of the code to drop off
    19|    of the bit buffer.  val is the actual byte to output in the case
    20|    of a literal, the base length or distance, or the offset from
    21|    the current table to the next table.  Each entry is four bytes. */
    22| typedef struct {
    23|     unsigned char op;           /* operation, extra bits, table bits */
    24|     unsigned char bits;         /* bits in this part of the code */
    25|     unsigned short val;         /* offset in table or code value */
    26| } code;
    27| /* op values as set by inflate_table():
    28|     00000000 - literal
    29|     0000tttt - table link, tttt != 0 is the number of table index bits
    30|     0001eeee - length or distance, eeee is the number of extra bits
    31|     01100000 - end of block
    32|     01000000 - invalid code
    33|  */
    34| /* Maximum size of the dynamic table.  The maximum number of code structures is
    35|    1444, which is the sum of 852 for literal/length codes and 592 for distance
    36|    codes.  These values were found by exhaustive searches using the program
    37|    examples/enough.c found in the zlib distribution.  The arguments to that
    38|    program are the number of symbols, the initial root table size, and the
    39|    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
    40|    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
    41|    The initial root table size (9 or 6) is found in the fifth argument of the
    42|    inflate_table() calls in inflate.c and infback.c.  If the root table size is
    43|    changed, then these maximum sizes would be need to be recalculated and
    44|    updated. */
    45| #define ENOUGH_LENS 852
    46| #define ENOUGH_DISTS 592
    47| #define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
    48| /* Type of code to build for inflate_table() */
    49| typedef enum {
    50|     CODES,
    51|     LENS,
    52|     DISTS
    53| } codetype;
    54| int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
    55|                              unsigned codes, code FAR * FAR *table,
    56|                              unsigned FAR *bits, unsigned short FAR *work));


# ====================================================================
# FILE: src/native/external/zlib-intel/trees.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1028 ---
     1| /* trees.c -- output deflated data using Huffman coding
     2|  * Copyright (C) 1995-2021 Jean-loup Gailly
     3|  * detect_data_type() function provided freely by Cosmin Truta, 2006
     4|  * For conditions of distribution and use, see copyright notice in zlib.h
     5|  */
     6| /*
     7|  *  ALGORITHM
     8|  *
     9|  *      The "deflation" process uses several Huffman trees. The more
    10|  *      common source values are represented by shorter bit sequences.
    11|  *
    12|  *      Each code tree is stored in a compressed form which is itself
    13|  * a Huffman encoding of the lengths of all the code strings (in
    14|  * ascending order by source values).  The actual code strings are
    15|  * reconstructed from the lengths in the inflate process, as described
    16|  * in the deflate specification.
    17|  *
    18|  *  REFERENCES
    19|  *
    20|  *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
    21|  *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
    22|  *
    23|  *      Storer, James A.
    24|  *          Data Compression:  Methods and Theory, pp. 49-50.
    25|  *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
    26|  *
    27|  *      Sedgewick, R.
    28|  *          Algorithms, p290.
    29|  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
    30|  */
    31| /* @(#) $Id$ */
    32| /* #define GEN_TREES_H */
    33| #include "deflate.h"
    34| #ifdef ZLIB_DEBUG
    35| #  include <ctype.h>
    36| #endif
    37| /* ===========================================================================
    38|  * Constants
    39|  */
    40| #define MAX_BL_BITS 7
    41| /* Bit length codes must not exceed MAX_BL_BITS bits */
    42| #define REP_3_6      16
    43| /* repeat previous bit length 3-6 times (2 bits of repeat count) */
    44| #define REPZ_3_10    17
    45| /* repeat a zero length 3-10 times  (3 bits of repeat count) */
    46| #define REPZ_11_138  18
    47| /* repeat a zero length 11-138 times  (7 bits of repeat count) */
    48| local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
    49|    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
    50| local const int extra_dbits[D_CODES] /* extra bits for each distance code */
    51|    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
    52| local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
    53|    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
    54| local const uch bl_order[BL_CODES]
    55|    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
    56| /* The lengths of the bit length codes are sent in order of decreasing
    57|  * probability, to avoid transmitting the lengths for unused bit length codes.
    58|  */
    59| /* ===========================================================================
    60|  * Local data. These are initialized only once.
    61|  */
    62| #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
    63| #if defined(GEN_TREES_H) || !defined(STDC)
    64| /* non ANSI compilers may not accept trees.h */
    65| ZLIB_INTERNAL ct_data static_ltree[L_CODES+2];
    66| /* The static literal tree. Since the bit lengths are imposed, there is no
    67|  * need for the L_CODES extra codes used during heap construction. However
    68|  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
    69|  * below).
    70|  */
    71| local ct_data static_dtree[D_CODES];
    72| /* The static distance tree. (Actually a trivial tree since all codes use
    73|  * 5 bits.)
    74|  */
    75| uch _dist_code[DIST_CODE_LEN];
    76| /* Distance codes. The first 256 values correspond to the distances
    77|  * 3 .. 258, the last 256 values correspond to the top 8 bits of
    78|  * the 15 bit distances.
    79|  */
    80| uch _length_code[MAX_MATCH-MIN_MATCH+1];
    81| /* length code for each normalized match length (0 == MIN_MATCH) */
    82| local int base_length[LENGTH_CODES];
    83| /* First normalized length for each code (0 = MIN_MATCH) */
    84| local int base_dist[D_CODES];
    85| /* First normalized distance for each code (0 = distance of 1) */
    86| #else
    87| #  include "trees.h"
    88| #endif /* GEN_TREES_H */
    89| struct static_tree_desc_s {
    90|     const ct_data *static_tree;  /* static tree or NULL */
    91|     const intf *extra_bits;      /* extra bits for each code or NULL */
    92|     int     extra_base;          /* base index for extra_bits */
    93|     int     elems;               /* max number of elements in the tree */
    94|     int     max_length;          /* max bit length for the codes */
    95| };
    96| local const static_tree_desc  static_l_desc =
    97| {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
    98| local const static_tree_desc  static_d_desc =
    99| {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
   100| local const static_tree_desc  static_bl_desc =
   101| {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
   102| /* ===========================================================================
   103|  * Local (static) routines in this file.
   104|  */
   105| local void tr_static_init OF((void));
   106| local void init_block     OF((deflate_state *s));
   107| local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
   108| local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
   109| local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
   110| local void build_tree     OF((deflate_state *s, tree_desc *desc));
   111| local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
   112| local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
   113| local int  build_bl_tree  OF((deflate_state *s));
   114| local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
   115|                               int blcodes));
   116| local void compress_block OF((deflate_state *s, const ct_data *ltree,
   117|                               const ct_data *dtree));
   118| local int  detect_data_type OF((deflate_state *s));
   119| local unsigned bi_reverse OF((unsigned code, int len));
   120| local void bi_flush       OF((deflate_state *s));
   121| #ifdef GEN_TREES_H
   122| local void gen_trees_header OF((void));
   123| #endif
   124| #ifndef ZLIB_DEBUG
   125| #  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   126|    /* Send a code of the given tree. c and tree must not have side effects */
   127| #else /* !ZLIB_DEBUG */
   128| #  define send_code(s, c, tree) \
   129|      { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
   130|        send_bits(s, tree[c].Code, tree[c].Len); }
   131| #endif
   132| /* ===========================================================================
   133|  * Output a short LSB first on the stream.
   134|  * IN assertion: there is enough room in pendingBuf.
   135|  */
   136| #define put_short(s, w) { \
   137|     put_byte(s, (uch)((w) & 0xff)); \
   138|     put_byte(s, (uch)((ush)(w) >> 8)); \
   139| }
   140| /* ===========================================================================
   141|  * Send a value on a given number of bits.
   142|  * IN assertion: length <= 16 and value fits in length bits.
   143|  */
   144| #ifdef ZLIB_DEBUG
   145| local void send_bits      OF((deflate_state *s, int value, int length));
   146| local void send_bits(s, value, length)
   147|     deflate_state *s;
   148|     int value;  /* value to send */
   149|     int length; /* number of bits */
   150| {
   151|     Tracevv((stderr," l %2d v %4x ", length, value));
   152|     Assert(length > 0 && length <= 15, "invalid length");
   153|     s->bits_sent += (ulg)length;
   154|     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
   155|      * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))
   156|      * unused bits in value.
   157|      */
   158|     if (s->bi_valid > (int)Buf_size - length) {
   159|         s->bi_buf |= (ush)value << s->bi_valid;
   160|         put_short(s, s->bi_buf);
   161|         s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
   162|         s->bi_valid += length - Buf_size;
   163|     } else {
   164|         s->bi_buf |= (ush)value << s->bi_valid;
   165|         s->bi_valid += length;
   166|     }
   167| }
   168| #else /* !ZLIB_DEBUG */
   169| #define send_bits(s, value, length) \
   170| { int len = length;\
   171|   if (s->bi_valid > (int)Buf_size - len) {\
   172|     int val = (int)value;\
   173|     s->bi_buf |= (ush)val << s->bi_valid;\
   174|     put_short(s, s->bi_buf);\
   175|     s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
   176|     s->bi_valid += len - Buf_size;\
   177|   } else {\
   178|     s->bi_buf |= (ush)(value) << s->bi_valid;\
   179|     s->bi_valid += len;\
   180|   }\
   181| }
   182| #endif /* ZLIB_DEBUG */
   183| /* the arguments must not have side effects */
   184| /* ===========================================================================
   185|  * Initialize the various 'constant' tables.
   186|  */
   187| local void tr_static_init()
   188| {
   189| #if defined(GEN_TREES_H) || !defined(STDC)
   190|     static int static_init_done = 0;
   191|     int n;        /* iterates over tree elements */
   192|     int bits;     /* bit counter */
   193|     int length;   /* length value */
   194|     int code;     /* code value */
   195|     int dist;     /* distance index */
   196|     ush bl_count[MAX_BITS+1];
   197|     /* number of codes at each bit length for an optimal tree */
   198|     if (static_init_done) return;
   199|     /* For some embedded targets, global variables are not initialized: */
   200| #ifdef NO_INIT_GLOBAL_POINTERS
   201|     static_l_desc.static_tree = static_ltree;
   202|     static_l_desc.extra_bits = extra_lbits;
   203|     static_d_desc.static_tree = static_dtree;
   204|     static_d_desc.extra_bits = extra_dbits;
   205|     static_bl_desc.extra_bits = extra_blbits;
   206| #endif
   207|     /* Initialize the mapping length (0..255) -> length code (0..28) */
   208|     length = 0;
   209|     for (code = 0; code < LENGTH_CODES-1; code++) {
   210|         base_length[code] = length;
   211|         for (n = 0; n < (1 << extra_lbits[code]); n++) {
   212|             _length_code[length++] = (uch)code;
   213|         }
   214|     }
   215|     Assert (length == 256, "tr_static_init: length != 256");
   216|     /* Note that the length 255 (match length 258) can be represented
   217|      * in two different ways: code 284 + 5 bits or code 285, so we
   218|      * overwrite length_code[255] to use the best encoding:
   219|      */
   220|     _length_code[length - 1] = (uch)code;
   221|     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
   222|     dist = 0;
   223|     for (code = 0 ; code < 16; code++) {
   224|         base_dist[code] = dist;
   225|         for (n = 0; n < (1 << extra_dbits[code]); n++) {
   226|             _dist_code[dist++] = (uch)code;
   227|         }
   228|     }
   229|     Assert (dist == 256, "tr_static_init: dist != 256");
   230|     dist >>= 7; /* from now on, all distances are divided by 128 */
   231|     for ( ; code < D_CODES; code++) {
   232|         base_dist[code] = dist << 7;
   233|         for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
   234|             _dist_code[256 + dist++] = (uch)code;
   235|         }
   236|     }
   237|     Assert (dist == 256, "tr_static_init: 256 + dist != 512");
   238|     /* Construct the codes of the static literal tree */
   239|     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
   240|     n = 0;
   241|     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
   242|     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
   243|     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
   244|     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
   245|     /* Codes 286 and 287 do not exist, but we must include them in the
   246|      * tree construction to get a canonical Huffman tree (longest code
   247|      * all ones)
   248|      */
   249|     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
   250|     /* The static distance tree is trivial: */
   251|     for (n = 0; n < D_CODES; n++) {
   252|         static_dtree[n].Len = 5;
   253|         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
   254|     }
   255|     static_init_done = 1;
   256| #  ifdef GEN_TREES_H
   257|     gen_trees_header();
   258| #  endif
   259| #endif /* defined(GEN_TREES_H) || !defined(STDC) */
   260| }
   261| /* ===========================================================================
   262|  * Generate the file trees.h describing the static trees.
   263|  */
   264| #ifdef GEN_TREES_H
   265| #  ifndef ZLIB_DEBUG
   266| #    include <stdio.h>
   267| #  endif
   268| #  define SEPARATOR(i, last, width) \
   269|       ((i) == (last)? "\n};\n\n" :    \
   270|        ((i) % (width) == (width) - 1 ? ",\n" : ", "))
   271| void gen_trees_header()
   272| {
   273|     FILE *header = fopen("trees.h", "w");
   274|     int i;
   275|     Assert (header != NULL, "Can't open trees.h");
   276|     fprintf(header,
   277|             "/* header created automatically with -DGEN_TREES_H */\n\n");
   278|     fprintf(header, "ZLIB_INTERNAL const ct_data static_ltree[L_CODES+2] = {\n");
   279|     for (i = 0; i < L_CODES+2; i++) {
   280|         fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
   281|                 static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
   282|     }
   283|     fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
   284|     for (i = 0; i < D_CODES; i++) {
   285|         fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
   286|                 static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
   287|     }
   288|     fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
   289|     for (i = 0; i < DIST_CODE_LEN; i++) {
   290|         fprintf(header, "%2u%s", _dist_code[i],
   291|                 SEPARATOR(i, DIST_CODE_LEN-1, 20));
   292|     }
   293|     fprintf(header,
   294|         "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
   295|     for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
   296|         fprintf(header, "%2u%s", _length_code[i],
   297|                 SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
   298|     }
   299|     fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
   300|     for (i = 0; i < LENGTH_CODES; i++) {
   301|         fprintf(header, "%1u%s", base_length[i],
   302|                 SEPARATOR(i, LENGTH_CODES-1, 20));
   303|     }
   304|     fprintf(header, "local const int base_dist[D_CODES] = {\n");
   305|     for (i = 0; i < D_CODES; i++) {
   306|         fprintf(header, "%5u%s", base_dist[i],
   307|                 SEPARATOR(i, D_CODES-1, 10));
   308|     }
   309|     fclose(header);
   310| }
   311| #endif /* GEN_TREES_H */
   312| /* ===========================================================================
   313|  * Initialize the tree data structures for a new zlib stream.
   314|  */
   315| void ZLIB_INTERNAL _tr_init(s)
   316|     deflate_state *s;
   317| {
   318|     tr_static_init();
   319|     s->l_desc.dyn_tree = s->dyn_ltree;
   320|     s->l_desc.stat_desc = &static_l_desc;
   321|     s->d_desc.dyn_tree = s->dyn_dtree;
   322|     s->d_desc.stat_desc = &static_d_desc;
   323|     s->bl_desc.dyn_tree = s->bl_tree;
   324|     s->bl_desc.stat_desc = &static_bl_desc;
   325|     s->bi_buf = 0;
   326|     s->bi_valid = 0;
   327| #ifdef ZLIB_DEBUG
   328|     s->compressed_len = 0L;
   329|     s->bits_sent = 0L;
   330| #endif
   331|     /* Initialize the first block of the first file: */
   332|     init_block(s);
   333| }
   334| /* ===========================================================================
   335|  * Initialize a new block.
   336|  */
   337| local void init_block(s)
   338|     deflate_state *s;
   339| {
   340|     int n; /* iterates over tree elements */
   341|     /* Initialize the trees. */
   342|     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
   343|     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
   344|     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
   345|     s->dyn_ltree[END_BLOCK].Freq = 1;
   346|     s->opt_len = s->static_len = 0L;
   347|     s->sym_next = s->matches = 0;
   348| }
   349| #define SMALLEST 1
   350| /* Index within the heap array of least frequent node in the Huffman tree */
   351| /* ===========================================================================
   352|  * Remove the smallest element from the heap and recreate the heap with
   353|  * one less element. Updates heap and heap_len.
   354|  */
   355| #define pqremove(s, tree, top) \
   356| {\
   357|     top = s->heap[SMALLEST]; \
   358|     s->heap[SMALLEST] = s->heap[s->heap_len--]; \
   359|     pqdownheap(s, tree, SMALLEST); \
   360| }
   361| /* ===========================================================================
   362|  * Compares to subtrees, using the tree depth as tie breaker when
   363|  * the subtrees have equal frequency. This minimizes the worst case length.
   364|  */
   365| #define smaller(tree, n, m, depth) \
   366|    (tree[n].Freq < tree[m].Freq || \
   367|    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
   368| /* ===========================================================================
   369|  * Restore the heap property by moving down the tree starting at node k,
   370|  * exchanging a node with the smallest of its two sons if necessary, stopping
   371|  * when the heap property is re-established (each father smaller than its
   372|  * two sons).
   373|  */
   374| local void pqdownheap(s, tree, k)
   375|     deflate_state *s;
   376|     ct_data *tree;  /* the tree to restore */
   377|     int k;               /* node to move down */
   378| {
   379|     int v = s->heap[k];
   380|     int j = k << 1;  /* left son of k */
   381|     while (j <= s->heap_len) {
   382|         /* Set j to the smallest of the two sons: */
   383|         if (j < s->heap_len &&
   384|             smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
   385|             j++;
   386|         }
   387|         /* Exit if v is smaller than both sons */
   388|         if (smaller(tree, v, s->heap[j], s->depth)) break;
   389|         /* Exchange v with the smallest son */
   390|         s->heap[k] = s->heap[j];  k = j;
   391|         /* And continue down the tree, setting j to the left son of k */
   392|         j <<= 1;
   393|     }
   394|     s->heap[k] = v;
   395| }
   396| /* ===========================================================================
   397|  * Compute the optimal bit lengths for a tree and update the total bit length
   398|  * for the current block.
   399|  * IN assertion: the fields freq and dad are set, heap[heap_max] and
   400|  *    above are the tree nodes sorted by increasing frequency.
   401|  * OUT assertions: the field len is set to the optimal bit length, the
   402|  *     array bl_count contains the frequencies for each bit length.
   403|  *     The length opt_len is updated; static_len is also updated if stree is
   404|  *     not null.
   405|  */
   406| local void gen_bitlen(s, desc)
   407|     deflate_state *s;
   408|     tree_desc *desc;    /* the tree descriptor */
   409| {
   410|     ct_data *tree        = desc->dyn_tree;
   411|     int max_code         = desc->max_code;
   412|     const ct_data *stree = desc->stat_desc->static_tree;
   413|     const intf *extra    = desc->stat_desc->extra_bits;
   414|     int base             = desc->stat_desc->extra_base;
   415|     int max_length       = desc->stat_desc->max_length;
   416|     int h;              /* heap index */
   417|     int n, m;           /* iterate over the tree elements */
   418|     int bits;           /* bit length */
   419|     int xbits;          /* extra bits */
   420|     ush f;              /* frequency */
   421|     int overflow = 0;   /* number of elements with bit length too large */
   422|     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
   423|     /* In a first pass, compute the optimal bit lengths (which may
   424|      * overflow in the case of the bit length tree).
   425|      */
   426|     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
   427|     for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
   428|         n = s->heap[h];
   429|         bits = tree[tree[n].Dad].Len + 1;
   430|         if (bits > max_length) bits = max_length, overflow++;
   431|         tree[n].Len = (ush)bits;
   432|         /* We overwrite tree[n].Dad which is no longer needed */
   433|         if (n > max_code) continue; /* not a leaf node */
   434|         s->bl_count[bits]++;
   435|         xbits = 0;
   436|         if (n >= base) xbits = extra[n - base];
   437|         f = tree[n].Freq;
   438|         s->opt_len += (ulg)f * (unsigned)(bits + xbits);
   439|         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
   440|     }
   441|     if (overflow == 0) return;
   442|     Tracev((stderr,"\nbit length overflow\n"));
   443|     /* This happens for example on obj2 and pic of the Calgary corpus */
   444|     /* Find the first bit length which could increase: */
   445|     do {
   446|         bits = max_length - 1;
   447|         while (s->bl_count[bits] == 0) bits--;
   448|         s->bl_count[bits]--;        /* move one leaf down the tree */
   449|         s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
   450|         s->bl_count[max_length]--;
   451|         /* The brother of the overflow item also moves one step up,
   452|          * but this does not affect bl_count[max_length]
   453|          */
   454|         overflow -= 2;
   455|     } while (overflow > 0);
   456|     /* Now recompute all bit lengths, scanning in increasing frequency.
   457|      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   458|      * lengths instead of fixing only the wrong ones. This idea is taken
   459|      * from 'ar' written by Haruhiko Okumura.)
   460|      */
   461|     for (bits = max_length; bits != 0; bits--) {
   462|         n = s->bl_count[bits];
   463|         while (n != 0) {
   464|             m = s->heap[--h];
   465|             if (m > max_code) continue;
   466|             if ((unsigned) tree[m].Len != (unsigned) bits) {
   467|                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
   468|                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
   469|                 tree[m].Len = (ush)bits;
   470|             }
   471|             n--;
   472|         }
   473|     }
   474| }
   475| /* ===========================================================================
   476|  * Generate the codes for a given tree and bit counts (which need not be
   477|  * optimal).
   478|  * IN assertion: the array bl_count contains the bit length statistics for
   479|  * the given tree and the field len is set for all tree elements.
   480|  * OUT assertion: the field code is set for all tree elements of non
   481|  *     zero code length.
   482|  */
   483| local void gen_codes(tree, max_code, bl_count)
   484|     ct_data *tree;             /* the tree to decorate */
   485|     int max_code;              /* largest code with non zero frequency */
   486|     ushf *bl_count;            /* number of codes at each bit length */
   487| {
   488|     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
   489|     unsigned code = 0;         /* running code value */
   490|     int bits;                  /* bit index */
   491|     int n;                     /* code index */
   492|     /* The distribution counts are first used to generate the code values
   493|      * without bit reversal.
   494|      */
   495|     for (bits = 1; bits <= MAX_BITS; bits++) {
   496|         code = (code + bl_count[bits - 1]) << 1;
   497|         next_code[bits] = (ush)code;
   498|     }
   499|     /* Check that the bit counts in bl_count are consistent. The last code
   500|      * must be all ones.
   501|      */
   502|     Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
   503|             "inconsistent bit counts");
   504|     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
   505|     for (n = 0;  n <= max_code; n++) {
   506|         int len = tree[n].Len;
   507|         if (len == 0) continue;
   508|         /* Now reverse the bits */
   509|         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
   510|         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
   511|             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
   512|     }
   513| }
   514| /* ===========================================================================
   515|  * Construct one Huffman tree and assigns the code bit strings and lengths.
   516|  * Update the total bit length for the current block.
   517|  * IN assertion: the field freq is set for all tree elements.
   518|  * OUT assertions: the fields len and code are set to the optimal bit length
   519|  *     and corresponding code. The length opt_len is updated; static_len is
   520|  *     also updated if stree is not null. The field max_code is set.
   521|  */
   522| local void build_tree(s, desc)
   523|     deflate_state *s;
   524|     tree_desc *desc; /* the tree descriptor */
   525| {
   526|     ct_data *tree         = desc->dyn_tree;
   527|     const ct_data *stree  = desc->stat_desc->static_tree;
   528|     int elems             = desc->stat_desc->elems;
   529|     int n, m;          /* iterate over heap elements */
   530|     int max_code = -1; /* largest code with non zero frequency */
   531|     int node;          /* new node being created */
   532|     /* Construct the initial heap, with least frequent element in
   533|      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
   534|      * heap[0] is not used.
   535|      */
   536|     s->heap_len = 0, s->heap_max = HEAP_SIZE;
   537|     for (n = 0; n < elems; n++) {
   538|         if (tree[n].Freq != 0) {
   539|             s->heap[++(s->heap_len)] = max_code = n;
   540|             s->depth[n] = 0;
   541|         } else {
   542|             tree[n].Len = 0;
   543|         }
   544|     }
   545|     /* The pkzip format requires that at least one distance code exists,
   546|      * and that at least one bit should be sent even if there is only one
   547|      * possible code. So to avoid special checks later on we force at least
   548|      * two codes of non zero frequency.
   549|      */
   550|     while (s->heap_len < 2) {
   551|         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
   552|         tree[node].Freq = 1;
   553|         s->depth[node] = 0;
   554|         s->opt_len--; if (stree) s->static_len -= stree[node].Len;
   555|         /* node is 0 or 1 so it does not have extra bits */
   556|     }
   557|     desc->max_code = max_code;
   558|     /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
   559|      * establish sub-heaps of increasing lengths:
   560|      */
   561|     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
   562|     /* Construct the Huffman tree by repeatedly combining the least two
   563|      * frequent nodes.
   564|      */
   565|     node = elems;              /* next internal node of the tree */
   566|     do {
   567|         pqremove(s, tree, n);  /* n = node of least frequency */
   568|         m = s->heap[SMALLEST]; /* m = node of next least frequency */
   569|         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
   570|         s->heap[--(s->heap_max)] = m;
   571|         /* Create a new node father of n and m */
   572|         tree[node].Freq = tree[n].Freq + tree[m].Freq;
   573|         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
   574|                                 s->depth[n] : s->depth[m]) + 1);
   575|         tree[n].Dad = tree[m].Dad = (ush)node;
   576| #ifdef DUMP_BL_TREE
   577|         if (tree == s->bl_tree) {
   578|             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
   579|                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
   580|         }
   581| #endif
   582|         /* and insert the new node in the heap */
   583|         s->heap[SMALLEST] = node++;
   584|         pqdownheap(s, tree, SMALLEST);
   585|     } while (s->heap_len >= 2);
   586|     s->heap[--(s->heap_max)] = s->heap[SMALLEST];
   587|     /* At this point, the fields freq and dad are set. We can now
   588|      * generate the bit lengths.
   589|      */
   590|     gen_bitlen(s, (tree_desc *)desc);
   591|     /* The field len is now set, we can generate the bit codes */
   592|     gen_codes ((ct_data *)tree, max_code, s->bl_count);
   593| }
   594| /* ===========================================================================
   595|  * Scan a literal or distance tree to determine the frequencies of the codes
   596|  * in the bit length tree.
   597|  */
   598| local void scan_tree(s, tree, max_code)
   599|     deflate_state *s;
   600|     ct_data *tree;   /* the tree to be scanned */
   601|     int max_code;    /* and its largest code of non zero frequency */
   602| {
   603|     int n;                     /* iterates over all tree elements */
   604|     int prevlen = -1;          /* last emitted length */
   605|     int curlen;                /* length of current code */
   606|     int nextlen = tree[0].Len; /* length of next code */
   607|     int count = 0;             /* repeat count of the current code */
   608|     int max_count = 7;         /* max repeat count */
   609|     int min_count = 4;         /* min repeat count */
   610|     if (nextlen == 0) max_count = 138, min_count = 3;
   611|     tree[max_code + 1].Len = (ush)0xffff; /* guard */
   612|     for (n = 0; n <= max_code; n++) {
   613|         curlen = nextlen; nextlen = tree[n + 1].Len;
   614|         if (++count < max_count && curlen == nextlen) {
   615|             continue;
   616|         } else if (count < min_count) {
   617|             s->bl_tree[curlen].Freq += count;
   618|         } else if (curlen != 0) {
   619|             if (curlen != prevlen) s->bl_tree[curlen].Freq++;
   620|             s->bl_tree[REP_3_6].Freq++;
   621|         } else if (count <= 10) {
   622|             s->bl_tree[REPZ_3_10].Freq++;
   623|         } else {
   624|             s->bl_tree[REPZ_11_138].Freq++;
   625|         }
   626|         count = 0; prevlen = curlen;
   627|         if (nextlen == 0) {
   628|             max_count = 138, min_count = 3;
   629|         } else if (curlen == nextlen) {
   630|             max_count = 6, min_count = 3;
   631|         } else {
   632|             max_count = 7, min_count = 4;
   633|         }
   634|     }
   635| }
   636| /* ===========================================================================
   637|  * Send a literal or distance tree in compressed form, using the codes in
   638|  * bl_tree.
   639|  */
   640| local void send_tree(s, tree, max_code)
   641|     deflate_state *s;
   642|     ct_data *tree; /* the tree to be scanned */
   643|     int max_code;       /* and its largest code of non zero frequency */
   644| {
   645|     int n;                     /* iterates over all tree elements */
   646|     int prevlen = -1;          /* last emitted length */
   647|     int curlen;                /* length of current code */
   648|     int nextlen = tree[0].Len; /* length of next code */
   649|     int count = 0;             /* repeat count of the current code */
   650|     int max_count = 7;         /* max repeat count */
   651|     int min_count = 4;         /* min repeat count */
   652|     /* tree[max_code + 1].Len = -1; */  /* guard already set */
   653|     if (nextlen == 0) max_count = 138, min_count = 3;
   654|     for (n = 0; n <= max_code; n++) {
   655|         curlen = nextlen; nextlen = tree[n + 1].Len;
   656|         if (++count < max_count && curlen == nextlen) {
   657|             continue;
   658|         } else if (count < min_count) {
   659|             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
   660|         } else if (curlen != 0) {
   661|             if (curlen != prevlen) {
   662|                 send_code(s, curlen, s->bl_tree); count--;
   663|             }
   664|             Assert(count >= 3 && count <= 6, " 3_6?");
   665|             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);
   666|         } else if (count <= 10) {
   667|             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);
   668|         } else {
   669|             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);
   670|         }
   671|         count = 0; prevlen = curlen;
   672|         if (nextlen == 0) {
   673|             max_count = 138, min_count = 3;
   674|         } else if (curlen == nextlen) {
   675|             max_count = 6, min_count = 3;
   676|         } else {
   677|             max_count = 7, min_count = 4;
   678|         }
   679|     }
   680| }
   681| /* ===========================================================================
   682|  * Construct the Huffman tree for the bit lengths and return the index in
   683|  * bl_order of the last bit length code to send.
   684|  */
   685| local int build_bl_tree(s)
   686|     deflate_state *s;
   687| {
   688|     int max_blindex;  /* index of last bit length code of non zero freq */
   689|     /* Determine the bit length frequencies for literal and distance trees */
   690|     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
   691|     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
   692|     /* Build the bit length tree: */
   693|     build_tree(s, (tree_desc *)(&(s->bl_desc)));
   694|     /* opt_len now includes the length of the tree representations, except the
   695|      * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
   696|      */
   697|     /* Determine the number of bit length codes to send. The pkzip format
   698|      * requires that at least 4 bit length codes be sent. (appnote.txt says
   699|      * 3 but the actual value used is 4.)
   700|      */
   701|     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
   702|         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
   703|     }
   704|     /* Update opt_len to include the bit length tree and counts */
   705|     s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;
   706|     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
   707|             s->opt_len, s->static_len));
   708|     return max_blindex;
   709| }
   710| /* ===========================================================================
   711|  * Send the header for a block using dynamic Huffman trees: the counts, the
   712|  * lengths of the bit length codes, the literal tree and the distance tree.
   713|  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   714|  */
   715| local void send_all_trees(s, lcodes, dcodes, blcodes)
   716|     deflate_state *s;
   717|     int lcodes, dcodes, blcodes; /* number of codes for each tree */
   718| {
   719|     int rank;                    /* index in bl_order */
   720|     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
   721|     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
   722|             "too many codes");
   723|     Tracev((stderr, "\nbl counts: "));
   724|     send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */
   725|     send_bits(s, dcodes - 1,   5);
   726|     send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */
   727|     for (rank = 0; rank < blcodes; rank++) {
   728|         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
   729|         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
   730|     }
   731|     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
   732|     send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */
   733|     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
   734|     send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */
   735|     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
   736| }
   737| /* ===========================================================================
   738|  * Send a stored block
   739|  */
   740| void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
   741|     deflate_state *s;
   742|     charf *buf;       /* input block */
   743|     ulg stored_len;   /* length of input block */
   744|     int last;         /* one if this is the last block for a file */
   745| {
   746|     send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */
   747|     bi_windup(s);        /* align on byte boundary */
   748|     put_short(s, (ush)stored_len);
   749|     put_short(s, (ush)~stored_len);
   750|     if (stored_len)
   751|         zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
   752|     s->pending += stored_len;
   753| #ifdef ZLIB_DEBUG
   754|     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
   755|     s->compressed_len += (stored_len + 4) << 3;
   756|     s->bits_sent += 2*16;
   757|     s->bits_sent += stored_len << 3;
   758| #endif
   759| }
   760| /* ===========================================================================
   761|  * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
   762|  */
   763| void ZLIB_INTERNAL _tr_flush_bits(s)
   764|     deflate_state *s;
   765| {
   766|     bi_flush(s);
   767| }
   768| /* ===========================================================================
   769|  * Send one empty static block to give enough lookahead for inflate.
   770|  * This takes 10 bits, of which 7 may remain in the bit buffer.
   771|  */
   772| void ZLIB_INTERNAL _tr_align(s)
   773|     deflate_state *s;
   774| {
   775|     send_bits(s, STATIC_TREES<<1, 3);
   776|     send_code(s, END_BLOCK, static_ltree);
   777| #ifdef ZLIB_DEBUG
   778|     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
   779| #endif
   780|     bi_flush(s);
   781| }
   782| /* ===========================================================================
   783|  * Determine the best encoding for the current block: dynamic trees, static
   784|  * trees or store, and write out the encoded block.
   785|  */
   786| void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
   787|     deflate_state *s;
   788|     charf *buf;       /* input block, or NULL if too old */
   789|     ulg stored_len;   /* length of input block */
   790|     int last;         /* one if this is the last block for a file */
   791| {
   792|     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
   793|     int max_blindex = 0;  /* index of last bit length code of non zero freq */
   794|     /* Build the Huffman trees unless a stored block is forced */
   795|     if (s->level > 0) {
   796|         /* Check if the file is binary or text */
   797|         if (s->strm->data_type == Z_UNKNOWN)
   798|             s->strm->data_type = detect_data_type(s);
   799|         /* Construct the literal and distance trees */
   800|         build_tree(s, (tree_desc *)(&(s->l_desc)));
   801|         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
   802|                 s->static_len));
   803|         build_tree(s, (tree_desc *)(&(s->d_desc)));
   804|         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
   805|                 s->static_len));
   806|         /* At this point, opt_len and static_len are the total bit lengths of
   807|          * the compressed block data, excluding the tree representations.
   808|          */
   809|         /* Build the bit length tree for the above two trees, and get the index
   810|          * in bl_order of the last bit length code to send.
   811|          */
   812|         max_blindex = build_bl_tree(s);
   813|         /* Determine the best encoding. Compute the block lengths in bytes. */
   814|         opt_lenb = (s->opt_len + 3 + 7) >> 3;
   815|         static_lenb = (s->static_len + 3 + 7) >> 3;
   816|         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
   817|                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
   818|                 s->sym_next / 3));
   819| #ifndef FORCE_STATIC
   820|         if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)
   821| #endif
   822|             opt_lenb = static_lenb;
   823|     } else {
   824|         Assert(buf != (char*)0, "lost buf");
   825|         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
   826|     }
   827| #ifdef FORCE_STORED
   828|     if (buf != (char*)0) { /* force stored block */
   829| #else
   830|     if (stored_len + 4 <= opt_lenb && buf != (char*)0) {
   831|                        /* 4: two words for the lengths */
   832| #endif
   833|         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
   834|          * Otherwise we can't have processed more than WSIZE input bytes since
   835|          * the last block flush, because compression would have been
   836|          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
   837|          * transform a block into a stored block.
   838|          */
   839|         _tr_stored_block(s, buf, stored_len, last);
   840|     } else if (static_lenb == opt_lenb) {
   841|         send_bits(s, (STATIC_TREES<<1) + last, 3);
   842|         compress_block(s, (const ct_data *)static_ltree,
   843|                        (const ct_data *)static_dtree);
   844| #ifdef ZLIB_DEBUG
   845|         s->compressed_len += 3 + s->static_len;
   846| #endif
   847|     } else {
   848|         send_bits(s, (DYN_TREES<<1) + last, 3);
   849|         send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,
   850|                        max_blindex + 1);
   851|         compress_block(s, (const ct_data *)s->dyn_ltree,
   852|                        (const ct_data *)s->dyn_dtree);
   853| #ifdef ZLIB_DEBUG
   854|         s->compressed_len += 3 + s->opt_len;
   855| #endif
   856|     }
   857|     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
   858|     /* The above check is made mod 2^32, for files larger than 512 MB
   859|      * and uLong implemented on 32 bits.
   860|      */
   861|     init_block(s);
   862|     if (last) {
   863|         bi_windup(s);
   864| #ifdef ZLIB_DEBUG
   865|         s->compressed_len += 7;  /* align on byte boundary */
   866| #endif
   867|     }
   868|     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
   869|            s->compressed_len - 7*last));
   870| }
   871| /* ===========================================================================
   872|  * Save the match info and tally the frequency counts. Return true if
   873|  * the current block must be flushed.
   874|  */
   875| int ZLIB_INTERNAL _tr_tally(s, dist, lc)
   876|     deflate_state *s;
   877|     unsigned dist;  /* distance of matched string */
   878|     unsigned lc;    /* match length - MIN_MATCH or unmatched char (dist==0) */
   879| {
   880|     s->sym_buf[s->sym_next++] = (uch)dist;
   881|     s->sym_buf[s->sym_next++] = (uch)(dist >> 8);
   882|     s->sym_buf[s->sym_next++] = (uch)lc;
   883|     if (dist == 0) {
   884|         /* lc is the unmatched char */
   885|         s->dyn_ltree[lc].Freq++;
   886|     } else {
   887|         s->matches++;
   888|         /* Here, lc is the match length - MIN_MATCH */
   889|         dist--;             /* dist = match distance - 1 */
   890|         Assert((ush)dist < (ush)MAX_DIST(s) &&
   891|                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
   892|                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
   893|         s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
   894|         s->dyn_dtree[d_code(dist)].Freq++;
   895|     }
   896|     return (s->sym_next == s->sym_end);
   897| }
   898| /* ===========================================================================
   899|  * Send the block data compressed using the given Huffman trees
   900|  */
   901| local void compress_block(s, ltree, dtree)
   902|     deflate_state *s;
   903|     const ct_data *ltree; /* literal tree */
   904|     const ct_data *dtree; /* distance tree */
   905| {
   906|     unsigned dist;      /* distance of matched string */
   907|     int lc;             /* match length or unmatched char (if dist == 0) */
   908|     unsigned sx = 0;    /* running index in sym_buf */
   909|     unsigned code;      /* the code to send */
   910|     int extra;          /* number of extra bits to send */
   911|     if (s->sym_next != 0) do {
   912|         dist = s->sym_buf[sx++] & 0xff;
   913|         dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;
   914|         lc = s->sym_buf[sx++];
   915|         if (dist == 0) {
   916|             send_code(s, lc, ltree); /* send a literal byte */
   917|             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
   918|         } else {
   919|             /* Here, lc is the match length - MIN_MATCH */
   920|             code = _length_code[lc];
   921|             send_code(s, code + LITERALS + 1, ltree);   /* send length code */
   922|             extra = extra_lbits[code];
   923|             if (extra != 0) {
   924|                 lc -= base_length[code];
   925|                 send_bits(s, lc, extra);       /* send the extra length bits */
   926|             }
   927|             dist--; /* dist is now the match distance - 1 */
   928|             code = d_code(dist);
   929|             Assert (code < D_CODES, "bad d_code");
   930|             send_code(s, code, dtree);       /* send the distance code */
   931|             extra = extra_dbits[code];
   932|             if (extra != 0) {
   933|                 dist -= (unsigned)base_dist[code];
   934|                 send_bits(s, dist, extra);   /* send the extra distance bits */
   935|             }
   936|         } /* literal or match pair ? */
   937|         /* Check that the overlay between pending_buf and sym_buf is ok: */
   938|         Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
   939|     } while (sx < s->sym_next);
   940|     send_code(s, END_BLOCK, ltree);
   941| }
   942| /* ===========================================================================
   943|  * Check if the data type is TEXT or BINARY, using the following algorithm:
   944|  * - TEXT if the two conditions below are satisfied:
   945|  *    a) There are no non-portable control characters belonging to the
   946|  *       "block list" (0..6, 14..25, 28..31).
   947|  *    b) There is at least one printable character belonging to the
   948|  *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   949|  * - BINARY otherwise.
   950|  * - The following partially-portable control characters form a
   951|  *   "gray list" that is ignored in this detection algorithm:
   952|  *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   953|  * IN assertion: the fields Freq of dyn_ltree are set.
   954|  */
   955| local int detect_data_type(s)
   956|     deflate_state *s;
   957| {
   958|     /* block_mask is the bit mask of block-listed bytes
   959|      * set bits 0..6, 14..25, and 28..31
   960|      * 0xf3ffc07f = binary 11110011111111111100000001111111
   961|      */
   962|     unsigned long block_mask = 0xf3ffc07fUL;
   963|     int n;
   964|     /* Check for non-textual ("block-listed") bytes. */
   965|     for (n = 0; n <= 31; n++, block_mask >>= 1)
   966|         if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))
   967|             return Z_BINARY;
   968|     /* Check for textual ("allow-listed") bytes. */
   969|     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
   970|             || s->dyn_ltree[13].Freq != 0)
   971|         return Z_TEXT;
   972|     for (n = 32; n < LITERALS; n++)
   973|         if (s->dyn_ltree[n].Freq != 0)
   974|             return Z_TEXT;
   975|     /* There are no "block-listed" or "allow-listed" bytes:
   976|      * this stream either is empty or has tolerated ("gray-listed") bytes only.
   977|      */
   978|     return Z_BINARY;
   979| }
   980| /* ===========================================================================
   981|  * Reverse the first len bits of a code, using straightforward code (a faster
   982|  * method would use a table)
   983|  * IN assertion: 1 <= len <= 15
   984|  */
   985| local unsigned bi_reverse(code, len)
   986|     unsigned code; /* the value to invert */
   987|     int len;       /* its bit length */
   988| {
   989|     register unsigned res = 0;
   990|     do {
   991|         res |= code & 1;
   992|         code >>= 1, res <<= 1;
   993|     } while (--len > 0);
   994|     return res >> 1;
   995| }
   996| /* ===========================================================================
   997|  * Flush the bit buffer, keeping at most 7 bits in it.
   998|  */
   999| local void bi_flush(s)
  1000|     deflate_state *s;
  1001| {
  1002|     if (s->bi_valid == 16) {
  1003|         put_short(s, s->bi_buf);
  1004|         s->bi_buf = 0;
  1005|         s->bi_valid = 0;
  1006|     } else if (s->bi_valid >= 8) {
  1007|         put_byte(s, (Byte)s->bi_buf);
  1008|         s->bi_buf >>= 8;
  1009|         s->bi_valid -= 8;
  1010|     }
  1011| }
  1012| /* ===========================================================================
  1013|  * Flush the bit buffer and align the output on a byte boundary
  1014|  */
  1015| ZLIB_INTERNAL void bi_windup(s)
  1016|     deflate_state *s;
  1017| {
  1018|     if (s->bi_valid > 8) {
  1019|         put_short(s, s->bi_buf);
  1020|     } else if (s->bi_valid > 0) {
  1021|         put_byte(s, (Byte)s->bi_buf);
  1022|     }
  1023|     s->bi_buf = 0;
  1024|     s->bi_valid = 0;
  1025| #ifdef ZLIB_DEBUG
  1026|     s->bits_sent = (s->bits_sent + 7) & ~7;
  1027| #endif
  1028| }


# ====================================================================
# FILE: src/native/external/zlib-intel/zconf.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-501 ---
     1| /* zconf.h -- configuration of the zlib compression library
     2|  * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #ifndef ZCONF_H
     7| #define ZCONF_H
     8| /*
     9|  * If you *really* need a unique prefix for all types and library functions,
    10|  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
    11|  * Even better than compiling with -DZ_PREFIX would be to use configure to set
    12|  * this permanently in zconf.h using "./configure --zprefix".
    13|  */
    14| #ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
    15| #  define Z_PREFIX_SET
    16| /* all linked symbols and init macros */
    17| #  define _dist_code            z__dist_code
    18| #  define _length_code          z__length_code
    19| #  define _tr_align             z__tr_align
    20| #  define _tr_flush_bits        z__tr_flush_bits
    21| #  define _tr_flush_block       z__tr_flush_block
    22| #  define _tr_init              z__tr_init
    23| #  define _tr_stored_block      z__tr_stored_block
    24| #  define _tr_tally             z__tr_tally
    25| #  define adler32               z_adler32
    26| #  define adler32_combine       z_adler32_combine
    27| #  define adler32_combine64     z_adler32_combine64
    28| #  define adler32_z             z_adler32_z
    29| #  ifndef Z_SOLO
    30| #    define compress              z_compress
    31| #    define compress2             z_compress2
    32| #    define compressBound         z_compressBound
    33| #  endif
    34| #  define crc32                 z_crc32
    35| #  define crc32_combine         z_crc32_combine
    36| #  define crc32_combine64       z_crc32_combine64
    37| #  define crc32_combine_gen     z_crc32_combine_gen
    38| #  define crc32_combine_gen64   z_crc32_combine_gen64
    39| #  define crc32_combine_op      z_crc32_combine_op
    40| #  define crc32_z               z_crc32_z
    41| #  define deflate               z_deflate
    42| #  define deflateBound          z_deflateBound
    43| #  define deflateCopy           z_deflateCopy
    44| #  define deflateEnd            z_deflateEnd
    45| #  define deflateGetDictionary  z_deflateGetDictionary
    46| #  define deflateInit           z_deflateInit
    47| #  define deflateInit2          z_deflateInit2
    48| #  define deflateInit2_         z_deflateInit2_
    49| #  define deflateInit_          z_deflateInit_
    50| #  define deflateParams         z_deflateParams
    51| #  define deflatePending        z_deflatePending
    52| #  define deflatePrime          z_deflatePrime
    53| #  define deflateReset          z_deflateReset
    54| #  define deflateResetKeep      z_deflateResetKeep
    55| #  define deflateSetDictionary  z_deflateSetDictionary
    56| #  define deflateSetHeader      z_deflateSetHeader
    57| #  define deflateTune           z_deflateTune
    58| #  define deflate_copyright     z_deflate_copyright
    59| #  define get_crc_table         z_get_crc_table
    60| #  ifndef Z_SOLO
    61| #    define gz_error              z_gz_error
    62| #    define gz_intmax             z_gz_intmax
    63| #    define gz_strwinerror        z_gz_strwinerror
    64| #    define gzbuffer              z_gzbuffer
    65| #    define gzclearerr            z_gzclearerr
    66| #    define gzclose               z_gzclose
    67| #    define gzclose_r             z_gzclose_r
    68| #    define gzclose_w             z_gzclose_w
    69| #    define gzdirect              z_gzdirect
    70| #    define gzdopen               z_gzdopen
    71| #    define gzeof                 z_gzeof
    72| #    define gzerror               z_gzerror
    73| #    define gzflush               z_gzflush
    74| #    define gzfread               z_gzfread
    75| #    define gzfwrite              z_gzfwrite
    76| #    define gzgetc                z_gzgetc
    77| #    define gzgetc_               z_gzgetc_
    78| #    define gzgets                z_gzgets
    79| #    define gzoffset              z_gzoffset
    80| #    define gzoffset64            z_gzoffset64
    81| #    define gzopen                z_gzopen
    82| #    define gzopen64              z_gzopen64
    83| #    ifdef _WIN32
    84| #      define gzopen_w              z_gzopen_w
    85| #    endif
    86| #    define gzprintf              z_gzprintf
    87| #    define gzputc                z_gzputc
    88| #    define gzputs                z_gzputs
    89| #    define gzread                z_gzread
    90| #    define gzrewind              z_gzrewind
    91| #    define gzseek                z_gzseek
    92| #    define gzseek64              z_gzseek64
    93| #    define gzsetparams           z_gzsetparams
    94| #    define gztell                z_gztell
    95| #    define gztell64              z_gztell64
    96| #    define gzungetc              z_gzungetc
    97| #    define gzvprintf             z_gzvprintf
    98| #    define gzwrite               z_gzwrite
    99| #  endif
   100| #  define inflate               z_inflate
   101| #  define inflateBack           z_inflateBack
   102| #  define inflateBackEnd        z_inflateBackEnd
   103| #  define inflateBackInit       z_inflateBackInit
   104| #  define inflateBackInit_      z_inflateBackInit_
   105| #  define inflateCodesUsed      z_inflateCodesUsed
   106| #  define inflateCopy           z_inflateCopy
   107| #  define inflateEnd            z_inflateEnd
   108| #  define inflateGetDictionary  z_inflateGetDictionary
   109| #  define inflateGetHeader      z_inflateGetHeader
   110| #  define inflateInit           z_inflateInit
   111| #  define inflateInit2          z_inflateInit2
   112| #  define inflateInit2_         z_inflateInit2_
   113| #  define inflateInit_          z_inflateInit_
   114| #  define inflateMark           z_inflateMark
   115| #  define inflatePrime          z_inflatePrime
   116| #  define inflateReset          z_inflateReset
   117| #  define inflateReset2         z_inflateReset2
   118| #  define inflateResetKeep      z_inflateResetKeep
   119| #  define inflateSetDictionary  z_inflateSetDictionary
   120| #  define inflateSync           z_inflateSync
   121| #  define inflateSyncPoint      z_inflateSyncPoint
   122| #  define inflateUndermine      z_inflateUndermine
   123| #  define inflateValidate       z_inflateValidate
   124| #  define inflate_copyright     z_inflate_copyright
   125| #  define inflate_fast          z_inflate_fast
   126| #  define inflate_table         z_inflate_table
   127| #  ifndef Z_SOLO
   128| #    define uncompress            z_uncompress
   129| #    define uncompress2           z_uncompress2
   130| #  endif
   131| #  define zError                z_zError
   132| #  ifndef Z_SOLO
   133| #    define zcalloc               z_zcalloc
   134| #    define zcfree                z_zcfree
   135| #  endif
   136| #  define zlibCompileFlags      z_zlibCompileFlags
   137| #  define zlibVersion           z_zlibVersion
   138| /* all zlib typedefs in zlib.h and zconf.h */
   139| #  define Byte                  z_Byte
   140| #  define Bytef                 z_Bytef
   141| #  define alloc_func            z_alloc_func
   142| #  define charf                 z_charf
   143| #  define free_func             z_free_func
   144| #  ifndef Z_SOLO
   145| #    define gzFile                z_gzFile
   146| #  endif
   147| #  define gz_header             z_gz_header
   148| #  define gz_headerp            z_gz_headerp
   149| #  define in_func               z_in_func
   150| #  define intf                  z_intf
   151| #  define out_func              z_out_func
   152| #  define uInt                  z_uInt
   153| #  define uIntf                 z_uIntf
   154| #  define uLong                 z_uLong
   155| #  define uLongf                z_uLongf
   156| #  define voidp                 z_voidp
   157| #  define voidpc                z_voidpc
   158| #  define voidpf                z_voidpf
   159| /* all zlib structs in zlib.h and zconf.h */
   160| #  define gz_header_s           z_gz_header_s
   161| #  define internal_state        z_internal_state
   162| #endif
   163| #if defined(__MSDOS__) && !defined(MSDOS)
   164| #  define MSDOS
   165| #endif
   166| #if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
   167| #  define OS2
   168| #endif
   169| #if defined(_WINDOWS) && !defined(WINDOWS)
   170| #  define WINDOWS
   171| #endif
   172| #if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
   173| #  ifndef WIN32
   174| #    define WIN32
   175| #  endif
   176| #endif
   177| #if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
   178| #  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
   179| #    ifndef SYS16BIT
   180| #      define SYS16BIT
   181| #    endif
   182| #  endif
   183| #endif
   184| /*
   185|  * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
   186|  * than 64k bytes at a time (needed on systems with 16-bit int).
   187|  */
   188| #ifdef SYS16BIT
   189| #  define MAXSEG_64K
   190| #endif
   191| #ifdef MSDOS
   192| #  define UNALIGNED_OK
   193| #endif
   194| #ifdef __STDC_VERSION__
   195| #  ifndef STDC
   196| #    define STDC
   197| #  endif
   198| #  if __STDC_VERSION__ >= 199901L
   199| #    ifndef STDC99
   200| #      define STDC99
   201| #    endif
   202| #  endif
   203| #endif
   204| #if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
   205| #  define STDC
   206| #endif
   207| #if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
   208| #  define STDC
   209| #endif
   210| #if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
   211| #  define STDC
   212| #endif
   213| #if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
   214| #  define STDC
   215| #endif
   216| #if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
   217| #  define STDC
   218| #endif
   219| #ifndef STDC
   220| #  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
   221| #    define const       /* note: need a more gentle solution here */
   222| #  endif
   223| #endif
   224| #if defined(ZLIB_CONST) && !defined(z_const)
   225| #  define z_const const
   226| #else
   227| #  define z_const
   228| #endif
   229| #ifdef Z_SOLO
   230|    typedef unsigned long z_size_t;
   231| #else
   232| #  define z_longlong long long
   233| #  if defined(NO_SIZE_T)
   234|      typedef unsigned NO_SIZE_T z_size_t;
   235| #  elif defined(STDC)
   236| #    include <stddef.h>
   237|      typedef size_t z_size_t;
   238| #  else
   239|      typedef unsigned long z_size_t;
   240| #  endif
   241| #  undef z_longlong
   242| #endif
   243| /* Maximum value for memLevel in deflateInit2 */
   244| #ifndef MAX_MEM_LEVEL
   245| #  ifdef MAXSEG_64K
   246| #    define MAX_MEM_LEVEL 8
   247| #  else
   248| #    define MAX_MEM_LEVEL 9
   249| #  endif
   250| #endif
   251| /* Maximum value for windowBits in deflateInit2 and inflateInit2.
   252|  * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
   253|  * created by gzip. (Files created by minigzip can still be extracted by
   254|  * gzip.)
   255|  */
   256| #ifndef MAX_WBITS
   257| #  define MAX_WBITS   15 /* 32K LZ77 window */
   258| #endif
   259| /* The memory requirements for deflate are (in bytes):
   260|             (1 << (windowBits+2)) +  (1 << (memLevel+9))
   261|  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
   262|  plus a few kilobytes for small objects. For example, if you want to reduce
   263|  the default memory requirements from 256K to 128K, compile with
   264|      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
   265|  Of course this will generally degrade compression (there's no free lunch).
   266|    The memory requirements for inflate are (in bytes) 1 << windowBits
   267|  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
   268|  for small objects.
   269| */
   270|                         /* Type declarations */
   271| #ifndef OF /* function prototypes */
   272| #  ifdef STDC
   273| #    define OF(args)  args
   274| #  else
   275| #    define OF(args)  ()
   276| #  endif
   277| #endif
   278| #ifndef Z_ARG /* function prototypes for stdarg */
   279| #  if defined(STDC) || defined(Z_HAVE_STDARG_H)
   280| #    define Z_ARG(args)  args
   281| #  else
   282| #    define Z_ARG(args)  ()
   283| #  endif
   284| #endif
   285| /* The following definitions for FAR are needed only for MSDOS mixed
   286|  * model programming (small or medium model with some far allocations).
   287|  * This was tested only with MSC; for other MSDOS compilers you may have
   288|  * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
   289|  * just define FAR to be empty.
   290|  */
   291| #ifdef SYS16BIT
   292| #  if defined(M_I86SM) || defined(M_I86MM)
   293|      /* MSC small or medium model */
   294| #    define SMALL_MEDIUM
   295| #    ifdef _MSC_VER
   296| #      define FAR _far
   297| #    else
   298| #      define FAR far
   299| #    endif
   300| #  endif
   301| #  if (defined(__SMALL__) || defined(__MEDIUM__))
   302|      /* Turbo C small or medium model */
   303| #    define SMALL_MEDIUM
   304| #    ifdef __BORLANDC__
   305| #      define FAR _far
   306| #    else
   307| #      define FAR far
   308| #    endif
   309| #  endif
   310| #endif
   311| #if defined(WINDOWS) || defined(WIN32)
   312|    /* If building or using zlib as a DLL, define ZLIB_DLL.
   313|     * This is not mandatory, but it offers a little performance increase.
   314|     */
   315| #  ifdef ZLIB_DLL
   316| #    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
   317| #      ifdef ZLIB_INTERNAL
   318| #        define ZEXTERN extern __declspec(dllexport)
   319| #      else
   320| #        define ZEXTERN extern __declspec(dllimport)
   321| #      endif
   322| #    endif
   323| #  endif  /* ZLIB_DLL */
   324|    /* If building or using zlib with the WINAPI/WINAPIV calling convention,
   325|     * define ZLIB_WINAPI.
   326|     * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
   327|     */
   328| #  ifdef ZLIB_WINAPI
   329| #    ifdef FAR
   330| #      undef FAR
   331| #    endif
   332| #    ifndef WIN32_LEAN_AND_MEAN
   333| #      define WIN32_LEAN_AND_MEAN
   334| #    endif
   335| #    include <windows.h>
   336|      /* No need for _export, use ZLIB.DEF instead. */
   337|      /* For complete Windows compatibility, use WINAPI, not __stdcall. */
   338| #    define ZEXPORT WINAPI
   339| #    ifdef WIN32
   340| #      define ZEXPORTVA WINAPIV
   341| #    else
   342| #      define ZEXPORTVA FAR CDECL
   343| #    endif
   344| #  endif
   345| #endif
   346| #if defined (__BEOS__)
   347| #  ifdef ZLIB_DLL
   348| #    ifdef ZLIB_INTERNAL
   349| #      define ZEXPORT   __declspec(dllexport)
   350| #      define ZEXPORTVA __declspec(dllexport)
   351| #    else
   352| #      define ZEXPORT   __declspec(dllimport)
   353| #      define ZEXPORTVA __declspec(dllimport)
   354| #    endif
   355| #  endif
   356| #endif
   357| #ifndef ZEXTERN
   358| #  define ZEXTERN extern
   359| #endif
   360| #ifndef ZEXPORT
   361| #  define ZEXPORT
   362| #endif
   363| #ifndef ZEXPORTVA
   364| #  define ZEXPORTVA
   365| #endif
   366| #ifndef FAR
   367| #  define FAR
   368| #endif
   369| #if !defined(__MACTYPES__)
   370| typedef unsigned char  Byte;  /* 8 bits */
   371| #endif
   372| typedef unsigned int   uInt;  /* 16 bits or more */
   373| typedef unsigned long  uLong; /* 32 bits or more */
   374| #ifdef SMALL_MEDIUM
   375|    /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
   376| #  define Bytef Byte FAR
   377| #else
   378|    typedef Byte  FAR Bytef;
   379| #endif
   380| typedef char  FAR charf;
   381| typedef int   FAR intf;
   382| typedef uInt  FAR uIntf;
   383| typedef uLong FAR uLongf;
   384| #ifdef STDC
   385|    typedef void const *voidpc;
   386|    typedef void FAR   *voidpf;
   387|    typedef void       *voidp;
   388| #else
   389|    typedef Byte const *voidpc;
   390|    typedef Byte FAR   *voidpf;
   391|    typedef Byte       *voidp;
   392| #endif
   393| #if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
   394| #  include <limits.h>
   395| #  if (UINT_MAX == 0xffffffffUL)
   396| #    define Z_U4 unsigned
   397| #  elif (ULONG_MAX == 0xffffffffUL)
   398| #    define Z_U4 unsigned long
   399| #  elif (USHRT_MAX == 0xffffffffUL)
   400| #    define Z_U4 unsigned short
   401| #  endif
   402| #endif
   403| #ifdef Z_U4
   404|    typedef Z_U4 z_crc_t;
   405| #else
   406|    typedef unsigned long z_crc_t;
   407| #endif
   408| #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
   409| #  define Z_HAVE_UNISTD_H
   410| #endif
   411| #ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
   412| #  define Z_HAVE_STDARG_H
   413| #endif
   414| #ifdef STDC
   415| #  ifndef Z_SOLO
   416| #    include <sys/types.h>      /* for off_t */
   417| #  endif
   418| #endif
   419| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
   420| #  ifndef Z_SOLO
   421| #    include <stdarg.h>         /* for va_list */
   422| #  endif
   423| #endif
   424| #ifdef _WIN32
   425| #  ifndef Z_SOLO
   426| #    include <stddef.h>         /* for wchar_t */
   427| #  endif
   428| #endif
   429| /* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
   430|  * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
   431|  * though the former does not conform to the LFS document), but considering
   432|  * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
   433|  * equivalently requesting no 64-bit operations
   434|  */
   435| #if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
   436| #  undef _LARGEFILE64_SOURCE
   437| #endif
   438| #ifndef Z_HAVE_UNISTD_H
   439| #  ifdef __WATCOMC__
   440| #    define Z_HAVE_UNISTD_H
   441| #  endif
   442| #endif
   443| #ifndef Z_HAVE_UNISTD_H
   444| #  if defined(_LARGEFILE64_SOURCE) && !defined(_WIN32)
   445| #    define Z_HAVE_UNISTD_H
   446| #  endif
   447| #endif
   448| #ifndef Z_SOLO
   449| #  if defined(Z_HAVE_UNISTD_H)
   450| #    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
   451| #    ifdef VMS
   452| #      include <unixio.h>       /* for off_t */
   453| #    endif
   454| #    ifndef z_off_t
   455| #      define z_off_t off_t
   456| #    endif
   457| #  endif
   458| #endif
   459| #if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
   460| #  define Z_LFS64
   461| #endif
   462| #if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
   463| #  define Z_LARGE64
   464| #endif
   465| #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
   466| #  define Z_WANT64
   467| #endif
   468| #if !defined(SEEK_SET) && !defined(Z_SOLO)
   469| #  define SEEK_SET        0       /* Seek from beginning of file.  */
   470| #  define SEEK_CUR        1       /* Seek from current position.  */
   471| #  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
   472| #endif
   473| #ifndef z_off_t
   474| #  define z_off_t long
   475| #endif
   476| #if !defined(_WIN32) && defined(Z_LARGE64)
   477| #  define z_off64_t off64_t
   478| #else
   479| #  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
   480| #    define z_off64_t __int64
   481| #  else
   482| #    define z_off64_t z_off_t
   483| #  endif
   484| #endif
   485| /* MVS linker does not support external names larger than 8 bytes */
   486| #if defined(__MVS__)
   487|   #pragma map(deflateInit_,"DEIN")
   488|   #pragma map(deflateInit2_,"DEIN2")
   489|   #pragma map(deflateEnd,"DEEND")
   490|   #pragma map(deflateBound,"DEBND")
   491|   #pragma map(inflateInit_,"ININ")
   492|   #pragma map(inflateInit2_,"ININ2")
   493|   #pragma map(inflateEnd,"INEND")
   494|   #pragma map(inflateSync,"INSY")
   495|   #pragma map(inflateSetDictionary,"INSEDI")
   496|   #pragma map(compressBound,"CMBND")
   497|   #pragma map(inflate_table,"INTABL")
   498|   #pragma map(inflate_fast,"INFA")
   499|   #pragma map(inflate_copyright,"INCOPY")
   500| #endif
   501| #endif /* ZCONF_H */


# ====================================================================
# FILE: src/native/external/zlib-intel/zlib.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1643 ---
     1| /* zlib.h -- interface of the 'zlib' general purpose compression library
     2|   version 1.2.13, October 13th, 2022
     3|   Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
     4|   This software is provided 'as-is', without any express or implied
     5|   warranty.  In no event will the authors be held liable for any damages
     6|   arising from the use of this software.
     7|   Permission is granted to anyone to use this software for any purpose,
     8|   including commercial applications, and to alter it and redistribute it
     9|   freely, subject to the following restrictions:
    10|   1. The origin of this software must not be misrepresented; you must not
    11|      claim that you wrote the original software. If you use this software
    12|      in a product, an acknowledgment in the product documentation would be
    13|      appreciated but is not required.
    14|   2. Altered source versions must be plainly marked as such, and must not be
    15|      misrepresented as being the original software.
    16|   3. This notice may not be removed or altered from any source distribution.
    17|   Jean-loup Gailly        Mark Adler
    18|   jloup@gzip.org          madler@alumni.caltech.edu
    19|   The data format used by the zlib library is described by RFCs (Request for
    20|   Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
    21|   (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
    22| */
    23| #ifndef ZLIB_H
    24| #define ZLIB_H
    25| #include "zconf.h"
    26| #ifdef __cplusplus
    27| extern "C" {
    28| #endif
    29| #define ZLIB_VERSION "1.2.13"
    30| #define ZLIB_VERNUM 0x12d0
    31| #define ZLIB_VER_MAJOR 1
    32| #define ZLIB_VER_MINOR 2
    33| #define ZLIB_VER_REVISION 13
    34| #define ZLIB_VER_SUBREVISION 0
    35| /*
    36|     The 'zlib' compression library provides in-memory compression and
    37|   decompression functions, including integrity checks of the uncompressed data.
    38|   This version of the library supports only one compression method (deflation)
    39|   but other algorithms will be added later and will have the same stream
    40|   interface.
    41|     Compression can be done in a single step if the buffers are large enough,
    42|   or can be done by repeated calls of the compression function.  In the latter
    43|   case, the application must provide more input and/or consume the output
    44|   (providing more output space) before each call.
    45|     The compressed data format used by default by the in-memory functions is
    46|   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
    47|   around a deflate stream, which is itself documented in RFC 1951.
    48|     The library also supports reading and writing files in gzip (.gz) format
    49|   with an interface similar to that of stdio using the functions that start
    50|   with "gz".  The gzip format is different from the zlib format.  gzip is a
    51|   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
    52|     This library can optionally read and write gzip and raw deflate streams in
    53|   memory as well.
    54|     The zlib format was designed to be compact and fast for use in memory
    55|   and on communications channels.  The gzip format was designed for single-
    56|   file compression on file systems, has a larger header than zlib to maintain
    57|   directory information, and uses a different, slower check method than zlib.
    58|     The library does not install any signal handler.  The decoder checks
    59|   the consistency of the compressed data, so the library should never crash
    60|   even in the case of corrupted input.
    61| */
    62| typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
    63| typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
    64| struct internal_state;
    65| typedef struct z_stream_s {
    66|     z_const Bytef *next_in;     /* next input byte */
    67|     uInt     avail_in;  /* number of bytes available at next_in */
    68|     uLong    total_in;  /* total number of input bytes read so far */
    69|     Bytef    *next_out; /* next output byte will go here */
    70|     uInt     avail_out; /* remaining free space at next_out */
    71|     uLong    total_out; /* total number of bytes output so far */
    72|     z_const char *msg;  /* last error message, NULL if no error */
    73|     struct internal_state FAR *state; /* not visible by applications */
    74|     alloc_func zalloc;  /* used to allocate the internal state */
    75|     free_func  zfree;   /* used to free the internal state */
    76|     voidpf     opaque;  /* private data object passed to zalloc and zfree */
    77|     int     data_type;  /* best guess about the data type: binary or text
    78|                            for deflate, or the decoding state for inflate */
    79|     uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
    80|     uLong   reserved;   /* reserved for future use */
    81| } z_stream;
    82| typedef z_stream FAR *z_streamp;
    83| /*
    84|      gzip header information passed to and from zlib routines.  See RFC 1952
    85|   for more details on the meanings of these fields.
    86| */
    87| typedef struct gz_header_s {
    88|     int     text;       /* true if compressed data believed to be text */
    89|     uLong   time;       /* modification time */
    90|     int     xflags;     /* extra flags (not used when writing a gzip file) */
    91|     int     os;         /* operating system */
    92|     Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    93|     uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    94|     uInt    extra_max;  /* space at extra (only when reading header) */
    95|     Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    96|     uInt    name_max;   /* space at name (only when reading header) */
    97|     Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    98|     uInt    comm_max;   /* space at comment (only when reading header) */
    99|     int     hcrc;       /* true if there was or will be a header crc */
   100|     int     done;       /* true when done reading gzip header (not used
   101|                            when writing a gzip file) */
   102| } gz_header;
   103| typedef gz_header FAR *gz_headerp;
   104| /*
   105|      The application must update next_in and avail_in when avail_in has dropped
   106|    to zero.  It must update next_out and avail_out when avail_out has dropped
   107|    to zero.  The application must initialize zalloc, zfree and opaque before
   108|    calling the init function.  All other fields are set by the compression
   109|    library and must not be updated by the application.
   110|      The opaque value provided by the application will be passed as the first
   111|    parameter for calls of zalloc and zfree.  This can be useful for custom
   112|    memory management.  The compression library attaches no meaning to the
   113|    opaque value.
   114|      zalloc must return Z_NULL if there is not enough memory for the object.
   115|    If zlib is used in a multi-threaded application, zalloc and zfree must be
   116|    thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
   117|    Z_NULL on entry to the initialization function, they are set to internal
   118|    routines that use the standard library functions malloc() and free().
   119|      On 16-bit systems, the functions zalloc and zfree must be able to allocate
   120|    exactly 65536 bytes, but will not be required to allocate more than this if
   121|    the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   122|    returned by zalloc for objects of exactly 65536 bytes *must* have their
   123|    offset normalized to zero.  The default allocation function provided by this
   124|    library ensures this (see zutil.c).  To reduce memory requirements and avoid
   125|    any allocation of 64K objects, at the expense of compression ratio, compile
   126|    the library with -DMAX_WBITS=14 (see zconf.h).
   127|      The fields total_in and total_out can be used for statistics or progress
   128|    reports.  After compression, total_in holds the total size of the
   129|    uncompressed data and may be saved for use by the decompressor (particularly
   130|    if the decompressor wants to decompress everything in a single step).
   131| */
   132|                         /* constants */
   133| #define Z_NO_FLUSH      0
   134| #define Z_PARTIAL_FLUSH 1
   135| #define Z_SYNC_FLUSH    2
   136| #define Z_FULL_FLUSH    3
   137| #define Z_FINISH        4
   138| #define Z_BLOCK         5
   139| #define Z_TREES         6
   140| /* Allowed flush values; see deflate() and inflate() below for details */
   141| #define Z_OK            0
   142| #define Z_STREAM_END    1
   143| #define Z_NEED_DICT     2
   144| #define Z_ERRNO        (-1)
   145| #define Z_STREAM_ERROR (-2)
   146| #define Z_DATA_ERROR   (-3)
   147| #define Z_MEM_ERROR    (-4)
   148| #define Z_BUF_ERROR    (-5)
   149| #define Z_VERSION_ERROR (-6)
   150| /* Return codes for the compression/decompression functions. Negative values
   151|  * are errors, positive values are used for special but normal events.
   152|  */
   153| #define Z_NO_COMPRESSION         0
   154| #define Z_BEST_SPEED             1
   155| #define Z_BEST_COMPRESSION       9
   156| #define Z_DEFAULT_COMPRESSION  (-1)
   157| /* compression levels */
   158| #define Z_FILTERED            1
   159| #define Z_HUFFMAN_ONLY        2
   160| #define Z_RLE                 3
   161| #define Z_FIXED               4
   162| #define Z_DEFAULT_STRATEGY    0
   163| /* compression strategy; see deflateInit2() below for details */
   164| #define Z_BINARY   0
   165| #define Z_TEXT     1
   166| #define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
   167| #define Z_UNKNOWN  2
   168| /* Possible values of the data_type field for deflate() */
   169| #define Z_DEFLATED   8
   170| /* The deflate compression method (the only one supported in this version) */
   171| #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
   172| #define zlib_version zlibVersion()
   173| /* for compatibility with versions < 1.0.2 */
   174|                         /* basic functions */
   175| ZEXTERN const char * ZEXPORT zlibVersion OF((void));
   176| /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   177|    If the first character differs, the library code actually used is not
   178|    compatible with the zlib.h header file used by the application.  This check
   179|    is automatically made by deflateInit and inflateInit.
   180|  */
   181| /*
   182| ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
   183|      Initializes the internal stream state for compression.  The fields
   184|    zalloc, zfree and opaque must be initialized before by the caller.  If
   185|    zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   186|    allocation functions.
   187|      The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   188|    1 gives best speed, 9 gives best compression, 0 gives no compression at all
   189|    (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   190|    requests a default compromise between speed and compression (currently
   191|    equivalent to level 6).
   192|      deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   193|    memory, Z_STREAM_ERROR if level is not a valid compression level, or
   194|    Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   195|    with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   196|    if there is no error message.  deflateInit does not perform any compression:
   197|    this will be done by deflate().
   198| */
   199| ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
   200| /*
   201|     deflate compresses as much data as possible, and stops when the input
   202|   buffer becomes empty or the output buffer becomes full.  It may introduce
   203|   some output latency (reading input without producing any output) except when
   204|   forced to flush.
   205|     The detailed semantics are as follows.  deflate performs one or both of the
   206|   following actions:
   207|   - Compress more input starting at next_in and update next_in and avail_in
   208|     accordingly.  If not all input can be processed (because there is not
   209|     enough room in the output buffer), next_in and avail_in are updated and
   210|     processing will resume at this point for the next call of deflate().
   211|   - Generate more output starting at next_out and update next_out and avail_out
   212|     accordingly.  This action is forced if the parameter flush is non zero.
   213|     Forcing flush frequently degrades the compression ratio, so this parameter
   214|     should be set only when necessary.  Some output may be provided even if
   215|     flush is zero.
   216|     Before the call of deflate(), the application should ensure that at least
   217|   one of the actions is possible, by providing more input and/or consuming more
   218|   output, and updating avail_in or avail_out accordingly; avail_out should
   219|   never be zero before the call.  The application can consume the compressed
   220|   output when it wants, for example when the output buffer is full (avail_out
   221|   == 0), or after each call of deflate().  If deflate returns Z_OK and with
   222|   zero avail_out, it must be called again after making room in the output
   223|   buffer because there might be more output pending. See deflatePending(),
   224|   which can be used if desired to determine whether or not there is more output
   225|   in that case.
   226|     Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
   227|   decide how much data to accumulate before producing output, in order to
   228|   maximize compression.
   229|     If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
   230|   flushed to the output buffer and the output is aligned on a byte boundary, so
   231|   that the decompressor can get all input data available so far.  (In
   232|   particular avail_in is zero after the call if enough output space has been
   233|   provided before the call.) Flushing may degrade compression for some
   234|   compression algorithms and so it should be used only when necessary.  This
   235|   completes the current deflate block and follows it with an empty stored block
   236|   that is three bits plus filler bits to the next byte, followed by four bytes
   237|   (00 00 ff ff).
   238|     If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
   239|   output buffer, but the output is not aligned to a byte boundary.  All of the
   240|   input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
   241|   This completes the current deflate block and follows it with an empty fixed
   242|   codes block that is 10 bits long.  This assures that enough bytes are output
   243|   in order for the decompressor to finish the block before the empty fixed
   244|   codes block.
   245|     If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
   246|   for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
   247|   seven bits of the current block are held to be written as the next byte after
   248|   the next deflate block is completed.  In this case, the decompressor may not
   249|   be provided enough bits at this point in order to complete decompression of
   250|   the data provided so far to the compressor.  It may need to wait for the next
   251|   block to be emitted.  This is for advanced applications that need to control
   252|   the emission of deflate blocks.
   253|     If flush is set to Z_FULL_FLUSH, all output is flushed as with
   254|   Z_SYNC_FLUSH, and the compression state is reset so that decompression can
   255|   restart from this point if previous compressed data has been damaged or if
   256|   random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
   257|   compression.
   258|     If deflate returns with avail_out == 0, this function must be called again
   259|   with the same value of the flush parameter and more output space (updated
   260|   avail_out), until the flush is complete (deflate returns with non-zero
   261|   avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
   262|   avail_out is greater than six to avoid repeated flush markers due to
   263|   avail_out == 0 on return.
   264|     If the parameter flush is set to Z_FINISH, pending input is processed,
   265|   pending output is flushed and deflate returns with Z_STREAM_END if there was
   266|   enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
   267|   function must be called again with Z_FINISH and more output space (updated
   268|   avail_out) but no more input data, until it returns with Z_STREAM_END or an
   269|   error.  After deflate has returned Z_STREAM_END, the only possible operations
   270|   on the stream are deflateReset or deflateEnd.
   271|     Z_FINISH can be used in the first deflate call after deflateInit if all the
   272|   compression is to be done in a single step.  In order to complete in one
   273|   call, avail_out must be at least the value returned by deflateBound (see
   274|   below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
   275|   output space is provided, deflate will not return Z_STREAM_END, and it must
   276|   be called again as described above.
   277|     deflate() sets strm->adler to the Adler-32 checksum of all input read
   278|   so far (that is, total_in bytes).  If a gzip stream is being generated, then
   279|   strm->adler will be the CRC-32 checksum of the input read so far.  (See
   280|   deflateInit2 below.)
   281|     deflate() may update strm->data_type if it can make a good guess about
   282|   the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
   283|   considered binary.  This field is only for information purposes and does not
   284|   affect the compression algorithm in any manner.
   285|     deflate() returns Z_OK if some progress has been made (more input
   286|   processed or more output produced), Z_STREAM_END if all input has been
   287|   consumed and all output has been produced (only when flush is set to
   288|   Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
   289|   if next_in or next_out was Z_NULL or the state was inadvertently written over
   290|   by the application), or Z_BUF_ERROR if no progress is possible (for example
   291|   avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
   292|   deflate() can be called again with more input and more output space to
   293|   continue compressing.
   294| */
   295| ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
   296| /*
   297|      All dynamically allocated data structures for this stream are freed.
   298|    This function discards any unprocessed input and does not flush any pending
   299|    output.
   300|      deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   301|    stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   302|    prematurely (some input or output was discarded).  In the error case, msg
   303|    may be set but then points to a static string (which must not be
   304|    deallocated).
   305| */
   306| /*
   307| ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
   308|      Initializes the internal stream state for decompression.  The fields
   309|    next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   310|    the caller.  In the current version of inflate, the provided input is not
   311|    read or consumed.  The allocation of a sliding window will be deferred to
   312|    the first call of inflate (if the decompression does not complete on the
   313|    first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
   314|    them to use default allocation functions.
   315|      inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   316|    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   317|    version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   318|    invalid, such as a null pointer to the structure.  msg is set to null if
   319|    there is no error message.  inflateInit does not perform any decompression.
   320|    Actual decompression will be done by inflate().  So next_in, and avail_in,
   321|    next_out, and avail_out are unused and unchanged.  The current
   322|    implementation of inflateInit() does not process any header information --
   323|    that is deferred until inflate() is called.
   324| */
   325| ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
   326| /*
   327|     inflate decompresses as much data as possible, and stops when the input
   328|   buffer becomes empty or the output buffer becomes full.  It may introduce
   329|   some output latency (reading input without producing any output) except when
   330|   forced to flush.
   331|   The detailed semantics are as follows.  inflate performs one or both of the
   332|   following actions:
   333|   - Decompress more input starting at next_in and update next_in and avail_in
   334|     accordingly.  If not all input can be processed (because there is not
   335|     enough room in the output buffer), then next_in and avail_in are updated
   336|     accordingly, and processing will resume at this point for the next call of
   337|     inflate().
   338|   - Generate more output starting at next_out and update next_out and avail_out
   339|     accordingly.  inflate() provides as much output as possible, until there is
   340|     no more input data or no more space in the output buffer (see below about
   341|     the flush parameter).
   342|     Before the call of inflate(), the application should ensure that at least
   343|   one of the actions is possible, by providing more input and/or consuming more
   344|   output, and updating the next_* and avail_* values accordingly.  If the
   345|   caller of inflate() does not provide both available input and available
   346|   output space, it is possible that there will be no progress made.  The
   347|   application can consume the uncompressed output when it wants, for example
   348|   when the output buffer is full (avail_out == 0), or after each call of
   349|   inflate().  If inflate returns Z_OK and with zero avail_out, it must be
   350|   called again after making room in the output buffer because there might be
   351|   more output pending.
   352|     The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
   353|   Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
   354|   output as possible to the output buffer.  Z_BLOCK requests that inflate()
   355|   stop if and when it gets to the next deflate block boundary.  When decoding
   356|   the zlib or gzip format, this will cause inflate() to return immediately
   357|   after the header and before the first block.  When doing a raw inflate,
   358|   inflate() will go ahead and process the first block, and will return when it
   359|   gets to the end of that block, or when it runs out of data.
   360|     The Z_BLOCK option assists in appending to or combining deflate streams.
   361|   To assist in this, on return inflate() always sets strm->data_type to the
   362|   number of unused bits in the last byte taken from strm->next_in, plus 64 if
   363|   inflate() is currently decoding the last block in the deflate stream, plus
   364|   128 if inflate() returned immediately after decoding an end-of-block code or
   365|   decoding the complete header up to just before the first byte of the deflate
   366|   stream.  The end-of-block will not be indicated until all of the uncompressed
   367|   data from that block has been written to strm->next_out.  The number of
   368|   unused bits may in general be greater than seven, except when bit 7 of
   369|   data_type is set, in which case the number of unused bits will be less than
   370|   eight.  data_type is set as noted here every time inflate() returns for all
   371|   flush options, and so can be used to determine the amount of currently
   372|   consumed input in bits.
   373|     The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
   374|   end of each deflate block header is reached, before any actual data in that
   375|   block is decoded.  This allows the caller to determine the length of the
   376|   deflate block header for later use in random access within a deflate block.
   377|   256 is added to the value of strm->data_type when inflate() returns
   378|   immediately after reaching the end of the deflate block header.
   379|     inflate() should normally be called until it returns Z_STREAM_END or an
   380|   error.  However if all decompression is to be performed in a single step (a
   381|   single call of inflate), the parameter flush should be set to Z_FINISH.  In
   382|   this case all pending input is processed and all pending output is flushed;
   383|   avail_out must be large enough to hold all of the uncompressed data for the
   384|   operation to complete.  (The size of the uncompressed data may have been
   385|   saved by the compressor for this purpose.)  The use of Z_FINISH is not
   386|   required to perform an inflation in one step.  However it may be used to
   387|   inform inflate that a faster approach can be used for the single inflate()
   388|   call.  Z_FINISH also informs inflate to not maintain a sliding window if the
   389|   stream completes, which reduces inflate's memory footprint.  If the stream
   390|   does not complete, either because not all of the stream is provided or not
   391|   enough output space is provided, then a sliding window will be allocated and
   392|   inflate() can be called again to continue the operation as if Z_NO_FLUSH had
   393|   been used.
   394|      In this implementation, inflate() always flushes as much output as
   395|   possible to the output buffer, and always uses the faster approach on the
   396|   first call.  So the effects of the flush parameter in this implementation are
   397|   on the return value of inflate() as noted below, when inflate() returns early
   398|   when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
   399|   memory for a sliding window when Z_FINISH is used.
   400|      If a preset dictionary is needed after this call (see inflateSetDictionary
   401|   below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
   402|   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
   403|   strm->adler to the Adler-32 checksum of all output produced so far (that is,
   404|   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
   405|   below.  At the end of the stream, inflate() checks that its computed Adler-32
   406|   checksum is equal to that saved by the compressor and returns Z_STREAM_END
   407|   only if the checksum is correct.
   408|     inflate() can decompress and check either zlib-wrapped or gzip-wrapped
   409|   deflate data.  The header type is detected automatically, if requested when
   410|   initializing with inflateInit2().  Any information contained in the gzip
   411|   header is not retained unless inflateGetHeader() is used.  When processing
   412|   gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
   413|   produced so far.  The CRC-32 is checked against the gzip trailer, as is the
   414|   uncompressed length, modulo 2^32.
   415|     inflate() returns Z_OK if some progress has been made (more input processed
   416|   or more output produced), Z_STREAM_END if the end of the compressed data has
   417|   been reached and all uncompressed output has been produced, Z_NEED_DICT if a
   418|   preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
   419|   corrupted (input stream not conforming to the zlib format or incorrect check
   420|   value, in which case strm->msg points to a string with a more specific
   421|   error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
   422|   next_in or next_out was Z_NULL, or the state was inadvertently written over
   423|   by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
   424|   if no progress was possible or if there was not enough room in the output
   425|   buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
   426|   inflate() can be called again with more input and more output space to
   427|   continue decompressing.  If Z_DATA_ERROR is returned, the application may
   428|   then call inflateSync() to look for a good compression block if a partial
   429|   recovery of the data is to be attempted.
   430| */
   431| ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
   432| /*
   433|      All dynamically allocated data structures for this stream are freed.
   434|    This function discards any unprocessed input and does not flush any pending
   435|    output.
   436|      inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
   437|    was inconsistent.
   438| */
   439|                         /* Advanced functions */
   440| /*
   441|     The following functions are needed only in some special applications.
   442| */
   443| /*
   444| ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
   445|                                      int  level,
   446|                                      int  method,
   447|                                      int  windowBits,
   448|                                      int  memLevel,
   449|                                      int  strategy));
   450|      This is another version of deflateInit with more compression options.  The
   451|    fields zalloc, zfree and opaque must be initialized before by the caller.
   452|      The method parameter is the compression method.  It must be Z_DEFLATED in
   453|    this version of the library.
   454|      The windowBits parameter is the base two logarithm of the window size
   455|    (the size of the history buffer).  It should be in the range 8..15 for this
   456|    version of the library.  Larger values of this parameter result in better
   457|    compression at the expense of memory usage.  The default value is 15 if
   458|    deflateInit is used instead.
   459|      For the current implementation of deflate(), a windowBits value of 8 (a
   460|    window size of 256 bytes) is not supported.  As a result, a request for 8
   461|    will result in 9 (a 512-byte window).  In that case, providing 8 to
   462|    inflateInit2() will result in an error when the zlib header with 9 is
   463|    checked against the initialization of inflate().  The remedy is to not use 8
   464|    with deflateInit2() with this initialization, or at least in that case use 9
   465|    with inflateInit2().
   466|      windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   467|    determines the window size.  deflate() will then generate raw deflate data
   468|    with no zlib header or trailer, and will not compute a check value.
   469|      windowBits can also be greater than 15 for optional gzip encoding.  Add
   470|    16 to windowBits to write a simple gzip header and trailer around the
   471|    compressed data instead of a zlib wrapper.  The gzip header will have no
   472|    file name, no extra data, no comment, no modification time (set to zero), no
   473|    header crc, and the operating system will be set to the appropriate value,
   474|    if the operating system was determined at compile time.  If a gzip stream is
   475|    being written, strm->adler is a CRC-32 instead of an Adler-32.
   476|      For raw deflate or gzip encoding, a request for a 256-byte window is
   477|    rejected as invalid, since only the zlib header provides a means of
   478|    transmitting the window size to the decompressor.
   479|      The memLevel parameter specifies how much memory should be allocated
   480|    for the internal compression state.  memLevel=1 uses minimum memory but is
   481|    slow and reduces compression ratio; memLevel=9 uses maximum memory for
   482|    optimal speed.  The default value is 8.  See zconf.h for total memory usage
   483|    as a function of windowBits and memLevel.
   484|      The strategy parameter is used to tune the compression algorithm.  Use the
   485|    value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   486|    filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   487|    string match), or Z_RLE to limit match distances to one (run-length
   488|    encoding).  Filtered data consists mostly of small values with a somewhat
   489|    random distribution.  In this case, the compression algorithm is tuned to
   490|    compress them better.  The effect of Z_FILTERED is to force more Huffman
   491|    coding and less string matching; it is somewhat intermediate between
   492|    Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   493|    fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   494|    strategy parameter only affects the compression ratio but not the
   495|    correctness of the compressed output even if it is not set appropriately.
   496|    Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   497|    decoder for special applications.
   498|      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   499|    memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   500|    method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   501|    incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   502|    set to null if there is no error message.  deflateInit2 does not perform any
   503|    compression: this will be done by deflate().
   504| */
   505| ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
   506|                                              const Bytef *dictionary,
   507|                                              uInt  dictLength));
   508| /*
   509|      Initializes the compression dictionary from the given byte sequence
   510|    without producing any compressed output.  When using the zlib format, this
   511|    function must be called immediately after deflateInit, deflateInit2 or
   512|    deflateReset, and before any call of deflate.  When doing raw deflate, this
   513|    function must be called either before any call of deflate, or immediately
   514|    after the completion of a deflate block, i.e. after all input has been
   515|    consumed and all output has been delivered when using any of the flush
   516|    options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   517|    compressor and decompressor must use exactly the same dictionary (see
   518|    inflateSetDictionary).
   519|      The dictionary should consist of strings (byte sequences) that are likely
   520|    to be encountered later in the data to be compressed, with the most commonly
   521|    used strings preferably put towards the end of the dictionary.  Using a
   522|    dictionary is most useful when the data to be compressed is short and can be
   523|    predicted with good accuracy; the data can then be compressed better than
   524|    with the default empty dictionary.
   525|      Depending on the size of the compression data structures selected by
   526|    deflateInit or deflateInit2, a part of the dictionary may in effect be
   527|    discarded, for example if the dictionary is larger than the window size
   528|    provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   529|    useful should be put at the end of the dictionary, not at the front.  In
   530|    addition, the current implementation of deflate will use at most the window
   531|    size minus 262 bytes of the provided dictionary.
   532|      Upon return of this function, strm->adler is set to the Adler-32 value
   533|    of the dictionary; the decompressor may later use this value to determine
   534|    which dictionary has been used by the compressor.  (The Adler-32 value
   535|    applies to the whole dictionary even if only a subset of the dictionary is
   536|    actually used by the compressor.) If a raw deflate was requested, then the
   537|    Adler-32 value is not computed and strm->adler is not set.
   538|      deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   539|    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   540|    inconsistent (for example if deflate has already been called for this stream
   541|    or if not at a block boundary for raw deflate).  deflateSetDictionary does
   542|    not perform any compression: this will be done by deflate().
   543| */
   544| ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
   545|                                              Bytef *dictionary,
   546|                                              uInt  *dictLength));
   547| /*
   548|      Returns the sliding dictionary being maintained by deflate.  dictLength is
   549|    set to the number of bytes in the dictionary, and that many bytes are copied
   550|    to dictionary.  dictionary must have enough space, where 32768 bytes is
   551|    always enough.  If deflateGetDictionary() is called with dictionary equal to
   552|    Z_NULL, then only the dictionary length is returned, and nothing is copied.
   553|    Similarly, if dictLength is Z_NULL, then it is not set.
   554|      deflateGetDictionary() may return a length less than the window size, even
   555|    when more than the window size in input has been provided. It may return up
   556|    to 258 bytes less in that case, due to how zlib's implementation of deflate
   557|    manages the sliding window and lookahead for matches, where matches can be
   558|    up to 258 bytes long. If the application needs the last window-size bytes of
   559|    input, then that would need to be saved by the application outside of zlib.
   560|      deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   561|    stream state is inconsistent.
   562| */
   563| ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
   564|                                     z_streamp source));
   565| /*
   566|      Sets the destination stream as a complete copy of the source stream.
   567|      This function can be useful when several compression strategies will be
   568|    tried, for example when there are several ways of pre-processing the input
   569|    data with a filter.  The streams that will be discarded should then be freed
   570|    by calling deflateEnd.  Note that deflateCopy duplicates the internal
   571|    compression state which can be quite large, so this strategy is slow and can
   572|    consume lots of memory.
   573|      deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   574|    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   575|    (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   576|    destination.
   577| */
   578| ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
   579| /*
   580|      This function is equivalent to deflateEnd followed by deflateInit, but
   581|    does not free and reallocate the internal compression state.  The stream
   582|    will leave the compression level and any other attributes that may have been
   583|    set unchanged.
   584|      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   585|    stream state was inconsistent (such as zalloc or state being Z_NULL).
   586| */
   587| ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
   588|                                       int level,
   589|                                       int strategy));
   590| /*
   591|      Dynamically update the compression level and compression strategy.  The
   592|    interpretation of level and strategy is as in deflateInit2().  This can be
   593|    used to switch between compression and straight copy of the input data, or
   594|    to switch to a different kind of input data requiring a different strategy.
   595|    If the compression approach (which is a function of the level) or the
   596|    strategy is changed, and if there have been any deflate() calls since the
   597|    state was initialized or reset, then the input available so far is
   598|    compressed with the old level and strategy using deflate(strm, Z_BLOCK).
   599|    There are three approaches for the compression levels 0, 1..3, and 4..9
   600|    respectively.  The new level and strategy will take effect at the next call
   601|    of deflate().
   602|      If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
   603|    not have enough output space to complete, then the parameter change will not
   604|    take effect.  In this case, deflateParams() can be called again with the
   605|    same parameters and more output space to try again.
   606|      In order to assure a change in the parameters on the first try, the
   607|    deflate stream should be flushed using deflate() with Z_BLOCK or other flush
   608|    request until strm.avail_out is not zero, before calling deflateParams().
   609|    Then no more input data should be provided before the deflateParams() call.
   610|    If this is done, the old level and strategy will be applied to the data
   611|    compressed before deflateParams(), and the new level and strategy will be
   612|    applied to the the data compressed after deflateParams().
   613|      deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
   614|    state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
   615|    there was not enough output space to complete the compression of the
   616|    available input data before a change in the strategy or approach.  Note that
   617|    in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
   618|    value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
   619|    retried with more output space.
   620| */
   621| ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
   622|                                     int good_length,
   623|                                     int max_lazy,
   624|                                     int nice_length,
   625|                                     int max_chain));
   626| /*
   627|      Fine tune deflate's internal compression parameters.  This should only be
   628|    used by someone who understands the algorithm used by zlib's deflate for
   629|    searching for the best matching string, and even then only by the most
   630|    fanatic optimizer trying to squeeze out the last compressed bit for their
   631|    specific input data.  Read the deflate.c source code for the meaning of the
   632|    max_lazy, good_length, nice_length, and max_chain parameters.
   633|      deflateTune() can be called after deflateInit() or deflateInit2(), and
   634|    returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
   635|  */
   636| ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
   637|                                        uLong sourceLen));
   638| /*
   639|      deflateBound() returns an upper bound on the compressed size after
   640|    deflation of sourceLen bytes.  It must be called after deflateInit() or
   641|    deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   642|    to allocate an output buffer for deflation in a single pass, and so would be
   643|    called before deflate().  If that first deflate() call is provided the
   644|    sourceLen input bytes, an output buffer allocated to the size returned by
   645|    deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   646|    to return Z_STREAM_END.  Note that it is possible for the compressed size to
   647|    be larger than the value returned by deflateBound() if flush options other
   648|    than Z_FINISH or Z_NO_FLUSH are used.
   649| */
   650| ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
   651|                                        unsigned *pending,
   652|                                        int *bits));
   653| /*
   654|      deflatePending() returns the number of bytes and bits of output that have
   655|    been generated, but not yet provided in the available output.  The bytes not
   656|    provided would be due to the available output space having being consumed.
   657|    The number of bits of output not provided are between 0 and 7, where they
   658|    await more bits to join them in order to fill out a full byte.  If pending
   659|    or bits are Z_NULL, then those values are not set.
   660|      deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   661|    stream state was inconsistent.
   662|  */
   663| ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
   664|                                      int bits,
   665|                                      int value));
   666| /*
   667|      deflatePrime() inserts bits in the deflate output stream.  The intent
   668|    is that this function is used to start off the deflate output with the bits
   669|    leftover from a previous deflate stream when appending to it.  As such, this
   670|    function can only be used for raw deflate, and must be used before the first
   671|    deflate() call after a deflateInit2() or deflateReset().  bits must be less
   672|    than or equal to 16, and that many of the least significant bits of value
   673|    will be inserted in the output.
   674|      deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   675|    room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   676|    source stream state was inconsistent.
   677| */
   678| ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
   679|                                          gz_headerp head));
   680| /*
   681|      deflateSetHeader() provides gzip header information for when a gzip
   682|    stream is requested by deflateInit2().  deflateSetHeader() may be called
   683|    after deflateInit2() or deflateReset() and before the first call of
   684|    deflate().  The text, time, os, extra field, name, and comment information
   685|    in the provided gz_header structure are written to the gzip header (xflag is
   686|    ignored -- the extra flags are set according to the compression level).  The
   687|    caller must assure that, if not Z_NULL, name and comment are terminated with
   688|    a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   689|    available there.  If hcrc is true, a gzip header crc is included.  Note that
   690|    the current versions of the command-line version of gzip (up through version
   691|    1.3.x) do not support header crc's, and will report that it is a "multi-part
   692|    gzip file" and give up.
   693|      If deflateSetHeader is not used, the default gzip header has text false,
   694|    the time set to zero, and os set to 255, with no extra, name, or comment
   695|    fields.  The gzip header is returned to the default state by deflateReset().
   696|      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   697|    stream state was inconsistent.
   698| */
   699| /*
   700| ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
   701|                                      int  windowBits));
   702|      This is another version of inflateInit with an extra parameter.  The
   703|    fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   704|    before by the caller.
   705|      The windowBits parameter is the base two logarithm of the maximum window
   706|    size (the size of the history buffer).  It should be in the range 8..15 for
   707|    this version of the library.  The default value is 15 if inflateInit is used
   708|    instead.  windowBits must be greater than or equal to the windowBits value
   709|    provided to deflateInit2() while compressing, or it must be equal to 15 if
   710|    deflateInit2() was not used.  If a compressed stream with a larger window
   711|    size is given as input, inflate() will return with the error code
   712|    Z_DATA_ERROR instead of trying to allocate a larger window.
   713|      windowBits can also be zero to request that inflate use the window size in
   714|    the zlib header of the compressed stream.
   715|      windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   716|    determines the window size.  inflate() will then process raw deflate data,
   717|    not looking for a zlib or gzip header, not generating a check value, and not
   718|    looking for any check values for comparison at the end of the stream.  This
   719|    is for use with other formats that use the deflate compressed data format
   720|    such as zip.  Those formats provide their own check values.  If a custom
   721|    format is developed using the raw deflate format for compressed data, it is
   722|    recommended that a check value such as an Adler-32 or a CRC-32 be applied to
   723|    the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   724|    most applications, the zlib format should be used as is.  Note that comments
   725|    above on the use in deflateInit2() applies to the magnitude of windowBits.
   726|      windowBits can also be greater than 15 for optional gzip decoding.  Add
   727|    32 to windowBits to enable zlib and gzip decoding with automatic header
   728|    detection, or add 16 to decode only the gzip format (the zlib format will
   729|    return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   730|    CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
   731|    below), inflate() will *not* automatically decode concatenated gzip members.
   732|    inflate() will return Z_STREAM_END at the end of the gzip member.  The state
   733|    would need to be reset to continue decoding a subsequent gzip member.  This
   734|    *must* be done if there is more data after a gzip member, in order for the
   735|    decompression to be compliant with the gzip standard (RFC 1952).
   736|      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   737|    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   738|    version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   739|    invalid, such as a null pointer to the structure.  msg is set to null if
   740|    there is no error message.  inflateInit2 does not perform any decompression
   741|    apart from possibly reading the zlib header if present: actual decompression
   742|    will be done by inflate().  (So next_in and avail_in may be modified, but
   743|    next_out and avail_out are unused and unchanged.) The current implementation
   744|    of inflateInit2() does not process any header information -- that is
   745|    deferred until inflate() is called.
   746| */
   747| ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
   748|                                              const Bytef *dictionary,
   749|                                              uInt  dictLength));
   750| /*
   751|      Initializes the decompression dictionary from the given uncompressed byte
   752|    sequence.  This function must be called immediately after a call of inflate,
   753|    if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   754|    can be determined from the Adler-32 value returned by that call of inflate.
   755|    The compressor and decompressor must use exactly the same dictionary (see
   756|    deflateSetDictionary).  For raw inflate, this function can be called at any
   757|    time to set the dictionary.  If the provided dictionary is smaller than the
   758|    window and there is already data in the window, then the provided dictionary
   759|    will amend what's there.  The application must insure that the dictionary
   760|    that was used for compression is provided.
   761|      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   762|    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   763|    inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   764|    expected one (incorrect Adler-32 value).  inflateSetDictionary does not
   765|    perform any decompression: this will be done by subsequent calls of
   766|    inflate().
   767| */
   768| ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
   769|                                              Bytef *dictionary,
   770|                                              uInt  *dictLength));
   771| /*
   772|      Returns the sliding dictionary being maintained by inflate.  dictLength is
   773|    set to the number of bytes in the dictionary, and that many bytes are copied
   774|    to dictionary.  dictionary must have enough space, where 32768 bytes is
   775|    always enough.  If inflateGetDictionary() is called with dictionary equal to
   776|    Z_NULL, then only the dictionary length is returned, and nothing is copied.
   777|    Similarly, if dictLength is Z_NULL, then it is not set.
   778|      inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   779|    stream state is inconsistent.
   780| */
   781| ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
   782| /*
   783|      Skips invalid compressed data until a possible full flush point (see above
   784|    for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   785|    available input is skipped.  No output is provided.
   786|      inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   787|    All full flush points have this pattern, but not all occurrences of this
   788|    pattern are full flush points.
   789|      inflateSync returns Z_OK if a possible full flush point has been found,
   790|    Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   791|    has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   792|    In the success case, the application may save the current current value of
   793|    total_in which indicates where valid compressed data was found.  In the
   794|    error case, the application may repeatedly call inflateSync, providing more
   795|    input each time, until success or end of the input data.
   796| */
   797| ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
   798|                                     z_streamp source));
   799| /*
   800|      Sets the destination stream as a complete copy of the source stream.
   801|      This function can be useful when randomly accessing a large stream.  The
   802|    first pass through the stream can periodically record the inflate state,
   803|    allowing restarting inflate at those points when randomly accessing the
   804|    stream.
   805|      inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   806|    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   807|    (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   808|    destination.
   809| */
   810| ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
   811| /*
   812|      This function is equivalent to inflateEnd followed by inflateInit,
   813|    but does not free and reallocate the internal decompression state.  The
   814|    stream will keep attributes that may have been set by inflateInit2.
   815|      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   816|    stream state was inconsistent (such as zalloc or state being Z_NULL).
   817| */
   818| ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
   819|                                       int windowBits));
   820| /*
   821|      This function is the same as inflateReset, but it also permits changing
   822|    the wrap and window size requests.  The windowBits parameter is interpreted
   823|    the same as it is for inflateInit2.  If the window size is changed, then the
   824|    memory allocated for the window is freed, and the window will be reallocated
   825|    by inflate() if needed.
   826|      inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   827|    stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   828|    the windowBits parameter is invalid.
   829| */
   830| ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
   831|                                      int bits,
   832|                                      int value));
   833| /*
   834|      This function inserts bits in the inflate input stream.  The intent is
   835|    that this function is used to start inflating at a bit position in the
   836|    middle of a byte.  The provided bits will be used before any bytes are used
   837|    from next_in.  This function should only be used with raw inflate, and
   838|    should be used before the first inflate() call after inflateInit2() or
   839|    inflateReset().  bits must be less than or equal to 16, and that many of the
   840|    least significant bits of value will be inserted in the input.
   841|      If bits is negative, then the input stream bit buffer is emptied.  Then
   842|    inflatePrime() can be called again to put bits in the buffer.  This is used
   843|    to clear out bits leftover after feeding inflate a block description prior
   844|    to feeding inflate codes.
   845|      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   846|    stream state was inconsistent.
   847| */
   848| ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
   849| /*
   850|      This function returns two values, one in the lower 16 bits of the return
   851|    value, and the other in the remaining upper bits, obtained by shifting the
   852|    return value down 16 bits.  If the upper value is -1 and the lower value is
   853|    zero, then inflate() is currently decoding information outside of a block.
   854|    If the upper value is -1 and the lower value is non-zero, then inflate is in
   855|    the middle of a stored block, with the lower value equaling the number of
   856|    bytes from the input remaining to copy.  If the upper value is not -1, then
   857|    it is the number of bits back from the current bit position in the input of
   858|    the code (literal or length/distance pair) currently being processed.  In
   859|    that case the lower value is the number of bytes already emitted for that
   860|    code.
   861|      A code is being processed if inflate is waiting for more input to complete
   862|    decoding of the code, or if it has completed decoding but is waiting for
   863|    more output space to write the literal or match data.
   864|      inflateMark() is used to mark locations in the input data for random
   865|    access, which may be at bit positions, and to note those cases where the
   866|    output of a code may span boundaries of random access blocks.  The current
   867|    location in the input stream can be determined from avail_in and data_type
   868|    as noted in the description for the Z_BLOCK flush parameter for inflate.
   869|      inflateMark returns the value noted above, or -65536 if the provided
   870|    source stream state was inconsistent.
   871| */
   872| ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
   873|                                          gz_headerp head));
   874| /*
   875|      inflateGetHeader() requests that gzip header information be stored in the
   876|    provided gz_header structure.  inflateGetHeader() may be called after
   877|    inflateInit2() or inflateReset(), and before the first call of inflate().
   878|    As inflate() processes the gzip stream, head->done is zero until the header
   879|    is completed, at which time head->done is set to one.  If a zlib stream is
   880|    being decoded, then head->done is set to -1 to indicate that there will be
   881|    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   882|    used to force inflate() to return immediately after header processing is
   883|    complete and before any actual data is decompressed.
   884|      The text, time, xflags, and os fields are filled in with the gzip header
   885|    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   886|    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   887|    contains the maximum number of bytes to write to extra.  Once done is true,
   888|    extra_len contains the actual extra field length, and extra contains the
   889|    extra field, or that field truncated if extra_max is less than extra_len.
   890|    If name is not Z_NULL, then up to name_max characters are written there,
   891|    terminated with a zero unless the length is greater than name_max.  If
   892|    comment is not Z_NULL, then up to comm_max characters are written there,
   893|    terminated with a zero unless the length is greater than comm_max.  When any
   894|    of extra, name, or comment are not Z_NULL and the respective field is not
   895|    present in the header, then that field is set to Z_NULL to signal its
   896|    absence.  This allows the use of deflateSetHeader() with the returned
   897|    structure to duplicate the header.  However if those fields are set to
   898|    allocated memory, then the application will need to save those pointers
   899|    elsewhere so that they can be eventually freed.
   900|      If inflateGetHeader is not used, then the header information is simply
   901|    discarded.  The header is always checked for validity, including the header
   902|    CRC if present.  inflateReset() will reset the process to discard the header
   903|    information.  The application would need to call inflateGetHeader() again to
   904|    retrieve the header from the next gzip stream.
   905|      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   906|    stream state was inconsistent.
   907| */
   908| /*
   909| ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
   910|                                         unsigned char FAR *window));
   911|      Initialize the internal stream state for decompression using inflateBack()
   912|    calls.  The fields zalloc, zfree and opaque in strm must be initialized
   913|    before the call.  If zalloc and zfree are Z_NULL, then the default library-
   914|    derived memory allocation routines are used.  windowBits is the base two
   915|    logarithm of the window size, in the range 8..15.  window is a caller
   916|    supplied buffer of that size.  Except for special applications where it is
   917|    assured that deflate was used with small window sizes, windowBits must be 15
   918|    and a 32K byte window must be supplied to be able to decompress general
   919|    deflate streams.
   920|      See inflateBack() for the usage of these routines.
   921|      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   922|    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   923|    allocated, or Z_VERSION_ERROR if the version of the library does not match
   924|    the version of the header file.
   925| */
   926| typedef unsigned (*in_func) OF((void FAR *,
   927|                                 z_const unsigned char FAR * FAR *));
   928| typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
   929| ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
   930|                                     in_func in, void FAR *in_desc,
   931|                                     out_func out, void FAR *out_desc));
   932| /*
   933|      inflateBack() does a raw inflate with a single call using a call-back
   934|    interface for input and output.  This is potentially more efficient than
   935|    inflate() for file i/o applications, in that it avoids copying between the
   936|    output and the sliding window by simply making the window itself the output
   937|    buffer.  inflate() can be faster on modern CPUs when used with large
   938|    buffers.  inflateBack() trusts the application to not change the output
   939|    buffer passed by the output function, at least until inflateBack() returns.
   940|      inflateBackInit() must be called first to allocate the internal state
   941|    and to initialize the state with the user-provided window buffer.
   942|    inflateBack() may then be used multiple times to inflate a complete, raw
   943|    deflate stream with each call.  inflateBackEnd() is then called to free the
   944|    allocated state.
   945|      A raw deflate stream is one with no zlib or gzip header or trailer.
   946|    This routine would normally be used in a utility that reads zip or gzip
   947|    files and writes out uncompressed files.  The utility would decode the
   948|    header and process the trailer on its own, hence this routine expects only
   949|    the raw deflate stream to decompress.  This is different from the default
   950|    behavior of inflate(), which expects a zlib header and trailer around the
   951|    deflate stream.
   952|      inflateBack() uses two subroutines supplied by the caller that are then
   953|    called by inflateBack() for input and output.  inflateBack() calls those
   954|    routines until it reads a complete deflate stream and writes out all of the
   955|    uncompressed data, or until it encounters an error.  The function's
   956|    parameters and return types are defined above in the in_func and out_func
   957|    typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   958|    number of bytes of provided input, and a pointer to that input in buf.  If
   959|    there is no input available, in() must return zero -- buf is ignored in that
   960|    case -- and inflateBack() will return a buffer error.  inflateBack() will
   961|    call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
   962|    out() should return zero on success, or non-zero on failure.  If out()
   963|    returns non-zero, inflateBack() will return with an error.  Neither in() nor
   964|    out() are permitted to change the contents of the window provided to
   965|    inflateBackInit(), which is also the buffer that out() uses to write from.
   966|    The length written by out() will be at most the window size.  Any non-zero
   967|    amount of input may be provided by in().
   968|      For convenience, inflateBack() can be provided input on the first call by
   969|    setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   970|    in() will be called.  Therefore strm->next_in must be initialized before
   971|    calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   972|    immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   973|    must also be initialized, and then if strm->avail_in is not zero, input will
   974|    initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
   975|      The in_desc and out_desc parameters of inflateBack() is passed as the
   976|    first parameter of in() and out() respectively when they are called.  These
   977|    descriptors can be optionally used to pass any information that the caller-
   978|    supplied in() and out() functions need to do their job.
   979|      On return, inflateBack() will set strm->next_in and strm->avail_in to
   980|    pass back any unused input that was provided by the last in() call.  The
   981|    return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   982|    if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   983|    in the deflate stream (in which case strm->msg is set to indicate the nature
   984|    of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   985|    In the case of Z_BUF_ERROR, an input or output error can be distinguished
   986|    using strm->next_in which will be Z_NULL only if in() returned an error.  If
   987|    strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   988|    non-zero.  (in() will always be called before out(), so strm->next_in is
   989|    assured to be defined if out() returns non-zero.)  Note that inflateBack()
   990|    cannot return Z_OK.
   991| */
   992| ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
   993| /*
   994|      All memory allocated by inflateBackInit() is freed.
   995|      inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   996|    state was inconsistent.
   997| */
   998| ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
   999| /* Return flags indicating compile-time options.
  1000|     Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
  1001|      1.0: size of uInt
  1002|      3.2: size of uLong
  1003|      5.4: size of voidpf (pointer)
  1004|      7.6: size of z_off_t
  1005|     Compiler, assembler, and debug options:
  1006|      8: ZLIB_DEBUG
  1007|      9: ASMV or ASMINF -- use ASM code
  1008|      10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
  1009|      11: 0 (reserved)
  1010|     One-time table building (smaller code, but not thread-safe if true):
  1011|      12: BUILDFIXED -- build static block decoding tables when needed
  1012|      13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
  1013|      14,15: 0 (reserved)
  1014|     Library content (indicates missing functionality):
  1015|      16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
  1016|                           deflate code when not needed)
  1017|      17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
  1018|                     and decode gzip streams (to avoid linking crc code)
  1019|      18-19: 0 (reserved)
  1020|     Operation variations (changes in library functionality):
  1021|      20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
  1022|      21: FASTEST -- deflate algorithm with only one, lowest compression level
  1023|      22,23: 0 (reserved)
  1024|     The sprintf variant used by gzprintf (zero is best):
  1025|      24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
  1026|      25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
  1027|      26: 0 = returns value, 1 = void -- 1 means inferred string length returned
  1028|     Remainder:
  1029|      27-31: 0 (reserved)
  1030|  */
  1031| #ifndef Z_SOLO
  1032|                         /* utility functions */
  1033| /*
  1034|      The following utility functions are implemented on top of the basic
  1035|    stream-oriented functions.  To simplify the interface, some default options
  1036|    are assumed (compression level and memory usage, standard memory allocation
  1037|    functions).  The source code of these utility functions can be modified if
  1038|    you need special options.
  1039| */
  1040| ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
  1041|                                  const Bytef *source, uLong sourceLen));
  1042| /*
  1043|      Compresses the source buffer into the destination buffer.  sourceLen is
  1044|    the byte length of the source buffer.  Upon entry, destLen is the total size
  1045|    of the destination buffer, which must be at least the value returned by
  1046|    compressBound(sourceLen).  Upon exit, destLen is the actual size of the
  1047|    compressed data.  compress() is equivalent to compress2() with a level
  1048|    parameter of Z_DEFAULT_COMPRESSION.
  1049|      compress returns Z_OK if success, Z_MEM_ERROR if there was not
  1050|    enough memory, Z_BUF_ERROR if there was not enough room in the output
  1051|    buffer.
  1052| */
  1053| ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
  1054|                                   const Bytef *source, uLong sourceLen,
  1055|                                   int level));
  1056| /*
  1057|      Compresses the source buffer into the destination buffer.  The level
  1058|    parameter has the same meaning as in deflateInit.  sourceLen is the byte
  1059|    length of the source buffer.  Upon entry, destLen is the total size of the
  1060|    destination buffer, which must be at least the value returned by
  1061|    compressBound(sourceLen).  Upon exit, destLen is the actual size of the
  1062|    compressed data.
  1063|      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
  1064|    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
  1065|    Z_STREAM_ERROR if the level parameter is invalid.
  1066| */
  1067| ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
  1068| /*
  1069|      compressBound() returns an upper bound on the compressed size after
  1070|    compress() or compress2() on sourceLen bytes.  It would be used before a
  1071|    compress() or compress2() call to allocate the destination buffer.
  1072| */
  1073| ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
  1074|                                    const Bytef *source, uLong sourceLen));
  1075| /*
  1076|      Decompresses the source buffer into the destination buffer.  sourceLen is
  1077|    the byte length of the source buffer.  Upon entry, destLen is the total size
  1078|    of the destination buffer, which must be large enough to hold the entire
  1079|    uncompressed data.  (The size of the uncompressed data must have been saved
  1080|    previously by the compressor and transmitted to the decompressor by some
  1081|    mechanism outside the scope of this compression library.) Upon exit, destLen
  1082|    is the actual size of the uncompressed data.
  1083|      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
  1084|    enough memory, Z_BUF_ERROR if there was not enough room in the output
  1085|    buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
  1086|    the case where there is not enough room, uncompress() will fill the output
  1087|    buffer with the uncompressed data up to that point.
  1088| */
  1089| ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
  1090|                                     const Bytef *source, uLong *sourceLen));
  1091| /*
  1092|      Same as uncompress, except that sourceLen is a pointer, where the
  1093|    length of the source is *sourceLen.  On return, *sourceLen is the number of
  1094|    source bytes consumed.
  1095| */
  1096|                         /* gzip file access functions */
  1097| /*
  1098|      This library supports reading and writing files in gzip (.gz) format with
  1099|    an interface similar to that of stdio, using the functions that start with
  1100|    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
  1101|    wrapper, documented in RFC 1952, wrapped around a deflate stream.
  1102| */
  1103| typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
  1104| /*
  1105| ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
  1106|      Open the gzip (.gz) file at path for reading and decompressing, or
  1107|    compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")
  1108|    but can also include a compression level ("wb9") or a strategy: 'f' for
  1109|    filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",
  1110|    'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression
  1111|    as in "wb9F".  (See the description of deflateInit2 for more information
  1112|    about the strategy parameter.)  'T' will request transparent writing or
  1113|    appending with no compression and not using the gzip format.
  1114|      "a" can be used instead of "w" to request that the gzip stream that will
  1115|    be written be appended to the file.  "+" will result in an error, since
  1116|    reading and writing to the same gzip file is not supported.  The addition of
  1117|    "x" when writing will create the file exclusively, which fails if the file
  1118|    already exists.  On systems that support it, the addition of "e" when
  1119|    reading or writing will set the flag to close the file on an execve() call.
  1120|      These functions, as well as gzip, will read and decode a sequence of gzip
  1121|    streams in a file.  The append function of gzopen() can be used to create
  1122|    such a file.  (Also see gzflush() for another way to do this.)  When
  1123|    appending, gzopen does not test whether the file begins with a gzip stream,
  1124|    nor does it look for the end of the gzip streams to begin appending.  gzopen
  1125|    will simply append a gzip stream to the existing file.
  1126|      gzopen can be used to read a file which is not in gzip format; in this
  1127|    case gzread will directly read from the file without decompression.  When
  1128|    reading, this will be detected automatically by looking for the magic two-
  1129|    byte gzip header.
  1130|      gzopen returns NULL if the file could not be opened, if there was
  1131|    insufficient memory to allocate the gzFile state, or if an invalid mode was
  1132|    specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
  1133|    errno can be checked to determine if the reason gzopen failed was that the
  1134|    file could not be opened.
  1135| */
  1136| ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
  1137| /*
  1138|      Associate a gzFile with the file descriptor fd.  File descriptors are
  1139|    obtained from calls like open, dup, creat, pipe or fileno (if the file has
  1140|    been previously opened with fopen).  The mode parameter is as in gzopen.
  1141|      The next call of gzclose on the returned gzFile will also close the file
  1142|    descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
  1143|    fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
  1144|    mode);.  The duplicated descriptor should be saved to avoid a leak, since
  1145|    gzdopen does not close fd if it fails.  If you are using fileno() to get the
  1146|    file descriptor from a FILE *, then you will have to use dup() to avoid
  1147|    double-close()ing the file descriptor.  Both gzclose() and fclose() will
  1148|    close the associated file descriptor, so they need to have different file
  1149|    descriptors.
  1150|      gzdopen returns NULL if there was insufficient memory to allocate the
  1151|    gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
  1152|    provided, or '+' was provided), or if fd is -1.  The file descriptor is not
  1153|    used until the next gz* read, write, seek, or close operation, so gzdopen
  1154|    will not detect if fd is invalid (unless fd is -1).
  1155| */
  1156| ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
  1157| /*
  1158|      Set the internal buffer size used by this library's functions for file to
  1159|    size.  The default buffer size is 8192 bytes.  This function must be called
  1160|    after gzopen() or gzdopen(), and before any other calls that read or write
  1161|    the file.  The buffer memory allocation is always deferred to the first read
  1162|    or write.  Three times that size in buffer space is allocated.  A larger
  1163|    buffer size of, for example, 64K or 128K bytes will noticeably increase the
  1164|    speed of decompression (reading).
  1165|      The new buffer size also affects the maximum length for gzprintf().
  1166|      gzbuffer() returns 0 on success, or -1 on failure, such as being called
  1167|    too late.
  1168| */
  1169| ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
  1170| /*
  1171|      Dynamically update the compression level and strategy for file.  See the
  1172|    description of deflateInit2 for the meaning of these parameters. Previously
  1173|    provided data is flushed before applying the parameter changes.
  1174|      gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
  1175|    opened for writing, Z_ERRNO if there is an error writing the flushed data,
  1176|    or Z_MEM_ERROR if there is a memory allocation error.
  1177| */
  1178| ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
  1179| /*
  1180|      Read and decompress up to len uncompressed bytes from file into buf.  If
  1181|    the input file is not in gzip format, gzread copies the given number of
  1182|    bytes into the buffer directly from the file.
  1183|      After reaching the end of a gzip stream in the input, gzread will continue
  1184|    to read, looking for another gzip stream.  Any number of gzip streams may be
  1185|    concatenated in the input file, and will all be decompressed by gzread().
  1186|    If something other than a gzip stream is encountered after a gzip stream,
  1187|    that remaining trailing garbage is ignored (and no error is returned).
  1188|      gzread can be used to read a gzip file that is being concurrently written.
  1189|    Upon reaching the end of the input, gzread will return with the available
  1190|    data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
  1191|    gzclearerr can be used to clear the end of file indicator in order to permit
  1192|    gzread to be tried again.  Z_OK indicates that a gzip stream was completed
  1193|    on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
  1194|    middle of a gzip stream.  Note that gzread does not return -1 in the event
  1195|    of an incomplete gzip stream.  This error is deferred until gzclose(), which
  1196|    will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
  1197|    stream.  Alternatively, gzerror can be used before gzclose to detect this
  1198|    case.
  1199|      gzread returns the number of uncompressed bytes actually read, less than
  1200|    len for end of file, or -1 for error.  If len is too large to fit in an int,
  1201|    then nothing is read, -1 is returned, and the error state is set to
  1202|    Z_STREAM_ERROR.
  1203| */
  1204| ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
  1205|                                      gzFile file));
  1206| /*
  1207|      Read and decompress up to nitems items of size size from file into buf,
  1208|    otherwise operating as gzread() does.  This duplicates the interface of
  1209|    stdio's fread(), with size_t request and return types.  If the library
  1210|    defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t
  1211|    is an unsigned integer type that can contain a pointer.
  1212|      gzfread() returns the number of full items read of size size, or zero if
  1213|    the end of the file was reached and a full item could not be read, or if
  1214|    there was an error.  gzerror() must be consulted if zero is returned in
  1215|    order to determine if there was an error.  If the multiplication of size and
  1216|    nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
  1217|    is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
  1218|      In the event that the end of file is reached and only a partial item is
  1219|    available at the end, i.e. the remaining uncompressed data length is not a
  1220|    multiple of size, then the final partial item is nevertheless read into buf
  1221|    and the end-of-file flag is set.  The length of the partial item read is not
  1222|    provided, but could be inferred from the result of gztell().  This behavior
  1223|    is the same as the behavior of fread() implementations in common libraries,
  1224|    but it prevents the direct use of gzfread() to read a concurrently written
  1225|    file, resetting and retrying on end-of-file, when size is not 1.
  1226| */
  1227| ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));
  1228| /*
  1229|      Compress and write the len uncompressed bytes at buf to file. gzwrite
  1230|    returns the number of uncompressed bytes written or 0 in case of error.
  1231| */
  1232| ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
  1233|                                       z_size_t nitems, gzFile file));
  1234| /*
  1235|      Compress and write nitems items of size size from buf to file, duplicating
  1236|    the interface of stdio's fwrite(), with size_t request and return types.  If
  1237|    the library defines size_t, then z_size_t is identical to size_t.  If not,
  1238|    then z_size_t is an unsigned integer type that can contain a pointer.
  1239|      gzfwrite() returns the number of full items written of size size, or zero
  1240|    if there was an error.  If the multiplication of size and nitems overflows,
  1241|    i.e. the product does not fit in a z_size_t, then nothing is written, zero
  1242|    is returned, and the error state is set to Z_STREAM_ERROR.
  1243| */
  1244| ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
  1245| /*
  1246|      Convert, format, compress, and write the arguments (...) to file under
  1247|    control of the string format, as in fprintf.  gzprintf returns the number of
  1248|    uncompressed bytes actually written, or a negative zlib error code in case
  1249|    of error.  The number of uncompressed bytes written is limited to 8191, or
  1250|    one less than the buffer size given to gzbuffer().  The caller should assure
  1251|    that this limit is not exceeded.  If it is exceeded, then gzprintf() will
  1252|    return an error (0) with nothing written.  In this case, there may also be a
  1253|    buffer overflow with unpredictable consequences, which is possible only if
  1254|    zlib was compiled with the insecure functions sprintf() or vsprintf(),
  1255|    because the secure snprintf() or vsnprintf() functions were not available.
  1256|    This can be determined using zlibCompileFlags().
  1257| */
  1258| ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
  1259| /*
  1260|      Compress and write the given null-terminated string s to file, excluding
  1261|    the terminating null character.
  1262|      gzputs returns the number of characters written, or -1 in case of error.
  1263| */
  1264| ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
  1265| /*
  1266|      Read and decompress bytes from file into buf, until len-1 characters are
  1267|    read, or until a newline character is read and transferred to buf, or an
  1268|    end-of-file condition is encountered.  If any characters are read or if len
  1269|    is one, the string is terminated with a null character.  If no characters
  1270|    are read due to an end-of-file or len is less than one, then the buffer is
  1271|    left untouched.
  1272|      gzgets returns buf which is a null-terminated string, or it returns NULL
  1273|    for end-of-file or in case of error.  If there was an error, the contents at
  1274|    buf are indeterminate.
  1275| */
  1276| ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
  1277| /*
  1278|      Compress and write c, converted to an unsigned char, into file.  gzputc
  1279|    returns the value that was written, or -1 in case of error.
  1280| */
  1281| ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
  1282| /*
  1283|      Read and decompress one byte from file.  gzgetc returns this byte or -1
  1284|    in case of end of file or error.  This is implemented as a macro for speed.
  1285|    As such, it does not do all of the checking the other functions do.  I.e.
  1286|    it does not check to see if file is NULL, nor whether the structure file
  1287|    points to has been clobbered or not.
  1288| */
  1289| ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
  1290| /*
  1291|      Push c back onto the stream for file to be read as the first character on
  1292|    the next read.  At least one character of push-back is always allowed.
  1293|    gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
  1294|    fail if c is -1, and may fail if a character has been pushed but not read
  1295|    yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
  1296|    output buffer size of pushed characters is allowed.  (See gzbuffer above.)
  1297|    The pushed character will be discarded if the stream is repositioned with
  1298|    gzseek() or gzrewind().
  1299| */
  1300| ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
  1301| /*
  1302|      Flush all pending output to file.  The parameter flush is as in the
  1303|    deflate() function.  The return value is the zlib error number (see function
  1304|    gzerror below).  gzflush is only permitted when writing.
  1305|      If the flush parameter is Z_FINISH, the remaining data is written and the
  1306|    gzip stream is completed in the output.  If gzwrite() is called again, a new
  1307|    gzip stream will be started in the output.  gzread() is able to read such
  1308|    concatenated gzip streams.
  1309|      gzflush should be called only when strictly necessary because it will
  1310|    degrade compression if called too often.
  1311| */
  1312| /*
  1313| ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
  1314|                                    z_off_t offset, int whence));
  1315|      Set the starting position to offset relative to whence for the next gzread
  1316|    or gzwrite on file.  The offset represents a number of bytes in the
  1317|    uncompressed data stream.  The whence parameter is defined as in lseek(2);
  1318|    the value SEEK_END is not supported.
  1319|      If the file is opened for reading, this function is emulated but can be
  1320|    extremely slow.  If the file is opened for writing, only forward seeks are
  1321|    supported; gzseek then compresses a sequence of zeroes up to the new
  1322|    starting position.
  1323|      gzseek returns the resulting offset location as measured in bytes from
  1324|    the beginning of the uncompressed stream, or -1 in case of error, in
  1325|    particular if the file is opened for writing and the new starting position
  1326|    would be before the current position.
  1327| */
  1328| ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
  1329| /*
  1330|      Rewind file. This function is supported only for reading.
  1331|      gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).
  1332| */
  1333| /*
  1334| ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
  1335|      Return the starting position for the next gzread or gzwrite on file.
  1336|    This position represents a number of bytes in the uncompressed data stream,
  1337|    and is zero when starting, even if appending or reading a gzip stream from
  1338|    the middle of a file using gzdopen().
  1339|      gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
  1340| */
  1341| /*
  1342| ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
  1343|      Return the current compressed (actual) read or write offset of file.  This
  1344|    offset includes the count of bytes that precede the gzip stream, for example
  1345|    when appending or when using gzdopen() for reading.  When reading, the
  1346|    offset does not include as yet unused buffered input.  This information can
  1347|    be used for a progress indicator.  On error, gzoffset() returns -1.
  1348| */
  1349| ZEXTERN int ZEXPORT gzeof OF((gzFile file));
  1350| /*
  1351|      Return true (1) if the end-of-file indicator for file has been set while
  1352|    reading, false (0) otherwise.  Note that the end-of-file indicator is set
  1353|    only if the read tried to go past the end of the input, but came up short.
  1354|    Therefore, just like feof(), gzeof() may return false even if there is no
  1355|    more data to read, in the event that the last read request was for the exact
  1356|    number of bytes remaining in the input file.  This will happen if the input
  1357|    file size is an exact multiple of the buffer size.
  1358|      If gzeof() returns true, then the read functions will return no more data,
  1359|    unless the end-of-file indicator is reset by gzclearerr() and the input file
  1360|    has grown since the previous end of file was detected.
  1361| */
  1362| ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
  1363| /*
  1364|      Return true (1) if file is being copied directly while reading, or false
  1365|    (0) if file is a gzip stream being decompressed.
  1366|      If the input file is empty, gzdirect() will return true, since the input
  1367|    does not contain a gzip stream.
  1368|      If gzdirect() is used immediately after gzopen() or gzdopen() it will
  1369|    cause buffers to be allocated to allow reading the file to determine if it
  1370|    is a gzip file.  Therefore if gzbuffer() is used, it should be called before
  1371|    gzdirect().
  1372|      When writing, gzdirect() returns true (1) if transparent writing was
  1373|    requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
  1374|    gzdirect() is not needed when writing.  Transparent writing must be
  1375|    explicitly requested, so the application already knows the answer.  When
  1376|    linking statically, using gzdirect() will include all of the zlib code for
  1377|    gzip file reading and decompression, which may not be desired.)
  1378| */
  1379| ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
  1380| /*
  1381|      Flush all pending output for file, if necessary, close file and
  1382|    deallocate the (de)compression state.  Note that once file is closed, you
  1383|    cannot call gzerror with file, since its structures have been deallocated.
  1384|    gzclose must not be called more than once on the same file, just as free
  1385|    must not be called more than once on the same allocation.
  1386|      gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
  1387|    file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
  1388|    last read ended in the middle of a gzip stream, or Z_OK on success.
  1389| */
  1390| ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
  1391| ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
  1392| /*
  1393|      Same as gzclose(), but gzclose_r() is only for use when reading, and
  1394|    gzclose_w() is only for use when writing or appending.  The advantage to
  1395|    using these instead of gzclose() is that they avoid linking in zlib
  1396|    compression or decompression code that is not used when only reading or only
  1397|    writing respectively.  If gzclose() is used, then both compression and
  1398|    decompression code will be included the application when linking to a static
  1399|    zlib library.
  1400| */
  1401| ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
  1402| /*
  1403|      Return the error message for the last error which occurred on file.
  1404|    errnum is set to zlib error number.  If an error occurred in the file system
  1405|    and not in the compression library, errnum is set to Z_ERRNO and the
  1406|    application may consult errno to get the exact error code.
  1407|      The application must not modify the returned string.  Future calls to
  1408|    this function may invalidate the previously returned string.  If file is
  1409|    closed, then the string previously returned by gzerror will no longer be
  1410|    available.
  1411|      gzerror() should be used to distinguish errors from end-of-file for those
  1412|    functions above that do not distinguish those cases in their return values.
  1413| */
  1414| ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
  1415| /*
  1416|      Clear the error and end-of-file flags for file.  This is analogous to the
  1417|    clearerr() function in stdio.  This is useful for continuing to read a gzip
  1418|    file that is being written concurrently.
  1419| */
  1420| #endif /* !Z_SOLO */
  1421|                         /* checksum functions */
  1422| /*
  1423|      These functions are not related to compression but are exported
  1424|    anyway because they might be useful in applications using the compression
  1425|    library.
  1426| */
  1427| ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
  1428| /*
  1429|      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
  1430|    return the updated checksum. An Adler-32 value is in the range of a 32-bit
  1431|    unsigned integer. If buf is Z_NULL, this function returns the required
  1432|    initial value for the checksum.
  1433|      An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
  1434|    much faster.
  1435|    Usage example:
  1436|      uLong adler = adler32(0L, Z_NULL, 0);
  1437|      while (read_buffer(buffer, length) != EOF) {
  1438|        adler = adler32(adler, buffer, length);
  1439|      }
  1440|      if (adler != original_adler) error();
  1441| */
  1442| ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
  1443|                                     z_size_t len));
  1444| /*
  1445|      Same as adler32(), but with a size_t length.
  1446| */
  1447| /*
  1448| ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
  1449|                                           z_off_t len2));
  1450|      Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
  1451|    and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
  1452|    each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
  1453|    seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
  1454|    that the z_off_t type (like off_t) is a signed integer.  If len2 is
  1455|    negative, the result has no meaning or utility.
  1456| */
  1457| ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));
  1458| /*
  1459|      Update a running CRC-32 with the bytes buf[0..len-1] and return the
  1460|    updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.
  1461|    If buf is Z_NULL, this function returns the required initial value for the
  1462|    crc. Pre- and post-conditioning (one's complement) is performed within this
  1463|    function so it shouldn't be done by the application.
  1464|    Usage example:
  1465|      uLong crc = crc32(0L, Z_NULL, 0);
  1466|      while (read_buffer(buffer, length) != EOF) {
  1467|        crc = crc32(crc, buffer, length);
  1468|      }
  1469|      if (crc != original_crc) error();
  1470| */
  1471| ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,
  1472|                                   z_size_t len));
  1473| /*
  1474|      Same as crc32(), but with a size_t length.
  1475| */
  1476| /*
  1477| ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
  1478|      Combine two CRC-32 check values into one.  For two sequences of bytes,
  1479|    seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
  1480|    calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
  1481|    check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
  1482|    len2.
  1483| */
  1484| /*
  1485| ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));
  1486|      Return the operator corresponding to length len2, to be used with
  1487|    crc32_combine_op().
  1488| */
  1489| ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));
  1490| /*
  1491|      Give the same result as crc32_combine(), using op in place of len2. op is
  1492|    is generated from len2 by crc32_combine_gen(). This will be faster than
  1493|    crc32_combine() if the generated op is used more than once.
  1494| */
  1495|                         /* various hacks, don't look :) */
  1496| /* deflateInit and inflateInit are macros to allow checking the zlib version
  1497|  * and the compiler's view of z_stream:
  1498|  */
  1499| ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
  1500|                                      const char *version, int stream_size));
  1501| ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
  1502|                                      const char *version, int stream_size));
  1503| ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
  1504|                                       int windowBits, int memLevel,
  1505|                                       int strategy, const char *version,
  1506|                                       int stream_size));
  1507| ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
  1508|                                       const char *version, int stream_size));
  1509| ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
  1510|                                          unsigned char FAR *window,
  1511|                                          const char *version,
  1512|                                          int stream_size));
  1513| #ifdef Z_PREFIX_SET
  1514| #  define z_deflateInit(strm, level) \
  1515|           deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
  1516| #  define z_inflateInit(strm) \
  1517|           inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
  1518| #  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
  1519|           deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
  1520|                         (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
  1521| #  define z_inflateInit2(strm, windowBits) \
  1522|           inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
  1523|                         (int)sizeof(z_stream))
  1524| #  define z_inflateBackInit(strm, windowBits, window) \
  1525|           inflateBackInit_((strm), (windowBits), (window), \
  1526|                            ZLIB_VERSION, (int)sizeof(z_stream))
  1527| #else
  1528| #  define deflateInit(strm, level) \
  1529|           deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
  1530| #  define inflateInit(strm) \
  1531|           inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
  1532| #  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
  1533|           deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
  1534|                         (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
  1535| #  define inflateInit2(strm, windowBits) \
  1536|           inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
  1537|                         (int)sizeof(z_stream))
  1538| #  define inflateBackInit(strm, windowBits, window) \
  1539|           inflateBackInit_((strm), (windowBits), (window), \
  1540|                            ZLIB_VERSION, (int)sizeof(z_stream))
  1541| #endif
  1542| #ifndef Z_SOLO
  1543| /* gzgetc() macro and its supporting function and exposed data structure.  Note
  1544|  * that the real internal state is much larger than the exposed structure.
  1545|  * This abbreviated structure exposes just enough for the gzgetc() macro.  The
  1546|  * user should not mess with these exposed elements, since their names or
  1547|  * behavior could change in the future, perhaps even capriciously.  They can
  1548|  * only be used by the gzgetc() macro.  You have been warned.
  1549|  */
  1550| struct gzFile_s {
  1551|     unsigned have;
  1552|     unsigned char *next;
  1553|     z_off64_t pos;
  1554| };
  1555| ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
  1556| #ifdef Z_PREFIX_SET
  1557| #  undef z_gzgetc
  1558| #  define z_gzgetc(g) \
  1559|           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
  1560| #else
  1561| #  define gzgetc(g) \
  1562|           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
  1563| #endif
  1564| /* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
  1565|  * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
  1566|  * both are true, the application gets the *64 functions, and the regular
  1567|  * functions are changed to 64 bits) -- in case these are set on systems
  1568|  * without large file support, _LFS64_LARGEFILE must also be true
  1569|  */
  1570| #ifdef Z_LARGE64
  1571|    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
  1572|    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
  1573|    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
  1574|    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
  1575|    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
  1576|    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
  1577|    ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));
  1578| #endif
  1579| #if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
  1580| #  ifdef Z_PREFIX_SET
  1581| #    define z_gzopen z_gzopen64
  1582| #    define z_gzseek z_gzseek64
  1583| #    define z_gztell z_gztell64
  1584| #    define z_gzoffset z_gzoffset64
  1585| #    define z_adler32_combine z_adler32_combine64
  1586| #    define z_crc32_combine z_crc32_combine64
  1587| #    define z_crc32_combine_gen z_crc32_combine_gen64
  1588| #  else
  1589| #    define gzopen gzopen64
  1590| #    define gzseek gzseek64
  1591| #    define gztell gztell64
  1592| #    define gzoffset gzoffset64
  1593| #    define adler32_combine adler32_combine64
  1594| #    define crc32_combine crc32_combine64
  1595| #    define crc32_combine_gen crc32_combine_gen64
  1596| #  endif
  1597| #  ifndef Z_LARGE64
  1598|      ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
  1599|      ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
  1600|      ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
  1601|      ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
  1602|      ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
  1603|      ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
  1604|      ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
  1605| #  endif
  1606| #else
  1607|    ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
  1608|    ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
  1609|    ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
  1610|    ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
  1611|    ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
  1612|    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
  1613|    ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
  1614| #endif
  1615| #else /* Z_SOLO */
  1616|    ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
  1617|    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
  1618|    ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
  1619| #endif /* !Z_SOLO */
  1620| /* undocumented functions */
  1621| ZEXTERN const char   * ZEXPORT zError           OF((int));
  1622| ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
  1623| ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
  1624| ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
  1625| ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
  1626| ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));
  1627| ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
  1628| ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
  1629| #if defined(_WIN32) && !defined(Z_SOLO)
  1630| ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
  1631|                                             const char *mode));
  1632| #endif
  1633| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
  1634| #  ifndef Z_SOLO
  1635| ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
  1636|                                                   const char *format,
  1637|                                                   va_list va));
  1638| #  endif
  1639| #endif
  1640| #ifdef __cplusplus
  1641| }
  1642| #endif
  1643| #endif /* ZLIB_H */


# ====================================================================
# FILE: src/native/external/zlib-intel/zutil.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-278 ---
     1| /* zutil.c -- target dependent utility functions for the compression library
     2|  * Copyright (C) 1995-2017 Jean-loup Gailly
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #include "zutil.h"
     7| #ifndef Z_SOLO
     8| #  include "gzguts.h"
     9| #endif
    10| z_const char * const z_errmsg[10] = {
    11|     (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
    12|     (z_const char *)"stream end",          /* Z_STREAM_END      1  */
    13|     (z_const char *)"",                    /* Z_OK              0  */
    14|     (z_const char *)"file error",          /* Z_ERRNO         (-1) */
    15|     (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
    16|     (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
    17|     (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
    18|     (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
    19|     (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
    20|     (z_const char *)""
    21| };
    22| const char * ZEXPORT zlibVersion()
    23| {
    24|     return ZLIB_VERSION;
    25| }
    26| uLong ZEXPORT zlibCompileFlags()
    27| {
    28|     uLong flags;
    29|     flags = 0;
    30|     switch ((int)(sizeof(uInt))) {
    31|     case 2:     break;
    32|     case 4:     flags += 1;     break;
    33|     case 8:     flags += 2;     break;
    34|     default:    flags += 3;
    35|     }
    36|     switch ((int)(sizeof(uLong))) {
    37|     case 2:     break;
    38|     case 4:     flags += 1 << 2;        break;
    39|     case 8:     flags += 2 << 2;        break;
    40|     default:    flags += 3 << 2;
    41|     }
    42|     switch ((int)(sizeof(voidpf))) {
    43|     case 2:     break;
    44|     case 4:     flags += 1 << 4;        break;
    45|     case 8:     flags += 2 << 4;        break;
    46|     default:    flags += 3 << 4;
    47|     }
    48|     switch ((int)(sizeof(z_off_t))) {
    49|     case 2:     break;
    50|     case 4:     flags += 1 << 6;        break;
    51|     case 8:     flags += 2 << 6;        break;
    52|     default:    flags += 3 << 6;
    53|     }
    54| #ifdef ZLIB_DEBUG
    55|     flags += 1 << 8;
    56| #endif
    57|     /*
    58| #if defined(ASMV) || defined(ASMINF)
    59|     flags += 1 << 9;
    60| #endif
    61|      */
    62| #ifdef ZLIB_WINAPI
    63|     flags += 1 << 10;
    64| #endif
    65| #ifdef BUILDFIXED
    66|     flags += 1 << 12;
    67| #endif
    68| #ifdef DYNAMIC_CRC_TABLE
    69|     flags += 1 << 13;
    70| #endif
    71| #ifdef NO_GZCOMPRESS
    72|     flags += 1L << 16;
    73| #endif
    74| #ifdef NO_GZIP
    75|     flags += 1L << 17;
    76| #endif
    77| #ifdef PKZIP_BUG_WORKAROUND
    78|     flags += 1L << 20;
    79| #endif
    80| #ifdef FASTEST
    81|     flags += 1L << 21;
    82| #endif
    83| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
    84| #  ifdef NO_vsnprintf
    85|     flags += 1L << 25;
    86| #    ifdef HAS_vsprintf_void
    87|     flags += 1L << 26;
    88| #    endif
    89| #  else
    90| #    ifdef HAS_vsnprintf_void
    91|     flags += 1L << 26;
    92| #    endif
    93| #  endif
    94| #else
    95|     flags += 1L << 24;
    96| #  ifdef NO_snprintf
    97|     flags += 1L << 25;
    98| #    ifdef HAS_sprintf_void
    99|     flags += 1L << 26;
   100| #    endif
   101| #  else
   102| #    ifdef HAS_snprintf_void
   103|     flags += 1L << 26;
   104| #    endif
   105| #  endif
   106| #endif
   107|     return flags;
   108| }
   109| #ifdef ZLIB_DEBUG
   110| #include <stdlib.h>
   111| #  ifndef verbose
   112| #    define verbose 0
   113| #  endif
   114| int ZLIB_INTERNAL z_verbose = verbose;
   115| void ZLIB_INTERNAL z_error(m)
   116|     char *m;
   117| {
   118|     fprintf(stderr, "%s\n", m);
   119|     exit(1);
   120| }
   121| #endif
   122| /* exported to allow conversion of error code to string for compress() and
   123|  * uncompress()
   124|  */
   125| const char * ZEXPORT zError(err)
   126|     int err;
   127| {
   128|     return ERR_MSG(err);
   129| }
   130| #if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
   131|     /* The older Microsoft C Run-Time Library for Windows CE doesn't have
   132|      * errno.  We define it as a global variable to simplify porting.
   133|      * Its value is always 0 and should not be used.
   134|      */
   135|     int errno = 0;
   136| #endif
   137| #ifndef HAVE_MEMCPY
   138| void ZLIB_INTERNAL zmemcpy(dest, source, len)
   139|     Bytef* dest;
   140|     const Bytef* source;
   141|     uInt  len;
   142| {
   143|     if (len == 0) return;
   144|     do {
   145|         *dest++ = *source++; /* ??? to be unrolled */
   146|     } while (--len != 0);
   147| }
   148| int ZLIB_INTERNAL zmemcmp(s1, s2, len)
   149|     const Bytef* s1;
   150|     const Bytef* s2;
   151|     uInt  len;
   152| {
   153|     uInt j;
   154|     for (j = 0; j < len; j++) {
   155|         if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
   156|     }
   157|     return 0;
   158| }
   159| void ZLIB_INTERNAL zmemzero(dest, len)
   160|     Bytef* dest;
   161|     uInt  len;
   162| {
   163|     if (len == 0) return;
   164|     do {
   165|         *dest++ = 0;  /* ??? to be unrolled */
   166|     } while (--len != 0);
   167| }
   168| #endif
   169| #ifndef Z_SOLO
   170| #ifdef SYS16BIT
   171| #ifdef __TURBOC__
   172| /* Turbo C in 16-bit mode */
   173| #  define MY_ZCALLOC
   174| /* Turbo C malloc() does not allow dynamic allocation of 64K bytes
   175|  * and farmalloc(64K) returns a pointer with an offset of 8, so we
   176|  * must fix the pointer. Warning: the pointer must be put back to its
   177|  * original form in order to free it, use zcfree().
   178|  */
   179| #define MAX_PTR 10
   180| /* 10*64K = 640K */
   181| local int next_ptr = 0;
   182| typedef struct ptr_table_s {
   183|     voidpf org_ptr;
   184|     voidpf new_ptr;
   185| } ptr_table;
   186| local ptr_table table[MAX_PTR];
   187| /* This table is used to remember the original form of pointers
   188|  * to large buffers (64K). Such pointers are normalized with a zero offset.
   189|  * Since MSDOS is not a preemptive multitasking OS, this table is not
   190|  * protected from concurrent access. This hack doesn't work anyway on
   191|  * a protected system like OS/2. Use Microsoft C instead.
   192|  */
   193| voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
   194| {
   195|     voidpf buf;
   196|     ulg bsize = (ulg)items*size;
   197|     (void)opaque;
   198|     /* If we allocate less than 65520 bytes, we assume that farmalloc
   199|      * will return a usable pointer which doesn't have to be normalized.
   200|      */
   201|     if (bsize < 65520L) {
   202|         buf = farmalloc(bsize);
   203|         if (*(ush*)&buf != 0) return buf;
   204|     } else {
   205|         buf = farmalloc(bsize + 16L);
   206|     }
   207|     if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
   208|     table[next_ptr].org_ptr = buf;
   209|     /* Normalize the pointer to seg:0 */
   210|     *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
   211|     *(ush*)&buf = 0;
   212|     table[next_ptr++].new_ptr = buf;
   213|     return buf;
   214| }
   215| void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
   216| {
   217|     int n;
   218|     (void)opaque;
   219|     if (*(ush*)&ptr != 0) { /* object < 64K */
   220|         farfree(ptr);
   221|         return;
   222|     }
   223|     /* Find the original pointer */
   224|     for (n = 0; n < next_ptr; n++) {
   225|         if (ptr != table[n].new_ptr) continue;
   226|         farfree(table[n].org_ptr);
   227|         while (++n < next_ptr) {
   228|             table[n-1] = table[n];
   229|         }
   230|         next_ptr--;
   231|         return;
   232|     }
   233|     Assert(0, "zcfree: ptr not found");
   234| }
   235| #endif /* __TURBOC__ */
   236| #ifdef M_I86
   237| /* Microsoft C in 16-bit mode */
   238| #  define MY_ZCALLOC
   239| #if (!defined(_MSC_VER) || (_MSC_VER <= 600))
   240| #  define _halloc  halloc
   241| #  define _hfree   hfree
   242| #endif
   243| voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)
   244| {
   245|     (void)opaque;
   246|     return _halloc((long)items, size);
   247| }
   248| void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
   249| {
   250|     (void)opaque;
   251|     _hfree(ptr);
   252| }
   253| #endif /* M_I86 */
   254| #endif /* SYS16BIT */
   255| #ifndef MY_ZCALLOC /* Any system without a special alloc function */
   256| #ifndef STDC
   257| extern voidp  malloc OF((uInt size));
   258| extern voidp  calloc OF((uInt items, uInt size));
   259| extern void   free   OF((voidpf ptr));
   260| #endif
   261| voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
   262|     voidpf opaque;
   263|     unsigned items;
   264|     unsigned size;
   265| {
   266|     (void)opaque;
   267|     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
   268|                               (voidpf)calloc(items, size);
   269| }
   270| void ZLIB_INTERNAL zcfree(opaque, ptr)
   271|     voidpf opaque;
   272|     voidpf ptr;
   273| {
   274|     (void)opaque;
   275|     free(ptr);
   276| }
   277| #endif /* MY_ZCALLOC */
   278| #endif /* !Z_SOLO */


# ====================================================================
# FILE: src/native/external/zlib-intel/zutil.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-253 ---
     1| /* zutil.h -- internal interface and configuration of the compression library
     2|  * Copyright (C) 1995-2022 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* WARNING: this file should *not* be used by applications. It is
     6|    part of the implementation of the compression library and is
     7|    subject to change. Applications should only use zlib.h.
     8|  */
     9| /* @(#) $Id$ */
    10| #ifndef ZUTIL_H
    11| #define ZUTIL_H
    12| #include "x86.h"
    13| #ifdef HAVE_HIDDEN
    14| #  define ZLIB_INTERNAL __attribute__((visibility ("hidden")))
    15| #else
    16| #  define ZLIB_INTERNAL
    17| #endif
    18| #include "zlib.h"
    19| #if defined(STDC) && !defined(Z_SOLO)
    20| #  if !(defined(_WIN32_WCE) && defined(_MSC_VER))
    21| #    include <stddef.h>
    22| #  endif
    23| #  include <string.h>
    24| #  include <stdlib.h>
    25| #endif
    26| #ifndef local
    27| #  define local static
    28| #endif
    29| /* since "static" is used to mean two completely different things in C, we
    30|    define "local" for the non-static meaning of "static", for readability
    31|    (compile with -Dlocal if your debugger can't find static symbols) */
    32| typedef unsigned char  uch;
    33| typedef uch FAR uchf;
    34| typedef unsigned short ush;
    35| typedef ush FAR ushf;
    36| typedef unsigned long  ulg;
    37| #if !defined(Z_U8) && !defined(Z_SOLO) && defined(STDC)
    38| #  include <limits.h>
    39| #  if (ULONG_MAX == 0xffffffffffffffff)
    40| #    define Z_U8 unsigned long
    41| #  elif (ULLONG_MAX == 0xffffffffffffffff)
    42| #    define Z_U8 unsigned long long
    43| #  elif (UINT_MAX == 0xffffffffffffffff)
    44| #    define Z_U8 unsigned
    45| #  endif
    46| #endif
    47| extern z_const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
    48| /* (size given to avoid silly warnings with Visual C++) */
    49| #define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
    50| #define ERR_RETURN(strm,err) \
    51|   return (strm->msg = ERR_MSG(err), (err))
    52| /* To be used only when the state is known to be valid */
    53|         /* common constants */
    54| #ifndef DEF_WBITS
    55| #  define DEF_WBITS MAX_WBITS
    56| #endif
    57| /* default windowBits for decompression. MAX_WBITS is for compression only */
    58| #if MAX_MEM_LEVEL >= 8
    59| #  define DEF_MEM_LEVEL 8
    60| #else
    61| #  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
    62| #endif
    63| /* default memLevel */
    64| #define STORED_BLOCK 0
    65| #define STATIC_TREES 1
    66| #define DYN_TREES    2
    67| /* The three kinds of block type */
    68| #define MIN_MATCH  3
    69| #define MAX_MATCH  258
    70| /* The minimum and maximum match lengths */
    71| #define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
    72|         /* target dependencies */
    73| #if defined(MSDOS) || (defined(WINDOWS) && !defined(WIN32))
    74| #  define OS_CODE  0x00
    75| #  ifndef Z_SOLO
    76| #    if defined(__TURBOC__) || defined(__BORLANDC__)
    77| #      if (__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
    78|          /* Allow compilation with ANSI keywords only enabled */
    79|          void _Cdecl farfree( void *block );
    80|          void *_Cdecl farmalloc( unsigned long nbytes );
    81| #      else
    82| #        include <alloc.h>
    83| #      endif
    84| #    else /* MSC or DJGPP */
    85| #      include <malloc.h>
    86| #    endif
    87| #  endif
    88| #endif
    89| #ifdef AMIGA
    90| #  define OS_CODE  1
    91| #endif
    92| #if defined(VAXC) || defined(VMS)
    93| #  define OS_CODE  2
    94| #  define F_OPEN(name, mode) \
    95|      fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
    96| #endif
    97| #ifdef __370__
    98| #  if __TARGET_LIB__ < 0x20000000
    99| #    define OS_CODE 4
   100| #  elif __TARGET_LIB__ < 0x40000000
   101| #    define OS_CODE 11
   102| #  else
   103| #    define OS_CODE 8
   104| #  endif
   105| #endif
   106| #if defined(ATARI) || defined(atarist)
   107| #  define OS_CODE  5
   108| #endif
   109| #ifdef OS2
   110| #  define OS_CODE  6
   111| #  if defined(M_I86) && !defined(Z_SOLO)
   112| #    include <malloc.h>
   113| #  endif
   114| #endif
   115| #if defined(MACOS) || defined(TARGET_OS_MAC)
   116| #  define OS_CODE  7
   117| #  ifndef Z_SOLO
   118| #    if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
   119| #      include <unix.h> /* for fdopen */
   120| #    else
   121| #      ifndef fdopen
   122| #        define fdopen(fd,mode) NULL /* No fdopen() */
   123| #      endif
   124| #    endif
   125| #  endif
   126| #endif
   127| #ifdef __acorn
   128| #  define OS_CODE 13
   129| #endif
   130| #if defined(WIN32) && !defined(__CYGWIN__)
   131| #  define OS_CODE  10
   132| #endif
   133| #ifdef _BEOS_
   134| #  define OS_CODE  16
   135| #endif
   136| #ifdef __TOS_OS400__
   137| #  define OS_CODE 18
   138| #endif
   139| #ifdef __APPLE__
   140| #  define OS_CODE 19
   141| #endif
   142| #if defined(_BEOS_) || defined(RISCOS)
   143| #  define fdopen(fd,mode) NULL /* No fdopen() */
   144| #endif
   145| #if (defined(_MSC_VER) && (_MSC_VER > 600)) && !defined __INTERIX
   146| #  if defined(_WIN32_WCE)
   147| #    define fdopen(fd,mode) NULL /* No fdopen() */
   148| #  else
   149| #    define fdopen(fd,type)  _fdopen(fd,type)
   150| #  endif
   151| #endif
   152| #if defined(__BORLANDC__) && !defined(MSDOS)
   153|   #pragma warn -8004
   154|   #pragma warn -8008
   155|   #pragma warn -8066
   156| #endif
   157| #if defined(__GNUC__)
   158| #  define zlikely(x)    __builtin_expect(!!(x), 1)
   159| #  define zunlikely(x)  __builtin_expect(!!(x), 0)
   160| #else
   161| #  define zlikely(x)    x
   162| #  define zunlikely(x)  x
   163| #endif
   164| #if defined(_MSC_VER)
   165| #define zalign(x)        __declspec(align(x))
   166| #else
   167| #define zalign(x)        __attribute__((aligned((x))))
   168| #endif
   169| #if defined(_MSC_VER)
   170| #define zalways_inline    __forceinline
   171| #else
   172| #define zalways_inline    __attribute__((always_inline))
   173| #endif
   174| /* provide prototypes for these when building zlib without LFS */
   175| #if !defined(_WIN32) && \
   176|     (!defined(_LARGEFILE64_SOURCE) || _LFS64_LARGEFILE-0 == 0)
   177|     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
   178|     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
   179|     ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
   180| #endif
   181|         /* common defaults */
   182| #ifndef OS_CODE
   183| #  define OS_CODE  3     /* assume Unix */
   184| #endif
   185| #ifndef F_OPEN
   186| #  define F_OPEN(name, mode) fopen((name), (mode))
   187| #endif
   188|          /* functions */
   189| #if defined(pyr) || defined(Z_SOLO)
   190| #  define NO_MEMCPY
   191| #endif
   192| #if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
   193|  /* Use our own functions for small and medium model with MSC <= 5.0.
   194|   * You may have to use the same strategy for Borland C (untested).
   195|   * The __SC__ check is for Symantec.
   196|   */
   197| #  define NO_MEMCPY
   198| #endif
   199| #if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
   200| #  define HAVE_MEMCPY
   201| #endif
   202| #ifdef HAVE_MEMCPY
   203| #  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
   204| #    define zmemcpy _fmemcpy
   205| #    define zmemcmp _fmemcmp
   206| #    define zmemzero(dest, len) _fmemset(dest, 0, len)
   207| #  elif HAVE_INTEL_MEMCPY
   208| #    include "rte_memcpy.h"
   209| #    define zmemcpy rte_memcpy
   210| #    define zmemcmp memcmp
   211| #    define zmemzero(dest, len) memset(dest, 0, len)
   212| #  else
   213| #    define zmemcpy memcpy
   214| #    define zmemcmp memcmp
   215| #    define zmemzero(dest, len) memset(dest, 0, len)
   216| #  endif
   217| #else
   218|    void ZLIB_INTERNAL zmemcpy OF((Bytef* dest, const Bytef* source, uInt len));
   219|    int ZLIB_INTERNAL zmemcmp OF((const Bytef* s1, const Bytef* s2, uInt len));
   220|    void ZLIB_INTERNAL zmemzero OF((Bytef* dest, uInt len));
   221| #endif
   222| /* Diagnostic functions */
   223| #ifdef ZLIB_DEBUG
   224| #  include <stdio.h>
   225|    extern int ZLIB_INTERNAL z_verbose;
   226|    extern void ZLIB_INTERNAL z_error OF((char *m));
   227| #  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
   228| #  define Trace(x) {if (z_verbose>=0) fprintf x ;}
   229| #  define Tracev(x) {if (z_verbose>0) fprintf x ;}
   230| #  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
   231| #  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
   232| #  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
   233| #else
   234| #  define Assert(cond,msg)
   235| #  define Trace(x)
   236| #  define Tracev(x)
   237| #  define Tracevv(x)
   238| #  define Tracec(c,x)
   239| #  define Tracecv(c,x)
   240| #endif
   241| #ifndef Z_SOLO
   242|    voidpf ZLIB_INTERNAL zcalloc OF((voidpf opaque, unsigned items,
   243|                                     unsigned size));
   244|    void ZLIB_INTERNAL zcfree  OF((voidpf opaque, voidpf ptr));
   245| #endif
   246| #define ZALLOC(strm, items, size) \
   247|            (*((strm)->zalloc))((strm)->opaque, (items), (size))
   248| #define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
   249| #define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
   250| /* Reverse the bytes in a 32-bit value */
   251| #define ZSWAP32(q) ((((q) >> 24) & 0xff) + (((q) >> 8) & 0xff00) + \
   252|                     (((q) & 0xff00) << 8) + (((q) & 0xff) << 24))
   253| #endif /* ZUTIL_H */


# ====================================================================
# FILE: src/native/external/zlib/compress.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| /* compress.c -- compress a memory buffer
     2|  * Copyright (C) 1995-2005, 2014, 2016 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #define ZLIB_INTERNAL
     7| #include "zlib.h"
     8| /* ===========================================================================
     9|      Compresses the source buffer into the destination buffer. The level
    10|    parameter has the same meaning as in deflateInit.  sourceLen is the byte
    11|    length of the source buffer. Upon entry, destLen is the total size of the
    12|    destination buffer, which must be at least 0.1% larger than sourceLen plus
    13|    12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
    14|      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
    15|    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
    16|    Z_STREAM_ERROR if the level parameter is invalid.
    17| */
    18| int ZEXPORT compress2(dest, destLen, source, sourceLen, level)
    19|     Bytef *dest;
    20|     uLongf *destLen;
    21|     const Bytef *source;
    22|     uLong sourceLen;
    23|     int level;
    24| {
    25|     z_stream stream;
    26|     int err;
    27|     const uInt max = (uInt)-1;
    28|     uLong left;
    29|     left = *destLen;
    30|     *destLen = 0;
    31|     stream.zalloc = (alloc_func)0;
    32|     stream.zfree = (free_func)0;
    33|     stream.opaque = (voidpf)0;
    34|     err = deflateInit(&stream, level);
    35|     if (err != Z_OK) return err;
    36|     stream.next_out = dest;
    37|     stream.avail_out = 0;
    38|     stream.next_in = (z_const Bytef *)source;
    39|     stream.avail_in = 0;
    40|     do {
    41|         if (stream.avail_out == 0) {
    42|             stream.avail_out = left > (uLong)max ? max : (uInt)left;
    43|             left -= stream.avail_out;
    44|         }
    45|         if (stream.avail_in == 0) {
    46|             stream.avail_in = sourceLen > (uLong)max ? max : (uInt)sourceLen;
    47|             sourceLen -= stream.avail_in;
    48|         }
    49|         err = deflate(&stream, sourceLen ? Z_NO_FLUSH : Z_FINISH);
    50|     } while (err == Z_OK);
    51|     *destLen = stream.total_out;
    52|     deflateEnd(&stream);
    53|     return err == Z_STREAM_END ? Z_OK : err;
    54| }
    55| /* ===========================================================================
    56|  */
    57| int ZEXPORT compress(dest, destLen, source, sourceLen)
    58|     Bytef *dest;
    59|     uLongf *destLen;
    60|     const Bytef *source;
    61|     uLong sourceLen;
    62| {
    63|     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
    64| }
    65| /* ===========================================================================
    66|      If the default memLevel or windowBits for deflateInit() is changed, then
    67|    this function needs to be updated.
    68|  */
    69| uLong ZEXPORT compressBound(sourceLen)
    70|     uLong sourceLen;
    71| {
    72|     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
    73|            (sourceLen >> 25) + 13;
    74| }


# ====================================================================
# FILE: src/native/external/zlib/crc32.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1011 ---
     1| /* crc32.c -- compute the CRC-32 of a data stream
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  *
     5|  * This interleaved implementation of a CRC makes use of pipelined multiple
     6|  * arithmetic-logic units, commonly found in modern CPU cores. It is due to
     7|  * Kadatch and Jenkins (2010). See doc/crc-doc.1.0.pdf in this distribution.
     8|  */
     9| /* @(#) $Id$ */
    10| /*
    11|   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
    12|   protection on the static variables used to control the first-use generation
    13|   of the crc tables. Therefore, if you #define DYNAMIC_CRC_TABLE, you should
    14|   first call get_crc_table() to initialize the tables before allowing more than
    15|   one thread to use crc32().
    16|   MAKECRCH can be #defined to write out crc32.h. A main() routine is also
    17|   produced, so that this one source file can be compiled to an executable.
    18|  */
    19| #ifdef MAKECRCH
    20| #  include <stdio.h>
    21| #  ifndef DYNAMIC_CRC_TABLE
    22| #    define DYNAMIC_CRC_TABLE
    23| #  endif /* !DYNAMIC_CRC_TABLE */
    24| #endif /* MAKECRCH */
    25| #include "zutil.h"      /* for Z_U4, Z_U8, z_crc_t, and FAR definitions */
    26|  /*
    27|   A CRC of a message is computed on N braids of words in the message, where
    28|   each word consists of W bytes (4 or 8). If N is 3, for example, then three
    29|   running sparse CRCs are calculated respectively on each braid, at these
    30|   indices in the array of words: 0, 3, 6, ..., 1, 4, 7, ..., and 2, 5, 8, ...
    31|   This is done starting at a word boundary, and continues until as many blocks
    32|   of N * W bytes as are available have been processed. The results are combined
    33|   into a single CRC at the end. For this code, N must be in the range 1..6 and
    34|   W must be 4 or 8. The upper limit on N can be increased if desired by adding
    35|   more #if blocks, extending the patterns apparent in the code. In addition,
    36|   crc32.h would need to be regenerated, if the maximum N value is increased.
    37|   N and W are chosen empirically by benchmarking the execution time on a given
    38|   processor. The choices for N and W below were based on testing on Intel Kaby
    39|   Lake i7, AMD Ryzen 7, ARM Cortex-A57, Sparc64-VII, PowerPC POWER9, and MIPS64
    40|   Octeon II processors. The Intel, AMD, and ARM processors were all fastest
    41|   with N=5, W=8. The Sparc, PowerPC, and MIPS64 were all fastest at N=5, W=4.
    42|   They were all tested with either gcc or clang, all using the -O3 optimization
    43|   level. Your mileage may vary.
    44|  */
    45| /* Define N */
    46| #ifdef Z_TESTN
    47| #  define N Z_TESTN
    48| #else
    49| #  define N 5
    50| #endif
    51| #if N < 1 || N > 6
    52| #  error N must be in 1..6
    53| #endif
    54| /*
    55|   z_crc_t must be at least 32 bits. z_word_t must be at least as long as
    56|   z_crc_t. It is assumed here that z_word_t is either 32 bits or 64 bits, and
    57|   that bytes are eight bits.
    58|  */
    59| /*
    60|   Define W and the associated z_word_t type. If W is not defined, then a
    61|   braided calculation is not used, and the associated tables and code are not
    62|   compiled.
    63|  */
    64| #ifdef Z_TESTW
    65| #  if Z_TESTW-1 != -1
    66| #    define W Z_TESTW
    67| #  endif
    68| #else
    69| #  ifdef MAKECRCH
    70| #    define W 8         /* required for MAKECRCH */
    71| #  else
    72| #    if defined(__x86_64__) || defined(__aarch64__)
    73| #      define W 8
    74| #    else
    75| #      define W 4
    76| #    endif
    77| #  endif
    78| #endif
    79| #ifdef W
    80| #  if W == 8 && defined(Z_U8)
    81|      typedef Z_U8 z_word_t;
    82| #  elif defined(Z_U4)
    83| #    undef W
    84| #    define W 4
    85|      typedef Z_U4 z_word_t;
    86| #  else
    87| #    undef W
    88| #  endif
    89| #endif
    90| /* If available, use the ARM processor CRC32 instruction. */
    91| #if defined(__aarch64__) && defined(__ARM_FEATURE_CRC32) && W == 8
    92| #  define ARMCRC32
    93| #endif
    94| /* Local functions. */
    95| local z_crc_t multmodp OF((z_crc_t a, z_crc_t b));
    96| local z_crc_t x2nmodp OF((z_off64_t n, unsigned k));
    97| #if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
    98|     local z_word_t byte_swap OF((z_word_t word));
    99| #endif
   100| #if defined(W) && !defined(ARMCRC32)
   101|     local z_crc_t crc_word OF((z_word_t data));
   102|     local z_word_t crc_word_big OF((z_word_t data));
   103| #endif
   104| #if defined(W) && (!defined(ARMCRC32) || defined(DYNAMIC_CRC_TABLE))
   105| /*
   106|   Swap the bytes in a z_word_t to convert between little and big endian. Any
   107|   self-respecting compiler will optimize this to a single machine byte-swap
   108|   instruction, if one is available. This assumes that word_t is either 32 bits
   109|   or 64 bits.
   110|  */
   111| local z_word_t byte_swap(word)
   112|     z_word_t word;
   113| {
   114| #  if W == 8
   115|     return
   116|         (word & 0xff00000000000000) >> 56 |
   117|         (word & 0xff000000000000) >> 40 |
   118|         (word & 0xff0000000000) >> 24 |
   119|         (word & 0xff00000000) >> 8 |
   120|         (word & 0xff000000) << 8 |
   121|         (word & 0xff0000) << 24 |
   122|         (word & 0xff00) << 40 |
   123|         (word & 0xff) << 56;
   124| #  else   /* W == 4 */
   125|     return
   126|         (word & 0xff000000) >> 24 |
   127|         (word & 0xff0000) >> 8 |
   128|         (word & 0xff00) << 8 |
   129|         (word & 0xff) << 24;
   130| #  endif
   131| }
   132| #endif
   133| /* CRC polynomial. */
   134| #define POLY 0xedb88320         /* p(x) reflected, with x^32 implied */
   135| #ifdef DYNAMIC_CRC_TABLE
   136| local z_crc_t FAR crc_table[256];
   137| local z_crc_t FAR x2n_table[32];
   138| local void make_crc_table OF((void));
   139| #ifdef W
   140|    local z_word_t FAR crc_big_table[256];
   141|    local z_crc_t FAR crc_braid_table[W][256];
   142|    local z_word_t FAR crc_braid_big_table[W][256];
   143|    local void braid OF((z_crc_t [][256], z_word_t [][256], int, int));
   144| #endif
   145| #ifdef MAKECRCH
   146|    local void write_table OF((FILE *, const z_crc_t FAR *, int));
   147|    local void write_table32hi OF((FILE *, const z_word_t FAR *, int));
   148|    local void write_table64 OF((FILE *, const z_word_t FAR *, int));
   149| #endif /* MAKECRCH */
   150| /*
   151|   Define a once() function depending on the availability of atomics. If this is
   152|   compiled with DYNAMIC_CRC_TABLE defined, and if CRCs will be computed in
   153|   multiple threads, and if atomics are not available, then get_crc_table() must
   154|   be called to initialize the tables and must return before any threads are
   155|   allowed to compute or combine CRCs.
   156|  */
   157| /* Definition of once functionality. */
   158| typedef struct once_s once_t;
   159| local void once OF((once_t *, void (*)(void)));
   160| /* Check for the availability of atomics. */
   161| #if defined(__STDC__) && __STDC_VERSION__ >= 201112L && \
   162|     !defined(__STDC_NO_ATOMICS__)
   163| #include <stdatomic.h>
   164| /* Structure for once(), which must be initialized with ONCE_INIT. */
   165| struct once_s {
   166|     atomic_flag begun;
   167|     atomic_int done;
   168| };
   169| #define ONCE_INIT {ATOMIC_FLAG_INIT, 0}
   170| /*
   171|   Run the provided init() function exactly once, even if multiple threads
   172|   invoke once() at the same time. The state must be a once_t initialized with
   173|   ONCE_INIT.
   174|  */
   175| local void once(state, init)
   176|     once_t *state;
   177|     void (*init)(void);
   178| {
   179|     if (!atomic_load(&state->done)) {
   180|         if (atomic_flag_test_and_set(&state->begun))
   181|             while (!atomic_load(&state->done))
   182|                 ;
   183|         else {
   184|             init();
   185|             atomic_store(&state->done, 1);
   186|         }
   187|     }
   188| }
   189| #else   /* no atomics */
   190| /* Structure for once(), which must be initialized with ONCE_INIT. */
   191| struct once_s {
   192|     volatile int begun;
   193|     volatile int done;
   194| };
   195| #define ONCE_INIT {0, 0}
   196| /* Test and set. Alas, not atomic, but tries to minimize the period of
   197|    vulnerability. */
   198| local int test_and_set OF((int volatile *));
   199| local int test_and_set(flag)
   200|     int volatile *flag;
   201| {
   202|     int was;
   203|     was = *flag;
   204|     *flag = 1;
   205|     return was;
   206| }
   207| /* Run the provided init() function once. This is not thread-safe. */
   208| local void once(state, init)
   209|     once_t *state;
   210|     void (*init)(void);
   211| {
   212|     if (!state->done) {
   213|         if (test_and_set(&state->begun))
   214|             while (!state->done)
   215|                 ;
   216|         else {
   217|             init();
   218|             state->done = 1;
   219|         }
   220|     }
   221| }
   222| #endif
   223| /* State for once(). */
   224| local once_t made = ONCE_INIT;
   225| /*
   226|   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
   227|   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
   228|   Polynomials over GF(2) are represented in binary, one bit per coefficient,
   229|   with the lowest powers in the most significant bit. Then adding polynomials
   230|   is just exclusive-or, and multiplying a polynomial by x is a right shift by
   231|   one. If we call the above polynomial p, and represent a byte as the
   232|   polynomial q, also with the lowest power in the most significant bit (so the
   233|   byte 0xb1 is the polynomial x^7+x^3+x^2+1), then the CRC is (q*x^32) mod p,
   234|   where a mod b means the remainder after dividing a by b.
   235|   This calculation is done using the shift-register method of multiplying and
   236|   taking the remainder. The register is initialized to zero, and for each
   237|   incoming bit, x^32 is added mod p to the register if the bit is a one (where
   238|   x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by x
   239|   (which is shifting right by one and adding x^32 mod p if the bit shifted out
   240|   is a one). We start with the highest power (least significant bit) of q and
   241|   repeat for all eight bits of q.
   242|   The table is simply the CRC of all possible eight bit values. This is all the
   243|   information needed to generate CRCs on data a byte at a time for all
   244|   combinations of CRC register values and incoming bytes.
   245|  */
   246| local void make_crc_table()
   247| {
   248|     unsigned i, j, n;
   249|     z_crc_t p;
   250|     /* initialize the CRC of bytes tables */
   251|     for (i = 0; i < 256; i++) {
   252|         p = i;
   253|         for (j = 0; j < 8; j++)
   254|             p = p & 1 ? (p >> 1) ^ POLY : p >> 1;
   255|         crc_table[i] = p;
   256| #ifdef W
   257|         crc_big_table[i] = byte_swap(p);
   258| #endif
   259|     }
   260|     /* initialize the x^2^n mod p(x) table */
   261|     p = (z_crc_t)1 << 30;         /* x^1 */
   262|     x2n_table[0] = p;
   263|     for (n = 1; n < 32; n++)
   264|         x2n_table[n] = p = multmodp(p, p);
   265| #ifdef W
   266|     /* initialize the braiding tables -- needs x2n_table[] */
   267|     braid(crc_braid_table, crc_braid_big_table, N, W);
   268| #endif
   269| #ifdef MAKECRCH
   270|     {
   271|         /*
   272|           The crc32.h header file contains tables for both 32-bit and 64-bit
   273|           z_word_t's, and so requires a 64-bit type be available. In that case,
   274|           z_word_t must be defined to be 64-bits. This code then also generates
   275|           and writes out the tables for the case that z_word_t is 32 bits.
   276|          */
   277| #if !defined(W) || W != 8
   278| #  error Need a 64-bit integer type in order to generate crc32.h.
   279| #endif
   280|         FILE *out;
   281|         int k, n;
   282|         z_crc_t ltl[8][256];
   283|         z_word_t big[8][256];
   284|         out = fopen("crc32.h", "w");
   285|         if (out == NULL) return;
   286|         /* write out little-endian CRC table to crc32.h */
   287|         fprintf(out,
   288|             "/* crc32.h -- tables for rapid CRC calculation\n"
   289|             " * Generated automatically by crc32.c\n */\n"
   290|             "\n"
   291|             "local const z_crc_t FAR crc_table[] = {\n"
   292|             "    ");
   293|         write_table(out, crc_table, 256);
   294|         fprintf(out,
   295|             "};\n");
   296|         /* write out big-endian CRC table for 64-bit z_word_t to crc32.h */
   297|         fprintf(out,
   298|             "\n"
   299|             "#ifdef W\n"
   300|             "\n"
   301|             "#if W == 8\n"
   302|             "\n"
   303|             "local const z_word_t FAR crc_big_table[] = {\n"
   304|             "    ");
   305|         write_table64(out, crc_big_table, 256);
   306|         fprintf(out,
   307|             "};\n");
   308|         /* write out big-endian CRC table for 32-bit z_word_t to crc32.h */
   309|         fprintf(out,
   310|             "\n"
   311|             "#else /* W == 4 */\n"
   312|             "\n"
   313|             "local const z_word_t FAR crc_big_table[] = {\n"
   314|             "    ");
   315|         write_table32hi(out, crc_big_table, 256);
   316|         fprintf(out,
   317|             "};\n"
   318|             "\n"
   319|             "#endif\n");
   320|         /* write out braid tables for each value of N */
   321|         for (n = 1; n <= 6; n++) {
   322|             fprintf(out,
   323|             "\n"
   324|             "#if N == %d\n", n);
   325|             /* compute braid tables for this N and 64-bit word_t */
   326|             braid(ltl, big, n, 8);
   327|             /* write out braid tables for 64-bit z_word_t to crc32.h */
   328|             fprintf(out,
   329|             "\n"
   330|             "#if W == 8\n"
   331|             "\n"
   332|             "local const z_crc_t FAR crc_braid_table[][256] = {\n");
   333|             for (k = 0; k < 8; k++) {
   334|                 fprintf(out, "   {");
   335|                 write_table(out, ltl[k], 256);
   336|                 fprintf(out, "}%s", k < 7 ? ",\n" : "");
   337|             }
   338|             fprintf(out,
   339|             "};\n"
   340|             "\n"
   341|             "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
   342|             for (k = 0; k < 8; k++) {
   343|                 fprintf(out, "   {");
   344|                 write_table64(out, big[k], 256);
   345|                 fprintf(out, "}%s", k < 7 ? ",\n" : "");
   346|             }
   347|             fprintf(out,
   348|             "};\n");
   349|             /* compute braid tables for this N and 32-bit word_t */
   350|             braid(ltl, big, n, 4);
   351|             /* write out braid tables for 32-bit z_word_t to crc32.h */
   352|             fprintf(out,
   353|             "\n"
   354|             "#else /* W == 4 */\n"
   355|             "\n"
   356|             "local const z_crc_t FAR crc_braid_table[][256] = {\n");
   357|             for (k = 0; k < 4; k++) {
   358|                 fprintf(out, "   {");
   359|                 write_table(out, ltl[k], 256);
   360|                 fprintf(out, "}%s", k < 3 ? ",\n" : "");
   361|             }
   362|             fprintf(out,
   363|             "};\n"
   364|             "\n"
   365|             "local const z_word_t FAR crc_braid_big_table[][256] = {\n");
   366|             for (k = 0; k < 4; k++) {
   367|                 fprintf(out, "   {");
   368|                 write_table32hi(out, big[k], 256);
   369|                 fprintf(out, "}%s", k < 3 ? ",\n" : "");
   370|             }
   371|             fprintf(out,
   372|             "};\n"
   373|             "\n"
   374|             "#endif\n"
   375|             "\n"
   376|             "#endif\n");
   377|         }
   378|         fprintf(out,
   379|             "\n"
   380|             "#endif\n");
   381|         /* write out zeros operator table to crc32.h */
   382|         fprintf(out,
   383|             "\n"
   384|             "local const z_crc_t FAR x2n_table[] = {\n"
   385|             "    ");
   386|         write_table(out, x2n_table, 32);
   387|         fprintf(out,
   388|             "};\n");
   389|         fclose(out);
   390|     }
   391| #endif /* MAKECRCH */
   392| }
   393| #ifdef MAKECRCH
   394| /*
   395|    Write the 32-bit values in table[0..k-1] to out, five per line in
   396|    hexadecimal separated by commas.
   397|  */
   398| local void write_table(out, table, k)
   399|     FILE *out;
   400|     const z_crc_t FAR *table;
   401|     int k;
   402| {
   403|     int n;
   404|     for (n = 0; n < k; n++)
   405|         fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
   406|                 (unsigned long)(table[n]),
   407|                 n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
   408| }
   409| /*
   410|    Write the high 32-bits of each value in table[0..k-1] to out, five per line
   411|    in hexadecimal separated by commas.
   412|  */
   413| local void write_table32hi(out, table, k)
   414| FILE *out;
   415| const z_word_t FAR *table;
   416| int k;
   417| {
   418|     int n;
   419|     for (n = 0; n < k; n++)
   420|         fprintf(out, "%s0x%08lx%s", n == 0 || n % 5 ? "" : "    ",
   421|                 (unsigned long)(table[n] >> 32),
   422|                 n == k - 1 ? "" : (n % 5 == 4 ? ",\n" : ", "));
   423| }
   424| /*
   425|   Write the 64-bit values in table[0..k-1] to out, three per line in
   426|   hexadecimal separated by commas. This assumes that if there is a 64-bit
   427|   type, then there is also a long long integer type, and it is at least 64
   428|   bits. If not, then the type cast and format string can be adjusted
   429|   accordingly.
   430|  */
   431| local void write_table64(out, table, k)
   432|     FILE *out;
   433|     const z_word_t FAR *table;
   434|     int k;
   435| {
   436|     int n;
   437|     for (n = 0; n < k; n++)
   438|         fprintf(out, "%s0x%016llx%s", n == 0 || n % 3 ? "" : "    ",
   439|                 (unsigned long long)(table[n]),
   440|                 n == k - 1 ? "" : (n % 3 == 2 ? ",\n" : ", "));
   441| }
   442| /* Actually do the deed. */
   443| int main()
   444| {
   445|     make_crc_table();
   446|     return 0;
   447| }
   448| #endif /* MAKECRCH */
   449| #ifdef W
   450| /*
   451|   Generate the little and big-endian braid tables for the given n and z_word_t
   452|   size w. Each array must have room for w blocks of 256 elements.
   453|  */
   454| local void braid(ltl, big, n, w)
   455|     z_crc_t ltl[][256];
   456|     z_word_t big[][256];
   457|     int n;
   458|     int w;
   459| {
   460|     int k;
   461|     z_crc_t i, p, q;
   462|     for (k = 0; k < w; k++) {
   463|         p = x2nmodp((n * w + 3 - k) << 3, 0);
   464|         ltl[k][0] = 0;
   465|         big[w - 1 - k][0] = 0;
   466|         for (i = 1; i < 256; i++) {
   467|             ltl[k][i] = q = multmodp(i << 24, p);
   468|             big[w - 1 - k][i] = byte_swap(q);
   469|         }
   470|     }
   471| }
   472| #endif
   473| #else /* !DYNAMIC_CRC_TABLE */
   474| /* ========================================================================
   475|  * Tables for byte-wise and braided CRC-32 calculations, and a table of powers
   476|  * of x for combining CRC-32s, all made by make_crc_table().
   477|  */
   478| #include "crc32.h"
   479| #endif /* DYNAMIC_CRC_TABLE */
   480| /* ========================================================================
   481|  * Routines used for CRC calculation. Some are also required for the table
   482|  * generation above.
   483|  */
   484| /*
   485|   Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC polynomial,
   486|   reflected. For speed, this requires that a not be zero.
   487|  */
   488| local z_crc_t multmodp(a, b)
   489|     z_crc_t a;
   490|     z_crc_t b;
   491| {
   492|     z_crc_t m, p;
   493|     m = (z_crc_t)1 << 31;
   494|     p = 0;
   495|     for (;;) {
   496|         if (a & m) {
   497|             p ^= b;
   498|             if ((a & (m - 1)) == 0)
   499|                 break;
   500|         }
   501|         m >>= 1;
   502|         b = b & 1 ? (b >> 1) ^ POLY : b >> 1;
   503|     }
   504|     return p;
   505| }
   506| /*
   507|   Return x^(n * 2^k) modulo p(x). Requires that x2n_table[] has been
   508|   initialized.
   509|  */
   510| local z_crc_t x2nmodp(n, k)
   511|     z_off64_t n;
   512|     unsigned k;
   513| {
   514|     z_crc_t p;
   515|     p = (z_crc_t)1 << 31;           /* x^0 == 1 */
   516|     while (n) {
   517|         if (n & 1)
   518|             p = multmodp(x2n_table[k & 31], p);
   519|         n >>= 1;
   520|         k++;
   521|     }
   522|     return p;
   523| }
   524| /* =========================================================================
   525|  * This function can be used by asm versions of crc32(), and to force the
   526|  * generation of the CRC tables in a threaded application.
   527|  */
   528| const z_crc_t FAR * ZEXPORT get_crc_table()
   529| {
   530| #ifdef DYNAMIC_CRC_TABLE
   531|     once(&made, make_crc_table);
   532| #endif /* DYNAMIC_CRC_TABLE */
   533|     return (const z_crc_t FAR *)crc_table;
   534| }
   535| /* =========================================================================
   536|  * Use ARM machine instructions if available. This will compute the CRC about
   537|  * ten times faster than the braided calculation. This code does not check for
   538|  * the presence of the CRC instruction at run time. __ARM_FEATURE_CRC32 will
   539|  * only be defined if the compilation specifies an ARM processor architecture
   540|  * that has the instructions. For example, compiling with -march=armv8.1-a or
   541|  * -march=armv8-a+crc, or -march=native if the compile machine has the crc32
   542|  * instructions.
   543|  */
   544| #ifdef ARMCRC32
   545| /*
   546|    Constants empirically determined to maximize speed. These values are from
   547|    measurements on a Cortex-A57. Your mileage may vary.
   548|  */
   549| #define Z_BATCH 3990                /* number of words in a batch */
   550| #define Z_BATCH_ZEROS 0xa10d3d0c    /* computed from Z_BATCH = 3990 */
   551| #define Z_BATCH_MIN 800             /* fewest words in a final batch */
   552| unsigned long ZEXPORT crc32_z(crc, buf, len)
   553|     unsigned long crc;
   554|     const unsigned char FAR *buf;
   555|     z_size_t len;
   556| {
   557|     z_crc_t val;
   558|     z_word_t crc1, crc2;
   559|     const z_word_t *word;
   560|     z_word_t val0, val1, val2;
   561|     z_size_t last, last2, i;
   562|     z_size_t num;
   563|     /* Return initial CRC, if requested. */
   564|     if (buf == Z_NULL) return 0;
   565| #ifdef DYNAMIC_CRC_TABLE
   566|     once(&made, make_crc_table);
   567| #endif /* DYNAMIC_CRC_TABLE */
   568|     /* Pre-condition the CRC */
   569|     crc = (~crc) & 0xffffffff;
   570|     /* Compute the CRC up to a word boundary. */
   571|     while (len && ((z_size_t)buf & 7) != 0) {
   572|         len--;
   573|         val = *buf++;
   574|         __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
   575|     }
   576|     /* Prepare to compute the CRC on full 64-bit words word[0..num-1]. */
   577|     word = (z_word_t const *)buf;
   578|     num = len >> 3;
   579|     len &= 7;
   580|     /* Do three interleaved CRCs to realize the throughput of one crc32x
   581|        instruction per cycle. Each CRC is calculated on Z_BATCH words. The
   582|        three CRCs are combined into a single CRC after each set of batches. */
   583|     while (num >= 3 * Z_BATCH) {
   584|         crc1 = 0;
   585|         crc2 = 0;
   586|         for (i = 0; i < Z_BATCH; i++) {
   587|             val0 = word[i];
   588|             val1 = word[i + Z_BATCH];
   589|             val2 = word[i + 2 * Z_BATCH];
   590|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   591|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
   592|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
   593|         }
   594|         word += 3 * Z_BATCH;
   595|         num -= 3 * Z_BATCH;
   596|         crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc1;
   597|         crc = multmodp(Z_BATCH_ZEROS, crc) ^ crc2;
   598|     }
   599|     /* Do one last smaller batch with the remaining words, if there are enough
   600|        to pay for the combination of CRCs. */
   601|     last = num / 3;
   602|     if (last >= Z_BATCH_MIN) {
   603|         last2 = last << 1;
   604|         crc1 = 0;
   605|         crc2 = 0;
   606|         for (i = 0; i < last; i++) {
   607|             val0 = word[i];
   608|             val1 = word[i + last];
   609|             val2 = word[i + last2];
   610|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   611|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc1) : "r"(val1));
   612|             __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc2) : "r"(val2));
   613|         }
   614|         word += 3 * last;
   615|         num -= 3 * last;
   616|         val = x2nmodp(last, 6);
   617|         crc = multmodp(val, crc) ^ crc1;
   618|         crc = multmodp(val, crc) ^ crc2;
   619|     }
   620|     /* Compute the CRC on any remaining words. */
   621|     for (i = 0; i < num; i++) {
   622|         val0 = word[i];
   623|         __asm__ volatile("crc32x %w0, %w0, %x1" : "+r"(crc) : "r"(val0));
   624|     }
   625|     word += num;
   626|     /* Complete the CRC on any remaining bytes. */
   627|     buf = (const unsigned char FAR *)word;
   628|     while (len) {
   629|         len--;
   630|         val = *buf++;
   631|         __asm__ volatile("crc32b %w0, %w0, %w1" : "+r"(crc) : "r"(val));
   632|     }
   633|     /* Return the CRC, post-conditioned. */
   634|     return crc ^ 0xffffffff;
   635| }
   636| #else
   637| #ifdef W
   638| /*
   639|   Return the CRC of the W bytes in the word_t data, taking the
   640|   least-significant byte of the word as the first byte of data, without any pre
   641|   or post conditioning. This is used to combine the CRCs of each braid.
   642|  */
   643| local z_crc_t crc_word(data)
   644|     z_word_t data;
   645| {
   646|     int k;
   647|     for (k = 0; k < W; k++)
   648|         data = (data >> 8) ^ crc_table[data & 0xff];
   649|     return (z_crc_t)data;
   650| }
   651| local z_word_t crc_word_big(data)
   652|     z_word_t data;
   653| {
   654|     int k;
   655|     for (k = 0; k < W; k++)
   656|         data = (data << 8) ^
   657|             crc_big_table[(data >> ((W - 1) << 3)) & 0xff];
   658|     return data;
   659| }
   660| #endif
   661| /* ========================================================================= */
   662| unsigned long ZEXPORT crc32_z(crc, buf, len)
   663|     unsigned long crc;
   664|     const unsigned char FAR *buf;
   665|     z_size_t len;
   666| {
   667|     /* Return initial CRC, if requested. */
   668|     if (buf == Z_NULL) return 0;
   669| #ifdef DYNAMIC_CRC_TABLE
   670|     once(&made, make_crc_table);
   671| #endif /* DYNAMIC_CRC_TABLE */
   672|     /* Pre-condition the CRC */
   673|     crc = (~crc) & 0xffffffff;
   674| #ifdef W
   675|     /* If provided enough bytes, do a braided CRC calculation. */
   676|     if (len >= N * W + W - 1) {
   677|         z_size_t blks;
   678|         z_word_t const *words;
   679|         unsigned endian;
   680|         int k;
   681|         /* Compute the CRC up to a z_word_t boundary. */
   682|         while (len && ((z_size_t)buf & (W - 1)) != 0) {
   683|             len--;
   684|             crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   685|         }
   686|         /* Compute the CRC on as many N z_word_t blocks as are available. */
   687|         blks = len / (N * W);
   688|         len -= blks * N * W;
   689|         words = (z_word_t const *)buf;
   690|         /* Do endian check at execution time instead of compile time, since ARM
   691|            processors can change the endianess at execution time. If the
   692|            compiler knows what the endianess will be, it can optimize out the
   693|            check and the unused branch. */
   694|         endian = 1;
   695|         if (*(unsigned char *)&endian) {
   696|             /* Little endian. */
   697|             z_crc_t crc0;
   698|             z_word_t word0;
   699| #if N > 1
   700|             z_crc_t crc1;
   701|             z_word_t word1;
   702| #if N > 2
   703|             z_crc_t crc2;
   704|             z_word_t word2;
   705| #if N > 3
   706|             z_crc_t crc3;
   707|             z_word_t word3;
   708| #if N > 4
   709|             z_crc_t crc4;
   710|             z_word_t word4;
   711| #if N > 5
   712|             z_crc_t crc5;
   713|             z_word_t word5;
   714| #endif
   715| #endif
   716| #endif
   717| #endif
   718| #endif
   719|             /* Initialize the CRC for each braid. */
   720|             crc0 = crc;
   721| #if N > 1
   722|             crc1 = 0;
   723| #if N > 2
   724|             crc2 = 0;
   725| #if N > 3
   726|             crc3 = 0;
   727| #if N > 4
   728|             crc4 = 0;
   729| #if N > 5
   730|             crc5 = 0;
   731| #endif
   732| #endif
   733| #endif
   734| #endif
   735| #endif
   736|             /*
   737|               Process the first blks-1 blocks, computing the CRCs on each braid
   738|               independently.
   739|              */
   740|             while (--blks) {
   741|                 /* Load the word for each braid into registers. */
   742|                 word0 = crc0 ^ words[0];
   743| #if N > 1
   744|                 word1 = crc1 ^ words[1];
   745| #if N > 2
   746|                 word2 = crc2 ^ words[2];
   747| #if N > 3
   748|                 word3 = crc3 ^ words[3];
   749| #if N > 4
   750|                 word4 = crc4 ^ words[4];
   751| #if N > 5
   752|                 word5 = crc5 ^ words[5];
   753| #endif
   754| #endif
   755| #endif
   756| #endif
   757| #endif
   758|                 words += N;
   759|                 /* Compute and update the CRC for each word. The loop should
   760|                    get unrolled. */
   761|                 crc0 = crc_braid_table[0][word0 & 0xff];
   762| #if N > 1
   763|                 crc1 = crc_braid_table[0][word1 & 0xff];
   764| #if N > 2
   765|                 crc2 = crc_braid_table[0][word2 & 0xff];
   766| #if N > 3
   767|                 crc3 = crc_braid_table[0][word3 & 0xff];
   768| #if N > 4
   769|                 crc4 = crc_braid_table[0][word4 & 0xff];
   770| #if N > 5
   771|                 crc5 = crc_braid_table[0][word5 & 0xff];
   772| #endif
   773| #endif
   774| #endif
   775| #endif
   776| #endif
   777|                 for (k = 1; k < W; k++) {
   778|                     crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
   779| #if N > 1
   780|                     crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
   781| #if N > 2
   782|                     crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
   783| #if N > 3
   784|                     crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
   785| #if N > 4
   786|                     crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
   787| #if N > 5
   788|                     crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
   789| #endif
   790| #endif
   791| #endif
   792| #endif
   793| #endif
   794|                 }
   795|             }
   796|             /*
   797|               Process the last block, combining the CRCs of the N braids at the
   798|               same time.
   799|              */
   800|             crc = crc_word(crc0 ^ words[0]);
   801| #if N > 1
   802|             crc = crc_word(crc1 ^ words[1] ^ crc);
   803| #if N > 2
   804|             crc = crc_word(crc2 ^ words[2] ^ crc);
   805| #if N > 3
   806|             crc = crc_word(crc3 ^ words[3] ^ crc);
   807| #if N > 4
   808|             crc = crc_word(crc4 ^ words[4] ^ crc);
   809| #if N > 5
   810|             crc = crc_word(crc5 ^ words[5] ^ crc);
   811| #endif
   812| #endif
   813| #endif
   814| #endif
   815| #endif
   816|             words += N;
   817|         }
   818|         else {
   819|             /* Big endian. */
   820|             z_word_t crc0, word0, comb;
   821| #if N > 1
   822|             z_word_t crc1, word1;
   823| #if N > 2
   824|             z_word_t crc2, word2;
   825| #if N > 3
   826|             z_word_t crc3, word3;
   827| #if N > 4
   828|             z_word_t crc4, word4;
   829| #if N > 5
   830|             z_word_t crc5, word5;
   831| #endif
   832| #endif
   833| #endif
   834| #endif
   835| #endif
   836|             /* Initialize the CRC for each braid. */
   837|             crc0 = byte_swap(crc);
   838| #if N > 1
   839|             crc1 = 0;
   840| #if N > 2
   841|             crc2 = 0;
   842| #if N > 3
   843|             crc3 = 0;
   844| #if N > 4
   845|             crc4 = 0;
   846| #if N > 5
   847|             crc5 = 0;
   848| #endif
   849| #endif
   850| #endif
   851| #endif
   852| #endif
   853|             /*
   854|               Process the first blks-1 blocks, computing the CRCs on each braid
   855|               independently.
   856|              */
   857|             while (--blks) {
   858|                 /* Load the word for each braid into registers. */
   859|                 word0 = crc0 ^ words[0];
   860| #if N > 1
   861|                 word1 = crc1 ^ words[1];
   862| #if N > 2
   863|                 word2 = crc2 ^ words[2];
   864| #if N > 3
   865|                 word3 = crc3 ^ words[3];
   866| #if N > 4
   867|                 word4 = crc4 ^ words[4];
   868| #if N > 5
   869|                 word5 = crc5 ^ words[5];
   870| #endif
   871| #endif
   872| #endif
   873| #endif
   874| #endif
   875|                 words += N;
   876|                 /* Compute and update the CRC for each word. The loop should
   877|                    get unrolled. */
   878|                 crc0 = crc_braid_big_table[0][word0 & 0xff];
   879| #if N > 1
   880|                 crc1 = crc_braid_big_table[0][word1 & 0xff];
   881| #if N > 2
   882|                 crc2 = crc_braid_big_table[0][word2 & 0xff];
   883| #if N > 3
   884|                 crc3 = crc_braid_big_table[0][word3 & 0xff];
   885| #if N > 4
   886|                 crc4 = crc_braid_big_table[0][word4 & 0xff];
   887| #if N > 5
   888|                 crc5 = crc_braid_big_table[0][word5 & 0xff];
   889| #endif
   890| #endif
   891| #endif
   892| #endif
   893| #endif
   894|                 for (k = 1; k < W; k++) {
   895|                     crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
   896| #if N > 1
   897|                     crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
   898| #if N > 2
   899|                     crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
   900| #if N > 3
   901|                     crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
   902| #if N > 4
   903|                     crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
   904| #if N > 5
   905|                     crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
   906| #endif
   907| #endif
   908| #endif
   909| #endif
   910| #endif
   911|                 }
   912|             }
   913|             /*
   914|               Process the last block, combining the CRCs of the N braids at the
   915|               same time.
   916|              */
   917|             comb = crc_word_big(crc0 ^ words[0]);
   918| #if N > 1
   919|             comb = crc_word_big(crc1 ^ words[1] ^ comb);
   920| #if N > 2
   921|             comb = crc_word_big(crc2 ^ words[2] ^ comb);
   922| #if N > 3
   923|             comb = crc_word_big(crc3 ^ words[3] ^ comb);
   924| #if N > 4
   925|             comb = crc_word_big(crc4 ^ words[4] ^ comb);
   926| #if N > 5
   927|             comb = crc_word_big(crc5 ^ words[5] ^ comb);
   928| #endif
   929| #endif
   930| #endif
   931| #endif
   932| #endif
   933|             words += N;
   934|             crc = byte_swap(comb);
   935|         }
   936|         /*
   937|           Update the pointer to the remaining bytes to process.
   938|          */
   939|         buf = (unsigned char const *)words;
   940|     }
   941| #endif /* W */
   942|     /* Complete the computation of the CRC on any remaining bytes. */
   943|     while (len >= 8) {
   944|         len -= 8;
   945|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   946|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   947|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   948|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   949|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   950|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   951|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   952|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   953|     }
   954|     while (len) {
   955|         len--;
   956|         crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
   957|     }
   958|     /* Return the CRC, post-conditioned. */
   959|     return crc ^ 0xffffffff;
   960| }
   961| #endif
   962| /* ========================================================================= */
   963| unsigned long ZEXPORT crc32(crc, buf, len)
   964|     unsigned long crc;
   965|     const unsigned char FAR *buf;
   966|     uInt len;
   967| {
   968|     return crc32_z(crc, buf, len);
   969| }
   970| /* ========================================================================= */
   971| uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
   972|     uLong crc1;
   973|     uLong crc2;
   974|     z_off64_t len2;
   975| {
   976| #ifdef DYNAMIC_CRC_TABLE
   977|     once(&made, make_crc_table);
   978| #endif /* DYNAMIC_CRC_TABLE */
   979|     return multmodp(x2nmodp(len2, 3), crc1) ^ (crc2 & 0xffffffff);
   980| }
   981| /* ========================================================================= */
   982| uLong ZEXPORT crc32_combine(crc1, crc2, len2)
   983|     uLong crc1;
   984|     uLong crc2;
   985|     z_off_t len2;
   986| {
   987|     return crc32_combine64(crc1, crc2, (z_off64_t)len2);
   988| }
   989| /* ========================================================================= */
   990| uLong ZEXPORT crc32_combine_gen64(len2)
   991|     z_off64_t len2;
   992| {
   993| #ifdef DYNAMIC_CRC_TABLE
   994|     once(&made, make_crc_table);
   995| #endif /* DYNAMIC_CRC_TABLE */
   996|     return x2nmodp(len2, 3);
   997| }
   998| /* ========================================================================= */
   999| uLong ZEXPORT crc32_combine_gen(len2)
  1000|     z_off_t len2;
  1001| {
  1002|     return crc32_combine_gen64((z_off64_t)len2);
  1003| }
  1004| /* ========================================================================= */
  1005| uLong ZEXPORT crc32_combine_op(crc1, crc2, op)
  1006|     uLong crc1;
  1007|     uLong crc2;
  1008|     uLong op;
  1009| {
  1010|     return multmodp(op, crc1) ^ (crc2 & 0xffffffff);
  1011| }


# ====================================================================
# FILE: src/native/external/zlib/deflate.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1999 ---
     1| /* deflate.c -- compress data using the deflation algorithm
     2|  * Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /*
     6|  *  ALGORITHM
     7|  *
     8|  *      The "deflation" process depends on being able to identify portions
     9|  *      of the input text which are identical to earlier input (within a
    10|  *      sliding window trailing behind the input currently being processed).
    11|  *
    12|  *      The most straightforward technique turns out to be the fastest for
    13|  *      most input files: try all possible matches and select the longest.
    14|  *      The key feature of this algorithm is that insertions into the string
    15|  *      dictionary are very simple and thus fast, and deletions are avoided
    16|  *      completely. Insertions are performed at each input character, whereas
    17|  *      string matches are performed only when the previous match ends. So it
    18|  *      is preferable to spend more time in matches to allow very fast string
    19|  *      insertions and avoid deletions. The matching algorithm for small
    20|  *      strings is inspired from that of Rabin & Karp. A brute force approach
    21|  *      is used to find longer strings when a small match has been found.
    22|  *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
    23|  *      (by Leonid Broukhis).
    24|  *         A previous version of this file used a more sophisticated algorithm
    25|  *      (by Fiala and Greene) which is guaranteed to run in linear amortized
    26|  *      time, but has a larger average cost, uses more memory and is patented.
    27|  *      However the F&G algorithm may be faster for some highly redundant
    28|  *      files if the parameter max_chain_length (described below) is too large.
    29|  *
    30|  *  ACKNOWLEDGEMENTS
    31|  *
    32|  *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
    33|  *      I found it in 'freeze' written by Leonid Broukhis.
    34|  *      Thanks to many people for bug reports and testing.
    35|  *
    36|  *  REFERENCES
    37|  *
    38|  *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
    39|  *      Available in http://tools.ietf.org/html/rfc1951
    40|  *
    41|  *      A description of the Rabin and Karp algorithm is given in the book
    42|  *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
    43|  *
    44|  *      Fiala,E.R., and Greene,D.H.
    45|  *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
    46|  *
    47|  */
    48| /* @(#) $Id$ */
    49| #include "deflate.h"
    50| const char deflate_copyright[] =
    51|    " deflate 1.2.13 Copyright 1995-2022 Jean-loup Gailly and Mark Adler ";
    52| /*
    53|   If you use the zlib library in a product, an acknowledgment is welcome
    54|   in the documentation of your product. If for some reason you cannot
    55|   include such an acknowledgment, I would appreciate that you keep this
    56|   copyright string in the executable of your product.
    57|  */
    58| /* ===========================================================================
    59|  *  Function prototypes.
    60|  */
    61| typedef enum {
    62|     need_more,      /* block not completed, need more input or more output */
    63|     block_done,     /* block flush performed */
    64|     finish_started, /* finish started, need only more output at next deflate */
    65|     finish_done     /* finish done, accept no more input or output */
    66| } block_state;
    67| typedef block_state (*compress_func) OF((deflate_state *s, int flush));
    68| /* Compression function. Returns the block state after the call. */
    69| local int deflateStateCheck      OF((z_streamp strm));
    70| local void slide_hash     OF((deflate_state *s));
    71| local void fill_window    OF((deflate_state *s));
    72| local block_state deflate_stored OF((deflate_state *s, int flush));
    73| local block_state deflate_fast   OF((deflate_state *s, int flush));
    74| #ifndef FASTEST
    75| local block_state deflate_slow   OF((deflate_state *s, int flush));
    76| #endif
    77| local block_state deflate_rle    OF((deflate_state *s, int flush));
    78| local block_state deflate_huff   OF((deflate_state *s, int flush));
    79| local void lm_init        OF((deflate_state *s));
    80| local void putShortMSB    OF((deflate_state *s, uInt b));
    81| local void flush_pending  OF((z_streamp strm));
    82| local unsigned read_buf   OF((z_streamp strm, Bytef *buf, unsigned size));
    83| local uInt longest_match  OF((deflate_state *s, IPos cur_match));
    84| #ifdef ZLIB_DEBUG
    85| local  void check_match OF((deflate_state *s, IPos start, IPos match,
    86|                             int length));
    87| #endif
    88| /* ===========================================================================
    89|  * Local data
    90|  */
    91| #define NIL 0
    92| /* Tail of hash chains */
    93| #ifndef TOO_FAR
    94| #  define TOO_FAR 4096
    95| #endif
    96| /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
    97| /* Values for max_lazy_match, good_match and max_chain_length, depending on
    98|  * the desired pack level (0..9). The values given below have been tuned to
    99|  * exclude worst case performance for pathological files. Better values may be
   100|  * found for specific files.
   101|  */
   102| typedef struct config_s {
   103|    ush good_length; /* reduce lazy search above this match length */
   104|    ush max_lazy;    /* do not perform lazy search above this match length */
   105|    ush nice_length; /* quit search above this match length */
   106|    ush max_chain;
   107|    compress_func func;
   108| } config;
   109| #ifdef FASTEST
   110| local const config configuration_table[2] = {
   111| /*      good lazy nice chain */
   112| /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
   113| /* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
   114| #else
   115| local const config configuration_table[10] = {
   116| /*      good lazy nice chain */
   117| /* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
   118| /* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
   119| /* 2 */ {4,    5, 16,    8, deflate_fast},
   120| /* 3 */ {4,    6, 32,   32, deflate_fast},
   121| /* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
   122| /* 5 */ {8,   16, 32,   32, deflate_slow},
   123| /* 6 */ {8,   16, 128, 128, deflate_slow},
   124| /* 7 */ {8,   32, 128, 256, deflate_slow},
   125| /* 8 */ {32, 128, 258, 1024, deflate_slow},
   126| /* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
   127| #endif
   128| /* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
   129|  * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
   130|  * meaning.
   131|  */
   132| /* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
   133| #define RANK(f) (((f) * 2) - ((f) > 4 ? 9 : 0))
   134| /* ===========================================================================
   135|  * Update a hash value with the given input byte
   136|  * IN  assertion: all calls to UPDATE_HASH are made with consecutive input
   137|  *    characters, so that a running hash key can be computed from the previous
   138|  *    key instead of complete recalculation each time.
   139|  */
   140| #define UPDATE_HASH(s,h,c) (h = (((h) << s->hash_shift) ^ (c)) & s->hash_mask)
   141| /* ===========================================================================
   142|  * Insert string str in the dictionary and set match_head to the previous head
   143|  * of the hash chain (the most recent string with same hash key). Return
   144|  * the previous length of the hash chain.
   145|  * If this file is compiled with -DFASTEST, the compression level is forced
   146|  * to 1, and no hash chains are maintained.
   147|  * IN  assertion: all calls to INSERT_STRING are made with consecutive input
   148|  *    characters and the first MIN_MATCH bytes of str are valid (except for
   149|  *    the last MIN_MATCH-1 bytes of the input file).
   150|  */
   151| #ifdef FASTEST
   152| #define INSERT_STRING(s, str, match_head) \
   153|    (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
   154|     match_head = s->head[s->ins_h], \
   155|     s->head[s->ins_h] = (Pos)(str))
   156| #else
   157| #define INSERT_STRING(s, str, match_head) \
   158|    (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
   159|     match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
   160|     s->head[s->ins_h] = (Pos)(str))
   161| #endif
   162| /* ===========================================================================
   163|  * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
   164|  * prev[] will be initialized on the fly.
   165|  */
   166| #define CLEAR_HASH(s) \
   167|     do { \
   168|         s->head[s->hash_size - 1] = NIL; \
   169|         zmemzero((Bytef *)s->head, \
   170|                  (unsigned)(s->hash_size - 1)*sizeof(*s->head)); \
   171|     } while (0)
   172| /* ===========================================================================
   173|  * Slide the hash table when sliding the window down (could be avoided with 32
   174|  * bit values at the expense of memory usage). We slide even when level == 0 to
   175|  * keep the hash table consistent if we switch back to level > 0 later.
   176|  */
   177| local void slide_hash(s)
   178|     deflate_state *s;
   179| {
   180|     unsigned n, m;
   181|     Posf *p;
   182|     uInt wsize = s->w_size;
   183|     n = s->hash_size;
   184|     p = &s->head[n];
   185|     do {
   186|         m = *--p;
   187|         *p = (Pos)(m >= wsize ? m - wsize : NIL);
   188|     } while (--n);
   189|     n = wsize;
   190| #ifndef FASTEST
   191|     p = &s->prev[n];
   192|     do {
   193|         m = *--p;
   194|         *p = (Pos)(m >= wsize ? m - wsize : NIL);
   195|         /* If n is not on any hash chain, prev[n] is garbage but
   196|          * its value will never be used.
   197|          */
   198|     } while (--n);
   199| #endif
   200| }
   201| /* ========================================================================= */
   202| int ZEXPORT deflateInit_(strm, level, version, stream_size)
   203|     z_streamp strm;
   204|     int level;
   205|     const char *version;
   206|     int stream_size;
   207| {
   208|     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
   209|                          Z_DEFAULT_STRATEGY, version, stream_size);
   210|     /* To do: ignore strm->next_in if we use it as window */
   211| }
   212| /* ========================================================================= */
   213| int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
   214|                   version, stream_size)
   215|     z_streamp strm;
   216|     int  level;
   217|     int  method;
   218|     int  windowBits;
   219|     int  memLevel;
   220|     int  strategy;
   221|     const char *version;
   222|     int stream_size;
   223| {
   224|     deflate_state *s;
   225|     int wrap = 1;
   226|     static const char my_version[] = ZLIB_VERSION;
   227|     if (version == Z_NULL || version[0] != my_version[0] ||
   228|         stream_size != sizeof(z_stream)) {
   229|         return Z_VERSION_ERROR;
   230|     }
   231|     if (strm == Z_NULL) return Z_STREAM_ERROR;
   232|     strm->msg = Z_NULL;
   233|     if (strm->zalloc == (alloc_func)0) {
   234| #ifdef Z_SOLO
   235|         return Z_STREAM_ERROR;
   236| #else
   237|         strm->zalloc = zcalloc;
   238|         strm->opaque = (voidpf)0;
   239| #endif
   240|     }
   241|     if (strm->zfree == (free_func)0)
   242| #ifdef Z_SOLO
   243|         return Z_STREAM_ERROR;
   244| #else
   245|         strm->zfree = zcfree;
   246| #endif
   247| #ifdef FASTEST
   248|     if (level != 0) level = 1;
   249| #else
   250|     if (level == Z_DEFAULT_COMPRESSION) level = 6;
   251| #endif
   252|     if (windowBits < 0) { /* suppress zlib wrapper */
   253|         wrap = 0;
   254|         if (windowBits < -15)
   255|             return Z_STREAM_ERROR;
   256|         windowBits = -windowBits;
   257|     }
   258| #ifdef GZIP
   259|     else if (windowBits > 15) {
   260|         wrap = 2;       /* write gzip wrapper instead */
   261|         windowBits -= 16;
   262|     }
   263| #endif
   264|     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
   265|         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
   266|         strategy < 0 || strategy > Z_FIXED || (windowBits == 8 && wrap != 1)) {
   267|         return Z_STREAM_ERROR;
   268|     }
   269|     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
   270|     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
   271|     if (s == Z_NULL) return Z_MEM_ERROR;
   272|     strm->state = (struct internal_state FAR *)s;
   273|     s->strm = strm;
   274|     s->status = INIT_STATE;     /* to pass state test in deflateReset() */
   275|     s->wrap = wrap;
   276|     s->gzhead = Z_NULL;
   277|     s->w_bits = (uInt)windowBits;
   278|     s->w_size = 1 << s->w_bits;
   279|     s->w_mask = s->w_size - 1;
   280|     s->hash_bits = (uInt)memLevel + 7;
   281|     s->hash_size = 1 << s->hash_bits;
   282|     s->hash_mask = s->hash_size - 1;
   283|     s->hash_shift =  ((s->hash_bits + MIN_MATCH-1) / MIN_MATCH);
   284|     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
   285|     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
   286|     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
   287|     s->high_water = 0;      /* nothing written to s->window yet */
   288|     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
   289|     /* We overlay pending_buf and sym_buf. This works since the average size
   290|      * for length/distance pairs over any compressed block is assured to be 31
   291|      * bits or less.
   292|      *
   293|      * Analysis: The longest fixed codes are a length code of 8 bits plus 5
   294|      * extra bits, for lengths 131 to 257. The longest fixed distance codes are
   295|      * 5 bits plus 13 extra bits, for distances 16385 to 32768. The longest
   296|      * possible fixed-codes length/distance pair is then 31 bits total.
   297|      *
   298|      * sym_buf starts one-fourth of the way into pending_buf. So there are
   299|      * three bytes in sym_buf for every four bytes in pending_buf. Each symbol
   300|      * in sym_buf is three bytes -- two for the distance and one for the
   301|      * literal/length. As each symbol is consumed, the pointer to the next
   302|      * sym_buf value to read moves forward three bytes. From that symbol, up to
   303|      * 31 bits are written to pending_buf. The closest the written pending_buf
   304|      * bits gets to the next sym_buf symbol to read is just before the last
   305|      * code is written. At that time, 31*(n - 2) bits have been written, just
   306|      * after 24*(n - 2) bits have been consumed from sym_buf. sym_buf starts at
   307|      * 8*n bits into pending_buf. (Note that the symbol buffer fills when n - 1
   308|      * symbols are written.) The closest the writing gets to what is unread is
   309|      * then n + 14 bits. Here n is lit_bufsize, which is 16384 by default, and
   310|      * can range from 128 to 32768.
   311|      *
   312|      * Therefore, at a minimum, there are 142 bits of space between what is
   313|      * written and what is read in the overlain buffers, so the symbols cannot
   314|      * be overwritten by the compressed data. That space is actually 139 bits,
   315|      * due to the three-bit fixed-code block header.
   316|      *
   317|      * That covers the case where either Z_FIXED is specified, forcing fixed
   318|      * codes, or when the use of fixed codes is chosen, because that choice
   319|      * results in a smaller compressed block than dynamic codes. That latter
   320|      * condition then assures that the above analysis also covers all dynamic
   321|      * blocks. A dynamic-code block will only be chosen to be emitted if it has
   322|      * fewer bits than a fixed-code block would for the same set of symbols.
   323|      * Therefore its average symbol length is assured to be less than 31. So
   324|      * the compressed data for a dynamic block also cannot overwrite the
   325|      * symbols from which it is being constructed.
   326|      */
   327|     s->pending_buf = (uchf *) ZALLOC(strm, s->lit_bufsize, 4);
   328|     s->pending_buf_size = (ulg)s->lit_bufsize * 4;
   329|     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
   330|         s->pending_buf == Z_NULL) {
   331|         s->status = FINISH_STATE;
   332|         strm->msg = ERR_MSG(Z_MEM_ERROR);
   333|         deflateEnd (strm);
   334|         return Z_MEM_ERROR;
   335|     }
   336|     s->sym_buf = s->pending_buf + s->lit_bufsize;
   337|     s->sym_end = (s->lit_bufsize - 1) * 3;
   338|     /* We avoid equality with lit_bufsize*3 because of wraparound at 64K
   339|      * on 16 bit machines and because stored blocks are restricted to
   340|      * 64K-1 bytes.
   341|      */
   342|     s->level = level;
   343|     s->strategy = strategy;
   344|     s->method = (Byte)method;
   345|     return deflateReset(strm);
   346| }
   347| /* =========================================================================
   348|  * Check for a valid deflate stream state. Return 0 if ok, 1 if not.
   349|  */
   350| local int deflateStateCheck(strm)
   351|     z_streamp strm;
   352| {
   353|     deflate_state *s;
   354|     if (strm == Z_NULL ||
   355|         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
   356|         return 1;
   357|     s = strm->state;
   358|     if (s == Z_NULL || s->strm != strm || (s->status != INIT_STATE &&
   359| #ifdef GZIP
   360|                                            s->status != GZIP_STATE &&
   361| #endif
   362|                                            s->status != EXTRA_STATE &&
   363|                                            s->status != NAME_STATE &&
   364|                                            s->status != COMMENT_STATE &&
   365|                                            s->status != HCRC_STATE &&
   366|                                            s->status != BUSY_STATE &&
   367|                                            s->status != FINISH_STATE))
   368|         return 1;
   369|     return 0;
   370| }
   371| /* ========================================================================= */
   372| int ZEXPORT deflateSetDictionary(strm, dictionary, dictLength)
   373|     z_streamp strm;
   374|     const Bytef *dictionary;
   375|     uInt  dictLength;
   376| {
   377|     deflate_state *s;
   378|     uInt str, n;
   379|     int wrap;
   380|     unsigned avail;
   381|     z_const unsigned char *next;
   382|     if (deflateStateCheck(strm) || dictionary == Z_NULL)
   383|         return Z_STREAM_ERROR;
   384|     s = strm->state;
   385|     wrap = s->wrap;
   386|     if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
   387|         return Z_STREAM_ERROR;
   388|     /* when using zlib wrappers, compute Adler-32 for provided dictionary */
   389|     if (wrap == 1)
   390|         strm->adler = adler32(strm->adler, dictionary, dictLength);
   391|     s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */
   392|     /* if dictionary would fill window, just replace the history */
   393|     if (dictLength >= s->w_size) {
   394|         if (wrap == 0) {            /* already empty otherwise */
   395|             CLEAR_HASH(s);
   396|             s->strstart = 0;
   397|             s->block_start = 0L;
   398|             s->insert = 0;
   399|         }
   400|         dictionary += dictLength - s->w_size;  /* use the tail */
   401|         dictLength = s->w_size;
   402|     }
   403|     /* insert dictionary into window and hash */
   404|     avail = strm->avail_in;
   405|     next = strm->next_in;
   406|     strm->avail_in = dictLength;
   407|     strm->next_in = (z_const Bytef *)dictionary;
   408|     fill_window(s);
   409|     while (s->lookahead >= MIN_MATCH) {
   410|         str = s->strstart;
   411|         n = s->lookahead - (MIN_MATCH-1);
   412|         do {
   413|             UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
   414| #ifndef FASTEST
   415|             s->prev[str & s->w_mask] = s->head[s->ins_h];
   416| #endif
   417|             s->head[s->ins_h] = (Pos)str;
   418|             str++;
   419|         } while (--n);
   420|         s->strstart = str;
   421|         s->lookahead = MIN_MATCH-1;
   422|         fill_window(s);
   423|     }
   424|     s->strstart += s->lookahead;
   425|     s->block_start = (long)s->strstart;
   426|     s->insert = s->lookahead;
   427|     s->lookahead = 0;
   428|     s->match_length = s->prev_length = MIN_MATCH-1;
   429|     s->match_available = 0;
   430|     strm->next_in = next;
   431|     strm->avail_in = avail;
   432|     s->wrap = wrap;
   433|     return Z_OK;
   434| }
   435| /* ========================================================================= */
   436| int ZEXPORT deflateGetDictionary(strm, dictionary, dictLength)
   437|     z_streamp strm;
   438|     Bytef *dictionary;
   439|     uInt  *dictLength;
   440| {
   441|     deflate_state *s;
   442|     uInt len;
   443|     if (deflateStateCheck(strm))
   444|         return Z_STREAM_ERROR;
   445|     s = strm->state;
   446|     len = s->strstart + s->lookahead;
   447|     if (len > s->w_size)
   448|         len = s->w_size;
   449|     if (dictionary != Z_NULL && len)
   450|         zmemcpy(dictionary, s->window + s->strstart + s->lookahead - len, len);
   451|     if (dictLength != Z_NULL)
   452|         *dictLength = len;
   453|     return Z_OK;
   454| }
   455| /* ========================================================================= */
   456| int ZEXPORT deflateResetKeep(strm)
   457|     z_streamp strm;
   458| {
   459|     deflate_state *s;
   460|     if (deflateStateCheck(strm)) {
   461|         return Z_STREAM_ERROR;
   462|     }
   463|     strm->total_in = strm->total_out = 0;
   464|     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
   465|     strm->data_type = Z_UNKNOWN;
   466|     s = (deflate_state *)strm->state;
   467|     s->pending = 0;
   468|     s->pending_out = s->pending_buf;
   469|     if (s->wrap < 0) {
   470|         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
   471|     }
   472|     s->status =
   473| #ifdef GZIP
   474|         s->wrap == 2 ? GZIP_STATE :
   475| #endif
   476|         INIT_STATE;
   477|     strm->adler =
   478| #ifdef GZIP
   479|         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
   480| #endif
   481|         adler32(0L, Z_NULL, 0);
   482|     s->last_flush = -2;
   483|     _tr_init(s);
   484|     return Z_OK;
   485| }
   486| /* ========================================================================= */
   487| int ZEXPORT deflateReset(strm)
   488|     z_streamp strm;
   489| {
   490|     int ret;
   491|     ret = deflateResetKeep(strm);
   492|     if (ret == Z_OK)
   493|         lm_init(strm->state);
   494|     return ret;
   495| }
   496| /* ========================================================================= */
   497| int ZEXPORT deflateSetHeader(strm, head)
   498|     z_streamp strm;
   499|     gz_headerp head;
   500| {
   501|     if (deflateStateCheck(strm) || strm->state->wrap != 2)
   502|         return Z_STREAM_ERROR;
   503|     strm->state->gzhead = head;
   504|     return Z_OK;
   505| }
   506| /* ========================================================================= */
   507| int ZEXPORT deflatePending(strm, pending, bits)
   508|     unsigned *pending;
   509|     int *bits;
   510|     z_streamp strm;
   511| {
   512|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   513|     if (pending != Z_NULL)
   514|         *pending = strm->state->pending;
   515|     if (bits != Z_NULL)
   516|         *bits = strm->state->bi_valid;
   517|     return Z_OK;
   518| }
   519| /* ========================================================================= */
   520| int ZEXPORT deflatePrime(strm, bits, value)
   521|     z_streamp strm;
   522|     int bits;
   523|     int value;
   524| {
   525|     deflate_state *s;
   526|     int put;
   527|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   528|     s = strm->state;
   529|     if (bits < 0 || bits > 16 ||
   530|         s->sym_buf < s->pending_out + ((Buf_size + 7) >> 3))
   531|         return Z_BUF_ERROR;
   532|     do {
   533|         put = Buf_size - s->bi_valid;
   534|         if (put > bits)
   535|             put = bits;
   536|         s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
   537|         s->bi_valid += put;
   538|         _tr_flush_bits(s);
   539|         value >>= put;
   540|         bits -= put;
   541|     } while (bits);
   542|     return Z_OK;
   543| }
   544| /* ========================================================================= */
   545| int ZEXPORT deflateParams(strm, level, strategy)
   546|     z_streamp strm;
   547|     int level;
   548|     int strategy;
   549| {
   550|     deflate_state *s;
   551|     compress_func func;
   552|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   553|     s = strm->state;
   554| #ifdef FASTEST
   555|     if (level != 0) level = 1;
   556| #else
   557|     if (level == Z_DEFAULT_COMPRESSION) level = 6;
   558| #endif
   559|     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
   560|         return Z_STREAM_ERROR;
   561|     }
   562|     func = configuration_table[s->level].func;
   563|     if ((strategy != s->strategy || func != configuration_table[level].func) &&
   564|         s->last_flush != -2) {
   565|         /* Flush the last buffer: */
   566|         int err = deflate(strm, Z_BLOCK);
   567|         if (err == Z_STREAM_ERROR)
   568|             return err;
   569|         if (strm->avail_in || (s->strstart - s->block_start) + s->lookahead)
   570|             return Z_BUF_ERROR;
   571|     }
   572|     if (s->level != level) {
   573|         if (s->level == 0 && s->matches != 0) {
   574|             if (s->matches == 1)
   575|                 slide_hash(s);
   576|             else
   577|                 CLEAR_HASH(s);
   578|             s->matches = 0;
   579|         }
   580|         s->level = level;
   581|         s->max_lazy_match   = configuration_table[level].max_lazy;
   582|         s->good_match       = configuration_table[level].good_length;
   583|         s->nice_match       = configuration_table[level].nice_length;
   584|         s->max_chain_length = configuration_table[level].max_chain;
   585|     }
   586|     s->strategy = strategy;
   587|     return Z_OK;
   588| }
   589| /* ========================================================================= */
   590| int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
   591|     z_streamp strm;
   592|     int good_length;
   593|     int max_lazy;
   594|     int nice_length;
   595|     int max_chain;
   596| {
   597|     deflate_state *s;
   598|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
   599|     s = strm->state;
   600|     s->good_match = (uInt)good_length;
   601|     s->max_lazy_match = (uInt)max_lazy;
   602|     s->nice_match = nice_length;
   603|     s->max_chain_length = (uInt)max_chain;
   604|     return Z_OK;
   605| }
   606| /* =========================================================================
   607|  * For the default windowBits of 15 and memLevel of 8, this function returns a
   608|  * close to exact, as well as small, upper bound on the compressed size. This
   609|  * is an expansion of ~0.03%, plus a small constant.
   610|  *
   611|  * For any setting other than those defaults for windowBits and memLevel, one
   612|  * of two worst case bounds is returned. This is at most an expansion of ~4% or
   613|  * ~13%, plus a small constant.
   614|  *
   615|  * Both the 0.03% and 4% derive from the overhead of stored blocks. The first
   616|  * one is for stored blocks of 16383 bytes (memLevel == 8), whereas the second
   617|  * is for stored blocks of 127 bytes (the worst case memLevel == 1). The
   618|  * expansion results from five bytes of header for each stored block.
   619|  *
   620|  * The larger expansion of 13% results from a window size less than or equal to
   621|  * the symbols buffer size (windowBits <= memLevel + 7). In that case some of
   622|  * the data being compressed may have slid out of the sliding window, impeding
   623|  * a stored block from being emitted. Then the only choice is a fixed or
   624|  * dynamic block, where a fixed block limits the maximum expansion to 9 bits
   625|  * per 8-bit byte, plus 10 bits for every block. The smallest block size for
   626|  * which this can occur is 255 (memLevel == 2).
   627|  *
   628|  * Shifts are used to approximate divisions, for speed.
   629|  */
   630| uLong ZEXPORT deflateBound(strm, sourceLen)
   631|     z_streamp strm;
   632|     uLong sourceLen;
   633| {
   634|     deflate_state *s;
   635|     uLong fixedlen, storelen, wraplen;
   636|     /* upper bound for fixed blocks with 9-bit literals and length 255
   637|        (memLevel == 2, which is the lowest that may not use stored blocks) --
   638|        ~13% overhead plus a small constant */
   639|     fixedlen = sourceLen + (sourceLen >> 3) + (sourceLen >> 8) +
   640|                (sourceLen >> 9) + 4;
   641|     /* upper bound for stored blocks with length 127 (memLevel == 1) --
   642|        ~4% overhead plus a small constant */
   643|     storelen = sourceLen + (sourceLen >> 5) + (sourceLen >> 7) +
   644|                (sourceLen >> 11) + 7;
   645|     /* if can't get parameters, return larger bound plus a zlib wrapper */
   646|     if (deflateStateCheck(strm))
   647|         return (fixedlen > storelen ? fixedlen : storelen) + 6;
   648|     /* compute wrapper length */
   649|     s = strm->state;
   650|     switch (s->wrap) {
   651|     case 0:                                 /* raw deflate */
   652|         wraplen = 0;
   653|         break;
   654|     case 1:                                 /* zlib wrapper */
   655|         wraplen = 6 + (s->strstart ? 4 : 0);
   656|         break;
   657| #ifdef GZIP
   658|     case 2:                                 /* gzip wrapper */
   659|         wraplen = 18;
   660|         if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
   661|             Bytef *str;
   662|             if (s->gzhead->extra != Z_NULL)
   663|                 wraplen += 2 + s->gzhead->extra_len;
   664|             str = s->gzhead->name;
   665|             if (str != Z_NULL)
   666|                 do {
   667|                     wraplen++;
   668|                 } while (*str++);
   669|             str = s->gzhead->comment;
   670|             if (str != Z_NULL)
   671|                 do {
   672|                     wraplen++;
   673|                 } while (*str++);
   674|             if (s->gzhead->hcrc)
   675|                 wraplen += 2;
   676|         }
   677|         break;
   678| #endif
   679|     default:                                /* for compiler happiness */
   680|         wraplen = 6;
   681|     }
   682|     /* if not default parameters, return one of the conservative bounds */
   683|     if (s->w_bits != 15 || s->hash_bits != 8 + 7)
   684|         return (s->w_bits <= s->hash_bits && s->level ? fixedlen : storelen) +
   685|                wraplen;
   686|     /* default settings: return tight bound for that case -- ~0.03% overhead
   687|        plus a small constant */
   688|     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
   689|            (sourceLen >> 25) + 13 - 6 + wraplen;
   690| }
   691| /* =========================================================================
   692|  * Put a short in the pending buffer. The 16-bit value is put in MSB order.
   693|  * IN assertion: the stream state is correct and there is enough room in
   694|  * pending_buf.
   695|  */
   696| local void putShortMSB(s, b)
   697|     deflate_state *s;
   698|     uInt b;
   699| {
   700|     put_byte(s, (Byte)(b >> 8));
   701|     put_byte(s, (Byte)(b & 0xff));
   702| }
   703| /* =========================================================================
   704|  * Flush as much pending output as possible. All deflate() output, except for
   705|  * some deflate_stored() output, goes through this function so some
   706|  * applications may wish to modify it to avoid allocating a large
   707|  * strm->next_out buffer and copying into it. (See also read_buf()).
   708|  */
   709| local void flush_pending(strm)
   710|     z_streamp strm;
   711| {
   712|     unsigned len;
   713|     deflate_state *s = strm->state;
   714|     _tr_flush_bits(s);
   715|     len = s->pending;
   716|     if (len > strm->avail_out) len = strm->avail_out;
   717|     if (len == 0) return;
   718|     zmemcpy(strm->next_out, s->pending_out, len);
   719|     strm->next_out  += len;
   720|     s->pending_out  += len;
   721|     strm->total_out += len;
   722|     strm->avail_out -= len;
   723|     s->pending      -= len;
   724|     if (s->pending == 0) {
   725|         s->pending_out = s->pending_buf;
   726|     }
   727| }
   728| /* ===========================================================================
   729|  * Update the header CRC with the bytes s->pending_buf[beg..s->pending - 1].
   730|  */
   731| #define HCRC_UPDATE(beg) \
   732|     do { \
   733|         if (s->gzhead->hcrc && s->pending > (beg)) \
   734|             strm->adler = crc32(strm->adler, s->pending_buf + (beg), \
   735|                                 s->pending - (beg)); \
   736|     } while (0)
   737| /* ========================================================================= */
   738| int ZEXPORT deflate(strm, flush)
   739|     z_streamp strm;
   740|     int flush;
   741| {
   742|     int old_flush; /* value of flush param for previous deflate call */
   743|     deflate_state *s;
   744|     if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
   745|         return Z_STREAM_ERROR;
   746|     }
   747|     s = strm->state;
   748|     if (strm->next_out == Z_NULL ||
   749|         (strm->avail_in != 0 && strm->next_in == Z_NULL) ||
   750|         (s->status == FINISH_STATE && flush != Z_FINISH)) {
   751|         ERR_RETURN(strm, Z_STREAM_ERROR);
   752|     }
   753|     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
   754|     old_flush = s->last_flush;
   755|     s->last_flush = flush;
   756|     /* Flush as much pending output as possible */
   757|     if (s->pending != 0) {
   758|         flush_pending(strm);
   759|         if (strm->avail_out == 0) {
   760|             /* Since avail_out is 0, deflate will be called again with
   761|              * more output space, but possibly with both pending and
   762|              * avail_in equal to zero. There won't be anything to do,
   763|              * but this is not an error situation so make sure we
   764|              * return OK instead of BUF_ERROR at next call of deflate:
   765|              */
   766|             s->last_flush = -1;
   767|             return Z_OK;
   768|         }
   769|     /* Make sure there is something to do and avoid duplicate consecutive
   770|      * flushes. For repeated and useless calls with Z_FINISH, we keep
   771|      * returning Z_STREAM_END instead of Z_BUF_ERROR.
   772|      */
   773|     } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
   774|                flush != Z_FINISH) {
   775|         ERR_RETURN(strm, Z_BUF_ERROR);
   776|     }
   777|     /* User must not provide more input after the first FINISH: */
   778|     if (s->status == FINISH_STATE && strm->avail_in != 0) {
   779|         ERR_RETURN(strm, Z_BUF_ERROR);
   780|     }
   781|     /* Write the header */
   782|     if (s->status == INIT_STATE && s->wrap == 0)
   783|         s->status = BUSY_STATE;
   784|     if (s->status == INIT_STATE) {
   785|         /* zlib header */
   786|         uInt header = (Z_DEFLATED + ((s->w_bits - 8) << 4)) << 8;
   787|         uInt level_flags;
   788|         if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
   789|             level_flags = 0;
   790|         else if (s->level < 6)
   791|             level_flags = 1;
   792|         else if (s->level == 6)
   793|             level_flags = 2;
   794|         else
   795|             level_flags = 3;
   796|         header |= (level_flags << 6);
   797|         if (s->strstart != 0) header |= PRESET_DICT;
   798|         header += 31 - (header % 31);
   799|         putShortMSB(s, header);
   800|         /* Save the adler32 of the preset dictionary: */
   801|         if (s->strstart != 0) {
   802|             putShortMSB(s, (uInt)(strm->adler >> 16));
   803|             putShortMSB(s, (uInt)(strm->adler & 0xffff));
   804|         }
   805|         strm->adler = adler32(0L, Z_NULL, 0);
   806|         s->status = BUSY_STATE;
   807|         /* Compression must start with an empty pending buffer */
   808|         flush_pending(strm);
   809|         if (s->pending != 0) {
   810|             s->last_flush = -1;
   811|             return Z_OK;
   812|         }
   813|     }
   814| #ifdef GZIP
   815|     if (s->status == GZIP_STATE) {
   816|         /* gzip header */
   817|         strm->adler = crc32(0L, Z_NULL, 0);
   818|         put_byte(s, 31);
   819|         put_byte(s, 139);
   820|         put_byte(s, 8);
   821|         if (s->gzhead == Z_NULL) {
   822|             put_byte(s, 0);
   823|             put_byte(s, 0);
   824|             put_byte(s, 0);
   825|             put_byte(s, 0);
   826|             put_byte(s, 0);
   827|             put_byte(s, s->level == 9 ? 2 :
   828|                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
   829|                       4 : 0));
   830|             put_byte(s, OS_CODE);
   831|             s->status = BUSY_STATE;
   832|             /* Compression must start with an empty pending buffer */
   833|             flush_pending(strm);
   834|             if (s->pending != 0) {
   835|                 s->last_flush = -1;
   836|                 return Z_OK;
   837|             }
   838|         }
   839|         else {
   840|             put_byte(s, (s->gzhead->text ? 1 : 0) +
   841|                      (s->gzhead->hcrc ? 2 : 0) +
   842|                      (s->gzhead->extra == Z_NULL ? 0 : 4) +
   843|                      (s->gzhead->name == Z_NULL ? 0 : 8) +
   844|                      (s->gzhead->comment == Z_NULL ? 0 : 16)
   845|                      );
   846|             put_byte(s, (Byte)(s->gzhead->time & 0xff));
   847|             put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
   848|             put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
   849|             put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
   850|             put_byte(s, s->level == 9 ? 2 :
   851|                      (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
   852|                       4 : 0));
   853|             put_byte(s, s->gzhead->os & 0xff);
   854|             if (s->gzhead->extra != Z_NULL) {
   855|                 put_byte(s, s->gzhead->extra_len & 0xff);
   856|                 put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
   857|             }
   858|             if (s->gzhead->hcrc)
   859|                 strm->adler = crc32(strm->adler, s->pending_buf,
   860|                                     s->pending);
   861|             s->gzindex = 0;
   862|             s->status = EXTRA_STATE;
   863|         }
   864|     }
   865|     if (s->status == EXTRA_STATE) {
   866|         if (s->gzhead->extra != Z_NULL) {
   867|             ulg beg = s->pending;   /* start of bytes to update crc */
   868|             uInt left = (s->gzhead->extra_len & 0xffff) - s->gzindex;
   869|             while (s->pending + left > s->pending_buf_size) {
   870|                 uInt copy = s->pending_buf_size - s->pending;
   871|                 zmemcpy(s->pending_buf + s->pending,
   872|                         s->gzhead->extra + s->gzindex, copy);
   873|                 s->pending = s->pending_buf_size;
   874|                 HCRC_UPDATE(beg);
   875|                 s->gzindex += copy;
   876|                 flush_pending(strm);
   877|                 if (s->pending != 0) {
   878|                     s->last_flush = -1;
   879|                     return Z_OK;
   880|                 }
   881|                 beg = 0;
   882|                 left -= copy;
   883|             }
   884|             zmemcpy(s->pending_buf + s->pending,
   885|                     s->gzhead->extra + s->gzindex, left);
   886|             s->pending += left;
   887|             HCRC_UPDATE(beg);
   888|             s->gzindex = 0;
   889|         }
   890|         s->status = NAME_STATE;
   891|     }
   892|     if (s->status == NAME_STATE) {
   893|         if (s->gzhead->name != Z_NULL) {
   894|             ulg beg = s->pending;   /* start of bytes to update crc */
   895|             int val;
   896|             do {
   897|                 if (s->pending == s->pending_buf_size) {
   898|                     HCRC_UPDATE(beg);
   899|                     flush_pending(strm);
   900|                     if (s->pending != 0) {
   901|                         s->last_flush = -1;
   902|                         return Z_OK;
   903|                     }
   904|                     beg = 0;
   905|                 }
   906|                 val = s->gzhead->name[s->gzindex++];
   907|                 put_byte(s, val);
   908|             } while (val != 0);
   909|             HCRC_UPDATE(beg);
   910|             s->gzindex = 0;
   911|         }
   912|         s->status = COMMENT_STATE;
   913|     }
   914|     if (s->status == COMMENT_STATE) {
   915|         if (s->gzhead->comment != Z_NULL) {
   916|             ulg beg = s->pending;   /* start of bytes to update crc */
   917|             int val;
   918|             do {
   919|                 if (s->pending == s->pending_buf_size) {
   920|                     HCRC_UPDATE(beg);
   921|                     flush_pending(strm);
   922|                     if (s->pending != 0) {
   923|                         s->last_flush = -1;
   924|                         return Z_OK;
   925|                     }
   926|                     beg = 0;
   927|                 }
   928|                 val = s->gzhead->comment[s->gzindex++];
   929|                 put_byte(s, val);
   930|             } while (val != 0);
   931|             HCRC_UPDATE(beg);
   932|         }
   933|         s->status = HCRC_STATE;
   934|     }
   935|     if (s->status == HCRC_STATE) {
   936|         if (s->gzhead->hcrc) {
   937|             if (s->pending + 2 > s->pending_buf_size) {
   938|                 flush_pending(strm);
   939|                 if (s->pending != 0) {
   940|                     s->last_flush = -1;
   941|                     return Z_OK;
   942|                 }
   943|             }
   944|             put_byte(s, (Byte)(strm->adler & 0xff));
   945|             put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
   946|             strm->adler = crc32(0L, Z_NULL, 0);
   947|         }
   948|         s->status = BUSY_STATE;
   949|         /* Compression must start with an empty pending buffer */
   950|         flush_pending(strm);
   951|         if (s->pending != 0) {
   952|             s->last_flush = -1;
   953|             return Z_OK;
   954|         }
   955|     }
   956| #endif
   957|     /* Start a new block or continue the current one.
   958|      */
   959|     if (strm->avail_in != 0 || s->lookahead != 0 ||
   960|         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
   961|         block_state bstate;
   962|         bstate = s->level == 0 ? deflate_stored(s, flush) :
   963|                  s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
   964|                  s->strategy == Z_RLE ? deflate_rle(s, flush) :
   965|                  (*(configuration_table[s->level].func))(s, flush);
   966|         if (bstate == finish_started || bstate == finish_done) {
   967|             s->status = FINISH_STATE;
   968|         }
   969|         if (bstate == need_more || bstate == finish_started) {
   970|             if (strm->avail_out == 0) {
   971|                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
   972|             }
   973|             return Z_OK;
   974|             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
   975|              * of deflate should use the same flush parameter to make sure
   976|              * that the flush is complete. So we don't have to output an
   977|              * empty block here, this will be done at next call. This also
   978|              * ensures that for a very small output buffer, we emit at most
   979|              * one empty block.
   980|              */
   981|         }
   982|         if (bstate == block_done) {
   983|             if (flush == Z_PARTIAL_FLUSH) {
   984|                 _tr_align(s);
   985|             } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
   986|                 _tr_stored_block(s, (char*)0, 0L, 0);
   987|                 /* For a full flush, this empty block will be recognized
   988|                  * as a special marker by inflate_sync().
   989|                  */
   990|                 if (flush == Z_FULL_FLUSH) {
   991|                     CLEAR_HASH(s);             /* forget history */
   992|                     if (s->lookahead == 0) {
   993|                         s->strstart = 0;
   994|                         s->block_start = 0L;
   995|                         s->insert = 0;
   996|                     }
   997|                 }
   998|             }
   999|             flush_pending(strm);
  1000|             if (strm->avail_out == 0) {
  1001|               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
  1002|               return Z_OK;
  1003|             }
  1004|         }
  1005|     }
  1006|     if (flush != Z_FINISH) return Z_OK;
  1007|     if (s->wrap <= 0) return Z_STREAM_END;
  1008|     /* Write the trailer */
  1009| #ifdef GZIP
  1010|     if (s->wrap == 2) {
  1011|         put_byte(s, (Byte)(strm->adler & 0xff));
  1012|         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
  1013|         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
  1014|         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
  1015|         put_byte(s, (Byte)(strm->total_in & 0xff));
  1016|         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
  1017|         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
  1018|         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
  1019|     }
  1020|     else
  1021| #endif
  1022|     {
  1023|         putShortMSB(s, (uInt)(strm->adler >> 16));
  1024|         putShortMSB(s, (uInt)(strm->adler & 0xffff));
  1025|     }
  1026|     flush_pending(strm);
  1027|     /* If avail_out is zero, the application will call deflate again
  1028|      * to flush the rest.
  1029|      */
  1030|     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
  1031|     return s->pending != 0 ? Z_OK : Z_STREAM_END;
  1032| }
  1033| /* ========================================================================= */
  1034| int ZEXPORT deflateEnd(strm)
  1035|     z_streamp strm;
  1036| {
  1037|     int status;
  1038|     if (deflateStateCheck(strm)) return Z_STREAM_ERROR;
  1039|     status = strm->state->status;
  1040|     /* Deallocate in reverse order of allocations: */
  1041|     TRY_FREE(strm, strm->state->pending_buf);
  1042|     TRY_FREE(strm, strm->state->head);
  1043|     TRY_FREE(strm, strm->state->prev);
  1044|     TRY_FREE(strm, strm->state->window);
  1045|     ZFREE(strm, strm->state);
  1046|     strm->state = Z_NULL;
  1047|     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
  1048| }
  1049| /* =========================================================================
  1050|  * Copy the source state to the destination state.
  1051|  * To simplify the source, this is not supported for 16-bit MSDOS (which
  1052|  * doesn't have enough memory anyway to duplicate compression states).
  1053|  */
  1054| int ZEXPORT deflateCopy(dest, source)
  1055|     z_streamp dest;
  1056|     z_streamp source;
  1057| {
  1058| #ifdef MAXSEG_64K
  1059|     return Z_STREAM_ERROR;
  1060| #else
  1061|     deflate_state *ds;
  1062|     deflate_state *ss;
  1063|     if (deflateStateCheck(source) || dest == Z_NULL) {
  1064|         return Z_STREAM_ERROR;
  1065|     }
  1066|     ss = source->state;
  1067|     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
  1068|     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
  1069|     if (ds == Z_NULL) return Z_MEM_ERROR;
  1070|     dest->state = (struct internal_state FAR *) ds;
  1071|     zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
  1072|     ds->strm = dest;
  1073|     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
  1074|     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
  1075|     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
  1076|     ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);
  1077|     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
  1078|         ds->pending_buf == Z_NULL) {
  1079|         deflateEnd (dest);
  1080|         return Z_MEM_ERROR;
  1081|     }
  1082|     /* following zmemcpy do not work for 16-bit MSDOS */
  1083|     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
  1084|     zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
  1085|     zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
  1086|     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
  1087|     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
  1088|     ds->sym_buf = ds->pending_buf + ds->lit_bufsize;
  1089|     ds->l_desc.dyn_tree = ds->dyn_ltree;
  1090|     ds->d_desc.dyn_tree = ds->dyn_dtree;
  1091|     ds->bl_desc.dyn_tree = ds->bl_tree;
  1092|     return Z_OK;
  1093| #endif /* MAXSEG_64K */
  1094| }
  1095| /* ===========================================================================
  1096|  * Read a new buffer from the current input stream, update the adler32
  1097|  * and total number of bytes read.  All deflate() input goes through
  1098|  * this function so some applications may wish to modify it to avoid
  1099|  * allocating a large strm->next_in buffer and copying from it.
  1100|  * (See also flush_pending()).
  1101|  */
  1102| local unsigned read_buf(strm, buf, size)
  1103|     z_streamp strm;
  1104|     Bytef *buf;
  1105|     unsigned size;
  1106| {
  1107|     unsigned len = strm->avail_in;
  1108|     if (len > size) len = size;
  1109|     if (len == 0) return 0;
  1110|     strm->avail_in  -= len;
  1111|     zmemcpy(buf, strm->next_in, len);
  1112|     if (strm->state->wrap == 1) {
  1113|         strm->adler = adler32(strm->adler, buf, len);
  1114|     }
  1115| #ifdef GZIP
  1116|     else if (strm->state->wrap == 2) {
  1117|         strm->adler = crc32(strm->adler, buf, len);
  1118|     }
  1119| #endif
  1120|     strm->next_in  += len;
  1121|     strm->total_in += len;
  1122|     return len;
  1123| }
  1124| /* ===========================================================================
  1125|  * Initialize the "longest match" routines for a new zlib stream
  1126|  */
  1127| local void lm_init(s)
  1128|     deflate_state *s;
  1129| {
  1130|     s->window_size = (ulg)2L*s->w_size;
  1131|     CLEAR_HASH(s);
  1132|     /* Set the default configuration parameters:
  1133|      */
  1134|     s->max_lazy_match   = configuration_table[s->level].max_lazy;
  1135|     s->good_match       = configuration_table[s->level].good_length;
  1136|     s->nice_match       = configuration_table[s->level].nice_length;
  1137|     s->max_chain_length = configuration_table[s->level].max_chain;
  1138|     s->strstart = 0;
  1139|     s->block_start = 0L;
  1140|     s->lookahead = 0;
  1141|     s->insert = 0;
  1142|     s->match_length = s->prev_length = MIN_MATCH-1;
  1143|     s->match_available = 0;
  1144|     s->ins_h = 0;
  1145| }
  1146| #ifndef FASTEST
  1147| /* ===========================================================================
  1148|  * Set match_start to the longest match starting at the given string and
  1149|  * return its length. Matches shorter or equal to prev_length are discarded,
  1150|  * in which case the result is equal to prev_length and match_start is
  1151|  * garbage.
  1152|  * IN assertions: cur_match is the head of the hash chain for the current
  1153|  *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
  1154|  * OUT assertion: the match length is not greater than s->lookahead.
  1155|  */
  1156| local uInt longest_match(s, cur_match)
  1157|     deflate_state *s;
  1158|     IPos cur_match;                             /* current match */
  1159| {
  1160|     unsigned chain_length = s->max_chain_length;/* max hash chain length */
  1161|     register Bytef *scan = s->window + s->strstart; /* current string */
  1162|     register Bytef *match;                      /* matched string */
  1163|     register int len;                           /* length of current match */
  1164|     int best_len = (int)s->prev_length;         /* best match length so far */
  1165|     int nice_match = s->nice_match;             /* stop if match long enough */
  1166|     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
  1167|         s->strstart - (IPos)MAX_DIST(s) : NIL;
  1168|     /* Stop when cur_match becomes <= limit. To simplify the code,
  1169|      * we prevent matches with the string of window index 0.
  1170|      */
  1171|     Posf *prev = s->prev;
  1172|     uInt wmask = s->w_mask;
  1173| #ifdef UNALIGNED_OK
  1174|     /* Compare two bytes at a time. Note: this is not always beneficial.
  1175|      * Try with and without -DUNALIGNED_OK to check.
  1176|      */
  1177|     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
  1178|     register ush scan_start = *(ushf*)scan;
  1179|     register ush scan_end   = *(ushf*)(scan + best_len - 1);
  1180| #else
  1181|     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
  1182|     register Byte scan_end1  = scan[best_len - 1];
  1183|     register Byte scan_end   = scan[best_len];
  1184| #endif
  1185|     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
  1186|      * It is easy to get rid of this optimization if necessary.
  1187|      */
  1188|     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
  1189|     /* Do not waste too much time if we already have a good match: */
  1190|     if (s->prev_length >= s->good_match) {
  1191|         chain_length >>= 2;
  1192|     }
  1193|     /* Do not look for matches beyond the end of the input. This is necessary
  1194|      * to make deflate deterministic.
  1195|      */
  1196|     if ((uInt)nice_match > s->lookahead) nice_match = (int)s->lookahead;
  1197|     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  1198|            "need lookahead");
  1199|     do {
  1200|         Assert(cur_match < s->strstart, "no future");
  1201|         match = s->window + cur_match;
  1202|         /* Skip to next match if the match length cannot increase
  1203|          * or if the match length is less than 2.  Note that the checks below
  1204|          * for insufficient lookahead only occur occasionally for performance
  1205|          * reasons.  Therefore uninitialized memory will be accessed, and
  1206|          * conditional jumps will be made that depend on those values.
  1207|          * However the length of the match is limited to the lookahead, so
  1208|          * the output of deflate is not affected by the uninitialized values.
  1209|          */
  1210| #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
  1211|         /* This code assumes sizeof(unsigned short) == 2. Do not use
  1212|          * UNALIGNED_OK if your compiler uses a different size.
  1213|          */
  1214|         if (*(ushf*)(match + best_len - 1) != scan_end ||
  1215|             *(ushf*)match != scan_start) continue;
  1216|         /* It is not necessary to compare scan[2] and match[2] since they are
  1217|          * always equal when the other bytes match, given that the hash keys
  1218|          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
  1219|          * strstart + 3, + 5, up to strstart + 257. We check for insufficient
  1220|          * lookahead only every 4th comparison; the 128th check will be made
  1221|          * at strstart + 257. If MAX_MATCH-2 is not a multiple of 8, it is
  1222|          * necessary to put more guard bytes at the end of the window, or
  1223|          * to check more often for insufficient lookahead.
  1224|          */
  1225|         Assert(scan[2] == match[2], "scan[2]?");
  1226|         scan++, match++;
  1227|         do {
  1228|         } while (*(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
  1229|                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
  1230|                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
  1231|                  *(ushf*)(scan += 2) == *(ushf*)(match += 2) &&
  1232|                  scan < strend);
  1233|         /* The funny "do {}" generates better code on most compilers */
  1234|         /* Here, scan <= window + strstart + 257 */
  1235|         Assert(scan <= s->window + (unsigned)(s->window_size - 1),
  1236|                "wild scan");
  1237|         if (*scan == *match) scan++;
  1238|         len = (MAX_MATCH - 1) - (int)(strend - scan);
  1239|         scan = strend - (MAX_MATCH-1);
  1240| #else /* UNALIGNED_OK */
  1241|         if (match[best_len]     != scan_end  ||
  1242|             match[best_len - 1] != scan_end1 ||
  1243|             *match              != *scan     ||
  1244|             *++match            != scan[1])      continue;
  1245|         /* The check at best_len - 1 can be removed because it will be made
  1246|          * again later. (This heuristic is not always a win.)
  1247|          * It is not necessary to compare scan[2] and match[2] since they
  1248|          * are always equal when the other bytes match, given that
  1249|          * the hash keys are equal and that HASH_BITS >= 8.
  1250|          */
  1251|         scan += 2, match++;
  1252|         Assert(*scan == *match, "match[2]?");
  1253|         /* We check for insufficient lookahead only every 8th comparison;
  1254|          * the 256th check will be made at strstart + 258.
  1255|          */
  1256|         do {
  1257|         } while (*++scan == *++match && *++scan == *++match &&
  1258|                  *++scan == *++match && *++scan == *++match &&
  1259|                  *++scan == *++match && *++scan == *++match &&
  1260|                  *++scan == *++match && *++scan == *++match &&
  1261|                  scan < strend);
  1262|         Assert(scan <= s->window + (unsigned)(s->window_size - 1),
  1263|                "wild scan");
  1264|         len = MAX_MATCH - (int)(strend - scan);
  1265|         scan = strend - MAX_MATCH;
  1266| #endif /* UNALIGNED_OK */
  1267|         if (len > best_len) {
  1268|             s->match_start = cur_match;
  1269|             best_len = len;
  1270|             if (len >= nice_match) break;
  1271| #ifdef UNALIGNED_OK
  1272|             scan_end = *(ushf*)(scan + best_len - 1);
  1273| #else
  1274|             scan_end1  = scan[best_len - 1];
  1275|             scan_end   = scan[best_len];
  1276| #endif
  1277|         }
  1278|     } while ((cur_match = prev[cur_match & wmask]) > limit
  1279|              && --chain_length != 0);
  1280|     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
  1281|     return s->lookahead;
  1282| }
  1283| #else /* FASTEST */
  1284| /* ---------------------------------------------------------------------------
  1285|  * Optimized version for FASTEST only
  1286|  */
  1287| local uInt longest_match(s, cur_match)
  1288|     deflate_state *s;
  1289|     IPos cur_match;                             /* current match */
  1290| {
  1291|     register Bytef *scan = s->window + s->strstart; /* current string */
  1292|     register Bytef *match;                       /* matched string */
  1293|     register int len;                           /* length of current match */
  1294|     register Bytef *strend = s->window + s->strstart + MAX_MATCH;
  1295|     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
  1296|      * It is easy to get rid of this optimization if necessary.
  1297|      */
  1298|     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
  1299|     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  1300|            "need lookahead");
  1301|     Assert(cur_match < s->strstart, "no future");
  1302|     match = s->window + cur_match;
  1303|     /* Return failure if the match length is less than 2:
  1304|      */
  1305|     if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
  1306|     /* The check at best_len - 1 can be removed because it will be made
  1307|      * again later. (This heuristic is not always a win.)
  1308|      * It is not necessary to compare scan[2] and match[2] since they
  1309|      * are always equal when the other bytes match, given that
  1310|      * the hash keys are equal and that HASH_BITS >= 8.
  1311|      */
  1312|     scan += 2, match += 2;
  1313|     Assert(*scan == *match, "match[2]?");
  1314|     /* We check for insufficient lookahead only every 8th comparison;
  1315|      * the 256th check will be made at strstart + 258.
  1316|      */
  1317|     do {
  1318|     } while (*++scan == *++match && *++scan == *++match &&
  1319|              *++scan == *++match && *++scan == *++match &&
  1320|              *++scan == *++match && *++scan == *++match &&
  1321|              *++scan == *++match && *++scan == *++match &&
  1322|              scan < strend);
  1323|     Assert(scan <= s->window + (unsigned)(s->window_size - 1), "wild scan");
  1324|     len = MAX_MATCH - (int)(strend - scan);
  1325|     if (len < MIN_MATCH) return MIN_MATCH - 1;
  1326|     s->match_start = cur_match;
  1327|     return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
  1328| }
  1329| #endif /* FASTEST */
  1330| #ifdef ZLIB_DEBUG
  1331| #define EQUAL 0
  1332| /* result of memcmp for equal strings */
  1333| /* ===========================================================================
  1334|  * Check that the match at match_start is indeed a match.
  1335|  */
  1336| local void check_match(s, start, match, length)
  1337|     deflate_state *s;
  1338|     IPos start, match;
  1339|     int length;
  1340| {
  1341|     /* check that the match is indeed a match */
  1342|     if (zmemcmp(s->window + match,
  1343|                 s->window + start, length) != EQUAL) {
  1344|         fprintf(stderr, " start %u, match %u, length %d\n",
  1345|                 start, match, length);
  1346|         do {
  1347|             fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
  1348|         } while (--length != 0);
  1349|         z_error("invalid match");
  1350|     }
  1351|     if (z_verbose > 1) {
  1352|         fprintf(stderr,"\\[%d,%d]", start - match, length);
  1353|         do { putc(s->window[start++], stderr); } while (--length != 0);
  1354|     }
  1355| }
  1356| #else
  1357| #  define check_match(s, start, match, length)
  1358| #endif /* ZLIB_DEBUG */
  1359| /* ===========================================================================
  1360|  * Fill the window when the lookahead becomes insufficient.
  1361|  * Updates strstart and lookahead.
  1362|  *
  1363|  * IN assertion: lookahead < MIN_LOOKAHEAD
  1364|  * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
  1365|  *    At least one byte has been read, or avail_in == 0; reads are
  1366|  *    performed for at least two bytes (required for the zip translate_eol
  1367|  *    option -- not supported here).
  1368|  */
  1369| local void fill_window(s)
  1370|     deflate_state *s;
  1371| {
  1372|     unsigned n;
  1373|     unsigned more;    /* Amount of free space at the end of the window. */
  1374|     uInt wsize = s->w_size;
  1375|     Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");
  1376|     do {
  1377|         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
  1378|         /* Deal with !@#$% 64K limit: */
  1379|         if (sizeof(int) <= 2) {
  1380|             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
  1381|                 more = wsize;
  1382|             } else if (more == (unsigned)(-1)) {
  1383|                 /* Very unlikely, but possible on 16 bit machine if
  1384|                  * strstart == 0 && lookahead == 1 (input done a byte at time)
  1385|                  */
  1386|                 more--;
  1387|             }
  1388|         }
  1389|         /* If the window is almost full and there is insufficient lookahead,
  1390|          * move the upper half to the lower one to make room in the upper half.
  1391|          */
  1392|         if (s->strstart >= wsize + MAX_DIST(s)) {
  1393|             zmemcpy(s->window, s->window + wsize, (unsigned)wsize - more);
  1394|             s->match_start -= wsize;
  1395|             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
  1396|             s->block_start -= (long) wsize;
  1397|             if (s->insert > s->strstart)
  1398|                 s->insert = s->strstart;
  1399|             slide_hash(s);
  1400|             more += wsize;
  1401|         }
  1402|         if (s->strm->avail_in == 0) break;
  1403|         /* If there was no sliding:
  1404|          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
  1405|          *    more == window_size - lookahead - strstart
  1406|          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
  1407|          * => more >= window_size - 2*WSIZE + 2
  1408|          * In the BIG_MEM or MMAP case (not yet supported),
  1409|          *   window_size == input_size + MIN_LOOKAHEAD  &&
  1410|          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
  1411|          * Otherwise, window_size == 2*WSIZE so more >= 2.
  1412|          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
  1413|          */
  1414|         Assert(more >= 2, "more < 2");
  1415|         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
  1416|         s->lookahead += n;
  1417|         /* Initialize the hash value now that we have some input: */
  1418|         if (s->lookahead + s->insert >= MIN_MATCH) {
  1419|             uInt str = s->strstart - s->insert;
  1420|             s->ins_h = s->window[str];
  1421|             UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
  1422| #if MIN_MATCH != 3
  1423|             Call UPDATE_HASH() MIN_MATCH-3 more times
  1424| #endif
  1425|             while (s->insert) {
  1426|                 UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
  1427| #ifndef FASTEST
  1428|                 s->prev[str & s->w_mask] = s->head[s->ins_h];
  1429| #endif
  1430|                 s->head[s->ins_h] = (Pos)str;
  1431|                 str++;
  1432|                 s->insert--;
  1433|                 if (s->lookahead + s->insert < MIN_MATCH)
  1434|                     break;
  1435|             }
  1436|         }
  1437|         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
  1438|          * but this is not important since only literal bytes will be emitted.
  1439|          */
  1440|     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
  1441|     /* If the WIN_INIT bytes after the end of the current data have never been
  1442|      * written, then zero those bytes in order to avoid memory check reports of
  1443|      * the use of uninitialized (or uninitialised as Julian writes) bytes by
  1444|      * the longest match routines.  Update the high water mark for the next
  1445|      * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
  1446|      * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
  1447|      */
  1448|     if (s->high_water < s->window_size) {
  1449|         ulg curr = s->strstart + (ulg)(s->lookahead);
  1450|         ulg init;
  1451|         if (s->high_water < curr) {
  1452|             /* Previous high water mark below current data -- zero WIN_INIT
  1453|              * bytes or up to end of window, whichever is less.
  1454|              */
  1455|             init = s->window_size - curr;
  1456|             if (init > WIN_INIT)
  1457|                 init = WIN_INIT;
  1458|             zmemzero(s->window + curr, (unsigned)init);
  1459|             s->high_water = curr + init;
  1460|         }
  1461|         else if (s->high_water < (ulg)curr + WIN_INIT) {
  1462|             /* High water mark at or above current data, but below current data
  1463|              * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  1464|              * to end of window, whichever is less.
  1465|              */
  1466|             init = (ulg)curr + WIN_INIT - s->high_water;
  1467|             if (init > s->window_size - s->high_water)
  1468|                 init = s->window_size - s->high_water;
  1469|             zmemzero(s->window + s->high_water, (unsigned)init);
  1470|             s->high_water += init;
  1471|         }
  1472|     }
  1473|     Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  1474|            "not enough room for search");
  1475| }
  1476| /* ===========================================================================
  1477|  * Flush the current block, with given end-of-file flag.
  1478|  * IN assertion: strstart is set to the end of the current match.
  1479|  */
  1480| #define FLUSH_BLOCK_ONLY(s, last) { \
  1481|    _tr_flush_block(s, (s->block_start >= 0L ? \
  1482|                    (charf *)&s->window[(unsigned)s->block_start] : \
  1483|                    (charf *)Z_NULL), \
  1484|                 (ulg)((long)s->strstart - s->block_start), \
  1485|                 (last)); \
  1486|    s->block_start = s->strstart; \
  1487|    flush_pending(s->strm); \
  1488|    Tracev((stderr,"[FLUSH]")); \
  1489| }
  1490| /* Same but force premature exit if necessary. */
  1491| #define FLUSH_BLOCK(s, last) { \
  1492|    FLUSH_BLOCK_ONLY(s, last); \
  1493|    if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
  1494| }
  1495| /* Maximum stored block length in deflate format (not including header). */
  1496| #define MAX_STORED 65535
  1497| /* Minimum of a and b. */
  1498| #define MIN(a, b) ((a) > (b) ? (b) : (a))
  1499| /* ===========================================================================
  1500|  * Copy without compression as much as possible from the input stream, return
  1501|  * the current block state.
  1502|  *
  1503|  * In case deflateParams() is used to later switch to a non-zero compression
  1504|  * level, s->matches (otherwise unused when storing) keeps track of the number
  1505|  * of hash table slides to perform. If s->matches is 1, then one hash table
  1506|  * slide will be done when switching. If s->matches is 2, the maximum value
  1507|  * allowed here, then the hash table will be cleared, since two or more slides
  1508|  * is the same as a clear.
  1509|  *
  1510|  * deflate_stored() is written to minimize the number of times an input byte is
  1511|  * copied. It is most efficient with large input and output buffers, which
  1512|  * maximizes the opportunities to have a single copy from next_in to next_out.
  1513|  */
  1514| local block_state deflate_stored(s, flush)
  1515|     deflate_state *s;
  1516|     int flush;
  1517| {
  1518|     /* Smallest worthy block size when not flushing or finishing. By default
  1519|      * this is 32K. This can be as small as 507 bytes for memLevel == 1. For
  1520|      * large input and output buffers, the stored block size will be larger.
  1521|      */
  1522|     unsigned min_block = MIN(s->pending_buf_size - 5, s->w_size);
  1523|     /* Copy as many min_block or larger stored blocks directly to next_out as
  1524|      * possible. If flushing, copy the remaining available input to next_out as
  1525|      * stored blocks, if there is enough space.
  1526|      */
  1527|     unsigned len, left, have, last = 0;
  1528|     unsigned used = s->strm->avail_in;
  1529|     do {
  1530|         /* Set len to the maximum size block that we can copy directly with the
  1531|          * available input data and output space. Set left to how much of that
  1532|          * would be copied from what's left in the window.
  1533|          */
  1534|         len = MAX_STORED;       /* maximum deflate stored block length */
  1535|         have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
  1536|         if (s->strm->avail_out < have)          /* need room for header */
  1537|             break;
  1538|             /* maximum stored block length that will fit in avail_out: */
  1539|         have = s->strm->avail_out - have;
  1540|         left = s->strstart - s->block_start;    /* bytes left in window */
  1541|         if (len > (ulg)left + s->strm->avail_in)
  1542|             len = left + s->strm->avail_in;     /* limit len to the input */
  1543|         if (len > have)
  1544|             len = have;                         /* limit len to the output */
  1545|         /* If the stored block would be less than min_block in length, or if
  1546|          * unable to copy all of the available input when flushing, then try
  1547|          * copying to the window and the pending buffer instead. Also don't
  1548|          * write an empty block when flushing -- deflate() does that.
  1549|          */
  1550|         if (len < min_block && ((len == 0 && flush != Z_FINISH) ||
  1551|                                 flush == Z_NO_FLUSH ||
  1552|                                 len != left + s->strm->avail_in))
  1553|             break;
  1554|         /* Make a dummy stored block in pending to get the header bytes,
  1555|          * including any pending bits. This also updates the debugging counts.
  1556|          */
  1557|         last = flush == Z_FINISH && len == left + s->strm->avail_in ? 1 : 0;
  1558|         _tr_stored_block(s, (char *)0, 0L, last);
  1559|         /* Replace the lengths in the dummy stored block with len. */
  1560|         s->pending_buf[s->pending - 4] = len;
  1561|         s->pending_buf[s->pending - 3] = len >> 8;
  1562|         s->pending_buf[s->pending - 2] = ~len;
  1563|         s->pending_buf[s->pending - 1] = ~len >> 8;
  1564|         /* Write the stored block header bytes. */
  1565|         flush_pending(s->strm);
  1566| #ifdef ZLIB_DEBUG
  1567|         /* Update debugging counts for the data about to be copied. */
  1568|         s->compressed_len += len << 3;
  1569|         s->bits_sent += len << 3;
  1570| #endif
  1571|         /* Copy uncompressed bytes from the window to next_out. */
  1572|         if (left) {
  1573|             if (left > len)
  1574|                 left = len;
  1575|             zmemcpy(s->strm->next_out, s->window + s->block_start, left);
  1576|             s->strm->next_out += left;
  1577|             s->strm->avail_out -= left;
  1578|             s->strm->total_out += left;
  1579|             s->block_start += left;
  1580|             len -= left;
  1581|         }
  1582|         /* Copy uncompressed bytes directly from next_in to next_out, updating
  1583|          * the check value.
  1584|          */
  1585|         if (len) {
  1586|             read_buf(s->strm, s->strm->next_out, len);
  1587|             s->strm->next_out += len;
  1588|             s->strm->avail_out -= len;
  1589|             s->strm->total_out += len;
  1590|         }
  1591|     } while (last == 0);
  1592|     /* Update the sliding window with the last s->w_size bytes of the copied
  1593|      * data, or append all of the copied data to the existing window if less
  1594|      * than s->w_size bytes were copied. Also update the number of bytes to
  1595|      * insert in the hash tables, in the event that deflateParams() switches to
  1596|      * a non-zero compression level.
  1597|      */
  1598|     used -= s->strm->avail_in;      /* number of input bytes directly copied */
  1599|     if (used) {
  1600|         /* If any input was used, then no unused input remains in the window,
  1601|          * therefore s->block_start == s->strstart.
  1602|          */
  1603|         if (used >= s->w_size) {    /* supplant the previous history */
  1604|             s->matches = 2;         /* clear hash */
  1605|             zmemcpy(s->window, s->strm->next_in - s->w_size, s->w_size);
  1606|             s->strstart = s->w_size;
  1607|             s->insert = s->strstart;
  1608|         }
  1609|         else {
  1610|             if (s->window_size - s->strstart <= used) {
  1611|                 /* Slide the window down. */
  1612|                 s->strstart -= s->w_size;
  1613|                 zmemcpy(s->window, s->window + s->w_size, s->strstart);
  1614|                 if (s->matches < 2)
  1615|                     s->matches++;   /* add a pending slide_hash() */
  1616|                 if (s->insert > s->strstart)
  1617|                     s->insert = s->strstart;
  1618|             }
  1619|             zmemcpy(s->window + s->strstart, s->strm->next_in - used, used);
  1620|             s->strstart += used;
  1621|             s->insert += MIN(used, s->w_size - s->insert);
  1622|         }
  1623|         s->block_start = s->strstart;
  1624|     }
  1625|     if (s->high_water < s->strstart)
  1626|         s->high_water = s->strstart;
  1627|     /* If the last block was written to next_out, then done. */
  1628|     if (last)
  1629|         return finish_done;
  1630|     /* If flushing and all input has been consumed, then done. */
  1631|     if (flush != Z_NO_FLUSH && flush != Z_FINISH &&
  1632|         s->strm->avail_in == 0 && (long)s->strstart == s->block_start)
  1633|         return block_done;
  1634|     /* Fill the window with any remaining input. */
  1635|     have = s->window_size - s->strstart;
  1636|     if (s->strm->avail_in > have && s->block_start >= (long)s->w_size) {
  1637|         /* Slide the window down. */
  1638|         s->block_start -= s->w_size;
  1639|         s->strstart -= s->w_size;
  1640|         zmemcpy(s->window, s->window + s->w_size, s->strstart);
  1641|         if (s->matches < 2)
  1642|             s->matches++;           /* add a pending slide_hash() */
  1643|         have += s->w_size;          /* more space now */
  1644|         if (s->insert > s->strstart)
  1645|             s->insert = s->strstart;
  1646|     }
  1647|     if (have > s->strm->avail_in)
  1648|         have = s->strm->avail_in;
  1649|     if (have) {
  1650|         read_buf(s->strm, s->window + s->strstart, have);
  1651|         s->strstart += have;
  1652|         s->insert += MIN(have, s->w_size - s->insert);
  1653|     }
  1654|     if (s->high_water < s->strstart)
  1655|         s->high_water = s->strstart;
  1656|     /* There was not enough avail_out to write a complete worthy or flushed
  1657|      * stored block to next_out. Write a stored block to pending instead, if we
  1658|      * have enough input for a worthy block, or if flushing and there is enough
  1659|      * room for the remaining input as a stored block in the pending buffer.
  1660|      */
  1661|     have = (s->bi_valid + 42) >> 3;         /* number of header bytes */
  1662|         /* maximum stored block length that will fit in pending: */
  1663|     have = MIN(s->pending_buf_size - have, MAX_STORED);
  1664|     min_block = MIN(have, s->w_size);
  1665|     left = s->strstart - s->block_start;
  1666|     if (left >= min_block ||
  1667|         ((left || flush == Z_FINISH) && flush != Z_NO_FLUSH &&
  1668|          s->strm->avail_in == 0 && left <= have)) {
  1669|         len = MIN(left, have);
  1670|         last = flush == Z_FINISH && s->strm->avail_in == 0 &&
  1671|                len == left ? 1 : 0;
  1672|         _tr_stored_block(s, (charf *)s->window + s->block_start, len, last);
  1673|         s->block_start += len;
  1674|         flush_pending(s->strm);
  1675|     }
  1676|     /* We've done all we can with the available input and output. */
  1677|     return last ? finish_started : need_more;
  1678| }
  1679| /* ===========================================================================
  1680|  * Compress as much as possible from the input stream, return the current
  1681|  * block state.
  1682|  * This function does not perform lazy evaluation of matches and inserts
  1683|  * new strings in the dictionary only for unmatched strings or for short
  1684|  * matches. It is used only for the fast compression options.
  1685|  */
  1686| local block_state deflate_fast(s, flush)
  1687|     deflate_state *s;
  1688|     int flush;
  1689| {
  1690|     IPos hash_head;       /* head of the hash chain */
  1691|     int bflush;           /* set if current block must be flushed */
  1692|     for (;;) {
  1693|         /* Make sure that we always have enough lookahead, except
  1694|          * at the end of the input file. We need MAX_MATCH bytes
  1695|          * for the next match, plus MIN_MATCH bytes to insert the
  1696|          * string following the next match.
  1697|          */
  1698|         if (s->lookahead < MIN_LOOKAHEAD) {
  1699|             fill_window(s);
  1700|             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
  1701|                 return need_more;
  1702|             }
  1703|             if (s->lookahead == 0) break; /* flush the current block */
  1704|         }
  1705|         /* Insert the string window[strstart .. strstart + 2] in the
  1706|          * dictionary, and set hash_head to the head of the hash chain:
  1707|          */
  1708|         hash_head = NIL;
  1709|         if (s->lookahead >= MIN_MATCH) {
  1710|             INSERT_STRING(s, s->strstart, hash_head);
  1711|         }
  1712|         /* Find the longest match, discarding those <= prev_length.
  1713|          * At this point we have always match_length < MIN_MATCH
  1714|          */
  1715|         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
  1716|             /* To simplify the code, we prevent matches with the string
  1717|              * of window index 0 (in particular we have to avoid a match
  1718|              * of the string with itself at the start of the input file).
  1719|              */
  1720|             s->match_length = longest_match (s, hash_head);
  1721|             /* longest_match() sets match_start */
  1722|         }
  1723|         if (s->match_length >= MIN_MATCH) {
  1724|             check_match(s, s->strstart, s->match_start, s->match_length);
  1725|             _tr_tally_dist(s, s->strstart - s->match_start,
  1726|                            s->match_length - MIN_MATCH, bflush);
  1727|             s->lookahead -= s->match_length;
  1728|             /* Insert new strings in the hash table only if the match length
  1729|              * is not too large. This saves time but degrades compression.
  1730|              */
  1731| #ifndef FASTEST
  1732|             if (s->match_length <= s->max_insert_length &&
  1733|                 s->lookahead >= MIN_MATCH) {
  1734|                 s->match_length--; /* string at strstart already in table */
  1735|                 do {
  1736|                     s->strstart++;
  1737|                     INSERT_STRING(s, s->strstart, hash_head);
  1738|                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
  1739|                      * always MIN_MATCH bytes ahead.
  1740|                      */
  1741|                 } while (--s->match_length != 0);
  1742|                 s->strstart++;
  1743|             } else
  1744| #endif
  1745|             {
  1746|                 s->strstart += s->match_length;
  1747|                 s->match_length = 0;
  1748|                 s->ins_h = s->window[s->strstart];
  1749|                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart + 1]);
  1750| #if MIN_MATCH != 3
  1751|                 Call UPDATE_HASH() MIN_MATCH-3 more times
  1752| #endif
  1753|                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
  1754|                  * matter since it will be recomputed at next deflate call.
  1755|                  */
  1756|             }
  1757|         } else {
  1758|             /* No match, output a literal byte */
  1759|             Tracevv((stderr,"%c", s->window[s->strstart]));
  1760|             _tr_tally_lit(s, s->window[s->strstart], bflush);
  1761|             s->lookahead--;
  1762|             s->strstart++;
  1763|         }
  1764|         if (bflush) FLUSH_BLOCK(s, 0);
  1765|     }
  1766|     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
  1767|     if (flush == Z_FINISH) {
  1768|         FLUSH_BLOCK(s, 1);
  1769|         return finish_done;
  1770|     }
  1771|     if (s->sym_next)
  1772|         FLUSH_BLOCK(s, 0);
  1773|     return block_done;
  1774| }
  1775| #ifndef FASTEST
  1776| /* ===========================================================================
  1777|  * Same as above, but achieves better compression. We use a lazy
  1778|  * evaluation for matches: a match is finally adopted only if there is
  1779|  * no better match at the next window position.
  1780|  */
  1781| local block_state deflate_slow(s, flush)
  1782|     deflate_state *s;
  1783|     int flush;
  1784| {
  1785|     IPos hash_head;          /* head of hash chain */
  1786|     int bflush;              /* set if current block must be flushed */
  1787|     /* Process the input block. */
  1788|     for (;;) {
  1789|         /* Make sure that we always have enough lookahead, except
  1790|          * at the end of the input file. We need MAX_MATCH bytes
  1791|          * for the next match, plus MIN_MATCH bytes to insert the
  1792|          * string following the next match.
  1793|          */
  1794|         if (s->lookahead < MIN_LOOKAHEAD) {
  1795|             fill_window(s);
  1796|             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
  1797|                 return need_more;
  1798|             }
  1799|             if (s->lookahead == 0) break; /* flush the current block */
  1800|         }
  1801|         /* Insert the string window[strstart .. strstart + 2] in the
  1802|          * dictionary, and set hash_head to the head of the hash chain:
  1803|          */
  1804|         hash_head = NIL;
  1805|         if (s->lookahead >= MIN_MATCH) {
  1806|             INSERT_STRING(s, s->strstart, hash_head);
  1807|         }
  1808|         /* Find the longest match, discarding those <= prev_length.
  1809|          */
  1810|         s->prev_length = s->match_length, s->prev_match = s->match_start;
  1811|         s->match_length = MIN_MATCH-1;
  1812|         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
  1813|             s->strstart - hash_head <= MAX_DIST(s)) {
  1814|             /* To simplify the code, we prevent matches with the string
  1815|              * of window index 0 (in particular we have to avoid a match
  1816|              * of the string with itself at the start of the input file).
  1817|              */
  1818|             s->match_length = longest_match (s, hash_head);
  1819|             /* longest_match() sets match_start */
  1820|             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
  1821| #if TOO_FAR <= 32767
  1822|                 || (s->match_length == MIN_MATCH &&
  1823|                     s->strstart - s->match_start > TOO_FAR)
  1824| #endif
  1825|                 )) {
  1826|                 /* If prev_match is also MIN_MATCH, match_start is garbage
  1827|                  * but we will ignore the current match anyway.
  1828|                  */
  1829|                 s->match_length = MIN_MATCH-1;
  1830|             }
  1831|         }
  1832|         /* If there was a match at the previous step and the current
  1833|          * match is not better, output the previous match:
  1834|          */
  1835|         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
  1836|             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
  1837|             /* Do not insert strings in hash table beyond this. */
  1838|             check_match(s, s->strstart - 1, s->prev_match, s->prev_length);
  1839|             _tr_tally_dist(s, s->strstart - 1 - s->prev_match,
  1840|                            s->prev_length - MIN_MATCH, bflush);
  1841|             /* Insert in hash table all strings up to the end of the match.
  1842|              * strstart - 1 and strstart are already inserted. If there is not
  1843|              * enough lookahead, the last two strings are not inserted in
  1844|              * the hash table.
  1845|              */
  1846|             s->lookahead -= s->prev_length - 1;
  1847|             s->prev_length -= 2;
  1848|             do {
  1849|                 if (++s->strstart <= max_insert) {
  1850|                     INSERT_STRING(s, s->strstart, hash_head);
  1851|                 }
  1852|             } while (--s->prev_length != 0);
  1853|             s->match_available = 0;
  1854|             s->match_length = MIN_MATCH-1;
  1855|             s->strstart++;
  1856|             if (bflush) FLUSH_BLOCK(s, 0);
  1857|         } else if (s->match_available) {
  1858|             /* If there was no match at the previous position, output a
  1859|              * single literal. If there was a match but the current match
  1860|              * is longer, truncate the previous match to a single literal.
  1861|              */
  1862|             Tracevv((stderr,"%c", s->window[s->strstart - 1]));
  1863|             _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
  1864|             if (bflush) {
  1865|                 FLUSH_BLOCK_ONLY(s, 0);
  1866|             }
  1867|             s->strstart++;
  1868|             s->lookahead--;
  1869|             if (s->strm->avail_out == 0) return need_more;
  1870|         } else {
  1871|             /* There is no previous match to compare with, wait for
  1872|              * the next step to decide.
  1873|              */
  1874|             s->match_available = 1;
  1875|             s->strstart++;
  1876|             s->lookahead--;
  1877|         }
  1878|     }
  1879|     Assert (flush != Z_NO_FLUSH, "no flush?");
  1880|     if (s->match_available) {
  1881|         Tracevv((stderr,"%c", s->window[s->strstart - 1]));
  1882|         _tr_tally_lit(s, s->window[s->strstart - 1], bflush);
  1883|         s->match_available = 0;
  1884|     }
  1885|     s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
  1886|     if (flush == Z_FINISH) {
  1887|         FLUSH_BLOCK(s, 1);
  1888|         return finish_done;
  1889|     }
  1890|     if (s->sym_next)
  1891|         FLUSH_BLOCK(s, 0);
  1892|     return block_done;
  1893| }
  1894| #endif /* FASTEST */
  1895| /* ===========================================================================
  1896|  * For Z_RLE, simply look for runs of bytes, generate matches only of distance
  1897|  * one.  Do not maintain a hash table.  (It will be regenerated if this run of
  1898|  * deflate switches away from Z_RLE.)
  1899|  */
  1900| local block_state deflate_rle(s, flush)
  1901|     deflate_state *s;
  1902|     int flush;
  1903| {
  1904|     int bflush;             /* set if current block must be flushed */
  1905|     uInt prev;              /* byte at distance one to match */
  1906|     Bytef *scan, *strend;   /* scan goes up to strend for length of run */
  1907|     for (;;) {
  1908|         /* Make sure that we always have enough lookahead, except
  1909|          * at the end of the input file. We need MAX_MATCH bytes
  1910|          * for the longest run, plus one for the unrolled loop.
  1911|          */
  1912|         if (s->lookahead <= MAX_MATCH) {
  1913|             fill_window(s);
  1914|             if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
  1915|                 return need_more;
  1916|             }
  1917|             if (s->lookahead == 0) break; /* flush the current block */
  1918|         }
  1919|         /* See how many times the previous byte repeats */
  1920|         s->match_length = 0;
  1921|         if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
  1922|             scan = s->window + s->strstart - 1;
  1923|             prev = *scan;
  1924|             if (prev == *++scan && prev == *++scan && prev == *++scan) {
  1925|                 strend = s->window + s->strstart + MAX_MATCH;
  1926|                 do {
  1927|                 } while (prev == *++scan && prev == *++scan &&
  1928|                          prev == *++scan && prev == *++scan &&
  1929|                          prev == *++scan && prev == *++scan &&
  1930|                          prev == *++scan && prev == *++scan &&
  1931|                          scan < strend);
  1932|                 s->match_length = MAX_MATCH - (uInt)(strend - scan);
  1933|                 if (s->match_length > s->lookahead)
  1934|                     s->match_length = s->lookahead;
  1935|             }
  1936|             Assert(scan <= s->window + (uInt)(s->window_size - 1),
  1937|                    "wild scan");
  1938|         }
  1939|         /* Emit match if have run of MIN_MATCH or longer, else emit literal */
  1940|         if (s->match_length >= MIN_MATCH) {
  1941|             check_match(s, s->strstart, s->strstart - 1, s->match_length);
  1942|             _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);
  1943|             s->lookahead -= s->match_length;
  1944|             s->strstart += s->match_length;
  1945|             s->match_length = 0;
  1946|         } else {
  1947|             /* No match, output a literal byte */
  1948|             Tracevv((stderr,"%c", s->window[s->strstart]));
  1949|             _tr_tally_lit(s, s->window[s->strstart], bflush);
  1950|             s->lookahead--;
  1951|             s->strstart++;
  1952|         }
  1953|         if (bflush) FLUSH_BLOCK(s, 0);
  1954|     }
  1955|     s->insert = 0;
  1956|     if (flush == Z_FINISH) {
  1957|         FLUSH_BLOCK(s, 1);
  1958|         return finish_done;
  1959|     }
  1960|     if (s->sym_next)
  1961|         FLUSH_BLOCK(s, 0);
  1962|     return block_done;
  1963| }
  1964| /* ===========================================================================
  1965|  * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
  1966|  * (It will be regenerated if this run of deflate switches away from Huffman.)
  1967|  */
  1968| local block_state deflate_huff(s, flush)
  1969|     deflate_state *s;
  1970|     int flush;
  1971| {
  1972|     int bflush;             /* set if current block must be flushed */
  1973|     for (;;) {
  1974|         /* Make sure that we have a literal to write. */
  1975|         if (s->lookahead == 0) {
  1976|             fill_window(s);
  1977|             if (s->lookahead == 0) {
  1978|                 if (flush == Z_NO_FLUSH)
  1979|                     return need_more;
  1980|                 break;      /* flush the current block */
  1981|             }
  1982|         }
  1983|         /* Output a literal byte */
  1984|         s->match_length = 0;
  1985|         Tracevv((stderr,"%c", s->window[s->strstart]));
  1986|         _tr_tally_lit(s, s->window[s->strstart], bflush);
  1987|         s->lookahead--;
  1988|         s->strstart++;
  1989|         if (bflush) FLUSH_BLOCK(s, 0);
  1990|     }
  1991|     s->insert = 0;
  1992|     if (flush == Z_FINISH) {
  1993|         FLUSH_BLOCK(s, 1);
  1994|         return finish_done;
  1995|     }
  1996|     if (s->sym_next)
  1997|         FLUSH_BLOCK(s, 0);
  1998|     return block_done;
  1999| }


# ====================================================================
# FILE: src/native/external/zlib/deflate.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-283 ---
     1| /* deflate.h -- internal compression state
     2|  * Copyright (C) 1995-2018 Jean-loup Gailly
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* WARNING: this file should *not* be used by applications. It is
     6|    part of the implementation of the compression library and is
     7|    subject to change. Applications should only use zlib.h.
     8|  */
     9| /* @(#) $Id$ */
    10| #ifndef DEFLATE_H
    11| #define DEFLATE_H
    12| #include "zutil.h"
    13| /* define NO_GZIP when compiling if you want to disable gzip header and
    14|    trailer creation by deflate().  NO_GZIP would be used to avoid linking in
    15|    the crc code when it is not needed.  For shared libraries, gzip encoding
    16|    should be left enabled. */
    17| #ifndef NO_GZIP
    18| #  define GZIP
    19| #endif
    20| /* ===========================================================================
    21|  * Internal compression state.
    22|  */
    23| #define LENGTH_CODES 29
    24| /* number of length codes, not counting the special END_BLOCK code */
    25| #define LITERALS  256
    26| /* number of literal bytes 0..255 */
    27| #define L_CODES (LITERALS+1+LENGTH_CODES)
    28| /* number of Literal or Length codes, including the END_BLOCK code */
    29| #define D_CODES   30
    30| /* number of distance codes */
    31| #define BL_CODES  19
    32| /* number of codes used to transfer the bit lengths */
    33| #define HEAP_SIZE (2*L_CODES+1)
    34| /* maximum heap size */
    35| #define MAX_BITS 15
    36| /* All codes must not exceed MAX_BITS bits */
    37| #define Buf_size 16
    38| /* size of bit buffer in bi_buf */
    39| #define INIT_STATE    42    /* zlib header -> BUSY_STATE */
    40| #ifdef GZIP
    41| #  define GZIP_STATE  57    /* gzip header -> BUSY_STATE | EXTRA_STATE */
    42| #endif
    43| #define EXTRA_STATE   69    /* gzip extra block -> NAME_STATE */
    44| #define NAME_STATE    73    /* gzip file name -> COMMENT_STATE */
    45| #define COMMENT_STATE 91    /* gzip comment -> HCRC_STATE */
    46| #define HCRC_STATE   103    /* gzip header CRC -> BUSY_STATE */
    47| #define BUSY_STATE   113    /* deflate -> FINISH_STATE */
    48| #define FINISH_STATE 666    /* stream complete */
    49| /* Stream status */
    50| /* Data structure describing a single value and its code string. */
    51| typedef struct ct_data_s {
    52|     union {
    53|         ush  freq;       /* frequency count */
    54|         ush  code;       /* bit string */
    55|     } fc;
    56|     union {
    57|         ush  dad;        /* father node in Huffman tree */
    58|         ush  len;        /* length of bit string */
    59|     } dl;
    60| } FAR ct_data;
    61| #define Freq fc.freq
    62| #define Code fc.code
    63| #define Dad  dl.dad
    64| #define Len  dl.len
    65| typedef struct static_tree_desc_s  static_tree_desc;
    66| typedef struct tree_desc_s {
    67|     ct_data *dyn_tree;           /* the dynamic tree */
    68|     int     max_code;            /* largest code with non zero frequency */
    69|     const static_tree_desc *stat_desc;  /* the corresponding static tree */
    70| } FAR tree_desc;
    71| typedef ush Pos;
    72| typedef Pos FAR Posf;
    73| typedef unsigned IPos;
    74| /* A Pos is an index in the character window. We use short instead of int to
    75|  * save space in the various tables. IPos is used only for parameter passing.
    76|  */
    77| typedef struct internal_state {
    78|     z_streamp strm;      /* pointer back to this zlib stream */
    79|     int   status;        /* as the name implies */
    80|     Bytef *pending_buf;  /* output still pending */
    81|     ulg   pending_buf_size; /* size of pending_buf */
    82|     Bytef *pending_out;  /* next pending byte to output to the stream */
    83|     ulg   pending;       /* nb of bytes in the pending buffer */
    84|     int   wrap;          /* bit 0 true for zlib, bit 1 true for gzip */
    85|     gz_headerp  gzhead;  /* gzip header information to write */
    86|     ulg   gzindex;       /* where in extra, name, or comment */
    87|     Byte  method;        /* can only be DEFLATED */
    88|     int   last_flush;    /* value of flush param for previous deflate call */
    89|                 /* used by deflate.c: */
    90|     uInt  w_size;        /* LZ77 window size (32K by default) */
    91|     uInt  w_bits;        /* log2(w_size)  (8..16) */
    92|     uInt  w_mask;        /* w_size - 1 */
    93|     Bytef *window;
    94|     /* Sliding window. Input bytes are read into the second half of the window,
    95|      * and move to the first half later to keep a dictionary of at least wSize
    96|      * bytes. With this organization, matches are limited to a distance of
    97|      * wSize-MAX_MATCH bytes, but this ensures that IO is always
    98|      * performed with a length multiple of the block size. Also, it limits
    99|      * the window size to 64K, which is quite useful on MSDOS.
   100|      * To do: use the user input buffer as sliding window.
   101|      */
   102|     ulg window_size;
   103|     /* Actual size of window: 2*wSize, except when the user input buffer
   104|      * is directly used as sliding window.
   105|      */
   106|     Posf *prev;
   107|     /* Link to older string with same hash index. To limit the size of this
   108|      * array to 64K, this link is maintained only for the last 32K strings.
   109|      * An index in this array is thus a window index modulo 32K.
   110|      */
   111|     Posf *head; /* Heads of the hash chains or NIL. */
   112|     uInt  ins_h;          /* hash index of string to be inserted */
   113|     uInt  hash_size;      /* number of elements in hash table */
   114|     uInt  hash_bits;      /* log2(hash_size) */
   115|     uInt  hash_mask;      /* hash_size-1 */
   116|     uInt  hash_shift;
   117|     /* Number of bits by which ins_h must be shifted at each input
   118|      * step. It must be such that after MIN_MATCH steps, the oldest
   119|      * byte no longer takes part in the hash key, that is:
   120|      *   hash_shift * MIN_MATCH >= hash_bits
   121|      */
   122|     long block_start;
   123|     /* Window position at the beginning of the current output block. Gets
   124|      * negative when the window is moved backwards.
   125|      */
   126|     uInt match_length;           /* length of best match */
   127|     IPos prev_match;             /* previous match */
   128|     int match_available;         /* set if previous match exists */
   129|     uInt strstart;               /* start of string to insert */
   130|     uInt match_start;            /* start of matching string */
   131|     uInt lookahead;              /* number of valid bytes ahead in window */
   132|     uInt prev_length;
   133|     /* Length of the best match at previous step. Matches not greater than this
   134|      * are discarded. This is used in the lazy match evaluation.
   135|      */
   136|     uInt max_chain_length;
   137|     /* To speed up deflation, hash chains are never searched beyond this
   138|      * length.  A higher limit improves compression ratio but degrades the
   139|      * speed.
   140|      */
   141|     uInt max_lazy_match;
   142|     /* Attempt to find a better match only when the current match is strictly
   143|      * smaller than this value. This mechanism is used only for compression
   144|      * levels >= 4.
   145|      */
   146| #   define max_insert_length  max_lazy_match
   147|     /* Insert new strings in the hash table only if the match length is not
   148|      * greater than this length. This saves time but degrades compression.
   149|      * max_insert_length is used only for compression levels <= 3.
   150|      */
   151|     int level;    /* compression level (1..9) */
   152|     int strategy; /* favor or force Huffman coding*/
   153|     uInt good_match;
   154|     /* Use a faster search when the previous match is longer than this */
   155|     int nice_match; /* Stop searching when current match exceeds this */
   156|                 /* used by trees.c: */
   157|     /* Didn't use ct_data typedef below to suppress compiler warning */
   158|     struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
   159|     struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
   160|     struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
   161|     struct tree_desc_s l_desc;               /* desc. for literal tree */
   162|     struct tree_desc_s d_desc;               /* desc. for distance tree */
   163|     struct tree_desc_s bl_desc;              /* desc. for bit length tree */
   164|     ush bl_count[MAX_BITS+1];
   165|     /* number of codes at each bit length for an optimal tree */
   166|     int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
   167|     int heap_len;               /* number of elements in the heap */
   168|     int heap_max;               /* element of largest frequency */
   169|     /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   170|      * The same heap array is used to build all trees.
   171|      */
   172|     uch depth[2*L_CODES+1];
   173|     /* Depth of each subtree used as tie breaker for trees of equal frequency
   174|      */
   175|     uchf *sym_buf;        /* buffer for distances and literals/lengths */
   176|     uInt  lit_bufsize;
   177|     /* Size of match buffer for literals/lengths.  There are 4 reasons for
   178|      * limiting lit_bufsize to 64K:
   179|      *   - frequencies can be kept in 16 bit counters
   180|      *   - if compression is not successful for the first block, all input
   181|      *     data is still in the window so we can still emit a stored block even
   182|      *     when input comes from standard input.  (This can also be done for
   183|      *     all blocks if lit_bufsize is not greater than 32K.)
   184|      *   - if compression is not successful for a file smaller than 64K, we can
   185|      *     even emit a stored file instead of a stored block (saving 5 bytes).
   186|      *     This is applicable only for zip (not gzip or zlib).
   187|      *   - creating new Huffman trees less frequently may not provide fast
   188|      *     adaptation to changes in the input data statistics. (Take for
   189|      *     example a binary file with poorly compressible code followed by
   190|      *     a highly compressible string table.) Smaller buffer sizes give
   191|      *     fast adaptation but have of course the overhead of transmitting
   192|      *     trees more frequently.
   193|      *   - I can't count above 4
   194|      */
   195|     uInt sym_next;      /* running index in sym_buf */
   196|     uInt sym_end;       /* symbol table full when sym_next reaches this */
   197|     ulg opt_len;        /* bit length of current block with optimal trees */
   198|     ulg static_len;     /* bit length of current block with static trees */
   199|     uInt matches;       /* number of string matches in current block */
   200|     uInt insert;        /* bytes at end of window left to insert */
   201| #ifdef ZLIB_DEBUG
   202|     ulg compressed_len; /* total bit length of compressed file mod 2^32 */
   203|     ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
   204| #endif
   205|     ush bi_buf;
   206|     /* Output buffer. bits are inserted starting at the bottom (least
   207|      * significant bits).
   208|      */
   209|     int bi_valid;
   210|     /* Number of valid bits in bi_buf.  All bits above the last valid bit
   211|      * are always zero.
   212|      */
   213|     ulg high_water;
   214|     /* High water mark offset in window for initialized bytes -- bytes above
   215|      * this are set to zero in order to avoid memory check warnings when
   216|      * longest match routines access bytes past the input.  This is then
   217|      * updated to the new high water mark.
   218|      */
   219| } FAR deflate_state;
   220| /* Output a byte on the stream.
   221|  * IN assertion: there is enough room in pending_buf.
   222|  */
   223| #define put_byte(s, c) {s->pending_buf[s->pending++] = (Bytef)(c);}
   224| #define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
   225| /* Minimum amount of lookahead, except at the end of the input file.
   226|  * See deflate.c for comments about the MIN_MATCH+1.
   227|  */
   228| #define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
   229| /* In order to simplify the code, particularly on 16 bit machines, match
   230|  * distances are limited to MAX_DIST instead of WSIZE.
   231|  */
   232| #define WIN_INIT MAX_MATCH
   233| /* Number of bytes after end of data in window to initialize in order to avoid
   234|    memory checker errors from longest match routines */
   235|         /* in trees.c */
   236| void ZLIB_INTERNAL _tr_init OF((deflate_state *s));
   237| int ZLIB_INTERNAL _tr_tally OF((deflate_state *s, unsigned dist, unsigned lc));
   238| void ZLIB_INTERNAL _tr_flush_block OF((deflate_state *s, charf *buf,
   239|                         ulg stored_len, int last));
   240| void ZLIB_INTERNAL _tr_flush_bits OF((deflate_state *s));
   241| void ZLIB_INTERNAL _tr_align OF((deflate_state *s));
   242| void ZLIB_INTERNAL _tr_stored_block OF((deflate_state *s, charf *buf,
   243|                         ulg stored_len, int last));
   244| #define d_code(dist) \
   245|    ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
   246| /* Mapping from a distance to a distance code. dist is the distance - 1 and
   247|  * must not have side effects. _dist_code[256] and _dist_code[257] are never
   248|  * used.
   249|  */
   250| #ifndef ZLIB_DEBUG
   251| /* Inline versions of _tr_tally for speed: */
   252| #if defined(GEN_TREES_H) || !defined(STDC)
   253|   extern uch ZLIB_INTERNAL _length_code[];
   254|   extern uch ZLIB_INTERNAL _dist_code[];
   255| #else
   256|   extern const uch ZLIB_INTERNAL _length_code[];
   257|   extern const uch ZLIB_INTERNAL _dist_code[];
   258| #endif
   259| # define _tr_tally_lit(s, c, flush) \
   260|   { uch cc = (c); \
   261|     s->sym_buf[s->sym_next++] = 0; \
   262|     s->sym_buf[s->sym_next++] = 0; \
   263|     s->sym_buf[s->sym_next++] = cc; \
   264|     s->dyn_ltree[cc].Freq++; \
   265|     flush = (s->sym_next == s->sym_end); \
   266|    }
   267| # define _tr_tally_dist(s, distance, length, flush) \
   268|   { uch len = (uch)(length); \
   269|     ush dist = (ush)(distance); \
   270|     s->sym_buf[s->sym_next++] = (uch)dist; \
   271|     s->sym_buf[s->sym_next++] = (uch)(dist >> 8); \
   272|     s->sym_buf[s->sym_next++] = len; \
   273|     dist--; \
   274|     s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
   275|     s->dyn_dtree[d_code(dist)].Freq++; \
   276|     flush = (s->sym_next == s->sym_end); \
   277|   }
   278| #else
   279| # define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
   280| # define _tr_tally_dist(s, distance, length, flush) \
   281|               flush = _tr_tally(s, distance, length)
   282| #endif
   283| #endif /* DEFLATE_H */


# ====================================================================
# FILE: src/native/external/zlib/gzlib.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-564 ---
     1| /* gzlib.c -- zlib functions common to reading and writing gzip files
     2|  * Copyright (C) 2004-2019 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| #include "gzguts.h"
     6| #if defined(_WIN32) && !defined(__BORLANDC__)
     7| #  define LSEEK _lseeki64
     8| #else
     9| #if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
    10| #  define LSEEK lseek64
    11| #else
    12| #  define LSEEK lseek
    13| #endif
    14| #endif
    15| /* Local functions */
    16| local void gz_reset OF((gz_statep));
    17| local gzFile gz_open OF((const void *, int, const char *));
    18| #if defined UNDER_CE
    19| /* Map the Windows error number in ERROR to a locale-dependent error message
    20|    string and return a pointer to it.  Typically, the values for ERROR come
    21|    from GetLastError.
    22|    The string pointed to shall not be modified by the application, but may be
    23|    overwritten by a subsequent call to gz_strwinerror
    24|    The gz_strwinerror function does not change the current setting of
    25|    GetLastError. */
    26| char ZLIB_INTERNAL *gz_strwinerror(error)
    27|      DWORD error;
    28| {
    29|     static char buf[1024];
    30|     wchar_t *msgbuf;
    31|     DWORD lasterr = GetLastError();
    32|     DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
    33|         | FORMAT_MESSAGE_ALLOCATE_BUFFER,
    34|         NULL,
    35|         error,
    36|         0, /* Default language */
    37|         (LPVOID)&msgbuf,
    38|         0,
    39|         NULL);
    40|     if (chars != 0) {
    41|         /* If there is an \r\n appended, zap it.  */
    42|         if (chars >= 2
    43|             && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
    44|             chars -= 2;
    45|             msgbuf[chars] = 0;
    46|         }
    47|         if (chars > sizeof (buf) - 1) {
    48|             chars = sizeof (buf) - 1;
    49|             msgbuf[chars] = 0;
    50|         }
    51|         wcstombs(buf, msgbuf, chars + 1);
    52|         LocalFree(msgbuf);
    53|     }
    54|     else {
    55|         sprintf(buf, "unknown win32 error (%ld)", error);
    56|     }
    57|     SetLastError(lasterr);
    58|     return buf;
    59| }
    60| #endif /* UNDER_CE */
    61| /* Reset gzip file state */
    62| local void gz_reset(state)
    63|     gz_statep state;
    64| {
    65|     state->x.have = 0;              /* no output data available */
    66|     if (state->mode == GZ_READ) {   /* for reading ... */
    67|         state->eof = 0;             /* not at end of file */
    68|         state->past = 0;            /* have not read past end yet */
    69|         state->how = LOOK;          /* look for gzip header */
    70|     }
    71|     else                            /* for writing ... */
    72|         state->reset = 0;           /* no deflateReset pending */
    73|     state->seek = 0;                /* no seek request pending */
    74|     gz_error(state, Z_OK, NULL);    /* clear error */
    75|     state->x.pos = 0;               /* no uncompressed data yet */
    76|     state->strm.avail_in = 0;       /* no input data yet */
    77| }
    78| /* Open a gzip file either by name or file descriptor. */
    79| local gzFile gz_open(path, fd, mode)
    80|     const void *path;
    81|     int fd;
    82|     const char *mode;
    83| {
    84|     gz_statep state;
    85|     z_size_t len;
    86|     int oflag;
    87| #ifdef O_CLOEXEC
    88|     int cloexec = 0;
    89| #endif
    90| #ifdef O_EXCL
    91|     int exclusive = 0;
    92| #endif
    93|     /* check input */
    94|     if (path == NULL)
    95|         return NULL;
    96|     /* allocate gzFile structure to return */
    97|     state = (gz_statep)malloc(sizeof(gz_state));
    98|     if (state == NULL)
    99|         return NULL;
   100|     state->size = 0;            /* no buffers allocated yet */
   101|     state->want = GZBUFSIZE;    /* requested buffer size */
   102|     state->msg = NULL;          /* no error message yet */
   103|     /* interpret mode */
   104|     state->mode = GZ_NONE;
   105|     state->level = Z_DEFAULT_COMPRESSION;
   106|     state->strategy = Z_DEFAULT_STRATEGY;
   107|     state->direct = 0;
   108|     while (*mode) {
   109|         if (*mode >= '0' && *mode <= '9')
   110|             state->level = *mode - '0';
   111|         else
   112|             switch (*mode) {
   113|             case 'r':
   114|                 state->mode = GZ_READ;
   115|                 break;
   116| #ifndef NO_GZCOMPRESS
   117|             case 'w':
   118|                 state->mode = GZ_WRITE;
   119|                 break;
   120|             case 'a':
   121|                 state->mode = GZ_APPEND;
   122|                 break;
   123| #endif
   124|             case '+':       /* can't read and write at the same time */
   125|                 free(state);
   126|                 return NULL;
   127|             case 'b':       /* ignore -- will request binary anyway */
   128|                 break;
   129| #ifdef O_CLOEXEC
   130|             case 'e':
   131|                 cloexec = 1;
   132|                 break;
   133| #endif
   134| #ifdef O_EXCL
   135|             case 'x':
   136|                 exclusive = 1;
   137|                 break;
   138| #endif
   139|             case 'f':
   140|                 state->strategy = Z_FILTERED;
   141|                 break;
   142|             case 'h':
   143|                 state->strategy = Z_HUFFMAN_ONLY;
   144|                 break;
   145|             case 'R':
   146|                 state->strategy = Z_RLE;
   147|                 break;
   148|             case 'F':
   149|                 state->strategy = Z_FIXED;
   150|                 break;
   151|             case 'T':
   152|                 state->direct = 1;
   153|                 break;
   154|             default:        /* could consider as an error, but just ignore */
   155|                 ;
   156|             }
   157|         mode++;
   158|     }
   159|     /* must provide an "r", "w", or "a" */
   160|     if (state->mode == GZ_NONE) {
   161|         free(state);
   162|         return NULL;
   163|     }
   164|     /* can't force transparent read */
   165|     if (state->mode == GZ_READ) {
   166|         if (state->direct) {
   167|             free(state);
   168|             return NULL;
   169|         }
   170|         state->direct = 1;      /* for empty file */
   171|     }
   172|     /* save the path name for error messages */
   173| #ifdef WIDECHAR
   174|     if (fd == -2) {
   175|         len = wcstombs(NULL, path, 0);
   176|         if (len == (z_size_t)-1)
   177|             len = 0;
   178|     }
   179|     else
   180| #endif
   181|         len = strlen((const char *)path);
   182|     state->path = (char *)malloc(len + 1);
   183|     if (state->path == NULL) {
   184|         free(state);
   185|         return NULL;
   186|     }
   187| #ifdef WIDECHAR
   188|     if (fd == -2)
   189|         if (len)
   190|             wcstombs(state->path, path, len + 1);
   191|         else
   192|             *(state->path) = 0;
   193|     else
   194| #endif
   195| #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
   196|         (void)snprintf(state->path, len + 1, "%s", (const char *)path);
   197| #else
   198|         strcpy(state->path, path);
   199| #endif
   200|     /* compute the flags for open() */
   201|     oflag =
   202| #ifdef O_LARGEFILE
   203|         O_LARGEFILE |
   204| #endif
   205| #ifdef O_BINARY
   206|         O_BINARY |
   207| #endif
   208| #ifdef O_CLOEXEC
   209|         (cloexec ? O_CLOEXEC : 0) |
   210| #endif
   211|         (state->mode == GZ_READ ?
   212|          O_RDONLY :
   213|          (O_WRONLY | O_CREAT |
   214| #ifdef O_EXCL
   215|           (exclusive ? O_EXCL : 0) |
   216| #endif
   217|           (state->mode == GZ_WRITE ?
   218|            O_TRUNC :
   219|            O_APPEND)));
   220|     /* open the file with the appropriate flags (or just use fd) */
   221|     state->fd = fd > -1 ? fd : (
   222| #ifdef WIDECHAR
   223|         fd == -2 ? _wopen(path, oflag, 0666) :
   224| #endif
   225|         open((const char *)path, oflag, 0666));
   226|     if (state->fd == -1) {
   227|         free(state->path);
   228|         free(state);
   229|         return NULL;
   230|     }
   231|     if (state->mode == GZ_APPEND) {
   232|         LSEEK(state->fd, 0, SEEK_END);  /* so gzoffset() is correct */
   233|         state->mode = GZ_WRITE;         /* simplify later checks */
   234|     }
   235|     /* save the current position for rewinding (only if reading) */
   236|     if (state->mode == GZ_READ) {
   237|         state->start = LSEEK(state->fd, 0, SEEK_CUR);
   238|         if (state->start == -1) state->start = 0;
   239|     }
   240|     /* initialize stream */
   241|     gz_reset(state);
   242|     /* return stream */
   243|     return (gzFile)state;
   244| }
   245| /* -- see zlib.h -- */
   246| gzFile ZEXPORT gzopen(path, mode)
   247|     const char *path;
   248|     const char *mode;
   249| {
   250|     return gz_open(path, -1, mode);
   251| }
   252| /* -- see zlib.h -- */
   253| gzFile ZEXPORT gzopen64(path, mode)
   254|     const char *path;
   255|     const char *mode;
   256| {
   257|     return gz_open(path, -1, mode);
   258| }
   259| /* -- see zlib.h -- */
   260| gzFile ZEXPORT gzdopen(fd, mode)
   261|     int fd;
   262|     const char *mode;
   263| {
   264|     char *path;         /* identifier for error messages */
   265|     gzFile gz;
   266|     if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
   267|         return NULL;
   268| #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
   269|     (void)snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd);
   270| #else
   271|     sprintf(path, "<fd:%d>", fd);   /* for debugging */
   272| #endif
   273|     gz = gz_open(path, fd, mode);
   274|     free(path);
   275|     return gz;
   276| }
   277| /* -- see zlib.h -- */
   278| #ifdef WIDECHAR
   279| gzFile ZEXPORT gzopen_w(path, mode)
   280|     const wchar_t *path;
   281|     const char *mode;
   282| {
   283|     return gz_open(path, -2, mode);
   284| }
   285| #endif
   286| /* -- see zlib.h -- */
   287| int ZEXPORT gzbuffer(file, size)
   288|     gzFile file;
   289|     unsigned size;
   290| {
   291|     gz_statep state;
   292|     /* get internal structure and check integrity */
   293|     if (file == NULL)
   294|         return -1;
   295|     state = (gz_statep)file;
   296|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   297|         return -1;
   298|     /* make sure we haven't already allocated memory */
   299|     if (state->size != 0)
   300|         return -1;
   301|     /* check and set requested size */
   302|     if ((size << 1) < size)
   303|         return -1;              /* need to be able to double it */
   304|     if (size < 2)
   305|         size = 2;               /* need two bytes to check magic header */
   306|     state->want = size;
   307|     return 0;
   308| }
   309| /* -- see zlib.h -- */
   310| int ZEXPORT gzrewind(file)
   311|     gzFile file;
   312| {
   313|     gz_statep state;
   314|     /* get internal structure */
   315|     if (file == NULL)
   316|         return -1;
   317|     state = (gz_statep)file;
   318|     /* check that we're reading and that there's no error */
   319|     if (state->mode != GZ_READ ||
   320|             (state->err != Z_OK && state->err != Z_BUF_ERROR))
   321|         return -1;
   322|     /* back up and start over */
   323|     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
   324|         return -1;
   325|     gz_reset(state);
   326|     return 0;
   327| }
   328| /* -- see zlib.h -- */
   329| z_off64_t ZEXPORT gzseek64(file, offset, whence)
   330|     gzFile file;
   331|     z_off64_t offset;
   332|     int whence;
   333| {
   334|     unsigned n;
   335|     z_off64_t ret;
   336|     gz_statep state;
   337|     /* get internal structure and check integrity */
   338|     if (file == NULL)
   339|         return -1;
   340|     state = (gz_statep)file;
   341|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   342|         return -1;
   343|     /* check that there's no error */
   344|     if (state->err != Z_OK && state->err != Z_BUF_ERROR)
   345|         return -1;
   346|     /* can only seek from start or relative to current position */
   347|     if (whence != SEEK_SET && whence != SEEK_CUR)
   348|         return -1;
   349|     /* normalize offset to a SEEK_CUR specification */
   350|     if (whence == SEEK_SET)
   351|         offset -= state->x.pos;
   352|     else if (state->seek)
   353|         offset += state->skip;
   354|     state->seek = 0;
   355|     /* if within raw area while reading, just go there */
   356|     if (state->mode == GZ_READ && state->how == COPY &&
   357|             state->x.pos + offset >= 0) {
   358|         ret = LSEEK(state->fd, offset - (z_off64_t)state->x.have, SEEK_CUR);
   359|         if (ret == -1)
   360|             return -1;
   361|         state->x.have = 0;
   362|         state->eof = 0;
   363|         state->past = 0;
   364|         state->seek = 0;
   365|         gz_error(state, Z_OK, NULL);
   366|         state->strm.avail_in = 0;
   367|         state->x.pos += offset;
   368|         return state->x.pos;
   369|     }
   370|     /* calculate skip amount, rewinding if needed for back seek when reading */
   371|     if (offset < 0) {
   372|         if (state->mode != GZ_READ)         /* writing -- can't go backwards */
   373|             return -1;
   374|         offset += state->x.pos;
   375|         if (offset < 0)                     /* before start of file! */
   376|             return -1;
   377|         if (gzrewind(file) == -1)           /* rewind, then skip to offset */
   378|             return -1;
   379|     }
   380|     /* if reading, skip what's in output buffer (one less gzgetc() check) */
   381|     if (state->mode == GZ_READ) {
   382|         n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
   383|             (unsigned)offset : state->x.have;
   384|         state->x.have -= n;
   385|         state->x.next += n;
   386|         state->x.pos += n;
   387|         offset -= n;
   388|     }
   389|     /* request skip (if not zero) */
   390|     if (offset) {
   391|         state->seek = 1;
   392|         state->skip = offset;
   393|     }
   394|     return state->x.pos + offset;
   395| }
   396| /* -- see zlib.h -- */
   397| z_off_t ZEXPORT gzseek(file, offset, whence)
   398|     gzFile file;
   399|     z_off_t offset;
   400|     int whence;
   401| {
   402|     z_off64_t ret;
   403|     ret = gzseek64(file, (z_off64_t)offset, whence);
   404|     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
   405| }
   406| /* -- see zlib.h -- */
   407| z_off64_t ZEXPORT gztell64(file)
   408|     gzFile file;
   409| {
   410|     gz_statep state;
   411|     /* get internal structure and check integrity */
   412|     if (file == NULL)
   413|         return -1;
   414|     state = (gz_statep)file;
   415|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   416|         return -1;
   417|     /* return position */
   418|     return state->x.pos + (state->seek ? state->skip : 0);
   419| }
   420| /* -- see zlib.h -- */
   421| z_off_t ZEXPORT gztell(file)
   422|     gzFile file;
   423| {
   424|     z_off64_t ret;
   425|     ret = gztell64(file);
   426|     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
   427| }
   428| /* -- see zlib.h -- */
   429| z_off64_t ZEXPORT gzoffset64(file)
   430|     gzFile file;
   431| {
   432|     z_off64_t offset;
   433|     gz_statep state;
   434|     /* get internal structure and check integrity */
   435|     if (file == NULL)
   436|         return -1;
   437|     state = (gz_statep)file;
   438|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   439|         return -1;
   440|     /* compute and return effective offset in file */
   441|     offset = LSEEK(state->fd, 0, SEEK_CUR);
   442|     if (offset == -1)
   443|         return -1;
   444|     if (state->mode == GZ_READ)             /* reading */
   445|         offset -= state->strm.avail_in;     /* don't count buffered input */
   446|     return offset;
   447| }
   448| /* -- see zlib.h -- */
   449| z_off_t ZEXPORT gzoffset(file)
   450|     gzFile file;
   451| {
   452|     z_off64_t ret;
   453|     ret = gzoffset64(file);
   454|     return ret == (z_off_t)ret ? (z_off_t)ret : -1;
   455| }
   456| /* -- see zlib.h -- */
   457| int ZEXPORT gzeof(file)
   458|     gzFile file;
   459| {
   460|     gz_statep state;
   461|     /* get internal structure and check integrity */
   462|     if (file == NULL)
   463|         return 0;
   464|     state = (gz_statep)file;
   465|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   466|         return 0;
   467|     /* return end-of-file state */
   468|     return state->mode == GZ_READ ? state->past : 0;
   469| }
   470| /* -- see zlib.h -- */
   471| const char * ZEXPORT gzerror(file, errnum)
   472|     gzFile file;
   473|     int *errnum;
   474| {
   475|     gz_statep state;
   476|     /* get internal structure and check integrity */
   477|     if (file == NULL)
   478|         return NULL;
   479|     state = (gz_statep)file;
   480|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   481|         return NULL;
   482|     /* return error information */
   483|     if (errnum != NULL)
   484|         *errnum = state->err;
   485|     return state->err == Z_MEM_ERROR ? "out of memory" :
   486|                                        (state->msg == NULL ? "" : state->msg);
   487| }
   488| /* -- see zlib.h -- */
   489| void ZEXPORT gzclearerr(file)
   490|     gzFile file;
   491| {
   492|     gz_statep state;
   493|     /* get internal structure and check integrity */
   494|     if (file == NULL)
   495|         return;
   496|     state = (gz_statep)file;
   497|     if (state->mode != GZ_READ && state->mode != GZ_WRITE)
   498|         return;
   499|     /* clear error and end-of-file */
   500|     if (state->mode == GZ_READ) {
   501|         state->eof = 0;
   502|         state->past = 0;
   503|     }
   504|     gz_error(state, Z_OK, NULL);
   505| }
   506| /* Create an error message in allocated memory and set state->err and
   507|    state->msg accordingly.  Free any previous error message already there.  Do
   508|    not try to free or allocate space if the error is Z_MEM_ERROR (out of
   509|    memory).  Simply save the error message as a static string.  If there is an
   510|    allocation failure constructing the error message, then convert the error to
   511|    out of memory. */
   512| void ZLIB_INTERNAL gz_error(state, err, msg)
   513|     gz_statep state;
   514|     int err;
   515|     const char *msg;
   516| {
   517|     /* free previously allocated message and clear */
   518|     if (state->msg != NULL) {
   519|         if (state->err != Z_MEM_ERROR)
   520|             free(state->msg);
   521|         state->msg = NULL;
   522|     }
   523|     /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
   524|     if (err != Z_OK && err != Z_BUF_ERROR)
   525|         state->x.have = 0;
   526|     /* set error code, and if no message, then done */
   527|     state->err = err;
   528|     if (msg == NULL)
   529|         return;
   530|     /* for an out of memory error, return literal string when requested */
   531|     if (err == Z_MEM_ERROR)
   532|         return;
   533|     /* construct error message with path */
   534|     if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
   535|             NULL) {
   536|         state->err = Z_MEM_ERROR;
   537|         return;
   538|     }
   539| #if !defined(NO_snprintf) && !defined(NO_vsnprintf)
   540|     (void)snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
   541|                    "%s%s%s", state->path, ": ", msg);
   542| #else
   543|     strcpy(state->msg, state->path);
   544|     strcat(state->msg, ": ");
   545|     strcat(state->msg, msg);
   546| #endif
   547| }
   548| #ifndef INT_MAX
   549| /* portably return maximum value for an int (when limits.h presumed not
   550|    available) -- we need to do this to cover cases where 2's complement not
   551|    used, since C standard permits 1's complement and sign-bit representations,
   552|    otherwise we could just use ((unsigned)-1) >> 1 */
   553| unsigned ZLIB_INTERNAL gz_intmax()
   554| {
   555|     unsigned p, q;
   556|     p = 1;
   557|     do {
   558|         q = p;
   559|         p <<= 1;
   560|         p++;
   561|     } while (p > q);
   562|     return q >> 1;
   563| }
   564| #endif


# ====================================================================
# FILE: src/native/external/zlib/gzread.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-572 ---
     1| /* gzread.c -- zlib functions for reading gzip files
     2|  * Copyright (C) 2004-2017 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| #include "gzguts.h"
     6| /* Local functions */
     7| local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
     8| local int gz_avail OF((gz_statep));
     9| local int gz_look OF((gz_statep));
    10| local int gz_decomp OF((gz_statep));
    11| local int gz_fetch OF((gz_statep));
    12| local int gz_skip OF((gz_statep, z_off64_t));
    13| local z_size_t gz_read OF((gz_statep, voidp, z_size_t));
    14| /* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
    15|    state->fd, and update state->eof, state->err, and state->msg as appropriate.
    16|    This function needs to loop on read(), since read() is not guaranteed to
    17|    read the number of bytes requested, depending on the type of descriptor. */
    18| local int gz_load(state, buf, len, have)
    19|     gz_statep state;
    20|     unsigned char *buf;
    21|     unsigned len;
    22|     unsigned *have;
    23| {
    24|     int ret;
    25|     unsigned get, max = ((unsigned)-1 >> 2) + 1;
    26|     *have = 0;
    27|     do {
    28|         get = len - *have;
    29|         if (get > max)
    30|             get = max;
    31|         ret = read(state->fd, buf + *have, get);
    32|         if (ret <= 0)
    33|             break;
    34|         *have += (unsigned)ret;
    35|     } while (*have < len);
    36|     if (ret < 0) {
    37|         gz_error(state, Z_ERRNO, zstrerror());
    38|         return -1;
    39|     }
    40|     if (ret == 0)
    41|         state->eof = 1;
    42|     return 0;
    43| }
    44| /* Load up input buffer and set eof flag if last data loaded -- return -1 on
    45|    error, 0 otherwise.  Note that the eof flag is set when the end of the input
    46|    file is reached, even though there may be unused data in the buffer.  Once
    47|    that data has been used, no more attempts will be made to read the file.
    48|    If strm->avail_in != 0, then the current data is moved to the beginning of
    49|    the input buffer, and then the remainder of the buffer is loaded with the
    50|    available data from the input file. */
    51| local int gz_avail(state)
    52|     gz_statep state;
    53| {
    54|     unsigned got;
    55|     z_streamp strm = &(state->strm);
    56|     if (state->err != Z_OK && state->err != Z_BUF_ERROR)
    57|         return -1;
    58|     if (state->eof == 0) {
    59|         if (strm->avail_in) {       /* copy what's there to the start */
    60|             unsigned char *p = state->in;
    61|             unsigned const char *q = strm->next_in;
    62|             unsigned n = strm->avail_in;
    63|             do {
    64|                 *p++ = *q++;
    65|             } while (--n);
    66|         }
    67|         if (gz_load(state, state->in + strm->avail_in,
    68|                     state->size - strm->avail_in, &got) == -1)
    69|             return -1;
    70|         strm->avail_in += got;
    71|         strm->next_in = state->in;
    72|     }
    73|     return 0;
    74| }
    75| /* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
    76|    If this is the first time in, allocate required memory.  state->how will be
    77|    left unchanged if there is no more input data available, will be set to COPY
    78|    if there is no gzip header and direct copying will be performed, or it will
    79|    be set to GZIP for decompression.  If direct copying, then leftover input
    80|    data from the input buffer will be copied to the output buffer.  In that
    81|    case, all further file reads will be directly to either the output buffer or
    82|    a user buffer.  If decompressing, the inflate state will be initialized.
    83|    gz_look() will return 0 on success or -1 on failure. */
    84| local int gz_look(state)
    85|     gz_statep state;
    86| {
    87|     z_streamp strm = &(state->strm);
    88|     /* allocate read buffers and inflate memory */
    89|     if (state->size == 0) {
    90|         /* allocate buffers */
    91|         state->in = (unsigned char *)malloc(state->want);
    92|         state->out = (unsigned char *)malloc(state->want << 1);
    93|         if (state->in == NULL || state->out == NULL) {
    94|             free(state->out);
    95|             free(state->in);
    96|             gz_error(state, Z_MEM_ERROR, "out of memory");
    97|             return -1;
    98|         }
    99|         state->size = state->want;
   100|         /* allocate inflate memory */
   101|         state->strm.zalloc = Z_NULL;
   102|         state->strm.zfree = Z_NULL;
   103|         state->strm.opaque = Z_NULL;
   104|         state->strm.avail_in = 0;
   105|         state->strm.next_in = Z_NULL;
   106|         if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
   107|             free(state->out);
   108|             free(state->in);
   109|             state->size = 0;
   110|             gz_error(state, Z_MEM_ERROR, "out of memory");
   111|             return -1;
   112|         }
   113|     }
   114|     /* get at least the magic bytes in the input buffer */
   115|     if (strm->avail_in < 2) {
   116|         if (gz_avail(state) == -1)
   117|             return -1;
   118|         if (strm->avail_in == 0)
   119|             return 0;
   120|     }
   121|     /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
   122|        a logical dilemma here when considering the case of a partially written
   123|        gzip file, to wit, if a single 31 byte is written, then we cannot tell
   124|        whether this is a single-byte file, or just a partially written gzip
   125|        file -- for here we assume that if a gzip file is being written, then
   126|        the header will be written in a single operation, so that reading a
   127|        single byte is sufficient indication that it is not a gzip file) */
   128|     if (strm->avail_in > 1 &&
   129|             strm->next_in[0] == 31 && strm->next_in[1] == 139) {
   130|         inflateReset(strm);
   131|         state->how = GZIP;
   132|         state->direct = 0;
   133|         return 0;
   134|     }
   135|     /* no gzip header -- if we were decoding gzip before, then this is trailing
   136|        garbage.  Ignore the trailing garbage and finish. */
   137|     if (state->direct == 0) {
   138|         strm->avail_in = 0;
   139|         state->eof = 1;
   140|         state->x.have = 0;
   141|         return 0;
   142|     }
   143|     /* doing raw i/o, copy any leftover input to output -- this assumes that
   144|        the output buffer is larger than the input buffer, which also assures
   145|        space for gzungetc() */
   146|     state->x.next = state->out;
   147|     memcpy(state->x.next, strm->next_in, strm->avail_in);
   148|     state->x.have = strm->avail_in;
   149|     strm->avail_in = 0;
   150|     state->how = COPY;
   151|     state->direct = 1;
   152|     return 0;
   153| }
   154| /* Decompress from input to the provided next_out and avail_out in the state.
   155|    On return, state->x.have and state->x.next point to the just decompressed
   156|    data.  If the gzip stream completes, state->how is reset to LOOK to look for
   157|    the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   158|    on success, -1 on failure. */
   159| local int gz_decomp(state)
   160|     gz_statep state;
   161| {
   162|     int ret = Z_OK;
   163|     unsigned had;
   164|     z_streamp strm = &(state->strm);
   165|     /* fill output buffer up to end of deflate stream */
   166|     had = strm->avail_out;
   167|     do {
   168|         /* get more input for inflate() */
   169|         if (strm->avail_in == 0 && gz_avail(state) == -1)
   170|             return -1;
   171|         if (strm->avail_in == 0) {
   172|             gz_error(state, Z_BUF_ERROR, "unexpected end of file");
   173|             break;
   174|         }
   175|         /* decompress and handle errors */
   176|         ret = inflate(strm, Z_NO_FLUSH);
   177|         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
   178|             gz_error(state, Z_STREAM_ERROR,
   179|                      "internal error: inflate stream corrupt");
   180|             return -1;
   181|         }
   182|         if (ret == Z_MEM_ERROR) {
   183|             gz_error(state, Z_MEM_ERROR, "out of memory");
   184|             return -1;
   185|         }
   186|         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
   187|             gz_error(state, Z_DATA_ERROR,
   188|                      strm->msg == NULL ? "compressed data error" : strm->msg);
   189|             return -1;
   190|         }
   191|     } while (strm->avail_out && ret != Z_STREAM_END);
   192|     /* update available output */
   193|     state->x.have = had - strm->avail_out;
   194|     state->x.next = strm->next_out - state->x.have;
   195|     /* if the gzip stream completed successfully, look for another */
   196|     if (ret == Z_STREAM_END)
   197|         state->how = LOOK;
   198|     /* good decompression */
   199|     return 0;
   200| }
   201| /* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   202|    Data is either copied from the input file or decompressed from the input
   203|    file depending on state->how.  If state->how is LOOK, then a gzip header is
   204|    looked for to determine whether to copy or decompress.  Returns -1 on error,
   205|    otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   206|    end of the input file has been reached and all data has been processed.  */
   207| local int gz_fetch(state)
   208|     gz_statep state;
   209| {
   210|     z_streamp strm = &(state->strm);
   211|     do {
   212|         switch(state->how) {
   213|         case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
   214|             if (gz_look(state) == -1)
   215|                 return -1;
   216|             if (state->how == LOOK)
   217|                 return 0;
   218|             break;
   219|         case COPY:      /* -> COPY */
   220|             if (gz_load(state, state->out, state->size << 1, &(state->x.have))
   221|                     == -1)
   222|                 return -1;
   223|             state->x.next = state->out;
   224|             return 0;
   225|         case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
   226|             strm->avail_out = state->size << 1;
   227|             strm->next_out = state->out;
   228|             if (gz_decomp(state) == -1)
   229|                 return -1;
   230|         }
   231|     } while (state->x.have == 0 && (!state->eof || strm->avail_in));
   232|     return 0;
   233| }
   234| /* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
   235| local int gz_skip(state, len)
   236|     gz_statep state;
   237|     z_off64_t len;
   238| {
   239|     unsigned n;
   240|     /* skip over len bytes or reach end-of-file, whichever comes first */
   241|     while (len)
   242|         /* skip over whatever is in output buffer */
   243|         if (state->x.have) {
   244|             n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
   245|                 (unsigned)len : state->x.have;
   246|             state->x.have -= n;
   247|             state->x.next += n;
   248|             state->x.pos += n;
   249|             len -= n;
   250|         }
   251|         /* output buffer empty -- return if we're at the end of the input */
   252|         else if (state->eof && state->strm.avail_in == 0)
   253|             break;
   254|         /* need more data to skip -- load up output buffer */
   255|         else {
   256|             /* get more output, looking for header if required */
   257|             if (gz_fetch(state) == -1)
   258|                 return -1;
   259|         }
   260|     return 0;
   261| }
   262| /* Read len bytes into buf from file, or less than len up to the end of the
   263|    input.  Return the number of bytes read.  If zero is returned, either the
   264|    end of file was reached, or there was an error.  state->err must be
   265|    consulted in that case to determine which. */
   266| local z_size_t gz_read(state, buf, len)
   267|     gz_statep state;
   268|     voidp buf;
   269|     z_size_t len;
   270| {
   271|     z_size_t got;
   272|     unsigned n;
   273|     /* if len is zero, avoid unnecessary operations */
   274|     if (len == 0)
   275|         return 0;
   276|     /* process a skip request */
   277|     if (state->seek) {
   278|         state->seek = 0;
   279|         if (gz_skip(state, state->skip) == -1)
   280|             return 0;
   281|     }
   282|     /* get len bytes to buf, or less than len if at the end */
   283|     got = 0;
   284|     do {
   285|         /* set n to the maximum amount of len that fits in an unsigned int */
   286|         n = (unsigned)-1;
   287|         if (n > len)
   288|             n = (unsigned)len;
   289|         /* first just try copying data from the output buffer */
   290|         if (state->x.have) {
   291|             if (state->x.have < n)
   292|                 n = state->x.have;
   293|             memcpy(buf, state->x.next, n);
   294|             state->x.next += n;
   295|             state->x.have -= n;
   296|         }
   297|         /* output buffer empty -- return if we're at the end of the input */
   298|         else if (state->eof && state->strm.avail_in == 0) {
   299|             state->past = 1;        /* tried to read past end */
   300|             break;
   301|         }
   302|         /* need output data -- for small len or new stream load up our output
   303|            buffer */
   304|         else if (state->how == LOOK || n < (state->size << 1)) {
   305|             /* get more output, looking for header if required */
   306|             if (gz_fetch(state) == -1)
   307|                 return 0;
   308|             continue;       /* no progress yet -- go back to copy above */
   309|             /* the copy above assures that we will leave with space in the
   310|                output buffer, allowing at least one gzungetc() to succeed */
   311|         }
   312|         /* large len -- read directly into user buffer */
   313|         else if (state->how == COPY) {      /* read directly */
   314|             if (gz_load(state, (unsigned char *)buf, n, &n) == -1)
   315|                 return 0;
   316|         }
   317|         /* large len -- decompress directly into user buffer */
   318|         else {  /* state->how == GZIP */
   319|             state->strm.avail_out = n;
   320|             state->strm.next_out = (unsigned char *)buf;
   321|             if (gz_decomp(state) == -1)
   322|                 return 0;
   323|             n = state->x.have;
   324|             state->x.have = 0;
   325|         }
   326|         /* update progress */
   327|         len -= n;
   328|         buf = (char *)buf + n;
   329|         got += n;
   330|         state->x.pos += n;
   331|     } while (len);
   332|     /* return number of bytes read into user buffer */
   333|     return got;
   334| }
   335| /* -- see zlib.h -- */
   336| int ZEXPORT gzread(file, buf, len)
   337|     gzFile file;
   338|     voidp buf;
   339|     unsigned len;
   340| {
   341|     gz_statep state;
   342|     /* get internal structure */
   343|     if (file == NULL)
   344|         return -1;
   345|     state = (gz_statep)file;
   346|     /* check that we're reading and that there's no (serious) error */
   347|     if (state->mode != GZ_READ ||
   348|             (state->err != Z_OK && state->err != Z_BUF_ERROR))
   349|         return -1;
   350|     /* since an int is returned, make sure len fits in one, otherwise return
   351|        with an error (this avoids a flaw in the interface) */
   352|     if ((int)len < 0) {
   353|         gz_error(state, Z_STREAM_ERROR, "request does not fit in an int");
   354|         return -1;
   355|     }
   356|     /* read len or fewer bytes to buf */
   357|     len = (unsigned)gz_read(state, buf, len);
   358|     /* check for an error */
   359|     if (len == 0 && state->err != Z_OK && state->err != Z_BUF_ERROR)
   360|         return -1;
   361|     /* return the number of bytes read (this is assured to fit in an int) */
   362|     return (int)len;
   363| }
   364| /* -- see zlib.h -- */
   365| z_size_t ZEXPORT gzfread(buf, size, nitems, file)
   366|     voidp buf;
   367|     z_size_t size;
   368|     z_size_t nitems;
   369|     gzFile file;
   370| {
   371|     z_size_t len;
   372|     gz_statep state;
   373|     /* get internal structure */
   374|     if (file == NULL)
   375|         return 0;
   376|     state = (gz_statep)file;
   377|     /* check that we're reading and that there's no (serious) error */
   378|     if (state->mode != GZ_READ ||
   379|             (state->err != Z_OK && state->err != Z_BUF_ERROR))
   380|         return 0;
   381|     /* compute bytes to read -- error on overflow */
   382|     len = nitems * size;
   383|     if (size && len / size != nitems) {
   384|         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
   385|         return 0;
   386|     }
   387|     /* read len or fewer bytes to buf, return the number of full items read */
   388|     return len ? gz_read(state, buf, len) / size : 0;
   389| }
   390| /* -- see zlib.h -- */
   391| #ifdef Z_PREFIX_SET
   392| #  undef z_gzgetc
   393| #else
   394| #  undef gzgetc
   395| #endif
   396| int ZEXPORT gzgetc(file)
   397|     gzFile file;
   398| {
   399|     unsigned char buf[1];
   400|     gz_statep state;
   401|     /* get internal structure */
   402|     if (file == NULL)
   403|         return -1;
   404|     state = (gz_statep)file;
   405|     /* check that we're reading and that there's no (serious) error */
   406|     if (state->mode != GZ_READ ||
   407|         (state->err != Z_OK && state->err != Z_BUF_ERROR))
   408|         return -1;
   409|     /* try output buffer (no need to check for skip request) */
   410|     if (state->x.have) {
   411|         state->x.have--;
   412|         state->x.pos++;
   413|         return *(state->x.next)++;
   414|     }
   415|     /* nothing there -- try gz_read() */
   416|     return gz_read(state, buf, 1) < 1 ? -1 : buf[0];
   417| }
   418| int ZEXPORT gzgetc_(file)
   419| gzFile file;
   420| {
   421|     return gzgetc(file);
   422| }
   423| /* -- see zlib.h -- */
   424| int ZEXPORT gzungetc(c, file)
   425|     int c;
   426|     gzFile file;
   427| {
   428|     gz_statep state;
   429|     /* get internal structure */
   430|     if (file == NULL)
   431|         return -1;
   432|     state = (gz_statep)file;
   433|     /* check that we're reading and that there's no (serious) error */
   434|     if (state->mode != GZ_READ ||
   435|         (state->err != Z_OK && state->err != Z_BUF_ERROR))
   436|         return -1;
   437|     /* process a skip request */
   438|     if (state->seek) {
   439|         state->seek = 0;
   440|         if (gz_skip(state, state->skip) == -1)
   441|             return -1;
   442|     }
   443|     /* can't push EOF */
   444|     if (c < 0)
   445|         return -1;
   446|     /* if output buffer empty, put byte at end (allows more pushing) */
   447|     if (state->x.have == 0) {
   448|         state->x.have = 1;
   449|         state->x.next = state->out + (state->size << 1) - 1;
   450|         state->x.next[0] = (unsigned char)c;
   451|         state->x.pos--;
   452|         state->past = 0;
   453|         return c;
   454|     }
   455|     /* if no room, give up (must have already done a gzungetc()) */
   456|     if (state->x.have == (state->size << 1)) {
   457|         gz_error(state, Z_DATA_ERROR, "out of room to push characters");
   458|         return -1;
   459|     }
   460|     /* slide output data if needed and insert byte before existing data */
   461|     if (state->x.next == state->out) {
   462|         unsigned char *src = state->out + state->x.have;
   463|         unsigned char *dest = state->out + (state->size << 1);
   464|         while (src > state->out)
   465|             *--dest = *--src;
   466|         state->x.next = dest;
   467|     }
   468|     state->x.have++;
   469|     state->x.next--;
   470|     state->x.next[0] = (unsigned char)c;
   471|     state->x.pos--;
   472|     state->past = 0;
   473|     return c;
   474| }
   475| /* -- see zlib.h -- */
   476| char * ZEXPORT gzgets(file, buf, len)
   477|     gzFile file;
   478|     char *buf;
   479|     int len;
   480| {
   481|     unsigned left, n;
   482|     char *str;
   483|     unsigned char *eol;
   484|     gz_statep state;
   485|     /* check parameters and get internal structure */
   486|     if (file == NULL || buf == NULL || len < 1)
   487|         return NULL;
   488|     state = (gz_statep)file;
   489|     /* check that we're reading and that there's no (serious) error */
   490|     if (state->mode != GZ_READ ||
   491|         (state->err != Z_OK && state->err != Z_BUF_ERROR))
   492|         return NULL;
   493|     /* process a skip request */
   494|     if (state->seek) {
   495|         state->seek = 0;
   496|         if (gz_skip(state, state->skip) == -1)
   497|             return NULL;
   498|     }
   499|     /* copy output bytes up to new line or len - 1, whichever comes first --
   500|        append a terminating zero to the string (we don't check for a zero in
   501|        the contents, let the user worry about that) */
   502|     str = buf;
   503|     left = (unsigned)len - 1;
   504|     if (left) do {
   505|         /* assure that something is in the output buffer */
   506|         if (state->x.have == 0 && gz_fetch(state) == -1)
   507|             return NULL;                /* error */
   508|         if (state->x.have == 0) {       /* end of file */
   509|             state->past = 1;            /* read past end */
   510|             break;                      /* return what we have */
   511|         }
   512|         /* look for end-of-line in current output buffer */
   513|         n = state->x.have > left ? left : state->x.have;
   514|         eol = (unsigned char *)memchr(state->x.next, '\n', n);
   515|         if (eol != NULL)
   516|             n = (unsigned)(eol - state->x.next) + 1;
   517|         /* copy through end-of-line, or remainder if not found */
   518|         memcpy(buf, state->x.next, n);
   519|         state->x.have -= n;
   520|         state->x.next += n;
   521|         state->x.pos += n;
   522|         left -= n;
   523|         buf += n;
   524|     } while (left && eol == NULL);
   525|     /* return terminated string, or if nothing, end of file */
   526|     if (buf == str)
   527|         return NULL;
   528|     buf[0] = 0;
   529|     return str;
   530| }
   531| /* -- see zlib.h -- */
   532| int ZEXPORT gzdirect(file)
   533|     gzFile file;
   534| {
   535|     gz_statep state;
   536|     /* get internal structure */
   537|     if (file == NULL)
   538|         return 0;
   539|     state = (gz_statep)file;
   540|     /* if the state is not known, but we can find out, then do so (this is
   541|        mainly for right after a gzopen() or gzdopen()) */
   542|     if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
   543|         (void)gz_look(state);
   544|     /* return 1 if transparent, 0 if processing a gzip stream */
   545|     return state->direct;
   546| }
   547| /* -- see zlib.h -- */
   548| int ZEXPORT gzclose_r(file)
   549|     gzFile file;
   550| {
   551|     int ret, err;
   552|     gz_statep state;
   553|     /* get internal structure */
   554|     if (file == NULL)
   555|         return Z_STREAM_ERROR;
   556|     state = (gz_statep)file;
   557|     /* check that we're reading */
   558|     if (state->mode != GZ_READ)
   559|         return Z_STREAM_ERROR;
   560|     /* free memory and close file */
   561|     if (state->size) {
   562|         inflateEnd(&(state->strm));
   563|         free(state->out);
   564|         free(state->in);
   565|     }
   566|     err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
   567|     gz_error(state, Z_OK, NULL);
   568|     free(state->path);
   569|     ret = close(state->fd);
   570|     free(state);
   571|     return ret ? Z_ERRNO : err;
   572| }


# ====================================================================
# FILE: src/native/external/zlib/gzwrite.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-591 ---
     1| /* gzwrite.c -- zlib functions for writing gzip files
     2|  * Copyright (C) 2004-2019 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| #include "gzguts.h"
     6| /* Local functions */
     7| local int gz_init OF((gz_statep));
     8| local int gz_comp OF((gz_statep, int));
     9| local int gz_zero OF((gz_statep, z_off64_t));
    10| local z_size_t gz_write OF((gz_statep, voidpc, z_size_t));
    11| /* Initialize state for writing a gzip file.  Mark initialization by setting
    12|    state->size to non-zero.  Return -1 on a memory allocation failure, or 0 on
    13|    success. */
    14| local int gz_init(state)
    15|     gz_statep state;
    16| {
    17|     int ret;
    18|     z_streamp strm = &(state->strm);
    19|     /* allocate input buffer (double size for gzprintf) */
    20|     state->in = (unsigned char *)malloc(state->want << 1);
    21|     if (state->in == NULL) {
    22|         gz_error(state, Z_MEM_ERROR, "out of memory");
    23|         return -1;
    24|     }
    25|     /* only need output buffer and deflate state if compressing */
    26|     if (!state->direct) {
    27|         /* allocate output buffer */
    28|         state->out = (unsigned char *)malloc(state->want);
    29|         if (state->out == NULL) {
    30|             free(state->in);
    31|             gz_error(state, Z_MEM_ERROR, "out of memory");
    32|             return -1;
    33|         }
    34|         /* allocate deflate memory, set up for gzip compression */
    35|         strm->zalloc = Z_NULL;
    36|         strm->zfree = Z_NULL;
    37|         strm->opaque = Z_NULL;
    38|         ret = deflateInit2(strm, state->level, Z_DEFLATED,
    39|                            MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
    40|         if (ret != Z_OK) {
    41|             free(state->out);
    42|             free(state->in);
    43|             gz_error(state, Z_MEM_ERROR, "out of memory");
    44|             return -1;
    45|         }
    46|         strm->next_in = NULL;
    47|     }
    48|     /* mark state as initialized */
    49|     state->size = state->want;
    50|     /* initialize write buffer if compressing */
    51|     if (!state->direct) {
    52|         strm->avail_out = state->size;
    53|         strm->next_out = state->out;
    54|         state->x.next = strm->next_out;
    55|     }
    56|     return 0;
    57| }
    58| /* Compress whatever is at avail_in and next_in and write to the output file.
    59|    Return -1 if there is an error writing to the output file or if gz_init()
    60|    fails to allocate memory, otherwise 0.  flush is assumed to be a valid
    61|    deflate() flush value.  If flush is Z_FINISH, then the deflate() state is
    62|    reset to start a new gzip stream.  If gz->direct is true, then simply write
    63|    to the output file without compressing, and ignore flush. */
    64| local int gz_comp(state, flush)
    65|     gz_statep state;
    66|     int flush;
    67| {
    68|     int ret, writ;
    69|     unsigned have, put, max = ((unsigned)-1 >> 2) + 1;
    70|     z_streamp strm = &(state->strm);
    71|     /* allocate memory if this is the first time through */
    72|     if (state->size == 0 && gz_init(state) == -1)
    73|         return -1;
    74|     /* write directly if requested */
    75|     if (state->direct) {
    76|         while (strm->avail_in) {
    77|             put = strm->avail_in > max ? max : strm->avail_in;
    78|             writ = write(state->fd, strm->next_in, put);
    79|             if (writ < 0) {
    80|                 gz_error(state, Z_ERRNO, zstrerror());
    81|                 return -1;
    82|             }
    83|             strm->avail_in -= (unsigned)writ;
    84|             strm->next_in += writ;
    85|         }
    86|         return 0;
    87|     }
    88|     /* check for a pending reset */
    89|     if (state->reset) {
    90|         /* don't start a new gzip member unless there is data to write */
    91|         if (strm->avail_in == 0)
    92|             return 0;
    93|         deflateReset(strm);
    94|         state->reset = 0;
    95|     }
    96|     /* run deflate() on provided input until it produces no more output */
    97|     ret = Z_OK;
    98|     do {
    99|         /* write out current buffer contents if full, or if flushing, but if
   100|            doing Z_FINISH then don't write until we get to Z_STREAM_END */
   101|         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
   102|             (flush != Z_FINISH || ret == Z_STREAM_END))) {
   103|             while (strm->next_out > state->x.next) {
   104|                 put = strm->next_out - state->x.next > (int)max ? max :
   105|                       (unsigned)(strm->next_out - state->x.next);
   106|                 writ = write(state->fd, state->x.next, put);
   107|                 if (writ < 0) {
   108|                     gz_error(state, Z_ERRNO, zstrerror());
   109|                     return -1;
   110|                 }
   111|                 state->x.next += writ;
   112|             }
   113|             if (strm->avail_out == 0) {
   114|                 strm->avail_out = state->size;
   115|                 strm->next_out = state->out;
   116|                 state->x.next = state->out;
   117|             }
   118|         }
   119|         /* compress */
   120|         have = strm->avail_out;
   121|         ret = deflate(strm, flush);
   122|         if (ret == Z_STREAM_ERROR) {
   123|             gz_error(state, Z_STREAM_ERROR,
   124|                       "internal error: deflate stream corrupt");
   125|             return -1;
   126|         }
   127|         have -= strm->avail_out;
   128|     } while (have);
   129|     /* if that completed a deflate stream, allow another to start */
   130|     if (flush == Z_FINISH)
   131|         state->reset = 1;
   132|     /* all done, no errors */
   133|     return 0;
   134| }
   135| /* Compress len zeros to output.  Return -1 on a write error or memory
   136|    allocation failure by gz_comp(), or 0 on success. */
   137| local int gz_zero(state, len)
   138|     gz_statep state;
   139|     z_off64_t len;
   140| {
   141|     int first;
   142|     unsigned n;
   143|     z_streamp strm = &(state->strm);
   144|     /* consume whatever's left in the input buffer */
   145|     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
   146|         return -1;
   147|     /* compress len zeros (len guaranteed > 0) */
   148|     first = 1;
   149|     while (len) {
   150|         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
   151|             (unsigned)len : state->size;
   152|         if (first) {
   153|             memset(state->in, 0, n);
   154|             first = 0;
   155|         }
   156|         strm->avail_in = n;
   157|         strm->next_in = state->in;
   158|         state->x.pos += n;
   159|         if (gz_comp(state, Z_NO_FLUSH) == -1)
   160|             return -1;
   161|         len -= n;
   162|     }
   163|     return 0;
   164| }
   165| /* Write len bytes from buf to file.  Return the number of bytes written.  If
   166|    the returned value is less than len, then there was an error. */
   167| local z_size_t gz_write(state, buf, len)
   168|     gz_statep state;
   169|     voidpc buf;
   170|     z_size_t len;
   171| {
   172|     z_size_t put = len;
   173|     /* if len is zero, avoid unnecessary operations */
   174|     if (len == 0)
   175|         return 0;
   176|     /* allocate memory if this is the first time through */
   177|     if (state->size == 0 && gz_init(state) == -1)
   178|         return 0;
   179|     /* check for seek request */
   180|     if (state->seek) {
   181|         state->seek = 0;
   182|         if (gz_zero(state, state->skip) == -1)
   183|             return 0;
   184|     }
   185|     /* for small len, copy to input buffer, otherwise compress directly */
   186|     if (len < state->size) {
   187|         /* copy to input buffer, compress when full */
   188|         do {
   189|             unsigned have, copy;
   190|             if (state->strm.avail_in == 0)
   191|                 state->strm.next_in = state->in;
   192|             have = (unsigned)((state->strm.next_in + state->strm.avail_in) -
   193|                               state->in);
   194|             copy = state->size - have;
   195|             if (copy > len)
   196|                 copy = (unsigned)len;
   197|             memcpy(state->in + have, buf, copy);
   198|             state->strm.avail_in += copy;
   199|             state->x.pos += copy;
   200|             buf = (const char *)buf + copy;
   201|             len -= copy;
   202|             if (len && gz_comp(state, Z_NO_FLUSH) == -1)
   203|                 return 0;
   204|         } while (len);
   205|     }
   206|     else {
   207|         /* consume whatever's left in the input buffer */
   208|         if (state->strm.avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
   209|             return 0;
   210|         /* directly compress user buffer to file */
   211|         state->strm.next_in = (z_const Bytef *)buf;
   212|         do {
   213|             unsigned n = (unsigned)-1;
   214|             if (n > len)
   215|                 n = (unsigned)len;
   216|             state->strm.avail_in = n;
   217|             state->x.pos += n;
   218|             if (gz_comp(state, Z_NO_FLUSH) == -1)
   219|                 return 0;
   220|             len -= n;
   221|         } while (len);
   222|     }
   223|     /* input was all buffered or compressed */
   224|     return put;
   225| }
   226| /* -- see zlib.h -- */
   227| int ZEXPORT gzwrite(file, buf, len)
   228|     gzFile file;
   229|     voidpc buf;
   230|     unsigned len;
   231| {
   232|     gz_statep state;
   233|     /* get internal structure */
   234|     if (file == NULL)
   235|         return 0;
   236|     state = (gz_statep)file;
   237|     /* check that we're writing and that there's no error */
   238|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   239|         return 0;
   240|     /* since an int is returned, make sure len fits in one, otherwise return
   241|        with an error (this avoids a flaw in the interface) */
   242|     if ((int)len < 0) {
   243|         gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
   244|         return 0;
   245|     }
   246|     /* write len bytes from buf (the return value will fit in an int) */
   247|     return (int)gz_write(state, buf, len);
   248| }
   249| /* -- see zlib.h -- */
   250| z_size_t ZEXPORT gzfwrite(buf, size, nitems, file)
   251|     voidpc buf;
   252|     z_size_t size;
   253|     z_size_t nitems;
   254|     gzFile file;
   255| {
   256|     z_size_t len;
   257|     gz_statep state;
   258|     /* get internal structure */
   259|     if (file == NULL)
   260|         return 0;
   261|     state = (gz_statep)file;
   262|     /* check that we're writing and that there's no error */
   263|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   264|         return 0;
   265|     /* compute bytes to read -- error on overflow */
   266|     len = nitems * size;
   267|     if (size && len / size != nitems) {
   268|         gz_error(state, Z_STREAM_ERROR, "request does not fit in a size_t");
   269|         return 0;
   270|     }
   271|     /* write len bytes to buf, return the number of full items written */
   272|     return len ? gz_write(state, buf, len) / size : 0;
   273| }
   274| /* -- see zlib.h -- */
   275| int ZEXPORT gzputc(file, c)
   276|     gzFile file;
   277|     int c;
   278| {
   279|     unsigned have;
   280|     unsigned char buf[1];
   281|     gz_statep state;
   282|     z_streamp strm;
   283|     /* get internal structure */
   284|     if (file == NULL)
   285|         return -1;
   286|     state = (gz_statep)file;
   287|     strm = &(state->strm);
   288|     /* check that we're writing and that there's no error */
   289|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   290|         return -1;
   291|     /* check for seek request */
   292|     if (state->seek) {
   293|         state->seek = 0;
   294|         if (gz_zero(state, state->skip) == -1)
   295|             return -1;
   296|     }
   297|     /* try writing to input buffer for speed (state->size == 0 if buffer not
   298|        initialized) */
   299|     if (state->size) {
   300|         if (strm->avail_in == 0)
   301|             strm->next_in = state->in;
   302|         have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
   303|         if (have < state->size) {
   304|             state->in[have] = (unsigned char)c;
   305|             strm->avail_in++;
   306|             state->x.pos++;
   307|             return c & 0xff;
   308|         }
   309|     }
   310|     /* no room in buffer or not initialized, use gz_write() */
   311|     buf[0] = (unsigned char)c;
   312|     if (gz_write(state, buf, 1) != 1)
   313|         return -1;
   314|     return c & 0xff;
   315| }
   316| /* -- see zlib.h -- */
   317| int ZEXPORT gzputs(file, s)
   318|     gzFile file;
   319|     const char *s;
   320| {
   321|     z_size_t len, put;
   322|     gz_statep state;
   323|     /* get internal structure */
   324|     if (file == NULL)
   325|         return -1;
   326|     state = (gz_statep)file;
   327|     /* check that we're writing and that there's no error */
   328|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   329|         return -1;
   330|     /* write string */
   331|     len = strlen(s);
   332|     if ((int)len < 0 || (unsigned)len != len) {
   333|         gz_error(state, Z_STREAM_ERROR, "string length does not fit in int");
   334|         return -1;
   335|     }
   336|     put = gz_write(state, s, len);
   337|     return put < len ? -1 : (int)len;
   338| }
   339| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
   340| #include <stdarg.h>
   341| /* -- see zlib.h -- */
   342| int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
   343| {
   344|     int len;
   345|     unsigned left;
   346|     char *next;
   347|     gz_statep state;
   348|     z_streamp strm;
   349|     /* get internal structure */
   350|     if (file == NULL)
   351|         return Z_STREAM_ERROR;
   352|     state = (gz_statep)file;
   353|     strm = &(state->strm);
   354|     /* check that we're writing and that there's no error */
   355|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   356|         return Z_STREAM_ERROR;
   357|     /* make sure we have some buffer space */
   358|     if (state->size == 0 && gz_init(state) == -1)
   359|         return state->err;
   360|     /* check for seek request */
   361|     if (state->seek) {
   362|         state->seek = 0;
   363|         if (gz_zero(state, state->skip) == -1)
   364|             return state->err;
   365|     }
   366|     /* do the printf() into the input buffer, put length in len -- the input
   367|        buffer is double-sized just for this function, so there is guaranteed to
   368|        be state->size bytes available after the current contents */
   369|     if (strm->avail_in == 0)
   370|         strm->next_in = state->in;
   371|     next = (char *)(state->in + (strm->next_in - state->in) + strm->avail_in);
   372|     next[state->size - 1] = 0;
   373| #ifdef NO_vsnprintf
   374| #  ifdef HAS_vsprintf_void
   375|     (void)vsprintf(next, format, va);
   376|     for (len = 0; len < state->size; len++)
   377|         if (next[len] == 0) break;
   378| #  else
   379|     len = vsprintf(next, format, va);
   380| #  endif
   381| #else
   382| #  ifdef HAS_vsnprintf_void
   383|     (void)vsnprintf(next, state->size, format, va);
   384|     len = strlen(next);
   385| #  else
   386|     len = vsnprintf(next, state->size, format, va);
   387| #  endif
   388| #endif
   389|     /* check that printf() results fit in buffer */
   390|     if (len == 0 || (unsigned)len >= state->size || next[state->size - 1] != 0)
   391|         return 0;
   392|     /* update buffer and position, compress first half if past that */
   393|     strm->avail_in += (unsigned)len;
   394|     state->x.pos += len;
   395|     if (strm->avail_in >= state->size) {
   396|         left = strm->avail_in - state->size;
   397|         strm->avail_in = state->size;
   398|         if (gz_comp(state, Z_NO_FLUSH) == -1)
   399|             return state->err;
   400|         memmove(state->in, state->in + state->size, left);
   401|         strm->next_in = state->in;
   402|         strm->avail_in = left;
   403|     }
   404|     return len;
   405| }
   406| int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
   407| {
   408|     va_list va;
   409|     int ret;
   410|     va_start(va, format);
   411|     ret = gzvprintf(file, format, va);
   412|     va_end(va);
   413|     return ret;
   414| }
   415| #else /* !STDC && !Z_HAVE_STDARG_H */
   416| /* -- see zlib.h -- */
   417| int ZEXPORTVA gzprintf(file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
   418|                        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
   419|     gzFile file;
   420|     const char *format;
   421|     int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
   422|         a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
   423| {
   424|     unsigned len, left;
   425|     char *next;
   426|     gz_statep state;
   427|     z_streamp strm;
   428|     /* get internal structure */
   429|     if (file == NULL)
   430|         return Z_STREAM_ERROR;
   431|     state = (gz_statep)file;
   432|     strm = &(state->strm);
   433|     /* check that can really pass pointer in ints */
   434|     if (sizeof(int) != sizeof(void *))
   435|         return Z_STREAM_ERROR;
   436|     /* check that we're writing and that there's no error */
   437|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   438|         return Z_STREAM_ERROR;
   439|     /* make sure we have some buffer space */
   440|     if (state->size == 0 && gz_init(state) == -1)
   441|         return state->error;
   442|     /* check for seek request */
   443|     if (state->seek) {
   444|         state->seek = 0;
   445|         if (gz_zero(state, state->skip) == -1)
   446|             return state->error;
   447|     }
   448|     /* do the printf() into the input buffer, put length in len -- the input
   449|        buffer is double-sized just for this function, so there is guaranteed to
   450|        be state->size bytes available after the current contents */
   451|     if (strm->avail_in == 0)
   452|         strm->next_in = state->in;
   453|     next = (char *)(strm->next_in + strm->avail_in);
   454|     next[state->size - 1] = 0;
   455| #ifdef NO_snprintf
   456| #  ifdef HAS_sprintf_void
   457|     sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
   458|             a13, a14, a15, a16, a17, a18, a19, a20);
   459|     for (len = 0; len < size; len++)
   460|         if (next[len] == 0)
   461|             break;
   462| #  else
   463|     len = sprintf(next, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11,
   464|                   a12, a13, a14, a15, a16, a17, a18, a19, a20);
   465| #  endif
   466| #else
   467| #  ifdef HAS_snprintf_void
   468|     snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8, a9,
   469|              a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
   470|     len = strlen(next);
   471| #  else
   472|     len = snprintf(next, state->size, format, a1, a2, a3, a4, a5, a6, a7, a8,
   473|                    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
   474| #  endif
   475| #endif
   476|     /* check that printf() results fit in buffer */
   477|     if (len == 0 || len >= state->size || next[state->size - 1] != 0)
   478|         return 0;
   479|     /* update buffer and position, compress first half if past that */
   480|     strm->avail_in += len;
   481|     state->x.pos += len;
   482|     if (strm->avail_in >= state->size) {
   483|         left = strm->avail_in - state->size;
   484|         strm->avail_in = state->size;
   485|         if (gz_comp(state, Z_NO_FLUSH) == -1)
   486|             return state->err;
   487|         memmove(state->in, state->in + state->size, left);
   488|         strm->next_in = state->in;
   489|         strm->avail_in = left;
   490|     }
   491|     return (int)len;
   492| }
   493| #endif
   494| /* -- see zlib.h -- */
   495| int ZEXPORT gzflush(file, flush)
   496|     gzFile file;
   497|     int flush;
   498| {
   499|     gz_statep state;
   500|     /* get internal structure */
   501|     if (file == NULL)
   502|         return Z_STREAM_ERROR;
   503|     state = (gz_statep)file;
   504|     /* check that we're writing and that there's no error */
   505|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   506|         return Z_STREAM_ERROR;
   507|     /* check flush parameter */
   508|     if (flush < 0 || flush > Z_FINISH)
   509|         return Z_STREAM_ERROR;
   510|     /* check for seek request */
   511|     if (state->seek) {
   512|         state->seek = 0;
   513|         if (gz_zero(state, state->skip) == -1)
   514|             return state->err;
   515|     }
   516|     /* compress remaining data with requested flush */
   517|     (void)gz_comp(state, flush);
   518|     return state->err;
   519| }
   520| /* -- see zlib.h -- */
   521| int ZEXPORT gzsetparams(file, level, strategy)
   522|     gzFile file;
   523|     int level;
   524|     int strategy;
   525| {
   526|     gz_statep state;
   527|     z_streamp strm;
   528|     /* get internal structure */
   529|     if (file == NULL)
   530|         return Z_STREAM_ERROR;
   531|     state = (gz_statep)file;
   532|     strm = &(state->strm);
   533|     /* check that we're writing and that there's no error */
   534|     if (state->mode != GZ_WRITE || state->err != Z_OK)
   535|         return Z_STREAM_ERROR;
   536|     /* if no change is requested, then do nothing */
   537|     if (level == state->level && strategy == state->strategy)
   538|         return Z_OK;
   539|     /* check for seek request */
   540|     if (state->seek) {
   541|         state->seek = 0;
   542|         if (gz_zero(state, state->skip) == -1)
   543|             return state->err;
   544|     }
   545|     /* change compression parameters for subsequent input */
   546|     if (state->size) {
   547|         /* flush previous input with previous parameters before changing */
   548|         if (strm->avail_in && gz_comp(state, Z_BLOCK) == -1)
   549|             return state->err;
   550|         deflateParams(strm, level, strategy);
   551|     }
   552|     state->level = level;
   553|     state->strategy = strategy;
   554|     return Z_OK;
   555| }
   556| /* -- see zlib.h -- */
   557| int ZEXPORT gzclose_w(file)
   558|     gzFile file;
   559| {
   560|     int ret = Z_OK;
   561|     gz_statep state;
   562|     /* get internal structure */
   563|     if (file == NULL)
   564|         return Z_STREAM_ERROR;
   565|     state = (gz_statep)file;
   566|     /* check that we're writing */
   567|     if (state->mode != GZ_WRITE)
   568|         return Z_STREAM_ERROR;
   569|     /* check for seek request */
   570|     if (state->seek) {
   571|         state->seek = 0;
   572|         if (gz_zero(state, state->skip) == -1)
   573|             ret = state->err;
   574|     }
   575|     /* flush, free memory, and close file */
   576|     if (gz_comp(state, Z_FINISH) == -1)
   577|         ret = state->err;
   578|     if (state->size) {
   579|         if (!state->direct) {
   580|             (void)deflateEnd(&(state->strm));
   581|             free(state->out);
   582|         }
   583|         free(state->in);
   584|     }
   585|     gz_error(state, Z_OK, NULL);
   586|     free(state->path);
   587|     if (close(state->fd) == -1)
   588|         ret = Z_ERRNO;
   589|     free(state);
   590|     return ret;
   591| }


# ====================================================================
# FILE: src/native/external/zlib/infback.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-593 ---
     1| /* infback.c -- inflate using a call-back interface
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /*
     6|    This code is largely copied from inflate.c.  Normally either infback.o or
     7|    inflate.o would be linked into an application--not both.  The interface
     8|    with inffast.c is retained so that optimized assembler-coded versions of
     9|    inflate_fast() can be used with either inflate.c or infback.c.
    10|  */
    11| #include "zutil.h"
    12| #include "inftrees.h"
    13| #include "inflate.h"
    14| #include "inffast.h"
    15| /* function prototypes */
    16| local void fixedtables OF((struct inflate_state FAR *state));
    17| /*
    18|    strm provides memory allocation functions in zalloc and zfree, or
    19|    Z_NULL to use the library memory allocation functions.
    20|    windowBits is in the range 8..15, and window is a user-supplied
    21|    window and output buffer that is 2**windowBits bytes.
    22|  */
    23| int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
    24| z_streamp strm;
    25| int windowBits;
    26| unsigned char FAR *window;
    27| const char *version;
    28| int stream_size;
    29| {
    30|     struct inflate_state FAR *state;
    31|     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
    32|         stream_size != (int)(sizeof(z_stream)))
    33|         return Z_VERSION_ERROR;
    34|     if (strm == Z_NULL || window == Z_NULL ||
    35|         windowBits < 8 || windowBits > 15)
    36|         return Z_STREAM_ERROR;
    37|     strm->msg = Z_NULL;                 /* in case we return an error */
    38|     if (strm->zalloc == (alloc_func)0) {
    39| #ifdef Z_SOLO
    40|         return Z_STREAM_ERROR;
    41| #else
    42|         strm->zalloc = zcalloc;
    43|         strm->opaque = (voidpf)0;
    44| #endif
    45|     }
    46|     if (strm->zfree == (free_func)0)
    47| #ifdef Z_SOLO
    48|         return Z_STREAM_ERROR;
    49| #else
    50|     strm->zfree = zcfree;
    51| #endif
    52|     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
    53|                                                sizeof(struct inflate_state));
    54|     if (state == Z_NULL) return Z_MEM_ERROR;
    55|     Tracev((stderr, "inflate: allocated\n"));
    56|     strm->state = (struct internal_state FAR *)state;
    57|     state->dmax = 32768U;
    58|     state->wbits = (uInt)windowBits;
    59|     state->wsize = 1U << windowBits;
    60|     state->window = window;
    61|     state->wnext = 0;
    62|     state->whave = 0;
    63|     state->sane = 1;
    64|     return Z_OK;
    65| }
    66| /*
    67|    Return state with length and distance decoding tables and index sizes set to
    68|    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
    69|    If BUILDFIXED is defined, then instead this routine builds the tables the
    70|    first time it's called, and returns those tables the first time and
    71|    thereafter.  This reduces the size of the code by about 2K bytes, in
    72|    exchange for a little execution time.  However, BUILDFIXED should not be
    73|    used for threaded applications, since the rewriting of the tables and virgin
    74|    may not be thread-safe.
    75|  */
    76| local void fixedtables(state)
    77| struct inflate_state FAR *state;
    78| {
    79| #ifdef BUILDFIXED
    80|     static int virgin = 1;
    81|     static code *lenfix, *distfix;
    82|     static code fixed[544];
    83|     /* build fixed huffman tables if first call (may not be thread safe) */
    84|     if (virgin) {
    85|         unsigned sym, bits;
    86|         static code *next;
    87|         /* literal/length table */
    88|         sym = 0;
    89|         while (sym < 144) state->lens[sym++] = 8;
    90|         while (sym < 256) state->lens[sym++] = 9;
    91|         while (sym < 280) state->lens[sym++] = 7;
    92|         while (sym < 288) state->lens[sym++] = 8;
    93|         next = fixed;
    94|         lenfix = next;
    95|         bits = 9;
    96|         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
    97|         /* distance table */
    98|         sym = 0;
    99|         while (sym < 32) state->lens[sym++] = 5;
   100|         distfix = next;
   101|         bits = 5;
   102|         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
   103|         /* do this just once */
   104|         virgin = 0;
   105|     }
   106| #else /* !BUILDFIXED */
   107| #   include "inffixed.h"
   108| #endif /* BUILDFIXED */
   109|     state->lencode = lenfix;
   110|     state->lenbits = 9;
   111|     state->distcode = distfix;
   112|     state->distbits = 5;
   113| }
   114| /* Macros for inflateBack(): */
   115| /* Load returned state from inflate_fast() */
   116| #define LOAD() \
   117|     do { \
   118|         put = strm->next_out; \
   119|         left = strm->avail_out; \
   120|         next = strm->next_in; \
   121|         have = strm->avail_in; \
   122|         hold = state->hold; \
   123|         bits = state->bits; \
   124|     } while (0)
   125| /* Set state from registers for inflate_fast() */
   126| #define RESTORE() \
   127|     do { \
   128|         strm->next_out = put; \
   129|         strm->avail_out = left; \
   130|         strm->next_in = next; \
   131|         strm->avail_in = have; \
   132|         state->hold = hold; \
   133|         state->bits = bits; \
   134|     } while (0)
   135| /* Clear the input bit accumulator */
   136| #define INITBITS() \
   137|     do { \
   138|         hold = 0; \
   139|         bits = 0; \
   140|     } while (0)
   141| /* Assure that some input is available.  If input is requested, but denied,
   142|    then return a Z_BUF_ERROR from inflateBack(). */
   143| #define PULL() \
   144|     do { \
   145|         if (have == 0) { \
   146|             have = in(in_desc, &next); \
   147|             if (have == 0) { \
   148|                 next = Z_NULL; \
   149|                 ret = Z_BUF_ERROR; \
   150|                 goto inf_leave; \
   151|             } \
   152|         } \
   153|     } while (0)
   154| /* Get a byte of input into the bit accumulator, or return from inflateBack()
   155|    with an error if there is no input available. */
   156| #define PULLBYTE() \
   157|     do { \
   158|         PULL(); \
   159|         have--; \
   160|         hold += (unsigned long)(*next++) << bits; \
   161|         bits += 8; \
   162|     } while (0)
   163| /* Assure that there are at least n bits in the bit accumulator.  If there is
   164|    not enough available input to do that, then return from inflateBack() with
   165|    an error. */
   166| #define NEEDBITS(n) \
   167|     do { \
   168|         while (bits < (unsigned)(n)) \
   169|             PULLBYTE(); \
   170|     } while (0)
   171| /* Return the low n bits of the bit accumulator (n < 16) */
   172| #define BITS(n) \
   173|     ((unsigned)hold & ((1U << (n)) - 1))
   174| /* Remove n bits from the bit accumulator */
   175| #define DROPBITS(n) \
   176|     do { \
   177|         hold >>= (n); \
   178|         bits -= (unsigned)(n); \
   179|     } while (0)
   180| /* Remove zero to seven bits as needed to go to a byte boundary */
   181| #define BYTEBITS() \
   182|     do { \
   183|         hold >>= bits & 7; \
   184|         bits -= bits & 7; \
   185|     } while (0)
   186| /* Assure that some output space is available, by writing out the window
   187|    if it's full.  If the write fails, return from inflateBack() with a
   188|    Z_BUF_ERROR. */
   189| #define ROOM() \
   190|     do { \
   191|         if (left == 0) { \
   192|             put = state->window; \
   193|             left = state->wsize; \
   194|             state->whave = left; \
   195|             if (out(out_desc, put, left)) { \
   196|                 ret = Z_BUF_ERROR; \
   197|                 goto inf_leave; \
   198|             } \
   199|         } \
   200|     } while (0)
   201| /*
   202|    strm provides the memory allocation functions and window buffer on input,
   203|    and provides information on the unused input on return.  For Z_DATA_ERROR
   204|    returns, strm will also provide an error message.
   205|    in() and out() are the call-back input and output functions.  When
   206|    inflateBack() needs more input, it calls in().  When inflateBack() has
   207|    filled the window with output, or when it completes with data in the
   208|    window, it calls out() to write out the data.  The application must not
   209|    change the provided input until in() is called again or inflateBack()
   210|    returns.  The application must not change the window/output buffer until
   211|    inflateBack() returns.
   212|    in() and out() are called with a descriptor parameter provided in the
   213|    inflateBack() call.  This parameter can be a structure that provides the
   214|    information required to do the read or write, as well as accumulated
   215|    information on the input and output such as totals and check values.
   216|    in() should return zero on failure.  out() should return non-zero on
   217|    failure.  If either in() or out() fails, than inflateBack() returns a
   218|    Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
   219|    was in() or out() that caused in the error.  Otherwise,  inflateBack()
   220|    returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   221|    error, or Z_MEM_ERROR if it could not allocate memory for the state.
   222|    inflateBack() can also return Z_STREAM_ERROR if the input parameters
   223|    are not correct, i.e. strm is Z_NULL or the state was not initialized.
   224|  */
   225| int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
   226| z_streamp strm;
   227| in_func in;
   228| void FAR *in_desc;
   229| out_func out;
   230| void FAR *out_desc;
   231| {
   232|     struct inflate_state FAR *state;
   233|     z_const unsigned char FAR *next;    /* next input */
   234|     unsigned char FAR *put;     /* next output */
   235|     unsigned have, left;        /* available input and output */
   236|     unsigned long hold;         /* bit buffer */
   237|     unsigned bits;              /* bits in bit buffer */
   238|     unsigned copy;              /* number of stored or match bytes to copy */
   239|     unsigned char FAR *from;    /* where to copy match bytes from */
   240|     code here;                  /* current decoding table entry */
   241|     code last;                  /* parent table entry */
   242|     unsigned len;               /* length to copy for repeats, bits to drop */
   243|     int ret;                    /* return code */
   244|     static const unsigned short order[19] = /* permutation of code lengths */
   245|         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
   246|     /* Check that the strm exists and that the state was initialized */
   247|     if (strm == Z_NULL || strm->state == Z_NULL)
   248|         return Z_STREAM_ERROR;
   249|     state = (struct inflate_state FAR *)strm->state;
   250|     /* Reset the state */
   251|     strm->msg = Z_NULL;
   252|     state->mode = TYPE;
   253|     state->last = 0;
   254|     state->whave = 0;
   255|     next = strm->next_in;
   256|     have = next != Z_NULL ? strm->avail_in : 0;
   257|     hold = 0;
   258|     bits = 0;
   259|     put = state->window;
   260|     left = state->wsize;
   261|     /* Inflate until end of block marked as last */
   262|     for (;;)
   263|         switch (state->mode) {
   264|         case TYPE:
   265|             /* determine and dispatch block type */
   266|             if (state->last) {
   267|                 BYTEBITS();
   268|                 state->mode = DONE;
   269|                 break;
   270|             }
   271|             NEEDBITS(3);
   272|             state->last = BITS(1);
   273|             DROPBITS(1);
   274|             switch (BITS(2)) {
   275|             case 0:                             /* stored block */
   276|                 Tracev((stderr, "inflate:     stored block%s\n",
   277|                         state->last ? " (last)" : ""));
   278|                 state->mode = STORED;
   279|                 break;
   280|             case 1:                             /* fixed block */
   281|                 fixedtables(state);
   282|                 Tracev((stderr, "inflate:     fixed codes block%s\n",
   283|                         state->last ? " (last)" : ""));
   284|                 state->mode = LEN;              /* decode codes */
   285|                 break;
   286|             case 2:                             /* dynamic block */
   287|                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
   288|                         state->last ? " (last)" : ""));
   289|                 state->mode = TABLE;
   290|                 break;
   291|             case 3:
   292|                 strm->msg = (char *)"invalid block type";
   293|                 state->mode = BAD;
   294|             }
   295|             DROPBITS(2);
   296|             break;
   297|         case STORED:
   298|             /* get and verify stored block length */
   299|             BYTEBITS();                         /* go to byte boundary */
   300|             NEEDBITS(32);
   301|             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
   302|                 strm->msg = (char *)"invalid stored block lengths";
   303|                 state->mode = BAD;
   304|                 break;
   305|             }
   306|             state->length = (unsigned)hold & 0xffff;
   307|             Tracev((stderr, "inflate:       stored length %u\n",
   308|                     state->length));
   309|             INITBITS();
   310|             /* copy stored block from input to output */
   311|             while (state->length != 0) {
   312|                 copy = state->length;
   313|                 PULL();
   314|                 ROOM();
   315|                 if (copy > have) copy = have;
   316|                 if (copy > left) copy = left;
   317|                 zmemcpy(put, next, copy);
   318|                 have -= copy;
   319|                 next += copy;
   320|                 left -= copy;
   321|                 put += copy;
   322|                 state->length -= copy;
   323|             }
   324|             Tracev((stderr, "inflate:       stored end\n"));
   325|             state->mode = TYPE;
   326|             break;
   327|         case TABLE:
   328|             /* get dynamic table entries descriptor */
   329|             NEEDBITS(14);
   330|             state->nlen = BITS(5) + 257;
   331|             DROPBITS(5);
   332|             state->ndist = BITS(5) + 1;
   333|             DROPBITS(5);
   334|             state->ncode = BITS(4) + 4;
   335|             DROPBITS(4);
   336| #ifndef PKZIP_BUG_WORKAROUND
   337|             if (state->nlen > 286 || state->ndist > 30) {
   338|                 strm->msg = (char *)"too many length or distance symbols";
   339|                 state->mode = BAD;
   340|                 break;
   341|             }
   342| #endif
   343|             Tracev((stderr, "inflate:       table sizes ok\n"));
   344|             /* get code length code lengths (not a typo) */
   345|             state->have = 0;
   346|             while (state->have < state->ncode) {
   347|                 NEEDBITS(3);
   348|                 state->lens[order[state->have++]] = (unsigned short)BITS(3);
   349|                 DROPBITS(3);
   350|             }
   351|             while (state->have < 19)
   352|                 state->lens[order[state->have++]] = 0;
   353|             state->next = state->codes;
   354|             state->lencode = (code const FAR *)(state->next);
   355|             state->lenbits = 7;
   356|             ret = inflate_table(CODES, state->lens, 19, &(state->next),
   357|                                 &(state->lenbits), state->work);
   358|             if (ret) {
   359|                 strm->msg = (char *)"invalid code lengths set";
   360|                 state->mode = BAD;
   361|                 break;
   362|             }
   363|             Tracev((stderr, "inflate:       code lengths ok\n"));
   364|             /* get length and distance code code lengths */
   365|             state->have = 0;
   366|             while (state->have < state->nlen + state->ndist) {
   367|                 for (;;) {
   368|                     here = state->lencode[BITS(state->lenbits)];
   369|                     if ((unsigned)(here.bits) <= bits) break;
   370|                     PULLBYTE();
   371|                 }
   372|                 if (here.val < 16) {
   373|                     DROPBITS(here.bits);
   374|                     state->lens[state->have++] = here.val;
   375|                 }
   376|                 else {
   377|                     if (here.val == 16) {
   378|                         NEEDBITS(here.bits + 2);
   379|                         DROPBITS(here.bits);
   380|                         if (state->have == 0) {
   381|                             strm->msg = (char *)"invalid bit length repeat";
   382|                             state->mode = BAD;
   383|                             break;
   384|                         }
   385|                         len = (unsigned)(state->lens[state->have - 1]);
   386|                         copy = 3 + BITS(2);
   387|                         DROPBITS(2);
   388|                     }
   389|                     else if (here.val == 17) {
   390|                         NEEDBITS(here.bits + 3);
   391|                         DROPBITS(here.bits);
   392|                         len = 0;
   393|                         copy = 3 + BITS(3);
   394|                         DROPBITS(3);
   395|                     }
   396|                     else {
   397|                         NEEDBITS(here.bits + 7);
   398|                         DROPBITS(here.bits);
   399|                         len = 0;
   400|                         copy = 11 + BITS(7);
   401|                         DROPBITS(7);
   402|                     }
   403|                     if (state->have + copy > state->nlen + state->ndist) {
   404|                         strm->msg = (char *)"invalid bit length repeat";
   405|                         state->mode = BAD;
   406|                         break;
   407|                     }
   408|                     while (copy--)
   409|                         state->lens[state->have++] = (unsigned short)len;
   410|                 }
   411|             }
   412|             /* handle error breaks in while */
   413|             if (state->mode == BAD) break;
   414|             /* check for end-of-block code (better have one) */
   415|             if (state->lens[256] == 0) {
   416|                 strm->msg = (char *)"invalid code -- missing end-of-block";
   417|                 state->mode = BAD;
   418|                 break;
   419|             }
   420|             /* build code tables -- note: do not change the lenbits or distbits
   421|                values here (9 and 6) without reading the comments in inftrees.h
   422|                concerning the ENOUGH constants, which depend on those values */
   423|             state->next = state->codes;
   424|             state->lencode = (code const FAR *)(state->next);
   425|             state->lenbits = 9;
   426|             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
   427|                                 &(state->lenbits), state->work);
   428|             if (ret) {
   429|                 strm->msg = (char *)"invalid literal/lengths set";
   430|                 state->mode = BAD;
   431|                 break;
   432|             }
   433|             state->distcode = (code const FAR *)(state->next);
   434|             state->distbits = 6;
   435|             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
   436|                             &(state->next), &(state->distbits), state->work);
   437|             if (ret) {
   438|                 strm->msg = (char *)"invalid distances set";
   439|                 state->mode = BAD;
   440|                 break;
   441|             }
   442|             Tracev((stderr, "inflate:       codes ok\n"));
   443|             state->mode = LEN;
   444|                 /* fallthrough */
   445|         case LEN:
   446|             /* use inflate_fast() if we have enough input and output */
   447|             if (have >= 6 && left >= 258) {
   448|                 RESTORE();
   449|                 if (state->whave < state->wsize)
   450|                     state->whave = state->wsize - left;
   451|                 inflate_fast(strm, state->wsize);
   452|                 LOAD();
   453|                 break;
   454|             }
   455|             /* get a literal, length, or end-of-block code */
   456|             for (;;) {
   457|                 here = state->lencode[BITS(state->lenbits)];
   458|                 if ((unsigned)(here.bits) <= bits) break;
   459|                 PULLBYTE();
   460|             }
   461|             if (here.op && (here.op & 0xf0) == 0) {
   462|                 last = here;
   463|                 for (;;) {
   464|                     here = state->lencode[last.val +
   465|                             (BITS(last.bits + last.op) >> last.bits)];
   466|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
   467|                     PULLBYTE();
   468|                 }
   469|                 DROPBITS(last.bits);
   470|             }
   471|             DROPBITS(here.bits);
   472|             state->length = (unsigned)here.val;
   473|             /* process literal */
   474|             if (here.op == 0) {
   475|                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
   476|                         "inflate:         literal '%c'\n" :
   477|                         "inflate:         literal 0x%02x\n", here.val));
   478|                 ROOM();
   479|                 *put++ = (unsigned char)(state->length);
   480|                 left--;
   481|                 state->mode = LEN;
   482|                 break;
   483|             }
   484|             /* process end of block */
   485|             if (here.op & 32) {
   486|                 Tracevv((stderr, "inflate:         end of block\n"));
   487|                 state->mode = TYPE;
   488|                 break;
   489|             }
   490|             /* invalid code */
   491|             if (here.op & 64) {
   492|                 strm->msg = (char *)"invalid literal/length code";
   493|                 state->mode = BAD;
   494|                 break;
   495|             }
   496|             /* length code -- get extra bits, if any */
   497|             state->extra = (unsigned)(here.op) & 15;
   498|             if (state->extra != 0) {
   499|                 NEEDBITS(state->extra);
   500|                 state->length += BITS(state->extra);
   501|                 DROPBITS(state->extra);
   502|             }
   503|             Tracevv((stderr, "inflate:         length %u\n", state->length));
   504|             /* get distance code */
   505|             for (;;) {
   506|                 here = state->distcode[BITS(state->distbits)];
   507|                 if ((unsigned)(here.bits) <= bits) break;
   508|                 PULLBYTE();
   509|             }
   510|             if ((here.op & 0xf0) == 0) {
   511|                 last = here;
   512|                 for (;;) {
   513|                     here = state->distcode[last.val +
   514|                             (BITS(last.bits + last.op) >> last.bits)];
   515|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
   516|                     PULLBYTE();
   517|                 }
   518|                 DROPBITS(last.bits);
   519|             }
   520|             DROPBITS(here.bits);
   521|             if (here.op & 64) {
   522|                 strm->msg = (char *)"invalid distance code";
   523|                 state->mode = BAD;
   524|                 break;
   525|             }
   526|             state->offset = (unsigned)here.val;
   527|             /* get distance extra bits, if any */
   528|             state->extra = (unsigned)(here.op) & 15;
   529|             if (state->extra != 0) {
   530|                 NEEDBITS(state->extra);
   531|                 state->offset += BITS(state->extra);
   532|                 DROPBITS(state->extra);
   533|             }
   534|             if (state->offset > state->wsize - (state->whave < state->wsize ?
   535|                                                 left : 0)) {
   536|                 strm->msg = (char *)"invalid distance too far back";
   537|                 state->mode = BAD;
   538|                 break;
   539|             }
   540|             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
   541|             /* copy match from window to output */
   542|             do {
   543|                 ROOM();
   544|                 copy = state->wsize - state->offset;
   545|                 if (copy < left) {
   546|                     from = put + copy;
   547|                     copy = left - copy;
   548|                 }
   549|                 else {
   550|                     from = put - state->offset;
   551|                     copy = left;
   552|                 }
   553|                 if (copy > state->length) copy = state->length;
   554|                 state->length -= copy;
   555|                 left -= copy;
   556|                 do {
   557|                     *put++ = *from++;
   558|                 } while (--copy);
   559|             } while (state->length != 0);
   560|             break;
   561|         case DONE:
   562|             /* inflate stream terminated properly */
   563|             ret = Z_STREAM_END;
   564|             goto inf_leave;
   565|         case BAD:
   566|             ret = Z_DATA_ERROR;
   567|             goto inf_leave;
   568|         default:
   569|             /* can't happen, but makes compilers happy */
   570|             ret = Z_STREAM_ERROR;
   571|             goto inf_leave;
   572|         }
   573|     /* Write leftover output and return unused input */
   574|   inf_leave:
   575|     if (left < state->wsize) {
   576|         if (out(out_desc, state->window, state->wsize - left) &&
   577|             ret == Z_STREAM_END)
   578|             ret = Z_BUF_ERROR;
   579|     }
   580|     strm->next_in = next;
   581|     strm->avail_in = have;
   582|     return ret;
   583| }
   584| int ZEXPORT inflateBackEnd(strm)
   585| z_streamp strm;
   586| {
   587|     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
   588|         return Z_STREAM_ERROR;
   589|     ZFREE(strm, strm->state);
   590|     strm->state = Z_NULL;
   591|     Tracev((stderr, "inflate: end\n"));
   592|     return Z_OK;
   593| }


# ====================================================================
# FILE: src/native/external/zlib/inflate.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1496 ---
     1| /* inflate.c -- zlib decompression
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /*
     6|  * Change history:
     7|  *
     8|  * 1.2.beta0    24 Nov 2002
     9|  * - First version -- complete rewrite of inflate to simplify code, avoid
    10|  *   creation of window when not needed, minimize use of window when it is
    11|  *   needed, make inffast.c even faster, implement gzip decoding, and to
    12|  *   improve code readability and style over the previous zlib inflate code
    13|  *
    14|  * 1.2.beta1    25 Nov 2002
    15|  * - Use pointers for available input and output checking in inffast.c
    16|  * - Remove input and output counters in inffast.c
    17|  * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
    18|  * - Remove unnecessary second byte pull from length extra in inffast.c
    19|  * - Unroll direct copy to three copies per loop in inffast.c
    20|  *
    21|  * 1.2.beta2    4 Dec 2002
    22|  * - Change external routine names to reduce potential conflicts
    23|  * - Correct filename to inffixed.h for fixed tables in inflate.c
    24|  * - Make hbuf[] unsigned char to match parameter type in inflate.c
    25|  * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
    26|  *   to avoid negation problem on Alphas (64 bit) in inflate.c
    27|  *
    28|  * 1.2.beta3    22 Dec 2002
    29|  * - Add comments on state->bits assertion in inffast.c
    30|  * - Add comments on op field in inftrees.h
    31|  * - Fix bug in reuse of allocated window after inflateReset()
    32|  * - Remove bit fields--back to byte structure for speed
    33|  * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
    34|  * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
    35|  * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
    36|  * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
    37|  * - Use local copies of stream next and avail values, as well as local bit
    38|  *   buffer and bit count in inflate()--for speed when inflate_fast() not used
    39|  *
    40|  * 1.2.beta4    1 Jan 2003
    41|  * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
    42|  * - Move a comment on output buffer sizes from inffast.c to inflate.c
    43|  * - Add comments in inffast.c to introduce the inflate_fast() routine
    44|  * - Rearrange window copies in inflate_fast() for speed and simplification
    45|  * - Unroll last copy for window match in inflate_fast()
    46|  * - Use local copies of window variables in inflate_fast() for speed
    47|  * - Pull out common wnext == 0 case for speed in inflate_fast()
    48|  * - Make op and len in inflate_fast() unsigned for consistency
    49|  * - Add FAR to lcode and dcode declarations in inflate_fast()
    50|  * - Simplified bad distance check in inflate_fast()
    51|  * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
    52|  *   source file infback.c to provide a call-back interface to inflate for
    53|  *   programs like gzip and unzip -- uses window as output buffer to avoid
    54|  *   window copying
    55|  *
    56|  * 1.2.beta5    1 Jan 2003
    57|  * - Improved inflateBack() interface to allow the caller to provide initial
    58|  *   input in strm.
    59|  * - Fixed stored blocks bug in inflateBack()
    60|  *
    61|  * 1.2.beta6    4 Jan 2003
    62|  * - Added comments in inffast.c on effectiveness of POSTINC
    63|  * - Typecasting all around to reduce compiler warnings
    64|  * - Changed loops from while (1) or do {} while (1) to for (;;), again to
    65|  *   make compilers happy
    66|  * - Changed type of window in inflateBackInit() to unsigned char *
    67|  *
    68|  * 1.2.beta7    27 Jan 2003
    69|  * - Changed many types to unsigned or unsigned short to avoid warnings
    70|  * - Added inflateCopy() function
    71|  *
    72|  * 1.2.0        9 Mar 2003
    73|  * - Changed inflateBack() interface to provide separate opaque descriptors
    74|  *   for the in() and out() functions
    75|  * - Changed inflateBack() argument and in_func typedef to swap the length
    76|  *   and buffer address return values for the input function
    77|  * - Check next_in and next_out for Z_NULL on entry to inflate()
    78|  *
    79|  * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
    80|  */
    81| #include "zutil.h"
    82| #include "inftrees.h"
    83| #include "inflate.h"
    84| #include "inffast.h"
    85| #ifdef MAKEFIXED
    86| #  ifndef BUILDFIXED
    87| #    define BUILDFIXED
    88| #  endif
    89| #endif
    90| /* function prototypes */
    91| local int inflateStateCheck OF((z_streamp strm));
    92| local void fixedtables OF((struct inflate_state FAR *state));
    93| local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
    94|                            unsigned copy));
    95| #ifdef BUILDFIXED
    96|    void makefixed OF((void));
    97| #endif
    98| local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
    99|                               unsigned len));
   100| local int inflateStateCheck(strm)
   101| z_streamp strm;
   102| {
   103|     struct inflate_state FAR *state;
   104|     if (strm == Z_NULL ||
   105|         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
   106|         return 1;
   107|     state = (struct inflate_state FAR *)strm->state;
   108|     if (state == Z_NULL || state->strm != strm ||
   109|         state->mode < HEAD || state->mode > SYNC)
   110|         return 1;
   111|     return 0;
   112| }
   113| int ZEXPORT inflateResetKeep(strm)
   114| z_streamp strm;
   115| {
   116|     struct inflate_state FAR *state;
   117|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   118|     state = (struct inflate_state FAR *)strm->state;
   119|     strm->total_in = strm->total_out = state->total = 0;
   120|     strm->msg = Z_NULL;
   121|     if (state->wrap)        /* to support ill-conceived Java test suite */
   122|         strm->adler = state->wrap & 1;
   123|     state->mode = HEAD;
   124|     state->last = 0;
   125|     state->havedict = 0;
   126|     state->flags = -1;
   127|     state->dmax = 32768U;
   128|     state->head = Z_NULL;
   129|     state->hold = 0;
   130|     state->bits = 0;
   131|     state->lencode = state->distcode = state->next = state->codes;
   132|     state->sane = 1;
   133|     state->back = -1;
   134|     Tracev((stderr, "inflate: reset\n"));
   135|     return Z_OK;
   136| }
   137| int ZEXPORT inflateReset(strm)
   138| z_streamp strm;
   139| {
   140|     struct inflate_state FAR *state;
   141|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   142|     state = (struct inflate_state FAR *)strm->state;
   143|     state->wsize = 0;
   144|     state->whave = 0;
   145|     state->wnext = 0;
   146|     return inflateResetKeep(strm);
   147| }
   148| int ZEXPORT inflateReset2(strm, windowBits)
   149| z_streamp strm;
   150| int windowBits;
   151| {
   152|     int wrap;
   153|     struct inflate_state FAR *state;
   154|     /* get the state */
   155|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   156|     state = (struct inflate_state FAR *)strm->state;
   157|     /* extract wrap request from windowBits parameter */
   158|     if (windowBits < 0) {
   159|         if (windowBits < -15)
   160|             return Z_STREAM_ERROR;
   161|         wrap = 0;
   162|         windowBits = -windowBits;
   163|     }
   164|     else {
   165|         wrap = (windowBits >> 4) + 5;
   166| #ifdef GUNZIP
   167|         if (windowBits < 48)
   168|             windowBits &= 15;
   169| #endif
   170|     }
   171|     /* set number of window bits, free window if different */
   172|     if (windowBits && (windowBits < 8 || windowBits > 15))
   173|         return Z_STREAM_ERROR;
   174|     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
   175|         ZFREE(strm, state->window);
   176|         state->window = Z_NULL;
   177|     }
   178|     /* update state and reset the rest of it */
   179|     state->wrap = wrap;
   180|     state->wbits = (unsigned)windowBits;
   181|     return inflateReset(strm);
   182| }
   183| int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
   184| z_streamp strm;
   185| int windowBits;
   186| const char *version;
   187| int stream_size;
   188| {
   189|     int ret;
   190|     struct inflate_state FAR *state;
   191|     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
   192|         stream_size != (int)(sizeof(z_stream)))
   193|         return Z_VERSION_ERROR;
   194|     if (strm == Z_NULL) return Z_STREAM_ERROR;
   195|     strm->msg = Z_NULL;                 /* in case we return an error */
   196|     if (strm->zalloc == (alloc_func)0) {
   197| #ifdef Z_SOLO
   198|         return Z_STREAM_ERROR;
   199| #else
   200|         strm->zalloc = zcalloc;
   201|         strm->opaque = (voidpf)0;
   202| #endif
   203|     }
   204|     if (strm->zfree == (free_func)0)
   205| #ifdef Z_SOLO
   206|         return Z_STREAM_ERROR;
   207| #else
   208|         strm->zfree = zcfree;
   209| #endif
   210|     state = (struct inflate_state FAR *)
   211|             ZALLOC(strm, 1, sizeof(struct inflate_state));
   212|     if (state == Z_NULL) return Z_MEM_ERROR;
   213|     Tracev((stderr, "inflate: allocated\n"));
   214|     strm->state = (struct internal_state FAR *)state;
   215|     state->strm = strm;
   216|     state->window = Z_NULL;
   217|     state->mode = HEAD;     /* to pass state test in inflateReset2() */
   218|     ret = inflateReset2(strm, windowBits);
   219|     if (ret != Z_OK) {
   220|         ZFREE(strm, state);
   221|         strm->state = Z_NULL;
   222|     }
   223|     return ret;
   224| }
   225| int ZEXPORT inflateInit_(strm, version, stream_size)
   226| z_streamp strm;
   227| const char *version;
   228| int stream_size;
   229| {
   230|     return inflateInit2_(strm, DEF_WBITS, version, stream_size);
   231| }
   232| int ZEXPORT inflatePrime(strm, bits, value)
   233| z_streamp strm;
   234| int bits;
   235| int value;
   236| {
   237|     struct inflate_state FAR *state;
   238|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
   239|     state = (struct inflate_state FAR *)strm->state;
   240|     if (bits < 0) {
   241|         state->hold = 0;
   242|         state->bits = 0;
   243|         return Z_OK;
   244|     }
   245|     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;
   246|     value &= (1L << bits) - 1;
   247|     state->hold += (unsigned)value << state->bits;
   248|     state->bits += (uInt)bits;
   249|     return Z_OK;
   250| }
   251| /*
   252|    Return state with length and distance decoding tables and index sizes set to
   253|    fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   254|    If BUILDFIXED is defined, then instead this routine builds the tables the
   255|    first time it's called, and returns those tables the first time and
   256|    thereafter.  This reduces the size of the code by about 2K bytes, in
   257|    exchange for a little execution time.  However, BUILDFIXED should not be
   258|    used for threaded applications, since the rewriting of the tables and virgin
   259|    may not be thread-safe.
   260|  */
   261| local void fixedtables(state)
   262| struct inflate_state FAR *state;
   263| {
   264| #ifdef BUILDFIXED
   265|     static int virgin = 1;
   266|     static code *lenfix, *distfix;
   267|     static code fixed[544];
   268|     /* build fixed huffman tables if first call (may not be thread safe) */
   269|     if (virgin) {
   270|         unsigned sym, bits;
   271|         static code *next;
   272|         /* literal/length table */
   273|         sym = 0;
   274|         while (sym < 144) state->lens[sym++] = 8;
   275|         while (sym < 256) state->lens[sym++] = 9;
   276|         while (sym < 280) state->lens[sym++] = 7;
   277|         while (sym < 288) state->lens[sym++] = 8;
   278|         next = fixed;
   279|         lenfix = next;
   280|         bits = 9;
   281|         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
   282|         /* distance table */
   283|         sym = 0;
   284|         while (sym < 32) state->lens[sym++] = 5;
   285|         distfix = next;
   286|         bits = 5;
   287|         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
   288|         /* do this just once */
   289|         virgin = 0;
   290|     }
   291| #else /* !BUILDFIXED */
   292| #   include "inffixed.h"
   293| #endif /* BUILDFIXED */
   294|     state->lencode = lenfix;
   295|     state->lenbits = 9;
   296|     state->distcode = distfix;
   297|     state->distbits = 5;
   298| }
   299| #ifdef MAKEFIXED
   300| #include <stdio.h>
   301| /*
   302|    Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   303|    defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   304|    those tables to stdout, which would be piped to inffixed.h.  A small program
   305|    can simply call makefixed to do this:
   306|     void makefixed(void);
   307|     int main(void)
   308|     {
   309|         makefixed();
   310|         return 0;
   311|     }
   312|    Then that can be linked with zlib built with MAKEFIXED defined and run:
   313|     a.out > inffixed.h
   314|  */
   315| void makefixed()
   316| {
   317|     unsigned low, size;
   318|     struct inflate_state state;
   319|     fixedtables(&state);
   320|     puts("    /* inffixed.h -- table for decoding fixed codes");
   321|     puts("     * Generated automatically by makefixed().");
   322|     puts("     */");
   323|     puts("");
   324|     puts("    /* WARNING: this file should *not* be used by applications.");
   325|     puts("       It is part of the implementation of this library and is");
   326|     puts("       subject to change. Applications should only use zlib.h.");
   327|     puts("     */");
   328|     puts("");
   329|     size = 1U << 9;
   330|     printf("    static const code lenfix[%u] = {", size);
   331|     low = 0;
   332|     for (;;) {
   333|         if ((low % 7) == 0) printf("\n        ");
   334|         printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
   335|                state.lencode[low].bits, state.lencode[low].val);
   336|         if (++low == size) break;
   337|         putchar(',');
   338|     }
   339|     puts("\n    };");
   340|     size = 1U << 5;
   341|     printf("\n    static const code distfix[%u] = {", size);
   342|     low = 0;
   343|     for (;;) {
   344|         if ((low % 6) == 0) printf("\n        ");
   345|         printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
   346|                state.distcode[low].val);
   347|         if (++low == size) break;
   348|         putchar(',');
   349|     }
   350|     puts("\n    };");
   351| }
   352| #endif /* MAKEFIXED */
   353| /*
   354|    Update the window with the last wsize (normally 32K) bytes written before
   355|    returning.  If window does not exist yet, create it.  This is only called
   356|    when a window is already in use, or when output has been written during this
   357|    inflate call, but the end of the deflate stream has not been reached yet.
   358|    It is also called to create a window for dictionary data when a dictionary
   359|    is loaded.
   360|    Providing output buffers larger than 32K to inflate() should provide a speed
   361|    advantage, since only the last 32K of output is copied to the sliding window
   362|    upon return from inflate(), and since all distances after the first 32K of
   363|    output will fall in the output data, making match copies simpler and faster.
   364|    The advantage may be dependent on the size of the processor's data caches.
   365|  */
   366| local int updatewindow(strm, end, copy)
   367| z_streamp strm;
   368| const Bytef *end;
   369| unsigned copy;
   370| {
   371|     struct inflate_state FAR *state;
   372|     unsigned dist;
   373|     state = (struct inflate_state FAR *)strm->state;
   374|     /* if it hasn't been done already, allocate space for the window */
   375|     if (state->window == Z_NULL) {
   376|         state->window = (unsigned char FAR *)
   377|                         ZALLOC(strm, 1U << state->wbits,
   378|                                sizeof(unsigned char));
   379|         if (state->window == Z_NULL) return 1;
   380|     }
   381|     /* if window not in use yet, initialize */
   382|     if (state->wsize == 0) {
   383|         state->wsize = 1U << state->wbits;
   384|         state->wnext = 0;
   385|         state->whave = 0;
   386|     }
   387|     /* copy state->wsize or less output bytes into the circular window */
   388|     if (copy >= state->wsize) {
   389|         zmemcpy(state->window, end - state->wsize, state->wsize);
   390|         state->wnext = 0;
   391|         state->whave = state->wsize;
   392|     }
   393|     else {
   394|         dist = state->wsize - state->wnext;
   395|         if (dist > copy) dist = copy;
   396|         zmemcpy(state->window + state->wnext, end - copy, dist);
   397|         copy -= dist;
   398|         if (copy) {
   399|             zmemcpy(state->window, end - copy, copy);
   400|             state->wnext = copy;
   401|             state->whave = state->wsize;
   402|         }
   403|         else {
   404|             state->wnext += dist;
   405|             if (state->wnext == state->wsize) state->wnext = 0;
   406|             if (state->whave < state->wsize) state->whave += dist;
   407|         }
   408|     }
   409|     return 0;
   410| }
   411| /* Macros for inflate(): */
   412| /* check function to use adler32() for zlib or crc32() for gzip */
   413| #ifdef GUNZIP
   414| #  define UPDATE_CHECK(check, buf, len) \
   415|     (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
   416| #else
   417| #  define UPDATE_CHECK(check, buf, len) adler32(check, buf, len)
   418| #endif
   419| /* check macros for header crc */
   420| #ifdef GUNZIP
   421| #  define CRC2(check, word) \
   422|     do { \
   423|         hbuf[0] = (unsigned char)(word); \
   424|         hbuf[1] = (unsigned char)((word) >> 8); \
   425|         check = crc32(check, hbuf, 2); \
   426|     } while (0)
   427| #  define CRC4(check, word) \
   428|     do { \
   429|         hbuf[0] = (unsigned char)(word); \
   430|         hbuf[1] = (unsigned char)((word) >> 8); \
   431|         hbuf[2] = (unsigned char)((word) >> 16); \
   432|         hbuf[3] = (unsigned char)((word) >> 24); \
   433|         check = crc32(check, hbuf, 4); \
   434|     } while (0)
   435| #endif
   436| /* Load registers with state in inflate() for speed */
   437| #define LOAD() \
   438|     do { \
   439|         put = strm->next_out; \
   440|         left = strm->avail_out; \
   441|         next = strm->next_in; \
   442|         have = strm->avail_in; \
   443|         hold = state->hold; \
   444|         bits = state->bits; \
   445|     } while (0)
   446| /* Restore state from registers in inflate() */
   447| #define RESTORE() \
   448|     do { \
   449|         strm->next_out = put; \
   450|         strm->avail_out = left; \
   451|         strm->next_in = next; \
   452|         strm->avail_in = have; \
   453|         state->hold = hold; \
   454|         state->bits = bits; \
   455|     } while (0)
   456| /* Clear the input bit accumulator */
   457| #define INITBITS() \
   458|     do { \
   459|         hold = 0; \
   460|         bits = 0; \
   461|     } while (0)
   462| /* Get a byte of input into the bit accumulator, or return from inflate()
   463|    if there is no input available. */
   464| #define PULLBYTE() \
   465|     do { \
   466|         if (have == 0) goto inf_leave; \
   467|         have--; \
   468|         hold += (unsigned long)(*next++) << bits; \
   469|         bits += 8; \
   470|     } while (0)
   471| /* Assure that there are at least n bits in the bit accumulator.  If there is
   472|    not enough available input to do that, then return from inflate(). */
   473| #define NEEDBITS(n) \
   474|     do { \
   475|         while (bits < (unsigned)(n)) \
   476|             PULLBYTE(); \
   477|     } while (0)
   478| /* Return the low n bits of the bit accumulator (n < 16) */
   479| #define BITS(n) \
   480|     ((unsigned)hold & ((1U << (n)) - 1))
   481| /* Remove n bits from the bit accumulator */
   482| #define DROPBITS(n) \
   483|     do { \
   484|         hold >>= (n); \
   485|         bits -= (unsigned)(n); \
   486|     } while (0)
   487| /* Remove zero to seven bits as needed to go to a byte boundary */
   488| #define BYTEBITS() \
   489|     do { \
   490|         hold >>= bits & 7; \
   491|         bits -= bits & 7; \
   492|     } while (0)
   493| /*
   494|    inflate() uses a state machine to process as much input data and generate as
   495|    much output data as possible before returning.  The state machine is
   496|    structured roughly as follows:
   497|     for (;;) switch (state) {
   498|     ...
   499|     case STATEn:
   500|         if (not enough input data or output space to make progress)
   501|             return;
   502|         ... make progress ...
   503|         state = STATEm;
   504|         break;
   505|     ...
   506|     }
   507|    so when inflate() is called again, the same case is attempted again, and
   508|    if the appropriate resources are provided, the machine proceeds to the
   509|    next state.  The NEEDBITS() macro is usually the way the state evaluates
   510|    whether it can proceed or should return.  NEEDBITS() does the return if
   511|    the requested bits are not available.  The typical use of the BITS macros
   512|    is:
   513|         NEEDBITS(n);
   514|         ... do something with BITS(n) ...
   515|         DROPBITS(n);
   516|    where NEEDBITS(n) either returns from inflate() if there isn't enough
   517|    input left to load n bits into the accumulator, or it continues.  BITS(n)
   518|    gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   519|    the low n bits off the accumulator.  INITBITS() clears the accumulator
   520|    and sets the number of available bits to zero.  BYTEBITS() discards just
   521|    enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   522|    and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.
   523|    NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   524|    if there is no input available.  The decoding of variable length codes uses
   525|    PULLBYTE() directly in order to pull just enough bytes to decode the next
   526|    code, and no more.
   527|    Some states loop until they get enough input, making sure that enough
   528|    state information is maintained to continue the loop where it left off
   529|    if NEEDBITS() returns in the loop.  For example, want, need, and keep
   530|    would all have to actually be part of the saved state in case NEEDBITS()
   531|    returns:
   532|     case STATEw:
   533|         while (want < need) {
   534|             NEEDBITS(n);
   535|             keep[want++] = BITS(n);
   536|             DROPBITS(n);
   537|         }
   538|         state = STATEx;
   539|     case STATEx:
   540|    As shown above, if the next state is also the next case, then the break
   541|    is omitted.
   542|    A state may also return if there is not enough output space available to
   543|    complete that state.  Those states are copying stored data, writing a
   544|    literal byte, and copying a matching string.
   545|    When returning, a "goto inf_leave" is used to update the total counters,
   546|    update the check value, and determine whether any progress has been made
   547|    during that inflate() call in order to return the proper return code.
   548|    Progress is defined as a change in either strm->avail_in or strm->avail_out.
   549|    When there is a window, goto inf_leave will update the window with the last
   550|    output written.  If a goto inf_leave occurs in the middle of decompression
   551|    and there is no window currently, goto inf_leave will create one and copy
   552|    output to the window for the next call of inflate().
   553|    In this implementation, the flush parameter of inflate() only affects the
   554|    return code (per zlib.h).  inflate() always writes as much as possible to
   555|    strm->next_out, given the space available and the provided input--the effect
   556|    documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   557|    the allocation of and copying into a sliding window until necessary, which
   558|    provides the effect documented in zlib.h for Z_FINISH when the entire input
   559|    stream available.  So the only thing the flush parameter actually does is:
   560|    when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   561|    will return Z_BUF_ERROR if it has not reached the end of the stream.
   562|  */
   563| int ZEXPORT inflate(strm, flush)
   564| z_streamp strm;
   565| int flush;
   566| {
   567|     struct inflate_state FAR *state;
   568|     z_const unsigned char FAR *next;    /* next input */
   569|     unsigned char FAR *put;     /* next output */
   570|     unsigned have, left;        /* available input and output */
   571|     unsigned long hold;         /* bit buffer */
   572|     unsigned bits;              /* bits in bit buffer */
   573|     unsigned in, out;           /* save starting available input and output */
   574|     unsigned copy;              /* number of stored or match bytes to copy */
   575|     unsigned char FAR *from;    /* where to copy match bytes from */
   576|     code here;                  /* current decoding table entry */
   577|     code last;                  /* parent table entry */
   578|     unsigned len;               /* length to copy for repeats, bits to drop */
   579|     int ret;                    /* return code */
   580| #ifdef GUNZIP
   581|     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
   582| #endif
   583|     static const unsigned short order[19] = /* permutation of code lengths */
   584|         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
   585|     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
   586|         (strm->next_in == Z_NULL && strm->avail_in != 0))
   587|         return Z_STREAM_ERROR;
   588|     state = (struct inflate_state FAR *)strm->state;
   589|     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
   590|     LOAD();
   591|     in = have;
   592|     out = left;
   593|     ret = Z_OK;
   594|     for (;;)
   595|         switch (state->mode) {
   596|         case HEAD:
   597|             if (state->wrap == 0) {
   598|                 state->mode = TYPEDO;
   599|                 break;
   600|             }
   601|             NEEDBITS(16);
   602| #ifdef GUNZIP
   603|             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
   604|                 if (state->wbits == 0)
   605|                     state->wbits = 15;
   606|                 state->check = crc32(0L, Z_NULL, 0);
   607|                 CRC2(state->check, hold);
   608|                 INITBITS();
   609|                 state->mode = FLAGS;
   610|                 break;
   611|             }
   612|             if (state->head != Z_NULL)
   613|                 state->head->done = -1;
   614|             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
   615| #else
   616|             if (
   617| #endif
   618|                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
   619|                 strm->msg = (char *)"incorrect header check";
   620|                 state->mode = BAD;
   621|                 break;
   622|             }
   623|             if (BITS(4) != Z_DEFLATED) {
   624|                 strm->msg = (char *)"unknown compression method";
   625|                 state->mode = BAD;
   626|                 break;
   627|             }
   628|             DROPBITS(4);
   629|             len = BITS(4) + 8;
   630|             if (state->wbits == 0)
   631|                 state->wbits = len;
   632|             if (len > 15 || len > state->wbits) {
   633|                 strm->msg = (char *)"invalid window size";
   634|                 state->mode = BAD;
   635|                 break;
   636|             }
   637|             state->dmax = 1U << len;
   638|             state->flags = 0;               /* indicate zlib header */
   639|             Tracev((stderr, "inflate:   zlib header ok\n"));
   640|             strm->adler = state->check = adler32(0L, Z_NULL, 0);
   641|             state->mode = hold & 0x200 ? DICTID : TYPE;
   642|             INITBITS();
   643|             break;
   644| #ifdef GUNZIP
   645|         case FLAGS:
   646|             NEEDBITS(16);
   647|             state->flags = (int)(hold);
   648|             if ((state->flags & 0xff) != Z_DEFLATED) {
   649|                 strm->msg = (char *)"unknown compression method";
   650|                 state->mode = BAD;
   651|                 break;
   652|             }
   653|             if (state->flags & 0xe000) {
   654|                 strm->msg = (char *)"unknown header flags set";
   655|                 state->mode = BAD;
   656|                 break;
   657|             }
   658|             if (state->head != Z_NULL)
   659|                 state->head->text = (int)((hold >> 8) & 1);
   660|             if ((state->flags & 0x0200) && (state->wrap & 4))
   661|                 CRC2(state->check, hold);
   662|             INITBITS();
   663|             state->mode = TIME;
   664|                 /* fallthrough */
   665|         case TIME:
   666|             NEEDBITS(32);
   667|             if (state->head != Z_NULL)
   668|                 state->head->time = hold;
   669|             if ((state->flags & 0x0200) && (state->wrap & 4))
   670|                 CRC4(state->check, hold);
   671|             INITBITS();
   672|             state->mode = OS;
   673|                 /* fallthrough */
   674|         case OS:
   675|             NEEDBITS(16);
   676|             if (state->head != Z_NULL) {
   677|                 state->head->xflags = (int)(hold & 0xff);
   678|                 state->head->os = (int)(hold >> 8);
   679|             }
   680|             if ((state->flags & 0x0200) && (state->wrap & 4))
   681|                 CRC2(state->check, hold);
   682|             INITBITS();
   683|             state->mode = EXLEN;
   684|                 /* fallthrough */
   685|         case EXLEN:
   686|             if (state->flags & 0x0400) {
   687|                 NEEDBITS(16);
   688|                 state->length = (unsigned)(hold);
   689|                 if (state->head != Z_NULL)
   690|                     state->head->extra_len = (unsigned)hold;
   691|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   692|                     CRC2(state->check, hold);
   693|                 INITBITS();
   694|             }
   695|             else if (state->head != Z_NULL)
   696|                 state->head->extra = Z_NULL;
   697|             state->mode = EXTRA;
   698|                 /* fallthrough */
   699|         case EXTRA:
   700|             if (state->flags & 0x0400) {
   701|                 copy = state->length;
   702|                 if (copy > have) copy = have;
   703|                 if (copy) {
   704|                     if (state->head != Z_NULL &&
   705|                         state->head->extra != Z_NULL &&
   706|                         (len = state->head->extra_len - state->length) <
   707|                             state->head->extra_max) {
   708|                         zmemcpy(state->head->extra + len, next,
   709|                                 len + copy > state->head->extra_max ?
   710|                                 state->head->extra_max - len : copy);
   711|                     }
   712|                     if ((state->flags & 0x0200) && (state->wrap & 4))
   713|                         state->check = crc32(state->check, next, copy);
   714|                     have -= copy;
   715|                     next += copy;
   716|                     state->length -= copy;
   717|                 }
   718|                 if (state->length) goto inf_leave;
   719|             }
   720|             state->length = 0;
   721|             state->mode = NAME;
   722|                 /* fallthrough */
   723|         case NAME:
   724|             if (state->flags & 0x0800) {
   725|                 if (have == 0) goto inf_leave;
   726|                 copy = 0;
   727|                 do {
   728|                     len = (unsigned)(next[copy++]);
   729|                     if (state->head != Z_NULL &&
   730|                             state->head->name != Z_NULL &&
   731|                             state->length < state->head->name_max)
   732|                         state->head->name[state->length++] = (Bytef)len;
   733|                 } while (len && copy < have);
   734|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   735|                     state->check = crc32(state->check, next, copy);
   736|                 have -= copy;
   737|                 next += copy;
   738|                 if (len) goto inf_leave;
   739|             }
   740|             else if (state->head != Z_NULL)
   741|                 state->head->name = Z_NULL;
   742|             state->length = 0;
   743|             state->mode = COMMENT;
   744|                 /* fallthrough */
   745|         case COMMENT:
   746|             if (state->flags & 0x1000) {
   747|                 if (have == 0) goto inf_leave;
   748|                 copy = 0;
   749|                 do {
   750|                     len = (unsigned)(next[copy++]);
   751|                     if (state->head != Z_NULL &&
   752|                             state->head->comment != Z_NULL &&
   753|                             state->length < state->head->comm_max)
   754|                         state->head->comment[state->length++] = (Bytef)len;
   755|                 } while (len && copy < have);
   756|                 if ((state->flags & 0x0200) && (state->wrap & 4))
   757|                     state->check = crc32(state->check, next, copy);
   758|                 have -= copy;
   759|                 next += copy;
   760|                 if (len) goto inf_leave;
   761|             }
   762|             else if (state->head != Z_NULL)
   763|                 state->head->comment = Z_NULL;
   764|             state->mode = HCRC;
   765|                 /* fallthrough */
   766|         case HCRC:
   767|             if (state->flags & 0x0200) {
   768|                 NEEDBITS(16);
   769|                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
   770|                     strm->msg = (char *)"header crc mismatch";
   771|                     state->mode = BAD;
   772|                     break;
   773|                 }
   774|                 INITBITS();
   775|             }
   776|             if (state->head != Z_NULL) {
   777|                 state->head->hcrc = (int)((state->flags >> 9) & 1);
   778|                 state->head->done = 1;
   779|             }
   780|             strm->adler = state->check = crc32(0L, Z_NULL, 0);
   781|             state->mode = TYPE;
   782|             break;
   783| #endif
   784|         case DICTID:
   785|             NEEDBITS(32);
   786|             strm->adler = state->check = ZSWAP32(hold);
   787|             INITBITS();
   788|             state->mode = DICT;
   789|                 /* fallthrough */
   790|         case DICT:
   791|             if (state->havedict == 0) {
   792|                 RESTORE();
   793|                 return Z_NEED_DICT;
   794|             }
   795|             strm->adler = state->check = adler32(0L, Z_NULL, 0);
   796|             state->mode = TYPE;
   797|                 /* fallthrough */
   798|         case TYPE:
   799|             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
   800|                 /* fallthrough */
   801|         case TYPEDO:
   802|             if (state->last) {
   803|                 BYTEBITS();
   804|                 state->mode = CHECK;
   805|                 break;
   806|             }
   807|             NEEDBITS(3);
   808|             state->last = BITS(1);
   809|             DROPBITS(1);
   810|             switch (BITS(2)) {
   811|             case 0:                             /* stored block */
   812|                 Tracev((stderr, "inflate:     stored block%s\n",
   813|                         state->last ? " (last)" : ""));
   814|                 state->mode = STORED;
   815|                 break;
   816|             case 1:                             /* fixed block */
   817|                 fixedtables(state);
   818|                 Tracev((stderr, "inflate:     fixed codes block%s\n",
   819|                         state->last ? " (last)" : ""));
   820|                 state->mode = LEN_;             /* decode codes */
   821|                 if (flush == Z_TREES) {
   822|                     DROPBITS(2);
   823|                     goto inf_leave;
   824|                 }
   825|                 break;
   826|             case 2:                             /* dynamic block */
   827|                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
   828|                         state->last ? " (last)" : ""));
   829|                 state->mode = TABLE;
   830|                 break;
   831|             case 3:
   832|                 strm->msg = (char *)"invalid block type";
   833|                 state->mode = BAD;
   834|             }
   835|             DROPBITS(2);
   836|             break;
   837|         case STORED:
   838|             BYTEBITS();                         /* go to byte boundary */
   839|             NEEDBITS(32);
   840|             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
   841|                 strm->msg = (char *)"invalid stored block lengths";
   842|                 state->mode = BAD;
   843|                 break;
   844|             }
   845|             state->length = (unsigned)hold & 0xffff;
   846|             Tracev((stderr, "inflate:       stored length %u\n",
   847|                     state->length));
   848|             INITBITS();
   849|             state->mode = COPY_;
   850|             if (flush == Z_TREES) goto inf_leave;
   851|                 /* fallthrough */
   852|         case COPY_:
   853|             state->mode = COPY;
   854|                 /* fallthrough */
   855|         case COPY:
   856|             copy = state->length;
   857|             if (copy) {
   858|                 if (copy > have) copy = have;
   859|                 if (copy > left) copy = left;
   860|                 if (copy == 0) goto inf_leave;
   861|                 zmemcpy(put, next, copy);
   862|                 have -= copy;
   863|                 next += copy;
   864|                 left -= copy;
   865|                 put += copy;
   866|                 state->length -= copy;
   867|                 break;
   868|             }
   869|             Tracev((stderr, "inflate:       stored end\n"));
   870|             state->mode = TYPE;
   871|             break;
   872|         case TABLE:
   873|             NEEDBITS(14);
   874|             state->nlen = BITS(5) + 257;
   875|             DROPBITS(5);
   876|             state->ndist = BITS(5) + 1;
   877|             DROPBITS(5);
   878|             state->ncode = BITS(4) + 4;
   879|             DROPBITS(4);
   880| #ifndef PKZIP_BUG_WORKAROUND
   881|             if (state->nlen > 286 || state->ndist > 30) {
   882|                 strm->msg = (char *)"too many length or distance symbols";
   883|                 state->mode = BAD;
   884|                 break;
   885|             }
   886| #endif
   887|             Tracev((stderr, "inflate:       table sizes ok\n"));
   888|             state->have = 0;
   889|             state->mode = LENLENS;
   890|                 /* fallthrough */
   891|         case LENLENS:
   892|             while (state->have < state->ncode) {
   893|                 NEEDBITS(3);
   894|                 state->lens[order[state->have++]] = (unsigned short)BITS(3);
   895|                 DROPBITS(3);
   896|             }
   897|             while (state->have < 19)
   898|                 state->lens[order[state->have++]] = 0;
   899|             state->next = state->codes;
   900|             state->lencode = (const code FAR *)(state->next);
   901|             state->lenbits = 7;
   902|             ret = inflate_table(CODES, state->lens, 19, &(state->next),
   903|                                 &(state->lenbits), state->work);
   904|             if (ret) {
   905|                 strm->msg = (char *)"invalid code lengths set";
   906|                 state->mode = BAD;
   907|                 break;
   908|             }
   909|             Tracev((stderr, "inflate:       code lengths ok\n"));
   910|             state->have = 0;
   911|             state->mode = CODELENS;
   912|                 /* fallthrough */
   913|         case CODELENS:
   914|             while (state->have < state->nlen + state->ndist) {
   915|                 for (;;) {
   916|                     here = state->lencode[BITS(state->lenbits)];
   917|                     if ((unsigned)(here.bits) <= bits) break;
   918|                     PULLBYTE();
   919|                 }
   920|                 if (here.val < 16) {
   921|                     DROPBITS(here.bits);
   922|                     state->lens[state->have++] = here.val;
   923|                 }
   924|                 else {
   925|                     if (here.val == 16) {
   926|                         NEEDBITS(here.bits + 2);
   927|                         DROPBITS(here.bits);
   928|                         if (state->have == 0) {
   929|                             strm->msg = (char *)"invalid bit length repeat";
   930|                             state->mode = BAD;
   931|                             break;
   932|                         }
   933|                         len = state->lens[state->have - 1];
   934|                         copy = 3 + BITS(2);
   935|                         DROPBITS(2);
   936|                     }
   937|                     else if (here.val == 17) {
   938|                         NEEDBITS(here.bits + 3);
   939|                         DROPBITS(here.bits);
   940|                         len = 0;
   941|                         copy = 3 + BITS(3);
   942|                         DROPBITS(3);
   943|                     }
   944|                     else {
   945|                         NEEDBITS(here.bits + 7);
   946|                         DROPBITS(here.bits);
   947|                         len = 0;
   948|                         copy = 11 + BITS(7);
   949|                         DROPBITS(7);
   950|                     }
   951|                     if (state->have + copy > state->nlen + state->ndist) {
   952|                         strm->msg = (char *)"invalid bit length repeat";
   953|                         state->mode = BAD;
   954|                         break;
   955|                     }
   956|                     while (copy--)
   957|                         state->lens[state->have++] = (unsigned short)len;
   958|                 }
   959|             }
   960|             /* handle error breaks in while */
   961|             if (state->mode == BAD) break;
   962|             /* check for end-of-block code (better have one) */
   963|             if (state->lens[256] == 0) {
   964|                 strm->msg = (char *)"invalid code -- missing end-of-block";
   965|                 state->mode = BAD;
   966|                 break;
   967|             }
   968|             /* build code tables -- note: do not change the lenbits or distbits
   969|                values here (9 and 6) without reading the comments in inftrees.h
   970|                concerning the ENOUGH constants, which depend on those values */
   971|             state->next = state->codes;
   972|             state->lencode = (const code FAR *)(state->next);
   973|             state->lenbits = 9;
   974|             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
   975|                                 &(state->lenbits), state->work);
   976|             if (ret) {
   977|                 strm->msg = (char *)"invalid literal/lengths set";
   978|                 state->mode = BAD;
   979|                 break;
   980|             }
   981|             state->distcode = (const code FAR *)(state->next);
   982|             state->distbits = 6;
   983|             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
   984|                             &(state->next), &(state->distbits), state->work);
   985|             if (ret) {
   986|                 strm->msg = (char *)"invalid distances set";
   987|                 state->mode = BAD;
   988|                 break;
   989|             }
   990|             Tracev((stderr, "inflate:       codes ok\n"));
   991|             state->mode = LEN_;
   992|             if (flush == Z_TREES) goto inf_leave;
   993|                 /* fallthrough */
   994|         case LEN_:
   995|             state->mode = LEN;
   996|                 /* fallthrough */
   997|         case LEN:
   998|             if (have >= 6 && left >= 258) {
   999|                 RESTORE();
  1000|                 inflate_fast(strm, out);
  1001|                 LOAD();
  1002|                 if (state->mode == TYPE)
  1003|                     state->back = -1;
  1004|                 break;
  1005|             }
  1006|             state->back = 0;
  1007|             for (;;) {
  1008|                 here = state->lencode[BITS(state->lenbits)];
  1009|                 if ((unsigned)(here.bits) <= bits) break;
  1010|                 PULLBYTE();
  1011|             }
  1012|             if (here.op && (here.op & 0xf0) == 0) {
  1013|                 last = here;
  1014|                 for (;;) {
  1015|                     here = state->lencode[last.val +
  1016|                             (BITS(last.bits + last.op) >> last.bits)];
  1017|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
  1018|                     PULLBYTE();
  1019|                 }
  1020|                 DROPBITS(last.bits);
  1021|                 state->back += last.bits;
  1022|             }
  1023|             DROPBITS(here.bits);
  1024|             state->back += here.bits;
  1025|             state->length = (unsigned)here.val;
  1026|             if ((int)(here.op) == 0) {
  1027|                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
  1028|                         "inflate:         literal '%c'\n" :
  1029|                         "inflate:         literal 0x%02x\n", here.val));
  1030|                 state->mode = LIT;
  1031|                 break;
  1032|             }
  1033|             if (here.op & 32) {
  1034|                 Tracevv((stderr, "inflate:         end of block\n"));
  1035|                 state->back = -1;
  1036|                 state->mode = TYPE;
  1037|                 break;
  1038|             }
  1039|             if (here.op & 64) {
  1040|                 strm->msg = (char *)"invalid literal/length code";
  1041|                 state->mode = BAD;
  1042|                 break;
  1043|             }
  1044|             state->extra = (unsigned)(here.op) & 15;
  1045|             state->mode = LENEXT;
  1046|                 /* fallthrough */
  1047|         case LENEXT:
  1048|             if (state->extra) {
  1049|                 NEEDBITS(state->extra);
  1050|                 state->length += BITS(state->extra);
  1051|                 DROPBITS(state->extra);
  1052|                 state->back += state->extra;
  1053|             }
  1054|             Tracevv((stderr, "inflate:         length %u\n", state->length));
  1055|             state->was = state->length;
  1056|             state->mode = DIST;
  1057|                 /* fallthrough */
  1058|         case DIST:
  1059|             for (;;) {
  1060|                 here = state->distcode[BITS(state->distbits)];
  1061|                 if ((unsigned)(here.bits) <= bits) break;
  1062|                 PULLBYTE();
  1063|             }
  1064|             if ((here.op & 0xf0) == 0) {
  1065|                 last = here;
  1066|                 for (;;) {
  1067|                     here = state->distcode[last.val +
  1068|                             (BITS(last.bits + last.op) >> last.bits)];
  1069|                     if ((unsigned)(last.bits + here.bits) <= bits) break;
  1070|                     PULLBYTE();
  1071|                 }
  1072|                 DROPBITS(last.bits);
  1073|                 state->back += last.bits;
  1074|             }
  1075|             DROPBITS(here.bits);
  1076|             state->back += here.bits;
  1077|             if (here.op & 64) {
  1078|                 strm->msg = (char *)"invalid distance code";
  1079|                 state->mode = BAD;
  1080|                 break;
  1081|             }
  1082|             state->offset = (unsigned)here.val;
  1083|             state->extra = (unsigned)(here.op) & 15;
  1084|             state->mode = DISTEXT;
  1085|                 /* fallthrough */
  1086|         case DISTEXT:
  1087|             if (state->extra) {
  1088|                 NEEDBITS(state->extra);
  1089|                 state->offset += BITS(state->extra);
  1090|                 DROPBITS(state->extra);
  1091|                 state->back += state->extra;
  1092|             }
  1093| #ifdef INFLATE_STRICT
  1094|             if (state->offset > state->dmax) {
  1095|                 strm->msg = (char *)"invalid distance too far back";
  1096|                 state->mode = BAD;
  1097|                 break;
  1098|             }
  1099| #endif
  1100|             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
  1101|             state->mode = MATCH;
  1102|                 /* fallthrough */
  1103|         case MATCH:
  1104|             if (left == 0) goto inf_leave;
  1105|             copy = out - left;
  1106|             if (state->offset > copy) {         /* copy from window */
  1107|                 copy = state->offset - copy;
  1108|                 if (copy > state->whave) {
  1109|                     if (state->sane) {
  1110|                         strm->msg = (char *)"invalid distance too far back";
  1111|                         state->mode = BAD;
  1112|                         break;
  1113|                     }
  1114| #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  1115|                     Trace((stderr, "inflate.c too far\n"));
  1116|                     copy -= state->whave;
  1117|                     if (copy > state->length) copy = state->length;
  1118|                     if (copy > left) copy = left;
  1119|                     left -= copy;
  1120|                     state->length -= copy;
  1121|                     do {
  1122|                         *put++ = 0;
  1123|                     } while (--copy);
  1124|                     if (state->length == 0) state->mode = LEN;
  1125|                     break;
  1126| #endif
  1127|                 }
  1128|                 if (copy > state->wnext) {
  1129|                     copy -= state->wnext;
  1130|                     from = state->window + (state->wsize - copy);
  1131|                 }
  1132|                 else
  1133|                     from = state->window + (state->wnext - copy);
  1134|                 if (copy > state->length) copy = state->length;
  1135|             }
  1136|             else {                              /* copy from output */
  1137|                 from = put - state->offset;
  1138|                 copy = state->length;
  1139|             }
  1140|             if (copy > left) copy = left;
  1141|             left -= copy;
  1142|             state->length -= copy;
  1143|             do {
  1144|                 *put++ = *from++;
  1145|             } while (--copy);
  1146|             if (state->length == 0) state->mode = LEN;
  1147|             break;
  1148|         case LIT:
  1149|             if (left == 0) goto inf_leave;
  1150|             *put++ = (unsigned char)(state->length);
  1151|             left--;
  1152|             state->mode = LEN;
  1153|             break;
  1154|         case CHECK:
  1155|             if (state->wrap) {
  1156|                 NEEDBITS(32);
  1157|                 out -= left;
  1158|                 strm->total_out += out;
  1159|                 state->total += out;
  1160|                 if ((state->wrap & 4) && out)
  1161|                     strm->adler = state->check =
  1162|                         UPDATE_CHECK(state->check, put - out, out);
  1163|                 out = left;
  1164|                 if ((state->wrap & 4) && (
  1165| #ifdef GUNZIP
  1166|                      state->flags ? hold :
  1167| #endif
  1168|                      ZSWAP32(hold)) != state->check) {
  1169|                     strm->msg = (char *)"incorrect data check";
  1170|                     state->mode = BAD;
  1171|                     break;
  1172|                 }
  1173|                 INITBITS();
  1174|                 Tracev((stderr, "inflate:   check matches trailer\n"));
  1175|             }
  1176| #ifdef GUNZIP
  1177|             state->mode = LENGTH;
  1178|                 /* fallthrough */
  1179|         case LENGTH:
  1180|             if (state->wrap && state->flags) {
  1181|                 NEEDBITS(32);
  1182|                 if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {
  1183|                     strm->msg = (char *)"incorrect length check";
  1184|                     state->mode = BAD;
  1185|                     break;
  1186|                 }
  1187|                 INITBITS();
  1188|                 Tracev((stderr, "inflate:   length matches trailer\n"));
  1189|             }
  1190| #endif
  1191|             state->mode = DONE;
  1192|                 /* fallthrough */
  1193|         case DONE:
  1194|             ret = Z_STREAM_END;
  1195|             goto inf_leave;
  1196|         case BAD:
  1197|             ret = Z_DATA_ERROR;
  1198|             goto inf_leave;
  1199|         case MEM:
  1200|             return Z_MEM_ERROR;
  1201|         case SYNC:
  1202|                 /* fallthrough */
  1203|         default:
  1204|             return Z_STREAM_ERROR;
  1205|         }
  1206|     /*
  1207|        Return from inflate(), updating the total counts and the check value.
  1208|        If there was no progress during the inflate() call, return a buffer
  1209|        error.  Call updatewindow() to create and/or update the window state.
  1210|        Note: a memory error from inflate() is non-recoverable.
  1211|      */
  1212|   inf_leave:
  1213|     RESTORE();
  1214|     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
  1215|             (state->mode < CHECK || flush != Z_FINISH)))
  1216|         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
  1217|             state->mode = MEM;
  1218|             return Z_MEM_ERROR;
  1219|         }
  1220|     in -= strm->avail_in;
  1221|     out -= strm->avail_out;
  1222|     strm->total_in += in;
  1223|     strm->total_out += out;
  1224|     state->total += out;
  1225|     if ((state->wrap & 4) && out)
  1226|         strm->adler = state->check =
  1227|             UPDATE_CHECK(state->check, strm->next_out - out, out);
  1228|     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
  1229|                       (state->mode == TYPE ? 128 : 0) +
  1230|                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
  1231|     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
  1232|         ret = Z_BUF_ERROR;
  1233|     return ret;
  1234| }
  1235| int ZEXPORT inflateEnd(strm)
  1236| z_streamp strm;
  1237| {
  1238|     struct inflate_state FAR *state;
  1239|     if (inflateStateCheck(strm))
  1240|         return Z_STREAM_ERROR;
  1241|     state = (struct inflate_state FAR *)strm->state;
  1242|     if (state->window != Z_NULL) ZFREE(strm, state->window);
  1243|     ZFREE(strm, strm->state);
  1244|     strm->state = Z_NULL;
  1245|     Tracev((stderr, "inflate: end\n"));
  1246|     return Z_OK;
  1247| }
  1248| int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
  1249| z_streamp strm;
  1250| Bytef *dictionary;
  1251| uInt *dictLength;
  1252| {
  1253|     struct inflate_state FAR *state;
  1254|     /* check state */
  1255|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1256|     state = (struct inflate_state FAR *)strm->state;
  1257|     /* copy dictionary */
  1258|     if (state->whave && dictionary != Z_NULL) {
  1259|         zmemcpy(dictionary, state->window + state->wnext,
  1260|                 state->whave - state->wnext);
  1261|         zmemcpy(dictionary + state->whave - state->wnext,
  1262|                 state->window, state->wnext);
  1263|     }
  1264|     if (dictLength != Z_NULL)
  1265|         *dictLength = state->whave;
  1266|     return Z_OK;
  1267| }
  1268| int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
  1269| z_streamp strm;
  1270| const Bytef *dictionary;
  1271| uInt dictLength;
  1272| {
  1273|     struct inflate_state FAR *state;
  1274|     unsigned long dictid;
  1275|     int ret;
  1276|     /* check state */
  1277|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1278|     state = (struct inflate_state FAR *)strm->state;
  1279|     if (state->wrap != 0 && state->mode != DICT)
  1280|         return Z_STREAM_ERROR;
  1281|     /* check for correct dictionary identifier */
  1282|     if (state->mode == DICT) {
  1283|         dictid = adler32(0L, Z_NULL, 0);
  1284|         dictid = adler32(dictid, dictionary, dictLength);
  1285|         if (dictid != state->check)
  1286|             return Z_DATA_ERROR;
  1287|     }
  1288|     /* copy dictionary to window using updatewindow(), which will amend the
  1289|        existing dictionary if appropriate */
  1290|     ret = updatewindow(strm, dictionary + dictLength, dictLength);
  1291|     if (ret) {
  1292|         state->mode = MEM;
  1293|         return Z_MEM_ERROR;
  1294|     }
  1295|     state->havedict = 1;
  1296|     Tracev((stderr, "inflate:   dictionary set\n"));
  1297|     return Z_OK;
  1298| }
  1299| int ZEXPORT inflateGetHeader(strm, head)
  1300| z_streamp strm;
  1301| gz_headerp head;
  1302| {
  1303|     struct inflate_state FAR *state;
  1304|     /* check state */
  1305|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1306|     state = (struct inflate_state FAR *)strm->state;
  1307|     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;
  1308|     /* save header structure */
  1309|     state->head = head;
  1310|     head->done = 0;
  1311|     return Z_OK;
  1312| }
  1313| /*
  1314|    Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
  1315|    or when out of input.  When called, *have is the number of pattern bytes
  1316|    found in order so far, in 0..3.  On return *have is updated to the new
  1317|    state.  If on return *have equals four, then the pattern was found and the
  1318|    return value is how many bytes were read including the last byte of the
  1319|    pattern.  If *have is less than four, then the pattern has not been found
  1320|    yet and the return value is len.  In the latter case, syncsearch() can be
  1321|    called again with more data and the *have state.  *have is initialized to
  1322|    zero for the first call.
  1323|  */
  1324| local unsigned syncsearch(have, buf, len)
  1325| unsigned FAR *have;
  1326| const unsigned char FAR *buf;
  1327| unsigned len;
  1328| {
  1329|     unsigned got;
  1330|     unsigned next;
  1331|     got = *have;
  1332|     next = 0;
  1333|     while (next < len && got < 4) {
  1334|         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
  1335|             got++;
  1336|         else if (buf[next])
  1337|             got = 0;
  1338|         else
  1339|             got = 4 - got;
  1340|         next++;
  1341|     }
  1342|     *have = got;
  1343|     return next;
  1344| }
  1345| int ZEXPORT inflateSync(strm)
  1346| z_streamp strm;
  1347| {
  1348|     unsigned len;               /* number of bytes to look at or looked at */
  1349|     int flags;                  /* temporary to save header status */
  1350|     unsigned long in, out;      /* temporary to save total_in and total_out */
  1351|     unsigned char buf[4];       /* to restore bit buffer to byte string */
  1352|     struct inflate_state FAR *state;
  1353|     /* check parameters */
  1354|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1355|     state = (struct inflate_state FAR *)strm->state;
  1356|     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;
  1357|     /* if first time, start search in bit buffer */
  1358|     if (state->mode != SYNC) {
  1359|         state->mode = SYNC;
  1360|         state->hold <<= state->bits & 7;
  1361|         state->bits -= state->bits & 7;
  1362|         len = 0;
  1363|         while (state->bits >= 8) {
  1364|             buf[len++] = (unsigned char)(state->hold);
  1365|             state->hold >>= 8;
  1366|             state->bits -= 8;
  1367|         }
  1368|         state->have = 0;
  1369|         syncsearch(&(state->have), buf, len);
  1370|     }
  1371|     /* search available input */
  1372|     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
  1373|     strm->avail_in -= len;
  1374|     strm->next_in += len;
  1375|     strm->total_in += len;
  1376|     /* return no joy or set up to restart inflate() on a new block */
  1377|     if (state->have != 4) return Z_DATA_ERROR;
  1378|     if (state->flags == -1)
  1379|         state->wrap = 0;    /* if no header yet, treat as raw */
  1380|     else
  1381|         state->wrap &= ~4;  /* no point in computing a check value now */
  1382|     flags = state->flags;
  1383|     in = strm->total_in;  out = strm->total_out;
  1384|     inflateReset(strm);
  1385|     strm->total_in = in;  strm->total_out = out;
  1386|     state->flags = flags;
  1387|     state->mode = TYPE;
  1388|     return Z_OK;
  1389| }
  1390| /*
  1391|    Returns true if inflate is currently at the end of a block generated by
  1392|    Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  1393|    implementation to provide an additional safety check. PPP uses
  1394|    Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
  1395|    block. When decompressing, PPP checks that at the end of input packet,
  1396|    inflate is waiting for these length bytes.
  1397|  */
  1398| int ZEXPORT inflateSyncPoint(strm)
  1399| z_streamp strm;
  1400| {
  1401|     struct inflate_state FAR *state;
  1402|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1403|     state = (struct inflate_state FAR *)strm->state;
  1404|     return state->mode == STORED && state->bits == 0;
  1405| }
  1406| int ZEXPORT inflateCopy(dest, source)
  1407| z_streamp dest;
  1408| z_streamp source;
  1409| {
  1410|     struct inflate_state FAR *state;
  1411|     struct inflate_state FAR *copy;
  1412|     unsigned char FAR *window;
  1413|     unsigned wsize;
  1414|     /* check input */
  1415|     if (inflateStateCheck(source) || dest == Z_NULL)
  1416|         return Z_STREAM_ERROR;
  1417|     state = (struct inflate_state FAR *)source->state;
  1418|     /* allocate space */
  1419|     copy = (struct inflate_state FAR *)
  1420|            ZALLOC(source, 1, sizeof(struct inflate_state));
  1421|     if (copy == Z_NULL) return Z_MEM_ERROR;
  1422|     window = Z_NULL;
  1423|     if (state->window != Z_NULL) {
  1424|         window = (unsigned char FAR *)
  1425|                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
  1426|         if (window == Z_NULL) {
  1427|             ZFREE(source, copy);
  1428|             return Z_MEM_ERROR;
  1429|         }
  1430|     }
  1431|     /* copy state */
  1432|     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
  1433|     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
  1434|     copy->strm = dest;
  1435|     if (state->lencode >= state->codes &&
  1436|         state->lencode <= state->codes + ENOUGH - 1) {
  1437|         copy->lencode = copy->codes + (state->lencode - state->codes);
  1438|         copy->distcode = copy->codes + (state->distcode - state->codes);
  1439|     }
  1440|     copy->next = copy->codes + (state->next - state->codes);
  1441|     if (window != Z_NULL) {
  1442|         wsize = 1U << state->wbits;
  1443|         zmemcpy(window, state->window, wsize);
  1444|     }
  1445|     copy->window = window;
  1446|     dest->state = (struct internal_state FAR *)copy;
  1447|     return Z_OK;
  1448| }
  1449| int ZEXPORT inflateUndermine(strm, subvert)
  1450| z_streamp strm;
  1451| int subvert;
  1452| {
  1453|     struct inflate_state FAR *state;
  1454|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1455|     state = (struct inflate_state FAR *)strm->state;
  1456| #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  1457|     state->sane = !subvert;
  1458|     return Z_OK;
  1459| #else
  1460|     (void)subvert;
  1461|     state->sane = 1;
  1462|     return Z_DATA_ERROR;
  1463| #endif
  1464| }
  1465| int ZEXPORT inflateValidate(strm, check)
  1466| z_streamp strm;
  1467| int check;
  1468| {
  1469|     struct inflate_state FAR *state;
  1470|     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  1471|     state = (struct inflate_state FAR *)strm->state;
  1472|     if (check && state->wrap)
  1473|         state->wrap |= 4;
  1474|     else
  1475|         state->wrap &= ~4;
  1476|     return Z_OK;
  1477| }
  1478| long ZEXPORT inflateMark(strm)
  1479| z_streamp strm;
  1480| {
  1481|     struct inflate_state FAR *state;
  1482|     if (inflateStateCheck(strm))
  1483|         return -(1L << 16);
  1484|     state = (struct inflate_state FAR *)strm->state;
  1485|     return (long)(((unsigned long)((long)state->back)) << 16) +
  1486|         (state->mode == COPY ? state->length :
  1487|             (state->mode == MATCH ? state->was - state->length : 0));
  1488| }
  1489| unsigned long ZEXPORT inflateCodesUsed(strm)
  1490| z_streamp strm;
  1491| {
  1492|     struct inflate_state FAR *state;
  1493|     if (inflateStateCheck(strm)) return (unsigned long)-1;
  1494|     state = (struct inflate_state FAR *)strm->state;
  1495|     return (unsigned long)(state->next - state->codes);
  1496| }


# ====================================================================
# FILE: src/native/external/zlib/inftrees.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-272 ---
     1| /* inftrees.c -- generate Huffman trees for efficient decoding
     2|  * Copyright (C) 1995-2022 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| #include "zutil.h"
     6| #include "inftrees.h"
     7| #define MAXBITS 15
     8| const char inflate_copyright[] =
     9|    " inflate 1.2.13 Copyright 1995-2022 Mark Adler ";
    10| /*
    11|   If you use the zlib library in a product, an acknowledgment is welcome
    12|   in the documentation of your product. If for some reason you cannot
    13|   include such an acknowledgment, I would appreciate that you keep this
    14|   copyright string in the executable of your product.
    15|  */
    16| /*
    17|    Build a set of tables to decode the provided canonical Huffman code.
    18|    The code lengths are lens[0..codes-1].  The result starts at *table,
    19|    whose indices are 0..2^bits-1.  work is a writable array of at least
    20|    lens shorts, which is used as a work area.  type is the type of code
    21|    to be generated, CODES, LENS, or DISTS.  On return, zero is success,
    22|    -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
    23|    on return points to the next available entry's address.  bits is the
    24|    requested root table index bits, and on return it is the actual root
    25|    table index bits.  It will differ if the request is greater than the
    26|    longest code or if it is less than the shortest code.
    27|  */
    28| int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
    29| codetype type;
    30| unsigned short FAR *lens;
    31| unsigned codes;
    32| code FAR * FAR *table;
    33| unsigned FAR *bits;
    34| unsigned short FAR *work;
    35| {
    36|     unsigned len;               /* a code's length in bits */
    37|     unsigned sym;               /* index of code symbols */
    38|     unsigned min, max;          /* minimum and maximum code lengths */
    39|     unsigned root;              /* number of index bits for root table */
    40|     unsigned curr;              /* number of index bits for current table */
    41|     unsigned drop;              /* code bits to drop for sub-table */
    42|     int left;                   /* number of prefix codes available */
    43|     unsigned used;              /* code entries in table used */
    44|     unsigned huff;              /* Huffman code */
    45|     unsigned incr;              /* for incrementing code, index */
    46|     unsigned fill;              /* index for replicating entries */
    47|     unsigned low;               /* low bits for current root entry */
    48|     unsigned mask;              /* mask for low root bits */
    49|     code here;                  /* table entry for duplication */
    50|     code FAR *next;             /* next available space in table */
    51|     const unsigned short FAR *base;     /* base value table to use */
    52|     const unsigned short FAR *extra;    /* extra bits table to use */
    53|     unsigned match;             /* use base and extra for symbol >= match */
    54|     unsigned short count[MAXBITS+1];    /* number of codes of each length */
    55|     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    56|     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
    57|         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
    58|         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    59|     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
    60|         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
    61|         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 194, 65};
    62|     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
    63|         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
    64|         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
    65|         8193, 12289, 16385, 24577, 0, 0};
    66|     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
    67|         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
    68|         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
    69|         28, 28, 29, 29, 64, 64};
    70|     /*
    71|        Process a set of code lengths to create a canonical Huffman code.  The
    72|        code lengths are lens[0..codes-1].  Each length corresponds to the
    73|        symbols 0..codes-1.  The Huffman code is generated by first sorting the
    74|        symbols by length from short to long, and retaining the symbol order
    75|        for codes with equal lengths.  Then the code starts with all zero bits
    76|        for the first code of the shortest length, and the codes are integer
    77|        increments for the same length, and zeros are appended as the length
    78|        increases.  For the deflate format, these bits are stored backwards
    79|        from their more natural integer increment ordering, and so when the
    80|        decoding tables are built in the large loop below, the integer codes
    81|        are incremented backwards.
    82|        This routine assumes, but does not check, that all of the entries in
    83|        lens[] are in the range 0..MAXBITS.  The caller must assure this.
    84|        1..MAXBITS is interpreted as that code length.  zero means that that
    85|        symbol does not occur in this code.
    86|        The codes are sorted by computing a count of codes for each length,
    87|        creating from that a table of starting indices for each length in the
    88|        sorted table, and then entering the symbols in order in the sorted
    89|        table.  The sorted table is work[], with that space being provided by
    90|        the caller.
    91|        The length counts are used for other purposes as well, i.e. finding
    92|        the minimum and maximum length codes, determining if there are any
    93|        codes at all, checking for a valid set of lengths, and looking ahead
    94|        at length counts to determine sub-table sizes when building the
    95|        decoding tables.
    96|      */
    97|     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    98|     for (len = 0; len <= MAXBITS; len++)
    99|         count[len] = 0;
   100|     for (sym = 0; sym < codes; sym++)
   101|         count[lens[sym]]++;
   102|     /* bound code lengths, force root to be within code lengths */
   103|     root = *bits;
   104|     for (max = MAXBITS; max >= 1; max--)
   105|         if (count[max] != 0) break;
   106|     if (root > max) root = max;
   107|     if (max == 0) {                     /* no symbols to code at all */
   108|         here.op = (unsigned char)64;    /* invalid code marker */
   109|         here.bits = (unsigned char)1;
   110|         here.val = (unsigned short)0;
   111|         *(*table)++ = here;             /* make a table to force an error */
   112|         *(*table)++ = here;
   113|         *bits = 1;
   114|         return 0;     /* no symbols, but wait for decoding to report error */
   115|     }
   116|     for (min = 1; min < max; min++)
   117|         if (count[min] != 0) break;
   118|     if (root < min) root = min;
   119|     /* check for an over-subscribed or incomplete set of lengths */
   120|     left = 1;
   121|     for (len = 1; len <= MAXBITS; len++) {
   122|         left <<= 1;
   123|         left -= count[len];
   124|         if (left < 0) return -1;        /* over-subscribed */
   125|     }
   126|     if (left > 0 && (type == CODES || max != 1))
   127|         return -1;                      /* incomplete set */
   128|     /* generate offsets into symbol table for each length for sorting */
   129|     offs[1] = 0;
   130|     for (len = 1; len < MAXBITS; len++)
   131|         offs[len + 1] = offs[len] + count[len];
   132|     /* sort symbols by length, by symbol order within each length */
   133|     for (sym = 0; sym < codes; sym++)
   134|         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
   135|     /*
   136|        Create and fill in decoding tables.  In this loop, the table being
   137|        filled is at next and has curr index bits.  The code being used is huff
   138|        with length len.  That code is converted to an index by dropping drop
   139|        bits off of the bottom.  For codes where len is less than drop + curr,
   140|        those top drop + curr - len bits are incremented through all values to
   141|        fill the table with replicated entries.
   142|        root is the number of index bits for the root table.  When len exceeds
   143|        root, sub-tables are created pointed to by the root entry with an index
   144|        of the low root bits of huff.  This is saved in low to check for when a
   145|        new sub-table should be started.  drop is zero when the root table is
   146|        being filled, and drop is root when sub-tables are being filled.
   147|        When a new sub-table is needed, it is necessary to look ahead in the
   148|        code lengths to determine what size sub-table is needed.  The length
   149|        counts are used for this, and so count[] is decremented as codes are
   150|        entered in the tables.
   151|        used keeps track of how many table entries have been allocated from the
   152|        provided *table space.  It is checked for LENS and DIST tables against
   153|        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   154|        the initial root table size constants.  See the comments in inftrees.h
   155|        for more information.
   156|        sym increments through all symbols, and the loop terminates when
   157|        all codes of length max, i.e. all codes, have been processed.  This
   158|        routine permits incomplete codes, so another loop after this one fills
   159|        in the rest of the decoding tables with invalid code markers.
   160|      */
   161|     /* set up for code type */
   162|     switch (type) {
   163|     case CODES:
   164|         base = extra = work;    /* dummy value--not used */
   165|         match = 20;
   166|         break;
   167|     case LENS:
   168|         base = lbase;
   169|         extra = lext;
   170|         match = 257;
   171|         break;
   172|     default:    /* DISTS */
   173|         base = dbase;
   174|         extra = dext;
   175|         match = 0;
   176|     }
   177|     /* initialize state for loop */
   178|     huff = 0;                   /* starting code */
   179|     sym = 0;                    /* starting code symbol */
   180|     len = min;                  /* starting code length */
   181|     next = *table;              /* current table to fill in */
   182|     curr = root;                /* current table index bits */
   183|     drop = 0;                   /* current bits to drop from code for index */
   184|     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
   185|     used = 1U << root;          /* use root table entries */
   186|     mask = used - 1;            /* mask for comparing low */
   187|     /* check available table space */
   188|     if ((type == LENS && used > ENOUGH_LENS) ||
   189|         (type == DISTS && used > ENOUGH_DISTS))
   190|         return 1;
   191|     /* process all codes and make table entries */
   192|     for (;;) {
   193|         /* create table entry */
   194|         here.bits = (unsigned char)(len - drop);
   195|         if (work[sym] + 1U < match) {
   196|             here.op = (unsigned char)0;
   197|             here.val = work[sym];
   198|         }
   199|         else if (work[sym] >= match) {
   200|             here.op = (unsigned char)(extra[work[sym] - match]);
   201|             here.val = base[work[sym] - match];
   202|         }
   203|         else {
   204|             here.op = (unsigned char)(32 + 64);         /* end of block */
   205|             here.val = 0;
   206|         }
   207|         /* replicate for those indices with low len bits equal to huff */
   208|         incr = 1U << (len - drop);
   209|         fill = 1U << curr;
   210|         min = fill;                 /* save offset to next table */
   211|         do {
   212|             fill -= incr;
   213|             next[(huff >> drop) + fill] = here;
   214|         } while (fill != 0);
   215|         /* backwards increment the len-bit code huff */
   216|         incr = 1U << (len - 1);
   217|         while (huff & incr)
   218|             incr >>= 1;
   219|         if (incr != 0) {
   220|             huff &= incr - 1;
   221|             huff += incr;
   222|         }
   223|         else
   224|             huff = 0;
   225|         /* go to next symbol, update count, len */
   226|         sym++;
   227|         if (--(count[len]) == 0) {
   228|             if (len == max) break;
   229|             len = lens[work[sym]];
   230|         }
   231|         /* create new sub-table if needed */
   232|         if (len > root && (huff & mask) != low) {
   233|             /* if first time, transition to sub-tables */
   234|             if (drop == 0)
   235|                 drop = root;
   236|             /* increment past last table */
   237|             next += min;            /* here min is 1 << curr */
   238|             /* determine length of next table */
   239|             curr = len - drop;
   240|             left = (int)(1 << curr);
   241|             while (curr + drop < max) {
   242|                 left -= count[curr + drop];
   243|                 if (left <= 0) break;
   244|                 curr++;
   245|                 left <<= 1;
   246|             }
   247|             /* check for enough space */
   248|             used += 1U << curr;
   249|             if ((type == LENS && used > ENOUGH_LENS) ||
   250|                 (type == DISTS && used > ENOUGH_DISTS))
   251|                 return 1;
   252|             /* point entry in root table to sub-table */
   253|             low = huff & mask;
   254|             (*table)[low].op = (unsigned char)curr;
   255|             (*table)[low].bits = (unsigned char)root;
   256|             (*table)[low].val = (unsigned short)(next - *table);
   257|         }
   258|     }
   259|     /* fill in remaining table entry if code is incomplete (guaranteed to have
   260|        at most one remaining entry, since if the code is incomplete, the
   261|        maximum code length that was allowed to get this far is one bit) */
   262|     if (huff != 0) {
   263|         here.op = (unsigned char)64;            /* invalid code marker */
   264|         here.bits = (unsigned char)(len - drop);
   265|         here.val = (unsigned short)0;
   266|         next[huff] = here;
   267|     }
   268|     /* set return parameters */
   269|     *table += used;
   270|     *bits = root;
   271|     return 0;
   272| }


# ====================================================================
# FILE: src/native/external/zlib/inftrees.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| /* inftrees.h -- header to use inftrees.c
     2|  * Copyright (C) 1995-2005, 2010 Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* WARNING: this file should *not* be used by applications. It is
     6|    part of the implementation of the compression library and is
     7|    subject to change. Applications should only use zlib.h.
     8|  */
     9| /* Structure for decoding tables.  Each entry provides either the
    10|    information needed to do the operation requested by the code that
    11|    indexed that table entry, or it provides a pointer to another
    12|    table that indexes more bits of the code.  op indicates whether
    13|    the entry is a pointer to another table, a literal, a length or
    14|    distance, an end-of-block, or an invalid code.  For a table
    15|    pointer, the low four bits of op is the number of index bits of
    16|    that table.  For a length or distance, the low four bits of op
    17|    is the number of extra bits to get after the code.  bits is
    18|    the number of bits in this code or part of the code to drop off
    19|    of the bit buffer.  val is the actual byte to output in the case
    20|    of a literal, the base length or distance, or the offset from
    21|    the current table to the next table.  Each entry is four bytes. */
    22| typedef struct {
    23|     unsigned char op;           /* operation, extra bits, table bits */
    24|     unsigned char bits;         /* bits in this part of the code */
    25|     unsigned short val;         /* offset in table or code value */
    26| } code;
    27| /* op values as set by inflate_table():
    28|     00000000 - literal
    29|     0000tttt - table link, tttt != 0 is the number of table index bits
    30|     0001eeee - length or distance, eeee is the number of extra bits
    31|     01100000 - end of block
    32|     01000000 - invalid code
    33|  */
    34| /* Maximum size of the dynamic table.  The maximum number of code structures is
    35|    1444, which is the sum of 852 for literal/length codes and 592 for distance
    36|    codes.  These values were found by exhaustive searches using the program
    37|    examples/enough.c found in the zlib distribution.  The arguments to that
    38|    program are the number of symbols, the initial root table size, and the
    39|    maximum bit length of a code.  "enough 286 9 15" for literal/length codes
    40|    returns returns 852, and "enough 30 6 15" for distance codes returns 592.
    41|    The initial root table size (9 or 6) is found in the fifth argument of the
    42|    inflate_table() calls in inflate.c and infback.c.  If the root table size is
    43|    changed, then these maximum sizes would be need to be recalculated and
    44|    updated. */
    45| #define ENOUGH_LENS 852
    46| #define ENOUGH_DISTS 592
    47| #define ENOUGH (ENOUGH_LENS+ENOUGH_DISTS)
    48| /* Type of code to build for inflate_table() */
    49| typedef enum {
    50|     CODES,
    51|     LENS,
    52|     DISTS
    53| } codetype;
    54| int ZLIB_INTERNAL inflate_table OF((codetype type, unsigned short FAR *lens,
    55|                              unsigned codes, code FAR * FAR *table,
    56|                              unsigned FAR *bits, unsigned short FAR *work));


# ====================================================================
# FILE: src/native/external/zlib/trees.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1031 ---
     1| /* trees.c -- output deflated data using Huffman coding
     2|  * Copyright (C) 1995-2021 Jean-loup Gailly
     3|  * detect_data_type() function provided freely by Cosmin Truta, 2006
     4|  * For conditions of distribution and use, see copyright notice in zlib.h
     5|  */
     6| /*
     7|  *  ALGORITHM
     8|  *
     9|  *      The "deflation" process uses several Huffman trees. The more
    10|  *      common source values are represented by shorter bit sequences.
    11|  *
    12|  *      Each code tree is stored in a compressed form which is itself
    13|  * a Huffman encoding of the lengths of all the code strings (in
    14|  * ascending order by source values).  The actual code strings are
    15|  * reconstructed from the lengths in the inflate process, as described
    16|  * in the deflate specification.
    17|  *
    18|  *  REFERENCES
    19|  *
    20|  *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
    21|  *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
    22|  *
    23|  *      Storer, James A.
    24|  *          Data Compression:  Methods and Theory, pp. 49-50.
    25|  *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
    26|  *
    27|  *      Sedgewick, R.
    28|  *          Algorithms, p290.
    29|  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
    30|  */
    31| /* @(#) $Id$ */
    32| /* #define GEN_TREES_H */
    33| #include "deflate.h"
    34| #ifdef ZLIB_DEBUG
    35| #  include <ctype.h>
    36| #endif
    37| /* ===========================================================================
    38|  * Constants
    39|  */
    40| #define MAX_BL_BITS 7
    41| /* Bit length codes must not exceed MAX_BL_BITS bits */
    42| #define END_BLOCK 256
    43| /* end of block literal code */
    44| #define REP_3_6      16
    45| /* repeat previous bit length 3-6 times (2 bits of repeat count) */
    46| #define REPZ_3_10    17
    47| /* repeat a zero length 3-10 times  (3 bits of repeat count) */
    48| #define REPZ_11_138  18
    49| /* repeat a zero length 11-138 times  (7 bits of repeat count) */
    50| local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
    51|    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
    52| local const int extra_dbits[D_CODES] /* extra bits for each distance code */
    53|    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
    54| local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
    55|    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
    56| local const uch bl_order[BL_CODES]
    57|    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
    58| /* The lengths of the bit length codes are sent in order of decreasing
    59|  * probability, to avoid transmitting the lengths for unused bit length codes.
    60|  */
    61| /* ===========================================================================
    62|  * Local data. These are initialized only once.
    63|  */
    64| #define DIST_CODE_LEN  512 /* see definition of array dist_code below */
    65| #if defined(GEN_TREES_H) || !defined(STDC)
    66| /* non ANSI compilers may not accept trees.h */
    67| local ct_data static_ltree[L_CODES+2];
    68| /* The static literal tree. Since the bit lengths are imposed, there is no
    69|  * need for the L_CODES extra codes used during heap construction. However
    70|  * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
    71|  * below).
    72|  */
    73| local ct_data static_dtree[D_CODES];
    74| /* The static distance tree. (Actually a trivial tree since all codes use
    75|  * 5 bits.)
    76|  */
    77| uch _dist_code[DIST_CODE_LEN];
    78| /* Distance codes. The first 256 values correspond to the distances
    79|  * 3 .. 258, the last 256 values correspond to the top 8 bits of
    80|  * the 15 bit distances.
    81|  */
    82| uch _length_code[MAX_MATCH-MIN_MATCH+1];
    83| /* length code for each normalized match length (0 == MIN_MATCH) */
    84| local int base_length[LENGTH_CODES];
    85| /* First normalized length for each code (0 = MIN_MATCH) */
    86| local int base_dist[D_CODES];
    87| /* First normalized distance for each code (0 = distance of 1) */
    88| #else
    89| #  include "trees.h"
    90| #endif /* GEN_TREES_H */
    91| struct static_tree_desc_s {
    92|     const ct_data *static_tree;  /* static tree or NULL */
    93|     const intf *extra_bits;      /* extra bits for each code or NULL */
    94|     int     extra_base;          /* base index for extra_bits */
    95|     int     elems;               /* max number of elements in the tree */
    96|     int     max_length;          /* max bit length for the codes */
    97| };
    98| local const static_tree_desc  static_l_desc =
    99| {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
   100| local const static_tree_desc  static_d_desc =
   101| {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
   102| local const static_tree_desc  static_bl_desc =
   103| {(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
   104| /* ===========================================================================
   105|  * Local (static) routines in this file.
   106|  */
   107| local void tr_static_init OF((void));
   108| local void init_block     OF((deflate_state *s));
   109| local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
   110| local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
   111| local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
   112| local void build_tree     OF((deflate_state *s, tree_desc *desc));
   113| local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
   114| local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
   115| local int  build_bl_tree  OF((deflate_state *s));
   116| local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
   117|                               int blcodes));
   118| local void compress_block OF((deflate_state *s, const ct_data *ltree,
   119|                               const ct_data *dtree));
   120| local int  detect_data_type OF((deflate_state *s));
   121| local unsigned bi_reverse OF((unsigned code, int len));
   122| local void bi_windup      OF((deflate_state *s));
   123| local void bi_flush       OF((deflate_state *s));
   124| #ifdef GEN_TREES_H
   125| local void gen_trees_header OF((void));
   126| #endif
   127| #ifndef ZLIB_DEBUG
   128| #  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   129|    /* Send a code of the given tree. c and tree must not have side effects */
   130| #else /* !ZLIB_DEBUG */
   131| #  define send_code(s, c, tree) \
   132|      { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
   133|        send_bits(s, tree[c].Code, tree[c].Len); }
   134| #endif
   135| /* ===========================================================================
   136|  * Output a short LSB first on the stream.
   137|  * IN assertion: there is enough room in pendingBuf.
   138|  */
   139| #define put_short(s, w) { \
   140|     put_byte(s, (uch)((w) & 0xff)); \
   141|     put_byte(s, (uch)((ush)(w) >> 8)); \
   142| }
   143| /* ===========================================================================
   144|  * Send a value on a given number of bits.
   145|  * IN assertion: length <= 16 and value fits in length bits.
   146|  */
   147| #ifdef ZLIB_DEBUG
   148| local void send_bits      OF((deflate_state *s, int value, int length));
   149| local void send_bits(s, value, length)
   150|     deflate_state *s;
   151|     int value;  /* value to send */
   152|     int length; /* number of bits */
   153| {
   154|     Tracevv((stderr," l %2d v %4x ", length, value));
   155|     Assert(length > 0 && length <= 15, "invalid length");
   156|     s->bits_sent += (ulg)length;
   157|     /* If not enough room in bi_buf, use (valid) bits from bi_buf and
   158|      * (16 - bi_valid) bits from value, leaving (width - (16 - bi_valid))
   159|      * unused bits in value.
   160|      */
   161|     if (s->bi_valid > (int)Buf_size - length) {
   162|         s->bi_buf |= (ush)value << s->bi_valid;
   163|         put_short(s, s->bi_buf);
   164|         s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
   165|         s->bi_valid += length - Buf_size;
   166|     } else {
   167|         s->bi_buf |= (ush)value << s->bi_valid;
   168|         s->bi_valid += length;
   169|     }
   170| }
   171| #else /* !ZLIB_DEBUG */
   172| #define send_bits(s, value, length) \
   173| { int len = length;\
   174|   if (s->bi_valid > (int)Buf_size - len) {\
   175|     int val = (int)value;\
   176|     s->bi_buf |= (ush)val << s->bi_valid;\
   177|     put_short(s, s->bi_buf);\
   178|     s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
   179|     s->bi_valid += len - Buf_size;\
   180|   } else {\
   181|     s->bi_buf |= (ush)(value) << s->bi_valid;\
   182|     s->bi_valid += len;\
   183|   }\
   184| }
   185| #endif /* ZLIB_DEBUG */
   186| /* the arguments must not have side effects */
   187| /* ===========================================================================
   188|  * Initialize the various 'constant' tables.
   189|  */
   190| local void tr_static_init()
   191| {
   192| #if defined(GEN_TREES_H) || !defined(STDC)
   193|     static int static_init_done = 0;
   194|     int n;        /* iterates over tree elements */
   195|     int bits;     /* bit counter */
   196|     int length;   /* length value */
   197|     int code;     /* code value */
   198|     int dist;     /* distance index */
   199|     ush bl_count[MAX_BITS+1];
   200|     /* number of codes at each bit length for an optimal tree */
   201|     if (static_init_done) return;
   202|     /* For some embedded targets, global variables are not initialized: */
   203| #ifdef NO_INIT_GLOBAL_POINTERS
   204|     static_l_desc.static_tree = static_ltree;
   205|     static_l_desc.extra_bits = extra_lbits;
   206|     static_d_desc.static_tree = static_dtree;
   207|     static_d_desc.extra_bits = extra_dbits;
   208|     static_bl_desc.extra_bits = extra_blbits;
   209| #endif
   210|     /* Initialize the mapping length (0..255) -> length code (0..28) */
   211|     length = 0;
   212|     for (code = 0; code < LENGTH_CODES-1; code++) {
   213|         base_length[code] = length;
   214|         for (n = 0; n < (1 << extra_lbits[code]); n++) {
   215|             _length_code[length++] = (uch)code;
   216|         }
   217|     }
   218|     Assert (length == 256, "tr_static_init: length != 256");
   219|     /* Note that the length 255 (match length 258) can be represented
   220|      * in two different ways: code 284 + 5 bits or code 285, so we
   221|      * overwrite length_code[255] to use the best encoding:
   222|      */
   223|     _length_code[length - 1] = (uch)code;
   224|     /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
   225|     dist = 0;
   226|     for (code = 0 ; code < 16; code++) {
   227|         base_dist[code] = dist;
   228|         for (n = 0; n < (1 << extra_dbits[code]); n++) {
   229|             _dist_code[dist++] = (uch)code;
   230|         }
   231|     }
   232|     Assert (dist == 256, "tr_static_init: dist != 256");
   233|     dist >>= 7; /* from now on, all distances are divided by 128 */
   234|     for ( ; code < D_CODES; code++) {
   235|         base_dist[code] = dist << 7;
   236|         for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
   237|             _dist_code[256 + dist++] = (uch)code;
   238|         }
   239|     }
   240|     Assert (dist == 256, "tr_static_init: 256 + dist != 512");
   241|     /* Construct the codes of the static literal tree */
   242|     for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
   243|     n = 0;
   244|     while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
   245|     while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
   246|     while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
   247|     while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
   248|     /* Codes 286 and 287 do not exist, but we must include them in the
   249|      * tree construction to get a canonical Huffman tree (longest code
   250|      * all ones)
   251|      */
   252|     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
   253|     /* The static distance tree is trivial: */
   254|     for (n = 0; n < D_CODES; n++) {
   255|         static_dtree[n].Len = 5;
   256|         static_dtree[n].Code = bi_reverse((unsigned)n, 5);
   257|     }
   258|     static_init_done = 1;
   259| #  ifdef GEN_TREES_H
   260|     gen_trees_header();
   261| #  endif
   262| #endif /* defined(GEN_TREES_H) || !defined(STDC) */
   263| }
   264| /* ===========================================================================
   265|  * Generate the file trees.h describing the static trees.
   266|  */
   267| #ifdef GEN_TREES_H
   268| #  ifndef ZLIB_DEBUG
   269| #    include <stdio.h>
   270| #  endif
   271| #  define SEPARATOR(i, last, width) \
   272|       ((i) == (last)? "\n};\n\n" :    \
   273|        ((i) % (width) == (width) - 1 ? ",\n" : ", "))
   274| void gen_trees_header()
   275| {
   276|     FILE *header = fopen("trees.h", "w");
   277|     int i;
   278|     Assert (header != NULL, "Can't open trees.h");
   279|     fprintf(header,
   280|             "/* header created automatically with -DGEN_TREES_H */\n\n");
   281|     fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
   282|     for (i = 0; i < L_CODES+2; i++) {
   283|         fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
   284|                 static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
   285|     }
   286|     fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
   287|     for (i = 0; i < D_CODES; i++) {
   288|         fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
   289|                 static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
   290|     }
   291|     fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
   292|     for (i = 0; i < DIST_CODE_LEN; i++) {
   293|         fprintf(header, "%2u%s", _dist_code[i],
   294|                 SEPARATOR(i, DIST_CODE_LEN-1, 20));
   295|     }
   296|     fprintf(header,
   297|         "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
   298|     for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
   299|         fprintf(header, "%2u%s", _length_code[i],
   300|                 SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
   301|     }
   302|     fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
   303|     for (i = 0; i < LENGTH_CODES; i++) {
   304|         fprintf(header, "%1u%s", base_length[i],
   305|                 SEPARATOR(i, LENGTH_CODES-1, 20));
   306|     }
   307|     fprintf(header, "local const int base_dist[D_CODES] = {\n");
   308|     for (i = 0; i < D_CODES; i++) {
   309|         fprintf(header, "%5u%s", base_dist[i],
   310|                 SEPARATOR(i, D_CODES-1, 10));
   311|     }
   312|     fclose(header);
   313| }
   314| #endif /* GEN_TREES_H */
   315| /* ===========================================================================
   316|  * Initialize the tree data structures for a new zlib stream.
   317|  */
   318| void ZLIB_INTERNAL _tr_init(s)
   319|     deflate_state *s;
   320| {
   321|     tr_static_init();
   322|     s->l_desc.dyn_tree = s->dyn_ltree;
   323|     s->l_desc.stat_desc = &static_l_desc;
   324|     s->d_desc.dyn_tree = s->dyn_dtree;
   325|     s->d_desc.stat_desc = &static_d_desc;
   326|     s->bl_desc.dyn_tree = s->bl_tree;
   327|     s->bl_desc.stat_desc = &static_bl_desc;
   328|     s->bi_buf = 0;
   329|     s->bi_valid = 0;
   330| #ifdef ZLIB_DEBUG
   331|     s->compressed_len = 0L;
   332|     s->bits_sent = 0L;
   333| #endif
   334|     /* Initialize the first block of the first file: */
   335|     init_block(s);
   336| }
   337| /* ===========================================================================
   338|  * Initialize a new block.
   339|  */
   340| local void init_block(s)
   341|     deflate_state *s;
   342| {
   343|     int n; /* iterates over tree elements */
   344|     /* Initialize the trees. */
   345|     for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
   346|     for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
   347|     for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
   348|     s->dyn_ltree[END_BLOCK].Freq = 1;
   349|     s->opt_len = s->static_len = 0L;
   350|     s->sym_next = s->matches = 0;
   351| }
   352| #define SMALLEST 1
   353| /* Index within the heap array of least frequent node in the Huffman tree */
   354| /* ===========================================================================
   355|  * Remove the smallest element from the heap and recreate the heap with
   356|  * one less element. Updates heap and heap_len.
   357|  */
   358| #define pqremove(s, tree, top) \
   359| {\
   360|     top = s->heap[SMALLEST]; \
   361|     s->heap[SMALLEST] = s->heap[s->heap_len--]; \
   362|     pqdownheap(s, tree, SMALLEST); \
   363| }
   364| /* ===========================================================================
   365|  * Compares to subtrees, using the tree depth as tie breaker when
   366|  * the subtrees have equal frequency. This minimizes the worst case length.
   367|  */
   368| #define smaller(tree, n, m, depth) \
   369|    (tree[n].Freq < tree[m].Freq || \
   370|    (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
   371| /* ===========================================================================
   372|  * Restore the heap property by moving down the tree starting at node k,
   373|  * exchanging a node with the smallest of its two sons if necessary, stopping
   374|  * when the heap property is re-established (each father smaller than its
   375|  * two sons).
   376|  */
   377| local void pqdownheap(s, tree, k)
   378|     deflate_state *s;
   379|     ct_data *tree;  /* the tree to restore */
   380|     int k;               /* node to move down */
   381| {
   382|     int v = s->heap[k];
   383|     int j = k << 1;  /* left son of k */
   384|     while (j <= s->heap_len) {
   385|         /* Set j to the smallest of the two sons: */
   386|         if (j < s->heap_len &&
   387|             smaller(tree, s->heap[j + 1], s->heap[j], s->depth)) {
   388|             j++;
   389|         }
   390|         /* Exit if v is smaller than both sons */
   391|         if (smaller(tree, v, s->heap[j], s->depth)) break;
   392|         /* Exchange v with the smallest son */
   393|         s->heap[k] = s->heap[j];  k = j;
   394|         /* And continue down the tree, setting j to the left son of k */
   395|         j <<= 1;
   396|     }
   397|     s->heap[k] = v;
   398| }
   399| /* ===========================================================================
   400|  * Compute the optimal bit lengths for a tree and update the total bit length
   401|  * for the current block.
   402|  * IN assertion: the fields freq and dad are set, heap[heap_max] and
   403|  *    above are the tree nodes sorted by increasing frequency.
   404|  * OUT assertions: the field len is set to the optimal bit length, the
   405|  *     array bl_count contains the frequencies for each bit length.
   406|  *     The length opt_len is updated; static_len is also updated if stree is
   407|  *     not null.
   408|  */
   409| local void gen_bitlen(s, desc)
   410|     deflate_state *s;
   411|     tree_desc *desc;    /* the tree descriptor */
   412| {
   413|     ct_data *tree        = desc->dyn_tree;
   414|     int max_code         = desc->max_code;
   415|     const ct_data *stree = desc->stat_desc->static_tree;
   416|     const intf *extra    = desc->stat_desc->extra_bits;
   417|     int base             = desc->stat_desc->extra_base;
   418|     int max_length       = desc->stat_desc->max_length;
   419|     int h;              /* heap index */
   420|     int n, m;           /* iterate over the tree elements */
   421|     int bits;           /* bit length */
   422|     int xbits;          /* extra bits */
   423|     ush f;              /* frequency */
   424|     int overflow = 0;   /* number of elements with bit length too large */
   425|     for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
   426|     /* In a first pass, compute the optimal bit lengths (which may
   427|      * overflow in the case of the bit length tree).
   428|      */
   429|     tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
   430|     for (h = s->heap_max + 1; h < HEAP_SIZE; h++) {
   431|         n = s->heap[h];
   432|         bits = tree[tree[n].Dad].Len + 1;
   433|         if (bits > max_length) bits = max_length, overflow++;
   434|         tree[n].Len = (ush)bits;
   435|         /* We overwrite tree[n].Dad which is no longer needed */
   436|         if (n > max_code) continue; /* not a leaf node */
   437|         s->bl_count[bits]++;
   438|         xbits = 0;
   439|         if (n >= base) xbits = extra[n - base];
   440|         f = tree[n].Freq;
   441|         s->opt_len += (ulg)f * (unsigned)(bits + xbits);
   442|         if (stree) s->static_len += (ulg)f * (unsigned)(stree[n].Len + xbits);
   443|     }
   444|     if (overflow == 0) return;
   445|     Tracev((stderr,"\nbit length overflow\n"));
   446|     /* This happens for example on obj2 and pic of the Calgary corpus */
   447|     /* Find the first bit length which could increase: */
   448|     do {
   449|         bits = max_length - 1;
   450|         while (s->bl_count[bits] == 0) bits--;
   451|         s->bl_count[bits]--;        /* move one leaf down the tree */
   452|         s->bl_count[bits + 1] += 2; /* move one overflow item as its brother */
   453|         s->bl_count[max_length]--;
   454|         /* The brother of the overflow item also moves one step up,
   455|          * but this does not affect bl_count[max_length]
   456|          */
   457|         overflow -= 2;
   458|     } while (overflow > 0);
   459|     /* Now recompute all bit lengths, scanning in increasing frequency.
   460|      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   461|      * lengths instead of fixing only the wrong ones. This idea is taken
   462|      * from 'ar' written by Haruhiko Okumura.)
   463|      */
   464|     for (bits = max_length; bits != 0; bits--) {
   465|         n = s->bl_count[bits];
   466|         while (n != 0) {
   467|             m = s->heap[--h];
   468|             if (m > max_code) continue;
   469|             if ((unsigned) tree[m].Len != (unsigned) bits) {
   470|                 Tracev((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
   471|                 s->opt_len += ((ulg)bits - tree[m].Len) * tree[m].Freq;
   472|                 tree[m].Len = (ush)bits;
   473|             }
   474|             n--;
   475|         }
   476|     }
   477| }
   478| /* ===========================================================================
   479|  * Generate the codes for a given tree and bit counts (which need not be
   480|  * optimal).
   481|  * IN assertion: the array bl_count contains the bit length statistics for
   482|  * the given tree and the field len is set for all tree elements.
   483|  * OUT assertion: the field code is set for all tree elements of non
   484|  *     zero code length.
   485|  */
   486| local void gen_codes(tree, max_code, bl_count)
   487|     ct_data *tree;             /* the tree to decorate */
   488|     int max_code;              /* largest code with non zero frequency */
   489|     ushf *bl_count;            /* number of codes at each bit length */
   490| {
   491|     ush next_code[MAX_BITS+1]; /* next code value for each bit length */
   492|     unsigned code = 0;         /* running code value */
   493|     int bits;                  /* bit index */
   494|     int n;                     /* code index */
   495|     /* The distribution counts are first used to generate the code values
   496|      * without bit reversal.
   497|      */
   498|     for (bits = 1; bits <= MAX_BITS; bits++) {
   499|         code = (code + bl_count[bits - 1]) << 1;
   500|         next_code[bits] = (ush)code;
   501|     }
   502|     /* Check that the bit counts in bl_count are consistent. The last code
   503|      * must be all ones.
   504|      */
   505|     Assert (code + bl_count[MAX_BITS] - 1 == (1 << MAX_BITS) - 1,
   506|             "inconsistent bit counts");
   507|     Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
   508|     for (n = 0;  n <= max_code; n++) {
   509|         int len = tree[n].Len;
   510|         if (len == 0) continue;
   511|         /* Now reverse the bits */
   512|         tree[n].Code = (ush)bi_reverse(next_code[len]++, len);
   513|         Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
   514|             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len] - 1));
   515|     }
   516| }
   517| /* ===========================================================================
   518|  * Construct one Huffman tree and assigns the code bit strings and lengths.
   519|  * Update the total bit length for the current block.
   520|  * IN assertion: the field freq is set for all tree elements.
   521|  * OUT assertions: the fields len and code are set to the optimal bit length
   522|  *     and corresponding code. The length opt_len is updated; static_len is
   523|  *     also updated if stree is not null. The field max_code is set.
   524|  */
   525| local void build_tree(s, desc)
   526|     deflate_state *s;
   527|     tree_desc *desc; /* the tree descriptor */
   528| {
   529|     ct_data *tree         = desc->dyn_tree;
   530|     const ct_data *stree  = desc->stat_desc->static_tree;
   531|     int elems             = desc->stat_desc->elems;
   532|     int n, m;          /* iterate over heap elements */
   533|     int max_code = -1; /* largest code with non zero frequency */
   534|     int node;          /* new node being created */
   535|     /* Construct the initial heap, with least frequent element in
   536|      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n + 1].
   537|      * heap[0] is not used.
   538|      */
   539|     s->heap_len = 0, s->heap_max = HEAP_SIZE;
   540|     for (n = 0; n < elems; n++) {
   541|         if (tree[n].Freq != 0) {
   542|             s->heap[++(s->heap_len)] = max_code = n;
   543|             s->depth[n] = 0;
   544|         } else {
   545|             tree[n].Len = 0;
   546|         }
   547|     }
   548|     /* The pkzip format requires that at least one distance code exists,
   549|      * and that at least one bit should be sent even if there is only one
   550|      * possible code. So to avoid special checks later on we force at least
   551|      * two codes of non zero frequency.
   552|      */
   553|     while (s->heap_len < 2) {
   554|         node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
   555|         tree[node].Freq = 1;
   556|         s->depth[node] = 0;
   557|         s->opt_len--; if (stree) s->static_len -= stree[node].Len;
   558|         /* node is 0 or 1 so it does not have extra bits */
   559|     }
   560|     desc->max_code = max_code;
   561|     /* The elements heap[heap_len/2 + 1 .. heap_len] are leaves of the tree,
   562|      * establish sub-heaps of increasing lengths:
   563|      */
   564|     for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
   565|     /* Construct the Huffman tree by repeatedly combining the least two
   566|      * frequent nodes.
   567|      */
   568|     node = elems;              /* next internal node of the tree */
   569|     do {
   570|         pqremove(s, tree, n);  /* n = node of least frequency */
   571|         m = s->heap[SMALLEST]; /* m = node of next least frequency */
   572|         s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
   573|         s->heap[--(s->heap_max)] = m;
   574|         /* Create a new node father of n and m */
   575|         tree[node].Freq = tree[n].Freq + tree[m].Freq;
   576|         s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
   577|                                 s->depth[n] : s->depth[m]) + 1);
   578|         tree[n].Dad = tree[m].Dad = (ush)node;
   579| #ifdef DUMP_BL_TREE
   580|         if (tree == s->bl_tree) {
   581|             fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
   582|                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
   583|         }
   584| #endif
   585|         /* and insert the new node in the heap */
   586|         s->heap[SMALLEST] = node++;
   587|         pqdownheap(s, tree, SMALLEST);
   588|     } while (s->heap_len >= 2);
   589|     s->heap[--(s->heap_max)] = s->heap[SMALLEST];
   590|     /* At this point, the fields freq and dad are set. We can now
   591|      * generate the bit lengths.
   592|      */
   593|     gen_bitlen(s, (tree_desc *)desc);
   594|     /* The field len is now set, we can generate the bit codes */
   595|     gen_codes ((ct_data *)tree, max_code, s->bl_count);
   596| }
   597| /* ===========================================================================
   598|  * Scan a literal or distance tree to determine the frequencies of the codes
   599|  * in the bit length tree.
   600|  */
   601| local void scan_tree(s, tree, max_code)
   602|     deflate_state *s;
   603|     ct_data *tree;   /* the tree to be scanned */
   604|     int max_code;    /* and its largest code of non zero frequency */
   605| {
   606|     int n;                     /* iterates over all tree elements */
   607|     int prevlen = -1;          /* last emitted length */
   608|     int curlen;                /* length of current code */
   609|     int nextlen = tree[0].Len; /* length of next code */
   610|     int count = 0;             /* repeat count of the current code */
   611|     int max_count = 7;         /* max repeat count */
   612|     int min_count = 4;         /* min repeat count */
   613|     if (nextlen == 0) max_count = 138, min_count = 3;
   614|     tree[max_code + 1].Len = (ush)0xffff; /* guard */
   615|     for (n = 0; n <= max_code; n++) {
   616|         curlen = nextlen; nextlen = tree[n + 1].Len;
   617|         if (++count < max_count && curlen == nextlen) {
   618|             continue;
   619|         } else if (count < min_count) {
   620|             s->bl_tree[curlen].Freq += count;
   621|         } else if (curlen != 0) {
   622|             if (curlen != prevlen) s->bl_tree[curlen].Freq++;
   623|             s->bl_tree[REP_3_6].Freq++;
   624|         } else if (count <= 10) {
   625|             s->bl_tree[REPZ_3_10].Freq++;
   626|         } else {
   627|             s->bl_tree[REPZ_11_138].Freq++;
   628|         }
   629|         count = 0; prevlen = curlen;
   630|         if (nextlen == 0) {
   631|             max_count = 138, min_count = 3;
   632|         } else if (curlen == nextlen) {
   633|             max_count = 6, min_count = 3;
   634|         } else {
   635|             max_count = 7, min_count = 4;
   636|         }
   637|     }
   638| }
   639| /* ===========================================================================
   640|  * Send a literal or distance tree in compressed form, using the codes in
   641|  * bl_tree.
   642|  */
   643| local void send_tree(s, tree, max_code)
   644|     deflate_state *s;
   645|     ct_data *tree; /* the tree to be scanned */
   646|     int max_code;       /* and its largest code of non zero frequency */
   647| {
   648|     int n;                     /* iterates over all tree elements */
   649|     int prevlen = -1;          /* last emitted length */
   650|     int curlen;                /* length of current code */
   651|     int nextlen = tree[0].Len; /* length of next code */
   652|     int count = 0;             /* repeat count of the current code */
   653|     int max_count = 7;         /* max repeat count */
   654|     int min_count = 4;         /* min repeat count */
   655|     /* tree[max_code + 1].Len = -1; */  /* guard already set */
   656|     if (nextlen == 0) max_count = 138, min_count = 3;
   657|     for (n = 0; n <= max_code; n++) {
   658|         curlen = nextlen; nextlen = tree[n + 1].Len;
   659|         if (++count < max_count && curlen == nextlen) {
   660|             continue;
   661|         } else if (count < min_count) {
   662|             do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
   663|         } else if (curlen != 0) {
   664|             if (curlen != prevlen) {
   665|                 send_code(s, curlen, s->bl_tree); count--;
   666|             }
   667|             Assert(count >= 3 && count <= 6, " 3_6?");
   668|             send_code(s, REP_3_6, s->bl_tree); send_bits(s, count - 3, 2);
   669|         } else if (count <= 10) {
   670|             send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count - 3, 3);
   671|         } else {
   672|             send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count - 11, 7);
   673|         }
   674|         count = 0; prevlen = curlen;
   675|         if (nextlen == 0) {
   676|             max_count = 138, min_count = 3;
   677|         } else if (curlen == nextlen) {
   678|             max_count = 6, min_count = 3;
   679|         } else {
   680|             max_count = 7, min_count = 4;
   681|         }
   682|     }
   683| }
   684| /* ===========================================================================
   685|  * Construct the Huffman tree for the bit lengths and return the index in
   686|  * bl_order of the last bit length code to send.
   687|  */
   688| local int build_bl_tree(s)
   689|     deflate_state *s;
   690| {
   691|     int max_blindex;  /* index of last bit length code of non zero freq */
   692|     /* Determine the bit length frequencies for literal and distance trees */
   693|     scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
   694|     scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
   695|     /* Build the bit length tree: */
   696|     build_tree(s, (tree_desc *)(&(s->bl_desc)));
   697|     /* opt_len now includes the length of the tree representations, except the
   698|      * lengths of the bit lengths codes and the 5 + 5 + 4 bits for the counts.
   699|      */
   700|     /* Determine the number of bit length codes to send. The pkzip format
   701|      * requires that at least 4 bit length codes be sent. (appnote.txt says
   702|      * 3 but the actual value used is 4.)
   703|      */
   704|     for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
   705|         if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
   706|     }
   707|     /* Update opt_len to include the bit length tree and counts */
   708|     s->opt_len += 3*((ulg)max_blindex + 1) + 5 + 5 + 4;
   709|     Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
   710|             s->opt_len, s->static_len));
   711|     return max_blindex;
   712| }
   713| /* ===========================================================================
   714|  * Send the header for a block using dynamic Huffman trees: the counts, the
   715|  * lengths of the bit length codes, the literal tree and the distance tree.
   716|  * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
   717|  */
   718| local void send_all_trees(s, lcodes, dcodes, blcodes)
   719|     deflate_state *s;
   720|     int lcodes, dcodes, blcodes; /* number of codes for each tree */
   721| {
   722|     int rank;                    /* index in bl_order */
   723|     Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
   724|     Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
   725|             "too many codes");
   726|     Tracev((stderr, "\nbl counts: "));
   727|     send_bits(s, lcodes - 257, 5);  /* not +255 as stated in appnote.txt */
   728|     send_bits(s, dcodes - 1,   5);
   729|     send_bits(s, blcodes - 4,  4);  /* not -3 as stated in appnote.txt */
   730|     for (rank = 0; rank < blcodes; rank++) {
   731|         Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
   732|         send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
   733|     }
   734|     Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
   735|     send_tree(s, (ct_data *)s->dyn_ltree, lcodes - 1);  /* literal tree */
   736|     Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
   737|     send_tree(s, (ct_data *)s->dyn_dtree, dcodes - 1);  /* distance tree */
   738|     Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
   739| }
   740| /* ===========================================================================
   741|  * Send a stored block
   742|  */
   743| void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
   744|     deflate_state *s;
   745|     charf *buf;       /* input block */
   746|     ulg stored_len;   /* length of input block */
   747|     int last;         /* one if this is the last block for a file */
   748| {
   749|     send_bits(s, (STORED_BLOCK<<1) + last, 3);  /* send block type */
   750|     bi_windup(s);        /* align on byte boundary */
   751|     put_short(s, (ush)stored_len);
   752|     put_short(s, (ush)~stored_len);
   753|     if (stored_len)
   754|         zmemcpy(s->pending_buf + s->pending, (Bytef *)buf, stored_len);
   755|     s->pending += stored_len;
   756| #ifdef ZLIB_DEBUG
   757|     s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
   758|     s->compressed_len += (stored_len + 4) << 3;
   759|     s->bits_sent += 2*16;
   760|     s->bits_sent += stored_len << 3;
   761| #endif
   762| }
   763| /* ===========================================================================
   764|  * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
   765|  */
   766| void ZLIB_INTERNAL _tr_flush_bits(s)
   767|     deflate_state *s;
   768| {
   769|     bi_flush(s);
   770| }
   771| /* ===========================================================================
   772|  * Send one empty static block to give enough lookahead for inflate.
   773|  * This takes 10 bits, of which 7 may remain in the bit buffer.
   774|  */
   775| void ZLIB_INTERNAL _tr_align(s)
   776|     deflate_state *s;
   777| {
   778|     send_bits(s, STATIC_TREES<<1, 3);
   779|     send_code(s, END_BLOCK, static_ltree);
   780| #ifdef ZLIB_DEBUG
   781|     s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
   782| #endif
   783|     bi_flush(s);
   784| }
   785| /* ===========================================================================
   786|  * Determine the best encoding for the current block: dynamic trees, static
   787|  * trees or store, and write out the encoded block.
   788|  */
   789| void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
   790|     deflate_state *s;
   791|     charf *buf;       /* input block, or NULL if too old */
   792|     ulg stored_len;   /* length of input block */
   793|     int last;         /* one if this is the last block for a file */
   794| {
   795|     ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
   796|     int max_blindex = 0;  /* index of last bit length code of non zero freq */
   797|     /* Build the Huffman trees unless a stored block is forced */
   798|     if (s->level > 0) {
   799|         /* Check if the file is binary or text */
   800|         if (s->strm->data_type == Z_UNKNOWN)
   801|             s->strm->data_type = detect_data_type(s);
   802|         /* Construct the literal and distance trees */
   803|         build_tree(s, (tree_desc *)(&(s->l_desc)));
   804|         Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
   805|                 s->static_len));
   806|         build_tree(s, (tree_desc *)(&(s->d_desc)));
   807|         Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
   808|                 s->static_len));
   809|         /* At this point, opt_len and static_len are the total bit lengths of
   810|          * the compressed block data, excluding the tree representations.
   811|          */
   812|         /* Build the bit length tree for the above two trees, and get the index
   813|          * in bl_order of the last bit length code to send.
   814|          */
   815|         max_blindex = build_bl_tree(s);
   816|         /* Determine the best encoding. Compute the block lengths in bytes. */
   817|         opt_lenb = (s->opt_len + 3 + 7) >> 3;
   818|         static_lenb = (s->static_len + 3 + 7) >> 3;
   819|         Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
   820|                 opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
   821|                 s->sym_next / 3));
   822| #ifndef FORCE_STATIC
   823|         if (static_lenb <= opt_lenb || s->strategy == Z_FIXED)
   824| #endif
   825|             opt_lenb = static_lenb;
   826|     } else {
   827|         Assert(buf != (char*)0, "lost buf");
   828|         opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
   829|     }
   830| #ifdef FORCE_STORED
   831|     if (buf != (char*)0) { /* force stored block */
   832| #else
   833|     if (stored_len + 4 <= opt_lenb && buf != (char*)0) {
   834|                        /* 4: two words for the lengths */
   835| #endif
   836|         /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
   837|          * Otherwise we can't have processed more than WSIZE input bytes since
   838|          * the last block flush, because compression would have been
   839|          * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
   840|          * transform a block into a stored block.
   841|          */
   842|         _tr_stored_block(s, buf, stored_len, last);
   843|     } else if (static_lenb == opt_lenb) {
   844|         send_bits(s, (STATIC_TREES<<1) + last, 3);
   845|         compress_block(s, (const ct_data *)static_ltree,
   846|                        (const ct_data *)static_dtree);
   847| #ifdef ZLIB_DEBUG
   848|         s->compressed_len += 3 + s->static_len;
   849| #endif
   850|     } else {
   851|         send_bits(s, (DYN_TREES<<1) + last, 3);
   852|         send_all_trees(s, s->l_desc.max_code + 1, s->d_desc.max_code + 1,
   853|                        max_blindex + 1);
   854|         compress_block(s, (const ct_data *)s->dyn_ltree,
   855|                        (const ct_data *)s->dyn_dtree);
   856| #ifdef ZLIB_DEBUG
   857|         s->compressed_len += 3 + s->opt_len;
   858| #endif
   859|     }
   860|     Assert (s->compressed_len == s->bits_sent, "bad compressed size");
   861|     /* The above check is made mod 2^32, for files larger than 512 MB
   862|      * and uLong implemented on 32 bits.
   863|      */
   864|     init_block(s);
   865|     if (last) {
   866|         bi_windup(s);
   867| #ifdef ZLIB_DEBUG
   868|         s->compressed_len += 7;  /* align on byte boundary */
   869| #endif
   870|     }
   871|     Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len >> 3,
   872|            s->compressed_len - 7*last));
   873| }
   874| /* ===========================================================================
   875|  * Save the match info and tally the frequency counts. Return true if
   876|  * the current block must be flushed.
   877|  */
   878| int ZLIB_INTERNAL _tr_tally(s, dist, lc)
   879|     deflate_state *s;
   880|     unsigned dist;  /* distance of matched string */
   881|     unsigned lc;    /* match length - MIN_MATCH or unmatched char (dist==0) */
   882| {
   883|     s->sym_buf[s->sym_next++] = (uch)dist;
   884|     s->sym_buf[s->sym_next++] = (uch)(dist >> 8);
   885|     s->sym_buf[s->sym_next++] = (uch)lc;
   886|     if (dist == 0) {
   887|         /* lc is the unmatched char */
   888|         s->dyn_ltree[lc].Freq++;
   889|     } else {
   890|         s->matches++;
   891|         /* Here, lc is the match length - MIN_MATCH */
   892|         dist--;             /* dist = match distance - 1 */
   893|         Assert((ush)dist < (ush)MAX_DIST(s) &&
   894|                (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
   895|                (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
   896|         s->dyn_ltree[_length_code[lc] + LITERALS + 1].Freq++;
   897|         s->dyn_dtree[d_code(dist)].Freq++;
   898|     }
   899|     return (s->sym_next == s->sym_end);
   900| }
   901| /* ===========================================================================
   902|  * Send the block data compressed using the given Huffman trees
   903|  */
   904| local void compress_block(s, ltree, dtree)
   905|     deflate_state *s;
   906|     const ct_data *ltree; /* literal tree */
   907|     const ct_data *dtree; /* distance tree */
   908| {
   909|     unsigned dist;      /* distance of matched string */
   910|     int lc;             /* match length or unmatched char (if dist == 0) */
   911|     unsigned sx = 0;    /* running index in sym_buf */
   912|     unsigned code;      /* the code to send */
   913|     int extra;          /* number of extra bits to send */
   914|     if (s->sym_next != 0) do {
   915|         dist = s->sym_buf[sx++] & 0xff;
   916|         dist += (unsigned)(s->sym_buf[sx++] & 0xff) << 8;
   917|         lc = s->sym_buf[sx++];
   918|         if (dist == 0) {
   919|             send_code(s, lc, ltree); /* send a literal byte */
   920|             Tracecv(isgraph(lc), (stderr," '%c' ", lc));
   921|         } else {
   922|             /* Here, lc is the match length - MIN_MATCH */
   923|             code = _length_code[lc];
   924|             send_code(s, code + LITERALS + 1, ltree);   /* send length code */
   925|             extra = extra_lbits[code];
   926|             if (extra != 0) {
   927|                 lc -= base_length[code];
   928|                 send_bits(s, lc, extra);       /* send the extra length bits */
   929|             }
   930|             dist--; /* dist is now the match distance - 1 */
   931|             code = d_code(dist);
   932|             Assert (code < D_CODES, "bad d_code");
   933|             send_code(s, code, dtree);       /* send the distance code */
   934|             extra = extra_dbits[code];
   935|             if (extra != 0) {
   936|                 dist -= (unsigned)base_dist[code];
   937|                 send_bits(s, dist, extra);   /* send the extra distance bits */
   938|             }
   939|         } /* literal or match pair ? */
   940|         /* Check that the overlay between pending_buf and sym_buf is ok: */
   941|         Assert(s->pending < s->lit_bufsize + sx, "pendingBuf overflow");
   942|     } while (sx < s->sym_next);
   943|     send_code(s, END_BLOCK, ltree);
   944| }
   945| /* ===========================================================================
   946|  * Check if the data type is TEXT or BINARY, using the following algorithm:
   947|  * - TEXT if the two conditions below are satisfied:
   948|  *    a) There are no non-portable control characters belonging to the
   949|  *       "block list" (0..6, 14..25, 28..31).
   950|  *    b) There is at least one printable character belonging to the
   951|  *       "allow list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
   952|  * - BINARY otherwise.
   953|  * - The following partially-portable control characters form a
   954|  *   "gray list" that is ignored in this detection algorithm:
   955|  *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
   956|  * IN assertion: the fields Freq of dyn_ltree are set.
   957|  */
   958| local int detect_data_type(s)
   959|     deflate_state *s;
   960| {
   961|     /* block_mask is the bit mask of block-listed bytes
   962|      * set bits 0..6, 14..25, and 28..31
   963|      * 0xf3ffc07f = binary 11110011111111111100000001111111
   964|      */
   965|     unsigned long block_mask = 0xf3ffc07fUL;
   966|     int n;
   967|     /* Check for non-textual ("block-listed") bytes. */
   968|     for (n = 0; n <= 31; n++, block_mask >>= 1)
   969|         if ((block_mask & 1) && (s->dyn_ltree[n].Freq != 0))
   970|             return Z_BINARY;
   971|     /* Check for textual ("allow-listed") bytes. */
   972|     if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
   973|             || s->dyn_ltree[13].Freq != 0)
   974|         return Z_TEXT;
   975|     for (n = 32; n < LITERALS; n++)
   976|         if (s->dyn_ltree[n].Freq != 0)
   977|             return Z_TEXT;
   978|     /* There are no "block-listed" or "allow-listed" bytes:
   979|      * this stream either is empty or has tolerated ("gray-listed") bytes only.
   980|      */
   981|     return Z_BINARY;
   982| }
   983| /* ===========================================================================
   984|  * Reverse the first len bits of a code, using straightforward code (a faster
   985|  * method would use a table)
   986|  * IN assertion: 1 <= len <= 15
   987|  */
   988| local unsigned bi_reverse(code, len)
   989|     unsigned code; /* the value to invert */
   990|     int len;       /* its bit length */
   991| {
   992|     register unsigned res = 0;
   993|     do {
   994|         res |= code & 1;
   995|         code >>= 1, res <<= 1;
   996|     } while (--len > 0);
   997|     return res >> 1;
   998| }
   999| /* ===========================================================================
  1000|  * Flush the bit buffer, keeping at most 7 bits in it.
  1001|  */
  1002| local void bi_flush(s)
  1003|     deflate_state *s;
  1004| {
  1005|     if (s->bi_valid == 16) {
  1006|         put_short(s, s->bi_buf);
  1007|         s->bi_buf = 0;
  1008|         s->bi_valid = 0;
  1009|     } else if (s->bi_valid >= 8) {
  1010|         put_byte(s, (Byte)s->bi_buf);
  1011|         s->bi_buf >>= 8;
  1012|         s->bi_valid -= 8;
  1013|     }
  1014| }
  1015| /* ===========================================================================
  1016|  * Flush the bit buffer and align the output on a byte boundary
  1017|  */
  1018| local void bi_windup(s)
  1019|     deflate_state *s;
  1020| {
  1021|     if (s->bi_valid > 8) {
  1022|         put_short(s, s->bi_buf);
  1023|     } else if (s->bi_valid > 0) {
  1024|         put_byte(s, (Byte)s->bi_buf);
  1025|     }
  1026|     s->bi_buf = 0;
  1027|     s->bi_valid = 0;
  1028| #ifdef ZLIB_DEBUG
  1029|     s->bits_sent = (s->bits_sent + 7) & ~7;
  1030| #endif
  1031| }


# ====================================================================
# FILE: src/native/external/zlib/uncompr.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| /* uncompr.c -- decompress a memory buffer
     2|  * Copyright (C) 1995-2003, 2010, 2014, 2016 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #define ZLIB_INTERNAL
     7| #include "zlib.h"
     8| /* ===========================================================================
     9|      Decompresses the source buffer into the destination buffer.  *sourceLen is
    10|    the byte length of the source buffer. Upon entry, *destLen is the total size
    11|    of the destination buffer, which must be large enough to hold the entire
    12|    uncompressed data. (The size of the uncompressed data must have been saved
    13|    previously by the compressor and transmitted to the decompressor by some
    14|    mechanism outside the scope of this compression library.) Upon exit,
    15|    *destLen is the size of the decompressed data and *sourceLen is the number
    16|    of source bytes consumed. Upon return, source + *sourceLen points to the
    17|    first unused input byte.
    18|      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
    19|    memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
    20|    Z_DATA_ERROR if the input data was corrupted, including if the input data is
    21|    an incomplete zlib stream.
    22| */
    23| int ZEXPORT uncompress2(dest, destLen, source, sourceLen)
    24|     Bytef *dest;
    25|     uLongf *destLen;
    26|     const Bytef *source;
    27|     uLong *sourceLen;
    28| {
    29|     z_stream stream;
    30|     int err;
    31|     const uInt max = (uInt)-1;
    32|     uLong len, left;
    33|     Byte buf[1];    /* for detection of incomplete stream when *destLen == 0 */
    34|     len = *sourceLen;
    35|     if (*destLen) {
    36|         left = *destLen;
    37|         *destLen = 0;
    38|     }
    39|     else {
    40|         left = 1;
    41|         dest = buf;
    42|     }
    43|     stream.next_in = (z_const Bytef *)source;
    44|     stream.avail_in = 0;
    45|     stream.zalloc = (alloc_func)0;
    46|     stream.zfree = (free_func)0;
    47|     stream.opaque = (voidpf)0;
    48|     err = inflateInit(&stream);
    49|     if (err != Z_OK) return err;
    50|     stream.next_out = dest;
    51|     stream.avail_out = 0;
    52|     do {
    53|         if (stream.avail_out == 0) {
    54|             stream.avail_out = left > (uLong)max ? max : (uInt)left;
    55|             left -= stream.avail_out;
    56|         }
    57|         if (stream.avail_in == 0) {
    58|             stream.avail_in = len > (uLong)max ? max : (uInt)len;
    59|             len -= stream.avail_in;
    60|         }
    61|         err = inflate(&stream, Z_NO_FLUSH);
    62|     } while (err == Z_OK);
    63|     *sourceLen -= len + stream.avail_in;
    64|     if (dest != buf)
    65|         *destLen = stream.total_out;
    66|     else if (stream.total_out && err == Z_BUF_ERROR)
    67|         left = 1;
    68|     inflateEnd(&stream);
    69|     return err == Z_STREAM_END ? Z_OK :
    70|            err == Z_NEED_DICT ? Z_DATA_ERROR  :
    71|            err == Z_BUF_ERROR && left + stream.avail_out ? Z_DATA_ERROR :
    72|            err;
    73| }
    74| int ZEXPORT uncompress(dest, destLen, source, sourceLen)
    75|     Bytef *dest;
    76|     uLongf *destLen;
    77|     const Bytef *source;
    78|     uLong sourceLen;
    79| {
    80|     return uncompress2(dest, destLen, source, &sourceLen);
    81| }


# ====================================================================
# FILE: src/native/external/zlib/zconf.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-501 ---
     1| /* zconf.h -- configuration of the zlib compression library
     2|  * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #ifndef ZCONF_H
     7| #define ZCONF_H
     8| /*
     9|  * If you *really* need a unique prefix for all types and library functions,
    10|  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
    11|  * Even better than compiling with -DZ_PREFIX would be to use configure to set
    12|  * this permanently in zconf.h using "./configure --zprefix".
    13|  */
    14| #ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
    15| #  define Z_PREFIX_SET
    16| /* all linked symbols and init macros */
    17| #  define _dist_code            z__dist_code
    18| #  define _length_code          z__length_code
    19| #  define _tr_align             z__tr_align
    20| #  define _tr_flush_bits        z__tr_flush_bits
    21| #  define _tr_flush_block       z__tr_flush_block
    22| #  define _tr_init              z__tr_init
    23| #  define _tr_stored_block      z__tr_stored_block
    24| #  define _tr_tally             z__tr_tally
    25| #  define adler32               z_adler32
    26| #  define adler32_combine       z_adler32_combine
    27| #  define adler32_combine64     z_adler32_combine64
    28| #  define adler32_z             z_adler32_z
    29| #  ifndef Z_SOLO
    30| #    define compress              z_compress
    31| #    define compress2             z_compress2
    32| #    define compressBound         z_compressBound
    33| #  endif
    34| #  define crc32                 z_crc32
    35| #  define crc32_combine         z_crc32_combine
    36| #  define crc32_combine64       z_crc32_combine64
    37| #  define crc32_combine_gen     z_crc32_combine_gen
    38| #  define crc32_combine_gen64   z_crc32_combine_gen64
    39| #  define crc32_combine_op      z_crc32_combine_op
    40| #  define crc32_z               z_crc32_z
    41| #  define deflate               z_deflate
    42| #  define deflateBound          z_deflateBound
    43| #  define deflateCopy           z_deflateCopy
    44| #  define deflateEnd            z_deflateEnd
    45| #  define deflateGetDictionary  z_deflateGetDictionary
    46| #  define deflateInit           z_deflateInit
    47| #  define deflateInit2          z_deflateInit2
    48| #  define deflateInit2_         z_deflateInit2_
    49| #  define deflateInit_          z_deflateInit_
    50| #  define deflateParams         z_deflateParams
    51| #  define deflatePending        z_deflatePending
    52| #  define deflatePrime          z_deflatePrime
    53| #  define deflateReset          z_deflateReset
    54| #  define deflateResetKeep      z_deflateResetKeep
    55| #  define deflateSetDictionary  z_deflateSetDictionary
    56| #  define deflateSetHeader      z_deflateSetHeader
    57| #  define deflateTune           z_deflateTune
    58| #  define deflate_copyright     z_deflate_copyright
    59| #  define get_crc_table         z_get_crc_table
    60| #  ifndef Z_SOLO
    61| #    define gz_error              z_gz_error
    62| #    define gz_intmax             z_gz_intmax
    63| #    define gz_strwinerror        z_gz_strwinerror
    64| #    define gzbuffer              z_gzbuffer
    65| #    define gzclearerr            z_gzclearerr
    66| #    define gzclose               z_gzclose
    67| #    define gzclose_r             z_gzclose_r
    68| #    define gzclose_w             z_gzclose_w
    69| #    define gzdirect              z_gzdirect
    70| #    define gzdopen               z_gzdopen
    71| #    define gzeof                 z_gzeof
    72| #    define gzerror               z_gzerror
    73| #    define gzflush               z_gzflush
    74| #    define gzfread               z_gzfread
    75| #    define gzfwrite              z_gzfwrite
    76| #    define gzgetc                z_gzgetc
    77| #    define gzgetc_               z_gzgetc_
    78| #    define gzgets                z_gzgets
    79| #    define gzoffset              z_gzoffset
    80| #    define gzoffset64            z_gzoffset64
    81| #    define gzopen                z_gzopen
    82| #    define gzopen64              z_gzopen64
    83| #    ifdef _WIN32
    84| #      define gzopen_w              z_gzopen_w
    85| #    endif
    86| #    define gzprintf              z_gzprintf
    87| #    define gzputc                z_gzputc
    88| #    define gzputs                z_gzputs
    89| #    define gzread                z_gzread
    90| #    define gzrewind              z_gzrewind
    91| #    define gzseek                z_gzseek
    92| #    define gzseek64              z_gzseek64
    93| #    define gzsetparams           z_gzsetparams
    94| #    define gztell                z_gztell
    95| #    define gztell64              z_gztell64
    96| #    define gzungetc              z_gzungetc
    97| #    define gzvprintf             z_gzvprintf
    98| #    define gzwrite               z_gzwrite
    99| #  endif
   100| #  define inflate               z_inflate
   101| #  define inflateBack           z_inflateBack
   102| #  define inflateBackEnd        z_inflateBackEnd
   103| #  define inflateBackInit       z_inflateBackInit
   104| #  define inflateBackInit_      z_inflateBackInit_
   105| #  define inflateCodesUsed      z_inflateCodesUsed
   106| #  define inflateCopy           z_inflateCopy
   107| #  define inflateEnd            z_inflateEnd
   108| #  define inflateGetDictionary  z_inflateGetDictionary
   109| #  define inflateGetHeader      z_inflateGetHeader
   110| #  define inflateInit           z_inflateInit
   111| #  define inflateInit2          z_inflateInit2
   112| #  define inflateInit2_         z_inflateInit2_
   113| #  define inflateInit_          z_inflateInit_
   114| #  define inflateMark           z_inflateMark
   115| #  define inflatePrime          z_inflatePrime
   116| #  define inflateReset          z_inflateReset
   117| #  define inflateReset2         z_inflateReset2
   118| #  define inflateResetKeep      z_inflateResetKeep
   119| #  define inflateSetDictionary  z_inflateSetDictionary
   120| #  define inflateSync           z_inflateSync
   121| #  define inflateSyncPoint      z_inflateSyncPoint
   122| #  define inflateUndermine      z_inflateUndermine
   123| #  define inflateValidate       z_inflateValidate
   124| #  define inflate_copyright     z_inflate_copyright
   125| #  define inflate_fast          z_inflate_fast
   126| #  define inflate_table         z_inflate_table
   127| #  ifndef Z_SOLO
   128| #    define uncompress            z_uncompress
   129| #    define uncompress2           z_uncompress2
   130| #  endif
   131| #  define zError                z_zError
   132| #  ifndef Z_SOLO
   133| #    define zcalloc               z_zcalloc
   134| #    define zcfree                z_zcfree
   135| #  endif
   136| #  define zlibCompileFlags      z_zlibCompileFlags
   137| #  define zlibVersion           z_zlibVersion
   138| /* all zlib typedefs in zlib.h and zconf.h */
   139| #  define Byte                  z_Byte
   140| #  define Bytef                 z_Bytef
   141| #  define alloc_func            z_alloc_func
   142| #  define charf                 z_charf
   143| #  define free_func             z_free_func
   144| #  ifndef Z_SOLO
   145| #    define gzFile                z_gzFile
   146| #  endif
   147| #  define gz_header             z_gz_header
   148| #  define gz_headerp            z_gz_headerp
   149| #  define in_func               z_in_func
   150| #  define intf                  z_intf
   151| #  define out_func              z_out_func
   152| #  define uInt                  z_uInt
   153| #  define uIntf                 z_uIntf
   154| #  define uLong                 z_uLong
   155| #  define uLongf                z_uLongf
   156| #  define voidp                 z_voidp
   157| #  define voidpc                z_voidpc
   158| #  define voidpf                z_voidpf
   159| /* all zlib structs in zlib.h and zconf.h */
   160| #  define gz_header_s           z_gz_header_s
   161| #  define internal_state        z_internal_state
   162| #endif
   163| #if defined(__MSDOS__) && !defined(MSDOS)
   164| #  define MSDOS
   165| #endif
   166| #if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
   167| #  define OS2
   168| #endif
   169| #if defined(_WINDOWS) && !defined(WINDOWS)
   170| #  define WINDOWS
   171| #endif
   172| #if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
   173| #  ifndef WIN32
   174| #    define WIN32
   175| #  endif
   176| #endif
   177| #if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
   178| #  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
   179| #    ifndef SYS16BIT
   180| #      define SYS16BIT
   181| #    endif
   182| #  endif
   183| #endif
   184| /*
   185|  * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
   186|  * than 64k bytes at a time (needed on systems with 16-bit int).
   187|  */
   188| #ifdef SYS16BIT
   189| #  define MAXSEG_64K
   190| #endif
   191| #ifdef MSDOS
   192| #  define UNALIGNED_OK
   193| #endif
   194| #ifdef __STDC_VERSION__
   195| #  ifndef STDC
   196| #    define STDC
   197| #  endif
   198| #  if __STDC_VERSION__ >= 199901L
   199| #    ifndef STDC99
   200| #      define STDC99
   201| #    endif
   202| #  endif
   203| #endif
   204| #if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
   205| #  define STDC
   206| #endif
   207| #if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
   208| #  define STDC
   209| #endif
   210| #if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
   211| #  define STDC
   212| #endif
   213| #if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
   214| #  define STDC
   215| #endif
   216| #if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
   217| #  define STDC
   218| #endif
   219| #ifndef STDC
   220| #  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
   221| #    define const       /* note: need a more gentle solution here */
   222| #  endif
   223| #endif
   224| #if defined(ZLIB_CONST) && !defined(z_const)
   225| #  define z_const const
   226| #else
   227| #  define z_const
   228| #endif
   229| #ifdef Z_SOLO
   230|    typedef unsigned long z_size_t;
   231| #else
   232| #  define z_longlong long long
   233| #  if defined(NO_SIZE_T)
   234|      typedef unsigned NO_SIZE_T z_size_t;
   235| #  elif defined(STDC)
   236| #    include <stddef.h>
   237|      typedef size_t z_size_t;
   238| #  else
   239|      typedef unsigned long z_size_t;
   240| #  endif
   241| #  undef z_longlong
   242| #endif
   243| /* Maximum value for memLevel in deflateInit2 */
   244| #ifndef MAX_MEM_LEVEL
   245| #  ifdef MAXSEG_64K
   246| #    define MAX_MEM_LEVEL 8
   247| #  else
   248| #    define MAX_MEM_LEVEL 9
   249| #  endif
   250| #endif
   251| /* Maximum value for windowBits in deflateInit2 and inflateInit2.
   252|  * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
   253|  * created by gzip. (Files created by minigzip can still be extracted by
   254|  * gzip.)
   255|  */
   256| #ifndef MAX_WBITS
   257| #  define MAX_WBITS   15 /* 32K LZ77 window */
   258| #endif
   259| /* The memory requirements for deflate are (in bytes):
   260|             (1 << (windowBits+2)) +  (1 << (memLevel+9))
   261|  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
   262|  plus a few kilobytes for small objects. For example, if you want to reduce
   263|  the default memory requirements from 256K to 128K, compile with
   264|      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
   265|  Of course this will generally degrade compression (there's no free lunch).
   266|    The memory requirements for inflate are (in bytes) 1 << windowBits
   267|  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
   268|  for small objects.
   269| */
   270|                         /* Type declarations */
   271| #ifndef OF /* function prototypes */
   272| #  ifdef STDC
   273| #    define OF(args)  args
   274| #  else
   275| #    define OF(args)  ()
   276| #  endif
   277| #endif
   278| #ifndef Z_ARG /* function prototypes for stdarg */
   279| #  if defined(STDC) || defined(Z_HAVE_STDARG_H)
   280| #    define Z_ARG(args)  args
   281| #  else
   282| #    define Z_ARG(args)  ()
   283| #  endif
   284| #endif
   285| /* The following definitions for FAR are needed only for MSDOS mixed
   286|  * model programming (small or medium model with some far allocations).
   287|  * This was tested only with MSC; for other MSDOS compilers you may have
   288|  * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
   289|  * just define FAR to be empty.
   290|  */
   291| #ifdef SYS16BIT
   292| #  if defined(M_I86SM) || defined(M_I86MM)
   293|      /* MSC small or medium model */
   294| #    define SMALL_MEDIUM
   295| #    ifdef _MSC_VER
   296| #      define FAR _far
   297| #    else
   298| #      define FAR far
   299| #    endif
   300| #  endif
   301| #  if (defined(__SMALL__) || defined(__MEDIUM__))
   302|      /* Turbo C small or medium model */
   303| #    define SMALL_MEDIUM
   304| #    ifdef __BORLANDC__
   305| #      define FAR _far
   306| #    else
   307| #      define FAR far
   308| #    endif
   309| #  endif
   310| #endif
   311| #if defined(WINDOWS) || defined(WIN32)
   312|    /* If building or using zlib as a DLL, define ZLIB_DLL.
   313|     * This is not mandatory, but it offers a little performance increase.
   314|     */
   315| #  ifdef ZLIB_DLL
   316| #    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
   317| #      ifdef ZLIB_INTERNAL
   318| #        define ZEXTERN extern __declspec(dllexport)
   319| #      else
   320| #        define ZEXTERN extern __declspec(dllimport)
   321| #      endif
   322| #    endif
   323| #  endif  /* ZLIB_DLL */
   324|    /* If building or using zlib with the WINAPI/WINAPIV calling convention,
   325|     * define ZLIB_WINAPI.
   326|     * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
   327|     */
   328| #  ifdef ZLIB_WINAPI
   329| #    ifdef FAR
   330| #      undef FAR
   331| #    endif
   332| #    ifndef WIN32_LEAN_AND_MEAN
   333| #      define WIN32_LEAN_AND_MEAN
   334| #    endif
   335| #    include <windows.h>
   336|      /* No need for _export, use ZLIB.DEF instead. */
   337|      /* For complete Windows compatibility, use WINAPI, not __stdcall. */
   338| #    define ZEXPORT WINAPI
   339| #    ifdef WIN32
   340| #      define ZEXPORTVA WINAPIV
   341| #    else
   342| #      define ZEXPORTVA FAR CDECL
   343| #    endif
   344| #  endif
   345| #endif
   346| #if defined (__BEOS__)
   347| #  ifdef ZLIB_DLL
   348| #    ifdef ZLIB_INTERNAL
   349| #      define ZEXPORT   __declspec(dllexport)
   350| #      define ZEXPORTVA __declspec(dllexport)
   351| #    else
   352| #      define ZEXPORT   __declspec(dllimport)
   353| #      define ZEXPORTVA __declspec(dllimport)
   354| #    endif
   355| #  endif
   356| #endif
   357| #ifndef ZEXTERN
   358| #  define ZEXTERN extern
   359| #endif
   360| #ifndef ZEXPORT
   361| #  define ZEXPORT
   362| #endif
   363| #ifndef ZEXPORTVA
   364| #  define ZEXPORTVA
   365| #endif
   366| #ifndef FAR
   367| #  define FAR
   368| #endif
   369| #if !defined(__MACTYPES__)
   370| typedef unsigned char  Byte;  /* 8 bits */
   371| #endif
   372| typedef unsigned int   uInt;  /* 16 bits or more */
   373| typedef unsigned long  uLong; /* 32 bits or more */
   374| #ifdef SMALL_MEDIUM
   375|    /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
   376| #  define Bytef Byte FAR
   377| #else
   378|    typedef Byte  FAR Bytef;
   379| #endif
   380| typedef char  FAR charf;
   381| typedef int   FAR intf;
   382| typedef uInt  FAR uIntf;
   383| typedef uLong FAR uLongf;
   384| #ifdef STDC
   385|    typedef void const *voidpc;
   386|    typedef void FAR   *voidpf;
   387|    typedef void       *voidp;
   388| #else
   389|    typedef Byte const *voidpc;
   390|    typedef Byte FAR   *voidpf;
   391|    typedef Byte       *voidp;
   392| #endif
   393| #if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
   394| #  include <limits.h>
   395| #  if (UINT_MAX == 0xffffffffUL)
   396| #    define Z_U4 unsigned
   397| #  elif (ULONG_MAX == 0xffffffffUL)
   398| #    define Z_U4 unsigned long
   399| #  elif (USHRT_MAX == 0xffffffffUL)
   400| #    define Z_U4 unsigned short
   401| #  endif
   402| #endif
   403| #ifdef Z_U4
   404|    typedef Z_U4 z_crc_t;
   405| #else
   406|    typedef unsigned long z_crc_t;
   407| #endif
   408| #ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
   409| #  define Z_HAVE_UNISTD_H
   410| #endif
   411| #ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
   412| #  define Z_HAVE_STDARG_H
   413| #endif
   414| #ifdef STDC
   415| #  ifndef Z_SOLO
   416| #    include <sys/types.h>      /* for off_t */
   417| #  endif
   418| #endif
   419| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
   420| #  ifndef Z_SOLO
   421| #    include <stdarg.h>         /* for va_list */
   422| #  endif
   423| #endif
   424| #ifdef _WIN32
   425| #  ifndef Z_SOLO
   426| #    include <stddef.h>         /* for wchar_t */
   427| #  endif
   428| #endif
   429| /* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
   430|  * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
   431|  * though the former does not conform to the LFS document), but considering
   432|  * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
   433|  * equivalently requesting no 64-bit operations
   434|  */
   435| #if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
   436| #  undef _LARGEFILE64_SOURCE
   437| #endif
   438| #ifndef Z_HAVE_UNISTD_H
   439| #  ifdef __WATCOMC__
   440| #    define Z_HAVE_UNISTD_H
   441| #  endif
   442| #endif
   443| #ifndef Z_HAVE_UNISTD_H
   444| #  if defined(_LARGEFILE64_SOURCE) && !defined(_WIN32)
   445| #    define Z_HAVE_UNISTD_H
   446| #  endif
   447| #endif
   448| #ifndef Z_SOLO
   449| #  if defined(Z_HAVE_UNISTD_H)
   450| #    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
   451| #    ifdef VMS
   452| #      include <unixio.h>       /* for off_t */
   453| #    endif
   454| #    ifndef z_off_t
   455| #      define z_off_t off_t
   456| #    endif
   457| #  endif
   458| #endif
   459| #if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
   460| #  define Z_LFS64
   461| #endif
   462| #if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
   463| #  define Z_LARGE64
   464| #endif
   465| #if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
   466| #  define Z_WANT64
   467| #endif
   468| #if !defined(SEEK_SET) && !defined(Z_SOLO)
   469| #  define SEEK_SET        0       /* Seek from beginning of file.  */
   470| #  define SEEK_CUR        1       /* Seek from current position.  */
   471| #  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
   472| #endif
   473| #ifndef z_off_t
   474| #  define z_off_t long
   475| #endif
   476| #if !defined(_WIN32) && defined(Z_LARGE64)
   477| #  define z_off64_t off64_t
   478| #else
   479| #  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
   480| #    define z_off64_t __int64
   481| #  else
   482| #    define z_off64_t z_off_t
   483| #  endif
   484| #endif
   485| /* MVS linker does not support external names larger than 8 bytes */
   486| #if defined(__MVS__)
   487|   #pragma map(deflateInit_,"DEIN")
   488|   #pragma map(deflateInit2_,"DEIN2")
   489|   #pragma map(deflateEnd,"DEEND")
   490|   #pragma map(deflateBound,"DEBND")
   491|   #pragma map(inflateInit_,"ININ")
   492|   #pragma map(inflateInit2_,"ININ2")
   493|   #pragma map(inflateEnd,"INEND")
   494|   #pragma map(inflateSync,"INSY")
   495|   #pragma map(inflateSetDictionary,"INSEDI")
   496|   #pragma map(compressBound,"CMBND")
   497|   #pragma map(inflate_table,"INTABL")
   498|   #pragma map(inflate_fast,"INFA")
   499|   #pragma map(inflate_copyright,"INCOPY")
   500| #endif
   501| #endif /* ZCONF_H */


# ====================================================================
# FILE: src/native/external/zlib/zlib.h
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1643 ---
     1| /* zlib.h -- interface of the 'zlib' general purpose compression library
     2|   version 1.2.13, October 13th, 2022
     3|   Copyright (C) 1995-2022 Jean-loup Gailly and Mark Adler
     4|   This software is provided 'as-is', without any express or implied
     5|   warranty.  In no event will the authors be held liable for any damages
     6|   arising from the use of this software.
     7|   Permission is granted to anyone to use this software for any purpose,
     8|   including commercial applications, and to alter it and redistribute it
     9|   freely, subject to the following restrictions:
    10|   1. The origin of this software must not be misrepresented; you must not
    11|      claim that you wrote the original software. If you use this software
    12|      in a product, an acknowledgment in the product documentation would be
    13|      appreciated but is not required.
    14|   2. Altered source versions must be plainly marked as such, and must not be
    15|      misrepresented as being the original software.
    16|   3. This notice may not be removed or altered from any source distribution.
    17|   Jean-loup Gailly        Mark Adler
    18|   jloup@gzip.org          madler@alumni.caltech.edu
    19|   The data format used by the zlib library is described by RFCs (Request for
    20|   Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
    21|   (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
    22| */
    23| #ifndef ZLIB_H
    24| #define ZLIB_H
    25| #include "zconf.h"
    26| #ifdef __cplusplus
    27| extern "C" {
    28| #endif
    29| #define ZLIB_VERSION "1.2.13"
    30| #define ZLIB_VERNUM 0x12d0
    31| #define ZLIB_VER_MAJOR 1
    32| #define ZLIB_VER_MINOR 2
    33| #define ZLIB_VER_REVISION 13
    34| #define ZLIB_VER_SUBREVISION 0
    35| /*
    36|     The 'zlib' compression library provides in-memory compression and
    37|   decompression functions, including integrity checks of the uncompressed data.
    38|   This version of the library supports only one compression method (deflation)
    39|   but other algorithms will be added later and will have the same stream
    40|   interface.
    41|     Compression can be done in a single step if the buffers are large enough,
    42|   or can be done by repeated calls of the compression function.  In the latter
    43|   case, the application must provide more input and/or consume the output
    44|   (providing more output space) before each call.
    45|     The compressed data format used by default by the in-memory functions is
    46|   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
    47|   around a deflate stream, which is itself documented in RFC 1951.
    48|     The library also supports reading and writing files in gzip (.gz) format
    49|   with an interface similar to that of stdio using the functions that start
    50|   with "gz".  The gzip format is different from the zlib format.  gzip is a
    51|   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
    52|     This library can optionally read and write gzip and raw deflate streams in
    53|   memory as well.
    54|     The zlib format was designed to be compact and fast for use in memory
    55|   and on communications channels.  The gzip format was designed for single-
    56|   file compression on file systems, has a larger header than zlib to maintain
    57|   directory information, and uses a different, slower check method than zlib.
    58|     The library does not install any signal handler.  The decoder checks
    59|   the consistency of the compressed data, so the library should never crash
    60|   even in the case of corrupted input.
    61| */
    62| typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
    63| typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
    64| struct internal_state;
    65| typedef struct z_stream_s {
    66|     z_const Bytef *next_in;     /* next input byte */
    67|     uInt     avail_in;  /* number of bytes available at next_in */
    68|     uLong    total_in;  /* total number of input bytes read so far */
    69|     Bytef    *next_out; /* next output byte will go here */
    70|     uInt     avail_out; /* remaining free space at next_out */
    71|     uLong    total_out; /* total number of bytes output so far */
    72|     z_const char *msg;  /* last error message, NULL if no error */
    73|     struct internal_state FAR *state; /* not visible by applications */
    74|     alloc_func zalloc;  /* used to allocate the internal state */
    75|     free_func  zfree;   /* used to free the internal state */
    76|     voidpf     opaque;  /* private data object passed to zalloc and zfree */
    77|     int     data_type;  /* best guess about the data type: binary or text
    78|                            for deflate, or the decoding state for inflate */
    79|     uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
    80|     uLong   reserved;   /* reserved for future use */
    81| } z_stream;
    82| typedef z_stream FAR *z_streamp;
    83| /*
    84|      gzip header information passed to and from zlib routines.  See RFC 1952
    85|   for more details on the meanings of these fields.
    86| */
    87| typedef struct gz_header_s {
    88|     int     text;       /* true if compressed data believed to be text */
    89|     uLong   time;       /* modification time */
    90|     int     xflags;     /* extra flags (not used when writing a gzip file) */
    91|     int     os;         /* operating system */
    92|     Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    93|     uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    94|     uInt    extra_max;  /* space at extra (only when reading header) */
    95|     Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    96|     uInt    name_max;   /* space at name (only when reading header) */
    97|     Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    98|     uInt    comm_max;   /* space at comment (only when reading header) */
    99|     int     hcrc;       /* true if there was or will be a header crc */
   100|     int     done;       /* true when done reading gzip header (not used
   101|                            when writing a gzip file) */
   102| } gz_header;
   103| typedef gz_header FAR *gz_headerp;
   104| /*
   105|      The application must update next_in and avail_in when avail_in has dropped
   106|    to zero.  It must update next_out and avail_out when avail_out has dropped
   107|    to zero.  The application must initialize zalloc, zfree and opaque before
   108|    calling the init function.  All other fields are set by the compression
   109|    library and must not be updated by the application.
   110|      The opaque value provided by the application will be passed as the first
   111|    parameter for calls of zalloc and zfree.  This can be useful for custom
   112|    memory management.  The compression library attaches no meaning to the
   113|    opaque value.
   114|      zalloc must return Z_NULL if there is not enough memory for the object.
   115|    If zlib is used in a multi-threaded application, zalloc and zfree must be
   116|    thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
   117|    Z_NULL on entry to the initialization function, they are set to internal
   118|    routines that use the standard library functions malloc() and free().
   119|      On 16-bit systems, the functions zalloc and zfree must be able to allocate
   120|    exactly 65536 bytes, but will not be required to allocate more than this if
   121|    the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   122|    returned by zalloc for objects of exactly 65536 bytes *must* have their
   123|    offset normalized to zero.  The default allocation function provided by this
   124|    library ensures this (see zutil.c).  To reduce memory requirements and avoid
   125|    any allocation of 64K objects, at the expense of compression ratio, compile
   126|    the library with -DMAX_WBITS=14 (see zconf.h).
   127|      The fields total_in and total_out can be used for statistics or progress
   128|    reports.  After compression, total_in holds the total size of the
   129|    uncompressed data and may be saved for use by the decompressor (particularly
   130|    if the decompressor wants to decompress everything in a single step).
   131| */
   132|                         /* constants */
   133| #define Z_NO_FLUSH      0
   134| #define Z_PARTIAL_FLUSH 1
   135| #define Z_SYNC_FLUSH    2
   136| #define Z_FULL_FLUSH    3
   137| #define Z_FINISH        4
   138| #define Z_BLOCK         5
   139| #define Z_TREES         6
   140| /* Allowed flush values; see deflate() and inflate() below for details */
   141| #define Z_OK            0
   142| #define Z_STREAM_END    1
   143| #define Z_NEED_DICT     2
   144| #define Z_ERRNO        (-1)
   145| #define Z_STREAM_ERROR (-2)
   146| #define Z_DATA_ERROR   (-3)
   147| #define Z_MEM_ERROR    (-4)
   148| #define Z_BUF_ERROR    (-5)
   149| #define Z_VERSION_ERROR (-6)
   150| /* Return codes for the compression/decompression functions. Negative values
   151|  * are errors, positive values are used for special but normal events.
   152|  */
   153| #define Z_NO_COMPRESSION         0
   154| #define Z_BEST_SPEED             1
   155| #define Z_BEST_COMPRESSION       9
   156| #define Z_DEFAULT_COMPRESSION  (-1)
   157| /* compression levels */
   158| #define Z_FILTERED            1
   159| #define Z_HUFFMAN_ONLY        2
   160| #define Z_RLE                 3
   161| #define Z_FIXED               4
   162| #define Z_DEFAULT_STRATEGY    0
   163| /* compression strategy; see deflateInit2() below for details */
   164| #define Z_BINARY   0
   165| #define Z_TEXT     1
   166| #define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
   167| #define Z_UNKNOWN  2
   168| /* Possible values of the data_type field for deflate() */
   169| #define Z_DEFLATED   8
   170| /* The deflate compression method (the only one supported in this version) */
   171| #define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
   172| #define zlib_version zlibVersion()
   173| /* for compatibility with versions < 1.0.2 */
   174|                         /* basic functions */
   175| ZEXTERN const char * ZEXPORT zlibVersion OF((void));
   176| /* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   177|    If the first character differs, the library code actually used is not
   178|    compatible with the zlib.h header file used by the application.  This check
   179|    is automatically made by deflateInit and inflateInit.
   180|  */
   181| /*
   182| ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
   183|      Initializes the internal stream state for compression.  The fields
   184|    zalloc, zfree and opaque must be initialized before by the caller.  If
   185|    zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   186|    allocation functions.
   187|      The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   188|    1 gives best speed, 9 gives best compression, 0 gives no compression at all
   189|    (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   190|    requests a default compromise between speed and compression (currently
   191|    equivalent to level 6).
   192|      deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   193|    memory, Z_STREAM_ERROR if level is not a valid compression level, or
   194|    Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   195|    with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   196|    if there is no error message.  deflateInit does not perform any compression:
   197|    this will be done by deflate().
   198| */
   199| ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
   200| /*
   201|     deflate compresses as much data as possible, and stops when the input
   202|   buffer becomes empty or the output buffer becomes full.  It may introduce
   203|   some output latency (reading input without producing any output) except when
   204|   forced to flush.
   205|     The detailed semantics are as follows.  deflate performs one or both of the
   206|   following actions:
   207|   - Compress more input starting at next_in and update next_in and avail_in
   208|     accordingly.  If not all input can be processed (because there is not
   209|     enough room in the output buffer), next_in and avail_in are updated and
   210|     processing will resume at this point for the next call of deflate().
   211|   - Generate more output starting at next_out and update next_out and avail_out
   212|     accordingly.  This action is forced if the parameter flush is non zero.
   213|     Forcing flush frequently degrades the compression ratio, so this parameter
   214|     should be set only when necessary.  Some output may be provided even if
   215|     flush is zero.
   216|     Before the call of deflate(), the application should ensure that at least
   217|   one of the actions is possible, by providing more input and/or consuming more
   218|   output, and updating avail_in or avail_out accordingly; avail_out should
   219|   never be zero before the call.  The application can consume the compressed
   220|   output when it wants, for example when the output buffer is full (avail_out
   221|   == 0), or after each call of deflate().  If deflate returns Z_OK and with
   222|   zero avail_out, it must be called again after making room in the output
   223|   buffer because there might be more output pending. See deflatePending(),
   224|   which can be used if desired to determine whether or not there is more output
   225|   in that case.
   226|     Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
   227|   decide how much data to accumulate before producing output, in order to
   228|   maximize compression.
   229|     If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
   230|   flushed to the output buffer and the output is aligned on a byte boundary, so
   231|   that the decompressor can get all input data available so far.  (In
   232|   particular avail_in is zero after the call if enough output space has been
   233|   provided before the call.) Flushing may degrade compression for some
   234|   compression algorithms and so it should be used only when necessary.  This
   235|   completes the current deflate block and follows it with an empty stored block
   236|   that is three bits plus filler bits to the next byte, followed by four bytes
   237|   (00 00 ff ff).
   238|     If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
   239|   output buffer, but the output is not aligned to a byte boundary.  All of the
   240|   input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
   241|   This completes the current deflate block and follows it with an empty fixed
   242|   codes block that is 10 bits long.  This assures that enough bytes are output
   243|   in order for the decompressor to finish the block before the empty fixed
   244|   codes block.
   245|     If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
   246|   for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
   247|   seven bits of the current block are held to be written as the next byte after
   248|   the next deflate block is completed.  In this case, the decompressor may not
   249|   be provided enough bits at this point in order to complete decompression of
   250|   the data provided so far to the compressor.  It may need to wait for the next
   251|   block to be emitted.  This is for advanced applications that need to control
   252|   the emission of deflate blocks.
   253|     If flush is set to Z_FULL_FLUSH, all output is flushed as with
   254|   Z_SYNC_FLUSH, and the compression state is reset so that decompression can
   255|   restart from this point if previous compressed data has been damaged or if
   256|   random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
   257|   compression.
   258|     If deflate returns with avail_out == 0, this function must be called again
   259|   with the same value of the flush parameter and more output space (updated
   260|   avail_out), until the flush is complete (deflate returns with non-zero
   261|   avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
   262|   avail_out is greater than six to avoid repeated flush markers due to
   263|   avail_out == 0 on return.
   264|     If the parameter flush is set to Z_FINISH, pending input is processed,
   265|   pending output is flushed and deflate returns with Z_STREAM_END if there was
   266|   enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
   267|   function must be called again with Z_FINISH and more output space (updated
   268|   avail_out) but no more input data, until it returns with Z_STREAM_END or an
   269|   error.  After deflate has returned Z_STREAM_END, the only possible operations
   270|   on the stream are deflateReset or deflateEnd.
   271|     Z_FINISH can be used in the first deflate call after deflateInit if all the
   272|   compression is to be done in a single step.  In order to complete in one
   273|   call, avail_out must be at least the value returned by deflateBound (see
   274|   below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
   275|   output space is provided, deflate will not return Z_STREAM_END, and it must
   276|   be called again as described above.
   277|     deflate() sets strm->adler to the Adler-32 checksum of all input read
   278|   so far (that is, total_in bytes).  If a gzip stream is being generated, then
   279|   strm->adler will be the CRC-32 checksum of the input read so far.  (See
   280|   deflateInit2 below.)
   281|     deflate() may update strm->data_type if it can make a good guess about
   282|   the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
   283|   considered binary.  This field is only for information purposes and does not
   284|   affect the compression algorithm in any manner.
   285|     deflate() returns Z_OK if some progress has been made (more input
   286|   processed or more output produced), Z_STREAM_END if all input has been
   287|   consumed and all output has been produced (only when flush is set to
   288|   Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
   289|   if next_in or next_out was Z_NULL or the state was inadvertently written over
   290|   by the application), or Z_BUF_ERROR if no progress is possible (for example
   291|   avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
   292|   deflate() can be called again with more input and more output space to
   293|   continue compressing.
   294| */
   295| ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
   296| /*
   297|      All dynamically allocated data structures for this stream are freed.
   298|    This function discards any unprocessed input and does not flush any pending
   299|    output.
   300|      deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   301|    stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   302|    prematurely (some input or output was discarded).  In the error case, msg
   303|    may be set but then points to a static string (which must not be
   304|    deallocated).
   305| */
   306| /*
   307| ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
   308|      Initializes the internal stream state for decompression.  The fields
   309|    next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   310|    the caller.  In the current version of inflate, the provided input is not
   311|    read or consumed.  The allocation of a sliding window will be deferred to
   312|    the first call of inflate (if the decompression does not complete on the
   313|    first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
   314|    them to use default allocation functions.
   315|      inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   316|    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   317|    version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   318|    invalid, such as a null pointer to the structure.  msg is set to null if
   319|    there is no error message.  inflateInit does not perform any decompression.
   320|    Actual decompression will be done by inflate().  So next_in, and avail_in,
   321|    next_out, and avail_out are unused and unchanged.  The current
   322|    implementation of inflateInit() does not process any header information --
   323|    that is deferred until inflate() is called.
   324| */
   325| ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
   326| /*
   327|     inflate decompresses as much data as possible, and stops when the input
   328|   buffer becomes empty or the output buffer becomes full.  It may introduce
   329|   some output latency (reading input without producing any output) except when
   330|   forced to flush.
   331|   The detailed semantics are as follows.  inflate performs one or both of the
   332|   following actions:
   333|   - Decompress more input starting at next_in and update next_in and avail_in
   334|     accordingly.  If not all input can be processed (because there is not
   335|     enough room in the output buffer), then next_in and avail_in are updated
   336|     accordingly, and processing will resume at this point for the next call of
   337|     inflate().
   338|   - Generate more output starting at next_out and update next_out and avail_out
   339|     accordingly.  inflate() provides as much output as possible, until there is
   340|     no more input data or no more space in the output buffer (see below about
   341|     the flush parameter).
   342|     Before the call of inflate(), the application should ensure that at least
   343|   one of the actions is possible, by providing more input and/or consuming more
   344|   output, and updating the next_* and avail_* values accordingly.  If the
   345|   caller of inflate() does not provide both available input and available
   346|   output space, it is possible that there will be no progress made.  The
   347|   application can consume the uncompressed output when it wants, for example
   348|   when the output buffer is full (avail_out == 0), or after each call of
   349|   inflate().  If inflate returns Z_OK and with zero avail_out, it must be
   350|   called again after making room in the output buffer because there might be
   351|   more output pending.
   352|     The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
   353|   Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
   354|   output as possible to the output buffer.  Z_BLOCK requests that inflate()
   355|   stop if and when it gets to the next deflate block boundary.  When decoding
   356|   the zlib or gzip format, this will cause inflate() to return immediately
   357|   after the header and before the first block.  When doing a raw inflate,
   358|   inflate() will go ahead and process the first block, and will return when it
   359|   gets to the end of that block, or when it runs out of data.
   360|     The Z_BLOCK option assists in appending to or combining deflate streams.
   361|   To assist in this, on return inflate() always sets strm->data_type to the
   362|   number of unused bits in the last byte taken from strm->next_in, plus 64 if
   363|   inflate() is currently decoding the last block in the deflate stream, plus
   364|   128 if inflate() returned immediately after decoding an end-of-block code or
   365|   decoding the complete header up to just before the first byte of the deflate
   366|   stream.  The end-of-block will not be indicated until all of the uncompressed
   367|   data from that block has been written to strm->next_out.  The number of
   368|   unused bits may in general be greater than seven, except when bit 7 of
   369|   data_type is set, in which case the number of unused bits will be less than
   370|   eight.  data_type is set as noted here every time inflate() returns for all
   371|   flush options, and so can be used to determine the amount of currently
   372|   consumed input in bits.
   373|     The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
   374|   end of each deflate block header is reached, before any actual data in that
   375|   block is decoded.  This allows the caller to determine the length of the
   376|   deflate block header for later use in random access within a deflate block.
   377|   256 is added to the value of strm->data_type when inflate() returns
   378|   immediately after reaching the end of the deflate block header.
   379|     inflate() should normally be called until it returns Z_STREAM_END or an
   380|   error.  However if all decompression is to be performed in a single step (a
   381|   single call of inflate), the parameter flush should be set to Z_FINISH.  In
   382|   this case all pending input is processed and all pending output is flushed;
   383|   avail_out must be large enough to hold all of the uncompressed data for the
   384|   operation to complete.  (The size of the uncompressed data may have been
   385|   saved by the compressor for this purpose.)  The use of Z_FINISH is not
   386|   required to perform an inflation in one step.  However it may be used to
   387|   inform inflate that a faster approach can be used for the single inflate()
   388|   call.  Z_FINISH also informs inflate to not maintain a sliding window if the
   389|   stream completes, which reduces inflate's memory footprint.  If the stream
   390|   does not complete, either because not all of the stream is provided or not
   391|   enough output space is provided, then a sliding window will be allocated and
   392|   inflate() can be called again to continue the operation as if Z_NO_FLUSH had
   393|   been used.
   394|      In this implementation, inflate() always flushes as much output as
   395|   possible to the output buffer, and always uses the faster approach on the
   396|   first call.  So the effects of the flush parameter in this implementation are
   397|   on the return value of inflate() as noted below, when inflate() returns early
   398|   when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
   399|   memory for a sliding window when Z_FINISH is used.
   400|      If a preset dictionary is needed after this call (see inflateSetDictionary
   401|   below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
   402|   chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
   403|   strm->adler to the Adler-32 checksum of all output produced so far (that is,
   404|   total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
   405|   below.  At the end of the stream, inflate() checks that its computed Adler-32
   406|   checksum is equal to that saved by the compressor and returns Z_STREAM_END
   407|   only if the checksum is correct.
   408|     inflate() can decompress and check either zlib-wrapped or gzip-wrapped
   409|   deflate data.  The header type is detected automatically, if requested when
   410|   initializing with inflateInit2().  Any information contained in the gzip
   411|   header is not retained unless inflateGetHeader() is used.  When processing
   412|   gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
   413|   produced so far.  The CRC-32 is checked against the gzip trailer, as is the
   414|   uncompressed length, modulo 2^32.
   415|     inflate() returns Z_OK if some progress has been made (more input processed
   416|   or more output produced), Z_STREAM_END if the end of the compressed data has
   417|   been reached and all uncompressed output has been produced, Z_NEED_DICT if a
   418|   preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
   419|   corrupted (input stream not conforming to the zlib format or incorrect check
   420|   value, in which case strm->msg points to a string with a more specific
   421|   error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
   422|   next_in or next_out was Z_NULL, or the state was inadvertently written over
   423|   by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
   424|   if no progress was possible or if there was not enough room in the output
   425|   buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
   426|   inflate() can be called again with more input and more output space to
   427|   continue decompressing.  If Z_DATA_ERROR is returned, the application may
   428|   then call inflateSync() to look for a good compression block if a partial
   429|   recovery of the data is to be attempted.
   430| */
   431| ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
   432| /*
   433|      All dynamically allocated data structures for this stream are freed.
   434|    This function discards any unprocessed input and does not flush any pending
   435|    output.
   436|      inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
   437|    was inconsistent.
   438| */
   439|                         /* Advanced functions */
   440| /*
   441|     The following functions are needed only in some special applications.
   442| */
   443| /*
   444| ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
   445|                                      int  level,
   446|                                      int  method,
   447|                                      int  windowBits,
   448|                                      int  memLevel,
   449|                                      int  strategy));
   450|      This is another version of deflateInit with more compression options.  The
   451|    fields zalloc, zfree and opaque must be initialized before by the caller.
   452|      The method parameter is the compression method.  It must be Z_DEFLATED in
   453|    this version of the library.
   454|      The windowBits parameter is the base two logarithm of the window size
   455|    (the size of the history buffer).  It should be in the range 8..15 for this
   456|    version of the library.  Larger values of this parameter result in better
   457|    compression at the expense of memory usage.  The default value is 15 if
   458|    deflateInit is used instead.
   459|      For the current implementation of deflate(), a windowBits value of 8 (a
   460|    window size of 256 bytes) is not supported.  As a result, a request for 8
   461|    will result in 9 (a 512-byte window).  In that case, providing 8 to
   462|    inflateInit2() will result in an error when the zlib header with 9 is
   463|    checked against the initialization of inflate().  The remedy is to not use 8
   464|    with deflateInit2() with this initialization, or at least in that case use 9
   465|    with inflateInit2().
   466|      windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   467|    determines the window size.  deflate() will then generate raw deflate data
   468|    with no zlib header or trailer, and will not compute a check value.
   469|      windowBits can also be greater than 15 for optional gzip encoding.  Add
   470|    16 to windowBits to write a simple gzip header and trailer around the
   471|    compressed data instead of a zlib wrapper.  The gzip header will have no
   472|    file name, no extra data, no comment, no modification time (set to zero), no
   473|    header crc, and the operating system will be set to the appropriate value,
   474|    if the operating system was determined at compile time.  If a gzip stream is
   475|    being written, strm->adler is a CRC-32 instead of an Adler-32.
   476|      For raw deflate or gzip encoding, a request for a 256-byte window is
   477|    rejected as invalid, since only the zlib header provides a means of
   478|    transmitting the window size to the decompressor.
   479|      The memLevel parameter specifies how much memory should be allocated
   480|    for the internal compression state.  memLevel=1 uses minimum memory but is
   481|    slow and reduces compression ratio; memLevel=9 uses maximum memory for
   482|    optimal speed.  The default value is 8.  See zconf.h for total memory usage
   483|    as a function of windowBits and memLevel.
   484|      The strategy parameter is used to tune the compression algorithm.  Use the
   485|    value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   486|    filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   487|    string match), or Z_RLE to limit match distances to one (run-length
   488|    encoding).  Filtered data consists mostly of small values with a somewhat
   489|    random distribution.  In this case, the compression algorithm is tuned to
   490|    compress them better.  The effect of Z_FILTERED is to force more Huffman
   491|    coding and less string matching; it is somewhat intermediate between
   492|    Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   493|    fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   494|    strategy parameter only affects the compression ratio but not the
   495|    correctness of the compressed output even if it is not set appropriately.
   496|    Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   497|    decoder for special applications.
   498|      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   499|    memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   500|    method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   501|    incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   502|    set to null if there is no error message.  deflateInit2 does not perform any
   503|    compression: this will be done by deflate().
   504| */
   505| ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
   506|                                              const Bytef *dictionary,
   507|                                              uInt  dictLength));
   508| /*
   509|      Initializes the compression dictionary from the given byte sequence
   510|    without producing any compressed output.  When using the zlib format, this
   511|    function must be called immediately after deflateInit, deflateInit2 or
   512|    deflateReset, and before any call of deflate.  When doing raw deflate, this
   513|    function must be called either before any call of deflate, or immediately
   514|    after the completion of a deflate block, i.e. after all input has been
   515|    consumed and all output has been delivered when using any of the flush
   516|    options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   517|    compressor and decompressor must use exactly the same dictionary (see
   518|    inflateSetDictionary).
   519|      The dictionary should consist of strings (byte sequences) that are likely
   520|    to be encountered later in the data to be compressed, with the most commonly
   521|    used strings preferably put towards the end of the dictionary.  Using a
   522|    dictionary is most useful when the data to be compressed is short and can be
   523|    predicted with good accuracy; the data can then be compressed better than
   524|    with the default empty dictionary.
   525|      Depending on the size of the compression data structures selected by
   526|    deflateInit or deflateInit2, a part of the dictionary may in effect be
   527|    discarded, for example if the dictionary is larger than the window size
   528|    provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   529|    useful should be put at the end of the dictionary, not at the front.  In
   530|    addition, the current implementation of deflate will use at most the window
   531|    size minus 262 bytes of the provided dictionary.
   532|      Upon return of this function, strm->adler is set to the Adler-32 value
   533|    of the dictionary; the decompressor may later use this value to determine
   534|    which dictionary has been used by the compressor.  (The Adler-32 value
   535|    applies to the whole dictionary even if only a subset of the dictionary is
   536|    actually used by the compressor.) If a raw deflate was requested, then the
   537|    Adler-32 value is not computed and strm->adler is not set.
   538|      deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   539|    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   540|    inconsistent (for example if deflate has already been called for this stream
   541|    or if not at a block boundary for raw deflate).  deflateSetDictionary does
   542|    not perform any compression: this will be done by deflate().
   543| */
   544| ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
   545|                                              Bytef *dictionary,
   546|                                              uInt  *dictLength));
   547| /*
   548|      Returns the sliding dictionary being maintained by deflate.  dictLength is
   549|    set to the number of bytes in the dictionary, and that many bytes are copied
   550|    to dictionary.  dictionary must have enough space, where 32768 bytes is
   551|    always enough.  If deflateGetDictionary() is called with dictionary equal to
   552|    Z_NULL, then only the dictionary length is returned, and nothing is copied.
   553|    Similarly, if dictLength is Z_NULL, then it is not set.
   554|      deflateGetDictionary() may return a length less than the window size, even
   555|    when more than the window size in input has been provided. It may return up
   556|    to 258 bytes less in that case, due to how zlib's implementation of deflate
   557|    manages the sliding window and lookahead for matches, where matches can be
   558|    up to 258 bytes long. If the application needs the last window-size bytes of
   559|    input, then that would need to be saved by the application outside of zlib.
   560|      deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   561|    stream state is inconsistent.
   562| */
   563| ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
   564|                                     z_streamp source));
   565| /*
   566|      Sets the destination stream as a complete copy of the source stream.
   567|      This function can be useful when several compression strategies will be
   568|    tried, for example when there are several ways of pre-processing the input
   569|    data with a filter.  The streams that will be discarded should then be freed
   570|    by calling deflateEnd.  Note that deflateCopy duplicates the internal
   571|    compression state which can be quite large, so this strategy is slow and can
   572|    consume lots of memory.
   573|      deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   574|    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   575|    (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   576|    destination.
   577| */
   578| ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
   579| /*
   580|      This function is equivalent to deflateEnd followed by deflateInit, but
   581|    does not free and reallocate the internal compression state.  The stream
   582|    will leave the compression level and any other attributes that may have been
   583|    set unchanged.
   584|      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   585|    stream state was inconsistent (such as zalloc or state being Z_NULL).
   586| */
   587| ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
   588|                                       int level,
   589|                                       int strategy));
   590| /*
   591|      Dynamically update the compression level and compression strategy.  The
   592|    interpretation of level and strategy is as in deflateInit2().  This can be
   593|    used to switch between compression and straight copy of the input data, or
   594|    to switch to a different kind of input data requiring a different strategy.
   595|    If the compression approach (which is a function of the level) or the
   596|    strategy is changed, and if there have been any deflate() calls since the
   597|    state was initialized or reset, then the input available so far is
   598|    compressed with the old level and strategy using deflate(strm, Z_BLOCK).
   599|    There are three approaches for the compression levels 0, 1..3, and 4..9
   600|    respectively.  The new level and strategy will take effect at the next call
   601|    of deflate().
   602|      If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
   603|    not have enough output space to complete, then the parameter change will not
   604|    take effect.  In this case, deflateParams() can be called again with the
   605|    same parameters and more output space to try again.
   606|      In order to assure a change in the parameters on the first try, the
   607|    deflate stream should be flushed using deflate() with Z_BLOCK or other flush
   608|    request until strm.avail_out is not zero, before calling deflateParams().
   609|    Then no more input data should be provided before the deflateParams() call.
   610|    If this is done, the old level and strategy will be applied to the data
   611|    compressed before deflateParams(), and the new level and strategy will be
   612|    applied to the the data compressed after deflateParams().
   613|      deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
   614|    state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
   615|    there was not enough output space to complete the compression of the
   616|    available input data before a change in the strategy or approach.  Note that
   617|    in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
   618|    value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
   619|    retried with more output space.
   620| */
   621| ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
   622|                                     int good_length,
   623|                                     int max_lazy,
   624|                                     int nice_length,
   625|                                     int max_chain));
   626| /*
   627|      Fine tune deflate's internal compression parameters.  This should only be
   628|    used by someone who understands the algorithm used by zlib's deflate for
   629|    searching for the best matching string, and even then only by the most
   630|    fanatic optimizer trying to squeeze out the last compressed bit for their
   631|    specific input data.  Read the deflate.c source code for the meaning of the
   632|    max_lazy, good_length, nice_length, and max_chain parameters.
   633|      deflateTune() can be called after deflateInit() or deflateInit2(), and
   634|    returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
   635|  */
   636| ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
   637|                                        uLong sourceLen));
   638| /*
   639|      deflateBound() returns an upper bound on the compressed size after
   640|    deflation of sourceLen bytes.  It must be called after deflateInit() or
   641|    deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   642|    to allocate an output buffer for deflation in a single pass, and so would be
   643|    called before deflate().  If that first deflate() call is provided the
   644|    sourceLen input bytes, an output buffer allocated to the size returned by
   645|    deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   646|    to return Z_STREAM_END.  Note that it is possible for the compressed size to
   647|    be larger than the value returned by deflateBound() if flush options other
   648|    than Z_FINISH or Z_NO_FLUSH are used.
   649| */
   650| ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
   651|                                        unsigned *pending,
   652|                                        int *bits));
   653| /*
   654|      deflatePending() returns the number of bytes and bits of output that have
   655|    been generated, but not yet provided in the available output.  The bytes not
   656|    provided would be due to the available output space having being consumed.
   657|    The number of bits of output not provided are between 0 and 7, where they
   658|    await more bits to join them in order to fill out a full byte.  If pending
   659|    or bits are Z_NULL, then those values are not set.
   660|      deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   661|    stream state was inconsistent.
   662|  */
   663| ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
   664|                                      int bits,
   665|                                      int value));
   666| /*
   667|      deflatePrime() inserts bits in the deflate output stream.  The intent
   668|    is that this function is used to start off the deflate output with the bits
   669|    leftover from a previous deflate stream when appending to it.  As such, this
   670|    function can only be used for raw deflate, and must be used before the first
   671|    deflate() call after a deflateInit2() or deflateReset().  bits must be less
   672|    than or equal to 16, and that many of the least significant bits of value
   673|    will be inserted in the output.
   674|      deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   675|    room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   676|    source stream state was inconsistent.
   677| */
   678| ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
   679|                                          gz_headerp head));
   680| /*
   681|      deflateSetHeader() provides gzip header information for when a gzip
   682|    stream is requested by deflateInit2().  deflateSetHeader() may be called
   683|    after deflateInit2() or deflateReset() and before the first call of
   684|    deflate().  The text, time, os, extra field, name, and comment information
   685|    in the provided gz_header structure are written to the gzip header (xflag is
   686|    ignored -- the extra flags are set according to the compression level).  The
   687|    caller must assure that, if not Z_NULL, name and comment are terminated with
   688|    a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   689|    available there.  If hcrc is true, a gzip header crc is included.  Note that
   690|    the current versions of the command-line version of gzip (up through version
   691|    1.3.x) do not support header crc's, and will report that it is a "multi-part
   692|    gzip file" and give up.
   693|      If deflateSetHeader is not used, the default gzip header has text false,
   694|    the time set to zero, and os set to 255, with no extra, name, or comment
   695|    fields.  The gzip header is returned to the default state by deflateReset().
   696|      deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   697|    stream state was inconsistent.
   698| */
   699| /*
   700| ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
   701|                                      int  windowBits));
   702|      This is another version of inflateInit with an extra parameter.  The
   703|    fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   704|    before by the caller.
   705|      The windowBits parameter is the base two logarithm of the maximum window
   706|    size (the size of the history buffer).  It should be in the range 8..15 for
   707|    this version of the library.  The default value is 15 if inflateInit is used
   708|    instead.  windowBits must be greater than or equal to the windowBits value
   709|    provided to deflateInit2() while compressing, or it must be equal to 15 if
   710|    deflateInit2() was not used.  If a compressed stream with a larger window
   711|    size is given as input, inflate() will return with the error code
   712|    Z_DATA_ERROR instead of trying to allocate a larger window.
   713|      windowBits can also be zero to request that inflate use the window size in
   714|    the zlib header of the compressed stream.
   715|      windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   716|    determines the window size.  inflate() will then process raw deflate data,
   717|    not looking for a zlib or gzip header, not generating a check value, and not
   718|    looking for any check values for comparison at the end of the stream.  This
   719|    is for use with other formats that use the deflate compressed data format
   720|    such as zip.  Those formats provide their own check values.  If a custom
   721|    format is developed using the raw deflate format for compressed data, it is
   722|    recommended that a check value such as an Adler-32 or a CRC-32 be applied to
   723|    the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   724|    most applications, the zlib format should be used as is.  Note that comments
   725|    above on the use in deflateInit2() applies to the magnitude of windowBits.
   726|      windowBits can also be greater than 15 for optional gzip decoding.  Add
   727|    32 to windowBits to enable zlib and gzip decoding with automatic header
   728|    detection, or add 16 to decode only the gzip format (the zlib format will
   729|    return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   730|    CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
   731|    below), inflate() will *not* automatically decode concatenated gzip members.
   732|    inflate() will return Z_STREAM_END at the end of the gzip member.  The state
   733|    would need to be reset to continue decoding a subsequent gzip member.  This
   734|    *must* be done if there is more data after a gzip member, in order for the
   735|    decompression to be compliant with the gzip standard (RFC 1952).
   736|      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   737|    memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   738|    version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   739|    invalid, such as a null pointer to the structure.  msg is set to null if
   740|    there is no error message.  inflateInit2 does not perform any decompression
   741|    apart from possibly reading the zlib header if present: actual decompression
   742|    will be done by inflate().  (So next_in and avail_in may be modified, but
   743|    next_out and avail_out are unused and unchanged.) The current implementation
   744|    of inflateInit2() does not process any header information -- that is
   745|    deferred until inflate() is called.
   746| */
   747| ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
   748|                                              const Bytef *dictionary,
   749|                                              uInt  dictLength));
   750| /*
   751|      Initializes the decompression dictionary from the given uncompressed byte
   752|    sequence.  This function must be called immediately after a call of inflate,
   753|    if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   754|    can be determined from the Adler-32 value returned by that call of inflate.
   755|    The compressor and decompressor must use exactly the same dictionary (see
   756|    deflateSetDictionary).  For raw inflate, this function can be called at any
   757|    time to set the dictionary.  If the provided dictionary is smaller than the
   758|    window and there is already data in the window, then the provided dictionary
   759|    will amend what's there.  The application must insure that the dictionary
   760|    that was used for compression is provided.
   761|      inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   762|    parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   763|    inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   764|    expected one (incorrect Adler-32 value).  inflateSetDictionary does not
   765|    perform any decompression: this will be done by subsequent calls of
   766|    inflate().
   767| */
   768| ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
   769|                                              Bytef *dictionary,
   770|                                              uInt  *dictLength));
   771| /*
   772|      Returns the sliding dictionary being maintained by inflate.  dictLength is
   773|    set to the number of bytes in the dictionary, and that many bytes are copied
   774|    to dictionary.  dictionary must have enough space, where 32768 bytes is
   775|    always enough.  If inflateGetDictionary() is called with dictionary equal to
   776|    Z_NULL, then only the dictionary length is returned, and nothing is copied.
   777|    Similarly, if dictLength is Z_NULL, then it is not set.
   778|      inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   779|    stream state is inconsistent.
   780| */
   781| ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
   782| /*
   783|      Skips invalid compressed data until a possible full flush point (see above
   784|    for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   785|    available input is skipped.  No output is provided.
   786|      inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   787|    All full flush points have this pattern, but not all occurrences of this
   788|    pattern are full flush points.
   789|      inflateSync returns Z_OK if a possible full flush point has been found,
   790|    Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   791|    has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   792|    In the success case, the application may save the current current value of
   793|    total_in which indicates where valid compressed data was found.  In the
   794|    error case, the application may repeatedly call inflateSync, providing more
   795|    input each time, until success or end of the input data.
   796| */
   797| ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
   798|                                     z_streamp source));
   799| /*
   800|      Sets the destination stream as a complete copy of the source stream.
   801|      This function can be useful when randomly accessing a large stream.  The
   802|    first pass through the stream can periodically record the inflate state,
   803|    allowing restarting inflate at those points when randomly accessing the
   804|    stream.
   805|      inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   806|    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   807|    (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   808|    destination.
   809| */
   810| ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
   811| /*
   812|      This function is equivalent to inflateEnd followed by inflateInit,
   813|    but does not free and reallocate the internal decompression state.  The
   814|    stream will keep attributes that may have been set by inflateInit2.
   815|      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   816|    stream state was inconsistent (such as zalloc or state being Z_NULL).
   817| */
   818| ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
   819|                                       int windowBits));
   820| /*
   821|      This function is the same as inflateReset, but it also permits changing
   822|    the wrap and window size requests.  The windowBits parameter is interpreted
   823|    the same as it is for inflateInit2.  If the window size is changed, then the
   824|    memory allocated for the window is freed, and the window will be reallocated
   825|    by inflate() if needed.
   826|      inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   827|    stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   828|    the windowBits parameter is invalid.
   829| */
   830| ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
   831|                                      int bits,
   832|                                      int value));
   833| /*
   834|      This function inserts bits in the inflate input stream.  The intent is
   835|    that this function is used to start inflating at a bit position in the
   836|    middle of a byte.  The provided bits will be used before any bytes are used
   837|    from next_in.  This function should only be used with raw inflate, and
   838|    should be used before the first inflate() call after inflateInit2() or
   839|    inflateReset().  bits must be less than or equal to 16, and that many of the
   840|    least significant bits of value will be inserted in the input.
   841|      If bits is negative, then the input stream bit buffer is emptied.  Then
   842|    inflatePrime() can be called again to put bits in the buffer.  This is used
   843|    to clear out bits leftover after feeding inflate a block description prior
   844|    to feeding inflate codes.
   845|      inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   846|    stream state was inconsistent.
   847| */
   848| ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
   849| /*
   850|      This function returns two values, one in the lower 16 bits of the return
   851|    value, and the other in the remaining upper bits, obtained by shifting the
   852|    return value down 16 bits.  If the upper value is -1 and the lower value is
   853|    zero, then inflate() is currently decoding information outside of a block.
   854|    If the upper value is -1 and the lower value is non-zero, then inflate is in
   855|    the middle of a stored block, with the lower value equaling the number of
   856|    bytes from the input remaining to copy.  If the upper value is not -1, then
   857|    it is the number of bits back from the current bit position in the input of
   858|    the code (literal or length/distance pair) currently being processed.  In
   859|    that case the lower value is the number of bytes already emitted for that
   860|    code.
   861|      A code is being processed if inflate is waiting for more input to complete
   862|    decoding of the code, or if it has completed decoding but is waiting for
   863|    more output space to write the literal or match data.
   864|      inflateMark() is used to mark locations in the input data for random
   865|    access, which may be at bit positions, and to note those cases where the
   866|    output of a code may span boundaries of random access blocks.  The current
   867|    location in the input stream can be determined from avail_in and data_type
   868|    as noted in the description for the Z_BLOCK flush parameter for inflate.
   869|      inflateMark returns the value noted above, or -65536 if the provided
   870|    source stream state was inconsistent.
   871| */
   872| ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
   873|                                          gz_headerp head));
   874| /*
   875|      inflateGetHeader() requests that gzip header information be stored in the
   876|    provided gz_header structure.  inflateGetHeader() may be called after
   877|    inflateInit2() or inflateReset(), and before the first call of inflate().
   878|    As inflate() processes the gzip stream, head->done is zero until the header
   879|    is completed, at which time head->done is set to one.  If a zlib stream is
   880|    being decoded, then head->done is set to -1 to indicate that there will be
   881|    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   882|    used to force inflate() to return immediately after header processing is
   883|    complete and before any actual data is decompressed.
   884|      The text, time, xflags, and os fields are filled in with the gzip header
   885|    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   886|    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   887|    contains the maximum number of bytes to write to extra.  Once done is true,
   888|    extra_len contains the actual extra field length, and extra contains the
   889|    extra field, or that field truncated if extra_max is less than extra_len.
   890|    If name is not Z_NULL, then up to name_max characters are written there,
   891|    terminated with a zero unless the length is greater than name_max.  If
   892|    comment is not Z_NULL, then up to comm_max characters are written there,
   893|    terminated with a zero unless the length is greater than comm_max.  When any
   894|    of extra, name, or comment are not Z_NULL and the respective field is not
   895|    present in the header, then that field is set to Z_NULL to signal its
   896|    absence.  This allows the use of deflateSetHeader() with the returned
   897|    structure to duplicate the header.  However if those fields are set to
   898|    allocated memory, then the application will need to save those pointers
   899|    elsewhere so that they can be eventually freed.
   900|      If inflateGetHeader is not used, then the header information is simply
   901|    discarded.  The header is always checked for validity, including the header
   902|    CRC if present.  inflateReset() will reset the process to discard the header
   903|    information.  The application would need to call inflateGetHeader() again to
   904|    retrieve the header from the next gzip stream.
   905|      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   906|    stream state was inconsistent.
   907| */
   908| /*
   909| ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
   910|                                         unsigned char FAR *window));
   911|      Initialize the internal stream state for decompression using inflateBack()
   912|    calls.  The fields zalloc, zfree and opaque in strm must be initialized
   913|    before the call.  If zalloc and zfree are Z_NULL, then the default library-
   914|    derived memory allocation routines are used.  windowBits is the base two
   915|    logarithm of the window size, in the range 8..15.  window is a caller
   916|    supplied buffer of that size.  Except for special applications where it is
   917|    assured that deflate was used with small window sizes, windowBits must be 15
   918|    and a 32K byte window must be supplied to be able to decompress general
   919|    deflate streams.
   920|      See inflateBack() for the usage of these routines.
   921|      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   922|    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   923|    allocated, or Z_VERSION_ERROR if the version of the library does not match
   924|    the version of the header file.
   925| */
   926| typedef unsigned (*in_func) OF((void FAR *,
   927|                                 z_const unsigned char FAR * FAR *));
   928| typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
   929| ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
   930|                                     in_func in, void FAR *in_desc,
   931|                                     out_func out, void FAR *out_desc));
   932| /*
   933|      inflateBack() does a raw inflate with a single call using a call-back
   934|    interface for input and output.  This is potentially more efficient than
   935|    inflate() for file i/o applications, in that it avoids copying between the
   936|    output and the sliding window by simply making the window itself the output
   937|    buffer.  inflate() can be faster on modern CPUs when used with large
   938|    buffers.  inflateBack() trusts the application to not change the output
   939|    buffer passed by the output function, at least until inflateBack() returns.
   940|      inflateBackInit() must be called first to allocate the internal state
   941|    and to initialize the state with the user-provided window buffer.
   942|    inflateBack() may then be used multiple times to inflate a complete, raw
   943|    deflate stream with each call.  inflateBackEnd() is then called to free the
   944|    allocated state.
   945|      A raw deflate stream is one with no zlib or gzip header or trailer.
   946|    This routine would normally be used in a utility that reads zip or gzip
   947|    files and writes out uncompressed files.  The utility would decode the
   948|    header and process the trailer on its own, hence this routine expects only
   949|    the raw deflate stream to decompress.  This is different from the default
   950|    behavior of inflate(), which expects a zlib header and trailer around the
   951|    deflate stream.
   952|      inflateBack() uses two subroutines supplied by the caller that are then
   953|    called by inflateBack() for input and output.  inflateBack() calls those
   954|    routines until it reads a complete deflate stream and writes out all of the
   955|    uncompressed data, or until it encounters an error.  The function's
   956|    parameters and return types are defined above in the in_func and out_func
   957|    typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   958|    number of bytes of provided input, and a pointer to that input in buf.  If
   959|    there is no input available, in() must return zero -- buf is ignored in that
   960|    case -- and inflateBack() will return a buffer error.  inflateBack() will
   961|    call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
   962|    out() should return zero on success, or non-zero on failure.  If out()
   963|    returns non-zero, inflateBack() will return with an error.  Neither in() nor
   964|    out() are permitted to change the contents of the window provided to
   965|    inflateBackInit(), which is also the buffer that out() uses to write from.
   966|    The length written by out() will be at most the window size.  Any non-zero
   967|    amount of input may be provided by in().
   968|      For convenience, inflateBack() can be provided input on the first call by
   969|    setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   970|    in() will be called.  Therefore strm->next_in must be initialized before
   971|    calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   972|    immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   973|    must also be initialized, and then if strm->avail_in is not zero, input will
   974|    initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
   975|      The in_desc and out_desc parameters of inflateBack() is passed as the
   976|    first parameter of in() and out() respectively when they are called.  These
   977|    descriptors can be optionally used to pass any information that the caller-
   978|    supplied in() and out() functions need to do their job.
   979|      On return, inflateBack() will set strm->next_in and strm->avail_in to
   980|    pass back any unused input that was provided by the last in() call.  The
   981|    return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   982|    if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   983|    in the deflate stream (in which case strm->msg is set to indicate the nature
   984|    of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   985|    In the case of Z_BUF_ERROR, an input or output error can be distinguished
   986|    using strm->next_in which will be Z_NULL only if in() returned an error.  If
   987|    strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   988|    non-zero.  (in() will always be called before out(), so strm->next_in is
   989|    assured to be defined if out() returns non-zero.)  Note that inflateBack()
   990|    cannot return Z_OK.
   991| */
   992| ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
   993| /*
   994|      All memory allocated by inflateBackInit() is freed.
   995|      inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   996|    state was inconsistent.
   997| */
   998| ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
   999| /* Return flags indicating compile-time options.
  1000|     Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
  1001|      1.0: size of uInt
  1002|      3.2: size of uLong
  1003|      5.4: size of voidpf (pointer)
  1004|      7.6: size of z_off_t
  1005|     Compiler, assembler, and debug options:
  1006|      8: ZLIB_DEBUG
  1007|      9: ASMV or ASMINF -- use ASM code
  1008|      10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
  1009|      11: 0 (reserved)
  1010|     One-time table building (smaller code, but not thread-safe if true):
  1011|      12: BUILDFIXED -- build static block decoding tables when needed
  1012|      13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
  1013|      14,15: 0 (reserved)
  1014|     Library content (indicates missing functionality):
  1015|      16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
  1016|                           deflate code when not needed)
  1017|      17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
  1018|                     and decode gzip streams (to avoid linking crc code)
  1019|      18-19: 0 (reserved)
  1020|     Operation variations (changes in library functionality):
  1021|      20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
  1022|      21: FASTEST -- deflate algorithm with only one, lowest compression level
  1023|      22,23: 0 (reserved)
  1024|     The sprintf variant used by gzprintf (zero is best):
  1025|      24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
  1026|      25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
  1027|      26: 0 = returns value, 1 = void -- 1 means inferred string length returned
  1028|     Remainder:
  1029|      27-31: 0 (reserved)
  1030|  */
  1031| #ifndef Z_SOLO
  1032|                         /* utility functions */
  1033| /*
  1034|      The following utility functions are implemented on top of the basic
  1035|    stream-oriented functions.  To simplify the interface, some default options
  1036|    are assumed (compression level and memory usage, standard memory allocation
  1037|    functions).  The source code of these utility functions can be modified if
  1038|    you need special options.
  1039| */
  1040| ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
  1041|                                  const Bytef *source, uLong sourceLen));
  1042| /*
  1043|      Compresses the source buffer into the destination buffer.  sourceLen is
  1044|    the byte length of the source buffer.  Upon entry, destLen is the total size
  1045|    of the destination buffer, which must be at least the value returned by
  1046|    compressBound(sourceLen).  Upon exit, destLen is the actual size of the
  1047|    compressed data.  compress() is equivalent to compress2() with a level
  1048|    parameter of Z_DEFAULT_COMPRESSION.
  1049|      compress returns Z_OK if success, Z_MEM_ERROR if there was not
  1050|    enough memory, Z_BUF_ERROR if there was not enough room in the output
  1051|    buffer.
  1052| */
  1053| ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
  1054|                                   const Bytef *source, uLong sourceLen,
  1055|                                   int level));
  1056| /*
  1057|      Compresses the source buffer into the destination buffer.  The level
  1058|    parameter has the same meaning as in deflateInit.  sourceLen is the byte
  1059|    length of the source buffer.  Upon entry, destLen is the total size of the
  1060|    destination buffer, which must be at least the value returned by
  1061|    compressBound(sourceLen).  Upon exit, destLen is the actual size of the
  1062|    compressed data.
  1063|      compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
  1064|    memory, Z_BUF_ERROR if there was not enough room in the output buffer,
  1065|    Z_STREAM_ERROR if the level parameter is invalid.
  1066| */
  1067| ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
  1068| /*
  1069|      compressBound() returns an upper bound on the compressed size after
  1070|    compress() or compress2() on sourceLen bytes.  It would be used before a
  1071|    compress() or compress2() call to allocate the destination buffer.
  1072| */
  1073| ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
  1074|                                    const Bytef *source, uLong sourceLen));
  1075| /*
  1076|      Decompresses the source buffer into the destination buffer.  sourceLen is
  1077|    the byte length of the source buffer.  Upon entry, destLen is the total size
  1078|    of the destination buffer, which must be large enough to hold the entire
  1079|    uncompressed data.  (The size of the uncompressed data must have been saved
  1080|    previously by the compressor and transmitted to the decompressor by some
  1081|    mechanism outside the scope of this compression library.) Upon exit, destLen
  1082|    is the actual size of the uncompressed data.
  1083|      uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
  1084|    enough memory, Z_BUF_ERROR if there was not enough room in the output
  1085|    buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
  1086|    the case where there is not enough room, uncompress() will fill the output
  1087|    buffer with the uncompressed data up to that point.
  1088| */
  1089| ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
  1090|                                     const Bytef *source, uLong *sourceLen));
  1091| /*
  1092|      Same as uncompress, except that sourceLen is a pointer, where the
  1093|    length of the source is *sourceLen.  On return, *sourceLen is the number of
  1094|    source bytes consumed.
  1095| */
  1096|                         /* gzip file access functions */
  1097| /*
  1098|      This library supports reading and writing files in gzip (.gz) format with
  1099|    an interface similar to that of stdio, using the functions that start with
  1100|    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
  1101|    wrapper, documented in RFC 1952, wrapped around a deflate stream.
  1102| */
  1103| typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */
  1104| /*
  1105| ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
  1106|      Open the gzip (.gz) file at path for reading and decompressing, or
  1107|    compressing and writing.  The mode parameter is as in fopen ("rb" or "wb")
  1108|    but can also include a compression level ("wb9") or a strategy: 'f' for
  1109|    filtered data as in "wb6f", 'h' for Huffman-only compression as in "wb1h",
  1110|    'R' for run-length encoding as in "wb1R", or 'F' for fixed code compression
  1111|    as in "wb9F".  (See the description of deflateInit2 for more information
  1112|    about the strategy parameter.)  'T' will request transparent writing or
  1113|    appending with no compression and not using the gzip format.
  1114|      "a" can be used instead of "w" to request that the gzip stream that will
  1115|    be written be appended to the file.  "+" will result in an error, since
  1116|    reading and writing to the same gzip file is not supported.  The addition of
  1117|    "x" when writing will create the file exclusively, which fails if the file
  1118|    already exists.  On systems that support it, the addition of "e" when
  1119|    reading or writing will set the flag to close the file on an execve() call.
  1120|      These functions, as well as gzip, will read and decode a sequence of gzip
  1121|    streams in a file.  The append function of gzopen() can be used to create
  1122|    such a file.  (Also see gzflush() for another way to do this.)  When
  1123|    appending, gzopen does not test whether the file begins with a gzip stream,
  1124|    nor does it look for the end of the gzip streams to begin appending.  gzopen
  1125|    will simply append a gzip stream to the existing file.
  1126|      gzopen can be used to read a file which is not in gzip format; in this
  1127|    case gzread will directly read from the file without decompression.  When
  1128|    reading, this will be detected automatically by looking for the magic two-
  1129|    byte gzip header.
  1130|      gzopen returns NULL if the file could not be opened, if there was
  1131|    insufficient memory to allocate the gzFile state, or if an invalid mode was
  1132|    specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
  1133|    errno can be checked to determine if the reason gzopen failed was that the
  1134|    file could not be opened.
  1135| */
  1136| ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
  1137| /*
  1138|      Associate a gzFile with the file descriptor fd.  File descriptors are
  1139|    obtained from calls like open, dup, creat, pipe or fileno (if the file has
  1140|    been previously opened with fopen).  The mode parameter is as in gzopen.
  1141|      The next call of gzclose on the returned gzFile will also close the file
  1142|    descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
  1143|    fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
  1144|    mode);.  The duplicated descriptor should be saved to avoid a leak, since
  1145|    gzdopen does not close fd if it fails.  If you are using fileno() to get the
  1146|    file descriptor from a FILE *, then you will have to use dup() to avoid
  1147|    double-close()ing the file descriptor.  Both gzclose() and fclose() will
  1148|    close the associated file descriptor, so they need to have different file
  1149|    descriptors.
  1150|      gzdopen returns NULL if there was insufficient memory to allocate the
  1151|    gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
  1152|    provided, or '+' was provided), or if fd is -1.  The file descriptor is not
  1153|    used until the next gz* read, write, seek, or close operation, so gzdopen
  1154|    will not detect if fd is invalid (unless fd is -1).
  1155| */
  1156| ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
  1157| /*
  1158|      Set the internal buffer size used by this library's functions for file to
  1159|    size.  The default buffer size is 8192 bytes.  This function must be called
  1160|    after gzopen() or gzdopen(), and before any other calls that read or write
  1161|    the file.  The buffer memory allocation is always deferred to the first read
  1162|    or write.  Three times that size in buffer space is allocated.  A larger
  1163|    buffer size of, for example, 64K or 128K bytes will noticeably increase the
  1164|    speed of decompression (reading).
  1165|      The new buffer size also affects the maximum length for gzprintf().
  1166|      gzbuffer() returns 0 on success, or -1 on failure, such as being called
  1167|    too late.
  1168| */
  1169| ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
  1170| /*
  1171|      Dynamically update the compression level and strategy for file.  See the
  1172|    description of deflateInit2 for the meaning of these parameters. Previously
  1173|    provided data is flushed before applying the parameter changes.
  1174|      gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
  1175|    opened for writing, Z_ERRNO if there is an error writing the flushed data,
  1176|    or Z_MEM_ERROR if there is a memory allocation error.
  1177| */
  1178| ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
  1179| /*
  1180|      Read and decompress up to len uncompressed bytes from file into buf.  If
  1181|    the input file is not in gzip format, gzread copies the given number of
  1182|    bytes into the buffer directly from the file.
  1183|      After reaching the end of a gzip stream in the input, gzread will continue
  1184|    to read, looking for another gzip stream.  Any number of gzip streams may be
  1185|    concatenated in the input file, and will all be decompressed by gzread().
  1186|    If something other than a gzip stream is encountered after a gzip stream,
  1187|    that remaining trailing garbage is ignored (and no error is returned).
  1188|      gzread can be used to read a gzip file that is being concurrently written.
  1189|    Upon reaching the end of the input, gzread will return with the available
  1190|    data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
  1191|    gzclearerr can be used to clear the end of file indicator in order to permit
  1192|    gzread to be tried again.  Z_OK indicates that a gzip stream was completed
  1193|    on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
  1194|    middle of a gzip stream.  Note that gzread does not return -1 in the event
  1195|    of an incomplete gzip stream.  This error is deferred until gzclose(), which
  1196|    will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
  1197|    stream.  Alternatively, gzerror can be used before gzclose to detect this
  1198|    case.
  1199|      gzread returns the number of uncompressed bytes actually read, less than
  1200|    len for end of file, or -1 for error.  If len is too large to fit in an int,
  1201|    then nothing is read, -1 is returned, and the error state is set to
  1202|    Z_STREAM_ERROR.
  1203| */
  1204| ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
  1205|                                      gzFile file));
  1206| /*
  1207|      Read and decompress up to nitems items of size size from file into buf,
  1208|    otherwise operating as gzread() does.  This duplicates the interface of
  1209|    stdio's fread(), with size_t request and return types.  If the library
  1210|    defines size_t, then z_size_t is identical to size_t.  If not, then z_size_t
  1211|    is an unsigned integer type that can contain a pointer.
  1212|      gzfread() returns the number of full items read of size size, or zero if
  1213|    the end of the file was reached and a full item could not be read, or if
  1214|    there was an error.  gzerror() must be consulted if zero is returned in
  1215|    order to determine if there was an error.  If the multiplication of size and
  1216|    nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
  1217|    is read, zero is returned, and the error state is set to Z_STREAM_ERROR.
  1218|      In the event that the end of file is reached and only a partial item is
  1219|    available at the end, i.e. the remaining uncompressed data length is not a
  1220|    multiple of size, then the final partial item is nevertheless read into buf
  1221|    and the end-of-file flag is set.  The length of the partial item read is not
  1222|    provided, but could be inferred from the result of gztell().  This behavior
  1223|    is the same as the behavior of fread() implementations in common libraries,
  1224|    but it prevents the direct use of gzfread() to read a concurrently written
  1225|    file, resetting and retrying on end-of-file, when size is not 1.
  1226| */
  1227| ZEXTERN int ZEXPORT gzwrite OF((gzFile file, voidpc buf, unsigned len));
  1228| /*
  1229|      Compress and write the len uncompressed bytes at buf to file. gzwrite
  1230|    returns the number of uncompressed bytes written or 0 in case of error.
  1231| */
  1232| ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
  1233|                                       z_size_t nitems, gzFile file));
  1234| /*
  1235|      Compress and write nitems items of size size from buf to file, duplicating
  1236|    the interface of stdio's fwrite(), with size_t request and return types.  If
  1237|    the library defines size_t, then z_size_t is identical to size_t.  If not,
  1238|    then z_size_t is an unsigned integer type that can contain a pointer.
  1239|      gzfwrite() returns the number of full items written of size size, or zero
  1240|    if there was an error.  If the multiplication of size and nitems overflows,
  1241|    i.e. the product does not fit in a z_size_t, then nothing is written, zero
  1242|    is returned, and the error state is set to Z_STREAM_ERROR.
  1243| */
  1244| ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
  1245| /*
  1246|      Convert, format, compress, and write the arguments (...) to file under
  1247|    control of the string format, as in fprintf.  gzprintf returns the number of
  1248|    uncompressed bytes actually written, or a negative zlib error code in case
  1249|    of error.  The number of uncompressed bytes written is limited to 8191, or
  1250|    one less than the buffer size given to gzbuffer().  The caller should assure
  1251|    that this limit is not exceeded.  If it is exceeded, then gzprintf() will
  1252|    return an error (0) with nothing written.  In this case, there may also be a
  1253|    buffer overflow with unpredictable consequences, which is possible only if
  1254|    zlib was compiled with the insecure functions sprintf() or vsprintf(),
  1255|    because the secure snprintf() or vsnprintf() functions were not available.
  1256|    This can be determined using zlibCompileFlags().
  1257| */
  1258| ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
  1259| /*
  1260|      Compress and write the given null-terminated string s to file, excluding
  1261|    the terminating null character.
  1262|      gzputs returns the number of characters written, or -1 in case of error.
  1263| */
  1264| ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
  1265| /*
  1266|      Read and decompress bytes from file into buf, until len-1 characters are
  1267|    read, or until a newline character is read and transferred to buf, or an
  1268|    end-of-file condition is encountered.  If any characters are read or if len
  1269|    is one, the string is terminated with a null character.  If no characters
  1270|    are read due to an end-of-file or len is less than one, then the buffer is
  1271|    left untouched.
  1272|      gzgets returns buf which is a null-terminated string, or it returns NULL
  1273|    for end-of-file or in case of error.  If there was an error, the contents at
  1274|    buf are indeterminate.
  1275| */
  1276| ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
  1277| /*
  1278|      Compress and write c, converted to an unsigned char, into file.  gzputc
  1279|    returns the value that was written, or -1 in case of error.
  1280| */
  1281| ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
  1282| /*
  1283|      Read and decompress one byte from file.  gzgetc returns this byte or -1
  1284|    in case of end of file or error.  This is implemented as a macro for speed.
  1285|    As such, it does not do all of the checking the other functions do.  I.e.
  1286|    it does not check to see if file is NULL, nor whether the structure file
  1287|    points to has been clobbered or not.
  1288| */
  1289| ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
  1290| /*
  1291|      Push c back onto the stream for file to be read as the first character on
  1292|    the next read.  At least one character of push-back is always allowed.
  1293|    gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
  1294|    fail if c is -1, and may fail if a character has been pushed but not read
  1295|    yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
  1296|    output buffer size of pushed characters is allowed.  (See gzbuffer above.)
  1297|    The pushed character will be discarded if the stream is repositioned with
  1298|    gzseek() or gzrewind().
  1299| */
  1300| ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
  1301| /*
  1302|      Flush all pending output to file.  The parameter flush is as in the
  1303|    deflate() function.  The return value is the zlib error number (see function
  1304|    gzerror below).  gzflush is only permitted when writing.
  1305|      If the flush parameter is Z_FINISH, the remaining data is written and the
  1306|    gzip stream is completed in the output.  If gzwrite() is called again, a new
  1307|    gzip stream will be started in the output.  gzread() is able to read such
  1308|    concatenated gzip streams.
  1309|      gzflush should be called only when strictly necessary because it will
  1310|    degrade compression if called too often.
  1311| */
  1312| /*
  1313| ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
  1314|                                    z_off_t offset, int whence));
  1315|      Set the starting position to offset relative to whence for the next gzread
  1316|    or gzwrite on file.  The offset represents a number of bytes in the
  1317|    uncompressed data stream.  The whence parameter is defined as in lseek(2);
  1318|    the value SEEK_END is not supported.
  1319|      If the file is opened for reading, this function is emulated but can be
  1320|    extremely slow.  If the file is opened for writing, only forward seeks are
  1321|    supported; gzseek then compresses a sequence of zeroes up to the new
  1322|    starting position.
  1323|      gzseek returns the resulting offset location as measured in bytes from
  1324|    the beginning of the uncompressed stream, or -1 in case of error, in
  1325|    particular if the file is opened for writing and the new starting position
  1326|    would be before the current position.
  1327| */
  1328| ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
  1329| /*
  1330|      Rewind file. This function is supported only for reading.
  1331|      gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).
  1332| */
  1333| /*
  1334| ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
  1335|      Return the starting position for the next gzread or gzwrite on file.
  1336|    This position represents a number of bytes in the uncompressed data stream,
  1337|    and is zero when starting, even if appending or reading a gzip stream from
  1338|    the middle of a file using gzdopen().
  1339|      gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
  1340| */
  1341| /*
  1342| ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
  1343|      Return the current compressed (actual) read or write offset of file.  This
  1344|    offset includes the count of bytes that precede the gzip stream, for example
  1345|    when appending or when using gzdopen() for reading.  When reading, the
  1346|    offset does not include as yet unused buffered input.  This information can
  1347|    be used for a progress indicator.  On error, gzoffset() returns -1.
  1348| */
  1349| ZEXTERN int ZEXPORT gzeof OF((gzFile file));
  1350| /*
  1351|      Return true (1) if the end-of-file indicator for file has been set while
  1352|    reading, false (0) otherwise.  Note that the end-of-file indicator is set
  1353|    only if the read tried to go past the end of the input, but came up short.
  1354|    Therefore, just like feof(), gzeof() may return false even if there is no
  1355|    more data to read, in the event that the last read request was for the exact
  1356|    number of bytes remaining in the input file.  This will happen if the input
  1357|    file size is an exact multiple of the buffer size.
  1358|      If gzeof() returns true, then the read functions will return no more data,
  1359|    unless the end-of-file indicator is reset by gzclearerr() and the input file
  1360|    has grown since the previous end of file was detected.
  1361| */
  1362| ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
  1363| /*
  1364|      Return true (1) if file is being copied directly while reading, or false
  1365|    (0) if file is a gzip stream being decompressed.
  1366|      If the input file is empty, gzdirect() will return true, since the input
  1367|    does not contain a gzip stream.
  1368|      If gzdirect() is used immediately after gzopen() or gzdopen() it will
  1369|    cause buffers to be allocated to allow reading the file to determine if it
  1370|    is a gzip file.  Therefore if gzbuffer() is used, it should be called before
  1371|    gzdirect().
  1372|      When writing, gzdirect() returns true (1) if transparent writing was
  1373|    requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
  1374|    gzdirect() is not needed when writing.  Transparent writing must be
  1375|    explicitly requested, so the application already knows the answer.  When
  1376|    linking statically, using gzdirect() will include all of the zlib code for
  1377|    gzip file reading and decompression, which may not be desired.)
  1378| */
  1379| ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
  1380| /*
  1381|      Flush all pending output for file, if necessary, close file and
  1382|    deallocate the (de)compression state.  Note that once file is closed, you
  1383|    cannot call gzerror with file, since its structures have been deallocated.
  1384|    gzclose must not be called more than once on the same file, just as free
  1385|    must not be called more than once on the same allocation.
  1386|      gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
  1387|    file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
  1388|    last read ended in the middle of a gzip stream, or Z_OK on success.
  1389| */
  1390| ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
  1391| ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
  1392| /*
  1393|      Same as gzclose(), but gzclose_r() is only for use when reading, and
  1394|    gzclose_w() is only for use when writing or appending.  The advantage to
  1395|    using these instead of gzclose() is that they avoid linking in zlib
  1396|    compression or decompression code that is not used when only reading or only
  1397|    writing respectively.  If gzclose() is used, then both compression and
  1398|    decompression code will be included the application when linking to a static
  1399|    zlib library.
  1400| */
  1401| ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
  1402| /*
  1403|      Return the error message for the last error which occurred on file.
  1404|    errnum is set to zlib error number.  If an error occurred in the file system
  1405|    and not in the compression library, errnum is set to Z_ERRNO and the
  1406|    application may consult errno to get the exact error code.
  1407|      The application must not modify the returned string.  Future calls to
  1408|    this function may invalidate the previously returned string.  If file is
  1409|    closed, then the string previously returned by gzerror will no longer be
  1410|    available.
  1411|      gzerror() should be used to distinguish errors from end-of-file for those
  1412|    functions above that do not distinguish those cases in their return values.
  1413| */
  1414| ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
  1415| /*
  1416|      Clear the error and end-of-file flags for file.  This is analogous to the
  1417|    clearerr() function in stdio.  This is useful for continuing to read a gzip
  1418|    file that is being written concurrently.
  1419| */
  1420| #endif /* !Z_SOLO */
  1421|                         /* checksum functions */
  1422| /*
  1423|      These functions are not related to compression but are exported
  1424|    anyway because they might be useful in applications using the compression
  1425|    library.
  1426| */
  1427| ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
  1428| /*
  1429|      Update a running Adler-32 checksum with the bytes buf[0..len-1] and
  1430|    return the updated checksum. An Adler-32 value is in the range of a 32-bit
  1431|    unsigned integer. If buf is Z_NULL, this function returns the required
  1432|    initial value for the checksum.
  1433|      An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
  1434|    much faster.
  1435|    Usage example:
  1436|      uLong adler = adler32(0L, Z_NULL, 0);
  1437|      while (read_buffer(buffer, length) != EOF) {
  1438|        adler = adler32(adler, buffer, length);
  1439|      }
  1440|      if (adler != original_adler) error();
  1441| */
  1442| ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
  1443|                                     z_size_t len));
  1444| /*
  1445|      Same as adler32(), but with a size_t length.
  1446| */
  1447| /*
  1448| ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
  1449|                                           z_off_t len2));
  1450|      Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
  1451|    and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
  1452|    each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
  1453|    seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
  1454|    that the z_off_t type (like off_t) is a signed integer.  If len2 is
  1455|    negative, the result has no meaning or utility.
  1456| */
  1457| ZEXTERN uLong ZEXPORT crc32 OF((uLong crc, const Bytef *buf, uInt len));
  1458| /*
  1459|      Update a running CRC-32 with the bytes buf[0..len-1] and return the
  1460|    updated CRC-32. A CRC-32 value is in the range of a 32-bit unsigned integer.
  1461|    If buf is Z_NULL, this function returns the required initial value for the
  1462|    crc. Pre- and post-conditioning (one's complement) is performed within this
  1463|    function so it shouldn't be done by the application.
  1464|    Usage example:
  1465|      uLong crc = crc32(0L, Z_NULL, 0);
  1466|      while (read_buffer(buffer, length) != EOF) {
  1467|        crc = crc32(crc, buffer, length);
  1468|      }
  1469|      if (crc != original_crc) error();
  1470| */
  1471| ZEXTERN uLong ZEXPORT crc32_z OF((uLong crc, const Bytef *buf,
  1472|                                   z_size_t len));
  1473| /*
  1474|      Same as crc32(), but with a size_t length.
  1475| */
  1476| /*
  1477| ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
  1478|      Combine two CRC-32 check values into one.  For two sequences of bytes,
  1479|    seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
  1480|    calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
  1481|    check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
  1482|    len2.
  1483| */
  1484| /*
  1485| ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t len2));
  1486|      Return the operator corresponding to length len2, to be used with
  1487|    crc32_combine_op().
  1488| */
  1489| ZEXTERN uLong ZEXPORT crc32_combine_op OF((uLong crc1, uLong crc2, uLong op));
  1490| /*
  1491|      Give the same result as crc32_combine(), using op in place of len2. op is
  1492|    is generated from len2 by crc32_combine_gen(). This will be faster than
  1493|    crc32_combine() if the generated op is used more than once.
  1494| */
  1495|                         /* various hacks, don't look :) */
  1496| /* deflateInit and inflateInit are macros to allow checking the zlib version
  1497|  * and the compiler's view of z_stream:
  1498|  */
  1499| ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
  1500|                                      const char *version, int stream_size));
  1501| ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
  1502|                                      const char *version, int stream_size));
  1503| ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
  1504|                                       int windowBits, int memLevel,
  1505|                                       int strategy, const char *version,
  1506|                                       int stream_size));
  1507| ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
  1508|                                       const char *version, int stream_size));
  1509| ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
  1510|                                          unsigned char FAR *window,
  1511|                                          const char *version,
  1512|                                          int stream_size));
  1513| #ifdef Z_PREFIX_SET
  1514| #  define z_deflateInit(strm, level) \
  1515|           deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
  1516| #  define z_inflateInit(strm) \
  1517|           inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
  1518| #  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
  1519|           deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
  1520|                         (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
  1521| #  define z_inflateInit2(strm, windowBits) \
  1522|           inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
  1523|                         (int)sizeof(z_stream))
  1524| #  define z_inflateBackInit(strm, windowBits, window) \
  1525|           inflateBackInit_((strm), (windowBits), (window), \
  1526|                            ZLIB_VERSION, (int)sizeof(z_stream))
  1527| #else
  1528| #  define deflateInit(strm, level) \
  1529|           deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
  1530| #  define inflateInit(strm) \
  1531|           inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
  1532| #  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
  1533|           deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
  1534|                         (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
  1535| #  define inflateInit2(strm, windowBits) \
  1536|           inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
  1537|                         (int)sizeof(z_stream))
  1538| #  define inflateBackInit(strm, windowBits, window) \
  1539|           inflateBackInit_((strm), (windowBits), (window), \
  1540|                            ZLIB_VERSION, (int)sizeof(z_stream))
  1541| #endif
  1542| #ifndef Z_SOLO
  1543| /* gzgetc() macro and its supporting function and exposed data structure.  Note
  1544|  * that the real internal state is much larger than the exposed structure.
  1545|  * This abbreviated structure exposes just enough for the gzgetc() macro.  The
  1546|  * user should not mess with these exposed elements, since their names or
  1547|  * behavior could change in the future, perhaps even capriciously.  They can
  1548|  * only be used by the gzgetc() macro.  You have been warned.
  1549|  */
  1550| struct gzFile_s {
  1551|     unsigned have;
  1552|     unsigned char *next;
  1553|     z_off64_t pos;
  1554| };
  1555| ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
  1556| #ifdef Z_PREFIX_SET
  1557| #  undef z_gzgetc
  1558| #  define z_gzgetc(g) \
  1559|           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
  1560| #else
  1561| #  define gzgetc(g) \
  1562|           ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
  1563| #endif
  1564| /* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
  1565|  * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
  1566|  * both are true, the application gets the *64 functions, and the regular
  1567|  * functions are changed to 64 bits) -- in case these are set on systems
  1568|  * without large file support, _LFS64_LARGEFILE must also be true
  1569|  */
  1570| #ifdef Z_LARGE64
  1571|    ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
  1572|    ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
  1573|    ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
  1574|    ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
  1575|    ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
  1576|    ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
  1577|    ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off64_t));
  1578| #endif
  1579| #if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
  1580| #  ifdef Z_PREFIX_SET
  1581| #    define z_gzopen z_gzopen64
  1582| #    define z_gzseek z_gzseek64
  1583| #    define z_gztell z_gztell64
  1584| #    define z_gzoffset z_gzoffset64
  1585| #    define z_adler32_combine z_adler32_combine64
  1586| #    define z_crc32_combine z_crc32_combine64
  1587| #    define z_crc32_combine_gen z_crc32_combine_gen64
  1588| #  else
  1589| #    define gzopen gzopen64
  1590| #    define gzseek gzseek64
  1591| #    define gztell gztell64
  1592| #    define gzoffset gzoffset64
  1593| #    define adler32_combine adler32_combine64
  1594| #    define crc32_combine crc32_combine64
  1595| #    define crc32_combine_gen crc32_combine_gen64
  1596| #  endif
  1597| #  ifndef Z_LARGE64
  1598|      ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
  1599|      ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
  1600|      ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
  1601|      ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
  1602|      ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
  1603|      ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
  1604|      ZEXTERN uLong ZEXPORT crc32_combine_gen64 OF((z_off_t));
  1605| #  endif
  1606| #else
  1607|    ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
  1608|    ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
  1609|    ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
  1610|    ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
  1611|    ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
  1612|    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
  1613|    ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
  1614| #endif
  1615| #else /* Z_SOLO */
  1616|    ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
  1617|    ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
  1618|    ZEXTERN uLong ZEXPORT crc32_combine_gen OF((z_off_t));
  1619| #endif /* !Z_SOLO */
  1620| /* undocumented functions */
  1621| ZEXTERN const char   * ZEXPORT zError           OF((int));
  1622| ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
  1623| ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
  1624| ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
  1625| ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
  1626| ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF((z_streamp));
  1627| ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
  1628| ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
  1629| #if defined(_WIN32) && !defined(Z_SOLO)
  1630| ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
  1631|                                             const char *mode));
  1632| #endif
  1633| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
  1634| #  ifndef Z_SOLO
  1635| ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
  1636|                                                   const char *format,
  1637|                                                   va_list va));
  1638| #  endif
  1639| #endif
  1640| #ifdef __cplusplus
  1641| }
  1642| #endif
  1643| #endif /* ZLIB_H */


# ====================================================================
# FILE: src/native/external/zlib/zutil.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-278 ---
     1| /* zutil.c -- target dependent utility functions for the compression library
     2|  * Copyright (C) 1995-2017 Jean-loup Gailly
     3|  * For conditions of distribution and use, see copyright notice in zlib.h
     4|  */
     5| /* @(#) $Id$ */
     6| #include "zutil.h"
     7| #ifndef Z_SOLO
     8| #  include "gzguts.h"
     9| #endif
    10| z_const char * const z_errmsg[10] = {
    11|     (z_const char *)"need dictionary",     /* Z_NEED_DICT       2  */
    12|     (z_const char *)"stream end",          /* Z_STREAM_END      1  */
    13|     (z_const char *)"",                    /* Z_OK              0  */
    14|     (z_const char *)"file error",          /* Z_ERRNO         (-1) */
    15|     (z_const char *)"stream error",        /* Z_STREAM_ERROR  (-2) */
    16|     (z_const char *)"data error",          /* Z_DATA_ERROR    (-3) */
    17|     (z_const char *)"insufficient memory", /* Z_MEM_ERROR     (-4) */
    18|     (z_const char *)"buffer error",        /* Z_BUF_ERROR     (-5) */
    19|     (z_const char *)"incompatible version",/* Z_VERSION_ERROR (-6) */
    20|     (z_const char *)""
    21| };
    22| const char * ZEXPORT zlibVersion()
    23| {
    24|     return ZLIB_VERSION;
    25| }
    26| uLong ZEXPORT zlibCompileFlags()
    27| {
    28|     uLong flags;
    29|     flags = 0;
    30|     switch ((int)(sizeof(uInt))) {
    31|     case 2:     break;
    32|     case 4:     flags += 1;     break;
    33|     case 8:     flags += 2;     break;
    34|     default:    flags += 3;
    35|     }
    36|     switch ((int)(sizeof(uLong))) {
    37|     case 2:     break;
    38|     case 4:     flags += 1 << 2;        break;
    39|     case 8:     flags += 2 << 2;        break;
    40|     default:    flags += 3 << 2;
    41|     }
    42|     switch ((int)(sizeof(voidpf))) {
    43|     case 2:     break;
    44|     case 4:     flags += 1 << 4;        break;
    45|     case 8:     flags += 2 << 4;        break;
    46|     default:    flags += 3 << 4;
    47|     }
    48|     switch ((int)(sizeof(z_off_t))) {
    49|     case 2:     break;
    50|     case 4:     flags += 1 << 6;        break;
    51|     case 8:     flags += 2 << 6;        break;
    52|     default:    flags += 3 << 6;
    53|     }
    54| #ifdef ZLIB_DEBUG
    55|     flags += 1 << 8;
    56| #endif
    57|     /*
    58| #if defined(ASMV) || defined(ASMINF)
    59|     flags += 1 << 9;
    60| #endif
    61|      */
    62| #ifdef ZLIB_WINAPI
    63|     flags += 1 << 10;
    64| #endif
    65| #ifdef BUILDFIXED
    66|     flags += 1 << 12;
    67| #endif
    68| #ifdef DYNAMIC_CRC_TABLE
    69|     flags += 1 << 13;
    70| #endif
    71| #ifdef NO_GZCOMPRESS
    72|     flags += 1L << 16;
    73| #endif
    74| #ifdef NO_GZIP
    75|     flags += 1L << 17;
    76| #endif
    77| #ifdef PKZIP_BUG_WORKAROUND
    78|     flags += 1L << 20;
    79| #endif
    80| #ifdef FASTEST
    81|     flags += 1L << 21;
    82| #endif
    83| #if defined(STDC) || defined(Z_HAVE_STDARG_H)
    84| #  ifdef NO_vsnprintf
    85|     flags += 1L << 25;
    86| #    ifdef HAS_vsprintf_void
    87|     flags += 1L << 26;
    88| #    endif
    89| #  else
    90| #    ifdef HAS_vsnprintf_void
    91|     flags += 1L << 26;
    92| #    endif
    93| #  endif
    94| #else
    95|     flags += 1L << 24;
    96| #  ifdef NO_snprintf
    97|     flags += 1L << 25;
    98| #    ifdef HAS_sprintf_void
    99|     flags += 1L << 26;
   100| #    endif
   101| #  else
   102| #    ifdef HAS_snprintf_void
   103|     flags += 1L << 26;
   104| #    endif
   105| #  endif
   106| #endif
   107|     return flags;
   108| }
   109| #ifdef ZLIB_DEBUG
   110| #include <stdlib.h>
   111| #  ifndef verbose
   112| #    define verbose 0
   113| #  endif
   114| int ZLIB_INTERNAL z_verbose = verbose;
   115| void ZLIB_INTERNAL z_error(m)
   116|     char *m;
   117| {
   118|     fprintf(stderr, "%s\n", m);
   119|     exit(1);
   120| }
   121| #endif
   122| /* exported to allow conversion of error code to string for compress() and
   123|  * uncompress()
   124|  */
   125| const char * ZEXPORT zError(err)
   126|     int err;
   127| {
   128|     return ERR_MSG(err);
   129| }
   130| #if defined(_WIN32_WCE) && _WIN32_WCE < 0x800
   131|     /* The older Microsoft C Run-Time Library for Windows CE doesn't have
   132|      * errno.  We define it as a global variable to simplify porting.
   133|      * Its value is always 0 and should not be used.
   134|      */
   135|     int errno = 0;
   136| #endif
   137| #ifndef HAVE_MEMCPY
   138| void ZLIB_INTERNAL zmemcpy(dest, source, len)
   139|     Bytef* dest;
   140|     const Bytef* source;
   141|     uInt  len;
   142| {
   143|     if (len == 0) return;
   144|     do {
   145|         *dest++ = *source++; /* ??? to be unrolled */
   146|     } while (--len != 0);
   147| }
   148| int ZLIB_INTERNAL zmemcmp(s1, s2, len)
   149|     const Bytef* s1;
   150|     const Bytef* s2;
   151|     uInt  len;
   152| {
   153|     uInt j;
   154|     for (j = 0; j < len; j++) {
   155|         if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
   156|     }
   157|     return 0;
   158| }
   159| void ZLIB_INTERNAL zmemzero(dest, len)
   160|     Bytef* dest;
   161|     uInt  len;
   162| {
   163|     if (len == 0) return;
   164|     do {
   165|         *dest++ = 0;  /* ??? to be unrolled */
   166|     } while (--len != 0);
   167| }
   168| #endif
   169| #ifndef Z_SOLO
   170| #ifdef SYS16BIT
   171| #ifdef __TURBOC__
   172| /* Turbo C in 16-bit mode */
   173| #  define MY_ZCALLOC
   174| /* Turbo C malloc() does not allow dynamic allocation of 64K bytes
   175|  * and farmalloc(64K) returns a pointer with an offset of 8, so we
   176|  * must fix the pointer. Warning: the pointer must be put back to its
   177|  * original form in order to free it, use zcfree().
   178|  */
   179| #define MAX_PTR 10
   180| /* 10*64K = 640K */
   181| local int next_ptr = 0;
   182| typedef struct ptr_table_s {
   183|     voidpf org_ptr;
   184|     voidpf new_ptr;
   185| } ptr_table;
   186| local ptr_table table[MAX_PTR];
   187| /* This table is used to remember the original form of pointers
   188|  * to large buffers (64K). Such pointers are normalized with a zero offset.
   189|  * Since MSDOS is not a preemptive multitasking OS, this table is not
   190|  * protected from concurrent access. This hack doesn't work anyway on
   191|  * a protected system like OS/2. Use Microsoft C instead.
   192|  */
   193| voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, unsigned items, unsigned size)
   194| {
   195|     voidpf buf;
   196|     ulg bsize = (ulg)items*size;
   197|     (void)opaque;
   198|     /* If we allocate less than 65520 bytes, we assume that farmalloc
   199|      * will return a usable pointer which doesn't have to be normalized.
   200|      */
   201|     if (bsize < 65520L) {
   202|         buf = farmalloc(bsize);
   203|         if (*(ush*)&buf != 0) return buf;
   204|     } else {
   205|         buf = farmalloc(bsize + 16L);
   206|     }
   207|     if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
   208|     table[next_ptr].org_ptr = buf;
   209|     /* Normalize the pointer to seg:0 */
   210|     *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
   211|     *(ush*)&buf = 0;
   212|     table[next_ptr++].new_ptr = buf;
   213|     return buf;
   214| }
   215| void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
   216| {
   217|     int n;
   218|     (void)opaque;
   219|     if (*(ush*)&ptr != 0) { /* object < 64K */
   220|         farfree(ptr);
   221|         return;
   222|     }
   223|     /* Find the original pointer */
   224|     for (n = 0; n < next_ptr; n++) {
   225|         if (ptr != table[n].new_ptr) continue;
   226|         farfree(table[n].org_ptr);
   227|         while (++n < next_ptr) {
   228|             table[n-1] = table[n];
   229|         }
   230|         next_ptr--;
   231|         return;
   232|     }
   233|     Assert(0, "zcfree: ptr not found");
   234| }
   235| #endif /* __TURBOC__ */
   236| #ifdef M_I86
   237| /* Microsoft C in 16-bit mode */
   238| #  define MY_ZCALLOC
   239| #if (!defined(_MSC_VER) || (_MSC_VER <= 600))
   240| #  define _halloc  halloc
   241| #  define _hfree   hfree
   242| #endif
   243| voidpf ZLIB_INTERNAL zcalloc(voidpf opaque, uInt items, uInt size)
   244| {
   245|     (void)opaque;
   246|     return _halloc((long)items, size);
   247| }
   248| void ZLIB_INTERNAL zcfree(voidpf opaque, voidpf ptr)
   249| {
   250|     (void)opaque;
   251|     _hfree(ptr);
   252| }
   253| #endif /* M_I86 */
   254| #endif /* SYS16BIT */
   255| #ifndef MY_ZCALLOC /* Any system without a special alloc function */
   256| #ifndef STDC
   257| extern voidp  malloc OF((uInt size));
   258| extern voidp  calloc OF((uInt items, uInt size));
   259| extern void   free   OF((voidpf ptr));
   260| #endif
   261| voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
   262|     voidpf opaque;
   263|     unsigned items;
   264|     unsigned size;
   265| {
   266|     (void)opaque;
   267|     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
   268|                               (voidpf)calloc(items, size);
   269| }
   270| void ZLIB_INTERNAL zcfree(opaque, ptr)
   271|     voidpf opaque;
   272|     voidpf ptr;
   273| {
   274|     (void)opaque;
   275|     free(ptr);
   276| }
   277| #endif /* MY_ZCALLOC */
   278| #endif /* !Z_SOLO */


# ====================================================================
# FILE: src/native/libs/System.IO.Compression.Native/pal_zlib.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-172 ---
     1| #include <assert.h>
     2| #include <stdlib.h>
     3| #include "pal_zlib.h"
     4| #ifdef INTERNAL_ZLIB
     5|     #ifdef  _WIN32
     6|         #define c_static_assert(e) static_assert((e),"")
     7|     #endif
     8|     #ifdef INTERNAL_ZLIB_INTEL
     9|         #include <external/zlib-intel/zlib.h>
    10|     #else
    11|         #include <external/zlib/zlib.h>
    12|     #endif
    13| #else
    14|     #include "pal_utilities.h"
    15|     #include <zlib.h>
    16| #endif
    17| c_static_assert(PAL_Z_NOFLUSH == Z_NO_FLUSH);
    18| c_static_assert(PAL_Z_FINISH == Z_FINISH);
    19| c_static_assert(PAL_Z_OK == Z_OK);
    20| c_static_assert(PAL_Z_STREAMEND == Z_STREAM_END);
    21| c_static_assert(PAL_Z_STREAMERROR == Z_STREAM_ERROR);
    22| c_static_assert(PAL_Z_DATAERROR == Z_DATA_ERROR);
    23| c_static_assert(PAL_Z_MEMERROR == Z_MEM_ERROR);
    24| c_static_assert(PAL_Z_BUFERROR == Z_BUF_ERROR);
    25| c_static_assert(PAL_Z_VERSIONERROR == Z_VERSION_ERROR);
    26| c_static_assert(PAL_Z_NOCOMPRESSION == Z_NO_COMPRESSION);
    27| c_static_assert(PAL_Z_BESTSPEED == Z_BEST_SPEED);
    28| c_static_assert(PAL_Z_DEFAULTCOMPRESSION == Z_DEFAULT_COMPRESSION);
    29| c_static_assert(PAL_Z_DEFAULTSTRATEGY == Z_DEFAULT_STRATEGY);
    30| c_static_assert(PAL_Z_DEFLATED == Z_DEFLATED);
    31| /*
    32| Initializes the PAL_ZStream by creating and setting its underlying z_stream.
    33| */
    34| static int32_t Init(PAL_ZStream* stream)
    35| {
    36|     z_stream* zStream = (z_stream*)calloc(1, sizeof(z_stream));
    37|     stream->internalState = zStream;
    38|     if (zStream != NULL)
    39|     {
    40|         return PAL_Z_OK;
    41|     }
    42|     else
    43|     {
    44|         return PAL_Z_MEMERROR;
    45|     }
    46| }
    47| /*
    48| Frees any memory on the PAL_ZStream that was created by Init.
    49| */
    50| static void End(PAL_ZStream* stream)
    51| {
    52|     z_stream* zStream = (z_stream*)(stream->internalState);
    53|     assert(zStream != NULL);
    54|     if (zStream != NULL)
    55|     {
    56|         free(zStream);
    57|         stream->internalState = NULL;
    58|     }
    59| }
    60| /*
    61| Transfers the output values from the underlying z_stream to the PAL_ZStream.
    62| */
    63| static void TransferStateToPalZStream(z_stream* from, PAL_ZStream* to)
    64| {
    65|     to->nextIn = from->next_in;
    66|     to->availIn = from->avail_in;
    67|     to->nextOut = from->next_out;
    68|     to->availOut = from->avail_out;
    69|     to->msg = from->msg;
    70| }
    71| /*
    72| Transfers the input values from the PAL_ZStream to the underlying z_stream object.
    73| */
    74| static void TransferStateFromPalZStream(PAL_ZStream* from, z_stream* to)
    75| {
    76|     to->next_in = from->nextIn;
    77|     to->avail_in = from->availIn;
    78|     to->next_out = from->nextOut;
    79|     to->avail_out = from->availOut;
    80| }
    81| /*
    82| Gets the current z_stream object for the specified PAL_ZStream.
    83| This ensures any inputs are transferred from the PAL_ZStream to the underlying z_stream,
    84| since the current values are always needed.
    85| */
    86| static z_stream* GetCurrentZStream(PAL_ZStream* stream)
    87| {
    88|     z_stream* zStream = (z_stream*)(stream->internalState);
    89|     assert(zStream != NULL);
    90|     TransferStateFromPalZStream(stream, zStream);
    91|     return zStream;
    92| }
    93| int32_t CompressionNative_DeflateInit2_(
    94|     PAL_ZStream* stream, int32_t level, int32_t method, int32_t windowBits, int32_t memLevel, int32_t strategy)
    95| {
    96|     assert(stream != NULL);
    97|     int32_t result = Init(stream);
    98|     if (result == PAL_Z_OK)
    99|     {
   100|         z_stream* zStream = GetCurrentZStream(stream);
   101|         result = deflateInit2(zStream, level, method, windowBits, memLevel, strategy);
   102|         TransferStateToPalZStream(zStream, stream);
   103|     }
   104|     return result;
   105| }
   106| int32_t CompressionNative_Deflate(PAL_ZStream* stream, int32_t flush)
   107| {
   108|     assert(stream != NULL);
   109|     z_stream* zStream = GetCurrentZStream(stream);
   110|     int32_t result = deflate(zStream, flush);
   111|     TransferStateToPalZStream(zStream, stream);
   112|     return result;
   113| }
   114| int32_t CompressionNative_DeflateReset(PAL_ZStream* stream)
   115| {
   116|     assert(stream != NULL);
   117|     z_stream* zStream = GetCurrentZStream(stream);
   118|     int32_t result = deflateReset(zStream);
   119|     TransferStateToPalZStream(zStream, stream);
   120|     return result;
   121| }
   122| int32_t CompressionNative_DeflateEnd(PAL_ZStream* stream)
   123| {
   124|     assert(stream != NULL);
   125|     z_stream* zStream = GetCurrentZStream(stream);
   126|     int32_t result = deflateEnd(zStream);
   127|     End(stream);
   128|     return result;
   129| }
   130| int32_t CompressionNative_InflateInit2_(PAL_ZStream* stream, int32_t windowBits)
   131| {
   132|     assert(stream != NULL);
   133|     int32_t result = Init(stream);
   134|     if (result == PAL_Z_OK)
   135|     {
   136|         z_stream* zStream = GetCurrentZStream(stream);
   137|         result = inflateInit2(zStream, windowBits);
   138|         TransferStateToPalZStream(zStream, stream);
   139|     }
   140|     return result;
   141| }
   142| int32_t CompressionNative_Inflate(PAL_ZStream* stream, int32_t flush)
   143| {
   144|     assert(stream != NULL);
   145|     z_stream* zStream = GetCurrentZStream(stream);
   146|     int32_t result = inflate(zStream, flush);
   147|     TransferStateToPalZStream(zStream, stream);
   148|     return result;
   149| }
   150| int32_t CompressionNative_InflateReset(PAL_ZStream* stream)
   151| {
   152|     assert(stream != NULL);
   153|     z_stream* zStream = GetCurrentZStream(stream);
   154|     int32_t result = inflateReset(zStream);
   155|     TransferStateToPalZStream(zStream, stream);
   156|     return result;
   157| }
   158| int32_t CompressionNative_InflateEnd(PAL_ZStream* stream)
   159| {
   160|     assert(stream != NULL);
   161|     z_stream* zStream = GetCurrentZStream(stream);
   162|     int32_t result = inflateEnd(zStream);
   163|     End(stream);
   164|     return result;
   165| }
   166| uint32_t CompressionNative_Crc32(uint32_t crc, uint8_t* buffer, int32_t len)
   167| {
   168|     assert(buffer != NULL);
   169|     unsigned long result = crc32(crc, buffer, len);
   170|     assert(result <= UINT32_MAX);
   171|     return (uint32_t)result;
   172| }


# ====================================================================
# FILE: src/native/libs/System.IO.Compression.Native/zlib_allocator_unix.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-140 ---
     1| #include <stdbool.h>
     2| #include <stdint.h>
     3| #include <external/zlib/zutil.h>
     4| /* A custom allocator for zlib that provides some defense-in-depth over standard malloc / free.
     5|  * (non-Windows version)
     6|  *
     7|  * 1. When zlib allocates fixed-length data structures for containing stream metadata, we zero
     8|  *    the memory before using it, preventing use of uninitialized memory within these structures.
     9|  *    Ideally we would do this for dynamically-sized buffers as well, but there is a measurable
    10|  *    perf impact to doing this. Zeroing fixed structures seems like a good trade-off here, since
    11|  *    these data structures contain most of the metadata used for managing the variable-length
    12|  *    dynamically allocated buffers.
    13|  *
    14|  * 2. We put a cookie both before and after any allocated memory, which allows us to detect local
    15|  *    buffer overruns on the call to free(). The cookie values are tied to the addresses where
    16|  *    the data is located in memory.
    17|  *
    18|  * 3. We trash the aforementioned cookie on free(), which allows us to detect double-free.
    19|  *
    20|  * If any of these checks fails, the application raises SIGABRT.
    21|  */
    22| static bool IsMitigationDisabled()
    23| {
    24|     enum _MitigationEnablementTristate
    25|     {
    26|         MITIGATION_NOT_YET_QUERIED = 0,
    27|         MITIGATION_DISABLED = 1,
    28|         MITIGATION_ENABLED = 2 // really, anything other than 0 or 1
    29|     };
    30|     static int s_fMitigationEnablementState = MITIGATION_NOT_YET_QUERIED;
    31|     if (s_fMitigationEnablementState != MITIGATION_NOT_YET_QUERIED)
    32|     {
    33|         return (s_fMitigationEnablementState == MITIGATION_DISABLED);
    34|     }
    35|     char* pchEnvVar = getenv("DOTNET_SYSTEM_IO_COMPRESSION_DISABLEZLIBMITIGATIONS");
    36|     bool fMitigationDisabled = (pchEnvVar && (strcmp(pchEnvVar, "1") == 0 || strcmp(pchEnvVar, "true") == 0));
    37|     __sync_val_compare_and_swap(
    38|         /* destination: */ &s_fMitigationEnablementState,
    39|         /* comparand:   */ MITIGATION_NOT_YET_QUERIED,
    40|         /* exchange:    */ fMitigationDisabled ? MITIGATION_DISABLED : MITIGATION_ENABLED);
    41|     return IsMitigationDisabled();
    42| }
    43| #ifndef MEMORY_ALLOCATION_ALIGNMENT
    44| #ifdef HOST_64BIT
    45| #define MEMORY_ALLOCATION_ALIGNMENT 16
    46| #else
    47| #define MEMORY_ALLOCATION_ALIGNMENT 8
    48| #endif
    49| #endif
    50| typedef struct _DOTNET_ALLOC_COOKIE
    51| {
    52|     void* Address;
    53|     size_t Size;
    54| } DOTNET_ALLOC_COOKIE;
    55| static bool SafeAdd(size_t a, size_t b, size_t* sum)
    56| {
    57|     if (SIZE_MAX - a >= b) { *sum = a + b; return true; }
    58|     else { *sum = 0; return false; }
    59| }
    60| static bool SafeMult(size_t a, size_t b, size_t* product)
    61| {
    62|     if (SIZE_MAX / a >= b) { *product = a * b; return true; }
    63|     else { *product = 0; return false; }
    64| }
    65| static DOTNET_ALLOC_COOKIE ReadAllocCookieUnaligned(const void* pSrc)
    66| {
    67|     DOTNET_ALLOC_COOKIE vCookie;
    68|     memcpy(&vCookie, pSrc, sizeof(DOTNET_ALLOC_COOKIE));
    69|     return vCookie;
    70| }
    71| static void WriteAllocCookieUnaligned(void* pDest, DOTNET_ALLOC_COOKIE vCookie)
    72| {
    73|     memcpy(pDest, &vCookie, sizeof(DOTNET_ALLOC_COOKIE));
    74| }
    75| const size_t DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING = (sizeof(DOTNET_ALLOC_COOKIE) + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~((size_t)MEMORY_ALLOCATION_ALIGNMENT  - 1);
    76| const size_t DOTNET_ALLOC_TRAILER_COOKIE_SIZE = sizeof(DOTNET_ALLOC_COOKIE);
    77| voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
    78|     voidpf opaque;
    79|     unsigned items;
    80|     unsigned size;
    81| {
    82|     (void)opaque; // unreferenced formal parameter
    83|     if (IsMitigationDisabled())
    84|     {
    85|         return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
    86|                                   (voidpf)calloc(items, size);
    87|     }
    88|     bool fZeroMemory = (items == 1);
    89|     size_t cbRequested;
    90|     if (sizeof(items) + sizeof(size) <= sizeof(cbRequested))
    91|     {
    92|         cbRequested = (size_t)items * (size_t)size;
    93|     }
    94|     else
    95|     {
    96|         if (!SafeMult((size_t)items, (size_t)size, &cbRequested)) { return NULL; }
    97|     }
    98|     size_t cbActualAllocationSize;
    99|     if (!SafeAdd(cbRequested, DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING + DOTNET_ALLOC_TRAILER_COOKIE_SIZE, &cbActualAllocationSize)) { return NULL; }
   100|     void* pAlloced = (fZeroMemory) ? calloc(1, cbActualAllocationSize) : malloc(cbActualAllocationSize);
   101|     if (pAlloced == NULL) { return NULL; } // OOM
   102|     DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)pAlloced;
   103|     uint8_t* pReturnToCaller = (uint8_t*)pAlloced + DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING;
   104|     uint8_t* pTrailerCookie = pReturnToCaller + cbRequested;
   105|     DOTNET_ALLOC_COOKIE vCookie = { 0 };
   106|     vCookie.Address = pReturnToCaller;
   107|     vCookie.Size = cbRequested;
   108|     *pHeaderCookie = vCookie; // aligned
   109|     WriteAllocCookieUnaligned(pTrailerCookie, vCookie);
   110|     return pReturnToCaller;
   111| }
   112| static void zcfree_trash_cookie(void* pCookie)
   113| {
   114|     memset(pCookie, 0, sizeof(DOTNET_ALLOC_COOKIE));
   115| }
   116| void ZLIB_INTERNAL zcfree(opaque, ptr)
   117|     voidpf opaque;
   118|     voidpf ptr;
   119| {
   120|     (void)opaque; // unreferenced formal parameter
   121|     if (IsMitigationDisabled())
   122|     {
   123|         free(ptr);
   124|         return;
   125|     }
   126|     if (ptr == NULL) { return; } // ok to free nullptr
   127|     DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)((uint8_t*)ptr - DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING);
   128|     if (pHeaderCookie->Address != ptr) { goto Fail; }
   129|     size_t cbRequested = pHeaderCookie->Size;
   130|     uint8_t* pTrailerCookie = (uint8_t*)ptr + cbRequested;
   131|     DOTNET_ALLOC_COOKIE vTrailerCookie = ReadAllocCookieUnaligned(pTrailerCookie);
   132|     if (vTrailerCookie.Address != ptr) { goto Fail; }
   133|     if (vTrailerCookie.Size != cbRequested) { goto Fail; }
   134|     zcfree_trash_cookie(pHeaderCookie);
   135|     zcfree_trash_cookie(pTrailerCookie);
   136|     free(pHeaderCookie);
   137|     return;
   138| Fail:
   139|     abort(); // cookie check failed
   140| }


# ====================================================================
# FILE: src/native/libs/System.IO.Compression.Native/zlib_allocator_win.c
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-161 ---
     1| #include <Windows.h>
     2| #include <heapapi.h>
     3| #include <intsafe.h>
     4| #include <winnt.h>
     5| #include <crtdbg.h> /* _ASSERTE */
     6| #ifdef INTERNAL_ZLIB_INTEL
     7| #include <external/zlib-intel/zutil.h>
     8| #else
     9| #include <external/zlib/zutil.h>
    10| #endif
    11| /* A custom allocator for zlib that provides some defense-in-depth over standard malloc / free.
    12|  * (Windows-specific version)
    13|  *
    14|  * 1. In 64-bit processes, we use a custom heap rather than relying on the standard process heap.
    15|  *    This should cause zlib's buffers to go into a separate address range from the rest of app
    16|  *    data, making it more difficult for buffer overruns to affect non-zlib-related data structures.
    17|  *
    18|  * 2. When zlib allocates fixed-length data structures for containing stream metadata, we zero
    19|  *    the memory before using it, preventing use of uninitialized memory within these structures.
    20|  *    Ideally we would do this for dynamically-sized buffers as well, but there is a measurable
    21|  *    perf impact to doing this. Zeroing fixed structures seems like a good trade-off here, since
    22|  *    these data structures contain most of the metadata used for managing the variable-length
    23|  *    dynamically allocated buffers.
    24|  *
    25|  * 3. We put a cookie both before and after any allocated memory, which allows us to detect local
    26|  *    buffer overruns on the call to free(). The cookie values are enciphered to make it more
    27|  *    difficult for somebody to guess a correct value.
    28|  *
    29|  * 4. We trash the aforementioned cookie on free(), which allows us to detect double-free.
    30|  *
    31|  * If any of these checks fails, the application terminates immediately, optionally triggering a
    32|  * crash dump. We use a special code that's easy to search for in Watson.
    33|  */
    34| BOOL IsMitigationDisabled()
    35| {
    36|     enum _MitigationEnablementTristate
    37|     {
    38|         MITIGATION_NOT_YET_QUERIED = 0,
    39|         MITIGATION_DISABLED = 1,
    40|         MITIGATION_ENABLED = 2 // really, anything other than 0 or 1
    41|     };
    42|     static long s_fMitigationEnablementState = MITIGATION_NOT_YET_QUERIED;
    43|     if (s_fMitigationEnablementState != MITIGATION_NOT_YET_QUERIED)
    44|     {
    45|         return (s_fMitigationEnablementState == MITIGATION_DISABLED);
    46|     }
    47|     CHAR pchBuffer[5]; // enough to hold "true" and a terminator
    48|     DWORD dwEnvVarLength = GetEnvironmentVariableA("DOTNET_SYSTEM_IO_COMPRESSION_DISABLEZLIBMITIGATIONS", pchBuffer, _countof(pchBuffer));
    49|     BOOL fMitigationDisabled = (dwEnvVarLength > 0 && dwEnvVarLength < _countof(pchBuffer))
    50|         && (strcmp(pchBuffer, "1") == 0 || strcmp(pchBuffer, "true") == 0);
    51|     InterlockedCompareExchange(
    52|         /* destination: */ &s_fMitigationEnablementState,
    53|         /* exchange:    */ fMitigationDisabled ? MITIGATION_DISABLED : MITIGATION_ENABLED,
    54|         /* comparand:   */ MITIGATION_NOT_YET_QUERIED);
    55|     return IsMitigationDisabled();
    56| }
    57| HANDLE GetZlibHeap()
    58| {
    59| #ifdef _WIN64
    60|     static HANDLE s_hPublishedHeap = NULL;
    61|     if (s_hPublishedHeap != NULL) { return s_hPublishedHeap; }
    62|     HANDLE hNewHeap = HeapCreate(0, 0, 0);
    63|     if (hNewHeap != NULL)
    64|     {
    65|         if (InterlockedCompareExchangePointer(&s_hPublishedHeap, hNewHeap, NULL) != NULL)
    66|         {
    67|             HeapDestroy(hNewHeap); // Somebody published before us. Destroy our heap.
    68|             hNewHeap = NULL; // Guard against accidental use later in the method.
    69|         }
    70|     }
    71|     else
    72|     {
    73|         InterlockedCompareExchangePointer(&s_hPublishedHeap, GetProcessHeap(), NULL);
    74|     }
    75|     _ASSERTE(s_hPublishedHeap != NULL);
    76|     return s_hPublishedHeap;
    77| #else
    78|     return GetProcessHeap();
    79| #endif
    80| }
    81| typedef struct _DOTNET_ALLOC_COOKIE
    82| {
    83|     PVOID CookieValue;
    84|     union _Size
    85|     {
    86|         SIZE_T RawValue;
    87|         LPVOID EncodedValue;
    88|     } Size;
    89| } DOTNET_ALLOC_COOKIE;
    90| const SIZE_T DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING = (sizeof(DOTNET_ALLOC_COOKIE) + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~((SIZE_T)MEMORY_ALLOCATION_ALIGNMENT  - 1);
    91| const SIZE_T DOTNET_ALLOC_TRAILER_COOKIE_SIZE = sizeof(DOTNET_ALLOC_COOKIE);
    92| voidpf ZLIB_INTERNAL zcalloc(opaque, items, size)
    93|     voidpf opaque;
    94|     unsigned items;
    95|     unsigned size;
    96| {
    97|     (void)opaque; // suppress C4100 - unreferenced formal parameter
    98|     if (IsMitigationDisabled())
    99|     {
   100|         return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
   101|                                   (voidpf)calloc(items, size);
   102|     }
   103|     DWORD dwFlags = (items == 1) ? HEAP_ZERO_MEMORY : 0;
   104|     SIZE_T cbRequested;
   105|     if (sizeof(items) + sizeof(size) <= sizeof(cbRequested))
   106|     {
   107|         cbRequested = (SIZE_T)items * (SIZE_T)size;
   108|     }
   109|     else
   110|     {
   111|         if (FAILED(SIZETMult(items, size, &cbRequested))) { return NULL; }
   112|     }
   113|     SIZE_T cbActualAllocationSize;
   114|     if (FAILED(SIZETAdd(cbRequested, DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING + DOTNET_ALLOC_TRAILER_COOKIE_SIZE, &cbActualAllocationSize))) { return NULL; }
   115|     LPVOID pAlloced = HeapAlloc(GetZlibHeap(), dwFlags, cbActualAllocationSize);
   116|     if (pAlloced == NULL) { return NULL; } // OOM
   117|     DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)pAlloced;
   118|     pHeaderCookie->CookieValue = EncodePointer(&pHeaderCookie->CookieValue);
   119|     pHeaderCookie->Size.RawValue = cbRequested;
   120|     LPBYTE pReturnToCaller = (LPBYTE)pHeaderCookie + DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING;
   121|     UNALIGNED DOTNET_ALLOC_COOKIE* pTrailerCookie = (UNALIGNED DOTNET_ALLOC_COOKIE*)(pReturnToCaller + cbRequested);
   122|     pTrailerCookie->CookieValue = EncodePointer(&pTrailerCookie->CookieValue);
   123|     pTrailerCookie->Size.EncodedValue = EncodePointer((PVOID)cbRequested);
   124|     return pReturnToCaller;
   125| }
   126| FORCEINLINE
   127| void zcfree_trash_cookie(UNALIGNED DOTNET_ALLOC_COOKIE* pCookie)
   128| {
   129|     memset(pCookie, 0, sizeof(*pCookie));
   130|     pCookie->CookieValue = (PVOID)(SIZE_T)0xDEADBEEF;
   131| }
   132| DECLSPEC_NOINLINE
   133| DECLSPEC_NORETURN
   134| void zcfree_cookie_check_failed()
   135| {
   136|     __fastfail(FAST_FAIL_HEAP_METADATA_CORRUPTION);
   137| }
   138| void ZLIB_INTERNAL zcfree(opaque, ptr)
   139|     voidpf opaque;
   140|     voidpf ptr;
   141| {
   142|     (void)opaque; // suppress C4100 - unreferenced formal parameter
   143|     if (IsMitigationDisabled())
   144|     {
   145|         free(ptr);
   146|         return;
   147|     }
   148|     if (ptr == NULL) { return; } // ok to free nullptr
   149|     DOTNET_ALLOC_COOKIE* pHeaderCookie = (DOTNET_ALLOC_COOKIE*)((LPBYTE)ptr - DOTNET_ALLOC_HEADER_COOKIE_SIZE_WITH_PADDING);
   150|     if (DecodePointer(pHeaderCookie->CookieValue) != &pHeaderCookie->CookieValue) { goto Fail; }
   151|     SIZE_T cbRequested = pHeaderCookie->Size.RawValue;
   152|     UNALIGNED DOTNET_ALLOC_COOKIE* pTrailerCookie = (UNALIGNED DOTNET_ALLOC_COOKIE*)((LPBYTE)ptr + cbRequested);
   153|     if (DecodePointer(pTrailerCookie->CookieValue) != &pTrailerCookie->CookieValue) { goto Fail; }
   154|     if (DecodePointer(pTrailerCookie->Size.EncodedValue) != (LPVOID)cbRequested) { goto Fail; }
   155|     zcfree_trash_cookie(pHeaderCookie);
   156|     zcfree_trash_cookie(pTrailerCookie);
   157|     if (!HeapFree(GetZlibHeap(), 0, pHeaderCookie)) { goto Fail; }
   158|     return;
   159| Fail:
   160|     zcfree_cookie_check_failed();
   161| }

