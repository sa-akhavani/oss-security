--- a/benches/output.rs
+++ b/benches/output.rs
@@ -53,21 +53,20 @@
         ))
     });
 }
 #[bench]
 fn bench_output_covdir(b: &mut Bencher) {
     let dir = tempdir().unwrap();
     b.iter(|| {
         black_box(output_covdir(
             &generate_cov_result_iter(),
             Some(&dir.path().join("temp")),
-            2,
         ));
     });
 }
 #[bench]
 fn bench_output_lcov(b: &mut Bencher) {
     let dir = tempdir().unwrap();
     b.iter(|| {
         black_box(output_lcov(
             &generate_cov_result_iter(),
             Some(&dir.path().join("temp")),

--- a/benches/parser.rs
+++ b/benches/parser.rs
@@ -14,14 +14,14 @@
 }
 #[bench]
 fn bench_parser_gcov(b: &mut Bencher) {
     let path = Path::new("./test/negative_counts.gcov");
     b.iter(|| black_box(grcov::parse_gcov(path)));
 }
 #[bench]
 fn bench_parser_jacoco(b: &mut Bencher) {
     let path = Path::new("./test/jacoco/full-junit4-report-multiple-top-level-classes.xml");
     b.iter(|| {
-        let file = BufReader::new(File::open(path).unwrap());
+        let file = BufReader::new(File::open(&path).unwrap());
         black_box(grcov::parse_jacoco_xml_report(file))
     });
 }

--- a/src/cobertura.rs
+++ b/src/cobertura.rs
@@ -1,22 +1,19 @@
 use crate::defs::*;
 use quick_xml::{
     events::{BytesDecl, BytesEnd, BytesStart, BytesText, Event},
     Writer,
 };
 use rustc_hash::FxHashMap;
+use std::io::{BufWriter, Cursor, Write};
+use std::path::Path;
 use std::time::{SystemTime, UNIX_EPOCH};
-use std::{
-    fmt::Display,
-    io::{BufWriter, Cursor, Write},
-};
-use std::{fmt::Formatter, path::Path};
 use symbolic_common::Name;
 use symbolic_demangle::{Demangle, DemangleOptions};
 use crate::output::get_target_output_writable;
 macro_rules! demangle {
     ($name: expr, $demangle: expr, $options: expr) => {{
         if $demangle {
             Name::from($name)
                 .demangle($options)
                 .unwrap_or_else(|| $name.clone())
         } else {
@@ -183,24 +180,24 @@
 #[derive(Debug, Clone)]
 struct Condition {
     number: usize,
     cond_type: ConditionType,
     coverage: f64,
 }
 #[derive(Debug, Clone)]
 enum ConditionType {
     Jump,
 }
-impl Display for ConditionType {
-    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
-        match self {
-            Self::Jump => write!(f, "jump"),
+impl ToString for ConditionType {
+    fn to_string(&self) -> String {
+        match *self {
+            Self::Jump => String::from("jump"),
         }
     }
 }
 fn get_coverage(
     results: &[ResultTuple],
     sources: Vec<String>,
     demangle: bool,
     demangle_options: DemangleOptions,
 ) -> Coverage {
     let packages: Vec<Package> = results
@@ -280,33 +277,28 @@
             }
         })
         .collect();
     Coverage { sources, packages }
 }
 pub fn output_cobertura(
     source_dir: Option<&Path>,
     results: &[ResultTuple],
     output_file: Option<&Path>,
     demangle: bool,
-    pretty: bool,
 ) {
     let demangle_options = DemangleOptions::name_only();
     let sources = vec![source_dir
         .unwrap_or_else(|| Path::new("."))
         .display()
         .to_string()];
     let coverage = get_coverage(results, sources, demangle, demangle_options);
-    let mut writer = if pretty {
-        Writer::new_with_indent(Cursor::new(vec![]), b' ', 4)
-    } else {
-        Writer::new(Cursor::new(vec![]))
-    };
+    let mut writer = Writer::new_with_indent(Cursor::new(vec![]), b' ', 4);
     writer
         .write_event(Event::Decl(BytesDecl::new("1.0", None, None)))
         .unwrap();
     writer
         .write_event(Event::DocType(BytesText::from_escaped(
             " coverage SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'",
         )))
         .unwrap();
     let cov_tag = "coverage";
     let mut cov = BytesStart::from_content(cov_tag, cov_tag.len());
@@ -444,21 +436,21 @@
         .unwrap();
     for line in lines {
         let mut l = BytesStart::from_content(line_tag, line_tag.len());
         match line {
             Line::Plain {
                 ref number,
                 ref hits,
             } => {
                 l.push_attribute(("number", number.to_string().as_ref()));
                 l.push_attribute(("hits", hits.to_string().as_ref()));
-                writer.write_event(Event::Empty(l)).unwrap();
+                writer.write_event(Event::Start(l)).unwrap();
             }
             Line::Branch {
                 ref number,
                 ref hits,
                 conditions,
             } => {
                 l.push_attribute(("number", number.to_string().as_ref()));
                 l.push_attribute(("hits", hits.to_string().as_ref()));
                 l.push_attribute(("branch", "true"));
                 writer.write_event(Event::Start(l)).unwrap();
@@ -473,25 +465,25 @@
                 for condition in conditions {
                     let mut c = BytesStart::from_content(condition_tag, condition_tag.len());
                     c.push_attribute(("number", condition.number.to_string().as_ref()));
                     c.push_attribute(("type", condition.cond_type.to_string().as_ref()));
                     c.push_attribute(("coverage", condition.coverage.to_string().as_ref()));
                     writer.write_event(Event::Empty(c)).unwrap();
                 }
                 writer
                     .write_event(Event::End(BytesEnd::new(conditions_tag)))
                     .unwrap();
-                writer
-                    .write_event(Event::End(BytesEnd::new(line_tag)))
-                    .unwrap();
             }
         }
+        writer
+            .write_event(Event::End(BytesEnd::new(line_tag)))
+            .unwrap();
     }
     writer
         .write_event(Event::End(BytesEnd::new(lines_tag)))
         .unwrap();
 }
 #[cfg(test)]
 mod tests {
     use super::*;
     use crate::{CovResult, Function};
     use std::io::Read;
@@ -630,49 +622,47 @@
     #[test]
     fn test_cobertura() {
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let file_name = "test_cobertura.xml";
         let file_path = tmp_dir.path().join(file_name);
         let results = vec![(
             PathBuf::from("src/main.rs"),
             PathBuf::from("src/main.rs"),
             coverage_result(Result::Main),
         )];
-        for pretty in [false, true] {
-            output_cobertura(None, &results, Some(&file_path), true, pretty);
-            let results = read_file(&file_path);
-            assert!(results.contains(r#"<source>.</source>"#));
-            assert!(results.contains(r#"package name="src/main.rs""#));
-            assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
-            assert!(results.contains(r#"method name="cov_test::main""#));
-            assert!(results.contains(r#"line number="1" hits="1"/>"#));
-            assert!(results.contains(r#"line number="3" hits="2" branch="true""#));
-            assert!(results.contains(r#"<condition number="0" type="jump" coverage="1"/>"#));
-            assert!(results.contains(r#"lines-covered="6""#));
-            assert!(results.contains(r#"lines-valid="8""#));
-            assert!(results.contains(r#"line-rate="0.75""#));
-            assert!(results.contains(r#"branches-covered="1""#));
-            assert!(results.contains(r#"branches-valid="4""#));
-            assert!(results.contains(r#"branch-rate="0.25""#));
-        }
+        output_cobertura(None, &results, Some(&file_path), true);
+        let results = read_file(&file_path);
+        assert!(results.contains(r#"<source>.</source>"#));
+        assert!(results.contains(r#"package name="src/main.rs""#));
+        assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
+        assert!(results.contains(r#"method name="cov_test::main""#));
+        assert!(results.contains(r#"line number="1" hits="1">"#));
+        assert!(results.contains(r#"line number="3" hits="2" branch="true""#));
+        assert!(results.contains(r#"<condition number="0" type="jump" coverage="1"/>"#));
+        assert!(results.contains(r#"lines-covered="6""#));
+        assert!(results.contains(r#"lines-valid="8""#));
+        assert!(results.contains(r#"line-rate="0.75""#));
+        assert!(results.contains(r#"branches-covered="1""#));
+        assert!(results.contains(r#"branches-valid="4""#));
+        assert!(results.contains(r#"branch-rate="0.25""#));
     }
     #[test]
     fn test_cobertura_double_lines() {
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let file_name = "test_cobertura.xml";
         let file_path = tmp_dir.path().join(file_name);
         let results = vec![(
             PathBuf::from("src/main.rs"),
             PathBuf::from("src/main.rs"),
             coverage_result(Result::Test),
         )];
-        output_cobertura(None, &results, Some(file_path.as_ref()), true, true);
+        output_cobertura(None, &results, Some(file_path.as_ref()), true);
         let results = read_file(&file_path);
         assert!(results.contains(r#"<source>.</source>"#));
         assert!(results.contains(r#"package name="src/main.rs""#));
         assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
         assert!(results.contains(r#"method name="cov_test::main""#));
         assert!(results.contains(r#"method name="cov_test::test_fn""#));
         assert!(results.contains(r#"lines-covered="7""#));
         assert!(results.contains(r#"lines-valid="8""#));
         assert!(results.contains(r#"line-rate="0.875""#));
         assert!(results.contains(r#"branches-covered="1""#));
@@ -689,21 +679,21 @@
                 PathBuf::from("src/main.rs"),
                 PathBuf::from("src/main.rs"),
                 coverage_result(Result::Main),
             ),
             (
                 PathBuf::from("src/test.rs"),
                 PathBuf::from("src/test.rs"),
                 coverage_result(Result::Test),
             ),
         ];
-        output_cobertura(None, &results, Some(file_path.as_ref()), true, true);
+        output_cobertura(None, &results, Some(file_path.as_ref()), true);
         let results = read_file(&file_path);
         assert!(results.contains(r#"<source>.</source>"#));
         assert!(results.contains(r#"package name="src/main.rs""#));
         assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
         assert!(results.contains(r#"package name="src/test.rs""#));
         assert!(results.contains(r#"class name="test" filename="src/test.rs""#));
         assert!(results.contains(r#"lines-covered="13""#));
         assert!(results.contains(r#"lines-valid="16""#));
         assert!(results.contains(r#"line-rate="0.8125""#));
         assert!(results.contains(r#"branches-covered="2""#));
@@ -713,37 +703,31 @@
     #[test]
     fn test_cobertura_source_root_none() {
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let file_name = "test_cobertura.xml";
         let file_path = tmp_dir.path().join(file_name);
         let results = vec![(
             PathBuf::from("src/main.rs"),
             PathBuf::from("src/main.rs"),
             CovResult::default(),
         )];
-        output_cobertura(None, &results, Some(&file_path), true, true);
+        output_cobertura(None, &results, Some(&file_path), true);
         let results = read_file(&file_path);
         assert!(results.contains(r#"<source>.</source>"#));
         assert!(results.contains(r#"package name="src/main.rs""#));
     }
     #[test]
     fn test_cobertura_source_root_some() {
         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
         let file_name = "test_cobertura.xml";
         let file_path = tmp_dir.path().join(file_name);
         let results = vec![(
             PathBuf::from("main.rs"),
             PathBuf::from("main.rs"),
             CovResult::default(),
         )];
-        output_cobertura(
-            Some(Path::new("src")),
-            &results,
-            Some(&file_path),
-            true,
-            true,
-        );
+        output_cobertura(Some(Path::new("src")), &results, Some(&file_path), true);
         let results = read_file(&file_path);
         assert!(results.contains(r#"<source>src</source>"#));
         assert!(results.contains(r#"package name="main.rs""#));
     }
 }

--- a/src/covdir.rs
+++ b/src/covdir.rs
@@ -36,24 +36,25 @@
             stats: CDStats::new(total, covered, precision),
             coverage: lines,
         }
     }
     fn get_coverage(coverage: BTreeMap<u32, u64>) -> (usize, usize, Vec<i64>) {
         let mut covered = 0;
         let last_line = *coverage.keys().last().unwrap_or(&0) as usize;
         let total = coverage.len();
         let mut lines: Vec<i64> = vec![-1; last_line];
         for (line_num, line_count) in coverage.iter() {
-            if let Some(line) = lines.get_mut((*line_num - 1) as usize) {
-                *line = *line_count as i64;
-                covered += (*line_count > 0) as usize;
+            let line_count = *line_count;
+            unsafe {
+                *lines.get_unchecked_mut((*line_num - 1) as usize) = line_count as i64;
             }
+            covered += (line_count > 0) as usize;
         }
         (total, covered, lines)
     }
     pub fn to_json(&self) -> serde_json::Value {
         json!({
             "name": self.name,
             "linesTotal": self.stats.total,
             "linesCovered": self.stats.covered,
             "linesMissed": self.stats.missed,
             "coveragePercent": self.stats.percent,

--- a/src/gcov.rs
+++ b/src/gcov.rs
@@ -78,38 +78,37 @@
             if get_gcov_version() >= &min_ver {
                 ".gcov.json.gz"
             } else {
                 ".gcov"
             }
         };
     }
     &E
 }
 fn parse_version(gcov_output: &str) -> Version {
-    let version = gcov_output
-        .split([' ', '\n'])
-        .filter_map(|value| Version::parse(value.trim()).ok())
-        .last();
-    assert!(version.is_some(), "no version found for `gcov`.");
-    version.unwrap()
+    let mut versions: Vec<_> = gcov_output
+        .split(|c| c == ' ' || c == '\n')
+        .filter_map(|value| Version::parse(value).ok())
+        .collect();
+    assert!(!versions.is_empty(), "no version found for `gcov`.");
+    versions.pop().unwrap()
 }
 #[cfg(test)]
 mod tests {
     use super::*;
     #[test]
     fn test_parse_version() {
         assert_eq!(
             parse_version("gcov (Ubuntu 4.3.0-12ubuntu2) 4.3.0 20170406"),
             Version::new(4, 3, 0)
         );
         assert_eq!(
             parse_version("gcov (Ubuntu 4.9.0-12ubuntu2) 4.9.0 20170406"),
             Version::new(4, 9, 0)
         );
         assert_eq!(
             parse_version("gcov (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406"),
             Version::new(6, 3, 0)
         );
         assert_eq!(parse_version("gcov (GCC) 12.2.0"), Version::new(12, 2, 0));
-        assert_eq!(parse_version("gcov (GCC) 12.2.0\r"), Version::new(12, 2, 0));
     }
 }

--- a/src/lib.rs
+++ b/src/lib.rs
@@ -15,39 +15,40 @@
 mod symlink;
 mod path_rewriting;
 pub use crate::path_rewriting::*;
 mod output;
 pub use crate::output::*;
 mod cobertura;
 pub use crate::cobertura::*;
 mod reader;
 pub use crate::reader::*;
 mod covdir;
+pub use crate::covdir::*;
 pub mod html;
 mod file_filter;
 pub use crate::file_filter::*;
 use log::{error, warn};
 use std::fs;
 use std::io::{BufReader, Cursor};
 use std::{
     collections::{btree_map, hash_map},
     path::Path,
 };
 use walkdir::WalkDir;
 pub fn merge_results(result: &mut CovResult, result2: CovResult) -> bool {
     let mut warn_overflow = false;
     for (&line_no, &execution_count) in &result2.lines {
         match result.lines.entry(line_no) {
             btree_map::Entry::Occupied(c) => {
                 let v = c.get().checked_add(execution_count).unwrap_or_else(|| {
                     warn_overflow = true;
-                    u64::MAX
+                    std::u64::MAX
                 });
                 *c.into_mut() = v;
             }
             btree_map::Entry::Vacant(v) => {
                 v.insert(execution_count);
             }
         };
     }
     for (line_no, taken) in result2.branches {
         match result.branches.entry(line_no) {
@@ -105,21 +106,21 @@
         };
     }
     if warn_overflow {
         warn!("Execution count overflow detected.");
     }
 }
 fn rename_single_files(results: &mut [(String, CovResult)], stem: &str) {
     if let Some(parent) = Path::new(stem).parent() {
         for (file, _) in results.iter_mut() {
             if has_no_parent(file) {
-                *file = parent.join(file.as_str()).to_str().unwrap().to_string();
+                *file = parent.join(&file).to_str().unwrap().to_string();
             }
         }
     }
 }
 #[derive(PartialEq, Eq)]
 enum GcovType {
     Unknown,
     SingleFile,
     MultipleFiles,
 }

--- a/src/llvm_tools.rs
+++ b/src/llvm_tools.rs
@@ -1,15 +1,14 @@
+use cargo_binutils::Tool;
 use once_cell::sync::OnceCell;
 use rayon::prelude::{IntoParallelIterator, ParallelIterator};
-use std::env;
 use std::env::consts::EXE_SUFFIX;
-use std::error::Error;
 use std::ffi::OsStr;
 use std::fs;
 use std::io::Write;
 use std::path::{Path, PathBuf};
 use std::process::{Command, Stdio};
 use log::warn;
 use walkdir::WalkDir;
 pub static LLVM_PATH: OnceCell<PathBuf> = OnceCell::new();
 pub fn is_binary(path: impl AsRef<Path>) -> bool {
     if let Ok(oty) = infer::get_from_path(path) {
@@ -116,58 +115,39 @@
                         "Suppressing error returned by llvm-cov tool for binary {:?}\n{}",
                         binary, err_str
                     );
                     None
                 }
             }
         })
         .collect::<Vec<_>>();
     Ok(results)
 }
-fn sysroot() -> Result<String, Box<dyn Error>> {
-    let rustc = env::var_os("RUSTC").unwrap_or_else(|| "rustc".into());
-    let output = Command::new(rustc).arg("--print").arg("sysroot").output()?;
-    Ok(String::from_utf8(output.stdout)?.trim().to_owned())
-}
-fn rustlib() -> Result<PathBuf, Box<dyn Error>> {
-    let sysroot = sysroot()?;
-    let mut pathbuf = PathBuf::from(sysroot);
-    pathbuf.push("lib");
-    pathbuf.push("rustlib");
-    pathbuf.push(rustc_version::version_meta()?.host); // TODO: Prevent calling rustc_version::version_meta() multiple times
-    pathbuf.push("bin");
-    Ok(pathbuf)
-}
-fn llvm_tool_path(name: &str) -> Result<PathBuf, Box<dyn Error>> {
-    let mut path = rustlib()?;
-    path.push(format!("llvm-{}{}", name, EXE_SUFFIX));
-    Ok(path)
-}
 fn get_profdata_path() -> Result<PathBuf, String> {
     let path = if let Some(mut path) = LLVM_PATH.get().cloned() {
         path.push(format!("llvm-profdata{}", EXE_SUFFIX));
         path
     } else {
-        llvm_tool_path("profdata").map_err(|x| x.to_string())?
+        Tool::Profdata.path().map_err(|x| x.to_string())?
     };
     if !path.exists() {
         Err(String::from("We couldn't find llvm-profdata. Try installing the llvm-tools component with `rustup component add llvm-tools-preview` or specifying the --llvm-path option."))
     } else {
         Ok(path)
     }
 }
 fn get_cov_path() -> Result<PathBuf, String> {
     let path = if let Some(mut path) = LLVM_PATH.get().cloned() {
         path.push(format!("llvm-cov{}", EXE_SUFFIX));
         path
     } else {
-        llvm_tool_path("cov").map_err(|x| x.to_string())?
+        Tool::Cov.path().map_err(|x| x.to_string())?
     };
     if !path.exists() {
         Err(String::from("We couldn't find llvm-cov. Try installing the llvm-tools component with `rustup component add llvm-tools-preview` or specifying the --llvm-path option."))
     } else {
         Ok(path)
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
@@ -223,54 +203,37 @@
             &tmp_path,
         );
         assert!(lcovs.is_ok());
         let lcovs = lcovs.unwrap();
         assert_eq!(lcovs.len(), 1);
         let output_lcov = String::from_utf8_lossy(&lcovs[0]);
         println!("{}", output_lcov);
         assert!(output_lcov
             .lines()
             .any(|line| line.contains("SF") && line.contains("src") && line.contains("main.rs")));
-        if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
-            assert!(output_lcov.lines().any(|line| line.contains("FN:3")
-                && line.contains("rust_code_coverage_sample")
-                && line.contains("Ciao")));
-        }
+        assert!(output_lcov.lines().any(|line| line.contains("FN:3")
+            && line.contains("rust_code_coverage_sample")
+            && line.contains("Ciao")));
         assert!(output_lcov.lines().any(|line| line.contains("FN:8")
             && line.contains("rust_code_coverage_sample")
             && line.contains("main")));
-        if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
-            assert!(output_lcov.lines().any(|line| line.contains("FNDA:0")
-                && line.contains("rust_code_coverage_sample")
-                && line.contains("Ciao")));
-        } else {
-            assert!(output_lcov.lines().any(|line| line.contains("FNDA:1")
-                && line.contains("rust_code_coverage_sample")
-                && line.contains("main")));
-        }
+        assert!(output_lcov.lines().any(|line| line.contains("FNDA:0")
+            && line.contains("rust_code_coverage_sample")
+            && line.contains("Ciao")));
         assert!(output_lcov.lines().any(|line| line.contains("FNDA:1")
             && line.contains("rust_code_coverage_sample")
             && line.contains("main")));
-        if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
-            assert!(output_lcov.lines().any(|line| line == "FNF:2"));
-        }
+        assert!(output_lcov.lines().any(|line| line == "FNF:2"));
         assert!(output_lcov.lines().any(|line| line == "FNH:1"));
-        if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
-            assert!(output_lcov.lines().any(|line| line == "DA:3,0"));
-        }
+        assert!(output_lcov.lines().any(|line| line == "DA:3,0"));
         assert!(output_lcov.lines().any(|line| line == "DA:8,1"));
         assert!(output_lcov.lines().any(|line| line == "DA:9,1"));
         assert!(output_lcov.lines().any(|line| line == "DA:10,1"));
         assert!(output_lcov.lines().any(|line| line == "DA:11,1"));
         assert!(output_lcov.lines().any(|line| line == "DA:12,1"));
         assert!(output_lcov.lines().any(|line| line == "BRF:0"));
         assert!(output_lcov.lines().any(|line| line == "BRH:0"));
-        if rustc_version::version_meta().unwrap().channel == rustc_version::Channel::Nightly {
-            assert!(output_lcov.lines().any(|line| line == "LF:5"));
-            assert!(output_lcov.lines().any(|line| line == "LH:5"));
-        } else {
-            assert!(output_lcov.lines().any(|line| line == "LF:6"));
-            assert!(output_lcov.lines().any(|line| line == "LH:5"));
-        }
+        assert!(output_lcov.lines().any(|line| line == "LF:6"));
+        assert!(output_lcov.lines().any(|line| line == "LH:5"));
         assert!(output_lcov.lines().any(|line| line == "end_of_record"));
     }
 }

--- a/src/main.rs
+++ b/src/main.rs
@@ -9,66 +9,62 @@
 use serde_json::Value;
 use simplelog::{ColorChoice, Config, LevelFilter, TermLogger, TerminalMode, WriteLogger};
 use std::fs::{self, File};
 use std::ops::Deref;
 use std::panic;
 use std::path::{Path, PathBuf};
 use std::str::FromStr;
 use std::sync::{Arc, Mutex};
 use std::{process, thread};
 use grcov::*;
-#[derive(Clone, PartialEq)]
+#[derive(Clone)]
 enum OutputType {
     Ade,
     Lcov,
     Coveralls,
     CoverallsPlus,
     Files,
     Covdir,
     Html,
     Cobertura,
-    CoberturaPretty,
     Markdown,
 }
 impl FromStr for OutputType {
     type Err = String;
     fn from_str(s: &str) -> Result<Self, Self::Err> {
         Ok(match s {
             "ade" => Self::Ade,
             "lcov" => Self::Lcov,
             "coveralls" => Self::Coveralls,
             "coveralls+" => Self::CoverallsPlus,
             "files" => Self::Files,
             "covdir" => Self::Covdir,
             "html" => Self::Html,
             "cobertura" => Self::Cobertura,
-            "cobertura-pretty" => Self::CoberturaPretty,
             "markdown" => Self::Markdown,
             _ => return Err(format!("{} is not a supported output type", s)),
         })
     }
 }
 impl OutputType {
     fn to_file_name(&self, output_path: Option<&Path>) -> Option<PathBuf> {
         output_path.map(|path| {
             if path.is_dir() {
                 match self {
                     OutputType::Ade => path.join("activedata"),
                     OutputType::Lcov => path.join("lcov"),
                     OutputType::Coveralls => path.join("coveralls"),
                     OutputType::CoverallsPlus => path.join("coveralls+"),
                     OutputType::Files => path.join("files"),
                     OutputType::Covdir => path.join("covdir"),
                     OutputType::Html => path.join("html"),
-                    OutputType::Cobertura | OutputType::CoberturaPretty => {
-                        path.join("cobertura.xml")
-                    }
+                    OutputType::Cobertura => path.join("cobertura.xml"),
                     OutputType::Markdown => path.join("markdown.md"),
                 }
             } else {
                 path.to_path_buf()
             }
         })
     }
 }
 #[derive(clap::ValueEnum, Clone)]
 enum Filter {
@@ -139,21 +135,20 @@
             Comma separated list of custom output types:\n\
             - *html* for a HTML coverage report;\n\
             - *coveralls* for the Coveralls specific format;\n\
             - *lcov* for the lcov INFO format;\n\
             - *covdir* for the covdir recursive JSON format;\n\
             - *coveralls+* for the Coveralls specific format with function information;\n\
             - *ade* for the ActiveData-ETL specific format;\n\
             - *files* to only return a list of files.\n\
             - *markdown* for human easy read.\n\
             - *cobertura* for output in cobertura format.\n\
-            - *cobertura-pretty* to pretty-print in cobertura format.\n\
         ",
         value_name = "OUTPUT TYPE",
         requires_ifs = [
             ("coveralls", "coveralls-auth"),
             ("coveralls+", "coveralls-auth"),
         ],
         value_delimiter = ',',
         alias = "output-type",
         default_value = "lcov",
     )]
@@ -171,28 +166,20 @@
     #[arg(long = "ignore", value_name = "PATH", num_args = 1)]
     ignore_dir: Vec<String>,
     #[arg(long = "keep-only", value_name = "PATH", num_args = 1)]
     keep_dir: Vec<String>,
     #[arg(long, value_name = "PATH")]
     path_mapping: Option<PathBuf>,
     #[arg(long)]
     branch: bool,
     #[arg(long, value_enum)]
     filter: Option<Filter>,
-    #[arg(
-        long,
-        value_name = "OUTPUT TYPES",
-        value_delimiter = ',',
-        alias = "sort-output-types",
-        default_value = "markdown"
-    )]
-    sort_output_types: Vec<OutputType>,
     #[arg(long)]
     llvm: bool,
     #[arg(long, value_name = "TOKEN")]
     token: Option<String>,
     #[arg(long, value_name = "COMMIT HASH")]
     commit_sha: Option<String>,
     #[arg(long, value_name = "SERVICE NAME")]
     service_name: Option<String>,
     #[arg(long, value_name = "SERVICE NUMBER")]
     service_number: Option<String>,
@@ -390,109 +377,92 @@
         result_map,
         path_mapping,
         source_root.as_deref(),
         prefix_dir.as_deref(),
         opt.ignore_not_existing,
         &opt.ignore_dir,
         &opt.keep_dir,
         filter_option,
         file_filter,
     );
-    let mut sorted_iterator: Option<Vec<ResultTuple>> = None;
     let service_number = opt.service_number.unwrap_or_default();
     let service_pull_request = opt.service_pull_request.unwrap_or_default();
     let commit_sha = opt.commit_sha.unwrap_or_default();
     let output_types = opt.output_types;
     let output_path = match output_types.len() {
         0 => unreachable!("Output types has a default value"),
         1 => opt.output_path.as_deref(),
         _ => match opt.output_path.as_deref() {
             Some(output_path) => {
                 if output_path.is_dir() {
                     Some(output_path)
                 } else {
                     panic!("output_path must be a directory when using multiple outputs");
                 }
             }
             _ => None,
         },
     };
     for output_type in &output_types {
         let output_path = output_type.to_file_name(output_path);
-        let results = if opt.sort_output_types.contains(output_type) {
-            sorted_iterator = sorted_iterator.or_else(|| {
-                let mut results = iterator.clone();
-                results.sort_by_key(|result| result.0.display().to_string());
-                Some(results)
-            });
-            sorted_iterator.as_ref().unwrap()
-        } else {
-            &iterator
-        };
         match output_type {
-            OutputType::Ade => output_activedata_etl(results, output_path.as_deref(), demangle),
-            OutputType::Lcov => output_lcov(results, output_path.as_deref(), demangle),
+            OutputType::Ade => output_activedata_etl(&iterator, output_path.as_deref(), demangle),
+            OutputType::Lcov => output_lcov(&iterator, output_path.as_deref(), demangle),
             OutputType::Coveralls => output_coveralls(
-                results,
+                &iterator,
                 opt.token.as_deref(),
                 opt.service_name.as_deref(),
                 &service_number,
                 opt.service_job_id.as_deref(),
                 &service_pull_request,
                 opt.service_flag_name.as_deref(),
                 &commit_sha,
                 false,
                 output_path.as_deref(),
                 &opt.vcs_branch,
                 opt.parallel,
                 demangle,
             ),
             OutputType::CoverallsPlus => output_coveralls(
-                results,
+                &iterator,
                 opt.token.as_deref(),
                 opt.service_name.as_deref(),
                 &service_number,
                 opt.service_job_id.as_deref(),
                 &service_pull_request,
                 opt.service_flag_name.as_deref(),
                 &commit_sha,
                 true,
                 output_path.as_deref(),
                 &opt.vcs_branch,
                 opt.parallel,
                 demangle,
             ),
-            OutputType::Files => output_files(results, output_path.as_deref()),
-            OutputType::Covdir => output_covdir(results, output_path.as_deref(), opt.precision),
+            OutputType::Files => output_files(&iterator, output_path.as_deref()),
+            OutputType::Covdir => output_covdir(&iterator, output_path.as_deref(), opt.precision),
             OutputType::Html => output_html(
-                results,
+                &iterator,
                 output_path.as_deref(),
                 num_threads,
                 opt.branch,
                 opt.output_config_file.as_deref(),
                 opt.precision,
             ),
             OutputType::Cobertura => output_cobertura(
                 source_root.as_deref(),
-                results,
+                &iterator,
                 output_path.as_deref(),
                 demangle,
-                false,
             ),
-            OutputType::CoberturaPretty => output_cobertura(
-                source_root.as_deref(),
-                results,
-                output_path.as_deref(),
-                demangle,
-                true,
-            ),
-            OutputType::Markdown => output_markdown(results, output_path.as_deref(), opt.precision),
+            OutputType::Markdown => {
+                output_markdown(&iterator, output_path.as_deref(), opt.precision)
+            }
         };
     }
 }
 #[cfg(test)]
 mod tests {
     use super::*;
     use clap::CommandFactory;
     #[test]
     fn clap_debug_assert() {
         Opt::command().debug_assert();

--- a/src/parser.rs
+++ b/src/parser.rs
@@ -491,21 +491,21 @@
     Ok(results)
 }
 fn get_xml_attribute<R: BufRead>(
     reader: &Reader<R>,
     event: &BytesStart<'_>,
     name: &str,
 ) -> Result<String, ParserError> {
     for a in event.attributes() {
         let a = a?;
         if a.key.into_inner() == name.as_bytes() {
-            return Ok(a.decode_and_unescape_value(reader.decoder())?.into_owned());
+            return Ok(a.decode_and_unescape_value(reader)?.into_owned());
         }
     }
     Err(ParserError::InvalidRecord(format!(
         "Attribute {} not found",
         name
     )))
 }
 fn parse_jacoco_report_sourcefile<T: BufRead>(
     parser: &mut Reader<T>,
     buf: &mut Vec<u8>,
@@ -677,23 +677,21 @@
                     .to_string(),
                 result,
             )
         })
         .collect())
 }
 pub fn parse_jacoco_xml_report<T: Read>(
     xml_reader: BufReader<T>,
 ) -> Result<Vec<(String, CovResult)>, ParserError> {
     let mut parser = Reader::from_reader(xml_reader);
-    let config = parser.config_mut();
-    config.expand_empty_elements = true;
-    config.trim_text(false);
+    parser.expand_empty_elements(true).trim_text(false);
     let mut results = Vec::new();
     let mut buf = Vec::new();
     loop {
         match parser.read_event_into(&mut buf) {
             Ok(Event::Start(ref e)) if e.local_name().into_inner() == b"package" => {
                 let package = get_xml_attribute(&parser, e, "name")?;
                 let mut package_results =
                     parse_jacoco_report_package(&mut parser, &mut buf, &package)?;
                 results.append(&mut package_results);
             }

--- a/src/reader.rs
+++ b/src/reader.rs
@@ -862,21 +862,21 @@
         }
         let mut r = Vec::with_capacity(results.len());
         for (k, v) in results.drain() {
             r.push((k.to_string(), v));
         }
         r
     }
 }
 impl GcovFunction {
     fn get_cycle_count(edges: &mut [GcovEdge], path: &[usize]) -> u64 {
-        let mut count = u64::MAX;
+        let mut count = std::u64::MAX;
         for e in path.iter() {
             count = cmp::min(count, edges[*e].cycles);
         }
         for e in path {
             edges[*e].cycles -= count;
         }
         count
     }
     fn unblock(
         block: usize,
