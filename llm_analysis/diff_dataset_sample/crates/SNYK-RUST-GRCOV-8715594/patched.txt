# ====================================================================
# FILE: benches/output.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 43-77 ---
    43|         .collect::<Vec<_>>()
    44| }
    45| #[bench]
    46| fn bench_output_activedata_etl(b: &mut Bencher) {
    47|     let dir = tempdir().unwrap();
    48|     b.iter(|| {
    49|         black_box(output_activedata_etl(
    50|             &generate_cov_result_iter(),
    51|             Some(&dir.path().join("temp")),
    52|             false,
    53|         ))
    54|     });
    55| }
    56| #[bench]
    57| fn bench_output_covdir(b: &mut Bencher) {
    58|     let dir = tempdir().unwrap();
    59|     b.iter(|| {
    60|         black_box(output_covdir(
    61|             &generate_cov_result_iter(),
    62|             Some(&dir.path().join("temp")),
    63|             2,
    64|         ));
    65|     });
    66| }
    67| #[bench]
    68| fn bench_output_lcov(b: &mut Bencher) {
    69|     let dir = tempdir().unwrap();
    70|     b.iter(|| {
    71|         black_box(output_lcov(
    72|             &generate_cov_result_iter(),
    73|             Some(&dir.path().join("temp")),
    74|             false,
    75|         ));
    76|     });
    77| }


# ====================================================================
# FILE: benches/parser.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-27 ---
     4| use std::fs::File;
     5| use std::io::BufReader;
     6| use std::path::Path;
     7| use test::{black_box, Bencher};
     8| #[bench]
     9| fn bench_parser_lcov(b: &mut Bencher) {
    10|     b.iter(|| {
    11|         let file = std::fs::read("./test/prova.info").expect("Failed to open lcov file");
    12|         black_box(grcov::parse_lcov(file, true).unwrap());
    13|     });
    14| }
    15| #[bench]
    16| fn bench_parser_gcov(b: &mut Bencher) {
    17|     let path = Path::new("./test/negative_counts.gcov");
    18|     b.iter(|| black_box(grcov::parse_gcov(path)));
    19| }
    20| #[bench]
    21| fn bench_parser_jacoco(b: &mut Bencher) {
    22|     let path = Path::new("./test/jacoco/full-junit4-report-multiple-top-level-classes.xml");
    23|     b.iter(|| {
    24|         let file = BufReader::new(File::open(path).unwrap());
    25|         black_box(grcov::parse_jacoco_xml_report(file))
    26|     });
    27| }


# ====================================================================
# FILE: src/cobertura.rs
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| use crate::defs::*;
     2| use quick_xml::{
     3|     events::{BytesDecl, BytesEnd, BytesStart, BytesText, Event},
     4|     Writer,
     5| };
     6| use rustc_hash::FxHashMap;
     7| use std::time::{SystemTime, UNIX_EPOCH};
     8| use std::{
     9|     fmt::Display,
    10|     io::{BufWriter, Cursor, Write},
    11| };
    12| use std::{fmt::Formatter, path::Path};
    13| use symbolic_common::Name;
    14| use symbolic_demangle::{Demangle, DemangleOptions};
    15| use crate::output::get_target_output_writable;
    16| macro_rules! demangle {
    17|     ($name: expr, $demangle: expr, $options: expr) => {{
    18|         if $demangle {
    19|             Name::from($name)
    20|                 .demangle($options)
    21|                 .unwrap_or_else(|| $name.clone())
    22|         } else {
    23|             $name.clone()
    24|         }
    25|     }};
    26| }
    27| struct Coverage {
    28|     sources: Vec<String>,
    29|     packages: Vec<Package>,
    30| }
    31| #[derive(Default)]
    32| struct CoverageStats {

# --- HUNK 2: Lines 173-216 ---
   173|         matches!(self, Line::Plain { hits, .. } | Line::Branch { hits, .. } if *hits > 0)
   174|     }
   175| }
   176| impl Stats for Line {
   177|     fn get_lines(&self) -> FxHashMap<u32, Line> {
   178|         let mut lines = FxHashMap::default();
   179|         lines.insert(self.number(), self.clone());
   180|         lines
   181|     }
   182| }
   183| #[derive(Debug, Clone)]
   184| struct Condition {
   185|     number: usize,
   186|     cond_type: ConditionType,
   187|     coverage: f64,
   188| }
   189| #[derive(Debug, Clone)]
   190| enum ConditionType {
   191|     Jump,
   192| }
   193| impl Display for ConditionType {
   194|     fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
   195|         match self {
   196|             Self::Jump => write!(f, "jump"),
   197|         }
   198|     }
   199| }
   200| fn get_coverage(
   201|     results: &[ResultTuple],
   202|     sources: Vec<String>,
   203|     demangle: bool,
   204|     demangle_options: DemangleOptions,
   205| ) -> Coverage {
   206|     let packages: Vec<Package> = results
   207|         .iter()
   208|         .map(|(_, rel_path, result)| {
   209|             let all_lines: Vec<u32> = result.lines.keys().cloned().collect();
   210|             let end: u32 = result.lines.keys().last().unwrap_or(&0) + 1;
   211|             let mut start_indexes: Vec<u32> = Vec::new();
   212|             for function in result.functions.values() {
   213|                 start_indexes.push(function.start);
   214|             }
   215|             start_indexes.sort_unstable();
   216|             let line_from_number = |number| {

# --- HUNK 3: Lines 270-322 ---
   270|                     .map(|x| x.to_str().unwrap())
   271|                     .unwrap_or_default()
   272|                     .to_string(),
   273|                 file_name: rel_path.to_str().unwrap_or_default().to_string(),
   274|                 lines,
   275|                 methods,
   276|             };
   277|             Package {
   278|                 name: rel_path.to_str().unwrap_or_default().to_string(),
   279|                 classes: vec![class],
   280|             }
   281|         })
   282|         .collect();
   283|     Coverage { sources, packages }
   284| }
   285| pub fn output_cobertura(
   286|     source_dir: Option<&Path>,
   287|     results: &[ResultTuple],
   288|     output_file: Option<&Path>,
   289|     demangle: bool,
   290|     pretty: bool,
   291| ) {
   292|     let demangle_options = DemangleOptions::name_only();
   293|     let sources = vec![source_dir
   294|         .unwrap_or_else(|| Path::new("."))
   295|         .display()
   296|         .to_string()];
   297|     let coverage = get_coverage(results, sources, demangle, demangle_options);
   298|     let mut writer = if pretty {
   299|         Writer::new_with_indent(Cursor::new(vec![]), b' ', 4)
   300|     } else {
   301|         Writer::new(Cursor::new(vec![]))
   302|     };
   303|     writer
   304|         .write_event(Event::Decl(BytesDecl::new("1.0", None, None)))
   305|         .unwrap();
   306|     writer
   307|         .write_event(Event::DocType(BytesText::from_escaped(
   308|             " coverage SYSTEM 'http://cobertura.sourceforge.net/xml/coverage-04.dtd'",
   309|         )))
   310|         .unwrap();
   311|     let cov_tag = "coverage";
   312|     let mut cov = BytesStart::from_content(cov_tag, cov_tag.len());
   313|     let stats = coverage.get_stats();
   314|     cov.push_attribute(("lines-covered", stats.lines_covered.to_string().as_ref()));
   315|     cov.push_attribute(("lines-valid", stats.lines_valid.to_string().as_ref()));
   316|     cov.push_attribute(("line-rate", stats.line_rate().to_string().as_ref()));
   317|     cov.push_attribute((
   318|         "branches-covered",
   319|         stats.branches_covered.to_string().as_ref(),
   320|     ));
   321|     cov.push_attribute(("branches-valid", stats.branches_valid.to_string().as_ref()));
   322|     cov.push_attribute(("branch-rate", stats.branch_rate().to_string().as_ref()));

# --- HUNK 4: Lines 434-507 ---
   434|     file.write_all(&result).unwrap();
   435| }
   436| fn write_lines(writer: &mut Writer<Cursor<Vec<u8>>>, lines: &[Line]) {
   437|     let lines_tag = "lines";
   438|     let line_tag = "line";
   439|     writer
   440|         .write_event(Event::Start(BytesStart::from_content(
   441|             lines_tag,
   442|             lines_tag.len(),
   443|         )))
   444|         .unwrap();
   445|     for line in lines {
   446|         let mut l = BytesStart::from_content(line_tag, line_tag.len());
   447|         match line {
   448|             Line::Plain {
   449|                 ref number,
   450|                 ref hits,
   451|             } => {
   452|                 l.push_attribute(("number", number.to_string().as_ref()));
   453|                 l.push_attribute(("hits", hits.to_string().as_ref()));
   454|                 writer.write_event(Event::Empty(l)).unwrap();
   455|             }
   456|             Line::Branch {
   457|                 ref number,
   458|                 ref hits,
   459|                 conditions,
   460|             } => {
   461|                 l.push_attribute(("number", number.to_string().as_ref()));
   462|                 l.push_attribute(("hits", hits.to_string().as_ref()));
   463|                 l.push_attribute(("branch", "true"));
   464|                 writer.write_event(Event::Start(l)).unwrap();
   465|                 let conditions_tag = "conditions";
   466|                 let condition_tag = "condition";
   467|                 writer
   468|                     .write_event(Event::Start(BytesStart::from_content(
   469|                         conditions_tag,
   470|                         conditions_tag.len(),
   471|                     )))
   472|                     .unwrap();
   473|                 for condition in conditions {
   474|                     let mut c = BytesStart::from_content(condition_tag, condition_tag.len());
   475|                     c.push_attribute(("number", condition.number.to_string().as_ref()));
   476|                     c.push_attribute(("type", condition.cond_type.to_string().as_ref()));
   477|                     c.push_attribute(("coverage", condition.coverage.to_string().as_ref()));
   478|                     writer.write_event(Event::Empty(c)).unwrap();
   479|                 }
   480|                 writer
   481|                     .write_event(Event::End(BytesEnd::new(conditions_tag)))
   482|                     .unwrap();
   483|                 writer
   484|                     .write_event(Event::End(BytesEnd::new(line_tag)))
   485|                     .unwrap();
   486|             }
   487|         }
   488|     }
   489|     writer
   490|         .write_event(Event::End(BytesEnd::new(lines_tag)))
   491|         .unwrap();
   492| }
   493| #[cfg(test)]
   494| mod tests {
   495|     use super::*;
   496|     use crate::{CovResult, Function};
   497|     use std::io::Read;
   498|     use std::{collections::BTreeMap, path::PathBuf};
   499|     use std::{fs::File, path::Path};
   500|     enum Result {
   501|         Main,
   502|         Test,
   503|     }
   504|     fn coverage_result(which: Result) -> CovResult {
   505|         match which {
   506|             Result::Main => CovResult {
   507|                 /* main.rs

# --- HUNK 5: Lines 620-749 ---
   620|             },
   621|         }
   622|     }
   623|     fn read_file(path: &Path) -> String {
   624|         let mut f =
   625|             File::open(path).unwrap_or_else(|_| panic!("{:?} file not found", path.file_name()));
   626|         let mut s = String::new();
   627|         f.read_to_string(&mut s).unwrap();
   628|         s
   629|     }
   630|     #[test]
   631|     fn test_cobertura() {
   632|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   633|         let file_name = "test_cobertura.xml";
   634|         let file_path = tmp_dir.path().join(file_name);
   635|         let results = vec![(
   636|             PathBuf::from("src/main.rs"),
   637|             PathBuf::from("src/main.rs"),
   638|             coverage_result(Result::Main),
   639|         )];
   640|         for pretty in [false, true] {
   641|             output_cobertura(None, &results, Some(&file_path), true, pretty);
   642|             let results = read_file(&file_path);
   643|             assert!(results.contains(r#"<source>.</source>"#));
   644|             assert!(results.contains(r#"package name="src/main.rs""#));
   645|             assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
   646|             assert!(results.contains(r#"method name="cov_test::main""#));
   647|             assert!(results.contains(r#"line number="1" hits="1"/>"#));
   648|             assert!(results.contains(r#"line number="3" hits="2" branch="true""#));
   649|             assert!(results.contains(r#"<condition number="0" type="jump" coverage="1"/>"#));
   650|             assert!(results.contains(r#"lines-covered="6""#));
   651|             assert!(results.contains(r#"lines-valid="8""#));
   652|             assert!(results.contains(r#"line-rate="0.75""#));
   653|             assert!(results.contains(r#"branches-covered="1""#));
   654|             assert!(results.contains(r#"branches-valid="4""#));
   655|             assert!(results.contains(r#"branch-rate="0.25""#));
   656|         }
   657|     }
   658|     #[test]
   659|     fn test_cobertura_double_lines() {
   660|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   661|         let file_name = "test_cobertura.xml";
   662|         let file_path = tmp_dir.path().join(file_name);
   663|         let results = vec![(
   664|             PathBuf::from("src/main.rs"),
   665|             PathBuf::from("src/main.rs"),
   666|             coverage_result(Result::Test),
   667|         )];
   668|         output_cobertura(None, &results, Some(file_path.as_ref()), true, true);
   669|         let results = read_file(&file_path);
   670|         assert!(results.contains(r#"<source>.</source>"#));
   671|         assert!(results.contains(r#"package name="src/main.rs""#));
   672|         assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
   673|         assert!(results.contains(r#"method name="cov_test::main""#));
   674|         assert!(results.contains(r#"method name="cov_test::test_fn""#));
   675|         assert!(results.contains(r#"lines-covered="7""#));
   676|         assert!(results.contains(r#"lines-valid="8""#));
   677|         assert!(results.contains(r#"line-rate="0.875""#));
   678|         assert!(results.contains(r#"branches-covered="1""#));
   679|         assert!(results.contains(r#"branches-valid="2""#));
   680|         assert!(results.contains(r#"branch-rate="0.5""#));
   681|     }
   682|     #[test]
   683|     fn test_cobertura_multiple_files() {
   684|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   685|         let file_name = "test_cobertura.xml";
   686|         let file_path = tmp_dir.path().join(file_name);
   687|         let results = vec![
   688|             (
   689|                 PathBuf::from("src/main.rs"),
   690|                 PathBuf::from("src/main.rs"),
   691|                 coverage_result(Result::Main),
   692|             ),
   693|             (
   694|                 PathBuf::from("src/test.rs"),
   695|                 PathBuf::from("src/test.rs"),
   696|                 coverage_result(Result::Test),
   697|             ),
   698|         ];
   699|         output_cobertura(None, &results, Some(file_path.as_ref()), true, true);
   700|         let results = read_file(&file_path);
   701|         assert!(results.contains(r#"<source>.</source>"#));
   702|         assert!(results.contains(r#"package name="src/main.rs""#));
   703|         assert!(results.contains(r#"class name="main" filename="src/main.rs""#));
   704|         assert!(results.contains(r#"package name="src/test.rs""#));
   705|         assert!(results.contains(r#"class name="test" filename="src/test.rs""#));
   706|         assert!(results.contains(r#"lines-covered="13""#));
   707|         assert!(results.contains(r#"lines-valid="16""#));
   708|         assert!(results.contains(r#"line-rate="0.8125""#));
   709|         assert!(results.contains(r#"branches-covered="2""#));
   710|         assert!(results.contains(r#"branches-valid="6""#));
   711|         assert!(results.contains(r#"branch-rate="0.3333333333333333""#));
   712|     }
   713|     #[test]
   714|     fn test_cobertura_source_root_none() {
   715|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   716|         let file_name = "test_cobertura.xml";
   717|         let file_path = tmp_dir.path().join(file_name);
   718|         let results = vec![(
   719|             PathBuf::from("src/main.rs"),
   720|             PathBuf::from("src/main.rs"),
   721|             CovResult::default(),
   722|         )];
   723|         output_cobertura(None, &results, Some(&file_path), true, true);
   724|         let results = read_file(&file_path);
   725|         assert!(results.contains(r#"<source>.</source>"#));
   726|         assert!(results.contains(r#"package name="src/main.rs""#));
   727|     }
   728|     #[test]
   729|     fn test_cobertura_source_root_some() {
   730|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   731|         let file_name = "test_cobertura.xml";
   732|         let file_path = tmp_dir.path().join(file_name);
   733|         let results = vec![(
   734|             PathBuf::from("main.rs"),
   735|             PathBuf::from("main.rs"),
   736|             CovResult::default(),
   737|         )];
   738|         output_cobertura(
   739|             Some(Path::new("src")),
   740|             &results,
   741|             Some(&file_path),
   742|             true,
   743|             true,
   744|         );
   745|         let results = read_file(&file_path);
   746|         assert!(results.contains(r#"<source>src</source>"#));
   747|         assert!(results.contains(r#"package name="main.rs""#));
   748|     }
   749| }


# ====================================================================
# FILE: src/covdir.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 26-69 ---
    26|         } else {
    27|             0.0
    28|         }
    29|     }
    30| }
    31| impl CDFileStats {
    32|     pub fn new(name: String, coverage: BTreeMap<u32, u64>, precision: usize) -> Self {
    33|         let (total, covered, lines) = Self::get_coverage(coverage);
    34|         Self {
    35|             name,
    36|             stats: CDStats::new(total, covered, precision),
    37|             coverage: lines,
    38|         }
    39|     }
    40|     fn get_coverage(coverage: BTreeMap<u32, u64>) -> (usize, usize, Vec<i64>) {
    41|         let mut covered = 0;
    42|         let last_line = *coverage.keys().last().unwrap_or(&0) as usize;
    43|         let total = coverage.len();
    44|         let mut lines: Vec<i64> = vec![-1; last_line];
    45|         for (line_num, line_count) in coverage.iter() {
    46|             if let Some(line) = lines.get_mut((*line_num - 1) as usize) {
    47|                 *line = *line_count as i64;
    48|                 covered += (*line_count > 0) as usize;
    49|             }
    50|         }
    51|         (total, covered, lines)
    52|     }
    53|     pub fn to_json(&self) -> serde_json::Value {
    54|         json!({
    55|             "name": self.name,
    56|             "linesTotal": self.stats.total,
    57|             "linesCovered": self.stats.covered,
    58|             "linesMissed": self.stats.missed,
    59|             "coveragePercent": self.stats.percent,
    60|             "coverage": self.coverage,
    61|         })
    62|     }
    63| }
    64| impl CDDirStats {
    65|     pub fn new(name: String) -> Self {
    66|         Self {
    67|             name,
    68|             files: Vec::new(),
    69|             dirs: Vec::new(),


# ====================================================================
# FILE: src/gcov.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 68-115 ---
    68|             let output = String::from_utf8(output.stdout).unwrap();
    69|             parse_version(&output)
    70|         };
    71|     }
    72|     &V
    73| }
    74| pub fn get_gcov_output_ext() -> &'static str {
    75|     lazy_static! {
    76|         static ref E: &'static str = {
    77|             let min_ver = Version::new(9, 1, 0);
    78|             if get_gcov_version() >= &min_ver {
    79|                 ".gcov.json.gz"
    80|             } else {
    81|                 ".gcov"
    82|             }
    83|         };
    84|     }
    85|     &E
    86| }
    87| fn parse_version(gcov_output: &str) -> Version {
    88|     let version = gcov_output
    89|         .split([' ', '\n'])
    90|         .filter_map(|value| Version::parse(value.trim()).ok())
    91|         .last();
    92|     assert!(version.is_some(), "no version found for `gcov`.");
    93|     version.unwrap()
    94| }
    95| #[cfg(test)]
    96| mod tests {
    97|     use super::*;
    98|     #[test]
    99|     fn test_parse_version() {
   100|         assert_eq!(
   101|             parse_version("gcov (Ubuntu 4.3.0-12ubuntu2) 4.3.0 20170406"),
   102|             Version::new(4, 3, 0)
   103|         );
   104|         assert_eq!(
   105|             parse_version("gcov (Ubuntu 4.9.0-12ubuntu2) 4.9.0 20170406"),
   106|             Version::new(4, 9, 0)
   107|         );
   108|         assert_eq!(
   109|             parse_version("gcov (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406"),
   110|             Version::new(6, 3, 0)
   111|         );
   112|         assert_eq!(parse_version("gcov (GCC) 12.2.0"), Version::new(12, 2, 0));
   113|         assert_eq!(parse_version("gcov (GCC) 12.2.0\r"), Version::new(12, 2, 0));
   114|     }
   115| }


# ====================================================================
# FILE: src/lib.rs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 5-63 ---
     5| mod producer;
     6| pub use crate::producer::*;
     7| mod gcov;
     8| pub use crate::gcov::*;
     9| mod llvm_tools;
    10| pub use crate::llvm_tools::*;
    11| mod parser;
    12| pub use crate::parser::*;
    13| mod filter;
    14| pub use crate::filter::*;
    15| mod symlink;
    16| mod path_rewriting;
    17| pub use crate::path_rewriting::*;
    18| mod output;
    19| pub use crate::output::*;
    20| mod cobertura;
    21| pub use crate::cobertura::*;
    22| mod reader;
    23| pub use crate::reader::*;
    24| mod covdir;
    25| pub mod html;
    26| mod file_filter;
    27| pub use crate::file_filter::*;
    28| use log::{error, warn};
    29| use std::fs;
    30| use std::io::{BufReader, Cursor};
    31| use std::{
    32|     collections::{btree_map, hash_map},
    33|     path::Path,
    34| };
    35| use walkdir::WalkDir;
    36| pub fn merge_results(result: &mut CovResult, result2: CovResult) -> bool {
    37|     let mut warn_overflow = false;
    38|     for (&line_no, &execution_count) in &result2.lines {
    39|         match result.lines.entry(line_no) {
    40|             btree_map::Entry::Occupied(c) => {
    41|                 let v = c.get().checked_add(execution_count).unwrap_or_else(|| {
    42|                     warn_overflow = true;
    43|                     u64::MAX
    44|                 });
    45|                 *c.into_mut() = v;
    46|             }
    47|             btree_map::Entry::Vacant(v) => {
    48|                 v.insert(execution_count);
    49|             }
    50|         };
    51|     }
    52|     for (line_no, taken) in result2.branches {
    53|         match result.branches.entry(line_no) {
    54|             btree_map::Entry::Occupied(c) => {
    55|                 let v = c.into_mut();
    56|                 for (x, y) in taken.iter().zip(v.iter_mut()) {
    57|                     *y |= x;
    58|                 }
    59|                 let l = v.len();
    60|                 if taken.len() > l {
    61|                     v.extend(&taken[l..]);
    62|                 }
    63|             }

# --- HUNK 2: Lines 95-135 ---
    95|             None => result.0,
    96|         };
    97|         let entry = map.entry(path);
    98|         match entry {
    99|             hash_map::Entry::Occupied(obj) => {
   100|                 warn_overflow |= merge_results(obj.into_mut(), result.1);
   101|             }
   102|             hash_map::Entry::Vacant(v) => {
   103|                 v.insert(result.1);
   104|             }
   105|         };
   106|     }
   107|     if warn_overflow {
   108|         warn!("Execution count overflow detected.");
   109|     }
   110| }
   111| fn rename_single_files(results: &mut [(String, CovResult)], stem: &str) {
   112|     if let Some(parent) = Path::new(stem).parent() {
   113|         for (file, _) in results.iter_mut() {
   114|             if has_no_parent(file) {
   115|                 *file = parent.join(file.as_str()).to_str().unwrap().to_string();
   116|             }
   117|         }
   118|     }
   119| }
   120| #[derive(PartialEq, Eq)]
   121| enum GcovType {
   122|     Unknown,
   123|     SingleFile,
   124|     MultipleFiles,
   125| }
   126| macro_rules! try_parse {
   127|     ($v:expr, $f:expr) => {
   128|         match $v {
   129|             Ok(val) => val,
   130|             Err(err) => {
   131|                 error!("Error parsing file {}: {}", $f, err);
   132|                 continue;
   133|             }
   134|         }
   135|     };


# ====================================================================
# FILE: src/llvm_tools.rs
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| use once_cell::sync::OnceCell;
     2| use rayon::prelude::{IntoParallelIterator, ParallelIterator};
     3| use std::env;
     4| use std::env::consts::EXE_SUFFIX;
     5| use std::error::Error;
     6| use std::ffi::OsStr;
     7| use std::fs;
     8| use std::io::Write;
     9| use std::path::{Path, PathBuf};
    10| use std::process::{Command, Stdio};
    11| use log::warn;
    12| use walkdir::WalkDir;
    13| pub static LLVM_PATH: OnceCell<PathBuf> = OnceCell::new();
    14| pub fn is_binary(path: impl AsRef<Path>) -> bool {
    15|     if let Ok(oty) = infer::get_from_path(path) {
    16|         if let Some("dll" | "exe" | "elf" | "mach") = oty.map(|x| x.extension()) {
    17|             return true;
    18|         }
    19|     }
    20|     false
    21| }
    22| pub fn run_with_stdin(
    23|     cmd: impl AsRef<OsStr>,
    24|     stdin: impl AsRef<str>,
    25|     args: &[&OsStr],

# --- HUNK 2: Lines 106-183 ---
   106|                 binary.as_ref(),
   107|                 "--instr-profile".as_ref(),
   108|                 profdata_path.as_ref(),
   109|                 "--format".as_ref(),
   110|                 "lcov".as_ref(),
   111|             ];
   112|             match run(&cov_tool_path, &args) {
   113|                 Ok(result) => Some(result),
   114|                 Err(err_str) => {
   115|                     warn!(
   116|                         "Suppressing error returned by llvm-cov tool for binary {:?}\n{}",
   117|                         binary, err_str
   118|                     );
   119|                     None
   120|                 }
   121|             }
   122|         })
   123|         .collect::<Vec<_>>();
   124|     Ok(results)
   125| }
   126| fn sysroot() -> Result<String, Box<dyn Error>> {
   127|     let rustc = env::var_os("RUSTC").unwrap_or_else(|| "rustc".into());
   128|     let output = Command::new(rustc).arg("--print").arg("sysroot").output()?;
   129|     Ok(String::from_utf8(output.stdout)?.trim().to_owned())
   130| }
   131| fn rustlib() -> Result<PathBuf, Box<dyn Error>> {
   132|     let sysroot = sysroot()?;
   133|     let mut pathbuf = PathBuf::from(sysroot);
   134|     pathbuf.push("lib");
   135|     pathbuf.push("rustlib");
   136|     pathbuf.push(rustc_version::version_meta()?.host); // TODO: Prevent calling rustc_version::version_meta() multiple times
   137|     pathbuf.push("bin");
   138|     Ok(pathbuf)
   139| }
   140| fn llvm_tool_path(name: &str) -> Result<PathBuf, Box<dyn Error>> {
   141|     let mut path = rustlib()?;
   142|     path.push(format!("llvm-{}{}", name, EXE_SUFFIX));
   143|     Ok(path)
   144| }
   145| fn get_profdata_path() -> Result<PathBuf, String> {
   146|     let path = if let Some(mut path) = LLVM_PATH.get().cloned() {
   147|         path.push(format!("llvm-profdata{}", EXE_SUFFIX));
   148|         path
   149|     } else {
   150|         llvm_tool_path("profdata").map_err(|x| x.to_string())?
   151|     };
   152|     if !path.exists() {
   153|         Err(String::from("We couldn't find llvm-profdata. Try installing the llvm-tools component with `rustup component add llvm-tools-preview` or specifying the --llvm-path option."))
   154|     } else {
   155|         Ok(path)
   156|     }
   157| }
   158| fn get_cov_path() -> Result<PathBuf, String> {
   159|     let path = if let Some(mut path) = LLVM_PATH.get().cloned() {
   160|         path.push(format!("llvm-cov{}", EXE_SUFFIX));
   161|         path
   162|     } else {
   163|         llvm_tool_path("cov").map_err(|x| x.to_string())?
   164|     };
   165|     if !path.exists() {
   166|         Err(String::from("We couldn't find llvm-cov. Try installing the llvm-tools component with `rustup component add llvm-tools-preview` or specifying the --llvm-path option."))
   167|     } else {
   168|         Ok(path)
   169|     }
   170| }
   171| #[cfg(test)]
   172| mod tests {
   173|     use super::*;
   174|     use std::fs;
   175|     #[test]
   176|     fn test_profraws_to_lcov() {
   177|         let output = Command::new("rustc").arg("--version").output().unwrap();
   178|         if !String::from_utf8_lossy(&output.stdout).contains("nightly") {
   179|             return;
   180|         }
   181|         let tmp_dir = tempfile::tempdir().expect("Failed to create temporary directory");
   182|         let tmp_path = tmp_dir.path().to_owned();
   183|         fs::copy(

# --- HUNK 3: Lines 213-276 ---
   213|             std::env::var("CARGO_TARGET_DIR").unwrap_or("target".to_string())
   214|         );
   215|         #[cfg(windows)]
   216|         let binary_path = format!(
   217|             "{}/debug/rust-code-coverage-sample.exe",
   218|             std::env::var("CARGO_TARGET_DIR").unwrap_or("target".to_string())
   219|         );
   220|         let lcovs = profraws_to_lcov(
   221|             &[tmp_path.join("default.profraw")],
   222|             &tmp_path.join(binary_path),
   223|             &tmp_path,
   224|         );
   225|         assert!(lcovs.is_ok());
   226|         let lcovs = lcovs.unwrap();
   227|         assert_eq!(lcovs.len(), 1);
   228|         let output_lcov = String::from_utf8_lossy(&lcovs[0]);
   229|         println!("{}", output_lcov);
   230|         assert!(output_lcov
   231|             .lines()
   232|             .any(|line| line.contains("SF") && line.contains("src") && line.contains("main.rs")));
   233|         if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
   234|             assert!(output_lcov.lines().any(|line| line.contains("FN:3")
   235|                 && line.contains("rust_code_coverage_sample")
   236|                 && line.contains("Ciao")));
   237|         }
   238|         assert!(output_lcov.lines().any(|line| line.contains("FN:8")
   239|             && line.contains("rust_code_coverage_sample")
   240|             && line.contains("main")));
   241|         if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
   242|             assert!(output_lcov.lines().any(|line| line.contains("FNDA:0")
   243|                 && line.contains("rust_code_coverage_sample")
   244|                 && line.contains("Ciao")));
   245|         } else {
   246|             assert!(output_lcov.lines().any(|line| line.contains("FNDA:1")
   247|                 && line.contains("rust_code_coverage_sample")
   248|                 && line.contains("main")));
   249|         }
   250|         assert!(output_lcov.lines().any(|line| line.contains("FNDA:1")
   251|             && line.contains("rust_code_coverage_sample")
   252|             && line.contains("main")));
   253|         if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
   254|             assert!(output_lcov.lines().any(|line| line == "FNF:2"));
   255|         }
   256|         assert!(output_lcov.lines().any(|line| line == "FNH:1"));
   257|         if rustc_version::version_meta().unwrap().channel != rustc_version::Channel::Nightly {
   258|             assert!(output_lcov.lines().any(|line| line == "DA:3,0"));
   259|         }
   260|         assert!(output_lcov.lines().any(|line| line == "DA:8,1"));
   261|         assert!(output_lcov.lines().any(|line| line == "DA:9,1"));
   262|         assert!(output_lcov.lines().any(|line| line == "DA:10,1"));
   263|         assert!(output_lcov.lines().any(|line| line == "DA:11,1"));
   264|         assert!(output_lcov.lines().any(|line| line == "DA:12,1"));
   265|         assert!(output_lcov.lines().any(|line| line == "BRF:0"));
   266|         assert!(output_lcov.lines().any(|line| line == "BRH:0"));
   267|         if rustc_version::version_meta().unwrap().channel == rustc_version::Channel::Nightly {
   268|             assert!(output_lcov.lines().any(|line| line == "LF:5"));
   269|             assert!(output_lcov.lines().any(|line| line == "LH:5"));
   270|         } else {
   271|             assert!(output_lcov.lines().any(|line| line == "LF:6"));
   272|             assert!(output_lcov.lines().any(|line| line == "LH:5"));
   273|         }
   274|         assert!(output_lcov.lines().any(|line| line == "end_of_record"));
   275|     }
   276| }


# ====================================================================
# FILE: src/main.rs
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| #[cfg(all(unix, feature = "tc"))]
     2| #[global_allocator]
     3| static GLOBAL: tcmalloc::TCMalloc = tcmalloc::TCMalloc;
     4| use clap::{builder::PossibleValue, ArgGroup, Parser, ValueEnum};
     5| use crossbeam_channel::bounded;
     6| use log::error;
     7| use regex::Regex;
     8| use rustc_hash::FxHashMap;
     9| use serde_json::Value;
    10| use simplelog::{ColorChoice, Config, LevelFilter, TermLogger, TerminalMode, WriteLogger};
    11| use std::fs::{self, File};
    12| use std::ops::Deref;
    13| use std::panic;
    14| use std::path::{Path, PathBuf};
    15| use std::str::FromStr;
    16| use std::sync::{Arc, Mutex};
    17| use std::{process, thread};
    18| use grcov::*;
    19| #[derive(Clone, PartialEq)]
    20| enum OutputType {
    21|     Ade,
    22|     Lcov,
    23|     Coveralls,
    24|     CoverallsPlus,
    25|     Files,
    26|     Covdir,
    27|     Html,
    28|     Cobertura,
    29|     CoberturaPretty,
    30|     Markdown,
    31| }
    32| impl FromStr for OutputType {
    33|     type Err = String;
    34|     fn from_str(s: &str) -> Result<Self, Self::Err> {
    35|         Ok(match s {
    36|             "ade" => Self::Ade,
    37|             "lcov" => Self::Lcov,
    38|             "coveralls" => Self::Coveralls,
    39|             "coveralls+" => Self::CoverallsPlus,
    40|             "files" => Self::Files,
    41|             "covdir" => Self::Covdir,
    42|             "html" => Self::Html,
    43|             "cobertura" => Self::Cobertura,
    44|             "cobertura-pretty" => Self::CoberturaPretty,
    45|             "markdown" => Self::Markdown,
    46|             _ => return Err(format!("{} is not a supported output type", s)),
    47|         })
    48|     }
    49| }
    50| impl OutputType {
    51|     fn to_file_name(&self, output_path: Option<&Path>) -> Option<PathBuf> {
    52|         output_path.map(|path| {
    53|             if path.is_dir() {
    54|                 match self {
    55|                     OutputType::Ade => path.join("activedata"),
    56|                     OutputType::Lcov => path.join("lcov"),
    57|                     OutputType::Coveralls => path.join("coveralls"),
    58|                     OutputType::CoverallsPlus => path.join("coveralls+"),
    59|                     OutputType::Files => path.join("files"),
    60|                     OutputType::Covdir => path.join("covdir"),
    61|                     OutputType::Html => path.join("html"),
    62|                     OutputType::Cobertura | OutputType::CoberturaPretty => {
    63|                         path.join("cobertura.xml")
    64|                     }
    65|                     OutputType::Markdown => path.join("markdown.md"),
    66|                 }
    67|             } else {
    68|                 path.to_path_buf()
    69|             }
    70|         })
    71|     }
    72| }
    73| #[derive(clap::ValueEnum, Clone)]
    74| enum Filter {
    75|     Covered,
    76|     Uncovered,
    77| }
    78| impl FromStr for Filter {
    79|     type Err = String;
    80|     fn from_str(s: &str) -> Result<Self, Self::Err> {
    81|         Ok(match s {
    82|             "covered" => Self::Covered,
    83|             "uncovered" => Self::Uncovered,
    84|             _ => return Err(format!("{} is not a supported filter", s)),

# --- HUNK 2: Lines 129-208 ---
   129|     #[arg(required = true)]
   130|     paths: Vec<String>,
   131|     #[arg(short, long, value_name = "PATH")]
   132|     binary_path: Option<PathBuf>,
   133|     #[arg(long, value_name = "PATH")]
   134|     llvm_path: Option<PathBuf>,
   135|     #[arg(
   136|         short = 't',
   137|         long,
   138|         long_help = "\
   139|             Comma separated list of custom output types:\n\
   140|             - *html* for a HTML coverage report;\n\
   141|             - *coveralls* for the Coveralls specific format;\n\
   142|             - *lcov* for the lcov INFO format;\n\
   143|             - *covdir* for the covdir recursive JSON format;\n\
   144|             - *coveralls+* for the Coveralls specific format with function information;\n\
   145|             - *ade* for the ActiveData-ETL specific format;\n\
   146|             - *files* to only return a list of files.\n\
   147|             - *markdown* for human easy read.\n\
   148|             - *cobertura* for output in cobertura format.\n\
   149|             - *cobertura-pretty* to pretty-print in cobertura format.\n\
   150|         ",
   151|         value_name = "OUTPUT TYPE",
   152|         requires_ifs = [
   153|             ("coveralls", "coveralls-auth"),
   154|             ("coveralls+", "coveralls-auth"),
   155|         ],
   156|         value_delimiter = ',',
   157|         alias = "output-type",
   158|         default_value = "lcov",
   159|     )]
   160|     output_types: Vec<OutputType>,
   161|     #[arg(short, long, value_name = "PATH", alias = "output-file")]
   162|     output_path: Option<PathBuf>,
   163|     #[arg(long, value_name = "PATH", alias = "output-config-file")]
   164|     output_config_file: Option<PathBuf>,
   165|     #[arg(short, long, value_name = "DIRECTORY")]
   166|     source_dir: Option<PathBuf>,
   167|     #[arg(short, long, value_name = "PATH")]
   168|     prefix_dir: Option<PathBuf>,
   169|     #[arg(long)]
   170|     ignore_not_existing: bool,
   171|     #[arg(long = "ignore", value_name = "PATH", num_args = 1)]
   172|     ignore_dir: Vec<String>,
   173|     #[arg(long = "keep-only", value_name = "PATH", num_args = 1)]
   174|     keep_dir: Vec<String>,
   175|     #[arg(long, value_name = "PATH")]
   176|     path_mapping: Option<PathBuf>,
   177|     #[arg(long)]
   178|     branch: bool,
   179|     #[arg(long, value_enum)]
   180|     filter: Option<Filter>,
   181|     #[arg(
   182|         long,
   183|         value_name = "OUTPUT TYPES",
   184|         value_delimiter = ',',
   185|         alias = "sort-output-types",
   186|         default_value = "markdown"
   187|     )]
   188|     sort_output_types: Vec<OutputType>,
   189|     #[arg(long)]
   190|     llvm: bool,
   191|     #[arg(long, value_name = "TOKEN")]
   192|     token: Option<String>,
   193|     #[arg(long, value_name = "COMMIT HASH")]
   194|     commit_sha: Option<String>,
   195|     #[arg(long, value_name = "SERVICE NAME")]
   196|     service_name: Option<String>,
   197|     #[arg(long, value_name = "SERVICE NUMBER")]
   198|     service_number: Option<String>,
   199|     #[arg(
   200|         long,
   201|         value_name = "SERVICE JOB ID",
   202|         visible_alias = "service-job-number",
   203|         requires = "service_name"
   204|     )]
   205|     service_job_id: Option<String>,
   206|     #[arg(long, value_name = "SERVICE PULL REQUEST")]
   207|     service_pull_request: Option<String>,
   208|     #[arg(long, value_name = "SERVICE FLAG NAME")]

# --- HUNK 3: Lines 380-500 ---
   380|     for parser in parsers {
   381|         if parser.join().is_err() {
   382|             process::exit(1);
   383|         }
   384|     }
   385|     let result_map_mutex = Arc::try_unwrap(result_map).unwrap();
   386|     let result_map = result_map_mutex.into_inner().unwrap();
   387|     let path_mapping_mutex = Arc::try_unwrap(path_mapping).unwrap();
   388|     let path_mapping = path_mapping_mutex.into_inner().unwrap();
   389|     let iterator = rewrite_paths(
   390|         result_map,
   391|         path_mapping,
   392|         source_root.as_deref(),
   393|         prefix_dir.as_deref(),
   394|         opt.ignore_not_existing,
   395|         &opt.ignore_dir,
   396|         &opt.keep_dir,
   397|         filter_option,
   398|         file_filter,
   399|     );
   400|     let mut sorted_iterator: Option<Vec<ResultTuple>> = None;
   401|     let service_number = opt.service_number.unwrap_or_default();
   402|     let service_pull_request = opt.service_pull_request.unwrap_or_default();
   403|     let commit_sha = opt.commit_sha.unwrap_or_default();
   404|     let output_types = opt.output_types;
   405|     let output_path = match output_types.len() {
   406|         0 => unreachable!("Output types has a default value"),
   407|         1 => opt.output_path.as_deref(),
   408|         _ => match opt.output_path.as_deref() {
   409|             Some(output_path) => {
   410|                 if output_path.is_dir() {
   411|                     Some(output_path)
   412|                 } else {
   413|                     panic!("output_path must be a directory when using multiple outputs");
   414|                 }
   415|             }
   416|             _ => None,
   417|         },
   418|     };
   419|     for output_type in &output_types {
   420|         let output_path = output_type.to_file_name(output_path);
   421|         let results = if opt.sort_output_types.contains(output_type) {
   422|             sorted_iterator = sorted_iterator.or_else(|| {
   423|                 let mut results = iterator.clone();
   424|                 results.sort_by_key(|result| result.0.display().to_string());
   425|                 Some(results)
   426|             });
   427|             sorted_iterator.as_ref().unwrap()
   428|         } else {
   429|             &iterator
   430|         };
   431|         match output_type {
   432|             OutputType::Ade => output_activedata_etl(results, output_path.as_deref(), demangle),
   433|             OutputType::Lcov => output_lcov(results, output_path.as_deref(), demangle),
   434|             OutputType::Coveralls => output_coveralls(
   435|                 results,
   436|                 opt.token.as_deref(),
   437|                 opt.service_name.as_deref(),
   438|                 &service_number,
   439|                 opt.service_job_id.as_deref(),
   440|                 &service_pull_request,
   441|                 opt.service_flag_name.as_deref(),
   442|                 &commit_sha,
   443|                 false,
   444|                 output_path.as_deref(),
   445|                 &opt.vcs_branch,
   446|                 opt.parallel,
   447|                 demangle,
   448|             ),
   449|             OutputType::CoverallsPlus => output_coveralls(
   450|                 results,
   451|                 opt.token.as_deref(),
   452|                 opt.service_name.as_deref(),
   453|                 &service_number,
   454|                 opt.service_job_id.as_deref(),
   455|                 &service_pull_request,
   456|                 opt.service_flag_name.as_deref(),
   457|                 &commit_sha,
   458|                 true,
   459|                 output_path.as_deref(),
   460|                 &opt.vcs_branch,
   461|                 opt.parallel,
   462|                 demangle,
   463|             ),
   464|             OutputType::Files => output_files(results, output_path.as_deref()),
   465|             OutputType::Covdir => output_covdir(results, output_path.as_deref(), opt.precision),
   466|             OutputType::Html => output_html(
   467|                 results,
   468|                 output_path.as_deref(),
   469|                 num_threads,
   470|                 opt.branch,
   471|                 opt.output_config_file.as_deref(),
   472|                 opt.precision,
   473|             ),
   474|             OutputType::Cobertura => output_cobertura(
   475|                 source_root.as_deref(),
   476|                 results,
   477|                 output_path.as_deref(),
   478|                 demangle,
   479|                 false,
   480|             ),
   481|             OutputType::CoberturaPretty => output_cobertura(
   482|                 source_root.as_deref(),
   483|                 results,
   484|                 output_path.as_deref(),
   485|                 demangle,
   486|                 true,
   487|             ),
   488|             OutputType::Markdown => output_markdown(results, output_path.as_deref(), opt.precision),
   489|         };
   490|     }
   491| }
   492| #[cfg(test)]
   493| mod tests {
   494|     use super::*;
   495|     use clap::CommandFactory;
   496|     #[test]
   497|     fn clap_debug_assert() {
   498|         Opt::command().debug_assert();
   499|     }
   500| }


# ====================================================================
# FILE: src/parser.rs
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 481-521 ---
   481|     if !cur_lines.is_empty() {
   482|         results.push((
   483|             cur_file.unwrap(),
   484|             CovResult {
   485|                 lines: cur_lines,
   486|                 branches: cur_branches,
   487|                 functions: cur_functions,
   488|             },
   489|         ));
   490|     }
   491|     Ok(results)
   492| }
   493| fn get_xml_attribute<R: BufRead>(
   494|     reader: &Reader<R>,
   495|     event: &BytesStart<'_>,
   496|     name: &str,
   497| ) -> Result<String, ParserError> {
   498|     for a in event.attributes() {
   499|         let a = a?;
   500|         if a.key.into_inner() == name.as_bytes() {
   501|             return Ok(a.decode_and_unescape_value(reader.decoder())?.into_owned());
   502|         }
   503|     }
   504|     Err(ParserError::InvalidRecord(format!(
   505|         "Attribute {} not found",
   506|         name
   507|     )))
   508| }
   509| fn parse_jacoco_report_sourcefile<T: BufRead>(
   510|     parser: &mut Reader<T>,
   511|     buf: &mut Vec<u8>,
   512| ) -> Result<JacocoReport, ParserError> {
   513|     let mut lines: BTreeMap<u32, u64> = BTreeMap::new();
   514|     let mut branches: BTreeMap<u32, Vec<bool>> = BTreeMap::new();
   515|     loop {
   516|         match parser.read_event_into(buf) {
   517|             Ok(Event::Start(ref e)) if e.local_name().into_inner() == b"line" => {
   518|                 let (mut ci, mut cb, mut mb, mut nr) = (None, None, None, None);
   519|                 for a in e.attributes() {
   520|                     let a = a?;
   521|                     match a.key.into_inner() {

# --- HUNK 2: Lines 667-709 ---
   667|                 package, class
   668|             )));
   669|         }
   670|     }
   671|     Ok(results_map
   672|         .into_iter()
   673|         .map(|(class, result)| {
   674|             (
   675|                 format!("{}/{}.java", package, class)
   676|                     .trim_start_matches('/')
   677|                     .to_string(),
   678|                 result,
   679|             )
   680|         })
   681|         .collect())
   682| }
   683| pub fn parse_jacoco_xml_report<T: Read>(
   684|     xml_reader: BufReader<T>,
   685| ) -> Result<Vec<(String, CovResult)>, ParserError> {
   686|     let mut parser = Reader::from_reader(xml_reader);
   687|     let config = parser.config_mut();
   688|     config.expand_empty_elements = true;
   689|     config.trim_text(false);
   690|     let mut results = Vec::new();
   691|     let mut buf = Vec::new();
   692|     loop {
   693|         match parser.read_event_into(&mut buf) {
   694|             Ok(Event::Start(ref e)) if e.local_name().into_inner() == b"package" => {
   695|                 let package = get_xml_attribute(&parser, e, "name")?;
   696|                 let mut package_results =
   697|                     parse_jacoco_report_package(&mut parser, &mut buf, &package)?;
   698|                 results.append(&mut package_results);
   699|             }
   700|             Ok(Event::Eof) => break,
   701|             Err(e) => return Err(ParserError::Parse(e.to_string())),
   702|             _ => {}
   703|         }
   704|         buf.clear();
   705|     }
   706|     Ok(results)
   707| }
   708| #[cfg(test)]
   709| mod tests {


# ====================================================================
# FILE: src/reader.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 852-892 ---
   852|                         btree_map::Entry::Occupied(c) => {
   853|                             let v = c.into_mut();
   854|                             v.extend_from_slice(&taken);
   855|                         }
   856|                         btree_map::Entry::Vacant(p) => {
   857|                             p.insert(taken);
   858|                         }
   859|                     }
   860|                 }
   861|             }
   862|         }
   863|         let mut r = Vec::with_capacity(results.len());
   864|         for (k, v) in results.drain() {
   865|             r.push((k.to_string(), v));
   866|         }
   867|         r
   868|     }
   869| }
   870| impl GcovFunction {
   871|     fn get_cycle_count(edges: &mut [GcovEdge], path: &[usize]) -> u64 {
   872|         let mut count = u64::MAX;
   873|         for e in path.iter() {
   874|             count = cmp::min(count, edges[*e].cycles);
   875|         }
   876|         for e in path {
   877|             edges[*e].cycles -= count;
   878|         }
   879|         count
   880|     }
   881|     fn unblock(
   882|         block: usize,
   883|         blocked: &mut SmallVec<[usize; 4]>,
   884|         block_lists: &mut SmallVec<[SmallVec<[usize; 2]>; 2]>,
   885|     ) {
   886|         if let Some(i) = blocked.iter().position(|x| *x == block) {
   887|             blocked.remove(i);
   888|             for b in block_lists.remove(i) {
   889|                 GcovFunction::unblock(b, blocked, block_lists);
   890|             }
   891|         }
   892|     }

