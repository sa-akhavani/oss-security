# ====================================================================
# FILE: src/dir.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-159 ---
     1| use crate::{Error, NixPath, Result};
     2| use crate::errno::Errno;
     3| use crate::fcntl::{self, OFlag};
     4| use std::os::unix::io::{AsRawFd, IntoRawFd, RawFd};
     5| use std::ptr;
     6| use std::ffi;
     7| use crate::sys;
     8| #[cfg(target_os = "linux")]
     9| use libc::{dirent64 as dirent, readdir64_r as readdir_r};
    10| #[cfg(not(target_os = "linux"))]
    11| use libc::{dirent, readdir_r};
    12| #[derive(Debug, Eq, Hash, PartialEq)]
    13| pub struct Dir(
    14|     ptr::NonNull<libc::DIR>
    15| );
    16| impl Dir {
    17|     pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag,
    18|                                      mode: sys::stat::Mode) -> Result<Self> {
    19|         let fd = fcntl::open(path, oflag, mode)?;
    20|         Dir::from_fd(fd)
    21|     }
    22|     pub fn openat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P, oflag: OFlag,
    23|                                        mode: sys::stat::Mode) -> Result<Self> {
    24|         let fd = fcntl::openat(dirfd, path, oflag, mode)?;
    25|         Dir::from_fd(fd)
    26|     }
    27|     #[inline]
    28|     pub fn from<F: IntoRawFd>(fd: F) -> Result<Self> {
    29|         Dir::from_fd(fd.into_raw_fd())
    30|     }
    31|     pub fn from_fd(fd: RawFd) -> Result<Self> {
    32|         let d = ptr::NonNull::new(unsafe { libc::fdopendir(fd) }).ok_or_else(|| {
    33|             let e = Error::last();
    34|             unsafe { libc::close(fd) };
    35|             e
    36|         })?;
    37|         Ok(Dir(d))
    38|     }
    39|     pub fn iter(&mut self) -> Iter {
    40|         Iter(self)
    41|     }
    42| }
    43| unsafe impl Send for Dir {}
    44| impl AsRawFd for Dir {
    45|     fn as_raw_fd(&self) -> RawFd {
    46|         unsafe { libc::dirfd(self.0.as_ptr()) }
    47|     }
    48| }
    49| impl Drop for Dir {
    50|     fn drop(&mut self) {
    51|         let e = Errno::result(unsafe { libc::closedir(self.0.as_ptr()) });
    52|         if !std::thread::panicking() && e == Err(Error::from(Errno::EBADF)) {
    53|             panic!("Closing an invalid file descriptor!");
    54|         };
    55|     }
    56| }
    57| fn next(dir: &mut Dir) -> Option<Result<Entry>> {
    58|     unsafe {
    59|         let mut ent = std::mem::MaybeUninit::<dirent>::uninit();
    60|         let mut result = ptr::null_mut();
    61|         if let Err(e) = Errno::result(
    62|             readdir_r(dir.0.as_ptr(), ent.as_mut_ptr(), &mut result))
    63|         {
    64|             return Some(Err(e));
    65|         }
    66|         if result.is_null() {
    67|             return None;
    68|         }
    69|         assert_eq!(result, ent.as_mut_ptr());
    70|         Some(Ok(Entry(ent.assume_init())))
    71|     }
    72| }
    73| #[derive(Debug, Eq, Hash, PartialEq)]
    74| pub struct Iter<'d>(&'d mut Dir);
    75| impl<'d> Iterator for Iter<'d> {
    76|     type Item = Result<Entry>;
    77|     fn next(&mut self) -> Option<Self::Item> {
    78|         next(self.0)
    79|     }
    80| }
    81| impl<'d> Drop for Iter<'d> {
    82|     fn drop(&mut self) {
    83|         unsafe { libc::rewinddir((self.0).0.as_ptr()) }
    84|     }
    85| }
    86| #[derive(Debug, Eq, Hash, PartialEq)]
    87| pub struct OwningIter(Dir);
    88| impl Iterator for OwningIter {
    89|     type Item = Result<Entry>;
    90|     fn next(&mut self) -> Option<Self::Item> {
    91|         next(&mut self.0)
    92|     }
    93| }
    94| impl IntoIterator for Dir {
    95|     type Item = Result<Entry>;
    96|     type IntoIter = OwningIter;
    97|     fn into_iter(self) -> Self::IntoIter {
    98|         OwningIter(self)
    99|     }
   100| }
   101| #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
   102| #[repr(transparent)]
   103| pub struct Entry(dirent);
   104| #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
   105| pub enum Type {
   106|     Fifo,
   107|     CharacterDevice,
   108|     Directory,
   109|     BlockDevice,
   110|     File,
   111|     Symlink,
   112|     Socket,
   113| }
   114| impl Entry {
   115|     #[cfg(any(target_os = "android",
   116|               target_os = "emscripten",
   117|               target_os = "fuchsia",
   118|               target_os = "haiku",
   119|               target_os = "illumos",
   120|               target_os = "ios",
   121|               target_os = "l4re",
   122|               target_os = "linux",
   123|               target_os = "macos",
   124|               target_os = "solaris"))]
   125|     pub fn ino(&self) -> u64 {
   126|         self.0.d_ino as u64
   127|     }
   128|     #[cfg(not(any(target_os = "android",
   129|                   target_os = "emscripten",
   130|                   target_os = "fuchsia",
   131|                   target_os = "haiku",
   132|                   target_os = "illumos",
   133|                   target_os = "ios",
   134|                   target_os = "l4re",
   135|                   target_os = "linux",
   136|                   target_os = "macos",
   137|                   target_os = "solaris")))]
   138|     pub fn ino(&self) -> u64 {
   139|         u64::from(self.0.d_fileno)
   140|     }
   141|     pub fn file_name(&self) -> &ffi::CStr {
   142|         unsafe { ::std::ffi::CStr::from_ptr(self.0.d_name.as_ptr()) }
   143|     }
   144|     pub fn file_type(&self) -> Option<Type> {
   145|         #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
   146|         match self.0.d_type {
   147|             libc::DT_FIFO => Some(Type::Fifo),
   148|             libc::DT_CHR => Some(Type::CharacterDevice),
   149|             libc::DT_DIR => Some(Type::Directory),
   150|             libc::DT_BLK => Some(Type::BlockDevice),
   151|             libc::DT_REG => Some(Type::File),
   152|             libc::DT_LNK => Some(Type::Symlink),
   153|             libc::DT_SOCK => Some(Type::Socket),
   154|             /* libc::DT_UNKNOWN | */ _ => None,
   155|         }
   156|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   157|         None
   158|     }
   159| }


# ====================================================================
# FILE: src/env.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-35 ---
     1| use cfg_if::cfg_if;
     2| use std::fmt;
     3| #[derive(Clone, Copy, Debug)]
     4| pub struct ClearEnvError;
     5| impl fmt::Display for ClearEnvError {
     6|     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
     7|         write!(f, "clearenv failed")
     8|     }
     9| }
    10| impl std::error::Error for ClearEnvError {}
    11| pub unsafe fn clearenv() -> std::result::Result<(), ClearEnvError> {
    12|     let ret;
    13|     cfg_if! {
    14|         if #[cfg(any(target_os = "fuchsia",
    15|                      target_os = "wasi",
    16|                      target_env = "wasi",
    17|                      target_env = "uclibc",
    18|                      target_os = "linux",
    19|                      target_os = "android",
    20|                      target_os = "emscripten"))] {
    21|             ret = libc::clearenv();
    22|         } else {
    23|             use std::env;
    24|             for (name, _) in env::vars_os() {
    25|                 env::remove_var(name);
    26|             }
    27|             ret = 0;
    28|         }
    29|     }
    30|     if ret == 0 {
    31|         Ok(())
    32|     } else {
    33|         Err(ClearEnvError)
    34|     }
    35| }


# ====================================================================
# FILE: src/errno.rs
# Total hunks: 8
# ====================================================================
# --- HUNK 1: Lines 723-762 ---
   723|         EUCLEAN         = libc::EUCLEAN,
   724|         ENOTNAM         = libc::ENOTNAM,
   725|         ENAVAIL         = libc::ENAVAIL,
   726|         EISNAM          = libc::EISNAM,
   727|         EREMOTEIO       = libc::EREMOTEIO,
   728|         EDQUOT          = libc::EDQUOT,
   729|         ENOMEDIUM       = libc::ENOMEDIUM,
   730|         EMEDIUMTYPE     = libc::EMEDIUMTYPE,
   731|         ECANCELED       = libc::ECANCELED,
   732|         ENOKEY          = libc::ENOKEY,
   733|         EKEYEXPIRED     = libc::EKEYEXPIRED,
   734|         EKEYREVOKED     = libc::EKEYREVOKED,
   735|         EKEYREJECTED    = libc::EKEYREJECTED,
   736|         EOWNERDEAD      = libc::EOWNERDEAD,
   737|         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
   738|         #[cfg(not(any(target_os = "android", target_arch="mips")))]
   739|         ERFKILL         = libc::ERFKILL,
   740|         #[cfg(not(any(target_os = "android", target_arch="mips")))]
   741|         EHWPOISON       = libc::EHWPOISON,
   742|     }
   743|     impl Errno {
   744|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
   745|         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
   746|         pub const ENOTSUP:     Errno = Errno::EOPNOTSUPP;
   747|     }
   748|     pub fn from_i32(e: i32) -> Errno {
   749|         use self::Errno::*;
   750|         match e {
   751|             libc::EPERM => EPERM,
   752|             libc::ENOENT => ENOENT,
   753|             libc::ESRCH => ESRCH,
   754|             libc::EINTR => EINTR,
   755|             libc::EIO => EIO,
   756|             libc::ENXIO => ENXIO,
   757|             libc::E2BIG => E2BIG,
   758|             libc::ENOEXEC => ENOEXEC,
   759|             libc::EBADF => EBADF,
   760|             libc::ECHILD => ECHILD,
   761|             libc::EAGAIN => EAGAIN,
   762|             libc::ENOMEM => ENOMEM,

# --- HUNK 2: Lines 981-1020 ---
   981|         EBADMACHO       = libc::EBADMACHO,
   982|         ECANCELED       = libc::ECANCELED,
   983|         EIDRM           = libc::EIDRM,
   984|         ENOMSG          = libc::ENOMSG,
   985|         EILSEQ          = libc::EILSEQ,
   986|         ENOATTR         = libc::ENOATTR,
   987|         EBADMSG         = libc::EBADMSG,
   988|         EMULTIHOP       = libc::EMULTIHOP,
   989|         ENODATA         = libc::ENODATA,
   990|         ENOLINK         = libc::ENOLINK,
   991|         ENOSR           = libc::ENOSR,
   992|         ENOSTR          = libc::ENOSTR,
   993|         EPROTO          = libc::EPROTO,
   994|         ETIME           = libc::ETIME,
   995|         EOPNOTSUPP      = libc::EOPNOTSUPP,
   996|         ENOPOLICY       = libc::ENOPOLICY,
   997|         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
   998|         EOWNERDEAD      = libc::EOWNERDEAD,
   999|         EQFULL          = libc::EQFULL,
  1000|     }
  1001|     impl Errno {
  1002|         pub const ELAST: Errno       = Errno::EQFULL;
  1003|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  1004|         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
  1005|     }
  1006|     pub fn from_i32(e: i32) -> Errno {
  1007|         use self::Errno::*;
  1008|         match e {
  1009|             libc::EPERM => EPERM,
  1010|             libc::ENOENT => ENOENT,
  1011|             libc::ESRCH => ESRCH,
  1012|             libc::EINTR => EINTR,
  1013|             libc::EIO => EIO,
  1014|             libc::ENXIO => ENXIO,
  1015|             libc::E2BIG => E2BIG,
  1016|             libc::ENOEXEC => ENOEXEC,
  1017|             libc::EBADF => EBADF,
  1018|             libc::ECHILD => ECHILD,
  1019|             libc::EDEADLK => EDEADLK,
  1020|             libc::ENOMEM => ENOMEM,

# --- HUNK 3: Lines 1202-1241 ---
  1202|         ENOSYS          = libc::ENOSYS,
  1203|         EFTYPE          = libc::EFTYPE,
  1204|         EAUTH           = libc::EAUTH,
  1205|         ENEEDAUTH       = libc::ENEEDAUTH,
  1206|         EIDRM           = libc::EIDRM,
  1207|         ENOMSG          = libc::ENOMSG,
  1208|         EOVERFLOW       = libc::EOVERFLOW,
  1209|         ECANCELED       = libc::ECANCELED,
  1210|         EILSEQ          = libc::EILSEQ,
  1211|         ENOATTR         = libc::ENOATTR,
  1212|         EDOOFUS         = libc::EDOOFUS,
  1213|         EBADMSG         = libc::EBADMSG,
  1214|         EMULTIHOP       = libc::EMULTIHOP,
  1215|         ENOLINK         = libc::ENOLINK,
  1216|         EPROTO          = libc::EPROTO,
  1217|         ENOTCAPABLE     = libc::ENOTCAPABLE,
  1218|         ECAPMODE        = libc::ECAPMODE,
  1219|         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
  1220|         EOWNERDEAD      = libc::EOWNERDEAD,
  1221|     }
  1222|     impl Errno {
  1223|         pub const ELAST: Errno       = Errno::EOWNERDEAD;
  1224|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  1225|         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
  1226|         pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
  1227|     }
  1228|     pub fn from_i32(e: i32) -> Errno {
  1229|         use self::Errno::*;
  1230|         match e {
  1231|             libc::EPERM => EPERM,
  1232|             libc::ENOENT => ENOENT,
  1233|             libc::ESRCH => ESRCH,
  1234|             libc::EINTR => EINTR,
  1235|             libc::EIO => EIO,
  1236|             libc::ENXIO => ENXIO,
  1237|             libc::E2BIG => E2BIG,
  1238|             libc::ENOEXEC => ENOEXEC,
  1239|             libc::EBADF => EBADF,
  1240|             libc::ECHILD => ECHILD,
  1241|             libc::EDEADLK => EDEADLK,

# --- HUNK 4: Lines 1412-1451 ---
  1412|         EPROCUNAVAIL    = libc::EPROCUNAVAIL,
  1413|         ENOLCK          = libc::ENOLCK,
  1414|         ENOSYS          = libc::ENOSYS,
  1415|         EFTYPE          = libc::EFTYPE,
  1416|         EAUTH           = libc::EAUTH,
  1417|         ENEEDAUTH       = libc::ENEEDAUTH,
  1418|         EIDRM           = libc::EIDRM,
  1419|         ENOMSG          = libc::ENOMSG,
  1420|         EOVERFLOW       = libc::EOVERFLOW,
  1421|         ECANCELED       = libc::ECANCELED,
  1422|         EILSEQ          = libc::EILSEQ,
  1423|         ENOATTR         = libc::ENOATTR,
  1424|         EDOOFUS         = libc::EDOOFUS,
  1425|         EBADMSG         = libc::EBADMSG,
  1426|         EMULTIHOP       = libc::EMULTIHOP,
  1427|         ENOLINK         = libc::ENOLINK,
  1428|         EPROTO          = libc::EPROTO,
  1429|         ENOMEDIUM       = libc::ENOMEDIUM,
  1430|         EASYNC          = libc::EASYNC,
  1431|     }
  1432|     impl Errno {
  1433|         pub const ELAST: Errno       = Errno::EASYNC;
  1434|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  1435|         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
  1436|         pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
  1437|     }
  1438|     pub fn from_i32(e: i32) -> Errno {
  1439|         use self::Errno::*;
  1440|         match e {
  1441|             libc::EPERM => EPERM,
  1442|             libc::ENOENT => ENOENT,
  1443|             libc::ESRCH => ESRCH,
  1444|             libc::EINTR => EINTR,
  1445|             libc::EIO => EIO,
  1446|             libc::ENXIO => ENXIO,
  1447|             libc::E2BIG => E2BIG,
  1448|             libc::ENOEXEC => ENOEXEC,
  1449|             libc::EBADF => EBADF,
  1450|             libc::ECHILD => ECHILD,
  1451|             libc::EDEADLK => EDEADLK,

# --- HUNK 5: Lines 1621-1660 ---
  1621|         ENOLCK          = libc::ENOLCK,
  1622|         ENOSYS          = libc::ENOSYS,
  1623|         EFTYPE          = libc::EFTYPE,
  1624|         EAUTH           = libc::EAUTH,
  1625|         ENEEDAUTH       = libc::ENEEDAUTH,
  1626|         EIPSEC          = libc::EIPSEC,
  1627|         ENOATTR         = libc::ENOATTR,
  1628|         EILSEQ          = libc::EILSEQ,
  1629|         ENOMEDIUM       = libc::ENOMEDIUM,
  1630|         EMEDIUMTYPE     = libc::EMEDIUMTYPE,
  1631|         EOVERFLOW       = libc::EOVERFLOW,
  1632|         ECANCELED       = libc::ECANCELED,
  1633|         EIDRM           = libc::EIDRM,
  1634|         ENOMSG          = libc::ENOMSG,
  1635|         ENOTSUP         = libc::ENOTSUP,
  1636|         EBADMSG         = libc::EBADMSG,
  1637|         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
  1638|         EOWNERDEAD      = libc::EOWNERDEAD,
  1639|         EPROTO          = libc::EPROTO,
  1640|     }
  1641|     impl Errno {
  1642|         pub const ELAST: Errno       = Errno::ENOTSUP;
  1643|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  1644|     }
  1645|     pub fn from_i32(e: i32) -> Errno {
  1646|         use self::Errno::*;
  1647|         match e {
  1648|             libc::EPERM => EPERM,
  1649|             libc::ENOENT => ENOENT,
  1650|             libc::ESRCH => ESRCH,
  1651|             libc::EINTR => EINTR,
  1652|             libc::EIO => EIO,
  1653|             libc::ENXIO => ENXIO,
  1654|             libc::E2BIG => E2BIG,
  1655|             libc::ENOEXEC => ENOEXEC,
  1656|             libc::EBADF => EBADF,
  1657|             libc::ECHILD => ECHILD,
  1658|             libc::EDEADLK => EDEADLK,
  1659|             libc::ENOMEM => ENOMEM,
  1660|             libc::EACCES => EACCES,

# --- HUNK 6: Lines 1830-1869 ---
  1830|         ENOSYS          = libc::ENOSYS,
  1831|         EFTYPE          = libc::EFTYPE,
  1832|         EAUTH           = libc::EAUTH,
  1833|         ENEEDAUTH       = libc::ENEEDAUTH,
  1834|         EIDRM           = libc::EIDRM,
  1835|         ENOMSG          = libc::ENOMSG,
  1836|         EOVERFLOW       = libc::EOVERFLOW,
  1837|         EILSEQ          = libc::EILSEQ,
  1838|         ENOTSUP         = libc::ENOTSUP,
  1839|         ECANCELED       = libc::ECANCELED,
  1840|         EBADMSG         = libc::EBADMSG,
  1841|         ENODATA         = libc::ENODATA,
  1842|         ENOSR           = libc::ENOSR,
  1843|         ENOSTR          = libc::ENOSTR,
  1844|         ETIME           = libc::ETIME,
  1845|         ENOATTR         = libc::ENOATTR,
  1846|         EMULTIHOP       = libc::EMULTIHOP,
  1847|         ENOLINK         = libc::ENOLINK,
  1848|         EPROTO          = libc::EPROTO,
  1849|     }
  1850|     impl Errno {
  1851|         pub const ELAST: Errno       = Errno::ENOTSUP;
  1852|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  1853|     }
  1854|     pub fn from_i32(e: i32) -> Errno {
  1855|         use self::Errno::*;
  1856|         match e {
  1857|             libc::EPERM => EPERM,
  1858|             libc::ENOENT => ENOENT,
  1859|             libc::ESRCH => ESRCH,
  1860|             libc::EINTR => EINTR,
  1861|             libc::EIO => EIO,
  1862|             libc::ENXIO => ENXIO,
  1863|             libc::E2BIG => E2BIG,
  1864|             libc::ENOEXEC => ENOEXEC,
  1865|             libc::EBADF => EBADF,
  1866|             libc::ECHILD => ECHILD,
  1867|             libc::EDEADLK => EDEADLK,
  1868|             libc::ENOMEM => ENOMEM,
  1869|             libc::EACCES => EACCES,

# --- HUNK 7: Lines 2029-2068 ---
  2029|         EUSERS = libc::EUSERS,
  2030|         EDQUOT = libc::EDQUOT,
  2031|         ESTALE = libc::ESTALE,
  2032|         EREMOTE = libc::EREMOTE,
  2033|         ENOLCK = libc::ENOLCK,
  2034|         ENOSYS = libc::ENOSYS,
  2035|         EIDRM = libc::EIDRM,
  2036|         ENOMSG = libc::ENOMSG,
  2037|         EOVERFLOW = libc::EOVERFLOW,
  2038|         EILSEQ = libc::EILSEQ,
  2039|         ECANCELED = libc::ECANCELED,
  2040|         EBADMSG = libc::EBADMSG,
  2041|         ENODATA = libc::ENODATA,
  2042|         ENOSR = libc::ENOSR,
  2043|         ENOSTR = libc::ENOSTR,
  2044|         ETIME = libc::ETIME,
  2045|         EMULTIHOP = libc::EMULTIHOP,
  2046|         ENOLINK = libc::ENOLINK,
  2047|         EPROTO = libc::EPROTO,
  2048|     }
  2049|     impl Errno {
  2050|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  2051|     }
  2052|     pub fn from_i32(e: i32) -> Errno {
  2053|         use self::Errno::*;
  2054|         match e {
  2055|             libc::EPERM => EPERM,
  2056|             libc::ENOENT => ENOENT,
  2057|             libc::ESRCH => ESRCH,
  2058|             libc::EINTR => EINTR,
  2059|             libc::EIO => EIO,
  2060|             libc::ENXIO => ENXIO,
  2061|             libc::E2BIG => E2BIG,
  2062|             libc::ENOEXEC => ENOEXEC,
  2063|             libc::EBADF => EBADF,
  2064|             libc::ECHILD => ECHILD,
  2065|             libc::EDEADLK => EDEADLK,
  2066|             libc::ENOMEM => ENOMEM,
  2067|             libc::EACCES => EACCES,
  2068|             libc::EFAULT => EFAULT,

# --- HUNK 8: Lines 2252-2291 ---
  2252|         EADDRINUSE = libc::EADDRINUSE,
  2253|         EADDRNOTAVAIL = libc::EADDRNOTAVAIL,
  2254|         ENETDOWN = libc::ENETDOWN,
  2255|         ENETUNREACH = libc::ENETUNREACH,
  2256|         ENETRESET = libc::ENETRESET,
  2257|         ECONNABORTED = libc::ECONNABORTED,
  2258|         ECONNRESET = libc::ECONNRESET,
  2259|         ENOBUFS = libc::ENOBUFS,
  2260|         EISCONN = libc::EISCONN,
  2261|         ENOTCONN = libc::ENOTCONN,
  2262|         ESHUTDOWN = libc::ESHUTDOWN,
  2263|         ETOOMANYREFS = libc::ETOOMANYREFS,
  2264|         ETIMEDOUT = libc::ETIMEDOUT,
  2265|         ECONNREFUSED = libc::ECONNREFUSED,
  2266|         EHOSTDOWN = libc::EHOSTDOWN,
  2267|         EHOSTUNREACH = libc::EHOSTUNREACH,
  2268|         EALREADY = libc::EALREADY,
  2269|         EINPROGRESS = libc::EINPROGRESS,
  2270|         ESTALE = libc::ESTALE,
  2271|     }
  2272|     impl Errno {
  2273|         pub const ELAST: Errno       = Errno::ESTALE;
  2274|         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
  2275|     }
  2276|     pub fn from_i32(e: i32) -> Errno {
  2277|         use self::Errno::*;
  2278|         match e {
  2279|             libc::EPERM => EPERM,
  2280|             libc::ENOENT => ENOENT,
  2281|             libc::ESRCH => ESRCH,
  2282|             libc::EINTR => EINTR,
  2283|             libc::EIO => EIO,
  2284|             libc::ENXIO => ENXIO,
  2285|             libc::E2BIG => E2BIG,
  2286|             libc::ENOEXEC => ENOEXEC,
  2287|             libc::EBADF => EBADF,
  2288|             libc::ECHILD => ECHILD,
  2289|             libc::EAGAIN => EAGAIN,
  2290|             libc::ENOMEM => ENOMEM,
  2291|             libc::EACCES => EACCES,


# ====================================================================
# FILE: src/fcntl.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-535 ---
     1| use crate::errno::Errno;
     2| use libc::{self, c_char, c_int, c_uint, size_t, ssize_t};
     3| use std::ffi::OsString;
     4| #[cfg(not(target_os = "redox"))]
     5| use std::os::raw;
     6| use std::os::unix::ffi::OsStringExt;
     7| use std::os::unix::io::RawFd;
     8| use crate::sys::stat::Mode;
     9| use crate::{NixPath, Result};
    10| #[cfg(any(target_os = "android", target_os = "linux"))]
    11| use std::ptr; // For splice and copy_file_range
    12| #[cfg(any(target_os = "android", target_os = "linux"))]
    13| use crate::sys::uio::IoVec; // For vmsplice
    14| #[cfg(any(
    15|     target_os = "linux",
    16|     target_os = "android",
    17|     target_os = "emscripten",
    18|     target_os = "fuchsia",
    19|     any(target_os = "wasi", target_env = "wasi"),
    20|     target_env = "uclibc",
    21|     target_os = "freebsd"
    22| ))]
    23| pub use self::posix_fadvise::*;
    24| #[cfg(not(target_os = "redox"))]
    25| libc_bitflags! {
    26|     pub struct AtFlags: c_int {
    27|         AT_REMOVEDIR;
    28|         AT_SYMLINK_FOLLOW;
    29|         AT_SYMLINK_NOFOLLOW;
    30|         #[cfg(any(target_os = "android", target_os = "linux"))]
    31|         AT_NO_AUTOMOUNT;
    32|         #[cfg(any(target_os = "android", target_os = "linux"))]
    33|         AT_EMPTY_PATH;
    34|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
    35|         AT_EACCESS;
    36|     }
    37| }
    38| libc_bitflags!(
    39|     pub struct OFlag: c_int {
    40|         O_ACCMODE;
    41|         #[cfg(target_os = "netbsd")]
    42|         O_ALT_IO;
    43|         O_APPEND;
    44|         #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
    45|         O_ASYNC;
    46|         O_CLOEXEC;
    47|         O_CREAT;
    48|         #[cfg(any(target_os = "android",
    49|                   target_os = "dragonfly",
    50|                   target_os = "freebsd",
    51|                   target_os = "linux",
    52|                   target_os = "netbsd"))]
    53|         O_DIRECT;
    54|         #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
    55|         O_DIRECTORY;
    56|         #[cfg(any(target_os = "android",
    57|                   target_os = "ios",
    58|                   target_os = "linux",
    59|                   target_os = "macos",
    60|                   target_os = "netbsd",
    61|                   target_os = "openbsd"))]
    62|         O_DSYNC;
    63|         O_EXCL;
    64|         #[cfg(target_os = "freebsd")]
    65|         O_EXEC;
    66|         #[cfg(any(target_os = "dragonfly",
    67|                   target_os = "freebsd",
    68|                   target_os = "ios",
    69|                   target_os = "macos",
    70|                   target_os = "netbsd",
    71|                   target_os = "openbsd",
    72|                   target_os = "redox"))]
    73|         O_EXLOCK;
    74|         #[cfg(any(target_os = "dragonfly",
    75|                   target_os = "freebsd",
    76|                   target_os = "ios",
    77|                   all(target_os = "linux", not(target_env = "musl")),
    78|                   target_os = "macos",
    79|                   target_os = "netbsd",
    80|                   target_os = "openbsd",
    81|                   target_os = "redox"))]
    82|         O_FSYNC;
    83|         #[cfg(any(target_os = "android", target_os = "linux"))]
    84|         O_LARGEFILE;
    85|         #[cfg(any(target_os = "android", target_os = "linux"))]
    86|         O_NOATIME;
    87|         #[cfg(not(target_os = "redox"))]
    88|         O_NOCTTY;
    89|         #[cfg(not(target_os = "redox"))]
    90|         O_NDELAY;
    91|         O_NOFOLLOW;
    92|         O_NONBLOCK;
    93|         #[cfg(target_os = "netbsd")]
    94|         O_NOSIGPIPE;
    95|         #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
    96|         O_PATH;
    97|         O_RDONLY;
    98|         O_RDWR;
    99|         #[cfg(any(target_os = "linux", target_os = "netbsd", target_os = "openbsd"))]
   100|         O_RSYNC;
   101|         #[cfg(target_os = "netbsd")]
   102|         O_SEARCH;
   103|         #[cfg(any(target_os = "dragonfly",
   104|                   target_os = "freebsd",
   105|                   target_os = "ios",
   106|                   target_os = "macos",
   107|                   target_os = "netbsd",
   108|                   target_os = "openbsd",
   109|                   target_os = "redox"))]
   110|         O_SHLOCK;
   111|         #[cfg(not(target_os = "redox"))]
   112|         O_SYNC;
   113|         #[cfg(any(target_os = "android", target_os = "linux"))]
   114|         O_TMPFILE;
   115|         O_TRUNC;
   116|         #[cfg(target_os = "freebsd")]
   117|         O_TTY_INIT;
   118|         O_WRONLY;
   119|     }
   120| );
   121| #[allow(clippy::useless_conversion)]
   122| pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag, mode: Mode) -> Result<RawFd> {
   123|     let fd = path.with_nix_path(|cstr| {
   124|         unsafe { libc::open(cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
   125|     })?;
   126|     Errno::result(fd)
   127| }
   128| #[allow(clippy::useless_conversion)]
   129| #[cfg(not(target_os = "redox"))]
   130| pub fn openat<P: ?Sized + NixPath>(
   131|     dirfd: RawFd,
   132|     path: &P,
   133|     oflag: OFlag,
   134|     mode: Mode,
   135| ) -> Result<RawFd> {
   136|     let fd = path.with_nix_path(|cstr| {
   137|         unsafe { libc::openat(dirfd, cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
   138|     })?;
   139|     Errno::result(fd)
   140| }
   141| #[cfg(not(target_os = "redox"))]
   142| pub fn renameat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
   143|     old_dirfd: Option<RawFd>,
   144|     old_path: &P1,
   145|     new_dirfd: Option<RawFd>,
   146|     new_path: &P2,
   147| ) -> Result<()> {
   148|     let res = old_path.with_nix_path(|old_cstr| {
   149|         new_path.with_nix_path(|new_cstr| unsafe {
   150|             libc::renameat(
   151|                 at_rawfd(old_dirfd),
   152|                 old_cstr.as_ptr(),
   153|                 at_rawfd(new_dirfd),
   154|                 new_cstr.as_ptr(),
   155|             )
   156|         })
   157|     })??;
   158|     Errno::result(res).map(drop)
   159| }
   160| #[cfg(all(
   161|     target_os = "linux",
   162|     target_env = "gnu",
   163| ))]
   164| libc_bitflags! {
   165|     pub struct RenameFlags: u32 {
   166|         RENAME_EXCHANGE;
   167|         RENAME_NOREPLACE;
   168|         RENAME_WHITEOUT;
   169|     }
   170| }
   171| #[cfg(all(
   172|     target_os = "linux",
   173|     target_env = "gnu",
   174| ))]
   175| pub fn renameat2<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
   176|     old_dirfd: Option<RawFd>,
   177|     old_path: &P1,
   178|     new_dirfd: Option<RawFd>,
   179|     new_path: &P2,
   180|     flags: RenameFlags,
   181| ) -> Result<()> {
   182|     let res = old_path.with_nix_path(|old_cstr| {
   183|         new_path.with_nix_path(|new_cstr| unsafe {
   184|             libc::renameat2(
   185|                 at_rawfd(old_dirfd),
   186|                 old_cstr.as_ptr(),
   187|                 at_rawfd(new_dirfd),
   188|                 new_cstr.as_ptr(),
   189|                 flags.bits(),
   190|             )
   191|         })
   192|     })??;
   193|     Errno::result(res).map(drop)
   194| }
   195| fn wrap_readlink_result(mut v: Vec<u8>, len: ssize_t) -> Result<OsString> {
   196|     unsafe { v.set_len(len as usize) }
   197|     v.shrink_to_fit();
   198|     Ok(OsString::from_vec(v.to_vec()))
   199| }
   200| fn readlink_maybe_at<P: ?Sized + NixPath>(
   201|     dirfd: Option<RawFd>,
   202|     path: &P,
   203|     v: &mut Vec<u8>,
   204| ) -> Result<libc::ssize_t> {
   205|     path.with_nix_path(|cstr| unsafe {
   206|         match dirfd {
   207|             #[cfg(target_os = "redox")]
   208|             Some(_) => unreachable!(),
   209|             #[cfg(not(target_os = "redox"))]
   210|             Some(dirfd) => libc::readlinkat(
   211|                 dirfd,
   212|                 cstr.as_ptr(),
   213|                 v.as_mut_ptr() as *mut c_char,
   214|                 v.capacity() as size_t,
   215|             ),
   216|             None => libc::readlink(
   217|                 cstr.as_ptr(),
   218|                 v.as_mut_ptr() as *mut c_char,
   219|                 v.capacity() as size_t,
   220|             ),
   221|         }
   222|     })
   223| }
   224| fn inner_readlink<P: ?Sized + NixPath>(dirfd: Option<RawFd>, path: &P) -> Result<OsString> {
   225|     let mut v = Vec::with_capacity(libc::PATH_MAX as usize);
   226|     let res = readlink_maybe_at(dirfd, path, &mut v)?;
   227|     let len = Errno::result(res)?;
   228|     debug_assert!(len >= 0);
   229|     if (len as usize) < v.capacity() {
   230|         return wrap_readlink_result(v, res);
   231|     }
   232|     let reported_size = match dirfd {
   233|         #[cfg(target_os = "redox")]
   234|         Some(_) => unreachable!(),
   235|         #[cfg(any(target_os = "android", target_os = "linux"))]
   236|         Some(dirfd) => {
   237|             let flags = if path.is_empty() { AtFlags::AT_EMPTY_PATH } else { AtFlags::empty() };
   238|             super::sys::stat::fstatat(dirfd, path, flags | AtFlags::AT_SYMLINK_NOFOLLOW)
   239|         },
   240|         #[cfg(not(any(target_os = "android", target_os = "linux", target_os = "redox")))]
   241|         Some(dirfd) => super::sys::stat::fstatat(dirfd, path, AtFlags::AT_SYMLINK_NOFOLLOW),
   242|         None => super::sys::stat::lstat(path)
   243|     }
   244|         .map(|x| x.st_size)
   245|         .unwrap_or(0);
   246|     let mut try_size = if reported_size > 0 {
   247|         reported_size as usize + 1
   248|     } else {
   249|         (libc::PATH_MAX as usize).max(128) << 1
   250|     };
   251|     loop {
   252|         v.reserve_exact(try_size);
   253|         let res = readlink_maybe_at(dirfd, path, &mut v)?;
   254|         let len = Errno::result(res)?;
   255|         debug_assert!(len >= 0);
   256|         if (len as usize) < v.capacity() {
   257|             break wrap_readlink_result(v, res);
   258|         } else {
   259|             match try_size.checked_shl(1) {
   260|                 Some(next_size) => try_size = next_size,
   261|                 None => break Err(super::Error::from(Errno::ENAMETOOLONG)),
   262|             }
   263|         }
   264|     }
   265| }
   266| pub fn readlink<P: ?Sized + NixPath>(path: &P) -> Result<OsString> {
   267|     inner_readlink(None, path)
   268| }
   269| #[cfg(not(target_os = "redox"))]
   270| pub fn readlinkat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P) -> Result<OsString> {
   271|     inner_readlink(Some(dirfd), path)
   272| }
   273| #[cfg(not(target_os = "redox"))]
   274| pub(crate) fn at_rawfd(fd: Option<RawFd>) -> raw::c_int {
   275|     match fd {
   276|         None => libc::AT_FDCWD,
   277|         Some(fd) => fd,
   278|     }
   279| }
   280| #[cfg(any(target_os = "android", target_os = "linux"))]
   281| libc_bitflags!(
   282|     pub struct SealFlag: c_int {
   283|         F_SEAL_SEAL;
   284|         F_SEAL_SHRINK;
   285|         F_SEAL_GROW;
   286|         F_SEAL_WRITE;
   287|     }
   288| );
   289| libc_bitflags!(
   290|     pub struct FdFlag: c_int {
   291|         FD_CLOEXEC;
   292|     }
   293| );
   294| #[cfg(not(target_os = "redox"))]
   295| #[derive(Debug, Eq, Hash, PartialEq)]
   296| pub enum FcntlArg<'a> {
   297|     F_DUPFD(RawFd),
   298|     F_DUPFD_CLOEXEC(RawFd),
   299|     F_GETFD,
   300|     F_SETFD(FdFlag), // FD_FLAGS
   301|     F_GETFL,
   302|     F_SETFL(OFlag), // O_NONBLOCK
   303|     F_SETLK(&'a libc::flock),
   304|     F_SETLKW(&'a libc::flock),
   305|     F_GETLK(&'a mut libc::flock),
   306|     #[cfg(any(target_os = "linux", target_os = "android"))]
   307|     F_OFD_SETLK(&'a libc::flock),
   308|     #[cfg(any(target_os = "linux", target_os = "android"))]
   309|     F_OFD_SETLKW(&'a libc::flock),
   310|     #[cfg(any(target_os = "linux", target_os = "android"))]
   311|     F_OFD_GETLK(&'a mut libc::flock),
   312|     #[cfg(any(target_os = "android", target_os = "linux"))]
   313|     F_ADD_SEALS(SealFlag),
   314|     #[cfg(any(target_os = "android", target_os = "linux"))]
   315|     F_GET_SEALS,
   316|     #[cfg(any(target_os = "macos", target_os = "ios"))]
   317|     F_FULLFSYNC,
   318|     #[cfg(any(target_os = "linux", target_os = "android"))]
   319|     F_GETPIPE_SZ,
   320|     #[cfg(any(target_os = "linux", target_os = "android"))]
   321|     F_SETPIPE_SZ(c_int),
   322| }
   323| #[cfg(target_os = "redox")]
   324| #[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]
   325| pub enum FcntlArg {
   326|     F_DUPFD(RawFd),
   327|     F_DUPFD_CLOEXEC(RawFd),
   328|     F_GETFD,
   329|     F_SETFD(FdFlag), // FD_FLAGS
   330|     F_GETFL,
   331|     F_SETFL(OFlag), // O_NONBLOCK
   332| }
   333| pub use self::FcntlArg::*;
   334| pub fn fcntl(fd: RawFd, arg: FcntlArg) -> Result<c_int> {
   335|     let res = unsafe {
   336|         match arg {
   337|             F_DUPFD(rawfd) => libc::fcntl(fd, libc::F_DUPFD, rawfd),
   338|             F_DUPFD_CLOEXEC(rawfd) => libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, rawfd),
   339|             F_GETFD => libc::fcntl(fd, libc::F_GETFD),
   340|             F_SETFD(flag) => libc::fcntl(fd, libc::F_SETFD, flag.bits()),
   341|             F_GETFL => libc::fcntl(fd, libc::F_GETFL),
   342|             F_SETFL(flag) => libc::fcntl(fd, libc::F_SETFL, flag.bits()),
   343|             #[cfg(not(target_os = "redox"))]
   344|             F_SETLK(flock) => libc::fcntl(fd, libc::F_SETLK, flock),
   345|             #[cfg(not(target_os = "redox"))]
   346|             F_SETLKW(flock) => libc::fcntl(fd, libc::F_SETLKW, flock),
   347|             #[cfg(not(target_os = "redox"))]
   348|             F_GETLK(flock) => libc::fcntl(fd, libc::F_GETLK, flock),
   349|             #[cfg(any(target_os = "android", target_os = "linux"))]
   350|             F_OFD_SETLK(flock) => libc::fcntl(fd, libc::F_OFD_SETLK, flock),
   351|             #[cfg(any(target_os = "android", target_os = "linux"))]
   352|             F_OFD_SETLKW(flock) => libc::fcntl(fd, libc::F_OFD_SETLKW, flock),
   353|             #[cfg(any(target_os = "android", target_os = "linux"))]
   354|             F_OFD_GETLK(flock) => libc::fcntl(fd, libc::F_OFD_GETLK, flock),
   355|             #[cfg(any(target_os = "android", target_os = "linux"))]
   356|             F_ADD_SEALS(flag) => libc::fcntl(fd, libc::F_ADD_SEALS, flag.bits()),
   357|             #[cfg(any(target_os = "android", target_os = "linux"))]
   358|             F_GET_SEALS => libc::fcntl(fd, libc::F_GET_SEALS),
   359|             #[cfg(any(target_os = "macos", target_os = "ios"))]
   360|             F_FULLFSYNC => libc::fcntl(fd, libc::F_FULLFSYNC),
   361|             #[cfg(any(target_os = "linux", target_os = "android"))]
   362|             F_GETPIPE_SZ => libc::fcntl(fd, libc::F_GETPIPE_SZ),
   363|             #[cfg(any(target_os = "linux", target_os = "android"))]
   364|             F_SETPIPE_SZ(size) => libc::fcntl(fd, libc::F_SETPIPE_SZ, size),
   365|         }
   366|     };
   367|     Errno::result(res)
   368| }
   369| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   370| pub enum FlockArg {
   371|     LockShared,
   372|     LockExclusive,
   373|     Unlock,
   374|     LockSharedNonblock,
   375|     LockExclusiveNonblock,
   376|     UnlockNonblock,
   377| }
   378| #[cfg(not(target_os = "redox"))]
   379| pub fn flock(fd: RawFd, arg: FlockArg) -> Result<()> {
   380|     use self::FlockArg::*;
   381|     let res = unsafe {
   382|         match arg {
   383|             LockShared => libc::flock(fd, libc::LOCK_SH),
   384|             LockExclusive => libc::flock(fd, libc::LOCK_EX),
   385|             Unlock => libc::flock(fd, libc::LOCK_UN),
   386|             LockSharedNonblock => libc::flock(fd, libc::LOCK_SH | libc::LOCK_NB),
   387|             LockExclusiveNonblock => libc::flock(fd, libc::LOCK_EX | libc::LOCK_NB),
   388|             UnlockNonblock => libc::flock(fd, libc::LOCK_UN | libc::LOCK_NB),
   389|         }
   390|     };
   391|     Errno::result(res).map(drop)
   392| }
   393| #[cfg(any(target_os = "android", target_os = "linux"))]
   394| libc_bitflags! {
   395|     pub struct SpliceFFlags: c_uint {
   396|         SPLICE_F_MOVE;
   397|         SPLICE_F_NONBLOCK;
   398|         SPLICE_F_MORE;
   399|         SPLICE_F_GIFT;
   400|     }
   401| }
   402| #[cfg(any(target_os = "android", target_os = "linux"))]
   403| pub fn copy_file_range(
   404|     fd_in: RawFd,
   405|     off_in: Option<&mut libc::loff_t>,
   406|     fd_out: RawFd,
   407|     off_out: Option<&mut libc::loff_t>,
   408|     len: usize,
   409| ) -> Result<usize> {
   410|     let off_in = off_in
   411|         .map(|offset| offset as *mut libc::loff_t)
   412|         .unwrap_or(ptr::null_mut());
   413|     let off_out = off_out
   414|         .map(|offset| offset as *mut libc::loff_t)
   415|         .unwrap_or(ptr::null_mut());
   416|     let ret = unsafe {
   417|         libc::syscall(
   418|             libc::SYS_copy_file_range,
   419|             fd_in,
   420|             off_in,
   421|             fd_out,
   422|             off_out,
   423|             len,
   424|             0,
   425|         )
   426|     };
   427|     Errno::result(ret).map(|r| r as usize)
   428| }
   429| #[cfg(any(target_os = "linux", target_os = "android"))]
   430| pub fn splice(
   431|     fd_in: RawFd,
   432|     off_in: Option<&mut libc::loff_t>,
   433|     fd_out: RawFd,
   434|     off_out: Option<&mut libc::loff_t>,
   435|     len: usize,
   436|     flags: SpliceFFlags,
   437| ) -> Result<usize> {
   438|     let off_in = off_in
   439|         .map(|offset| offset as *mut libc::loff_t)
   440|         .unwrap_or(ptr::null_mut());
   441|     let off_out = off_out
   442|         .map(|offset| offset as *mut libc::loff_t)
   443|         .unwrap_or(ptr::null_mut());
   444|     let ret = unsafe { libc::splice(fd_in, off_in, fd_out, off_out, len, flags.bits()) };
   445|     Errno::result(ret).map(|r| r as usize)
   446| }
   447| #[cfg(any(target_os = "linux", target_os = "android"))]
   448| pub fn tee(fd_in: RawFd, fd_out: RawFd, len: usize, flags: SpliceFFlags) -> Result<usize> {
   449|     let ret = unsafe { libc::tee(fd_in, fd_out, len, flags.bits()) };
   450|     Errno::result(ret).map(|r| r as usize)
   451| }
   452| #[cfg(any(target_os = "linux", target_os = "android"))]
   453| pub fn vmsplice(fd: RawFd, iov: &[IoVec<&[u8]>], flags: SpliceFFlags) -> Result<usize> {
   454|     let ret = unsafe {
   455|         libc::vmsplice(
   456|             fd,
   457|             iov.as_ptr() as *const libc::iovec,
   458|             iov.len(),
   459|             flags.bits(),
   460|         )
   461|     };
   462|     Errno::result(ret).map(|r| r as usize)
   463| }
   464| #[cfg(any(target_os = "linux"))]
   465| libc_bitflags!(
   466|     pub struct FallocateFlags: c_int {
   467|         FALLOC_FL_KEEP_SIZE;
   468|         FALLOC_FL_PUNCH_HOLE;
   469|         FALLOC_FL_COLLAPSE_RANGE;
   470|         FALLOC_FL_ZERO_RANGE;
   471|         FALLOC_FL_INSERT_RANGE;
   472|         FALLOC_FL_UNSHARE_RANGE;
   473|     }
   474| );
   475| #[cfg(any(target_os = "linux"))]
   476| pub fn fallocate(
   477|     fd: RawFd,
   478|     mode: FallocateFlags,
   479|     offset: libc::off_t,
   480|     len: libc::off_t,
   481| ) -> Result<()> {
   482|     let res = unsafe { libc::fallocate(fd, mode.bits(), offset, len) };
   483|     Errno::result(res).map(drop)
   484| }
   485| #[cfg(any(
   486|     target_os = "linux",
   487|     target_os = "android",
   488|     target_os = "emscripten",
   489|     target_os = "fuchsia",
   490|     any(target_os = "wasi", target_env = "wasi"),
   491|     target_env = "uclibc",
   492|     target_os = "freebsd"
   493| ))]
   494| mod posix_fadvise {
   495|     use crate::errno::Errno;
   496|     use libc;
   497|     use std::os::unix::io::RawFd;
   498|     use crate::Result;
   499|     libc_enum! {
   500|         #[repr(i32)]
   501|         pub enum PosixFadviseAdvice {
   502|             POSIX_FADV_NORMAL,
   503|             POSIX_FADV_SEQUENTIAL,
   504|             POSIX_FADV_RANDOM,
   505|             POSIX_FADV_NOREUSE,
   506|             POSIX_FADV_WILLNEED,
   507|             POSIX_FADV_DONTNEED,
   508|         }
   509|     }
   510|     pub fn posix_fadvise(
   511|         fd: RawFd,
   512|         offset: libc::off_t,
   513|         len: libc::off_t,
   514|         advice: PosixFadviseAdvice,
   515|     ) -> Result<libc::c_int> {
   516|         let res = unsafe { libc::posix_fadvise(fd, offset, len, advice as libc::c_int) };
   517|         Errno::result(res)
   518|     }
   519| }
   520| #[cfg(any(
   521|     target_os = "linux",
   522|     target_os = "android",
   523|     target_os = "emscripten",
   524|     target_os = "fuchsia",
   525|     any(target_os = "wasi", target_env = "wasi"),
   526|     target_os = "freebsd"
   527| ))]
   528| pub fn posix_fallocate(fd: RawFd, offset: libc::off_t, len: libc::off_t) -> Result<()> {
   529|     let res = unsafe { libc::posix_fallocate(fd, offset, len) };
   530|     match Errno::result(res) {
   531|         Err(err) => Err(err),
   532|         Ok(0) => Ok(()),
   533|         Ok(errno) => Err(crate::Error::from(Errno::from_i32(errno))),
   534|     }
   535| }


# ====================================================================
# FILE: src/lib.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-162 ---
     1| #![crate_name = "nix"]
     2| #![cfg(unix)]
     3| #![allow(non_camel_case_types)]
     4| #![allow(dead_code)]
     5| #![cfg_attr(test, deny(warnings))]
     6| #![recursion_limit = "500"]
     7| #![deny(unused)]
     8| #![deny(unstable_features)]
     9| #![deny(missing_copy_implementations)]
    10| #![deny(missing_debug_implementations)]
    11| pub use libc;
    12| #[macro_use] mod macros;
    13| #[cfg(not(target_os = "redox"))]
    14| pub mod dir;
    15| pub mod env;
    16| pub mod errno;
    17| #[deny(missing_docs)]
    18| pub mod features;
    19| pub mod fcntl;
    20| #[deny(missing_docs)]
    21| #[cfg(any(target_os = "android",
    22|           target_os = "dragonfly",
    23|           target_os = "freebsd",
    24|           target_os = "ios",
    25|           target_os = "linux",
    26|           target_os = "macos",
    27|           target_os = "netbsd",
    28|           target_os = "illumos",
    29|           target_os = "openbsd"))]
    30| pub mod ifaddrs;
    31| #[cfg(any(target_os = "android",
    32|           target_os = "linux"))]
    33| pub mod kmod;
    34| #[cfg(any(target_os = "android",
    35|           target_os = "freebsd",
    36|           target_os = "linux"))]
    37| pub mod mount;
    38| #[cfg(any(target_os = "dragonfly",
    39|           target_os = "freebsd",
    40|           target_os = "fushsia",
    41|           target_os = "linux",
    42|           target_os = "netbsd"))]
    43| pub mod mqueue;
    44| #[deny(missing_docs)]
    45| #[cfg(not(target_os = "redox"))]
    46| pub mod net;
    47| #[deny(missing_docs)]
    48| pub mod poll;
    49| #[deny(missing_docs)]
    50| #[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
    51| pub mod pty;
    52| pub mod sched;
    53| pub mod sys;
    54| pub mod time;
    55| #[cfg(all(target_os = "linux",
    56|           any(target_arch = "x86", target_arch = "x86_64")))]
    57| pub mod ucontext;
    58| pub mod unistd;
    59| /*
    60|  *
    61|  * ===== Result / Error =====
    62|  *
    63|  */
    64| use libc::{c_char, PATH_MAX};
    65| use std::{ptr, result};
    66| use std::ffi::{CStr, OsStr};
    67| use std::os::unix::ffi::OsStrExt;
    68| use std::path::{Path, PathBuf};
    69| use errno::Errno;
    70| pub type Result<T> = result::Result<T, Errno>;
    71| pub type Error = Errno;
    72| pub trait NixPath {
    73|     fn is_empty(&self) -> bool;
    74|     fn len(&self) -> usize;
    75|     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
    76|         where F: FnOnce(&CStr) -> T;
    77| }
    78| impl NixPath for str {
    79|     fn is_empty(&self) -> bool {
    80|         NixPath::is_empty(OsStr::new(self))
    81|     }
    82|     fn len(&self) -> usize {
    83|         NixPath::len(OsStr::new(self))
    84|     }
    85|     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
    86|         where F: FnOnce(&CStr) -> T {
    87|             OsStr::new(self).with_nix_path(f)
    88|         }
    89| }
    90| impl NixPath for OsStr {
    91|     fn is_empty(&self) -> bool {
    92|         self.as_bytes().is_empty()
    93|     }
    94|     fn len(&self) -> usize {
    95|         self.as_bytes().len()
    96|     }
    97|     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
    98|         where F: FnOnce(&CStr) -> T {
    99|             self.as_bytes().with_nix_path(f)
   100|         }
   101| }
   102| impl NixPath for CStr {
   103|     fn is_empty(&self) -> bool {
   104|         self.to_bytes().is_empty()
   105|     }
   106|     fn len(&self) -> usize {
   107|         self.to_bytes().len()
   108|     }
   109|     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
   110|             where F: FnOnce(&CStr) -> T {
   111|         if self.len() >= PATH_MAX as usize {
   112|             return Err(Error::from(Errno::ENAMETOOLONG))
   113|         }
   114|         Ok(f(self))
   115|     }
   116| }
   117| impl NixPath for [u8] {
   118|     fn is_empty(&self) -> bool {
   119|         self.is_empty()
   120|     }
   121|     fn len(&self) -> usize {
   122|         self.len()
   123|     }
   124|     fn with_nix_path<T, F>(&self, f: F) -> Result<T>
   125|             where F: FnOnce(&CStr) -> T {
   126|         let mut buf = [0u8; PATH_MAX as usize];
   127|         if self.len() >= PATH_MAX as usize {
   128|             return Err(Error::from(Errno::ENAMETOOLONG))
   129|         }
   130|         match self.iter().position(|b| *b == 0) {
   131|             Some(_) => Err(Error::from(Errno::EINVAL)),
   132|             None => {
   133|                 unsafe {
   134|                     ptr::copy_nonoverlapping(self.as_ptr(), buf.as_mut_ptr(), self.len());
   135|                     Ok(f(CStr::from_ptr(buf.as_ptr() as *const c_char)))
   136|                 }
   137|             }
   138|         }
   139|     }
   140| }
   141| impl NixPath for Path {
   142|     fn is_empty(&self) -> bool {
   143|         NixPath::is_empty(self.as_os_str())
   144|     }
   145|     fn len(&self) -> usize {
   146|         NixPath::len(self.as_os_str())
   147|     }
   148|     fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
   149|         self.as_os_str().with_nix_path(f)
   150|     }
   151| }
   152| impl NixPath for PathBuf {
   153|     fn is_empty(&self) -> bool {
   154|         NixPath::is_empty(self.as_os_str())
   155|     }
   156|     fn len(&self) -> usize {
   157|         NixPath::len(self.as_os_str())
   158|     }
   159|     fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
   160|         self.as_os_str().with_nix_path(f)
   161|     }
   162| }


# ====================================================================
# FILE: src/mount/bsd.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-229 ---
     1| use crate::{
     2|     Error,
     3|     Errno,
     4|     NixPath,
     5|     Result,
     6|     sys::uio::IoVec
     7| };
     8| use libc::{c_char, c_int, c_uint, c_void};
     9| use std::{
    10|     borrow::Cow,
    11|     ffi::{CString, CStr},
    12|     fmt,
    13|     io,
    14|     ptr
    15| };
    16| libc_bitflags!(
    17|     pub struct MntFlags: c_int {
    18|         #[cfg(any(target_os = "netbsd", target_os = "freebsd"))]
    19|         MNT_ACLS;
    20|         MNT_ASYNC;
    21|         #[cfg(target_os = "freebsd")]
    22|         MNT_BYFSID;
    23|         MNT_FORCE;
    24|         #[cfg(target_os = "freebsd")]
    25|         MNT_GJOURNAL;
    26|         #[cfg(any(target_os = "macos", target_os = "freebsd"))]
    27|         MNT_MULTILABEL;
    28|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
    29|         MNT_NOCLUSTERR;
    30|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
    31|         MNT_NOCLUSTERW;
    32|         #[cfg(target_os = "freebsd")]
    33|         MNT_NFS4ACLS;
    34|         MNT_NOATIME;
    35|         MNT_NOEXEC;
    36|         MNT_NOSUID;
    37|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
    38|         MNT_NOSYMFOLLOW;
    39|         MNT_RDONLY;
    40|         MNT_RELOAD;
    41|         #[cfg(any(target_os = "macos", target_os = "freebsd"))]
    42|         MNT_SNAPSHOT;
    43|         #[cfg(any(
    44|                 target_os = "dragonfly",
    45|                 target_os = "freebsd",
    46|                 target_os = "netbsd",
    47|                 target_os = "openbsd"
    48|         ))]
    49|         MNT_SOFTDEP;
    50|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
    51|         MNT_SUIDDIR;
    52|         MNT_SYNCHRONOUS;
    53|         #[cfg(any(
    54|                 target_os = "macos",
    55|                 target_os = "freebsd",
    56|                 target_os = "netbsd"
    57|         ))]
    58|         MNT_UNION;
    59|         MNT_UPDATE;
    60|         #[cfg(target_os = "freebsd")]
    61|         MNT_NONBUSY;
    62|     }
    63| );
    64| #[derive(Debug)]
    65| pub struct NmountError {
    66|     errno: Error,
    67|     errmsg: Option<String>
    68| }
    69| impl NmountError {
    70|     pub fn errmsg(&self) -> Option<&str> {
    71|         self.errmsg.as_deref()
    72|     }
    73|     pub fn error(&self) -> Error {
    74|         self.errno
    75|     }
    76|     fn new(error: Error, errmsg: Option<&CStr>) -> Self {
    77|         Self {
    78|             errno: error,
    79|             errmsg: errmsg.map(CStr::to_string_lossy).map(Cow::into_owned)
    80|         }
    81|     }
    82| }
    83| impl std::error::Error for NmountError {}
    84| impl fmt::Display for NmountError {
    85|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    86|         if let Some(errmsg) = &self.errmsg {
    87|             write!(f, "{:?}: {}: {}", self.errno, errmsg, self.errno.desc())
    88|         } else {
    89|             write!(f, "{:?}: {}", self.errno, self.errno.desc())
    90|         }
    91|     }
    92| }
    93| impl From<NmountError> for io::Error {
    94|     fn from(err: NmountError) -> Self {
    95|         err.errno.into()
    96|     }
    97| }
    98| pub type NmountResult = std::result::Result<(), NmountError>;
    99| #[cfg(target_os = "freebsd")]
   100| #[derive(Debug, Default)]
   101| pub struct Nmount<'a>{
   102|     iov: Vec<IoVec<&'a [u8]>>,
   103|     is_owned: Vec<bool>,
   104| }
   105| #[cfg(target_os = "freebsd")]
   106| impl<'a> Nmount<'a> {
   107|     pub unsafe fn mut_ptr_opt(
   108|         &mut self,
   109|         name: &'a CStr,
   110|         val: *mut c_void,
   111|         len: usize
   112|     ) -> &mut Self
   113|     {
   114|         self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
   115|         self.is_owned.push(false);
   116|         self.iov.push(IoVec::from_raw_parts(val, len));
   117|         self.is_owned.push(false);
   118|         self
   119|     }
   120|     pub fn null_opt(&mut self, name: &'a CStr) -> &mut Self {
   121|         self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
   122|         self.is_owned.push(false);
   123|         self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
   124|         self.is_owned.push(false);
   125|         self
   126|     }
   127|     pub fn null_opt_owned<P: ?Sized + NixPath>(&mut self, name: &P) -> &mut Self
   128|     {
   129|         name.with_nix_path(|s| {
   130|             let len = s.to_bytes_with_nul().len();
   131|             self.iov.push(IoVec::from_raw_parts(
   132|                 s.to_owned().into_raw() as *mut c_void,
   133|                 len
   134|             ));
   135|             self.is_owned.push(true);
   136|         }).unwrap();
   137|         self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
   138|         self.is_owned.push(false);
   139|         self
   140|     }
   141|     pub fn str_opt(
   142|         &mut self,
   143|         name: &'a CStr,
   144|         val: &'a CStr
   145|     ) -> &mut Self
   146|     {
   147|         self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
   148|         self.is_owned.push(false);
   149|         self.iov.push(IoVec::from_slice(val.to_bytes_with_nul()));
   150|         self.is_owned.push(false);
   151|         self
   152|     }
   153|     pub fn str_opt_owned<P1, P2>(&mut self, name: &P1, val: &P2) -> &mut Self
   154|         where P1: ?Sized + NixPath,
   155|               P2: ?Sized + NixPath
   156|     {
   157|         name.with_nix_path(|s| {
   158|             let len = s.to_bytes_with_nul().len();
   159|             self.iov.push(IoVec::from_raw_parts(
   160|                 s.to_owned().into_raw() as *mut c_void,
   161|                 len
   162|             ));
   163|             self.is_owned.push(true);
   164|         }).unwrap();
   165|         val.with_nix_path(|s| {
   166|             let len = s.to_bytes_with_nul().len();
   167|             self.iov.push(IoVec::from_raw_parts(
   168|                 s.to_owned().into_raw() as *mut c_void,
   169|                 len
   170|             ));
   171|             self.is_owned.push(true);
   172|         }).unwrap();
   173|         self
   174|     }
   175|     pub fn new() -> Self {
   176|         Self::default()
   177|     }
   178|     pub fn nmount(&mut self, flags: MntFlags) -> NmountResult {
   179|         const ERRMSG_NAME: &[u8] = b"errmsg\0";
   180|         let mut errmsg = vec![0u8; 255];
   181|         self.iov.push(IoVec::from_raw_parts(
   182|                 ERRMSG_NAME.as_ptr() as *mut c_void,
   183|                 ERRMSG_NAME.len()
   184|         ));
   185|         self.iov.push(IoVec::from_raw_parts(
   186|                 errmsg.as_mut_ptr() as *mut c_void,
   187|                 errmsg.len()
   188|         ));
   189|         let niov = self.iov.len() as c_uint;
   190|         let iovp = self.iov.as_mut_ptr() as *mut libc::iovec;
   191|         let res = unsafe {
   192|             libc::nmount(iovp, niov, flags.bits)
   193|         };
   194|         match Errno::result(res) {
   195|             Ok(_) => Ok(()),
   196|             Err(error) => {
   197|                 let errmsg = match errmsg.iter().position(|&x| x == 0) {
   198|                     None => None,
   199|                     Some(0) => None,
   200|                     Some(n) => {
   201|                         let sl = &errmsg[0..n + 1];
   202|                         Some(CStr::from_bytes_with_nul(sl).unwrap())
   203|                     }
   204|                 };
   205|                 Err(NmountError::new(error.into(), errmsg))
   206|             }
   207|         }
   208|     }
   209| }
   210| #[cfg(target_os = "freebsd")]
   211| impl<'a> Drop for Nmount<'a> {
   212|     fn drop(&mut self) {
   213|         for (iov, is_owned) in self.iov.iter().zip(self.is_owned.iter()) {
   214|             if *is_owned {
   215|                 unsafe {
   216|                     CString::from_raw(iov.0.iov_base as *mut c_char);
   217|                 }
   218|             }
   219|         }
   220|     }
   221| }
   222| pub fn unmount<P>(mountpoint: &P, flags: MntFlags) -> Result<()>
   223|     where P: ?Sized + NixPath
   224| {
   225|     let res = mountpoint.with_nix_path(|cstr| {
   226|         unsafe { libc::unmount(cstr.as_ptr(), flags.bits) }
   227|     })?;
   228|     Errno::result(res).map(drop)
   229| }


# ====================================================================
# FILE: src/mount/linux.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| use libc::{self, c_ulong, c_int};
     2| use crate::{Result, NixPath};
     3| use crate::errno::Errno;
     4| libc_bitflags!(
     5|     pub struct MsFlags: c_ulong {
     6|         MS_RDONLY;
     7|         MS_NOSUID;
     8|         MS_NODEV;
     9|         MS_NOEXEC;
    10|         MS_SYNCHRONOUS;
    11|         MS_REMOUNT;
    12|         MS_MANDLOCK;
    13|         MS_DIRSYNC;
    14|         MS_NOATIME;
    15|         MS_NODIRATIME;
    16|         MS_BIND;
    17|         MS_MOVE;
    18|         MS_REC;
    19|         MS_SILENT;
    20|         MS_POSIXACL;
    21|         MS_UNBINDABLE;
    22|         MS_PRIVATE;
    23|         MS_SLAVE;
    24|         MS_SHARED;
    25|         MS_RELATIME;
    26|         MS_KERNMOUNT;
    27|         MS_I_VERSION;
    28|         MS_STRICTATIME;
    29|         MS_LAZYTIME;
    30|         MS_ACTIVE;
    31|         MS_NOUSER;
    32|         MS_RMT_MASK;
    33|         MS_MGC_VAL;
    34|         MS_MGC_MSK;
    35|     }
    36| );
    37| libc_bitflags!(
    38|     pub struct MntFlags: c_int {
    39|         MNT_FORCE;
    40|         MNT_DETACH;
    41|         MNT_EXPIRE;
    42|     }
    43| );
    44| pub fn mount<P1: ?Sized + NixPath, P2: ?Sized + NixPath, P3: ?Sized + NixPath, P4: ?Sized + NixPath>(
    45|         source: Option<&P1>,
    46|         target: &P2,
    47|         fstype: Option<&P3>,
    48|         flags: MsFlags,
    49|         data: Option<&P4>) -> Result<()> {
    50|     fn with_opt_nix_path<P, T, F>(p: Option<&P>, f: F) -> Result<T>
    51|         where P: ?Sized + NixPath,
    52|               F: FnOnce(*const libc::c_char) -> T
    53|     {
    54|         match p {
    55|             Some(path) => path.with_nix_path(|p_str| f(p_str.as_ptr())),
    56|             None => Ok(f(std::ptr::null()))
    57|         }
    58|     }
    59|     let res = with_opt_nix_path(source, |s| {
    60|         target.with_nix_path(|t| {
    61|             with_opt_nix_path(fstype, |ty| {
    62|                 with_opt_nix_path(data, |d| {
    63|                     unsafe {
    64|                         libc::mount(
    65|                             s,
    66|                             t.as_ptr(),
    67|                             ty,
    68|                             flags.bits,
    69|                             d as *const libc::c_void
    70|                         )
    71|                     }
    72|                 })
    73|             })
    74|         })
    75|     })????;
    76|     Errno::result(res).map(drop)
    77| }
    78| pub fn umount<P: ?Sized + NixPath>(target: &P) -> Result<()> {
    79|     let res = target.with_nix_path(|cstr| {
    80|         unsafe { libc::umount(cstr.as_ptr()) }
    81|     })?;
    82|     Errno::result(res).map(drop)
    83| }
    84| pub fn umount2<P: ?Sized + NixPath>(target: &P, flags: MntFlags) -> Result<()> {
    85|     let res = target.with_nix_path(|cstr| {
    86|         unsafe { libc::umount2(cstr.as_ptr(), flags.bits) }
    87|     })?;
    88|     Errno::result(res).map(drop)
    89| }


# ====================================================================
# FILE: src/mount/mod.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| #[cfg(any(target_os = "android", target_os = "linux"))]
     2| mod linux;
     3| #[cfg(any(target_os = "android", target_os = "linux"))]
     4| pub use self::linux::*;
     5| #[cfg(any(target_os = "dragonfly",
     6|           target_os = "freebsd",
     7|           target_os = "macos",
     8|           target_os = "netbsd",
     9|           target_os = "openbsd"))]
    10| mod bsd;
    11| #[cfg(any(target_os = "dragonfly",
    12|           target_os = "freebsd",
    13|           target_os = "macos",
    14|           target_os = "netbsd",
    15|           target_os = "openbsd"
    16|           ))]
    17| pub use self::bsd::*;


# ====================================================================
# FILE: src/net/if_.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-288 ---
     1| use crate::{Error, NixPath, Result};
     2| use libc::c_uint;
     3| pub fn if_nametoindex<P: ?Sized + NixPath>(name: &P) -> Result<c_uint> {
     4|     let if_index = name.with_nix_path(|name| unsafe { libc::if_nametoindex(name.as_ptr()) })?;
     5|     if if_index == 0 {
     6|         Err(Error::last())
     7|     } else {
     8|         Ok(if_index)
     9|     }
    10| }
    11| libc_bitflags!(
    12|     pub struct InterfaceFlags: libc::c_int {
    13|         IFF_UP;
    14|         IFF_BROADCAST;
    15|         IFF_DEBUG;
    16|         IFF_LOOPBACK;
    17|         IFF_POINTOPOINT;
    18|         #[cfg(any(target_os = "android",
    19|                   target_os = "fuchsia",
    20|                   target_os = "ios",
    21|                   target_os = "linux",
    22|                   target_os = "macos",
    23|                   target_os = "netbsd",
    24|                   target_os = "illumos",
    25|                   target_os = "solaris"))]
    26|         IFF_NOTRAILERS;
    27|         #[cfg(any(target_os = "dragonfly"))]
    28|         IFF_SMART;
    29|         #[cfg(any(target_os = "android",
    30|                   target_os = "dragonfly",
    31|                   target_os = "freebsd",
    32|                   target_os = "fuchsia",
    33|                   target_os = "illumos",
    34|                   target_os = "ios",
    35|                   target_os = "linux",
    36|                   target_os = "macos",
    37|                   target_os = "netbsd",
    38|                   target_os = "openbsd",
    39|                   target_os = "solaris"))]
    40|         IFF_RUNNING;
    41|         IFF_NOARP;
    42|         IFF_PROMISC;
    43|         IFF_ALLMULTI;
    44|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
    45|         IFF_MASTER;
    46|         #[cfg(any(target_os = "freebsd",
    47|                   target_os = "macos",
    48|                   target_os = "netbsd",
    49|                   target_os = "openbsd",
    50|                   target_os = "ios"))]
    51|         IFF_OACTIVE;
    52|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
    53|         IFF_INTELLIGENT;
    54|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
    55|         IFF_SLAVE;
    56|         #[cfg(any(target_os = "dragonfly",
    57|                   target_os = "freebsd",
    58|                   target_os = "macos",
    59|                   target_os = "netbsd",
    60|                   target_os = "openbsd",
    61|                   target_os = "osx"))]
    62|         IFF_SIMPLEX;
    63|         IFF_MULTICAST;
    64|         #[cfg(any(target_os = "dragonfly",
    65|                   target_os = "freebsd",
    66|                   target_os = "macos",
    67|                   target_os = "netbsd",
    68|                   target_os = "openbsd",
    69|                   target_os = "ios"))]
    70|         IFF_LINK0;
    71|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
    72|         IFF_MULTI_BCAST;
    73|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
    74|         IFF_PORTSEL;
    75|         #[cfg(any(target_os = "dragonfly",
    76|                   target_os = "freebsd",
    77|                   target_os = "macos",
    78|                   target_os = "netbsd",
    79|                   target_os = "openbsd",
    80|                   target_os = "ios"))]
    81|         IFF_LINK1;
    82|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
    83|         IFF_UNNUMBERED;
    84|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
    85|         IFF_AUTOMEDIA;
    86|         #[cfg(any(target_os = "dragonfly",
    87|                   target_os = "freebsd",
    88|                   target_os = "macos",
    89|                   target_os = "netbsd",
    90|                   target_os = "openbsd",
    91|                   target_os = "ios"))]
    92|         IFF_LINK2;
    93|         #[cfg(any(target_os = "dragonfly",
    94|                   target_os = "freebsd",
    95|                   target_os = "macos",
    96|                   target_os = "ios"))]
    97|         IFF_ALTPHYS;
    98|         #[cfg(any(target_os = "solaris", target_os = "illumos"))]
    99|         IFF_DHCPRUNNING;
   100|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   101|         IFF_DYNAMIC;
   102|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   103|         IFF_PRIVATE;
   104|         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
   105|         IFF_LOWER_UP;
   106|         #[cfg(any(target_os = "dragonfly"))]
   107|         IFF_POLLING_COMPAT;
   108|         #[cfg(any(target_os = "freebsd"))]
   109|         IFF_CANTCONFIG;
   110|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   111|         IFF_NOXMIT;
   112|         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
   113|         IFF_DORMANT;
   114|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   115|         IFF_PPROMISC;
   116|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   117|         IFF_NOLOCAL;
   118|         #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
   119|         IFF_ECHO;
   120|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   121|         IFF_MONITOR;
   122|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   123|         IFF_DEPRECATED;
   124|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   125|         IFF_STATICARP;
   126|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   127|         IFF_ADDRCONF;
   128|         #[cfg(any(target_os = "dragonfly"))]
   129|         IFF_NPOLLING;
   130|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   131|         IFF_ROUTER;
   132|         #[cfg(any(target_os = "dragonfly"))]
   133|         IFF_IDIRECT;
   134|         #[cfg(any(target_os = "freebsd"))]
   135|         IFF_DYING;
   136|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   137|         IFF_NONUD;
   138|         #[cfg(any(target_os = "freebsd"))]
   139|         IFF_RENAMING;
   140|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   141|         IFF_ANYCAST;
   142|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   143|         IFF_NORTEXCH;
   144|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   145|         IFF_NO_PI as libc::c_int;
   146|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   147|         IFF_TUN as libc::c_int;
   148|         #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   149|         IFF_TAP as libc::c_int;
   150|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   151|         IFF_IPV4;
   152|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   153|         IFF_IPV6;
   154|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   155|         IFF_NOFAILOVER;
   156|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   157|         IFF_FAILED;
   158|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   159|         IFF_STANDBY;
   160|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   161|         IFF_INACTIVE;
   162|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   163|         IFF_OFFLINE;
   164|         #[cfg(target_os = "solaris")]
   165|         IFF_COS_ENABLED;
   166|         #[cfg(target_os = "solaris")]
   167|         IFF_PREFERRED;
   168|         #[cfg(target_os = "solaris")]
   169|         IFF_TEMPORARY;
   170|         #[cfg(target_os = "solaris")]
   171|         IFF_FIXEDMTU;
   172|         #[cfg(target_os = "solaris")]
   173|         IFF_VIRTUAL;
   174|         #[cfg(target_os = "solaris")]
   175|         IFF_DUPLICATE;
   176|         #[cfg(target_os = "solaris")]
   177|         IFF_IPMP;
   178|     }
   179| );
   180| #[cfg(any(
   181|     target_os = "dragonfly",
   182|     target_os = "freebsd",
   183|     target_os = "fuchsia",
   184|     target_os = "ios",
   185|     target_os = "linux",
   186|     target_os = "macos",
   187|     target_os = "netbsd",
   188|     target_os = "openbsd",
   189| ))]
   190| mod if_nameindex {
   191|     use super::*;
   192|     use std::ffi::CStr;
   193|     use std::fmt;
   194|     use std::marker::PhantomData;
   195|     use std::ptr::NonNull;
   196|     #[allow(missing_copy_implementations)]
   197|     #[repr(transparent)]
   198|     pub struct Interface(libc::if_nameindex);
   199|     impl Interface {
   200|         pub fn index(&self) -> c_uint {
   201|             self.0.if_index
   202|         }
   203|         pub fn name(&self) -> &CStr {
   204|             unsafe { CStr::from_ptr(self.0.if_name) }
   205|         }
   206|     }
   207|     impl fmt::Debug for Interface {
   208|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   209|             f.debug_struct("Interface")
   210|                 .field("index", &self.index())
   211|                 .field("name", &self.name())
   212|                 .finish()
   213|         }
   214|     }
   215|     pub struct Interfaces {
   216|         ptr: NonNull<libc::if_nameindex>,
   217|     }
   218|     impl Interfaces {
   219|         #[inline]
   220|         pub fn iter(&self) -> InterfacesIter<'_> {
   221|             self.into_iter()
   222|         }
   223|         pub fn to_slice(&self) -> &[Interface] {
   224|             let ifs = self.ptr.as_ptr() as *const Interface;
   225|             let len = self.iter().count();
   226|             unsafe { std::slice::from_raw_parts(ifs, len) }
   227|         }
   228|     }
   229|     impl Drop for Interfaces {
   230|         fn drop(&mut self) {
   231|             unsafe { libc::if_freenameindex(self.ptr.as_ptr()) };
   232|         }
   233|     }
   234|     impl fmt::Debug for Interfaces {
   235|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   236|             self.to_slice().fmt(f)
   237|         }
   238|     }
   239|     impl<'a> IntoIterator for &'a Interfaces {
   240|         type IntoIter = InterfacesIter<'a>;
   241|         type Item = &'a Interface;
   242|         #[inline]
   243|         fn into_iter(self) -> Self::IntoIter {
   244|             InterfacesIter {
   245|                 ptr: self.ptr.as_ptr(),
   246|                 _marker: PhantomData,
   247|             }
   248|         }
   249|     }
   250|     #[derive(Debug)]
   251|     pub struct InterfacesIter<'a> {
   252|         ptr: *const libc::if_nameindex,
   253|         _marker: PhantomData<&'a Interfaces>,
   254|     }
   255|     impl<'a> Iterator for InterfacesIter<'a> {
   256|         type Item = &'a Interface;
   257|         #[inline]
   258|         fn next(&mut self) -> Option<Self::Item> {
   259|             unsafe {
   260|                 if (*self.ptr).if_index == 0 {
   261|                     None
   262|                 } else {
   263|                     let ret = &*(self.ptr as *const Interface);
   264|                     self.ptr = self.ptr.add(1);
   265|                     Some(ret)
   266|                 }
   267|             }
   268|         }
   269|     }
   270|     pub fn if_nameindex() -> Result<Interfaces> {
   271|         unsafe {
   272|             let ifs = libc::if_nameindex();
   273|             let ptr = NonNull::new(ifs).ok_or_else(Error::last)?;
   274|             Ok(Interfaces { ptr })
   275|         }
   276|     }
   277| }
   278| #[cfg(any(
   279|     target_os = "dragonfly",
   280|     target_os = "freebsd",
   281|     target_os = "fuchsia",
   282|     target_os = "ios",
   283|     target_os = "linux",
   284|     target_os = "macos",
   285|     target_os = "netbsd",
   286|     target_os = "openbsd",
   287| ))]
   288| pub use if_nameindex::*;


# ====================================================================
# FILE: src/pty.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-193 ---
     1| pub use libc::pid_t as SessionId;
     2| pub use libc::winsize as Winsize;
     3| use std::ffi::CStr;
     4| use std::io;
     5| use std::mem;
     6| use std::os::unix::prelude::*;
     7| use crate::sys::termios::Termios;
     8| use crate::unistd::{self, ForkResult, Pid};
     9| use crate::{Result, Error, fcntl};
    10| use crate::errno::Errno;
    11| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    12| pub struct OpenptyResult {
    13|     pub master: RawFd,
    14|     pub slave: RawFd,
    15| }
    16| #[derive(Clone, Copy, Debug)]
    17| pub struct ForkptyResult {
    18|     pub master: RawFd,
    19|     pub fork_result: ForkResult,
    20| }
    21| #[derive(Debug, Eq, Hash, PartialEq)]
    22| pub struct PtyMaster(RawFd);
    23| impl AsRawFd for PtyMaster {
    24|     fn as_raw_fd(&self) -> RawFd {
    25|         self.0
    26|     }
    27| }
    28| impl IntoRawFd for PtyMaster {
    29|     fn into_raw_fd(self) -> RawFd {
    30|         let fd = self.0;
    31|         mem::forget(self);
    32|         fd
    33|     }
    34| }
    35| impl Drop for PtyMaster {
    36|     fn drop(&mut self) {
    37|         let e = unistd::close(self.0);
    38|         if e == Err(Errno::EBADF) {
    39|             panic!("Closing an invalid file descriptor!");
    40|         };
    41|     }
    42| }
    43| impl io::Read for PtyMaster {
    44|     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
    45|         unistd::read(self.0, buf).map_err(io::Error::from)
    46|     }
    47| }
    48| impl io::Write for PtyMaster {
    49|     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
    50|         unistd::write(self.0, buf).map_err(io::Error::from)
    51|     }
    52|     fn flush(&mut self) -> io::Result<()> {
    53|         Ok(())
    54|     }
    55| }
    56| #[inline]
    57| pub fn grantpt(fd: &PtyMaster) -> Result<()> {
    58|     if unsafe { libc::grantpt(fd.as_raw_fd()) } < 0 {
    59|         return Err(Error::from(Errno::last()));
    60|     }
    61|     Ok(())
    62| }
    63| #[inline]
    64| pub fn posix_openpt(flags: fcntl::OFlag) -> Result<PtyMaster> {
    65|     let fd = unsafe {
    66|         libc::posix_openpt(flags.bits())
    67|     };
    68|     if fd < 0 {
    69|         return Err(Error::from(Errno::last()));
    70|     }
    71|     Ok(PtyMaster(fd))
    72| }
    73| #[inline]
    74| pub unsafe fn ptsname(fd: &PtyMaster) -> Result<String> {
    75|     let name_ptr = libc::ptsname(fd.as_raw_fd());
    76|     if name_ptr.is_null() {
    77|         return Err(Error::from(Errno::last()));
    78|     }
    79|     let name = CStr::from_ptr(name_ptr);
    80|     Ok(name.to_string_lossy().into_owned())
    81| }
    82| #[cfg(any(target_os = "android", target_os = "linux"))]
    83| #[inline]
    84| pub fn ptsname_r(fd: &PtyMaster) -> Result<String> {
    85|     let mut name_buf = Vec::<libc::c_char>::with_capacity(64);
    86|     let name_buf_ptr = name_buf.as_mut_ptr();
    87|     let cname = unsafe {
    88|         let cap = name_buf.capacity();
    89|         if libc::ptsname_r(fd.as_raw_fd(), name_buf_ptr, cap) != 0 {
    90|             return Err(Error::last());
    91|         }
    92|         CStr::from_ptr(name_buf.as_ptr())
    93|     };
    94|     let name = cname.to_string_lossy().into_owned();
    95|     Ok(name)
    96| }
    97| #[inline]
    98| pub fn unlockpt(fd: &PtyMaster) -> Result<()> {
    99|     if unsafe { libc::unlockpt(fd.as_raw_fd()) } < 0 {
   100|         return Err(Error::from(Errno::last()));
   101|     }
   102|     Ok(())
   103| }
   104| #[inline]
   105| pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(winsize: T, termios: U) -> Result<OpenptyResult> {
   106|     use std::ptr;
   107|     let mut slave = mem::MaybeUninit::<libc::c_int>::uninit();
   108|     let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
   109|     let ret = {
   110|         match (termios.into(), winsize.into()) {
   111|             (Some(termios), Some(winsize)) => {
   112|                 let inner_termios = termios.get_libc_termios();
   113|                 unsafe {
   114|                     libc::openpty(
   115|                         master.as_mut_ptr(),
   116|                         slave.as_mut_ptr(),
   117|                         ptr::null_mut(),
   118|                         &*inner_termios as *const libc::termios as *mut _,
   119|                         winsize as *const Winsize as *mut _,
   120|                     )
   121|                 }
   122|             }
   123|             (None, Some(winsize)) => {
   124|                 unsafe {
   125|                     libc::openpty(
   126|                         master.as_mut_ptr(),
   127|                         slave.as_mut_ptr(),
   128|                         ptr::null_mut(),
   129|                         ptr::null_mut(),
   130|                         winsize as *const Winsize as *mut _,
   131|                     )
   132|                 }
   133|             }
   134|             (Some(termios), None) => {
   135|                 let inner_termios = termios.get_libc_termios();
   136|                 unsafe {
   137|                     libc::openpty(
   138|                         master.as_mut_ptr(),
   139|                         slave.as_mut_ptr(),
   140|                         ptr::null_mut(),
   141|                         &*inner_termios as *const libc::termios as *mut _,
   142|                         ptr::null_mut(),
   143|                     )
   144|                 }
   145|             }
   146|             (None, None) => {
   147|                 unsafe {
   148|                     libc::openpty(
   149|                         master.as_mut_ptr(),
   150|                         slave.as_mut_ptr(),
   151|                         ptr::null_mut(),
   152|                         ptr::null_mut(),
   153|                         ptr::null_mut(),
   154|                     )
   155|                 }
   156|             }
   157|         }
   158|     };
   159|     Errno::result(ret)?;
   160|     unsafe {
   161|         Ok(OpenptyResult {
   162|             master: master.assume_init(),
   163|             slave: slave.assume_init(),
   164|         })
   165|     }
   166| }
   167| pub unsafe fn forkpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(
   168|     winsize: T,
   169|     termios: U,
   170| ) -> Result<ForkptyResult> {
   171|     use std::ptr;
   172|     let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
   173|     let term = match termios.into() {
   174|         Some(termios) => {
   175|             let inner_termios = termios.get_libc_termios();
   176|             &*inner_termios as *const libc::termios as *mut _
   177|         },
   178|         None => ptr::null_mut(),
   179|     };
   180|     let win = winsize
   181|         .into()
   182|         .map(|ws| ws as *const Winsize as *mut _)
   183|         .unwrap_or(ptr::null_mut());
   184|     let res = libc::forkpty(master.as_mut_ptr(), ptr::null_mut(), term, win);
   185|     let fork_result = Errno::result(res).map(|res| match res {
   186|         0 => ForkResult::Child,
   187|         res => ForkResult::Parent { child: Pid::from_raw(res) },
   188|     })?;
   189|     Ok(ForkptyResult {
   190|         master: master.assume_init(),
   191|         fork_result,
   192|     })
   193| }


# ====================================================================
# FILE: src/sched.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-142 ---
     1| use crate::{Errno, Result};
     2| #[cfg(any(target_os = "android", target_os = "linux"))]
     3| pub use self::sched_linux_like::*;
     4| #[cfg(any(target_os = "android", target_os = "linux"))]
     5| mod sched_linux_like {
     6|     use crate::errno::Errno;
     7|     use libc::{self, c_int, c_void};
     8|     use std::mem;
     9|     use std::option::Option;
    10|     use std::os::unix::io::RawFd;
    11|     use crate::unistd::Pid;
    12|     use crate::{Error, Result};
    13|     libc_bitflags! {
    14|         pub struct CloneFlags: c_int {
    15|             CLONE_VM;
    16|             CLONE_FS;
    17|             CLONE_FILES;
    18|             CLONE_SIGHAND;
    19|             CLONE_PTRACE;
    20|             CLONE_VFORK;
    21|             CLONE_PARENT;
    22|             CLONE_THREAD;
    23|             CLONE_NEWNS;
    24|             CLONE_SYSVSEM;
    25|             CLONE_SETTLS;
    26|             CLONE_PARENT_SETTID;
    27|             CLONE_CHILD_CLEARTID;
    28|             CLONE_DETACHED;
    29|             CLONE_UNTRACED;
    30|             CLONE_CHILD_SETTID;
    31|             CLONE_NEWCGROUP;
    32|             CLONE_NEWUTS;
    33|             CLONE_NEWIPC;
    34|             CLONE_NEWUSER;
    35|             CLONE_NEWPID;
    36|             CLONE_NEWNET;
    37|             CLONE_IO;
    38|         }
    39|     }
    40|     pub type CloneCb<'a> = Box<dyn FnMut() -> isize + 'a>;
    41|     #[repr(C)]
    42|     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    43|     pub struct CpuSet {
    44|         cpu_set: libc::cpu_set_t,
    45|     }
    46|     impl CpuSet {
    47|         pub fn new() -> CpuSet {
    48|             CpuSet {
    49|                 cpu_set: unsafe { mem::zeroed() },
    50|             }
    51|         }
    52|         pub fn is_set(&self, field: usize) -> Result<bool> {
    53|             if field >= CpuSet::count() {
    54|                 Err(Error::from(Errno::EINVAL))
    55|             } else {
    56|                 Ok(unsafe { libc::CPU_ISSET(field, &self.cpu_set) })
    57|             }
    58|         }
    59|         pub fn set(&mut self, field: usize) -> Result<()> {
    60|             if field >= CpuSet::count() {
    61|                 Err(Error::from(Errno::EINVAL))
    62|             } else {
    63|                 unsafe { libc::CPU_SET(field, &mut self.cpu_set); }
    64|                 Ok(())
    65|             }
    66|         }
    67|         pub fn unset(&mut self, field: usize) -> Result<()> {
    68|             if field >= CpuSet::count() {
    69|                 Err(Error::from(Errno::EINVAL))
    70|             } else {
    71|                 unsafe { libc::CPU_CLR(field, &mut self.cpu_set);}
    72|                 Ok(())
    73|             }
    74|         }
    75|         pub fn count() -> usize {
    76|             8 * mem::size_of::<libc::cpu_set_t>()
    77|         }
    78|     }
    79|     impl Default for CpuSet {
    80|         fn default() -> Self {
    81|             Self::new()
    82|         }
    83|     }
    84|     pub fn sched_setaffinity(pid: Pid, cpuset: &CpuSet) -> Result<()> {
    85|         let res = unsafe {
    86|             libc::sched_setaffinity(
    87|                 pid.into(),
    88|                 mem::size_of::<CpuSet>() as libc::size_t,
    89|                 &cpuset.cpu_set,
    90|             )
    91|         };
    92|         Errno::result(res).map(drop)
    93|     }
    94|     pub fn sched_getaffinity(pid: Pid) -> Result<CpuSet> {
    95|         let mut cpuset = CpuSet::new();
    96|         let res = unsafe {
    97|             libc::sched_getaffinity(
    98|                 pid.into(),
    99|                 mem::size_of::<CpuSet>() as libc::size_t,
   100|                 &mut cpuset.cpu_set,
   101|             )
   102|         };
   103|         Errno::result(res).and(Ok(cpuset))
   104|     }
   105|     pub fn clone(
   106|         mut cb: CloneCb,
   107|         stack: &mut [u8],
   108|         flags: CloneFlags,
   109|         signal: Option<c_int>,
   110|     ) -> Result<Pid> {
   111|         extern "C" fn callback(data: *mut CloneCb) -> c_int {
   112|             let cb: &mut CloneCb = unsafe { &mut *data };
   113|             (*cb)() as c_int
   114|         }
   115|         let res = unsafe {
   116|             let combined = flags.bits() | signal.unwrap_or(0);
   117|             let ptr = stack.as_mut_ptr().add(stack.len());
   118|             let ptr_aligned = ptr.sub(ptr as usize % 16);
   119|             libc::clone(
   120|                 mem::transmute(
   121|                     callback as extern "C" fn(*mut Box<dyn FnMut() -> isize>) -> i32,
   122|                 ),
   123|                 ptr_aligned as *mut c_void,
   124|                 combined,
   125|                 &mut cb as *mut _ as *mut c_void,
   126|             )
   127|         };
   128|         Errno::result(res).map(Pid::from_raw)
   129|     }
   130|     pub fn unshare(flags: CloneFlags) -> Result<()> {
   131|         let res = unsafe { libc::unshare(flags.bits()) };
   132|         Errno::result(res).map(drop)
   133|     }
   134|     pub fn setns(fd: RawFd, nstype: CloneFlags) -> Result<()> {
   135|         let res = unsafe { libc::setns(fd, nstype.bits()) };
   136|         Errno::result(res).map(drop)
   137|     }
   138| }
   139| pub fn sched_yield() -> Result<()> {
   140|     let res = unsafe { libc::sched_yield() };
   141|     Errno::result(res).map(drop)
   142| }


# ====================================================================
# FILE: src/sys/aio.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-453 ---
     1| use crate::{Error, Result};
     2| use crate::errno::Errno;
     3| use std::os::unix::io::RawFd;
     4| use libc::{c_void, off_t, size_t};
     5| use std::fmt;
     6| use std::fmt::Debug;
     7| use std::marker::PhantomData;
     8| use std::mem;
     9| use std::pin::Pin;
    10| use std::ptr::{null, null_mut};
    11| use crate::sys::signal::*;
    12| use std::thread;
    13| use crate::sys::time::TimeSpec;
    14| libc_enum! {
    15|     #[repr(i32)]
    16|     pub enum AioFsyncMode {
    17|         O_SYNC,
    18|         #[cfg(any(target_os = "ios",
    19|                   target_os = "linux",
    20|                   target_os = "macos",
    21|                   target_os = "netbsd",
    22|                   target_os = "openbsd"))]
    23|         O_DSYNC
    24|     }
    25| }
    26| libc_enum! {
    27|     #[repr(i32)]
    28|     pub enum LioOpcode {
    29|         LIO_NOP,
    30|         LIO_WRITE,
    31|         LIO_READ,
    32|     }
    33| }
    34| libc_enum! {
    35|     #[repr(i32)]
    36|     pub enum LioMode {
    37|         LIO_WAIT,
    38|         LIO_NOWAIT,
    39|     }
    40| }
    41| #[repr(i32)]
    42| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    43| pub enum AioCancelStat {
    44|     AioCanceled = libc::AIO_CANCELED,
    45|     AioNotCanceled = libc::AIO_NOTCANCELED,
    46|     AioAllDone = libc::AIO_ALLDONE,
    47| }
    48| #[repr(transparent)]
    49| struct LibcAiocb(libc::aiocb);
    50| unsafe impl Send for LibcAiocb {}
    51| unsafe impl Sync for LibcAiocb {}
    52| pub struct AioCb<'a> {
    53|     aiocb: LibcAiocb,
    54|     mutable: bool,
    55|     in_progress: bool,
    56|     _buffer: std::marker::PhantomData<&'a [u8]>,
    57|     _pin: std::marker::PhantomPinned
    58| }
    59| impl<'a> AioCb<'a> {
    60|     pub fn fd(&self) -> RawFd {
    61|         self.aiocb.0.aio_fildes
    62|     }
    63|     pub fn from_fd(fd: RawFd, prio: libc::c_int,
    64|                     sigev_notify: SigevNotify) -> Pin<Box<AioCb<'a>>> {
    65|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
    66|         a.0.aio_offset = 0;
    67|         a.0.aio_nbytes = 0;
    68|         a.0.aio_buf = null_mut();
    69|         Box::pin(AioCb {
    70|             aiocb: a,
    71|             mutable: false,
    72|             in_progress: false,
    73|             _buffer: PhantomData,
    74|             _pin: std::marker::PhantomPinned
    75|         })
    76|     }
    77|     #[cfg(not(any(target_os = "ios", target_os = "macos")))]
    78|     fn from_mut_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a mut [u8],
    79|                           prio: libc::c_int, sigev_notify: SigevNotify,
    80|                           opcode: LioOpcode) -> AioCb<'a>
    81|     {
    82|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
    83|         a.0.aio_offset = offs;
    84|         a.0.aio_nbytes = buf.len() as size_t;
    85|         a.0.aio_buf = buf.as_ptr() as *mut c_void;
    86|         a.0.aio_lio_opcode = opcode as libc::c_int;
    87|         AioCb {
    88|             aiocb: a,
    89|             mutable: true,
    90|             in_progress: false,
    91|             _buffer: PhantomData,
    92|             _pin: std::marker::PhantomPinned
    93|         }
    94|     }
    95|     pub fn from_mut_slice(fd: RawFd, offs: off_t, buf: &'a mut [u8],
    96|                           prio: libc::c_int, sigev_notify: SigevNotify,
    97|                           opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
    98|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
    99|         a.0.aio_offset = offs;
   100|         a.0.aio_nbytes = buf.len() as size_t;
   101|         a.0.aio_buf = buf.as_ptr() as *mut c_void;
   102|         a.0.aio_lio_opcode = opcode as libc::c_int;
   103|         Box::pin(AioCb {
   104|             aiocb: a,
   105|             mutable: true,
   106|             in_progress: false,
   107|             _buffer: PhantomData,
   108|             _pin: std::marker::PhantomPinned
   109|         })
   110|     }
   111|     pub unsafe fn from_mut_ptr(fd: RawFd, offs: off_t,
   112|                            buf: *mut c_void, len: usize,
   113|                            prio: libc::c_int, sigev_notify: SigevNotify,
   114|                            opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
   115|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
   116|         a.0.aio_offset = offs;
   117|         a.0.aio_nbytes = len;
   118|         a.0.aio_buf = buf;
   119|         a.0.aio_lio_opcode = opcode as libc::c_int;
   120|         Box::pin(AioCb {
   121|             aiocb: a,
   122|             mutable: true,
   123|             in_progress: false,
   124|             _buffer: PhantomData,
   125|             _pin: std::marker::PhantomPinned,
   126|         })
   127|     }
   128|     pub unsafe fn from_ptr(fd: RawFd, offs: off_t,
   129|                            buf: *const c_void, len: usize,
   130|                            prio: libc::c_int, sigev_notify: SigevNotify,
   131|                            opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
   132|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
   133|         a.0.aio_offset = offs;
   134|         a.0.aio_nbytes = len;
   135|         a.0.aio_buf = buf as *mut c_void;
   136|         a.0.aio_lio_opcode = opcode as libc::c_int;
   137|         Box::pin(AioCb {
   138|             aiocb: a,
   139|             mutable: false,
   140|             in_progress: false,
   141|             _buffer: PhantomData,
   142|             _pin: std::marker::PhantomPinned
   143|         })
   144|     }
   145|     fn from_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a [u8],
   146|                            prio: libc::c_int, sigev_notify: SigevNotify,
   147|                            opcode: LioOpcode) -> AioCb
   148|     {
   149|         let mut a = AioCb::common_init(fd, prio, sigev_notify);
   150|         a.0.aio_offset = offs;
   151|         a.0.aio_nbytes = buf.len() as size_t;
   152|         a.0.aio_buf = buf.as_ptr() as *mut c_void;
   153|         assert!(opcode != LioOpcode::LIO_READ, "Can't read into an immutable buffer");
   154|         a.0.aio_lio_opcode = opcode as libc::c_int;
   155|         AioCb {
   156|             aiocb: a,
   157|             mutable: false,
   158|             in_progress: false,
   159|             _buffer: PhantomData,
   160|             _pin: std::marker::PhantomPinned
   161|         }
   162|     }
   163|     pub fn from_slice(fd: RawFd, offs: off_t, buf: &'a [u8],
   164|                       prio: libc::c_int, sigev_notify: SigevNotify,
   165|                       opcode: LioOpcode) -> Pin<Box<AioCb>>
   166|     {
   167|         Box::pin(AioCb::from_slice_unpinned(fd, offs, buf, prio, sigev_notify,
   168|                                             opcode))
   169|     }
   170|     fn common_init(fd: RawFd, prio: libc::c_int,
   171|                    sigev_notify: SigevNotify) -> LibcAiocb {
   172|         let mut a = unsafe { mem::zeroed::<libc::aiocb>()};
   173|         a.aio_fildes = fd;
   174|         a.aio_reqprio = prio;
   175|         a.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
   176|         LibcAiocb(a)
   177|     }
   178|     pub fn set_sigev_notify(self: &mut Pin<Box<Self>>,
   179|                             sigev_notify: SigevNotify)
   180|     {
   181|         let selfp = unsafe {
   182|             self.as_mut().get_unchecked_mut()
   183|         };
   184|         selfp.aiocb.0.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
   185|     }
   186|     pub fn cancel(self: &mut Pin<Box<Self>>) -> Result<AioCancelStat> {
   187|         let r = unsafe {
   188|             let selfp = self.as_mut().get_unchecked_mut();
   189|             libc::aio_cancel(selfp.aiocb.0.aio_fildes, &mut selfp.aiocb.0)
   190|         };
   191|         match r {
   192|             libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
   193|             libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
   194|             libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
   195|             -1 => Err(Error::from(Errno::last())),
   196|             _ => panic!("unknown aio_cancel return value")
   197|         }
   198|     }
   199|     fn error_unpinned(&mut self) -> Result<()> {
   200|         let r = unsafe {
   201|             libc::aio_error(&mut self.aiocb.0 as *mut libc::aiocb)
   202|         };
   203|         match r {
   204|             0 => Ok(()),
   205|             num if num > 0 => Err(Error::from(Errno::from_i32(num))),
   206|             -1 => Err(Error::from(Errno::last())),
   207|             num => panic!("unknown aio_error return value {:?}", num)
   208|         }
   209|     }
   210|     pub fn error(self: &mut Pin<Box<Self>>) -> Result<()> {
   211|         let selfp = unsafe {
   212|             self.as_mut().get_unchecked_mut()
   213|         };
   214|         selfp.error_unpinned()
   215|     }
   216|     pub fn fsync(self: &mut Pin<Box<Self>>, mode: AioFsyncMode) -> Result<()> {
   217|         unsafe {
   218|             let selfp = self.as_mut().get_unchecked_mut();
   219|             Errno::result({
   220|                 let p: *mut libc::aiocb = &mut selfp.aiocb.0;
   221|                 libc::aio_fsync(mode as libc::c_int, p)
   222|             }).map(|_| {
   223|                 selfp.in_progress = true;
   224|             })
   225|         }
   226|     }
   227|     pub fn lio_opcode(&self) -> Option<LioOpcode> {
   228|         match self.aiocb.0.aio_lio_opcode {
   229|             libc::LIO_READ => Some(LioOpcode::LIO_READ),
   230|             libc::LIO_WRITE => Some(LioOpcode::LIO_WRITE),
   231|             libc::LIO_NOP => Some(LioOpcode::LIO_NOP),
   232|             _ => None
   233|         }
   234|     }
   235|     pub fn nbytes(&self) -> usize {
   236|         self.aiocb.0.aio_nbytes
   237|     }
   238|     pub fn offset(&self) -> off_t {
   239|         self.aiocb.0.aio_offset
   240|     }
   241|     pub fn priority(&self) -> libc::c_int {
   242|         self.aiocb.0.aio_reqprio
   243|     }
   244|     pub fn read(self: &mut Pin<Box<Self>>) -> Result<()> {
   245|         assert!(self.mutable, "Can't read into an immutable buffer");
   246|         let selfp = unsafe {
   247|             self.as_mut().get_unchecked_mut()
   248|         };
   249|         Errno::result({
   250|             let p: *mut libc::aiocb = &mut selfp.aiocb.0;
   251|             unsafe { libc::aio_read(p) }
   252|         }).map(|_| {
   253|             selfp.in_progress = true;
   254|         })
   255|     }
   256|     pub fn sigevent(&self) -> SigEvent {
   257|         SigEvent::from(&self.aiocb.0.aio_sigevent)
   258|     }
   259|     fn aio_return_unpinned(&mut self) -> Result<isize> {
   260|         unsafe {
   261|             let p: *mut libc::aiocb = &mut self.aiocb.0;
   262|             self.in_progress = false;
   263|             Errno::result(libc::aio_return(p))
   264|         }
   265|     }
   266|     pub fn aio_return(self: &mut Pin<Box<Self>>) -> Result<isize> {
   267|         let selfp = unsafe {
   268|             self.as_mut().get_unchecked_mut()
   269|         };
   270|         selfp.aio_return_unpinned()
   271|     }
   272|     pub fn write(self: &mut Pin<Box<Self>>) -> Result<()> {
   273|         let selfp = unsafe {
   274|             self.as_mut().get_unchecked_mut()
   275|         };
   276|         Errno::result({
   277|             let p: *mut libc::aiocb = &mut selfp.aiocb.0;
   278|             unsafe{ libc::aio_write(p) }
   279|         }).map(|_| {
   280|             selfp.in_progress = true;
   281|         })
   282|     }
   283| }
   284| pub fn aio_cancel_all(fd: RawFd) -> Result<AioCancelStat> {
   285|     match unsafe { libc::aio_cancel(fd, null_mut()) } {
   286|         libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
   287|         libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
   288|         libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
   289|         -1 => Err(Error::from(Errno::last())),
   290|         _ => panic!("unknown aio_cancel return value")
   291|     }
   292| }
   293| pub fn aio_suspend(list: &[Pin<&AioCb>], timeout: Option<TimeSpec>) -> Result<()> {
   294|     let plist = list as *const [Pin<&AioCb>] as *const [*const libc::aiocb];
   295|     let p = plist as *const *const libc::aiocb;
   296|     let timep = match timeout {
   297|         None    => null::<libc::timespec>(),
   298|         Some(x) => x.as_ref() as *const libc::timespec
   299|     };
   300|     Errno::result(unsafe {
   301|         libc::aio_suspend(p, list.len() as i32, timep)
   302|     }).map(drop)
   303| }
   304| impl<'a> Debug for AioCb<'a> {
   305|     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   306|         fmt.debug_struct("AioCb")
   307|             .field("aiocb", &self.aiocb.0)
   308|             .field("mutable", &self.mutable)
   309|             .field("in_progress", &self.in_progress)
   310|             .finish()
   311|     }
   312| }
   313| impl<'a> Drop for AioCb<'a> {
   314|     fn drop(&mut self) {
   315|         assert!(thread::panicking() || !self.in_progress,
   316|                 "Dropped an in-progress AioCb");
   317|     }
   318| }
   319| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   320| pub struct LioCb<'a> {
   321|     aiocbs: Box<[AioCb<'a>]>,
   322|     list: Vec<*mut libc::aiocb>,
   323|     results: Vec<Option<Result<isize>>>
   324| }
   325| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   326| unsafe impl<'a> Send for LioCb<'a> {}
   327| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   328| unsafe impl<'a> Sync for LioCb<'a> {}
   329| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   330| impl<'a> LioCb<'a> {
   331|     pub fn is_empty(&self) -> bool {
   332|         self.aiocbs.is_empty()
   333|     }
   334|     pub fn len(&self) -> usize {
   335|         self.aiocbs.len()
   336|     }
   337|     pub fn listio(&mut self, mode: LioMode,
   338|                   sigev_notify: SigevNotify) -> Result<()> {
   339|         let sigev = SigEvent::new(sigev_notify);
   340|         let sigevp = &mut sigev.sigevent() as *mut libc::sigevent;
   341|         self.list.clear();
   342|         for a in &mut self.aiocbs.iter_mut() {
   343|             a.in_progress = true;
   344|             self.list.push(a as *mut AioCb<'a>
   345|                              as *mut libc::aiocb);
   346|         }
   347|         let p = self.list.as_ptr();
   348|         Errno::result(unsafe {
   349|             libc::lio_listio(mode as i32, p, self.list.len() as i32, sigevp)
   350|         }).map(drop)
   351|     }
   352|     pub fn listio_resubmit(&mut self, mode:LioMode,
   353|                            sigev_notify: SigevNotify) -> Result<()> {
   354|         let sigev = SigEvent::new(sigev_notify);
   355|         let sigevp = &mut sigev.sigevent() as *mut libc::sigevent;
   356|         self.list.clear();
   357|         while self.results.len() < self.aiocbs.len() {
   358|             self.results.push(None);
   359|         }
   360|         for (i, a) in self.aiocbs.iter_mut().enumerate() {
   361|             if self.results[i].is_some() {
   362|                 continue;
   363|             }
   364|             match a.error_unpinned() {
   365|                 Ok(()) => {
   366|                     self.results[i] = Some(a.aio_return_unpinned());
   367|                 },
   368|                 Err(Errno::EAGAIN) => {
   369|                     self.list.push(a as *mut AioCb<'a> as *mut libc::aiocb);
   370|                 },
   371|                 Err(Errno::EINPROGRESS) => {
   372|                 },
   373|                 Err(Errno::EINVAL) => panic!(
   374|                     "AioCb was never submitted, or already finalized"),
   375|                 _ => unreachable!()
   376|             }
   377|         }
   378|         let p = self.list.as_ptr();
   379|         Errno::result(unsafe {
   380|             libc::lio_listio(mode as i32, p, self.list.len() as i32, sigevp)
   381|         }).map(drop)
   382|     }
   383|     pub fn aio_return(&mut self, i: usize) -> Result<isize> {
   384|         if i >= self.results.len() || self.results[i].is_none() {
   385|             self.aiocbs[i].aio_return_unpinned()
   386|         } else {
   387|             self.results[i].unwrap()
   388|         }
   389|     }
   390|     pub fn error(&mut self, i: usize) -> Result<()> {
   391|         if i >= self.results.len() || self.results[i].is_none() {
   392|             self.aiocbs[i].error_unpinned()
   393|         } else {
   394|             Ok(())
   395|         }
   396|     }
   397| }
   398| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   399| impl<'a> Debug for LioCb<'a> {
   400|     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   401|         fmt.debug_struct("LioCb")
   402|             .field("aiocbs", &self.aiocbs)
   403|             .finish()
   404|     }
   405| }
   406| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   407| #[derive(Debug)]
   408| pub struct LioCbBuilder<'a> {
   409|     pub aiocbs: Vec<AioCb<'a>>,
   410| }
   411| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   412| impl<'a> LioCbBuilder<'a> {
   413|     pub fn with_capacity(capacity: usize) -> LioCbBuilder<'a> {
   414|         LioCbBuilder {
   415|             aiocbs: Vec::with_capacity(capacity),
   416|         }
   417|     }
   418|     pub fn emplace_slice(mut self, fd: RawFd, offs: off_t, buf: &'a [u8],
   419|                          prio: libc::c_int, sigev_notify: SigevNotify,
   420|                          opcode: LioOpcode) -> Self
   421|     {
   422|         self.aiocbs.push(AioCb::from_slice_unpinned(fd, offs, buf, prio,
   423|                                                     sigev_notify, opcode));
   424|         self
   425|     }
   426|     pub fn emplace_mut_slice(mut self, fd: RawFd, offs: off_t,
   427|                              buf: &'a mut [u8], prio: libc::c_int,
   428|                              sigev_notify: SigevNotify, opcode: LioOpcode)
   429|         -> Self
   430|     {
   431|         self.aiocbs.push(AioCb::from_mut_slice_unpinned(fd, offs, buf, prio,
   432|                                                         sigev_notify, opcode));
   433|         self
   434|     }
   435|     pub fn finish(self) -> LioCb<'a> {
   436|         let len = self.aiocbs.len();
   437|         LioCb {
   438|             aiocbs: self.aiocbs.into(),
   439|             list: Vec::with_capacity(len),
   440|             results: Vec::with_capacity(len)
   441|         }
   442|     }
   443| }
   444| #[cfg(not(any(target_os = "ios", target_os = "macos")))]
   445| #[cfg(test)]
   446| mod t {
   447|     use super::*;
   448|     #[test]
   449|     fn liocb_is_unpin() {
   450|         use assert_impl::assert_impl;
   451|         assert_impl!(Unpin: LioCb);
   452|     }
   453| }


# ====================================================================
# FILE: src/sys/epoll.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| use crate::{Error, Result};
     2| use crate::errno::Errno;
     3| use libc::{self, c_int};
     4| use std::os::unix::io::RawFd;
     5| use std::ptr;
     6| use std::mem;
     7| libc_bitflags!(
     8|     pub struct EpollFlags: c_int {
     9|         EPOLLIN;
    10|         EPOLLPRI;
    11|         EPOLLOUT;
    12|         EPOLLRDNORM;
    13|         EPOLLRDBAND;
    14|         EPOLLWRNORM;
    15|         EPOLLWRBAND;
    16|         EPOLLMSG;
    17|         EPOLLERR;
    18|         EPOLLHUP;
    19|         EPOLLRDHUP;
    20|         #[cfg(target_os = "linux")]  // Added in 4.5; not in Android.
    21|         EPOLLEXCLUSIVE;
    22|         #[cfg(not(target_arch = "mips"))]
    23|         EPOLLWAKEUP;
    24|         EPOLLONESHOT;
    25|         EPOLLET;
    26|     }
    27| );
    28| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    29| #[repr(i32)]
    30| pub enum EpollOp {
    31|     EpollCtlAdd = libc::EPOLL_CTL_ADD,
    32|     EpollCtlDel = libc::EPOLL_CTL_DEL,
    33|     EpollCtlMod = libc::EPOLL_CTL_MOD,
    34| }
    35| libc_bitflags!{
    36|     pub struct EpollCreateFlags: c_int {
    37|         EPOLL_CLOEXEC;
    38|     }
    39| }
    40| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    41| #[repr(transparent)]
    42| pub struct EpollEvent {
    43|     event: libc::epoll_event,
    44| }
    45| impl EpollEvent {
    46|     pub fn new(events: EpollFlags, data: u64) -> Self {
    47|         EpollEvent { event: libc::epoll_event { events: events.bits() as u32, u64: data } }
    48|     }
    49|     pub fn empty() -> Self {
    50|         unsafe { mem::zeroed::<EpollEvent>() }
    51|     }
    52|     pub fn events(&self) -> EpollFlags {
    53|         EpollFlags::from_bits(self.event.events as c_int).unwrap()
    54|     }
    55|     pub fn data(&self) -> u64 {
    56|         self.event.u64
    57|     }
    58| }
    59| #[inline]
    60| pub fn epoll_create() -> Result<RawFd> {
    61|     let res = unsafe { libc::epoll_create(1024) };
    62|     Errno::result(res)
    63| }
    64| #[inline]
    65| pub fn epoll_create1(flags: EpollCreateFlags) -> Result<RawFd> {
    66|     let res = unsafe { libc::epoll_create1(flags.bits()) };
    67|     Errno::result(res)
    68| }
    69| #[inline]
    70| pub fn epoll_ctl<'a, T>(epfd: RawFd, op: EpollOp, fd: RawFd, event: T) -> Result<()>
    71|     where T: Into<Option<&'a mut EpollEvent>>
    72| {
    73|     let mut event: Option<&mut EpollEvent> = event.into();
    74|     if event.is_none() && op != EpollOp::EpollCtlDel {
    75|         Err(Error::from(Errno::EINVAL))
    76|     } else {
    77|         let res = unsafe {
    78|             if let Some(ref mut event) = event {
    79|                 libc::epoll_ctl(epfd, op as c_int, fd, &mut event.event)
    80|             } else {
    81|                 libc::epoll_ctl(epfd, op as c_int, fd, ptr::null_mut())
    82|             }
    83|         };
    84|         Errno::result(res).map(drop)
    85|     }
    86| }
    87| #[inline]
    88| pub fn epoll_wait(epfd: RawFd, events: &mut [EpollEvent], timeout_ms: isize) -> Result<usize> {
    89|     let res = unsafe {
    90|         libc::epoll_wait(epfd, events.as_mut_ptr() as *mut libc::epoll_event, events.len() as c_int, timeout_ms as c_int)
    91|     };
    92|     Errno::result(res).map(|r| r as usize)
    93| }


# ====================================================================
# FILE: src/sys/mman.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-247 ---
     1| use crate::{Error, Result};
     2| #[cfg(not(target_os = "android"))]
     3| use crate::NixPath;
     4| use crate::errno::Errno;
     5| #[cfg(not(target_os = "android"))]
     6| use crate::fcntl::OFlag;
     7| use libc::{self, c_int, c_void, size_t, off_t};
     8| #[cfg(not(target_os = "android"))]
     9| use crate::sys::stat::Mode;
    10| use std::os::unix::io::RawFd;
    11| libc_bitflags!{
    12|     pub struct ProtFlags: c_int {
    13|         PROT_NONE;
    14|         PROT_READ;
    15|         PROT_WRITE;
    16|         PROT_EXEC;
    17|         #[cfg(any(target_os = "android", target_os = "linux"))]
    18|         PROT_GROWSDOWN;
    19|         #[cfg(any(target_os = "android", target_os = "linux"))]
    20|         PROT_GROWSUP;
    21|     }
    22| }
    23| libc_bitflags!{
    24|     pub struct MapFlags: c_int {
    25|         MAP_FILE;
    26|         MAP_SHARED;
    27|         MAP_PRIVATE;
    28|         MAP_FIXED;
    29|         MAP_ANON;
    30|         #[cfg(any(target_os = "android", target_os = "linux", target_os = "freebsd"))]
    31|         MAP_ANONYMOUS;
    32|         #[cfg(any(all(any(target_os = "android", target_os = "linux"),
    33|                       any(target_arch = "x86", target_arch = "x86_64")),
    34|                   all(target_os = "linux", target_env = "musl", any(target_arch = "x86", target_arch = "x86_64")),
    35|                   all(target_os = "freebsd", target_pointer_width = "64")))]
    36|         MAP_32BIT;
    37|         #[cfg(any(target_os = "android", target_os = "linux"))]
    38|         MAP_GROWSDOWN;
    39|         #[cfg(any(target_os = "android", target_os = "linux"))]
    40|         MAP_DENYWRITE;
    41|         #[cfg(any(target_os = "android", target_os = "linux"))]
    42|         MAP_EXECUTABLE;
    43|         #[cfg(any(target_os = "android", target_os = "linux"))]
    44|         MAP_LOCKED;
    45|         #[cfg(not(target_os = "freebsd"))]
    46|         MAP_NORESERVE;
    47|         #[cfg(any(target_os = "android", target_os = "linux"))]
    48|         MAP_POPULATE;
    49|         #[cfg(any(target_os = "android", target_os = "linux"))]
    50|         MAP_NONBLOCK;
    51|         #[cfg(any(target_os = "android", target_os = "linux"))]
    52|         MAP_HUGETLB;
    53|         #[cfg(target_os = "linux")]
    54|         MAP_HUGE_64KB;
    55|         #[cfg(target_os = "linux")]
    56|         MAP_HUGE_512KB;
    57|         #[cfg(target_os = "linux")]
    58|         MAP_HUGE_1MB;
    59|         #[cfg(target_os = "linux")]
    60|         MAP_HUGE_2MB;
    61|         #[cfg(target_os = "linux")]
    62|         MAP_HUGE_8MB;
    63|         #[cfg(target_os = "linux")]
    64|         MAP_HUGE_16MB;
    65|         #[cfg(target_os = "linux")]
    66|         MAP_HUGE_32MB;
    67|         #[cfg(target_os = "linux")]
    68|         MAP_HUGE_256MB;
    69|         #[cfg(target_os = "linux")]
    70|         MAP_HUGE_512MB;
    71|         #[cfg(target_os = "linux")]
    72|         MAP_HUGE_1GB;
    73|         #[cfg(target_os = "linux")]
    74|         MAP_HUGE_2GB;
    75|         #[cfg(target_os = "linux")]
    76|         MAP_HUGE_16GB;
    77|         #[cfg(target_os = "netbsd")]
    78|         MAP_WIRED;
    79|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
    80|         MAP_NOSYNC;
    81|         #[cfg(any(target_os = "dragonfly", target_os = "netbsd", target_os = "openbsd"))]
    82|         MAP_RENAME;
    83|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd", target_os = "netbsd", target_os = "openbsd"))]
    84|         MAP_HASSEMAPHORE;
    85|         #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
    86|         MAP_STACK;
    87|         #[cfg(any(target_os = "ios", target_os = "macos"))]
    88|         MAP_NOCACHE;
    89|         #[cfg(any(target_os = "ios", target_os = "macos"))]
    90|         MAP_JIT;
    91|     }
    92| }
    93| #[cfg(target_os = "linux")]
    94| libc_bitflags!{
    95|     pub struct MRemapFlags: c_int {
    96|         MREMAP_MAYMOVE;
    97|         MREMAP_FIXED;
    98|     }
    99| }
   100| libc_enum!{
   101|     #[repr(i32)]
   102|     pub enum MmapAdvise {
   103|         MADV_NORMAL,
   104|         MADV_RANDOM,
   105|         MADV_SEQUENTIAL,
   106|         MADV_WILLNEED,
   107|         MADV_DONTNEED,
   108|         #[cfg(any(target_os = "android", target_os = "linux"))]
   109|         MADV_REMOVE,
   110|         #[cfg(any(target_os = "android", target_os = "linux"))]
   111|         MADV_DONTFORK,
   112|         #[cfg(any(target_os = "android", target_os = "linux"))]
   113|         MADV_DOFORK,
   114|         #[cfg(any(target_os = "android", target_os = "linux"))]
   115|         MADV_HWPOISON,
   116|         #[cfg(any(target_os = "android", target_os = "linux"))]
   117|         MADV_MERGEABLE,
   118|         #[cfg(any(target_os = "android", target_os = "linux"))]
   119|         MADV_UNMERGEABLE,
   120|         #[cfg(any(target_os = "android",
   121|             all(target_os = "linux", any(
   122|                 target_arch = "aarch64",
   123|                 target_arch = "arm",
   124|                 target_arch = "ppc",
   125|                 target_arch = "s390x",
   126|                 target_arch = "x86",
   127|                 target_arch = "x86_64",
   128|                 target_arch = "sparc64"))))]
   129|         MADV_SOFT_OFFLINE,
   130|         #[cfg(any(target_os = "android", target_os = "linux"))]
   131|         MADV_HUGEPAGE,
   132|         #[cfg(any(target_os = "android", target_os = "linux"))]
   133|         MADV_NOHUGEPAGE,
   134|         #[cfg(any(target_os = "android", target_os = "linux"))]
   135|         MADV_DONTDUMP,
   136|         #[cfg(any(target_os = "android", target_os = "linux"))]
   137|         MADV_DODUMP,
   138|         MADV_FREE,
   139|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   140|         MADV_NOSYNC,
   141|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   142|         MADV_AUTOSYNC,
   143|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   144|         MADV_NOCORE,
   145|         #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   146|         MADV_CORE,
   147|         #[cfg(any(target_os = "freebsd"))]
   148|         MADV_PROTECT,
   149|         #[cfg(target_os = "dragonfly")]
   150|         MADV_INVAL,
   151|         #[cfg(target_os = "dragonfly")]
   152|         MADV_SETMAP,
   153|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   154|         MADV_ZERO_WIRED_PAGES,
   155|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   156|         MADV_FREE_REUSABLE,
   157|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   158|         MADV_FREE_REUSE,
   159|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   160|         MADV_CAN_REUSE,
   161|     }
   162| }
   163| libc_bitflags!{
   164|     pub struct MsFlags: c_int {
   165|         MS_ASYNC;
   166|         MS_INVALIDATE;
   167|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   168|         MS_KILLPAGES;
   169|         #[cfg(any(target_os = "ios", target_os = "macos"))]
   170|         MS_DEACTIVATE;
   171|         MS_SYNC;
   172|     }
   173| }
   174| libc_bitflags!{
   175|     pub struct MlockAllFlags: c_int {
   176|         MCL_CURRENT;
   177|         MCL_FUTURE;
   178|     }
   179| }
   180| pub unsafe fn mlock(addr: *const c_void, length: size_t) -> Result<()> {
   181|     Errno::result(libc::mlock(addr, length)).map(drop)
   182| }
   183| pub unsafe fn munlock(addr: *const c_void, length: size_t) -> Result<()> {
   184|     Errno::result(libc::munlock(addr, length)).map(drop)
   185| }
   186| pub fn mlockall(flags: MlockAllFlags) -> Result<()> {
   187|     unsafe { Errno::result(libc::mlockall(flags.bits())) }.map(drop)
   188| }
   189| pub fn munlockall() -> Result<()> {
   190|     unsafe { Errno::result(libc::munlockall()) }.map(drop)
   191| }
   192| pub unsafe fn mmap(addr: *mut c_void, length: size_t, prot: ProtFlags, flags: MapFlags, fd: RawFd, offset: off_t) -> Result<*mut c_void> {
   193|     let ret = libc::mmap(addr, length, prot.bits(), flags.bits(), fd, offset);
   194|     if ret == libc::MAP_FAILED {
   195|         Err(Error::from(Errno::last()))
   196|     } else {
   197|         Ok(ret)
   198|     }
   199| }
   200| #[cfg(target_os = "linux")]
   201| pub unsafe fn mremap(
   202|     addr: *mut c_void,
   203|     old_size: size_t,
   204|     new_size: size_t,
   205|     flags: MRemapFlags,
   206|     new_address: Option<* mut c_void>,
   207| ) -> Result<*mut c_void> {
   208|     let ret = libc::mremap(addr, old_size, new_size, flags.bits(), new_address.unwrap_or(std::ptr::null_mut()));
   209|     if ret == libc::MAP_FAILED {
   210|         Err(Error::from(Errno::last()))
   211|     } else {
   212|         Ok(ret)
   213|     }
   214| }
   215| pub unsafe fn munmap(addr: *mut c_void, len: size_t) -> Result<()> {
   216|     Errno::result(libc::munmap(addr, len)).map(drop)
   217| }
   218| pub unsafe fn madvise(addr: *mut c_void, length: size_t, advise: MmapAdvise) -> Result<()> {
   219|     Errno::result(libc::madvise(addr, length, advise as i32)).map(drop)
   220| }
   221| pub unsafe fn mprotect(addr: *mut c_void, length: size_t, prot: ProtFlags) -> Result<()> {
   222|     Errno::result(libc::mprotect(addr, length, prot.bits())).map(drop)
   223| }
   224| pub unsafe fn msync(addr: *mut c_void, length: size_t, flags: MsFlags) -> Result<()> {
   225|     Errno::result(libc::msync(addr, length, flags.bits())).map(drop)
   226| }
   227| #[cfg(not(target_os = "android"))]
   228| pub fn shm_open<P: ?Sized + NixPath>(name: &P, flag: OFlag, mode: Mode) -> Result<RawFd> {
   229|     let ret = name.with_nix_path(|cstr| {
   230|         #[cfg(any(target_os = "macos", target_os = "ios"))]
   231|         unsafe {
   232|             libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::c_uint)
   233|         }
   234|         #[cfg(not(any(target_os = "macos", target_os = "ios")))]
   235|         unsafe {
   236|             libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::mode_t)
   237|         }
   238|     })?;
   239|     Errno::result(ret)
   240| }
   241| #[cfg(not(target_os = "android"))]
   242| pub fn shm_unlink<P: ?Sized + NixPath>(name: &P) -> Result<()> {
   243|     let ret = name.with_nix_path(|cstr| {
   244|         unsafe { libc::shm_unlink(cstr.as_ptr()) }
   245|     })?;
   246|     Errno::result(ret).map(drop)
   247| }


# ====================================================================
# FILE: src/sys/ptrace/linux.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-332 ---
     1| use cfg_if::cfg_if;
     2| use std::{mem, ptr};
     3| use crate::Result;
     4| use crate::errno::Errno;
     5| use libc::{self, c_void, c_long, siginfo_t};
     6| use crate::unistd::Pid;
     7| use crate::sys::signal::Signal;
     8| pub type AddressType = *mut ::libc::c_void;
     9| #[cfg(all(
    10|     target_os = "linux",
    11|     any(all(target_arch = "x86_64",
    12|             any(target_env = "gnu", target_env = "musl")),
    13|         all(target_arch = "x86", target_env = "gnu"))
    14| ))]
    15| use libc::user_regs_struct;
    16| cfg_if! {
    17|     if #[cfg(any(all(target_os = "linux", target_arch = "s390x"),
    18|                  all(target_os = "linux", target_env = "gnu")))] {
    19|         #[doc(hidden)]
    20|         pub type RequestType = ::libc::c_uint;
    21|     } else {
    22|         #[doc(hidden)]
    23|         pub type RequestType = ::libc::c_int;
    24|     }
    25| }
    26| libc_enum!{
    27|     #[cfg_attr(not(any(target_env = "musl", target_os = "android")), repr(u32))]
    28|     #[cfg_attr(any(target_env = "musl", target_os = "android"), repr(i32))]
    29|     pub enum Request {
    30|         PTRACE_TRACEME,
    31|         PTRACE_PEEKTEXT,
    32|         PTRACE_PEEKDATA,
    33|         PTRACE_PEEKUSER,
    34|         PTRACE_POKETEXT,
    35|         PTRACE_POKEDATA,
    36|         PTRACE_POKEUSER,
    37|         PTRACE_CONT,
    38|         PTRACE_KILL,
    39|         PTRACE_SINGLESTEP,
    40|         #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
    41|                   all(target_os = "linux", any(target_env = "musl",
    42|                                                target_arch = "mips",
    43|                                                target_arch = "mips64",
    44|                                                target_arch = "x86_64",
    45|                                                target_pointer_width = "32"))))]
    46|         PTRACE_GETREGS,
    47|         #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
    48|                   all(target_os = "linux", any(target_env = "musl",
    49|                                                target_arch = "mips",
    50|                                                target_arch = "mips64",
    51|                                                target_arch = "x86_64",
    52|                                                target_pointer_width = "32"))))]
    53|         PTRACE_SETREGS,
    54|         #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
    55|                   all(target_os = "linux", any(target_env = "musl",
    56|                                                target_arch = "mips",
    57|                                                target_arch = "mips64",
    58|                                                target_arch = "x86_64",
    59|                                                target_pointer_width = "32"))))]
    60|         PTRACE_GETFPREGS,
    61|         #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
    62|                   all(target_os = "linux", any(target_env = "musl",
    63|                                                target_arch = "mips",
    64|                                                target_arch = "mips64",
    65|                                                target_arch = "x86_64",
    66|                                                target_pointer_width = "32"))))]
    67|         PTRACE_SETFPREGS,
    68|         PTRACE_ATTACH,
    69|         PTRACE_DETACH,
    70|         #[cfg(all(target_os = "linux", any(target_env = "musl",
    71|                                            target_arch = "mips",
    72|                                            target_arch = "mips64",
    73|                                            target_arch = "x86",
    74|                                            target_arch = "x86_64")))]
    75|         PTRACE_GETFPXREGS,
    76|         #[cfg(all(target_os = "linux", any(target_env = "musl",
    77|                                            target_arch = "mips",
    78|                                            target_arch = "mips64",
    79|                                            target_arch = "x86",
    80|                                            target_arch = "x86_64")))]
    81|         PTRACE_SETFPXREGS,
    82|         PTRACE_SYSCALL,
    83|         PTRACE_SETOPTIONS,
    84|         PTRACE_GETEVENTMSG,
    85|         PTRACE_GETSIGINFO,
    86|         PTRACE_SETSIGINFO,
    87|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
    88|                                                target_arch = "mips64"))))]
    89|         PTRACE_GETREGSET,
    90|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
    91|                                                target_arch = "mips64"))))]
    92|         PTRACE_SETREGSET,
    93|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
    94|                                                target_arch = "mips64"))))]
    95|         PTRACE_SEIZE,
    96|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
    97|                                                target_arch = "mips64"))))]
    98|         PTRACE_INTERRUPT,
    99|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
   100|                                                target_arch = "mips64"))))]
   101|         PTRACE_LISTEN,
   102|         #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
   103|                                                target_arch = "mips64"))))]
   104|         PTRACE_PEEKSIGINFO,
   105|         #[cfg(all(target_os = "linux", target_env = "gnu",
   106|                   any(target_arch = "x86", target_arch = "x86_64")))]
   107|         PTRACE_SYSEMU,
   108|         #[cfg(all(target_os = "linux", target_env = "gnu",
   109|                   any(target_arch = "x86", target_arch = "x86_64")))]
   110|         PTRACE_SYSEMU_SINGLESTEP,
   111|     }
   112| }
   113| libc_enum!{
   114|     #[repr(i32)]
   115|     pub enum Event {
   116|         PTRACE_EVENT_FORK,
   117|         PTRACE_EVENT_VFORK,
   118|         PTRACE_EVENT_CLONE,
   119|         PTRACE_EVENT_EXEC,
   120|         PTRACE_EVENT_VFORK_DONE,
   121|         PTRACE_EVENT_EXIT,
   122|         PTRACE_EVENT_SECCOMP,
   123|     }
   124| }
   125| libc_bitflags! {
   126|     pub struct Options: libc::c_int {
   127|         PTRACE_O_TRACESYSGOOD;
   128|         PTRACE_O_TRACEFORK;
   129|         PTRACE_O_TRACEVFORK;
   130|         PTRACE_O_TRACECLONE;
   131|         PTRACE_O_TRACEEXEC;
   132|         PTRACE_O_TRACEVFORKDONE;
   133|         PTRACE_O_TRACEEXIT;
   134|         PTRACE_O_TRACESECCOMP;
   135|         #[cfg(any(target_os = "android", target_os = "linux"))]
   136|         PTRACE_O_EXITKILL;
   137|     }
   138| }
   139| fn ptrace_peek(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
   140|     let ret = unsafe {
   141|         Errno::clear();
   142|         libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)
   143|     };
   144|     match Errno::result(ret) {
   145|         Ok(..) | Err(Errno::UnknownErrno) => Ok(ret),
   146|         err @ Err(..) => err,
   147|     }
   148| }
   149| #[cfg(all(
   150|     target_os = "linux",
   151|     any(all(target_arch = "x86_64",
   152|             any(target_env = "gnu", target_env = "musl")),
   153|         all(target_arch = "x86", target_env = "gnu"))
   154| ))]
   155| pub fn getregs(pid: Pid) -> Result<user_regs_struct> {
   156|     ptrace_get_data::<user_regs_struct>(Request::PTRACE_GETREGS, pid)
   157| }
   158| #[cfg(all(
   159|     target_os = "linux",
   160|     any(all(target_arch = "x86_64",
   161|             any(target_env = "gnu", target_env = "musl")),
   162|         all(target_arch = "x86", target_env = "gnu"))
   163| ))]
   164| pub fn setregs(pid: Pid, regs: user_regs_struct) -> Result<()> {
   165|     let res = unsafe {
   166|         libc::ptrace(Request::PTRACE_SETREGS as RequestType,
   167|                      libc::pid_t::from(pid),
   168|                      ptr::null_mut::<c_void>(),
   169|                      &regs as *const _ as *const c_void)
   170|     };
   171|     Errno::result(res).map(drop)
   172| }
   173| fn ptrace_get_data<T>(request: Request, pid: Pid) -> Result<T> {
   174|     let mut data = mem::MaybeUninit::uninit();
   175|     let res = unsafe {
   176|         libc::ptrace(request as RequestType,
   177|                      libc::pid_t::from(pid),
   178|                      ptr::null_mut::<T>(),
   179|                      data.as_mut_ptr() as *const _ as *const c_void)
   180|     };
   181|     Errno::result(res)?;
   182|     Ok(unsafe{ data.assume_init() })
   183| }
   184| unsafe fn ptrace_other(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
   185|     Errno::result(libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)).map(|_| 0)
   186| }
   187| pub fn setoptions(pid: Pid, options: Options) -> Result<()> {
   188|     let res = unsafe {
   189|         libc::ptrace(Request::PTRACE_SETOPTIONS as RequestType,
   190|                      libc::pid_t::from(pid),
   191|                      ptr::null_mut::<c_void>(),
   192|                      options.bits() as *mut c_void)
   193|     };
   194|     Errno::result(res).map(drop)
   195| }
   196| pub fn getevent(pid: Pid) -> Result<c_long> {
   197|     ptrace_get_data::<c_long>(Request::PTRACE_GETEVENTMSG, pid)
   198| }
   199| pub fn getsiginfo(pid: Pid) -> Result<siginfo_t> {
   200|     ptrace_get_data::<siginfo_t>(Request::PTRACE_GETSIGINFO, pid)
   201| }
   202| pub fn setsiginfo(pid: Pid, sig: &siginfo_t) -> Result<()> {
   203|     let ret = unsafe{
   204|         Errno::clear();
   205|         libc::ptrace(Request::PTRACE_SETSIGINFO as RequestType,
   206|                      libc::pid_t::from(pid),
   207|                      ptr::null_mut::<c_void>(),
   208|                      sig as *const _ as *const c_void)
   209|     };
   210|     match Errno::result(ret) {
   211|         Ok(_) => Ok(()),
   212|         Err(e) => Err(e),
   213|     }
   214| }
   215| pub fn traceme() -> Result<()> {
   216|     unsafe {
   217|         ptrace_other(
   218|             Request::PTRACE_TRACEME,
   219|             Pid::from_raw(0),
   220|             ptr::null_mut(),
   221|             ptr::null_mut(),
   222|         ).map(drop) // ignore the useless return value
   223|     }
   224| }
   225| pub fn syscall<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   226|     let data = match sig.into() {
   227|         Some(s) => s as i32 as *mut c_void,
   228|         None => ptr::null_mut(),
   229|     };
   230|     unsafe {
   231|         ptrace_other(
   232|             Request::PTRACE_SYSCALL,
   233|             pid,
   234|             ptr::null_mut(),
   235|             data,
   236|         ).map(drop) // ignore the useless return value
   237|     }
   238| }
   239| #[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
   240| pub fn sysemu<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   241|     let data = match sig.into() {
   242|         Some(s) => s as i32 as *mut c_void,
   243|         None => ptr::null_mut(),
   244|     };
   245|     unsafe {
   246|         ptrace_other(Request::PTRACE_SYSEMU, pid, ptr::null_mut(), data).map(drop)
   247|     }
   248| }
   249| pub fn attach(pid: Pid) -> Result<()> {
   250|     unsafe {
   251|         ptrace_other(
   252|             Request::PTRACE_ATTACH,
   253|             pid,
   254|             ptr::null_mut(),
   255|             ptr::null_mut(),
   256|         ).map(drop) // ignore the useless return value
   257|     }
   258| }
   259| #[cfg(all(target_os = "linux", not(any(target_arch = "mips", target_arch = "mips64"))))]
   260| pub fn seize(pid: Pid, options: Options) -> Result<()> {
   261|     unsafe {
   262|         ptrace_other(
   263|             Request::PTRACE_SEIZE,
   264|             pid,
   265|             ptr::null_mut(),
   266|             options.bits() as *mut c_void,
   267|         ).map(drop) // ignore the useless return value
   268|     }
   269| }
   270| pub fn detach<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   271|     let data = match sig.into() {
   272|         Some(s) => s as i32 as *mut c_void,
   273|         None => ptr::null_mut(),
   274|     };
   275|     unsafe {
   276|         ptrace_other(
   277|             Request::PTRACE_DETACH,
   278|             pid,
   279|             ptr::null_mut(),
   280|             data
   281|         ).map(drop)
   282|     }
   283| }
   284| pub fn cont<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   285|     let data = match sig.into() {
   286|         Some(s) => s as i32 as *mut c_void,
   287|         None => ptr::null_mut(),
   288|     };
   289|     unsafe {
   290|         ptrace_other(Request::PTRACE_CONT, pid, ptr::null_mut(), data).map(drop) // ignore the useless return value
   291|     }
   292| }
   293| pub fn kill(pid: Pid) -> Result<()> {
   294|     unsafe {
   295|         ptrace_other(Request::PTRACE_KILL, pid, ptr::null_mut(), ptr::null_mut()).map(drop)
   296|     }
   297| }
   298| pub fn step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   299|     let data = match sig.into() {
   300|         Some(s) => s as i32 as *mut c_void,
   301|         None => ptr::null_mut(),
   302|     };
   303|     unsafe {
   304|         ptrace_other(Request::PTRACE_SINGLESTEP, pid, ptr::null_mut(), data).map(drop)
   305|     }
   306| }
   307| #[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
   308| pub fn sysemu_step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
   309|     let data = match sig.into() {
   310|         Some(s) => s as i32 as *mut c_void,
   311|         None => ptr::null_mut(),
   312|     };
   313|     unsafe {
   314|         ptrace_other(
   315|             Request::PTRACE_SYSEMU_SINGLESTEP,
   316|             pid,
   317|             ptr::null_mut(),
   318|             data,
   319|         )
   320|         .map(drop) // ignore the useless return value
   321|     }
   322| }
   323| pub fn read(pid: Pid, addr: AddressType) -> Result<c_long> {
   324|     ptrace_peek(Request::PTRACE_PEEKDATA, pid, addr, ptr::null_mut())
   325| }
   326| pub unsafe fn write(
   327|     pid: Pid,
   328|     addr: AddressType,
   329|     data: *mut c_void) -> Result<()>
   330| {
   331|     ptrace_other(Request::PTRACE_POKEDATA, pid, addr, data).map(drop)
   332| }


# ====================================================================
# FILE: src/sys/reboot.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| use crate::{Error, Result};
     2| use crate::errno::Errno;
     3| use libc;
     4| use std::convert::Infallible;
     5| use std::mem::drop;
     6| libc_enum! {
     7|     #[repr(i32)]
     8|     pub enum RebootMode {
     9|         RB_HALT_SYSTEM,
    10|         RB_KEXEC,
    11|         RB_POWER_OFF,
    12|         RB_AUTOBOOT,
    13|         RB_SW_SUSPEND,
    14|     }
    15| }
    16| pub fn reboot(how: RebootMode) -> Result<Infallible> {
    17|     unsafe {
    18|         libc::reboot(how as libc::c_int)
    19|     };
    20|     Err(Error::from(Errno::last()))
    21| }
    22| pub fn set_cad_enabled(enable: bool) -> Result<()> {
    23|     let cmd = if enable {
    24|         libc::RB_ENABLE_CAD
    25|     } else {
    26|         libc::RB_DISABLE_CAD
    27|     };
    28|     let res = unsafe {
    29|         libc::reboot(cmd)
    30|     };
    31|     Errno::result(res).map(drop)
    32| }


# ====================================================================
# FILE: src/sys/signal.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-814 ---
     1| use crate::{Error, Result};
     2| use crate::errno::Errno;
     3| use crate::unistd::Pid;
     4| use std::convert::TryFrom;
     5| use std::mem;
     6| use std::fmt;
     7| use std::str::FromStr;
     8| #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
     9| use std::os::unix::io::RawFd;
    10| use std::ptr;
    11| #[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
    12| pub use self::sigevent::*;
    13| libc_enum!{
    14|     #[repr(i32)]
    15|     pub enum Signal {
    16|         SIGHUP,
    17|         SIGINT,
    18|         SIGQUIT,
    19|         SIGILL,
    20|         SIGTRAP,
    21|         SIGABRT,
    22|         SIGBUS,
    23|         SIGFPE,
    24|         SIGKILL,
    25|         SIGUSR1,
    26|         SIGSEGV,
    27|         SIGUSR2,
    28|         SIGPIPE,
    29|         SIGALRM,
    30|         SIGTERM,
    31|         #[cfg(all(any(target_os = "android", target_os = "emscripten",
    32|                       target_os = "fuchsia", target_os = "linux"),
    33|                   not(any(target_arch = "mips", target_arch = "mips64",
    34|                           target_arch = "sparc64"))))]
    35|         SIGSTKFLT,
    36|         SIGCHLD,
    37|         SIGCONT,
    38|         SIGSTOP,
    39|         SIGTSTP,
    40|         SIGTTIN,
    41|         SIGTTOU,
    42|         SIGURG,
    43|         SIGXCPU,
    44|         SIGXFSZ,
    45|         SIGVTALRM,
    46|         SIGPROF,
    47|         SIGWINCH,
    48|         SIGIO,
    49|         #[cfg(any(target_os = "android", target_os = "emscripten",
    50|                   target_os = "fuchsia", target_os = "linux"))]
    51|         SIGPWR,
    52|         SIGSYS,
    53|         #[cfg(not(any(target_os = "android", target_os = "emscripten",
    54|                       target_os = "fuchsia", target_os = "linux",
    55|                       target_os = "redox")))]
    56|         SIGEMT,
    57|         #[cfg(not(any(target_os = "android", target_os = "emscripten",
    58|                       target_os = "fuchsia", target_os = "linux",
    59|                       target_os = "redox")))]
    60|         SIGINFO,
    61|     }
    62| }
    63| impl FromStr for Signal {
    64|     type Err = Error;
    65|     fn from_str(s: &str) -> Result<Signal> {
    66|         Ok(match s {
    67|             "SIGHUP" => Signal::SIGHUP,
    68|             "SIGINT" => Signal::SIGINT,
    69|             "SIGQUIT" => Signal::SIGQUIT,
    70|             "SIGILL" => Signal::SIGILL,
    71|             "SIGTRAP" => Signal::SIGTRAP,
    72|             "SIGABRT" => Signal::SIGABRT,
    73|             "SIGBUS" => Signal::SIGBUS,
    74|             "SIGFPE" => Signal::SIGFPE,
    75|             "SIGKILL" => Signal::SIGKILL,
    76|             "SIGUSR1" => Signal::SIGUSR1,
    77|             "SIGSEGV" => Signal::SIGSEGV,
    78|             "SIGUSR2" => Signal::SIGUSR2,
    79|             "SIGPIPE" => Signal::SIGPIPE,
    80|             "SIGALRM" => Signal::SIGALRM,
    81|             "SIGTERM" => Signal::SIGTERM,
    82|             #[cfg(all(any(target_os = "android", target_os = "emscripten",
    83|                           target_os = "fuchsia", target_os = "linux"),
    84|                       not(any(target_arch = "mips", target_arch = "mips64",
    85|                               target_arch = "sparc64"))))]
    86|             "SIGSTKFLT" => Signal::SIGSTKFLT,
    87|             "SIGCHLD" => Signal::SIGCHLD,
    88|             "SIGCONT" => Signal::SIGCONT,
    89|             "SIGSTOP" => Signal::SIGSTOP,
    90|             "SIGTSTP" => Signal::SIGTSTP,
    91|             "SIGTTIN" => Signal::SIGTTIN,
    92|             "SIGTTOU" => Signal::SIGTTOU,
    93|             "SIGURG" => Signal::SIGURG,
    94|             "SIGXCPU" => Signal::SIGXCPU,
    95|             "SIGXFSZ" => Signal::SIGXFSZ,
    96|             "SIGVTALRM" => Signal::SIGVTALRM,
    97|             "SIGPROF" => Signal::SIGPROF,
    98|             "SIGWINCH" => Signal::SIGWINCH,
    99|             "SIGIO" => Signal::SIGIO,
   100|             #[cfg(any(target_os = "android", target_os = "emscripten",
   101|                       target_os = "fuchsia", target_os = "linux"))]
   102|             "SIGPWR" => Signal::SIGPWR,
   103|             "SIGSYS" => Signal::SIGSYS,
   104|             #[cfg(not(any(target_os = "android", target_os = "emscripten",
   105|                           target_os = "fuchsia", target_os = "linux",
   106|                           target_os = "redox")))]
   107|             "SIGEMT" => Signal::SIGEMT,
   108|             #[cfg(not(any(target_os = "android", target_os = "emscripten",
   109|                           target_os = "fuchsia", target_os = "linux",
   110|                           target_os = "redox")))]
   111|             "SIGINFO" => Signal::SIGINFO,
   112|             _ => return Err(Error::from(Errno::EINVAL)),
   113|         })
   114|     }
   115| }
   116| impl Signal {
   117|     pub fn as_str(self) -> &'static str {
   118|         match self {
   119|             Signal::SIGHUP => "SIGHUP",
   120|             Signal::SIGINT => "SIGINT",
   121|             Signal::SIGQUIT => "SIGQUIT",
   122|             Signal::SIGILL => "SIGILL",
   123|             Signal::SIGTRAP => "SIGTRAP",
   124|             Signal::SIGABRT => "SIGABRT",
   125|             Signal::SIGBUS => "SIGBUS",
   126|             Signal::SIGFPE => "SIGFPE",
   127|             Signal::SIGKILL => "SIGKILL",
   128|             Signal::SIGUSR1 => "SIGUSR1",
   129|             Signal::SIGSEGV => "SIGSEGV",
   130|             Signal::SIGUSR2 => "SIGUSR2",
   131|             Signal::SIGPIPE => "SIGPIPE",
   132|             Signal::SIGALRM => "SIGALRM",
   133|             Signal::SIGTERM => "SIGTERM",
   134|             #[cfg(all(any(target_os = "android", target_os = "emscripten",
   135|                           target_os = "fuchsia", target_os = "linux"),
   136|                       not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
   137|             Signal::SIGSTKFLT => "SIGSTKFLT",
   138|             Signal::SIGCHLD => "SIGCHLD",
   139|             Signal::SIGCONT => "SIGCONT",
   140|             Signal::SIGSTOP => "SIGSTOP",
   141|             Signal::SIGTSTP => "SIGTSTP",
   142|             Signal::SIGTTIN => "SIGTTIN",
   143|             Signal::SIGTTOU => "SIGTTOU",
   144|             Signal::SIGURG => "SIGURG",
   145|             Signal::SIGXCPU => "SIGXCPU",
   146|             Signal::SIGXFSZ => "SIGXFSZ",
   147|             Signal::SIGVTALRM => "SIGVTALRM",
   148|             Signal::SIGPROF => "SIGPROF",
   149|             Signal::SIGWINCH => "SIGWINCH",
   150|             Signal::SIGIO => "SIGIO",
   151|             #[cfg(any(target_os = "android", target_os = "emscripten",
   152|                       target_os = "fuchsia", target_os = "linux"))]
   153|             Signal::SIGPWR => "SIGPWR",
   154|             Signal::SIGSYS => "SIGSYS",
   155|             #[cfg(not(any(target_os = "android", target_os = "emscripten",
   156|                           target_os = "fuchsia", target_os = "linux",
   157|                           target_os = "redox")))]
   158|             Signal::SIGEMT => "SIGEMT",
   159|             #[cfg(not(any(target_os = "android", target_os = "emscripten",
   160|                           target_os = "fuchsia", target_os = "linux",
   161|                           target_os = "redox")))]
   162|             Signal::SIGINFO => "SIGINFO",
   163|         }
   164|     }
   165| }
   166| impl AsRef<str> for Signal {
   167|     fn as_ref(&self) -> &str {
   168|         self.as_str()
   169|     }
   170| }
   171| impl fmt::Display for Signal {
   172|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   173|         f.write_str(self.as_ref())
   174|     }
   175| }
   176| pub use self::Signal::*;
   177| #[cfg(target_os = "redox")]
   178| const SIGNALS: [Signal; 29] = [
   179|     SIGHUP,
   180|     SIGINT,
   181|     SIGQUIT,
   182|     SIGILL,
   183|     SIGTRAP,
   184|     SIGABRT,
   185|     SIGBUS,
   186|     SIGFPE,
   187|     SIGKILL,
   188|     SIGUSR1,
   189|     SIGSEGV,
   190|     SIGUSR2,
   191|     SIGPIPE,
   192|     SIGALRM,
   193|     SIGTERM,
   194|     SIGCHLD,
   195|     SIGCONT,
   196|     SIGSTOP,
   197|     SIGTSTP,
   198|     SIGTTIN,
   199|     SIGTTOU,
   200|     SIGURG,
   201|     SIGXCPU,
   202|     SIGXFSZ,
   203|     SIGVTALRM,
   204|     SIGPROF,
   205|     SIGWINCH,
   206|     SIGIO,
   207|     SIGSYS];
   208| #[cfg(all(any(target_os = "linux", target_os = "android",
   209|               target_os = "emscripten", target_os = "fuchsia"),
   210|           not(any(target_arch = "mips", target_arch = "mips64",
   211|                   target_arch = "sparc64"))))]
   212| const SIGNALS: [Signal; 31] = [
   213|     SIGHUP,
   214|     SIGINT,
   215|     SIGQUIT,
   216|     SIGILL,
   217|     SIGTRAP,
   218|     SIGABRT,
   219|     SIGBUS,
   220|     SIGFPE,
   221|     SIGKILL,
   222|     SIGUSR1,
   223|     SIGSEGV,
   224|     SIGUSR2,
   225|     SIGPIPE,
   226|     SIGALRM,
   227|     SIGTERM,
   228|     SIGSTKFLT,
   229|     SIGCHLD,
   230|     SIGCONT,
   231|     SIGSTOP,
   232|     SIGTSTP,
   233|     SIGTTIN,
   234|     SIGTTOU,
   235|     SIGURG,
   236|     SIGXCPU,
   237|     SIGXFSZ,
   238|     SIGVTALRM,
   239|     SIGPROF,
   240|     SIGWINCH,
   241|     SIGIO,
   242|     SIGPWR,
   243|     SIGSYS];
   244| #[cfg(all(any(target_os = "linux", target_os = "android",
   245|               target_os = "emscripten", target_os = "fuchsia"),
   246|           any(target_arch = "mips", target_arch = "mips64",
   247|               target_arch = "sparc64")))]
   248| const SIGNALS: [Signal; 30] = [
   249|     SIGHUP,
   250|     SIGINT,
   251|     SIGQUIT,
   252|     SIGILL,
   253|     SIGTRAP,
   254|     SIGABRT,
   255|     SIGBUS,
   256|     SIGFPE,
   257|     SIGKILL,
   258|     SIGUSR1,
   259|     SIGSEGV,
   260|     SIGUSR2,
   261|     SIGPIPE,
   262|     SIGALRM,
   263|     SIGTERM,
   264|     SIGCHLD,
   265|     SIGCONT,
   266|     SIGSTOP,
   267|     SIGTSTP,
   268|     SIGTTIN,
   269|     SIGTTOU,
   270|     SIGURG,
   271|     SIGXCPU,
   272|     SIGXFSZ,
   273|     SIGVTALRM,
   274|     SIGPROF,
   275|     SIGWINCH,
   276|     SIGIO,
   277|     SIGPWR,
   278|     SIGSYS];
   279| #[cfg(not(any(target_os = "linux", target_os = "android",
   280|               target_os = "fuchsia", target_os = "emscripten",
   281|               target_os = "redox")))]
   282| const SIGNALS: [Signal; 31] = [
   283|     SIGHUP,
   284|     SIGINT,
   285|     SIGQUIT,
   286|     SIGILL,
   287|     SIGTRAP,
   288|     SIGABRT,
   289|     SIGBUS,
   290|     SIGFPE,
   291|     SIGKILL,
   292|     SIGUSR1,
   293|     SIGSEGV,
   294|     SIGUSR2,
   295|     SIGPIPE,
   296|     SIGALRM,
   297|     SIGTERM,
   298|     SIGCHLD,
   299|     SIGCONT,
   300|     SIGSTOP,
   301|     SIGTSTP,
   302|     SIGTTIN,
   303|     SIGTTOU,
   304|     SIGURG,
   305|     SIGXCPU,
   306|     SIGXFSZ,
   307|     SIGVTALRM,
   308|     SIGPROF,
   309|     SIGWINCH,
   310|     SIGIO,
   311|     SIGSYS,
   312|     SIGEMT,
   313|     SIGINFO];
   314| pub const NSIG: libc::c_int = 32;
   315| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   316| pub struct SignalIterator {
   317|     next: usize,
   318| }
   319| impl Iterator for SignalIterator {
   320|     type Item = Signal;
   321|     fn next(&mut self) -> Option<Signal> {
   322|         if self.next < SIGNALS.len() {
   323|             let next_signal = SIGNALS[self.next];
   324|             self.next += 1;
   325|             Some(next_signal)
   326|         } else {
   327|             None
   328|         }
   329|     }
   330| }
   331| impl Signal {
   332|     pub fn iterator() -> SignalIterator {
   333|         SignalIterator{next: 0}
   334|     }
   335| }
   336| impl TryFrom<libc::c_int> for Signal {
   337|     type Error = Error;
   338|     fn try_from(signum: libc::c_int) -> Result<Signal> {
   339|         if 0 < signum && signum < NSIG {
   340|             Ok(unsafe { mem::transmute(signum) })
   341|         } else {
   342|             Err(Error::from(Errno::EINVAL))
   343|         }
   344|     }
   345| }
   346| pub const SIGIOT : Signal = SIGABRT;
   347| pub const SIGPOLL : Signal = SIGIO;
   348| pub const SIGUNUSED : Signal = SIGSYS;
   349| #[cfg(not(target_os = "redox"))]
   350| type SaFlags_t = libc::c_int;
   351| #[cfg(target_os = "redox")]
   352| type SaFlags_t = libc::c_ulong;
   353| libc_bitflags!{
   354|     pub struct SaFlags: SaFlags_t {
   355|         SA_NOCLDSTOP;
   356|         SA_NOCLDWAIT;
   357|         SA_NODEFER;
   358|         SA_ONSTACK;
   359|         SA_RESETHAND;
   360|         SA_RESTART;
   361|         SA_SIGINFO;
   362|     }
   363| }
   364| libc_enum! {
   365|     #[repr(i32)]
   366|     pub enum SigmaskHow {
   367|         SIG_BLOCK,
   368|         SIG_UNBLOCK,
   369|         SIG_SETMASK,
   370|     }
   371| }
   372| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   373| pub struct SigSet {
   374|     sigset: libc::sigset_t
   375| }
   376| impl SigSet {
   377|     pub fn all() -> SigSet {
   378|         let mut sigset = mem::MaybeUninit::uninit();
   379|         let _ = unsafe { libc::sigfillset(sigset.as_mut_ptr()) };
   380|         unsafe{ SigSet { sigset: sigset.assume_init() } }
   381|     }
   382|     pub fn empty() -> SigSet {
   383|         let mut sigset = mem::MaybeUninit::uninit();
   384|         let _ = unsafe { libc::sigemptyset(sigset.as_mut_ptr()) };
   385|         unsafe{ SigSet { sigset: sigset.assume_init() } }
   386|     }
   387|     pub fn add(&mut self, signal: Signal) {
   388|         unsafe { libc::sigaddset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
   389|     }
   390|     pub fn clear(&mut self) {
   391|         unsafe { libc::sigemptyset(&mut self.sigset as *mut libc::sigset_t) };
   392|     }
   393|     pub fn remove(&mut self, signal: Signal) {
   394|         unsafe { libc::sigdelset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
   395|     }
   396|     pub fn contains(&self, signal: Signal) -> bool {
   397|         let res = unsafe { libc::sigismember(&self.sigset as *const libc::sigset_t, signal as libc::c_int) };
   398|         match res {
   399|             1 => true,
   400|             0 => false,
   401|             _ => unreachable!("unexpected value from sigismember"),
   402|         }
   403|     }
   404|     pub fn extend(&mut self, other: &SigSet) {
   405|         for signal in Signal::iterator() {
   406|             if other.contains(signal) {
   407|                 self.add(signal);
   408|             }
   409|         }
   410|     }
   411|     pub fn thread_get_mask() -> Result<SigSet> {
   412|         let mut oldmask = mem::MaybeUninit::uninit();
   413|         do_pthread_sigmask(SigmaskHow::SIG_SETMASK, None, Some(oldmask.as_mut_ptr()))?;
   414|         Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
   415|     }
   416|     pub fn thread_set_mask(&self) -> Result<()> {
   417|         pthread_sigmask(SigmaskHow::SIG_SETMASK, Some(self), None)
   418|     }
   419|     pub fn thread_block(&self) -> Result<()> {
   420|         pthread_sigmask(SigmaskHow::SIG_BLOCK, Some(self), None)
   421|     }
   422|     pub fn thread_unblock(&self) -> Result<()> {
   423|         pthread_sigmask(SigmaskHow::SIG_UNBLOCK, Some(self), None)
   424|     }
   425|     pub fn thread_swap_mask(&self, how: SigmaskHow) -> Result<SigSet> {
   426|         let mut oldmask = mem::MaybeUninit::uninit();
   427|         do_pthread_sigmask(how, Some(self), Some(oldmask.as_mut_ptr()))?;
   428|         Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
   429|     }
   430|     #[cfg(not(target_os = "redox"))] // RedoxFS does not yet support sigwait
   431|     pub fn wait(&self) -> Result<Signal> {
   432|         let mut signum = mem::MaybeUninit::uninit();
   433|         let res = unsafe { libc::sigwait(&self.sigset as *const libc::sigset_t, signum.as_mut_ptr()) };
   434|         Errno::result(res).map(|_| unsafe {
   435|             Signal::try_from(signum.assume_init()).unwrap()
   436|         })
   437|     }
   438| }
   439| impl AsRef<libc::sigset_t> for SigSet {
   440|     fn as_ref(&self) -> &libc::sigset_t {
   441|         &self.sigset
   442|     }
   443| }
   444| #[allow(unknown_lints)]
   445| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   446| pub enum SigHandler {
   447|     SigDfl,
   448|     SigIgn,
   449|     Handler(extern fn(libc::c_int)),
   450|     #[cfg(not(target_os = "redox"))]
   451|     SigAction(extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void))
   452| }
   453| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   454| pub struct SigAction {
   455|     sigaction: libc::sigaction
   456| }
   457| impl SigAction {
   458|     pub fn new(handler: SigHandler, flags: SaFlags, mask: SigSet) -> SigAction {
   459|         #[cfg(target_os = "redox")]
   460|         unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
   461|             (*p).sa_handler = match handler {
   462|                 SigHandler::SigDfl => libc::SIG_DFL,
   463|                 SigHandler::SigIgn => libc::SIG_IGN,
   464|                 SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
   465|             };
   466|         }
   467|         #[cfg(not(target_os = "redox"))]
   468|         unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
   469|             (*p).sa_sigaction = match handler {
   470|                 SigHandler::SigDfl => libc::SIG_DFL,
   471|                 SigHandler::SigIgn => libc::SIG_IGN,
   472|                 SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
   473|                 SigHandler::SigAction(f) => f as *const extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void) as usize,
   474|             };
   475|         }
   476|         let mut s = mem::MaybeUninit::<libc::sigaction>::uninit();
   477|         unsafe {
   478|             let p = s.as_mut_ptr();
   479|             install_sig(p, handler);
   480|             (*p).sa_flags = match handler {
   481|                 #[cfg(not(target_os = "redox"))]
   482|                 SigHandler::SigAction(_) => (flags | SaFlags::SA_SIGINFO).bits(),
   483|                 _ => (flags - SaFlags::SA_SIGINFO).bits(),
   484|             };
   485|             (*p).sa_mask = mask.sigset;
   486|             SigAction { sigaction: s.assume_init() }
   487|         }
   488|     }
   489|     pub fn flags(&self) -> SaFlags {
   490|         SaFlags::from_bits_truncate(self.sigaction.sa_flags)
   491|     }
   492|     pub fn mask(&self) -> SigSet {
   493|         SigSet { sigset: self.sigaction.sa_mask }
   494|     }
   495|     #[cfg(not(target_os = "redox"))]
   496|     pub fn handler(&self) -> SigHandler {
   497|         match self.sigaction.sa_sigaction {
   498|             libc::SIG_DFL => SigHandler::SigDfl,
   499|             libc::SIG_IGN => SigHandler::SigIgn,
   500|             f if self.flags().contains(SaFlags::SA_SIGINFO) =>
   501|                 SigHandler::SigAction( unsafe { mem::transmute(f) } ),
   502|             f => SigHandler::Handler( unsafe { mem::transmute(f) } ),
   503|         }
   504|     }
   505|     #[cfg(target_os = "redox")]
   506|     pub fn handler(&self) -> SigHandler {
   507|         match self.sigaction.sa_handler {
   508|             libc::SIG_DFL => SigHandler::SigDfl,
   509|             libc::SIG_IGN => SigHandler::SigIgn,
   510|             f => SigHandler::Handler( unsafe { mem::transmute(f) } ),
   511|         }
   512|     }
   513| }
   514| pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigAction> {
   515|     let mut oldact = mem::MaybeUninit::<libc::sigaction>::uninit();
   516|     let res = libc::sigaction(signal as libc::c_int,
   517|                               &sigaction.sigaction as *const libc::sigaction,
   518|                               oldact.as_mut_ptr());
   519|     Errno::result(res).map(|_| SigAction { sigaction: oldact.assume_init() })
   520| }
   521| pub unsafe fn signal(signal: Signal, handler: SigHandler) -> Result<SigHandler> {
   522|     let signal = signal as libc::c_int;
   523|     let res = match handler {
   524|         SigHandler::SigDfl => libc::signal(signal, libc::SIG_DFL),
   525|         SigHandler::SigIgn => libc::signal(signal, libc::SIG_IGN),
   526|         SigHandler::Handler(handler) => libc::signal(signal, handler as libc::sighandler_t),
   527|         #[cfg(not(target_os = "redox"))]
   528|         SigHandler::SigAction(_) => return Err(Error::from(Errno::ENOTSUP)),
   529|     };
   530|     Errno::result(res).map(|oldhandler| {
   531|         match oldhandler {
   532|             libc::SIG_DFL => SigHandler::SigDfl,
   533|             libc::SIG_IGN => SigHandler::SigIgn,
   534|             f => SigHandler::Handler(mem::transmute(f)),
   535|         }
   536|     })
   537| }
   538| fn do_pthread_sigmask(how: SigmaskHow,
   539|                        set: Option<&SigSet>,
   540|                        oldset: Option<*mut libc::sigset_t>) -> Result<()> {
   541|     if set.is_none() && oldset.is_none() {
   542|         return Ok(())
   543|     }
   544|     let res = unsafe {
   545|         libc::pthread_sigmask(how as libc::c_int,
   546|                              set.map_or_else(ptr::null::<libc::sigset_t>,
   547|                                              |s| &s.sigset as *const libc::sigset_t),
   548|                              oldset.unwrap_or(ptr::null_mut())
   549|                              )
   550|     };
   551|     Errno::result(res).map(drop)
   552| }
   553| pub fn pthread_sigmask(how: SigmaskHow,
   554|                        set: Option<&SigSet>,
   555|                        oldset: Option<&mut SigSet>) -> Result<()>
   556| {
   557|     do_pthread_sigmask(how, set, oldset.map(|os| &mut os.sigset as *mut _ ))
   558| }
   559| pub fn sigprocmask(how: SigmaskHow, set: Option<&SigSet>, oldset: Option<&mut SigSet>) -> Result<()> {
   560|     if set.is_none() && oldset.is_none() {
   561|         return Ok(())
   562|     }
   563|     let res = unsafe {
   564|         libc::sigprocmask(how as libc::c_int,
   565|                           set.map_or_else(ptr::null::<libc::sigset_t>,
   566|                                           |s| &s.sigset as *const libc::sigset_t),
   567|                           oldset.map_or_else(ptr::null_mut::<libc::sigset_t>,
   568|                                              |os| &mut os.sigset as *mut libc::sigset_t))
   569|     };
   570|     Errno::result(res).map(drop)
   571| }
   572| pub fn kill<T: Into<Option<Signal>>>(pid: Pid, signal: T) -> Result<()> {
   573|     let res = unsafe { libc::kill(pid.into(),
   574|                                   match signal.into() {
   575|                                       Some(s) => s as libc::c_int,
   576|                                       None => 0,
   577|                                   }) };
   578|     Errno::result(res).map(drop)
   579| }
   580| #[cfg(not(target_os = "fuchsia"))]
   581| pub fn killpg<T: Into<Option<Signal>>>(pgrp: Pid, signal: T) -> Result<()> {
   582|     let res = unsafe { libc::killpg(pgrp.into(),
   583|                                   match signal.into() {
   584|                                       Some(s) => s as libc::c_int,
   585|                                       None => 0,
   586|                                   }) };
   587|     Errno::result(res).map(drop)
   588| }
   589| pub fn raise(signal: Signal) -> Result<()> {
   590|     let res = unsafe { libc::raise(signal as libc::c_int) };
   591|     Errno::result(res).map(drop)
   592| }
   593| #[cfg(target_os = "freebsd")]
   594| pub type type_of_thread_id = libc::lwpid_t;
   595| #[cfg(target_os = "linux")]
   596| pub type type_of_thread_id = libc::pid_t;
   597| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   598| pub enum SigevNotify {
   599|     SigevNone,
   600|     SigevSignal { signal: Signal, si_value: libc::intptr_t },
   601|     #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   602|     SigevKevent { kq: RawFd, udata: libc::intptr_t },
   603|     #[cfg(any(target_os = "freebsd", target_os = "linux"))]
   604|     SigevThreadId { signal: Signal, thread_id: type_of_thread_id,
   605|                     si_value: libc::intptr_t },
   606| }
   607| #[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
   608| mod sigevent {
   609|     use std::mem;
   610|     use std::ptr;
   611|     use super::SigevNotify;
   612|     #[cfg(any(target_os = "freebsd", target_os = "linux"))]
   613|     use super::type_of_thread_id;
   614|     #[repr(C)]
   615|     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   616|     pub struct SigEvent {
   617|         sigevent: libc::sigevent
   618|     }
   619|     impl SigEvent {
   620|         #[cfg_attr(target_os = "fuchsia", allow(invalid_value))]
   621|         pub fn new(sigev_notify: SigevNotify) -> SigEvent {
   622|             let mut sev = unsafe { mem::MaybeUninit::<libc::sigevent>::zeroed().assume_init() };
   623|             sev.sigev_notify = match sigev_notify {
   624|                 SigevNotify::SigevNone => libc::SIGEV_NONE,
   625|                 SigevNotify::SigevSignal{..} => libc::SIGEV_SIGNAL,
   626|                 #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   627|                 SigevNotify::SigevKevent{..} => libc::SIGEV_KEVENT,
   628|                 #[cfg(target_os = "freebsd")]
   629|                 SigevNotify::SigevThreadId{..} => libc::SIGEV_THREAD_ID,
   630|                 #[cfg(all(target_os = "linux", target_env = "gnu", not(target_arch = "mips")))]
   631|                 SigevNotify::SigevThreadId{..} => libc::SIGEV_THREAD_ID,
   632|                 #[cfg(any(all(target_os = "linux", target_env = "musl"), target_arch = "mips"))]
   633|                 SigevNotify::SigevThreadId{..} => 4  // No SIGEV_THREAD_ID defined
   634|             };
   635|             sev.sigev_signo = match sigev_notify {
   636|                 SigevNotify::SigevSignal{ signal, .. } => signal as libc::c_int,
   637|                 #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   638|                 SigevNotify::SigevKevent{ kq, ..} => kq,
   639|                 #[cfg(any(target_os = "linux", target_os = "freebsd"))]
   640|                 SigevNotify::SigevThreadId{ signal, .. } => signal as libc::c_int,
   641|                 _ => 0
   642|             };
   643|             sev.sigev_value.sival_ptr = match sigev_notify {
   644|                 SigevNotify::SigevNone => ptr::null_mut::<libc::c_void>(),
   645|                 SigevNotify::SigevSignal{ si_value, .. } => si_value as *mut libc::c_void,
   646|                 #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
   647|                 SigevNotify::SigevKevent{ udata, .. } => udata as *mut libc::c_void,
   648|                 #[cfg(any(target_os = "freebsd", target_os = "linux"))]
   649|                 SigevNotify::SigevThreadId{ si_value, .. } => si_value as *mut libc::c_void,
   650|             };
   651|             SigEvent::set_tid(&mut sev, &sigev_notify);
   652|             SigEvent{sigevent: sev}
   653|         }
   654|         #[cfg(any(target_os = "freebsd", target_os = "linux"))]
   655|         fn set_tid(sev: &mut libc::sigevent, sigev_notify: &SigevNotify) {
   656|             sev.sigev_notify_thread_id = match *sigev_notify {
   657|                 SigevNotify::SigevThreadId { thread_id, .. } => thread_id,
   658|                 _ => 0 as type_of_thread_id
   659|             };
   660|         }
   661|         #[cfg(not(any(target_os = "freebsd", target_os = "linux")))]
   662|         fn set_tid(_sev: &mut libc::sigevent, _sigev_notify: &SigevNotify) {
   663|         }
   664|         pub fn sigevent(&self) -> libc::sigevent {
   665|             self.sigevent
   666|         }
   667|     }
   668|     impl<'a> From<&'a libc::sigevent> for SigEvent {
   669|         fn from(sigevent: &libc::sigevent) -> Self {
   670|             SigEvent{ sigevent: *sigevent }
   671|         }
   672|     }
   673| }
   674| #[cfg(test)]
   675| mod tests {
   676|     #[cfg(not(target_os = "redox"))]
   677|     use std::thread;
   678|     use super::*;
   679|     #[test]
   680|     fn test_contains() {
   681|         let mut mask = SigSet::empty();
   682|         mask.add(SIGUSR1);
   683|         assert!(mask.contains(SIGUSR1));
   684|         assert!(!mask.contains(SIGUSR2));
   685|         let all = SigSet::all();
   686|         assert!(all.contains(SIGUSR1));
   687|         assert!(all.contains(SIGUSR2));
   688|     }
   689|     #[test]
   690|     fn test_clear() {
   691|         let mut set = SigSet::all();
   692|         set.clear();
   693|         for signal in Signal::iterator() {
   694|             assert!(!set.contains(signal));
   695|         }
   696|     }
   697|     #[test]
   698|     fn test_from_str_round_trips() {
   699|         for signal in Signal::iterator() {
   700|             assert_eq!(signal.as_ref().parse::<Signal>().unwrap(), signal);
   701|             assert_eq!(signal.to_string().parse::<Signal>().unwrap(), signal);
   702|         }
   703|     }
   704|     #[test]
   705|     fn test_from_str_invalid_value() {
   706|         let errval = Err(Error::from(Errno::EINVAL));
   707|         assert_eq!("NOSIGNAL".parse::<Signal>(), errval);
   708|         assert_eq!("kill".parse::<Signal>(), errval);
   709|         assert_eq!("9".parse::<Signal>(), errval);
   710|     }
   711|     #[test]
   712|     fn test_extend() {
   713|         let mut one_signal = SigSet::empty();
   714|         one_signal.add(SIGUSR1);
   715|         let mut two_signals = SigSet::empty();
   716|         two_signals.add(SIGUSR2);
   717|         two_signals.extend(&one_signal);
   718|         assert!(two_signals.contains(SIGUSR1));
   719|         assert!(two_signals.contains(SIGUSR2));
   720|     }
   721|     #[test]
   722|     #[cfg(not(target_os = "redox"))]
   723|     fn test_thread_signal_set_mask() {
   724|         thread::spawn(|| {
   725|             let prev_mask = SigSet::thread_get_mask()
   726|                 .expect("Failed to get existing signal mask!");
   727|             let mut test_mask = prev_mask;
   728|             test_mask.add(SIGUSR1);
   729|             assert!(test_mask.thread_set_mask().is_ok());
   730|             let new_mask = SigSet::thread_get_mask()
   731|                 .expect("Failed to get new mask!");
   732|             assert!(new_mask.contains(SIGUSR1));
   733|             assert!(!new_mask.contains(SIGUSR2));
   734|             prev_mask.thread_set_mask().expect("Failed to revert signal mask!");
   735|         }).join().unwrap();
   736|     }
   737|     #[test]
   738|     #[cfg(not(target_os = "redox"))]
   739|     fn test_thread_signal_block() {
   740|         thread::spawn(|| {
   741|             let mut mask = SigSet::empty();
   742|             mask.add(SIGUSR1);
   743|             assert!(mask.thread_block().is_ok());
   744|             assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
   745|         }).join().unwrap();
   746|     }
   747|     #[test]
   748|     #[cfg(not(target_os = "redox"))]
   749|     fn test_thread_signal_unblock() {
   750|         thread::spawn(|| {
   751|             let mut mask = SigSet::empty();
   752|             mask.add(SIGUSR1);
   753|             assert!(mask.thread_unblock().is_ok());
   754|             assert!(!SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
   755|         }).join().unwrap();
   756|     }
   757|     #[test]
   758|     #[cfg(not(target_os = "redox"))]
   759|     fn test_thread_signal_swap() {
   760|         thread::spawn(|| {
   761|             let mut mask = SigSet::empty();
   762|             mask.add(SIGUSR1);
   763|             mask.thread_block().unwrap();
   764|             assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
   765|             let mut mask2 = SigSet::empty();
   766|             mask2.add(SIGUSR2);
   767|             let oldmask = mask2.thread_swap_mask(SigmaskHow::SIG_SETMASK)
   768|                 .unwrap();
   769|             assert!(oldmask.contains(SIGUSR1));
   770|             assert!(!oldmask.contains(SIGUSR2));
   771|             assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR2));
   772|         }).join().unwrap();
   773|     }
   774|     #[test]
   775|     #[cfg(not(target_os = "redox"))]
   776|     fn test_sigaction() {
   777|         thread::spawn(|| {
   778|             extern fn test_sigaction_handler(_: libc::c_int) {}
   779|             extern fn test_sigaction_action(_: libc::c_int,
   780|                 _: *mut libc::siginfo_t, _: *mut libc::c_void) {}
   781|             let handler_sig = SigHandler::Handler(test_sigaction_handler);
   782|             let flags = SaFlags::SA_ONSTACK | SaFlags::SA_RESTART |
   783|                         SaFlags::SA_SIGINFO;
   784|             let mut mask = SigSet::empty();
   785|             mask.add(SIGUSR1);
   786|             let action_sig = SigAction::new(handler_sig, flags, mask);
   787|             assert_eq!(action_sig.flags(),
   788|                        SaFlags::SA_ONSTACK | SaFlags::SA_RESTART);
   789|             assert_eq!(action_sig.handler(), handler_sig);
   790|             mask = action_sig.mask();
   791|             assert!(mask.contains(SIGUSR1));
   792|             assert!(!mask.contains(SIGUSR2));
   793|             let handler_act = SigHandler::SigAction(test_sigaction_action);
   794|             let action_act = SigAction::new(handler_act, flags, mask);
   795|             assert_eq!(action_act.handler(), handler_act);
   796|             let action_dfl = SigAction::new(SigHandler::SigDfl, flags, mask);
   797|             assert_eq!(action_dfl.handler(), SigHandler::SigDfl);
   798|             let action_ign = SigAction::new(SigHandler::SigIgn, flags, mask);
   799|             assert_eq!(action_ign.handler(), SigHandler::SigIgn);
   800|         }).join().unwrap();
   801|     }
   802|     #[test]
   803|     #[cfg(not(target_os = "redox"))]
   804|     fn test_sigwait() {
   805|         thread::spawn(|| {
   806|             let mut mask = SigSet::empty();
   807|             mask.add(SIGUSR1);
   808|             mask.add(SIGUSR2);
   809|             mask.thread_block().unwrap();
   810|             raise(SIGUSR1).unwrap();
   811|             assert_eq!(mask.wait().unwrap(), SIGUSR1);
   812|         }).join().unwrap();
   813|     }
   814| }


# ====================================================================
# FILE: src/sys/signalfd.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| use libc;
     2| use crate::unistd;
     3| use crate::{Error, Result};
     4| use crate::errno::Errno;
     5| pub use crate::sys::signal::{self, SigSet};
     6| pub use libc::signalfd_siginfo as siginfo;
     7| use std::os::unix::io::{RawFd, AsRawFd};
     8| use std::mem;
     9| libc_bitflags!{
    10|     pub struct SfdFlags: libc::c_int {
    11|         SFD_NONBLOCK;
    12|         SFD_CLOEXEC;
    13|     }
    14| }
    15| pub const SIGNALFD_NEW: RawFd = -1;
    16| pub const SIGNALFD_SIGINFO_SIZE: usize = 128;
    17| pub fn signalfd(fd: RawFd, mask: &SigSet, flags: SfdFlags) -> Result<RawFd> {
    18|     unsafe {
    19|         Errno::result(libc::signalfd(fd as libc::c_int, mask.as_ref(), flags.bits()))
    20|     }
    21| }
    22| #[derive(Debug, Eq, Hash, PartialEq)]
    23| pub struct SignalFd(RawFd);
    24| impl SignalFd {
    25|     pub fn new(mask: &SigSet) -> Result<SignalFd> {
    26|         Self::with_flags(mask, SfdFlags::empty())
    27|     }
    28|     pub fn with_flags(mask: &SigSet, flags: SfdFlags) -> Result<SignalFd> {
    29|         let fd = signalfd(SIGNALFD_NEW, mask, flags)?;
    30|         Ok(SignalFd(fd))
    31|     }
    32|     pub fn set_mask(&mut self, mask: &SigSet) -> Result<()> {
    33|         signalfd(self.0, mask, SfdFlags::empty()).map(drop)
    34|     }
    35|     pub fn read_signal(&mut self) -> Result<Option<siginfo>> {
    36|         let mut buffer = mem::MaybeUninit::<[u8; SIGNALFD_SIGINFO_SIZE]>::uninit();
    37|         let res = Errno::result(unsafe {
    38|             libc::read(self.0,
    39|                        buffer.as_mut_ptr() as *mut libc::c_void,
    40|                        SIGNALFD_SIGINFO_SIZE as libc::size_t)
    41|         }).map(|r| r as usize);
    42|         match res {
    43|             Ok(SIGNALFD_SIGINFO_SIZE) => Ok(Some(unsafe { mem::transmute(buffer.assume_init()) })),
    44|             Ok(_) => unreachable!("partial read on signalfd"),
    45|             Err(Errno::EAGAIN) => Ok(None),
    46|             Err(error) => Err(error)
    47|         }
    48|     }
    49| }
    50| impl Drop for SignalFd {
    51|     fn drop(&mut self) {
    52|         let e = unistd::close(self.0);
    53|         if !std::thread::panicking() && e == Err(Error::from(Errno::EBADF)) {
    54|             panic!("Closing an invalid file descriptor!");
    55|         };
    56|     }
    57| }
    58| impl AsRawFd for SignalFd {
    59|     fn as_raw_fd(&self) -> RawFd {
    60|         self.0
    61|     }
    62| }
    63| impl Iterator for SignalFd {
    64|     type Item = siginfo;
    65|     fn next(&mut self) -> Option<Self::Item> {
    66|         match self.read_signal() {
    67|             Ok(Some(sig)) => Some(sig),
    68|             Ok(None) | Err(_) => None,
    69|         }
    70|     }
    71| }
    72| #[cfg(test)]
    73| mod tests {
    74|     use super::*;
    75|     use std::mem;
    76|     use libc;
    77|     #[test]
    78|     fn check_siginfo_size() {
    79|         assert_eq!(mem::size_of::<libc::signalfd_siginfo>(), SIGNALFD_SIGINFO_SIZE);
    80|     }
    81|     #[test]
    82|     fn create_signalfd() {
    83|         let mask = SigSet::empty();
    84|         let fd = SignalFd::new(&mask);
    85|         assert!(fd.is_ok());
    86|     }
    87|     #[test]
    88|     fn create_signalfd_with_opts() {
    89|         let mask = SigSet::empty();
    90|         let fd = SignalFd::with_flags(&mask, SfdFlags::SFD_CLOEXEC | SfdFlags::SFD_NONBLOCK);
    91|         assert!(fd.is_ok());
    92|     }
    93|     #[test]
    94|     fn read_empty_signalfd() {
    95|         let mask = SigSet::empty();
    96|         let mut fd = SignalFd::with_flags(&mask, SfdFlags::SFD_NONBLOCK).unwrap();
    97|         let res = fd.read_signal();
    98|         assert!(res.unwrap().is_none());
    99|     }
   100| }


# ====================================================================
# FILE: src/sys/socket/addr.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1117 ---
     1| use super::sa_family_t;
     2| use crate::{Error, Result, NixPath};
     3| use crate::errno::Errno;
     4| use memoffset::offset_of;
     5| use std::{fmt, mem, net, ptr, slice};
     6| use std::ffi::OsStr;
     7| use std::hash::{Hash, Hasher};
     8| use std::path::Path;
     9| use std::os::unix::ffi::OsStrExt;
    10| #[cfg(any(target_os = "android", target_os = "linux"))]
    11| use crate::sys::socket::addr::netlink::NetlinkAddr;
    12| #[cfg(any(target_os = "android", target_os = "linux"))]
    13| use crate::sys::socket::addr::alg::AlgAddr;
    14| #[cfg(any(target_os = "ios", target_os = "macos"))]
    15| use std::os::unix::io::RawFd;
    16| #[cfg(any(target_os = "ios", target_os = "macos"))]
    17| use crate::sys::socket::addr::sys_control::SysControlAddr;
    18| #[cfg(any(target_os = "android",
    19|           target_os = "dragonfly",
    20|           target_os = "freebsd",
    21|           target_os = "ios",
    22|           target_os = "linux",
    23|           target_os = "macos",
    24|           target_os = "illumos",
    25|           target_os = "netbsd",
    26|           target_os = "openbsd",
    27|           target_os = "fuchsia"))]
    28| pub use self::datalink::LinkAddr;
    29| #[cfg(any(target_os = "android", target_os = "linux"))]
    30| pub use self::vsock::VsockAddr;
    31| #[repr(i32)]
    32| #[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]
    33| pub enum AddressFamily {
    34|     Unix = libc::AF_UNIX,
    35|     Inet = libc::AF_INET,
    36|     Inet6 = libc::AF_INET6,
    37|     #[cfg(any(target_os = "android", target_os = "linux"))]
    38|     Netlink = libc::AF_NETLINK,
    39|     #[cfg(any(target_os = "android",
    40|               target_os = "linux",
    41|               target_os = "illumos",
    42|               target_os = "fuchsia",
    43|               target_os = "solaris"))]
    44|     Packet = libc::AF_PACKET,
    45|     #[cfg(any(target_os = "ios", target_os = "macos"))]
    46|     System = libc::AF_SYSTEM,
    47|     #[cfg(any(target_os = "android", target_os = "linux"))]
    48|     Ax25 = libc::AF_AX25,
    49|     Ipx = libc::AF_IPX,
    50|     AppleTalk = libc::AF_APPLETALK,
    51|     #[cfg(any(target_os = "android", target_os = "linux"))]
    52|     NetRom = libc::AF_NETROM,
    53|     #[cfg(any(target_os = "android", target_os = "linux"))]
    54|     Bridge = libc::AF_BRIDGE,
    55|     #[cfg(any(target_os = "android", target_os = "linux"))]
    56|     AtmPvc = libc::AF_ATMPVC,
    57|     #[cfg(any(target_os = "android", target_os = "linux"))]
    58|     X25 = libc::AF_X25,
    59|     #[cfg(any(target_os = "android", target_os = "linux"))]
    60|     Rose = libc::AF_ROSE,
    61|     Decnet = libc::AF_DECnet,
    62|     #[cfg(any(target_os = "android", target_os = "linux"))]
    63|     NetBeui = libc::AF_NETBEUI,
    64|     #[cfg(any(target_os = "android", target_os = "linux"))]
    65|     Security = libc::AF_SECURITY,
    66|     #[cfg(any(target_os = "android", target_os = "linux"))]
    67|     Key = libc::AF_KEY,
    68|     #[cfg(any(target_os = "android", target_os = "linux"))]
    69|     Ash = libc::AF_ASH,
    70|     #[cfg(any(target_os = "android", target_os = "linux"))]
    71|     Econet = libc::AF_ECONET,
    72|     #[cfg(any(target_os = "android", target_os = "linux"))]
    73|     AtmSvc = libc::AF_ATMSVC,
    74|     #[cfg(any(target_os = "android", target_os = "linux"))]
    75|     Rds = libc::AF_RDS,
    76|     Sna = libc::AF_SNA,
    77|     #[cfg(any(target_os = "android", target_os = "linux"))]
    78|     Irda = libc::AF_IRDA,
    79|     #[cfg(any(target_os = "android", target_os = "linux"))]
    80|     Pppox = libc::AF_PPPOX,
    81|     #[cfg(any(target_os = "android", target_os = "linux"))]
    82|     Wanpipe = libc::AF_WANPIPE,
    83|     #[cfg(any(target_os = "android", target_os = "linux"))]
    84|     Llc = libc::AF_LLC,
    85|     #[cfg(target_os = "linux")]
    86|     Ib = libc::AF_IB,
    87|     #[cfg(target_os = "linux")]
    88|     Mpls = libc::AF_MPLS,
    89|     #[cfg(any(target_os = "android", target_os = "linux"))]
    90|     Can = libc::AF_CAN,
    91|     #[cfg(any(target_os = "android", target_os = "linux"))]
    92|     Tipc = libc::AF_TIPC,
    93|     #[cfg(not(any(target_os = "illumos",
    94|                   target_os = "ios",
    95|                   target_os = "macos",
    96|                   target_os = "solaris")))]
    97|     Bluetooth = libc::AF_BLUETOOTH,
    98|     #[cfg(any(target_os = "android", target_os = "linux"))]
    99|     Iucv = libc::AF_IUCV,
   100|     #[cfg(any(target_os = "android", target_os = "linux"))]
   101|     RxRpc = libc::AF_RXRPC,
   102|     #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
   103|     Isdn = libc::AF_ISDN,
   104|     #[cfg(any(target_os = "android", target_os = "linux"))]
   105|     Phonet = libc::AF_PHONET,
   106|     #[cfg(any(target_os = "android", target_os = "linux"))]
   107|     Ieee802154 = libc::AF_IEEE802154,
   108|     #[cfg(any(target_os = "android", target_os = "linux"))]
   109|     Caif = libc::AF_CAIF,
   110|     #[cfg(any(target_os = "android", target_os = "linux"))]
   111|     Alg = libc::AF_ALG,
   112|     #[cfg(target_os = "linux")]
   113|     Nfc = libc::AF_NFC,
   114|     #[cfg(any(target_os = "android", target_os = "linux"))]
   115|     Vsock = libc::AF_VSOCK,
   116|     #[cfg(any(target_os = "dragonfly",
   117|               target_os = "freebsd",
   118|               target_os = "ios",
   119|               target_os = "macos",
   120|               target_os = "netbsd",
   121|               target_os = "openbsd"))]
   122|     ImpLink = libc::AF_IMPLINK,
   123|     #[cfg(any(target_os = "dragonfly",
   124|               target_os = "freebsd",
   125|               target_os = "ios",
   126|               target_os = "macos",
   127|               target_os = "netbsd",
   128|               target_os = "openbsd"))]
   129|     Pup = libc::AF_PUP,
   130|     #[cfg(any(target_os = "dragonfly",
   131|               target_os = "freebsd",
   132|               target_os = "ios",
   133|               target_os = "macos",
   134|               target_os = "netbsd",
   135|               target_os = "openbsd"))]
   136|     Chaos = libc::AF_CHAOS,
   137|     #[cfg(any(target_os = "ios",
   138|               target_os = "macos",
   139|               target_os = "netbsd",
   140|               target_os = "openbsd"))]
   141|     Ns = libc::AF_NS,
   142|     #[cfg(any(target_os = "dragonfly",
   143|               target_os = "freebsd",
   144|               target_os = "ios",
   145|               target_os = "macos",
   146|               target_os = "netbsd",
   147|               target_os = "openbsd"))]
   148|     Iso = libc::AF_ISO,
   149|     #[cfg(any(target_os = "dragonfly",
   150|               target_os = "freebsd",
   151|               target_os = "ios",
   152|               target_os = "macos",
   153|               target_os = "netbsd",
   154|               target_os = "openbsd"))]
   155|     Datakit = libc::AF_DATAKIT,
   156|     #[cfg(any(target_os = "dragonfly",
   157|               target_os = "freebsd",
   158|               target_os = "ios",
   159|               target_os = "macos",
   160|               target_os = "netbsd",
   161|               target_os = "openbsd"))]
   162|     Ccitt = libc::AF_CCITT,
   163|     #[cfg(any(target_os = "dragonfly",
   164|               target_os = "freebsd",
   165|               target_os = "ios",
   166|               target_os = "macos",
   167|               target_os = "netbsd",
   168|               target_os = "openbsd"))]
   169|     Dli = libc::AF_DLI,
   170|     #[cfg(any(target_os = "dragonfly",
   171|               target_os = "freebsd",
   172|               target_os = "ios",
   173|               target_os = "macos",
   174|               target_os = "netbsd",
   175|               target_os = "openbsd"))]
   176|     Lat = libc::AF_LAT,
   177|     #[cfg(any(target_os = "dragonfly",
   178|               target_os = "freebsd",
   179|               target_os = "ios",
   180|               target_os = "macos",
   181|               target_os = "netbsd",
   182|               target_os = "openbsd"))]
   183|     Hylink = libc::AF_HYLINK,
   184|     #[cfg(any(target_os = "dragonfly",
   185|               target_os = "freebsd",
   186|               target_os = "ios",
   187|               target_os = "macos",
   188|               target_os = "illumos",
   189|               target_os = "netbsd",
   190|               target_os = "openbsd"))]
   191|     Link = libc::AF_LINK,
   192|     #[cfg(any(target_os = "dragonfly",
   193|               target_os = "freebsd",
   194|               target_os = "ios",
   195|               target_os = "macos",
   196|               target_os = "netbsd",
   197|               target_os = "openbsd"))]
   198|     Coip = libc::AF_COIP,
   199|     #[cfg(any(target_os = "dragonfly",
   200|               target_os = "freebsd",
   201|               target_os = "ios",
   202|               target_os = "macos",
   203|               target_os = "netbsd",
   204|               target_os = "openbsd"))]
   205|     Cnt = libc::AF_CNT,
   206|     #[cfg(any(target_os = "dragonfly",
   207|               target_os = "freebsd",
   208|               target_os = "ios",
   209|               target_os = "macos",
   210|               target_os = "netbsd",
   211|               target_os = "openbsd"))]
   212|     Natm = libc::AF_NATM,
   213|     #[cfg(any(target_os = "android", target_os = "linux"))]
   214|     Unspec = libc::AF_UNSPEC,
   215| }
   216| impl AddressFamily {
   217|     pub fn from_i32(family: i32) -> Option<AddressFamily> {
   218|         match family {
   219|             libc::AF_UNIX => Some(AddressFamily::Unix),
   220|             libc::AF_INET => Some(AddressFamily::Inet),
   221|             libc::AF_INET6 => Some(AddressFamily::Inet6),
   222|             #[cfg(any(target_os = "android", target_os = "linux"))]
   223|             libc::AF_NETLINK => Some(AddressFamily::Netlink),
   224|             #[cfg(any(target_os = "macos", target_os = "macos"))]
   225|             libc::AF_SYSTEM => Some(AddressFamily::System),
   226|             #[cfg(any(target_os = "android", target_os = "linux"))]
   227|             libc::AF_PACKET => Some(AddressFamily::Packet),
   228|             #[cfg(any(target_os = "dragonfly",
   229|                       target_os = "freebsd",
   230|                       target_os = "ios",
   231|                       target_os = "macos",
   232|                       target_os = "netbsd",
   233|                       target_os = "illumos",
   234|                       target_os = "openbsd"))]
   235|             libc::AF_LINK => Some(AddressFamily::Link),
   236|             #[cfg(any(target_os = "android", target_os = "linux"))]
   237|             libc::AF_VSOCK => Some(AddressFamily::Vsock),
   238|             _ => None
   239|         }
   240|     }
   241| }
   242| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   243| pub enum InetAddr {
   244|     V4(libc::sockaddr_in),
   245|     V6(libc::sockaddr_in6),
   246| }
   247| impl InetAddr {
   248|     pub fn from_std(std: &net::SocketAddr) -> InetAddr {
   249|         match *std {
   250|             net::SocketAddr::V4(ref addr) => {
   251|                 InetAddr::V4(libc::sockaddr_in {
   252|                     sin_family: AddressFamily::Inet as sa_family_t,
   253|                     sin_port: addr.port().to_be(),  // network byte order
   254|                     sin_addr: Ipv4Addr::from_std(addr.ip()).0,
   255|                     .. unsafe { mem::zeroed() }
   256|                 })
   257|             }
   258|             net::SocketAddr::V6(ref addr) => {
   259|                 InetAddr::V6(libc::sockaddr_in6 {
   260|                     sin6_family: AddressFamily::Inet6 as sa_family_t,
   261|                     sin6_port: addr.port().to_be(),  // network byte order
   262|                     sin6_addr: Ipv6Addr::from_std(addr.ip()).0,
   263|                     sin6_flowinfo: addr.flowinfo(),  // host byte order
   264|                     sin6_scope_id: addr.scope_id(),  // host byte order
   265|                     .. unsafe { mem::zeroed() }
   266|                 })
   267|             }
   268|         }
   269|     }
   270|     pub fn new(ip: IpAddr, port: u16) -> InetAddr {
   271|         match ip {
   272|             IpAddr::V4(ref ip) => {
   273|                 InetAddr::V4(libc::sockaddr_in {
   274|                     sin_family: AddressFamily::Inet as sa_family_t,
   275|                     sin_port: port.to_be(),
   276|                     sin_addr: ip.0,
   277|                     .. unsafe { mem::zeroed() }
   278|                 })
   279|             }
   280|             IpAddr::V6(ref ip) => {
   281|                 InetAddr::V6(libc::sockaddr_in6 {
   282|                     sin6_family: AddressFamily::Inet6 as sa_family_t,
   283|                     sin6_port: port.to_be(),
   284|                     sin6_addr: ip.0,
   285|                     .. unsafe { mem::zeroed() }
   286|                 })
   287|             }
   288|         }
   289|     }
   290|     pub fn ip(&self) -> IpAddr {
   291|         match *self {
   292|             InetAddr::V4(ref sa) => IpAddr::V4(Ipv4Addr(sa.sin_addr)),
   293|             InetAddr::V6(ref sa) => IpAddr::V6(Ipv6Addr(sa.sin6_addr)),
   294|         }
   295|     }
   296|     pub fn port(&self) -> u16 {
   297|         match *self {
   298|             InetAddr::V6(ref sa) => u16::from_be(sa.sin6_port),
   299|             InetAddr::V4(ref sa) => u16::from_be(sa.sin_port),
   300|         }
   301|     }
   302|     pub fn to_std(&self) -> net::SocketAddr {
   303|         match *self {
   304|             InetAddr::V4(ref sa) => net::SocketAddr::V4(
   305|                 net::SocketAddrV4::new(
   306|                     Ipv4Addr(sa.sin_addr).to_std(),
   307|                     self.port())),
   308|             InetAddr::V6(ref sa) => net::SocketAddr::V6(
   309|                 net::SocketAddrV6::new(
   310|                     Ipv6Addr(sa.sin6_addr).to_std(),
   311|                     self.port(),
   312|                     sa.sin6_flowinfo,
   313|                     sa.sin6_scope_id)),
   314|         }
   315|     }
   316|     pub fn to_str(&self) -> String {
   317|         format!("{}", self)
   318|     }
   319| }
   320| impl fmt::Display for InetAddr {
   321|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   322|         match *self {
   323|             InetAddr::V4(_) => write!(f, "{}:{}", self.ip(), self.port()),
   324|             InetAddr::V6(_) => write!(f, "[{}]:{}", self.ip(), self.port()),
   325|         }
   326|     }
   327| }
   328| /*
   329|  *
   330|  * ===== IpAddr =====
   331|  *
   332|  */
   333| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   334| pub enum IpAddr {
   335|     V4(Ipv4Addr),
   336|     V6(Ipv6Addr),
   337| }
   338| impl IpAddr {
   339|     pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {
   340|         IpAddr::V4(Ipv4Addr::new(a, b, c, d))
   341|     }
   342|     #[allow(clippy::many_single_char_names)]
   343|     #[allow(clippy::too_many_arguments)]
   344|     pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpAddr {
   345|         IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))
   346|     }
   347|     pub fn from_std(std: &net::IpAddr) -> IpAddr {
   348|         match *std {
   349|             net::IpAddr::V4(ref std) => IpAddr::V4(Ipv4Addr::from_std(std)),
   350|             net::IpAddr::V6(ref std) => IpAddr::V6(Ipv6Addr::from_std(std)),
   351|         }
   352|     }
   353|     pub fn to_std(&self) -> net::IpAddr {
   354|         match *self {
   355|             IpAddr::V4(ref ip) => net::IpAddr::V4(ip.to_std()),
   356|             IpAddr::V6(ref ip) => net::IpAddr::V6(ip.to_std()),
   357|         }
   358|     }
   359| }
   360| impl fmt::Display for IpAddr {
   361|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   362|         match *self {
   363|             IpAddr::V4(ref v4) => v4.fmt(f),
   364|             IpAddr::V6(ref v6) => v6.fmt(f)
   365|         }
   366|     }
   367| }
   368| /*
   369|  *
   370|  * ===== Ipv4Addr =====
   371|  *
   372|  */
   373| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   374| pub struct Ipv4Addr(pub libc::in_addr);
   375| impl Ipv4Addr {
   376|     #[allow(clippy::identity_op)]   // More readable this way
   377|     pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
   378|         let ip = ((u32::from(a) << 24) |
   379|                   (u32::from(b) << 16) |
   380|                   (u32::from(c) <<  8) |
   381|                   (u32::from(d) <<  0)).to_be();
   382|         Ipv4Addr(libc::in_addr { s_addr: ip })
   383|     }
   384|     #[allow(clippy::trivially_copy_pass_by_ref)]
   385|     pub fn from_std(std: &net::Ipv4Addr) -> Ipv4Addr {
   386|         let bits = std.octets();
   387|         Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
   388|     }
   389|     pub fn any() -> Ipv4Addr {
   390|         Ipv4Addr(libc::in_addr { s_addr: libc::INADDR_ANY })
   391|     }
   392|     pub fn octets(self) -> [u8; 4] {
   393|         let bits = u32::from_be(self.0.s_addr);
   394|         [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]
   395|     }
   396|     pub fn to_std(self) -> net::Ipv4Addr {
   397|         let bits = self.octets();
   398|         net::Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
   399|     }
   400| }
   401| impl fmt::Display for Ipv4Addr {
   402|     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   403|         let octets = self.octets();
   404|         write!(fmt, "{}.{}.{}.{}", octets[0], octets[1], octets[2], octets[3])
   405|     }
   406| }
   407| /*
   408|  *
   409|  * ===== Ipv6Addr =====
   410|  *
   411|  */
   412| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   413| pub struct Ipv6Addr(pub libc::in6_addr);
   414| macro_rules! to_u8_array {
   415|     ($($num:ident),*) => {
   416|         [ $(($num>>8) as u8, ($num&0xff) as u8,)* ]
   417|     }
   418| }
   419| macro_rules! to_u16_array {
   420|     ($slf:ident, $($first:expr, $second:expr),*) => {
   421|         [$( (($slf.0.s6_addr[$first] as u16) << 8) + $slf.0.s6_addr[$second] as u16,)*]
   422|     }
   423| }
   424| impl Ipv6Addr {
   425|     #[allow(clippy::many_single_char_names)]
   426|     #[allow(clippy::too_many_arguments)]
   427|     pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {
   428|         Ipv6Addr(libc::in6_addr{s6_addr: to_u8_array!(a,b,c,d,e,f,g,h)})
   429|     }
   430|     pub fn from_std(std: &net::Ipv6Addr) -> Ipv6Addr {
   431|         let s = std.segments();
   432|         Ipv6Addr::new(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7])
   433|     }
   434|     pub fn segments(&self) -> [u16; 8] {
   435|         to_u16_array!(self, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
   436|     }
   437|     pub fn to_std(&self) -> net::Ipv6Addr {
   438|         let s = self.segments();
   439|         net::Ipv6Addr::new(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7])
   440|     }
   441| }
   442| impl fmt::Display for Ipv6Addr {
   443|     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
   444|         self.to_std().fmt(fmt)
   445|     }
   446| }
   447| #[derive(Clone, Copy, Debug)]
   448| pub struct UnixAddr(pub libc::sockaddr_un, pub usize);
   449| impl UnixAddr {
   450|     pub fn new<P: ?Sized + NixPath>(path: &P) -> Result<UnixAddr> {
   451|         path.with_nix_path(|cstr| {
   452|             unsafe {
   453|                 let mut ret = libc::sockaddr_un {
   454|                     sun_family: AddressFamily::Unix as sa_family_t,
   455|                     .. mem::zeroed()
   456|                 };
   457|                 let bytes = cstr.to_bytes();
   458|                 if bytes.len() > ret.sun_path.len() {
   459|                     return Err(Error::from(Errno::ENAMETOOLONG));
   460|                 }
   461|                 ptr::copy_nonoverlapping(bytes.as_ptr(),
   462|                                          ret.sun_path.as_mut_ptr() as *mut u8,
   463|                                          bytes.len());
   464|                 Ok(UnixAddr(ret, bytes.len()))
   465|             }
   466|         })?
   467|     }
   468|     #[cfg(any(target_os = "android", target_os = "linux"))]
   469|     pub fn new_abstract(path: &[u8]) -> Result<UnixAddr> {
   470|         unsafe {
   471|             let mut ret = libc::sockaddr_un {
   472|                 sun_family: AddressFamily::Unix as sa_family_t,
   473|                 .. mem::zeroed()
   474|             };
   475|             if path.len() + 1 > ret.sun_path.len() {
   476|                 return Err(Error::from(Errno::ENAMETOOLONG));
   477|             }
   478|             ptr::copy_nonoverlapping(path.as_ptr(),
   479|                                      ret.sun_path.as_mut_ptr().offset(1) as *mut u8,
   480|                                      path.len());
   481|             Ok(UnixAddr(ret, path.len() + 1))
   482|         }
   483|     }
   484|     fn sun_path(&self) -> &[u8] {
   485|         unsafe { slice::from_raw_parts(self.0.sun_path.as_ptr() as *const u8, self.1) }
   486|     }
   487|     pub fn path(&self) -> Option<&Path> {
   488|         if self.1 == 0 || self.0.sun_path[0] == 0 {
   489|             None
   490|         } else {
   491|             let p = self.sun_path();
   492|             let ptr = &self.0.sun_path as *const libc::c_char;
   493|             let reallen = unsafe { libc::strnlen(ptr, p.len()) };
   494|             Some(Path::new(<OsStr as OsStrExt>::from_bytes(&p[..reallen])))
   495|         }
   496|     }
   497|     #[cfg(any(target_os = "android", target_os = "linux"))]
   498|     pub fn as_abstract(&self) -> Option<&[u8]> {
   499|         if self.1 >= 1 && self.0.sun_path[0] == 0 {
   500|             Some(&self.sun_path()[1..])
   501|         } else {
   502|             None
   503|         }
   504|     }
   505| }
   506| impl fmt::Display for UnixAddr {
   507|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   508|         if self.1 == 0 {
   509|             f.write_str("<unbound UNIX socket>")
   510|         } else if let Some(path) = self.path() {
   511|             path.display().fmt(f)
   512|         } else {
   513|             let display = String::from_utf8_lossy(&self.sun_path()[1..]);
   514|             write!(f, "@{}", display)
   515|         }
   516|     }
   517| }
   518| impl PartialEq for UnixAddr {
   519|     fn eq(&self, other: &UnixAddr) -> bool {
   520|         self.sun_path() == other.sun_path()
   521|     }
   522| }
   523| impl Eq for UnixAddr {}
   524| impl Hash for UnixAddr {
   525|     fn hash<H: Hasher>(&self, s: &mut H) {
   526|         ( self.0.sun_family, self.sun_path() ).hash(s)
   527|     }
   528| }
   529| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   530| pub enum SockAddr {
   531|     Inet(InetAddr),
   532|     Unix(UnixAddr),
   533|     #[cfg(any(target_os = "android", target_os = "linux"))]
   534|     Netlink(NetlinkAddr),
   535|     #[cfg(any(target_os = "android", target_os = "linux"))]
   536|     Alg(AlgAddr),
   537|     #[cfg(any(target_os = "ios", target_os = "macos"))]
   538|     SysControl(SysControlAddr),
   539|     #[cfg(any(target_os = "android",
   540|               target_os = "dragonfly",
   541|               target_os = "freebsd",
   542|               target_os = "ios",
   543|               target_os = "linux",
   544|               target_os = "macos",
   545|               target_os = "illumos",
   546|               target_os = "netbsd",
   547|               target_os = "openbsd"))]
   548|     Link(LinkAddr),
   549|     #[cfg(any(target_os = "android", target_os = "linux"))]
   550|     Vsock(VsockAddr),
   551| }
   552| impl SockAddr {
   553|     pub fn new_inet(addr: InetAddr) -> SockAddr {
   554|         SockAddr::Inet(addr)
   555|     }
   556|     pub fn new_unix<P: ?Sized + NixPath>(path: &P) -> Result<SockAddr> {
   557|         Ok(SockAddr::Unix(UnixAddr::new(path)?))
   558|     }
   559|     #[cfg(any(target_os = "android", target_os = "linux"))]
   560|     pub fn new_netlink(pid: u32, groups: u32) -> SockAddr {
   561|         SockAddr::Netlink(NetlinkAddr::new(pid, groups))
   562|     }
   563|     #[cfg(any(target_os = "android", target_os = "linux"))]
   564|     pub fn new_alg(alg_type: &str, alg_name: &str) -> SockAddr {
   565|         SockAddr::Alg(AlgAddr::new(alg_type, alg_name))
   566|     }
   567|     #[cfg(any(target_os = "ios", target_os = "macos"))]
   568|     pub fn new_sys_control(sockfd: RawFd, name: &str, unit: u32) -> Result<SockAddr> {
   569|         SysControlAddr::from_name(sockfd, name, unit).map(|a| SockAddr::SysControl(a))
   570|     }
   571|     #[cfg(any(target_os = "android", target_os = "linux"))]
   572|     pub fn new_vsock(cid: u32, port: u32) -> SockAddr {
   573|         SockAddr::Vsock(VsockAddr::new(cid, port))
   574|     }
   575|     pub fn family(&self) -> AddressFamily {
   576|         match *self {
   577|             SockAddr::Inet(InetAddr::V4(..)) => AddressFamily::Inet,
   578|             SockAddr::Inet(InetAddr::V6(..)) => AddressFamily::Inet6,
   579|             SockAddr::Unix(..) => AddressFamily::Unix,
   580|             #[cfg(any(target_os = "android", target_os = "linux"))]
   581|             SockAddr::Netlink(..) => AddressFamily::Netlink,
   582|             #[cfg(any(target_os = "android", target_os = "linux"))]
   583|             SockAddr::Alg(..) => AddressFamily::Alg,
   584|             #[cfg(any(target_os = "ios", target_os = "macos"))]
   585|             SockAddr::SysControl(..) => AddressFamily::System,
   586|             #[cfg(any(target_os = "android", target_os = "linux"))]
   587|             SockAddr::Link(..) => AddressFamily::Packet,
   588|             #[cfg(any(target_os = "dragonfly",
   589|                       target_os = "freebsd",
   590|                       target_os = "ios",
   591|                       target_os = "macos",
   592|                       target_os = "netbsd",
   593|                       target_os = "illumos",
   594|                       target_os = "openbsd"))]
   595|             SockAddr::Link(..) => AddressFamily::Link,
   596|             #[cfg(any(target_os = "android", target_os = "linux"))]
   597|             SockAddr::Vsock(..) => AddressFamily::Vsock,
   598|         }
   599|     }
   600|     pub fn to_str(&self) -> String {
   601|         format!("{}", self)
   602|     }
   603|     #[cfg(not(target_os = "fuchsia"))]
   604|     pub(crate) unsafe fn from_libc_sockaddr(addr: *const libc::sockaddr) -> Option<SockAddr> {
   605|         if addr.is_null() {
   606|             None
   607|         } else {
   608|             match AddressFamily::from_i32(i32::from((*addr).sa_family)) {
   609|                 Some(AddressFamily::Unix) => None,
   610|                 Some(AddressFamily::Inet) => Some(SockAddr::Inet(
   611|                     InetAddr::V4(*(addr as *const libc::sockaddr_in)))),
   612|                 Some(AddressFamily::Inet6) => Some(SockAddr::Inet(
   613|                     InetAddr::V6(*(addr as *const libc::sockaddr_in6)))),
   614|                 #[cfg(any(target_os = "android", target_os = "linux"))]
   615|                 Some(AddressFamily::Netlink) => Some(SockAddr::Netlink(
   616|                     NetlinkAddr(*(addr as *const libc::sockaddr_nl)))),
   617|                 #[cfg(any(target_os = "ios", target_os = "macos"))]
   618|                 Some(AddressFamily::System) => Some(SockAddr::SysControl(
   619|                     SysControlAddr(*(addr as *const libc::sockaddr_ctl)))),
   620|                 #[cfg(any(target_os = "android", target_os = "linux"))]
   621|                 Some(AddressFamily::Packet) => Some(SockAddr::Link(
   622|                     LinkAddr(*(addr as *const libc::sockaddr_ll)))),
   623|                 #[cfg(any(target_os = "dragonfly",
   624|                           target_os = "freebsd",
   625|                           target_os = "ios",
   626|                           target_os = "macos",
   627|                           target_os = "netbsd",
   628|                           target_os = "illumos",
   629|                           target_os = "openbsd"))]
   630|                 Some(AddressFamily::Link) => {
   631|                     let ether_addr = LinkAddr(*(addr as *const libc::sockaddr_dl));
   632|                     if ether_addr.is_empty() {
   633|                         None
   634|                     } else {
   635|                         Some(SockAddr::Link(ether_addr))
   636|                     }
   637|                 },
   638|                 #[cfg(any(target_os = "android", target_os = "linux"))]
   639|                 Some(AddressFamily::Vsock) => Some(SockAddr::Vsock(
   640|                     VsockAddr(*(addr as *const libc::sockaddr_vm)))),
   641|                 Some(_) | None => None,
   642|             }
   643|         }
   644|     }
   645|     pub fn as_ffi_pair(&self) -> (&libc::sockaddr, libc::socklen_t) {
   646|         match *self {
   647|             SockAddr::Inet(InetAddr::V4(ref addr)) => (
   648|                 unsafe {
   649|                     &*(addr as *const libc::sockaddr_in as *const libc::sockaddr)
   650|                 },
   651|                 mem::size_of_val(addr) as libc::socklen_t
   652|             ),
   653|             SockAddr::Inet(InetAddr::V6(ref addr)) => (
   654|                 unsafe {
   655|                     &*(addr as *const libc::sockaddr_in6 as *const libc::sockaddr)
   656|                 },
   657|                 mem::size_of_val(addr) as libc::socklen_t
   658|             ),
   659|             SockAddr::Unix(UnixAddr(ref addr, len)) => (
   660|                 unsafe {
   661|                     &*(addr as *const libc::sockaddr_un as *const libc::sockaddr)
   662|                 },
   663|                 (len + offset_of!(libc::sockaddr_un, sun_path)) as libc::socklen_t
   664|             ),
   665|             #[cfg(any(target_os = "android", target_os = "linux"))]
   666|             SockAddr::Netlink(NetlinkAddr(ref sa)) => (
   667|                 unsafe {
   668|                     &*(sa as *const libc::sockaddr_nl as *const libc::sockaddr)
   669|                 },
   670|                 mem::size_of_val(sa) as libc::socklen_t
   671|             ),
   672|             #[cfg(any(target_os = "android", target_os = "linux"))]
   673|             SockAddr::Alg(AlgAddr(ref sa)) => (
   674|                 unsafe {
   675|                     &*(sa as *const libc::sockaddr_alg as *const libc::sockaddr)
   676|                 },
   677|                 mem::size_of_val(sa) as libc::socklen_t
   678|             ),
   679|             #[cfg(any(target_os = "ios", target_os = "macos"))]
   680|             SockAddr::SysControl(SysControlAddr(ref sa)) => (
   681|                 unsafe {
   682|                     &*(sa as *const libc::sockaddr_ctl as *const libc::sockaddr)
   683|                 },
   684|                 mem::size_of_val(sa) as libc::socklen_t
   685|             ),
   686|             #[cfg(any(target_os = "android", target_os = "linux"))]
   687|             SockAddr::Link(LinkAddr(ref addr)) => (
   688|                 unsafe {
   689|                     &*(addr as *const libc::sockaddr_ll as *const libc::sockaddr)
   690|                 },
   691|                 mem::size_of_val(addr) as libc::socklen_t
   692|             ),
   693|             #[cfg(any(target_os = "dragonfly",
   694|                       target_os = "freebsd",
   695|                       target_os = "ios",
   696|                       target_os = "macos",
   697|                       target_os = "illumos",
   698|                       target_os = "netbsd",
   699|                       target_os = "openbsd"))]
   700|             SockAddr::Link(LinkAddr(ref addr)) => (
   701|                 unsafe {
   702|                     &*(addr as *const libc::sockaddr_dl as *const libc::sockaddr)
   703|                 },
   704|                 mem::size_of_val(addr) as libc::socklen_t
   705|             ),
   706|             #[cfg(any(target_os = "android", target_os = "linux"))]
   707|             SockAddr::Vsock(VsockAddr(ref sa)) => (
   708|                 unsafe {
   709|                     &*(sa as *const libc::sockaddr_vm as *const libc::sockaddr)
   710|                 },
   711|                 mem::size_of_val(sa) as libc::socklen_t
   712|             ),
   713|         }
   714|     }
   715| }
   716| impl fmt::Display for SockAddr {
   717|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   718|         match *self {
   719|             SockAddr::Inet(ref inet) => inet.fmt(f),
   720|             SockAddr::Unix(ref unix) => unix.fmt(f),
   721|             #[cfg(any(target_os = "android", target_os = "linux"))]
   722|             SockAddr::Netlink(ref nl) => nl.fmt(f),
   723|             #[cfg(any(target_os = "android", target_os = "linux"))]
   724|             SockAddr::Alg(ref nl) => nl.fmt(f),
   725|             #[cfg(any(target_os = "ios", target_os = "macos"))]
   726|             SockAddr::SysControl(ref sc) => sc.fmt(f),
   727|             #[cfg(any(target_os = "android",
   728|                       target_os = "dragonfly",
   729|                       target_os = "freebsd",
   730|                       target_os = "ios",
   731|                       target_os = "linux",
   732|                       target_os = "macos",
   733|                       target_os = "netbsd",
   734|                       target_os = "illumos",
   735|                       target_os = "openbsd"))]
   736|             SockAddr::Link(ref ether_addr) => ether_addr.fmt(f),
   737|             #[cfg(any(target_os = "android", target_os = "linux"))]
   738|             SockAddr::Vsock(ref svm) => svm.fmt(f),
   739|         }
   740|     }
   741| }
   742| #[cfg(any(target_os = "android", target_os = "linux"))]
   743| pub mod netlink {
   744|     use crate::sys::socket::addr::AddressFamily;
   745|     use libc::{sa_family_t, sockaddr_nl};
   746|     use std::{fmt, mem};
   747|     #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
   748|     pub struct NetlinkAddr(pub sockaddr_nl);
   749|     impl NetlinkAddr {
   750|         pub fn new(pid: u32, groups: u32) -> NetlinkAddr {
   751|             let mut addr: sockaddr_nl = unsafe { mem::zeroed() };
   752|             addr.nl_family = AddressFamily::Netlink as sa_family_t;
   753|             addr.nl_pid = pid;
   754|             addr.nl_groups = groups;
   755|             NetlinkAddr(addr)
   756|         }
   757|         pub fn pid(&self) -> u32 {
   758|             self.0.nl_pid
   759|         }
   760|         pub fn groups(&self) -> u32 {
   761|             self.0.nl_groups
   762|         }
   763|     }
   764|     impl fmt::Display for NetlinkAddr {
   765|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   766|             write!(f, "pid: {} groups: {}", self.pid(), self.groups())
   767|         }
   768|     }
   769| }
   770| #[cfg(any(target_os = "android", target_os = "linux"))]
   771| pub mod alg {
   772|     use libc::{AF_ALG, sockaddr_alg, c_char};
   773|     use std::{fmt, mem, str};
   774|     use std::hash::{Hash, Hasher};
   775|     use std::ffi::CStr;
   776|     #[derive(Copy, Clone)]
   777|     pub struct AlgAddr(pub sockaddr_alg);
   778|     impl PartialEq for AlgAddr {
   779|         fn eq(&self, other: &Self) -> bool {
   780|             let (inner, other) = (self.0, other.0);
   781|             (inner.salg_family, &inner.salg_type[..], inner.salg_feat, inner.salg_mask, &inner.salg_name[..]) ==
   782|             (other.salg_family, &other.salg_type[..], other.salg_feat, other.salg_mask, &other.salg_name[..])
   783|         }
   784|     }
   785|     impl Eq for AlgAddr {}
   786|     impl Hash for AlgAddr {
   787|         fn hash<H: Hasher>(&self, s: &mut H) {
   788|             let inner = self.0;
   789|             (inner.salg_family, &inner.salg_type[..], inner.salg_feat, inner.salg_mask, &inner.salg_name[..]).hash(s);
   790|         }
   791|     }
   792|     impl AlgAddr {
   793|         pub fn new(alg_type: &str, alg_name: &str) -> AlgAddr {
   794|             let mut addr: sockaddr_alg = unsafe { mem::zeroed() };
   795|             addr.salg_family = AF_ALG as u16;
   796|             addr.salg_type[..alg_type.len()].copy_from_slice(alg_type.to_string().as_bytes());
   797|             addr.salg_name[..alg_name.len()].copy_from_slice(alg_name.to_string().as_bytes());
   798|             AlgAddr(addr)
   799|         }
   800|         pub fn alg_type(&self) -> &CStr {
   801|             unsafe { CStr::from_ptr(self.0.salg_type.as_ptr() as *const c_char) }
   802|         }
   803|         pub fn alg_name(&self) -> &CStr {
   804|             unsafe { CStr::from_ptr(self.0.salg_name.as_ptr() as *const c_char) }
   805|         }
   806|     }
   807|     impl fmt::Display for AlgAddr {
   808|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   809|             write!(f, "type: {} alg: {}",
   810|                    self.alg_name().to_string_lossy(),
   811|                    self.alg_type().to_string_lossy())
   812|         }
   813|     }
   814|     impl fmt::Debug for AlgAddr {
   815|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   816|             fmt::Display::fmt(self, f)
   817|         }
   818|     }
   819| }
   820| #[cfg(any(target_os = "ios", target_os = "macos"))]
   821| pub mod sys_control {
   822|     use crate::sys::socket::addr::AddressFamily;
   823|     use libc::{self, c_uchar};
   824|     use std::{fmt, mem};
   825|     use std::os::unix::io::RawFd;
   826|     use crate::{Errno, Error, Result};
   827|     #[repr(C)]
   828|     #[derive(Clone, Copy)]
   829|     #[allow(missing_debug_implementations)]
   830|     pub struct ctl_ioc_info {
   831|         pub ctl_id: u32,
   832|         pub ctl_name: [c_uchar; MAX_KCTL_NAME],
   833|     }
   834|     const CTL_IOC_MAGIC: u8 = 'N' as u8;
   835|     const CTL_IOC_INFO: u8 = 3;
   836|     const MAX_KCTL_NAME: usize = 96;
   837|     ioctl_readwrite!(ctl_info, CTL_IOC_MAGIC, CTL_IOC_INFO, ctl_ioc_info);
   838|     #[repr(C)]
   839|     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   840|     pub struct SysControlAddr(pub libc::sockaddr_ctl);
   841|     impl SysControlAddr {
   842|         pub fn new(id: u32, unit: u32) -> SysControlAddr {
   843|             let addr = libc::sockaddr_ctl {
   844|                 sc_len: mem::size_of::<libc::sockaddr_ctl>() as c_uchar,
   845|                 sc_family: AddressFamily::System as c_uchar,
   846|                 ss_sysaddr: libc::AF_SYS_CONTROL as u16,
   847|                 sc_id: id,
   848|                 sc_unit: unit,
   849|                 sc_reserved: [0; 5]
   850|             };
   851|             SysControlAddr(addr)
   852|         }
   853|         pub fn from_name(sockfd: RawFd, name: &str, unit: u32) -> Result<SysControlAddr> {
   854|             if name.len() > MAX_KCTL_NAME {
   855|                 return Err(Error::from(Errno::ENAMETOOLONG));
   856|             }
   857|             let mut ctl_name = [0; MAX_KCTL_NAME];
   858|             ctl_name[..name.len()].clone_from_slice(name.as_bytes());
   859|             let mut info = ctl_ioc_info { ctl_id: 0, ctl_name };
   860|             unsafe { ctl_info(sockfd, &mut info)?; }
   861|             Ok(SysControlAddr::new(info.ctl_id, unit))
   862|         }
   863|         pub fn id(&self) -> u32 {
   864|             self.0.sc_id
   865|         }
   866|         pub fn unit(&self) -> u32 {
   867|             self.0.sc_unit
   868|         }
   869|     }
   870|     impl fmt::Display for SysControlAddr {
   871|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   872|             fmt::Debug::fmt(self, f)
   873|         }
   874|     }
   875| }
   876| #[cfg(any(target_os = "android", target_os = "linux", target_os = "fuchsia"))]
   877| mod datalink {
   878|     use super::{fmt, AddressFamily};
   879|     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   880|     pub struct LinkAddr(pub libc::sockaddr_ll);
   881|     impl LinkAddr {
   882|         pub fn family(&self) -> AddressFamily {
   883|             assert_eq!(self.0.sll_family as i32, libc::AF_PACKET);
   884|             AddressFamily::Packet
   885|         }
   886|         pub fn protocol(&self) -> u16 {
   887|             self.0.sll_protocol
   888|         }
   889|         pub fn ifindex(&self) -> usize {
   890|             self.0.sll_ifindex as usize
   891|         }
   892|         pub fn hatype(&self) -> u16 {
   893|             self.0.sll_hatype
   894|         }
   895|         pub fn pkttype(&self) -> u8 {
   896|             self.0.sll_pkttype
   897|         }
   898|         pub fn halen(&self) -> usize {
   899|             self.0.sll_halen as usize
   900|         }
   901|         pub fn addr(&self) -> [u8; 6] {
   902|             [
   903|                 self.0.sll_addr[0] as u8,
   904|                 self.0.sll_addr[1] as u8,
   905|                 self.0.sll_addr[2] as u8,
   906|                 self.0.sll_addr[3] as u8,
   907|                 self.0.sll_addr[4] as u8,
   908|                 self.0.sll_addr[5] as u8,
   909|             ]
   910|         }
   911|     }
   912|     impl fmt::Display for LinkAddr {
   913|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   914|             let addr = self.addr();
   915|             write!(f, "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
   916|                 addr[0],
   917|                 addr[1],
   918|                 addr[2],
   919|                 addr[3],
   920|                 addr[4],
   921|                 addr[5])
   922|         }
   923|     }
   924| }
   925| #[cfg(any(target_os = "dragonfly",
   926|           target_os = "freebsd",
   927|           target_os = "ios",
   928|           target_os = "macos",
   929|           target_os = "illumos",
   930|           target_os = "netbsd",
   931|           target_os = "openbsd"))]
   932| mod datalink {
   933|     use super::{fmt, AddressFamily};
   934|     #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   935|     pub struct LinkAddr(pub libc::sockaddr_dl);
   936|     impl LinkAddr {
   937|         #[cfg(not(target_os = "illumos"))]
   938|         pub fn len(&self) -> usize {
   939|             self.0.sdl_len as usize
   940|         }
   941|         pub fn family(&self) -> AddressFamily {
   942|             assert_eq!(i32::from(self.0.sdl_family), libc::AF_LINK);
   943|             AddressFamily::Link
   944|         }
   945|         pub fn ifindex(&self) -> usize {
   946|             self.0.sdl_index as usize
   947|         }
   948|         pub fn datalink_type(&self) -> u8 {
   949|             self.0.sdl_type
   950|         }
   951|         pub fn nlen(&self) -> usize {
   952|             self.0.sdl_nlen as usize
   953|         }
   954|         pub fn alen(&self) -> usize {
   955|             self.0.sdl_alen as usize
   956|         }
   957|         pub fn slen(&self) -> usize {
   958|             self.0.sdl_slen as usize
   959|         }
   960|         pub fn is_empty(&self) -> bool {
   961|             let nlen = self.nlen();
   962|             let alen = self.alen();
   963|             let data_len = self.0.sdl_data.len();
   964|             alen == 0 || nlen + alen >= data_len
   965|         }
   966|         pub fn addr(&self) -> [u8; 6] {
   967|             let nlen = self.nlen();
   968|             let data = self.0.sdl_data;
   969|             assert!(!self.is_empty());
   970|             [
   971|                 data[nlen] as u8,
   972|                 data[nlen + 1] as u8,
   973|                 data[nlen + 2] as u8,
   974|                 data[nlen + 3] as u8,
   975|                 data[nlen + 4] as u8,
   976|                 data[nlen + 5] as u8,
   977|             ]
   978|         }
   979|     }
   980|     impl fmt::Display for LinkAddr {
   981|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   982|             let addr = self.addr();
   983|             write!(f, "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
   984|                 addr[0],
   985|                 addr[1],
   986|                 addr[2],
   987|                 addr[3],
   988|                 addr[4],
   989|                 addr[5])
   990|         }
   991|     }
   992| }
   993| #[cfg(any(target_os = "android", target_os = "linux"))]
   994| pub mod vsock {
   995|     use crate::sys::socket::addr::AddressFamily;
   996|     use libc::{sa_family_t, sockaddr_vm};
   997|     use std::{fmt, mem};
   998|     use std::hash::{Hash, Hasher};
   999|     #[derive(Copy, Clone)]
  1000|     pub struct VsockAddr(pub sockaddr_vm);
  1001|     impl PartialEq for VsockAddr {
  1002|         fn eq(&self, other: &Self) -> bool {
  1003|             let (inner, other) = (self.0, other.0);
  1004|             (inner.svm_family, inner.svm_cid, inner.svm_port) ==
  1005|             (other.svm_family, other.svm_cid, other.svm_port)
  1006|         }
  1007|     }
  1008|     impl Eq for VsockAddr {}
  1009|     impl Hash for VsockAddr {
  1010|         fn hash<H: Hasher>(&self, s: &mut H) {
  1011|             let inner = self.0;
  1012|             (inner.svm_family, inner.svm_cid, inner.svm_port).hash(s);
  1013|         }
  1014|     }
  1015|     impl VsockAddr {
  1016|         pub fn new(cid: u32, port: u32) -> VsockAddr {
  1017|             let mut addr: sockaddr_vm = unsafe { mem::zeroed() };
  1018|             addr.svm_family = AddressFamily::Vsock as sa_family_t;
  1019|             addr.svm_cid = cid;
  1020|             addr.svm_port = port;
  1021|             VsockAddr(addr)
  1022|         }
  1023|         pub fn cid(&self) -> u32 {
  1024|             self.0.svm_cid
  1025|         }
  1026|         pub fn port(&self) -> u32 {
  1027|             self.0.svm_port
  1028|         }
  1029|     }
  1030|     impl fmt::Display for VsockAddr {
  1031|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  1032|             write!(f, "cid: {} port: {}", self.cid(), self.port())
  1033|         }
  1034|     }
  1035|     impl fmt::Debug for VsockAddr {
  1036|         fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
  1037|             fmt::Display::fmt(self, f)
  1038|         }
  1039|     }
  1040| }
  1041| #[cfg(test)]
  1042| mod tests {
  1043|     #[cfg(any(target_os = "android",
  1044|               target_os = "dragonfly",
  1045|               target_os = "freebsd",
  1046|               target_os = "ios",
  1047|               target_os = "linux",
  1048|               target_os = "macos",
  1049|               target_os = "netbsd",
  1050|               target_os = "illumos",
  1051|               target_os = "openbsd"))]
  1052|     use super::*;
  1053|     #[cfg(any(target_os = "dragonfly",
  1054|               target_os = "freebsd",
  1055|               target_os = "ios",
  1056|               target_os = "macos",
  1057|               target_os = "netbsd",
  1058|               target_os = "openbsd"))]
  1059|     #[test]
  1060|     fn test_macos_loopback_datalink_addr() {
  1061|         let bytes = [20i8, 18, 1, 0, 24, 3, 0, 0, 108, 111, 48, 0, 0, 0, 0, 0];
  1062|         let sa = bytes.as_ptr() as *const libc::sockaddr;
  1063|         let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
  1064|         assert!(_sock_addr.is_none());
  1065|     }
  1066|     #[cfg(any(target_os = "dragonfly",
  1067|               target_os = "freebsd",
  1068|               target_os = "ios",
  1069|               target_os = "macos",
  1070|               target_os = "netbsd",
  1071|               target_os = "openbsd"))]
  1072|     #[test]
  1073|     fn test_macos_tap_datalink_addr() {
  1074|         let bytes = [20i8, 18, 7, 0, 6, 3, 6, 0, 101, 110, 48, 24, 101, -112, -35, 76, -80];
  1075|         let ptr = bytes.as_ptr();
  1076|         let sa = ptr as *const libc::sockaddr;
  1077|         let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
  1078|         assert!(_sock_addr.is_some());
  1079|         let sock_addr = _sock_addr.unwrap();
  1080|         assert_eq!(sock_addr.family(), AddressFamily::Link);
  1081|         match sock_addr {
  1082|             SockAddr::Link(ether_addr) => {
  1083|                 assert_eq!(ether_addr.addr(), [24u8, 101, 144, 221, 76, 176]);
  1084|             },
  1085|             _ => { unreachable!() }
  1086|         };
  1087|     }
  1088|     #[cfg(target_os = "illumos")]
  1089|     #[test]
  1090|     fn test_illumos_tap_datalink_addr() {
  1091|         let bytes = [25u8, 0, 0, 0, 6, 0, 6, 0, 24, 101, 144, 221, 76, 176];
  1092|         let ptr = bytes.as_ptr();
  1093|         let sa = ptr as *const libc::sockaddr;
  1094|         let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
  1095|         assert!(_sock_addr.is_some());
  1096|         let sock_addr = _sock_addr.unwrap();
  1097|         assert_eq!(sock_addr.family(), AddressFamily::Link);
  1098|         match sock_addr {
  1099|             SockAddr::Link(ether_addr) => {
  1100|                 assert_eq!(ether_addr.addr(), [24u8, 101, 144, 221, 76, 176]);
  1101|             },
  1102|             _ => { unreachable!() }
  1103|         };
  1104|     }
  1105|     #[cfg(any(target_os = "android", target_os = "linux"))]
  1106|     #[test]
  1107|     fn test_abstract_sun_path() {
  1108|         let name = String::from("nix\0abstract\0test");
  1109|         let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();
  1110|         let sun_path1 = addr.sun_path();
  1111|         let sun_path2 = [0u8, 110, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116];
  1112|         assert_eq!(sun_path1.len(), sun_path2.len());
  1113|         for i in 0..sun_path1.len() {
  1114|             assert_eq!(sun_path1[i], sun_path2[i]);
  1115|         }
  1116|     }
  1117| }


# ====================================================================
# FILE: src/sys/socket/mod.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1169 ---
     1| use cfg_if::cfg_if;
     2| use crate::{Error, Result, errno::Errno};
     3| use libc::{self, c_void, c_int, iovec, socklen_t, size_t,
     4|         CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_LEN};
     5| use memoffset::offset_of;
     6| use std::{mem, ptr, slice};
     7| use std::os::unix::io::RawFd;
     8| #[cfg(all(target_os = "linux"))]
     9| use crate::sys::time::TimeSpec;
    10| use crate::sys::time::TimeVal;
    11| use crate::sys::uio::IoVec;
    12| mod addr;
    13| pub mod sockopt;
    14| /*
    15|  *
    16|  * ===== Re-exports =====
    17|  *
    18|  */
    19| #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
    20| pub use self::addr::{
    21|     AddressFamily,
    22|     SockAddr,
    23|     InetAddr,
    24|     UnixAddr,
    25|     IpAddr,
    26|     Ipv4Addr,
    27|     Ipv6Addr,
    28|     LinkAddr,
    29| };
    30| #[cfg(any(target_os = "illumos", target_os = "solaris"))]
    31| pub use self::addr::{
    32|     AddressFamily,
    33|     SockAddr,
    34|     InetAddr,
    35|     UnixAddr,
    36|     IpAddr,
    37|     Ipv4Addr,
    38|     Ipv6Addr,
    39| };
    40| #[cfg(any(target_os = "android", target_os = "linux"))]
    41| pub use crate::sys::socket::addr::netlink::NetlinkAddr;
    42| #[cfg(any(target_os = "android", target_os = "linux"))]
    43| pub use crate::sys::socket::addr::alg::AlgAddr;
    44| #[cfg(any(target_os = "android", target_os = "linux"))]
    45| pub use crate::sys::socket::addr::vsock::VsockAddr;
    46| pub use libc::{
    47|     cmsghdr,
    48|     msghdr,
    49|     sa_family_t,
    50|     sockaddr,
    51|     sockaddr_in,
    52|     sockaddr_in6,
    53|     sockaddr_storage,
    54|     sockaddr_un,
    55| };
    56| #[doc(hidden)]
    57| pub use libc::{c_uint, CMSG_SPACE};
    58| #[derive(Clone, Copy, PartialEq, Eq, Debug)]
    59| #[repr(i32)]
    60| pub enum SockType {
    61|     Stream = libc::SOCK_STREAM,
    62|     Datagram = libc::SOCK_DGRAM,
    63|     SeqPacket = libc::SOCK_SEQPACKET,
    64|     Raw = libc::SOCK_RAW,
    65|     Rdm = libc::SOCK_RDM,
    66| }
    67| #[repr(i32)]
    68| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    69| pub enum SockProtocol {
    70|     Tcp = libc::IPPROTO_TCP,
    71|     Udp = libc::IPPROTO_UDP,
    72|     #[cfg(any(target_os = "ios", target_os = "macos"))]
    73|     KextEvent = libc::SYSPROTO_EVENT,
    74|     #[cfg(any(target_os = "ios", target_os = "macos"))]
    75|     KextControl = libc::SYSPROTO_CONTROL,
    76|     #[cfg(any(target_os = "android", target_os = "linux"))]
    77|     NetlinkRoute = libc::NETLINK_ROUTE,
    78|     #[cfg(any(target_os = "android", target_os = "linux"))]
    79|     NetlinkUserSock = libc::NETLINK_USERSOCK,
    80|     #[cfg(any(target_os = "android", target_os = "linux"))]
    81|     NetlinkSockDiag = libc::NETLINK_SOCK_DIAG,
    82|     #[cfg(any(target_os = "android", target_os = "linux"))]
    83|     NetlinkSELinux = libc::NETLINK_SELINUX,
    84|     #[cfg(any(target_os = "android", target_os = "linux"))]
    85|     NetlinkISCSI = libc::NETLINK_ISCSI,
    86|     #[cfg(any(target_os = "android", target_os = "linux"))]
    87|     NetlinkAudit = libc::NETLINK_AUDIT,
    88|     #[cfg(any(target_os = "android", target_os = "linux"))]
    89|     NetlinkFIBLookup = libc::NETLINK_FIB_LOOKUP,
    90|     #[cfg(any(target_os = "android", target_os = "linux"))]
    91|     NetlinkNetFilter = libc::NETLINK_NETFILTER,
    92|     #[cfg(any(target_os = "android", target_os = "linux"))]
    93|     NetlinkSCSITransport = libc::NETLINK_SCSITRANSPORT,
    94|     #[cfg(any(target_os = "android", target_os = "linux"))]
    95|     NetlinkRDMA = libc::NETLINK_RDMA,
    96|     #[cfg(any(target_os = "android", target_os = "linux"))]
    97|     NetlinkIPv6Firewall = libc::NETLINK_IP6_FW,
    98|     #[cfg(any(target_os = "android", target_os = "linux"))]
    99|     NetlinkDECNetRoutingMessage = libc::NETLINK_DNRTMSG,
   100|     #[cfg(any(target_os = "android", target_os = "linux"))]
   101|     NetlinkKObjectUEvent = libc::NETLINK_KOBJECT_UEVENT,
   102|     #[cfg(any(target_os = "android", target_os = "linux"))]
   103|     NetlinkCrypto = libc::NETLINK_CRYPTO,
   104| }
   105| libc_bitflags!{
   106|     pub struct SockFlag: c_int {
   107|         #[cfg(any(target_os = "android",
   108|                   target_os = "dragonfly",
   109|                   target_os = "freebsd",
   110|                   target_os = "illumos",
   111|                   target_os = "linux",
   112|                   target_os = "netbsd",
   113|                   target_os = "openbsd"))]
   114|         SOCK_NONBLOCK;
   115|         #[cfg(any(target_os = "android",
   116|                   target_os = "dragonfly",
   117|                   target_os = "freebsd",
   118|                   target_os = "illumos",
   119|                   target_os = "linux",
   120|                   target_os = "netbsd",
   121|                   target_os = "openbsd"))]
   122|         SOCK_CLOEXEC;
   123|         #[cfg(target_os = "netbsd")]
   124|         SOCK_NOSIGPIPE;
   125|         #[cfg(target_os = "openbsd")]
   126|         SOCK_DNS;
   127|     }
   128| }
   129| libc_bitflags!{
   130|     pub struct MsgFlags: c_int {
   131|         MSG_OOB;
   132|         MSG_PEEK;
   133|         MSG_WAITALL;
   134|         MSG_DONTWAIT;
   135|         MSG_CTRUNC;
   136|         MSG_TRUNC;
   137|         MSG_EOR;
   138|         #[cfg(any(target_os = "android", target_os = "linux"))]
   139|         MSG_ERRQUEUE;
   140|         #[cfg(any(target_os = "android",
   141|                   target_os = "dragonfly",
   142|                   target_os = "freebsd",
   143|                   target_os = "linux",
   144|                   target_os = "netbsd",
   145|                   target_os = "openbsd"))]
   146|         MSG_CMSG_CLOEXEC;
   147|     }
   148| }
   149| cfg_if! {
   150|     if #[cfg(any(target_os = "android", target_os = "linux"))] {
   151|         #[repr(transparent)]
   152|         #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   153|         pub struct UnixCredentials(libc::ucred);
   154|         impl UnixCredentials {
   155|             pub fn new() -> Self {
   156|                 UnixCredentials(libc::ucred {
   157|                     pid: crate::unistd::getpid().as_raw(),
   158|                     uid: crate::unistd::getuid().as_raw(),
   159|                     gid: crate::unistd::getgid().as_raw(),
   160|                 })
   161|             }
   162|             pub fn pid(&self) -> libc::pid_t {
   163|                 self.0.pid
   164|             }
   165|             pub fn uid(&self) -> libc::uid_t {
   166|                 self.0.uid
   167|             }
   168|             pub fn gid(&self) -> libc::gid_t {
   169|                 self.0.gid
   170|             }
   171|         }
   172|         impl Default for UnixCredentials {
   173|             fn default() -> Self {
   174|                 Self::new()
   175|             }
   176|         }
   177|         impl From<libc::ucred> for UnixCredentials {
   178|             fn from(cred: libc::ucred) -> Self {
   179|                 UnixCredentials(cred)
   180|             }
   181|         }
   182|         impl Into<libc::ucred> for UnixCredentials {
   183|             fn into(self) -> libc::ucred {
   184|                 self.0
   185|             }
   186|         }
   187|     } else if #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))] {
   188|         #[repr(transparent)]
   189|         #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   190|         pub struct UnixCredentials(libc::cmsgcred);
   191|         impl UnixCredentials {
   192|             pub fn pid(&self) -> libc::pid_t {
   193|                 self.0.cmcred_pid
   194|             }
   195|             pub fn uid(&self) -> libc::uid_t {
   196|                 self.0.cmcred_uid
   197|             }
   198|             pub fn euid(&self) -> libc::uid_t {
   199|                 self.0.cmcred_euid
   200|             }
   201|             pub fn gid(&self) -> libc::gid_t {
   202|                 self.0.cmcred_gid
   203|             }
   204|             pub fn groups(&self) -> &[libc::gid_t] {
   205|                 unsafe { slice::from_raw_parts(self.0.cmcred_groups.as_ptr() as *const libc::gid_t, self.0.cmcred_ngroups as _) }
   206|             }
   207|         }
   208|         impl From<libc::cmsgcred> for UnixCredentials {
   209|             fn from(cred: libc::cmsgcred) -> Self {
   210|                 UnixCredentials(cred)
   211|             }
   212|         }
   213|     }
   214| }
   215| #[repr(transparent)]
   216| #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   217| pub struct IpMembershipRequest(libc::ip_mreq);
   218| impl IpMembershipRequest {
   219|     pub fn new(group: Ipv4Addr, interface: Option<Ipv4Addr>) -> Self {
   220|         IpMembershipRequest(libc::ip_mreq {
   221|             imr_multiaddr: group.0,
   222|             imr_interface: interface.unwrap_or_else(Ipv4Addr::any).0,
   223|         })
   224|     }
   225| }
   226| #[repr(transparent)]
   227| #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   228| pub struct Ipv6MembershipRequest(libc::ipv6_mreq);
   229| impl Ipv6MembershipRequest {
   230|     pub fn new(group: Ipv6Addr) -> Self {
   231|         Ipv6MembershipRequest(libc::ipv6_mreq {
   232|             ipv6mr_multiaddr: group.0,
   233|             ipv6mr_interface: 0,
   234|         })
   235|     }
   236| }
   237| #[macro_export]
   238| macro_rules! cmsg_space {
   239|     ( $( $x:ty ),* ) => {
   240|         {
   241|             let mut space = 0;
   242|             $(
   243|                 space += unsafe {
   244|                     $crate::sys::socket::CMSG_SPACE(::std::mem::size_of::<$x>() as $crate::sys::socket::c_uint)
   245|                 } as usize;
   246|             )*
   247|             Vec::<u8>::with_capacity(space)
   248|         }
   249|     }
   250| }
   251| #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   252| pub struct RecvMsg<'a> {
   253|     pub bytes: usize,
   254|     cmsghdr: Option<&'a cmsghdr>,
   255|     pub address: Option<SockAddr>,
   256|     pub flags: MsgFlags,
   257|     mhdr: msghdr,
   258| }
   259| impl<'a> RecvMsg<'a> {
   260|     pub fn cmsgs(&self) -> CmsgIterator {
   261|         CmsgIterator {
   262|             cmsghdr: self.cmsghdr,
   263|             mhdr: &self.mhdr
   264|         }
   265|     }
   266| }
   267| #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   268| pub struct CmsgIterator<'a> {
   269|     cmsghdr: Option<&'a cmsghdr>,
   270|     mhdr: &'a msghdr
   271| }
   272| impl<'a> Iterator for CmsgIterator<'a> {
   273|     type Item = ControlMessageOwned;
   274|     fn next(&mut self) -> Option<ControlMessageOwned> {
   275|         match self.cmsghdr {
   276|             None => None,   // No more messages
   277|             Some(hdr) => {
   278|                 let cm = unsafe { Some(ControlMessageOwned::decode_from(hdr))};
   279|                 self.cmsghdr = unsafe {
   280|                     let p = CMSG_NXTHDR(self.mhdr as *const _, hdr as *const _);
   281|                     p.as_ref()
   282|                 };
   283|                 cm
   284|             }
   285|         }
   286|     }
   287| }
   288| #[derive(Clone, Debug, Eq, PartialEq)]
   289| pub enum ControlMessageOwned {
   290|     ScmRights(Vec<RawFd>),
   291|     #[cfg(any(target_os = "android", target_os = "linux"))]
   292|     ScmCredentials(UnixCredentials),
   293|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   294|     ScmCreds(UnixCredentials),
   295|     ScmTimestamp(TimeVal),
   296|     #[cfg(all(target_os = "linux"))]
   297|     ScmTimestampns(TimeSpec),
   298|     #[cfg(any(
   299|         target_os = "android",
   300|         target_os = "ios",
   301|         target_os = "linux",
   302|         target_os = "macos",
   303|         target_os = "netbsd",
   304|     ))]
   305|     Ipv4PacketInfo(libc::in_pktinfo),
   306|     #[cfg(any(
   307|         target_os = "android",
   308|         target_os = "dragonfly",
   309|         target_os = "freebsd",
   310|         target_os = "ios",
   311|         target_os = "linux",
   312|         target_os = "macos",
   313|         target_os = "openbsd",
   314|         target_os = "netbsd",
   315|     ))]
   316|     Ipv6PacketInfo(libc::in6_pktinfo),
   317|     #[cfg(any(
   318|         target_os = "freebsd",
   319|         target_os = "ios",
   320|         target_os = "macos",
   321|         target_os = "netbsd",
   322|         target_os = "openbsd",
   323|     ))]
   324|     Ipv4RecvIf(libc::sockaddr_dl),
   325|     #[cfg(any(
   326|         target_os = "freebsd",
   327|         target_os = "ios",
   328|         target_os = "macos",
   329|         target_os = "netbsd",
   330|         target_os = "openbsd",
   331|     ))]
   332|     Ipv4RecvDstAddr(libc::in_addr),
   333|     #[cfg(target_os = "linux")]
   334|     UdpGroSegments(u16),
   335|     #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   336|     RxqOvfl(u32),
   337|     #[doc(hidden)]
   338|     Unknown(UnknownCmsg),
   339| }
   340| impl ControlMessageOwned {
   341|     #[allow(clippy::cast_ptr_alignment)]
   342|     unsafe fn decode_from(header: &cmsghdr) -> ControlMessageOwned
   343|     {
   344|         let p = CMSG_DATA(header);
   345|         let len = header as *const _ as usize + header.cmsg_len as usize
   346|             - p as usize;
   347|         match (header.cmsg_level, header.cmsg_type) {
   348|             (libc::SOL_SOCKET, libc::SCM_RIGHTS) => {
   349|                 let n = len / mem::size_of::<RawFd>();
   350|                 let mut fds = Vec::with_capacity(n);
   351|                 for i in 0..n {
   352|                     let fdp = (p as *const RawFd).add(i);
   353|                     fds.push(ptr::read_unaligned(fdp));
   354|                 }
   355|                 ControlMessageOwned::ScmRights(fds)
   356|             },
   357|             #[cfg(any(target_os = "android", target_os = "linux"))]
   358|             (libc::SOL_SOCKET, libc::SCM_CREDENTIALS) => {
   359|                 let cred: libc::ucred = ptr::read_unaligned(p as *const _);
   360|                 ControlMessageOwned::ScmCredentials(cred.into())
   361|             }
   362|             #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   363|             (libc::SOL_SOCKET, libc::SCM_CREDS) => {
   364|                 let cred: libc::cmsgcred = ptr::read_unaligned(p as *const _);
   365|                 ControlMessageOwned::ScmCreds(cred.into())
   366|             }
   367|             (libc::SOL_SOCKET, libc::SCM_TIMESTAMP) => {
   368|                 let tv: libc::timeval = ptr::read_unaligned(p as *const _);
   369|                 ControlMessageOwned::ScmTimestamp(TimeVal::from(tv))
   370|             },
   371|             #[cfg(all(target_os = "linux"))]
   372|             (libc::SOL_SOCKET, libc::SCM_TIMESTAMPNS) => {
   373|                 let ts: libc::timespec = ptr::read_unaligned(p as *const _);
   374|                 ControlMessageOwned::ScmTimestampns(TimeSpec::from(ts))
   375|             }
   376|             #[cfg(any(
   377|                 target_os = "android",
   378|                 target_os = "freebsd",
   379|                 target_os = "ios",
   380|                 target_os = "linux",
   381|                 target_os = "macos"
   382|             ))]
   383|             (libc::IPPROTO_IPV6, libc::IPV6_PKTINFO) => {
   384|                 let info = ptr::read_unaligned(p as *const libc::in6_pktinfo);
   385|                 ControlMessageOwned::Ipv6PacketInfo(info)
   386|             }
   387|             #[cfg(any(
   388|                 target_os = "android",
   389|                 target_os = "ios",
   390|                 target_os = "linux",
   391|                 target_os = "macos",
   392|                 target_os = "netbsd",
   393|             ))]
   394|             (libc::IPPROTO_IP, libc::IP_PKTINFO) => {
   395|                 let info = ptr::read_unaligned(p as *const libc::in_pktinfo);
   396|                 ControlMessageOwned::Ipv4PacketInfo(info)
   397|             }
   398|             #[cfg(any(
   399|                 target_os = "freebsd",
   400|                 target_os = "ios",
   401|                 target_os = "macos",
   402|                 target_os = "netbsd",
   403|                 target_os = "openbsd",
   404|             ))]
   405|             (libc::IPPROTO_IP, libc::IP_RECVIF) => {
   406|                 let dl = ptr::read_unaligned(p as *const libc::sockaddr_dl);
   407|                 ControlMessageOwned::Ipv4RecvIf(dl)
   408|             },
   409|             #[cfg(any(
   410|                 target_os = "freebsd",
   411|                 target_os = "ios",
   412|                 target_os = "macos",
   413|                 target_os = "netbsd",
   414|                 target_os = "openbsd",
   415|             ))]
   416|             (libc::IPPROTO_IP, libc::IP_RECVDSTADDR) => {
   417|                 let dl = ptr::read_unaligned(p as *const libc::in_addr);
   418|                 ControlMessageOwned::Ipv4RecvDstAddr(dl)
   419|             },
   420|             #[cfg(target_os = "linux")]
   421|             (libc::SOL_UDP, libc::UDP_GRO) => {
   422|                 let gso_size: u16 = ptr::read_unaligned(p as *const _);
   423|                 ControlMessageOwned::UdpGroSegments(gso_size)
   424|             },
   425|             #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   426|             (libc::SOL_SOCKET, libc::SO_RXQ_OVFL) => {
   427|                 let drop_counter = ptr::read_unaligned(p as *const u32);
   428|                 ControlMessageOwned::RxqOvfl(drop_counter)
   429|             },
   430|             (_, _) => {
   431|                 let sl = slice::from_raw_parts(p, len);
   432|                 let ucmsg = UnknownCmsg(*header, Vec::<u8>::from(sl));
   433|                 ControlMessageOwned::Unknown(ucmsg)
   434|             }
   435|         }
   436|     }
   437| }
   438| #[derive(Clone, Copy, Debug, Eq, PartialEq)]
   439| pub enum ControlMessage<'a> {
   440|     ScmRights(&'a [RawFd]),
   441|     #[cfg(any(target_os = "android", target_os = "linux"))]
   442|     ScmCredentials(&'a UnixCredentials),
   443|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   444|     ScmCreds,
   445|     #[cfg(any(
   446|         target_os = "android",
   447|         target_os = "linux",
   448|     ))]
   449|     AlgSetIv(&'a [u8]),
   450|     #[cfg(any(
   451|         target_os = "android",
   452|         target_os = "linux",
   453|     ))]
   454|     AlgSetOp(&'a libc::c_int),
   455|     #[cfg(any(
   456|         target_os = "android",
   457|         target_os = "linux",
   458|     ))]
   459|     AlgSetAeadAssoclen(&'a u32),
   460|     #[cfg(target_os = "linux")]
   461|     UdpGsoSegments(&'a u16),
   462|     #[cfg(any(target_os = "linux",
   463|               target_os = "macos",
   464|               target_os = "netbsd",
   465|               target_os = "android",
   466|               target_os = "ios",))]
   467|     Ipv4PacketInfo(&'a libc::in_pktinfo),
   468|     #[cfg(any(target_os = "linux",
   469|               target_os = "macos",
   470|               target_os = "netbsd",
   471|               target_os = "freebsd",
   472|               target_os = "android",
   473|               target_os = "ios",))]
   474|     Ipv6PacketInfo(&'a libc::in6_pktinfo),
   475|     #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   476|     RxqOvfl(&'a u32),
   477| }
   478| #[doc(hidden)]
   479| #[derive(Clone, Debug, Eq, PartialEq)]
   480| pub struct UnknownCmsg(cmsghdr, Vec<u8>);
   481| impl<'a> ControlMessage<'a> {
   482|     fn space(&self) -> usize {
   483|         unsafe{CMSG_SPACE(self.len() as libc::c_uint) as usize}
   484|     }
   485|     #[cfg(any(target_os = "android",
   486|               all(target_os = "linux", not(target_env = "musl"))))]
   487|     fn cmsg_len(&self) -> usize {
   488|         unsafe{CMSG_LEN(self.len() as libc::c_uint) as usize}
   489|     }
   490|     #[cfg(not(any(target_os = "android",
   491|                   all(target_os = "linux", not(target_env = "musl")))))]
   492|     fn cmsg_len(&self) -> libc::c_uint {
   493|         unsafe{CMSG_LEN(self.len() as libc::c_uint)}
   494|     }
   495|     fn copy_to_cmsg_data(&self, cmsg_data: *mut u8) {
   496|         let data_ptr = match *self {
   497|             ControlMessage::ScmRights(fds) => {
   498|                 fds as *const _ as *const u8
   499|             },
   500|             #[cfg(any(target_os = "android", target_os = "linux"))]
   501|             ControlMessage::ScmCredentials(creds) => {
   502|                 &creds.0 as *const libc::ucred as *const u8
   503|             }
   504|             #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   505|             ControlMessage::ScmCreds => {
   506|                 unsafe { ptr::write_bytes(cmsg_data, 0, self.len()) };
   507|                 return
   508|             }
   509|             #[cfg(any(target_os = "android", target_os = "linux"))]
   510|             ControlMessage::AlgSetIv(iv) => {
   511|                 #[allow(deprecated)] // https://github.com/rust-lang/libc/issues/1501
   512|                 let af_alg_iv = libc::af_alg_iv {
   513|                     ivlen: iv.len() as u32,
   514|                     iv: [0u8; 0],
   515|                 };
   516|                 let size = mem::size_of_val(&af_alg_iv);
   517|                 unsafe {
   518|                     ptr::copy_nonoverlapping(
   519|                         &af_alg_iv as *const _ as *const u8,
   520|                         cmsg_data,
   521|                         size,
   522|                     );
   523|                     ptr::copy_nonoverlapping(
   524|                         iv.as_ptr(),
   525|                         cmsg_data.add(size),
   526|                         iv.len()
   527|                     );
   528|                 };
   529|                 return
   530|             },
   531|             #[cfg(any(target_os = "android", target_os = "linux"))]
   532|             ControlMessage::AlgSetOp(op) => {
   533|                 op as *const _ as *const u8
   534|             },
   535|             #[cfg(any(target_os = "android", target_os = "linux"))]
   536|             ControlMessage::AlgSetAeadAssoclen(len) => {
   537|                 len as *const _ as *const u8
   538|             },
   539|             #[cfg(target_os = "linux")]
   540|             ControlMessage::UdpGsoSegments(gso_size) => {
   541|                 gso_size as *const _ as *const u8
   542|             },
   543|             #[cfg(any(target_os = "linux", target_os = "macos",
   544|                       target_os = "netbsd", target_os = "android",
   545|                       target_os = "ios",))]
   546|             ControlMessage::Ipv4PacketInfo(info) => info as *const _ as *const u8,
   547|             #[cfg(any(target_os = "linux", target_os = "macos",
   548|                       target_os = "netbsd", target_os = "freebsd",
   549|                       target_os = "android", target_os = "ios",))]
   550|             ControlMessage::Ipv6PacketInfo(info) => info as *const _ as *const u8,
   551|             #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   552|             ControlMessage::RxqOvfl(drop_count) => {
   553|                 drop_count as *const _ as *const u8
   554|             },
   555|         };
   556|         unsafe {
   557|             ptr::copy_nonoverlapping(
   558|                 data_ptr,
   559|                 cmsg_data,
   560|                 self.len()
   561|             )
   562|         };
   563|     }
   564|     fn len(&self) -> usize {
   565|         match *self {
   566|             ControlMessage::ScmRights(fds) => {
   567|                 mem::size_of_val(fds)
   568|             },
   569|             #[cfg(any(target_os = "android", target_os = "linux"))]
   570|             ControlMessage::ScmCredentials(creds) => {
   571|                 mem::size_of_val(creds)
   572|             }
   573|             #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   574|             ControlMessage::ScmCreds => {
   575|                 mem::size_of::<libc::cmsgcred>()
   576|             }
   577|             #[cfg(any(target_os = "android", target_os = "linux"))]
   578|             ControlMessage::AlgSetIv(iv) => {
   579|                 mem::size_of_val(&iv) + iv.len()
   580|             },
   581|             #[cfg(any(target_os = "android", target_os = "linux"))]
   582|             ControlMessage::AlgSetOp(op) => {
   583|                 mem::size_of_val(op)
   584|             },
   585|             #[cfg(any(target_os = "android", target_os = "linux"))]
   586|             ControlMessage::AlgSetAeadAssoclen(len) => {
   587|                 mem::size_of_val(len)
   588|             },
   589|             #[cfg(target_os = "linux")]
   590|             ControlMessage::UdpGsoSegments(gso_size) => {
   591|                 mem::size_of_val(gso_size)
   592|             },
   593|             #[cfg(any(target_os = "linux", target_os = "macos",
   594|               target_os = "netbsd", target_os = "android",
   595|               target_os = "ios",))]
   596|             ControlMessage::Ipv4PacketInfo(info) => mem::size_of_val(info),
   597|             #[cfg(any(target_os = "linux", target_os = "macos",
   598|               target_os = "netbsd", target_os = "freebsd",
   599|               target_os = "android", target_os = "ios",))]
   600|             ControlMessage::Ipv6PacketInfo(info) => mem::size_of_val(info),
   601|             #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   602|             ControlMessage::RxqOvfl(drop_count) => {
   603|                 mem::size_of_val(drop_count)
   604|             },
   605|         }
   606|     }
   607|     fn cmsg_level(&self) -> libc::c_int {
   608|         match *self {
   609|             ControlMessage::ScmRights(_) => libc::SOL_SOCKET,
   610|             #[cfg(any(target_os = "android", target_os = "linux"))]
   611|             ControlMessage::ScmCredentials(_) => libc::SOL_SOCKET,
   612|             #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   613|             ControlMessage::ScmCreds => libc::SOL_SOCKET,
   614|             #[cfg(any(target_os = "android", target_os = "linux"))]
   615|             ControlMessage::AlgSetIv(_) | ControlMessage::AlgSetOp(_) |
   616|                 ControlMessage::AlgSetAeadAssoclen(_) => libc::SOL_ALG,
   617|             #[cfg(target_os = "linux")]
   618|             ControlMessage::UdpGsoSegments(_) => libc::SOL_UDP,
   619|             #[cfg(any(target_os = "linux", target_os = "macos",
   620|                       target_os = "netbsd", target_os = "android",
   621|                       target_os = "ios",))]
   622|             ControlMessage::Ipv4PacketInfo(_) => libc::IPPROTO_IP,
   623|             #[cfg(any(target_os = "linux", target_os = "macos",
   624|               target_os = "netbsd", target_os = "freebsd",
   625|               target_os = "android", target_os = "ios",))]
   626|             ControlMessage::Ipv6PacketInfo(_) => libc::IPPROTO_IPV6,
   627|             #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   628|             ControlMessage::RxqOvfl(_) => libc::SOL_SOCKET,
   629|         }
   630|     }
   631|     fn cmsg_type(&self) -> libc::c_int {
   632|         match *self {
   633|             ControlMessage::ScmRights(_) => libc::SCM_RIGHTS,
   634|             #[cfg(any(target_os = "android", target_os = "linux"))]
   635|             ControlMessage::ScmCredentials(_) => libc::SCM_CREDENTIALS,
   636|             #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   637|             ControlMessage::ScmCreds => libc::SCM_CREDS,
   638|             #[cfg(any(target_os = "android", target_os = "linux"))]
   639|             ControlMessage::AlgSetIv(_) => {
   640|                 libc::ALG_SET_IV
   641|             },
   642|             #[cfg(any(target_os = "android", target_os = "linux"))]
   643|             ControlMessage::AlgSetOp(_) => {
   644|                 libc::ALG_SET_OP
   645|             },
   646|             #[cfg(any(target_os = "android", target_os = "linux"))]
   647|             ControlMessage::AlgSetAeadAssoclen(_) => {
   648|                 libc::ALG_SET_AEAD_ASSOCLEN
   649|             },
   650|             #[cfg(target_os = "linux")]
   651|             ControlMessage::UdpGsoSegments(_) => {
   652|                 libc::UDP_SEGMENT
   653|             },
   654|             #[cfg(any(target_os = "linux", target_os = "macos",
   655|                       target_os = "netbsd", target_os = "android",
   656|                       target_os = "ios",))]
   657|             ControlMessage::Ipv4PacketInfo(_) => libc::IP_PKTINFO,
   658|             #[cfg(any(target_os = "linux", target_os = "macos",
   659|                       target_os = "netbsd", target_os = "freebsd",
   660|                       target_os = "android", target_os = "ios",))]
   661|             ControlMessage::Ipv6PacketInfo(_) => libc::IPV6_PKTINFO,
   662|             #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   663|             ControlMessage::RxqOvfl(_) => {
   664|                 libc::SO_RXQ_OVFL
   665|             },
   666|         }
   667|     }
   668|     unsafe fn encode_into(&self, cmsg: *mut cmsghdr) {
   669|         (*cmsg).cmsg_level = self.cmsg_level();
   670|         (*cmsg).cmsg_type = self.cmsg_type();
   671|         (*cmsg).cmsg_len = self.cmsg_len();
   672|         self.copy_to_cmsg_data(CMSG_DATA(cmsg));
   673|     }
   674| }
   675| pub fn sendmsg(fd: RawFd, iov: &[IoVec<&[u8]>], cmsgs: &[ControlMessage],
   676|                flags: MsgFlags, addr: Option<&SockAddr>) -> Result<usize>
   677| {
   678|     let capacity = cmsgs.iter().map(|c| c.space()).sum();
   679|     let mut cmsg_buffer = vec![0u8; capacity];
   680|     let mhdr = pack_mhdr_to_send(&mut cmsg_buffer[..], &iov, &cmsgs, addr);
   681|     let ret = unsafe { libc::sendmsg(fd, &mhdr, flags.bits()) };
   682|     Errno::result(ret).map(|r| r as usize)
   683| }
   684| #[cfg(any(
   685|     target_os = "linux",
   686|     target_os = "android",
   687|     target_os = "freebsd",
   688|     target_os = "netbsd",
   689| ))]
   690| #[derive(Debug)]
   691| pub struct SendMmsgData<'a, I, C>
   692|     where
   693|         I: AsRef<[IoVec<&'a [u8]>]>,
   694|         C: AsRef<[ControlMessage<'a>]>
   695| {
   696|     pub iov: I,
   697|     pub cmsgs: C,
   698|     pub addr: Option<SockAddr>,
   699|     pub _lt: std::marker::PhantomData<&'a I>,
   700| }
   701| #[cfg(any(
   702|     target_os = "linux",
   703|     target_os = "android",
   704|     target_os = "freebsd",
   705|     target_os = "netbsd",
   706| ))]
   707| pub fn sendmmsg<'a, I, C>(
   708|     fd: RawFd,
   709|     data: impl std::iter::IntoIterator<Item=&'a SendMmsgData<'a, I, C>>,
   710|     flags: MsgFlags
   711| ) -> Result<Vec<usize>>
   712|     where
   713|         I: AsRef<[IoVec<&'a [u8]>]> + 'a,
   714|         C: AsRef<[ControlMessage<'a>]> + 'a,
   715| {
   716|     let iter = data.into_iter();
   717|     let size_hint = iter.size_hint();
   718|     let reserve_items = size_hint.1.unwrap_or(size_hint.0);
   719|     let mut output = Vec::<libc::mmsghdr>::with_capacity(reserve_items);
   720|     let mut cmsgs_buffers = Vec::<Vec<u8>>::with_capacity(reserve_items);
   721|     for d in iter {
   722|         let capacity: usize = d.cmsgs.as_ref().iter().map(|c| c.space()).sum();
   723|         let mut cmsgs_buffer = vec![0u8; capacity];
   724|         output.push(libc::mmsghdr {
   725|             msg_hdr: pack_mhdr_to_send(
   726|                 &mut cmsgs_buffer,
   727|                 &d.iov,
   728|                 &d.cmsgs,
   729|                 d.addr.as_ref()
   730|             ),
   731|             msg_len: 0,
   732|         });
   733|         cmsgs_buffers.push(cmsgs_buffer);
   734|     };
   735|     let ret = unsafe { libc::sendmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _) };
   736|     let sent_messages = Errno::result(ret)? as usize;
   737|     let mut sent_bytes = Vec::with_capacity(sent_messages);
   738|     for item in &output {
   739|         sent_bytes.push(item.msg_len as usize);
   740|     }
   741|     Ok(sent_bytes)
   742| }
   743| #[cfg(any(
   744|     target_os = "linux",
   745|     target_os = "android",
   746|     target_os = "freebsd",
   747|     target_os = "netbsd",
   748| ))]
   749| #[derive(Debug)]
   750| pub struct RecvMmsgData<'a, I>
   751|     where
   752|         I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
   753| {
   754|     pub iov: I,
   755|     pub cmsg_buffer: Option<&'a mut Vec<u8>>,
   756| }
   757| #[cfg(any(
   758|     target_os = "linux",
   759|     target_os = "android",
   760|     target_os = "freebsd",
   761|     target_os = "netbsd",
   762| ))]
   763| pub fn recvmmsg<'a, I>(
   764|     fd: RawFd,
   765|     data: impl std::iter::IntoIterator<Item=&'a mut RecvMmsgData<'a, I>,
   766|         IntoIter=impl ExactSizeIterator + Iterator<Item=&'a mut RecvMmsgData<'a, I>>>,
   767|     flags: MsgFlags,
   768|     timeout: Option<crate::sys::time::TimeSpec>
   769| ) -> Result<Vec<RecvMsg<'a>>>
   770|     where
   771|         I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
   772| {
   773|     let iter = data.into_iter();
   774|     let num_messages = iter.len();
   775|     let mut output: Vec<libc::mmsghdr> = Vec::with_capacity(num_messages);
   776|     let mut addresses = vec![mem::MaybeUninit::uninit(); num_messages]
   777|         .into_boxed_slice();
   778|     let results: Vec<_> = iter.enumerate().map(|(i, d)| {
   779|         let (msg_controllen, mhdr) = unsafe {
   780|             pack_mhdr_to_receive(
   781|                 d.iov.as_ref(),
   782|                 &mut d.cmsg_buffer,
   783|                 addresses[i].as_mut_ptr(),
   784|             )
   785|         };
   786|         output.push(
   787|             libc::mmsghdr {
   788|                 msg_hdr: mhdr,
   789|                 msg_len: 0,
   790|             }
   791|         );
   792|         (msg_controllen as usize, &mut d.cmsg_buffer)
   793|     }).collect();
   794|     let timeout = if let Some(mut t) = timeout {
   795|         t.as_mut() as *mut libc::timespec
   796|     } else {
   797|         ptr::null_mut()
   798|     };
   799|     let ret = unsafe { libc::recvmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _, timeout) };
   800|     let _ = Errno::result(ret)?;
   801|     Ok(output
   802|         .into_iter()
   803|         .take(ret as usize)
   804|         .zip(addresses.iter().map(|addr| unsafe{addr.assume_init()}))
   805|         .zip(results.into_iter())
   806|         .map(|((mmsghdr, address), (msg_controllen, cmsg_buffer))| {
   807|             unsafe {
   808|                 read_mhdr(
   809|                     mmsghdr.msg_hdr,
   810|                     mmsghdr.msg_len as isize,
   811|                     msg_controllen,
   812|                     address,
   813|                     cmsg_buffer
   814|                 )
   815|             }
   816|         })
   817|         .collect())
   818| }
   819| unsafe fn read_mhdr<'a, 'b>(
   820|     mhdr: msghdr,
   821|     r: isize,
   822|     msg_controllen: usize,
   823|     address: sockaddr_storage,
   824|     cmsg_buffer: &'a mut Option<&'b mut Vec<u8>>
   825| ) -> RecvMsg<'b> {
   826|     let cmsghdr = {
   827|         if mhdr.msg_controllen > 0 {
   828|             cmsg_buffer
   829|                 .as_mut()
   830|                 .unwrap()
   831|                 .set_len(mhdr.msg_controllen as usize);
   832|             debug_assert!(!mhdr.msg_control.is_null());
   833|             debug_assert!(msg_controllen >= mhdr.msg_controllen as usize);
   834|             CMSG_FIRSTHDR(&mhdr as *const msghdr)
   835|         } else {
   836|             ptr::null()
   837|         }.as_ref()
   838|     };
   839|     let address = sockaddr_storage_to_addr(
   840|         &address ,
   841|          mhdr.msg_namelen as usize
   842|     ).ok();
   843|     RecvMsg {
   844|         bytes: r as usize,
   845|         cmsghdr,
   846|         address,
   847|         flags: MsgFlags::from_bits_truncate(mhdr.msg_flags),
   848|         mhdr,
   849|     }
   850| }
   851| unsafe fn pack_mhdr_to_receive<'a, I>(
   852|     iov: I,
   853|     cmsg_buffer: &mut Option<&mut Vec<u8>>,
   854|     address: *mut sockaddr_storage,
   855| ) -> (usize, msghdr)
   856|     where
   857|         I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
   858| {
   859|     let (msg_control, msg_controllen) = cmsg_buffer.as_mut()
   860|         .map(|v| (v.as_mut_ptr(), v.capacity()))
   861|         .unwrap_or((ptr::null_mut(), 0));
   862|     let mhdr = {
   863|         let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
   864|         let p = mhdr.as_mut_ptr();
   865|         (*p).msg_name = address as *mut c_void;
   866|         (*p).msg_namelen = mem::size_of::<sockaddr_storage>() as socklen_t;
   867|         (*p).msg_iov = iov.as_ref().as_ptr() as *mut iovec;
   868|         (*p).msg_iovlen = iov.as_ref().len() as _;
   869|         (*p).msg_control = msg_control as *mut c_void;
   870|         (*p).msg_controllen = msg_controllen as _;
   871|         (*p).msg_flags = 0;
   872|         mhdr.assume_init()
   873|     };
   874|     (msg_controllen, mhdr)
   875| }
   876| fn pack_mhdr_to_send<'a, I, C>(
   877|     cmsg_buffer: &mut [u8],
   878|     iov: I,
   879|     cmsgs: C,
   880|     addr: Option<&SockAddr>
   881| ) -> msghdr
   882|     where
   883|         I: AsRef<[IoVec<&'a [u8]>]>,
   884|         C: AsRef<[ControlMessage<'a>]>
   885| {
   886|     let capacity = cmsg_buffer.len();
   887|     let (name, namelen) = match addr {
   888|         Some(addr) => {
   889|             let (x, y) = addr.as_ffi_pair();
   890|             (x as *const _, y)
   891|         },
   892|         None => (ptr::null(), 0),
   893|     };
   894|     let cmsg_ptr = if capacity > 0 {
   895|         cmsg_buffer.as_ptr() as *mut c_void
   896|     } else {
   897|         ptr::null_mut()
   898|     };
   899|     let mhdr = unsafe {
   900|         let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
   901|         let p = mhdr.as_mut_ptr();
   902|         (*p).msg_name = name as *mut _;
   903|         (*p).msg_namelen = namelen;
   904|         (*p).msg_iov = iov.as_ref().as_ptr() as *mut _;
   905|         (*p).msg_iovlen = iov.as_ref().len() as _;
   906|         (*p).msg_control = cmsg_ptr;
   907|         (*p).msg_controllen = capacity as _;
   908|         (*p).msg_flags = 0;
   909|         mhdr.assume_init()
   910|     };
   911|     let mut pmhdr: *mut cmsghdr = unsafe { CMSG_FIRSTHDR(&mhdr as *const msghdr) };
   912|     for cmsg in cmsgs.as_ref() {
   913|         assert_ne!(pmhdr, ptr::null_mut());
   914|         unsafe { cmsg.encode_into(pmhdr) };
   915|         pmhdr = unsafe { CMSG_NXTHDR(&mhdr as *const msghdr, pmhdr) };
   916|     }
   917|     mhdr
   918| }
   919| pub fn recvmsg<'a>(fd: RawFd, iov: &[IoVec<&mut [u8]>],
   920|                    mut cmsg_buffer: Option<&'a mut Vec<u8>>,
   921|                    flags: MsgFlags) -> Result<RecvMsg<'a>>
   922| {
   923|     let mut address = mem::MaybeUninit::uninit();
   924|     let (msg_controllen, mut mhdr) = unsafe {
   925|         pack_mhdr_to_receive(&iov, &mut cmsg_buffer, address.as_mut_ptr())
   926|     };
   927|     let ret = unsafe { libc::recvmsg(fd, &mut mhdr, flags.bits()) };
   928|     let r = Errno::result(ret)?;
   929|     Ok(unsafe { read_mhdr(mhdr, r, msg_controllen, address.assume_init(), &mut cmsg_buffer) })
   930| }
   931| pub fn socket<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, flags: SockFlag, protocol: T) -> Result<RawFd> {
   932|     let protocol = match protocol.into() {
   933|         None => 0,
   934|         Some(p) => p as c_int,
   935|     };
   936|     let mut ty = ty as c_int;
   937|     ty |= flags.bits();
   938|     let res = unsafe { libc::socket(domain as c_int, ty, protocol) };
   939|     Errno::result(res)
   940| }
   941| pub fn socketpair<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, protocol: T,
   942|                   flags: SockFlag) -> Result<(RawFd, RawFd)> {
   943|     let protocol = match protocol.into() {
   944|         None => 0,
   945|         Some(p) => p as c_int,
   946|     };
   947|     let mut ty = ty as c_int;
   948|     ty |= flags.bits();
   949|     let mut fds = [-1, -1];
   950|     let res = unsafe { libc::socketpair(domain as c_int, ty, protocol, fds.as_mut_ptr()) };
   951|     Errno::result(res)?;
   952|     Ok((fds[0], fds[1]))
   953| }
   954| pub fn listen(sockfd: RawFd, backlog: usize) -> Result<()> {
   955|     let res = unsafe { libc::listen(sockfd, backlog as c_int) };
   956|     Errno::result(res).map(drop)
   957| }
   958| pub fn bind(fd: RawFd, addr: &SockAddr) -> Result<()> {
   959|     let res = unsafe {
   960|         let (ptr, len) = addr.as_ffi_pair();
   961|         libc::bind(fd, ptr, len)
   962|     };
   963|     Errno::result(res).map(drop)
   964| }
   965| pub fn accept(sockfd: RawFd) -> Result<RawFd> {
   966|     let res = unsafe { libc::accept(sockfd, ptr::null_mut(), ptr::null_mut()) };
   967|     Errno::result(res)
   968| }
   969| #[cfg(any(all(
   970|             target_os = "android",
   971|             any(
   972|                 target_arch = "aarch64",
   973|                 target_arch = "x86",
   974|                 target_arch = "x86_64"
   975|             )
   976|           ),
   977|           target_os = "freebsd",
   978|           target_os = "linux",
   979|           target_os = "openbsd"))]
   980| pub fn accept4(sockfd: RawFd, flags: SockFlag) -> Result<RawFd> {
   981|     let res = unsafe { libc::accept4(sockfd, ptr::null_mut(), ptr::null_mut(), flags.bits()) };
   982|     Errno::result(res)
   983| }
   984| pub fn connect(fd: RawFd, addr: &SockAddr) -> Result<()> {
   985|     let res = unsafe {
   986|         let (ptr, len) = addr.as_ffi_pair();
   987|         libc::connect(fd, ptr, len)
   988|     };
   989|     Errno::result(res).map(drop)
   990| }
   991| pub fn recv(sockfd: RawFd, buf: &mut [u8], flags: MsgFlags) -> Result<usize> {
   992|     unsafe {
   993|         let ret = libc::recv(
   994|             sockfd,
   995|             buf.as_ptr() as *mut c_void,
   996|             buf.len() as size_t,
   997|             flags.bits());
   998|         Errno::result(ret).map(|r| r as usize)
   999|     }
  1000| }
  1001| pub fn recvfrom(sockfd: RawFd, buf: &mut [u8])
  1002|     -> Result<(usize, Option<SockAddr>)>
  1003| {
  1004|     unsafe {
  1005|         let mut addr: sockaddr_storage = mem::zeroed();
  1006|         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
  1007|         let ret = Errno::result(libc::recvfrom(
  1008|             sockfd,
  1009|             buf.as_ptr() as *mut c_void,
  1010|             buf.len() as size_t,
  1011|             0,
  1012|             &mut addr as *mut libc::sockaddr_storage as *mut libc::sockaddr,
  1013|             &mut len as *mut socklen_t))? as usize;
  1014|         match sockaddr_storage_to_addr(&addr, len as usize) {
  1015|             Err(Errno::ENOTCONN) => Ok((ret, None)),
  1016|             Ok(addr) => Ok((ret, Some(addr))),
  1017|             Err(e) => Err(e)
  1018|         }
  1019|     }
  1020| }
  1021| pub fn sendto(fd: RawFd, buf: &[u8], addr: &SockAddr, flags: MsgFlags) -> Result<usize> {
  1022|     let ret = unsafe {
  1023|         let (ptr, len) = addr.as_ffi_pair();
  1024|         libc::sendto(fd, buf.as_ptr() as *const c_void, buf.len() as size_t, flags.bits(), ptr, len)
  1025|     };
  1026|     Errno::result(ret).map(|r| r as usize)
  1027| }
  1028| pub fn send(fd: RawFd, buf: &[u8], flags: MsgFlags) -> Result<usize> {
  1029|     let ret = unsafe {
  1030|         libc::send(fd, buf.as_ptr() as *const c_void, buf.len() as size_t, flags.bits())
  1031|     };
  1032|     Errno::result(ret).map(|r| r as usize)
  1033| }
  1034| /*
  1035|  *
  1036|  * ===== Socket Options =====
  1037|  *
  1038|  */
  1039| pub trait GetSockOpt : Copy {
  1040|     type Val;
  1041|     #[doc(hidden)]
  1042|     fn get(&self, fd: RawFd) -> Result<Self::Val>;
  1043| }
  1044| pub trait SetSockOpt : Clone {
  1045|     type Val;
  1046|     #[doc(hidden)]
  1047|     fn set(&self, fd: RawFd, val: &Self::Val) -> Result<()>;
  1048| }
  1049| pub fn getsockopt<O: GetSockOpt>(fd: RawFd, opt: O) -> Result<O::Val> {
  1050|     opt.get(fd)
  1051| }
  1052| pub fn setsockopt<O: SetSockOpt>(fd: RawFd, opt: O, val: &O::Val) -> Result<()> {
  1053|     opt.set(fd, val)
  1054| }
  1055| pub fn getpeername(fd: RawFd) -> Result<SockAddr> {
  1056|     unsafe {
  1057|         let mut addr = mem::MaybeUninit::uninit();
  1058|         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
  1059|         let ret = libc::getpeername(
  1060|             fd,
  1061|             addr.as_mut_ptr() as *mut libc::sockaddr,
  1062|             &mut len
  1063|         );
  1064|         Errno::result(ret)?;
  1065|         sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
  1066|     }
  1067| }
  1068| pub fn getsockname(fd: RawFd) -> Result<SockAddr> {
  1069|     unsafe {
  1070|         let mut addr = mem::MaybeUninit::uninit();
  1071|         let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
  1072|         let ret = libc::getsockname(
  1073|             fd,
  1074|             addr.as_mut_ptr() as *mut libc::sockaddr,
  1075|             &mut len
  1076|         );
  1077|         Errno::result(ret)?;
  1078|         sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
  1079|     }
  1080| }
  1081| pub fn sockaddr_storage_to_addr(
  1082|     addr: &sockaddr_storage,
  1083|     len: usize) -> Result<SockAddr> {
  1084|     assert!(len <= mem::size_of::<sockaddr_un>());
  1085|     if len < mem::size_of_val(&addr.ss_family) {
  1086|         return Err(Error::from(Errno::ENOTCONN));
  1087|     }
  1088|     match c_int::from(addr.ss_family) {
  1089|         libc::AF_INET => {
  1090|             assert_eq!(len as usize, mem::size_of::<sockaddr_in>());
  1091|             let sin = unsafe {
  1092|                 *(addr as *const sockaddr_storage as *const sockaddr_in)
  1093|             };
  1094|             Ok(SockAddr::Inet(InetAddr::V4(sin)))
  1095|         }
  1096|         libc::AF_INET6 => {
  1097|             assert_eq!(len as usize, mem::size_of::<sockaddr_in6>());
  1098|             let sin6 = unsafe {
  1099|                 *(addr as *const _ as *const sockaddr_in6)
  1100|             };
  1101|             Ok(SockAddr::Inet(InetAddr::V6(sin6)))
  1102|         }
  1103|         libc::AF_UNIX => {
  1104|             let pathlen = len - offset_of!(sockaddr_un, sun_path);
  1105|             let sun = unsafe {
  1106|                 *(addr as *const _ as *const sockaddr_un)
  1107|             };
  1108|             Ok(SockAddr::Unix(UnixAddr(sun, pathlen)))
  1109|         }
  1110|         #[cfg(any(target_os = "android", target_os = "linux"))]
  1111|         libc::AF_PACKET => {
  1112|             use libc::sockaddr_ll;
  1113|             assert!(len as usize <= mem::size_of::<sockaddr_ll>());
  1114|             let sll = unsafe {
  1115|                 *(addr as *const _ as *const sockaddr_ll)
  1116|             };
  1117|             Ok(SockAddr::Link(LinkAddr(sll)))
  1118|         }
  1119|         #[cfg(any(target_os = "android", target_os = "linux"))]
  1120|         libc::AF_NETLINK => {
  1121|             use libc::sockaddr_nl;
  1122|             let snl = unsafe {
  1123|                 *(addr as *const _ as *const sockaddr_nl)
  1124|             };
  1125|             Ok(SockAddr::Netlink(NetlinkAddr(snl)))
  1126|         }
  1127|         #[cfg(any(target_os = "android", target_os = "linux"))]
  1128|         libc::AF_ALG => {
  1129|             use libc::sockaddr_alg;
  1130|             let salg = unsafe {
  1131|                 *(addr as *const _ as *const sockaddr_alg)
  1132|             };
  1133|             Ok(SockAddr::Alg(AlgAddr(salg)))
  1134|         }
  1135|         #[cfg(any(target_os = "android", target_os = "linux"))]
  1136|         libc::AF_VSOCK => {
  1137|             use libc::sockaddr_vm;
  1138|             let svm = unsafe {
  1139|                 *(addr as *const _ as *const sockaddr_vm)
  1140|             };
  1141|             Ok(SockAddr::Vsock(VsockAddr(svm)))
  1142|         }
  1143|         af => panic!("unexpected address family {}", af),
  1144|     }
  1145| }
  1146| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
  1147| pub enum Shutdown {
  1148|     Read,
  1149|     Write,
  1150|     Both,
  1151| }
  1152| pub fn shutdown(df: RawFd, how: Shutdown) -> Result<()> {
  1153|     unsafe {
  1154|         use libc::shutdown;
  1155|         let how = match how {
  1156|             Shutdown::Read  => libc::SHUT_RD,
  1157|             Shutdown::Write => libc::SHUT_WR,
  1158|             Shutdown::Both  => libc::SHUT_RDWR,
  1159|         };
  1160|         Errno::result(shutdown(df, how)).map(drop)
  1161|     }
  1162| }
  1163| #[cfg(test)]
  1164| mod tests {
  1165|     #[test]
  1166|     fn can_use_cmsg_space() {
  1167|         let _ = cmsg_space!(u8);
  1168|     }
  1169| }


# ====================================================================
# FILE: src/sys/socket/sockopt.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-516 ---
     1| use cfg_if::cfg_if;
     2| use super::{GetSockOpt, SetSockOpt};
     3| use crate::Result;
     4| use crate::errno::Errno;
     5| use crate::sys::time::TimeVal;
     6| use libc::{self, c_int, c_void, socklen_t};
     7| use std::mem::{
     8|     self,
     9|     MaybeUninit
    10| };
    11| use std::os::unix::io::RawFd;
    12| use std::ffi::{OsStr, OsString};
    13| #[cfg(target_family = "unix")]
    14| use std::os::unix::ffi::OsStrExt;
    15| #[cfg(any(target_os = "freebsd", target_os = "linux"))] 
    16| const TCP_CA_NAME_MAX: usize = 16;
    17| macro_rules! setsockopt_impl {
    18|     ($name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
    19|         impl SetSockOpt for $name {
    20|             type Val = $ty;
    21|             fn set(&self, fd: RawFd, val: &$ty) -> Result<()> {
    22|                 unsafe {
    23|                     let setter: $setter = Set::new(val);
    24|                     let res = libc::setsockopt(fd, $level, $flag,
    25|                                                setter.ffi_ptr(),
    26|                                                setter.ffi_len());
    27|                     Errno::result(res).map(drop)
    28|                 }
    29|             }
    30|         }
    31|     }
    32| }
    33| macro_rules! getsockopt_impl {
    34|     ($name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
    35|         impl GetSockOpt for $name {
    36|             type Val = $ty;
    37|             fn get(&self, fd: RawFd) -> Result<$ty> {
    38|                 unsafe {
    39|                     let mut getter: $getter = Get::uninit();
    40|                     let res = libc::getsockopt(fd, $level, $flag,
    41|                                                getter.ffi_ptr(),
    42|                                                getter.ffi_len());
    43|                     Errno::result(res)?;
    44|                     Ok(getter.assume_init())
    45|                 }
    46|             }
    47|         }
    48|     }
    49| }
    50| macro_rules! sockopt_impl {
    51|     (GetOnly, $name:ident, $level:path, $flag:path, bool) => {
    52|         sockopt_impl!(GetOnly, $name, $level, $flag, bool, GetBool);
    53|     };
    54|     (GetOnly, $name:ident, $level:path, $flag:path, u8) => {
    55|         sockopt_impl!(GetOnly, $name, $level, $flag, u8, GetU8);
    56|     };
    57|     (GetOnly, $name:ident, $level:path, $flag:path, usize) => {
    58|         sockopt_impl!(GetOnly, $name, $level, $flag, usize, GetUsize);
    59|     };
    60|     (SetOnly, $name:ident, $level:path, $flag:path, bool) => {
    61|         sockopt_impl!(SetOnly, $name, $level, $flag, bool, SetBool);
    62|     };
    63|     (SetOnly, $name:ident, $level:path, $flag:path, u8) => {
    64|         sockopt_impl!(SetOnly, $name, $level, $flag, u8, SetU8);
    65|     };
    66|     (SetOnly, $name:ident, $level:path, $flag:path, usize) => {
    67|         sockopt_impl!(SetOnly, $name, $level, $flag, usize, SetUsize);
    68|     };
    69|     (Both, $name:ident, $level:path, $flag:path, bool) => {
    70|         sockopt_impl!(Both, $name, $level, $flag, bool, GetBool, SetBool);
    71|     };
    72|     (Both, $name:ident, $level:path, $flag:path, u8) => {
    73|         sockopt_impl!(Both, $name, $level, $flag, u8, GetU8, SetU8);
    74|     };
    75|     (Both, $name:ident, $level:path, $flag:path, usize) => {
    76|         sockopt_impl!(Both, $name, $level, $flag, usize, GetUsize, SetUsize);
    77|     };
    78|     (Both, $name:ident, $level:path, $flag:path, OsString<$array:ty>) => {
    79|         sockopt_impl!(Both, $name, $level, $flag, OsString, GetOsString<$array>, SetOsString);
    80|     };
    81|     /*
    82|      * Matchers with generic getter types must be placed at the end, so
    83|      * they'll only match _after_ specialized matchers fail
    84|      */
    85|     (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
    86|         sockopt_impl!(GetOnly, $name, $level, $flag, $ty, GetStruct<$ty>);
    87|     };
    88|     (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
    89|         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    90|         pub struct $name;
    91|         getsockopt_impl!($name, $level, $flag, $ty, $getter);
    92|     };
    93|     (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
    94|         sockopt_impl!(SetOnly, $name, $level, $flag, $ty, SetStruct<$ty>);
    95|     };
    96|     (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
    97|         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    98|         pub struct $name;
    99|         setsockopt_impl!($name, $level, $flag, $ty, $setter);
   100|     };
   101|     (Both, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty, $setter:ty) => {
   102|         #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
   103|         pub struct $name;
   104|         setsockopt_impl!($name, $level, $flag, $ty, $setter);
   105|         getsockopt_impl!($name, $level, $flag, $ty, $getter);
   106|     };
   107|     (Both, $name:ident, $level:path, $flag:path, $ty:ty) => {
   108|         sockopt_impl!(Both, $name, $level, $flag, $ty, GetStruct<$ty>, SetStruct<$ty>);
   109|     };
   110| }
   111| /*
   112|  *
   113|  * ===== Define sockopts =====
   114|  *
   115|  */
   116| sockopt_impl!(Both, ReuseAddr, libc::SOL_SOCKET, libc::SO_REUSEADDR, bool);
   117| #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
   118| sockopt_impl!(Both, ReusePort, libc::SOL_SOCKET, libc::SO_REUSEPORT, bool);
   119| sockopt_impl!(Both, TcpNoDelay, libc::IPPROTO_TCP, libc::TCP_NODELAY, bool);
   120| sockopt_impl!(Both, Linger, libc::SOL_SOCKET, libc::SO_LINGER, libc::linger);
   121| sockopt_impl!(SetOnly, IpAddMembership, libc::IPPROTO_IP, libc::IP_ADD_MEMBERSHIP, super::IpMembershipRequest);
   122| sockopt_impl!(SetOnly, IpDropMembership, libc::IPPROTO_IP, libc::IP_DROP_MEMBERSHIP, super::IpMembershipRequest);
   123| cfg_if! {
   124|     if #[cfg(any(target_os = "android", target_os = "linux"))] {
   125|         sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_ADD_MEMBERSHIP, super::Ipv6MembershipRequest);
   126|         sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_DROP_MEMBERSHIP, super::Ipv6MembershipRequest);
   127|     } else if #[cfg(any(target_os = "dragonfly",
   128|                         target_os = "freebsd",
   129|                         target_os = "illumos",
   130|                         target_os = "ios",
   131|                         target_os = "macos",
   132|                         target_os = "netbsd",
   133|                         target_os = "openbsd",
   134|                         target_os = "solaris"))] {
   135|         sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_JOIN_GROUP, super::Ipv6MembershipRequest);
   136|         sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_LEAVE_GROUP, super::Ipv6MembershipRequest);
   137|     }
   138| }
   139| sockopt_impl!(Both, IpMulticastTtl, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL, u8);
   140| sockopt_impl!(Both, IpMulticastLoop, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP, bool);
   141| #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   142| sockopt_impl!(Both, IpFreebind, libc::IPPROTO_IP, libc::IP_FREEBIND, bool);
   143| sockopt_impl!(Both, ReceiveTimeout, libc::SOL_SOCKET, libc::SO_RCVTIMEO, TimeVal);
   144| sockopt_impl!(Both, SendTimeout, libc::SOL_SOCKET, libc::SO_SNDTIMEO, TimeVal);
   145| sockopt_impl!(Both, Broadcast, libc::SOL_SOCKET, libc::SO_BROADCAST, bool);
   146| sockopt_impl!(Both, OobInline, libc::SOL_SOCKET, libc::SO_OOBINLINE, bool);
   147| sockopt_impl!(GetOnly, SocketError, libc::SOL_SOCKET, libc::SO_ERROR, i32);
   148| sockopt_impl!(Both, KeepAlive, libc::SOL_SOCKET, libc::SO_KEEPALIVE, bool);
   149| #[cfg(any(target_os = "android", target_os = "linux"))]
   150| sockopt_impl!(GetOnly, PeerCredentials, libc::SOL_SOCKET, libc::SO_PEERCRED, super::UnixCredentials);
   151| #[cfg(any(target_os = "ios",
   152|           target_os = "macos"))]
   153| sockopt_impl!(Both, TcpKeepAlive, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE, u32);
   154| #[cfg(any(target_os = "android",
   155|           target_os = "dragonfly",
   156|           target_os = "freebsd",
   157|           target_os = "linux",
   158|           target_os = "nacl"))]
   159| sockopt_impl!(Both, TcpKeepIdle, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE, u32);
   160| #[cfg(not(target_os = "openbsd"))]
   161| sockopt_impl!(Both, TcpKeepCount, libc::IPPROTO_TCP, libc::TCP_KEEPCNT, u32);
   162| #[cfg(not(target_os = "openbsd"))]
   163| sockopt_impl!(Both, TcpKeepInterval, libc::IPPROTO_TCP, libc::TCP_KEEPINTVL, u32);
   164| #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
   165| sockopt_impl!(Both, TcpUserTimeout, libc::IPPROTO_TCP, libc::TCP_USER_TIMEOUT, u32);
   166| sockopt_impl!(Both, RcvBuf, libc::SOL_SOCKET, libc::SO_RCVBUF, usize);
   167| sockopt_impl!(Both, SndBuf, libc::SOL_SOCKET, libc::SO_SNDBUF, usize);
   168| #[cfg(any(target_os = "android", target_os = "linux"))]
   169| sockopt_impl!(SetOnly, RcvBufForce, libc::SOL_SOCKET, libc::SO_RCVBUFFORCE, usize);
   170| #[cfg(any(target_os = "android", target_os = "linux"))]
   171| sockopt_impl!(SetOnly, SndBufForce, libc::SOL_SOCKET, libc::SO_SNDBUFFORCE, usize);
   172| sockopt_impl!(GetOnly, SockType, libc::SOL_SOCKET, libc::SO_TYPE, super::SockType);
   173| sockopt_impl!(GetOnly, AcceptConn, libc::SOL_SOCKET, libc::SO_ACCEPTCONN, bool);
   174| #[cfg(any(target_os = "android", target_os = "linux"))]
   175| sockopt_impl!(Both, BindToDevice, libc::SOL_SOCKET, libc::SO_BINDTODEVICE, OsString<[u8; libc::IFNAMSIZ]>);
   176| #[cfg(any(target_os = "android", target_os = "linux"))]
   177| sockopt_impl!(GetOnly, OriginalDst, libc::SOL_IP, libc::SO_ORIGINAL_DST, libc::sockaddr_in);
   178| sockopt_impl!(Both, ReceiveTimestamp, libc::SOL_SOCKET, libc::SO_TIMESTAMP, bool);
   179| #[cfg(all(target_os = "linux"))]
   180| sockopt_impl!(Both, ReceiveTimestampns, libc::SOL_SOCKET, libc::SO_TIMESTAMPNS, bool);
   181| #[cfg(any(target_os = "android", target_os = "linux"))]
   182| sockopt_impl!(Both, IpTransparent, libc::SOL_IP, libc::IP_TRANSPARENT, bool);
   183| #[cfg(target_os = "openbsd")]
   184| sockopt_impl!(Both, BindAny, libc::SOL_SOCKET, libc::SO_BINDANY, bool);
   185| #[cfg(target_os = "freebsd")]
   186| sockopt_impl!(Both, BindAny, libc::IPPROTO_IP, libc::IP_BINDANY, bool);
   187| #[cfg(target_os = "linux")]
   188| sockopt_impl!(Both, Mark, libc::SOL_SOCKET, libc::SO_MARK, u32);
   189| #[cfg(any(target_os = "android", target_os = "linux"))]
   190| sockopt_impl!(Both, PassCred, libc::SOL_SOCKET, libc::SO_PASSCRED, bool);
   191| #[cfg(any(target_os = "freebsd", target_os = "linux"))] 
   192| sockopt_impl!(Both, TcpCongestion, libc::IPPROTO_TCP, libc::TCP_CONGESTION, OsString<[u8; TCP_CA_NAME_MAX]>);
   193| #[cfg(any(
   194|     target_os = "android",
   195|     target_os = "ios",
   196|     target_os = "linux",
   197|     target_os = "macos",
   198|     target_os = "netbsd",
   199| ))]
   200| sockopt_impl!(Both, Ipv4PacketInfo, libc::IPPROTO_IP, libc::IP_PKTINFO, bool);
   201| #[cfg(any(
   202|     target_os = "android",
   203|     target_os = "freebsd",
   204|     target_os = "ios",
   205|     target_os = "linux",
   206|     target_os = "macos",
   207|     target_os = "netbsd",
   208|     target_os = "openbsd",
   209| ))]
   210| sockopt_impl!(Both, Ipv6RecvPacketInfo, libc::IPPROTO_IPV6, libc::IPV6_RECVPKTINFO, bool);
   211| #[cfg(any(
   212|     target_os = "freebsd",
   213|     target_os = "ios",
   214|     target_os = "macos",
   215|     target_os = "netbsd",
   216|     target_os = "openbsd",
   217| ))]
   218| sockopt_impl!(Both, Ipv4RecvIf, libc::IPPROTO_IP, libc::IP_RECVIF, bool);
   219| #[cfg(any(
   220|     target_os = "freebsd",
   221|     target_os = "ios",
   222|     target_os = "macos",
   223|     target_os = "netbsd",
   224|     target_os = "openbsd",
   225| ))]
   226| sockopt_impl!(Both, Ipv4RecvDstAddr, libc::IPPROTO_IP, libc::IP_RECVDSTADDR, bool);
   227| #[cfg(target_os = "linux")]
   228| sockopt_impl!(Both, UdpGsoSegment, libc::SOL_UDP, libc::UDP_SEGMENT, libc::c_int);
   229| #[cfg(target_os = "linux")]
   230| sockopt_impl!(Both, UdpGroSegment, libc::IPPROTO_UDP, libc::UDP_GRO, bool);
   231| #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
   232| sockopt_impl!(Both, RxqOvfl, libc::SOL_SOCKET, libc::SO_RXQ_OVFL, libc::c_int);
   233| #[cfg(any(target_os = "android", target_os = "linux"))]
   234| #[derive(Copy, Clone, Debug)]
   235| pub struct AlgSetAeadAuthSize;
   236| #[cfg(any(target_os = "android", target_os = "linux"))]
   237| impl SetSockOpt for AlgSetAeadAuthSize {
   238|     type Val = usize;
   239|     fn set(&self, fd: RawFd, val: &usize) -> Result<()> {
   240|         unsafe {
   241|             let res = libc::setsockopt(fd,
   242|                                        libc::SOL_ALG,
   243|                                        libc::ALG_SET_AEAD_AUTHSIZE,
   244|                                        ::std::ptr::null(),
   245|                                        *val as libc::socklen_t);
   246|             Errno::result(res).map(drop)
   247|         }
   248|     }
   249| }
   250| #[cfg(any(target_os = "android", target_os = "linux"))]
   251| #[derive(Clone, Debug)]
   252| pub struct AlgSetKey<T>(::std::marker::PhantomData<T>);
   253| #[cfg(any(target_os = "android", target_os = "linux"))]
   254| impl<T> Default for AlgSetKey<T> {
   255|     fn default() -> Self {
   256|         AlgSetKey(Default::default())
   257|     }
   258| }
   259| #[cfg(any(target_os = "android", target_os = "linux"))]
   260| impl<T> SetSockOpt for AlgSetKey<T> where T: AsRef<[u8]> + Clone {
   261|     type Val = T;
   262|     fn set(&self, fd: RawFd, val: &T) -> Result<()> {
   263|         unsafe {
   264|             let res = libc::setsockopt(fd,
   265|                                        libc::SOL_ALG,
   266|                                        libc::ALG_SET_KEY,
   267|                                        val.as_ref().as_ptr() as *const _,
   268|                                        val.as_ref().len() as libc::socklen_t);
   269|             Errno::result(res).map(drop)
   270|         }
   271|     }
   272| }
   273| /*
   274|  *
   275|  * ===== Accessor helpers =====
   276|  *
   277|  */
   278| unsafe trait Get<T> {
   279|     unsafe fn uninit() -> Self;
   280|     fn ffi_ptr(&mut self) -> *mut c_void;
   281|     fn ffi_len(&mut self) -> *mut socklen_t;
   282|     unsafe fn assume_init(self) -> T;
   283| }
   284| unsafe trait Set<'a, T> {
   285|     fn new(val: &'a T) -> Self;
   286|     fn ffi_ptr(&self) -> *const c_void;
   287|     fn ffi_len(&self) -> socklen_t;
   288| }
   289| struct GetStruct<T> {
   290|     len: socklen_t,
   291|     val: MaybeUninit<T>,
   292| }
   293| unsafe impl<T> Get<T> for GetStruct<T> {
   294|     unsafe fn uninit() -> Self {
   295|         GetStruct {
   296|             len: mem::size_of::<T>() as socklen_t,
   297|             val: MaybeUninit::uninit(),
   298|         }
   299|     }
   300|     fn ffi_ptr(&mut self) -> *mut c_void {
   301|         self.val.as_mut_ptr() as *mut c_void
   302|     }
   303|     fn ffi_len(&mut self) -> *mut socklen_t {
   304|         &mut self.len
   305|     }
   306|     unsafe fn assume_init(self) -> T {
   307|         assert_eq!(self.len as usize, mem::size_of::<T>(), "invalid getsockopt implementation");
   308|         self.val.assume_init()
   309|     }
   310| }
   311| struct SetStruct<'a, T: 'static> {
   312|     ptr: &'a T,
   313| }
   314| unsafe impl<'a, T> Set<'a, T> for SetStruct<'a, T> {
   315|     fn new(ptr: &'a T) -> SetStruct<'a, T> {
   316|         SetStruct { ptr }
   317|     }
   318|     fn ffi_ptr(&self) -> *const c_void {
   319|         self.ptr as *const T as *const c_void
   320|     }
   321|     fn ffi_len(&self) -> socklen_t {
   322|         mem::size_of::<T>() as socklen_t
   323|     }
   324| }
   325| struct GetBool {
   326|     len: socklen_t,
   327|     val: MaybeUninit<c_int>,
   328| }
   329| unsafe impl Get<bool> for GetBool {
   330|     unsafe fn uninit() -> Self {
   331|         GetBool {
   332|             len: mem::size_of::<c_int>() as socklen_t,
   333|             val: MaybeUninit::uninit(),
   334|         }
   335|     }
   336|     fn ffi_ptr(&mut self) -> *mut c_void {
   337|         self.val.as_mut_ptr() as *mut c_void
   338|     }
   339|     fn ffi_len(&mut self) -> *mut socklen_t {
   340|         &mut self.len
   341|     }
   342|     unsafe fn assume_init(self) -> bool {
   343|         assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
   344|         self.val.assume_init() != 0
   345|     }
   346| }
   347| struct SetBool {
   348|     val: c_int,
   349| }
   350| unsafe impl<'a> Set<'a, bool> for SetBool {
   351|     fn new(val: &'a bool) -> SetBool {
   352|         SetBool { val: if *val { 1 } else { 0 } }
   353|     }
   354|     fn ffi_ptr(&self) -> *const c_void {
   355|         &self.val as *const c_int as *const c_void
   356|     }
   357|     fn ffi_len(&self) -> socklen_t {
   358|         mem::size_of::<c_int>() as socklen_t
   359|     }
   360| }
   361| struct GetU8 {
   362|     len: socklen_t,
   363|     val: MaybeUninit<u8>,
   364| }
   365| unsafe impl Get<u8> for GetU8 {
   366|     unsafe fn uninit() -> Self {
   367|         GetU8 {
   368|             len: mem::size_of::<u8>() as socklen_t,
   369|             val: MaybeUninit::uninit(),
   370|         }
   371|     }
   372|     fn ffi_ptr(&mut self) -> *mut c_void {
   373|         self.val.as_mut_ptr() as *mut c_void
   374|     }
   375|     fn ffi_len(&mut self) -> *mut socklen_t {
   376|         &mut self.len
   377|     }
   378|     unsafe fn assume_init(self) -> u8 {
   379|         assert_eq!(self.len as usize, mem::size_of::<u8>(), "invalid getsockopt implementation");
   380|         self.val.assume_init()
   381|     }
   382| }
   383| struct SetU8 {
   384|     val: u8,
   385| }
   386| unsafe impl<'a> Set<'a, u8> for SetU8 {
   387|     fn new(val: &'a u8) -> SetU8 {
   388|         SetU8 { val: *val as u8 }
   389|     }
   390|     fn ffi_ptr(&self) -> *const c_void {
   391|         &self.val as *const u8 as *const c_void
   392|     }
   393|     fn ffi_len(&self) -> socklen_t {
   394|         mem::size_of::<c_int>() as socklen_t
   395|     }
   396| }
   397| struct GetUsize {
   398|     len: socklen_t,
   399|     val: MaybeUninit<c_int>,
   400| }
   401| unsafe impl Get<usize> for GetUsize {
   402|     unsafe fn uninit() -> Self {
   403|         GetUsize {
   404|             len: mem::size_of::<c_int>() as socklen_t,
   405|             val: MaybeUninit::uninit(),
   406|         }
   407|     }
   408|     fn ffi_ptr(&mut self) -> *mut c_void {
   409|         self.val.as_mut_ptr() as *mut c_void
   410|     }
   411|     fn ffi_len(&mut self) -> *mut socklen_t {
   412|         &mut self.len
   413|     }
   414|     unsafe fn assume_init(self) -> usize {
   415|         assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
   416|         self.val.assume_init() as usize
   417|     }
   418| }
   419| struct SetUsize {
   420|     val: c_int,
   421| }
   422| unsafe impl<'a> Set<'a, usize> for SetUsize {
   423|     fn new(val: &'a usize) -> SetUsize {
   424|         SetUsize { val: *val as c_int }
   425|     }
   426|     fn ffi_ptr(&self) -> *const c_void {
   427|         &self.val as *const c_int as *const c_void
   428|     }
   429|     fn ffi_len(&self) -> socklen_t {
   430|         mem::size_of::<c_int>() as socklen_t
   431|     }
   432| }
   433| struct GetOsString<T: AsMut<[u8]>> {
   434|     len: socklen_t,
   435|     val: MaybeUninit<T>,
   436| }
   437| unsafe impl<T: AsMut<[u8]>> Get<OsString> for GetOsString<T> {
   438|     unsafe fn uninit() -> Self {
   439|         GetOsString {
   440|             len: mem::size_of::<T>() as socklen_t,
   441|             val: MaybeUninit::uninit(),
   442|         }
   443|     }
   444|     fn ffi_ptr(&mut self) -> *mut c_void {
   445|         self.val.as_mut_ptr() as *mut c_void
   446|     }
   447|     fn ffi_len(&mut self) -> *mut socklen_t {
   448|         &mut self.len
   449|     }
   450|     unsafe fn assume_init(self) -> OsString {
   451|         let len = self.len as usize;
   452|         let mut v = self.val.assume_init();
   453|         OsStr::from_bytes(&v.as_mut()[0..len]).to_owned()
   454|     }
   455| }
   456| struct SetOsString<'a> {
   457|     val: &'a OsStr,
   458| }
   459| unsafe impl<'a> Set<'a, OsString> for SetOsString<'a> {
   460|     fn new(val: &'a OsString) -> SetOsString {
   461|         SetOsString { val: val.as_os_str() }
   462|     }
   463|     fn ffi_ptr(&self) -> *const c_void {
   464|         self.val.as_bytes().as_ptr() as *const c_void
   465|     }
   466|     fn ffi_len(&self) -> socklen_t {
   467|         self.val.len() as socklen_t
   468|     }
   469| }
   470| #[cfg(test)]
   471| mod test {
   472|     #[cfg(any(target_os = "android", target_os = "linux"))]
   473|     #[test]
   474|     fn can_get_peercred_on_unix_socket() {
   475|         use super::super::*;
   476|         let (a, b) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty()).unwrap();
   477|         let a_cred = getsockopt(a, super::PeerCredentials).unwrap();
   478|         let b_cred = getsockopt(b, super::PeerCredentials).unwrap();
   479|         assert_eq!(a_cred, b_cred);
   480|         assert!(a_cred.pid() != 0);
   481|     }
   482|     #[test]
   483|     fn is_socket_type_unix() {
   484|         use super::super::*;
   485|         use crate::unistd::close;
   486|         let (a, b) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty()).unwrap();
   487|         let a_type = getsockopt(a, super::SockType).unwrap();
   488|         assert_eq!(a_type, SockType::Stream);
   489|         close(a).unwrap();
   490|         close(b).unwrap();
   491|     }
   492|     #[test]
   493|     fn is_socket_type_dgram() {
   494|         use super::super::*;
   495|         use crate::unistd::close;
   496|         let s = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(), None).unwrap();
   497|         let s_type = getsockopt(s, super::SockType).unwrap();
   498|         assert_eq!(s_type, SockType::Datagram);
   499|         close(s).unwrap();
   500|     }
   501|     #[cfg(any(target_os = "freebsd",
   502|               target_os = "linux",
   503|               target_os = "nacl"))]
   504|     #[test]
   505|     fn can_get_listen_on_tcp_socket() {
   506|         use super::super::*;
   507|         use crate::unistd::close;
   508|         let s = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), None).unwrap();
   509|         let s_listening = getsockopt(s, super::AcceptConn).unwrap();
   510|         assert!(!s_listening);
   511|         listen(s, 10).unwrap();
   512|         let s_listening2 = getsockopt(s, super::AcceptConn).unwrap();
   513|         assert!(s_listening2);
   514|         close(s).unwrap();
   515|     }
   516| }


# ====================================================================
# FILE: src/sys/termios.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-798 ---
     1| #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
     2|                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
     3|             doc = " ```rust,ignore")]
     4| #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
     5|                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
     6|             doc = " ```rust")]
     7| #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
     8|                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
     9|             doc = " ```rust")]
    10| #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
    11|                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
    12|             doc = " ```rust,ignore")]
    13| #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
    14|                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
    15|             doc = " ```rust")]
    16| #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
    17|                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
    18|             doc = " ```rust,ignore")]
    19| #![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
    20|                 target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
    21|             doc = " ```rust")]
    22| #![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
    23|                     target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
    24|             doc = " ```rust,ignore")]
    25| use cfg_if::cfg_if;
    26| use crate::{Error, Result};
    27| use crate::errno::Errno;
    28| use libc::{self, c_int, tcflag_t};
    29| use std::cell::{Ref, RefCell};
    30| use std::convert::{From, TryFrom};
    31| use std::mem;
    32| use std::os::unix::io::RawFd;
    33| use crate::unistd::Pid;
    34| #[derive(Clone, Debug, Eq, PartialEq)]
    35| pub struct Termios {
    36|     inner: RefCell<libc::termios>,
    37|     pub input_flags: InputFlags,
    38|     pub output_flags: OutputFlags,
    39|     pub control_flags: ControlFlags,
    40|     pub local_flags: LocalFlags,
    41|     pub control_chars: [libc::cc_t; NCCS],
    42| }
    43| impl Termios {
    44|     pub(crate) fn get_libc_termios(&self) -> Ref<libc::termios> {
    45|         {
    46|             let mut termios = self.inner.borrow_mut();
    47|             termios.c_iflag = self.input_flags.bits();
    48|             termios.c_oflag = self.output_flags.bits();
    49|             termios.c_cflag = self.control_flags.bits();
    50|             termios.c_lflag = self.local_flags.bits();
    51|             termios.c_cc = self.control_chars;
    52|         }
    53|         self.inner.borrow()
    54|     }
    55|     pub(crate) unsafe fn get_libc_termios_mut(&mut self) -> *mut libc::termios {
    56|         {
    57|             let mut termios = self.inner.borrow_mut();
    58|             termios.c_iflag = self.input_flags.bits();
    59|             termios.c_oflag = self.output_flags.bits();
    60|             termios.c_cflag = self.control_flags.bits();
    61|             termios.c_lflag = self.local_flags.bits();
    62|             termios.c_cc = self.control_chars;
    63|         }
    64|         self.inner.as_ptr()
    65|     }
    66|     pub(crate) fn update_wrapper(&mut self) {
    67|         let termios = *self.inner.borrow_mut();
    68|         self.input_flags = InputFlags::from_bits_truncate(termios.c_iflag);
    69|         self.output_flags = OutputFlags::from_bits_truncate(termios.c_oflag);
    70|         self.control_flags = ControlFlags::from_bits_truncate(termios.c_cflag);
    71|         self.local_flags = LocalFlags::from_bits_truncate(termios.c_lflag);
    72|         self.control_chars = termios.c_cc;
    73|     }
    74| }
    75| impl From<libc::termios> for Termios {
    76|     fn from(termios: libc::termios) -> Self {
    77|         Termios {
    78|             inner: RefCell::new(termios),
    79|             input_flags: InputFlags::from_bits_truncate(termios.c_iflag),
    80|             output_flags: OutputFlags::from_bits_truncate(termios.c_oflag),
    81|             control_flags: ControlFlags::from_bits_truncate(termios.c_cflag),
    82|             local_flags: LocalFlags::from_bits_truncate(termios.c_lflag),
    83|             control_chars: termios.c_cc,
    84|         }
    85|     }
    86| }
    87| impl From<Termios> for libc::termios {
    88|     fn from(termios: Termios) -> Self {
    89|         termios.inner.into_inner()
    90|     }
    91| }
    92| libc_enum!{
    93|     #[cfg_attr(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64"), repr(u64))]
    94|     #[cfg_attr(not(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64")), repr(u32))]
    95|     pub enum BaudRate {
    96|         B0,
    97|         B50,
    98|         B75,
    99|         B110,
   100|         B134,
   101|         B150,
   102|         B200,
   103|         B300,
   104|         B600,
   105|         B1200,
   106|         B1800,
   107|         B2400,
   108|         B4800,
   109|         #[cfg(any(target_os = "dragonfly",
   110|                 target_os = "freebsd",
   111|                 target_os = "macos",
   112|                 target_os = "netbsd",
   113|                 target_os = "openbsd"))]
   114|         B7200,
   115|         B9600,
   116|         #[cfg(any(target_os = "dragonfly",
   117|                 target_os = "freebsd",
   118|                 target_os = "macos",
   119|                 target_os = "netbsd",
   120|                 target_os = "openbsd"))]
   121|         B14400,
   122|         B19200,
   123|         #[cfg(any(target_os = "dragonfly",
   124|                 target_os = "freebsd",
   125|                 target_os = "macos",
   126|                 target_os = "netbsd",
   127|                 target_os = "openbsd"))]
   128|         B28800,
   129|         B38400,
   130|         B57600,
   131|         #[cfg(any(target_os = "dragonfly",
   132|                 target_os = "freebsd",
   133|                 target_os = "macos",
   134|                 target_os = "netbsd",
   135|                 target_os = "openbsd"))]
   136|         B76800,
   137|         B115200,
   138|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   139|         B153600,
   140|         B230400,
   141|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   142|         B307200,
   143|         #[cfg(any(target_os = "android",
   144|                   target_os = "freebsd",
   145|                   target_os = "illumos",
   146|                   target_os = "linux",
   147|                   target_os = "netbsd",
   148|                   target_os = "solaris"))]
   149|         B460800,
   150|         #[cfg(any(target_os = "android", target_os = "linux"))]
   151|         B500000,
   152|         #[cfg(any(target_os = "android", target_os = "linux"))]
   153|         B576000,
   154|         #[cfg(any(target_os = "android",
   155|                   target_os = "freebsd",
   156|                   target_os = "illumos",
   157|                   target_os = "linux",
   158|                   target_os = "netbsd",
   159|                   target_os = "solaris"))]
   160|         B921600,
   161|         #[cfg(any(target_os = "android", target_os = "linux"))]
   162|         B1000000,
   163|         #[cfg(any(target_os = "android", target_os = "linux"))]
   164|         B1152000,
   165|         #[cfg(any(target_os = "android", target_os = "linux"))]
   166|         B1500000,
   167|         #[cfg(any(target_os = "android", target_os = "linux"))]
   168|         B2000000,
   169|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   170|         B2500000,
   171|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   172|         B3000000,
   173|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   174|         B3500000,
   175|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   176|         B4000000,
   177|     }
   178| }
   179| impl TryFrom<libc::speed_t> for BaudRate {
   180|     type Error = Error;
   181|     fn try_from(s: libc::speed_t) -> Result<BaudRate> {
   182|         use libc::{B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400, B4800,
   183|                    B9600, B19200, B38400, B57600, B115200, B230400};
   184|         #[cfg(any(target_os = "android", target_os = "linux"))]
   185|         use libc::{B500000, B576000, B1000000, B1152000, B1500000, B2000000};
   186|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   187|         use libc::{B2500000, B3000000, B3500000, B4000000};
   188|         #[cfg(any(target_os = "dragonfly",
   189|                   target_os = "freebsd",
   190|                   target_os = "macos",
   191|                   target_os = "netbsd",
   192|                   target_os = "openbsd"))]
   193|         use libc::{B7200, B14400, B28800, B76800};
   194|         #[cfg(any(target_os = "android",
   195|                   target_os = "freebsd",
   196|                   target_os = "linux",
   197|                   target_os = "netbsd"))]
   198|         use libc::{B460800, B921600};
   199|         #[cfg(any(target_os = "illumos", target_os = "solaris"))]
   200|         use libc::{B153600, B307200, B460800, B921600};
   201|         match s {
   202|             B0 => Ok(BaudRate::B0),
   203|             B50 => Ok(BaudRate::B50),
   204|             B75 => Ok(BaudRate::B75),
   205|             B110 => Ok(BaudRate::B110),
   206|             B134 => Ok(BaudRate::B134),
   207|             B150 => Ok(BaudRate::B150),
   208|             B200 => Ok(BaudRate::B200),
   209|             B300 => Ok(BaudRate::B300),
   210|             B600 => Ok(BaudRate::B600),
   211|             B1200 => Ok(BaudRate::B1200),
   212|             B1800 => Ok(BaudRate::B1800),
   213|             B2400 => Ok(BaudRate::B2400),
   214|             B4800 => Ok(BaudRate::B4800),
   215|             #[cfg(any(target_os = "dragonfly",
   216|                       target_os = "freebsd",
   217|                       target_os = "macos",
   218|                       target_os = "netbsd",
   219|                       target_os = "openbsd"))]
   220|             B7200 => Ok(BaudRate::B7200),
   221|             B9600 => Ok(BaudRate::B9600),
   222|             #[cfg(any(target_os = "dragonfly",
   223|                       target_os = "freebsd",
   224|                       target_os = "macos",
   225|                       target_os = "netbsd",
   226|                       target_os = "openbsd"))]
   227|             B14400 => Ok(BaudRate::B14400),
   228|             B19200 => Ok(BaudRate::B19200),
   229|             #[cfg(any(target_os = "dragonfly",
   230|                       target_os = "freebsd",
   231|                       target_os = "macos",
   232|                       target_os = "netbsd",
   233|                       target_os = "openbsd"))]
   234|             B28800 => Ok(BaudRate::B28800),
   235|             B38400 => Ok(BaudRate::B38400),
   236|             B57600 => Ok(BaudRate::B57600),
   237|             #[cfg(any(target_os = "dragonfly",
   238|                       target_os = "freebsd",
   239|                       target_os = "macos",
   240|                       target_os = "netbsd",
   241|                       target_os = "openbsd"))]
   242|             B76800 => Ok(BaudRate::B76800),
   243|             B115200 => Ok(BaudRate::B115200),
   244|             #[cfg(any(target_os = "illumos",
   245|                       target_os = "solaris"))]
   246|             B153600 => Ok(BaudRate::B153600),
   247|             B230400 => Ok(BaudRate::B230400),
   248|             #[cfg(any(target_os = "illumos",
   249|                       target_os = "solaris"))]
   250|             B307200 => Ok(BaudRate::B307200),
   251|             #[cfg(any(target_os = "android",
   252|                       target_os = "freebsd",
   253|                       target_os = "illumos",
   254|                       target_os = "linux",
   255|                       target_os = "netbsd",
   256|                       target_os = "solaris"))]
   257|             B460800 => Ok(BaudRate::B460800),
   258|             #[cfg(any(target_os = "android", target_os = "linux"))]
   259|             B500000 => Ok(BaudRate::B500000),
   260|             #[cfg(any(target_os = "android", target_os = "linux"))]
   261|             B576000 => Ok(BaudRate::B576000),
   262|             #[cfg(any(target_os = "android",
   263|                       target_os = "freebsd",
   264|                       target_os = "illumos",
   265|                       target_os = "linux",
   266|                       target_os = "netbsd",
   267|                       target_os = "solaris"))]
   268|             B921600 => Ok(BaudRate::B921600),
   269|             #[cfg(any(target_os = "android", target_os = "linux"))]
   270|             B1000000 => Ok(BaudRate::B1000000),
   271|             #[cfg(any(target_os = "android", target_os = "linux"))]
   272|             B1152000 => Ok(BaudRate::B1152000),
   273|             #[cfg(any(target_os = "android", target_os = "linux"))]
   274|             B1500000 => Ok(BaudRate::B1500000),
   275|             #[cfg(any(target_os = "android", target_os = "linux"))]
   276|             B2000000 => Ok(BaudRate::B2000000),
   277|             #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   278|             B2500000 => Ok(BaudRate::B2500000),
   279|             #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   280|             B3000000 => Ok(BaudRate::B3000000),
   281|             #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   282|             B3500000 => Ok(BaudRate::B3500000),
   283|             #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
   284|             B4000000 => Ok(BaudRate::B4000000),
   285|             _ => Err(Error::from(Errno::EINVAL))
   286|         }
   287|     }
   288| }
   289| #[cfg(any(target_os = "freebsd",
   290|           target_os = "dragonfly",
   291|           target_os = "ios",
   292|           target_os = "macos",
   293|           target_os = "netbsd",
   294|           target_os = "openbsd"))]
   295| impl From<BaudRate> for u32 {
   296|     fn from(b: BaudRate) -> u32 {
   297|         b as u32
   298|     }
   299| }
   300| libc_enum! {
   301|     #[repr(i32)]
   302|     pub enum SetArg {
   303|         TCSANOW,
   304|         TCSADRAIN,
   305|         TCSAFLUSH,
   306|     }
   307| }
   308| libc_enum! {
   309|     #[repr(i32)]
   310|     pub enum FlushArg {
   311|         TCIFLUSH,
   312|         TCOFLUSH,
   313|         TCIOFLUSH,
   314|     }
   315| }
   316| libc_enum! {
   317|     #[repr(i32)]
   318|     pub enum FlowArg {
   319|         TCOOFF,
   320|         TCOON,
   321|         TCIOFF,
   322|         TCION,
   323|     }
   324| }
   325| libc_enum! {
   326|     #[repr(usize)]
   327|     pub enum SpecialCharacterIndices {
   328|         VDISCARD,
   329|         #[cfg(any(target_os = "dragonfly",
   330|                 target_os = "freebsd",
   331|                 target_os = "illumos",
   332|                 target_os = "macos",
   333|                 target_os = "netbsd",
   334|                 target_os = "openbsd",
   335|                 target_os = "solaris"))]
   336|         VDSUSP,
   337|         VEOF,
   338|         VEOL,
   339|         VEOL2,
   340|         VERASE,
   341|         #[cfg(any(target_os = "dragonfly",
   342|                   target_os = "freebsd",
   343|                   target_os = "illumos",
   344|                   target_os = "solaris"))]
   345|         VERASE2,
   346|         VINTR,
   347|         VKILL,
   348|         VLNEXT,
   349|         #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
   350|                 target_os = "illumos", target_os = "solaris")))]
   351|         VMIN,
   352|         VQUIT,
   353|         VREPRINT,
   354|         VSTART,
   355|         #[cfg(any(target_os = "dragonfly",
   356|                 target_os = "freebsd",
   357|                 target_os = "illumos",
   358|                 target_os = "macos",
   359|                 target_os = "netbsd",
   360|                 target_os = "openbsd",
   361|                 target_os = "solaris"))]
   362|         VSTATUS,
   363|         VSTOP,
   364|         VSUSP,
   365|         #[cfg(target_os = "linux")]
   366|         VSWTC,
   367|         #[cfg(any(target_os = "haiku", target_os = "illumos", target_os = "solaris"))]
   368|         VSWTCH,
   369|         #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
   370|                 target_os = "illumos", target_os = "solaris")))]
   371|         VTIME,
   372|         VWERASE,
   373|         #[cfg(target_os = "dragonfly")]
   374|         VCHECKPT,
   375|     }
   376| }
   377| #[cfg(any(all(target_os = "linux", target_arch = "sparc64"),
   378|         target_os = "illumos", target_os = "solaris"))]
   379| impl SpecialCharacterIndices {
   380|     pub const VMIN: SpecialCharacterIndices = SpecialCharacterIndices::VEOF;
   381|     pub const VTIME: SpecialCharacterIndices = SpecialCharacterIndices::VEOL;
   382| }
   383| pub use libc::NCCS;
   384| #[cfg(any(target_os = "dragonfly",
   385|           target_os = "freebsd",
   386|           target_os = "linux",
   387|           target_os = "macos",
   388|           target_os = "netbsd",
   389|           target_os = "openbsd"))]
   390| pub use libc::_POSIX_VDISABLE;
   391| libc_bitflags! {
   392|     pub struct InputFlags: tcflag_t {
   393|         IGNBRK;
   394|         BRKINT;
   395|         IGNPAR;
   396|         PARMRK;
   397|         INPCK;
   398|         ISTRIP;
   399|         INLCR;
   400|         IGNCR;
   401|         ICRNL;
   402|         IXON;
   403|         IXOFF;
   404|         IXANY;
   405|         IMAXBEL;
   406|         #[cfg(any(target_os = "android", target_os = "linux", target_os = "macos"))]
   407|         IUTF8;
   408|     }
   409| }
   410| libc_bitflags! {
   411|     pub struct OutputFlags: tcflag_t {
   412|         OPOST;
   413|         #[cfg(any(target_os = "android",
   414|                   target_os = "haiku",
   415|                   target_os = "linux",
   416|                   target_os = "openbsd"))]
   417|         OLCUC;
   418|         ONLCR;
   419|         OCRNL as tcflag_t;
   420|         ONOCR as tcflag_t;
   421|         ONLRET as tcflag_t;
   422|         #[cfg(any(target_os = "android",
   423|                   target_os = "haiku",
   424|                   target_os = "ios",
   425|                   target_os = "linux",
   426|                   target_os = "macos"))]
   427|         OFILL as tcflag_t;
   428|         #[cfg(any(target_os = "android",
   429|                   target_os = "haiku",
   430|                   target_os = "ios",
   431|                   target_os = "linux",
   432|                   target_os = "macos"))]
   433|         OFDEL as tcflag_t;
   434|         #[cfg(any(target_os = "android",
   435|                   target_os = "haiku",
   436|                   target_os = "ios",
   437|                   target_os = "linux",
   438|                   target_os = "macos"))]
   439|         NL0 as tcflag_t;
   440|         #[cfg(any(target_os = "android",
   441|                   target_os = "haiku",
   442|                   target_os = "ios",
   443|                   target_os = "linux",
   444|                   target_os = "macos"))]
   445|         NL1 as tcflag_t;
   446|         #[cfg(any(target_os = "android",
   447|                   target_os = "haiku",
   448|                   target_os = "ios",
   449|                   target_os = "linux",
   450|                   target_os = "macos"))]
   451|         CR0 as tcflag_t;
   452|         #[cfg(any(target_os = "android",
   453|                   target_os = "haiku",
   454|                   target_os = "ios",
   455|                   target_os = "linux",
   456|                   target_os = "macos"))]
   457|         CR1 as tcflag_t;
   458|         #[cfg(any(target_os = "android",
   459|                   target_os = "haiku",
   460|                   target_os = "ios",
   461|                   target_os = "linux",
   462|                   target_os = "macos"))]
   463|         CR2 as tcflag_t;
   464|         #[cfg(any(target_os = "android",
   465|                   target_os = "haiku",
   466|                   target_os = "ios",
   467|                   target_os = "linux",
   468|                   target_os = "macos"))]
   469|         CR3 as tcflag_t;
   470|         #[cfg(any(target_os = "android",
   471|                   target_os = "freebsd",
   472|                   target_os = "haiku",
   473|                   target_os = "ios",
   474|                   target_os = "linux",
   475|                   target_os = "macos"))]
   476|         TAB0 as tcflag_t;
   477|         #[cfg(any(target_os = "android",
   478|                   target_os = "haiku",
   479|                   target_os = "ios",
   480|                   target_os = "linux",
   481|                   target_os = "macos"))]
   482|         TAB1 as tcflag_t;
   483|         #[cfg(any(target_os = "android",
   484|                   target_os = "haiku",
   485|                   target_os = "ios",
   486|                   target_os = "linux",
   487|                   target_os = "macos"))]
   488|         TAB2 as tcflag_t;
   489|         #[cfg(any(target_os = "android",
   490|                   target_os = "freebsd",
   491|                   target_os = "haiku",
   492|                   target_os = "ios",
   493|                   target_os = "linux",
   494|                   target_os = "macos"))]
   495|         TAB3 as tcflag_t;
   496|         #[cfg(any(target_os = "android", target_os = "linux"))]
   497|         XTABS;
   498|         #[cfg(any(target_os = "android",
   499|                   target_os = "haiku",
   500|                   target_os = "ios",
   501|                   target_os = "linux",
   502|                   target_os = "macos"))]
   503|         BS0 as tcflag_t;
   504|         #[cfg(any(target_os = "android",
   505|                   target_os = "haiku",
   506|                   target_os = "ios",
   507|                   target_os = "linux",
   508|                   target_os = "macos"))]
   509|         BS1 as tcflag_t;
   510|         #[cfg(any(target_os = "android",
   511|                   target_os = "haiku",
   512|                   target_os = "ios",
   513|                   target_os = "linux",
   514|                   target_os = "macos"))]
   515|         VT0 as tcflag_t;
   516|         #[cfg(any(target_os = "android",
   517|                   target_os = "haiku",
   518|                   target_os = "ios",
   519|                   target_os = "linux",
   520|                   target_os = "macos"))]
   521|         VT1 as tcflag_t;
   522|         #[cfg(any(target_os = "android",
   523|                   target_os = "haiku",
   524|                   target_os = "ios",
   525|                   target_os = "linux",
   526|                   target_os = "macos"))]
   527|         FF0 as tcflag_t;
   528|         #[cfg(any(target_os = "android",
   529|                   target_os = "haiku",
   530|                   target_os = "ios",
   531|                   target_os = "linux",
   532|                   target_os = "macos"))]
   533|         FF1 as tcflag_t;
   534|         #[cfg(any(target_os = "freebsd",
   535|                   target_os = "dragonfly",
   536|                   target_os = "ios",
   537|                   target_os = "macos",
   538|                   target_os = "netbsd",
   539|                   target_os = "openbsd"))]
   540|         OXTABS;
   541|         #[cfg(any(target_os = "freebsd",
   542|                   target_os = "dragonfly",
   543|                   target_os = "macos",
   544|                   target_os = "netbsd",
   545|                   target_os = "openbsd"))]
   546|         ONOEOT as tcflag_t;
   547|         #[cfg(any(target_os = "android",
   548|                   target_os = "haiku",
   549|                   target_os = "ios",
   550|                   target_os = "linux",
   551|                   target_os = "macos"))]
   552|         NLDLY as tcflag_t; // FIXME: Datatype needs to be corrected in libc for mac
   553|         #[cfg(any(target_os = "android",
   554|                   target_os = "haiku",
   555|                   target_os = "ios",
   556|                   target_os = "linux",
   557|                   target_os = "macos"))]
   558|         CRDLY as tcflag_t;
   559|         #[cfg(any(target_os = "android",
   560|                   target_os = "freebsd",
   561|                   target_os = "haiku",
   562|                   target_os = "ios",
   563|                   target_os = "linux",
   564|                   target_os = "macos"))]
   565|         TABDLY as tcflag_t;
   566|         #[cfg(any(target_os = "android",
   567|                   target_os = "haiku",
   568|                   target_os = "ios",
   569|                   target_os = "linux",
   570|                   target_os = "macos"))]
   571|         BSDLY as tcflag_t;
   572|         #[cfg(any(target_os = "android",
   573|                   target_os = "haiku",
   574|                   target_os = "ios",
   575|                   target_os = "linux",
   576|                   target_os = "macos"))]
   577|         VTDLY as tcflag_t;
   578|         #[cfg(any(target_os = "android",
   579|                   target_os = "haiku",
   580|                   target_os = "ios",
   581|                   target_os = "linux",
   582|                   target_os = "macos"))]
   583|         FFDLY as tcflag_t;
   584|     }
   585| }
   586| libc_bitflags! {
   587|     pub struct ControlFlags: tcflag_t {
   588|         #[cfg(any(target_os = "dragonfly",
   589|                   target_os = "freebsd",
   590|                   target_os = "ios",
   591|                   target_os = "macos",
   592|                   target_os = "netbsd",
   593|                   target_os = "openbsd"))]
   594|         CIGNORE;
   595|         CS5;
   596|         CS6;
   597|         CS7;
   598|         CS8;
   599|         CSTOPB;
   600|         CREAD;
   601|         PARENB;
   602|         PARODD;
   603|         HUPCL;
   604|         CLOCAL;
   605|         #[cfg(not(target_os = "redox"))]
   606|         CRTSCTS;
   607|         #[cfg(any(target_os = "android", target_os = "linux"))]
   608|         CBAUD;
   609|         #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "mips"))))]
   610|         CMSPAR;
   611|         #[cfg(any(target_os = "android",
   612|                   all(target_os = "linux",
   613|                       not(any(target_arch = "powerpc", target_arch = "powerpc64")))))]
   614|         CIBAUD;
   615|         #[cfg(any(target_os = "android", target_os = "linux"))]
   616|         CBAUDEX;
   617|         #[cfg(any(target_os = "dragonfly",
   618|                   target_os = "freebsd",
   619|                   target_os = "macos",
   620|                   target_os = "netbsd",
   621|                   target_os = "openbsd"))]
   622|         MDMBUF;
   623|         #[cfg(any(target_os = "netbsd", target_os = "openbsd"))]
   624|         CHWFLOW;
   625|         #[cfg(any(target_os = "dragonfly",
   626|                   target_os = "freebsd",
   627|                   target_os = "netbsd",
   628|                   target_os = "openbsd"))]
   629|         CCTS_OFLOW;
   630|         #[cfg(any(target_os = "dragonfly",
   631|                   target_os = "freebsd",
   632|                   target_os = "netbsd",
   633|                   target_os = "openbsd"))]
   634|         CRTS_IFLOW;
   635|         #[cfg(any(target_os = "dragonfly",
   636|                   target_os = "freebsd"))]
   637|         CDTR_IFLOW;
   638|         #[cfg(any(target_os = "dragonfly",
   639|                   target_os = "freebsd"))]
   640|         CDSR_OFLOW;
   641|         #[cfg(any(target_os = "dragonfly",
   642|                   target_os = "freebsd"))]
   643|         CCAR_OFLOW;
   644|         CSIZE;
   645|     }
   646| }
   647| libc_bitflags! {
   648|     pub struct LocalFlags: tcflag_t {
   649|         #[cfg(not(target_os = "redox"))]
   650|         ECHOKE;
   651|         ECHOE;
   652|         ECHOK;
   653|         ECHO;
   654|         ECHONL;
   655|         #[cfg(not(target_os = "redox"))]
   656|         ECHOPRT;
   657|         #[cfg(not(target_os = "redox"))]
   658|         ECHOCTL;
   659|         ISIG;
   660|         ICANON;
   661|         #[cfg(any(target_os = "freebsd",
   662|                   target_os = "dragonfly",
   663|                   target_os = "ios",
   664|                   target_os = "macos",
   665|                   target_os = "netbsd",
   666|                   target_os = "openbsd"))]
   667|         ALTWERASE;
   668|         IEXTEN;
   669|         #[cfg(not(target_os = "redox"))]
   670|         EXTPROC;
   671|         TOSTOP;
   672|         #[cfg(not(target_os = "redox"))]
   673|         FLUSHO;
   674|         #[cfg(any(target_os = "freebsd",
   675|                   target_os = "dragonfly",
   676|                   target_os = "ios",
   677|                   target_os = "macos",
   678|                   target_os = "netbsd",
   679|                   target_os = "openbsd"))]
   680|         NOKERNINFO;
   681|         #[cfg(not(target_os = "redox"))]
   682|         PENDIN;
   683|         NOFLSH;
   684|     }
   685| }
   686| cfg_if!{
   687|     if #[cfg(any(target_os = "freebsd",
   688|                  target_os = "dragonfly",
   689|                  target_os = "ios",
   690|                  target_os = "macos",
   691|                  target_os = "netbsd",
   692|                  target_os = "openbsd"))] {
   693|         pub fn cfgetispeed(termios: &Termios) -> u32 {
   694|             let inner_termios = termios.get_libc_termios();
   695|             unsafe { libc::cfgetispeed(&*inner_termios) as u32 }
   696|         }
   697|         pub fn cfgetospeed(termios: &Termios) -> u32 {
   698|             let inner_termios = termios.get_libc_termios();
   699|             unsafe { libc::cfgetospeed(&*inner_termios) as u32 }
   700|         }
   701|         pub fn cfsetispeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
   702|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   703|             let res = unsafe { libc::cfsetispeed(inner_termios, baud.into() as libc::speed_t) };
   704|             termios.update_wrapper();
   705|             Errno::result(res).map(drop)
   706|         }
   707|         pub fn cfsetospeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
   708|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   709|             let res = unsafe { libc::cfsetospeed(inner_termios, baud.into() as libc::speed_t) };
   710|             termios.update_wrapper();
   711|             Errno::result(res).map(drop)
   712|         }
   713|         pub fn cfsetspeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
   714|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   715|             let res = unsafe { libc::cfsetspeed(inner_termios, baud.into() as libc::speed_t) };
   716|             termios.update_wrapper();
   717|             Errno::result(res).map(drop)
   718|         }
   719|     } else {
   720|         use std::convert::TryInto;
   721|         pub fn cfgetispeed(termios: &Termios) -> BaudRate {
   722|             let inner_termios = termios.get_libc_termios();
   723|             unsafe { libc::cfgetispeed(&*inner_termios) }.try_into().unwrap()
   724|         }
   725|         pub fn cfgetospeed(termios: &Termios) -> BaudRate {
   726|             let inner_termios = termios.get_libc_termios();
   727|             unsafe { libc::cfgetospeed(&*inner_termios) }.try_into().unwrap()
   728|         }
   729|         pub fn cfsetispeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
   730|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   731|             let res = unsafe { libc::cfsetispeed(inner_termios, baud as libc::speed_t) };
   732|             termios.update_wrapper();
   733|             Errno::result(res).map(drop)
   734|         }
   735|         pub fn cfsetospeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
   736|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   737|             let res = unsafe { libc::cfsetospeed(inner_termios, baud as libc::speed_t) };
   738|             termios.update_wrapper();
   739|             Errno::result(res).map(drop)
   740|         }
   741|         pub fn cfsetspeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
   742|             let inner_termios = unsafe { termios.get_libc_termios_mut() };
   743|             let res = unsafe { libc::cfsetspeed(inner_termios, baud as libc::speed_t) };
   744|             termios.update_wrapper();
   745|             Errno::result(res).map(drop)
   746|         }
   747|     }
   748| }
   749| pub fn cfmakeraw(termios: &mut Termios) {
   750|     let inner_termios = unsafe { termios.get_libc_termios_mut() };
   751|     unsafe {
   752|         libc::cfmakeraw(inner_termios);
   753|     }
   754|     termios.update_wrapper();
   755| }
   756| #[cfg(target_os = "freebsd")]
   757| pub fn cfmakesane(termios: &mut Termios) {
   758|     let inner_termios = unsafe { termios.get_libc_termios_mut() };
   759|     unsafe {
   760|         libc::cfmakesane(inner_termios);
   761|     }
   762|     termios.update_wrapper();
   763| }
   764| pub fn tcgetattr(fd: RawFd) -> Result<Termios> {
   765|     let mut termios = mem::MaybeUninit::uninit();
   766|     let res = unsafe { libc::tcgetattr(fd, termios.as_mut_ptr()) };
   767|     Errno::result(res)?;
   768|     unsafe { Ok(termios.assume_init().into()) }
   769| }
   770| pub fn tcsetattr(fd: RawFd, actions: SetArg, termios: &Termios) -> Result<()> {
   771|     let inner_termios = termios.get_libc_termios();
   772|     Errno::result(unsafe { libc::tcsetattr(fd, actions as c_int, &*inner_termios) }).map(drop)
   773| }
   774| pub fn tcdrain(fd: RawFd) -> Result<()> {
   775|     Errno::result(unsafe { libc::tcdrain(fd) }).map(drop)
   776| }
   777| pub fn tcflow(fd: RawFd, action: FlowArg) -> Result<()> {
   778|     Errno::result(unsafe { libc::tcflow(fd, action as c_int) }).map(drop)
   779| }
   780| pub fn tcflush(fd: RawFd, action: FlushArg) -> Result<()> {
   781|     Errno::result(unsafe { libc::tcflush(fd, action as c_int) }).map(drop)
   782| }
   783| pub fn tcsendbreak(fd: RawFd, duration: c_int) -> Result<()> {
   784|     Errno::result(unsafe { libc::tcsendbreak(fd, duration) }).map(drop)
   785| }
   786| pub fn tcgetsid(fd: RawFd) -> Result<Pid> {
   787|     let res = unsafe { libc::tcgetsid(fd) };
   788|     Errno::result(res).map(Pid::from_raw)
   789| }
   790| #[cfg(test)]
   791| mod test {
   792|     use super::*;
   793|     #[test]
   794|     fn try_from() {
   795|         assert_eq!(Ok(BaudRate::B0), BaudRate::try_from(libc::B0));
   796|         assert!(BaudRate::try_from(999999999).is_err());
   797|     }
   798| }


# ====================================================================
# FILE: src/sys/timerfd.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-182 ---
     1| use crate::sys::time::TimeSpec;
     2| use crate::unistd::read;
     3| use crate::{errno::Errno, Result};
     4| use bitflags::bitflags;
     5| use libc::c_int;
     6| use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};
     7| #[derive(Debug)]
     8| pub struct TimerFd {
     9|     fd: RawFd,
    10| }
    11| impl AsRawFd for TimerFd {
    12|     fn as_raw_fd(&self) -> RawFd {
    13|         self.fd
    14|     }
    15| }
    16| impl FromRawFd for TimerFd {
    17|     unsafe fn from_raw_fd(fd: RawFd) -> Self {
    18|         TimerFd { fd }
    19|     }
    20| }
    21| libc_enum! {
    22|     #[repr(i32)]
    23|     pub enum ClockId {
    24|         CLOCK_REALTIME,
    25|         CLOCK_MONOTONIC,
    26|         CLOCK_BOOTTIME,
    27|         CLOCK_REALTIME_ALARM,
    28|         CLOCK_BOOTTIME_ALARM,
    29|     }
    30| }
    31| libc_bitflags! {
    32|     pub struct TimerFlags: c_int {
    33|         TFD_NONBLOCK;
    34|         TFD_CLOEXEC;
    35|     }
    36| }
    37| bitflags! {
    38|     pub struct TimerSetTimeFlags: libc::c_int {
    39|         const TFD_TIMER_ABSTIME = libc::TFD_TIMER_ABSTIME;
    40|     }
    41| }
    42| #[derive(Debug, Clone, Copy)]
    43| struct TimerSpec(libc::itimerspec);
    44| impl TimerSpec {
    45|     pub fn none() -> Self {
    46|         Self(libc::itimerspec {
    47|             it_interval: libc::timespec {
    48|                 tv_sec: 0,
    49|                 tv_nsec: 0,
    50|             },
    51|             it_value: libc::timespec {
    52|                 tv_sec: 0,
    53|                 tv_nsec: 0,
    54|             },
    55|         })
    56|     }
    57| }
    58| impl AsRef<libc::itimerspec> for TimerSpec {
    59|     fn as_ref(&self) -> &libc::itimerspec {
    60|         &self.0
    61|     }
    62| }
    63| impl From<Expiration> for TimerSpec {
    64|     fn from(expiration: Expiration) -> TimerSpec {
    65|         match expiration {
    66|             Expiration::OneShot(t) => TimerSpec(libc::itimerspec {
    67|                 it_interval: libc::timespec {
    68|                     tv_sec: 0,
    69|                     tv_nsec: 0,
    70|                 },
    71|                 it_value: *t.as_ref(),
    72|             }),
    73|             Expiration::IntervalDelayed(start, interval) => TimerSpec(libc::itimerspec {
    74|                 it_interval: *interval.as_ref(),
    75|                 it_value: *start.as_ref(),
    76|             }),
    77|             Expiration::Interval(t) => TimerSpec(libc::itimerspec {
    78|                 it_interval: *t.as_ref(),
    79|                 it_value: *t.as_ref(),
    80|             }),
    81|         }
    82|     }
    83| }
    84| impl From<TimerSpec> for Expiration {
    85|     fn from(timerspec: TimerSpec) -> Expiration {
    86|         match timerspec {
    87|             TimerSpec(libc::itimerspec {
    88|                 it_interval:
    89|                     libc::timespec {
    90|                         tv_sec: 0,
    91|                         tv_nsec: 0,
    92|                     },
    93|                 it_value: ts,
    94|             }) => Expiration::OneShot(ts.into()),
    95|             TimerSpec(libc::itimerspec {
    96|                 it_interval: int_ts,
    97|                 it_value: val_ts,
    98|             }) => {
    99|                 if (int_ts.tv_sec == val_ts.tv_sec) && (int_ts.tv_nsec == val_ts.tv_nsec) {
   100|                     Expiration::Interval(int_ts.into())
   101|                 } else {
   102|                     Expiration::IntervalDelayed(val_ts.into(), int_ts.into())
   103|                 }
   104|             }
   105|         }
   106|     }
   107| }
   108| #[derive(Debug, Clone, Copy, PartialEq)]
   109| pub enum Expiration {
   110|     OneShot(TimeSpec),
   111|     IntervalDelayed(TimeSpec, TimeSpec),
   112|     Interval(TimeSpec),
   113| }
   114| impl TimerFd {
   115|     pub fn new(clockid: ClockId, flags: TimerFlags) -> Result<Self> {
   116|         Errno::result(unsafe { libc::timerfd_create(clockid as i32, flags.bits()) })
   117|             .map(|fd| Self { fd })
   118|     }
   119|     pub fn set(&self, expiration: Expiration, flags: TimerSetTimeFlags) -> Result<()> {
   120|         let timerspec: TimerSpec = expiration.into();
   121|         Errno::result(unsafe {
   122|             libc::timerfd_settime(
   123|                 self.fd,
   124|                 flags.bits(),
   125|                 timerspec.as_ref(),
   126|                 std::ptr::null_mut(),
   127|             )
   128|         })
   129|         .map(drop)
   130|     }
   131|     pub fn get(&self) -> Result<Option<Expiration>> {
   132|         let mut timerspec = TimerSpec::none();
   133|         let timerspec_ptr: *mut libc::itimerspec = &mut timerspec.0;
   134|         Errno::result(unsafe { libc::timerfd_gettime(self.fd, timerspec_ptr) }).map(|_| {
   135|             if timerspec.0.it_interval.tv_sec == 0
   136|                 && timerspec.0.it_interval.tv_nsec == 0
   137|                 && timerspec.0.it_value.tv_sec == 0
   138|                 && timerspec.0.it_value.tv_nsec == 0
   139|             {
   140|                 None
   141|             } else {
   142|                 Some(timerspec.into())
   143|             }
   144|         })
   145|     }
   146|     pub fn unset(&self) -> Result<()> {
   147|         Errno::result(unsafe {
   148|             libc::timerfd_settime(
   149|                 self.fd,
   150|                 TimerSetTimeFlags::empty().bits(),
   151|                 TimerSpec::none().as_ref(),
   152|                 std::ptr::null_mut(),
   153|             )
   154|         })
   155|         .map(drop)
   156|     }
   157|     pub fn wait(&self) -> Result<()> {
   158|         loop {
   159|             if let Err(e) = read(self.fd, &mut [0u8; 8]) {
   160|                 match e {
   161|                     Errno::EINTR => continue,
   162|                     _ => return Err(e),
   163|                 }
   164|             } else {
   165|                 break;
   166|             }
   167|         }
   168|         Ok(())
   169|     }
   170| }
   171| impl Drop for TimerFd {
   172|     fn drop(&mut self) {
   173|         if !std::thread::panicking() {
   174|             let result = Errno::result(unsafe {
   175|                 libc::close(self.fd)
   176|             });
   177|             if let Err(Errno::EBADF) = result {
   178|                 panic!("close of TimerFd encountered EBADF");
   179|             }
   180|         }
   181|     }
   182| }


# ====================================================================
# FILE: src/sys/uio.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-122 ---
     1| #![allow(improper_ctypes)]
     2| use crate::Result;
     3| use crate::errno::Errno;
     4| use libc::{self, c_int, c_void, size_t, off_t};
     5| use std::marker::PhantomData;
     6| use std::os::unix::io::RawFd;
     7| pub fn writev(fd: RawFd, iov: &[IoVec<&[u8]>]) -> Result<usize> {
     8|     let res = unsafe { libc::writev(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
     9|     Errno::result(res).map(|r| r as usize)
    10| }
    11| pub fn readv(fd: RawFd, iov: &mut [IoVec<&mut [u8]>]) -> Result<usize> {
    12|     let res = unsafe { libc::readv(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
    13|     Errno::result(res).map(|r| r as usize)
    14| }
    15| #[cfg(any(target_os = "dragonfly",
    16|           target_os = "freebsd",
    17|           target_os = "linux",
    18|           target_os = "netbsd",
    19|           target_os = "openbsd"))]
    20| pub fn pwritev(fd: RawFd, iov: &[IoVec<&[u8]>],
    21|                offset: off_t) -> Result<usize> {
    22|     let res = unsafe {
    23|         libc::pwritev(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int, offset)
    24|     };
    25|     Errno::result(res).map(|r| r as usize)
    26| }
    27| #[cfg(any(target_os = "dragonfly",
    28|           target_os = "freebsd",
    29|           target_os = "linux",
    30|           target_os = "netbsd",
    31|           target_os = "openbsd"))]
    32| pub fn preadv(fd: RawFd, iov: &[IoVec<&mut [u8]>],
    33|               offset: off_t) -> Result<usize> {
    34|     let res = unsafe {
    35|         libc::preadv(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int, offset)
    36|     };
    37|     Errno::result(res).map(|r| r as usize)
    38| }
    39| pub fn pwrite(fd: RawFd, buf: &[u8], offset: off_t) -> Result<usize> {
    40|     let res = unsafe {
    41|         libc::pwrite(fd, buf.as_ptr() as *const c_void, buf.len() as size_t,
    42|                     offset)
    43|     };
    44|     Errno::result(res).map(|r| r as usize)
    45| }
    46| pub fn pread(fd: RawFd, buf: &mut [u8], offset: off_t) -> Result<usize>{
    47|     let res = unsafe {
    48|         libc::pread(fd, buf.as_mut_ptr() as *mut c_void, buf.len() as size_t,
    49|                    offset)
    50|     };
    51|     Errno::result(res).map(|r| r as usize)
    52| }
    53| #[cfg(target_os = "linux")]
    54| #[repr(C)]
    55| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    56| pub struct RemoteIoVec {
    57|     pub base: usize,
    58|     pub len: usize,
    59| }
    60| #[cfg(target_os = "linux")]
    61| pub fn process_vm_writev(
    62|     pid: crate::unistd::Pid,
    63|     local_iov: &[IoVec<&[u8]>],
    64|     remote_iov: &[RemoteIoVec]) -> Result<usize>
    65| {
    66|     let res = unsafe {
    67|         libc::process_vm_writev(pid.into(),
    68|                                 local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
    69|                                 remote_iov.as_ptr() as *const libc::iovec, remote_iov.len() as libc::c_ulong, 0)
    70|     };
    71|     Errno::result(res).map(|r| r as usize)
    72| }
    73| #[cfg(any(target_os = "linux"))]
    74| pub fn process_vm_readv(
    75|     pid: crate::unistd::Pid,
    76|     local_iov: &[IoVec<&mut [u8]>],
    77|     remote_iov: &[RemoteIoVec]) -> Result<usize>
    78| {
    79|     let res = unsafe {
    80|         libc::process_vm_readv(pid.into(),
    81|                                local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
    82|                                remote_iov.as_ptr() as *const libc::iovec, remote_iov.len() as libc::c_ulong, 0)
    83|     };
    84|     Errno::result(res).map(|r| r as usize)
    85| }
    86| #[repr(transparent)]
    87| #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
    88| pub struct IoVec<T>(pub(crate) libc::iovec, PhantomData<T>);
    89| impl<T> IoVec<T> {
    90|     #[inline]
    91|     pub fn as_slice(&self) -> &[u8] {
    92|         use std::slice;
    93|         unsafe {
    94|             slice::from_raw_parts(
    95|                 self.0.iov_base as *const u8,
    96|                 self.0.iov_len as usize)
    97|         }
    98|     }
    99| }
   100| impl<'a> IoVec<&'a [u8]> {
   101|     #[cfg(target_os = "freebsd")]
   102|     pub(crate) fn from_raw_parts(base: *mut c_void, len: usize) -> Self {
   103|         IoVec(libc::iovec {
   104|             iov_base: base,
   105|             iov_len: len
   106|         }, PhantomData)
   107|     }
   108|     pub fn from_slice(buf: &'a [u8]) -> IoVec<&'a [u8]> {
   109|         IoVec(libc::iovec {
   110|             iov_base: buf.as_ptr() as *mut c_void,
   111|             iov_len: buf.len() as size_t,
   112|         }, PhantomData)
   113|     }
   114| }
   115| impl<'a> IoVec<&'a mut [u8]> {
   116|     pub fn from_mut_slice(buf: &'a mut [u8]) -> IoVec<&'a mut [u8]> {
   117|         IoVec(libc::iovec {
   118|             iov_base: buf.as_ptr() as *mut c_void,
   119|             iov_len: buf.len() as size_t,
   120|         }, PhantomData)
   121|     }
   122| }


# ====================================================================
# FILE: src/time.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-227 ---
     1| use crate::sys::time::TimeSpec;
     2| #[cfg(any(
     3|     target_os = "freebsd",
     4|     target_os = "dragonfly",
     5|     target_os = "linux",
     6|     target_os = "android",
     7|     target_os = "emscripten",
     8| ))]
     9| use crate::{unistd::Pid, Error};
    10| use crate::{Errno, Result};
    11| use libc::{self, clockid_t};
    12| use std::mem::MaybeUninit;
    13| #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    14| pub struct ClockId(clockid_t);
    15| impl ClockId {
    16|     pub fn from_raw(clk_id: clockid_t) -> Self {
    17|         ClockId(clk_id)
    18|     }
    19|     #[cfg(any(
    20|         target_os = "freebsd",
    21|         target_os = "dragonfly",
    22|         target_os = "linux",
    23|         target_os = "android",
    24|         target_os = "emscripten",
    25|     ))]
    26|     pub fn pid_cpu_clock_id(pid: Pid) -> Result<Self> {
    27|         clock_getcpuclockid(pid)
    28|     }
    29|     #[cfg(not(target_os = "redox"))]
    30|     pub fn res(self) -> Result<TimeSpec> {
    31|         clock_getres(self)
    32|     }
    33|     pub fn now(self) -> Result<TimeSpec> {
    34|         clock_gettime(self)
    35|     }
    36|     #[cfg(not(any(
    37|         target_os = "macos",
    38|         target_os = "ios",
    39|         all(
    40|             not(any(target_env = "uclibc", target_env = "newlibc")),
    41|             any(target_os = "redox", target_os = "hermit",),
    42|         ),
    43|     )))]
    44|     pub fn set_time(self, timespec: TimeSpec) -> Result<()> {
    45|         clock_settime(self, timespec)
    46|     }
    47|     pub fn as_raw(self) -> clockid_t {
    48|         self.0
    49|     }
    50|     #[cfg(any(
    51|         target_os = "fuchsia",
    52|         all(
    53|             not(any(target_env = "uclibc", target_env = "newlib")),
    54|             any(target_os = "linux", target_os = "android", target_os = "emscripten"),
    55|         )
    56|     ))]
    57|     pub const CLOCK_BOOTTIME: ClockId = ClockId(libc::CLOCK_BOOTTIME);
    58|     #[cfg(any(
    59|         target_os = "fuchsia",
    60|         all(
    61|             not(any(target_env = "uclibc", target_env = "newlib")),
    62|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
    63|         )
    64|     ))]
    65|     pub const CLOCK_BOOTTIME_ALARM: ClockId = ClockId(libc::CLOCK_BOOTTIME_ALARM);
    66|     pub const CLOCK_MONOTONIC: ClockId = ClockId(libc::CLOCK_MONOTONIC);
    67|     #[cfg(any(
    68|         target_os = "fuchsia",
    69|         all(
    70|             not(any(target_env = "uclibc", target_env = "newlib")),
    71|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
    72|         )
    73|     ))]
    74|     pub const CLOCK_MONOTONIC_COARSE: ClockId = ClockId(libc::CLOCK_MONOTONIC_COARSE);
    75|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
    76|     pub const CLOCK_MONOTONIC_FAST: ClockId = ClockId(libc::CLOCK_MONOTONIC_FAST);
    77|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
    78|     pub const CLOCK_MONOTONIC_PRECISE: ClockId = ClockId(libc::CLOCK_MONOTONIC_PRECISE);
    79|     #[cfg(any(
    80|         target_os = "fuchsia",
    81|         all(
    82|             not(any(target_env = "uclibc", target_env = "newlib")),
    83|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
    84|         )
    85|     ))]
    86|     pub const CLOCK_MONOTONIC_RAW: ClockId = ClockId(libc::CLOCK_MONOTONIC_RAW);
    87|     #[cfg(any(
    88|         target_os = "fuchsia",
    89|         target_env = "uclibc",
    90|         target_os = "macos",
    91|         target_os = "ios",
    92|         target_os = "freebsd",
    93|         target_os = "dragonfly",
    94|         all(
    95|             not(target_env = "newlib"),
    96|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
    97|         )
    98|     ))]
    99|     pub const CLOCK_PROCESS_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_PROCESS_CPUTIME_ID);
   100|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   101|     pub const CLOCK_PROF: ClockId = ClockId(libc::CLOCK_PROF);
   102|     pub const CLOCK_REALTIME: ClockId = ClockId(libc::CLOCK_REALTIME);
   103|     #[cfg(any(
   104|         target_os = "fuchsia",
   105|         all(
   106|             not(any(target_env = "uclibc", target_env = "newlib")),
   107|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
   108|         )
   109|     ))]
   110|     pub const CLOCK_REALTIME_ALARM: ClockId = ClockId(libc::CLOCK_REALTIME_ALARM);
   111|     #[cfg(any(
   112|         target_os = "fuchsia",
   113|         all(
   114|             not(any(target_env = "uclibc", target_env = "newlib")),
   115|             any(target_os = "linux", target_os = "android", target_os = "emscripten")
   116|         )
   117|     ))]
   118|     pub const CLOCK_REALTIME_COARSE: ClockId = ClockId(libc::CLOCK_REALTIME_COARSE);
   119|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   120|     pub const CLOCK_REALTIME_FAST: ClockId = ClockId(libc::CLOCK_REALTIME_FAST);
   121|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   122|     pub const CLOCK_REALTIME_PRECISE: ClockId = ClockId(libc::CLOCK_REALTIME_PRECISE);
   123|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   124|     pub const CLOCK_SECOND: ClockId = ClockId(libc::CLOCK_SECOND);
   125|     #[cfg(any(
   126|         target_os = "fuchsia",
   127|         all(
   128|             not(any(target_env = "uclibc", target_env = "newlib")),
   129|             any(
   130|                 target_os = "emscripten",
   131|                 all(target_os = "linux", target_env = "musl")
   132|             )
   133|         )
   134|     ))]
   135|     pub const CLOCK_SGI_CYCLE: ClockId = ClockId(libc::CLOCK_SGI_CYCLE);
   136|     #[cfg(any(
   137|         target_os = "fuchsia",
   138|         all(
   139|             not(any(target_env = "uclibc", target_env = "newlib")),
   140|             any(
   141|                 target_os = "emscripten",
   142|                 all(target_os = "linux", target_env = "musl")
   143|             )
   144|         )
   145|     ))]
   146|     pub const CLOCK_TAI: ClockId = ClockId(libc::CLOCK_TAI);
   147|     #[cfg(any(
   148|         target_env = "uclibc",
   149|         target_os = "fuchsia",
   150|         target_os = "ios",
   151|         target_os = "macos",
   152|         target_os = "freebsd",
   153|         target_os = "dragonfly",
   154|         all(
   155|             not(target_env = "newlib"),
   156|             any(target_os = "linux", target_os = "android", target_os = "emscripten",),
   157|         ),
   158|     ))]
   159|     pub const CLOCK_THREAD_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_THREAD_CPUTIME_ID);
   160|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   161|     pub const CLOCK_UPTIME: ClockId = ClockId(libc::CLOCK_UPTIME);
   162|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   163|     pub const CLOCK_UPTIME_FAST: ClockId = ClockId(libc::CLOCK_UPTIME_FAST);
   164|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   165|     pub const CLOCK_UPTIME_PRECISE: ClockId = ClockId(libc::CLOCK_UPTIME_PRECISE);
   166|     #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
   167|     pub const CLOCK_VIRTUAL: ClockId = ClockId(libc::CLOCK_VIRTUAL);
   168| }
   169| impl From<ClockId> for clockid_t {
   170|     fn from(clock_id: ClockId) -> Self {
   171|         clock_id.as_raw()
   172|     }
   173| }
   174| impl From<clockid_t> for ClockId {
   175|     fn from(clk_id: clockid_t) -> Self {
   176|         ClockId::from_raw(clk_id)
   177|     }
   178| }
   179| impl std::fmt::Display for ClockId {
   180|     fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
   181|         std::fmt::Display::fmt(&self.0, f)
   182|     }
   183| }
   184| #[cfg(not(target_os = "redox"))]
   185| pub fn clock_getres(clock_id: ClockId) -> Result<TimeSpec> {
   186|     let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
   187|     let ret = unsafe { libc::clock_getres(clock_id.as_raw(), c_time.as_mut_ptr()) };
   188|     Errno::result(ret)?;
   189|     let res = unsafe { c_time.assume_init() };
   190|     Ok(TimeSpec::from(res))
   191| }
   192| pub fn clock_gettime(clock_id: ClockId) -> Result<TimeSpec> {
   193|     let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
   194|     let ret = unsafe { libc::clock_gettime(clock_id.as_raw(), c_time.as_mut_ptr()) };
   195|     Errno::result(ret)?;
   196|     let res = unsafe { c_time.assume_init() };
   197|     Ok(TimeSpec::from(res))
   198| }
   199| #[cfg(not(any(
   200|     target_os = "macos",
   201|     target_os = "ios",
   202|     all(
   203|         not(any(target_env = "uclibc", target_env = "newlibc")),
   204|         any(target_os = "redox", target_os = "hermit",),
   205|     ),
   206| )))]
   207| pub fn clock_settime(clock_id: ClockId, timespec: TimeSpec) -> Result<()> {
   208|     let ret = unsafe { libc::clock_settime(clock_id.as_raw(), timespec.as_ref()) };
   209|     Errno::result(ret).map(drop)
   210| }
   211| #[cfg(any(
   212|     target_os = "freebsd",
   213|     target_os = "dragonfly",
   214|     target_os = "linux",
   215|     target_os = "android",
   216|     target_os = "emscripten",
   217| ))]
   218| pub fn clock_getcpuclockid(pid: Pid) -> Result<ClockId> {
   219|     let mut clk_id: MaybeUninit<libc::clockid_t> = MaybeUninit::uninit();
   220|     let ret = unsafe { libc::clock_getcpuclockid(pid.into(), clk_id.as_mut_ptr()) };
   221|     if ret == 0 {
   222|         let res = unsafe { clk_id.assume_init() };
   223|         Ok(ClockId::from(res))
   224|     } else {
   225|         Err(Error::from(Errno::from_i32(ret)))
   226|     }
   227| }


# ====================================================================
# FILE: src/unistd.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 722-772 ---
   722|             type setgroups_ngroups_t = c_int;
   723|         } else {
   724|             type setgroups_ngroups_t = size_t;
   725|         }
   726|     }
   727|     let res = unsafe {
   728|         libc::setgroups(groups.len() as setgroups_ngroups_t, groups.as_ptr() as *const gid_t)
   729|     };
   730|     Errno::result(res).map(drop)
   731| }
   732| #[cfg(not(any(target_os = "illumos",
   733|               target_os = "ios",
   734|               target_os = "macos",
   735|               target_os = "redox")))]
   736| pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
   737|     let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {
   738|         Ok(Some(n)) => n as c_int,
   739|         Ok(None) | Err(_) => <c_int>::max_value(),
   740|     };
   741|     use std::cmp::min;
   742|     let mut ngroups = min(ngroups_max, 8);
   743|     let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);
   744|     cfg_if! {
   745|         if #[cfg(any(target_os = "ios", target_os = "macos"))] {
   746|             type getgrouplist_group_t = c_int;
   747|         } else {
   748|             type getgrouplist_group_t = gid_t;
   749|         }
   750|     }
   751|     let gid: gid_t = group.into();
   752|     loop {
   753|         let ret = unsafe {
   754|             libc::getgrouplist(user.as_ptr(),
   755|                                gid as getgrouplist_group_t,
   756|                                groups.as_mut_ptr() as *mut getgrouplist_group_t,
   757|                                &mut ngroups)
   758|         };
   759|         if ret >= 0 {
   760|             unsafe { groups.set_len(ngroups as usize) };
   761|             return Ok(groups);
   762|         } else if ret == -1 {
   763|             reserve_double_buffer_size(&mut groups, ngroups_max as usize)
   764|                 .map_err(|_| Error::from(Errno::EINVAL))?;
   765|         }
   766|     }
   767| }
   768| #[cfg(not(any(target_os = "ios", target_os = "macos", target_os = "redox")))]
   769| pub fn initgroups(user: &CStr, group: Gid) -> Result<()> {
   770|     cfg_if! {
   771|         if #[cfg(any(target_os = "ios", target_os = "macos"))] {
   772|             type initgroups_group_t = c_int;

