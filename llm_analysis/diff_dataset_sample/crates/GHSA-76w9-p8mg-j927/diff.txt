--- a//dev/null
+++ b/src/dir.rs
@@ -0,0 +1,159 @@
+use crate::{Error, NixPath, Result};
+use crate::errno::Errno;
+use crate::fcntl::{self, OFlag};
+use std::os::unix::io::{AsRawFd, IntoRawFd, RawFd};
+use std::ptr;
+use std::ffi;
+use crate::sys;
+#[cfg(target_os = "linux")]
+use libc::{dirent64 as dirent, readdir64_r as readdir_r};
+#[cfg(not(target_os = "linux"))]
+use libc::{dirent, readdir_r};
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct Dir(
+    ptr::NonNull<libc::DIR>
+);
+impl Dir {
+    pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag,
+                                     mode: sys::stat::Mode) -> Result<Self> {
+        let fd = fcntl::open(path, oflag, mode)?;
+        Dir::from_fd(fd)
+    }
+    pub fn openat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P, oflag: OFlag,
+                                       mode: sys::stat::Mode) -> Result<Self> {
+        let fd = fcntl::openat(dirfd, path, oflag, mode)?;
+        Dir::from_fd(fd)
+    }
+    #[inline]
+    pub fn from<F: IntoRawFd>(fd: F) -> Result<Self> {
+        Dir::from_fd(fd.into_raw_fd())
+    }
+    pub fn from_fd(fd: RawFd) -> Result<Self> {
+        let d = ptr::NonNull::new(unsafe { libc::fdopendir(fd) }).ok_or_else(|| {
+            let e = Error::last();
+            unsafe { libc::close(fd) };
+            e
+        })?;
+        Ok(Dir(d))
+    }
+    pub fn iter(&mut self) -> Iter {
+        Iter(self)
+    }
+}
+unsafe impl Send for Dir {}
+impl AsRawFd for Dir {
+    fn as_raw_fd(&self) -> RawFd {
+        unsafe { libc::dirfd(self.0.as_ptr()) }
+    }
+}
+impl Drop for Dir {
+    fn drop(&mut self) {
+        let e = Errno::result(unsafe { libc::closedir(self.0.as_ptr()) });
+        if !std::thread::panicking() && e == Err(Error::from(Errno::EBADF)) {
+            panic!("Closing an invalid file descriptor!");
+        };
+    }
+}
+fn next(dir: &mut Dir) -> Option<Result<Entry>> {
+    unsafe {
+        let mut ent = std::mem::MaybeUninit::<dirent>::uninit();
+        let mut result = ptr::null_mut();
+        if let Err(e) = Errno::result(
+            readdir_r(dir.0.as_ptr(), ent.as_mut_ptr(), &mut result))
+        {
+            return Some(Err(e));
+        }
+        if result.is_null() {
+            return None;
+        }
+        assert_eq!(result, ent.as_mut_ptr());
+        Some(Ok(Entry(ent.assume_init())))
+    }
+}
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct Iter<'d>(&'d mut Dir);
+impl<'d> Iterator for Iter<'d> {
+    type Item = Result<Entry>;
+    fn next(&mut self) -> Option<Self::Item> {
+        next(self.0)
+    }
+}
+impl<'d> Drop for Iter<'d> {
+    fn drop(&mut self) {
+        unsafe { libc::rewinddir((self.0).0.as_ptr()) }
+    }
+}
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct OwningIter(Dir);
+impl Iterator for OwningIter {
+    type Item = Result<Entry>;
+    fn next(&mut self) -> Option<Self::Item> {
+        next(&mut self.0)
+    }
+}
+impl IntoIterator for Dir {
+    type Item = Result<Entry>;
+    type IntoIter = OwningIter;
+    fn into_iter(self) -> Self::IntoIter {
+        OwningIter(self)
+    }
+}
+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
+#[repr(transparent)]
+pub struct Entry(dirent);
+#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
+pub enum Type {
+    Fifo,
+    CharacterDevice,
+    Directory,
+    BlockDevice,
+    File,
+    Symlink,
+    Socket,
+}
+impl Entry {
+    #[cfg(any(target_os = "android",
+              target_os = "emscripten",
+              target_os = "fuchsia",
+              target_os = "haiku",
+              target_os = "illumos",
+              target_os = "ios",
+              target_os = "l4re",
+              target_os = "linux",
+              target_os = "macos",
+              target_os = "solaris"))]
+    pub fn ino(&self) -> u64 {
+        self.0.d_ino as u64
+    }
+    #[cfg(not(any(target_os = "android",
+                  target_os = "emscripten",
+                  target_os = "fuchsia",
+                  target_os = "haiku",
+                  target_os = "illumos",
+                  target_os = "ios",
+                  target_os = "l4re",
+                  target_os = "linux",
+                  target_os = "macos",
+                  target_os = "solaris")))]
+    pub fn ino(&self) -> u64 {
+        u64::from(self.0.d_fileno)
+    }
+    pub fn file_name(&self) -> &ffi::CStr {
+        unsafe { ::std::ffi::CStr::from_ptr(self.0.d_name.as_ptr()) }
+    }
+    pub fn file_type(&self) -> Option<Type> {
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+        match self.0.d_type {
+            libc::DT_FIFO => Some(Type::Fifo),
+            libc::DT_CHR => Some(Type::CharacterDevice),
+            libc::DT_DIR => Some(Type::Directory),
+            libc::DT_BLK => Some(Type::BlockDevice),
+            libc::DT_REG => Some(Type::File),
+            libc::DT_LNK => Some(Type::Symlink),
+            libc::DT_SOCK => Some(Type::Socket),
+            /* libc::DT_UNKNOWN | */ _ => None,
+        }
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        None
+    }
+}

--- a//dev/null
+++ b/src/env.rs
@@ -0,0 +1,35 @@
+use cfg_if::cfg_if;
+use std::fmt;
+#[derive(Clone, Copy, Debug)]
+pub struct ClearEnvError;
+impl fmt::Display for ClearEnvError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "clearenv failed")
+    }
+}
+impl std::error::Error for ClearEnvError {}
+pub unsafe fn clearenv() -> std::result::Result<(), ClearEnvError> {
+    let ret;
+    cfg_if! {
+        if #[cfg(any(target_os = "fuchsia",
+                     target_os = "wasi",
+                     target_env = "wasi",
+                     target_env = "uclibc",
+                     target_os = "linux",
+                     target_os = "android",
+                     target_os = "emscripten"))] {
+            ret = libc::clearenv();
+        } else {
+            use std::env;
+            for (name, _) in env::vars_os() {
+                env::remove_var(name);
+            }
+            ret = 0;
+        }
+    }
+    if ret == 0 {
+        Ok(())
+    } else {
+        Err(ClearEnvError)
+    }
+}

--- a/src/errno.rs
+++ b/src/errno.rs
@@ -733,35 +733,20 @@
         EKEYEXPIRED     = libc::EKEYEXPIRED,
         EKEYREVOKED     = libc::EKEYREVOKED,
         EKEYREJECTED    = libc::EKEYREJECTED,
         EOWNERDEAD      = libc::EOWNERDEAD,
         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
         #[cfg(not(any(target_os = "android", target_arch="mips")))]
         ERFKILL         = libc::ERFKILL,
         #[cfg(not(any(target_os = "android", target_arch="mips")))]
         EHWPOISON       = libc::EHWPOISON,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EDEADLOCK instead"
-    )]
-    pub const EDEADLOCK:   Errno = Errno::EDEADLK;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ENOTSUP instead"
-    )]
-    pub const ENOTSUP:  Errno = Errno::EOPNOTSUPP;
     impl Errno {
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
         pub const ENOTSUP:     Errno = Errno::EOPNOTSUPP;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
@@ -1006,35 +991,20 @@
         ENOSR           = libc::ENOSR,
         ENOSTR          = libc::ENOSTR,
         EPROTO          = libc::EPROTO,
         ETIME           = libc::ETIME,
         EOPNOTSUPP      = libc::EOPNOTSUPP,
         ENOPOLICY       = libc::ENOPOLICY,
         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
         EOWNERDEAD      = libc::EOWNERDEAD,
         EQFULL          = libc::EQFULL,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST:  Errno = Errno::EQFULL;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EDEADLOCK instead"
-    )]
-    pub const EDEADLOCK:   Errno = Errno::EDEADLK;
     impl Errno {
         pub const ELAST: Errno       = Errno::EQFULL;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
@@ -1242,40 +1212,20 @@
         EDOOFUS         = libc::EDOOFUS,
         EBADMSG         = libc::EBADMSG,
         EMULTIHOP       = libc::EMULTIHOP,
         ENOLINK         = libc::ENOLINK,
         EPROTO          = libc::EPROTO,
         ENOTCAPABLE     = libc::ENOTCAPABLE,
         ECAPMODE        = libc::ECAPMODE,
         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
         EOWNERDEAD      = libc::EOWNERDEAD,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST: Errno       = Errno::EOWNERDEAD;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EDEADLOCK instead"
-    )]
-    pub const EDEADLOCK:   Errno = Errno::EDEADLK;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EOPNOTSUPP instead"
-    )]
-    pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
     impl Errno {
         pub const ELAST: Errno       = Errno::EOWNERDEAD;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
         pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
@@ -1472,40 +1422,20 @@
         EILSEQ          = libc::EILSEQ,
         ENOATTR         = libc::ENOATTR,
         EDOOFUS         = libc::EDOOFUS,
         EBADMSG         = libc::EBADMSG,
         EMULTIHOP       = libc::EMULTIHOP,
         ENOLINK         = libc::ENOLINK,
         EPROTO          = libc::EPROTO,
         ENOMEDIUM       = libc::ENOMEDIUM,
         EASYNC          = libc::EASYNC,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST: Errno       = Errno::EASYNC;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EDEADLOCK instead"
-    )]
-    pub const EDEADLOCK:   Errno = Errno::EDEADLK;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EOPNOTSUPP instead"
-    )]
-    pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
     impl Errno {
         pub const ELAST: Errno       = Errno::EASYNC;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
         pub const EDEADLOCK:   Errno = Errno::EDEADLK;
         pub const EOPNOTSUPP:  Errno = Errno::ENOTSUP;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
@@ -1701,30 +1631,20 @@
         EOVERFLOW       = libc::EOVERFLOW,
         ECANCELED       = libc::ECANCELED,
         EIDRM           = libc::EIDRM,
         ENOMSG          = libc::ENOMSG,
         ENOTSUP         = libc::ENOTSUP,
         EBADMSG         = libc::EBADMSG,
         ENOTRECOVERABLE = libc::ENOTRECOVERABLE,
         EOWNERDEAD      = libc::EOWNERDEAD,
         EPROTO          = libc::EPROTO,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST: Errno       = Errno::ENOTSUP;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     impl Errno {
         pub const ELAST: Errno       = Errno::ENOTSUP;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
             libc::ESRCH => ESRCH,
@@ -1920,30 +1840,20 @@
         EBADMSG         = libc::EBADMSG,
         ENODATA         = libc::ENODATA,
         ENOSR           = libc::ENOSR,
         ENOSTR          = libc::ENOSTR,
         ETIME           = libc::ETIME,
         ENOATTR         = libc::ENOATTR,
         EMULTIHOP       = libc::EMULTIHOP,
         ENOLINK         = libc::ENOLINK,
         EPROTO          = libc::EPROTO,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST: Errno       = Errno::ENOTSUP;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     impl Errno {
         pub const ELAST: Errno       = Errno::ENOTSUP;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
             libc::ESRCH => ESRCH,
@@ -2129,25 +2039,20 @@
         ECANCELED = libc::ECANCELED,
         EBADMSG = libc::EBADMSG,
         ENODATA = libc::ENODATA,
         ENOSR = libc::ENOSR,
         ENOSTR = libc::ENOSTR,
         ETIME = libc::ETIME,
         EMULTIHOP = libc::EMULTIHOP,
         ENOLINK = libc::ENOLINK,
         EPROTO = libc::EPROTO,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     impl Errno {
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
             libc::ESRCH => ESRCH,
             libc::EINTR => EINTR,
@@ -2357,30 +2262,20 @@
         ESHUTDOWN = libc::ESHUTDOWN,
         ETOOMANYREFS = libc::ETOOMANYREFS,
         ETIMEDOUT = libc::ETIMEDOUT,
         ECONNREFUSED = libc::ECONNREFUSED,
         EHOSTDOWN = libc::EHOSTDOWN,
         EHOSTUNREACH = libc::EHOSTUNREACH,
         EALREADY = libc::EALREADY,
         EINPROGRESS = libc::EINPROGRESS,
         ESTALE = libc::ESTALE,
     }
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::ELAST instead"
-    )]
-    pub const ELAST: Errno = Errno::ELAST;
-    #[deprecated(
-        since = "0.22.1",
-        note = "use nix::errno::Errno::EWOULDBLOCK instead"
-    )]
-    pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     impl Errno {
         pub const ELAST: Errno       = Errno::ESTALE;
         pub const EWOULDBLOCK: Errno = Errno::EAGAIN;
     }
     pub fn from_i32(e: i32) -> Errno {
         use self::Errno::*;
         match e {
             libc::EPERM => EPERM,
             libc::ENOENT => ENOENT,
             libc::ESRCH => ESRCH,

--- a//dev/null
+++ b/src/fcntl.rs
@@ -0,0 +1,535 @@
+use crate::errno::Errno;
+use libc::{self, c_char, c_int, c_uint, size_t, ssize_t};
+use std::ffi::OsString;
+#[cfg(not(target_os = "redox"))]
+use std::os::raw;
+use std::os::unix::ffi::OsStringExt;
+use std::os::unix::io::RawFd;
+use crate::sys::stat::Mode;
+use crate::{NixPath, Result};
+#[cfg(any(target_os = "android", target_os = "linux"))]
+use std::ptr; // For splice and copy_file_range
+#[cfg(any(target_os = "android", target_os = "linux"))]
+use crate::sys::uio::IoVec; // For vmsplice
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_env = "uclibc",
+    target_os = "freebsd"
+))]
+pub use self::posix_fadvise::*;
+#[cfg(not(target_os = "redox"))]
+libc_bitflags! {
+    pub struct AtFlags: c_int {
+        AT_REMOVEDIR;
+        AT_SYMLINK_FOLLOW;
+        AT_SYMLINK_NOFOLLOW;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        AT_NO_AUTOMOUNT;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        AT_EMPTY_PATH;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        AT_EACCESS;
+    }
+}
+libc_bitflags!(
+    pub struct OFlag: c_int {
+        O_ACCMODE;
+        #[cfg(target_os = "netbsd")]
+        O_ALT_IO;
+        O_APPEND;
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+        O_ASYNC;
+        O_CLOEXEC;
+        O_CREAT;
+        #[cfg(any(target_os = "android",
+                  target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "linux",
+                  target_os = "netbsd"))]
+        O_DIRECT;
+        #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+        O_DIRECTORY;
+        #[cfg(any(target_os = "android",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        O_DSYNC;
+        O_EXCL;
+        #[cfg(target_os = "freebsd")]
+        O_EXEC;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "redox"))]
+        O_EXLOCK;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "ios",
+                  all(target_os = "linux", not(target_env = "musl")),
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "redox"))]
+        O_FSYNC;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        O_LARGEFILE;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        O_NOATIME;
+        #[cfg(not(target_os = "redox"))]
+        O_NOCTTY;
+        #[cfg(not(target_os = "redox"))]
+        O_NDELAY;
+        O_NOFOLLOW;
+        O_NONBLOCK;
+        #[cfg(target_os = "netbsd")]
+        O_NOSIGPIPE;
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "redox"))]
+        O_PATH;
+        O_RDONLY;
+        O_RDWR;
+        #[cfg(any(target_os = "linux", target_os = "netbsd", target_os = "openbsd"))]
+        O_RSYNC;
+        #[cfg(target_os = "netbsd")]
+        O_SEARCH;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "redox"))]
+        O_SHLOCK;
+        #[cfg(not(target_os = "redox"))]
+        O_SYNC;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        O_TMPFILE;
+        O_TRUNC;
+        #[cfg(target_os = "freebsd")]
+        O_TTY_INIT;
+        O_WRONLY;
+    }
+);
+#[allow(clippy::useless_conversion)]
+pub fn open<P: ?Sized + NixPath>(path: &P, oflag: OFlag, mode: Mode) -> Result<RawFd> {
+    let fd = path.with_nix_path(|cstr| {
+        unsafe { libc::open(cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
+    })?;
+    Errno::result(fd)
+}
+#[allow(clippy::useless_conversion)]
+#[cfg(not(target_os = "redox"))]
+pub fn openat<P: ?Sized + NixPath>(
+    dirfd: RawFd,
+    path: &P,
+    oflag: OFlag,
+    mode: Mode,
+) -> Result<RawFd> {
+    let fd = path.with_nix_path(|cstr| {
+        unsafe { libc::openat(dirfd, cstr.as_ptr(), oflag.bits(), mode.bits() as c_uint) }
+    })?;
+    Errno::result(fd)
+}
+#[cfg(not(target_os = "redox"))]
+pub fn renameat<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
+    old_dirfd: Option<RawFd>,
+    old_path: &P1,
+    new_dirfd: Option<RawFd>,
+    new_path: &P2,
+) -> Result<()> {
+    let res = old_path.with_nix_path(|old_cstr| {
+        new_path.with_nix_path(|new_cstr| unsafe {
+            libc::renameat(
+                at_rawfd(old_dirfd),
+                old_cstr.as_ptr(),
+                at_rawfd(new_dirfd),
+                new_cstr.as_ptr(),
+            )
+        })
+    })??;
+    Errno::result(res).map(drop)
+}
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+))]
+libc_bitflags! {
+    pub struct RenameFlags: u32 {
+        RENAME_EXCHANGE;
+        RENAME_NOREPLACE;
+        RENAME_WHITEOUT;
+    }
+}
+#[cfg(all(
+    target_os = "linux",
+    target_env = "gnu",
+))]
+pub fn renameat2<P1: ?Sized + NixPath, P2: ?Sized + NixPath>(
+    old_dirfd: Option<RawFd>,
+    old_path: &P1,
+    new_dirfd: Option<RawFd>,
+    new_path: &P2,
+    flags: RenameFlags,
+) -> Result<()> {
+    let res = old_path.with_nix_path(|old_cstr| {
+        new_path.with_nix_path(|new_cstr| unsafe {
+            libc::renameat2(
+                at_rawfd(old_dirfd),
+                old_cstr.as_ptr(),
+                at_rawfd(new_dirfd),
+                new_cstr.as_ptr(),
+                flags.bits(),
+            )
+        })
+    })??;
+    Errno::result(res).map(drop)
+}
+fn wrap_readlink_result(mut v: Vec<u8>, len: ssize_t) -> Result<OsString> {
+    unsafe { v.set_len(len as usize) }
+    v.shrink_to_fit();
+    Ok(OsString::from_vec(v.to_vec()))
+}
+fn readlink_maybe_at<P: ?Sized + NixPath>(
+    dirfd: Option<RawFd>,
+    path: &P,
+    v: &mut Vec<u8>,
+) -> Result<libc::ssize_t> {
+    path.with_nix_path(|cstr| unsafe {
+        match dirfd {
+            #[cfg(target_os = "redox")]
+            Some(_) => unreachable!(),
+            #[cfg(not(target_os = "redox"))]
+            Some(dirfd) => libc::readlinkat(
+                dirfd,
+                cstr.as_ptr(),
+                v.as_mut_ptr() as *mut c_char,
+                v.capacity() as size_t,
+            ),
+            None => libc::readlink(
+                cstr.as_ptr(),
+                v.as_mut_ptr() as *mut c_char,
+                v.capacity() as size_t,
+            ),
+        }
+    })
+}
+fn inner_readlink<P: ?Sized + NixPath>(dirfd: Option<RawFd>, path: &P) -> Result<OsString> {
+    let mut v = Vec::with_capacity(libc::PATH_MAX as usize);
+    let res = readlink_maybe_at(dirfd, path, &mut v)?;
+    let len = Errno::result(res)?;
+    debug_assert!(len >= 0);
+    if (len as usize) < v.capacity() {
+        return wrap_readlink_result(v, res);
+    }
+    let reported_size = match dirfd {
+        #[cfg(target_os = "redox")]
+        Some(_) => unreachable!(),
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        Some(dirfd) => {
+            let flags = if path.is_empty() { AtFlags::AT_EMPTY_PATH } else { AtFlags::empty() };
+            super::sys::stat::fstatat(dirfd, path, flags | AtFlags::AT_SYMLINK_NOFOLLOW)
+        },
+        #[cfg(not(any(target_os = "android", target_os = "linux", target_os = "redox")))]
+        Some(dirfd) => super::sys::stat::fstatat(dirfd, path, AtFlags::AT_SYMLINK_NOFOLLOW),
+        None => super::sys::stat::lstat(path)
+    }
+        .map(|x| x.st_size)
+        .unwrap_or(0);
+    let mut try_size = if reported_size > 0 {
+        reported_size as usize + 1
+    } else {
+        (libc::PATH_MAX as usize).max(128) << 1
+    };
+    loop {
+        v.reserve_exact(try_size);
+        let res = readlink_maybe_at(dirfd, path, &mut v)?;
+        let len = Errno::result(res)?;
+        debug_assert!(len >= 0);
+        if (len as usize) < v.capacity() {
+            break wrap_readlink_result(v, res);
+        } else {
+            match try_size.checked_shl(1) {
+                Some(next_size) => try_size = next_size,
+                None => break Err(super::Error::from(Errno::ENAMETOOLONG)),
+            }
+        }
+    }
+}
+pub fn readlink<P: ?Sized + NixPath>(path: &P) -> Result<OsString> {
+    inner_readlink(None, path)
+}
+#[cfg(not(target_os = "redox"))]
+pub fn readlinkat<P: ?Sized + NixPath>(dirfd: RawFd, path: &P) -> Result<OsString> {
+    inner_readlink(Some(dirfd), path)
+}
+#[cfg(not(target_os = "redox"))]
+pub(crate) fn at_rawfd(fd: Option<RawFd>) -> raw::c_int {
+    match fd {
+        None => libc::AT_FDCWD,
+        Some(fd) => fd,
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+libc_bitflags!(
+    pub struct SealFlag: c_int {
+        F_SEAL_SEAL;
+        F_SEAL_SHRINK;
+        F_SEAL_GROW;
+        F_SEAL_WRITE;
+    }
+);
+libc_bitflags!(
+    pub struct FdFlag: c_int {
+        FD_CLOEXEC;
+    }
+);
+#[cfg(not(target_os = "redox"))]
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub enum FcntlArg<'a> {
+    F_DUPFD(RawFd),
+    F_DUPFD_CLOEXEC(RawFd),
+    F_GETFD,
+    F_SETFD(FdFlag), // FD_FLAGS
+    F_GETFL,
+    F_SETFL(OFlag), // O_NONBLOCK
+    F_SETLK(&'a libc::flock),
+    F_SETLKW(&'a libc::flock),
+    F_GETLK(&'a mut libc::flock),
+    #[cfg(any(target_os = "linux", target_os = "android"))]
+    F_OFD_SETLK(&'a libc::flock),
+    #[cfg(any(target_os = "linux", target_os = "android"))]
+    F_OFD_SETLKW(&'a libc::flock),
+    #[cfg(any(target_os = "linux", target_os = "android"))]
+    F_OFD_GETLK(&'a mut libc::flock),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    F_ADD_SEALS(SealFlag),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    F_GET_SEALS,
+    #[cfg(any(target_os = "macos", target_os = "ios"))]
+    F_FULLFSYNC,
+    #[cfg(any(target_os = "linux", target_os = "android"))]
+    F_GETPIPE_SZ,
+    #[cfg(any(target_os = "linux", target_os = "android"))]
+    F_SETPIPE_SZ(c_int),
+}
+#[cfg(target_os = "redox")]
+#[derive(Debug, Clone, Copy, Eq, Hash, PartialEq)]
+pub enum FcntlArg {
+    F_DUPFD(RawFd),
+    F_DUPFD_CLOEXEC(RawFd),
+    F_GETFD,
+    F_SETFD(FdFlag), // FD_FLAGS
+    F_GETFL,
+    F_SETFL(OFlag), // O_NONBLOCK
+}
+pub use self::FcntlArg::*;
+pub fn fcntl(fd: RawFd, arg: FcntlArg) -> Result<c_int> {
+    let res = unsafe {
+        match arg {
+            F_DUPFD(rawfd) => libc::fcntl(fd, libc::F_DUPFD, rawfd),
+            F_DUPFD_CLOEXEC(rawfd) => libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, rawfd),
+            F_GETFD => libc::fcntl(fd, libc::F_GETFD),
+            F_SETFD(flag) => libc::fcntl(fd, libc::F_SETFD, flag.bits()),
+            F_GETFL => libc::fcntl(fd, libc::F_GETFL),
+            F_SETFL(flag) => libc::fcntl(fd, libc::F_SETFL, flag.bits()),
+            #[cfg(not(target_os = "redox"))]
+            F_SETLK(flock) => libc::fcntl(fd, libc::F_SETLK, flock),
+            #[cfg(not(target_os = "redox"))]
+            F_SETLKW(flock) => libc::fcntl(fd, libc::F_SETLKW, flock),
+            #[cfg(not(target_os = "redox"))]
+            F_GETLK(flock) => libc::fcntl(fd, libc::F_GETLK, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_SETLK(flock) => libc::fcntl(fd, libc::F_OFD_SETLK, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_SETLKW(flock) => libc::fcntl(fd, libc::F_OFD_SETLKW, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_OFD_GETLK(flock) => libc::fcntl(fd, libc::F_OFD_GETLK, flock),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_ADD_SEALS(flag) => libc::fcntl(fd, libc::F_ADD_SEALS, flag.bits()),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            F_GET_SEALS => libc::fcntl(fd, libc::F_GET_SEALS),
+            #[cfg(any(target_os = "macos", target_os = "ios"))]
+            F_FULLFSYNC => libc::fcntl(fd, libc::F_FULLFSYNC),
+            #[cfg(any(target_os = "linux", target_os = "android"))]
+            F_GETPIPE_SZ => libc::fcntl(fd, libc::F_GETPIPE_SZ),
+            #[cfg(any(target_os = "linux", target_os = "android"))]
+            F_SETPIPE_SZ(size) => libc::fcntl(fd, libc::F_SETPIPE_SZ, size),
+        }
+    };
+    Errno::result(res)
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum FlockArg {
+    LockShared,
+    LockExclusive,
+    Unlock,
+    LockSharedNonblock,
+    LockExclusiveNonblock,
+    UnlockNonblock,
+}
+#[cfg(not(target_os = "redox"))]
+pub fn flock(fd: RawFd, arg: FlockArg) -> Result<()> {
+    use self::FlockArg::*;
+    let res = unsafe {
+        match arg {
+            LockShared => libc::flock(fd, libc::LOCK_SH),
+            LockExclusive => libc::flock(fd, libc::LOCK_EX),
+            Unlock => libc::flock(fd, libc::LOCK_UN),
+            LockSharedNonblock => libc::flock(fd, libc::LOCK_SH | libc::LOCK_NB),
+            LockExclusiveNonblock => libc::flock(fd, libc::LOCK_EX | libc::LOCK_NB),
+            UnlockNonblock => libc::flock(fd, libc::LOCK_UN | libc::LOCK_NB),
+        }
+    };
+    Errno::result(res).map(drop)
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+libc_bitflags! {
+    pub struct SpliceFFlags: c_uint {
+        SPLICE_F_MOVE;
+        SPLICE_F_NONBLOCK;
+        SPLICE_F_MORE;
+        SPLICE_F_GIFT;
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub fn copy_file_range(
+    fd_in: RawFd,
+    off_in: Option<&mut libc::loff_t>,
+    fd_out: RawFd,
+    off_out: Option<&mut libc::loff_t>,
+    len: usize,
+) -> Result<usize> {
+    let off_in = off_in
+        .map(|offset| offset as *mut libc::loff_t)
+        .unwrap_or(ptr::null_mut());
+    let off_out = off_out
+        .map(|offset| offset as *mut libc::loff_t)
+        .unwrap_or(ptr::null_mut());
+    let ret = unsafe {
+        libc::syscall(
+            libc::SYS_copy_file_range,
+            fd_in,
+            off_in,
+            fd_out,
+            off_out,
+            len,
+            0,
+        )
+    };
+    Errno::result(ret).map(|r| r as usize)
+}
+#[cfg(any(target_os = "linux", target_os = "android"))]
+pub fn splice(
+    fd_in: RawFd,
+    off_in: Option<&mut libc::loff_t>,
+    fd_out: RawFd,
+    off_out: Option<&mut libc::loff_t>,
+    len: usize,
+    flags: SpliceFFlags,
+) -> Result<usize> {
+    let off_in = off_in
+        .map(|offset| offset as *mut libc::loff_t)
+        .unwrap_or(ptr::null_mut());
+    let off_out = off_out
+        .map(|offset| offset as *mut libc::loff_t)
+        .unwrap_or(ptr::null_mut());
+    let ret = unsafe { libc::splice(fd_in, off_in, fd_out, off_out, len, flags.bits()) };
+    Errno::result(ret).map(|r| r as usize)
+}
+#[cfg(any(target_os = "linux", target_os = "android"))]
+pub fn tee(fd_in: RawFd, fd_out: RawFd, len: usize, flags: SpliceFFlags) -> Result<usize> {
+    let ret = unsafe { libc::tee(fd_in, fd_out, len, flags.bits()) };
+    Errno::result(ret).map(|r| r as usize)
+}
+#[cfg(any(target_os = "linux", target_os = "android"))]
+pub fn vmsplice(fd: RawFd, iov: &[IoVec<&[u8]>], flags: SpliceFFlags) -> Result<usize> {
+    let ret = unsafe {
+        libc::vmsplice(
+            fd,
+            iov.as_ptr() as *const libc::iovec,
+            iov.len(),
+            flags.bits(),
+        )
+    };
+    Errno::result(ret).map(|r| r as usize)
+}
+#[cfg(any(target_os = "linux"))]
+libc_bitflags!(
+    pub struct FallocateFlags: c_int {
+        FALLOC_FL_KEEP_SIZE;
+        FALLOC_FL_PUNCH_HOLE;
+        FALLOC_FL_COLLAPSE_RANGE;
+        FALLOC_FL_ZERO_RANGE;
+        FALLOC_FL_INSERT_RANGE;
+        FALLOC_FL_UNSHARE_RANGE;
+    }
+);
+#[cfg(any(target_os = "linux"))]
+pub fn fallocate(
+    fd: RawFd,
+    mode: FallocateFlags,
+    offset: libc::off_t,
+    len: libc::off_t,
+) -> Result<()> {
+    let res = unsafe { libc::fallocate(fd, mode.bits(), offset, len) };
+    Errno::result(res).map(drop)
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_env = "uclibc",
+    target_os = "freebsd"
+))]
+mod posix_fadvise {
+    use crate::errno::Errno;
+    use libc;
+    use std::os::unix::io::RawFd;
+    use crate::Result;
+    libc_enum! {
+        #[repr(i32)]
+        pub enum PosixFadviseAdvice {
+            POSIX_FADV_NORMAL,
+            POSIX_FADV_SEQUENTIAL,
+            POSIX_FADV_RANDOM,
+            POSIX_FADV_NOREUSE,
+            POSIX_FADV_WILLNEED,
+            POSIX_FADV_DONTNEED,
+        }
+    }
+    pub fn posix_fadvise(
+        fd: RawFd,
+        offset: libc::off_t,
+        len: libc::off_t,
+        advice: PosixFadviseAdvice,
+    ) -> Result<libc::c_int> {
+        let res = unsafe { libc::posix_fadvise(fd, offset, len, advice as libc::c_int) };
+        Errno::result(res)
+    }
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+    target_os = "fuchsia",
+    any(target_os = "wasi", target_env = "wasi"),
+    target_os = "freebsd"
+))]
+pub fn posix_fallocate(fd: RawFd, offset: libc::off_t, len: libc::off_t) -> Result<()> {
+    let res = unsafe { libc::posix_fallocate(fd, offset, len) };
+    match Errno::result(res) {
+        Err(err) => Err(err),
+        Ok(0) => Ok(()),
+        Ok(errno) => Err(crate::Error::from(Errno::from_i32(errno))),
+    }
+}

--- a//dev/null
+++ b/src/lib.rs
@@ -0,0 +1,162 @@
+#![crate_name = "nix"]
+#![cfg(unix)]
+#![allow(non_camel_case_types)]
+#![allow(dead_code)]
+#![cfg_attr(test, deny(warnings))]
+#![recursion_limit = "500"]
+#![deny(unused)]
+#![deny(unstable_features)]
+#![deny(missing_copy_implementations)]
+#![deny(missing_debug_implementations)]
+pub use libc;
+#[macro_use] mod macros;
+#[cfg(not(target_os = "redox"))]
+pub mod dir;
+pub mod env;
+pub mod errno;
+#[deny(missing_docs)]
+pub mod features;
+pub mod fcntl;
+#[deny(missing_docs)]
+#[cfg(any(target_os = "android",
+          target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "ios",
+          target_os = "linux",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "illumos",
+          target_os = "openbsd"))]
+pub mod ifaddrs;
+#[cfg(any(target_os = "android",
+          target_os = "linux"))]
+pub mod kmod;
+#[cfg(any(target_os = "android",
+          target_os = "freebsd",
+          target_os = "linux"))]
+pub mod mount;
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "fushsia",
+          target_os = "linux",
+          target_os = "netbsd"))]
+pub mod mqueue;
+#[deny(missing_docs)]
+#[cfg(not(target_os = "redox"))]
+pub mod net;
+#[deny(missing_docs)]
+pub mod poll;
+#[deny(missing_docs)]
+#[cfg(not(any(target_os = "redox", target_os = "fuchsia")))]
+pub mod pty;
+pub mod sched;
+pub mod sys;
+pub mod time;
+#[cfg(all(target_os = "linux",
+          any(target_arch = "x86", target_arch = "x86_64")))]
+pub mod ucontext;
+pub mod unistd;
+/*
+ *
+ * ===== Result / Error =====
+ *
+ */
+use libc::{c_char, PATH_MAX};
+use std::{ptr, result};
+use std::ffi::{CStr, OsStr};
+use std::os::unix::ffi::OsStrExt;
+use std::path::{Path, PathBuf};
+use errno::Errno;
+pub type Result<T> = result::Result<T, Errno>;
+pub type Error = Errno;
+pub trait NixPath {
+    fn is_empty(&self) -> bool;
+    fn len(&self) -> usize;
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T>
+        where F: FnOnce(&CStr) -> T;
+}
+impl NixPath for str {
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(OsStr::new(self))
+    }
+    fn len(&self) -> usize {
+        NixPath::len(OsStr::new(self))
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T>
+        where F: FnOnce(&CStr) -> T {
+            OsStr::new(self).with_nix_path(f)
+        }
+}
+impl NixPath for OsStr {
+    fn is_empty(&self) -> bool {
+        self.as_bytes().is_empty()
+    }
+    fn len(&self) -> usize {
+        self.as_bytes().len()
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T>
+        where F: FnOnce(&CStr) -> T {
+            self.as_bytes().with_nix_path(f)
+        }
+}
+impl NixPath for CStr {
+    fn is_empty(&self) -> bool {
+        self.to_bytes().is_empty()
+    }
+    fn len(&self) -> usize {
+        self.to_bytes().len()
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T>
+            where F: FnOnce(&CStr) -> T {
+        if self.len() >= PATH_MAX as usize {
+            return Err(Error::from(Errno::ENAMETOOLONG))
+        }
+        Ok(f(self))
+    }
+}
+impl NixPath for [u8] {
+    fn is_empty(&self) -> bool {
+        self.is_empty()
+    }
+    fn len(&self) -> usize {
+        self.len()
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T>
+            where F: FnOnce(&CStr) -> T {
+        let mut buf = [0u8; PATH_MAX as usize];
+        if self.len() >= PATH_MAX as usize {
+            return Err(Error::from(Errno::ENAMETOOLONG))
+        }
+        match self.iter().position(|b| *b == 0) {
+            Some(_) => Err(Error::from(Errno::EINVAL)),
+            None => {
+                unsafe {
+                    ptr::copy_nonoverlapping(self.as_ptr(), buf.as_mut_ptr(), self.len());
+                    Ok(f(CStr::from_ptr(buf.as_ptr() as *const c_char)))
+                }
+            }
+        }
+    }
+}
+impl NixPath for Path {
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(self.as_os_str())
+    }
+    fn len(&self) -> usize {
+        NixPath::len(self.as_os_str())
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
+        self.as_os_str().with_nix_path(f)
+    }
+}
+impl NixPath for PathBuf {
+    fn is_empty(&self) -> bool {
+        NixPath::is_empty(self.as_os_str())
+    }
+    fn len(&self) -> usize {
+        NixPath::len(self.as_os_str())
+    }
+    fn with_nix_path<T, F>(&self, f: F) -> Result<T> where F: FnOnce(&CStr) -> T {
+        self.as_os_str().with_nix_path(f)
+    }
+}

--- a//dev/null
+++ b/src/mount/bsd.rs
@@ -0,0 +1,229 @@
+use crate::{
+    Error,
+    Errno,
+    NixPath,
+    Result,
+    sys::uio::IoVec
+};
+use libc::{c_char, c_int, c_uint, c_void};
+use std::{
+    borrow::Cow,
+    ffi::{CString, CStr},
+    fmt,
+    io,
+    ptr
+};
+libc_bitflags!(
+    pub struct MntFlags: c_int {
+        #[cfg(any(target_os = "netbsd", target_os = "freebsd"))]
+        MNT_ACLS;
+        MNT_ASYNC;
+        #[cfg(target_os = "freebsd")]
+        MNT_BYFSID;
+        MNT_FORCE;
+        #[cfg(target_os = "freebsd")]
+        MNT_GJOURNAL;
+        #[cfg(any(target_os = "macos", target_os = "freebsd"))]
+        MNT_MULTILABEL;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOCLUSTERR;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOCLUSTERW;
+        #[cfg(target_os = "freebsd")]
+        MNT_NFS4ACLS;
+        MNT_NOATIME;
+        MNT_NOEXEC;
+        MNT_NOSUID;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_NOSYMFOLLOW;
+        MNT_RDONLY;
+        MNT_RELOAD;
+        #[cfg(any(target_os = "macos", target_os = "freebsd"))]
+        MNT_SNAPSHOT;
+        #[cfg(any(
+                target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "netbsd",
+                target_os = "openbsd"
+        ))]
+        MNT_SOFTDEP;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MNT_SUIDDIR;
+        MNT_SYNCHRONOUS;
+        #[cfg(any(
+                target_os = "macos",
+                target_os = "freebsd",
+                target_os = "netbsd"
+        ))]
+        MNT_UNION;
+        MNT_UPDATE;
+        #[cfg(target_os = "freebsd")]
+        MNT_NONBUSY;
+    }
+);
+#[derive(Debug)]
+pub struct NmountError {
+    errno: Error,
+    errmsg: Option<String>
+}
+impl NmountError {
+    pub fn errmsg(&self) -> Option<&str> {
+        self.errmsg.as_deref()
+    }
+    pub fn error(&self) -> Error {
+        self.errno
+    }
+    fn new(error: Error, errmsg: Option<&CStr>) -> Self {
+        Self {
+            errno: error,
+            errmsg: errmsg.map(CStr::to_string_lossy).map(Cow::into_owned)
+        }
+    }
+}
+impl std::error::Error for NmountError {}
+impl fmt::Display for NmountError {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        if let Some(errmsg) = &self.errmsg {
+            write!(f, "{:?}: {}: {}", self.errno, errmsg, self.errno.desc())
+        } else {
+            write!(f, "{:?}: {}", self.errno, self.errno.desc())
+        }
+    }
+}
+impl From<NmountError> for io::Error {
+    fn from(err: NmountError) -> Self {
+        err.errno.into()
+    }
+}
+pub type NmountResult = std::result::Result<(), NmountError>;
+#[cfg(target_os = "freebsd")]
+#[derive(Debug, Default)]
+pub struct Nmount<'a>{
+    iov: Vec<IoVec<&'a [u8]>>,
+    is_owned: Vec<bool>,
+}
+#[cfg(target_os = "freebsd")]
+impl<'a> Nmount<'a> {
+    pub unsafe fn mut_ptr_opt(
+        &mut self,
+        name: &'a CStr,
+        val: *mut c_void,
+        len: usize
+    ) -> &mut Self
+    {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_raw_parts(val, len));
+        self.is_owned.push(false);
+        self
+    }
+    pub fn null_opt(&mut self, name: &'a CStr) -> &mut Self {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
+        self.is_owned.push(false);
+        self
+    }
+    pub fn null_opt_owned<P: ?Sized + NixPath>(&mut self, name: &P) -> &mut Self
+    {
+        name.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        self.iov.push(IoVec::from_raw_parts(ptr::null_mut(), 0));
+        self.is_owned.push(false);
+        self
+    }
+    pub fn str_opt(
+        &mut self,
+        name: &'a CStr,
+        val: &'a CStr
+    ) -> &mut Self
+    {
+        self.iov.push(IoVec::from_slice(name.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self.iov.push(IoVec::from_slice(val.to_bytes_with_nul()));
+        self.is_owned.push(false);
+        self
+    }
+    pub fn str_opt_owned<P1, P2>(&mut self, name: &P1, val: &P2) -> &mut Self
+        where P1: ?Sized + NixPath,
+              P2: ?Sized + NixPath
+    {
+        name.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        val.with_nix_path(|s| {
+            let len = s.to_bytes_with_nul().len();
+            self.iov.push(IoVec::from_raw_parts(
+                s.to_owned().into_raw() as *mut c_void,
+                len
+            ));
+            self.is_owned.push(true);
+        }).unwrap();
+        self
+    }
+    pub fn new() -> Self {
+        Self::default()
+    }
+    pub fn nmount(&mut self, flags: MntFlags) -> NmountResult {
+        const ERRMSG_NAME: &[u8] = b"errmsg\0";
+        let mut errmsg = vec![0u8; 255];
+        self.iov.push(IoVec::from_raw_parts(
+                ERRMSG_NAME.as_ptr() as *mut c_void,
+                ERRMSG_NAME.len()
+        ));
+        self.iov.push(IoVec::from_raw_parts(
+                errmsg.as_mut_ptr() as *mut c_void,
+                errmsg.len()
+        ));
+        let niov = self.iov.len() as c_uint;
+        let iovp = self.iov.as_mut_ptr() as *mut libc::iovec;
+        let res = unsafe {
+            libc::nmount(iovp, niov, flags.bits)
+        };
+        match Errno::result(res) {
+            Ok(_) => Ok(()),
+            Err(error) => {
+                let errmsg = match errmsg.iter().position(|&x| x == 0) {
+                    None => None,
+                    Some(0) => None,
+                    Some(n) => {
+                        let sl = &errmsg[0..n + 1];
+                        Some(CStr::from_bytes_with_nul(sl).unwrap())
+                    }
+                };
+                Err(NmountError::new(error.into(), errmsg))
+            }
+        }
+    }
+}
+#[cfg(target_os = "freebsd")]
+impl<'a> Drop for Nmount<'a> {
+    fn drop(&mut self) {
+        for (iov, is_owned) in self.iov.iter().zip(self.is_owned.iter()) {
+            if *is_owned {
+                unsafe {
+                    CString::from_raw(iov.0.iov_base as *mut c_char);
+                }
+            }
+        }
+    }
+}
+pub fn unmount<P>(mountpoint: &P, flags: MntFlags) -> Result<()>
+    where P: ?Sized + NixPath
+{
+    let res = mountpoint.with_nix_path(|cstr| {
+        unsafe { libc::unmount(cstr.as_ptr(), flags.bits) }
+    })?;
+    Errno::result(res).map(drop)
+}

--- a//dev/null
+++ b/src/mount/linux.rs
@@ -0,0 +1,89 @@
+use libc::{self, c_ulong, c_int};
+use crate::{Result, NixPath};
+use crate::errno::Errno;
+libc_bitflags!(
+    pub struct MsFlags: c_ulong {
+        MS_RDONLY;
+        MS_NOSUID;
+        MS_NODEV;
+        MS_NOEXEC;
+        MS_SYNCHRONOUS;
+        MS_REMOUNT;
+        MS_MANDLOCK;
+        MS_DIRSYNC;
+        MS_NOATIME;
+        MS_NODIRATIME;
+        MS_BIND;
+        MS_MOVE;
+        MS_REC;
+        MS_SILENT;
+        MS_POSIXACL;
+        MS_UNBINDABLE;
+        MS_PRIVATE;
+        MS_SLAVE;
+        MS_SHARED;
+        MS_RELATIME;
+        MS_KERNMOUNT;
+        MS_I_VERSION;
+        MS_STRICTATIME;
+        MS_LAZYTIME;
+        MS_ACTIVE;
+        MS_NOUSER;
+        MS_RMT_MASK;
+        MS_MGC_VAL;
+        MS_MGC_MSK;
+    }
+);
+libc_bitflags!(
+    pub struct MntFlags: c_int {
+        MNT_FORCE;
+        MNT_DETACH;
+        MNT_EXPIRE;
+    }
+);
+pub fn mount<P1: ?Sized + NixPath, P2: ?Sized + NixPath, P3: ?Sized + NixPath, P4: ?Sized + NixPath>(
+        source: Option<&P1>,
+        target: &P2,
+        fstype: Option<&P3>,
+        flags: MsFlags,
+        data: Option<&P4>) -> Result<()> {
+    fn with_opt_nix_path<P, T, F>(p: Option<&P>, f: F) -> Result<T>
+        where P: ?Sized + NixPath,
+              F: FnOnce(*const libc::c_char) -> T
+    {
+        match p {
+            Some(path) => path.with_nix_path(|p_str| f(p_str.as_ptr())),
+            None => Ok(f(std::ptr::null()))
+        }
+    }
+    let res = with_opt_nix_path(source, |s| {
+        target.with_nix_path(|t| {
+            with_opt_nix_path(fstype, |ty| {
+                with_opt_nix_path(data, |d| {
+                    unsafe {
+                        libc::mount(
+                            s,
+                            t.as_ptr(),
+                            ty,
+                            flags.bits,
+                            d as *const libc::c_void
+                        )
+                    }
+                })
+            })
+        })
+    })????;
+    Errno::result(res).map(drop)
+}
+pub fn umount<P: ?Sized + NixPath>(target: &P) -> Result<()> {
+    let res = target.with_nix_path(|cstr| {
+        unsafe { libc::umount(cstr.as_ptr()) }
+    })?;
+    Errno::result(res).map(drop)
+}
+pub fn umount2<P: ?Sized + NixPath>(target: &P, flags: MntFlags) -> Result<()> {
+    let res = target.with_nix_path(|cstr| {
+        unsafe { libc::umount2(cstr.as_ptr(), flags.bits) }
+    })?;
+    Errno::result(res).map(drop)
+}

--- a//dev/null
+++ b/src/mount/mod.rs
@@ -0,0 +1,17 @@
+#[cfg(any(target_os = "android", target_os = "linux"))]
+mod linux;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use self::linux::*;
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+mod bsd;
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"
+          ))]
+pub use self::bsd::*;

--- a//dev/null
+++ b/src/net/if_.rs
@@ -0,0 +1,288 @@
+use crate::{Error, NixPath, Result};
+use libc::c_uint;
+pub fn if_nametoindex<P: ?Sized + NixPath>(name: &P) -> Result<c_uint> {
+    let if_index = name.with_nix_path(|name| unsafe { libc::if_nametoindex(name.as_ptr()) })?;
+    if if_index == 0 {
+        Err(Error::last())
+    } else {
+        Ok(if_index)
+    }
+}
+libc_bitflags!(
+    pub struct InterfaceFlags: libc::c_int {
+        IFF_UP;
+        IFF_BROADCAST;
+        IFF_DEBUG;
+        IFF_LOOPBACK;
+        IFF_POINTOPOINT;
+        #[cfg(any(target_os = "android",
+                  target_os = "fuchsia",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "illumos",
+                  target_os = "solaris"))]
+        IFF_NOTRAILERS;
+        #[cfg(any(target_os = "dragonfly"))]
+        IFF_SMART;
+        #[cfg(any(target_os = "android",
+                  target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "fuchsia",
+                  target_os = "illumos",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "solaris"))]
+        IFF_RUNNING;
+        IFF_NOARP;
+        IFF_PROMISC;
+        IFF_ALLMULTI;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_MASTER;
+        #[cfg(any(target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "ios"))]
+        IFF_OACTIVE;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_INTELLIGENT;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_SLAVE;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "osx"))]
+        IFF_SIMPLEX;
+        IFF_MULTICAST;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "ios"))]
+        IFF_LINK0;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_MULTI_BCAST;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_PORTSEL;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "ios"))]
+        IFF_LINK1;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_UNNUMBERED;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_AUTOMEDIA;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd",
+                  target_os = "ios"))]
+        IFF_LINK2;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "ios"))]
+        IFF_ALTPHYS;
+        #[cfg(any(target_os = "solaris", target_os = "illumos"))]
+        IFF_DHCPRUNNING;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_DYNAMIC;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_PRIVATE;
+        #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
+        IFF_LOWER_UP;
+        #[cfg(any(target_os = "dragonfly"))]
+        IFF_POLLING_COMPAT;
+        #[cfg(any(target_os = "freebsd"))]
+        IFF_CANTCONFIG;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_NOXMIT;
+        #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
+        IFF_DORMANT;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        IFF_PPROMISC;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_NOLOCAL;
+        #[cfg(any(target_os = "fuchsia", target_os = "linux"))]
+        IFF_ECHO;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        IFF_MONITOR;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_DEPRECATED;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        IFF_STATICARP;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_ADDRCONF;
+        #[cfg(any(target_os = "dragonfly"))]
+        IFF_NPOLLING;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_ROUTER;
+        #[cfg(any(target_os = "dragonfly"))]
+        IFF_IDIRECT;
+        #[cfg(any(target_os = "freebsd"))]
+        IFF_DYING;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_NONUD;
+        #[cfg(any(target_os = "freebsd"))]
+        IFF_RENAMING;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_ANYCAST;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_NORTEXCH;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_NO_PI as libc::c_int;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_TUN as libc::c_int;
+        #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+        IFF_TAP as libc::c_int;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_IPV4;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_IPV6;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_NOFAILOVER;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_FAILED;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_STANDBY;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_INACTIVE;
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        IFF_OFFLINE;
+        #[cfg(target_os = "solaris")]
+        IFF_COS_ENABLED;
+        #[cfg(target_os = "solaris")]
+        IFF_PREFERRED;
+        #[cfg(target_os = "solaris")]
+        IFF_TEMPORARY;
+        #[cfg(target_os = "solaris")]
+        IFF_FIXEDMTU;
+        #[cfg(target_os = "solaris")]
+        IFF_VIRTUAL;
+        #[cfg(target_os = "solaris")]
+        IFF_DUPLICATE;
+        #[cfg(target_os = "solaris")]
+        IFF_IPMP;
+    }
+);
+#[cfg(any(
+    target_os = "dragonfly",
+    target_os = "freebsd",
+    target_os = "fuchsia",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+mod if_nameindex {
+    use super::*;
+    use std::ffi::CStr;
+    use std::fmt;
+    use std::marker::PhantomData;
+    use std::ptr::NonNull;
+    #[allow(missing_copy_implementations)]
+    #[repr(transparent)]
+    pub struct Interface(libc::if_nameindex);
+    impl Interface {
+        pub fn index(&self) -> c_uint {
+            self.0.if_index
+        }
+        pub fn name(&self) -> &CStr {
+            unsafe { CStr::from_ptr(self.0.if_name) }
+        }
+    }
+    impl fmt::Debug for Interface {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            f.debug_struct("Interface")
+                .field("index", &self.index())
+                .field("name", &self.name())
+                .finish()
+        }
+    }
+    pub struct Interfaces {
+        ptr: NonNull<libc::if_nameindex>,
+    }
+    impl Interfaces {
+        #[inline]
+        pub fn iter(&self) -> InterfacesIter<'_> {
+            self.into_iter()
+        }
+        pub fn to_slice(&self) -> &[Interface] {
+            let ifs = self.ptr.as_ptr() as *const Interface;
+            let len = self.iter().count();
+            unsafe { std::slice::from_raw_parts(ifs, len) }
+        }
+    }
+    impl Drop for Interfaces {
+        fn drop(&mut self) {
+            unsafe { libc::if_freenameindex(self.ptr.as_ptr()) };
+        }
+    }
+    impl fmt::Debug for Interfaces {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            self.to_slice().fmt(f)
+        }
+    }
+    impl<'a> IntoIterator for &'a Interfaces {
+        type IntoIter = InterfacesIter<'a>;
+        type Item = &'a Interface;
+        #[inline]
+        fn into_iter(self) -> Self::IntoIter {
+            InterfacesIter {
+                ptr: self.ptr.as_ptr(),
+                _marker: PhantomData,
+            }
+        }
+    }
+    #[derive(Debug)]
+    pub struct InterfacesIter<'a> {
+        ptr: *const libc::if_nameindex,
+        _marker: PhantomData<&'a Interfaces>,
+    }
+    impl<'a> Iterator for InterfacesIter<'a> {
+        type Item = &'a Interface;
+        #[inline]
+        fn next(&mut self) -> Option<Self::Item> {
+            unsafe {
+                if (*self.ptr).if_index == 0 {
+                    None
+                } else {
+                    let ret = &*(self.ptr as *const Interface);
+                    self.ptr = self.ptr.add(1);
+                    Some(ret)
+                }
+            }
+        }
+    }
+    pub fn if_nameindex() -> Result<Interfaces> {
+        unsafe {
+            let ifs = libc::if_nameindex();
+            let ptr = NonNull::new(ifs).ok_or_else(Error::last)?;
+            Ok(Interfaces { ptr })
+        }
+    }
+}
+#[cfg(any(
+    target_os = "dragonfly",
+    target_os = "freebsd",
+    target_os = "fuchsia",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+pub use if_nameindex::*;

--- a//dev/null
+++ b/src/pty.rs
@@ -0,0 +1,193 @@
+pub use libc::pid_t as SessionId;
+pub use libc::winsize as Winsize;
+use std::ffi::CStr;
+use std::io;
+use std::mem;
+use std::os::unix::prelude::*;
+use crate::sys::termios::Termios;
+use crate::unistd::{self, ForkResult, Pid};
+use crate::{Result, Error, fcntl};
+use crate::errno::Errno;
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct OpenptyResult {
+    pub master: RawFd,
+    pub slave: RawFd,
+}
+#[derive(Clone, Copy, Debug)]
+pub struct ForkptyResult {
+    pub master: RawFd,
+    pub fork_result: ForkResult,
+}
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct PtyMaster(RawFd);
+impl AsRawFd for PtyMaster {
+    fn as_raw_fd(&self) -> RawFd {
+        self.0
+    }
+}
+impl IntoRawFd for PtyMaster {
+    fn into_raw_fd(self) -> RawFd {
+        let fd = self.0;
+        mem::forget(self);
+        fd
+    }
+}
+impl Drop for PtyMaster {
+    fn drop(&mut self) {
+        let e = unistd::close(self.0);
+        if e == Err(Errno::EBADF) {
+            panic!("Closing an invalid file descriptor!");
+        };
+    }
+}
+impl io::Read for PtyMaster {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        unistd::read(self.0, buf).map_err(io::Error::from)
+    }
+}
+impl io::Write for PtyMaster {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        unistd::write(self.0, buf).map_err(io::Error::from)
+    }
+    fn flush(&mut self) -> io::Result<()> {
+        Ok(())
+    }
+}
+#[inline]
+pub fn grantpt(fd: &PtyMaster) -> Result<()> {
+    if unsafe { libc::grantpt(fd.as_raw_fd()) } < 0 {
+        return Err(Error::from(Errno::last()));
+    }
+    Ok(())
+}
+#[inline]
+pub fn posix_openpt(flags: fcntl::OFlag) -> Result<PtyMaster> {
+    let fd = unsafe {
+        libc::posix_openpt(flags.bits())
+    };
+    if fd < 0 {
+        return Err(Error::from(Errno::last()));
+    }
+    Ok(PtyMaster(fd))
+}
+#[inline]
+pub unsafe fn ptsname(fd: &PtyMaster) -> Result<String> {
+    let name_ptr = libc::ptsname(fd.as_raw_fd());
+    if name_ptr.is_null() {
+        return Err(Error::from(Errno::last()));
+    }
+    let name = CStr::from_ptr(name_ptr);
+    Ok(name.to_string_lossy().into_owned())
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[inline]
+pub fn ptsname_r(fd: &PtyMaster) -> Result<String> {
+    let mut name_buf = Vec::<libc::c_char>::with_capacity(64);
+    let name_buf_ptr = name_buf.as_mut_ptr();
+    let cname = unsafe {
+        let cap = name_buf.capacity();
+        if libc::ptsname_r(fd.as_raw_fd(), name_buf_ptr, cap) != 0 {
+            return Err(Error::last());
+        }
+        CStr::from_ptr(name_buf.as_ptr())
+    };
+    let name = cname.to_string_lossy().into_owned();
+    Ok(name)
+}
+#[inline]
+pub fn unlockpt(fd: &PtyMaster) -> Result<()> {
+    if unsafe { libc::unlockpt(fd.as_raw_fd()) } < 0 {
+        return Err(Error::from(Errno::last()));
+    }
+    Ok(())
+}
+#[inline]
+pub fn openpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(winsize: T, termios: U) -> Result<OpenptyResult> {
+    use std::ptr;
+    let mut slave = mem::MaybeUninit::<libc::c_int>::uninit();
+    let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
+    let ret = {
+        match (termios.into(), winsize.into()) {
+            (Some(termios), Some(winsize)) => {
+                let inner_termios = termios.get_libc_termios();
+                unsafe {
+                    libc::openpty(
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
+                        ptr::null_mut(),
+                        &*inner_termios as *const libc::termios as *mut _,
+                        winsize as *const Winsize as *mut _,
+                    )
+                }
+            }
+            (None, Some(winsize)) => {
+                unsafe {
+                    libc::openpty(
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
+                        ptr::null_mut(),
+                        ptr::null_mut(),
+                        winsize as *const Winsize as *mut _,
+                    )
+                }
+            }
+            (Some(termios), None) => {
+                let inner_termios = termios.get_libc_termios();
+                unsafe {
+                    libc::openpty(
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
+                        ptr::null_mut(),
+                        &*inner_termios as *const libc::termios as *mut _,
+                        ptr::null_mut(),
+                    )
+                }
+            }
+            (None, None) => {
+                unsafe {
+                    libc::openpty(
+                        master.as_mut_ptr(),
+                        slave.as_mut_ptr(),
+                        ptr::null_mut(),
+                        ptr::null_mut(),
+                        ptr::null_mut(),
+                    )
+                }
+            }
+        }
+    };
+    Errno::result(ret)?;
+    unsafe {
+        Ok(OpenptyResult {
+            master: master.assume_init(),
+            slave: slave.assume_init(),
+        })
+    }
+}
+pub unsafe fn forkpty<'a, 'b, T: Into<Option<&'a Winsize>>, U: Into<Option<&'b Termios>>>(
+    winsize: T,
+    termios: U,
+) -> Result<ForkptyResult> {
+    use std::ptr;
+    let mut master = mem::MaybeUninit::<libc::c_int>::uninit();
+    let term = match termios.into() {
+        Some(termios) => {
+            let inner_termios = termios.get_libc_termios();
+            &*inner_termios as *const libc::termios as *mut _
+        },
+        None => ptr::null_mut(),
+    };
+    let win = winsize
+        .into()
+        .map(|ws| ws as *const Winsize as *mut _)
+        .unwrap_or(ptr::null_mut());
+    let res = libc::forkpty(master.as_mut_ptr(), ptr::null_mut(), term, win);
+    let fork_result = Errno::result(res).map(|res| match res {
+        0 => ForkResult::Child,
+        res => ForkResult::Parent { child: Pid::from_raw(res) },
+    })?;
+    Ok(ForkptyResult {
+        master: master.assume_init(),
+        fork_result,
+    })
+}

--- a//dev/null
+++ b/src/sched.rs
@@ -0,0 +1,142 @@
+use crate::{Errno, Result};
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use self::sched_linux_like::*;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+mod sched_linux_like {
+    use crate::errno::Errno;
+    use libc::{self, c_int, c_void};
+    use std::mem;
+    use std::option::Option;
+    use std::os::unix::io::RawFd;
+    use crate::unistd::Pid;
+    use crate::{Error, Result};
+    libc_bitflags! {
+        pub struct CloneFlags: c_int {
+            CLONE_VM;
+            CLONE_FS;
+            CLONE_FILES;
+            CLONE_SIGHAND;
+            CLONE_PTRACE;
+            CLONE_VFORK;
+            CLONE_PARENT;
+            CLONE_THREAD;
+            CLONE_NEWNS;
+            CLONE_SYSVSEM;
+            CLONE_SETTLS;
+            CLONE_PARENT_SETTID;
+            CLONE_CHILD_CLEARTID;
+            CLONE_DETACHED;
+            CLONE_UNTRACED;
+            CLONE_CHILD_SETTID;
+            CLONE_NEWCGROUP;
+            CLONE_NEWUTS;
+            CLONE_NEWIPC;
+            CLONE_NEWUSER;
+            CLONE_NEWPID;
+            CLONE_NEWNET;
+            CLONE_IO;
+        }
+    }
+    pub type CloneCb<'a> = Box<dyn FnMut() -> isize + 'a>;
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+    pub struct CpuSet {
+        cpu_set: libc::cpu_set_t,
+    }
+    impl CpuSet {
+        pub fn new() -> CpuSet {
+            CpuSet {
+                cpu_set: unsafe { mem::zeroed() },
+            }
+        }
+        pub fn is_set(&self, field: usize) -> Result<bool> {
+            if field >= CpuSet::count() {
+                Err(Error::from(Errno::EINVAL))
+            } else {
+                Ok(unsafe { libc::CPU_ISSET(field, &self.cpu_set) })
+            }
+        }
+        pub fn set(&mut self, field: usize) -> Result<()> {
+            if field >= CpuSet::count() {
+                Err(Error::from(Errno::EINVAL))
+            } else {
+                unsafe { libc::CPU_SET(field, &mut self.cpu_set); }
+                Ok(())
+            }
+        }
+        pub fn unset(&mut self, field: usize) -> Result<()> {
+            if field >= CpuSet::count() {
+                Err(Error::from(Errno::EINVAL))
+            } else {
+                unsafe { libc::CPU_CLR(field, &mut self.cpu_set);}
+                Ok(())
+            }
+        }
+        pub fn count() -> usize {
+            8 * mem::size_of::<libc::cpu_set_t>()
+        }
+    }
+    impl Default for CpuSet {
+        fn default() -> Self {
+            Self::new()
+        }
+    }
+    pub fn sched_setaffinity(pid: Pid, cpuset: &CpuSet) -> Result<()> {
+        let res = unsafe {
+            libc::sched_setaffinity(
+                pid.into(),
+                mem::size_of::<CpuSet>() as libc::size_t,
+                &cpuset.cpu_set,
+            )
+        };
+        Errno::result(res).map(drop)
+    }
+    pub fn sched_getaffinity(pid: Pid) -> Result<CpuSet> {
+        let mut cpuset = CpuSet::new();
+        let res = unsafe {
+            libc::sched_getaffinity(
+                pid.into(),
+                mem::size_of::<CpuSet>() as libc::size_t,
+                &mut cpuset.cpu_set,
+            )
+        };
+        Errno::result(res).and(Ok(cpuset))
+    }
+    pub fn clone(
+        mut cb: CloneCb,
+        stack: &mut [u8],
+        flags: CloneFlags,
+        signal: Option<c_int>,
+    ) -> Result<Pid> {
+        extern "C" fn callback(data: *mut CloneCb) -> c_int {
+            let cb: &mut CloneCb = unsafe { &mut *data };
+            (*cb)() as c_int
+        }
+        let res = unsafe {
+            let combined = flags.bits() | signal.unwrap_or(0);
+            let ptr = stack.as_mut_ptr().add(stack.len());
+            let ptr_aligned = ptr.sub(ptr as usize % 16);
+            libc::clone(
+                mem::transmute(
+                    callback as extern "C" fn(*mut Box<dyn FnMut() -> isize>) -> i32,
+                ),
+                ptr_aligned as *mut c_void,
+                combined,
+                &mut cb as *mut _ as *mut c_void,
+            )
+        };
+        Errno::result(res).map(Pid::from_raw)
+    }
+    pub fn unshare(flags: CloneFlags) -> Result<()> {
+        let res = unsafe { libc::unshare(flags.bits()) };
+        Errno::result(res).map(drop)
+    }
+    pub fn setns(fd: RawFd, nstype: CloneFlags) -> Result<()> {
+        let res = unsafe { libc::setns(fd, nstype.bits()) };
+        Errno::result(res).map(drop)
+    }
+}
+pub fn sched_yield() -> Result<()> {
+    let res = unsafe { libc::sched_yield() };
+    Errno::result(res).map(drop)
+}

--- a//dev/null
+++ b/src/sys/aio.rs
@@ -0,0 +1,453 @@
+use crate::{Error, Result};
+use crate::errno::Errno;
+use std::os::unix::io::RawFd;
+use libc::{c_void, off_t, size_t};
+use std::fmt;
+use std::fmt::Debug;
+use std::marker::PhantomData;
+use std::mem;
+use std::pin::Pin;
+use std::ptr::{null, null_mut};
+use crate::sys::signal::*;
+use std::thread;
+use crate::sys::time::TimeSpec;
+libc_enum! {
+    #[repr(i32)]
+    pub enum AioFsyncMode {
+        O_SYNC,
+        #[cfg(any(target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        O_DSYNC
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum LioOpcode {
+        LIO_NOP,
+        LIO_WRITE,
+        LIO_READ,
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum LioMode {
+        LIO_WAIT,
+        LIO_NOWAIT,
+    }
+}
+#[repr(i32)]
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum AioCancelStat {
+    AioCanceled = libc::AIO_CANCELED,
+    AioNotCanceled = libc::AIO_NOTCANCELED,
+    AioAllDone = libc::AIO_ALLDONE,
+}
+#[repr(transparent)]
+struct LibcAiocb(libc::aiocb);
+unsafe impl Send for LibcAiocb {}
+unsafe impl Sync for LibcAiocb {}
+pub struct AioCb<'a> {
+    aiocb: LibcAiocb,
+    mutable: bool,
+    in_progress: bool,
+    _buffer: std::marker::PhantomData<&'a [u8]>,
+    _pin: std::marker::PhantomPinned
+}
+impl<'a> AioCb<'a> {
+    pub fn fd(&self) -> RawFd {
+        self.aiocb.0.aio_fildes
+    }
+    pub fn from_fd(fd: RawFd, prio: libc::c_int,
+                    sigev_notify: SigevNotify) -> Pin<Box<AioCb<'a>>> {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = 0;
+        a.0.aio_nbytes = 0;
+        a.0.aio_buf = null_mut();
+        Box::pin(AioCb {
+            aiocb: a,
+            mutable: false,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
+    }
+    #[cfg(not(any(target_os = "ios", target_os = "macos")))]
+    fn from_mut_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a mut [u8],
+                          prio: libc::c_int, sigev_notify: SigevNotify,
+                          opcode: LioOpcode) -> AioCb<'a>
+    {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+        AioCb {
+            aiocb: a,
+            mutable: true,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        }
+    }
+    pub fn from_mut_slice(fd: RawFd, offs: off_t, buf: &'a mut [u8],
+                          prio: libc::c_int, sigev_notify: SigevNotify,
+                          opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+        Box::pin(AioCb {
+            aiocb: a,
+            mutable: true,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
+    }
+    pub unsafe fn from_mut_ptr(fd: RawFd, offs: off_t,
+                           buf: *mut c_void, len: usize,
+                           prio: libc::c_int, sigev_notify: SigevNotify,
+                           opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = len;
+        a.0.aio_buf = buf;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+        Box::pin(AioCb {
+            aiocb: a,
+            mutable: true,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned,
+        })
+    }
+    pub unsafe fn from_ptr(fd: RawFd, offs: off_t,
+                           buf: *const c_void, len: usize,
+                           prio: libc::c_int, sigev_notify: SigevNotify,
+                           opcode: LioOpcode) -> Pin<Box<AioCb<'a>>> {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = len;
+        a.0.aio_buf = buf as *mut c_void;
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+        Box::pin(AioCb {
+            aiocb: a,
+            mutable: false,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        })
+    }
+    fn from_slice_unpinned(fd: RawFd, offs: off_t, buf: &'a [u8],
+                           prio: libc::c_int, sigev_notify: SigevNotify,
+                           opcode: LioOpcode) -> AioCb
+    {
+        let mut a = AioCb::common_init(fd, prio, sigev_notify);
+        a.0.aio_offset = offs;
+        a.0.aio_nbytes = buf.len() as size_t;
+        a.0.aio_buf = buf.as_ptr() as *mut c_void;
+        assert!(opcode != LioOpcode::LIO_READ, "Can't read into an immutable buffer");
+        a.0.aio_lio_opcode = opcode as libc::c_int;
+        AioCb {
+            aiocb: a,
+            mutable: false,
+            in_progress: false,
+            _buffer: PhantomData,
+            _pin: std::marker::PhantomPinned
+        }
+    }
+    pub fn from_slice(fd: RawFd, offs: off_t, buf: &'a [u8],
+                      prio: libc::c_int, sigev_notify: SigevNotify,
+                      opcode: LioOpcode) -> Pin<Box<AioCb>>
+    {
+        Box::pin(AioCb::from_slice_unpinned(fd, offs, buf, prio, sigev_notify,
+                                            opcode))
+    }
+    fn common_init(fd: RawFd, prio: libc::c_int,
+                   sigev_notify: SigevNotify) -> LibcAiocb {
+        let mut a = unsafe { mem::zeroed::<libc::aiocb>()};
+        a.aio_fildes = fd;
+        a.aio_reqprio = prio;
+        a.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
+        LibcAiocb(a)
+    }
+    pub fn set_sigev_notify(self: &mut Pin<Box<Self>>,
+                            sigev_notify: SigevNotify)
+    {
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.aiocb.0.aio_sigevent = SigEvent::new(sigev_notify).sigevent();
+    }
+    pub fn cancel(self: &mut Pin<Box<Self>>) -> Result<AioCancelStat> {
+        let r = unsafe {
+            let selfp = self.as_mut().get_unchecked_mut();
+            libc::aio_cancel(selfp.aiocb.0.aio_fildes, &mut selfp.aiocb.0)
+        };
+        match r {
+            libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
+            libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
+            libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
+            -1 => Err(Error::from(Errno::last())),
+            _ => panic!("unknown aio_cancel return value")
+        }
+    }
+    fn error_unpinned(&mut self) -> Result<()> {
+        let r = unsafe {
+            libc::aio_error(&mut self.aiocb.0 as *mut libc::aiocb)
+        };
+        match r {
+            0 => Ok(()),
+            num if num > 0 => Err(Error::from(Errno::from_i32(num))),
+            -1 => Err(Error::from(Errno::last())),
+            num => panic!("unknown aio_error return value {:?}", num)
+        }
+    }
+    pub fn error(self: &mut Pin<Box<Self>>) -> Result<()> {
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.error_unpinned()
+    }
+    pub fn fsync(self: &mut Pin<Box<Self>>, mode: AioFsyncMode) -> Result<()> {
+        unsafe {
+            let selfp = self.as_mut().get_unchecked_mut();
+            Errno::result({
+                let p: *mut libc::aiocb = &mut selfp.aiocb.0;
+                libc::aio_fsync(mode as libc::c_int, p)
+            }).map(|_| {
+                selfp.in_progress = true;
+            })
+        }
+    }
+    pub fn lio_opcode(&self) -> Option<LioOpcode> {
+        match self.aiocb.0.aio_lio_opcode {
+            libc::LIO_READ => Some(LioOpcode::LIO_READ),
+            libc::LIO_WRITE => Some(LioOpcode::LIO_WRITE),
+            libc::LIO_NOP => Some(LioOpcode::LIO_NOP),
+            _ => None
+        }
+    }
+    pub fn nbytes(&self) -> usize {
+        self.aiocb.0.aio_nbytes
+    }
+    pub fn offset(&self) -> off_t {
+        self.aiocb.0.aio_offset
+    }
+    pub fn priority(&self) -> libc::c_int {
+        self.aiocb.0.aio_reqprio
+    }
+    pub fn read(self: &mut Pin<Box<Self>>) -> Result<()> {
+        assert!(self.mutable, "Can't read into an immutable buffer");
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        Errno::result({
+            let p: *mut libc::aiocb = &mut selfp.aiocb.0;
+            unsafe { libc::aio_read(p) }
+        }).map(|_| {
+            selfp.in_progress = true;
+        })
+    }
+    pub fn sigevent(&self) -> SigEvent {
+        SigEvent::from(&self.aiocb.0.aio_sigevent)
+    }
+    fn aio_return_unpinned(&mut self) -> Result<isize> {
+        unsafe {
+            let p: *mut libc::aiocb = &mut self.aiocb.0;
+            self.in_progress = false;
+            Errno::result(libc::aio_return(p))
+        }
+    }
+    pub fn aio_return(self: &mut Pin<Box<Self>>) -> Result<isize> {
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        selfp.aio_return_unpinned()
+    }
+    pub fn write(self: &mut Pin<Box<Self>>) -> Result<()> {
+        let selfp = unsafe {
+            self.as_mut().get_unchecked_mut()
+        };
+        Errno::result({
+            let p: *mut libc::aiocb = &mut selfp.aiocb.0;
+            unsafe{ libc::aio_write(p) }
+        }).map(|_| {
+            selfp.in_progress = true;
+        })
+    }
+}
+pub fn aio_cancel_all(fd: RawFd) -> Result<AioCancelStat> {
+    match unsafe { libc::aio_cancel(fd, null_mut()) } {
+        libc::AIO_CANCELED => Ok(AioCancelStat::AioCanceled),
+        libc::AIO_NOTCANCELED => Ok(AioCancelStat::AioNotCanceled),
+        libc::AIO_ALLDONE => Ok(AioCancelStat::AioAllDone),
+        -1 => Err(Error::from(Errno::last())),
+        _ => panic!("unknown aio_cancel return value")
+    }
+}
+pub fn aio_suspend(list: &[Pin<&AioCb>], timeout: Option<TimeSpec>) -> Result<()> {
+    let plist = list as *const [Pin<&AioCb>] as *const [*const libc::aiocb];
+    let p = plist as *const *const libc::aiocb;
+    let timep = match timeout {
+        None    => null::<libc::timespec>(),
+        Some(x) => x.as_ref() as *const libc::timespec
+    };
+    Errno::result(unsafe {
+        libc::aio_suspend(p, list.len() as i32, timep)
+    }).map(drop)
+}
+impl<'a> Debug for AioCb<'a> {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("AioCb")
+            .field("aiocb", &self.aiocb.0)
+            .field("mutable", &self.mutable)
+            .field("in_progress", &self.in_progress)
+            .finish()
+    }
+}
+impl<'a> Drop for AioCb<'a> {
+    fn drop(&mut self) {
+        assert!(thread::panicking() || !self.in_progress,
+                "Dropped an in-progress AioCb");
+    }
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+pub struct LioCb<'a> {
+    aiocbs: Box<[AioCb<'a>]>,
+    list: Vec<*mut libc::aiocb>,
+    results: Vec<Option<Result<isize>>>
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+unsafe impl<'a> Send for LioCb<'a> {}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+unsafe impl<'a> Sync for LioCb<'a> {}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+impl<'a> LioCb<'a> {
+    pub fn is_empty(&self) -> bool {
+        self.aiocbs.is_empty()
+    }
+    pub fn len(&self) -> usize {
+        self.aiocbs.len()
+    }
+    pub fn listio(&mut self, mode: LioMode,
+                  sigev_notify: SigevNotify) -> Result<()> {
+        let sigev = SigEvent::new(sigev_notify);
+        let sigevp = &mut sigev.sigevent() as *mut libc::sigevent;
+        self.list.clear();
+        for a in &mut self.aiocbs.iter_mut() {
+            a.in_progress = true;
+            self.list.push(a as *mut AioCb<'a>
+                             as *mut libc::aiocb);
+        }
+        let p = self.list.as_ptr();
+        Errno::result(unsafe {
+            libc::lio_listio(mode as i32, p, self.list.len() as i32, sigevp)
+        }).map(drop)
+    }
+    pub fn listio_resubmit(&mut self, mode:LioMode,
+                           sigev_notify: SigevNotify) -> Result<()> {
+        let sigev = SigEvent::new(sigev_notify);
+        let sigevp = &mut sigev.sigevent() as *mut libc::sigevent;
+        self.list.clear();
+        while self.results.len() < self.aiocbs.len() {
+            self.results.push(None);
+        }
+        for (i, a) in self.aiocbs.iter_mut().enumerate() {
+            if self.results[i].is_some() {
+                continue;
+            }
+            match a.error_unpinned() {
+                Ok(()) => {
+                    self.results[i] = Some(a.aio_return_unpinned());
+                },
+                Err(Errno::EAGAIN) => {
+                    self.list.push(a as *mut AioCb<'a> as *mut libc::aiocb);
+                },
+                Err(Errno::EINPROGRESS) => {
+                },
+                Err(Errno::EINVAL) => panic!(
+                    "AioCb was never submitted, or already finalized"),
+                _ => unreachable!()
+            }
+        }
+        let p = self.list.as_ptr();
+        Errno::result(unsafe {
+            libc::lio_listio(mode as i32, p, self.list.len() as i32, sigevp)
+        }).map(drop)
+    }
+    pub fn aio_return(&mut self, i: usize) -> Result<isize> {
+        if i >= self.results.len() || self.results[i].is_none() {
+            self.aiocbs[i].aio_return_unpinned()
+        } else {
+            self.results[i].unwrap()
+        }
+    }
+    pub fn error(&mut self, i: usize) -> Result<()> {
+        if i >= self.results.len() || self.results[i].is_none() {
+            self.aiocbs[i].error_unpinned()
+        } else {
+            Ok(())
+        }
+    }
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+impl<'a> Debug for LioCb<'a> {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        fmt.debug_struct("LioCb")
+            .field("aiocbs", &self.aiocbs)
+            .finish()
+    }
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[derive(Debug)]
+pub struct LioCbBuilder<'a> {
+    pub aiocbs: Vec<AioCb<'a>>,
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+impl<'a> LioCbBuilder<'a> {
+    pub fn with_capacity(capacity: usize) -> LioCbBuilder<'a> {
+        LioCbBuilder {
+            aiocbs: Vec::with_capacity(capacity),
+        }
+    }
+    pub fn emplace_slice(mut self, fd: RawFd, offs: off_t, buf: &'a [u8],
+                         prio: libc::c_int, sigev_notify: SigevNotify,
+                         opcode: LioOpcode) -> Self
+    {
+        self.aiocbs.push(AioCb::from_slice_unpinned(fd, offs, buf, prio,
+                                                    sigev_notify, opcode));
+        self
+    }
+    pub fn emplace_mut_slice(mut self, fd: RawFd, offs: off_t,
+                             buf: &'a mut [u8], prio: libc::c_int,
+                             sigev_notify: SigevNotify, opcode: LioOpcode)
+        -> Self
+    {
+        self.aiocbs.push(AioCb::from_mut_slice_unpinned(fd, offs, buf, prio,
+                                                        sigev_notify, opcode));
+        self
+    }
+    pub fn finish(self) -> LioCb<'a> {
+        let len = self.aiocbs.len();
+        LioCb {
+            aiocbs: self.aiocbs.into(),
+            list: Vec::with_capacity(len),
+            results: Vec::with_capacity(len)
+        }
+    }
+}
+#[cfg(not(any(target_os = "ios", target_os = "macos")))]
+#[cfg(test)]
+mod t {
+    use super::*;
+    #[test]
+    fn liocb_is_unpin() {
+        use assert_impl::assert_impl;
+        assert_impl!(Unpin: LioCb);
+    }
+}

--- a//dev/null
+++ b/src/sys/epoll.rs
@@ -0,0 +1,93 @@
+use crate::{Error, Result};
+use crate::errno::Errno;
+use libc::{self, c_int};
+use std::os::unix::io::RawFd;
+use std::ptr;
+use std::mem;
+libc_bitflags!(
+    pub struct EpollFlags: c_int {
+        EPOLLIN;
+        EPOLLPRI;
+        EPOLLOUT;
+        EPOLLRDNORM;
+        EPOLLRDBAND;
+        EPOLLWRNORM;
+        EPOLLWRBAND;
+        EPOLLMSG;
+        EPOLLERR;
+        EPOLLHUP;
+        EPOLLRDHUP;
+        #[cfg(target_os = "linux")]  // Added in 4.5; not in Android.
+        EPOLLEXCLUSIVE;
+        #[cfg(not(target_arch = "mips"))]
+        EPOLLWAKEUP;
+        EPOLLONESHOT;
+        EPOLLET;
+    }
+);
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[repr(i32)]
+pub enum EpollOp {
+    EpollCtlAdd = libc::EPOLL_CTL_ADD,
+    EpollCtlDel = libc::EPOLL_CTL_DEL,
+    EpollCtlMod = libc::EPOLL_CTL_MOD,
+}
+libc_bitflags!{
+    pub struct EpollCreateFlags: c_int {
+        EPOLL_CLOEXEC;
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+#[repr(transparent)]
+pub struct EpollEvent {
+    event: libc::epoll_event,
+}
+impl EpollEvent {
+    pub fn new(events: EpollFlags, data: u64) -> Self {
+        EpollEvent { event: libc::epoll_event { events: events.bits() as u32, u64: data } }
+    }
+    pub fn empty() -> Self {
+        unsafe { mem::zeroed::<EpollEvent>() }
+    }
+    pub fn events(&self) -> EpollFlags {
+        EpollFlags::from_bits(self.event.events as c_int).unwrap()
+    }
+    pub fn data(&self) -> u64 {
+        self.event.u64
+    }
+}
+#[inline]
+pub fn epoll_create() -> Result<RawFd> {
+    let res = unsafe { libc::epoll_create(1024) };
+    Errno::result(res)
+}
+#[inline]
+pub fn epoll_create1(flags: EpollCreateFlags) -> Result<RawFd> {
+    let res = unsafe { libc::epoll_create1(flags.bits()) };
+    Errno::result(res)
+}
+#[inline]
+pub fn epoll_ctl<'a, T>(epfd: RawFd, op: EpollOp, fd: RawFd, event: T) -> Result<()>
+    where T: Into<Option<&'a mut EpollEvent>>
+{
+    let mut event: Option<&mut EpollEvent> = event.into();
+    if event.is_none() && op != EpollOp::EpollCtlDel {
+        Err(Error::from(Errno::EINVAL))
+    } else {
+        let res = unsafe {
+            if let Some(ref mut event) = event {
+                libc::epoll_ctl(epfd, op as c_int, fd, &mut event.event)
+            } else {
+                libc::epoll_ctl(epfd, op as c_int, fd, ptr::null_mut())
+            }
+        };
+        Errno::result(res).map(drop)
+    }
+}
+#[inline]
+pub fn epoll_wait(epfd: RawFd, events: &mut [EpollEvent], timeout_ms: isize) -> Result<usize> {
+    let res = unsafe {
+        libc::epoll_wait(epfd, events.as_mut_ptr() as *mut libc::epoll_event, events.len() as c_int, timeout_ms as c_int)
+    };
+    Errno::result(res).map(|r| r as usize)
+}

--- a//dev/null
+++ b/src/sys/mman.rs
@@ -0,0 +1,247 @@
+use crate::{Error, Result};
+#[cfg(not(target_os = "android"))]
+use crate::NixPath;
+use crate::errno::Errno;
+#[cfg(not(target_os = "android"))]
+use crate::fcntl::OFlag;
+use libc::{self, c_int, c_void, size_t, off_t};
+#[cfg(not(target_os = "android"))]
+use crate::sys::stat::Mode;
+use std::os::unix::io::RawFd;
+libc_bitflags!{
+    pub struct ProtFlags: c_int {
+        PROT_NONE;
+        PROT_READ;
+        PROT_WRITE;
+        PROT_EXEC;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        PROT_GROWSDOWN;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        PROT_GROWSUP;
+    }
+}
+libc_bitflags!{
+    pub struct MapFlags: c_int {
+        MAP_FILE;
+        MAP_SHARED;
+        MAP_PRIVATE;
+        MAP_FIXED;
+        MAP_ANON;
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "freebsd"))]
+        MAP_ANONYMOUS;
+        #[cfg(any(all(any(target_os = "android", target_os = "linux"),
+                      any(target_arch = "x86", target_arch = "x86_64")),
+                  all(target_os = "linux", target_env = "musl", any(target_arch = "x86", target_arch = "x86_64")),
+                  all(target_os = "freebsd", target_pointer_width = "64")))]
+        MAP_32BIT;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_GROWSDOWN;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_DENYWRITE;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_EXECUTABLE;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_LOCKED;
+        #[cfg(not(target_os = "freebsd"))]
+        MAP_NORESERVE;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_POPULATE;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_NONBLOCK;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MAP_HUGETLB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_64KB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_512KB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_1MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_2MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_8MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_16MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_32MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_256MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_512MB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_1GB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_2GB;
+        #[cfg(target_os = "linux")]
+        MAP_HUGE_16GB;
+        #[cfg(target_os = "netbsd")]
+        MAP_WIRED;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MAP_NOSYNC;
+        #[cfg(any(target_os = "dragonfly", target_os = "netbsd", target_os = "openbsd"))]
+        MAP_RENAME;
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd", target_os = "netbsd", target_os = "openbsd"))]
+        MAP_HASSEMAPHORE;
+        #[cfg(any(target_os = "android", target_os = "dragonfly", target_os = "freebsd", target_os = "linux"))]
+        MAP_STACK;
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MAP_NOCACHE;
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MAP_JIT;
+    }
+}
+#[cfg(target_os = "linux")]
+libc_bitflags!{
+    pub struct MRemapFlags: c_int {
+        MREMAP_MAYMOVE;
+        MREMAP_FIXED;
+    }
+}
+libc_enum!{
+    #[repr(i32)]
+    pub enum MmapAdvise {
+        MADV_NORMAL,
+        MADV_RANDOM,
+        MADV_SEQUENTIAL,
+        MADV_WILLNEED,
+        MADV_DONTNEED,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_REMOVE,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_DONTFORK,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_DOFORK,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_HWPOISON,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_MERGEABLE,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_UNMERGEABLE,
+        #[cfg(any(target_os = "android",
+            all(target_os = "linux", any(
+                target_arch = "aarch64",
+                target_arch = "arm",
+                target_arch = "ppc",
+                target_arch = "s390x",
+                target_arch = "x86",
+                target_arch = "x86_64",
+                target_arch = "sparc64"))))]
+        MADV_SOFT_OFFLINE,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_HUGEPAGE,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_NOHUGEPAGE,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_DONTDUMP,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MADV_DODUMP,
+        MADV_FREE,
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MADV_NOSYNC,
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MADV_AUTOSYNC,
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MADV_NOCORE,
+        #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+        MADV_CORE,
+        #[cfg(any(target_os = "freebsd"))]
+        MADV_PROTECT,
+        #[cfg(target_os = "dragonfly")]
+        MADV_INVAL,
+        #[cfg(target_os = "dragonfly")]
+        MADV_SETMAP,
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MADV_ZERO_WIRED_PAGES,
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MADV_FREE_REUSABLE,
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MADV_FREE_REUSE,
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MADV_CAN_REUSE,
+    }
+}
+libc_bitflags!{
+    pub struct MsFlags: c_int {
+        MS_ASYNC;
+        MS_INVALIDATE;
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MS_KILLPAGES;
+        #[cfg(any(target_os = "ios", target_os = "macos"))]
+        MS_DEACTIVATE;
+        MS_SYNC;
+    }
+}
+libc_bitflags!{
+    pub struct MlockAllFlags: c_int {
+        MCL_CURRENT;
+        MCL_FUTURE;
+    }
+}
+pub unsafe fn mlock(addr: *const c_void, length: size_t) -> Result<()> {
+    Errno::result(libc::mlock(addr, length)).map(drop)
+}
+pub unsafe fn munlock(addr: *const c_void, length: size_t) -> Result<()> {
+    Errno::result(libc::munlock(addr, length)).map(drop)
+}
+pub fn mlockall(flags: MlockAllFlags) -> Result<()> {
+    unsafe { Errno::result(libc::mlockall(flags.bits())) }.map(drop)
+}
+pub fn munlockall() -> Result<()> {
+    unsafe { Errno::result(libc::munlockall()) }.map(drop)
+}
+pub unsafe fn mmap(addr: *mut c_void, length: size_t, prot: ProtFlags, flags: MapFlags, fd: RawFd, offset: off_t) -> Result<*mut c_void> {
+    let ret = libc::mmap(addr, length, prot.bits(), flags.bits(), fd, offset);
+    if ret == libc::MAP_FAILED {
+        Err(Error::from(Errno::last()))
+    } else {
+        Ok(ret)
+    }
+}
+#[cfg(target_os = "linux")]
+pub unsafe fn mremap(
+    addr: *mut c_void,
+    old_size: size_t,
+    new_size: size_t,
+    flags: MRemapFlags,
+    new_address: Option<* mut c_void>,
+) -> Result<*mut c_void> {
+    let ret = libc::mremap(addr, old_size, new_size, flags.bits(), new_address.unwrap_or(std::ptr::null_mut()));
+    if ret == libc::MAP_FAILED {
+        Err(Error::from(Errno::last()))
+    } else {
+        Ok(ret)
+    }
+}
+pub unsafe fn munmap(addr: *mut c_void, len: size_t) -> Result<()> {
+    Errno::result(libc::munmap(addr, len)).map(drop)
+}
+pub unsafe fn madvise(addr: *mut c_void, length: size_t, advise: MmapAdvise) -> Result<()> {
+    Errno::result(libc::madvise(addr, length, advise as i32)).map(drop)
+}
+pub unsafe fn mprotect(addr: *mut c_void, length: size_t, prot: ProtFlags) -> Result<()> {
+    Errno::result(libc::mprotect(addr, length, prot.bits())).map(drop)
+}
+pub unsafe fn msync(addr: *mut c_void, length: size_t, flags: MsFlags) -> Result<()> {
+    Errno::result(libc::msync(addr, length, flags.bits())).map(drop)
+}
+#[cfg(not(target_os = "android"))]
+pub fn shm_open<P: ?Sized + NixPath>(name: &P, flag: OFlag, mode: Mode) -> Result<RawFd> {
+    let ret = name.with_nix_path(|cstr| {
+        #[cfg(any(target_os = "macos", target_os = "ios"))]
+        unsafe {
+            libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::c_uint)
+        }
+        #[cfg(not(any(target_os = "macos", target_os = "ios")))]
+        unsafe {
+            libc::shm_open(cstr.as_ptr(), flag.bits(), mode.bits() as libc::mode_t)
+        }
+    })?;
+    Errno::result(ret)
+}
+#[cfg(not(target_os = "android"))]
+pub fn shm_unlink<P: ?Sized + NixPath>(name: &P) -> Result<()> {
+    let ret = name.with_nix_path(|cstr| {
+        unsafe { libc::shm_unlink(cstr.as_ptr()) }
+    })?;
+    Errno::result(ret).map(drop)
+}

--- a//dev/null
+++ b/src/sys/ptrace/linux.rs
@@ -0,0 +1,332 @@
+use cfg_if::cfg_if;
+use std::{mem, ptr};
+use crate::Result;
+use crate::errno::Errno;
+use libc::{self, c_void, c_long, siginfo_t};
+use crate::unistd::Pid;
+use crate::sys::signal::Signal;
+pub type AddressType = *mut ::libc::c_void;
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
+use libc::user_regs_struct;
+cfg_if! {
+    if #[cfg(any(all(target_os = "linux", target_arch = "s390x"),
+                 all(target_os = "linux", target_env = "gnu")))] {
+        #[doc(hidden)]
+        pub type RequestType = ::libc::c_uint;
+    } else {
+        #[doc(hidden)]
+        pub type RequestType = ::libc::c_int;
+    }
+}
+libc_enum!{
+    #[cfg_attr(not(any(target_env = "musl", target_os = "android")), repr(u32))]
+    #[cfg_attr(any(target_env = "musl", target_os = "android"), repr(i32))]
+    pub enum Request {
+        PTRACE_TRACEME,
+        PTRACE_PEEKTEXT,
+        PTRACE_PEEKDATA,
+        PTRACE_PEEKUSER,
+        PTRACE_POKETEXT,
+        PTRACE_POKEDATA,
+        PTRACE_POKEUSER,
+        PTRACE_CONT,
+        PTRACE_KILL,
+        PTRACE_SINGLESTEP,
+        #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
+                  all(target_os = "linux", any(target_env = "musl",
+                                               target_arch = "mips",
+                                               target_arch = "mips64",
+                                               target_arch = "x86_64",
+                                               target_pointer_width = "32"))))]
+        PTRACE_GETREGS,
+        #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
+                  all(target_os = "linux", any(target_env = "musl",
+                                               target_arch = "mips",
+                                               target_arch = "mips64",
+                                               target_arch = "x86_64",
+                                               target_pointer_width = "32"))))]
+        PTRACE_SETREGS,
+        #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
+                  all(target_os = "linux", any(target_env = "musl",
+                                               target_arch = "mips",
+                                               target_arch = "mips64",
+                                               target_arch = "x86_64",
+                                               target_pointer_width = "32"))))]
+        PTRACE_GETFPREGS,
+        #[cfg(any(all(target_os = "android", target_pointer_width = "32"),
+                  all(target_os = "linux", any(target_env = "musl",
+                                               target_arch = "mips",
+                                               target_arch = "mips64",
+                                               target_arch = "x86_64",
+                                               target_pointer_width = "32"))))]
+        PTRACE_SETFPREGS,
+        PTRACE_ATTACH,
+        PTRACE_DETACH,
+        #[cfg(all(target_os = "linux", any(target_env = "musl",
+                                           target_arch = "mips",
+                                           target_arch = "mips64",
+                                           target_arch = "x86",
+                                           target_arch = "x86_64")))]
+        PTRACE_GETFPXREGS,
+        #[cfg(all(target_os = "linux", any(target_env = "musl",
+                                           target_arch = "mips",
+                                           target_arch = "mips64",
+                                           target_arch = "x86",
+                                           target_arch = "x86_64")))]
+        PTRACE_SETFPXREGS,
+        PTRACE_SYSCALL,
+        PTRACE_SETOPTIONS,
+        PTRACE_GETEVENTMSG,
+        PTRACE_GETSIGINFO,
+        PTRACE_SETSIGINFO,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_GETREGSET,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_SETREGSET,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_SEIZE,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_INTERRUPT,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_LISTEN,
+        #[cfg(all(target_os = "linux", not(any(target_arch = "mips",
+                                               target_arch = "mips64"))))]
+        PTRACE_PEEKSIGINFO,
+        #[cfg(all(target_os = "linux", target_env = "gnu",
+                  any(target_arch = "x86", target_arch = "x86_64")))]
+        PTRACE_SYSEMU,
+        #[cfg(all(target_os = "linux", target_env = "gnu",
+                  any(target_arch = "x86", target_arch = "x86_64")))]
+        PTRACE_SYSEMU_SINGLESTEP,
+    }
+}
+libc_enum!{
+    #[repr(i32)]
+    pub enum Event {
+        PTRACE_EVENT_FORK,
+        PTRACE_EVENT_VFORK,
+        PTRACE_EVENT_CLONE,
+        PTRACE_EVENT_EXEC,
+        PTRACE_EVENT_VFORK_DONE,
+        PTRACE_EVENT_EXIT,
+        PTRACE_EVENT_SECCOMP,
+    }
+}
+libc_bitflags! {
+    pub struct Options: libc::c_int {
+        PTRACE_O_TRACESYSGOOD;
+        PTRACE_O_TRACEFORK;
+        PTRACE_O_TRACEVFORK;
+        PTRACE_O_TRACECLONE;
+        PTRACE_O_TRACEEXEC;
+        PTRACE_O_TRACEVFORKDONE;
+        PTRACE_O_TRACEEXIT;
+        PTRACE_O_TRACESECCOMP;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        PTRACE_O_EXITKILL;
+    }
+}
+fn ptrace_peek(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
+    let ret = unsafe {
+        Errno::clear();
+        libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)
+    };
+    match Errno::result(ret) {
+        Ok(..) | Err(Errno::UnknownErrno) => Ok(ret),
+        err @ Err(..) => err,
+    }
+}
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
+pub fn getregs(pid: Pid) -> Result<user_regs_struct> {
+    ptrace_get_data::<user_regs_struct>(Request::PTRACE_GETREGS, pid)
+}
+#[cfg(all(
+    target_os = "linux",
+    any(all(target_arch = "x86_64",
+            any(target_env = "gnu", target_env = "musl")),
+        all(target_arch = "x86", target_env = "gnu"))
+))]
+pub fn setregs(pid: Pid, regs: user_regs_struct) -> Result<()> {
+    let res = unsafe {
+        libc::ptrace(Request::PTRACE_SETREGS as RequestType,
+                     libc::pid_t::from(pid),
+                     ptr::null_mut::<c_void>(),
+                     &regs as *const _ as *const c_void)
+    };
+    Errno::result(res).map(drop)
+}
+fn ptrace_get_data<T>(request: Request, pid: Pid) -> Result<T> {
+    let mut data = mem::MaybeUninit::uninit();
+    let res = unsafe {
+        libc::ptrace(request as RequestType,
+                     libc::pid_t::from(pid),
+                     ptr::null_mut::<T>(),
+                     data.as_mut_ptr() as *const _ as *const c_void)
+    };
+    Errno::result(res)?;
+    Ok(unsafe{ data.assume_init() })
+}
+unsafe fn ptrace_other(request: Request, pid: Pid, addr: AddressType, data: *mut c_void) -> Result<c_long> {
+    Errno::result(libc::ptrace(request as RequestType, libc::pid_t::from(pid), addr, data)).map(|_| 0)
+}
+pub fn setoptions(pid: Pid, options: Options) -> Result<()> {
+    let res = unsafe {
+        libc::ptrace(Request::PTRACE_SETOPTIONS as RequestType,
+                     libc::pid_t::from(pid),
+                     ptr::null_mut::<c_void>(),
+                     options.bits() as *mut c_void)
+    };
+    Errno::result(res).map(drop)
+}
+pub fn getevent(pid: Pid) -> Result<c_long> {
+    ptrace_get_data::<c_long>(Request::PTRACE_GETEVENTMSG, pid)
+}
+pub fn getsiginfo(pid: Pid) -> Result<siginfo_t> {
+    ptrace_get_data::<siginfo_t>(Request::PTRACE_GETSIGINFO, pid)
+}
+pub fn setsiginfo(pid: Pid, sig: &siginfo_t) -> Result<()> {
+    let ret = unsafe{
+        Errno::clear();
+        libc::ptrace(Request::PTRACE_SETSIGINFO as RequestType,
+                     libc::pid_t::from(pid),
+                     ptr::null_mut::<c_void>(),
+                     sig as *const _ as *const c_void)
+    };
+    match Errno::result(ret) {
+        Ok(_) => Ok(()),
+        Err(e) => Err(e),
+    }
+}
+pub fn traceme() -> Result<()> {
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_TRACEME,
+            Pid::from_raw(0),
+            ptr::null_mut(),
+            ptr::null_mut(),
+        ).map(drop) // ignore the useless return value
+    }
+}
+pub fn syscall<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_SYSCALL,
+            pid,
+            ptr::null_mut(),
+            data,
+        ).map(drop) // ignore the useless return value
+    }
+}
+#[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
+pub fn sysemu<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(Request::PTRACE_SYSEMU, pid, ptr::null_mut(), data).map(drop)
+    }
+}
+pub fn attach(pid: Pid) -> Result<()> {
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_ATTACH,
+            pid,
+            ptr::null_mut(),
+            ptr::null_mut(),
+        ).map(drop) // ignore the useless return value
+    }
+}
+#[cfg(all(target_os = "linux", not(any(target_arch = "mips", target_arch = "mips64"))))]
+pub fn seize(pid: Pid, options: Options) -> Result<()> {
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_SEIZE,
+            pid,
+            ptr::null_mut(),
+            options.bits() as *mut c_void,
+        ).map(drop) // ignore the useless return value
+    }
+}
+pub fn detach<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_DETACH,
+            pid,
+            ptr::null_mut(),
+            data
+        ).map(drop)
+    }
+}
+pub fn cont<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(Request::PTRACE_CONT, pid, ptr::null_mut(), data).map(drop) // ignore the useless return value
+    }
+}
+pub fn kill(pid: Pid) -> Result<()> {
+    unsafe {
+        ptrace_other(Request::PTRACE_KILL, pid, ptr::null_mut(), ptr::null_mut()).map(drop)
+    }
+}
+pub fn step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(Request::PTRACE_SINGLESTEP, pid, ptr::null_mut(), data).map(drop)
+    }
+}
+#[cfg(all(target_os = "linux", target_env = "gnu", any(target_arch = "x86", target_arch = "x86_64")))]
+pub fn sysemu_step<T: Into<Option<Signal>>>(pid: Pid, sig: T) -> Result<()> {
+    let data = match sig.into() {
+        Some(s) => s as i32 as *mut c_void,
+        None => ptr::null_mut(),
+    };
+    unsafe {
+        ptrace_other(
+            Request::PTRACE_SYSEMU_SINGLESTEP,
+            pid,
+            ptr::null_mut(),
+            data,
+        )
+        .map(drop) // ignore the useless return value
+    }
+}
+pub fn read(pid: Pid, addr: AddressType) -> Result<c_long> {
+    ptrace_peek(Request::PTRACE_PEEKDATA, pid, addr, ptr::null_mut())
+}
+pub unsafe fn write(
+    pid: Pid,
+    addr: AddressType,
+    data: *mut c_void) -> Result<()>
+{
+    ptrace_other(Request::PTRACE_POKEDATA, pid, addr, data).map(drop)
+}

--- a//dev/null
+++ b/src/sys/reboot.rs
@@ -0,0 +1,32 @@
+use crate::{Error, Result};
+use crate::errno::Errno;
+use libc;
+use std::convert::Infallible;
+use std::mem::drop;
+libc_enum! {
+    #[repr(i32)]
+    pub enum RebootMode {
+        RB_HALT_SYSTEM,
+        RB_KEXEC,
+        RB_POWER_OFF,
+        RB_AUTOBOOT,
+        RB_SW_SUSPEND,
+    }
+}
+pub fn reboot(how: RebootMode) -> Result<Infallible> {
+    unsafe {
+        libc::reboot(how as libc::c_int)
+    };
+    Err(Error::from(Errno::last()))
+}
+pub fn set_cad_enabled(enable: bool) -> Result<()> {
+    let cmd = if enable {
+        libc::RB_ENABLE_CAD
+    } else {
+        libc::RB_DISABLE_CAD
+    };
+    let res = unsafe {
+        libc::reboot(cmd)
+    };
+    Errno::result(res).map(drop)
+}

--- a//dev/null
+++ b/src/sys/signal.rs
@@ -0,0 +1,814 @@
+use crate::{Error, Result};
+use crate::errno::Errno;
+use crate::unistd::Pid;
+use std::convert::TryFrom;
+use std::mem;
+use std::fmt;
+use std::str::FromStr;
+#[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+use std::os::unix::io::RawFd;
+use std::ptr;
+#[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
+pub use self::sigevent::*;
+libc_enum!{
+    #[repr(i32)]
+    pub enum Signal {
+        SIGHUP,
+        SIGINT,
+        SIGQUIT,
+        SIGILL,
+        SIGTRAP,
+        SIGABRT,
+        SIGBUS,
+        SIGFPE,
+        SIGKILL,
+        SIGUSR1,
+        SIGSEGV,
+        SIGUSR2,
+        SIGPIPE,
+        SIGALRM,
+        SIGTERM,
+        #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"),
+                  not(any(target_arch = "mips", target_arch = "mips64",
+                          target_arch = "sparc64"))))]
+        SIGSTKFLT,
+        SIGCHLD,
+        SIGCONT,
+        SIGSTOP,
+        SIGTSTP,
+        SIGTTIN,
+        SIGTTOU,
+        SIGURG,
+        SIGXCPU,
+        SIGXFSZ,
+        SIGVTALRM,
+        SIGPROF,
+        SIGWINCH,
+        SIGIO,
+        #[cfg(any(target_os = "android", target_os = "emscripten",
+                  target_os = "fuchsia", target_os = "linux"))]
+        SIGPWR,
+        SIGSYS,
+        #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux",
+                      target_os = "redox")))]
+        SIGEMT,
+        #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux",
+                      target_os = "redox")))]
+        SIGINFO,
+    }
+}
+impl FromStr for Signal {
+    type Err = Error;
+    fn from_str(s: &str) -> Result<Signal> {
+        Ok(match s {
+            "SIGHUP" => Signal::SIGHUP,
+            "SIGINT" => Signal::SIGINT,
+            "SIGQUIT" => Signal::SIGQUIT,
+            "SIGILL" => Signal::SIGILL,
+            "SIGTRAP" => Signal::SIGTRAP,
+            "SIGABRT" => Signal::SIGABRT,
+            "SIGBUS" => Signal::SIGBUS,
+            "SIGFPE" => Signal::SIGFPE,
+            "SIGKILL" => Signal::SIGKILL,
+            "SIGUSR1" => Signal::SIGUSR1,
+            "SIGSEGV" => Signal::SIGSEGV,
+            "SIGUSR2" => Signal::SIGUSR2,
+            "SIGPIPE" => Signal::SIGPIPE,
+            "SIGALRM" => Signal::SIGALRM,
+            "SIGTERM" => Signal::SIGTERM,
+            #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux"),
+                      not(any(target_arch = "mips", target_arch = "mips64",
+                              target_arch = "sparc64"))))]
+            "SIGSTKFLT" => Signal::SIGSTKFLT,
+            "SIGCHLD" => Signal::SIGCHLD,
+            "SIGCONT" => Signal::SIGCONT,
+            "SIGSTOP" => Signal::SIGSTOP,
+            "SIGTSTP" => Signal::SIGTSTP,
+            "SIGTTIN" => Signal::SIGTTIN,
+            "SIGTTOU" => Signal::SIGTTOU,
+            "SIGURG" => Signal::SIGURG,
+            "SIGXCPU" => Signal::SIGXCPU,
+            "SIGXFSZ" => Signal::SIGXFSZ,
+            "SIGVTALRM" => Signal::SIGVTALRM,
+            "SIGPROF" => Signal::SIGPROF,
+            "SIGWINCH" => Signal::SIGWINCH,
+            "SIGIO" => Signal::SIGIO,
+            #[cfg(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"))]
+            "SIGPWR" => Signal::SIGPWR,
+            "SIGSYS" => Signal::SIGSYS,
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
+            "SIGEMT" => Signal::SIGEMT,
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
+            "SIGINFO" => Signal::SIGINFO,
+            _ => return Err(Error::from(Errno::EINVAL)),
+        })
+    }
+}
+impl Signal {
+    pub fn as_str(self) -> &'static str {
+        match self {
+            Signal::SIGHUP => "SIGHUP",
+            Signal::SIGINT => "SIGINT",
+            Signal::SIGQUIT => "SIGQUIT",
+            Signal::SIGILL => "SIGILL",
+            Signal::SIGTRAP => "SIGTRAP",
+            Signal::SIGABRT => "SIGABRT",
+            Signal::SIGBUS => "SIGBUS",
+            Signal::SIGFPE => "SIGFPE",
+            Signal::SIGKILL => "SIGKILL",
+            Signal::SIGUSR1 => "SIGUSR1",
+            Signal::SIGSEGV => "SIGSEGV",
+            Signal::SIGUSR2 => "SIGUSR2",
+            Signal::SIGPIPE => "SIGPIPE",
+            Signal::SIGALRM => "SIGALRM",
+            Signal::SIGTERM => "SIGTERM",
+            #[cfg(all(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux"),
+                      not(any(target_arch = "mips", target_arch = "mips64", target_arch = "sparc64"))))]
+            Signal::SIGSTKFLT => "SIGSTKFLT",
+            Signal::SIGCHLD => "SIGCHLD",
+            Signal::SIGCONT => "SIGCONT",
+            Signal::SIGSTOP => "SIGSTOP",
+            Signal::SIGTSTP => "SIGTSTP",
+            Signal::SIGTTIN => "SIGTTIN",
+            Signal::SIGTTOU => "SIGTTOU",
+            Signal::SIGURG => "SIGURG",
+            Signal::SIGXCPU => "SIGXCPU",
+            Signal::SIGXFSZ => "SIGXFSZ",
+            Signal::SIGVTALRM => "SIGVTALRM",
+            Signal::SIGPROF => "SIGPROF",
+            Signal::SIGWINCH => "SIGWINCH",
+            Signal::SIGIO => "SIGIO",
+            #[cfg(any(target_os = "android", target_os = "emscripten",
+                      target_os = "fuchsia", target_os = "linux"))]
+            Signal::SIGPWR => "SIGPWR",
+            Signal::SIGSYS => "SIGSYS",
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
+            Signal::SIGEMT => "SIGEMT",
+            #[cfg(not(any(target_os = "android", target_os = "emscripten",
+                          target_os = "fuchsia", target_os = "linux",
+                          target_os = "redox")))]
+            Signal::SIGINFO => "SIGINFO",
+        }
+    }
+}
+impl AsRef<str> for Signal {
+    fn as_ref(&self) -> &str {
+        self.as_str()
+    }
+}
+impl fmt::Display for Signal {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        f.write_str(self.as_ref())
+    }
+}
+pub use self::Signal::*;
+#[cfg(target_os = "redox")]
+const SIGNALS: [Signal; 29] = [
+    SIGHUP,
+    SIGINT,
+    SIGQUIT,
+    SIGILL,
+    SIGTRAP,
+    SIGABRT,
+    SIGBUS,
+    SIGFPE,
+    SIGKILL,
+    SIGUSR1,
+    SIGSEGV,
+    SIGUSR2,
+    SIGPIPE,
+    SIGALRM,
+    SIGTERM,
+    SIGCHLD,
+    SIGCONT,
+    SIGSTOP,
+    SIGTSTP,
+    SIGTTIN,
+    SIGTTOU,
+    SIGURG,
+    SIGXCPU,
+    SIGXFSZ,
+    SIGVTALRM,
+    SIGPROF,
+    SIGWINCH,
+    SIGIO,
+    SIGSYS];
+#[cfg(all(any(target_os = "linux", target_os = "android",
+              target_os = "emscripten", target_os = "fuchsia"),
+          not(any(target_arch = "mips", target_arch = "mips64",
+                  target_arch = "sparc64"))))]
+const SIGNALS: [Signal; 31] = [
+    SIGHUP,
+    SIGINT,
+    SIGQUIT,
+    SIGILL,
+    SIGTRAP,
+    SIGABRT,
+    SIGBUS,
+    SIGFPE,
+    SIGKILL,
+    SIGUSR1,
+    SIGSEGV,
+    SIGUSR2,
+    SIGPIPE,
+    SIGALRM,
+    SIGTERM,
+    SIGSTKFLT,
+    SIGCHLD,
+    SIGCONT,
+    SIGSTOP,
+    SIGTSTP,
+    SIGTTIN,
+    SIGTTOU,
+    SIGURG,
+    SIGXCPU,
+    SIGXFSZ,
+    SIGVTALRM,
+    SIGPROF,
+    SIGWINCH,
+    SIGIO,
+    SIGPWR,
+    SIGSYS];
+#[cfg(all(any(target_os = "linux", target_os = "android",
+              target_os = "emscripten", target_os = "fuchsia"),
+          any(target_arch = "mips", target_arch = "mips64",
+              target_arch = "sparc64")))]
+const SIGNALS: [Signal; 30] = [
+    SIGHUP,
+    SIGINT,
+    SIGQUIT,
+    SIGILL,
+    SIGTRAP,
+    SIGABRT,
+    SIGBUS,
+    SIGFPE,
+    SIGKILL,
+    SIGUSR1,
+    SIGSEGV,
+    SIGUSR2,
+    SIGPIPE,
+    SIGALRM,
+    SIGTERM,
+    SIGCHLD,
+    SIGCONT,
+    SIGSTOP,
+    SIGTSTP,
+    SIGTTIN,
+    SIGTTOU,
+    SIGURG,
+    SIGXCPU,
+    SIGXFSZ,
+    SIGVTALRM,
+    SIGPROF,
+    SIGWINCH,
+    SIGIO,
+    SIGPWR,
+    SIGSYS];
+#[cfg(not(any(target_os = "linux", target_os = "android",
+              target_os = "fuchsia", target_os = "emscripten",
+              target_os = "redox")))]
+const SIGNALS: [Signal; 31] = [
+    SIGHUP,
+    SIGINT,
+    SIGQUIT,
+    SIGILL,
+    SIGTRAP,
+    SIGABRT,
+    SIGBUS,
+    SIGFPE,
+    SIGKILL,
+    SIGUSR1,
+    SIGSEGV,
+    SIGUSR2,
+    SIGPIPE,
+    SIGALRM,
+    SIGTERM,
+    SIGCHLD,
+    SIGCONT,
+    SIGSTOP,
+    SIGTSTP,
+    SIGTTIN,
+    SIGTTOU,
+    SIGURG,
+    SIGXCPU,
+    SIGXFSZ,
+    SIGVTALRM,
+    SIGPROF,
+    SIGWINCH,
+    SIGIO,
+    SIGSYS,
+    SIGEMT,
+    SIGINFO];
+pub const NSIG: libc::c_int = 32;
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct SignalIterator {
+    next: usize,
+}
+impl Iterator for SignalIterator {
+    type Item = Signal;
+    fn next(&mut self) -> Option<Signal> {
+        if self.next < SIGNALS.len() {
+            let next_signal = SIGNALS[self.next];
+            self.next += 1;
+            Some(next_signal)
+        } else {
+            None
+        }
+    }
+}
+impl Signal {
+    pub fn iterator() -> SignalIterator {
+        SignalIterator{next: 0}
+    }
+}
+impl TryFrom<libc::c_int> for Signal {
+    type Error = Error;
+    fn try_from(signum: libc::c_int) -> Result<Signal> {
+        if 0 < signum && signum < NSIG {
+            Ok(unsafe { mem::transmute(signum) })
+        } else {
+            Err(Error::from(Errno::EINVAL))
+        }
+    }
+}
+pub const SIGIOT : Signal = SIGABRT;
+pub const SIGPOLL : Signal = SIGIO;
+pub const SIGUNUSED : Signal = SIGSYS;
+#[cfg(not(target_os = "redox"))]
+type SaFlags_t = libc::c_int;
+#[cfg(target_os = "redox")]
+type SaFlags_t = libc::c_ulong;
+libc_bitflags!{
+    pub struct SaFlags: SaFlags_t {
+        SA_NOCLDSTOP;
+        SA_NOCLDWAIT;
+        SA_NODEFER;
+        SA_ONSTACK;
+        SA_RESETHAND;
+        SA_RESTART;
+        SA_SIGINFO;
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum SigmaskHow {
+        SIG_BLOCK,
+        SIG_UNBLOCK,
+        SIG_SETMASK,
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct SigSet {
+    sigset: libc::sigset_t
+}
+impl SigSet {
+    pub fn all() -> SigSet {
+        let mut sigset = mem::MaybeUninit::uninit();
+        let _ = unsafe { libc::sigfillset(sigset.as_mut_ptr()) };
+        unsafe{ SigSet { sigset: sigset.assume_init() } }
+    }
+    pub fn empty() -> SigSet {
+        let mut sigset = mem::MaybeUninit::uninit();
+        let _ = unsafe { libc::sigemptyset(sigset.as_mut_ptr()) };
+        unsafe{ SigSet { sigset: sigset.assume_init() } }
+    }
+    pub fn add(&mut self, signal: Signal) {
+        unsafe { libc::sigaddset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
+    }
+    pub fn clear(&mut self) {
+        unsafe { libc::sigemptyset(&mut self.sigset as *mut libc::sigset_t) };
+    }
+    pub fn remove(&mut self, signal: Signal) {
+        unsafe { libc::sigdelset(&mut self.sigset as *mut libc::sigset_t, signal as libc::c_int) };
+    }
+    pub fn contains(&self, signal: Signal) -> bool {
+        let res = unsafe { libc::sigismember(&self.sigset as *const libc::sigset_t, signal as libc::c_int) };
+        match res {
+            1 => true,
+            0 => false,
+            _ => unreachable!("unexpected value from sigismember"),
+        }
+    }
+    pub fn extend(&mut self, other: &SigSet) {
+        for signal in Signal::iterator() {
+            if other.contains(signal) {
+                self.add(signal);
+            }
+        }
+    }
+    pub fn thread_get_mask() -> Result<SigSet> {
+        let mut oldmask = mem::MaybeUninit::uninit();
+        do_pthread_sigmask(SigmaskHow::SIG_SETMASK, None, Some(oldmask.as_mut_ptr()))?;
+        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
+    }
+    pub fn thread_set_mask(&self) -> Result<()> {
+        pthread_sigmask(SigmaskHow::SIG_SETMASK, Some(self), None)
+    }
+    pub fn thread_block(&self) -> Result<()> {
+        pthread_sigmask(SigmaskHow::SIG_BLOCK, Some(self), None)
+    }
+    pub fn thread_unblock(&self) -> Result<()> {
+        pthread_sigmask(SigmaskHow::SIG_UNBLOCK, Some(self), None)
+    }
+    pub fn thread_swap_mask(&self, how: SigmaskHow) -> Result<SigSet> {
+        let mut oldmask = mem::MaybeUninit::uninit();
+        do_pthread_sigmask(how, Some(self), Some(oldmask.as_mut_ptr()))?;
+        Ok(unsafe{ SigSet{sigset: oldmask.assume_init()}})
+    }
+    #[cfg(not(target_os = "redox"))] // RedoxFS does not yet support sigwait
+    pub fn wait(&self) -> Result<Signal> {
+        let mut signum = mem::MaybeUninit::uninit();
+        let res = unsafe { libc::sigwait(&self.sigset as *const libc::sigset_t, signum.as_mut_ptr()) };
+        Errno::result(res).map(|_| unsafe {
+            Signal::try_from(signum.assume_init()).unwrap()
+        })
+    }
+}
+impl AsRef<libc::sigset_t> for SigSet {
+    fn as_ref(&self) -> &libc::sigset_t {
+        &self.sigset
+    }
+}
+#[allow(unknown_lints)]
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum SigHandler {
+    SigDfl,
+    SigIgn,
+    Handler(extern fn(libc::c_int)),
+    #[cfg(not(target_os = "redox"))]
+    SigAction(extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void))
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct SigAction {
+    sigaction: libc::sigaction
+}
+impl SigAction {
+    pub fn new(handler: SigHandler, flags: SaFlags, mask: SigSet) -> SigAction {
+        #[cfg(target_os = "redox")]
+        unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
+            (*p).sa_handler = match handler {
+                SigHandler::SigDfl => libc::SIG_DFL,
+                SigHandler::SigIgn => libc::SIG_IGN,
+                SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
+            };
+        }
+        #[cfg(not(target_os = "redox"))]
+        unsafe fn install_sig(p: *mut libc::sigaction, handler: SigHandler) {
+            (*p).sa_sigaction = match handler {
+                SigHandler::SigDfl => libc::SIG_DFL,
+                SigHandler::SigIgn => libc::SIG_IGN,
+                SigHandler::Handler(f) => f as *const extern fn(libc::c_int) as usize,
+                SigHandler::SigAction(f) => f as *const extern fn(libc::c_int, *mut libc::siginfo_t, *mut libc::c_void) as usize,
+            };
+        }
+        let mut s = mem::MaybeUninit::<libc::sigaction>::uninit();
+        unsafe {
+            let p = s.as_mut_ptr();
+            install_sig(p, handler);
+            (*p).sa_flags = match handler {
+                #[cfg(not(target_os = "redox"))]
+                SigHandler::SigAction(_) => (flags | SaFlags::SA_SIGINFO).bits(),
+                _ => (flags - SaFlags::SA_SIGINFO).bits(),
+            };
+            (*p).sa_mask = mask.sigset;
+            SigAction { sigaction: s.assume_init() }
+        }
+    }
+    pub fn flags(&self) -> SaFlags {
+        SaFlags::from_bits_truncate(self.sigaction.sa_flags)
+    }
+    pub fn mask(&self) -> SigSet {
+        SigSet { sigset: self.sigaction.sa_mask }
+    }
+    #[cfg(not(target_os = "redox"))]
+    pub fn handler(&self) -> SigHandler {
+        match self.sigaction.sa_sigaction {
+            libc::SIG_DFL => SigHandler::SigDfl,
+            libc::SIG_IGN => SigHandler::SigIgn,
+            f if self.flags().contains(SaFlags::SA_SIGINFO) =>
+                SigHandler::SigAction( unsafe { mem::transmute(f) } ),
+            f => SigHandler::Handler( unsafe { mem::transmute(f) } ),
+        }
+    }
+    #[cfg(target_os = "redox")]
+    pub fn handler(&self) -> SigHandler {
+        match self.sigaction.sa_handler {
+            libc::SIG_DFL => SigHandler::SigDfl,
+            libc::SIG_IGN => SigHandler::SigIgn,
+            f => SigHandler::Handler( unsafe { mem::transmute(f) } ),
+        }
+    }
+}
+pub unsafe fn sigaction(signal: Signal, sigaction: &SigAction) -> Result<SigAction> {
+    let mut oldact = mem::MaybeUninit::<libc::sigaction>::uninit();
+    let res = libc::sigaction(signal as libc::c_int,
+                              &sigaction.sigaction as *const libc::sigaction,
+                              oldact.as_mut_ptr());
+    Errno::result(res).map(|_| SigAction { sigaction: oldact.assume_init() })
+}
+pub unsafe fn signal(signal: Signal, handler: SigHandler) -> Result<SigHandler> {
+    let signal = signal as libc::c_int;
+    let res = match handler {
+        SigHandler::SigDfl => libc::signal(signal, libc::SIG_DFL),
+        SigHandler::SigIgn => libc::signal(signal, libc::SIG_IGN),
+        SigHandler::Handler(handler) => libc::signal(signal, handler as libc::sighandler_t),
+        #[cfg(not(target_os = "redox"))]
+        SigHandler::SigAction(_) => return Err(Error::from(Errno::ENOTSUP)),
+    };
+    Errno::result(res).map(|oldhandler| {
+        match oldhandler {
+            libc::SIG_DFL => SigHandler::SigDfl,
+            libc::SIG_IGN => SigHandler::SigIgn,
+            f => SigHandler::Handler(mem::transmute(f)),
+        }
+    })
+}
+fn do_pthread_sigmask(how: SigmaskHow,
+                       set: Option<&SigSet>,
+                       oldset: Option<*mut libc::sigset_t>) -> Result<()> {
+    if set.is_none() && oldset.is_none() {
+        return Ok(())
+    }
+    let res = unsafe {
+        libc::pthread_sigmask(how as libc::c_int,
+                             set.map_or_else(ptr::null::<libc::sigset_t>,
+                                             |s| &s.sigset as *const libc::sigset_t),
+                             oldset.unwrap_or(ptr::null_mut())
+                             )
+    };
+    Errno::result(res).map(drop)
+}
+pub fn pthread_sigmask(how: SigmaskHow,
+                       set: Option<&SigSet>,
+                       oldset: Option<&mut SigSet>) -> Result<()>
+{
+    do_pthread_sigmask(how, set, oldset.map(|os| &mut os.sigset as *mut _ ))
+}
+pub fn sigprocmask(how: SigmaskHow, set: Option<&SigSet>, oldset: Option<&mut SigSet>) -> Result<()> {
+    if set.is_none() && oldset.is_none() {
+        return Ok(())
+    }
+    let res = unsafe {
+        libc::sigprocmask(how as libc::c_int,
+                          set.map_or_else(ptr::null::<libc::sigset_t>,
+                                          |s| &s.sigset as *const libc::sigset_t),
+                          oldset.map_or_else(ptr::null_mut::<libc::sigset_t>,
+                                             |os| &mut os.sigset as *mut libc::sigset_t))
+    };
+    Errno::result(res).map(drop)
+}
+pub fn kill<T: Into<Option<Signal>>>(pid: Pid, signal: T) -> Result<()> {
+    let res = unsafe { libc::kill(pid.into(),
+                                  match signal.into() {
+                                      Some(s) => s as libc::c_int,
+                                      None => 0,
+                                  }) };
+    Errno::result(res).map(drop)
+}
+#[cfg(not(target_os = "fuchsia"))]
+pub fn killpg<T: Into<Option<Signal>>>(pgrp: Pid, signal: T) -> Result<()> {
+    let res = unsafe { libc::killpg(pgrp.into(),
+                                  match signal.into() {
+                                      Some(s) => s as libc::c_int,
+                                      None => 0,
+                                  }) };
+    Errno::result(res).map(drop)
+}
+pub fn raise(signal: Signal) -> Result<()> {
+    let res = unsafe { libc::raise(signal as libc::c_int) };
+    Errno::result(res).map(drop)
+}
+#[cfg(target_os = "freebsd")]
+pub type type_of_thread_id = libc::lwpid_t;
+#[cfg(target_os = "linux")]
+pub type type_of_thread_id = libc::pid_t;
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum SigevNotify {
+    SigevNone,
+    SigevSignal { signal: Signal, si_value: libc::intptr_t },
+    #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+    SigevKevent { kq: RawFd, udata: libc::intptr_t },
+    #[cfg(any(target_os = "freebsd", target_os = "linux"))]
+    SigevThreadId { signal: Signal, thread_id: type_of_thread_id,
+                    si_value: libc::intptr_t },
+}
+#[cfg(not(any(target_os = "openbsd", target_os = "redox")))]
+mod sigevent {
+    use std::mem;
+    use std::ptr;
+    use super::SigevNotify;
+    #[cfg(any(target_os = "freebsd", target_os = "linux"))]
+    use super::type_of_thread_id;
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+    pub struct SigEvent {
+        sigevent: libc::sigevent
+    }
+    impl SigEvent {
+        #[cfg_attr(target_os = "fuchsia", allow(invalid_value))]
+        pub fn new(sigev_notify: SigevNotify) -> SigEvent {
+            let mut sev = unsafe { mem::MaybeUninit::<libc::sigevent>::zeroed().assume_init() };
+            sev.sigev_notify = match sigev_notify {
+                SigevNotify::SigevNone => libc::SIGEV_NONE,
+                SigevNotify::SigevSignal{..} => libc::SIGEV_SIGNAL,
+                #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+                SigevNotify::SigevKevent{..} => libc::SIGEV_KEVENT,
+                #[cfg(target_os = "freebsd")]
+                SigevNotify::SigevThreadId{..} => libc::SIGEV_THREAD_ID,
+                #[cfg(all(target_os = "linux", target_env = "gnu", not(target_arch = "mips")))]
+                SigevNotify::SigevThreadId{..} => libc::SIGEV_THREAD_ID,
+                #[cfg(any(all(target_os = "linux", target_env = "musl"), target_arch = "mips"))]
+                SigevNotify::SigevThreadId{..} => 4  // No SIGEV_THREAD_ID defined
+            };
+            sev.sigev_signo = match sigev_notify {
+                SigevNotify::SigevSignal{ signal, .. } => signal as libc::c_int,
+                #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+                SigevNotify::SigevKevent{ kq, ..} => kq,
+                #[cfg(any(target_os = "linux", target_os = "freebsd"))]
+                SigevNotify::SigevThreadId{ signal, .. } => signal as libc::c_int,
+                _ => 0
+            };
+            sev.sigev_value.sival_ptr = match sigev_notify {
+                SigevNotify::SigevNone => ptr::null_mut::<libc::c_void>(),
+                SigevNotify::SigevSignal{ si_value, .. } => si_value as *mut libc::c_void,
+                #[cfg(any(target_os = "dragonfly", target_os = "freebsd"))]
+                SigevNotify::SigevKevent{ udata, .. } => udata as *mut libc::c_void,
+                #[cfg(any(target_os = "freebsd", target_os = "linux"))]
+                SigevNotify::SigevThreadId{ si_value, .. } => si_value as *mut libc::c_void,
+            };
+            SigEvent::set_tid(&mut sev, &sigev_notify);
+            SigEvent{sigevent: sev}
+        }
+        #[cfg(any(target_os = "freebsd", target_os = "linux"))]
+        fn set_tid(sev: &mut libc::sigevent, sigev_notify: &SigevNotify) {
+            sev.sigev_notify_thread_id = match *sigev_notify {
+                SigevNotify::SigevThreadId { thread_id, .. } => thread_id,
+                _ => 0 as type_of_thread_id
+            };
+        }
+        #[cfg(not(any(target_os = "freebsd", target_os = "linux")))]
+        fn set_tid(_sev: &mut libc::sigevent, _sigev_notify: &SigevNotify) {
+        }
+        pub fn sigevent(&self) -> libc::sigevent {
+            self.sigevent
+        }
+    }
+    impl<'a> From<&'a libc::sigevent> for SigEvent {
+        fn from(sigevent: &libc::sigevent) -> Self {
+            SigEvent{ sigevent: *sigevent }
+        }
+    }
+}
+#[cfg(test)]
+mod tests {
+    #[cfg(not(target_os = "redox"))]
+    use std::thread;
+    use super::*;
+    #[test]
+    fn test_contains() {
+        let mut mask = SigSet::empty();
+        mask.add(SIGUSR1);
+        assert!(mask.contains(SIGUSR1));
+        assert!(!mask.contains(SIGUSR2));
+        let all = SigSet::all();
+        assert!(all.contains(SIGUSR1));
+        assert!(all.contains(SIGUSR2));
+    }
+    #[test]
+    fn test_clear() {
+        let mut set = SigSet::all();
+        set.clear();
+        for signal in Signal::iterator() {
+            assert!(!set.contains(signal));
+        }
+    }
+    #[test]
+    fn test_from_str_round_trips() {
+        for signal in Signal::iterator() {
+            assert_eq!(signal.as_ref().parse::<Signal>().unwrap(), signal);
+            assert_eq!(signal.to_string().parse::<Signal>().unwrap(), signal);
+        }
+    }
+    #[test]
+    fn test_from_str_invalid_value() {
+        let errval = Err(Error::from(Errno::EINVAL));
+        assert_eq!("NOSIGNAL".parse::<Signal>(), errval);
+        assert_eq!("kill".parse::<Signal>(), errval);
+        assert_eq!("9".parse::<Signal>(), errval);
+    }
+    #[test]
+    fn test_extend() {
+        let mut one_signal = SigSet::empty();
+        one_signal.add(SIGUSR1);
+        let mut two_signals = SigSet::empty();
+        two_signals.add(SIGUSR2);
+        two_signals.extend(&one_signal);
+        assert!(two_signals.contains(SIGUSR1));
+        assert!(two_signals.contains(SIGUSR2));
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_thread_signal_set_mask() {
+        thread::spawn(|| {
+            let prev_mask = SigSet::thread_get_mask()
+                .expect("Failed to get existing signal mask!");
+            let mut test_mask = prev_mask;
+            test_mask.add(SIGUSR1);
+            assert!(test_mask.thread_set_mask().is_ok());
+            let new_mask = SigSet::thread_get_mask()
+                .expect("Failed to get new mask!");
+            assert!(new_mask.contains(SIGUSR1));
+            assert!(!new_mask.contains(SIGUSR2));
+            prev_mask.thread_set_mask().expect("Failed to revert signal mask!");
+        }).join().unwrap();
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_thread_signal_block() {
+        thread::spawn(|| {
+            let mut mask = SigSet::empty();
+            mask.add(SIGUSR1);
+            assert!(mask.thread_block().is_ok());
+            assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
+        }).join().unwrap();
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_thread_signal_unblock() {
+        thread::spawn(|| {
+            let mut mask = SigSet::empty();
+            mask.add(SIGUSR1);
+            assert!(mask.thread_unblock().is_ok());
+            assert!(!SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
+        }).join().unwrap();
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_thread_signal_swap() {
+        thread::spawn(|| {
+            let mut mask = SigSet::empty();
+            mask.add(SIGUSR1);
+            mask.thread_block().unwrap();
+            assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR1));
+            let mut mask2 = SigSet::empty();
+            mask2.add(SIGUSR2);
+            let oldmask = mask2.thread_swap_mask(SigmaskHow::SIG_SETMASK)
+                .unwrap();
+            assert!(oldmask.contains(SIGUSR1));
+            assert!(!oldmask.contains(SIGUSR2));
+            assert!(SigSet::thread_get_mask().unwrap().contains(SIGUSR2));
+        }).join().unwrap();
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_sigaction() {
+        thread::spawn(|| {
+            extern fn test_sigaction_handler(_: libc::c_int) {}
+            extern fn test_sigaction_action(_: libc::c_int,
+                _: *mut libc::siginfo_t, _: *mut libc::c_void) {}
+            let handler_sig = SigHandler::Handler(test_sigaction_handler);
+            let flags = SaFlags::SA_ONSTACK | SaFlags::SA_RESTART |
+                        SaFlags::SA_SIGINFO;
+            let mut mask = SigSet::empty();
+            mask.add(SIGUSR1);
+            let action_sig = SigAction::new(handler_sig, flags, mask);
+            assert_eq!(action_sig.flags(),
+                       SaFlags::SA_ONSTACK | SaFlags::SA_RESTART);
+            assert_eq!(action_sig.handler(), handler_sig);
+            mask = action_sig.mask();
+            assert!(mask.contains(SIGUSR1));
+            assert!(!mask.contains(SIGUSR2));
+            let handler_act = SigHandler::SigAction(test_sigaction_action);
+            let action_act = SigAction::new(handler_act, flags, mask);
+            assert_eq!(action_act.handler(), handler_act);
+            let action_dfl = SigAction::new(SigHandler::SigDfl, flags, mask);
+            assert_eq!(action_dfl.handler(), SigHandler::SigDfl);
+            let action_ign = SigAction::new(SigHandler::SigIgn, flags, mask);
+            assert_eq!(action_ign.handler(), SigHandler::SigIgn);
+        }).join().unwrap();
+    }
+    #[test]
+    #[cfg(not(target_os = "redox"))]
+    fn test_sigwait() {
+        thread::spawn(|| {
+            let mut mask = SigSet::empty();
+            mask.add(SIGUSR1);
+            mask.add(SIGUSR2);
+            mask.thread_block().unwrap();
+            raise(SIGUSR1).unwrap();
+            assert_eq!(mask.wait().unwrap(), SIGUSR1);
+        }).join().unwrap();
+    }
+}

--- a//dev/null
+++ b/src/sys/signalfd.rs
@@ -0,0 +1,100 @@
+use libc;
+use crate::unistd;
+use crate::{Error, Result};
+use crate::errno::Errno;
+pub use crate::sys::signal::{self, SigSet};
+pub use libc::signalfd_siginfo as siginfo;
+use std::os::unix::io::{RawFd, AsRawFd};
+use std::mem;
+libc_bitflags!{
+    pub struct SfdFlags: libc::c_int {
+        SFD_NONBLOCK;
+        SFD_CLOEXEC;
+    }
+}
+pub const SIGNALFD_NEW: RawFd = -1;
+pub const SIGNALFD_SIGINFO_SIZE: usize = 128;
+pub fn signalfd(fd: RawFd, mask: &SigSet, flags: SfdFlags) -> Result<RawFd> {
+    unsafe {
+        Errno::result(libc::signalfd(fd as libc::c_int, mask.as_ref(), flags.bits()))
+    }
+}
+#[derive(Debug, Eq, Hash, PartialEq)]
+pub struct SignalFd(RawFd);
+impl SignalFd {
+    pub fn new(mask: &SigSet) -> Result<SignalFd> {
+        Self::with_flags(mask, SfdFlags::empty())
+    }
+    pub fn with_flags(mask: &SigSet, flags: SfdFlags) -> Result<SignalFd> {
+        let fd = signalfd(SIGNALFD_NEW, mask, flags)?;
+        Ok(SignalFd(fd))
+    }
+    pub fn set_mask(&mut self, mask: &SigSet) -> Result<()> {
+        signalfd(self.0, mask, SfdFlags::empty()).map(drop)
+    }
+    pub fn read_signal(&mut self) -> Result<Option<siginfo>> {
+        let mut buffer = mem::MaybeUninit::<[u8; SIGNALFD_SIGINFO_SIZE]>::uninit();
+        let res = Errno::result(unsafe {
+            libc::read(self.0,
+                       buffer.as_mut_ptr() as *mut libc::c_void,
+                       SIGNALFD_SIGINFO_SIZE as libc::size_t)
+        }).map(|r| r as usize);
+        match res {
+            Ok(SIGNALFD_SIGINFO_SIZE) => Ok(Some(unsafe { mem::transmute(buffer.assume_init()) })),
+            Ok(_) => unreachable!("partial read on signalfd"),
+            Err(Errno::EAGAIN) => Ok(None),
+            Err(error) => Err(error)
+        }
+    }
+}
+impl Drop for SignalFd {
+    fn drop(&mut self) {
+        let e = unistd::close(self.0);
+        if !std::thread::panicking() && e == Err(Error::from(Errno::EBADF)) {
+            panic!("Closing an invalid file descriptor!");
+        };
+    }
+}
+impl AsRawFd for SignalFd {
+    fn as_raw_fd(&self) -> RawFd {
+        self.0
+    }
+}
+impl Iterator for SignalFd {
+    type Item = siginfo;
+    fn next(&mut self) -> Option<Self::Item> {
+        match self.read_signal() {
+            Ok(Some(sig)) => Some(sig),
+            Ok(None) | Err(_) => None,
+        }
+    }
+}
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::mem;
+    use libc;
+    #[test]
+    fn check_siginfo_size() {
+        assert_eq!(mem::size_of::<libc::signalfd_siginfo>(), SIGNALFD_SIGINFO_SIZE);
+    }
+    #[test]
+    fn create_signalfd() {
+        let mask = SigSet::empty();
+        let fd = SignalFd::new(&mask);
+        assert!(fd.is_ok());
+    }
+    #[test]
+    fn create_signalfd_with_opts() {
+        let mask = SigSet::empty();
+        let fd = SignalFd::with_flags(&mask, SfdFlags::SFD_CLOEXEC | SfdFlags::SFD_NONBLOCK);
+        assert!(fd.is_ok());
+    }
+    #[test]
+    fn read_empty_signalfd() {
+        let mask = SigSet::empty();
+        let mut fd = SignalFd::with_flags(&mask, SfdFlags::SFD_NONBLOCK).unwrap();
+        let res = fd.read_signal();
+        assert!(res.unwrap().is_none());
+    }
+}

--- a//dev/null
+++ b/src/sys/socket/addr.rs
@@ -0,0 +1,1117 @@
+use super::sa_family_t;
+use crate::{Error, Result, NixPath};
+use crate::errno::Errno;
+use memoffset::offset_of;
+use std::{fmt, mem, net, ptr, slice};
+use std::ffi::OsStr;
+use std::hash::{Hash, Hasher};
+use std::path::Path;
+use std::os::unix::ffi::OsStrExt;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+use crate::sys::socket::addr::netlink::NetlinkAddr;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+use crate::sys::socket::addr::alg::AlgAddr;
+#[cfg(any(target_os = "ios", target_os = "macos"))]
+use std::os::unix::io::RawFd;
+#[cfg(any(target_os = "ios", target_os = "macos"))]
+use crate::sys::socket::addr::sys_control::SysControlAddr;
+#[cfg(any(target_os = "android",
+          target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "ios",
+          target_os = "linux",
+          target_os = "macos",
+          target_os = "illumos",
+          target_os = "netbsd",
+          target_os = "openbsd",
+          target_os = "fuchsia"))]
+pub use self::datalink::LinkAddr;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use self::vsock::VsockAddr;
+#[repr(i32)]
+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]
+pub enum AddressFamily {
+    Unix = libc::AF_UNIX,
+    Inet = libc::AF_INET,
+    Inet6 = libc::AF_INET6,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Netlink = libc::AF_NETLINK,
+    #[cfg(any(target_os = "android",
+              target_os = "linux",
+              target_os = "illumos",
+              target_os = "fuchsia",
+              target_os = "solaris"))]
+    Packet = libc::AF_PACKET,
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
+    System = libc::AF_SYSTEM,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Ax25 = libc::AF_AX25,
+    Ipx = libc::AF_IPX,
+    AppleTalk = libc::AF_APPLETALK,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetRom = libc::AF_NETROM,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Bridge = libc::AF_BRIDGE,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    AtmPvc = libc::AF_ATMPVC,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    X25 = libc::AF_X25,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Rose = libc::AF_ROSE,
+    Decnet = libc::AF_DECnet,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetBeui = libc::AF_NETBEUI,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Security = libc::AF_SECURITY,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Key = libc::AF_KEY,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Ash = libc::AF_ASH,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Econet = libc::AF_ECONET,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    AtmSvc = libc::AF_ATMSVC,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Rds = libc::AF_RDS,
+    Sna = libc::AF_SNA,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Irda = libc::AF_IRDA,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Pppox = libc::AF_PPPOX,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Wanpipe = libc::AF_WANPIPE,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Llc = libc::AF_LLC,
+    #[cfg(target_os = "linux")]
+    Ib = libc::AF_IB,
+    #[cfg(target_os = "linux")]
+    Mpls = libc::AF_MPLS,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Can = libc::AF_CAN,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Tipc = libc::AF_TIPC,
+    #[cfg(not(any(target_os = "illumos",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "solaris")))]
+    Bluetooth = libc::AF_BLUETOOTH,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Iucv = libc::AF_IUCV,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    RxRpc = libc::AF_RXRPC,
+    #[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+    Isdn = libc::AF_ISDN,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Phonet = libc::AF_PHONET,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Ieee802154 = libc::AF_IEEE802154,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Caif = libc::AF_CAIF,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Alg = libc::AF_ALG,
+    #[cfg(target_os = "linux")]
+    Nfc = libc::AF_NFC,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Vsock = libc::AF_VSOCK,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    ImpLink = libc::AF_IMPLINK,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Pup = libc::AF_PUP,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Chaos = libc::AF_CHAOS,
+    #[cfg(any(target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Ns = libc::AF_NS,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Iso = libc::AF_ISO,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Datakit = libc::AF_DATAKIT,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Ccitt = libc::AF_CCITT,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Dli = libc::AF_DLI,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Lat = libc::AF_LAT,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Hylink = libc::AF_HYLINK,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "illumos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Link = libc::AF_LINK,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Coip = libc::AF_COIP,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Cnt = libc::AF_CNT,
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Natm = libc::AF_NATM,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Unspec = libc::AF_UNSPEC,
+}
+impl AddressFamily {
+    pub fn from_i32(family: i32) -> Option<AddressFamily> {
+        match family {
+            libc::AF_UNIX => Some(AddressFamily::Unix),
+            libc::AF_INET => Some(AddressFamily::Inet),
+            libc::AF_INET6 => Some(AddressFamily::Inet6),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            libc::AF_NETLINK => Some(AddressFamily::Netlink),
+            #[cfg(any(target_os = "macos", target_os = "macos"))]
+            libc::AF_SYSTEM => Some(AddressFamily::System),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            libc::AF_PACKET => Some(AddressFamily::Packet),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "ios",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "illumos",
+                      target_os = "openbsd"))]
+            libc::AF_LINK => Some(AddressFamily::Link),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            libc::AF_VSOCK => Some(AddressFamily::Vsock),
+            _ => None
+        }
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum InetAddr {
+    V4(libc::sockaddr_in),
+    V6(libc::sockaddr_in6),
+}
+impl InetAddr {
+    pub fn from_std(std: &net::SocketAddr) -> InetAddr {
+        match *std {
+            net::SocketAddr::V4(ref addr) => {
+                InetAddr::V4(libc::sockaddr_in {
+                    sin_family: AddressFamily::Inet as sa_family_t,
+                    sin_port: addr.port().to_be(),  // network byte order
+                    sin_addr: Ipv4Addr::from_std(addr.ip()).0,
+                    .. unsafe { mem::zeroed() }
+                })
+            }
+            net::SocketAddr::V6(ref addr) => {
+                InetAddr::V6(libc::sockaddr_in6 {
+                    sin6_family: AddressFamily::Inet6 as sa_family_t,
+                    sin6_port: addr.port().to_be(),  // network byte order
+                    sin6_addr: Ipv6Addr::from_std(addr.ip()).0,
+                    sin6_flowinfo: addr.flowinfo(),  // host byte order
+                    sin6_scope_id: addr.scope_id(),  // host byte order
+                    .. unsafe { mem::zeroed() }
+                })
+            }
+        }
+    }
+    pub fn new(ip: IpAddr, port: u16) -> InetAddr {
+        match ip {
+            IpAddr::V4(ref ip) => {
+                InetAddr::V4(libc::sockaddr_in {
+                    sin_family: AddressFamily::Inet as sa_family_t,
+                    sin_port: port.to_be(),
+                    sin_addr: ip.0,
+                    .. unsafe { mem::zeroed() }
+                })
+            }
+            IpAddr::V6(ref ip) => {
+                InetAddr::V6(libc::sockaddr_in6 {
+                    sin6_family: AddressFamily::Inet6 as sa_family_t,
+                    sin6_port: port.to_be(),
+                    sin6_addr: ip.0,
+                    .. unsafe { mem::zeroed() }
+                })
+            }
+        }
+    }
+    pub fn ip(&self) -> IpAddr {
+        match *self {
+            InetAddr::V4(ref sa) => IpAddr::V4(Ipv4Addr(sa.sin_addr)),
+            InetAddr::V6(ref sa) => IpAddr::V6(Ipv6Addr(sa.sin6_addr)),
+        }
+    }
+    pub fn port(&self) -> u16 {
+        match *self {
+            InetAddr::V6(ref sa) => u16::from_be(sa.sin6_port),
+            InetAddr::V4(ref sa) => u16::from_be(sa.sin_port),
+        }
+    }
+    pub fn to_std(&self) -> net::SocketAddr {
+        match *self {
+            InetAddr::V4(ref sa) => net::SocketAddr::V4(
+                net::SocketAddrV4::new(
+                    Ipv4Addr(sa.sin_addr).to_std(),
+                    self.port())),
+            InetAddr::V6(ref sa) => net::SocketAddr::V6(
+                net::SocketAddrV6::new(
+                    Ipv6Addr(sa.sin6_addr).to_std(),
+                    self.port(),
+                    sa.sin6_flowinfo,
+                    sa.sin6_scope_id)),
+        }
+    }
+    pub fn to_str(&self) -> String {
+        format!("{}", self)
+    }
+}
+impl fmt::Display for InetAddr {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            InetAddr::V4(_) => write!(f, "{}:{}", self.ip(), self.port()),
+            InetAddr::V6(_) => write!(f, "[{}]:{}", self.ip(), self.port()),
+        }
+    }
+}
+/*
+ *
+ * ===== IpAddr =====
+ *
+ */
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum IpAddr {
+    V4(Ipv4Addr),
+    V6(Ipv6Addr),
+}
+impl IpAddr {
+    pub fn new_v4(a: u8, b: u8, c: u8, d: u8) -> IpAddr {
+        IpAddr::V4(Ipv4Addr::new(a, b, c, d))
+    }
+    #[allow(clippy::many_single_char_names)]
+    #[allow(clippy::too_many_arguments)]
+    pub fn new_v6(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> IpAddr {
+        IpAddr::V6(Ipv6Addr::new(a, b, c, d, e, f, g, h))
+    }
+    pub fn from_std(std: &net::IpAddr) -> IpAddr {
+        match *std {
+            net::IpAddr::V4(ref std) => IpAddr::V4(Ipv4Addr::from_std(std)),
+            net::IpAddr::V6(ref std) => IpAddr::V6(Ipv6Addr::from_std(std)),
+        }
+    }
+    pub fn to_std(&self) -> net::IpAddr {
+        match *self {
+            IpAddr::V4(ref ip) => net::IpAddr::V4(ip.to_std()),
+            IpAddr::V6(ref ip) => net::IpAddr::V6(ip.to_std()),
+        }
+    }
+}
+impl fmt::Display for IpAddr {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            IpAddr::V4(ref v4) => v4.fmt(f),
+            IpAddr::V6(ref v6) => v6.fmt(f)
+        }
+    }
+}
+/*
+ *
+ * ===== Ipv4Addr =====
+ *
+ */
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct Ipv4Addr(pub libc::in_addr);
+impl Ipv4Addr {
+    #[allow(clippy::identity_op)]   // More readable this way
+    pub fn new(a: u8, b: u8, c: u8, d: u8) -> Ipv4Addr {
+        let ip = ((u32::from(a) << 24) |
+                  (u32::from(b) << 16) |
+                  (u32::from(c) <<  8) |
+                  (u32::from(d) <<  0)).to_be();
+        Ipv4Addr(libc::in_addr { s_addr: ip })
+    }
+    #[allow(clippy::trivially_copy_pass_by_ref)]
+    pub fn from_std(std: &net::Ipv4Addr) -> Ipv4Addr {
+        let bits = std.octets();
+        Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
+    }
+    pub fn any() -> Ipv4Addr {
+        Ipv4Addr(libc::in_addr { s_addr: libc::INADDR_ANY })
+    }
+    pub fn octets(self) -> [u8; 4] {
+        let bits = u32::from_be(self.0.s_addr);
+        [(bits >> 24) as u8, (bits >> 16) as u8, (bits >> 8) as u8, bits as u8]
+    }
+    pub fn to_std(self) -> net::Ipv4Addr {
+        let bits = self.octets();
+        net::Ipv4Addr::new(bits[0], bits[1], bits[2], bits[3])
+    }
+}
+impl fmt::Display for Ipv4Addr {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        let octets = self.octets();
+        write!(fmt, "{}.{}.{}.{}", octets[0], octets[1], octets[2], octets[3])
+    }
+}
+/*
+ *
+ * ===== Ipv6Addr =====
+ *
+ */
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct Ipv6Addr(pub libc::in6_addr);
+macro_rules! to_u8_array {
+    ($($num:ident),*) => {
+        [ $(($num>>8) as u8, ($num&0xff) as u8,)* ]
+    }
+}
+macro_rules! to_u16_array {
+    ($slf:ident, $($first:expr, $second:expr),*) => {
+        [$( (($slf.0.s6_addr[$first] as u16) << 8) + $slf.0.s6_addr[$second] as u16,)*]
+    }
+}
+impl Ipv6Addr {
+    #[allow(clippy::many_single_char_names)]
+    #[allow(clippy::too_many_arguments)]
+    pub fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {
+        Ipv6Addr(libc::in6_addr{s6_addr: to_u8_array!(a,b,c,d,e,f,g,h)})
+    }
+    pub fn from_std(std: &net::Ipv6Addr) -> Ipv6Addr {
+        let s = std.segments();
+        Ipv6Addr::new(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7])
+    }
+    pub fn segments(&self) -> [u16; 8] {
+        to_u16_array!(self, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
+    }
+    pub fn to_std(&self) -> net::Ipv6Addr {
+        let s = self.segments();
+        net::Ipv6Addr::new(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7])
+    }
+}
+impl fmt::Display for Ipv6Addr {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        self.to_std().fmt(fmt)
+    }
+}
+#[derive(Clone, Copy, Debug)]
+pub struct UnixAddr(pub libc::sockaddr_un, pub usize);
+impl UnixAddr {
+    pub fn new<P: ?Sized + NixPath>(path: &P) -> Result<UnixAddr> {
+        path.with_nix_path(|cstr| {
+            unsafe {
+                let mut ret = libc::sockaddr_un {
+                    sun_family: AddressFamily::Unix as sa_family_t,
+                    .. mem::zeroed()
+                };
+                let bytes = cstr.to_bytes();
+                if bytes.len() > ret.sun_path.len() {
+                    return Err(Error::from(Errno::ENAMETOOLONG));
+                }
+                ptr::copy_nonoverlapping(bytes.as_ptr(),
+                                         ret.sun_path.as_mut_ptr() as *mut u8,
+                                         bytes.len());
+                Ok(UnixAddr(ret, bytes.len()))
+            }
+        })?
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub fn new_abstract(path: &[u8]) -> Result<UnixAddr> {
+        unsafe {
+            let mut ret = libc::sockaddr_un {
+                sun_family: AddressFamily::Unix as sa_family_t,
+                .. mem::zeroed()
+            };
+            if path.len() + 1 > ret.sun_path.len() {
+                return Err(Error::from(Errno::ENAMETOOLONG));
+            }
+            ptr::copy_nonoverlapping(path.as_ptr(),
+                                     ret.sun_path.as_mut_ptr().offset(1) as *mut u8,
+                                     path.len());
+            Ok(UnixAddr(ret, path.len() + 1))
+        }
+    }
+    fn sun_path(&self) -> &[u8] {
+        unsafe { slice::from_raw_parts(self.0.sun_path.as_ptr() as *const u8, self.1) }
+    }
+    pub fn path(&self) -> Option<&Path> {
+        if self.1 == 0 || self.0.sun_path[0] == 0 {
+            None
+        } else {
+            let p = self.sun_path();
+            let ptr = &self.0.sun_path as *const libc::c_char;
+            let reallen = unsafe { libc::strnlen(ptr, p.len()) };
+            Some(Path::new(<OsStr as OsStrExt>::from_bytes(&p[..reallen])))
+        }
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub fn as_abstract(&self) -> Option<&[u8]> {
+        if self.1 >= 1 && self.0.sun_path[0] == 0 {
+            Some(&self.sun_path()[1..])
+        } else {
+            None
+        }
+    }
+}
+impl fmt::Display for UnixAddr {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        if self.1 == 0 {
+            f.write_str("<unbound UNIX socket>")
+        } else if let Some(path) = self.path() {
+            path.display().fmt(f)
+        } else {
+            let display = String::from_utf8_lossy(&self.sun_path()[1..]);
+            write!(f, "@{}", display)
+        }
+    }
+}
+impl PartialEq for UnixAddr {
+    fn eq(&self, other: &UnixAddr) -> bool {
+        self.sun_path() == other.sun_path()
+    }
+}
+impl Eq for UnixAddr {}
+impl Hash for UnixAddr {
+    fn hash<H: Hasher>(&self, s: &mut H) {
+        ( self.0.sun_family, self.sun_path() ).hash(s)
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum SockAddr {
+    Inet(InetAddr),
+    Unix(UnixAddr),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Netlink(NetlinkAddr),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Alg(AlgAddr),
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
+    SysControl(SysControlAddr),
+    #[cfg(any(target_os = "android",
+              target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "linux",
+              target_os = "macos",
+              target_os = "illumos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    Link(LinkAddr),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    Vsock(VsockAddr),
+}
+impl SockAddr {
+    pub fn new_inet(addr: InetAddr) -> SockAddr {
+        SockAddr::Inet(addr)
+    }
+    pub fn new_unix<P: ?Sized + NixPath>(path: &P) -> Result<SockAddr> {
+        Ok(SockAddr::Unix(UnixAddr::new(path)?))
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub fn new_netlink(pid: u32, groups: u32) -> SockAddr {
+        SockAddr::Netlink(NetlinkAddr::new(pid, groups))
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub fn new_alg(alg_type: &str, alg_name: &str) -> SockAddr {
+        SockAddr::Alg(AlgAddr::new(alg_type, alg_name))
+    }
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
+    pub fn new_sys_control(sockfd: RawFd, name: &str, unit: u32) -> Result<SockAddr> {
+        SysControlAddr::from_name(sockfd, name, unit).map(|a| SockAddr::SysControl(a))
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    pub fn new_vsock(cid: u32, port: u32) -> SockAddr {
+        SockAddr::Vsock(VsockAddr::new(cid, port))
+    }
+    pub fn family(&self) -> AddressFamily {
+        match *self {
+            SockAddr::Inet(InetAddr::V4(..)) => AddressFamily::Inet,
+            SockAddr::Inet(InetAddr::V6(..)) => AddressFamily::Inet6,
+            SockAddr::Unix(..) => AddressFamily::Unix,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Netlink(..) => AddressFamily::Netlink,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Alg(..) => AddressFamily::Alg,
+            #[cfg(any(target_os = "ios", target_os = "macos"))]
+            SockAddr::SysControl(..) => AddressFamily::System,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Link(..) => AddressFamily::Packet,
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "ios",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "illumos",
+                      target_os = "openbsd"))]
+            SockAddr::Link(..) => AddressFamily::Link,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Vsock(..) => AddressFamily::Vsock,
+        }
+    }
+    pub fn to_str(&self) -> String {
+        format!("{}", self)
+    }
+    #[cfg(not(target_os = "fuchsia"))]
+    pub(crate) unsafe fn from_libc_sockaddr(addr: *const libc::sockaddr) -> Option<SockAddr> {
+        if addr.is_null() {
+            None
+        } else {
+            match AddressFamily::from_i32(i32::from((*addr).sa_family)) {
+                Some(AddressFamily::Unix) => None,
+                Some(AddressFamily::Inet) => Some(SockAddr::Inet(
+                    InetAddr::V4(*(addr as *const libc::sockaddr_in)))),
+                Some(AddressFamily::Inet6) => Some(SockAddr::Inet(
+                    InetAddr::V6(*(addr as *const libc::sockaddr_in6)))),
+                #[cfg(any(target_os = "android", target_os = "linux"))]
+                Some(AddressFamily::Netlink) => Some(SockAddr::Netlink(
+                    NetlinkAddr(*(addr as *const libc::sockaddr_nl)))),
+                #[cfg(any(target_os = "ios", target_os = "macos"))]
+                Some(AddressFamily::System) => Some(SockAddr::SysControl(
+                    SysControlAddr(*(addr as *const libc::sockaddr_ctl)))),
+                #[cfg(any(target_os = "android", target_os = "linux"))]
+                Some(AddressFamily::Packet) => Some(SockAddr::Link(
+                    LinkAddr(*(addr as *const libc::sockaddr_ll)))),
+                #[cfg(any(target_os = "dragonfly",
+                          target_os = "freebsd",
+                          target_os = "ios",
+                          target_os = "macos",
+                          target_os = "netbsd",
+                          target_os = "illumos",
+                          target_os = "openbsd"))]
+                Some(AddressFamily::Link) => {
+                    let ether_addr = LinkAddr(*(addr as *const libc::sockaddr_dl));
+                    if ether_addr.is_empty() {
+                        None
+                    } else {
+                        Some(SockAddr::Link(ether_addr))
+                    }
+                },
+                #[cfg(any(target_os = "android", target_os = "linux"))]
+                Some(AddressFamily::Vsock) => Some(SockAddr::Vsock(
+                    VsockAddr(*(addr as *const libc::sockaddr_vm)))),
+                Some(_) | None => None,
+            }
+        }
+    }
+    pub fn as_ffi_pair(&self) -> (&libc::sockaddr, libc::socklen_t) {
+        match *self {
+            SockAddr::Inet(InetAddr::V4(ref addr)) => (
+                unsafe {
+                    &*(addr as *const libc::sockaddr_in as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            SockAddr::Inet(InetAddr::V6(ref addr)) => (
+                unsafe {
+                    &*(addr as *const libc::sockaddr_in6 as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            SockAddr::Unix(UnixAddr(ref addr, len)) => (
+                unsafe {
+                    &*(addr as *const libc::sockaddr_un as *const libc::sockaddr)
+                },
+                (len + offset_of!(libc::sockaddr_un, sun_path)) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Netlink(NetlinkAddr(ref sa)) => (
+                unsafe {
+                    &*(sa as *const libc::sockaddr_nl as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Alg(AlgAddr(ref sa)) => (
+                unsafe {
+                    &*(sa as *const libc::sockaddr_alg as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "ios", target_os = "macos"))]
+            SockAddr::SysControl(SysControlAddr(ref sa)) => (
+                unsafe {
+                    &*(sa as *const libc::sockaddr_ctl as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Link(LinkAddr(ref addr)) => (
+                unsafe {
+                    &*(addr as *const libc::sockaddr_ll as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "ios",
+                      target_os = "macos",
+                      target_os = "illumos",
+                      target_os = "netbsd",
+                      target_os = "openbsd"))]
+            SockAddr::Link(LinkAddr(ref addr)) => (
+                unsafe {
+                    &*(addr as *const libc::sockaddr_dl as *const libc::sockaddr)
+                },
+                mem::size_of_val(addr) as libc::socklen_t
+            ),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Vsock(VsockAddr(ref sa)) => (
+                unsafe {
+                    &*(sa as *const libc::sockaddr_vm as *const libc::sockaddr)
+                },
+                mem::size_of_val(sa) as libc::socklen_t
+            ),
+        }
+    }
+}
+impl fmt::Display for SockAddr {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match *self {
+            SockAddr::Inet(ref inet) => inet.fmt(f),
+            SockAddr::Unix(ref unix) => unix.fmt(f),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Netlink(ref nl) => nl.fmt(f),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Alg(ref nl) => nl.fmt(f),
+            #[cfg(any(target_os = "ios", target_os = "macos"))]
+            SockAddr::SysControl(ref sc) => sc.fmt(f),
+            #[cfg(any(target_os = "android",
+                      target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "ios",
+                      target_os = "linux",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "illumos",
+                      target_os = "openbsd"))]
+            SockAddr::Link(ref ether_addr) => ether_addr.fmt(f),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            SockAddr::Vsock(ref svm) => svm.fmt(f),
+        }
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub mod netlink {
+    use crate::sys::socket::addr::AddressFamily;
+    use libc::{sa_family_t, sockaddr_nl};
+    use std::{fmt, mem};
+    #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq)]
+    pub struct NetlinkAddr(pub sockaddr_nl);
+    impl NetlinkAddr {
+        pub fn new(pid: u32, groups: u32) -> NetlinkAddr {
+            let mut addr: sockaddr_nl = unsafe { mem::zeroed() };
+            addr.nl_family = AddressFamily::Netlink as sa_family_t;
+            addr.nl_pid = pid;
+            addr.nl_groups = groups;
+            NetlinkAddr(addr)
+        }
+        pub fn pid(&self) -> u32 {
+            self.0.nl_pid
+        }
+        pub fn groups(&self) -> u32 {
+            self.0.nl_groups
+        }
+    }
+    impl fmt::Display for NetlinkAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            write!(f, "pid: {} groups: {}", self.pid(), self.groups())
+        }
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub mod alg {
+    use libc::{AF_ALG, sockaddr_alg, c_char};
+    use std::{fmt, mem, str};
+    use std::hash::{Hash, Hasher};
+    use std::ffi::CStr;
+    #[derive(Copy, Clone)]
+    pub struct AlgAddr(pub sockaddr_alg);
+    impl PartialEq for AlgAddr {
+        fn eq(&self, other: &Self) -> bool {
+            let (inner, other) = (self.0, other.0);
+            (inner.salg_family, &inner.salg_type[..], inner.salg_feat, inner.salg_mask, &inner.salg_name[..]) ==
+            (other.salg_family, &other.salg_type[..], other.salg_feat, other.salg_mask, &other.salg_name[..])
+        }
+    }
+    impl Eq for AlgAddr {}
+    impl Hash for AlgAddr {
+        fn hash<H: Hasher>(&self, s: &mut H) {
+            let inner = self.0;
+            (inner.salg_family, &inner.salg_type[..], inner.salg_feat, inner.salg_mask, &inner.salg_name[..]).hash(s);
+        }
+    }
+    impl AlgAddr {
+        pub fn new(alg_type: &str, alg_name: &str) -> AlgAddr {
+            let mut addr: sockaddr_alg = unsafe { mem::zeroed() };
+            addr.salg_family = AF_ALG as u16;
+            addr.salg_type[..alg_type.len()].copy_from_slice(alg_type.to_string().as_bytes());
+            addr.salg_name[..alg_name.len()].copy_from_slice(alg_name.to_string().as_bytes());
+            AlgAddr(addr)
+        }
+        pub fn alg_type(&self) -> &CStr {
+            unsafe { CStr::from_ptr(self.0.salg_type.as_ptr() as *const c_char) }
+        }
+        pub fn alg_name(&self) -> &CStr {
+            unsafe { CStr::from_ptr(self.0.salg_name.as_ptr() as *const c_char) }
+        }
+    }
+    impl fmt::Display for AlgAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            write!(f, "type: {} alg: {}",
+                   self.alg_name().to_string_lossy(),
+                   self.alg_type().to_string_lossy())
+        }
+    }
+    impl fmt::Debug for AlgAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            fmt::Display::fmt(self, f)
+        }
+    }
+}
+#[cfg(any(target_os = "ios", target_os = "macos"))]
+pub mod sys_control {
+    use crate::sys::socket::addr::AddressFamily;
+    use libc::{self, c_uchar};
+    use std::{fmt, mem};
+    use std::os::unix::io::RawFd;
+    use crate::{Errno, Error, Result};
+    #[repr(C)]
+    #[derive(Clone, Copy)]
+    #[allow(missing_debug_implementations)]
+    pub struct ctl_ioc_info {
+        pub ctl_id: u32,
+        pub ctl_name: [c_uchar; MAX_KCTL_NAME],
+    }
+    const CTL_IOC_MAGIC: u8 = 'N' as u8;
+    const CTL_IOC_INFO: u8 = 3;
+    const MAX_KCTL_NAME: usize = 96;
+    ioctl_readwrite!(ctl_info, CTL_IOC_MAGIC, CTL_IOC_INFO, ctl_ioc_info);
+    #[repr(C)]
+    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+    pub struct SysControlAddr(pub libc::sockaddr_ctl);
+    impl SysControlAddr {
+        pub fn new(id: u32, unit: u32) -> SysControlAddr {
+            let addr = libc::sockaddr_ctl {
+                sc_len: mem::size_of::<libc::sockaddr_ctl>() as c_uchar,
+                sc_family: AddressFamily::System as c_uchar,
+                ss_sysaddr: libc::AF_SYS_CONTROL as u16,
+                sc_id: id,
+                sc_unit: unit,
+                sc_reserved: [0; 5]
+            };
+            SysControlAddr(addr)
+        }
+        pub fn from_name(sockfd: RawFd, name: &str, unit: u32) -> Result<SysControlAddr> {
+            if name.len() > MAX_KCTL_NAME {
+                return Err(Error::from(Errno::ENAMETOOLONG));
+            }
+            let mut ctl_name = [0; MAX_KCTL_NAME];
+            ctl_name[..name.len()].clone_from_slice(name.as_bytes());
+            let mut info = ctl_ioc_info { ctl_id: 0, ctl_name };
+            unsafe { ctl_info(sockfd, &mut info)?; }
+            Ok(SysControlAddr::new(info.ctl_id, unit))
+        }
+        pub fn id(&self) -> u32 {
+            self.0.sc_id
+        }
+        pub fn unit(&self) -> u32 {
+            self.0.sc_unit
+        }
+    }
+    impl fmt::Display for SysControlAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            fmt::Debug::fmt(self, f)
+        }
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux", target_os = "fuchsia"))]
+mod datalink {
+    use super::{fmt, AddressFamily};
+    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+    pub struct LinkAddr(pub libc::sockaddr_ll);
+    impl LinkAddr {
+        pub fn family(&self) -> AddressFamily {
+            assert_eq!(self.0.sll_family as i32, libc::AF_PACKET);
+            AddressFamily::Packet
+        }
+        pub fn protocol(&self) -> u16 {
+            self.0.sll_protocol
+        }
+        pub fn ifindex(&self) -> usize {
+            self.0.sll_ifindex as usize
+        }
+        pub fn hatype(&self) -> u16 {
+            self.0.sll_hatype
+        }
+        pub fn pkttype(&self) -> u8 {
+            self.0.sll_pkttype
+        }
+        pub fn halen(&self) -> usize {
+            self.0.sll_halen as usize
+        }
+        pub fn addr(&self) -> [u8; 6] {
+            [
+                self.0.sll_addr[0] as u8,
+                self.0.sll_addr[1] as u8,
+                self.0.sll_addr[2] as u8,
+                self.0.sll_addr[3] as u8,
+                self.0.sll_addr[4] as u8,
+                self.0.sll_addr[5] as u8,
+            ]
+        }
+    }
+    impl fmt::Display for LinkAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            let addr = self.addr();
+            write!(f, "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
+                addr[0],
+                addr[1],
+                addr[2],
+                addr[3],
+                addr[4],
+                addr[5])
+        }
+    }
+}
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "ios",
+          target_os = "macos",
+          target_os = "illumos",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+mod datalink {
+    use super::{fmt, AddressFamily};
+    #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+    pub struct LinkAddr(pub libc::sockaddr_dl);
+    impl LinkAddr {
+        #[cfg(not(target_os = "illumos"))]
+        pub fn len(&self) -> usize {
+            self.0.sdl_len as usize
+        }
+        pub fn family(&self) -> AddressFamily {
+            assert_eq!(i32::from(self.0.sdl_family), libc::AF_LINK);
+            AddressFamily::Link
+        }
+        pub fn ifindex(&self) -> usize {
+            self.0.sdl_index as usize
+        }
+        pub fn datalink_type(&self) -> u8 {
+            self.0.sdl_type
+        }
+        pub fn nlen(&self) -> usize {
+            self.0.sdl_nlen as usize
+        }
+        pub fn alen(&self) -> usize {
+            self.0.sdl_alen as usize
+        }
+        pub fn slen(&self) -> usize {
+            self.0.sdl_slen as usize
+        }
+        pub fn is_empty(&self) -> bool {
+            let nlen = self.nlen();
+            let alen = self.alen();
+            let data_len = self.0.sdl_data.len();
+            alen == 0 || nlen + alen >= data_len
+        }
+        pub fn addr(&self) -> [u8; 6] {
+            let nlen = self.nlen();
+            let data = self.0.sdl_data;
+            assert!(!self.is_empty());
+            [
+                data[nlen] as u8,
+                data[nlen + 1] as u8,
+                data[nlen + 2] as u8,
+                data[nlen + 3] as u8,
+                data[nlen + 4] as u8,
+                data[nlen + 5] as u8,
+            ]
+        }
+    }
+    impl fmt::Display for LinkAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            let addr = self.addr();
+            write!(f, "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
+                addr[0],
+                addr[1],
+                addr[2],
+                addr[3],
+                addr[4],
+                addr[5])
+        }
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub mod vsock {
+    use crate::sys::socket::addr::AddressFamily;
+    use libc::{sa_family_t, sockaddr_vm};
+    use std::{fmt, mem};
+    use std::hash::{Hash, Hasher};
+    #[derive(Copy, Clone)]
+    pub struct VsockAddr(pub sockaddr_vm);
+    impl PartialEq for VsockAddr {
+        fn eq(&self, other: &Self) -> bool {
+            let (inner, other) = (self.0, other.0);
+            (inner.svm_family, inner.svm_cid, inner.svm_port) ==
+            (other.svm_family, other.svm_cid, other.svm_port)
+        }
+    }
+    impl Eq for VsockAddr {}
+    impl Hash for VsockAddr {
+        fn hash<H: Hasher>(&self, s: &mut H) {
+            let inner = self.0;
+            (inner.svm_family, inner.svm_cid, inner.svm_port).hash(s);
+        }
+    }
+    impl VsockAddr {
+        pub fn new(cid: u32, port: u32) -> VsockAddr {
+            let mut addr: sockaddr_vm = unsafe { mem::zeroed() };
+            addr.svm_family = AddressFamily::Vsock as sa_family_t;
+            addr.svm_cid = cid;
+            addr.svm_port = port;
+            VsockAddr(addr)
+        }
+        pub fn cid(&self) -> u32 {
+            self.0.svm_cid
+        }
+        pub fn port(&self) -> u32 {
+            self.0.svm_port
+        }
+    }
+    impl fmt::Display for VsockAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            write!(f, "cid: {} port: {}", self.cid(), self.port())
+        }
+    }
+    impl fmt::Debug for VsockAddr {
+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+            fmt::Display::fmt(self, f)
+        }
+    }
+}
+#[cfg(test)]
+mod tests {
+    #[cfg(any(target_os = "android",
+              target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "linux",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "illumos",
+              target_os = "openbsd"))]
+    use super::*;
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    #[test]
+    fn test_macos_loopback_datalink_addr() {
+        let bytes = [20i8, 18, 1, 0, 24, 3, 0, 0, 108, 111, 48, 0, 0, 0, 0, 0];
+        let sa = bytes.as_ptr() as *const libc::sockaddr;
+        let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
+        assert!(_sock_addr.is_none());
+    }
+    #[cfg(any(target_os = "dragonfly",
+              target_os = "freebsd",
+              target_os = "ios",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "openbsd"))]
+    #[test]
+    fn test_macos_tap_datalink_addr() {
+        let bytes = [20i8, 18, 7, 0, 6, 3, 6, 0, 101, 110, 48, 24, 101, -112, -35, 76, -80];
+        let ptr = bytes.as_ptr();
+        let sa = ptr as *const libc::sockaddr;
+        let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
+        assert!(_sock_addr.is_some());
+        let sock_addr = _sock_addr.unwrap();
+        assert_eq!(sock_addr.family(), AddressFamily::Link);
+        match sock_addr {
+            SockAddr::Link(ether_addr) => {
+                assert_eq!(ether_addr.addr(), [24u8, 101, 144, 221, 76, 176]);
+            },
+            _ => { unreachable!() }
+        };
+    }
+    #[cfg(target_os = "illumos")]
+    #[test]
+    fn test_illumos_tap_datalink_addr() {
+        let bytes = [25u8, 0, 0, 0, 6, 0, 6, 0, 24, 101, 144, 221, 76, 176];
+        let ptr = bytes.as_ptr();
+        let sa = ptr as *const libc::sockaddr;
+        let _sock_addr = unsafe { SockAddr::from_libc_sockaddr(sa) };
+        assert!(_sock_addr.is_some());
+        let sock_addr = _sock_addr.unwrap();
+        assert_eq!(sock_addr.family(), AddressFamily::Link);
+        match sock_addr {
+            SockAddr::Link(ether_addr) => {
+                assert_eq!(ether_addr.addr(), [24u8, 101, 144, 221, 76, 176]);
+            },
+            _ => { unreachable!() }
+        };
+    }
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    #[test]
+    fn test_abstract_sun_path() {
+        let name = String::from("nix\0abstract\0test");
+        let addr = UnixAddr::new_abstract(name.as_bytes()).unwrap();
+        let sun_path1 = addr.sun_path();
+        let sun_path2 = [0u8, 110, 105, 120, 0, 97, 98, 115, 116, 114, 97, 99, 116, 0, 116, 101, 115, 116];
+        assert_eq!(sun_path1.len(), sun_path2.len());
+        for i in 0..sun_path1.len() {
+            assert_eq!(sun_path1[i], sun_path2[i]);
+        }
+    }
+}

--- a//dev/null
+++ b/src/sys/socket/mod.rs
@@ -0,0 +1,1169 @@
+use cfg_if::cfg_if;
+use crate::{Error, Result, errno::Errno};
+use libc::{self, c_void, c_int, iovec, socklen_t, size_t,
+        CMSG_FIRSTHDR, CMSG_NXTHDR, CMSG_DATA, CMSG_LEN};
+use memoffset::offset_of;
+use std::{mem, ptr, slice};
+use std::os::unix::io::RawFd;
+#[cfg(all(target_os = "linux"))]
+use crate::sys::time::TimeSpec;
+use crate::sys::time::TimeVal;
+use crate::sys::uio::IoVec;
+mod addr;
+pub mod sockopt;
+/*
+ *
+ * ===== Re-exports =====
+ *
+ */
+#[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+pub use self::addr::{
+    AddressFamily,
+    SockAddr,
+    InetAddr,
+    UnixAddr,
+    IpAddr,
+    Ipv4Addr,
+    Ipv6Addr,
+    LinkAddr,
+};
+#[cfg(any(target_os = "illumos", target_os = "solaris"))]
+pub use self::addr::{
+    AddressFamily,
+    SockAddr,
+    InetAddr,
+    UnixAddr,
+    IpAddr,
+    Ipv4Addr,
+    Ipv6Addr,
+};
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use crate::sys::socket::addr::netlink::NetlinkAddr;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use crate::sys::socket::addr::alg::AlgAddr;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+pub use crate::sys::socket::addr::vsock::VsockAddr;
+pub use libc::{
+    cmsghdr,
+    msghdr,
+    sa_family_t,
+    sockaddr,
+    sockaddr_in,
+    sockaddr_in6,
+    sockaddr_storage,
+    sockaddr_un,
+};
+#[doc(hidden)]
+pub use libc::{c_uint, CMSG_SPACE};
+#[derive(Clone, Copy, PartialEq, Eq, Debug)]
+#[repr(i32)]
+pub enum SockType {
+    Stream = libc::SOCK_STREAM,
+    Datagram = libc::SOCK_DGRAM,
+    SeqPacket = libc::SOCK_SEQPACKET,
+    Raw = libc::SOCK_RAW,
+    Rdm = libc::SOCK_RDM,
+}
+#[repr(i32)]
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum SockProtocol {
+    Tcp = libc::IPPROTO_TCP,
+    Udp = libc::IPPROTO_UDP,
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
+    KextEvent = libc::SYSPROTO_EVENT,
+    #[cfg(any(target_os = "ios", target_os = "macos"))]
+    KextControl = libc::SYSPROTO_CONTROL,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkRoute = libc::NETLINK_ROUTE,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkUserSock = libc::NETLINK_USERSOCK,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSockDiag = libc::NETLINK_SOCK_DIAG,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSELinux = libc::NETLINK_SELINUX,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkISCSI = libc::NETLINK_ISCSI,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkAudit = libc::NETLINK_AUDIT,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkFIBLookup = libc::NETLINK_FIB_LOOKUP,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkNetFilter = libc::NETLINK_NETFILTER,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkSCSITransport = libc::NETLINK_SCSITRANSPORT,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkRDMA = libc::NETLINK_RDMA,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkIPv6Firewall = libc::NETLINK_IP6_FW,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkDECNetRoutingMessage = libc::NETLINK_DNRTMSG,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkKObjectUEvent = libc::NETLINK_KOBJECT_UEVENT,
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    NetlinkCrypto = libc::NETLINK_CRYPTO,
+}
+libc_bitflags!{
+    pub struct SockFlag: c_int {
+        #[cfg(any(target_os = "android",
+                  target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        SOCK_NONBLOCK;
+        #[cfg(any(target_os = "android",
+                  target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        SOCK_CLOEXEC;
+        #[cfg(target_os = "netbsd")]
+        SOCK_NOSIGPIPE;
+        #[cfg(target_os = "openbsd")]
+        SOCK_DNS;
+    }
+}
+libc_bitflags!{
+    pub struct MsgFlags: c_int {
+        MSG_OOB;
+        MSG_PEEK;
+        MSG_WAITALL;
+        MSG_DONTWAIT;
+        MSG_CTRUNC;
+        MSG_TRUNC;
+        MSG_EOR;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        MSG_ERRQUEUE;
+        #[cfg(any(target_os = "android",
+                  target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "linux",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        MSG_CMSG_CLOEXEC;
+    }
+}
+cfg_if! {
+    if #[cfg(any(target_os = "android", target_os = "linux"))] {
+        #[repr(transparent)]
+        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+        pub struct UnixCredentials(libc::ucred);
+        impl UnixCredentials {
+            pub fn new() -> Self {
+                UnixCredentials(libc::ucred {
+                    pid: crate::unistd::getpid().as_raw(),
+                    uid: crate::unistd::getuid().as_raw(),
+                    gid: crate::unistd::getgid().as_raw(),
+                })
+            }
+            pub fn pid(&self) -> libc::pid_t {
+                self.0.pid
+            }
+            pub fn uid(&self) -> libc::uid_t {
+                self.0.uid
+            }
+            pub fn gid(&self) -> libc::gid_t {
+                self.0.gid
+            }
+        }
+        impl Default for UnixCredentials {
+            fn default() -> Self {
+                Self::new()
+            }
+        }
+        impl From<libc::ucred> for UnixCredentials {
+            fn from(cred: libc::ucred) -> Self {
+                UnixCredentials(cred)
+            }
+        }
+        impl Into<libc::ucred> for UnixCredentials {
+            fn into(self) -> libc::ucred {
+                self.0
+            }
+        }
+    } else if #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))] {
+        #[repr(transparent)]
+        #[derive(Clone, Copy, Debug, Eq, PartialEq)]
+        pub struct UnixCredentials(libc::cmsgcred);
+        impl UnixCredentials {
+            pub fn pid(&self) -> libc::pid_t {
+                self.0.cmcred_pid
+            }
+            pub fn uid(&self) -> libc::uid_t {
+                self.0.cmcred_uid
+            }
+            pub fn euid(&self) -> libc::uid_t {
+                self.0.cmcred_euid
+            }
+            pub fn gid(&self) -> libc::gid_t {
+                self.0.cmcred_gid
+            }
+            pub fn groups(&self) -> &[libc::gid_t] {
+                unsafe { slice::from_raw_parts(self.0.cmcred_groups.as_ptr() as *const libc::gid_t, self.0.cmcred_ngroups as _) }
+            }
+        }
+        impl From<libc::cmsgcred> for UnixCredentials {
+            fn from(cred: libc::cmsgcred) -> Self {
+                UnixCredentials(cred)
+            }
+        }
+    }
+}
+#[repr(transparent)]
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct IpMembershipRequest(libc::ip_mreq);
+impl IpMembershipRequest {
+    pub fn new(group: Ipv4Addr, interface: Option<Ipv4Addr>) -> Self {
+        IpMembershipRequest(libc::ip_mreq {
+            imr_multiaddr: group.0,
+            imr_interface: interface.unwrap_or_else(Ipv4Addr::any).0,
+        })
+    }
+}
+#[repr(transparent)]
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct Ipv6MembershipRequest(libc::ipv6_mreq);
+impl Ipv6MembershipRequest {
+    pub fn new(group: Ipv6Addr) -> Self {
+        Ipv6MembershipRequest(libc::ipv6_mreq {
+            ipv6mr_multiaddr: group.0,
+            ipv6mr_interface: 0,
+        })
+    }
+}
+#[macro_export]
+macro_rules! cmsg_space {
+    ( $( $x:ty ),* ) => {
+        {
+            let mut space = 0;
+            $(
+                space += unsafe {
+                    $crate::sys::socket::CMSG_SPACE(::std::mem::size_of::<$x>() as $crate::sys::socket::c_uint)
+                } as usize;
+            )*
+            Vec::<u8>::with_capacity(space)
+        }
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct RecvMsg<'a> {
+    pub bytes: usize,
+    cmsghdr: Option<&'a cmsghdr>,
+    pub address: Option<SockAddr>,
+    pub flags: MsgFlags,
+    mhdr: msghdr,
+}
+impl<'a> RecvMsg<'a> {
+    pub fn cmsgs(&self) -> CmsgIterator {
+        CmsgIterator {
+            cmsghdr: self.cmsghdr,
+            mhdr: &self.mhdr
+        }
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub struct CmsgIterator<'a> {
+    cmsghdr: Option<&'a cmsghdr>,
+    mhdr: &'a msghdr
+}
+impl<'a> Iterator for CmsgIterator<'a> {
+    type Item = ControlMessageOwned;
+    fn next(&mut self) -> Option<ControlMessageOwned> {
+        match self.cmsghdr {
+            None => None,   // No more messages
+            Some(hdr) => {
+                let cm = unsafe { Some(ControlMessageOwned::decode_from(hdr))};
+                self.cmsghdr = unsafe {
+                    let p = CMSG_NXTHDR(self.mhdr as *const _, hdr as *const _);
+                    p.as_ref()
+                };
+                cm
+            }
+        }
+    }
+}
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub enum ControlMessageOwned {
+    ScmRights(Vec<RawFd>),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    ScmCredentials(UnixCredentials),
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    ScmCreds(UnixCredentials),
+    ScmTimestamp(TimeVal),
+    #[cfg(all(target_os = "linux"))]
+    ScmTimestampns(TimeSpec),
+    #[cfg(any(
+        target_os = "android",
+        target_os = "ios",
+        target_os = "linux",
+        target_os = "macos",
+        target_os = "netbsd",
+    ))]
+    Ipv4PacketInfo(libc::in_pktinfo),
+    #[cfg(any(
+        target_os = "android",
+        target_os = "dragonfly",
+        target_os = "freebsd",
+        target_os = "ios",
+        target_os = "linux",
+        target_os = "macos",
+        target_os = "openbsd",
+        target_os = "netbsd",
+    ))]
+    Ipv6PacketInfo(libc::in6_pktinfo),
+    #[cfg(any(
+        target_os = "freebsd",
+        target_os = "ios",
+        target_os = "macos",
+        target_os = "netbsd",
+        target_os = "openbsd",
+    ))]
+    Ipv4RecvIf(libc::sockaddr_dl),
+    #[cfg(any(
+        target_os = "freebsd",
+        target_os = "ios",
+        target_os = "macos",
+        target_os = "netbsd",
+        target_os = "openbsd",
+    ))]
+    Ipv4RecvDstAddr(libc::in_addr),
+    #[cfg(target_os = "linux")]
+    UdpGroSegments(u16),
+    #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+    RxqOvfl(u32),
+    #[doc(hidden)]
+    Unknown(UnknownCmsg),
+}
+impl ControlMessageOwned {
+    #[allow(clippy::cast_ptr_alignment)]
+    unsafe fn decode_from(header: &cmsghdr) -> ControlMessageOwned
+    {
+        let p = CMSG_DATA(header);
+        let len = header as *const _ as usize + header.cmsg_len as usize
+            - p as usize;
+        match (header.cmsg_level, header.cmsg_type) {
+            (libc::SOL_SOCKET, libc::SCM_RIGHTS) => {
+                let n = len / mem::size_of::<RawFd>();
+                let mut fds = Vec::with_capacity(n);
+                for i in 0..n {
+                    let fdp = (p as *const RawFd).add(i);
+                    fds.push(ptr::read_unaligned(fdp));
+                }
+                ControlMessageOwned::ScmRights(fds)
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            (libc::SOL_SOCKET, libc::SCM_CREDENTIALS) => {
+                let cred: libc::ucred = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmCredentials(cred.into())
+            }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            (libc::SOL_SOCKET, libc::SCM_CREDS) => {
+                let cred: libc::cmsgcred = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmCreds(cred.into())
+            }
+            (libc::SOL_SOCKET, libc::SCM_TIMESTAMP) => {
+                let tv: libc::timeval = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmTimestamp(TimeVal::from(tv))
+            },
+            #[cfg(all(target_os = "linux"))]
+            (libc::SOL_SOCKET, libc::SCM_TIMESTAMPNS) => {
+                let ts: libc::timespec = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::ScmTimestampns(TimeSpec::from(ts))
+            }
+            #[cfg(any(
+                target_os = "android",
+                target_os = "freebsd",
+                target_os = "ios",
+                target_os = "linux",
+                target_os = "macos"
+            ))]
+            (libc::IPPROTO_IPV6, libc::IPV6_PKTINFO) => {
+                let info = ptr::read_unaligned(p as *const libc::in6_pktinfo);
+                ControlMessageOwned::Ipv6PacketInfo(info)
+            }
+            #[cfg(any(
+                target_os = "android",
+                target_os = "ios",
+                target_os = "linux",
+                target_os = "macos",
+                target_os = "netbsd",
+            ))]
+            (libc::IPPROTO_IP, libc::IP_PKTINFO) => {
+                let info = ptr::read_unaligned(p as *const libc::in_pktinfo);
+                ControlMessageOwned::Ipv4PacketInfo(info)
+            }
+            #[cfg(any(
+                target_os = "freebsd",
+                target_os = "ios",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd",
+            ))]
+            (libc::IPPROTO_IP, libc::IP_RECVIF) => {
+                let dl = ptr::read_unaligned(p as *const libc::sockaddr_dl);
+                ControlMessageOwned::Ipv4RecvIf(dl)
+            },
+            #[cfg(any(
+                target_os = "freebsd",
+                target_os = "ios",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd",
+            ))]
+            (libc::IPPROTO_IP, libc::IP_RECVDSTADDR) => {
+                let dl = ptr::read_unaligned(p as *const libc::in_addr);
+                ControlMessageOwned::Ipv4RecvDstAddr(dl)
+            },
+            #[cfg(target_os = "linux")]
+            (libc::SOL_UDP, libc::UDP_GRO) => {
+                let gso_size: u16 = ptr::read_unaligned(p as *const _);
+                ControlMessageOwned::UdpGroSegments(gso_size)
+            },
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            (libc::SOL_SOCKET, libc::SO_RXQ_OVFL) => {
+                let drop_counter = ptr::read_unaligned(p as *const u32);
+                ControlMessageOwned::RxqOvfl(drop_counter)
+            },
+            (_, _) => {
+                let sl = slice::from_raw_parts(p, len);
+                let ucmsg = UnknownCmsg(*header, Vec::<u8>::from(sl));
+                ControlMessageOwned::Unknown(ucmsg)
+            }
+        }
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, PartialEq)]
+pub enum ControlMessage<'a> {
+    ScmRights(&'a [RawFd]),
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    ScmCredentials(&'a UnixCredentials),
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    ScmCreds,
+    #[cfg(any(
+        target_os = "android",
+        target_os = "linux",
+    ))]
+    AlgSetIv(&'a [u8]),
+    #[cfg(any(
+        target_os = "android",
+        target_os = "linux",
+    ))]
+    AlgSetOp(&'a libc::c_int),
+    #[cfg(any(
+        target_os = "android",
+        target_os = "linux",
+    ))]
+    AlgSetAeadAssoclen(&'a u32),
+    #[cfg(target_os = "linux")]
+    UdpGsoSegments(&'a u16),
+    #[cfg(any(target_os = "linux",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "android",
+              target_os = "ios",))]
+    Ipv4PacketInfo(&'a libc::in_pktinfo),
+    #[cfg(any(target_os = "linux",
+              target_os = "macos",
+              target_os = "netbsd",
+              target_os = "freebsd",
+              target_os = "android",
+              target_os = "ios",))]
+    Ipv6PacketInfo(&'a libc::in6_pktinfo),
+    #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+    RxqOvfl(&'a u32),
+}
+#[doc(hidden)]
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct UnknownCmsg(cmsghdr, Vec<u8>);
+impl<'a> ControlMessage<'a> {
+    fn space(&self) -> usize {
+        unsafe{CMSG_SPACE(self.len() as libc::c_uint) as usize}
+    }
+    #[cfg(any(target_os = "android",
+              all(target_os = "linux", not(target_env = "musl"))))]
+    fn cmsg_len(&self) -> usize {
+        unsafe{CMSG_LEN(self.len() as libc::c_uint) as usize}
+    }
+    #[cfg(not(any(target_os = "android",
+                  all(target_os = "linux", not(target_env = "musl")))))]
+    fn cmsg_len(&self) -> libc::c_uint {
+        unsafe{CMSG_LEN(self.len() as libc::c_uint)}
+    }
+    fn copy_to_cmsg_data(&self, cmsg_data: *mut u8) {
+        let data_ptr = match *self {
+            ControlMessage::ScmRights(fds) => {
+                fds as *const _ as *const u8
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::ScmCredentials(creds) => {
+                &creds.0 as *const libc::ucred as *const u8
+            }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => {
+                unsafe { ptr::write_bytes(cmsg_data, 0, self.len()) };
+                return
+            }
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetIv(iv) => {
+                #[allow(deprecated)] // https://github.com/rust-lang/libc/issues/1501
+                let af_alg_iv = libc::af_alg_iv {
+                    ivlen: iv.len() as u32,
+                    iv: [0u8; 0],
+                };
+                let size = mem::size_of_val(&af_alg_iv);
+                unsafe {
+                    ptr::copy_nonoverlapping(
+                        &af_alg_iv as *const _ as *const u8,
+                        cmsg_data,
+                        size,
+                    );
+                    ptr::copy_nonoverlapping(
+                        iv.as_ptr(),
+                        cmsg_data.add(size),
+                        iv.len()
+                    );
+                };
+                return
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetOp(op) => {
+                op as *const _ as *const u8
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetAeadAssoclen(len) => {
+                len as *const _ as *const u8
+            },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(gso_size) => {
+                gso_size as *const _ as *const u8
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(info) => info as *const _ as *const u8,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "freebsd",
+                      target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(info) => info as *const _ as *const u8,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(drop_count) => {
+                drop_count as *const _ as *const u8
+            },
+        };
+        unsafe {
+            ptr::copy_nonoverlapping(
+                data_ptr,
+                cmsg_data,
+                self.len()
+            )
+        };
+    }
+    fn len(&self) -> usize {
+        match *self {
+            ControlMessage::ScmRights(fds) => {
+                mem::size_of_val(fds)
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::ScmCredentials(creds) => {
+                mem::size_of_val(creds)
+            }
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => {
+                mem::size_of::<libc::cmsgcred>()
+            }
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetIv(iv) => {
+                mem::size_of_val(&iv) + iv.len()
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetOp(op) => {
+                mem::size_of_val(op)
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetAeadAssoclen(len) => {
+                mem::size_of_val(len)
+            },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(gso_size) => {
+                mem::size_of_val(gso_size)
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "android",
+              target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(info) => mem::size_of_val(info),
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "freebsd",
+              target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(info) => mem::size_of_val(info),
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(drop_count) => {
+                mem::size_of_val(drop_count)
+            },
+        }
+    }
+    fn cmsg_level(&self) -> libc::c_int {
+        match *self {
+            ControlMessage::ScmRights(_) => libc::SOL_SOCKET,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::ScmCredentials(_) => libc::SOL_SOCKET,
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => libc::SOL_SOCKET,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetIv(_) | ControlMessage::AlgSetOp(_) |
+                ControlMessage::AlgSetAeadAssoclen(_) => libc::SOL_ALG,
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(_) => libc::SOL_UDP,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(_) => libc::IPPROTO_IP,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+              target_os = "netbsd", target_os = "freebsd",
+              target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(_) => libc::IPPROTO_IPV6,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(_) => libc::SOL_SOCKET,
+        }
+    }
+    fn cmsg_type(&self) -> libc::c_int {
+        match *self {
+            ControlMessage::ScmRights(_) => libc::SCM_RIGHTS,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::ScmCredentials(_) => libc::SCM_CREDENTIALS,
+            #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+            ControlMessage::ScmCreds => libc::SCM_CREDS,
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetIv(_) => {
+                libc::ALG_SET_IV
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetOp(_) => {
+                libc::ALG_SET_OP
+            },
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            ControlMessage::AlgSetAeadAssoclen(_) => {
+                libc::ALG_SET_AEAD_ASSOCLEN
+            },
+            #[cfg(target_os = "linux")]
+            ControlMessage::UdpGsoSegments(_) => {
+                libc::UDP_SEGMENT
+            },
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "android",
+                      target_os = "ios",))]
+            ControlMessage::Ipv4PacketInfo(_) => libc::IP_PKTINFO,
+            #[cfg(any(target_os = "linux", target_os = "macos",
+                      target_os = "netbsd", target_os = "freebsd",
+                      target_os = "android", target_os = "ios",))]
+            ControlMessage::Ipv6PacketInfo(_) => libc::IPV6_PKTINFO,
+            #[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+            ControlMessage::RxqOvfl(_) => {
+                libc::SO_RXQ_OVFL
+            },
+        }
+    }
+    unsafe fn encode_into(&self, cmsg: *mut cmsghdr) {
+        (*cmsg).cmsg_level = self.cmsg_level();
+        (*cmsg).cmsg_type = self.cmsg_type();
+        (*cmsg).cmsg_len = self.cmsg_len();
+        self.copy_to_cmsg_data(CMSG_DATA(cmsg));
+    }
+}
+pub fn sendmsg(fd: RawFd, iov: &[IoVec<&[u8]>], cmsgs: &[ControlMessage],
+               flags: MsgFlags, addr: Option<&SockAddr>) -> Result<usize>
+{
+    let capacity = cmsgs.iter().map(|c| c.space()).sum();
+    let mut cmsg_buffer = vec![0u8; capacity];
+    let mhdr = pack_mhdr_to_send(&mut cmsg_buffer[..], &iov, &cmsgs, addr);
+    let ret = unsafe { libc::sendmsg(fd, &mhdr, flags.bits()) };
+    Errno::result(ret).map(|r| r as usize)
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+#[derive(Debug)]
+pub struct SendMmsgData<'a, I, C>
+    where
+        I: AsRef<[IoVec<&'a [u8]>]>,
+        C: AsRef<[ControlMessage<'a>]>
+{
+    pub iov: I,
+    pub cmsgs: C,
+    pub addr: Option<SockAddr>,
+    pub _lt: std::marker::PhantomData<&'a I>,
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+pub fn sendmmsg<'a, I, C>(
+    fd: RawFd,
+    data: impl std::iter::IntoIterator<Item=&'a SendMmsgData<'a, I, C>>,
+    flags: MsgFlags
+) -> Result<Vec<usize>>
+    where
+        I: AsRef<[IoVec<&'a [u8]>]> + 'a,
+        C: AsRef<[ControlMessage<'a>]> + 'a,
+{
+    let iter = data.into_iter();
+    let size_hint = iter.size_hint();
+    let reserve_items = size_hint.1.unwrap_or(size_hint.0);
+    let mut output = Vec::<libc::mmsghdr>::with_capacity(reserve_items);
+    let mut cmsgs_buffers = Vec::<Vec<u8>>::with_capacity(reserve_items);
+    for d in iter {
+        let capacity: usize = d.cmsgs.as_ref().iter().map(|c| c.space()).sum();
+        let mut cmsgs_buffer = vec![0u8; capacity];
+        output.push(libc::mmsghdr {
+            msg_hdr: pack_mhdr_to_send(
+                &mut cmsgs_buffer,
+                &d.iov,
+                &d.cmsgs,
+                d.addr.as_ref()
+            ),
+            msg_len: 0,
+        });
+        cmsgs_buffers.push(cmsgs_buffer);
+    };
+    let ret = unsafe { libc::sendmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _) };
+    let sent_messages = Errno::result(ret)? as usize;
+    let mut sent_bytes = Vec::with_capacity(sent_messages);
+    for item in &output {
+        sent_bytes.push(item.msg_len as usize);
+    }
+    Ok(sent_bytes)
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+#[derive(Debug)]
+pub struct RecvMmsgData<'a, I>
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    pub iov: I,
+    pub cmsg_buffer: Option<&'a mut Vec<u8>>,
+}
+#[cfg(any(
+    target_os = "linux",
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "netbsd",
+))]
+pub fn recvmmsg<'a, I>(
+    fd: RawFd,
+    data: impl std::iter::IntoIterator<Item=&'a mut RecvMmsgData<'a, I>,
+        IntoIter=impl ExactSizeIterator + Iterator<Item=&'a mut RecvMmsgData<'a, I>>>,
+    flags: MsgFlags,
+    timeout: Option<crate::sys::time::TimeSpec>
+) -> Result<Vec<RecvMsg<'a>>>
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    let iter = data.into_iter();
+    let num_messages = iter.len();
+    let mut output: Vec<libc::mmsghdr> = Vec::with_capacity(num_messages);
+    let mut addresses = vec![mem::MaybeUninit::uninit(); num_messages]
+        .into_boxed_slice();
+    let results: Vec<_> = iter.enumerate().map(|(i, d)| {
+        let (msg_controllen, mhdr) = unsafe {
+            pack_mhdr_to_receive(
+                d.iov.as_ref(),
+                &mut d.cmsg_buffer,
+                addresses[i].as_mut_ptr(),
+            )
+        };
+        output.push(
+            libc::mmsghdr {
+                msg_hdr: mhdr,
+                msg_len: 0,
+            }
+        );
+        (msg_controllen as usize, &mut d.cmsg_buffer)
+    }).collect();
+    let timeout = if let Some(mut t) = timeout {
+        t.as_mut() as *mut libc::timespec
+    } else {
+        ptr::null_mut()
+    };
+    let ret = unsafe { libc::recvmmsg(fd, output.as_mut_ptr(), output.len() as _, flags.bits() as _, timeout) };
+    let _ = Errno::result(ret)?;
+    Ok(output
+        .into_iter()
+        .take(ret as usize)
+        .zip(addresses.iter().map(|addr| unsafe{addr.assume_init()}))
+        .zip(results.into_iter())
+        .map(|((mmsghdr, address), (msg_controllen, cmsg_buffer))| {
+            unsafe {
+                read_mhdr(
+                    mmsghdr.msg_hdr,
+                    mmsghdr.msg_len as isize,
+                    msg_controllen,
+                    address,
+                    cmsg_buffer
+                )
+            }
+        })
+        .collect())
+}
+unsafe fn read_mhdr<'a, 'b>(
+    mhdr: msghdr,
+    r: isize,
+    msg_controllen: usize,
+    address: sockaddr_storage,
+    cmsg_buffer: &'a mut Option<&'b mut Vec<u8>>
+) -> RecvMsg<'b> {
+    let cmsghdr = {
+        if mhdr.msg_controllen > 0 {
+            cmsg_buffer
+                .as_mut()
+                .unwrap()
+                .set_len(mhdr.msg_controllen as usize);
+            debug_assert!(!mhdr.msg_control.is_null());
+            debug_assert!(msg_controllen >= mhdr.msg_controllen as usize);
+            CMSG_FIRSTHDR(&mhdr as *const msghdr)
+        } else {
+            ptr::null()
+        }.as_ref()
+    };
+    let address = sockaddr_storage_to_addr(
+        &address ,
+         mhdr.msg_namelen as usize
+    ).ok();
+    RecvMsg {
+        bytes: r as usize,
+        cmsghdr,
+        address,
+        flags: MsgFlags::from_bits_truncate(mhdr.msg_flags),
+        mhdr,
+    }
+}
+unsafe fn pack_mhdr_to_receive<'a, I>(
+    iov: I,
+    cmsg_buffer: &mut Option<&mut Vec<u8>>,
+    address: *mut sockaddr_storage,
+) -> (usize, msghdr)
+    where
+        I: AsRef<[IoVec<&'a mut [u8]>]> + 'a,
+{
+    let (msg_control, msg_controllen) = cmsg_buffer.as_mut()
+        .map(|v| (v.as_mut_ptr(), v.capacity()))
+        .unwrap_or((ptr::null_mut(), 0));
+    let mhdr = {
+        let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
+        let p = mhdr.as_mut_ptr();
+        (*p).msg_name = address as *mut c_void;
+        (*p).msg_namelen = mem::size_of::<sockaddr_storage>() as socklen_t;
+        (*p).msg_iov = iov.as_ref().as_ptr() as *mut iovec;
+        (*p).msg_iovlen = iov.as_ref().len() as _;
+        (*p).msg_control = msg_control as *mut c_void;
+        (*p).msg_controllen = msg_controllen as _;
+        (*p).msg_flags = 0;
+        mhdr.assume_init()
+    };
+    (msg_controllen, mhdr)
+}
+fn pack_mhdr_to_send<'a, I, C>(
+    cmsg_buffer: &mut [u8],
+    iov: I,
+    cmsgs: C,
+    addr: Option<&SockAddr>
+) -> msghdr
+    where
+        I: AsRef<[IoVec<&'a [u8]>]>,
+        C: AsRef<[ControlMessage<'a>]>
+{
+    let capacity = cmsg_buffer.len();
+    let (name, namelen) = match addr {
+        Some(addr) => {
+            let (x, y) = addr.as_ffi_pair();
+            (x as *const _, y)
+        },
+        None => (ptr::null(), 0),
+    };
+    let cmsg_ptr = if capacity > 0 {
+        cmsg_buffer.as_ptr() as *mut c_void
+    } else {
+        ptr::null_mut()
+    };
+    let mhdr = unsafe {
+        let mut mhdr = mem::MaybeUninit::<msghdr>::zeroed();
+        let p = mhdr.as_mut_ptr();
+        (*p).msg_name = name as *mut _;
+        (*p).msg_namelen = namelen;
+        (*p).msg_iov = iov.as_ref().as_ptr() as *mut _;
+        (*p).msg_iovlen = iov.as_ref().len() as _;
+        (*p).msg_control = cmsg_ptr;
+        (*p).msg_controllen = capacity as _;
+        (*p).msg_flags = 0;
+        mhdr.assume_init()
+    };
+    let mut pmhdr: *mut cmsghdr = unsafe { CMSG_FIRSTHDR(&mhdr as *const msghdr) };
+    for cmsg in cmsgs.as_ref() {
+        assert_ne!(pmhdr, ptr::null_mut());
+        unsafe { cmsg.encode_into(pmhdr) };
+        pmhdr = unsafe { CMSG_NXTHDR(&mhdr as *const msghdr, pmhdr) };
+    }
+    mhdr
+}
+pub fn recvmsg<'a>(fd: RawFd, iov: &[IoVec<&mut [u8]>],
+                   mut cmsg_buffer: Option<&'a mut Vec<u8>>,
+                   flags: MsgFlags) -> Result<RecvMsg<'a>>
+{
+    let mut address = mem::MaybeUninit::uninit();
+    let (msg_controllen, mut mhdr) = unsafe {
+        pack_mhdr_to_receive(&iov, &mut cmsg_buffer, address.as_mut_ptr())
+    };
+    let ret = unsafe { libc::recvmsg(fd, &mut mhdr, flags.bits()) };
+    let r = Errno::result(ret)?;
+    Ok(unsafe { read_mhdr(mhdr, r, msg_controllen, address.assume_init(), &mut cmsg_buffer) })
+}
+pub fn socket<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, flags: SockFlag, protocol: T) -> Result<RawFd> {
+    let protocol = match protocol.into() {
+        None => 0,
+        Some(p) => p as c_int,
+    };
+    let mut ty = ty as c_int;
+    ty |= flags.bits();
+    let res = unsafe { libc::socket(domain as c_int, ty, protocol) };
+    Errno::result(res)
+}
+pub fn socketpair<T: Into<Option<SockProtocol>>>(domain: AddressFamily, ty: SockType, protocol: T,
+                  flags: SockFlag) -> Result<(RawFd, RawFd)> {
+    let protocol = match protocol.into() {
+        None => 0,
+        Some(p) => p as c_int,
+    };
+    let mut ty = ty as c_int;
+    ty |= flags.bits();
+    let mut fds = [-1, -1];
+    let res = unsafe { libc::socketpair(domain as c_int, ty, protocol, fds.as_mut_ptr()) };
+    Errno::result(res)?;
+    Ok((fds[0], fds[1]))
+}
+pub fn listen(sockfd: RawFd, backlog: usize) -> Result<()> {
+    let res = unsafe { libc::listen(sockfd, backlog as c_int) };
+    Errno::result(res).map(drop)
+}
+pub fn bind(fd: RawFd, addr: &SockAddr) -> Result<()> {
+    let res = unsafe {
+        let (ptr, len) = addr.as_ffi_pair();
+        libc::bind(fd, ptr, len)
+    };
+    Errno::result(res).map(drop)
+}
+pub fn accept(sockfd: RawFd) -> Result<RawFd> {
+    let res = unsafe { libc::accept(sockfd, ptr::null_mut(), ptr::null_mut()) };
+    Errno::result(res)
+}
+#[cfg(any(all(
+            target_os = "android",
+            any(
+                target_arch = "aarch64",
+                target_arch = "x86",
+                target_arch = "x86_64"
+            )
+          ),
+          target_os = "freebsd",
+          target_os = "linux",
+          target_os = "openbsd"))]
+pub fn accept4(sockfd: RawFd, flags: SockFlag) -> Result<RawFd> {
+    let res = unsafe { libc::accept4(sockfd, ptr::null_mut(), ptr::null_mut(), flags.bits()) };
+    Errno::result(res)
+}
+pub fn connect(fd: RawFd, addr: &SockAddr) -> Result<()> {
+    let res = unsafe {
+        let (ptr, len) = addr.as_ffi_pair();
+        libc::connect(fd, ptr, len)
+    };
+    Errno::result(res).map(drop)
+}
+pub fn recv(sockfd: RawFd, buf: &mut [u8], flags: MsgFlags) -> Result<usize> {
+    unsafe {
+        let ret = libc::recv(
+            sockfd,
+            buf.as_ptr() as *mut c_void,
+            buf.len() as size_t,
+            flags.bits());
+        Errno::result(ret).map(|r| r as usize)
+    }
+}
+pub fn recvfrom(sockfd: RawFd, buf: &mut [u8])
+    -> Result<(usize, Option<SockAddr>)>
+{
+    unsafe {
+        let mut addr: sockaddr_storage = mem::zeroed();
+        let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
+        let ret = Errno::result(libc::recvfrom(
+            sockfd,
+            buf.as_ptr() as *mut c_void,
+            buf.len() as size_t,
+            0,
+            &mut addr as *mut libc::sockaddr_storage as *mut libc::sockaddr,
+            &mut len as *mut socklen_t))? as usize;
+        match sockaddr_storage_to_addr(&addr, len as usize) {
+            Err(Errno::ENOTCONN) => Ok((ret, None)),
+            Ok(addr) => Ok((ret, Some(addr))),
+            Err(e) => Err(e)
+        }
+    }
+}
+pub fn sendto(fd: RawFd, buf: &[u8], addr: &SockAddr, flags: MsgFlags) -> Result<usize> {
+    let ret = unsafe {
+        let (ptr, len) = addr.as_ffi_pair();
+        libc::sendto(fd, buf.as_ptr() as *const c_void, buf.len() as size_t, flags.bits(), ptr, len)
+    };
+    Errno::result(ret).map(|r| r as usize)
+}
+pub fn send(fd: RawFd, buf: &[u8], flags: MsgFlags) -> Result<usize> {
+    let ret = unsafe {
+        libc::send(fd, buf.as_ptr() as *const c_void, buf.len() as size_t, flags.bits())
+    };
+    Errno::result(ret).map(|r| r as usize)
+}
+/*
+ *
+ * ===== Socket Options =====
+ *
+ */
+pub trait GetSockOpt : Copy {
+    type Val;
+    #[doc(hidden)]
+    fn get(&self, fd: RawFd) -> Result<Self::Val>;
+}
+pub trait SetSockOpt : Clone {
+    type Val;
+    #[doc(hidden)]
+    fn set(&self, fd: RawFd, val: &Self::Val) -> Result<()>;
+}
+pub fn getsockopt<O: GetSockOpt>(fd: RawFd, opt: O) -> Result<O::Val> {
+    opt.get(fd)
+}
+pub fn setsockopt<O: SetSockOpt>(fd: RawFd, opt: O, val: &O::Val) -> Result<()> {
+    opt.set(fd, val)
+}
+pub fn getpeername(fd: RawFd) -> Result<SockAddr> {
+    unsafe {
+        let mut addr = mem::MaybeUninit::uninit();
+        let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
+        let ret = libc::getpeername(
+            fd,
+            addr.as_mut_ptr() as *mut libc::sockaddr,
+            &mut len
+        );
+        Errno::result(ret)?;
+        sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
+    }
+}
+pub fn getsockname(fd: RawFd) -> Result<SockAddr> {
+    unsafe {
+        let mut addr = mem::MaybeUninit::uninit();
+        let mut len = mem::size_of::<sockaddr_storage>() as socklen_t;
+        let ret = libc::getsockname(
+            fd,
+            addr.as_mut_ptr() as *mut libc::sockaddr,
+            &mut len
+        );
+        Errno::result(ret)?;
+        sockaddr_storage_to_addr(&addr.assume_init(), len as usize)
+    }
+}
+pub fn sockaddr_storage_to_addr(
+    addr: &sockaddr_storage,
+    len: usize) -> Result<SockAddr> {
+    assert!(len <= mem::size_of::<sockaddr_un>());
+    if len < mem::size_of_val(&addr.ss_family) {
+        return Err(Error::from(Errno::ENOTCONN));
+    }
+    match c_int::from(addr.ss_family) {
+        libc::AF_INET => {
+            assert_eq!(len as usize, mem::size_of::<sockaddr_in>());
+            let sin = unsafe {
+                *(addr as *const sockaddr_storage as *const sockaddr_in)
+            };
+            Ok(SockAddr::Inet(InetAddr::V4(sin)))
+        }
+        libc::AF_INET6 => {
+            assert_eq!(len as usize, mem::size_of::<sockaddr_in6>());
+            let sin6 = unsafe {
+                *(addr as *const _ as *const sockaddr_in6)
+            };
+            Ok(SockAddr::Inet(InetAddr::V6(sin6)))
+        }
+        libc::AF_UNIX => {
+            let pathlen = len - offset_of!(sockaddr_un, sun_path);
+            let sun = unsafe {
+                *(addr as *const _ as *const sockaddr_un)
+            };
+            Ok(SockAddr::Unix(UnixAddr(sun, pathlen)))
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        libc::AF_PACKET => {
+            use libc::sockaddr_ll;
+            assert!(len as usize <= mem::size_of::<sockaddr_ll>());
+            let sll = unsafe {
+                *(addr as *const _ as *const sockaddr_ll)
+            };
+            Ok(SockAddr::Link(LinkAddr(sll)))
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        libc::AF_NETLINK => {
+            use libc::sockaddr_nl;
+            let snl = unsafe {
+                *(addr as *const _ as *const sockaddr_nl)
+            };
+            Ok(SockAddr::Netlink(NetlinkAddr(snl)))
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        libc::AF_ALG => {
+            use libc::sockaddr_alg;
+            let salg = unsafe {
+                *(addr as *const _ as *const sockaddr_alg)
+            };
+            Ok(SockAddr::Alg(AlgAddr(salg)))
+        }
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        libc::AF_VSOCK => {
+            use libc::sockaddr_vm;
+            let svm = unsafe {
+                *(addr as *const _ as *const sockaddr_vm)
+            };
+            Ok(SockAddr::Vsock(VsockAddr(svm)))
+        }
+        af => panic!("unexpected address family {}", af),
+    }
+}
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub enum Shutdown {
+    Read,
+    Write,
+    Both,
+}
+pub fn shutdown(df: RawFd, how: Shutdown) -> Result<()> {
+    unsafe {
+        use libc::shutdown;
+        let how = match how {
+            Shutdown::Read  => libc::SHUT_RD,
+            Shutdown::Write => libc::SHUT_WR,
+            Shutdown::Both  => libc::SHUT_RDWR,
+        };
+        Errno::result(shutdown(df, how)).map(drop)
+    }
+}
+#[cfg(test)]
+mod tests {
+    #[test]
+    fn can_use_cmsg_space() {
+        let _ = cmsg_space!(u8);
+    }
+}

--- a//dev/null
+++ b/src/sys/socket/sockopt.rs
@@ -0,0 +1,516 @@
+use cfg_if::cfg_if;
+use super::{GetSockOpt, SetSockOpt};
+use crate::Result;
+use crate::errno::Errno;
+use crate::sys::time::TimeVal;
+use libc::{self, c_int, c_void, socklen_t};
+use std::mem::{
+    self,
+    MaybeUninit
+};
+use std::os::unix::io::RawFd;
+use std::ffi::{OsStr, OsString};
+#[cfg(target_family = "unix")]
+use std::os::unix::ffi::OsStrExt;
+#[cfg(any(target_os = "freebsd", target_os = "linux"))] 
+const TCP_CA_NAME_MAX: usize = 16;
+macro_rules! setsockopt_impl {
+    ($name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
+        impl SetSockOpt for $name {
+            type Val = $ty;
+            fn set(&self, fd: RawFd, val: &$ty) -> Result<()> {
+                unsafe {
+                    let setter: $setter = Set::new(val);
+                    let res = libc::setsockopt(fd, $level, $flag,
+                                               setter.ffi_ptr(),
+                                               setter.ffi_len());
+                    Errno::result(res).map(drop)
+                }
+            }
+        }
+    }
+}
+macro_rules! getsockopt_impl {
+    ($name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
+        impl GetSockOpt for $name {
+            type Val = $ty;
+            fn get(&self, fd: RawFd) -> Result<$ty> {
+                unsafe {
+                    let mut getter: $getter = Get::uninit();
+                    let res = libc::getsockopt(fd, $level, $flag,
+                                               getter.ffi_ptr(),
+                                               getter.ffi_len());
+                    Errno::result(res)?;
+                    Ok(getter.assume_init())
+                }
+            }
+        }
+    }
+}
+macro_rules! sockopt_impl {
+    (GetOnly, $name:ident, $level:path, $flag:path, bool) => {
+        sockopt_impl!(GetOnly, $name, $level, $flag, bool, GetBool);
+    };
+    (GetOnly, $name:ident, $level:path, $flag:path, u8) => {
+        sockopt_impl!(GetOnly, $name, $level, $flag, u8, GetU8);
+    };
+    (GetOnly, $name:ident, $level:path, $flag:path, usize) => {
+        sockopt_impl!(GetOnly, $name, $level, $flag, usize, GetUsize);
+    };
+    (SetOnly, $name:ident, $level:path, $flag:path, bool) => {
+        sockopt_impl!(SetOnly, $name, $level, $flag, bool, SetBool);
+    };
+    (SetOnly, $name:ident, $level:path, $flag:path, u8) => {
+        sockopt_impl!(SetOnly, $name, $level, $flag, u8, SetU8);
+    };
+    (SetOnly, $name:ident, $level:path, $flag:path, usize) => {
+        sockopt_impl!(SetOnly, $name, $level, $flag, usize, SetUsize);
+    };
+    (Both, $name:ident, $level:path, $flag:path, bool) => {
+        sockopt_impl!(Both, $name, $level, $flag, bool, GetBool, SetBool);
+    };
+    (Both, $name:ident, $level:path, $flag:path, u8) => {
+        sockopt_impl!(Both, $name, $level, $flag, u8, GetU8, SetU8);
+    };
+    (Both, $name:ident, $level:path, $flag:path, usize) => {
+        sockopt_impl!(Both, $name, $level, $flag, usize, GetUsize, SetUsize);
+    };
+    (Both, $name:ident, $level:path, $flag:path, OsString<$array:ty>) => {
+        sockopt_impl!(Both, $name, $level, $flag, OsString, GetOsString<$array>, SetOsString);
+    };
+    /*
+     * Matchers with generic getter types must be placed at the end, so
+     * they'll only match _after_ specialized matchers fail
+     */
+    (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
+        sockopt_impl!(GetOnly, $name, $level, $flag, $ty, GetStruct<$ty>);
+    };
+    (GetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty) => {
+        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+        pub struct $name;
+        getsockopt_impl!($name, $level, $flag, $ty, $getter);
+    };
+    (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty) => {
+        sockopt_impl!(SetOnly, $name, $level, $flag, $ty, SetStruct<$ty>);
+    };
+    (SetOnly, $name:ident, $level:path, $flag:path, $ty:ty, $setter:ty) => {
+        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+        pub struct $name;
+        setsockopt_impl!($name, $level, $flag, $ty, $setter);
+    };
+    (Both, $name:ident, $level:path, $flag:path, $ty:ty, $getter:ty, $setter:ty) => {
+        #[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+        pub struct $name;
+        setsockopt_impl!($name, $level, $flag, $ty, $setter);
+        getsockopt_impl!($name, $level, $flag, $ty, $getter);
+    };
+    (Both, $name:ident, $level:path, $flag:path, $ty:ty) => {
+        sockopt_impl!(Both, $name, $level, $flag, $ty, GetStruct<$ty>, SetStruct<$ty>);
+    };
+}
+/*
+ *
+ * ===== Define sockopts =====
+ *
+ */
+sockopt_impl!(Both, ReuseAddr, libc::SOL_SOCKET, libc::SO_REUSEADDR, bool);
+#[cfg(not(any(target_os = "illumos", target_os = "solaris")))]
+sockopt_impl!(Both, ReusePort, libc::SOL_SOCKET, libc::SO_REUSEPORT, bool);
+sockopt_impl!(Both, TcpNoDelay, libc::IPPROTO_TCP, libc::TCP_NODELAY, bool);
+sockopt_impl!(Both, Linger, libc::SOL_SOCKET, libc::SO_LINGER, libc::linger);
+sockopt_impl!(SetOnly, IpAddMembership, libc::IPPROTO_IP, libc::IP_ADD_MEMBERSHIP, super::IpMembershipRequest);
+sockopt_impl!(SetOnly, IpDropMembership, libc::IPPROTO_IP, libc::IP_DROP_MEMBERSHIP, super::IpMembershipRequest);
+cfg_if! {
+    if #[cfg(any(target_os = "android", target_os = "linux"))] {
+        sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_ADD_MEMBERSHIP, super::Ipv6MembershipRequest);
+        sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_DROP_MEMBERSHIP, super::Ipv6MembershipRequest);
+    } else if #[cfg(any(target_os = "dragonfly",
+                        target_os = "freebsd",
+                        target_os = "illumos",
+                        target_os = "ios",
+                        target_os = "macos",
+                        target_os = "netbsd",
+                        target_os = "openbsd",
+                        target_os = "solaris"))] {
+        sockopt_impl!(SetOnly, Ipv6AddMembership, libc::IPPROTO_IPV6, libc::IPV6_JOIN_GROUP, super::Ipv6MembershipRequest);
+        sockopt_impl!(SetOnly, Ipv6DropMembership, libc::IPPROTO_IPV6, libc::IPV6_LEAVE_GROUP, super::Ipv6MembershipRequest);
+    }
+}
+sockopt_impl!(Both, IpMulticastTtl, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL, u8);
+sockopt_impl!(Both, IpMulticastLoop, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP, bool);
+#[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(Both, IpFreebind, libc::IPPROTO_IP, libc::IP_FREEBIND, bool);
+sockopt_impl!(Both, ReceiveTimeout, libc::SOL_SOCKET, libc::SO_RCVTIMEO, TimeVal);
+sockopt_impl!(Both, SendTimeout, libc::SOL_SOCKET, libc::SO_SNDTIMEO, TimeVal);
+sockopt_impl!(Both, Broadcast, libc::SOL_SOCKET, libc::SO_BROADCAST, bool);
+sockopt_impl!(Both, OobInline, libc::SOL_SOCKET, libc::SO_OOBINLINE, bool);
+sockopt_impl!(GetOnly, SocketError, libc::SOL_SOCKET, libc::SO_ERROR, i32);
+sockopt_impl!(Both, KeepAlive, libc::SOL_SOCKET, libc::SO_KEEPALIVE, bool);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(GetOnly, PeerCredentials, libc::SOL_SOCKET, libc::SO_PEERCRED, super::UnixCredentials);
+#[cfg(any(target_os = "ios",
+          target_os = "macos"))]
+sockopt_impl!(Both, TcpKeepAlive, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE, u32);
+#[cfg(any(target_os = "android",
+          target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "linux",
+          target_os = "nacl"))]
+sockopt_impl!(Both, TcpKeepIdle, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE, u32);
+#[cfg(not(target_os = "openbsd"))]
+sockopt_impl!(Both, TcpKeepCount, libc::IPPROTO_TCP, libc::TCP_KEEPCNT, u32);
+#[cfg(not(target_os = "openbsd"))]
+sockopt_impl!(Both, TcpKeepInterval, libc::IPPROTO_TCP, libc::TCP_KEEPINTVL, u32);
+#[cfg(any(target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(Both, TcpUserTimeout, libc::IPPROTO_TCP, libc::TCP_USER_TIMEOUT, u32);
+sockopt_impl!(Both, RcvBuf, libc::SOL_SOCKET, libc::SO_RCVBUF, usize);
+sockopt_impl!(Both, SndBuf, libc::SOL_SOCKET, libc::SO_SNDBUF, usize);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(SetOnly, RcvBufForce, libc::SOL_SOCKET, libc::SO_RCVBUFFORCE, usize);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(SetOnly, SndBufForce, libc::SOL_SOCKET, libc::SO_SNDBUFFORCE, usize);
+sockopt_impl!(GetOnly, SockType, libc::SOL_SOCKET, libc::SO_TYPE, super::SockType);
+sockopt_impl!(GetOnly, AcceptConn, libc::SOL_SOCKET, libc::SO_ACCEPTCONN, bool);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(Both, BindToDevice, libc::SOL_SOCKET, libc::SO_BINDTODEVICE, OsString<[u8; libc::IFNAMSIZ]>);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(GetOnly, OriginalDst, libc::SOL_IP, libc::SO_ORIGINAL_DST, libc::sockaddr_in);
+sockopt_impl!(Both, ReceiveTimestamp, libc::SOL_SOCKET, libc::SO_TIMESTAMP, bool);
+#[cfg(all(target_os = "linux"))]
+sockopt_impl!(Both, ReceiveTimestampns, libc::SOL_SOCKET, libc::SO_TIMESTAMPNS, bool);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(Both, IpTransparent, libc::SOL_IP, libc::IP_TRANSPARENT, bool);
+#[cfg(target_os = "openbsd")]
+sockopt_impl!(Both, BindAny, libc::SOL_SOCKET, libc::SO_BINDANY, bool);
+#[cfg(target_os = "freebsd")]
+sockopt_impl!(Both, BindAny, libc::IPPROTO_IP, libc::IP_BINDANY, bool);
+#[cfg(target_os = "linux")]
+sockopt_impl!(Both, Mark, libc::SOL_SOCKET, libc::SO_MARK, u32);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+sockopt_impl!(Both, PassCred, libc::SOL_SOCKET, libc::SO_PASSCRED, bool);
+#[cfg(any(target_os = "freebsd", target_os = "linux"))] 
+sockopt_impl!(Both, TcpCongestion, libc::IPPROTO_TCP, libc::TCP_CONGESTION, OsString<[u8; TCP_CA_NAME_MAX]>);
+#[cfg(any(
+    target_os = "android",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+))]
+sockopt_impl!(Both, Ipv4PacketInfo, libc::IPPROTO_IP, libc::IP_PKTINFO, bool);
+#[cfg(any(
+    target_os = "android",
+    target_os = "freebsd",
+    target_os = "ios",
+    target_os = "linux",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+sockopt_impl!(Both, Ipv6RecvPacketInfo, libc::IPPROTO_IPV6, libc::IPV6_RECVPKTINFO, bool);
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "ios",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+sockopt_impl!(Both, Ipv4RecvIf, libc::IPPROTO_IP, libc::IP_RECVIF, bool);
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "ios",
+    target_os = "macos",
+    target_os = "netbsd",
+    target_os = "openbsd",
+))]
+sockopt_impl!(Both, Ipv4RecvDstAddr, libc::IPPROTO_IP, libc::IP_RECVDSTADDR, bool);
+#[cfg(target_os = "linux")]
+sockopt_impl!(Both, UdpGsoSegment, libc::SOL_UDP, libc::UDP_SEGMENT, libc::c_int);
+#[cfg(target_os = "linux")]
+sockopt_impl!(Both, UdpGroSegment, libc::IPPROTO_UDP, libc::UDP_GRO, bool);
+#[cfg(any(target_os = "android", target_os = "fuchsia", target_os = "linux"))]
+sockopt_impl!(Both, RxqOvfl, libc::SOL_SOCKET, libc::SO_RXQ_OVFL, libc::c_int);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[derive(Copy, Clone, Debug)]
+pub struct AlgSetAeadAuthSize;
+#[cfg(any(target_os = "android", target_os = "linux"))]
+impl SetSockOpt for AlgSetAeadAuthSize {
+    type Val = usize;
+    fn set(&self, fd: RawFd, val: &usize) -> Result<()> {
+        unsafe {
+            let res = libc::setsockopt(fd,
+                                       libc::SOL_ALG,
+                                       libc::ALG_SET_AEAD_AUTHSIZE,
+                                       ::std::ptr::null(),
+                                       *val as libc::socklen_t);
+            Errno::result(res).map(drop)
+        }
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+#[derive(Clone, Debug)]
+pub struct AlgSetKey<T>(::std::marker::PhantomData<T>);
+#[cfg(any(target_os = "android", target_os = "linux"))]
+impl<T> Default for AlgSetKey<T> {
+    fn default() -> Self {
+        AlgSetKey(Default::default())
+    }
+}
+#[cfg(any(target_os = "android", target_os = "linux"))]
+impl<T> SetSockOpt for AlgSetKey<T> where T: AsRef<[u8]> + Clone {
+    type Val = T;
+    fn set(&self, fd: RawFd, val: &T) -> Result<()> {
+        unsafe {
+            let res = libc::setsockopt(fd,
+                                       libc::SOL_ALG,
+                                       libc::ALG_SET_KEY,
+                                       val.as_ref().as_ptr() as *const _,
+                                       val.as_ref().len() as libc::socklen_t);
+            Errno::result(res).map(drop)
+        }
+    }
+}
+/*
+ *
+ * ===== Accessor helpers =====
+ *
+ */
+unsafe trait Get<T> {
+    unsafe fn uninit() -> Self;
+    fn ffi_ptr(&mut self) -> *mut c_void;
+    fn ffi_len(&mut self) -> *mut socklen_t;
+    unsafe fn assume_init(self) -> T;
+}
+unsafe trait Set<'a, T> {
+    fn new(val: &'a T) -> Self;
+    fn ffi_ptr(&self) -> *const c_void;
+    fn ffi_len(&self) -> socklen_t;
+}
+struct GetStruct<T> {
+    len: socklen_t,
+    val: MaybeUninit<T>,
+}
+unsafe impl<T> Get<T> for GetStruct<T> {
+    unsafe fn uninit() -> Self {
+        GetStruct {
+            len: mem::size_of::<T>() as socklen_t,
+            val: MaybeUninit::uninit(),
+        }
+    }
+    fn ffi_ptr(&mut self) -> *mut c_void {
+        self.val.as_mut_ptr() as *mut c_void
+    }
+    fn ffi_len(&mut self) -> *mut socklen_t {
+        &mut self.len
+    }
+    unsafe fn assume_init(self) -> T {
+        assert_eq!(self.len as usize, mem::size_of::<T>(), "invalid getsockopt implementation");
+        self.val.assume_init()
+    }
+}
+struct SetStruct<'a, T: 'static> {
+    ptr: &'a T,
+}
+unsafe impl<'a, T> Set<'a, T> for SetStruct<'a, T> {
+    fn new(ptr: &'a T) -> SetStruct<'a, T> {
+        SetStruct { ptr }
+    }
+    fn ffi_ptr(&self) -> *const c_void {
+        self.ptr as *const T as *const c_void
+    }
+    fn ffi_len(&self) -> socklen_t {
+        mem::size_of::<T>() as socklen_t
+    }
+}
+struct GetBool {
+    len: socklen_t,
+    val: MaybeUninit<c_int>,
+}
+unsafe impl Get<bool> for GetBool {
+    unsafe fn uninit() -> Self {
+        GetBool {
+            len: mem::size_of::<c_int>() as socklen_t,
+            val: MaybeUninit::uninit(),
+        }
+    }
+    fn ffi_ptr(&mut self) -> *mut c_void {
+        self.val.as_mut_ptr() as *mut c_void
+    }
+    fn ffi_len(&mut self) -> *mut socklen_t {
+        &mut self.len
+    }
+    unsafe fn assume_init(self) -> bool {
+        assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
+        self.val.assume_init() != 0
+    }
+}
+struct SetBool {
+    val: c_int,
+}
+unsafe impl<'a> Set<'a, bool> for SetBool {
+    fn new(val: &'a bool) -> SetBool {
+        SetBool { val: if *val { 1 } else { 0 } }
+    }
+    fn ffi_ptr(&self) -> *const c_void {
+        &self.val as *const c_int as *const c_void
+    }
+    fn ffi_len(&self) -> socklen_t {
+        mem::size_of::<c_int>() as socklen_t
+    }
+}
+struct GetU8 {
+    len: socklen_t,
+    val: MaybeUninit<u8>,
+}
+unsafe impl Get<u8> for GetU8 {
+    unsafe fn uninit() -> Self {
+        GetU8 {
+            len: mem::size_of::<u8>() as socklen_t,
+            val: MaybeUninit::uninit(),
+        }
+    }
+    fn ffi_ptr(&mut self) -> *mut c_void {
+        self.val.as_mut_ptr() as *mut c_void
+    }
+    fn ffi_len(&mut self) -> *mut socklen_t {
+        &mut self.len
+    }
+    unsafe fn assume_init(self) -> u8 {
+        assert_eq!(self.len as usize, mem::size_of::<u8>(), "invalid getsockopt implementation");
+        self.val.assume_init()
+    }
+}
+struct SetU8 {
+    val: u8,
+}
+unsafe impl<'a> Set<'a, u8> for SetU8 {
+    fn new(val: &'a u8) -> SetU8 {
+        SetU8 { val: *val as u8 }
+    }
+    fn ffi_ptr(&self) -> *const c_void {
+        &self.val as *const u8 as *const c_void
+    }
+    fn ffi_len(&self) -> socklen_t {
+        mem::size_of::<c_int>() as socklen_t
+    }
+}
+struct GetUsize {
+    len: socklen_t,
+    val: MaybeUninit<c_int>,
+}
+unsafe impl Get<usize> for GetUsize {
+    unsafe fn uninit() -> Self {
+        GetUsize {
+            len: mem::size_of::<c_int>() as socklen_t,
+            val: MaybeUninit::uninit(),
+        }
+    }
+    fn ffi_ptr(&mut self) -> *mut c_void {
+        self.val.as_mut_ptr() as *mut c_void
+    }
+    fn ffi_len(&mut self) -> *mut socklen_t {
+        &mut self.len
+    }
+    unsafe fn assume_init(self) -> usize {
+        assert_eq!(self.len as usize, mem::size_of::<c_int>(), "invalid getsockopt implementation");
+        self.val.assume_init() as usize
+    }
+}
+struct SetUsize {
+    val: c_int,
+}
+unsafe impl<'a> Set<'a, usize> for SetUsize {
+    fn new(val: &'a usize) -> SetUsize {
+        SetUsize { val: *val as c_int }
+    }
+    fn ffi_ptr(&self) -> *const c_void {
+        &self.val as *const c_int as *const c_void
+    }
+    fn ffi_len(&self) -> socklen_t {
+        mem::size_of::<c_int>() as socklen_t
+    }
+}
+struct GetOsString<T: AsMut<[u8]>> {
+    len: socklen_t,
+    val: MaybeUninit<T>,
+}
+unsafe impl<T: AsMut<[u8]>> Get<OsString> for GetOsString<T> {
+    unsafe fn uninit() -> Self {
+        GetOsString {
+            len: mem::size_of::<T>() as socklen_t,
+            val: MaybeUninit::uninit(),
+        }
+    }
+    fn ffi_ptr(&mut self) -> *mut c_void {
+        self.val.as_mut_ptr() as *mut c_void
+    }
+    fn ffi_len(&mut self) -> *mut socklen_t {
+        &mut self.len
+    }
+    unsafe fn assume_init(self) -> OsString {
+        let len = self.len as usize;
+        let mut v = self.val.assume_init();
+        OsStr::from_bytes(&v.as_mut()[0..len]).to_owned()
+    }
+}
+struct SetOsString<'a> {
+    val: &'a OsStr,
+}
+unsafe impl<'a> Set<'a, OsString> for SetOsString<'a> {
+    fn new(val: &'a OsString) -> SetOsString {
+        SetOsString { val: val.as_os_str() }
+    }
+    fn ffi_ptr(&self) -> *const c_void {
+        self.val.as_bytes().as_ptr() as *const c_void
+    }
+    fn ffi_len(&self) -> socklen_t {
+        self.val.len() as socklen_t
+    }
+}
+#[cfg(test)]
+mod test {
+    #[cfg(any(target_os = "android", target_os = "linux"))]
+    #[test]
+    fn can_get_peercred_on_unix_socket() {
+        use super::super::*;
+        let (a, b) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty()).unwrap();
+        let a_cred = getsockopt(a, super::PeerCredentials).unwrap();
+        let b_cred = getsockopt(b, super::PeerCredentials).unwrap();
+        assert_eq!(a_cred, b_cred);
+        assert!(a_cred.pid() != 0);
+    }
+    #[test]
+    fn is_socket_type_unix() {
+        use super::super::*;
+        use crate::unistd::close;
+        let (a, b) = socketpair(AddressFamily::Unix, SockType::Stream, None, SockFlag::empty()).unwrap();
+        let a_type = getsockopt(a, super::SockType).unwrap();
+        assert_eq!(a_type, SockType::Stream);
+        close(a).unwrap();
+        close(b).unwrap();
+    }
+    #[test]
+    fn is_socket_type_dgram() {
+        use super::super::*;
+        use crate::unistd::close;
+        let s = socket(AddressFamily::Inet, SockType::Datagram, SockFlag::empty(), None).unwrap();
+        let s_type = getsockopt(s, super::SockType).unwrap();
+        assert_eq!(s_type, SockType::Datagram);
+        close(s).unwrap();
+    }
+    #[cfg(any(target_os = "freebsd",
+              target_os = "linux",
+              target_os = "nacl"))]
+    #[test]
+    fn can_get_listen_on_tcp_socket() {
+        use super::super::*;
+        use crate::unistd::close;
+        let s = socket(AddressFamily::Inet, SockType::Stream, SockFlag::empty(), None).unwrap();
+        let s_listening = getsockopt(s, super::AcceptConn).unwrap();
+        assert!(!s_listening);
+        listen(s, 10).unwrap();
+        let s_listening2 = getsockopt(s, super::AcceptConn).unwrap();
+        assert!(s_listening2);
+        close(s).unwrap();
+    }
+}

--- a//dev/null
+++ b/src/sys/termios.rs
@@ -0,0 +1,798 @@
+#![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
+            doc = " ```rust,ignore")]
+#![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                    target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
+            doc = " ```rust")]
+#![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
+            doc = " ```rust")]
+#![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                    target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
+            doc = " ```rust,ignore")]
+#![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
+            doc = " ```rust")]
+#![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                    target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
+            doc = " ```rust,ignore")]
+#![cfg_attr(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                target_os = "macos", target_os = "netbsd", target_os = "openbsd"),
+            doc = " ```rust")]
+#![cfg_attr(not(any(target_os = "freebsd", target_os = "dragonfly", target_os = "ios",
+                    target_os = "macos", target_os = "netbsd", target_os = "openbsd")),
+            doc = " ```rust,ignore")]
+use cfg_if::cfg_if;
+use crate::{Error, Result};
+use crate::errno::Errno;
+use libc::{self, c_int, tcflag_t};
+use std::cell::{Ref, RefCell};
+use std::convert::{From, TryFrom};
+use std::mem;
+use std::os::unix::io::RawFd;
+use crate::unistd::Pid;
+#[derive(Clone, Debug, Eq, PartialEq)]
+pub struct Termios {
+    inner: RefCell<libc::termios>,
+    pub input_flags: InputFlags,
+    pub output_flags: OutputFlags,
+    pub control_flags: ControlFlags,
+    pub local_flags: LocalFlags,
+    pub control_chars: [libc::cc_t; NCCS],
+}
+impl Termios {
+    pub(crate) fn get_libc_termios(&self) -> Ref<libc::termios> {
+        {
+            let mut termios = self.inner.borrow_mut();
+            termios.c_iflag = self.input_flags.bits();
+            termios.c_oflag = self.output_flags.bits();
+            termios.c_cflag = self.control_flags.bits();
+            termios.c_lflag = self.local_flags.bits();
+            termios.c_cc = self.control_chars;
+        }
+        self.inner.borrow()
+    }
+    pub(crate) unsafe fn get_libc_termios_mut(&mut self) -> *mut libc::termios {
+        {
+            let mut termios = self.inner.borrow_mut();
+            termios.c_iflag = self.input_flags.bits();
+            termios.c_oflag = self.output_flags.bits();
+            termios.c_cflag = self.control_flags.bits();
+            termios.c_lflag = self.local_flags.bits();
+            termios.c_cc = self.control_chars;
+        }
+        self.inner.as_ptr()
+    }
+    pub(crate) fn update_wrapper(&mut self) {
+        let termios = *self.inner.borrow_mut();
+        self.input_flags = InputFlags::from_bits_truncate(termios.c_iflag);
+        self.output_flags = OutputFlags::from_bits_truncate(termios.c_oflag);
+        self.control_flags = ControlFlags::from_bits_truncate(termios.c_cflag);
+        self.local_flags = LocalFlags::from_bits_truncate(termios.c_lflag);
+        self.control_chars = termios.c_cc;
+    }
+}
+impl From<libc::termios> for Termios {
+    fn from(termios: libc::termios) -> Self {
+        Termios {
+            inner: RefCell::new(termios),
+            input_flags: InputFlags::from_bits_truncate(termios.c_iflag),
+            output_flags: OutputFlags::from_bits_truncate(termios.c_oflag),
+            control_flags: ControlFlags::from_bits_truncate(termios.c_cflag),
+            local_flags: LocalFlags::from_bits_truncate(termios.c_lflag),
+            control_chars: termios.c_cc,
+        }
+    }
+}
+impl From<Termios> for libc::termios {
+    fn from(termios: Termios) -> Self {
+        termios.inner.into_inner()
+    }
+}
+libc_enum!{
+    #[cfg_attr(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64"), repr(u64))]
+    #[cfg_attr(not(all(any(target_os = "ios", target_os = "macos"), target_pointer_width = "64")), repr(u32))]
+    pub enum BaudRate {
+        B0,
+        B50,
+        B75,
+        B110,
+        B134,
+        B150,
+        B200,
+        B300,
+        B600,
+        B1200,
+        B1800,
+        B2400,
+        B4800,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd"))]
+        B7200,
+        B9600,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd"))]
+        B14400,
+        B19200,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd"))]
+        B28800,
+        B38400,
+        B57600,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd"))]
+        B76800,
+        B115200,
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        B153600,
+        B230400,
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        B307200,
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "netbsd",
+                  target_os = "solaris"))]
+        B460800,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B500000,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B576000,
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "linux",
+                  target_os = "netbsd",
+                  target_os = "solaris"))]
+        B921600,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B1000000,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B1152000,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B1500000,
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        B2000000,
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+        B2500000,
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+        B3000000,
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+        B3500000,
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+        B4000000,
+    }
+}
+impl TryFrom<libc::speed_t> for BaudRate {
+    type Error = Error;
+    fn try_from(s: libc::speed_t) -> Result<BaudRate> {
+        use libc::{B0, B50, B75, B110, B134, B150, B200, B300, B600, B1200, B1800, B2400, B4800,
+                   B9600, B19200, B38400, B57600, B115200, B230400};
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        use libc::{B500000, B576000, B1000000, B1152000, B1500000, B2000000};
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+        use libc::{B2500000, B3000000, B3500000, B4000000};
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        use libc::{B7200, B14400, B28800, B76800};
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "linux",
+                  target_os = "netbsd"))]
+        use libc::{B460800, B921600};
+        #[cfg(any(target_os = "illumos", target_os = "solaris"))]
+        use libc::{B153600, B307200, B460800, B921600};
+        match s {
+            B0 => Ok(BaudRate::B0),
+            B50 => Ok(BaudRate::B50),
+            B75 => Ok(BaudRate::B75),
+            B110 => Ok(BaudRate::B110),
+            B134 => Ok(BaudRate::B134),
+            B150 => Ok(BaudRate::B150),
+            B200 => Ok(BaudRate::B200),
+            B300 => Ok(BaudRate::B300),
+            B600 => Ok(BaudRate::B600),
+            B1200 => Ok(BaudRate::B1200),
+            B1800 => Ok(BaudRate::B1800),
+            B2400 => Ok(BaudRate::B2400),
+            B4800 => Ok(BaudRate::B4800),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "openbsd"))]
+            B7200 => Ok(BaudRate::B7200),
+            B9600 => Ok(BaudRate::B9600),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "openbsd"))]
+            B14400 => Ok(BaudRate::B14400),
+            B19200 => Ok(BaudRate::B19200),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "openbsd"))]
+            B28800 => Ok(BaudRate::B28800),
+            B38400 => Ok(BaudRate::B38400),
+            B57600 => Ok(BaudRate::B57600),
+            #[cfg(any(target_os = "dragonfly",
+                      target_os = "freebsd",
+                      target_os = "macos",
+                      target_os = "netbsd",
+                      target_os = "openbsd"))]
+            B76800 => Ok(BaudRate::B76800),
+            B115200 => Ok(BaudRate::B115200),
+            #[cfg(any(target_os = "illumos",
+                      target_os = "solaris"))]
+            B153600 => Ok(BaudRate::B153600),
+            B230400 => Ok(BaudRate::B230400),
+            #[cfg(any(target_os = "illumos",
+                      target_os = "solaris"))]
+            B307200 => Ok(BaudRate::B307200),
+            #[cfg(any(target_os = "android",
+                      target_os = "freebsd",
+                      target_os = "illumos",
+                      target_os = "linux",
+                      target_os = "netbsd",
+                      target_os = "solaris"))]
+            B460800 => Ok(BaudRate::B460800),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B500000 => Ok(BaudRate::B500000),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B576000 => Ok(BaudRate::B576000),
+            #[cfg(any(target_os = "android",
+                      target_os = "freebsd",
+                      target_os = "illumos",
+                      target_os = "linux",
+                      target_os = "netbsd",
+                      target_os = "solaris"))]
+            B921600 => Ok(BaudRate::B921600),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B1000000 => Ok(BaudRate::B1000000),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B1152000 => Ok(BaudRate::B1152000),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B1500000 => Ok(BaudRate::B1500000),
+            #[cfg(any(target_os = "android", target_os = "linux"))]
+            B2000000 => Ok(BaudRate::B2000000),
+            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+            B2500000 => Ok(BaudRate::B2500000),
+            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+            B3000000 => Ok(BaudRate::B3000000),
+            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+            B3500000 => Ok(BaudRate::B3500000),
+            #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "sparc64"))))]
+            B4000000 => Ok(BaudRate::B4000000),
+            _ => Err(Error::from(Errno::EINVAL))
+        }
+    }
+}
+#[cfg(any(target_os = "freebsd",
+          target_os = "dragonfly",
+          target_os = "ios",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+impl From<BaudRate> for u32 {
+    fn from(b: BaudRate) -> u32 {
+        b as u32
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum SetArg {
+        TCSANOW,
+        TCSADRAIN,
+        TCSAFLUSH,
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum FlushArg {
+        TCIFLUSH,
+        TCOFLUSH,
+        TCIOFLUSH,
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum FlowArg {
+        TCOOFF,
+        TCOON,
+        TCIOFF,
+        TCION,
+    }
+}
+libc_enum! {
+    #[repr(usize)]
+    pub enum SpecialCharacterIndices {
+        VDISCARD,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "illumos",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd",
+                target_os = "solaris"))]
+        VDSUSP,
+        VEOF,
+        VEOL,
+        VEOL2,
+        VERASE,
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "illumos",
+                  target_os = "solaris"))]
+        VERASE2,
+        VINTR,
+        VKILL,
+        VLNEXT,
+        #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
+                target_os = "illumos", target_os = "solaris")))]
+        VMIN,
+        VQUIT,
+        VREPRINT,
+        VSTART,
+        #[cfg(any(target_os = "dragonfly",
+                target_os = "freebsd",
+                target_os = "illumos",
+                target_os = "macos",
+                target_os = "netbsd",
+                target_os = "openbsd",
+                target_os = "solaris"))]
+        VSTATUS,
+        VSTOP,
+        VSUSP,
+        #[cfg(target_os = "linux")]
+        VSWTC,
+        #[cfg(any(target_os = "haiku", target_os = "illumos", target_os = "solaris"))]
+        VSWTCH,
+        #[cfg(not(any(all(target_os = "linux", target_arch = "sparc64"),
+                target_os = "illumos", target_os = "solaris")))]
+        VTIME,
+        VWERASE,
+        #[cfg(target_os = "dragonfly")]
+        VCHECKPT,
+    }
+}
+#[cfg(any(all(target_os = "linux", target_arch = "sparc64"),
+        target_os = "illumos", target_os = "solaris"))]
+impl SpecialCharacterIndices {
+    pub const VMIN: SpecialCharacterIndices = SpecialCharacterIndices::VEOF;
+    pub const VTIME: SpecialCharacterIndices = SpecialCharacterIndices::VEOL;
+}
+pub use libc::NCCS;
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "linux",
+          target_os = "macos",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+pub use libc::_POSIX_VDISABLE;
+libc_bitflags! {
+    pub struct InputFlags: tcflag_t {
+        IGNBRK;
+        BRKINT;
+        IGNPAR;
+        PARMRK;
+        INPCK;
+        ISTRIP;
+        INLCR;
+        IGNCR;
+        ICRNL;
+        IXON;
+        IXOFF;
+        IXANY;
+        IMAXBEL;
+        #[cfg(any(target_os = "android", target_os = "linux", target_os = "macos"))]
+        IUTF8;
+    }
+}
+libc_bitflags! {
+    pub struct OutputFlags: tcflag_t {
+        OPOST;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "linux",
+                  target_os = "openbsd"))]
+        OLCUC;
+        ONLCR;
+        OCRNL as tcflag_t;
+        ONOCR as tcflag_t;
+        ONLRET as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        OFILL as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        OFDEL as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        NL0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        NL1 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        CR0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        CR1 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        CR2 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        CR3 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        TAB0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        TAB1 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        TAB2 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        TAB3 as tcflag_t;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        XTABS;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        BS0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        BS1 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        VT0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        VT1 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        FF0 as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        FF1 as tcflag_t;
+        #[cfg(any(target_os = "freebsd",
+                  target_os = "dragonfly",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        OXTABS;
+        #[cfg(any(target_os = "freebsd",
+                  target_os = "dragonfly",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        ONOEOT as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        NLDLY as tcflag_t; // FIXME: Datatype needs to be corrected in libc for mac
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        CRDLY as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "freebsd",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        TABDLY as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        BSDLY as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        VTDLY as tcflag_t;
+        #[cfg(any(target_os = "android",
+                  target_os = "haiku",
+                  target_os = "ios",
+                  target_os = "linux",
+                  target_os = "macos"))]
+        FFDLY as tcflag_t;
+    }
+}
+libc_bitflags! {
+    pub struct ControlFlags: tcflag_t {
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        CIGNORE;
+        CS5;
+        CS6;
+        CS7;
+        CS8;
+        CSTOPB;
+        CREAD;
+        PARENB;
+        PARODD;
+        HUPCL;
+        CLOCAL;
+        #[cfg(not(target_os = "redox"))]
+        CRTSCTS;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        CBAUD;
+        #[cfg(any(target_os = "android", all(target_os = "linux", not(target_arch = "mips"))))]
+        CMSPAR;
+        #[cfg(any(target_os = "android",
+                  all(target_os = "linux",
+                      not(any(target_arch = "powerpc", target_arch = "powerpc64")))))]
+        CIBAUD;
+        #[cfg(any(target_os = "android", target_os = "linux"))]
+        CBAUDEX;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        MDMBUF;
+        #[cfg(any(target_os = "netbsd", target_os = "openbsd"))]
+        CHWFLOW;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        CCTS_OFLOW;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        CRTS_IFLOW;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd"))]
+        CDTR_IFLOW;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd"))]
+        CDSR_OFLOW;
+        #[cfg(any(target_os = "dragonfly",
+                  target_os = "freebsd"))]
+        CCAR_OFLOW;
+        CSIZE;
+    }
+}
+libc_bitflags! {
+    pub struct LocalFlags: tcflag_t {
+        #[cfg(not(target_os = "redox"))]
+        ECHOKE;
+        ECHOE;
+        ECHOK;
+        ECHO;
+        ECHONL;
+        #[cfg(not(target_os = "redox"))]
+        ECHOPRT;
+        #[cfg(not(target_os = "redox"))]
+        ECHOCTL;
+        ISIG;
+        ICANON;
+        #[cfg(any(target_os = "freebsd",
+                  target_os = "dragonfly",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        ALTWERASE;
+        IEXTEN;
+        #[cfg(not(target_os = "redox"))]
+        EXTPROC;
+        TOSTOP;
+        #[cfg(not(target_os = "redox"))]
+        FLUSHO;
+        #[cfg(any(target_os = "freebsd",
+                  target_os = "dragonfly",
+                  target_os = "ios",
+                  target_os = "macos",
+                  target_os = "netbsd",
+                  target_os = "openbsd"))]
+        NOKERNINFO;
+        #[cfg(not(target_os = "redox"))]
+        PENDIN;
+        NOFLSH;
+    }
+}
+cfg_if!{
+    if #[cfg(any(target_os = "freebsd",
+                 target_os = "dragonfly",
+                 target_os = "ios",
+                 target_os = "macos",
+                 target_os = "netbsd",
+                 target_os = "openbsd"))] {
+        pub fn cfgetispeed(termios: &Termios) -> u32 {
+            let inner_termios = termios.get_libc_termios();
+            unsafe { libc::cfgetispeed(&*inner_termios) as u32 }
+        }
+        pub fn cfgetospeed(termios: &Termios) -> u32 {
+            let inner_termios = termios.get_libc_termios();
+            unsafe { libc::cfgetospeed(&*inner_termios) as u32 }
+        }
+        pub fn cfsetispeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetispeed(inner_termios, baud.into() as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+        pub fn cfsetospeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetospeed(inner_termios, baud.into() as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+        pub fn cfsetspeed<T: Into<u32>>(termios: &mut Termios, baud: T) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetspeed(inner_termios, baud.into() as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+    } else {
+        use std::convert::TryInto;
+        pub fn cfgetispeed(termios: &Termios) -> BaudRate {
+            let inner_termios = termios.get_libc_termios();
+            unsafe { libc::cfgetispeed(&*inner_termios) }.try_into().unwrap()
+        }
+        pub fn cfgetospeed(termios: &Termios) -> BaudRate {
+            let inner_termios = termios.get_libc_termios();
+            unsafe { libc::cfgetospeed(&*inner_termios) }.try_into().unwrap()
+        }
+        pub fn cfsetispeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetispeed(inner_termios, baud as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+        pub fn cfsetospeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetospeed(inner_termios, baud as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+        pub fn cfsetspeed(termios: &mut Termios, baud: BaudRate) -> Result<()> {
+            let inner_termios = unsafe { termios.get_libc_termios_mut() };
+            let res = unsafe { libc::cfsetspeed(inner_termios, baud as libc::speed_t) };
+            termios.update_wrapper();
+            Errno::result(res).map(drop)
+        }
+    }
+}
+pub fn cfmakeraw(termios: &mut Termios) {
+    let inner_termios = unsafe { termios.get_libc_termios_mut() };
+    unsafe {
+        libc::cfmakeraw(inner_termios);
+    }
+    termios.update_wrapper();
+}
+#[cfg(target_os = "freebsd")]
+pub fn cfmakesane(termios: &mut Termios) {
+    let inner_termios = unsafe { termios.get_libc_termios_mut() };
+    unsafe {
+        libc::cfmakesane(inner_termios);
+    }
+    termios.update_wrapper();
+}
+pub fn tcgetattr(fd: RawFd) -> Result<Termios> {
+    let mut termios = mem::MaybeUninit::uninit();
+    let res = unsafe { libc::tcgetattr(fd, termios.as_mut_ptr()) };
+    Errno::result(res)?;
+    unsafe { Ok(termios.assume_init().into()) }
+}
+pub fn tcsetattr(fd: RawFd, actions: SetArg, termios: &Termios) -> Result<()> {
+    let inner_termios = termios.get_libc_termios();
+    Errno::result(unsafe { libc::tcsetattr(fd, actions as c_int, &*inner_termios) }).map(drop)
+}
+pub fn tcdrain(fd: RawFd) -> Result<()> {
+    Errno::result(unsafe { libc::tcdrain(fd) }).map(drop)
+}
+pub fn tcflow(fd: RawFd, action: FlowArg) -> Result<()> {
+    Errno::result(unsafe { libc::tcflow(fd, action as c_int) }).map(drop)
+}
+pub fn tcflush(fd: RawFd, action: FlushArg) -> Result<()> {
+    Errno::result(unsafe { libc::tcflush(fd, action as c_int) }).map(drop)
+}
+pub fn tcsendbreak(fd: RawFd, duration: c_int) -> Result<()> {
+    Errno::result(unsafe { libc::tcsendbreak(fd, duration) }).map(drop)
+}
+pub fn tcgetsid(fd: RawFd) -> Result<Pid> {
+    let res = unsafe { libc::tcgetsid(fd) };
+    Errno::result(res).map(Pid::from_raw)
+}
+#[cfg(test)]
+mod test {
+    use super::*;
+    #[test]
+    fn try_from() {
+        assert_eq!(Ok(BaudRate::B0), BaudRate::try_from(libc::B0));
+        assert!(BaudRate::try_from(999999999).is_err());
+    }
+}

--- a//dev/null
+++ b/src/sys/timerfd.rs
@@ -0,0 +1,182 @@
+use crate::sys::time::TimeSpec;
+use crate::unistd::read;
+use crate::{errno::Errno, Result};
+use bitflags::bitflags;
+use libc::c_int;
+use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};
+#[derive(Debug)]
+pub struct TimerFd {
+    fd: RawFd,
+}
+impl AsRawFd for TimerFd {
+    fn as_raw_fd(&self) -> RawFd {
+        self.fd
+    }
+}
+impl FromRawFd for TimerFd {
+    unsafe fn from_raw_fd(fd: RawFd) -> Self {
+        TimerFd { fd }
+    }
+}
+libc_enum! {
+    #[repr(i32)]
+    pub enum ClockId {
+        CLOCK_REALTIME,
+        CLOCK_MONOTONIC,
+        CLOCK_BOOTTIME,
+        CLOCK_REALTIME_ALARM,
+        CLOCK_BOOTTIME_ALARM,
+    }
+}
+libc_bitflags! {
+    pub struct TimerFlags: c_int {
+        TFD_NONBLOCK;
+        TFD_CLOEXEC;
+    }
+}
+bitflags! {
+    pub struct TimerSetTimeFlags: libc::c_int {
+        const TFD_TIMER_ABSTIME = libc::TFD_TIMER_ABSTIME;
+    }
+}
+#[derive(Debug, Clone, Copy)]
+struct TimerSpec(libc::itimerspec);
+impl TimerSpec {
+    pub fn none() -> Self {
+        Self(libc::itimerspec {
+            it_interval: libc::timespec {
+                tv_sec: 0,
+                tv_nsec: 0,
+            },
+            it_value: libc::timespec {
+                tv_sec: 0,
+                tv_nsec: 0,
+            },
+        })
+    }
+}
+impl AsRef<libc::itimerspec> for TimerSpec {
+    fn as_ref(&self) -> &libc::itimerspec {
+        &self.0
+    }
+}
+impl From<Expiration> for TimerSpec {
+    fn from(expiration: Expiration) -> TimerSpec {
+        match expiration {
+            Expiration::OneShot(t) => TimerSpec(libc::itimerspec {
+                it_interval: libc::timespec {
+                    tv_sec: 0,
+                    tv_nsec: 0,
+                },
+                it_value: *t.as_ref(),
+            }),
+            Expiration::IntervalDelayed(start, interval) => TimerSpec(libc::itimerspec {
+                it_interval: *interval.as_ref(),
+                it_value: *start.as_ref(),
+            }),
+            Expiration::Interval(t) => TimerSpec(libc::itimerspec {
+                it_interval: *t.as_ref(),
+                it_value: *t.as_ref(),
+            }),
+        }
+    }
+}
+impl From<TimerSpec> for Expiration {
+    fn from(timerspec: TimerSpec) -> Expiration {
+        match timerspec {
+            TimerSpec(libc::itimerspec {
+                it_interval:
+                    libc::timespec {
+                        tv_sec: 0,
+                        tv_nsec: 0,
+                    },
+                it_value: ts,
+            }) => Expiration::OneShot(ts.into()),
+            TimerSpec(libc::itimerspec {
+                it_interval: int_ts,
+                it_value: val_ts,
+            }) => {
+                if (int_ts.tv_sec == val_ts.tv_sec) && (int_ts.tv_nsec == val_ts.tv_nsec) {
+                    Expiration::Interval(int_ts.into())
+                } else {
+                    Expiration::IntervalDelayed(val_ts.into(), int_ts.into())
+                }
+            }
+        }
+    }
+}
+#[derive(Debug, Clone, Copy, PartialEq)]
+pub enum Expiration {
+    OneShot(TimeSpec),
+    IntervalDelayed(TimeSpec, TimeSpec),
+    Interval(TimeSpec),
+}
+impl TimerFd {
+    pub fn new(clockid: ClockId, flags: TimerFlags) -> Result<Self> {
+        Errno::result(unsafe { libc::timerfd_create(clockid as i32, flags.bits()) })
+            .map(|fd| Self { fd })
+    }
+    pub fn set(&self, expiration: Expiration, flags: TimerSetTimeFlags) -> Result<()> {
+        let timerspec: TimerSpec = expiration.into();
+        Errno::result(unsafe {
+            libc::timerfd_settime(
+                self.fd,
+                flags.bits(),
+                timerspec.as_ref(),
+                std::ptr::null_mut(),
+            )
+        })
+        .map(drop)
+    }
+    pub fn get(&self) -> Result<Option<Expiration>> {
+        let mut timerspec = TimerSpec::none();
+        let timerspec_ptr: *mut libc::itimerspec = &mut timerspec.0;
+        Errno::result(unsafe { libc::timerfd_gettime(self.fd, timerspec_ptr) }).map(|_| {
+            if timerspec.0.it_interval.tv_sec == 0
+                && timerspec.0.it_interval.tv_nsec == 0
+                && timerspec.0.it_value.tv_sec == 0
+                && timerspec.0.it_value.tv_nsec == 0
+            {
+                None
+            } else {
+                Some(timerspec.into())
+            }
+        })
+    }
+    pub fn unset(&self) -> Result<()> {
+        Errno::result(unsafe {
+            libc::timerfd_settime(
+                self.fd,
+                TimerSetTimeFlags::empty().bits(),
+                TimerSpec::none().as_ref(),
+                std::ptr::null_mut(),
+            )
+        })
+        .map(drop)
+    }
+    pub fn wait(&self) -> Result<()> {
+        loop {
+            if let Err(e) = read(self.fd, &mut [0u8; 8]) {
+                match e {
+                    Errno::EINTR => continue,
+                    _ => return Err(e),
+                }
+            } else {
+                break;
+            }
+        }
+        Ok(())
+    }
+}
+impl Drop for TimerFd {
+    fn drop(&mut self) {
+        if !std::thread::panicking() {
+            let result = Errno::result(unsafe {
+                libc::close(self.fd)
+            });
+            if let Err(Errno::EBADF) = result {
+                panic!("close of TimerFd encountered EBADF");
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/src/sys/uio.rs
@@ -0,0 +1,122 @@
+#![allow(improper_ctypes)]
+use crate::Result;
+use crate::errno::Errno;
+use libc::{self, c_int, c_void, size_t, off_t};
+use std::marker::PhantomData;
+use std::os::unix::io::RawFd;
+pub fn writev(fd: RawFd, iov: &[IoVec<&[u8]>]) -> Result<usize> {
+    let res = unsafe { libc::writev(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
+    Errno::result(res).map(|r| r as usize)
+}
+pub fn readv(fd: RawFd, iov: &mut [IoVec<&mut [u8]>]) -> Result<usize> {
+    let res = unsafe { libc::readv(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int) };
+    Errno::result(res).map(|r| r as usize)
+}
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "linux",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+pub fn pwritev(fd: RawFd, iov: &[IoVec<&[u8]>],
+               offset: off_t) -> Result<usize> {
+    let res = unsafe {
+        libc::pwritev(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int, offset)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+#[cfg(any(target_os = "dragonfly",
+          target_os = "freebsd",
+          target_os = "linux",
+          target_os = "netbsd",
+          target_os = "openbsd"))]
+pub fn preadv(fd: RawFd, iov: &[IoVec<&mut [u8]>],
+              offset: off_t) -> Result<usize> {
+    let res = unsafe {
+        libc::preadv(fd, iov.as_ptr() as *const libc::iovec, iov.len() as c_int, offset)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+pub fn pwrite(fd: RawFd, buf: &[u8], offset: off_t) -> Result<usize> {
+    let res = unsafe {
+        libc::pwrite(fd, buf.as_ptr() as *const c_void, buf.len() as size_t,
+                    offset)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+pub fn pread(fd: RawFd, buf: &mut [u8], offset: off_t) -> Result<usize>{
+    let res = unsafe {
+        libc::pread(fd, buf.as_mut_ptr() as *mut c_void, buf.len() as size_t,
+                   offset)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+#[cfg(target_os = "linux")]
+#[repr(C)]
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct RemoteIoVec {
+    pub base: usize,
+    pub len: usize,
+}
+#[cfg(target_os = "linux")]
+pub fn process_vm_writev(
+    pid: crate::unistd::Pid,
+    local_iov: &[IoVec<&[u8]>],
+    remote_iov: &[RemoteIoVec]) -> Result<usize>
+{
+    let res = unsafe {
+        libc::process_vm_writev(pid.into(),
+                                local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
+                                remote_iov.as_ptr() as *const libc::iovec, remote_iov.len() as libc::c_ulong, 0)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+#[cfg(any(target_os = "linux"))]
+pub fn process_vm_readv(
+    pid: crate::unistd::Pid,
+    local_iov: &[IoVec<&mut [u8]>],
+    remote_iov: &[RemoteIoVec]) -> Result<usize>
+{
+    let res = unsafe {
+        libc::process_vm_readv(pid.into(),
+                               local_iov.as_ptr() as *const libc::iovec, local_iov.len() as libc::c_ulong,
+                               remote_iov.as_ptr() as *const libc::iovec, remote_iov.len() as libc::c_ulong, 0)
+    };
+    Errno::result(res).map(|r| r as usize)
+}
+#[repr(transparent)]
+#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
+pub struct IoVec<T>(pub(crate) libc::iovec, PhantomData<T>);
+impl<T> IoVec<T> {
+    #[inline]
+    pub fn as_slice(&self) -> &[u8] {
+        use std::slice;
+        unsafe {
+            slice::from_raw_parts(
+                self.0.iov_base as *const u8,
+                self.0.iov_len as usize)
+        }
+    }
+}
+impl<'a> IoVec<&'a [u8]> {
+    #[cfg(target_os = "freebsd")]
+    pub(crate) fn from_raw_parts(base: *mut c_void, len: usize) -> Self {
+        IoVec(libc::iovec {
+            iov_base: base,
+            iov_len: len
+        }, PhantomData)
+    }
+    pub fn from_slice(buf: &'a [u8]) -> IoVec<&'a [u8]> {
+        IoVec(libc::iovec {
+            iov_base: buf.as_ptr() as *mut c_void,
+            iov_len: buf.len() as size_t,
+        }, PhantomData)
+    }
+}
+impl<'a> IoVec<&'a mut [u8]> {
+    pub fn from_mut_slice(buf: &'a mut [u8]) -> IoVec<&'a mut [u8]> {
+        IoVec(libc::iovec {
+            iov_base: buf.as_ptr() as *mut c_void,
+            iov_len: buf.len() as size_t,
+        }, PhantomData)
+    }
+}

--- a//dev/null
+++ b/src/time.rs
@@ -0,0 +1,227 @@
+use crate::sys::time::TimeSpec;
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+use crate::{unistd::Pid, Error};
+use crate::{Errno, Result};
+use libc::{self, clockid_t};
+use std::mem::MaybeUninit;
+#[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
+pub struct ClockId(clockid_t);
+impl ClockId {
+    pub fn from_raw(clk_id: clockid_t) -> Self {
+        ClockId(clk_id)
+    }
+    #[cfg(any(
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        target_os = "linux",
+        target_os = "android",
+        target_os = "emscripten",
+    ))]
+    pub fn pid_cpu_clock_id(pid: Pid) -> Result<Self> {
+        clock_getcpuclockid(pid)
+    }
+    #[cfg(not(target_os = "redox"))]
+    pub fn res(self) -> Result<TimeSpec> {
+        clock_getres(self)
+    }
+    pub fn now(self) -> Result<TimeSpec> {
+        clock_gettime(self)
+    }
+    #[cfg(not(any(
+        target_os = "macos",
+        target_os = "ios",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlibc")),
+            any(target_os = "redox", target_os = "hermit",),
+        ),
+    )))]
+    pub fn set_time(self, timespec: TimeSpec) -> Result<()> {
+        clock_settime(self, timespec)
+    }
+    pub fn as_raw(self) -> clockid_t {
+        self.0
+    }
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten"),
+        )
+    ))]
+    pub const CLOCK_BOOTTIME: ClockId = ClockId(libc::CLOCK_BOOTTIME);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_BOOTTIME_ALARM: ClockId = ClockId(libc::CLOCK_BOOTTIME_ALARM);
+    pub const CLOCK_MONOTONIC: ClockId = ClockId(libc::CLOCK_MONOTONIC);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_MONOTONIC_COARSE: ClockId = ClockId(libc::CLOCK_MONOTONIC_COARSE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_MONOTONIC_FAST: ClockId = ClockId(libc::CLOCK_MONOTONIC_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_MONOTONIC_PRECISE: ClockId = ClockId(libc::CLOCK_MONOTONIC_PRECISE);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_MONOTONIC_RAW: ClockId = ClockId(libc::CLOCK_MONOTONIC_RAW);
+    #[cfg(any(
+        target_os = "fuchsia",
+        target_env = "uclibc",
+        target_os = "macos",
+        target_os = "ios",
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        all(
+            not(target_env = "newlib"),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_PROCESS_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_PROCESS_CPUTIME_ID);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_PROF: ClockId = ClockId(libc::CLOCK_PROF);
+    pub const CLOCK_REALTIME: ClockId = ClockId(libc::CLOCK_REALTIME);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_REALTIME_ALARM: ClockId = ClockId(libc::CLOCK_REALTIME_ALARM);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten")
+        )
+    ))]
+    pub const CLOCK_REALTIME_COARSE: ClockId = ClockId(libc::CLOCK_REALTIME_COARSE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_REALTIME_FAST: ClockId = ClockId(libc::CLOCK_REALTIME_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_REALTIME_PRECISE: ClockId = ClockId(libc::CLOCK_REALTIME_PRECISE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_SECOND: ClockId = ClockId(libc::CLOCK_SECOND);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(
+                target_os = "emscripten",
+                all(target_os = "linux", target_env = "musl")
+            )
+        )
+    ))]
+    pub const CLOCK_SGI_CYCLE: ClockId = ClockId(libc::CLOCK_SGI_CYCLE);
+    #[cfg(any(
+        target_os = "fuchsia",
+        all(
+            not(any(target_env = "uclibc", target_env = "newlib")),
+            any(
+                target_os = "emscripten",
+                all(target_os = "linux", target_env = "musl")
+            )
+        )
+    ))]
+    pub const CLOCK_TAI: ClockId = ClockId(libc::CLOCK_TAI);
+    #[cfg(any(
+        target_env = "uclibc",
+        target_os = "fuchsia",
+        target_os = "ios",
+        target_os = "macos",
+        target_os = "freebsd",
+        target_os = "dragonfly",
+        all(
+            not(target_env = "newlib"),
+            any(target_os = "linux", target_os = "android", target_os = "emscripten",),
+        ),
+    ))]
+    pub const CLOCK_THREAD_CPUTIME_ID: ClockId = ClockId(libc::CLOCK_THREAD_CPUTIME_ID);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME: ClockId = ClockId(libc::CLOCK_UPTIME);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME_FAST: ClockId = ClockId(libc::CLOCK_UPTIME_FAST);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_UPTIME_PRECISE: ClockId = ClockId(libc::CLOCK_UPTIME_PRECISE);
+    #[cfg(any(target_os = "freebsd", target_os = "dragonfly"))]
+    pub const CLOCK_VIRTUAL: ClockId = ClockId(libc::CLOCK_VIRTUAL);
+}
+impl From<ClockId> for clockid_t {
+    fn from(clock_id: ClockId) -> Self {
+        clock_id.as_raw()
+    }
+}
+impl From<clockid_t> for ClockId {
+    fn from(clk_id: clockid_t) -> Self {
+        ClockId::from_raw(clk_id)
+    }
+}
+impl std::fmt::Display for ClockId {
+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
+        std::fmt::Display::fmt(&self.0, f)
+    }
+}
+#[cfg(not(target_os = "redox"))]
+pub fn clock_getres(clock_id: ClockId) -> Result<TimeSpec> {
+    let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_getres(clock_id.as_raw(), c_time.as_mut_ptr()) };
+    Errno::result(ret)?;
+    let res = unsafe { c_time.assume_init() };
+    Ok(TimeSpec::from(res))
+}
+pub fn clock_gettime(clock_id: ClockId) -> Result<TimeSpec> {
+    let mut c_time: MaybeUninit<libc::timespec> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_gettime(clock_id.as_raw(), c_time.as_mut_ptr()) };
+    Errno::result(ret)?;
+    let res = unsafe { c_time.assume_init() };
+    Ok(TimeSpec::from(res))
+}
+#[cfg(not(any(
+    target_os = "macos",
+    target_os = "ios",
+    all(
+        not(any(target_env = "uclibc", target_env = "newlibc")),
+        any(target_os = "redox", target_os = "hermit",),
+    ),
+)))]
+pub fn clock_settime(clock_id: ClockId, timespec: TimeSpec) -> Result<()> {
+    let ret = unsafe { libc::clock_settime(clock_id.as_raw(), timespec.as_ref()) };
+    Errno::result(ret).map(drop)
+}
+#[cfg(any(
+    target_os = "freebsd",
+    target_os = "dragonfly",
+    target_os = "linux",
+    target_os = "android",
+    target_os = "emscripten",
+))]
+pub fn clock_getcpuclockid(pid: Pid) -> Result<ClockId> {
+    let mut clk_id: MaybeUninit<libc::clockid_t> = MaybeUninit::uninit();
+    let ret = unsafe { libc::clock_getcpuclockid(pid.into(), clk_id.as_mut_ptr()) };
+    if ret == 0 {
+        let res = unsafe { clk_id.assume_init() };
+        Ok(ClockId::from(res))
+    } else {
+        Err(Error::from(Errno::from_i32(ret)))
+    }
+}

--- a/src/unistd.rs
+++ b/src/unistd.rs
@@ -732,31 +732,31 @@
 #[cfg(not(any(target_os = "illumos",
               target_os = "ios",
               target_os = "macos",
               target_os = "redox")))]
 pub fn getgrouplist(user: &CStr, group: Gid) -> Result<Vec<Gid>> {
     let ngroups_max = match sysconf(SysconfVar::NGROUPS_MAX) {
         Ok(Some(n)) => n as c_int,
         Ok(None) | Err(_) => <c_int>::max_value(),
     };
     use std::cmp::min;
-    let mut groups = Vec::<Gid>::with_capacity(min(ngroups_max, 8) as usize);
+    let mut ngroups = min(ngroups_max, 8);
+    let mut groups = Vec::<Gid>::with_capacity(ngroups as usize);
     cfg_if! {
         if #[cfg(any(target_os = "ios", target_os = "macos"))] {
             type getgrouplist_group_t = c_int;
         } else {
             type getgrouplist_group_t = gid_t;
         }
     }
     let gid: gid_t = group.into();
     loop {
-        let mut ngroups = groups.capacity() as i32;
         let ret = unsafe {
             libc::getgrouplist(user.as_ptr(),
                                gid as getgrouplist_group_t,
                                groups.as_mut_ptr() as *mut getgrouplist_group_t,
                                &mut ngroups)
         };
         if ret >= 0 {
             unsafe { groups.set_len(ngroups as usize) };
             return Ok(groups);
         } else if ret == -1 {
