# ====================================================================
# FILE: benches/bench.rs
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-234 ---
     1| #![feature(test)]
     2| #[macro_use]
     3| extern crate smallvec;
     4| extern crate test;
     5| use self::test::Bencher;
     6| use smallvec::{ExtendFromSlice, SmallVec};
     7| const VEC_SIZE: usize = 16;
     8| const SPILLED_SIZE: usize = 100;
     9| trait Vector<T>: for<'a> From<&'a [T]> + Extend<T> + ExtendFromSlice<T> {
    10|     fn new() -> Self;
    11|     fn push(&mut self, val: T);
    12|     fn pop(&mut self) -> Option<T>;
    13|     fn remove(&mut self, p: usize) -> T;
    14|     fn insert(&mut self, n: usize, val: T);
    15|     fn from_elem(val: T, n: usize) -> Self;
    16| }
    17| impl<T: Copy> Vector<T> for Vec<T> {
    18|     fn new() -> Self {
    19|         Self::with_capacity(VEC_SIZE)
    20|     }
    21|     fn push(&mut self, val: T) {
    22|         self.push(val)
    23|     }
    24|     fn pop(&mut self) -> Option<T> {
    25|         self.pop()
    26|     }
    27|     fn remove(&mut self, p: usize) -> T {
    28|         self.remove(p)
    29|     }
    30|     fn insert(&mut self, n: usize, val: T) {
    31|         self.insert(n, val)
    32|     }
    33|     fn from_elem(val: T, n: usize) -> Self {
    34|         vec![val; n]
    35|     }
    36| }
    37| impl<T: Copy> Vector<T> for SmallVec<[T; VEC_SIZE]> {
    38|     fn new() -> Self {
    39|         Self::new()
    40|     }
    41|     fn push(&mut self, val: T) {
    42|         self.push(val)
    43|     }
    44|     fn pop(&mut self) -> Option<T> {
    45|         self.pop()
    46|     }
    47|     fn remove(&mut self, p: usize) -> T {
    48|         self.remove(p)
    49|     }
    50|     fn insert(&mut self, n: usize, val: T) {
    51|         self.insert(n, val)
    52|     }
    53|     fn from_elem(val: T, n: usize) -> Self {
    54|         smallvec![val; n]
    55|     }
    56| }
    57| macro_rules! make_benches {
    58|     ($typ:ty { $($b_name:ident => $g_name:ident($($args:expr),*),)* }) => {
    59|         $(
    60|             #[bench]
    61|             fn $b_name(b: &mut Bencher) {
    62|                 $g_name::<$typ>($($args,)* b)
    63|             }
    64|         )*
    65|     }
    66| }
    67| make_benches! {
    68|     SmallVec<[u64; VEC_SIZE]> {
    69|         bench_push => gen_push(SPILLED_SIZE as _),
    70|         bench_push_small => gen_push(VEC_SIZE as _),
    71|         bench_insert => gen_insert(SPILLED_SIZE as _),
    72|         bench_insert_small => gen_insert(VEC_SIZE as _),
    73|         bench_remove => gen_remove(SPILLED_SIZE as _),
    74|         bench_remove_small => gen_remove(VEC_SIZE as _),
    75|         bench_extend => gen_extend(SPILLED_SIZE as _),
    76|         bench_extend_small => gen_extend(VEC_SIZE as _),
    77|         bench_from_slice => gen_from_slice(SPILLED_SIZE as _),
    78|         bench_from_slice_small => gen_from_slice(VEC_SIZE as _),
    79|         bench_extend_from_slice => gen_extend_from_slice(SPILLED_SIZE as _),
    80|         bench_extend_from_slice_small => gen_extend_from_slice(VEC_SIZE as _),
    81|         bench_macro_from_elem => gen_from_elem(SPILLED_SIZE as _),
    82|         bench_macro_from_elem_small => gen_from_elem(VEC_SIZE as _),
    83|         bench_pushpop => gen_pushpop(),
    84|     }
    85| }
    86| make_benches! {
    87|     Vec<u64> {
    88|         bench_push_vec => gen_push(SPILLED_SIZE as _),
    89|         bench_push_vec_small => gen_push(VEC_SIZE as _),
    90|         bench_insert_vec => gen_insert(SPILLED_SIZE as _),
    91|         bench_insert_vec_small => gen_insert(VEC_SIZE as _),
    92|         bench_remove_vec => gen_remove(SPILLED_SIZE as _),
    93|         bench_remove_vec_small => gen_remove(VEC_SIZE as _),
    94|         bench_extend_vec => gen_extend(SPILLED_SIZE as _),
    95|         bench_extend_vec_small => gen_extend(VEC_SIZE as _),
    96|         bench_from_slice_vec => gen_from_slice(SPILLED_SIZE as _),
    97|         bench_from_slice_vec_small => gen_from_slice(VEC_SIZE as _),
    98|         bench_extend_from_slice_vec => gen_extend_from_slice(SPILLED_SIZE as _),
    99|         bench_extend_from_slice_vec_small => gen_extend_from_slice(VEC_SIZE as _),
   100|         bench_macro_from_elem_vec => gen_from_elem(SPILLED_SIZE as _),
   101|         bench_macro_from_elem_vec_small => gen_from_elem(VEC_SIZE as _),
   102|         bench_pushpop_vec => gen_pushpop(),
   103|     }
   104| }
   105| fn gen_push<V: Vector<u64>>(n: u64, b: &mut Bencher) {
   106|     #[inline(never)]
   107|     fn push_noinline<V: Vector<u64>>(vec: &mut V, x: u64) {
   108|         vec.push(x);
   109|     }
   110|     b.iter(|| {
   111|         let mut vec = V::new();
   112|         for x in 0..n {
   113|             push_noinline(&mut vec, x);
   114|         }
   115|         vec
   116|     });
   117| }
   118| fn gen_insert<V: Vector<u64>>(n: u64, b: &mut Bencher) {
   119|     #[inline(never)]
   120|     fn insert_noinline<V: Vector<u64>>(vec: &mut V, p: usize, x: u64) {
   121|         vec.insert(p, x)
   122|     }
   123|     b.iter(|| {
   124|         let mut vec = V::new();
   125|         vec.push(0);
   126|         for x in 0..n {
   127|             insert_noinline(&mut vec, x as _, x);
   128|         }
   129|         vec
   130|     });
   131| }
   132| fn gen_remove<V: Vector<u64>>(n: usize, b: &mut Bencher) {
   133|     #[inline(never)]
   134|     fn remove_noinline<V: Vector<u64>>(vec: &mut V, p: usize) -> u64 {
   135|         vec.remove(p)
   136|     }
   137|     b.iter(|| {
   138|         let mut vec = V::from_elem(0, n as _);
   139|         for x in (0..n - 1).rev() {
   140|             remove_noinline(&mut vec, x);
   141|         }
   142|     });
   143| }
   144| fn gen_extend<V: Vector<u64>>(n: u64, b: &mut Bencher) {
   145|     b.iter(|| {
   146|         let mut vec = V::new();
   147|         vec.extend(0..n);
   148|         vec
   149|     });
   150| }
   151| fn gen_from_slice<V: Vector<u64>>(n: u64, b: &mut Bencher) {
   152|     let v: Vec<u64> = (0..n).collect();
   153|     b.iter(|| {
   154|         let vec = V::from(&v);
   155|         vec
   156|     });
   157| }
   158| fn gen_extend_from_slice<V: Vector<u64>>(n: u64, b: &mut Bencher) {
   159|     let v: Vec<u64> = (0..n).collect();
   160|     b.iter(|| {
   161|         let mut vec = V::new();
   162|         vec.extend_from_slice(&v);
   163|         vec
   164|     });
   165| }
   166| fn gen_pushpop<V: Vector<u64>>(b: &mut Bencher) {
   167|     #[inline(never)]
   168|     fn pushpop_noinline<V: Vector<u64>>(vec: &mut V, x: u64) -> Option<u64> {
   169|         vec.push(x);
   170|         vec.pop()
   171|     }
   172|     b.iter(|| {
   173|         let mut vec = V::new();
   174|         for x in 0..SPILLED_SIZE as _ {
   175|             pushpop_noinline(&mut vec, x);
   176|         }
   177|         vec
   178|     });
   179| }
   180| fn gen_from_elem<V: Vector<u64>>(n: usize, b: &mut Bencher) {
   181|     b.iter(|| {
   182|         let vec = V::from_elem(42, n);
   183|         vec
   184|     });
   185| }
   186| #[bench]
   187| fn bench_insert_many(b: &mut Bencher) {
   188|     #[inline(never)]
   189|     fn insert_many_noinline<I: IntoIterator<Item = u64>>(
   190|         vec: &mut SmallVec<[u64; VEC_SIZE]>,
   191|         index: usize,
   192|         iterable: I,
   193|     ) {
   194|         vec.insert_many(index, iterable)
   195|     }
   196|     b.iter(|| {
   197|         let mut vec = SmallVec::<[u64; VEC_SIZE]>::new();
   198|         insert_many_noinline(&mut vec, 0, 0..SPILLED_SIZE as _);
   199|         insert_many_noinline(&mut vec, 0, 0..SPILLED_SIZE as _);
   200|         vec
   201|     });
   202| }
   203| #[bench]
   204| fn bench_insert_from_slice(b: &mut Bencher) {
   205|     let v: Vec<u64> = (0..SPILLED_SIZE as _).collect();
   206|     b.iter(|| {
   207|         let mut vec = SmallVec::<[u64; VEC_SIZE]>::new();
   208|         vec.insert_from_slice(0, &v);
   209|         vec.insert_from_slice(0, &v);
   210|         vec
   211|     });
   212| }
   213| #[bench]
   214| fn bench_macro_from_list(b: &mut Bencher) {
   215|     b.iter(|| {
   216|         let vec: SmallVec<[u64; 16]> = smallvec![
   217|             0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 24, 32, 36, 0x40, 0x80,
   218|             0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000, 0x20000, 0x40000,
   219|             0x80000, 0x100000,
   220|         ];
   221|         vec
   222|     });
   223| }
   224| #[bench]
   225| fn bench_macro_from_list_vec(b: &mut Bencher) {
   226|     b.iter(|| {
   227|         let vec: Vec<u64> = vec![
   228|             0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 24, 32, 36, 0x40, 0x80,
   229|             0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000, 0x20000, 0x40000,
   230|             0x80000, 0x100000,
   231|         ];
   232|         vec
   233|     });
   234| }


# ====================================================================
# FILE: lib.rs
# Total hunks: 15
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| #![cfg_attr(not(feature = "std"), no_std)]
     2| #![cfg_attr(not(feature = "std"), feature(alloc))]
     3| #![cfg_attr(feature = "union", feature(untagged_unions))]
     4| #![deny(missing_docs)]
     5| #[cfg(not(feature = "std"))]
     6| #[macro_use]
     7| extern crate alloc;
     8| #[cfg(not(feature = "std"))]
     9| use alloc::vec::Vec;
    10| #[cfg(feature = "serde")]
    11| extern crate serde;
    12| extern crate unreachable;
    13| use unreachable::UncheckedOptionExt;
    14| #[cfg(not(feature = "std"))]
    15| mod std {
    16|     pub use core::*;
    17| }
    18| use std::borrow::{Borrow, BorrowMut};
    19| use std::cmp;
    20| use std::fmt;
    21| use std::hash::{Hash, Hasher};
    22| use std::iter::{IntoIterator, FromIterator, repeat};
    23| use std::mem;
    24| #[cfg(not(feature = "union"))]
    25| use std::mem::ManuallyDrop;
    26| use std::ops;
    27| use std::ptr;
    28| use std::slice;
    29| #[cfg(feature = "std")]
    30| use std::io;
    31| #[cfg(feature = "serde")]
    32| use serde::ser::{Serialize, Serializer, SerializeSeq};
    33| #[cfg(feature = "serde")]
    34| use serde::de::{Deserialize, Deserializer, SeqAccess, Visitor};
    35| #[cfg(feature = "serde")]
    36| use std::marker::PhantomData;
    37| #[macro_export]
    38| macro_rules! smallvec {
    39|     ($elem:expr; $n:expr) => ({
    40|         SmallVec::from_elem($elem, $n)
    41|     });
    42|     ($($x:expr),*$(,)*) => ({
    43|         SmallVec::from_slice(&[$($x),*])
    44|     });
    45| }
    46| #[cfg(not(feature = "union"))]
    47| macro_rules! debug_unreachable {
    48|     () => { debug_unreachable!("entered unreachable code") };
    49|     ($e:expr) => {
    50|         if cfg!(not(debug_assertions)) {
    51|             unreachable::unreachable();
    52|         } else {
    53|             panic!($e);
    54|         }
    55|     }
    56| }
    57| #[deprecated(note = "Use `Extend` and `Deref<[T]>` instead")]
    58| pub trait VecLike<T>:
    59|         ops::Index<usize, Output=T> +
    60|         ops::IndexMut<usize> +
    61|         ops::Index<ops::Range<usize>, Output=[T]> +
    62|         ops::IndexMut<ops::Range<usize>> +
    63|         ops::Index<ops::RangeFrom<usize>, Output=[T]> +
    64|         ops::IndexMut<ops::RangeFrom<usize>> +
    65|         ops::Index<ops::RangeTo<usize>, Output=[T]> +
    66|         ops::IndexMut<ops::RangeTo<usize>> +
    67|         ops::Index<ops::RangeFull, Output=[T]> +
    68|         ops::IndexMut<ops::RangeFull> +
    69|         ops::DerefMut<Target = [T]> +
    70|         Extend<T> {
    71|     fn push(&mut self, value: T);

# --- HUNK 2: Lines 78-207 ---
    78|     }
    79| }
    80| pub trait ExtendFromSlice<T> {
    81|     fn extend_from_slice(&mut self, other: &[T]);
    82| }
    83| impl<T: Clone> ExtendFromSlice<T> for Vec<T> {
    84|     fn extend_from_slice(&mut self, other: &[T]) {
    85|         Vec::extend_from_slice(self, other)
    86|     }
    87| }
    88| unsafe fn deallocate<T>(ptr: *mut T, capacity: usize) {
    89|     let _vec: Vec<T> = Vec::from_raw_parts(ptr, 0, capacity);
    90| }
    91| pub struct Drain<'a, T: 'a> {
    92|     iter: slice::IterMut<'a,T>,
    93| }
    94| impl<'a, T: 'a> Iterator for Drain<'a,T> {
    95|     type Item = T;
    96|     #[inline]
    97|     fn next(&mut self) -> Option<T> {
    98|         match self.iter.next() {
    99|             None => None,
   100|             Some(reference) => {
   101|                 unsafe {
   102|                     Some(ptr::read(reference))
   103|                 }
   104|             }
   105|         }
   106|     }
   107|     #[inline]
   108|     fn size_hint(&self) -> (usize, Option<usize>) {
   109|         self.iter.size_hint()
   110|     }
   111| }
   112| impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {
   113|     #[inline]
   114|     fn next_back(&mut self) -> Option<T> {
   115|         match self.iter.next_back() {
   116|             None => None,
   117|             Some(reference) => {
   118|                 unsafe {
   119|                     Some(ptr::read(reference))
   120|                 }
   121|             }
   122|         }
   123|     }
   124| }
   125| impl<'a, T> ExactSizeIterator for Drain<'a, T> { }
   126| impl<'a, T: 'a> Drop for Drain<'a,T> {
   127|     fn drop(&mut self) {
   128|         for _ in self.by_ref() {}
   129|     }
   130| }
   131| #[cfg(feature = "union")]
   132| #[allow(unions_with_drop_fields)]
   133| union SmallVecData<A: Array> {
   134|     inline: A,
   135|     heap: (*mut A::Item, usize),
   136| }
   137| #[cfg(feature = "union")]
   138| impl<A: Array> SmallVecData<A> {
   139|     #[inline]
   140|     unsafe fn inline(&self) -> &A {
   141|         &self.inline
   142|     }
   143|     #[inline]
   144|     unsafe fn inline_mut(&mut self) -> &mut A {
   145|         &mut self.inline
   146|     }
   147|     #[inline]
   148|     fn from_inline(inline: A) -> SmallVecData<A> {
   149|         SmallVecData { inline }
   150|     }
   151|     #[inline]
   152|     unsafe fn heap(&self) -> (*mut A::Item, usize) {
   153|         self.heap
   154|     }
   155|     #[inline]
   156|     unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {
   157|         &mut self.heap
   158|     }
   159|     #[inline]
   160|     fn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A> {
   161|         SmallVecData { heap: (ptr, len) }
   162|     }
   163| }
   164| #[cfg(not(feature = "union"))]
   165| enum SmallVecData<A: Array> {
   166|     Inline(ManuallyDrop<A>),
   167|     Heap((*mut A::Item, usize)),
   168| }
   169| #[cfg(not(feature = "union"))]
   170| impl<A: Array> SmallVecData<A> {
   171|     #[inline]
   172|     unsafe fn inline(&self) -> &A {
   173|         match *self {
   174|             SmallVecData::Inline(ref a) => a,
   175|             _ => debug_unreachable!(),
   176|         }
   177|     }
   178|     #[inline]
   179|     unsafe fn inline_mut(&mut self) -> &mut A {
   180|         match *self {
   181|             SmallVecData::Inline(ref mut a) => a,
   182|             _ => debug_unreachable!(),
   183|         }
   184|     }
   185|     #[inline]
   186|     fn from_inline(inline: A) -> SmallVecData<A> {
   187|         SmallVecData::Inline(ManuallyDrop::new(inline))
   188|     }
   189|     #[inline]
   190|     unsafe fn heap(&self) -> (*mut A::Item, usize) {
   191|         match *self {
   192|             SmallVecData::Heap(data) => data,
   193|             _ => debug_unreachable!(),
   194|         }
   195|     }
   196|     #[inline]
   197|     unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {
   198|         match *self {
   199|             SmallVecData::Heap(ref mut data) => data,
   200|             _ => debug_unreachable!(),
   201|         }
   202|     }
   203|     #[inline]
   204|     fn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A> {
   205|         SmallVecData::Heap((ptr, len))
   206|     }
   207| }

# --- HUNK 3: Lines 239-278 ---
   239|                     capacity: len,
   240|                     data,
   241|                 }
   242|             }
   243|         } else {
   244|             let (ptr, cap, len) = (vec.as_mut_ptr(), vec.capacity(), vec.len());
   245|             mem::forget(vec);
   246|             SmallVec {
   247|                 capacity: cap,
   248|                 data: SmallVecData::from_heap(ptr, len),
   249|             }
   250|         }
   251|     }
   252|     #[inline]
   253|     pub fn from_buf(buf: A) -> SmallVec<A> {
   254|         SmallVec {
   255|             capacity: A::size(),
   256|             data: SmallVecData::from_inline(buf),
   257|         }
   258|     }
   259|     pub unsafe fn set_len(&mut self, new_len: usize) {
   260|         let (_, len_ptr, _) = self.triple_mut();
   261|         *len_ptr = new_len;
   262|     }
   263|     #[inline]
   264|     pub fn inline_size(&self) -> usize {
   265|         A::size()
   266|     }
   267|     #[inline]
   268|     pub fn len(&self) -> usize {
   269|         self.triple().1
   270|     }
   271|     #[inline]
   272|     pub fn is_empty(&self) -> bool {
   273|         self.len() == 0
   274|     }
   275|     #[inline]
   276|     pub fn capacity(&self) -> usize {
   277|         self.triple().2
   278|     }

# --- HUNK 4: Lines 301-384 ---
   301|     #[inline]
   302|     pub fn spilled(&self) -> bool {
   303|         self.capacity > A::size()
   304|     }
   305|     pub fn drain(&mut self) -> Drain<A::Item> {
   306|         unsafe {
   307|             let ptr = self.as_mut_ptr();
   308|             let current_len = self.len();
   309|             self.set_len(0);
   310|             let slice = slice::from_raw_parts_mut(ptr, current_len);
   311|             Drain {
   312|                 iter: slice.iter_mut(),
   313|             }
   314|         }
   315|     }
   316|     #[inline]
   317|     pub fn push(&mut self, value: A::Item) {
   318|         unsafe {
   319|             let (_, &mut len, cap) = self.triple_mut();
   320|             if len == cap {
   321|                 self.grow(cmp::max(cap * 2, 1))
   322|             }
   323|             let (ptr, len_ptr, _) = self.triple_mut();
   324|             *len_ptr = len + 1;
   325|             ptr::write(ptr.offset(len as isize), value);
   326|         }
   327|     }
   328|     #[inline]
   329|     pub fn pop(&mut self) -> Option<A::Item> {
   330|         unsafe {
   331|             let (ptr, len_ptr, _) = self.triple_mut();
   332|             if *len_ptr == 0 {
   333|                 return None;
   334|             }
   335|             let last_index = *len_ptr - 1;
   336|             *len_ptr = last_index;
   337|             Some(ptr::read(ptr.offset(last_index as isize)))
   338|         }
   339|     }
   340|     pub fn grow(&mut self, new_cap: usize) {
   341|         unsafe {
   342|             let (ptr, &mut len, cap) = self.triple_mut();
   343|             let spilled = self.spilled();
   344|             assert!(new_cap >= len);
   345|             if new_cap <= self.inline_size() {
   346|                 if !spilled {
   347|                     return;
   348|                 }
   349|                 self.data = SmallVecData::from_inline(mem::uninitialized());
   350|                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
   351|                 deallocate(ptr, cap);
   352|             } else if new_cap != cap {
   353|                 let mut vec = Vec::with_capacity(new_cap);
   354|                 let new_alloc = vec.as_mut_ptr();
   355|                 mem::forget(vec);
   356|                 ptr::copy_nonoverlapping(ptr, new_alloc, len);
   357|                 self.data = SmallVecData::from_heap(new_alloc, len);
   358|                 self.capacity = new_cap;
   359|                 if spilled {
   360|                     deallocate(ptr, cap);
   361|                 }
   362|             }
   363|         }
   364|     }
   365|     pub fn reserve(&mut self, additional: usize) {
   366|         let (_, &mut len, cap) = self.triple_mut();
   367|         if cap - len < additional {
   368|             let new_cap = len.checked_add(additional).
   369|                 and_then(usize::checked_next_power_of_two).
   370|                 unwrap_or(usize::max_value());
   371|             self.grow(new_cap);
   372|         }
   373|     }
   374|     pub fn reserve_exact(&mut self, additional: usize) {
   375|         let (_, &mut len, cap) = self.triple_mut();
   376|         if cap - len < additional {
   377|             match len.checked_add(additional) {
   378|                 Some(cap) => self.grow(cap),
   379|                 None => panic!("reserve_exact overflow"),
   380|             }
   381|         }
   382|     }
   383|     pub fn shrink_to_fit(&mut self) {
   384|         if !self.spilled() {

# --- HUNK 5: Lines 400-440 ---
   400|     pub fn truncate(&mut self, len: usize) {
   401|         unsafe {
   402|             let (ptr, len_ptr, _) = self.triple_mut();
   403|             while len < *len_ptr {
   404|                 let last_index = *len_ptr - 1;
   405|                 *len_ptr = last_index;
   406|                 ptr::drop_in_place(ptr.offset(last_index as isize));
   407|             }
   408|         }
   409|     }
   410|     pub fn as_slice(&self) -> &[A::Item] {
   411|         self
   412|     }
   413|     pub fn as_mut_slice(&mut self) -> &mut [A::Item] {
   414|         self
   415|     }
   416|     #[inline]
   417|     pub fn swap_remove(&mut self, index: usize) -> A::Item {
   418|         let len = self.len();
   419|         self.swap(len - 1, index);
   420|         unsafe { self.pop().unchecked_unwrap() }
   421|     }
   422|     #[inline]
   423|     pub fn clear(&mut self) {
   424|         self.truncate(0);
   425|     }
   426|     pub fn remove(&mut self, index: usize) -> A::Item {
   427|         unsafe {
   428|             let (mut ptr, len_ptr, _) = self.triple_mut();
   429|             let len = *len_ptr;
   430|             assert!(index < len);
   431|             *len_ptr = len - 1;
   432|             ptr = ptr.offset(index as isize);
   433|             let item = ptr::read(ptr);
   434|             ptr::copy(ptr.offset(1), ptr, len - index - 1);
   435|             item
   436|         }
   437|     }
   438|     pub fn insert(&mut self, index: usize, element: A::Item) {
   439|         self.reserve(1);
   440|         unsafe {

# --- HUNK 6: Lines 475-514 ---
   475|                 num_added += 1;
   476|             }
   477|             if num_added < lower_size_bound {
   478|                 ptr::copy(ptr.offset(lower_size_bound as isize), ptr.offset(num_added as isize), old_len - index);
   479|             }
   480|             self.set_len(old_len + num_added);
   481|         }
   482|     }
   483|     pub fn into_vec(self) -> Vec<A::Item> {
   484|         if self.spilled() {
   485|             unsafe {
   486|                 let (ptr, len) = self.data.heap();
   487|                 let v = Vec::from_raw_parts(ptr, len, self.capacity);
   488|                 mem::forget(self);
   489|                 v
   490|             }
   491|         } else {
   492|             self.into_iter().collect()
   493|         }
   494|     }
   495|     pub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F) {
   496|         let mut del = 0;
   497|         let len = self.len();
   498|         for i in 0..len {
   499|             if !f(&mut self[i]) {
   500|                 del += 1;
   501|             } else if del > 0 {
   502|                 self.swap(i - del, i);
   503|             }
   504|         }
   505|         self.truncate(len - del);
   506|     }
   507|     pub fn dedup(&mut self) where A::Item: PartialEq<A::Item> {
   508|         self.dedup_by(|a, b| a == b);
   509|     }
   510|     pub fn dedup_by<F>(&mut self, mut same_bucket: F)
   511|         where F: FnMut(&mut A::Item, &mut A::Item) -> bool
   512|     {
   513|         let len = self.len();
   514|         if len <= 1 {

# --- HUNK 7: Lines 520-565 ---
   520|             for r in 1..len {
   521|                 let p_r = ptr.offset(r as isize);
   522|                 let p_wm1 = ptr.offset((w - 1) as isize);
   523|                 if !same_bucket(&mut *p_r, &mut *p_wm1) {
   524|                     if r != w {
   525|                         let p_w = p_wm1.offset(1);
   526|                         mem::swap(&mut *p_r, &mut *p_w);
   527|                     }
   528|                     w += 1;
   529|                 }
   530|             }
   531|         }
   532|         self.truncate(w);
   533|     }
   534|     pub fn dedup_by_key<F, K>(&mut self, mut key: F)
   535|         where F: FnMut(&mut A::Item) -> K,
   536|               K: PartialEq<K>
   537|     {
   538|         self.dedup_by(|a, b| key(a) == key(b));
   539|     }
   540| }
   541| impl<A: Array> SmallVec<A> where A::Item: Copy {
   542|     pub fn from_slice(slice: &[A::Item]) -> Self {
   543|         let mut vec = Self::new();
   544|         vec.extend_from_slice(slice);
   545|         vec
   546|     }
   547|     pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
   548|         self.reserve(slice.len());
   549|         let len = self.len();
   550|         assert!(index <= len);
   551|         unsafe {
   552|             let slice_ptr = slice.as_ptr();
   553|             let ptr = self.as_mut_ptr().offset(index as isize);
   554|             ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);
   555|             ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
   556|             self.set_len(len + slice.len());
   557|         }
   558|     }
   559|     #[inline]
   560|     pub fn extend_from_slice(&mut self, slice: &[A::Item]) {
   561|         let len = self.len();
   562|         self.insert_from_slice(len, slice);
   563|     }
   564| }
   565| impl<A: Array> SmallVec<A> where A::Item: Clone {

# --- HUNK 8: Lines 671-714 ---
   671| #[cfg(feature = "serde")]
   672| impl<'de, A: Array> Visitor<'de> for SmallVecVisitor<A>
   673| where A::Item: Deserialize<'de>,
   674| {
   675|     type Value = SmallVec<A>;
   676|     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
   677|         formatter.write_str("a sequence")
   678|     }
   679|     fn visit_seq<B>(self, mut seq: B) -> Result<Self::Value, B::Error>
   680|         where
   681|             B: SeqAccess<'de>,
   682|     {
   683|         let len = seq.size_hint().unwrap_or(0);
   684|         let mut values = SmallVec::with_capacity(len);
   685|         while let Some(value) = seq.next_element()? {
   686|             values.push(value);
   687|         }
   688|         Ok(values)
   689|     }
   690| }
   691| impl<'a, A: Array> From<&'a [A::Item]> for SmallVec<A> where A::Item: Clone {
   692|     #[inline]
   693|     fn from(slice: &'a [A::Item]) -> SmallVec<A> {
   694|         slice.into_iter().cloned().collect()
   695|     }
   696| }
   697| impl<A: Array> From<Vec<A::Item>> for SmallVec<A> {
   698|     #[inline]
   699|     fn from(vec: Vec<A::Item>) -> SmallVec<A> {
   700|         SmallVec::from_vec(vec)
   701|     }
   702| }
   703| impl<A: Array> From<A> for SmallVec<A> {
   704|     #[inline]
   705|     fn from(array: A) -> SmallVec<A> {
   706|         SmallVec::from_buf(array)
   707|     }
   708| }
   709| macro_rules! impl_index {
   710|     ($index_type: ty, $output_type: ty) => {
   711|         impl<A: Array> ops::Index<$index_type> for SmallVec<A> {
   712|             type Output = $output_type;
   713|             #[inline]
   714|             fn index(&self, index: $index_type) -> &$output_type {

# --- HUNK 9: Lines 736-804 ---
   736| #[allow(deprecated)]
   737| impl<A: Array> VecLike<A::Item> for SmallVec<A> {
   738|     #[inline]
   739|     fn push(&mut self, value: A::Item) {
   740|         SmallVec::push(self, value);
   741|     }
   742| }
   743| impl<A: Array> FromIterator<A::Item> for SmallVec<A> {
   744|     fn from_iter<I: IntoIterator<Item=A::Item>>(iterable: I) -> SmallVec<A> {
   745|         let mut v = SmallVec::new();
   746|         v.extend(iterable);
   747|         v
   748|     }
   749| }
   750| impl<A: Array> Extend<A::Item> for SmallVec<A> {
   751|     fn extend<I: IntoIterator<Item=A::Item>>(&mut self, iterable: I) {
   752|         let mut iter = iterable.into_iter();
   753|         let (lower_size_bound, _) = iter.size_hint();
   754|         self.reserve(lower_size_bound);
   755|         unsafe {
   756|             let len = self.len();
   757|             let ptr = self.as_mut_ptr().offset(len as isize);
   758|             let mut count = 0;
   759|             while count < lower_size_bound {
   760|                 if let Some(out) = iter.next() {
   761|                     ptr::write(ptr.offset(count as isize), out);
   762|                     count += 1;
   763|                 } else {
   764|                     break;
   765|                 }
   766|             }
   767|             self.set_len(len + count);
   768|         }
   769|         for elem in iter {
   770|             self.push(elem);
   771|         }
   772|     }
   773| }
   774| impl<A: Array> fmt::Debug for SmallVec<A> where A::Item: fmt::Debug {
   775|     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
   776|         write!(f, "{:?}", &**self)
   777|     }
   778| }
   779| impl<A: Array> Default for SmallVec<A> {
   780|     #[inline]
   781|     fn default() -> SmallVec<A> {
   782|         SmallVec::new()
   783|     }
   784| }
   785| impl<A: Array> Drop for SmallVec<A> {
   786|     fn drop(&mut self) {
   787|         unsafe {
   788|             if self.spilled() {
   789|                 let (ptr, len) = self.data.heap();
   790|                 Vec::from_raw_parts(ptr, len, self.capacity);
   791|             } else {
   792|                 ptr::drop_in_place(&mut self[..]);
   793|             }
   794|         }
   795|     }
   796| }
   797| impl<A: Array> Clone for SmallVec<A> where A::Item: Clone {
   798|     fn clone(&self) -> SmallVec<A> {
   799|         let mut new_vector = SmallVec::with_capacity(self.len());
   800|         for element in self.iter() {
   801|             new_vector.push((*element).clone())
   802|         }
   803|         new_vector
   804|     }

# --- HUNK 10: Lines 901-940 ---
   901|     type IntoIter = slice::IterMut<'a, A::Item>;
   902|     type Item = &'a mut A::Item;
   903|     fn into_iter(self) -> Self::IntoIter {
   904|         self.iter_mut()
   905|     }
   906| }
   907| pub unsafe trait Array {
   908|     type Item;
   909|     fn size() -> usize;
   910|     fn ptr(&self) -> *const Self::Item;
   911|     fn ptr_mut(&mut self) -> *mut Self::Item;
   912| }
   913| struct SetLenOnDrop<'a> {
   914|     len: &'a mut usize,
   915|     local_len: usize,
   916| }
   917| impl<'a> SetLenOnDrop<'a> {
   918|     #[inline]
   919|     fn new(len: &'a mut usize) -> Self {
   920|         SetLenOnDrop { local_len: *len, len: len }
   921|     }
   922|     #[inline]
   923|     fn increment_len(&mut self, increment: usize) {
   924|         self.local_len += increment;
   925|     }
   926| }
   927| impl<'a> Drop for SetLenOnDrop<'a> {
   928|     #[inline]
   929|     fn drop(&mut self) {
   930|         *self.len = self.local_len;
   931|     }
   932| }
   933| macro_rules! impl_array(
   934|     ($($size:expr),+) => {
   935|         $(
   936|             unsafe impl<T> Array for [T; $size] {
   937|                 type Item = T;
   938|                 fn size() -> usize { $size }
   939|                 fn ptr(&self) -> *const T { self.as_ptr() }
   940|                 fn ptr_mut(&mut self) -> *mut T { self.as_mut_ptr() }

# --- HUNK 11: Lines 1173-1212 ---
  1173|     #[test]
  1174|     fn test_insert_many_short_hint() {
  1175|         let mut v: SmallVec<[u8; 8]> = SmallVec::new();
  1176|         for x in 0..4 {
  1177|             v.push(x);
  1178|         }
  1179|         assert_eq!(v.len(), 4);
  1180|         v.insert_many(1, MockHintIter{x: [5, 6].iter().cloned(), hint: 5});
  1181|         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);
  1182|     }
  1183|     #[test]
  1184|     fn test_insert_many_long_hint() {
  1185|         let mut v: SmallVec<[u8; 8]> = SmallVec::new();
  1186|         for x in 0..4 {
  1187|             v.push(x);
  1188|         }
  1189|         assert_eq!(v.len(), 4);
  1190|         v.insert_many(1, MockHintIter{x: [5, 6].iter().cloned(), hint: 1});
  1191|         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);
  1192|     }
  1193|     #[test]
  1194|     fn test_insert_many_panic() {
  1195|         struct PanicOnDoubleDrop {
  1196|             dropped: Box<bool>
  1197|         }
  1198|         impl Drop for PanicOnDoubleDrop {
  1199|             fn drop(&mut self) {
  1200|                 assert!(!*self.dropped, "already dropped");
  1201|                 *self.dropped = true;
  1202|             }
  1203|         }
  1204|         struct BadIter;
  1205|         impl Iterator for BadIter {
  1206|             type Item = PanicOnDoubleDrop;
  1207|             fn size_hint(&self) -> (usize, Option<usize>) { (1, None) }
  1208|             fn next(&mut self) -> Option<Self::Item> { panic!() }
  1209|         }
  1210|         let mut vec: SmallVec<[PanicOnDoubleDrop; 0]> = vec![
  1211|             PanicOnDoubleDrop { dropped: Box::new(false) },
  1212|             PanicOnDoubleDrop { dropped: Box::new(false) },

# --- HUNK 12: Lines 1396-1435 ---
  1396|             vec.sort();
  1397|             assert_eq!(&vec[..], [1, 2, 3]);
  1398|         }
  1399|         let mut vec = SmallVec::<[i32; 2]>::from(&[3, 1, 2][..]);
  1400|         test(&mut vec);
  1401|     }
  1402|     #[test]
  1403|     fn shrink_to_fit_unspill() {
  1404|         let mut vec = SmallVec::<[u8; 2]>::from_iter(0..3);
  1405|         vec.pop();
  1406|         assert!(vec.spilled());
  1407|         vec.shrink_to_fit();
  1408|         assert!(!vec.spilled(), "shrink_to_fit will un-spill if possible");
  1409|     }
  1410|     #[test]
  1411|     fn test_into_vec() {
  1412|         let vec = SmallVec::<[u8; 2]>::from_iter(0..2);
  1413|         assert_eq!(vec.into_vec(), vec![0, 1]);
  1414|         let vec = SmallVec::<[u8; 2]>::from_iter(0..3);
  1415|         assert_eq!(vec.into_vec(), vec![0, 1, 2]);
  1416|     }
  1417|     #[test]
  1418|     fn test_from_vec() {
  1419|         let vec = vec![];
  1420|         let small_vec: SmallVec<[u8; 3]> = SmallVec::from_vec(vec);
  1421|         assert_eq!(&*small_vec, &[]);
  1422|         drop(small_vec);
  1423|         let vec = vec![];
  1424|         let small_vec: SmallVec<[u8; 1]> = SmallVec::from_vec(vec);
  1425|         assert_eq!(&*small_vec, &[]);
  1426|         drop(small_vec);
  1427|         let vec = vec![1];
  1428|         let small_vec: SmallVec<[u8; 3]> = SmallVec::from_vec(vec);
  1429|         assert_eq!(&*small_vec, &[1]);
  1430|         drop(small_vec);
  1431|         let vec = vec![1, 2, 3];
  1432|         let small_vec: SmallVec<[u8; 3]> = SmallVec::from_vec(vec);
  1433|         assert_eq!(&*small_vec, &[1, 2, 3]);
  1434|         drop(small_vec);
  1435|         let vec = vec![1, 2, 3, 4, 5];

# --- HUNK 13: Lines 1493-1526 ---
  1493|         assert_eq!(v[..], [1, 0][..]);
  1494|     }
  1495|     #[cfg(feature = "std")]
  1496|     #[test]
  1497|     fn test_write() {
  1498|         use io::Write;
  1499|         let data = [1, 2, 3, 4, 5];
  1500|         let mut small_vec: SmallVec<[u8; 2]> = SmallVec::new();
  1501|         let len = small_vec.write(&data[..]).unwrap();
  1502|         assert_eq!(len, 5);
  1503|         assert_eq!(small_vec.as_ref(), data.as_ref());
  1504|         let mut small_vec: SmallVec<[u8; 2]> = SmallVec::new();
  1505|         small_vec.write_all(&data[..]).unwrap();
  1506|         assert_eq!(small_vec.as_ref(), data.as_ref());
  1507|     }
  1508|     #[cfg(feature = "serde")]
  1509|     extern crate bincode;
  1510|     #[cfg(feature = "serde")]
  1511|     #[test]
  1512|     fn test_serde() {
  1513|         use self::bincode::{serialize, deserialize, Bounded};
  1514|         let mut small_vec: SmallVec<[i32; 2]> = SmallVec::new();
  1515|         small_vec.push(1);
  1516|         let encoded = serialize(&small_vec, Bounded(100)).unwrap();
  1517|         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();
  1518|         assert_eq!(small_vec, decoded);
  1519|         small_vec.push(2);
  1520|         small_vec.push(3);
  1521|         small_vec.push(4);
  1522|         let encoded = serialize(&small_vec, Bounded(100)).unwrap();
  1523|         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();
  1524|         assert_eq!(small_vec, decoded);
  1525|     }
  1526| }

