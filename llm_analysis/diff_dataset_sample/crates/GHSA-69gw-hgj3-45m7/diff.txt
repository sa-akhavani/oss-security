--- a//dev/null
+++ b/benches/bench.rs
@@ -0,0 +1,234 @@
+#![feature(test)]
+#[macro_use]
+extern crate smallvec;
+extern crate test;
+use self::test::Bencher;
+use smallvec::{ExtendFromSlice, SmallVec};
+const VEC_SIZE: usize = 16;
+const SPILLED_SIZE: usize = 100;
+trait Vector<T>: for<'a> From<&'a [T]> + Extend<T> + ExtendFromSlice<T> {
+    fn new() -> Self;
+    fn push(&mut self, val: T);
+    fn pop(&mut self) -> Option<T>;
+    fn remove(&mut self, p: usize) -> T;
+    fn insert(&mut self, n: usize, val: T);
+    fn from_elem(val: T, n: usize) -> Self;
+}
+impl<T: Copy> Vector<T> for Vec<T> {
+    fn new() -> Self {
+        Self::with_capacity(VEC_SIZE)
+    }
+    fn push(&mut self, val: T) {
+        self.push(val)
+    }
+    fn pop(&mut self) -> Option<T> {
+        self.pop()
+    }
+    fn remove(&mut self, p: usize) -> T {
+        self.remove(p)
+    }
+    fn insert(&mut self, n: usize, val: T) {
+        self.insert(n, val)
+    }
+    fn from_elem(val: T, n: usize) -> Self {
+        vec![val; n]
+    }
+}
+impl<T: Copy> Vector<T> for SmallVec<[T; VEC_SIZE]> {
+    fn new() -> Self {
+        Self::new()
+    }
+    fn push(&mut self, val: T) {
+        self.push(val)
+    }
+    fn pop(&mut self) -> Option<T> {
+        self.pop()
+    }
+    fn remove(&mut self, p: usize) -> T {
+        self.remove(p)
+    }
+    fn insert(&mut self, n: usize, val: T) {
+        self.insert(n, val)
+    }
+    fn from_elem(val: T, n: usize) -> Self {
+        smallvec![val; n]
+    }
+}
+macro_rules! make_benches {
+    ($typ:ty { $($b_name:ident => $g_name:ident($($args:expr),*),)* }) => {
+        $(
+            #[bench]
+            fn $b_name(b: &mut Bencher) {
+                $g_name::<$typ>($($args,)* b)
+            }
+        )*
+    }
+}
+make_benches! {
+    SmallVec<[u64; VEC_SIZE]> {
+        bench_push => gen_push(SPILLED_SIZE as _),
+        bench_push_small => gen_push(VEC_SIZE as _),
+        bench_insert => gen_insert(SPILLED_SIZE as _),
+        bench_insert_small => gen_insert(VEC_SIZE as _),
+        bench_remove => gen_remove(SPILLED_SIZE as _),
+        bench_remove_small => gen_remove(VEC_SIZE as _),
+        bench_extend => gen_extend(SPILLED_SIZE as _),
+        bench_extend_small => gen_extend(VEC_SIZE as _),
+        bench_from_slice => gen_from_slice(SPILLED_SIZE as _),
+        bench_from_slice_small => gen_from_slice(VEC_SIZE as _),
+        bench_extend_from_slice => gen_extend_from_slice(SPILLED_SIZE as _),
+        bench_extend_from_slice_small => gen_extend_from_slice(VEC_SIZE as _),
+        bench_macro_from_elem => gen_from_elem(SPILLED_SIZE as _),
+        bench_macro_from_elem_small => gen_from_elem(VEC_SIZE as _),
+        bench_pushpop => gen_pushpop(),
+    }
+}
+make_benches! {
+    Vec<u64> {
+        bench_push_vec => gen_push(SPILLED_SIZE as _),
+        bench_push_vec_small => gen_push(VEC_SIZE as _),
+        bench_insert_vec => gen_insert(SPILLED_SIZE as _),
+        bench_insert_vec_small => gen_insert(VEC_SIZE as _),
+        bench_remove_vec => gen_remove(SPILLED_SIZE as _),
+        bench_remove_vec_small => gen_remove(VEC_SIZE as _),
+        bench_extend_vec => gen_extend(SPILLED_SIZE as _),
+        bench_extend_vec_small => gen_extend(VEC_SIZE as _),
+        bench_from_slice_vec => gen_from_slice(SPILLED_SIZE as _),
+        bench_from_slice_vec_small => gen_from_slice(VEC_SIZE as _),
+        bench_extend_from_slice_vec => gen_extend_from_slice(SPILLED_SIZE as _),
+        bench_extend_from_slice_vec_small => gen_extend_from_slice(VEC_SIZE as _),
+        bench_macro_from_elem_vec => gen_from_elem(SPILLED_SIZE as _),
+        bench_macro_from_elem_vec_small => gen_from_elem(VEC_SIZE as _),
+        bench_pushpop_vec => gen_pushpop(),
+    }
+}
+fn gen_push<V: Vector<u64>>(n: u64, b: &mut Bencher) {
+    #[inline(never)]
+    fn push_noinline<V: Vector<u64>>(vec: &mut V, x: u64) {
+        vec.push(x);
+    }
+    b.iter(|| {
+        let mut vec = V::new();
+        for x in 0..n {
+            push_noinline(&mut vec, x);
+        }
+        vec
+    });
+}
+fn gen_insert<V: Vector<u64>>(n: u64, b: &mut Bencher) {
+    #[inline(never)]
+    fn insert_noinline<V: Vector<u64>>(vec: &mut V, p: usize, x: u64) {
+        vec.insert(p, x)
+    }
+    b.iter(|| {
+        let mut vec = V::new();
+        vec.push(0);
+        for x in 0..n {
+            insert_noinline(&mut vec, x as _, x);
+        }
+        vec
+    });
+}
+fn gen_remove<V: Vector<u64>>(n: usize, b: &mut Bencher) {
+    #[inline(never)]
+    fn remove_noinline<V: Vector<u64>>(vec: &mut V, p: usize) -> u64 {
+        vec.remove(p)
+    }
+    b.iter(|| {
+        let mut vec = V::from_elem(0, n as _);
+        for x in (0..n - 1).rev() {
+            remove_noinline(&mut vec, x);
+        }
+    });
+}
+fn gen_extend<V: Vector<u64>>(n: u64, b: &mut Bencher) {
+    b.iter(|| {
+        let mut vec = V::new();
+        vec.extend(0..n);
+        vec
+    });
+}
+fn gen_from_slice<V: Vector<u64>>(n: u64, b: &mut Bencher) {
+    let v: Vec<u64> = (0..n).collect();
+    b.iter(|| {
+        let vec = V::from(&v);
+        vec
+    });
+}
+fn gen_extend_from_slice<V: Vector<u64>>(n: u64, b: &mut Bencher) {
+    let v: Vec<u64> = (0..n).collect();
+    b.iter(|| {
+        let mut vec = V::new();
+        vec.extend_from_slice(&v);
+        vec
+    });
+}
+fn gen_pushpop<V: Vector<u64>>(b: &mut Bencher) {
+    #[inline(never)]
+    fn pushpop_noinline<V: Vector<u64>>(vec: &mut V, x: u64) -> Option<u64> {
+        vec.push(x);
+        vec.pop()
+    }
+    b.iter(|| {
+        let mut vec = V::new();
+        for x in 0..SPILLED_SIZE as _ {
+            pushpop_noinline(&mut vec, x);
+        }
+        vec
+    });
+}
+fn gen_from_elem<V: Vector<u64>>(n: usize, b: &mut Bencher) {
+    b.iter(|| {
+        let vec = V::from_elem(42, n);
+        vec
+    });
+}
+#[bench]
+fn bench_insert_many(b: &mut Bencher) {
+    #[inline(never)]
+    fn insert_many_noinline<I: IntoIterator<Item = u64>>(
+        vec: &mut SmallVec<[u64; VEC_SIZE]>,
+        index: usize,
+        iterable: I,
+    ) {
+        vec.insert_many(index, iterable)
+    }
+    b.iter(|| {
+        let mut vec = SmallVec::<[u64; VEC_SIZE]>::new();
+        insert_many_noinline(&mut vec, 0, 0..SPILLED_SIZE as _);
+        insert_many_noinline(&mut vec, 0, 0..SPILLED_SIZE as _);
+        vec
+    });
+}
+#[bench]
+fn bench_insert_from_slice(b: &mut Bencher) {
+    let v: Vec<u64> = (0..SPILLED_SIZE as _).collect();
+    b.iter(|| {
+        let mut vec = SmallVec::<[u64; VEC_SIZE]>::new();
+        vec.insert_from_slice(0, &v);
+        vec.insert_from_slice(0, &v);
+        vec
+    });
+}
+#[bench]
+fn bench_macro_from_list(b: &mut Bencher) {
+    b.iter(|| {
+        let vec: SmallVec<[u64; 16]> = smallvec![
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 24, 32, 36, 0x40, 0x80,
+            0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000, 0x20000, 0x40000,
+            0x80000, 0x100000,
+        ];
+        vec
+    });
+}
+#[bench]
+fn bench_macro_from_list_vec(b: &mut Bencher) {
+    b.iter(|| {
+        let vec: Vec<u64> = vec![
+            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20, 24, 32, 36, 0x40, 0x80,
+            0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000, 0x10000, 0x20000, 0x40000,
+            0x80000, 0x100000,
+        ];
+        vec
+    });
+}

--- a/lib.rs
+++ b/lib.rs
@@ -1,74 +1,61 @@
 #![cfg_attr(not(feature = "std"), no_std)]
 #![cfg_attr(not(feature = "std"), feature(alloc))]
 #![cfg_attr(feature = "union", feature(untagged_unions))]
-#![cfg_attr(feature = "specialization", feature(specialization))]
-#![cfg_attr(feature = "may_dangle", feature(dropck_eyepatch))]
 #![deny(missing_docs)]
 #[cfg(not(feature = "std"))]
 #[macro_use]
 extern crate alloc;
 #[cfg(not(feature = "std"))]
 use alloc::vec::Vec;
 #[cfg(feature = "serde")]
 extern crate serde;
+extern crate unreachable;
+use unreachable::UncheckedOptionExt;
 #[cfg(not(feature = "std"))]
 mod std {
     pub use core::*;
 }
 use std::borrow::{Borrow, BorrowMut};
 use std::cmp;
 use std::fmt;
 use std::hash::{Hash, Hasher};
 use std::iter::{IntoIterator, FromIterator, repeat};
 use std::mem;
+#[cfg(not(feature = "union"))]
 use std::mem::ManuallyDrop;
 use std::ops;
 use std::ptr;
 use std::slice;
 #[cfg(feature = "std")]
 use std::io;
 #[cfg(feature = "serde")]
 use serde::ser::{Serialize, Serializer, SerializeSeq};
 #[cfg(feature = "serde")]
 use serde::de::{Deserialize, Deserializer, SeqAccess, Visitor};
 #[cfg(feature = "serde")]
 use std::marker::PhantomData;
 #[macro_export]
 macro_rules! smallvec {
-    (@one $x:expr) => (1usize);
     ($elem:expr; $n:expr) => ({
-        $crate::SmallVec::from_elem($elem, $n)
+        SmallVec::from_elem($elem, $n)
     });
     ($($x:expr),*$(,)*) => ({
-        let count = 0usize $(+ smallvec!(@one $x))*;
-        let mut vec = $crate::SmallVec::new();
-        if count <= vec.inline_size() {
-            $(vec.push($x);)*
-            vec
-        } else {
-            $crate::SmallVec::from_vec(vec![$($x,)*])
-        }
+        SmallVec::from_slice(&[$($x),*])
     });
-}
-#[inline]
-pub unsafe fn unreachable() -> ! {
-    enum Void {}
-    let x: &Void = mem::transmute(1usize);
-    match *x {}
 }
 #[cfg(not(feature = "union"))]
 macro_rules! debug_unreachable {
     () => { debug_unreachable!("entered unreachable code") };
     ($e:expr) => {
         if cfg!(not(debug_assertions)) {
-            unreachable();
+            unreachable::unreachable();
         } else {
             panic!($e);
         }
     }
 }
 #[deprecated(note = "Use `Extend` and `Deref<[T]>` instead")]
 pub trait VecLike<T>:
         ops::Index<usize, Output=T> +
         ops::IndexMut<usize> +
         ops::Index<ops::Range<usize>, Output=[T]> +
@@ -101,60 +88,73 @@
 unsafe fn deallocate<T>(ptr: *mut T, capacity: usize) {
     let _vec: Vec<T> = Vec::from_raw_parts(ptr, 0, capacity);
 }
 pub struct Drain<'a, T: 'a> {
     iter: slice::IterMut<'a,T>,
 }
 impl<'a, T: 'a> Iterator for Drain<'a,T> {
     type Item = T;
     #[inline]
     fn next(&mut self) -> Option<T> {
-        self.iter.next().map(|reference| unsafe { ptr::read(reference) })
+        match self.iter.next() {
+            None => None,
+            Some(reference) => {
+                unsafe {
+                    Some(ptr::read(reference))
+                }
+            }
+        }
     }
     #[inline]
     fn size_hint(&self) -> (usize, Option<usize>) {
         self.iter.size_hint()
     }
 }
 impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {
     #[inline]
     fn next_back(&mut self) -> Option<T> {
-        self.iter.next_back().map(|reference| unsafe { ptr::read(reference) })
+        match self.iter.next_back() {
+            None => None,
+            Some(reference) => {
+                unsafe {
+                    Some(ptr::read(reference))
+                }
+            }
+        }
     }
 }
 impl<'a, T> ExactSizeIterator for Drain<'a, T> { }
 impl<'a, T: 'a> Drop for Drain<'a,T> {
     fn drop(&mut self) {
         for _ in self.by_ref() {}
     }
 }
 #[cfg(feature = "union")]
+#[allow(unions_with_drop_fields)]
 union SmallVecData<A: Array> {
-    inline: ManuallyDrop<A>,
+    inline: A,
     heap: (*mut A::Item, usize),
 }
 #[cfg(feature = "union")]
 impl<A: Array> SmallVecData<A> {
     #[inline]
     unsafe fn inline(&self) -> &A {
         &self.inline
     }
     #[inline]
     unsafe fn inline_mut(&mut self) -> &mut A {
         &mut self.inline
     }
     #[inline]
     fn from_inline(inline: A) -> SmallVecData<A> {
-        SmallVecData { inline: ManuallyDrop::new(inline) }
-    }
-    #[inline]
-    unsafe fn into_inline(self) -> A { ManuallyDrop::into_inner(self.inline) }
+        SmallVecData { inline }
+    }
     #[inline]
     unsafe fn heap(&self) -> (*mut A::Item, usize) {
         self.heap
     }
     #[inline]
     unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {
         &mut self.heap
     }
     #[inline]
     fn from_heap(ptr: *mut A::Item, len: usize) -> SmallVecData<A> {
@@ -178,27 +178,20 @@
     #[inline]
     unsafe fn inline_mut(&mut self) -> &mut A {
         match *self {
             SmallVecData::Inline(ref mut a) => a,
             _ => debug_unreachable!(),
         }
     }
     #[inline]
     fn from_inline(inline: A) -> SmallVecData<A> {
         SmallVecData::Inline(ManuallyDrop::new(inline))
-    }
-    #[inline]
-    unsafe fn into_inline(self) -> A {
-        match self {
-            SmallVecData::Inline(a) => ManuallyDrop::into_inner(a),
-            _ => debug_unreachable!(),
-        }
     }
     #[inline]
     unsafe fn heap(&self) -> (*mut A::Item, usize) {
         match *self {
             SmallVecData::Heap(data) => data,
             _ => debug_unreachable!(),
         }
     }
     #[inline]
     unsafe fn heap_mut(&mut self) -> &mut (*mut A::Item, usize) {
@@ -256,32 +249,20 @@
             }
         }
     }
     #[inline]
     pub fn from_buf(buf: A) -> SmallVec<A> {
         SmallVec {
             capacity: A::size(),
             data: SmallVecData::from_inline(buf),
         }
     }
-    #[inline]
-    pub fn from_buf_and_len(buf: A, len: usize) -> SmallVec<A> {
-        assert!(len <= A::size());
-        unsafe { SmallVec::from_buf_and_len_unchecked(buf, len) }
-    }
-    #[inline]
-    pub unsafe fn from_buf_and_len_unchecked(buf: A, len: usize) -> SmallVec<A> {
-        SmallVec {
-            capacity: len,
-            data: SmallVecData::from_inline(buf),
-        }
-    }
     pub unsafe fn set_len(&mut self, new_len: usize) {
         let (_, len_ptr, _) = self.triple_mut();
         *len_ptr = new_len;
     }
     #[inline]
     pub fn inline_size(&self) -> usize {
         A::size()
     }
     #[inline]
     pub fn len(&self) -> usize {
@@ -330,21 +311,21 @@
             Drain {
                 iter: slice.iter_mut(),
             }
         }
     }
     #[inline]
     pub fn push(&mut self, value: A::Item) {
         unsafe {
             let (_, &mut len, cap) = self.triple_mut();
             if len == cap {
-                self.reserve(1);
+                self.grow(cmp::max(cap * 2, 1))
             }
             let (ptr, len_ptr, _) = self.triple_mut();
             *len_ptr = len + 1;
             ptr::write(ptr.offset(len as isize), value);
         }
     }
     #[inline]
     pub fn pop(&mut self) -> Option<A::Item> {
         unsafe {
             let (ptr, len_ptr, _) = self.triple_mut();
@@ -352,46 +333,42 @@
                 return None;
             }
             let last_index = *len_ptr - 1;
             *len_ptr = last_index;
             Some(ptr::read(ptr.offset(last_index as isize)))
         }
     }
     pub fn grow(&mut self, new_cap: usize) {
         unsafe {
             let (ptr, &mut len, cap) = self.triple_mut();
-            let unspilled = !self.spilled();
+            let spilled = self.spilled();
             assert!(new_cap >= len);
             if new_cap <= self.inline_size() {
-                if unspilled {
+                if !spilled {
                     return;
                 }
                 self.data = SmallVecData::from_inline(mem::uninitialized());
                 ptr::copy_nonoverlapping(ptr, self.data.inline_mut().ptr_mut(), len);
-                self.capacity = len;
+                deallocate(ptr, cap);
             } else if new_cap != cap {
                 let mut vec = Vec::with_capacity(new_cap);
                 let new_alloc = vec.as_mut_ptr();
                 mem::forget(vec);
                 ptr::copy_nonoverlapping(ptr, new_alloc, len);
                 self.data = SmallVecData::from_heap(new_alloc, len);
                 self.capacity = new_cap;
-                if unspilled {
-                    return;
+                if spilled {
+                    deallocate(ptr, cap);
                 }
-            } else {
-                return;
-            }
-            deallocate(ptr, cap);
-        }
-    }
-    #[inline]
+            }
+        }
+    }
     pub fn reserve(&mut self, additional: usize) {
         let (_, &mut len, cap) = self.triple_mut();
         if cap - len < additional {
             let new_cap = len.checked_add(additional).
                 and_then(usize::checked_next_power_of_two).
                 unwrap_or(usize::max_value());
             self.grow(new_cap);
         }
     }
     pub fn reserve_exact(&mut self, additional: usize) {
@@ -433,21 +410,21 @@
     pub fn as_slice(&self) -> &[A::Item] {
         self
     }
     pub fn as_mut_slice(&mut self) -> &mut [A::Item] {
         self
     }
     #[inline]
     pub fn swap_remove(&mut self, index: usize) -> A::Item {
         let len = self.len();
         self.swap(len - 1, index);
-        self.pop().unwrap_or_else(|| unsafe { unreachable() })
+        unsafe { self.pop().unchecked_unwrap() }
     }
     #[inline]
     pub fn clear(&mut self) {
         self.truncate(0);
     }
     pub fn remove(&mut self, index: usize) -> A::Item {
         unsafe {
             let (mut ptr, len_ptr, _) = self.triple_mut();
             let len = *len_ptr;
             assert!(index < len);
@@ -508,31 +485,20 @@
             unsafe {
                 let (ptr, len) = self.data.heap();
                 let v = Vec::from_raw_parts(ptr, len, self.capacity);
                 mem::forget(self);
                 v
             }
         } else {
             self.into_iter().collect()
         }
     }
-    pub fn into_inner(self) -> Result<A, Self> {
-        if self.spilled() || self.len() != A::size() {
-            Err(self)
-        } else {
-            unsafe {
-                let data = ptr::read(&self.data);
-                mem::forget(self);
-                Ok(data.into_inline())
-            }
-        }
-    }
     pub fn retain<F: FnMut(&mut A::Item) -> bool>(&mut self, mut f: F) {
         let mut del = 0;
         let len = self.len();
         for i in 0..len {
             if !f(&mut self[i]) {
                 del += 1;
             } else if del > 0 {
                 self.swap(i - del, i);
             }
         }
@@ -564,53 +530,26 @@
             }
         }
         self.truncate(w);
     }
     pub fn dedup_by_key<F, K>(&mut self, mut key: F)
         where F: FnMut(&mut A::Item) -> K,
               K: PartialEq<K>
     {
         self.dedup_by(|a, b| key(a) == key(b));
     }
-    pub unsafe fn from_raw_parts(
-        ptr: *mut A::Item,
-        length: usize,
-        capacity: usize,
-    ) -> SmallVec<A> {
-        assert!(capacity > A::size());
-        SmallVec {
-            capacity,
-            data: SmallVecData::from_heap(ptr, length),
-        }
-    }
 }
 impl<A: Array> SmallVec<A> where A::Item: Copy {
     pub fn from_slice(slice: &[A::Item]) -> Self {
-        let len = slice.len();
-        if len <= A::size() {
-            SmallVec {
-                capacity: len,
-                data: SmallVecData::from_inline(unsafe {
-                    let mut data: A = mem::uninitialized();
-                    ptr::copy_nonoverlapping(slice.as_ptr(), data.ptr_mut(), len);
-                    data
-                })
-            }
-        } else {
-            let mut b = slice.to_vec();
-            let (ptr, cap) = (b.as_mut_ptr(), b.capacity());
-            mem::forget(b);
-            SmallVec {
-                capacity: cap,
-                data: SmallVecData::from_heap(ptr, len),
-            }
-        }
+        let mut vec = Self::new();
+        vec.extend_from_slice(slice);
+        vec
     }
     pub fn insert_from_slice(&mut self, index: usize, slice: &[A::Item]) {
         self.reserve(slice.len());
         let len = self.len();
         assert!(index <= len);
         unsafe {
             let slice_ptr = slice.as_ptr();
             let ptr = self.as_mut_ptr().offset(index as isize);
             ptr::copy(ptr, ptr.offset(slice.len() as isize), len - index);
             ptr::copy_nonoverlapping(slice_ptr, ptr, slice.len());
@@ -742,48 +681,24 @@
             B: SeqAccess<'de>,
     {
         let len = seq.size_hint().unwrap_or(0);
         let mut values = SmallVec::with_capacity(len);
         while let Some(value) = seq.next_element()? {
             values.push(value);
         }
         Ok(values)
     }
 }
-#[cfg(feature = "specialization")]
-trait SpecFrom<A: Array, S> {
-    fn spec_from(slice: S) -> SmallVec<A>;
-}
-#[cfg(feature = "specialization")]
-impl<'a, A: Array> SpecFrom<A, &'a [A::Item]> for SmallVec<A> where A::Item: Clone {
-    #[inline]
-    default fn spec_from(slice: &'a [A::Item]) -> SmallVec<A> {
-        slice.into_iter().cloned().collect()
-    }
-}
-#[cfg(feature = "specialization")]
-impl<'a, A: Array> SpecFrom<A, &'a [A::Item]> for SmallVec<A> where A::Item: Copy {
-    #[inline]
-    fn spec_from(slice: &'a [A::Item]) -> SmallVec<A> {
-        SmallVec::from_slice(slice)
-    }
-}
 impl<'a, A: Array> From<&'a [A::Item]> for SmallVec<A> where A::Item: Clone {
-    #[cfg(not(feature = "specialization"))]
     #[inline]
     fn from(slice: &'a [A::Item]) -> SmallVec<A> {
         slice.into_iter().cloned().collect()
-    }
-    #[cfg(feature = "specialization")]
-    #[inline]
-    fn from(slice: &'a [A::Item]) -> SmallVec<A> {
-        SmallVec::spec_from(slice)
     }
 }
 impl<A: Array> From<Vec<A::Item>> for SmallVec<A> {
     #[inline]
     fn from(vec: Vec<A::Item>) -> SmallVec<A> {
         SmallVec::from_vec(vec)
     }
 }
 impl<A: Array> From<A> for SmallVec<A> {
     #[inline]
@@ -831,61 +746,49 @@
         v.extend(iterable);
         v
     }
 }
 impl<A: Array> Extend<A::Item> for SmallVec<A> {
     fn extend<I: IntoIterator<Item=A::Item>>(&mut self, iterable: I) {
         let mut iter = iterable.into_iter();
         let (lower_size_bound, _) = iter.size_hint();
         self.reserve(lower_size_bound);
         unsafe {
-            let (ptr, len_ptr, cap) = self.triple_mut();
-            let mut len = SetLenOnDrop::new(len_ptr);
-            while len.get() < cap {
+            let len = self.len();
+            let ptr = self.as_mut_ptr().offset(len as isize);
+            let mut count = 0;
+            while count < lower_size_bound {
                 if let Some(out) = iter.next() {
-                    ptr::write(ptr.offset(len.get() as isize), out);
-                    len.increment_len(1);
+                    ptr::write(ptr.offset(count as isize), out);
+                    count += 1;
                 } else {
-                    return;
+                    break;
                 }
             }
+            self.set_len(len + count);
         }
         for elem in iter {
             self.push(elem);
         }
     }
 }
 impl<A: Array> fmt::Debug for SmallVec<A> where A::Item: fmt::Debug {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
-        f.debug_list().entries(self.iter()).finish()
+        write!(f, "{:?}", &**self)
     }
 }
 impl<A: Array> Default for SmallVec<A> {
     #[inline]
     fn default() -> SmallVec<A> {
         SmallVec::new()
     }
 }
-#[cfg(feature = "may_dangle")]
-unsafe impl<#[may_dangle] A: Array> Drop for SmallVec<A> {
-    fn drop(&mut self) {
-        unsafe {
-            if self.spilled() {
-                let (ptr, len) = self.data.heap();
-                Vec::from_raw_parts(ptr, len, self.capacity);
-            } else {
-                ptr::drop_in_place(&mut self[..]);
-            }
-        }
-    }
-}
-#[cfg(not(feature = "may_dangle"))]
 impl<A: Array> Drop for SmallVec<A> {
     fn drop(&mut self) {
         unsafe {
             if self.spilled() {
                 let (ptr, len) = self.data.heap();
                 Vec::from_raw_parts(ptr, len, self.capacity);
             } else {
                 ptr::drop_in_place(&mut self[..]);
             }
         }
@@ -1008,24 +911,20 @@
     fn ptr_mut(&mut self) -> *mut Self::Item;
 }
 struct SetLenOnDrop<'a> {
     len: &'a mut usize,
     local_len: usize,
 }
 impl<'a> SetLenOnDrop<'a> {
     #[inline]
     fn new(len: &'a mut usize) -> Self {
         SetLenOnDrop { local_len: *len, len: len }
-    }
-    #[inline]
-    fn get(&self) -> usize {
-        self.local_len
     }
     #[inline]
     fn increment_len(&mut self, increment: usize) {
         self.local_len += increment;
     }
 }
 impl<'a> Drop for SetLenOnDrop<'a> {
     #[inline]
     fn drop(&mut self) {
         *self.len = self.local_len;
@@ -1284,21 +1183,20 @@
     #[test]
     fn test_insert_many_long_hint() {
         let mut v: SmallVec<[u8; 8]> = SmallVec::new();
         for x in 0..4 {
             v.push(x);
         }
         assert_eq!(v.len(), 4);
         v.insert_many(1, MockHintIter{x: [5, 6].iter().cloned(), hint: 1});
         assert_eq!(&v.iter().map(|v| *v).collect::<Vec<_>>(), &[0, 5, 6, 1, 2, 3]);
     }
-    #[cfg(feature = "std")]
     #[test]
     fn test_insert_many_panic() {
         struct PanicOnDoubleDrop {
             dropped: Box<bool>
         }
         impl Drop for PanicOnDoubleDrop {
             fn drop(&mut self) {
                 assert!(!*self.dropped, "already dropped");
                 *self.dropped = true;
             }
@@ -1508,29 +1406,20 @@
         assert!(vec.spilled());
         vec.shrink_to_fit();
         assert!(!vec.spilled(), "shrink_to_fit will un-spill if possible");
     }
     #[test]
     fn test_into_vec() {
         let vec = SmallVec::<[u8; 2]>::from_iter(0..2);
         assert_eq!(vec.into_vec(), vec![0, 1]);
         let vec = SmallVec::<[u8; 2]>::from_iter(0..3);
         assert_eq!(vec.into_vec(), vec![0, 1, 2]);
-    }
-    #[test]
-    fn test_into_inner() {
-        let vec = SmallVec::<[u8; 2]>::from_iter(0..2);
-        assert_eq!(vec.into_inner(), Ok([0, 1]));
-        let vec = SmallVec::<[u8; 2]>::from_iter(0..1);
-        assert_eq!(vec.clone().into_inner(), Err(vec));
-        let vec = SmallVec::<[u8; 2]>::from_iter(0..3);
-        assert_eq!(vec.clone().into_inner(), Err(vec));
     }
     #[test]
     fn test_from_vec() {
         let vec = vec![];
         let small_vec: SmallVec<[u8; 3]> = SmallVec::from_vec(vec);
         assert_eq!(&*small_vec, &[]);
         drop(small_vec);
         let vec = vec![];
         let small_vec: SmallVec<[u8; 1]> = SmallVec::from_vec(vec);
         assert_eq!(&*small_vec, &[]);
@@ -1614,61 +1503,24 @@
         assert_eq!(small_vec.as_ref(), data.as_ref());
         let mut small_vec: SmallVec<[u8; 2]> = SmallVec::new();
         small_vec.write_all(&data[..]).unwrap();
         assert_eq!(small_vec.as_ref(), data.as_ref());
     }
     #[cfg(feature = "serde")]
     extern crate bincode;
     #[cfg(feature = "serde")]
     #[test]
     fn test_serde() {
-        use self::bincode::{config, deserialize};
+        use self::bincode::{serialize, deserialize, Bounded};
         let mut small_vec: SmallVec<[i32; 2]> = SmallVec::new();
         small_vec.push(1);
-        let encoded = config().limit(100).serialize(&small_vec).unwrap();
+        let encoded = serialize(&small_vec, Bounded(100)).unwrap();
         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();
         assert_eq!(small_vec, decoded);
         small_vec.push(2);
         small_vec.push(3);
         small_vec.push(4);
-        let encoded = config().limit(100).serialize(&small_vec).unwrap();
+        let encoded = serialize(&small_vec, Bounded(100)).unwrap();
         let decoded: SmallVec<[i32; 2]> = deserialize(&encoded).unwrap();
         assert_eq!(small_vec, decoded);
     }
-    #[test]
-    fn grow_to_shrink() {
-        let mut v: SmallVec<[u8; 2]> = SmallVec::new();
-        v.push(1);
-        v.push(2);
-        v.push(3);
-        assert!(v.spilled());
-        v.clear();
-        v.grow(2);
-        assert!(!v.spilled());
-        assert_eq!(v.capacity(), 2);
-        assert_eq!(v.len(), 0);
-        v.push(4);
-        assert_eq!(v[..], [4]);
-    }
-    #[test]
-    fn resumable_extend() {
-        let s = "a b c";
-        let it = s
-            .chars()
-            .scan(0, |_, ch| if ch.is_whitespace() { None } else { Some(ch) });
-        let mut v: SmallVec<[char; 4]> = SmallVec::new();
-        v.extend(it);
-        assert_eq!(v[..], ['a']);
-    }
-    #[test]
-    fn grow_spilled_same_size() {
-        let mut v: SmallVec<[u8; 2]> = SmallVec::new();
-        v.push(0);
-        v.push(1);
-        v.push(2);
-        assert!(v.spilled());
-        assert_eq!(v.capacity(), 4);
-        v.grow(4);
-        assert_eq!(v.capacity(), 4);
-        assert_eq!(v[..], [0, 1, 2]);
-    }
-}
+}
