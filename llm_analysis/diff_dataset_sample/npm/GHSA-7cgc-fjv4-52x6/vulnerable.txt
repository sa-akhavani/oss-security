# ====================================================================
# FILE: index.js
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| var binary = require('node-pre-gyp')
     2| var path = require('path')
     3| var binPath = binary.find(path.resolve(path.join(__dirname, 'package.json')))
     4| var bin = require(binPath)
     5| var BigNum = bin.BigNum
     6| module.exports = BigNum
     7| BigNum.conditionArgs = function (num, base) {
     8|   if (typeof num !== 'string') num = num.toString(base || 10)
     9|   if (num.match(/e\+/)) { // positive exponent
    10|     if (!Number(num).toString().match(/e+/)) {
    11|       return {
    12|         num: Math.floor(Number(num)).toString(),
    13|         base: 10
    14|       }
    15|     } else {
    16|       var pow = Math.ceil(Math.log(num) / Math.log(2))
    17|       var n = (num / Math.pow(2, pow)).toString(2)
    18|         .replace(/^0/, '')
    19|       var i = n.length - n.indexOf('.')
    20|       n = n.replace(/\./, '')
    21|       for (; i <= pow; i++) n += '0'
    22|       return {
    23|         num: n,
    24|         base: 2
    25|       }
    26|     }
    27|   } else if (num.match(/e\-/)) { // negative exponent
    28|     return {
    29|       num: Math.floor(Number(num)).toString(),
    30|       base: base || 10
    31|     }
    32|   } else {
    33|     return {
    34|       num: num,
    35|       base: base || 10
    36|     }
    37|   }
    38| }
    39| bin.setJSConditioner(BigNum.conditionArgs)
    40| BigNum.isBigNum = function (num) {
    41|   if (!num) {
    42|     return false
    43|   }
    44|   for (var key in BigNum.prototype) {
    45|     if (!num[key]) {
    46|       return false
    47|     }

# --- HUNK 2: Lines 49-89 ---
    49|   return true
    50| }
    51| BigNum.prototype.inspect = function () {
    52|   return '<BigNum ' + this.toString(10) + '>'
    53| }
    54| BigNum.prototype.toString = function (base) {
    55|   var value
    56|   if (base) {
    57|     value = this.tostring(base)
    58|   } else {
    59|     value = this.tostring()
    60|   }
    61|   if (base > 10 && typeof value === 'string') {
    62|     value = value.toLowerCase()
    63|   }
    64|   return value
    65| }
    66| BigNum.prototype.toNumber = function () {
    67|   return parseInt(this.toString(), 10)
    68| }
    69| ;[ 'add', 'sub', 'mul', 'div', 'mod' ].forEach(function (op) {
    70|   BigNum.prototype[op] = function (num) {
    71|     var x
    72|     if (BigNum.isBigNum(num)) {
    73|       return this['b' + op](num)
    74|     } else if (typeof num === 'number') {
    75|       if (num >= 0) {
    76|         return this['u' + op](num)
    77|       } else if (op === 'add') {
    78|         return this.usub(-num)
    79|       } else if (op === 'sub') {
    80|         return this.uadd(-num)
    81|       } else {
    82|         x = BigNum(num)
    83|         return this['b' + op](x)
    84|       }
    85|     } else if (typeof num === 'string') {
    86|       x = BigNum(num)
    87|       return this['b' + op](x)
    88|     } else {
    89|       throw new TypeError('Unspecified operation for type ' +

# --- HUNK 3: Lines 208-250 ---
   208|   }
   209| })
   210| BigNum.prototype.sqrt = function () {
   211|   return this.bsqrt()
   212| }
   213| BigNum.prototype.root = function (num) {
   214|   if (BigNum.isBigNum(num)) {
   215|     return this.broot(num)
   216|   } else {
   217|     return this.broot(num)
   218|   }
   219| }
   220| BigNum.prototype.rand = function (to) {
   221|   if (to === undefined) {
   222|     if (this.toString() === '1') {
   223|       return BigNum(0)
   224|     } else {
   225|       return this.brand0()
   226|     }
   227|   } else {
   228|     var x = BigNum.isBigNum(to)
   229|       ? to.sub(this)
   230|      : BigNum(to).sub(this)
   231|     return x.brand0().add(this)
   232|   }
   233| }
   234| BigNum.prototype.invertm = function (mod) {
   235|   if (BigNum.isBigNum(mod)) {
   236|     return this.binvertm(mod)
   237|   } else {
   238|     var x = BigNum(mod)
   239|     return this.binvertm(x)
   240|   }
   241| }
   242| BigNum.prime = function (bits, safe) {
   243|   if (typeof safe === 'undefined') {
   244|     safe = true
   245|   }
   246|   bits >>>= 0
   247|   return BigNum.uprime0(bits, !!safe)
   248| }
   249| BigNum.prototype.probPrime = function (reps) {
   250|   var n = this.probprime(reps || 10)

# --- HUNK 4: Lines 275-341 ---
   275|     var chunk = []
   276|     for (var j = 0; j < size; j++) {
   277|       chunk.push(buf[i + (endian === 'big' ? j : (size - j - 1))])
   278|     }
   279|     hex.push(chunk
   280|       .map(function (c) {
   281|         return (c < 16 ? '0' : '') + c.toString(16)
   282|       })
   283|       .join('')
   284|     )
   285|   }
   286|   return BigNum(hex.join(''), 16)
   287| }
   288| BigNum.prototype.toBuffer = function (opts) {
   289|   if (typeof opts === 'string') {
   290|     if (opts !== 'mpint') return 'Unsupported Buffer representation'
   291|     var abs = this.abs()
   292|     var buf = abs.toBuffer({ size: 1, endian: 'big' })
   293|     var len = buf.length === 1 && buf[0] === 0 ? 0 : buf.length
   294|     if (buf[0] & 0x80) len++
   295|     var ret = new Buffer(4 + len)
   296|     if (len > 0) buf.copy(ret, 4 + (buf[0] & 0x80 ? 1 : 0))
   297|     if (buf[0] & 0x80) ret[4] = 0
   298|     ret[0] = len & (0xff << 24)
   299|     ret[1] = len & (0xff << 16)
   300|     ret[2] = len & (0xff << 8)
   301|     ret[3] = len & (0xff << 0)
   302|     var isNeg = this.lt(0)
   303|     if (isNeg) {
   304|       for (var i = 4; i < ret.length; i++) {
   305|         ret[i] = 0xff - ret[i]
   306|       }
   307|     }
   308|     ret[4] = (ret[4] & 0x7f) | (isNeg ? 0x80 : 0)
   309|     if (isNeg) ret[ret.length - 1]++
   310|     return ret
   311|   }
   312|   if (!opts) opts = {}
   313|   var endian = { 1: 'big', '-1': 'little' }[opts.endian] ||
   314|     opts.endian || 'big'
   315|   var hex = this.toString(16)
   316|   if (hex.charAt(0) === '-') {
   317|     throw new Error('converting negative numbers to Buffers not supported yet')
   318|   }
   319|   var size = opts.size === 'auto' ? Math.ceil(hex.length / 2) : (opts.size || 1)
   320|   len = Math.ceil(hex.length / (2 * size)) * size
   321|   buf = new Buffer(len)
   322|   while (hex.length < 2 * len) hex = '0' + hex
   323|   var hx = hex
   324|     .split(new RegExp('(.{' + (2 * size) + '})'))
   325|     .filter(function (s) { return s.length > 0 })
   326|   hx.forEach(function (chunk, i) {
   327|     for (var j = 0; j < size; j++) {
   328|       var ix = i * size + (endian === 'big' ? j : size - j - 1)
   329|       buf[ix] = parseInt(chunk.slice(j * 2, j * 2 + 2), 16)
   330|     }
   331|   })
   332|   return buf
   333| }
   334| Object.keys(BigNum.prototype).forEach(function (name) {
   335|   if (name === 'inspect' || name === 'toString') return
   336|   BigNum[name] = function (num) {
   337|     var args = [].slice.call(arguments, 1)
   338|     if (BigNum.isBigNum(num)) {
   339|       return num[name].apply(num, args)
   340|     } else {
   341|       var bigi = BigNum(num)

