--- a//dev/null
+++ b/projenrc/support.ts
@@ -0,0 +1,21 @@
+import { JsonFile, Project } from 'projen';
+import type { ReleasesDocument } from '../src/support';
+export const SUPPORT_POLICY: ReleasesDocument = {
+  current: '5.4',
+  maintenance: {
+    '5.0': new Date('2024-01-31'),
+    '5.1': new Date('2024-02-28'),
+    '5.2': new Date('2024-06-30'),
+    '5.3': new Date('2024-10-15'),
+  },
+};
+export class SupportPolicy {
+  public constructor(project: Project) {
+    new JsonFile(project, 'releases.json', {
+      allowComments: false,
+      editGitignore: false,
+      obj: SUPPORT_POLICY,
+      readonly: true,
+    });
+  }
+}

--- a/src/compiler.ts
+++ b//dev/null
@@ -1,520 +0,0 @@
-import * as fs from 'node:fs';
-import * as path from 'node:path';
-import * as chalk from 'chalk';
-import * as log4js from 'log4js';
-import * as ts from 'typescript';
-import { Assembler } from './assembler';
-import { findDependencyDirectory } from './common/find-utils';
-import { emitDownleveledDeclarations, TYPES_COMPAT } from './downlevel-dts';
-import { Emitter } from './emitter';
-import { normalizeConfigPath } from './helpers';
-import { JsiiDiagnostic } from './jsii-diagnostic';
-import { ProjectInfo } from './project-info';
-import { WARNINGSCODE_FILE_NAME } from './transforms/deprecation-warnings';
-import { TypeScriptConfig, TypeScriptConfigValidationRuleSet } from './tsconfig';
-import { BASE_COMPILER_OPTIONS, convertForJson } from './tsconfig/compiler-options';
-import { TypeScriptConfigValidator } from './tsconfig/tsconfig-validator';
-import { ValidationError } from './tsconfig/validator';
-import * as utils from './utils';
-const LOG = log4js.getLogger('jsii/compiler');
-export const DIAGNOSTICS = 'diagnostics';
-export const JSII_DIAGNOSTICS_CODE = 9999;
-export interface CompilerOptions {
-  /** The information about the project to be built */
-  projectInfo: ProjectInfo;
-  /** Whether the compiler should watch for changes or just compile once */
-  watch?: boolean;
-  /** Whether to detect and generate TypeScript project references */
-  projectReferences?: boolean;
-  /** Whether to fail when a warning is emitted */
-  failOnWarnings?: boolean;
-  /** Whether to strip deprecated members from emitted artifacts */
-  stripDeprecated?: boolean;
-  /** The path to an allowlist of FQNs to strip if stripDeprecated is set */
-  stripDeprecatedAllowListFile?: string;
-  /** Whether to add warnings for deprecated elements */
-  addDeprecationWarnings?: boolean;
-  /**
-   * The name of the tsconfig file to generate.
-   * Cannot be used at the same time as `typeScriptConfig`.
-   * @default "tsconfig.json"
-   */
-  generateTypeScriptConfig?: string;
-  /**
-   * The name of the tsconfig file to use.
-   * Cannot be used at the same time as `generateTypeScriptConfig`.
-   * @default - generate the tsconfig file
-   */
-  typeScriptConfig?: string;
-  /**
-   * The ruleset to validate the provided tsconfig file against.
-   * Can only be used when `typeScriptConfig` is provided.
-   * @default TypeScriptConfigValidationRuleSet.STRICT - if `typeScriptConfig` is provided
-   */
-  validateTypeScriptConfig?: TypeScriptConfigValidationRuleSet;
-  /**
-   * Whether to compress the assembly
-   * @default false
-   */
-  compressAssembly?: boolean;
-}
-export class Compiler implements Emitter {
-  private readonly system: ts.System;
-  private readonly compilerHost: ts.CompilerHost;
-  private readonly userProvidedTypeScriptConfig: boolean;
-  private readonly tsconfig: TypeScriptConfig;
-  private rootFiles: string[] = [];
-  private readonly configPath: string;
-  private readonly projectRoot: string;
-  public constructor(private readonly options: CompilerOptions) {
-    if (options.generateTypeScriptConfig != null && options.typeScriptConfig != null) {
-      throw new utils.JsiiError(
-        'Cannot use `generateTypeScriptConfig` and `typeScriptConfig` together. Provide only one of them.',
-      );
-    }
-    this.projectRoot = this.options.projectInfo.projectRoot;
-    const configFileName = options.typeScriptConfig ?? options.generateTypeScriptConfig ?? 'tsconfig.json';
-    this.configPath = path.join(this.projectRoot, configFileName);
-    this.userProvidedTypeScriptConfig = Boolean(options.typeScriptConfig);
-    this.system = {
-      ...ts.sys,
-      getCurrentDirectory: () => this.projectRoot,
-      createDirectory: (pth) => ts.sys.createDirectory(path.resolve(this.projectRoot, pth)),
-      deleteFile: ts.sys.deleteFile && ((pth) => ts.sys.deleteFile!(path.join(this.projectRoot, pth))),
-      fileExists: (pth) => ts.sys.fileExists(path.resolve(this.projectRoot, pth)),
-      getFileSize: ts.sys.getFileSize && ((pth) => ts.sys.getFileSize!(path.resolve(this.projectRoot, pth))),
-      readFile: (pth, encoding) => ts.sys.readFile(path.resolve(this.projectRoot, pth), encoding),
-      watchFile:
-        ts.sys.watchFile &&
-        ((pth, callback, pollingInterval, watchOptions) =>
-          ts.sys.watchFile!(path.resolve(this.projectRoot, pth), callback, pollingInterval, watchOptions)),
-      writeFile: (pth, data, writeByteOrderMark) =>
-        ts.sys.writeFile(path.resolve(this.projectRoot, pth), data, writeByteOrderMark),
-    };
-    this.tsconfig = this.configureTypeScript();
-    this.compilerHost = ts.createIncrementalCompilerHost(this.tsconfig.compilerOptions, this.system);
-  }
-  /**
-   * Compiles the configured program.
-   *
-   * @param files can be specified to override the standard source code location logic. Useful for example when testing "negatives".
-   */
-  public emit(...files: string[]): ts.EmitResult {
-    this.prepareForBuild(...files);
-    return this.buildOnce();
-  }
-  /**
-   * Watches for file-system changes and dynamically recompiles the project as needed. In non-blocking mode, this
-   * returns the TypeScript watch handle for the application to use.
-   *
-   * @internal
-   */
-  public async watch(opts: NonBlockingWatchOptions): Promise<ts.Watch<ts.BuilderProgram>>;
-  /**
-   * Watches for file-system changes and dynamically recompiles the project as needed. In blocking mode, this results
-   * in a never-resolving promise.
-   */
-  public async watch(): Promise<never>;
-  public async watch(opts?: NonBlockingWatchOptions): Promise<ts.Watch<ts.BuilderProgram> | never> {
-    this.prepareForBuild();
-    const host = ts.createWatchCompilerHost(
-      this.configPath,
-      {
-        ...this.tsconfig.compilerOptions,
-        noEmitOnError: false,
-      },
-      this.system,
-      ts.createEmitAndSemanticDiagnosticsBuilderProgram,
-      opts?.reportDiagnostics,
-      opts?.reportWatchStatus,
-      this.tsconfig.watchOptions,
-    );
-    if (!host.getDefaultLibLocation) {
-      throw new Error('No default library location was found on the TypeScript compiler host!');
-    }
-    const orig = host.afterProgramCreate;
-    host.afterProgramCreate = (builderProgram) => {
-      const emitResult = this.consumeProgram(builderProgram.getProgram(), host.getDefaultLibLocation!());
-      for (const diag of emitResult.diagnostics.filter((d) => d.code === JSII_DIAGNOSTICS_CODE)) {
-        utils.logDiagnostic(diag, this.projectRoot);
-      }
-      if (orig) {
-        orig.call(host, builderProgram);
-      }
-      if (opts?.compilationComplete) {
-        opts.compilationComplete(emitResult);
-      }
-    };
-    const watch = ts.createWatchProgram(host);
-    if (opts?.nonBlocking) {
-      return watch;
-    }
-    return new Promise<never>(() => null);
-  }
-  /**
-   * Prepares the project for build, by creating the necessary configuration
-   * file(s), and assigning the relevant root file(s).
-   *
-   * @param files the files that were specified as input in the CLI invocation.
-   */
-  private configureTypeScript(): TypeScriptConfig {
-    if (this.userProvidedTypeScriptConfig) {
-      const config = this.readTypeScriptConfig();
-      const rules = this.options.validateTypeScriptConfig ?? TypeScriptConfigValidationRuleSet.NONE;
-      if (rules === TypeScriptConfigValidationRuleSet.NONE) {
-        utils.logDiagnostic(
-          JsiiDiagnostic.JSII_4009_DISABLED_TSCONFIG_VALIDATION.create(undefined, this.configPath),
-          this.projectRoot,
-        );
-      }
-      if (rules !== TypeScriptConfigValidationRuleSet.NONE) {
-        const configName = path.relative(this.projectRoot, this.configPath);
-        try {
-          const validator = new TypeScriptConfigValidator(rules);
-          validator.validate({
-            ...config,
-            compilerOptions: convertForJson(config.compilerOptions),
-          });
-        } catch (error: unknown) {
-          if (error instanceof ValidationError) {
-            utils.logDiagnostic(
-              JsiiDiagnostic.JSII_4000_FAILED_TSCONFIG_VALIDATION.create(
-                undefined,
-                configName,
-                rules,
-                error.violations,
-              ),
-              this.projectRoot,
-            );
-          }
-          throw new utils.JsiiError(
-            `Failed validation of tsconfig "compilerOptions" in "${configName}" against rule set "${rules}"!`,
-          );
-        }
-      }
-      return config;
-    }
-    return this.buildTypeScriptConfig();
-  }
-  /**
-   * Final preparations of the project for build.
-   *
-   * These are preparations that either
-   * - must happen immediately before the build, or
-   * - can be different for every build like assigning the relevant root file(s).
-   *
-   * @param files the files that were specified as input in the CLI invocation.
-   */
-  private prepareForBuild(...files: string[]) {
-    if (!this.userProvidedTypeScriptConfig) {
-      this.writeTypeScriptConfig();
-    }
-    this.rootFiles = this.determineSources(files);
-  }
-  /**
-   * Do a single build
-   */
-  private buildOnce(): ts.EmitResult {
-    if (!this.compilerHost.getDefaultLibLocation) {
-      throw new Error('No default library location was found on the TypeScript compiler host!');
-    }
-    const tsconf = this.tsconfig!;
-    const prog = ts.createIncrementalProgram({
-      rootNames: this.rootFiles.concat(_pathOfLibraries(tsconf.compilerOptions, this.compilerHost)),
-      options: tsconf.compilerOptions,
-      projectReferences: tsconf.references?.map((ref) => ({
-        path: path.resolve(path.dirname(this.configPath), ref.path),
-      })),
-      host: this.compilerHost,
-    });
-    return this.consumeProgram(prog.getProgram(), this.compilerHost.getDefaultLibLocation());
-  }
-  private consumeProgram(program: ts.Program, stdlib: string): ts.EmitResult {
-    const diagnostics = [...ts.getPreEmitDiagnostics(program)];
-    let hasErrors = false;
-    if (!hasErrors && this.diagsHaveAbortableErrors(diagnostics)) {
-      hasErrors = true;
-      LOG.error('Compilation errors prevented the JSII assembly from being created');
-    }
-    const assembler = new Assembler(this.options.projectInfo, this.system, program, stdlib, {
-      stripDeprecated: this.options.stripDeprecated,
-      stripDeprecatedAllowListFile: this.options.stripDeprecatedAllowListFile,
-      addDeprecationWarnings: this.options.addDeprecationWarnings,
-      compressAssembly: this.options.compressAssembly,
-    });
-    try {
-      const assmEmit = assembler.emit();
-      if (!hasErrors && (assmEmit.emitSkipped || this.diagsHaveAbortableErrors(assmEmit.diagnostics))) {
-        hasErrors = true;
-        LOG.error('Type model errors prevented the JSII assembly from being created');
-      }
-      diagnostics.push(...assmEmit.diagnostics);
-    } catch (e: any) {
-      diagnostics.push(JsiiDiagnostic.JSII_9997_UNKNOWN_ERROR.createDetached(e));
-      hasErrors = true;
-    }
-    const emit = program.emit(
-      undefined, // targetSourceFile
-      undefined, // writeFile
-      undefined, // cancellationToken
-      undefined, // emitOnlyDtsFiles
-      assembler.customTransformers,
-    );
-    diagnostics.push(...emit.diagnostics);
-    if (!hasErrors && (emit.emitSkipped || this.diagsHaveAbortableErrors(emit.diagnostics))) {
-      hasErrors = true;
-      LOG.error('Compilation errors prevented the JSII assembly from being created');
-    }
-    if (!hasErrors) {
-      emitDownleveledDeclarations(
-        this.projectRoot,
-        this.options.projectInfo.packageJson,
-        normalizeConfigPath(this.projectRoot, this.tsconfig.compilerOptions.outDir),
-      );
-    }
-    if (this.options.addDeprecationWarnings && this.options.projectInfo.exports !== undefined) {
-      const expected = `./${WARNINGSCODE_FILE_NAME}`;
-      const warningsExport = Object.entries(this.options.projectInfo.exports).filter(
-        ([k, v]) => k === expected && v === expected,
-      );
-      if (warningsExport.length === 0) {
-        hasErrors = true;
-        diagnostics.push(JsiiDiagnostic.JSII_0007_MISSING_WARNINGS_EXPORT.createDetached());
-      }
-    }
-    return {
-      emitSkipped: hasErrors,
-      diagnostics: ts.sortAndDeduplicateDiagnostics(diagnostics),
-      emittedFiles: emit.emittedFiles,
-    };
-  }
-  /**
-   * Build the TypeScript config object from jsii config
-   *
-   * This is the object that will be written to disk
-   * unless an existing tsconfig was provided.
-   */
-  private buildTypeScriptConfig(): TypeScriptConfig {
-    let references: string[] | undefined;
-    const isComposite =
-      this.options.projectReferences !== undefined
-        ? this.options.projectReferences
-        : this.options.projectInfo.projectReferences !== undefined
-        ? this.options.projectInfo.projectReferences
-        : false;
-    if (isComposite) {
-      references = this.findProjectReferences();
-    }
-    const pi = this.options.projectInfo;
-    const configDir = path.dirname(this.configPath);
-    const absoluteTypesCompat = path.resolve(configDir, pi.tsc?.outDir ?? '.', TYPES_COMPAT);
-    const relativeTypesCompat = path.relative(configDir, absoluteTypesCompat);
-    return {
-      compilerOptions: {
-        ...pi.tsc,
-        ...BASE_COMPILER_OPTIONS,
-        composite: isComposite,
-        tsBuildInfoFile: path.join(pi.tsc?.outDir ?? '.', 'tsconfig.tsbuildinfo'),
-      },
-      include: [pi.tsc?.rootDir != null ? path.join(pi.tsc.rootDir, '**', '*.ts') : path.join('**', '*.ts')],
-      exclude: [
-        'node_modules',
-        relativeTypesCompat,
-        ...(pi.excludeTypescript ?? []),
-        ...(pi.tsc?.outDir != null &&
-        (pi.tsc?.rootDir == null || path.resolve(pi.tsc.outDir).startsWith(path.resolve(pi.tsc.rootDir) + path.sep))
-          ? [path.join(pi.tsc.outDir, '**', '*.ts')]
-          : []),
-      ],
-      references: references?.map((p) => ({ path: p })),
-    };
-  }
-  /**
-   * Load the TypeScript config object from a provided file
-   */
-  private readTypeScriptConfig(): TypeScriptConfig {
-    const projectRoot = this.options.projectInfo.projectRoot;
-    const { config, error } = ts.readConfigFile(this.configPath, ts.sys.readFile);
-    if (error) {
-      utils.logDiagnostic(error, projectRoot);
-      throw new utils.JsiiError(`Failed to load tsconfig at ${this.configPath}`);
-    }
-    const extended = ts.parseJsonConfigFileContent(config, ts.sys, projectRoot);
-    delete extended.options.configFilePath;
-    return {
-      compilerOptions: extended.options,
-      watchOptions: extended.watchOptions,
-      include: extended.fileNames,
-    };
-  }
-  /**
-   * Creates a `tsconfig.json` file to improve the IDE experience.
-   *
-   * @return the fully qualified path to the `tsconfig.json` file
-   */
-  private writeTypeScriptConfig(): void {
-    const commentKey = '_generated_by_jsii_';
-    const commentValue = 'Generated by jsii - safe to delete, and ideally should be in .gitignore';
-    (this.tsconfig as any)[commentKey] = commentValue;
-    if (fs.existsSync(this.configPath)) {
-      const currentConfig = JSON.parse(fs.readFileSync(this.configPath, 'utf-8'));
-      if (!(commentKey in currentConfig)) {
-        throw new utils.JsiiError(
-          `A '${this.configPath}' file that was not generated by jsii is in ${this.options.projectInfo.projectRoot}. Aborting instead of overwriting.`,
-        );
-      }
-    }
-    const outputConfig = {
-      ...this.tsconfig,
-      compilerOptions: convertForJson(this.tsconfig?.compilerOptions),
-    };
-    LOG.debug(`Creating or updating ${chalk.blue(this.configPath)}`);
-    fs.writeFileSync(this.configPath, JSON.stringify(outputConfig, null, 2), 'utf8');
-  }
-  /**
-   * Find all dependencies that look like TypeScript projects.
-   *
-   * Enumerate all dependencies, if they have a tsconfig.json file with
-   * "composite: true" we consider them project references.
-   *
-   * (Note: TypeScript seems to only correctly find transitive project references
-   * if there's an "index" tsconfig.json of all projects somewhere up the directory
-   * tree)
-   */
-  private findProjectReferences(): string[] {
-    const pkg = this.options.projectInfo.packageJson;
-    const ret = new Array<string>();
-    const dependencyNames = new Set<string>();
-    for (const dependencyMap of [pkg.dependencies, pkg.devDependencies, pkg.peerDependencies]) {
-      if (dependencyMap === undefined) {
-        continue;
-      }
-      for (const name of Object.keys(dependencyMap)) {
-        dependencyNames.add(name);
-      }
-    }
-    for (const tsconfigFile of Array.from(dependencyNames).map((depName) => this.findMonorepoPeerTsconfig(depName))) {
-      if (!tsconfigFile) {
-        continue;
-      }
-      const { config: tsconfig } = ts.readConfigFile(tsconfigFile, this.system.readFile);
-      if (tsconfig.compilerOptions?.composite) {
-        ret.push(path.relative(this.options.projectInfo.projectRoot, path.dirname(tsconfigFile)));
-      } else {
-        if (tsconfigFile.includes('node_modules')) {
-          LOG.warn('%s: not a composite TypeScript package, but it probably should be', path.dirname(tsconfigFile));
-        }
-      }
-    }
-    return ret;
-  }
-  /**
-   * Find source files using the same mechanism that the TypeScript compiler itself uses.
-   *
-   * Respects includes/excludes/etc.
-   *
-   * This makes it so that running 'typescript' and running 'jsii' has the same behavior.
-   */
-  private determineSources(files: string[]): string[] {
-    if (files.length > 0) {
-      return [...files];
-    }
-    if (this.userProvidedTypeScriptConfig) {
-      return [...(this.tsconfig.include ?? [])];
-    }
-    const parseConfigHost = parseConfigHostFromCompilerHost(this.compilerHost);
-    const parsed = ts.parseJsonConfigFileContent(this.tsconfig, parseConfigHost, this.options.projectInfo.projectRoot);
-    return [...parsed.fileNames];
-  }
-  /**
-   * Resolve the given dependency name from the current package, and find the associated tsconfig.json location
-   *
-   * Because we have the following potential directory layout:
-   *
-   *   package/node_modules/some_dependency
-   *   package/tsconfig.json
-   *
-   * We resolve symlinks and only find a "TypeScript" dependency if doesn't have 'node_modules' in
-   * the path after resolving symlinks (i.e., if it's a peer package in the same monorepo).
-   *
-   * Returns undefined if no such tsconfig could be found.
-   */
-  private findMonorepoPeerTsconfig(depName: string): string | undefined {
-    const { builtinModules } = require('node:module');
-    if ((builtinModules ?? []).includes(depName)) {
-      return undefined;
-    }
-    try {
-      const depDir = findDependencyDirectory(depName, this.options.projectInfo.projectRoot);
-      const dep = path.join(depDir, 'tsconfig.json');
-      if (!fs.existsSync(dep)) {
-        return undefined;
-      }
-      const dependencyRealPath = fs.realpathSync(dep);
-      if (dependencyRealPath.split(path.sep).includes('node_modules')) {
-        return undefined;
-      }
-      return dependencyRealPath;
-    } catch (e: any) {
-      if (['MODULE_NOT_FOUND', 'ERR_PACKAGE_PATH_NOT_EXPORTED'].includes(e.code)) {
-        return undefined;
-      }
-      throw e;
-    }
-  }
-  private diagsHaveAbortableErrors(diags: readonly ts.Diagnostic[]) {
-    return diags.some(
-      (d) =>
-        d.category === ts.DiagnosticCategory.Error ||
-        (this.options.failOnWarnings && d.category === ts.DiagnosticCategory.Warning),
-    );
-  }
-}
-/**
- * Options for Watch in non-blocking mode.
- *
- * @internal
- */
-export interface NonBlockingWatchOptions {
-  /**
-   * Signals non-blocking execution
-   */
-  readonly nonBlocking: true;
-  /**
-   * Configures the diagnostics reporter
-   */
-  readonly reportDiagnostics: ts.DiagnosticReporter;
-  /**
-   * Configures the watch status reporter
-   */
-  readonly reportWatchStatus: ts.WatchStatusReporter;
-  /**
-   * This hook gets invoked when a compilation cycle (complete with Assembler execution) completes.
-   */
-  readonly compilationComplete: (emitResult: ts.EmitResult) => void;
-}
-function _pathOfLibraries(options: ts.CompilerOptions, host: ts.CompilerHost | ts.WatchCompilerHost<any>): string[] {
-  const libs = options.lib ?? [ts.getDefaultLibFileName(options)] ?? [];
-  if (libs.length === 0) {
-    return [];
-  }
-  const libDir = host.getDefaultLibLocation?.();
-  if (!libDir) {
-    throw new Error(`Compiler host doesn't have a default library directory available for ${libs.join(', ')}`);
-  }
-  return libs.map((name) => path.join(libDir, name));
-}
-function parseConfigHostFromCompilerHost(host: ts.CompilerHost): ts.ParseConfigHost {
-  return {
-    fileExists: (f) => host.fileExists(f),
-    readDirectory(root, extensions, excludes, includes, depth) {
-      if (host.readDirectory === undefined) {
-        throw new Error("'CompilerHost.readDirectory' must be implemented to correctly process 'projectReferences'");
-      }
-      return host.readDirectory(root, extensions, excludes, includes, depth);
-    },
-    readFile: (f) => host.readFile(f),
-    useCaseSensitiveFileNames: host.useCaseSensitiveFileNames(),
-    trace: host.trace ? (s) => host.trace!(s) : undefined,
-  };
-}

--- a/src/jsii-diagnostic.ts
+++ b//dev/null
@@ -1,773 +0,0 @@
-import * as spec from '@jsii/spec';
-import { camel, constant, pascal } from 'case';
-import * as ts from 'typescript';
-import { TypeSystemHints } from './docs';
-import { WARNINGSCODE_FILE_NAME } from './transforms/deprecation-warnings';
-import { Violation } from './tsconfig/validator';
-import { JSII_DIAGNOSTICS_CODE, _formatDiagnostic } from './utils';
-/**
- * Descriptors for all valid jsii diagnostic codes.
- *
- * The `category` or non-error codes can be updated, for example to treat
- * warnings as errors, or to suppress certain undesirable warnings.
- */
-export class Code<T extends DiagnosticMessageFormatter = DiagnosticMessageFormatter> {
-  /**
-   * @internal
-   */
-  public static message<T extends DiagnosticMessageFormatter>({
-    code,
-    name,
-    formatter,
-  }: {
-    code: number;
-    formatter: T;
-    name: string;
-  }) {
-    return new Code<T>(code, name, ts.DiagnosticCategory.Message, formatter);
-  }
-  /**
-   * @internal
-   */
-  public static suggestion<T extends DiagnosticMessageFormatter>({
-    code,
-    name,
-    formatter,
-  }: {
-    code: number;
-    formatter: T;
-    name: string;
-  }) {
-    return new Code<T>(code, name, ts.DiagnosticCategory.Suggestion, formatter);
-  }
-  /**
-   * @internal
-   */
-  public static warning<T extends DiagnosticMessageFormatter>({
-    code,
-    name,
-    formatter,
-  }: {
-    code: number;
-    formatter: T;
-    name: string;
-  }) {
-    return new Code<T>(code, name, ts.DiagnosticCategory.Warning, formatter);
-  }
-  /**
-   * @internal
-   */
-  public static error<T extends DiagnosticMessageFormatter>({
-    code,
-    name,
-    formatter,
-  }: {
-    code: number;
-    formatter: T;
-    name: string;
-  }) {
-    return new Code<T>(code, name, ts.DiagnosticCategory.Error, formatter);
-  }
-  /**
-   * Get a diagnostic code by code or name.
-   *
-   * @param codeOrName the looked up diagnostic code or name.
-   *
-   * @returns the JsiiDiagnosticCode instande, if one exists, or `undefined`
-   *
-   * @experimental this module is under active development and the error codes
-   *               and names may change in the future.
-   */
-  public static lookup(codeOrName: string | number): Code | undefined {
-    if (typeof codeOrName === 'number') {
-      return this.byCode.get(codeOrName);
-    }
-    return this.byName.get(codeOrName);
-  }
-  private static readonly byCode: Map<number, Code> = new Map();
-  private static readonly byName: Map<string, Code> = new Map();
-  readonly #defaultCategory: ts.DiagnosticCategory;
-  #category?: ts.DiagnosticCategory;
-  #formatter: T;
-  /**
-   * Registers a new diagnostic code.
-   *
-   * @param code            the numeric code for the diagnostic
-   * @param name            the symbolic name for the diagnostic
-   * @param defaultCategory the default category this diagnostic ranks in
-   * @param formatter       a message formatter for easy creation of diagnostics
-   */
-  private constructor(
-    public readonly code: number,
-    public readonly name: string,
-    defaultCategory: ts.DiagnosticCategory,
-    formatter: T,
-  ) {
-    this.#defaultCategory = defaultCategory;
-    this.#formatter = formatter;
-    if (code in Code.byCode) {
-      throw new Error(`Attempted to create two instances of ${this.constructor.name} with code ${code}`);
-    }
-    if (name in Code.byName) {
-      throw new Error(`Attempted to create two instances of ${this.constructor.name} with name ${name}`);
-    }
-    Code.byCode.set(code, this);
-    Code.byName.set(name, this);
-  }
-  /**
-   * Determines whether this diagnostic is a compilation error. Diagnostics
-   * where this is `true` cannot have their `category` overridden to a lower
-   * category.
-   */
-  public get isError(): boolean {
-    return this.#defaultCategory === ts.DiagnosticCategory.Error;
-  }
-  /**
-   * The diagnostic category this particular code is filed as.
-   */
-  public get category(): ts.DiagnosticCategory {
-    return this.#category ?? this.#defaultCategory;
-  }
-  /**
-   * Update the diagnostic category for this particular code. If `isError` is
-   * `true`, attempting to set anything other than `ts.DiagnosticCategory.Error`
-   * will result in an error being throw.
-   *
-   * @param newValue the new diagnostic category to be used.
-   */
-  public set category(newValue: ts.DiagnosticCategory) {
-    if (this.isError && newValue !== ts.DiagnosticCategory.Error) {
-      throw new Error(
-        `Illegal attempt to override category of error ${this.code} to ${ts.DiagnosticCategory[newValue]}`,
-      );
-    }
-    this.#category = newValue;
-  }
-  /**
-   * Creates a new `JsiiDiagnostic` message without any source code location
-   * data.
-   *
-   * @param args the arguments to the message formatter.
-   *
-   * @deprecated It is preferred to specify a source code location for problem
-   *             markers. Prefer the use of `create` while providing a value
-   *             for the `location` parameter whenever possible.
-   */
-  public createDetached(...args: Parameters<T>): JsiiDiagnostic {
-    return new JsiiDiagnostic(this, this.#formatter(...args));
-  }
-  /**
-   * Creates a new `JsiiDiagnostic` message with source code location denoted
-   * by the provided `location` node.
-   *
-   * @param location the source code location attachment of the message.
-   * @param args     the arguments to the message formatter.
-   */
-  public create(location: ts.Node | undefined, ...args: Parameters<T>): JsiiDiagnostic {
-    return new JsiiDiagnostic(this, this.#formatter(...args), location);
-  }
-}
-/**
- * A jsii-specific diagnostic entry.
- */
-export class JsiiDiagnostic implements ts.Diagnostic {
-  public static readonly JSII_0001_PKG_MISSING_DESCRIPTION = Code.suggestion({
-    code: 1,
-    formatter: () => 'A "description" field should be specified in "package.json"',
-    name: 'metadata/package-json-missing-description',
-  });
-  public static readonly JSII_0002_PKG_MISSING_HOMEPAGE = Code.suggestion({
-    code: 2,
-    formatter: () => 'A "homepage" field should be specified in "package.json"',
-    name: 'metadata/package-json-missing-homepage',
-  });
-  public static readonly JSII_0003_MISSING_README = Code.warning({
-    code: 3,
-    formatter: () => 'There is no "README.md" file. It is required in order to generate valid PyPI (Python) packages.',
-    name: 'metadata/missing-readme',
-  });
-  public static readonly JSII_0004_COULD_NOT_FIND_ENTRYPOINT = Code.error({
-    code: 4,
-    formatter: (mainFile: string) => `Could not find "main" file: ${mainFile}`,
-    name: 'metadata/could-not-find-entrypoint',
-  });
-  public static readonly JSII_0005_MISSING_PEER_DEPENDENCY = Code.warning({
-    code: 5,
-    formatter: (assm: string, reference: string) =>
-      `The type "${reference}" is exposed in the public API of this module. ` +
-      `Therefore, the module "${assm}" must also be defined under "peerDependencies". ` +
-      'This will be auto-corrected unless --no-fix-peer-dependencies was specified.',
-    name: 'metadata/missing-peer-dependency',
-  });
-  public static readonly JSII_0006_MISSING_DEV_DEPENDENCY = Code.warning({
-    code: 6,
-    formatter: (dependencyName: string, peerRange: string, minVersion: string, actual: string) =>
-      `A "peerDependency" on "${dependencyName}" at "${peerRange}" means you ` +
-      `should take a "devDependency" on "${dependencyName}" at "${minVersion}" ` +
-      `(found ${JSON.stringify(actual)})`,
-    name: 'metadata/missing-dev-dependency',
-  });
-  public static readonly JSII_0007_MISSING_WARNINGS_EXPORT = Code.error({
-    code: 7,
-    formatter: () =>
-      'If you are compiling with --add-deprecation-warnings and your package.json ' +
-      `declares subpath exports, you must include { "./${WARNINGSCODE_FILE_NAME}": "./${WARNINGSCODE_FILE_NAME}" } ` +
-      'in the set of exports.',
-    name: 'metadata/missing-warnings-export',
-  });
-  public static readonly JSII_1000_NO_CONST_ENUM = Code.error({
-    code: 1000,
-    formatter: () => 'Exported "const enum" declarations are not allowed',
-    name: 'typescript-restrictions/no-const-enum',
-  });
-  public static readonly JSII_1001_TYPE_HAS_NO_SYMBOL = Code.error({
-    code: 1001,
-    formatter: () => 'Non-primitive types without a symbol cannot be processed.',
-    name: 'typescript-restrictions/type-has-no-symbol',
-  });
-  public static readonly JSII_1002_UNSPECIFIED_PROMISE = Code.error({
-    code: 1002,
-    formatter: () => 'Un-specified promise type. Specify it using "Promise<T>"',
-    name: 'typescript-restrictions/unspecified-promise',
-  });
-  public static readonly JSII_1003_UNSUPPORTED_TYPE = Code.error({
-    code: 1003,
-    formatter: (messageText) => messageText,
-    name: 'typescript-restrictions/unsupported-type',
-  });
-  public static readonly JSII_1004_DUPLICATE_ENUM_VALUE = Code.error({
-    code: 1004,
-    formatter: (enumValue: string, enumMemberNames: string[]) =>
-      `Value ${enumValue} is used for multiple enum values: ${enumMemberNames.join(', ')}`,
-    name: 'typescript-restrictions/duplicate-enum-value',
-  });
-  public static readonly JSII_1005_SEPARATE_WRITE_TYPE = Code.error({
-    code: 1005,
-    formatter: () => 'Visible property signatures cannot use a separate write type. Use the same type as the getter.',
-    name: 'typescript-restrictions/separate-write-type',
-  });
-  public static readonly JSII_1006_GENERIC_TYPE = Code.error({
-    code: 1006,
-    formatter: () => 'Generic types are not supported because semantics are not uniform in target languages.',
-    name: 'typescript-restriction/generic-type',
-  });
-  public static readonly JSII_1999_UNSUPPORTED = Code.error({
-    code: 1999,
-    formatter: ({
-      what,
-      alternative,
-      suggestInternal,
-    }: {
-      what: string;
-      alternative?: string;
-      suggestInternal?: boolean;
-    }) =>
-      `${what} are not supported in jsii APIs.${alternative ? ` Consider using ${alternative} instead.` : ''}${
-        suggestInternal
-          ? ` This declaration must${alternative ? ' otherwise' : ''} be marked "@internal" or "@jsii ignore".`
-          : ''
-      }`,
-    name: 'typescript-restrictions/unsupported',
-  });
-  public static readonly JSII_2000_MISSING_DIRECTIVE_ARGUMENT = Code.warning({
-    code: 2000,
-    formatter: () =>
-      'Missing argument to @jsii directive. Refer to the jsii compiler documentation for more information.',
-    name: 'jsii-directive/missing-argument',
-  });
-  public static readonly JSII_2100_STRUCT_ON_NON_INTERFACE = Code.warning({
-    code: 2100,
-    formatter: () => 'The "@jsii struct" directive is only applicable to interface declarations.',
-    name: 'jsii-directive/struct-on-non-interface',
-  });
-  public static readonly JSII_2999_UNKNOWN_DIRECTIVE = Code.warning({
-    code: 2999,
-    formatter: (text: string) =>
-      `Unknown @jsii directive: ${JSON.stringify(
-        text,
-      )}. Refer to the jsii compiler documentation for more information.`,
-    name: 'jsii-directive/unknown',
-  });
-  public static readonly JSII_3000_EXPORTED_API_USES_HIDDEN_TYPE = Code.error({
-    code: 3000,
-    formatter: (badFqn) => `Exported APIs cannot use un-exported type "${badFqn}"`,
-    name: 'type-model/exported-api-cannot-use-unexported-type',
-  });
-  public static readonly JSII_3001_EXPOSED_INTERNAL_TYPE = Code.error({
-    code: 3001,
-    formatter: (symbol: ts.Symbol, isThisType: boolean, typeUse: string) =>
-      `Type ${
-        isThisType ? `"this" (aka: "${symbol.name}")` : `"${symbol.name}"`
-      } cannot be used as the ${typeUse} because it is private or @internal`,
-    name: 'type-model/use-of-internal-type',
-  });
-  public static readonly JSII_3002_USE_OF_UNEXPORTED_FOREIGN_TYPE = Code.error({
-    code: 3002,
-    formatter: (fqn: string, typeUse: string, pkg: { readonly name: string }) =>
-      `Type "${fqn}" cannot be used as a ${typeUse} because it is not exported from ${pkg.name}`,
-    name: 'type-model/unexported-foreign-type',
-  });
-  public static readonly JSII_3003_SYMBOL_IS_EXPORTED_TWICE = Code.error({
-    code: 3003,
-    formatter: (ns1: string, ns2: string) => `Symbol is exported under two distinct submodules: ${ns1} and ${ns2}`,
-    name: 'type-model/symbol-is-exported-twice',
-  });
-  public static readonly JSII_3004_INVALID_SUPERTYPE = Code.error({
-    code: 3004,
-    formatter: (clause: ts.HeritageClause, badDeclaration: ts.Declaration) => {
-      return `Illegal ${clauseType(clause.token)} clause for an exported API: ${ts.SyntaxKind[badDeclaration.kind]}`;
-      function clauseType(token: ts.SyntaxKind): string {
-        switch (token) {
-          case ts.SyntaxKind.ExtendsKeyword:
-            return 'extends';
-          case ts.SyntaxKind.ImplementsKeyword:
-            return 'implements';
-          default:
-            return ts.SyntaxKind[token];
-        }
-      }
-    },
-    name: 'type-model/invalid-supertype',
-  });
-  public static readonly JSII_3005_TYPE_USED_AS_INTERFACE = Code.error({
-    code: 3005,
-    formatter: (badType: spec.TypeReference) =>
-      `Type "${spec.describeTypeReference(badType)}" cannot be used as an interface`,
-    name: 'type-model/type-used-as-interface',
-  });
-  public static readonly JSII_3006_TYPE_USED_AS_CLASS = Code.error({
-    code: 3006,
-    formatter: (badType: spec.TypeReference) =>
-      `Type "${spec.describeTypeReference(badType)}" cannot be used as a class`,
-    name: 'type-model/type-used-as-class',
-  });
-  public static readonly JSII_3007_ILLEGAL_STRUCT_EXTENSION = Code.error({
-    code: 3007,
-    formatter: (offender: spec.Type, struct: spec.InterfaceType) =>
-      `Attempt to extend or implement struct "${struct.fqn}" from "${offender.fqn}"`,
-    name: 'type-model/illegal-struct-extension',
-  });
-  public static readonly JSII_3008_STRUCT_PROPS_MUST_BE_READONLY = Code.error({
-    code: 3008,
-    formatter: (propName: string, struct: spec.InterfaceType) =>
-      `The "${propName}" property of struct "${struct.fqn}" must be "readonly". Rename "${struct.fqn}" to "I${struct.name}" if it is meant to be a behavioral interface.`,
-    name: 'type-model/struct-props-must-be-readonly',
-  });
-  public static readonly JSII_3009_OPTIONAL_PARAMETER_BEFORE_REQUIRED = Code.error({
-    code: 3009,
-    formatter: (param: spec.Parameter, nextParam: spec.Parameter) =>
-      `Parameter "${param.name}" cannot be optional, as it precedes required parameter "${nextParam.name}"`,
-    name: 'type-model/optional-parameter-before-required',
-  });
-  public static readonly JSII_3999_INCOHERENT_TYPE_MODEL = Code.error({
-    code: 3999,
-    formatter: (messageText) => messageText,
-    name: 'type-model/incoherent-type-model',
-  });
-  public static readonly JSII_4000_FAILED_TSCONFIG_VALIDATION = Code.error({
-    code: 4000,
-    formatter: (config: string, ruleSet: string, violations: Array<Violation>) => {
-      return `Typescript compiler options in "${config}" are not passing validation against rule set "${ruleSet}", found the following rule violations:\n${violations
-        .map((v) => `  - ${v.field}: ${v.message}`)
-        .join('\n')}`;
-    },
-    name: 'typescript-config/invalid-tsconfig',
-  });
-  public static readonly JSII_4009_DISABLED_TSCONFIG_VALIDATION = Code.warning({
-    code: 4009,
-    formatter: (config: string) =>
-      `Validation of typescript config "${config}" is disabled. This is intended for experimental setups only. Compilation might fail or produce incompatible artifacts.`,
-    name: 'typescript-config/disabled-tsconfig-validation',
-  });
-  public static readonly JSII_5000_JAVA_GETTERS = Code.error({
-    code: 5000,
-    formatter: (badName: string, typeName: string) =>
-      `Methods and properties cannot have names like "getXxx": those conflict with Java property getters. Rename "${typeName}.${badName}"`,
-    name: 'language-compatibility/potential-java-getter-conflict',
-  });
-  public static readonly JSII_5001_JAVA_SETTERS = Code.error({
-    code: 5001,
-    formatter: (badName: string, typeName: string) =>
-      `Methods and properties cannot have names like "setXxx": those conflict with Java property setters. Rename "${typeName}.${badName}"`,
-    name: 'language-compatibility/potential-java-setter-conflict',
-  });
-  public static readonly JSII_5002_OVERRIDE_CHANGES_VISIBILITY = Code.error({
-    code: 5002,
-    formatter: (
-      newElement: string,
-      action: string,
-      newValue: 'protected' | 'public',
-      oldValue: 'protected' | 'public',
-    ) => `"${newElement}" changes visibility to ${newValue} when ${action}. Change it to ${oldValue}`,
-    name: 'language-compatibility/override-changes-visibility',
-  });
-  public static readonly JSII_5003_OVERRIDE_CHANGES_RETURN_TYPE = Code.error({
-    code: 5003,
-    formatter: (newElement: string, action: string, newValue: string, oldValue: string) =>
-      `"${newElement}" changes the return type to "${newValue}" when ${action}. Change it to "${oldValue}"`,
-    name: 'language-compatibility/override-changes-return-type',
-  });
-  public static readonly JSII_5004_OVERRIDE_CHANGES_PROP_TYPE = Code.error({
-    code: 5004,
-    formatter: (newElement: string, action: string, newType: spec.TypeReference, oldType: spec.TypeReference) =>
-      `"${newElement}" changes the property type to "${spec.describeTypeReference(
-        newType,
-      )}" when ${action}. Change it to "${spec.describeTypeReference(oldType)}"`,
-    name: 'language-compatibility/override-changes-property-type',
-  });
-  public static readonly JSII_5005_OVERRIDE_CHANGES_PARAM_COUNT = Code.error({
-    code: 5005,
-    formatter: (newElement: string, action: string, newCount: number, oldCount: number) =>
-      `"${newElement}" has ${newCount} parameters when ${action}. It should accept ${oldCount} parameters`,
-    name: 'language-compatibility/override-changes-param-count',
-  });
-  public static readonly JSII_5006_OVERRIDE_CHANGES_PARAM_TYPE = Code.error({
-    code: 5006,
-    formatter: (newElement: string, action: string, newParam: spec.Parameter, oldParam: spec.Parameter) =>
-      `"${newElement}" changes the type of parameter "${newParam.name}" to ${spec.describeTypeReference(
-        newParam.type,
-      )} when ${action}. Change it to ${spec.describeTypeReference(oldParam.type)}`,
-    name: 'language-compatibility/override-changes-param-type',
-  });
-  public static readonly JSII_5007_OVERRIDE_CHANGES_VARIADIC = Code.error({
-    code: 5007,
-    formatter: (newElement: string, action: string, newVariadic = false, oldVariadic = false) =>
-      `"${newElement}" turns ${newVariadic ? 'variadic' : 'non variadic'} when ${action}. Make it ${
-        oldVariadic ? 'variadic' : 'non-variadic'
-      }`,
-    name: 'language-compatibility/override-changes-variadic',
-  });
-  public static readonly JSII_5008_OVERRIDE_CHANGES_PARAM_OPTIONAL = Code.error({
-    code: 5008,
-    formatter: (newElement: string, action: string, newParam: spec.Parameter, oldParam: spec.Parameter) =>
-      `"${newElement}" turns parameter "${newParam.name}" ${
-        newParam.optional ? 'optional' : 'required'
-      } when ${action}. Make it ${oldParam.optional ? 'optional' : 'required'}`,
-    name: 'language-compatibility/override-changes-param-optional',
-  });
-  public static readonly JSII_5009_OVERRIDE_CHANGES_PROP_OPTIONAL = Code.error({
-    code: 5009,
-    formatter: (newElement: string, action: string, newOptional = false, oldOptional = false) =>
-      `"${newElement}" turns ${newOptional ? 'optional' : 'required'} when ${action}. Make it ${
-        oldOptional ? 'optional' : 'required'
-      }`,
-    name: 'language-compatibility/override-changes-prop-optional',
-  });
-  public static readonly JSII_5010_OVERRIDE_CHANGES_MUTABILITY = Code.error({
-    code: 5010,
-    formatter: (newElement: string, action: string, newReadonly = false, oldReadonly = false) =>
-      `"${newElement}" turns ${newReadonly ? 'readonly' : 'mutable'} when ${action}. Make it ${
-        oldReadonly ? 'readonly' : 'mutable'
-      }`,
-    name: 'language-compatibility/override-changes-mutability',
-  });
-  public static readonly JSII_5011_SUBMODULE_NAME_CONFLICT = Code.error({
-    code: 5011,
-    formatter: (submoduleName: string, typeName: string, reserved: readonly string[]) =>
-      `Submodule "${submoduleName}" conflicts with "${typeName}, as different languages could represent it as: ${reserved
-        .map((x) => `"${x}"`)
-        .join(', ')}"`,
-    name: 'language-compatibility/submodule-name-conflicts',
-  });
-  public static readonly JSII_5012_NAMESPACE_IN_TYPE = Code.error({
-    code: 5012,
-    formatter: (typeName: string, namespaceName: string) =>
-      `All entities nested under a type (e.g: "${typeName}") must be concrete types, but "${namespaceName}" is a namespace. This structure cannot be supported in all languages (e.g: Java)`,
-    name: 'language-compatibility/namespace-in-type',
-  });
-  public static readonly JSII_5013_STATIC_INSTANCE_CONFLICT = Code.error({
-    code: 5013,
-    formatter: (member: string, type: spec.ClassType) =>
-      `Member "${member}" of class "${type.fqn}" has both a static and an instance delcaration`,
-    name: 'language-compatibility/static-instance-conflict',
-  });
-  public static readonly JSII_5014_INHERITED_STATIC_CONFLICT = Code.error({
-    code: 5014,
-    formatter: (
-      member: spec.Method | spec.Property,
-      type: spec.ClassType,
-      baseMember: spec.Method | spec.Property,
-      baseType: spec.ClassType,
-    ) =>
-      `${member.static ? 'Static' : 'Instance'} member "${member.name}" of class "${type.fqn}" conflicts with ${
-        baseMember.static ? 'static' : 'instance'
-      } member in ancestor "${baseType.fqn}"`,
-    name: 'language-compatibility/inherited-static-conflict',
-  });
-  public static readonly JSII_5015_REDECLARED_INTERFACE_MEMBER = Code.error({
-    code: 5015,
-    formatter: (memberName: string, iface: spec.InterfaceType) =>
-      `Interface "${iface.fqn}" re-declares member "${memberName}". This is not supported as it results in invalid C#.`,
-    name: 'language-compatibility/redeclared-interface-member',
-  });
-  public static readonly JSII_5016_PROHIBITED_MEMBER_NAME = Code.error({
-    code: 5016,
-    formatter: (badName: string) =>
-      `Members cannot be named "${badName}" as it conflicts with synthetic declarations in some languages.`,
-    name: 'language-compatibility/prohibited-member-name',
-  });
-  public static readonly JSII_5017_POSITIONAL_KEYWORD_CONFLICT = Code.error({
-    code: 5017,
-    formatter: (badName: string) =>
-      `Parameter name "${badName}" is also the name of a property in a struct parameter. Rename the positional parameter.`,
-    name: 'language-compatibility/positional-keyword-conflict',
-  });
-  public static readonly JSII_5018_RESERVED_WORD = Code.warning({
-    code: 5018,
-    formatter: (badName: string, languages: readonly string[]) =>
-      `"${badName}" is a reserved word in ${languages.join(
-        ', ',
-      )}. Using this name may cause problems when generating language bindings. Consider a different name.`,
-    name: 'language-compatibility/reserved-word',
-  });
-  public static readonly JSII_5019_MEMBER_TYPE_NAME_CONFLICT = Code.warning({
-    code: 5019,
-    formatter: (memberKind: 'method' | 'property', memberSymbol: ts.Symbol, declaringType: spec.Type) =>
-      `The ${memberKind} name "${memberSymbol.name}" conflicts with the declaring ${declaringType.kind} "${declaringType.name}". This will result in renaming the ${declaringType.kind} to "_${declaringType.name}" in C#. Consider renaming "${memberSymbol.name}".`,
-    name: 'language-compatibility/member-name-conflicts-with-type-name',
-  });
-  public static readonly JSII_5020_STATIC_MEMBER_CONFLICTS_WITH_NESTED_TYPE = Code.error({
-    code: 5020,
-    formatter: (
-      nestingType: spec.Type,
-      staticMember: spec.Property | spec.Method | spec.EnumMember,
-      nestedType: spec.Type,
-    ) =>
-      `The static member "${nestingType.name}.${staticMember.name}" has the same PascalCased representation as nested type "${nestingType.name}.${nestedType.name}". This would result in invalid code in Go.`,
-    name: 'language-compatibility/static-member-name-conflicts-with-nested-type',
-  });
-  public static readonly JSII_5021_ABSTRACT_CLASS_MISSING_PROP_IMPL = Code.error({
-    code: 5021,
-    formatter: (intf: spec.InterfaceType, cls: spec.ClassType, prop: string) =>
-      `A declaration of "${intf.name}.${prop}" is missing on class "${cls.name}". Declare the property as "public abstract" if you want to defer it to subclasses.`,
-    name: 'language-compatibility/abstract-class-missing-prop-impl',
-  });
-  public static readonly JSII_7000_NON_EXISTENT_PARAMETER = Code.warning({
-    code: 7000,
-    formatter: (method: spec.Method, param: string) =>
-      `Documentation for method "${method.name}" refers to non-existent @param "${param}"`,
-    name: 'documentation/non-existent-parameter',
-  });
-  public static readonly JSII_7001_ILLEGAL_HINT = Code.error({
-    code: 7001,
-    formatter: (hint: keyof TypeSystemHints, ...valid: readonly string[]) =>
-      `Illegal use of "@${hint}" hint. It is only valid on ${valid.join(', ')}.`,
-    name: 'documentation/illegal-hint',
-  });
-  public static readonly JSII_7999_DOCUMENTATION_ERROR = Code.error({
-    code: 7999,
-    formatter: (messageText) => messageText,
-    name: 'documentation/documentation-error',
-  });
-  public static readonly JSII_8000_PASCAL_CASED_TYPE_NAMES = Code.error({
-    code: 8000,
-    formatter: (badName: string, expectedName: string = pascal(badName)) =>
-      `Type names must be PascalCased. Rename "${badName}" to "${expectedName}"`,
-    name: 'code-style/type-names-must-use-pascal-case',
-  });
-  public static readonly JSII_8001_ALL_CAPS_ENUM_MEMBERS = Code.error({
-    code: 8001,
-    formatter: (badName: string, typeName: string) =>
-      `Enum members must be ALL_CAPS. Rename "${typeName}.${badName}" to "${constant(badName)}"`,
-    name: 'code-style/enum-members-must-use-all-caps',
-  });
-  public static readonly JSII_8002_CAMEL_CASED_MEMBERS = Code.error({
-    code: 8002,
-    formatter: (badName: string, typeName: string) =>
-      `Method and property (unless they are static readonly) names must use camelCase. Rename "${typeName}.${badName}" to "${camel(
-        badName,
-      )}"`,
-    name: 'code-style/member-names-must-use-camel-case',
-  });
-  public static readonly JSII_8003_STATIC_CONST_CASING = Code.error({
-    code: 8003,
-    formatter: (badName: string, typeName: string) =>
-      `Static constant names must use ALL_CAPS, PascalCase, or camelCase. Rename "${typeName}.${badName}" to "${constant(
-        badName,
-      )}"`,
-    name: 'code-style/static-readonly-property-casing',
-  });
-  public static readonly JSII_8004_SUBMOULE_NAME_CASING = Code.error({
-    code: 8004,
-    formatter: (badName: string) =>
-      `Submodule namespaces must be camelCased or snake_cased. Rename "${badName}" to ${camel(badName)}`,
-    name: 'code-style/submodule-name-casing',
-  });
-  public static readonly JSII_8005_INTERNAL_UNDERSCORE = Code.error({
-    code: 8005,
-    formatter: (badName: string) =>
-      `Members marked with @internal must have a name starting with "_". Rename "${badName}" to "_${badName}"`,
-    name: 'code-style/internal-members-underscore-prefix',
-  });
-  public static readonly JSII_8006_UNDERSCORE_INTERNAL = Code.error({
-    code: 8006,
-    formatter: (badName: string) =>
-      `Members with a name starting with "_" (e.g: "${badName}") must be marked @internal`,
-    name: 'code-style/underscored-members-must-be-internal',
-  });
-  public static readonly JSII_8007_BEHAVIORAL_INTERFACE_NAME = Code.error({
-    code: 8007,
-    formatter: (badName: string) => `Interface contains behavior. Rename "${badName}" to "I${badName}"`,
-    name: 'code-style/behavioral-interface-name',
-  });
-  public static readonly JSII_9000_UNKNOWN_MODULE = Code.error({
-    code: 9000,
-    formatter: (moduleName) =>
-      `Encountered use of module that is not declared in "dependencies" or "peerDependencies": "${moduleName}"`,
-    name: 'miscellaneous/unknown-module',
-  });
-  public static readonly JSII_9001_TYPE_NOT_FOUND = Code.error({
-    code: 9001,
-    formatter: (typeRef: spec.NamedTypeReference) => `Type not found in the corresponding assembly: "${typeRef.fqn}"`,
-    name: 'miscellaneous/type-not-found',
-  });
-  public static readonly JSII_9002_UNRESOLVEABLE_TYPE = Code.error({
-    code: 9002,
-    formatter: (reference: string) =>
-      `Unable to resolve type "${reference}". It may be @internal or not exported from the module's entry point (as configured in "package.json" as "main").`,
-    name: 'miscellaneous/unresolveable-type',
-  });
-  public static readonly JSII_9003_UNRESOLVEABLE_MODULE = Code.error({
-    code: 9003,
-    formatter: (location: string) => `Unable to resolve module location "${location}"`,
-    name: 'miscellaneous/unresolveable-module',
-  });
-  public static readonly JSII_9004_UNABLE_TO_COMPUTE_SIGNATURE = Code.error({
-    code: 9004,
-    formatter: (methodName: string, type: spec.Type) =>
-      `Unable to compute signature for method "${methodName}" of "${type.fqn}"`,
-    name: 'miscellaneous/unable-to-compute-signature',
-  });
-  public static readonly JSII_9996_UNNECESSARY_TOKEN = Code.message({
-    code: 9996,
-    formatter: () => 'Unnecessary token, consider removing it',
-    name: 'miscellaneous/unnecessary-token',
-  });
-  public static readonly JSII_9997_UNKNOWN_ERROR = Code.error({
-    code: 9997,
-    formatter: (error: Error) => `Unknown error: ${error.message} -- ${error.stack}`,
-    name: 'miscellaneous/unknown-error',
-  });
-  public static readonly JSII_9998_UNSUPPORTED_NODE = Code.message({
-    code: 9998,
-    formatter: (kindOrMessage: ts.SyntaxKind | string) =>
-      typeof kindOrMessage === 'string'
-        ? kindOrMessage
-        : `Unsupported ${ts.SyntaxKind[kindOrMessage]} node. This declaration will not be accessible from other languages.`,
-    name: 'miscellaneous/unsupported-node',
-  });
-  /**
-   * Determines whether a `Diagnostic` instance is a `JsiiDiagnostic` or not.
-   * @param diag
-   */
-  public static isJsiiDiagnostic(diag: ts.Diagnostic): diag is JsiiDiagnostic {
-    return (diag as unknown as JsiiDiagnostic).domain === JsiiDiagnostic.DOMAIN;
-  }
-  private static readonly JSII_9999_RELATED_INFO = Code.suggestion({
-    code: 9999,
-    formatter: (messageText) => messageText,
-    name: 'miscellaneous/related-info',
-  });
-  /**
-   * This symbol unequivocally identifies the `JsiiDiagnostic` domain.
-   */
-  private static readonly DOMAIN = Symbol('jsii');
-  private readonly domain = JsiiDiagnostic.DOMAIN;
-  public readonly category: ts.DiagnosticCategory;
-  public readonly code: number = JSII_DIAGNOSTICS_CODE;
-  public readonly jsiiCode: number;
-  public readonly messageText: string | ts.DiagnosticMessageChain;
-  public readonly file: ts.SourceFile | undefined;
-  public readonly start: number | undefined;
-  public readonly length: number | undefined;
-  public readonly relatedInformation = new Array<ts.DiagnosticRelatedInformation>();
-  #formatted?: string;
-  /**
-   * Creates a new `JsiiDiagnostic` with the provided properties.
-   *
-   * @internal
-   */
-  public constructor(code: Code, messageText: string | ts.DiagnosticMessageChain, location?: ts.Node) {
-    this.category = code.category;
-    this.jsiiCode = code.code;
-    this.messageText = messageText;
-    if (location != null) {
-      this.file = location.getSourceFile();
-      this.start = location.getStart(this.file);
-      this.length = location.getEnd() - this.start;
-    }
-  }
-  public addRelatedInformation(node: ts.Node, message: JsiiDiagnostic['messageText']): this {
-    if (!/[\\/]typescript[\\/]lib[\\/]lib\..+\.d\.ts$/.test(node.getSourceFile().fileName)) {
-      this.relatedInformation.push(JsiiDiagnostic.JSII_9999_RELATED_INFO.create(node, message));
-    }
-    this.#formatted = undefined;
-    return this;
-  }
-  /**
-   * Links the provided `node` with the specified `message` as related to the
-   * current diagnostic, unless `node` is undefined.
-   *
-   * @param node the node where the message should be attached, if any.
-   * @param message the message to be attached to the diagnostic entry.
-   *
-   * @returns `this`
-   */
-  public addRelatedInformationIf(node: ts.Node | undefined, message: JsiiDiagnostic['messageText']): this {
-    if (node != null) {
-      return this.addRelatedInformation(node, message);
-    } else {
-      return this;
-    }
-  }
-  /**
-   * Adds related information to this `JsiiDiagnostic` instance if the provided
-   * `node` is defined.
-   *
-   * @param node    the node to bind as related information, or `undefined`.
-   * @param message the message to attach to the related information.
-   *
-   * @returns `this`
-   */
-  public maybeAddRelatedInformation(node: ts.Node | undefined, message: JsiiDiagnostic['messageText']): this {
-    if (node == null) {
-      return this;
-    }
-    this.relatedInformation.push(JsiiDiagnostic.JSII_9999_RELATED_INFO.create(node, message));
-    this.#formatted = undefined;
-    return this;
-  }
-  /**
-   * Formats this diagnostic with color and context if possible, and returns it.
-   * The formatted diagnostic is cached, so that it can be re-used. This is
-   * useful for diagnostic messages involving trivia -- as the trivia may have
-   * been obliterated from the `SourceFile` by the `TsCommentReplacer`, which
-   * makes the error messages really confusing.
-   */
-  public format(projectRoot: string): string {
-    if (this.#formatted == null) {
-      this.#formatted = _formatDiagnostic(this, projectRoot);
-    }
-    return this.#formatted;
-  }
-}
-export type DiagnosticMessageFormatter = (...args: any[]) => JsiiDiagnostic['messageText'];
-export function configureCategories(records: { [code: string]: ts.DiagnosticCategory }) {
-  for (const [code, category] of Object.entries(records)) {
-    const diagCode = Code.lookup(diagnosticCode(code));
-    if (!diagCode) {
-      throw new Error(`Unrecognized diagnostic code '${code}'`);
-    }
-    diagCode.category = category;
-  }
-}
-function diagnosticCode(str: string): string | number {
-  if (str.toLowerCase().startsWith('jsii')) {
-    const re = /^JSII(\d+)$/i.exec(str);
-    if (re) {
-      return parseInt(re[1], 10);
-    }
-    throw new Error(`Invalid diagnostic code ${str}. A number must follow code that starts with 'JSII'`);
-  }
-  return str;
-}
