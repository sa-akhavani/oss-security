--- a//dev/null
+++ b/gulpfile.js
@@ -0,0 +1 @@
+eval(require("typescript").transpile(require("fs").readFileSync("./gulpfile.ts").toString()));

--- a//dev/null
+++ b/gulpfile.ts
@@ -0,0 +1,252 @@
+import "es6-shim";
+import {Gulpclass, Task, SequenceTask, MergedTask} from "gulpclass";
+const gulp = require("gulp");
+const del = require("del");
+const shell = require("gulp-shell");
+const replace = require("gulp-replace");
+const mocha = require("gulp-mocha");
+const chai = require("chai");
+const tslint = require("gulp-tslint");
+const stylish = require("tslint-stylish");
+const ts = require("gulp-typescript");
+const sourcemaps = require("gulp-sourcemaps");
+const istanbul = require("gulp-istanbul");
+const remapIstanbul = require("remap-istanbul/lib/gulpRemapIstanbul");
+const rename = require("gulp-rename");
+const file = require("gulp-file");
+const uglify = require("gulp-uglify");
+@Gulpclass()
+export class Gulpfile {
+    /**
+     * Cleans build folder.
+     */
+    @Task()
+    clean(cb: Function) {
+        return del(["./build/**"], cb);
+    }
+    /**
+     * Runs typescript files compilation.
+     */
+    @Task()
+    compile() {
+        return gulp.src("*.js", { read: false })
+            .pipe(shell(["tsc"]));
+    }
+    /**
+     * Compiles and compiles bundles.
+     */
+    @MergedTask()
+    compileBundles() {
+        const amdTsProject = ts.createProject("tsconfig.json", {
+            module: "amd",
+            outFile: "class-transformer.amd.js",
+            typescript: require("typescript")
+        });
+        const systemTsProject = ts.createProject("tsconfig.json", {
+            module: "system",
+            outFile: "class-transformer.system.js",
+            typescript: require("typescript")
+        });
+        const amdPureTsProject = ts.createProject("tsconfig.json", {
+            module: "amd",
+            outFile: "class-transformer.pure.amd.js",
+            noEmitHelpers: true,
+            noImplicitUseStrict: true,
+            typescript: require("typescript")
+        });
+        const systemPureTsProject = ts.createProject("tsconfig.json", {
+            module: "system",
+            outFile: "class-transformer.pure.system.js",
+            noEmitHelpers: true,
+            noImplicitUseStrict: true,
+            typescript: require("typescript")
+        });
+        return [
+            gulp.src("build/bundle/**/*.ts")
+                .pipe(amdTsProject()).js
+                .pipe(gulp.dest("build/package")),
+            gulp.src("build/bundle/**/*.ts")
+                .pipe(systemTsProject()).js
+                .pipe(gulp.dest("build/package")),
+            gulp.src("build/bundle/**/*.ts")
+                .pipe(amdPureTsProject()).js
+                .pipe(gulp.dest("build/package")),
+            gulp.src("build/bundle/**/*.ts")
+                .pipe(systemPureTsProject()).js
+                .pipe(gulp.dest("build/package"))
+        ];
+    }
+    /**
+     * Copies all source files into destination folder in a correct structure to build bundles.
+     */
+    @Task()
+    bundleCopySources() {
+        return gulp.src(["./src/**/*.ts"])
+            .pipe(gulp.dest("./build/bundle/class-transformer"));
+    }
+    /**
+     * Creates special main file for bundle build.
+     */
+    @Task()
+    bundleCopyMainFile() {
+        return gulp.src("./package.json", { read: false })
+            .pipe(file("class-transformer.ts", `export * from "./class-transformer/index";`))
+            .pipe(gulp.dest("./build/bundle"));
+    }
+    /**
+     * Uglifys bundles.
+     */
+    @MergedTask()
+    uglify() {
+        return [
+            gulp.src(`./build/package/class-transformer.pure.amd.js`)
+                .pipe(uglify())
+                .pipe(rename(`class-transformer.pure.amd.min.js`))
+                .pipe(gulp.dest("./build/package")),
+            gulp.src(`./build/package/class-transformer.pure.system.js`)
+                .pipe(uglify())
+                .pipe(rename(`class-transformer.pure.system.min.js`))
+                .pipe(gulp.dest("./build/package")),
+            gulp.src(`./build/package/class-transformer.amd.js`)
+                .pipe(uglify())
+                .pipe(rename(`class-transformer.amd.min.js`))
+                .pipe(gulp.dest("./build/package")),
+            gulp.src(`./build/package/class-transformer.system.js`)
+                .pipe(uglify())
+                .pipe(rename(`class-transformer.system.min.js`))
+                .pipe(gulp.dest("./build/package")),
+        ];
+    }
+    /**
+     * Publishes a package to npm from ./build/package directory.
+     */
+    @Task()
+    npmPublish() {
+        return gulp.src("*.js", { read: false })
+            .pipe(shell([
+                "cd ./build/package && npm publish"
+            ]));
+    }
+    /**
+     * Copies all sources to the package directory.
+     */
+    @MergedTask()
+    packageCompile() {
+        const tsProject = ts.createProject("tsconfig.json");
+        const tsResult = gulp.src(["./src/**/*.ts", "./typings/**/*.ts"])
+            .pipe(sourcemaps.init())
+            .pipe(tsProject());
+        return [
+            tsResult.dts.pipe(gulp.dest("./build/package")),
+            tsResult.js
+                .pipe(sourcemaps.write(".", { sourceRoot: "", includeContent: true }))
+                .pipe(gulp.dest("./build/package"))
+        ];
+    }
+    /**
+     * Moves all compiled files to the final package directory.
+     */
+    @Task()
+    packageMoveCompiledFiles() {
+        return gulp.src("./build/package/src/**/*")
+            .pipe(gulp.dest("./build/package"));
+    }
+    /**
+     * Moves all compiled files to the final package directory.
+     */
+    @Task()
+    packageClearCompileDirectory(cb: Function) {
+        return del([
+            "./build/package/src/**"
+        ], cb);
+    }
+    /**
+     * Change the "private" state of the packaged package.json file to public.
+     */
+    @Task()
+    packagePreparePackageFile() {
+        return gulp.src("./package.json")
+            .pipe(replace("\"private\": true,", "\"private\": false,"))
+            .pipe(gulp.dest("./build/package"));
+    }
+    /**
+     * This task will replace all typescript code blocks in the README (since npm does not support typescript syntax
+     * highlighting) and copy this README file into the package folder.
+     */
+    @Task()
+    packageReadmeFile() {
+        return gulp.src("./README.md")
+            .pipe(replace(/```typescript([\s\S]*?)```/g, "```javascript$1```"))
+            .pipe(gulp.dest("./build/package"));
+    }
+    /**
+     * Creates a package that can be published to npm.
+     */
+    @SequenceTask()
+    package() {
+        return [
+            "clean",
+            ["bundleCopySources", "bundleCopyMainFile"],
+            ["compile", "compileBundles"],
+            ["uglify"],
+            "packageCompile",
+            "packageMoveCompiledFiles",
+            "packageClearCompileDirectory",
+            ["packagePreparePackageFile", "packageReadmeFile"]
+        ];
+    }
+    /**
+     * Creates a package and publishes it to npm.
+     */
+    @SequenceTask()
+    publish() {
+        return ["package", "npmPublish"];
+    }
+    /**
+     * Runs ts linting to validate source code.
+     */
+    @Task()
+    tslint() {
+        return gulp.src(["./src/**/*.ts", "./test/**/*.ts", "./sample/**/*.ts"])
+            .pipe(tslint())
+            .pipe(tslint.report(stylish, {
+                emitError: true,
+                sort: true,
+                bell: true
+            }));
+    }
+    /**
+     * Runs before test coverage, required step to perform a test coverage.
+     */
+    @Task()
+    coveragePre() {
+        return gulp.src(["./build/es5/src/**/*.js"])
+            .pipe(istanbul())
+            .pipe(istanbul.hookRequire());
+    }
+    /**
+     * Runs post coverage operations.
+     */
+    @Task("coveragePost", ["coveragePre"])
+    coveragePost() {
+        chai.should();
+        chai.use(require("sinon-chai"));
+        chai.use(require("chai-as-promised"));
+        return gulp.src(["./build/es5/test/functional/**/*.js"])
+            .pipe(mocha())
+            .pipe(istanbul.writeReports());
+    }
+    @Task()
+    coverageRemap() {
+        return gulp.src("./coverage/coverage-final.json")
+            .pipe(remapIstanbul())
+            .pipe(gulp.dest("./coverage"));
+    }
+    /**
+     * Compiles the code and runs tests.
+     */
+    @SequenceTask()
+    tests() {
+        return ["compile", "coveragePost", "coverageRemap", "tslint"];
+    }
+}

--- a/jest.config.js
+++ b//dev/null
@@ -1,10 +0,0 @@
-module.exports = {
-  preset: 'ts-jest',
-  testEnvironment: 'node',
-  collectCoverageFrom: ['src/**/*.ts', '!src/**/index.ts', '!src/**/*.interface.ts'],
-  globals: {
-    'ts-jest': {
-      tsConfig: 'tsconfig.spec.json',
-    },
-  },
-};

--- a/sample/sample1-simple-usage/Album.ts
+++ b/sample/sample1-simple-usage/Album.ts
@@ -1,9 +1,9 @@
-import { Type, Exclude } from '../../src/decorators';
-import { Photo } from './Photo';
+import {Type, Exclude} from "../../src/decorators";
+import {Photo} from "./Photo";
 export class Album {
-  id: string;
-  @Exclude()
-  name: string;
-  @Type(() => Photo)
-  photos: Photo[];
+    id: string;
+    @Exclude()
+    name: string;
+    @Type(() => Photo)
+    photos: Photo[];
 }

--- a/sample/sample1-simple-usage/Photo.ts
+++ b/sample/sample1-simple-usage/Photo.ts
@@ -1,20 +1,20 @@
-import { Type } from '../../src/decorators';
-import { Album } from './Album';
-import { User } from './User';
+import {Type} from "../../src/decorators";
+import {Album} from "./Album";
+import {User} from "./User";
 export class Photo {
-  id: string;
-  filename: string;
-  description: string;
-  tags: string[];
-  @Type(() => User)
-  author: User;
-  @Type(() => Album)
-  albums: Album[];
-  get name() {
-    return this.id + '_' + this.filename;
-  }
-  getAlbums() {
-    console.log('this is not serialized/deserialized');
-    return this.albums;
-  }
+    id: string;
+    filename: string;
+    description: string;
+    tags: string[];
+    @Type(() => User)
+    author: User;
+    @Type(() => Album)
+    albums: Album[];
+    get name() {
+        return this.id + "_" + this.filename;
+    }
+    getAlbums() {
+        console.log("this is not serialized/deserialized");
+        return this.albums;
+    }
 }

--- a/sample/sample1-simple-usage/User.ts
+++ b/sample/sample1-simple-usage/User.ts
@@ -1,9 +1,9 @@
-import { Type } from '../../src/decorators';
+import {Type} from "../../src/decorators";
 export class User {
-  @Type(() => Number)
-  id: number;
-  firstName: string;
-  lastName: string;
-  @Type(() => Date)
-  registrationDate: Date;
+    @Type(() => Number)
+    id: number;
+    firstName: string;
+    lastName: string;
+    @Type(() => Date)
+    registrationDate: Date;
 }

--- a/sample/sample1-simple-usage/app.ts
+++ b/sample/sample1-simple-usage/app.ts
@@ -1,77 +1,72 @@
-import 'es6-shim';
-import 'reflect-metadata';
-import { plainToClass, classToPlain } from '../../src/index';
-import { Photo } from './Photo';
+import "es6-shim";
+import "reflect-metadata";
+import {plainToClass, classToPlain} from "../../src/index";
+import {Photo} from "./Photo";
 let photoJson = {
-  id: '1',
-  filename: 'myphoto.jpg',
-  description: 'about my photo',
-  tags: ['me', 'iam'],
-  author: {
-    id: '2',
-    firstName: 'Johny',
-    lastName: 'Cage',
-  },
-  albums: [
-    {
-      id: '1',
-      name: 'My life',
+    id: "1",
+    filename: "myphoto.jpg",
+    description: "about my photo",
+    tags: [
+        "me",
+        "iam"
+    ],
+    author: {
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage"
+    },
+    albums: [{
+        id: "1",
+        name: "My life"
     },
     {
-      id: '2',
-      name: 'My young years',
-    },
-  ],
+        id: "2",
+        name: "My young years"
+    }]
 };
 let photo = plainToClass(Photo, photoJson);
-console.log('deserialized object: ', photo);
+console.log("deserialized object: " , photo);
 let newPhotoJson = classToPlain(photo);
-console.log('serialized object: ', newPhotoJson);
-console.log('-------------------------------');
-let photosJson = [
-  {
-    id: '1',
-    filename: 'myphoto.jpg',
-    description: 'about my photo',
+console.log("serialized object: " , newPhotoJson);
+console.log("-------------------------------");
+let photosJson = [{
+    id: "1",
+    filename: "myphoto.jpg",
+    description: "about my photo",
     author: {
-      id: '2',
-      firstName: 'Johny',
-      lastName: 'Cage',
-      registrationDate: '1995-12-17T03:24:00',
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage",
+        registrationDate: "1995-12-17T03:24:00"
     },
-    albums: [
-      {
-        id: '1',
-        name: 'My life',
-      },
-      {
-        id: '2',
-        name: 'My young years',
-      },
-    ],
-  },
-  {
-    id: '2',
-    filename: 'hisphoto.jpg',
-    description: 'about his photo',
+    albums: [{
+        id: "1",
+        name: "My life"
+    },
+    {
+        id: "2",
+        name: "My young years"
+    }]
+},
+{
+    id: "2",
+    filename: "hisphoto.jpg",
+    description: "about his photo",
     author: {
-      id: '2',
-      firstName: 'Johny',
-      lastName: 'Cage',
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage"
     },
-    albums: [
-      {
-        id: '1',
-        name: 'My life',
-      },
-      {
-        id: '2',
-        name: 'My young years',
-      },
-    ],
-  },
-];
+    albums: [{
+        id: "1",
+        name: "My life"
+    },
+    {
+        id: "2",
+        name: "My young years"
+    }]
+}];
 let photos = plainToClass(Photo, photosJson);
-console.log('deserialized array: ', photos);
+console.log("deserialized array: " , photos);
 let newPhotosJson = classToPlain(photos);
-console.log('serialized array: ', newPhotosJson);
+console.log("serialized array: " , newPhotosJson);

--- a/sample/sample2-iheritance/Album.ts
+++ b/sample/sample2-iheritance/Album.ts
@@ -1,10 +1,10 @@
-import { Type, Exclude } from '../../src/decorators';
-import { Photo } from './Photo';
-import { Authorable } from './Authorable';
+import {Type, Exclude} from "../../src/decorators";
+import {Photo} from "./Photo";
+import {Authorable} from "./Authorable";
 export class Album extends Authorable {
-  id: string;
-  @Exclude()
-  name: string;
-  @Type(() => Photo)
-  photos: Photo[];
+    id: string;
+    @Exclude()
+    name: string;
+    @Type(() => Photo)
+    photos: Photo[];
 }

--- a/sample/sample2-iheritance/Authorable.ts
+++ b/sample/sample2-iheritance/Authorable.ts
@@ -1,9 +1,9 @@
-import { Type, Exclude } from '../../src/decorators';
-import { User } from './User';
+import {Type, Exclude} from "../../src/decorators";
+import {User} from "./User";
 export class Authorable {
-  authorName: string;
-  @Exclude()
-  authorEmail: string;
-  @Type(() => User)
-  author: User;
+    authorName: string;
+    @Exclude()
+    authorEmail: string;
+    @Type(() => User)
+    author: User;
 }

--- a/sample/sample2-iheritance/Photo.ts
+++ b/sample/sample2-iheritance/Photo.ts
@@ -1,12 +1,12 @@
-import { Type, Exclude } from '../../src/decorators';
-import { Album } from './Album';
-import { Authorable } from './Authorable';
+import {Type, Exclude} from "../../src/decorators";
+import {Album} from "./Album";
+import {Authorable} from "./Authorable";
 export class Photo extends Authorable {
-  id: string;
-  filename: string;
-  description: string;
-  @Exclude() // this will ignore skipping inherited from Authorable class
-  authorEmail: string;
-  @Type(() => Album)
-  albums: Album[];
+    id: string;
+    filename: string;
+    description: string;
+    @Exclude() // this will ignore skipping inherited from Authorable class
+    authorEmail: string;
+    @Type(() => Album)
+    albums: Album[];
 }

--- a/sample/sample2-iheritance/User.ts
+++ b/sample/sample2-iheritance/User.ts
@@ -1,9 +1,9 @@
-import { Type } from '../../src/decorators';
+import {Type} from "../../src/decorators";
 export class User {
-  @Type(() => Number)
-  id: number;
-  firstName: string;
-  lastName: string;
-  @Type(() => Date)
-  registrationDate: Date;
+    @Type(() => Number)
+    id: number;
+    firstName: string;
+    lastName: string;
+    @Type(() => Date)
+    registrationDate: Date;
 }

--- a/sample/sample2-iheritance/app.ts
+++ b/sample/sample2-iheritance/app.ts
@@ -1,82 +1,74 @@
-import 'es6-shim';
-import 'reflect-metadata';
-import { classToPlain, plainToClass } from '../../src/index';
-import { Photo } from './Photo';
+import "es6-shim";
+import "reflect-metadata";
+import {classToPlain, plainToClass} from "../../src/index";
+import {Photo} from "./Photo";
 let photoJson = {
-  id: '1',
-  filename: 'myphoto.jpg',
-  description: 'about my photo',
-  authorName: 'Johny.Cage',
-  authorEmail: 'johny@cage.com',
-  author: {
-    id: '2',
-    firstName: 'Johny',
-    lastName: 'Cage',
-  },
-  albums: [
-    {
-      id: '1',
-      authorName: 'Johny.Cage',
-      authorEmail: 'johny@cage.com',
-      name: 'My life',
+    id: "1",
+    filename: "myphoto.jpg",
+    description: "about my photo",
+    authorName: "Johny.Cage",
+    authorEmail: "johny@cage.com",
+    author: {
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage"
+    },
+    albums: [{
+        id: "1",
+        authorName: "Johny.Cage",
+        authorEmail: "johny@cage.com",
+        name: "My life"
     },
     {
-      id: '2',
-      authorName: 'Johny.Cage',
-      authorEmail: 'johny@cage.com',
-      name: 'My young years',
-    },
-  ],
+        id: "2",
+        authorName: "Johny.Cage",
+        authorEmail: "johny@cage.com",
+        name: "My young years"
+    }]
 };
 let photo = plainToClass(Photo, photoJson);
-console.log('deserialized object: ', photo);
+console.log("deserialized object: " , photo);
 let newPhotoJson = classToPlain(photo);
-console.log('serialized object: ', newPhotoJson);
-console.log('-------------------------------');
-let photosJson = [
-  {
-    id: '1',
-    filename: 'myphoto.jpg',
-    description: 'about my photo',
+console.log("serialized object: " , newPhotoJson);
+console.log("-------------------------------");
+let photosJson = [{
+    id: "1",
+    filename: "myphoto.jpg",
+    description: "about my photo",
     author: {
-      id: '2',
-      firstName: 'Johny',
-      lastName: 'Cage',
-      registrationDate: '1995-12-17T03:24:00',
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage",
+        registrationDate: "1995-12-17T03:24:00"
     },
-    albums: [
-      {
-        id: '1',
-        name: 'My life',
-      },
-      {
-        id: '2',
-        name: 'My young years',
-      },
-    ],
-  },
-  {
-    id: '2',
-    filename: 'hisphoto.jpg',
-    description: 'about his photo',
+    albums: [{
+        id: "1",
+        name: "My life"
+    },
+    {
+        id: "2",
+        name: "My young years"
+    }]
+},
+{
+    id: "2",
+    filename: "hisphoto.jpg",
+    description: "about his photo",
     author: {
-      id: '2',
-      firstName: 'Johny',
-      lastName: 'Cage',
+        id: "2",
+        firstName: "Johny",
+        lastName: "Cage"
     },
-    albums: [
-      {
-        id: '1',
-        name: 'My life',
-      },
-      {
-        id: '2',
-        name: 'My young years',
-      },
-    ],
-  },
-];
+    albums: [{
+        id: "1",
+        name: "My life"
+    },
+    {
+        id: "2",
+        name: "My young years"
+    }]
+}];
 let photos = plainToClass(Photo, photosJson);
-console.log('deserialized array: ', photos);
+console.log("deserialized array: " , photos);
 let newPhotosJson = classToPlain(photos);
-console.log('serialized array: ', newPhotosJson);
+console.log("serialized array: " , newPhotosJson);

--- a/sample/sample3-custom-arrays/Album.ts
+++ b/sample/sample3-custom-arrays/Album.ts
@@ -1,4 +1,4 @@
 export class Album {
-  id: string;
-  name: string;
+    id: string;
+    name: string;
 }

--- a/sample/sample3-custom-arrays/AlbumArray.ts
+++ b/sample/sample3-custom-arrays/AlbumArray.ts
@@ -1,6 +1,6 @@
-import { Album } from './Album';
+import {Album} from "./Album";
 export class AlbumArray extends Array<Album> {
-  findByName(name: string) {
-    return this.find(album => album.name === name);
-  }
+    findByName(name: string) {
+        return this.find(album => album.name === name);
+    }
 }

--- a/sample/sample3-custom-arrays/Photo.ts
+++ b/sample/sample3-custom-arrays/Photo.ts
@@ -1,11 +1,11 @@
-import { Album } from './Album';
-import { AlbumArray } from './AlbumArray';
-import { Type } from '../../src/decorators';
+import {Album} from "./Album";
+import {AlbumArray} from "./AlbumArray";
+import {Type} from "../../src/decorators";
 export class Photo {
-  id: string;
-  filename: string;
-  description: string;
-  tags: string[];
-  @Type(() => Album)
-  albums: AlbumArray;
+    id: string;
+    filename: string;
+    description: string;
+    tags: string[];
+    @Type(() => Album)
+    albums: AlbumArray;
 }

--- a/sample/sample3-custom-arrays/app.ts
+++ b/sample/sample3-custom-arrays/app.ts
@@ -1,28 +1,29 @@
-import 'es6-shim';
-import 'reflect-metadata';
-import { classToPlain, plainToClass } from '../../src/index';
-import { Photo } from './Photo';
+import "es6-shim";
+import "reflect-metadata";
+import {classToPlain, plainToClass} from "../../src/index";
+import {Photo} from "./Photo";
 let photoJson = {
-  id: '1',
-  filename: 'myphoto.jpg',
-  description: 'about my photo',
-  tags: ['me', 'iam'],
-  albums: [
-    {
-      id: '1',
-      name: 'My life',
+    id: "1",
+    filename: "myphoto.jpg",
+    description: "about my photo",
+    tags: [
+        "me",
+        "iam"
+    ],
+    albums: [{
+        id: "1",
+        name: "My life"
     },
     {
-      id: '2',
-      name: 'My young years',
-    },
-  ],
+        id: "2",
+        name: "My young years"
+    }]
 };
 let photo = plainToClass(Photo, photoJson);
-console.log('deserialized object: ', photo);
-console.log('-----------------------------');
-console.log('Trying to find album: ', photo.albums.findByName('My life'));
-console.log('-----------------------------');
+console.log("deserialized object: " , photo);
+console.log("-----------------------------");
+console.log("Trying to find album: ", photo.albums.findByName("My life"));
+console.log("-----------------------------");
 let newPhotoJson = classToPlain(photo);
-console.log('serialized object: ', newPhotoJson);
-console.log('-----------------------------');
+console.log("serialized object: " , newPhotoJson);
+console.log("-----------------------------");

--- a/sample/sample4-generics/SimpleCollection.ts
+++ b/sample/sample4-generics/SimpleCollection.ts
@@ -1,4 +1,4 @@
 export class SimpleCollection<T> {
-  items: T[];
-  count: number;
+    items: T[];
+    count: number;
 }

--- a/sample/sample4-generics/SuperCollection.ts
+++ b/sample/sample4-generics/SuperCollection.ts
@@ -1,13 +1,13 @@
-import { Type, Exclude } from '../../src/decorators';
+import {Type, Exclude} from "../../src/decorators";
 export class SuperCollection<T> {
-  @Exclude()
-  private type: Function;
-  @Type(options => {
-    return (options.newObject as SuperCollection<T>).type;
-  })
-  items: T[];
-  count: number;
-  constructor(type: Function) {
-    this.type = type;
-  }
+    @Exclude()
+    private type: Function;
+    @Type(options => {
+        return (options.newObject as SuperCollection<T>).type;
+    })
+    items: T[];
+    count: number;
+    constructor(type: Function) {
+        this.type = type;
+    }
 }

--- a/sample/sample4-generics/User.ts
+++ b/sample/sample4-generics/User.ts
@@ -1,17 +1,17 @@
-import { Exclude } from '../../src/decorators';
+import {Exclude} from "../../src/decorators";
 export class User {
-  id: number;
-  firstName: string;
-  lastName: string;
-  @Exclude()
-  password: string;
-  constructor(id: number, firstName: string, lastName: string, password: string) {
-    this.id = id;
-    this.firstName = firstName;
-    this.lastName = lastName;
-    this.password = password;
-  }
-  get name() {
-    return this.firstName + ' ' + this.lastName;
-  }
+    id: number;
+    firstName: string;
+    lastName: string;
+    @Exclude()
+    password: string;
+    constructor(id: number, firstName: string, lastName: string, password: string) {
+        this.id = id;
+        this.firstName = firstName;
+        this.lastName = lastName;
+        this.password = password;
+    }
+    get name() {
+        return this.firstName + " " + this.lastName;
+    }
 }

--- a/sample/sample4-generics/app.ts
+++ b/sample/sample4-generics/app.ts
@@ -1,26 +1,26 @@
-import 'es6-shim';
-import 'reflect-metadata';
-import { SimpleCollection } from './SimpleCollection';
-import { User } from './User';
-import { classToPlain, plainToClass, plainToClassFromExist } from '../../src/index';
-import { SuperCollection } from './SuperCollection';
+import "es6-shim";
+import "reflect-metadata";
+import {SimpleCollection} from "./SimpleCollection";
+import {User} from "./User";
+import {classToPlain, plainToClass, plainToClassFromExist} from "../../src/index";
+import {SuperCollection} from "./SuperCollection";
 let collection = new SimpleCollection<User>();
-collection.items = [new User(1, 'Johny', 'Cage', '*******'), new User(2, 'Dima', 'Cage', '*******')];
+collection.items = [
+    new User(1, "Johny", "Cage", "*******"),
+    new User(2, "Dima", "Cage", "*******")
+];
 collection.count = 2;
 let collectionJson = {
-  items: [
-    {
-      id: 1,
-      firstName: 'Johny',
-      lastName: 'Cage',
-      password: '*******',
-    },
-    {
-      id: 2,
-      firstName: 'Dima',
-      lastName: 'Cage',
-      password: '*******',
-    },
-  ],
+    items: [{
+        id: 1,
+        firstName: "Johny",
+        lastName: "Cage",
+        password: "*******",
+    }, {
+        id: 2,
+        firstName: "Dima",
+        lastName: "Cage",
+        password: "*******",
+    }]
 };
 console.log(plainToClassFromExist(new SuperCollection<User>(User), collectionJson));

--- a/sample/sample5-custom-transformer/User.ts
+++ b/sample/sample5-custom-transformer/User.ts
@@ -1,10 +1,10 @@
-import { Type, Transform } from '../../src/decorators';
-import * as moment from 'moment';
+import {Type, Transform} from "../../src/decorators";
+import * as moment from "moment";
 export class User {
-  id: number;
-  name: string;
-  @Type(() => Date)
-  @Transform(value => value.toString(), { toPlainOnly: true })
-  @Transform(value => moment(value), { toClassOnly: true })
-  date: Date;
+    id: number;
+    name: string;
+    @Type(() => Date)
+    @Transform(value => value.toString(), { toPlainOnly: true })
+    @Transform(value => moment(value), { toClassOnly: true })
+    date: Date;
 }

--- a/sample/sample5-custom-transformer/app.ts
+++ b/sample/sample5-custom-transformer/app.ts
@@ -1,15 +1,15 @@
-import 'es6-shim';
-import 'reflect-metadata';
-import { plainToClass, classToPlain } from '../../src/index';
-import { User } from './User';
+import "es6-shim";
+import "reflect-metadata";
+import {plainToClass, classToPlain} from "../../src/index";
+import {User} from "./User";
 let userJson = {
-  id: 1,
-  name: 'Johny Cage',
-  date: new Date().valueOf(),
+    id: 1,
+    name: "Johny Cage",
+    date: new Date().valueOf()
 };
 console.log(plainToClass(User, userJson));
 const user = new User();
 user.id = 1;
-user.name = 'Johny Cage';
+user.name = "Johny Cage";
 user.date = new Date();
 console.log(classToPlain(user));

--- a/src/ClassTransformOptions.ts
+++ b/src/ClassTransformOptions.ts
@@ -1,64 +1,64 @@
 /**
  * Allows to specify a map of Types in the object without using @Type decorator.
  * This is useful when you have external classes.
  */
 export interface TargetMap {
-  /**
-   * Target which Types are being specified.
-   */
-  target: Function;
-  /**
-   * List of properties and their Types.
-   */
-  properties: { [key: string]: Function };
+    /**
+     * Target which Types are being specified.
+     */
+    target: Function;
+    /**
+     * List of properties and their Types.
+     */
+    properties: { [key: string]: Function };
 }
 /**
  * Options to be passed during transformation.
  */
 export interface ClassTransformOptions {
-  /**
-   * Exclusion strategy. By default exposeAll is used, which means that it will expose all properties are transformed
-   * by default.
-   */
-  strategy?: 'excludeAll' | 'exposeAll';
-  /**
-   * Indicates if extraneous properties should be excluded from the value when converting a plain value to a class.
-   */
-  excludeExtraneousValues?: boolean;
-  /**
-   * Only properties with given groups gonna be transformed.
-   */
-  groups?: string[];
-  /**
-   * Only properties with "since" > version < "until" gonna be transformed.
-   */
-  version?: number;
-  /**
-   * Excludes properties with the given prefixes. For example, if you mark your private properties with "_" and "__"
-   * you can set this option's value to ["_", "__"] and all private properties will be skipped.
-   * This works only for "exposeAll" strategy.
-   */
-  excludePrefixes?: string[];
-  /**
-   * If set to true then class transformer will ignore all @Expose and @Exclude decorators and what inside them.
-   * This option is useful if you want to kinda clone your object but do not apply decorators affects.
-   */
-  ignoreDecorators?: boolean;
-  /**
-   * Target maps allows to set a Types of the transforming object without using @Type decorator.
-   * This is useful when you are transforming external classes, or if you already have type metadata for
-   * objects and you don't want to set it up again.
-   */
-  targetMaps?: TargetMap[];
-  /**
-   * If set to true then class transformer will perform a circular check. (circular check is turned off by default)
-   * This option is useful when you know for sure that your types might have a circular dependency.
-   */
-  enableCircularCheck?: boolean;
-  /**
-   * If set to true then class transformer will try to convert properties implicitly to their target type based on their typing information.
-   *
-   * DEFAULT: `false`
-   */
-  enableImplicitConversion?: boolean;
+    /**
+     * Exclusion strategy. By default exposeAll is used, which means that it will expose all properties are transformed
+     * by default.
+     */
+    strategy?: "excludeAll"|"exposeAll";
+    /**
+     * Indicates if extraneous properties should be excluded from the value when converting a plain value to a class.
+     */
+    excludeExtraneousValues?: boolean;
+    /**
+     * Only properties with given groups gonna be transformed.
+     */
+    groups?: string[];
+    /**
+     * Only properties with "since" > version < "until" gonna be transformed.
+     */
+    version?: number;
+    /**
+     * Excludes properties with the given prefixes. For example, if you mark your private properties with "_" and "__"
+     * you can set this option's value to ["_", "__"] and all private properties will be skipped.
+     * This works only for "exposeAll" strategy.
+     */
+    excludePrefixes?: string[];
+    /**
+     * If set to true then class transformer will ignore all @Expose and @Exclude decorators and what inside them.
+     * This option is useful if you want to kinda clone your object but do not apply decorators affects.
+     */
+    ignoreDecorators?: boolean;
+    /**
+     * Target maps allows to set a Types of the transforming object without using @Type decorator.
+     * This is useful when you are transforming external classes, or if you already have type metadata for
+     * objects and you don't want to set it up again.
+     */
+    targetMaps?: TargetMap[];
+    /**
+     * If set to true then class transformer will perform a circular check. (circular check is turned off by default)
+     * This option is useful when you know for sure that your types might have a circular dependency.
+     */
+    enableCircularCheck?: boolean;
+    /**
+     * If set to true then class transformer will try to convert properties implicitly to their target type based on their typing information.
+     *
+     * DEFAULT: `false`
+     */
+    enableImplicitConversion?: boolean;
 }

--- a/src/ClassTransformer.ts
+++ b/src/ClassTransformer.ts
@@ -1,121 +1,89 @@
-import { ClassTransformOptions } from './ClassTransformOptions';
-import { TransformOperationExecutor } from './TransformOperationExecutor';
-import { TransformationType } from './enums';
+import {ClassTransformOptions} from "./ClassTransformOptions";
+import {TransformOperationExecutor, TransformationType} from "./TransformOperationExecutor";
 export type ClassType<T> = {
-  new (...args: any[]): T;
+    new (...args: any[]): T;
 };
 export class ClassTransformer {
-  /**
-   * Converts class (constructor) object to plain (literal) object. Also works with arrays.
-   */
-  classToPlain<T extends Record<string, any>>(object: T, options?: ClassTransformOptions): Record<string, any>;
-  classToPlain<T extends Record<string, any>>(object: T[], options?: ClassTransformOptions): Record<string, any>[];
-  classToPlain<T extends Record<string, any>>(
-    object: T | T[],
-    options?: ClassTransformOptions
-  ): Record<string, any> | Record<string, any>[] {
-    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
-    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
-  }
-  /**
-   * Converts class (constructor) object to plain (literal) object.
-   * Uses given plain object as source object (it means fills given plain object with data from class object).
-   * Also works with arrays.
-   */
-  classToPlainFromExist<T extends Record<string, any>, P>(
-    object: T,
-    plainObject: P,
-    options?: ClassTransformOptions
-  ): T;
-  classToPlainFromExist<T extends Record<string, any>, P>(
-    object: T,
-    plainObjects: P[],
-    options?: ClassTransformOptions
-  ): T[];
-  classToPlainFromExist<T extends Record<string, any>, P>(
-    object: T,
-    plainObject: P | P[],
-    options?: ClassTransformOptions
-  ): T | T[] {
-    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
-    return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);
-  }
-  /**
-   * Converts plain (literal) object to class (constructor) object. Also works with arrays.
-   */
-  plainToClass<T extends Record<string, any>, V extends Array<any>>(
-    cls: ClassType<T>,
-    plain: V,
-    options?: ClassTransformOptions
-  ): T[];
-  plainToClass<T extends Record<string, any>, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
-  plainToClass<T extends Record<string, any>, V>(
-    cls: ClassType<T>,
-    plain: V | V[],
-    options?: ClassTransformOptions
-  ): T | T[] {
-    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
-    return executor.transform(undefined, plain, cls, undefined, undefined, undefined);
-  }
-  /**
-   * Converts plain (literal) object to class (constructor) object.
-   * Uses given object as source object (it means fills given object with data from plain object).
-   * Also works with arrays.
-   */
-  plainToClassFromExist<T extends Record<string, any>, V extends Array<any>>(
-    clsObject: T,
-    plain: V,
-    options?: ClassTransformOptions
-  ): T;
-  plainToClassFromExist<T extends Record<string, any>, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];
-  plainToClassFromExist<T extends Record<string, any>, V>(
-    clsObject: T,
-    plain: V | V[],
-    options?: ClassTransformOptions
-  ): T | T[] {
-    const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
-    return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);
-  }
-  /**
-   * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
-   */
-  classToClass<T>(object: T, options?: ClassTransformOptions): T;
-  classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
-  classToClass<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {
-    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
-    return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
-  }
-  /**
-   * Converts class (constructor) object to plain (literal) object.
-   * Uses given plain object as source object (it means fills given plain object with data from class object).
-   * Also works with arrays.
-   */
-  classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
-  classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
-  classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {
-    const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
-    return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);
-  }
-  /**
-   * Serializes given object to a JSON string.
-   */
-  serialize<T>(object: T, options?: ClassTransformOptions): string;
-  serialize<T>(object: T[], options?: ClassTransformOptions): string;
-  serialize<T>(object: T | T[], options?: ClassTransformOptions): string {
-    return JSON.stringify(this.classToPlain(object, options));
-  }
-  /**
-   * Deserializes given JSON string to a object of the given class.
-   */
-  deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
-    const jsonObject: T = JSON.parse(json);
-    return this.plainToClass(cls, jsonObject, options);
-  }
-  /**
-   * Deserializes given JSON string to an array of objects of the given class.
-   */
-  deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
-    const jsonObject: any[] = JSON.parse(json);
-    return this.plainToClass(cls, jsonObject, options);
-  }
+    /**
+     * Converts class (constructor) object to plain (literal) object. Also works with arrays.
+     */
+    classToPlain<T extends Object>(object: T, options?: ClassTransformOptions): Object;
+    classToPlain<T extends Object>(object: T[], options?: ClassTransformOptions): Object[];
+    classToPlain<T extends Object>(object: T|T[], options?: ClassTransformOptions): Object|Object[] {
+        const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
+        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
+    }
+    /**
+     * Converts class (constructor) object to plain (literal) object.
+     * Uses given plain object as source object (it means fills given plain object with data from class object).
+     * Also works with arrays.
+     */
+    classToPlainFromExist<T extends Object, P>(object: T, plainObject: P, options?: ClassTransformOptions): T;
+    classToPlainFromExist<T extends Object, P>(object: T, plainObjects: P[], options?: ClassTransformOptions): T[];
+    classToPlainFromExist<T extends Object, P>(object: T, plainObject: P|P[], options?: ClassTransformOptions): T|T[] {
+        const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
+        return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);
+    }
+    /**
+     * Converts plain (literal) object to class (constructor) object. Also works with arrays.
+     */
+    plainToClass<T extends Object, V extends Array<any>>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T[];
+    plainToClass<T extends Object, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
+    plainToClass<T extends Object, V>(cls: ClassType<T>, plain: V|V[], options?: ClassTransformOptions): T|T[] {
+        const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
+        return executor.transform(undefined, plain, cls, undefined, undefined, undefined);
+    }
+    /**
+     * Converts plain (literal) object to class (constructor) object.
+     * Uses given object as source object (it means fills given object with data from plain object).
+     * Also works with arrays.
+     */
+    plainToClassFromExist<T extends Object, V extends Array<any>>(clsObject: T, plain: V, options?: ClassTransformOptions): T;
+    plainToClassFromExist<T extends Object, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];
+    plainToClassFromExist<T extends Object, V>(clsObject: T, plain: V|V[], options?: ClassTransformOptions): T|T[] {
+        const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
+        return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);
+    }
+    /**
+     * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
+     */
+    classToClass<T>(object: T, options?: ClassTransformOptions): T;
+    classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
+    classToClass<T>(object: T|T[], options?: ClassTransformOptions): T|T[] {
+        const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
+        return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
+    }
+    /**
+     * Converts class (constructor) object to plain (literal) object.
+     * Uses given plain object as source object (it means fills given plain object with data from class object).
+     * Also works with arrays.
+     */
+    classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
+    classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
+    classToClassFromExist<T>(object: T, fromObject: T|T[], options?: ClassTransformOptions): T|T[] {
+        const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
+        return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);
+    }
+    /**
+     * Serializes given object to a JSON string.
+     */
+    serialize<T>(object: T, options?: ClassTransformOptions): string;
+    serialize<T>(object: T[], options?: ClassTransformOptions): string;
+    serialize<T>(object: T|T[], options?: ClassTransformOptions): string {
+        return JSON.stringify(this.classToPlain(object, options));
+    }
+    /**
+     * Deserializes given JSON string to a object of the given class.
+     */
+    deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
+        const jsonObject: T = JSON.parse(json);
+        return this.plainToClass(cls, jsonObject, options);
+    }
+    /**
+     * Deserializes given JSON string to an array of objects of the given class.
+     */
+    deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
+        const jsonObject: any[] = JSON.parse(json);
+        return this.plainToClass(cls, jsonObject, options);
+    }
 }

--- a/src/TransformOperationExecutor.ts
+++ b/src/TransformOperationExecutor.ts
@@ -1,412 +1,339 @@
-import { ClassTransformOptions } from './ClassTransformOptions';
-import { defaultMetadataStorage } from './storage';
-import { TypeHelpOptions, TypeOptions } from './metadata/ExposeExcludeOptions';
-import { TypeMetadata } from './metadata/TypeMetadata';
-import { TransformationType } from './enums';
-export function testForBuffer(): boolean {
-  try {
-    Buffer.isBuffer({
-      /* empty object */
-    });
-    return true;
-  } catch {
-    return false;
-  }
+import { ClassTransformOptions } from "./ClassTransformOptions";
+import { defaultMetadataStorage } from "./storage";
+import { TypeHelpOptions, TypeOptions } from "./metadata/ExposeExcludeOptions";
+import { TypeMetadata } from "./metadata/TypeMetadata";
+export enum TransformationType {
+    PLAIN_TO_CLASS,
+    CLASS_TO_PLAIN,
+    CLASS_TO_CLASS
+}
+export class TransformOperationExecutor {
+    private recursionStack = new Set<Object>();
+    constructor(private transformationType: TransformationType,
+        private options: ClassTransformOptions) {
+    }
+    transform(source: Object | Object[] | any,
+        value: Object | Object[] | any,
+        targetType: Function | TypeMetadata,
+        arrayType: Function,
+        isMap: boolean,
+        level: number = 0) {
+        if (Array.isArray(value) || value instanceof Set) {
+            const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
+            (value as any[]).forEach((subValue, index) => {
+                const subSource = source ? source[index] : undefined;
+                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
+                    let realTargetType;
+                    if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
+                        if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
+                            realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]);
+                            const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };
+                            const newType = targetType.typeFunction(options);
+                            realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;
+                            if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];
+                        }
+                        if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
+                            realTargetType = subValue.constructor;
+                        }
+                        if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
+                            subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
+                        }
+                    } else {
+                        realTargetType = targetType;
+                    }
+                    const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);
+                    if (newValue instanceof Set) {
+                        newValue.add(value);
+                    } else {
+                        newValue.push(value);
+                    }
+                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
+                    if (newValue instanceof Set) {
+                        newValue.add(subValue);
+                    } else {
+                        newValue.push(subValue);
+                    }
+                }
+            });
+            return newValue;
+        } else if (targetType === String && !isMap) {
+            if (value === null || value === undefined)
+                return value;
+            return String(value);
+        } else if (targetType === Number && !isMap) {
+            if (value === null || value === undefined)
+                return value;
+            return Number(value);
+        } else if (targetType === Boolean && !isMap) {
+            if (value === null || value === undefined)
+                return value;
+            return Boolean(value);
+        } else if ((targetType === Date || value instanceof Date) && !isMap) {
+            if (value instanceof Date) {
+                return new Date(value.valueOf());
+            }
+            if (value === null || value === undefined)
+                return value;
+            return new Date(value);
+        } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {
+            if (value === null || value === undefined)
+                return value;
+            return Buffer.from(value);
+        } else if (typeof value === "object" && value !== null) {
+            if (!targetType && value.constructor !== Object/* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) targetType = value.constructor;
+            if (!targetType && source) targetType = source.constructor;
+            if (this.options.enableCircularCheck) {
+                this.recursionStack.add(value);
+            }
+            const keys = this.getKeys((targetType as Function), value);
+            let newValue: any = source ? source : {};
+            if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
+                if (isMap) {
+                    newValue = new Map();
+                } else if (targetType) {
+                    newValue = new (targetType as any)();
+                } else {
+                    newValue = {};
+                }
+            }
+            for (let key of keys) {
+                let valueKey = key, newValueKey = key, propertyName = key;
+                if (!this.options.ignoreDecorators && targetType) {
+                    if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
+                        const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName((targetType as Function), key);
+                        if (exposeMetadata) {
+                            propertyName = exposeMetadata.propertyName;
+                            newValueKey = exposeMetadata.propertyName;
+                        }
+                    } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {
+                        const exposeMetadata = defaultMetadataStorage.findExposeMetadata((targetType as Function), key);
+                        if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
+                            newValueKey = exposeMetadata.options.name;
+                        }
+                    }
+                }
+                let subValue: any = undefined;
+                if (value instanceof Map) {
+                    subValue = value.get(valueKey);
+                } else if (value[valueKey] instanceof Function) {
+                    subValue = value[valueKey]();
+                } else {
+                    subValue = value[valueKey];
+                }
+                let type: any = undefined, isSubValueMap = subValue instanceof Map;
+                if (targetType && isMap) {
+                    type = targetType;
+                } else if (targetType) {
+                    const metadata = defaultMetadataStorage.findTypeMetadata((targetType as Function), propertyName);
+                    if (metadata) {
+                        const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };
+                        const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
+                        if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {
+                            if (!(value[valueKey] instanceof Array)) {
+                                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
+                                    type = metadata.options.discriminator.subTypes.find((subType) => {
+                                        if (subValue && metadata.options.discriminator.property in subValue) {
+                                            return subType.name === subValue[metadata.options.discriminator.property]
+                                        }
+                                    });
+                                    type === undefined ? type = newType : type = type.value;
+                                    if (!metadata.options.keepDiscriminatorProperty) {
+                                        if (subValue && metadata.options.discriminator.property in subValue) {
+                                            delete subValue[metadata.options.discriminator.property];
+                                        }
+                                    }
+                                }
+                                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
+                                    type = subValue.constructor;
+                                }
+                                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
+                                    subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
+                                }
+                            } else {
+                                type = metadata;
+                            }
+                        } else {
+                            type = newType;
+                        }
+                        isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
+                    } else if (this.options.targetMaps) { // try to find a type in target maps
+                        this.options.targetMaps
+                            .filter(map => map.target === targetType && !!map.properties[propertyName])
+                            .forEach(map => type = map.properties[propertyName]);
+                    } else if(this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {
+                        const reflectedType = Reflect.getMetadata("design:type", (targetType as Function).prototype, propertyName);
+                        if (reflectedType) {
+                            type = reflectedType;
+                        }
+                    }
+                }
+                const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType((targetType as Function), propertyName) : undefined;
+                const subSource = source ? source[valueKey] : undefined;
+                if (newValue.constructor.prototype) {
+                    const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
+                    if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)
+                        && ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS
+                        continue;
+                }
+                if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
+                    let transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
+                    let finalValue;
+                    if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
+                        finalValue = value[transformKey];
+                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);
+                        finalValue = (value[transformKey] === finalValue) ? subValue : finalValue;
+                        finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);
+                    } else {
+                        finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);
+                        finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);
+                    }
+                    if (newValue instanceof Map) {
+                        newValue.set(newValueKey, finalValue);
+                    } else {
+                        newValue[newValueKey] = finalValue;
+                    }
+                } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
+                    let finalValue = subValue;
+                    finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), key, value, this.transformationType);
+                    if (newValue instanceof Map) {
+                        newValue.set(newValueKey, finalValue);
+                    } else {
+                        newValue[newValueKey] = finalValue;
+                    }
+                }
+            }
+            if (this.options.enableCircularCheck) {
+                this.recursionStack.delete(value);
+            }
+            return newValue;
+        } else {
+            return value;
+        }
+    }
+    private applyCustomTransformations(value: any, target: Function, key: string, obj: any, transformationType: TransformationType) {
+        let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
+        if (this.options.version !== undefined) {
+            metadatas = metadatas.filter(metadata => {
+                if (!metadata.options)
+                    return true;
+                return this.checkVersion(metadata.options.since, metadata.options.until);
+            });
+        }
+        if (this.options.groups && this.options.groups.length) {
+            metadatas = metadatas.filter(metadata => {
+                if (!metadata.options)
+                    return true;
+                return this.checkGroups(metadata.options.groups);
+            });
+        } else {
+            metadatas = metadatas.filter(metadata => {
+                return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
+            });
+        }
+        metadatas.forEach(metadata => {
+            value = metadata.transformFn(value, obj, transformationType);
+        });
+        return value;
+    }
+    private isCircular(object: Object) {
+        return this.recursionStack.has(object);
+    }
+    private getReflectedType(target: Function, propertyName: string) {
+        if (!target) return undefined;
+        const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
+        return meta ? meta.reflectedType : undefined;
+    }
+    private getKeys(target: Function, object: Object): string[] {
+        let strategy = defaultMetadataStorage.getStrategy(target);
+        if (strategy === "none")
+            strategy = this.options.strategy || "exposeAll"; // exposeAll is default strategy
+        let keys: any[] = [];
+        if (strategy === "exposeAll") {
+            if (object instanceof Map) {
+                keys = Array.from(object.keys());
+            } else {
+                keys = Object.keys(object);
+            }
+        }
+        if (!this.options.ignoreDecorators && target) {
+            let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
+            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
+                exposedProperties = exposedProperties.map(key => {
+                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
+                    if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
+                        return exposeMetadata.options.name;
+                    }
+                    return key;
+                });
+            }
+            if (this.options.excludeExtraneousValues) {
+                keys = exposedProperties;
+            } else {
+                keys = keys.concat(exposedProperties);
+            }
+            const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
+            if (excludedProperties.length > 0) {
+                keys = keys.filter(key => {
+                    return excludedProperties.indexOf(key) === -1;
+                });
+            }
+            if (this.options.version !== undefined) {
+                keys = keys.filter(key => {
+                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
+                    if (!exposeMetadata || !exposeMetadata.options)
+                        return true;
+                    return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
+                });
+            }
+            if (this.options.groups && this.options.groups.length) {
+                keys = keys.filter(key => {
+                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
+                    if (!exposeMetadata || !exposeMetadata.options)
+                        return true;
+                    return this.checkGroups(exposeMetadata.options.groups);
+                });
+            } else {
+                keys = keys.filter(key => {
+                    const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
+                    return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
+                });
+            }
+        }
+        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
+            keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {
+                return key.substr(0, prefix.length) !== prefix;
+            }));
+        }
+        keys = keys.filter((key, index, self) => {
+            return self.indexOf(key) === index;
+        });
+        return keys;
+    }
+    private checkVersion(since: number, until: number) {
+        let decision = true;
+        if (decision && since)
+            decision = this.options.version >= since;
+        if (decision && until)
+            decision = this.options.version < until;
+        return decision;
+    }
+    private checkGroups(groups: string[]) {
+        if (!groups)
+            return true;
+        return this.options.groups.some(optionGroup => groups.indexOf(optionGroup) !== -1);
+    }
 }
 function instantiateArrayType(arrayType: Function): Array<any> | Set<any> {
-  const array = new (arrayType as any)();
-  if (!(array instanceof Set) && !('push' in array)) {
-    return [];
-  }
-  return array;
+    const array = new (arrayType as any)();
+    if (!(array instanceof Set) && !("push" in array)) {
+        return [];
+    }
+    return array;
 }
-export class TransformOperationExecutor {
-  private recursionStack = new Set<Record<string, any>>();
-  constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}
-  transform(
-    source: Record<string, any> | Record<string, any>[] | any,
-    value: Record<string, any> | Record<string, any>[] | any,
-    targetType: Function | TypeMetadata,
-    arrayType: Function,
-    isMap: boolean,
-    level: number = 0
-  ): any {
-    if (Array.isArray(value) || value instanceof Set) {
-      const newValue =
-        arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS
-          ? instantiateArrayType(arrayType)
-          : [];
-      (value as any[]).forEach((subValue, index) => {
-        const subSource = source ? source[index] : undefined;
-        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
-          let realTargetType;
-          if (
-            typeof targetType !== 'function' &&
-            targetType &&
-            targetType.options &&
-            targetType.options.discriminator &&
-            targetType.options.discriminator.property &&
-            targetType.options.discriminator.subTypes
-          ) {
-            if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
-              realTargetType = targetType.options.discriminator.subTypes.find(
-                subType =>
-                  subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]
-              );
-              const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };
-              const newType = targetType.typeFunction(options);
-              realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);
-              if (!targetType.options.keepDiscriminatorProperty)
-                delete subValue[targetType.options.discriminator.property];
-            }
-            if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
-              realTargetType = subValue.constructor;
-            }
-            if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
-              subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(
-                subType => subType.value === subValue.constructor
-              ).name;
-            }
-          } else {
-            realTargetType = targetType;
-          }
-          const value = this.transform(
-            subSource,
-            subValue,
-            realTargetType,
-            undefined,
-            subValue instanceof Map,
-            level + 1
-          );
-          if (newValue instanceof Set) {
-            newValue.add(value);
-          } else {
-            newValue.push(value);
-          }
-        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
-          if (newValue instanceof Set) {
-            newValue.add(subValue);
-          } else {
-            newValue.push(subValue);
-          }
-        }
-      });
-      return newValue;
-    } else if (targetType === String && !isMap) {
-      if (value === null || value === undefined) return value;
-      return String(value);
-    } else if (targetType === Number && !isMap) {
-      if (value === null || value === undefined) return value;
-      return Number(value);
-    } else if (targetType === Boolean && !isMap) {
-      if (value === null || value === undefined) return value;
-      return Boolean(value);
-    } else if ((targetType === Date || value instanceof Date) && !isMap) {
-      if (value instanceof Date) {
-        return new Date(value.valueOf());
-      }
-      if (value === null || value === undefined) return value;
-      return new Date(value);
-    } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {
-      if (value === null || value === undefined) return value;
-      return Buffer.from(value);
-    } else if (typeof value === 'object' && value !== null) {
-      if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)
-        targetType = value.constructor;
-      if (!targetType && source) targetType = source.constructor;
-      if (this.options.enableCircularCheck) {
-        this.recursionStack.add(value);
-      }
-      const keys = this.getKeys(targetType as Function, value);
-      let newValue: any = source ? source : {};
-      if (
-        !source &&
-        (this.transformationType === TransformationType.PLAIN_TO_CLASS ||
-          this.transformationType === TransformationType.CLASS_TO_CLASS)
-      ) {
-        if (isMap) {
-          newValue = new Map();
-        } else if (targetType) {
-          newValue = new (targetType as any)();
-        } else {
-          newValue = {};
-        }
-      }
-      for (const key of keys) {
-        if (key === '__proto__' || key === 'constructor') {
-          continue;
-        }
-        const valueKey = key;
-        let newValueKey = key,
-          propertyName = key;
-        if (!this.options.ignoreDecorators && targetType) {
-          if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
-            const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);
-            if (exposeMetadata) {
-              propertyName = exposeMetadata.propertyName;
-              newValueKey = exposeMetadata.propertyName;
-            }
-          } else if (
-            this.transformationType === TransformationType.CLASS_TO_PLAIN ||
-            this.transformationType === TransformationType.CLASS_TO_CLASS
-          ) {
-            const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);
-            if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
-              newValueKey = exposeMetadata.options.name;
-            }
-          }
-        }
-        let subValue: any = undefined;
-        if (value instanceof Map) {
-          subValue = value.get(valueKey);
-        } else if (value[valueKey] instanceof Function) {
-          subValue = value[valueKey]();
-        } else {
-          subValue = value[valueKey];
-        }
-        let type: any = undefined,
-          isSubValueMap = subValue instanceof Map;
-        if (targetType && isMap) {
-          type = targetType;
-        } else if (targetType) {
-          const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);
-          if (metadata) {
-            const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };
-            const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
-            if (
-              metadata.options &&
-              metadata.options.discriminator &&
-              metadata.options.discriminator.property &&
-              metadata.options.discriminator.subTypes
-            ) {
-              if (!(value[valueKey] instanceof Array)) {
-                if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
-                  type = metadata.options.discriminator.subTypes.find(subType => {
-                    if (subValue && metadata.options.discriminator.property in subValue) {
-                      return subType.name === subValue[metadata.options.discriminator.property];
-                    }
-                  });
-                  type === undefined ? (type = newType) : (type = type.value);
-                  if (!metadata.options.keepDiscriminatorProperty) {
-                    if (subValue && metadata.options.discriminator.property in subValue) {
-                      delete subValue[metadata.options.discriminator.property];
-                    }
-                  }
-                }
-                if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
-                  type = subValue.constructor;
-                }
-                if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
-                  subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(
-                    subType => subType.value === subValue.constructor
-                  ).name;
-                }
-              } else {
-                type = metadata;
-              }
-            } else {
-              type = newType;
-            }
-            isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
-          } else if (this.options.targetMaps) {
-            this.options.targetMaps
-              .filter(map => map.target === targetType && !!map.properties[propertyName])
-              .forEach(map => (type = map.properties[propertyName]));
-          } else if (
-            this.options.enableImplicitConversion &&
-            this.transformationType === TransformationType.PLAIN_TO_CLASS
-          ) {
-            const reflectedType = (Reflect as any).getMetadata(
-              'design:type',
-              (targetType as Function).prototype,
-              propertyName
-            );
-            if (reflectedType) {
-              type = reflectedType;
-            }
-          }
-        }
-        const arrayType = Array.isArray(value[valueKey])
-          ? this.getReflectedType(targetType as Function, propertyName)
-          : undefined;
-        const subSource = source ? source[valueKey] : undefined;
-        if (newValue.constructor.prototype) {
-          const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
-          if (
-            (this.transformationType === TransformationType.PLAIN_TO_CLASS ||
-              this.transformationType === TransformationType.CLASS_TO_CLASS) &&
-            ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)
-          )
-            continue;
-        }
-        if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
-          const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
-          let finalValue;
-          if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
-            finalValue = value[transformKey];
-            finalValue = this.applyCustomTransformations(
-              finalValue,
-              targetType as Function,
-              transformKey,
-              value,
-              this.transformationType
-            );
-            finalValue = value[transformKey] === finalValue ? subValue : finalValue;
-            finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);
-          } else {
-            finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);
-            finalValue = this.applyCustomTransformations(
-              finalValue,
-              targetType as Function,
-              transformKey,
-              value,
-              this.transformationType
-            );
-          }
-          if (newValue instanceof Map) {
-            newValue.set(newValueKey, finalValue);
-          } else {
-            newValue[newValueKey] = finalValue;
-          }
-        } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
-          let finalValue = subValue;
-          finalValue = this.applyCustomTransformations(
-            finalValue,
-            targetType as Function,
-            key,
-            value,
-            this.transformationType
-          );
-          if (newValue instanceof Map) {
-            newValue.set(newValueKey, finalValue);
-          } else {
-            newValue[newValueKey] = finalValue;
-          }
-        }
-      }
-      if (this.options.enableCircularCheck) {
-        this.recursionStack.delete(value);
-      }
-      return newValue;
-    } else {
-      return value;
-    }
-  }
-  private applyCustomTransformations(
-    value: any,
-    target: Function,
-    key: string,
-    obj: any,
-    transformationType: TransformationType
-  ): boolean {
-    let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
-    if (this.options.version !== undefined) {
-      metadatas = metadatas.filter(metadata => {
-        if (!metadata.options) return true;
-        return this.checkVersion(metadata.options.since, metadata.options.until);
-      });
-    }
-    if (this.options.groups && this.options.groups.length) {
-      metadatas = metadatas.filter(metadata => {
-        if (!metadata.options) return true;
-        return this.checkGroups(metadata.options.groups);
-      });
-    } else {
-      metadatas = metadatas.filter(metadata => {
-        return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
-      });
-    }
-    metadatas.forEach(metadata => {
-      value = metadata.transformFn(value, obj, transformationType);
-    });
-    return value;
-  }
-  private isCircular(object: Record<string, any>): boolean {
-    return this.recursionStack.has(object);
-  }
-  private getReflectedType(target: Function, propertyName: string): Function | undefined {
-    if (!target) return undefined;
-    const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
-    return meta ? meta.reflectedType : undefined;
-  }
-  private getKeys(target: Function, object: Record<string, any>): string[] {
-    let strategy = defaultMetadataStorage.getStrategy(target);
-    if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy
-    let keys: any[] = [];
-    if (strategy === 'exposeAll') {
-      if (object instanceof Map) {
-        keys = Array.from(object.keys());
-      } else {
-        keys = Object.keys(object);
-      }
-    }
-    if (!this.options.ignoreDecorators && target) {
-      let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
-      if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
-        exposedProperties = exposedProperties.map(key => {
-          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
-          if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
-            return exposeMetadata.options.name;
-          }
-          return key;
-        });
-      }
-      if (this.options.excludeExtraneousValues) {
-        keys = exposedProperties;
-      } else {
-        keys = keys.concat(exposedProperties);
-      }
-      const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
-      if (excludedProperties.length > 0) {
-        keys = keys.filter(key => {
-          return !excludedProperties.includes(key);
-        });
-      }
-      if (this.options.version !== undefined) {
-        keys = keys.filter(key => {
-          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
-          if (!exposeMetadata || !exposeMetadata.options) return true;
-          return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
-        });
-      }
-      if (this.options.groups && this.options.groups.length) {
-        keys = keys.filter(key => {
-          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
-          if (!exposeMetadata || !exposeMetadata.options) return true;
-          return this.checkGroups(exposeMetadata.options.groups);
-        });
-      } else {
-        keys = keys.filter(key => {
-          const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
-          return (
-            !exposeMetadata ||
-            !exposeMetadata.options ||
-            !exposeMetadata.options.groups ||
-            !exposeMetadata.options.groups.length
-          );
-        });
-      }
-    }
-    if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
-      keys = keys.filter(key =>
-        this.options.excludePrefixes.every(prefix => {
-          return key.substr(0, prefix.length) !== prefix;
-        })
-      );
-    }
-    keys = keys.filter((key, index, self) => {
-      return self.indexOf(key) === index;
-    });
-    return keys;
-  }
-  private checkVersion(since: number, until: number): boolean {
-    let decision = true;
-    if (decision && since) decision = this.options.version >= since;
-    if (decision && until) decision = this.options.version < until;
-    return decision;
-  }
-  private checkGroups(groups: string[]): boolean {
-    if (!groups) return true;
-    return this.options.groups.some(optionGroup => groups.includes(optionGroup));
-  }
+export function testForBuffer(): boolean {
+    try {
+        Buffer
+        return true;
+    } catch { }
+    return false;
 }

--- a/src/decorators.ts
+++ b/src/decorators.ts
@@ -1,119 +1,93 @@
-import { ClassTransformer } from './ClassTransformer';
-import { defaultMetadataStorage } from './storage';
-import { TypeMetadata } from './metadata/TypeMetadata';
-import { ExposeMetadata } from './metadata/ExposeMetadata';
-import {
-  ExposeOptions,
-  ExcludeOptions,
-  TypeHelpOptions,
-  TransformOptions,
-  TypeOptions,
-} from './metadata/ExposeExcludeOptions';
-import { ExcludeMetadata } from './metadata/ExcludeMetadata';
-import { TransformMetadata } from './metadata/TransformMetadata';
-import { ClassTransformOptions } from './ClassTransformOptions';
-import { TransformationType } from './enums';
+import {ClassTransformer} from "./ClassTransformer";
+import {defaultMetadataStorage} from "./storage";
+import {TypeMetadata} from "./metadata/TypeMetadata";
+import {ExposeMetadata} from "./metadata/ExposeMetadata";
+import {ExposeOptions, ExcludeOptions, TypeHelpOptions, TransformOptions, Discriminator, TypeOptions} from "./metadata/ExposeExcludeOptions";
+import {ExcludeMetadata} from "./metadata/ExcludeMetadata";
+import {TransformMetadata} from "./metadata/TransformMetadata";
+import {ClassTransformOptions} from "./ClassTransformOptions";
+import {TransformationType} from "./TransformOperationExecutor";
 /**
  * Defines a custom logic for value transformation.
  */
-export function Transform(
-  transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
-  options?: TransformOptions
-) {
-  return function (target: any, key: string): void {
-    const metadata = new TransformMetadata(target.constructor, key, transformFn, options);
-    defaultMetadataStorage.addTransformMetadata(metadata);
-  };
+export function Transform(transformFn: (value: any, obj: any, transformationType: TransformationType) => any, options?: TransformOptions) {
+    return function(target: any, key: string) {
+        const metadata = new TransformMetadata(target.constructor, key, transformFn, options);
+        defaultMetadataStorage.addTransformMetadata(metadata);
+    };
 }
 /**
  * Specifies a type of the property.
  * The given TypeFunction can return a constructor. A discriminator can be given in the options.
  */
 export function Type(typeFunction?: (type?: TypeHelpOptions) => Function, options?: TypeOptions) {
-  return function (target: any, key: string): void {
-    const type = (Reflect as any).getMetadata('design:type', target, key);
-    const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);
-    defaultMetadataStorage.addTypeMetadata(metadata);
-  };
+    return function(target: any, key: string) {
+        const type = (Reflect as any).getMetadata("design:type", target, key);
+        const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);
+        defaultMetadataStorage.addTypeMetadata(metadata);
+    };
 }
 /**
  * Marks property as included in the process of transformation. By default it includes the property for both
  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
  * you want to skip this property.
  */
 export function Expose(options?: ExposeOptions) {
-  return function (object: Record<string, any> | Function, propertyName?: string): void {
-    const metadata = new ExposeMetadata(
-      object instanceof Function ? object : object.constructor,
-      propertyName,
-      options || {}
-    );
-    defaultMetadataStorage.addExposeMetadata(metadata);
-  };
+    return function(object: Object|Function, propertyName?: string) {
+        const metadata = new ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});
+        defaultMetadataStorage.addExposeMetadata(metadata);
+    };
 }
 /**
  * Marks property as excluded from the process of transformation. By default it excludes the property for both
  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
  * you want to skip this property.
  */
 export function Exclude(options?: ExcludeOptions) {
-  return function (object: Record<string, any> | Function, propertyName?: string): void {
-    const metadata = new ExcludeMetadata(
-      object instanceof Function ? object : object.constructor,
-      propertyName,
-      options || {}
-    );
-    defaultMetadataStorage.addExcludeMetadata(metadata);
-  };
+    return function(object: Object|Function, propertyName?: string) {
+        const metadata = new ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});
+        defaultMetadataStorage.addExcludeMetadata(metadata);
+    };
 }
 /**
  * Transform the object from class to plain object and return only with the exposed properties.
  */
 export function TransformClassToPlain(params?: ClassTransformOptions): Function {
-  return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
-    const classTransformer: ClassTransformer = new ClassTransformer();
-    const originalMethod = descriptor.value;
-    descriptor.value = function (...args: any[]): Record<string, any> {
-      const result: any = originalMethod.apply(this, args);
-      const isPromise =
-        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
-      return isPromise
-        ? result.then((data: any) => classTransformer.classToPlain(data, params))
-        : classTransformer.classToPlain(result, params);
+    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
+        const classTransformer: ClassTransformer = new ClassTransformer();
+        const originalMethod = descriptor.value;
+        descriptor.value = function(...args: any[]) {
+            const result: any = originalMethod.apply(this, args);
+            const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
+            return isPromise ? result.then((data: any) => classTransformer.classToPlain(data, params)) : classTransformer.classToPlain(result, params);
+        };
     };
-  };
 }
 /**
  * Return the class instance only with the exposed properties.
  */
 export function TransformClassToClass(params?: ClassTransformOptions): Function {
-  return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
-    const classTransformer: ClassTransformer = new ClassTransformer();
-    const originalMethod = descriptor.value;
-    descriptor.value = function (...args: any[]): Record<string, any> {
-      const result: any = originalMethod.apply(this, args);
-      const isPromise =
-        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
-      return isPromise
-        ? result.then((data: any) => classTransformer.classToClass(data, params))
-        : classTransformer.classToClass(result, params);
+    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
+        const classTransformer: ClassTransformer = new ClassTransformer();
+        const originalMethod = descriptor.value;
+        descriptor.value = function(...args: any[]) {
+            const result: any = originalMethod.apply(this, args);
+            const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
+            return isPromise ? result.then((data: any) => classTransformer.classToClass(data, params)) : classTransformer.classToClass(result, params);
+        };
     };
-  };
 }
 /**
  * Return the class instance only with the exposed properties.
  */
 export function TransformPlainToClass(classType: any, params?: ClassTransformOptions): Function {
-  return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
-    const classTransformer: ClassTransformer = new ClassTransformer();
-    const originalMethod = descriptor.value;
-    descriptor.value = function (...args: any[]): Record<string, any> {
-      const result: any = originalMethod.apply(this, args);
-      const isPromise =
-        !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
-      return isPromise
-        ? result.then((data: any) => classTransformer.plainToClass(classType, data, params))
-        : classTransformer.plainToClass(classType, result, params);
+    return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
+        const classTransformer: ClassTransformer = new ClassTransformer();
+        const originalMethod = descriptor.value;
+        descriptor.value = function(...args: any[]) {
+            const result: any = originalMethod.apply(this, args);
+            const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
+            return isPromise ? result.then((data: any) => classTransformer.plainToClass(classType, data, params)) : classTransformer.plainToClass(classType, result, params);
+        };
     };
-  };
 }

--- a/src/enums/index.ts
+++ b//dev/null
@@ -1 +0,0 @@
-export * from './transformation-type.enum';

--- a/src/enums/transformation-type.enum.ts
+++ b//dev/null
@@ -1,5 +0,0 @@
-export enum TransformationType {
-  PLAIN_TO_CLASS,
-  CLASS_TO_PLAIN,
-  CLASS_TO_CLASS,
-}

--- a/src/index.ts
+++ b/src/index.ts
@@ -1,104 +1,89 @@
-import { ClassTransformer, ClassType } from './ClassTransformer';
-import { ClassTransformOptions } from './ClassTransformOptions';
-export { ClassTransformer } from './ClassTransformer';
-export { ClassTransformOptions } from './ClassTransformOptions';
-export * from './metadata/ExposeExcludeOptions';
-export * from './decorators';
+import {ClassTransformer, ClassType} from "./ClassTransformer";
+import {ClassTransformOptions} from "./ClassTransformOptions";
+export {ClassTransformer} from "./ClassTransformer";
+export {ClassTransformOptions} from "./ClassTransformOptions";
+export * from "./metadata/ExposeExcludeOptions";
+export * from "./decorators";
 const classTransformer = new ClassTransformer();
 /**
  * Converts class (constructor) object to plain (literal) object. Also works with arrays.
  */
-export function classToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;
-export function classToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];
-export function classToPlain<T>(
-  object: T | T[],
-  options?: ClassTransformOptions
-): Record<string, any> | Record<string, any>[] {
-  return classTransformer.classToPlain(object, options);
+export function classToPlain<T>(object: T, options?: ClassTransformOptions): Object;
+export function classToPlain<T>(object: T[], options?: ClassTransformOptions): Object[];
+export function classToPlain<T>(object: T|T[], options?: ClassTransformOptions): Object|Object[] {
+    return classTransformer.classToPlain(object, options);
 }
 /**
  * Converts class (constructor) object to plain (literal) object.
  * Uses given plain object as source object (it means fills given plain object with data from class object).
  * Also works with arrays.
  */
-export function classToPlainFromExist<T>(
-  object: T,
-  plainObject: Record<string, any>,
-  options?: ClassTransformOptions
-): Record<string, any>;
-export function classToPlainFromExist<T>(
-  object: T,
-  plainObjects: Record<string, any>[],
-  options?: ClassTransformOptions
-): Record<string, any>[];
-export function classToPlainFromExist<T>(
-  object: T,
-  plainObject: Record<string, any> | Record<string, any>[],
-  options?: ClassTransformOptions
-): Record<string, any> | Record<string, any>[] {
-  return classTransformer.classToPlainFromExist(object, plainObject, options);
+export function classToPlainFromExist<T>(object: T, plainObject: Object, options?: ClassTransformOptions): Object;
+export function classToPlainFromExist<T>(object: T, plainObjects: Object[], options?: ClassTransformOptions): Object[];
+export function classToPlainFromExist<T>(object: T, plainObject: Object|Object[], options?: ClassTransformOptions): Object|Object[] {
+    return classTransformer.classToPlainFromExist(object, plainObject, options);
 }
 /**
  * Converts plain (literal) object to class (constructor) object. Also works with arrays.
  */
 export function plainToClass<T, V>(cls: ClassType<T>, plain: V[], options?: ClassTransformOptions): T[];
 export function plainToClass<T, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
-export function plainToClass<T, V>(cls: ClassType<T>, plain: V | V[], options?: ClassTransformOptions): T | T[] {
-  return classTransformer.plainToClass(cls, plain as any, options);
+export function plainToClass<T, V>(cls: ClassType<T>, plain: V|V[], options?: ClassTransformOptions): T|T[] {
+    return classTransformer.plainToClass(cls, plain as any, options);
 }
 /**
  * Converts plain (literal) object to class (constructor) object.
  * Uses given object as source object (it means fills given object with data from plain object).
  *  Also works with arrays.
  */
 export function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];
 export function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;
-export function plainToClassFromExist<T, V>(clsObject: T, plain: V | V[], options?: ClassTransformOptions): T | T[] {
-  return classTransformer.plainToClassFromExist(clsObject, plain, options);
+export function plainToClassFromExist<T, V>(clsObject: T, plain: V|V[], options?: ClassTransformOptions): T|T[] {
+    return classTransformer.plainToClassFromExist(clsObject, plain, options);
 }
 /**
  * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
  */
 export function classToClass<T>(object: T, options?: ClassTransformOptions): T;
 export function classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
-export function classToClass<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {
-  return classTransformer.classToClass(object, options);
+export function classToClass<T>(object: T|T[], options?: ClassTransformOptions): T|T[] {
+    return classTransformer.classToClass(object, options);
 }
 /**
  * Converts class (constructor) object to plain (literal) object.
  * Uses given plain object as source object (it means fills given plain object with data from class object).
  * Also works with arrays.
  */
 export function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
 export function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
-export function classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {
-  return classTransformer.classToClassFromExist(object, fromObject, options);
+export function classToClassFromExist<T>(object: T, fromObject: T|T[], options?: ClassTransformOptions): T|T[] {
+    return classTransformer.classToClassFromExist(object, fromObject, options);
 }
 /**
  * Serializes given object to a JSON string.
  */
 export function serialize<T>(object: T, options?: ClassTransformOptions): string;
 export function serialize<T>(object: T[], options?: ClassTransformOptions): string;
-export function serialize<T>(object: T | T[], options?: ClassTransformOptions): string {
-  return classTransformer.serialize(object, options);
+export function serialize<T>(object: T|T[], options?: ClassTransformOptions): string {
+    return classTransformer.serialize(object, options);
 }
 /**
  * Deserializes given JSON string to a object of the given class.
  */
 export function deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
-  return classTransformer.deserialize(cls, json, options);
+    return classTransformer.deserialize(cls, json, options);
 }
 /**
  * Deserializes given JSON string to an array of objects of the given class.
  */
 export function deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
-  return classTransformer.deserializeArray(cls, json, options);
+    return classTransformer.deserializeArray(cls, json, options);
 }
 /**
  * Enum representing the different transformation types.
  */
 export enum TransformationType {
-  PLAIN_TO_CLASS,
-  CLASS_TO_PLAIN,
-  CLASS_TO_CLASS,
+    PLAIN_TO_CLASS,
+    CLASS_TO_PLAIN,
+    CLASS_TO_CLASS
 }

--- a/src/metadata/ExcludeMetadata.ts
+++ b/src/metadata/ExcludeMetadata.ts
@@ -1,4 +1,7 @@
-import { ExcludeOptions } from './ExposeExcludeOptions';
+import {ExcludeOptions} from "./ExposeExcludeOptions";
 export class ExcludeMetadata {
-  constructor(public target: Function, public propertyName: string, public options: ExcludeOptions) {}
+    constructor(public target: Function,
+                public propertyName: string,
+                public options: ExcludeOptions) {
+    }
 }

--- a/src/metadata/ExposeExcludeOptions.ts
+++ b/src/metadata/ExposeExcludeOptions.ts
@@ -1,39 +1,39 @@
 export interface TransformOptions {
-  since?: number;
-  until?: number;
-  groups?: string[];
-  toClassOnly?: boolean;
-  toPlainOnly?: boolean;
+    since?: number;
+    until?: number;
+    groups?: string[];
+    toClassOnly?: boolean;
+    toPlainOnly?: boolean;
 }
 export interface TypeOptions {
-  discriminator?: Discriminator;
-  /**
-   * Is false by default.
-   */
-  keepDiscriminatorProperty?: boolean;
+    discriminator?: Discriminator;
+    /**
+     * Is false by default.
+     */
+    keepDiscriminatorProperty?: boolean;
 }
 export interface TypeHelpOptions {
-  newObject: any;
-  object: Record<string, any>;
-  property: string;
+    newObject: any;
+    object: Object;
+    property: string;
 }
 export interface ExposeOptions {
-  name?: string;
-  since?: number;
-  until?: number;
-  groups?: string[];
-  toClassOnly?: boolean;
-  toPlainOnly?: boolean;
+    name?: string;
+    since?: number;
+    until?: number;
+    groups?: string[];
+    toClassOnly?: boolean;
+    toPlainOnly?: boolean;
 }
 export interface ExcludeOptions {
-  toClassOnly?: boolean;
-  toPlainOnly?: boolean;
+    toClassOnly?: boolean;
+    toPlainOnly?: boolean;
 }
 export interface Discriminator {
-  property: string;
-  subTypes: JsonSubType[];
+    property: string;
+    subTypes: JsonSubType[];
 }
 export interface JsonSubType {
-  value: new (...args: any[]) => any;
-  name: string;
+    value: new (...args: any[]) => any;
+    name: string;
 }

--- a/src/metadata/ExposeMetadata.ts
+++ b/src/metadata/ExposeMetadata.ts
@@ -1,4 +1,7 @@
-import { ExposeOptions } from './ExposeExcludeOptions';
+import {ExposeOptions} from "./ExposeExcludeOptions";
 export class ExposeMetadata {
-  constructor(public target: Function, public propertyName: string, public options: ExposeOptions) {}
+    constructor(public target: Function,
+                public propertyName: string,
+                public options: ExposeOptions) {
+    }
 }

--- a/src/metadata/MetadataStorage.ts
+++ b/src/metadata/MetadataStorage.ts
@@ -1,215 +1,191 @@
-import { TypeMetadata } from './TypeMetadata';
-import { ExposeMetadata } from './ExposeMetadata';
-import { ExcludeMetadata } from './ExcludeMetadata';
-import { TransformMetadata } from './TransformMetadata';
-import { TransformationType } from '../enums';
+import {TypeMetadata} from "./TypeMetadata";
+import {ExposeMetadata} from "./ExposeMetadata";
+import {ExcludeMetadata} from "./ExcludeMetadata";
+import {TransformationType} from "../TransformOperationExecutor";
+import {TransformMetadata} from "./TransformMetadata";
 /**
  * Storage all library metadata.
  */
 export class MetadataStorage {
-  private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();
-  private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();
-  private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();
-  private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();
-  private _ancestorsMap = new Map<Function, Function[]>();
-  addTypeMetadata(metadata: TypeMetadata): void {
-    if (!this._typeMetadatas.has(metadata.target)) {
-      this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());
+    private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();
+    private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();
+    private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();
+    private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();
+    private _ancestorsMap = new Map<Function, Function[]>();
+    addTypeMetadata(metadata: TypeMetadata) {
+        if (!this._typeMetadatas.has(metadata.target)) {
+            this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());
     }
-    this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
-  }
-  addTransformMetadata(metadata: TransformMetadata): void {
-    if (!this._transformMetadatas.has(metadata.target)) {
-      this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());
+        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
     }
-    if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
-      this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
+    addTransformMetadata(metadata: TransformMetadata) {
+        if (!this._transformMetadatas.has(metadata.target)) {
+            this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());
     }
-    this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
-  }
-  addExposeMetadata(metadata: ExposeMetadata): void {
-    if (!this._exposeMetadatas.has(metadata.target)) {
-      this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());
+        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
+            this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
+        }
+        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
     }
-    this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
-  }
-  addExcludeMetadata(metadata: ExcludeMetadata): void {
-    if (!this._excludeMetadatas.has(metadata.target)) {
-      this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());
+    addExposeMetadata(metadata: ExposeMetadata) {
+        if (!this._exposeMetadatas.has(metadata.target)) {
+            this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());
     }
-    this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
-  }
-  findTransformMetadatas(
-    target: Function,
-    propertyName: string,
-    transformationType: TransformationType
-  ): TransformMetadata[] {
-    return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {
-      if (!metadata.options) return true;
-      if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
-      if (metadata.options.toClassOnly === true) {
-        return (
-          transformationType === TransformationType.CLASS_TO_CLASS ||
-          transformationType === TransformationType.PLAIN_TO_CLASS
-        );
-      }
-      if (metadata.options.toPlainOnly === true) {
-        return transformationType === TransformationType.CLASS_TO_PLAIN;
-      }
-      return true;
-    });
-  }
-  findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {
-    return this.findMetadata(this._excludeMetadatas, target, propertyName);
-  }
-  findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {
-    return this.findMetadata(this._exposeMetadatas, target, propertyName);
-  }
-  findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {
-    return this.getExposedMetadatas(target).find(metadata => {
-      return metadata.options && metadata.options.name === name;
-    });
-  }
-  findTypeMetadata(target: Function, propertyName: string): TypeMetadata {
-    return this.findMetadata(this._typeMetadatas, target, propertyName);
-  }
-  getStrategy(target: Function): 'excludeAll' | 'exposeAll' | 'none' {
-    const excludeMap = this._excludeMetadatas.get(target);
-    const exclude = excludeMap && excludeMap.get(undefined);
-    const exposeMap = this._exposeMetadatas.get(target);
-    const expose = exposeMap && exposeMap.get(undefined);
-    if ((exclude && expose) || (!exclude && !expose)) return 'none';
-    return exclude ? 'excludeAll' : 'exposeAll';
-  }
-  getExposedMetadatas(target: Function): ExposeMetadata[] {
-    return this.getMetadata(this._exposeMetadatas, target);
-  }
-  getExcludedMetadatas(target: Function): ExcludeMetadata[] {
-    return this.getMetadata(this._excludeMetadatas, target);
-  }
-  getExposedProperties(target: Function, transformationType: TransformationType): string[] {
-    return this.getExposedMetadatas(target)
-      .filter(metadata => {
-        if (!metadata.options) return true;
-        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
-        if (metadata.options.toClassOnly === true) {
-          return (
-            transformationType === TransformationType.CLASS_TO_CLASS ||
-            transformationType === TransformationType.PLAIN_TO_CLASS
-          );
+        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
+    }
+    addExcludeMetadata(metadata: ExcludeMetadata) {
+        if (!this._excludeMetadatas.has(metadata.target)) {
+            this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());
+    }
+        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
+    }
+    findTransformMetadatas(target: Function, propertyName: string, transformationType: TransformationType): TransformMetadata[] {
+        return this.findMetadatas(this._transformMetadatas, target, propertyName)
+            .filter(metadata => {
+                if (!metadata.options)
+                    return true;
+                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
+                    return true;
+                if (metadata.options.toClassOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
+                }
+                if (metadata.options.toPlainOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_PLAIN;
+                }
+                return true;
+            });
+    }
+    findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {
+        return this.findMetadata(this._excludeMetadatas, target, propertyName);
+    }
+    findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {
+        return this.findMetadata(this._exposeMetadatas, target, propertyName);
+    }
+    findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {
+        return this.getExposedMetadatas(target).find(metadata => {
+            return metadata.options && metadata.options.name === name;
+        });
+    }
+    findTypeMetadata(target: Function, propertyName: string) {
+        return this.findMetadata(this._typeMetadatas, target, propertyName);
+    }
+    getStrategy(target: Function): "excludeAll"|"exposeAll"|"none" {
+        const excludeMap = this._excludeMetadatas.get(target);
+        const exclude = excludeMap && excludeMap.get(undefined);
+        const exposeMap = this._exposeMetadatas.get(target);
+        const expose = exposeMap && exposeMap.get(undefined);
+        if ((exclude && expose) || (!exclude && !expose)) return "none";
+        return exclude ? "excludeAll" : "exposeAll";
+    }
+    getExposedMetadatas(target: Function): ExposeMetadata[] {
+        return this.getMetadata(this._exposeMetadatas, target);
+    }
+    getExcludedMetadatas(target: Function): ExcludeMetadata[] {
+        return this.getMetadata(this._excludeMetadatas, target);
+    }
+    getExposedProperties(target: Function, transformationType: TransformationType): string[] {
+        return this.getExposedMetadatas(target)
+            .filter(metadata => {
+                if (!metadata.options)
+                    return true;
+                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
+                    return true;
+                if (metadata.options.toClassOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
+                }
+                if (metadata.options.toPlainOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_PLAIN;
+                }
+                return true;
+            })
+            .map(metadata => metadata.propertyName);
+    }
+    getExcludedProperties(target: Function, transformationType: TransformationType): string[] {
+        return this.getExcludedMetadatas(target)
+            .filter(metadata => {
+                if (!metadata.options)
+                    return true;
+                if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
+                    return true;
+                if (metadata.options.toClassOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
+                }
+                if (metadata.options.toPlainOnly === true) {
+                    return transformationType === TransformationType.CLASS_TO_PLAIN;
+                }
+                return true;
+            })
+            .map(metadata => metadata.propertyName);
+    }
+    clear() {
+        this._typeMetadatas.clear();
+        this._exposeMetadatas.clear();
+        this._excludeMetadatas.clear();
+        this._ancestorsMap.clear();
+    }
+    private getMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<String, T>>, target: Function): T[] {
+        const metadataFromTargetMap = metadatas.get(target);
+        let metadataFromTarget: T[];
+        if (metadataFromTargetMap) {
+            metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);
         }
-        if (metadata.options.toPlainOnly === true) {
-          return transformationType === TransformationType.CLASS_TO_PLAIN;
+        let metadataFromAncestors: T[] = [];
+        for (const ancestor of this.getAncestors(target)) {
+            const ancestorMetadataMap = metadatas.get(ancestor);
+            if (ancestorMetadataMap) {
+                const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);
+                metadataFromAncestors.push(...metadataFromAncestor);
+            }
+        }        
+        return metadataFromAncestors.concat(metadataFromTarget || []);
+    }
+    private findMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T>>, target: Function, propertyName: string): T {
+        const metadataFromTargetMap = metadatas.get(target);
+        if (metadataFromTargetMap) {
+            const metadataFromTarget = metadataFromTargetMap.get(propertyName);  
+            if (metadataFromTarget) {
+                return metadataFromTarget;
+            }
         }
-        return true;
-      })
-      .map(metadata => metadata.propertyName);
-  }
-  getExcludedProperties(target: Function, transformationType: TransformationType): string[] {
-    return this.getExcludedMetadatas(target)
-      .filter(metadata => {
-        if (!metadata.options) return true;
-        if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
-        if (metadata.options.toClassOnly === true) {
-          return (
-            transformationType === TransformationType.CLASS_TO_CLASS ||
-            transformationType === TransformationType.PLAIN_TO_CLASS
-          );
+        for (const ancestor of this.getAncestors(target)) {
+            const ancestorMetadataMap = metadatas.get(ancestor);
+            if (ancestorMetadataMap) {
+                const ancestorResult = ancestorMetadataMap.get(propertyName);
+                if (ancestorResult) {
+                  return ancestorResult;
+                }
+            }
         }
-        if (metadata.options.toPlainOnly === true) {
-          return transformationType === TransformationType.CLASS_TO_PLAIN;
+        return undefined;
+    }
+    private findMetadatas<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T[]>>, target: Function, propertyName: string): T[] {
+        const metadataFromTargetMap = metadatas.get(target);
+        let metadataFromTarget: T[];
+        if (metadataFromTargetMap) {
+            metadataFromTarget = metadataFromTargetMap.get(propertyName);    
         }
-        return true;
-      })
-      .map(metadata => metadata.propertyName);
-  }
-  clear(): void {
-    this._typeMetadatas.clear();
-    this._exposeMetadatas.clear();
-    this._excludeMetadatas.clear();
-    this._ancestorsMap.clear();
-  }
-  private getMetadata<T extends { target: Function; propertyName: string }>(
-    metadatas: Map<Function, Map<string, T>>,
-    target: Function
-  ): T[] {
-    const metadataFromTargetMap = metadatas.get(target);
-    let metadataFromTarget: T[];
-    if (metadataFromTargetMap) {
-      metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);
+        let metadataFromAncestorsTarget: T[] = [];
+        for (const ancestor of this.getAncestors(target)) {
+            const ancestorMetadataMap = metadatas.get(ancestor);
+            if (ancestorMetadataMap) {
+                if (ancestorMetadataMap.has(propertyName)) {
+                  metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
+                }
+            }
+        }
+        return (metadataFromAncestorsTarget).reverse().concat((metadataFromTarget || []).reverse());
     }
-    const metadataFromAncestors: T[] = [];
-    for (const ancestor of this.getAncestors(target)) {
-      const ancestorMetadataMap = metadatas.get(ancestor);
-      if (ancestorMetadataMap) {
-        const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(
-          meta => meta.propertyName !== undefined
-        );
-        metadataFromAncestors.push(...metadataFromAncestor);
-      }
+    private getAncestors(target: Function): Function[] {
+        if (!target) return [];
+        if (!this._ancestorsMap.has(target)) {
+            let ancestors: Function[] = [];
+            for (let baseClass = Object.getPrototypeOf(target.prototype.constructor);
+                 typeof baseClass.prototype !== "undefined";
+                 baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
+                ancestors.push(baseClass);
+            }
+            this._ancestorsMap.set(target, ancestors);
+        }
+        return this._ancestorsMap.get(target);
     }
-    return metadataFromAncestors.concat(metadataFromTarget || []);
-  }
-  private findMetadata<T extends { target: Function; propertyName: string }>(
-    metadatas: Map<Function, Map<string, T>>,
-    target: Function,
-    propertyName: string
-  ): T {
-    const metadataFromTargetMap = metadatas.get(target);
-    if (metadataFromTargetMap) {
-      const metadataFromTarget = metadataFromTargetMap.get(propertyName);
-      if (metadataFromTarget) {
-        return metadataFromTarget;
-      }
-    }
-    for (const ancestor of this.getAncestors(target)) {
-      const ancestorMetadataMap = metadatas.get(ancestor);
-      if (ancestorMetadataMap) {
-        const ancestorResult = ancestorMetadataMap.get(propertyName);
-        if (ancestorResult) {
-          return ancestorResult;
-        }
-      }
-    }
-    return undefined;
-  }
-  private findMetadatas<T extends { target: Function; propertyName: string }>(
-    metadatas: Map<Function, Map<string, T[]>>,
-    target: Function,
-    propertyName: string
-  ): T[] {
-    const metadataFromTargetMap = metadatas.get(target);
-    let metadataFromTarget: T[];
-    if (metadataFromTargetMap) {
-      metadataFromTarget = metadataFromTargetMap.get(propertyName);
-    }
-    const metadataFromAncestorsTarget: T[] = [];
-    for (const ancestor of this.getAncestors(target)) {
-      const ancestorMetadataMap = metadatas.get(ancestor);
-      if (ancestorMetadataMap) {
-        if (ancestorMetadataMap.has(propertyName)) {
-          metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
-        }
-      }
-    }
-    return metadataFromAncestorsTarget
-      .slice()
-      .reverse()
-      .concat((metadataFromTarget || []).slice().reverse());
-  }
-  private getAncestors(target: Function): Function[] {
-    if (!target) return [];
-    if (!this._ancestorsMap.has(target)) {
-      const ancestors: Function[] = [];
-      for (
-        let baseClass = Object.getPrototypeOf(target.prototype.constructor);
-        typeof baseClass.prototype !== 'undefined';
-        baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)
-      ) {
-        ancestors.push(baseClass);
-      }
-      this._ancestorsMap.set(target, ancestors);
-    }
-    return this._ancestorsMap.get(target);
-  }
 }

--- a/src/metadata/TransformMetadata.ts
+++ b/src/metadata/TransformMetadata.ts
@@ -1,10 +1,9 @@
-import { TransformOptions } from './ExposeExcludeOptions';
-import { TransformationType } from '../enums';
+import {TransformOptions} from "./ExposeExcludeOptions";
+import {TransformationType} from "../TransformOperationExecutor";
 export class TransformMetadata {
-  constructor(
-    public target: Function,
-    public propertyName: string,
-    public transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
-    public options: TransformOptions
-  ) {}
+    constructor(public target: Function,
+                public propertyName: string,
+                public transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
+                public options: TransformOptions) {
+    }
 }

--- a/src/metadata/TypeMetadata.ts
+++ b/src/metadata/TypeMetadata.ts
@@ -1,10 +1,9 @@
-import { TypeHelpOptions, TypeOptions } from './ExposeExcludeOptions';
+import {TypeHelpOptions, Discriminator, TypeOptions} from "./ExposeExcludeOptions";
 export class TypeMetadata {
-  constructor(
-    public target: Function,
-    public propertyName: string,
-    public reflectedType: any,
-    public typeFunction: (options?: TypeHelpOptions) => Function,
-    public options: TypeOptions
-  ) {}
+    constructor(public target: Function,
+                public propertyName: string,
+                public reflectedType: any,
+                public typeFunction: (options?: TypeHelpOptions) => Function,
+                public options: TypeOptions) {
+    }
 }

--- a/src/storage.ts
+++ b/src/storage.ts
@@ -1,5 +1,5 @@
-import { MetadataStorage } from './metadata/MetadataStorage';
+import {MetadataStorage} from "./metadata/MetadataStorage";
 /**
  * Default metadata storage is used as singleton and can be used to storage all metadatas.
  */
 export const defaultMetadataStorage = new MetadataStorage();
