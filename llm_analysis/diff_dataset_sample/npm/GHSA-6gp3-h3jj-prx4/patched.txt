# ====================================================================
# FILE: jest.config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| module.exports = {
     2|   preset: 'ts-jest',
     3|   testEnvironment: 'node',
     4|   collectCoverageFrom: ['src/**/*.ts', '!src/**/index.ts', '!src/**/*.interface.ts'],
     5|   globals: {
     6|     'ts-jest': {
     7|       tsConfig: 'tsconfig.spec.json',
     8|     },
     9|   },
    10| };


# ====================================================================
# FILE: sample/sample1-simple-usage/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { Type, Exclude } from '../../src/decorators';
     2| import { Photo } from './Photo';
     3| export class Album {
     4|   id: string;
     5|   @Exclude()
     6|   name: string;
     7|   @Type(() => Photo)
     8|   photos: Photo[];
     9| }


# ====================================================================
# FILE: sample/sample1-simple-usage/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import { Type } from '../../src/decorators';
     2| import { Album } from './Album';
     3| import { User } from './User';
     4| export class Photo {
     5|   id: string;
     6|   filename: string;
     7|   description: string;
     8|   tags: string[];
     9|   @Type(() => User)
    10|   author: User;
    11|   @Type(() => Album)
    12|   albums: Album[];
    13|   get name() {
    14|     return this.id + '_' + this.filename;
    15|   }
    16|   getAlbums() {
    17|     console.log('this is not serialized/deserialized');
    18|     return this.albums;
    19|   }
    20| }


# ====================================================================
# FILE: sample/sample1-simple-usage/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { Type } from '../../src/decorators';
     2| export class User {
     3|   @Type(() => Number)
     4|   id: number;
     5|   firstName: string;
     6|   lastName: string;
     7|   @Type(() => Date)
     8|   registrationDate: Date;
     9| }


# ====================================================================
# FILE: sample/sample1-simple-usage/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| import 'es6-shim';
     2| import 'reflect-metadata';
     3| import { plainToClass, classToPlain } from '../../src/index';
     4| import { Photo } from './Photo';
     5| let photoJson = {
     6|   id: '1',
     7|   filename: 'myphoto.jpg',
     8|   description: 'about my photo',
     9|   tags: ['me', 'iam'],
    10|   author: {
    11|     id: '2',
    12|     firstName: 'Johny',
    13|     lastName: 'Cage',
    14|   },
    15|   albums: [
    16|     {
    17|       id: '1',
    18|       name: 'My life',
    19|     },
    20|     {
    21|       id: '2',
    22|       name: 'My young years',
    23|     },
    24|   ],
    25| };
    26| let photo = plainToClass(Photo, photoJson);
    27| console.log('deserialized object: ', photo);
    28| let newPhotoJson = classToPlain(photo);
    29| console.log('serialized object: ', newPhotoJson);
    30| console.log('-------------------------------');
    31| let photosJson = [
    32|   {
    33|     id: '1',
    34|     filename: 'myphoto.jpg',
    35|     description: 'about my photo',
    36|     author: {
    37|       id: '2',
    38|       firstName: 'Johny',
    39|       lastName: 'Cage',
    40|       registrationDate: '1995-12-17T03:24:00',
    41|     },
    42|     albums: [
    43|       {
    44|         id: '1',
    45|         name: 'My life',
    46|       },
    47|       {
    48|         id: '2',
    49|         name: 'My young years',
    50|       },
    51|     ],
    52|   },
    53|   {
    54|     id: '2',
    55|     filename: 'hisphoto.jpg',
    56|     description: 'about his photo',
    57|     author: {
    58|       id: '2',
    59|       firstName: 'Johny',
    60|       lastName: 'Cage',
    61|     },
    62|     albums: [
    63|       {
    64|         id: '1',
    65|         name: 'My life',
    66|       },
    67|       {
    68|         id: '2',
    69|         name: 'My young years',
    70|       },
    71|     ],
    72|   },
    73| ];
    74| let photos = plainToClass(Photo, photosJson);
    75| console.log('deserialized array: ', photos);
    76| let newPhotosJson = classToPlain(photos);
    77| console.log('serialized array: ', newPhotosJson);


# ====================================================================
# FILE: sample/sample2-iheritance/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import { Type, Exclude } from '../../src/decorators';
     2| import { Photo } from './Photo';
     3| import { Authorable } from './Authorable';
     4| export class Album extends Authorable {
     5|   id: string;
     6|   @Exclude()
     7|   name: string;
     8|   @Type(() => Photo)
     9|   photos: Photo[];
    10| }


# ====================================================================
# FILE: sample/sample2-iheritance/Authorable.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { Type, Exclude } from '../../src/decorators';
     2| import { User } from './User';
     3| export class Authorable {
     4|   authorName: string;
     5|   @Exclude()
     6|   authorEmail: string;
     7|   @Type(() => User)
     8|   author: User;
     9| }


# ====================================================================
# FILE: sample/sample2-iheritance/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-12 ---
     1| import { Type, Exclude } from '../../src/decorators';
     2| import { Album } from './Album';
     3| import { Authorable } from './Authorable';
     4| export class Photo extends Authorable {
     5|   id: string;
     6|   filename: string;
     7|   description: string;
     8|   @Exclude() // this will ignore skipping inherited from Authorable class
     9|   authorEmail: string;
    10|   @Type(() => Album)
    11|   albums: Album[];
    12| }


# ====================================================================
# FILE: sample/sample2-iheritance/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import { Type } from '../../src/decorators';
     2| export class User {
     3|   @Type(() => Number)
     4|   id: number;
     5|   firstName: string;
     6|   lastName: string;
     7|   @Type(() => Date)
     8|   registrationDate: Date;
     9| }


# ====================================================================
# FILE: sample/sample2-iheritance/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-82 ---
     1| import 'es6-shim';
     2| import 'reflect-metadata';
     3| import { classToPlain, plainToClass } from '../../src/index';
     4| import { Photo } from './Photo';
     5| let photoJson = {
     6|   id: '1',
     7|   filename: 'myphoto.jpg',
     8|   description: 'about my photo',
     9|   authorName: 'Johny.Cage',
    10|   authorEmail: 'johny@cage.com',
    11|   author: {
    12|     id: '2',
    13|     firstName: 'Johny',
    14|     lastName: 'Cage',
    15|   },
    16|   albums: [
    17|     {
    18|       id: '1',
    19|       authorName: 'Johny.Cage',
    20|       authorEmail: 'johny@cage.com',
    21|       name: 'My life',
    22|     },
    23|     {
    24|       id: '2',
    25|       authorName: 'Johny.Cage',
    26|       authorEmail: 'johny@cage.com',
    27|       name: 'My young years',
    28|     },
    29|   ],
    30| };
    31| let photo = plainToClass(Photo, photoJson);
    32| console.log('deserialized object: ', photo);
    33| let newPhotoJson = classToPlain(photo);
    34| console.log('serialized object: ', newPhotoJson);
    35| console.log('-------------------------------');
    36| let photosJson = [
    37|   {
    38|     id: '1',
    39|     filename: 'myphoto.jpg',
    40|     description: 'about my photo',
    41|     author: {
    42|       id: '2',
    43|       firstName: 'Johny',
    44|       lastName: 'Cage',
    45|       registrationDate: '1995-12-17T03:24:00',
    46|     },
    47|     albums: [
    48|       {
    49|         id: '1',
    50|         name: 'My life',
    51|       },
    52|       {
    53|         id: '2',
    54|         name: 'My young years',
    55|       },
    56|     ],
    57|   },
    58|   {
    59|     id: '2',
    60|     filename: 'hisphoto.jpg',
    61|     description: 'about his photo',
    62|     author: {
    63|       id: '2',
    64|       firstName: 'Johny',
    65|       lastName: 'Cage',
    66|     },
    67|     albums: [
    68|       {
    69|         id: '1',
    70|         name: 'My life',
    71|       },
    72|       {
    73|         id: '2',
    74|         name: 'My young years',
    75|       },
    76|     ],
    77|   },
    78| ];
    79| let photos = plainToClass(Photo, photosJson);
    80| console.log('deserialized array: ', photos);
    81| let newPhotosJson = classToPlain(photos);
    82| console.log('serialized array: ', newPhotosJson);


# ====================================================================
# FILE: sample/sample3-custom-arrays/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| export class Album {
     2|   id: string;
     3|   name: string;
     4| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/AlbumArray.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| import { Album } from './Album';
     2| export class AlbumArray extends Array<Album> {
     3|   findByName(name: string) {
     4|     return this.find(album => album.name === name);
     5|   }
     6| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| import { Album } from './Album';
     2| import { AlbumArray } from './AlbumArray';
     3| import { Type } from '../../src/decorators';
     4| export class Photo {
     5|   id: string;
     6|   filename: string;
     7|   description: string;
     8|   tags: string[];
     9|   @Type(() => Album)
    10|   albums: AlbumArray;
    11| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| import 'es6-shim';
     2| import 'reflect-metadata';
     3| import { classToPlain, plainToClass } from '../../src/index';
     4| import { Photo } from './Photo';
     5| let photoJson = {
     6|   id: '1',
     7|   filename: 'myphoto.jpg',
     8|   description: 'about my photo',
     9|   tags: ['me', 'iam'],
    10|   albums: [
    11|     {
    12|       id: '1',
    13|       name: 'My life',
    14|     },
    15|     {
    16|       id: '2',
    17|       name: 'My young years',
    18|     },
    19|   ],
    20| };
    21| let photo = plainToClass(Photo, photoJson);
    22| console.log('deserialized object: ', photo);
    23| console.log('-----------------------------');
    24| console.log('Trying to find album: ', photo.albums.findByName('My life'));
    25| console.log('-----------------------------');
    26| let newPhotoJson = classToPlain(photo);
    27| console.log('serialized object: ', newPhotoJson);
    28| console.log('-----------------------------');


# ====================================================================
# FILE: sample/sample4-generics/SimpleCollection.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| export class SimpleCollection<T> {
     2|   items: T[];
     3|   count: number;
     4| }


# ====================================================================
# FILE: sample/sample4-generics/SuperCollection.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| import { Type, Exclude } from '../../src/decorators';
     2| export class SuperCollection<T> {
     3|   @Exclude()
     4|   private type: Function;
     5|   @Type(options => {
     6|     return (options.newObject as SuperCollection<T>).type;
     7|   })
     8|   items: T[];
     9|   count: number;
    10|   constructor(type: Function) {
    11|     this.type = type;
    12|   }
    13| }


# ====================================================================
# FILE: sample/sample4-generics/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| import { Exclude } from '../../src/decorators';
     2| export class User {
     3|   id: number;
     4|   firstName: string;
     5|   lastName: string;
     6|   @Exclude()
     7|   password: string;
     8|   constructor(id: number, firstName: string, lastName: string, password: string) {
     9|     this.id = id;
    10|     this.firstName = firstName;
    11|     this.lastName = lastName;
    12|     this.password = password;
    13|   }
    14|   get name() {
    15|     return this.firstName + ' ' + this.lastName;
    16|   }
    17| }


# ====================================================================
# FILE: sample/sample4-generics/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| import 'es6-shim';
     2| import 'reflect-metadata';
     3| import { SimpleCollection } from './SimpleCollection';
     4| import { User } from './User';
     5| import { classToPlain, plainToClass, plainToClassFromExist } from '../../src/index';
     6| import { SuperCollection } from './SuperCollection';
     7| let collection = new SimpleCollection<User>();
     8| collection.items = [new User(1, 'Johny', 'Cage', '*******'), new User(2, 'Dima', 'Cage', '*******')];
     9| collection.count = 2;
    10| let collectionJson = {
    11|   items: [
    12|     {
    13|       id: 1,
    14|       firstName: 'Johny',
    15|       lastName: 'Cage',
    16|       password: '*******',
    17|     },
    18|     {
    19|       id: 2,
    20|       firstName: 'Dima',
    21|       lastName: 'Cage',
    22|       password: '*******',
    23|     },
    24|   ],
    25| };
    26| console.log(plainToClassFromExist(new SuperCollection<User>(User), collectionJson));


# ====================================================================
# FILE: sample/sample5-custom-transformer/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import { Type, Transform } from '../../src/decorators';
     2| import * as moment from 'moment';
     3| export class User {
     4|   id: number;
     5|   name: string;
     6|   @Type(() => Date)
     7|   @Transform(value => value.toString(), { toPlainOnly: true })
     8|   @Transform(value => moment(value), { toClassOnly: true })
     9|   date: Date;
    10| }


# ====================================================================
# FILE: sample/sample5-custom-transformer/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| import 'es6-shim';
     2| import 'reflect-metadata';
     3| import { plainToClass, classToPlain } from '../../src/index';
     4| import { User } from './User';
     5| let userJson = {
     6|   id: 1,
     7|   name: 'Johny Cage',
     8|   date: new Date().valueOf(),
     9| };
    10| console.log(plainToClass(User, userJson));
    11| const user = new User();
    12| user.id = 1;
    13| user.name = 'Johny Cage';
    14| user.date = new Date();
    15| console.log(classToPlain(user));


# ====================================================================
# FILE: src/ClassTransformOptions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| /**
     2|  * Allows to specify a map of Types in the object without using @Type decorator.
     3|  * This is useful when you have external classes.
     4|  */
     5| export interface TargetMap {
     6|   /**
     7|    * Target which Types are being specified.
     8|    */
     9|   target: Function;
    10|   /**
    11|    * List of properties and their Types.
    12|    */
    13|   properties: { [key: string]: Function };
    14| }
    15| /**
    16|  * Options to be passed during transformation.
    17|  */
    18| export interface ClassTransformOptions {
    19|   /**
    20|    * Exclusion strategy. By default exposeAll is used, which means that it will expose all properties are transformed
    21|    * by default.
    22|    */
    23|   strategy?: 'excludeAll' | 'exposeAll';
    24|   /**
    25|    * Indicates if extraneous properties should be excluded from the value when converting a plain value to a class.
    26|    */
    27|   excludeExtraneousValues?: boolean;
    28|   /**
    29|    * Only properties with given groups gonna be transformed.
    30|    */
    31|   groups?: string[];
    32|   /**
    33|    * Only properties with "since" > version < "until" gonna be transformed.
    34|    */
    35|   version?: number;
    36|   /**
    37|    * Excludes properties with the given prefixes. For example, if you mark your private properties with "_" and "__"
    38|    * you can set this option's value to ["_", "__"] and all private properties will be skipped.
    39|    * This works only for "exposeAll" strategy.
    40|    */
    41|   excludePrefixes?: string[];
    42|   /**
    43|    * If set to true then class transformer will ignore all @Expose and @Exclude decorators and what inside them.
    44|    * This option is useful if you want to kinda clone your object but do not apply decorators affects.
    45|    */
    46|   ignoreDecorators?: boolean;
    47|   /**
    48|    * Target maps allows to set a Types of the transforming object without using @Type decorator.
    49|    * This is useful when you are transforming external classes, or if you already have type metadata for
    50|    * objects and you don't want to set it up again.
    51|    */
    52|   targetMaps?: TargetMap[];
    53|   /**
    54|    * If set to true then class transformer will perform a circular check. (circular check is turned off by default)
    55|    * This option is useful when you know for sure that your types might have a circular dependency.
    56|    */
    57|   enableCircularCheck?: boolean;
    58|   /**
    59|    * If set to true then class transformer will try to convert properties implicitly to their target type based on their typing information.
    60|    *
    61|    * DEFAULT: `false`
    62|    */
    63|   enableImplicitConversion?: boolean;
    64| }


# ====================================================================
# FILE: src/ClassTransformer.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-121 ---
     1| import { ClassTransformOptions } from './ClassTransformOptions';
     2| import { TransformOperationExecutor } from './TransformOperationExecutor';
     3| import { TransformationType } from './enums';
     4| export type ClassType<T> = {
     5|   new (...args: any[]): T;
     6| };
     7| export class ClassTransformer {
     8|   /**
     9|    * Converts class (constructor) object to plain (literal) object. Also works with arrays.
    10|    */
    11|   classToPlain<T extends Record<string, any>>(object: T, options?: ClassTransformOptions): Record<string, any>;
    12|   classToPlain<T extends Record<string, any>>(object: T[], options?: ClassTransformOptions): Record<string, any>[];
    13|   classToPlain<T extends Record<string, any>>(
    14|     object: T | T[],
    15|     options?: ClassTransformOptions
    16|   ): Record<string, any> | Record<string, any>[] {
    17|     const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
    18|     return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
    19|   }
    20|   /**
    21|    * Converts class (constructor) object to plain (literal) object.
    22|    * Uses given plain object as source object (it means fills given plain object with data from class object).
    23|    * Also works with arrays.
    24|    */
    25|   classToPlainFromExist<T extends Record<string, any>, P>(
    26|     object: T,
    27|     plainObject: P,
    28|     options?: ClassTransformOptions
    29|   ): T;
    30|   classToPlainFromExist<T extends Record<string, any>, P>(
    31|     object: T,
    32|     plainObjects: P[],
    33|     options?: ClassTransformOptions
    34|   ): T[];
    35|   classToPlainFromExist<T extends Record<string, any>, P>(
    36|     object: T,
    37|     plainObject: P | P[],
    38|     options?: ClassTransformOptions
    39|   ): T | T[] {
    40|     const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
    41|     return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);
    42|   }
    43|   /**
    44|    * Converts plain (literal) object to class (constructor) object. Also works with arrays.
    45|    */
    46|   plainToClass<T extends Record<string, any>, V extends Array<any>>(
    47|     cls: ClassType<T>,
    48|     plain: V,
    49|     options?: ClassTransformOptions
    50|   ): T[];
    51|   plainToClass<T extends Record<string, any>, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
    52|   plainToClass<T extends Record<string, any>, V>(
    53|     cls: ClassType<T>,
    54|     plain: V | V[],
    55|     options?: ClassTransformOptions
    56|   ): T | T[] {
    57|     const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
    58|     return executor.transform(undefined, plain, cls, undefined, undefined, undefined);
    59|   }
    60|   /**
    61|    * Converts plain (literal) object to class (constructor) object.
    62|    * Uses given object as source object (it means fills given object with data from plain object).
    63|    * Also works with arrays.
    64|    */
    65|   plainToClassFromExist<T extends Record<string, any>, V extends Array<any>>(
    66|     clsObject: T,
    67|     plain: V,
    68|     options?: ClassTransformOptions
    69|   ): T;
    70|   plainToClassFromExist<T extends Record<string, any>, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];
    71|   plainToClassFromExist<T extends Record<string, any>, V>(
    72|     clsObject: T,
    73|     plain: V | V[],
    74|     options?: ClassTransformOptions
    75|   ): T | T[] {
    76|     const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
    77|     return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);
    78|   }
    79|   /**
    80|    * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
    81|    */
    82|   classToClass<T>(object: T, options?: ClassTransformOptions): T;
    83|   classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
    84|   classToClass<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {
    85|     const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
    86|     return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
    87|   }
    88|   /**
    89|    * Converts class (constructor) object to plain (literal) object.
    90|    * Uses given plain object as source object (it means fills given plain object with data from class object).
    91|    * Also works with arrays.
    92|    */
    93|   classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
    94|   classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
    95|   classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {
    96|     const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
    97|     return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);
    98|   }
    99|   /**
   100|    * Serializes given object to a JSON string.
   101|    */
   102|   serialize<T>(object: T, options?: ClassTransformOptions): string;
   103|   serialize<T>(object: T[], options?: ClassTransformOptions): string;
   104|   serialize<T>(object: T | T[], options?: ClassTransformOptions): string {
   105|     return JSON.stringify(this.classToPlain(object, options));
   106|   }
   107|   /**
   108|    * Deserializes given JSON string to a object of the given class.
   109|    */
   110|   deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
   111|     const jsonObject: T = JSON.parse(json);
   112|     return this.plainToClass(cls, jsonObject, options);
   113|   }
   114|   /**
   115|    * Deserializes given JSON string to an array of objects of the given class.
   116|    */
   117|   deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
   118|     const jsonObject: any[] = JSON.parse(json);
   119|     return this.plainToClass(cls, jsonObject, options);
   120|   }
   121| }


# ====================================================================
# FILE: src/TransformOperationExecutor.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-412 ---
     1| import { ClassTransformOptions } from './ClassTransformOptions';
     2| import { defaultMetadataStorage } from './storage';
     3| import { TypeHelpOptions, TypeOptions } from './metadata/ExposeExcludeOptions';
     4| import { TypeMetadata } from './metadata/TypeMetadata';
     5| import { TransformationType } from './enums';
     6| export function testForBuffer(): boolean {
     7|   try {
     8|     Buffer.isBuffer({
     9|       /* empty object */
    10|     });
    11|     return true;
    12|   } catch {
    13|     return false;
    14|   }
    15| }
    16| function instantiateArrayType(arrayType: Function): Array<any> | Set<any> {
    17|   const array = new (arrayType as any)();
    18|   if (!(array instanceof Set) && !('push' in array)) {
    19|     return [];
    20|   }
    21|   return array;
    22| }
    23| export class TransformOperationExecutor {
    24|   private recursionStack = new Set<Record<string, any>>();
    25|   constructor(private transformationType: TransformationType, private options: ClassTransformOptions) {}
    26|   transform(
    27|     source: Record<string, any> | Record<string, any>[] | any,
    28|     value: Record<string, any> | Record<string, any>[] | any,
    29|     targetType: Function | TypeMetadata,
    30|     arrayType: Function,
    31|     isMap: boolean,
    32|     level: number = 0
    33|   ): any {
    34|     if (Array.isArray(value) || value instanceof Set) {
    35|       const newValue =
    36|         arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS
    37|           ? instantiateArrayType(arrayType)
    38|           : [];
    39|       (value as any[]).forEach((subValue, index) => {
    40|         const subSource = source ? source[index] : undefined;
    41|         if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
    42|           let realTargetType;
    43|           if (
    44|             typeof targetType !== 'function' &&
    45|             targetType &&
    46|             targetType.options &&
    47|             targetType.options.discriminator &&
    48|             targetType.options.discriminator.property &&
    49|             targetType.options.discriminator.subTypes
    50|           ) {
    51|             if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
    52|               realTargetType = targetType.options.discriminator.subTypes.find(
    53|                 subType =>
    54|                   subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]
    55|               );
    56|               const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };
    57|               const newType = targetType.typeFunction(options);
    58|               realTargetType === undefined ? (realTargetType = newType) : (realTargetType = realTargetType.value);
    59|               if (!targetType.options.keepDiscriminatorProperty)
    60|                 delete subValue[targetType.options.discriminator.property];
    61|             }
    62|             if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
    63|               realTargetType = subValue.constructor;
    64|             }
    65|             if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
    66|               subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find(
    67|                 subType => subType.value === subValue.constructor
    68|               ).name;
    69|             }
    70|           } else {
    71|             realTargetType = targetType;
    72|           }
    73|           const value = this.transform(
    74|             subSource,
    75|             subValue,
    76|             realTargetType,
    77|             undefined,
    78|             subValue instanceof Map,
    79|             level + 1
    80|           );
    81|           if (newValue instanceof Set) {
    82|             newValue.add(value);
    83|           } else {
    84|             newValue.push(value);
    85|           }
    86|         } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
    87|           if (newValue instanceof Set) {
    88|             newValue.add(subValue);
    89|           } else {
    90|             newValue.push(subValue);
    91|           }
    92|         }
    93|       });
    94|       return newValue;
    95|     } else if (targetType === String && !isMap) {
    96|       if (value === null || value === undefined) return value;
    97|       return String(value);
    98|     } else if (targetType === Number && !isMap) {
    99|       if (value === null || value === undefined) return value;
   100|       return Number(value);
   101|     } else if (targetType === Boolean && !isMap) {
   102|       if (value === null || value === undefined) return value;
   103|       return Boolean(value);
   104|     } else if ((targetType === Date || value instanceof Date) && !isMap) {
   105|       if (value instanceof Date) {
   106|         return new Date(value.valueOf());
   107|       }
   108|       if (value === null || value === undefined) return value;
   109|       return new Date(value);
   110|     } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {
   111|       if (value === null || value === undefined) return value;
   112|       return Buffer.from(value);
   113|     } else if (typeof value === 'object' && value !== null) {
   114|       if (!targetType && value.constructor !== Object /* && TransformationType === TransformationType.CLASS_TO_PLAIN*/)
   115|         targetType = value.constructor;
   116|       if (!targetType && source) targetType = source.constructor;
   117|       if (this.options.enableCircularCheck) {
   118|         this.recursionStack.add(value);
   119|       }
   120|       const keys = this.getKeys(targetType as Function, value);
   121|       let newValue: any = source ? source : {};
   122|       if (
   123|         !source &&
   124|         (this.transformationType === TransformationType.PLAIN_TO_CLASS ||
   125|           this.transformationType === TransformationType.CLASS_TO_CLASS)
   126|       ) {
   127|         if (isMap) {
   128|           newValue = new Map();
   129|         } else if (targetType) {
   130|           newValue = new (targetType as any)();
   131|         } else {
   132|           newValue = {};
   133|         }
   134|       }
   135|       for (const key of keys) {
   136|         if (key === '__proto__' || key === 'constructor') {
   137|           continue;
   138|         }
   139|         const valueKey = key;
   140|         let newValueKey = key,
   141|           propertyName = key;
   142|         if (!this.options.ignoreDecorators && targetType) {
   143|           if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   144|             const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName(targetType as Function, key);
   145|             if (exposeMetadata) {
   146|               propertyName = exposeMetadata.propertyName;
   147|               newValueKey = exposeMetadata.propertyName;
   148|             }
   149|           } else if (
   150|             this.transformationType === TransformationType.CLASS_TO_PLAIN ||
   151|             this.transformationType === TransformationType.CLASS_TO_CLASS
   152|           ) {
   153|             const exposeMetadata = defaultMetadataStorage.findExposeMetadata(targetType as Function, key);
   154|             if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
   155|               newValueKey = exposeMetadata.options.name;
   156|             }
   157|           }
   158|         }
   159|         let subValue: any = undefined;
   160|         if (value instanceof Map) {
   161|           subValue = value.get(valueKey);
   162|         } else if (value[valueKey] instanceof Function) {
   163|           subValue = value[valueKey]();
   164|         } else {
   165|           subValue = value[valueKey];
   166|         }
   167|         let type: any = undefined,
   168|           isSubValueMap = subValue instanceof Map;
   169|         if (targetType && isMap) {
   170|           type = targetType;
   171|         } else if (targetType) {
   172|           const metadata = defaultMetadataStorage.findTypeMetadata(targetType as Function, propertyName);
   173|           if (metadata) {
   174|             const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };
   175|             const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
   176|             if (
   177|               metadata.options &&
   178|               metadata.options.discriminator &&
   179|               metadata.options.discriminator.property &&
   180|               metadata.options.discriminator.subTypes
   181|             ) {
   182|               if (!(value[valueKey] instanceof Array)) {
   183|                 if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   184|                   type = metadata.options.discriminator.subTypes.find(subType => {
   185|                     if (subValue && metadata.options.discriminator.property in subValue) {
   186|                       return subType.name === subValue[metadata.options.discriminator.property];
   187|                     }
   188|                   });
   189|                   type === undefined ? (type = newType) : (type = type.value);
   190|                   if (!metadata.options.keepDiscriminatorProperty) {
   191|                     if (subValue && metadata.options.discriminator.property in subValue) {
   192|                       delete subValue[metadata.options.discriminator.property];
   193|                     }
   194|                   }
   195|                 }
   196|                 if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
   197|                   type = subValue.constructor;
   198|                 }
   199|                 if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
   200|                   subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find(
   201|                     subType => subType.value === subValue.constructor
   202|                   ).name;
   203|                 }
   204|               } else {
   205|                 type = metadata;
   206|               }
   207|             } else {
   208|               type = newType;
   209|             }
   210|             isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
   211|           } else if (this.options.targetMaps) {
   212|             this.options.targetMaps
   213|               .filter(map => map.target === targetType && !!map.properties[propertyName])
   214|               .forEach(map => (type = map.properties[propertyName]));
   215|           } else if (
   216|             this.options.enableImplicitConversion &&
   217|             this.transformationType === TransformationType.PLAIN_TO_CLASS
   218|           ) {
   219|             const reflectedType = (Reflect as any).getMetadata(
   220|               'design:type',
   221|               (targetType as Function).prototype,
   222|               propertyName
   223|             );
   224|             if (reflectedType) {
   225|               type = reflectedType;
   226|             }
   227|           }
   228|         }
   229|         const arrayType = Array.isArray(value[valueKey])
   230|           ? this.getReflectedType(targetType as Function, propertyName)
   231|           : undefined;
   232|         const subSource = source ? source[valueKey] : undefined;
   233|         if (newValue.constructor.prototype) {
   234|           const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
   235|           if (
   236|             (this.transformationType === TransformationType.PLAIN_TO_CLASS ||
   237|               this.transformationType === TransformationType.CLASS_TO_CLASS) &&
   238|             ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)
   239|           )
   240|             continue;
   241|         }
   242|         if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
   243|           const transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
   244|           let finalValue;
   245|           if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
   246|             finalValue = value[transformKey];
   247|             finalValue = this.applyCustomTransformations(
   248|               finalValue,
   249|               targetType as Function,
   250|               transformKey,
   251|               value,
   252|               this.transformationType
   253|             );
   254|             finalValue = value[transformKey] === finalValue ? subValue : finalValue;
   255|             finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);
   256|           } else {
   257|             finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);
   258|             finalValue = this.applyCustomTransformations(
   259|               finalValue,
   260|               targetType as Function,
   261|               transformKey,
   262|               value,
   263|               this.transformationType
   264|             );
   265|           }
   266|           if (newValue instanceof Map) {
   267|             newValue.set(newValueKey, finalValue);
   268|           } else {
   269|             newValue[newValueKey] = finalValue;
   270|           }
   271|         } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
   272|           let finalValue = subValue;
   273|           finalValue = this.applyCustomTransformations(
   274|             finalValue,
   275|             targetType as Function,
   276|             key,
   277|             value,
   278|             this.transformationType
   279|           );
   280|           if (newValue instanceof Map) {
   281|             newValue.set(newValueKey, finalValue);
   282|           } else {
   283|             newValue[newValueKey] = finalValue;
   284|           }
   285|         }
   286|       }
   287|       if (this.options.enableCircularCheck) {
   288|         this.recursionStack.delete(value);
   289|       }
   290|       return newValue;
   291|     } else {
   292|       return value;
   293|     }
   294|   }
   295|   private applyCustomTransformations(
   296|     value: any,
   297|     target: Function,
   298|     key: string,
   299|     obj: any,
   300|     transformationType: TransformationType
   301|   ): boolean {
   302|     let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
   303|     if (this.options.version !== undefined) {
   304|       metadatas = metadatas.filter(metadata => {
   305|         if (!metadata.options) return true;
   306|         return this.checkVersion(metadata.options.since, metadata.options.until);
   307|       });
   308|     }
   309|     if (this.options.groups && this.options.groups.length) {
   310|       metadatas = metadatas.filter(metadata => {
   311|         if (!metadata.options) return true;
   312|         return this.checkGroups(metadata.options.groups);
   313|       });
   314|     } else {
   315|       metadatas = metadatas.filter(metadata => {
   316|         return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
   317|       });
   318|     }
   319|     metadatas.forEach(metadata => {
   320|       value = metadata.transformFn(value, obj, transformationType);
   321|     });
   322|     return value;
   323|   }
   324|   private isCircular(object: Record<string, any>): boolean {
   325|     return this.recursionStack.has(object);
   326|   }
   327|   private getReflectedType(target: Function, propertyName: string): Function | undefined {
   328|     if (!target) return undefined;
   329|     const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
   330|     return meta ? meta.reflectedType : undefined;
   331|   }
   332|   private getKeys(target: Function, object: Record<string, any>): string[] {
   333|     let strategy = defaultMetadataStorage.getStrategy(target);
   334|     if (strategy === 'none') strategy = this.options.strategy || 'exposeAll'; // exposeAll is default strategy
   335|     let keys: any[] = [];
   336|     if (strategy === 'exposeAll') {
   337|       if (object instanceof Map) {
   338|         keys = Array.from(object.keys());
   339|       } else {
   340|         keys = Object.keys(object);
   341|       }
   342|     }
   343|     if (!this.options.ignoreDecorators && target) {
   344|       let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
   345|       if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   346|         exposedProperties = exposedProperties.map(key => {
   347|           const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   348|           if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
   349|             return exposeMetadata.options.name;
   350|           }
   351|           return key;
   352|         });
   353|       }
   354|       if (this.options.excludeExtraneousValues) {
   355|         keys = exposedProperties;
   356|       } else {
   357|         keys = keys.concat(exposedProperties);
   358|       }
   359|       const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
   360|       if (excludedProperties.length > 0) {
   361|         keys = keys.filter(key => {
   362|           return !excludedProperties.includes(key);
   363|         });
   364|       }
   365|       if (this.options.version !== undefined) {
   366|         keys = keys.filter(key => {
   367|           const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   368|           if (!exposeMetadata || !exposeMetadata.options) return true;
   369|           return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
   370|         });
   371|       }
   372|       if (this.options.groups && this.options.groups.length) {
   373|         keys = keys.filter(key => {
   374|           const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   375|           if (!exposeMetadata || !exposeMetadata.options) return true;
   376|           return this.checkGroups(exposeMetadata.options.groups);
   377|         });
   378|       } else {
   379|         keys = keys.filter(key => {
   380|           const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   381|           return (
   382|             !exposeMetadata ||
   383|             !exposeMetadata.options ||
   384|             !exposeMetadata.options.groups ||
   385|             !exposeMetadata.options.groups.length
   386|           );
   387|         });
   388|       }
   389|     }
   390|     if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
   391|       keys = keys.filter(key =>
   392|         this.options.excludePrefixes.every(prefix => {
   393|           return key.substr(0, prefix.length) !== prefix;
   394|         })
   395|       );
   396|     }
   397|     keys = keys.filter((key, index, self) => {
   398|       return self.indexOf(key) === index;
   399|     });
   400|     return keys;
   401|   }
   402|   private checkVersion(since: number, until: number): boolean {
   403|     let decision = true;
   404|     if (decision && since) decision = this.options.version >= since;
   405|     if (decision && until) decision = this.options.version < until;
   406|     return decision;
   407|   }
   408|   private checkGroups(groups: string[]): boolean {
   409|     if (!groups) return true;
   410|     return this.options.groups.some(optionGroup => groups.includes(optionGroup));
   411|   }
   412| }


# ====================================================================
# FILE: src/decorators.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-119 ---
     1| import { ClassTransformer } from './ClassTransformer';
     2| import { defaultMetadataStorage } from './storage';
     3| import { TypeMetadata } from './metadata/TypeMetadata';
     4| import { ExposeMetadata } from './metadata/ExposeMetadata';
     5| import {
     6|   ExposeOptions,
     7|   ExcludeOptions,
     8|   TypeHelpOptions,
     9|   TransformOptions,
    10|   TypeOptions,
    11| } from './metadata/ExposeExcludeOptions';
    12| import { ExcludeMetadata } from './metadata/ExcludeMetadata';
    13| import { TransformMetadata } from './metadata/TransformMetadata';
    14| import { ClassTransformOptions } from './ClassTransformOptions';
    15| import { TransformationType } from './enums';
    16| /**
    17|  * Defines a custom logic for value transformation.
    18|  */
    19| export function Transform(
    20|   transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
    21|   options?: TransformOptions
    22| ) {
    23|   return function (target: any, key: string): void {
    24|     const metadata = new TransformMetadata(target.constructor, key, transformFn, options);
    25|     defaultMetadataStorage.addTransformMetadata(metadata);
    26|   };
    27| }
    28| /**
    29|  * Specifies a type of the property.
    30|  * The given TypeFunction can return a constructor. A discriminator can be given in the options.
    31|  */
    32| export function Type(typeFunction?: (type?: TypeHelpOptions) => Function, options?: TypeOptions) {
    33|   return function (target: any, key: string): void {
    34|     const type = (Reflect as any).getMetadata('design:type', target, key);
    35|     const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);
    36|     defaultMetadataStorage.addTypeMetadata(metadata);
    37|   };
    38| }
    39| /**
    40|  * Marks property as included in the process of transformation. By default it includes the property for both
    41|  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
    42|  * you want to skip this property.
    43|  */
    44| export function Expose(options?: ExposeOptions) {
    45|   return function (object: Record<string, any> | Function, propertyName?: string): void {
    46|     const metadata = new ExposeMetadata(
    47|       object instanceof Function ? object : object.constructor,
    48|       propertyName,
    49|       options || {}
    50|     );
    51|     defaultMetadataStorage.addExposeMetadata(metadata);
    52|   };
    53| }
    54| /**
    55|  * Marks property as excluded from the process of transformation. By default it excludes the property for both
    56|  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
    57|  * you want to skip this property.
    58|  */
    59| export function Exclude(options?: ExcludeOptions) {
    60|   return function (object: Record<string, any> | Function, propertyName?: string): void {
    61|     const metadata = new ExcludeMetadata(
    62|       object instanceof Function ? object : object.constructor,
    63|       propertyName,
    64|       options || {}
    65|     );
    66|     defaultMetadataStorage.addExcludeMetadata(metadata);
    67|   };
    68| }
    69| /**
    70|  * Transform the object from class to plain object and return only with the exposed properties.
    71|  */
    72| export function TransformClassToPlain(params?: ClassTransformOptions): Function {
    73|   return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
    74|     const classTransformer: ClassTransformer = new ClassTransformer();
    75|     const originalMethod = descriptor.value;
    76|     descriptor.value = function (...args: any[]): Record<string, any> {
    77|       const result: any = originalMethod.apply(this, args);
    78|       const isPromise =
    79|         !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
    80|       return isPromise
    81|         ? result.then((data: any) => classTransformer.classToPlain(data, params))
    82|         : classTransformer.classToPlain(result, params);
    83|     };
    84|   };
    85| }
    86| /**
    87|  * Return the class instance only with the exposed properties.
    88|  */
    89| export function TransformClassToClass(params?: ClassTransformOptions): Function {
    90|   return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
    91|     const classTransformer: ClassTransformer = new ClassTransformer();
    92|     const originalMethod = descriptor.value;
    93|     descriptor.value = function (...args: any[]): Record<string, any> {
    94|       const result: any = originalMethod.apply(this, args);
    95|       const isPromise =
    96|         !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
    97|       return isPromise
    98|         ? result.then((data: any) => classTransformer.classToClass(data, params))
    99|         : classTransformer.classToClass(result, params);
   100|     };
   101|   };
   102| }
   103| /**
   104|  * Return the class instance only with the exposed properties.
   105|  */
   106| export function TransformPlainToClass(classType: any, params?: ClassTransformOptions): Function {
   107|   return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor): void {
   108|     const classTransformer: ClassTransformer = new ClassTransformer();
   109|     const originalMethod = descriptor.value;
   110|     descriptor.value = function (...args: any[]): Record<string, any> {
   111|       const result: any = originalMethod.apply(this, args);
   112|       const isPromise =
   113|         !!result && (typeof result === 'object' || typeof result === 'function') && typeof result.then === 'function';
   114|       return isPromise
   115|         ? result.then((data: any) => classTransformer.plainToClass(classType, data, params))
   116|         : classTransformer.plainToClass(classType, result, params);
   117|     };
   118|   };
   119| }


# ====================================================================
# FILE: src/enums/index.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| export * from './transformation-type.enum';


# ====================================================================
# FILE: src/enums/transformation-type.enum.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| export enum TransformationType {
     2|   PLAIN_TO_CLASS,
     3|   CLASS_TO_PLAIN,
     4|   CLASS_TO_CLASS,
     5| }


# ====================================================================
# FILE: src/index.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| import { ClassTransformer, ClassType } from './ClassTransformer';
     2| import { ClassTransformOptions } from './ClassTransformOptions';
     3| export { ClassTransformer } from './ClassTransformer';
     4| export { ClassTransformOptions } from './ClassTransformOptions';
     5| export * from './metadata/ExposeExcludeOptions';
     6| export * from './decorators';
     7| const classTransformer = new ClassTransformer();
     8| /**
     9|  * Converts class (constructor) object to plain (literal) object. Also works with arrays.
    10|  */
    11| export function classToPlain<T>(object: T, options?: ClassTransformOptions): Record<string, any>;
    12| export function classToPlain<T>(object: T[], options?: ClassTransformOptions): Record<string, any>[];
    13| export function classToPlain<T>(
    14|   object: T | T[],
    15|   options?: ClassTransformOptions
    16| ): Record<string, any> | Record<string, any>[] {
    17|   return classTransformer.classToPlain(object, options);
    18| }
    19| /**
    20|  * Converts class (constructor) object to plain (literal) object.
    21|  * Uses given plain object as source object (it means fills given plain object with data from class object).
    22|  * Also works with arrays.
    23|  */
    24| export function classToPlainFromExist<T>(
    25|   object: T,
    26|   plainObject: Record<string, any>,
    27|   options?: ClassTransformOptions
    28| ): Record<string, any>;
    29| export function classToPlainFromExist<T>(
    30|   object: T,
    31|   plainObjects: Record<string, any>[],
    32|   options?: ClassTransformOptions
    33| ): Record<string, any>[];
    34| export function classToPlainFromExist<T>(
    35|   object: T,
    36|   plainObject: Record<string, any> | Record<string, any>[],
    37|   options?: ClassTransformOptions
    38| ): Record<string, any> | Record<string, any>[] {
    39|   return classTransformer.classToPlainFromExist(object, plainObject, options);
    40| }
    41| /**
    42|  * Converts plain (literal) object to class (constructor) object. Also works with arrays.
    43|  */
    44| export function plainToClass<T, V>(cls: ClassType<T>, plain: V[], options?: ClassTransformOptions): T[];
    45| export function plainToClass<T, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
    46| export function plainToClass<T, V>(cls: ClassType<T>, plain: V | V[], options?: ClassTransformOptions): T | T[] {
    47|   return classTransformer.plainToClass(cls, plain as any, options);
    48| }
    49| /**
    50|  * Converts plain (literal) object to class (constructor) object.
    51|  * Uses given object as source object (it means fills given object with data from plain object).
    52|  *  Also works with arrays.
    53|  */
    54| export function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];
    55| export function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;
    56| export function plainToClassFromExist<T, V>(clsObject: T, plain: V | V[], options?: ClassTransformOptions): T | T[] {
    57|   return classTransformer.plainToClassFromExist(clsObject, plain, options);
    58| }
    59| /**
    60|  * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
    61|  */
    62| export function classToClass<T>(object: T, options?: ClassTransformOptions): T;
    63| export function classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
    64| export function classToClass<T>(object: T | T[], options?: ClassTransformOptions): T | T[] {
    65|   return classTransformer.classToClass(object, options);
    66| }
    67| /**
    68|  * Converts class (constructor) object to plain (literal) object.
    69|  * Uses given plain object as source object (it means fills given plain object with data from class object).
    70|  * Also works with arrays.
    71|  */
    72| export function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
    73| export function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
    74| export function classToClassFromExist<T>(object: T, fromObject: T | T[], options?: ClassTransformOptions): T | T[] {
    75|   return classTransformer.classToClassFromExist(object, fromObject, options);
    76| }
    77| /**
    78|  * Serializes given object to a JSON string.
    79|  */
    80| export function serialize<T>(object: T, options?: ClassTransformOptions): string;
    81| export function serialize<T>(object: T[], options?: ClassTransformOptions): string;
    82| export function serialize<T>(object: T | T[], options?: ClassTransformOptions): string {
    83|   return classTransformer.serialize(object, options);
    84| }
    85| /**
    86|  * Deserializes given JSON string to a object of the given class.
    87|  */
    88| export function deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
    89|   return classTransformer.deserialize(cls, json, options);
    90| }
    91| /**
    92|  * Deserializes given JSON string to an array of objects of the given class.
    93|  */
    94| export function deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
    95|   return classTransformer.deserializeArray(cls, json, options);
    96| }
    97| /**
    98|  * Enum representing the different transformation types.
    99|  */
   100| export enum TransformationType {
   101|   PLAIN_TO_CLASS,
   102|   CLASS_TO_PLAIN,
   103|   CLASS_TO_CLASS,
   104| }


# ====================================================================
# FILE: src/metadata/ExcludeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| import { ExcludeOptions } from './ExposeExcludeOptions';
     2| export class ExcludeMetadata {
     3|   constructor(public target: Function, public propertyName: string, public options: ExcludeOptions) {}
     4| }


# ====================================================================
# FILE: src/metadata/ExposeExcludeOptions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| export interface TransformOptions {
     2|   since?: number;
     3|   until?: number;
     4|   groups?: string[];
     5|   toClassOnly?: boolean;
     6|   toPlainOnly?: boolean;
     7| }
     8| export interface TypeOptions {
     9|   discriminator?: Discriminator;
    10|   /**
    11|    * Is false by default.
    12|    */
    13|   keepDiscriminatorProperty?: boolean;
    14| }
    15| export interface TypeHelpOptions {
    16|   newObject: any;
    17|   object: Record<string, any>;
    18|   property: string;
    19| }
    20| export interface ExposeOptions {
    21|   name?: string;
    22|   since?: number;
    23|   until?: number;
    24|   groups?: string[];
    25|   toClassOnly?: boolean;
    26|   toPlainOnly?: boolean;
    27| }
    28| export interface ExcludeOptions {
    29|   toClassOnly?: boolean;
    30|   toPlainOnly?: boolean;
    31| }
    32| export interface Discriminator {
    33|   property: string;
    34|   subTypes: JsonSubType[];
    35| }
    36| export interface JsonSubType {
    37|   value: new (...args: any[]) => any;
    38|   name: string;
    39| }


# ====================================================================
# FILE: src/metadata/ExposeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| import { ExposeOptions } from './ExposeExcludeOptions';
     2| export class ExposeMetadata {
     3|   constructor(public target: Function, public propertyName: string, public options: ExposeOptions) {}
     4| }


# ====================================================================
# FILE: src/metadata/MetadataStorage.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-215 ---
     1| import { TypeMetadata } from './TypeMetadata';
     2| import { ExposeMetadata } from './ExposeMetadata';
     3| import { ExcludeMetadata } from './ExcludeMetadata';
     4| import { TransformMetadata } from './TransformMetadata';
     5| import { TransformationType } from '../enums';
     6| /**
     7|  * Storage all library metadata.
     8|  */
     9| export class MetadataStorage {
    10|   private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();
    11|   private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();
    12|   private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();
    13|   private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();
    14|   private _ancestorsMap = new Map<Function, Function[]>();
    15|   addTypeMetadata(metadata: TypeMetadata): void {
    16|     if (!this._typeMetadatas.has(metadata.target)) {
    17|       this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());
    18|     }
    19|     this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    20|   }
    21|   addTransformMetadata(metadata: TransformMetadata): void {
    22|     if (!this._transformMetadatas.has(metadata.target)) {
    23|       this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());
    24|     }
    25|     if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
    26|       this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
    27|     }
    28|     this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
    29|   }
    30|   addExposeMetadata(metadata: ExposeMetadata): void {
    31|     if (!this._exposeMetadatas.has(metadata.target)) {
    32|       this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());
    33|     }
    34|     this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    35|   }
    36|   addExcludeMetadata(metadata: ExcludeMetadata): void {
    37|     if (!this._excludeMetadatas.has(metadata.target)) {
    38|       this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());
    39|     }
    40|     this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    41|   }
    42|   findTransformMetadatas(
    43|     target: Function,
    44|     propertyName: string,
    45|     transformationType: TransformationType
    46|   ): TransformMetadata[] {
    47|     return this.findMetadatas(this._transformMetadatas, target, propertyName).filter(metadata => {
    48|       if (!metadata.options) return true;
    49|       if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
    50|       if (metadata.options.toClassOnly === true) {
    51|         return (
    52|           transformationType === TransformationType.CLASS_TO_CLASS ||
    53|           transformationType === TransformationType.PLAIN_TO_CLASS
    54|         );
    55|       }
    56|       if (metadata.options.toPlainOnly === true) {
    57|         return transformationType === TransformationType.CLASS_TO_PLAIN;
    58|       }
    59|       return true;
    60|     });
    61|   }
    62|   findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {
    63|     return this.findMetadata(this._excludeMetadatas, target, propertyName);
    64|   }
    65|   findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {
    66|     return this.findMetadata(this._exposeMetadatas, target, propertyName);
    67|   }
    68|   findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {
    69|     return this.getExposedMetadatas(target).find(metadata => {
    70|       return metadata.options && metadata.options.name === name;
    71|     });
    72|   }
    73|   findTypeMetadata(target: Function, propertyName: string): TypeMetadata {
    74|     return this.findMetadata(this._typeMetadatas, target, propertyName);
    75|   }
    76|   getStrategy(target: Function): 'excludeAll' | 'exposeAll' | 'none' {
    77|     const excludeMap = this._excludeMetadatas.get(target);
    78|     const exclude = excludeMap && excludeMap.get(undefined);
    79|     const exposeMap = this._exposeMetadatas.get(target);
    80|     const expose = exposeMap && exposeMap.get(undefined);
    81|     if ((exclude && expose) || (!exclude && !expose)) return 'none';
    82|     return exclude ? 'excludeAll' : 'exposeAll';
    83|   }
    84|   getExposedMetadatas(target: Function): ExposeMetadata[] {
    85|     return this.getMetadata(this._exposeMetadatas, target);
    86|   }
    87|   getExcludedMetadatas(target: Function): ExcludeMetadata[] {
    88|     return this.getMetadata(this._excludeMetadatas, target);
    89|   }
    90|   getExposedProperties(target: Function, transformationType: TransformationType): string[] {
    91|     return this.getExposedMetadatas(target)
    92|       .filter(metadata => {
    93|         if (!metadata.options) return true;
    94|         if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
    95|         if (metadata.options.toClassOnly === true) {
    96|           return (
    97|             transformationType === TransformationType.CLASS_TO_CLASS ||
    98|             transformationType === TransformationType.PLAIN_TO_CLASS
    99|           );
   100|         }
   101|         if (metadata.options.toPlainOnly === true) {
   102|           return transformationType === TransformationType.CLASS_TO_PLAIN;
   103|         }
   104|         return true;
   105|       })
   106|       .map(metadata => metadata.propertyName);
   107|   }
   108|   getExcludedProperties(target: Function, transformationType: TransformationType): string[] {
   109|     return this.getExcludedMetadatas(target)
   110|       .filter(metadata => {
   111|         if (!metadata.options) return true;
   112|         if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true) return true;
   113|         if (metadata.options.toClassOnly === true) {
   114|           return (
   115|             transformationType === TransformationType.CLASS_TO_CLASS ||
   116|             transformationType === TransformationType.PLAIN_TO_CLASS
   117|           );
   118|         }
   119|         if (metadata.options.toPlainOnly === true) {
   120|           return transformationType === TransformationType.CLASS_TO_PLAIN;
   121|         }
   122|         return true;
   123|       })
   124|       .map(metadata => metadata.propertyName);
   125|   }
   126|   clear(): void {
   127|     this._typeMetadatas.clear();
   128|     this._exposeMetadatas.clear();
   129|     this._excludeMetadatas.clear();
   130|     this._ancestorsMap.clear();
   131|   }
   132|   private getMetadata<T extends { target: Function; propertyName: string }>(
   133|     metadatas: Map<Function, Map<string, T>>,
   134|     target: Function
   135|   ): T[] {
   136|     const metadataFromTargetMap = metadatas.get(target);
   137|     let metadataFromTarget: T[];
   138|     if (metadataFromTargetMap) {
   139|       metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);
   140|     }
   141|     const metadataFromAncestors: T[] = [];
   142|     for (const ancestor of this.getAncestors(target)) {
   143|       const ancestorMetadataMap = metadatas.get(ancestor);
   144|       if (ancestorMetadataMap) {
   145|         const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(
   146|           meta => meta.propertyName !== undefined
   147|         );
   148|         metadataFromAncestors.push(...metadataFromAncestor);
   149|       }
   150|     }
   151|     return metadataFromAncestors.concat(metadataFromTarget || []);
   152|   }
   153|   private findMetadata<T extends { target: Function; propertyName: string }>(
   154|     metadatas: Map<Function, Map<string, T>>,
   155|     target: Function,
   156|     propertyName: string
   157|   ): T {
   158|     const metadataFromTargetMap = metadatas.get(target);
   159|     if (metadataFromTargetMap) {
   160|       const metadataFromTarget = metadataFromTargetMap.get(propertyName);
   161|       if (metadataFromTarget) {
   162|         return metadataFromTarget;
   163|       }
   164|     }
   165|     for (const ancestor of this.getAncestors(target)) {
   166|       const ancestorMetadataMap = metadatas.get(ancestor);
   167|       if (ancestorMetadataMap) {
   168|         const ancestorResult = ancestorMetadataMap.get(propertyName);
   169|         if (ancestorResult) {
   170|           return ancestorResult;
   171|         }
   172|       }
   173|     }
   174|     return undefined;
   175|   }
   176|   private findMetadatas<T extends { target: Function; propertyName: string }>(
   177|     metadatas: Map<Function, Map<string, T[]>>,
   178|     target: Function,
   179|     propertyName: string
   180|   ): T[] {
   181|     const metadataFromTargetMap = metadatas.get(target);
   182|     let metadataFromTarget: T[];
   183|     if (metadataFromTargetMap) {
   184|       metadataFromTarget = metadataFromTargetMap.get(propertyName);
   185|     }
   186|     const metadataFromAncestorsTarget: T[] = [];
   187|     for (const ancestor of this.getAncestors(target)) {
   188|       const ancestorMetadataMap = metadatas.get(ancestor);
   189|       if (ancestorMetadataMap) {
   190|         if (ancestorMetadataMap.has(propertyName)) {
   191|           metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
   192|         }
   193|       }
   194|     }
   195|     return metadataFromAncestorsTarget
   196|       .slice()
   197|       .reverse()
   198|       .concat((metadataFromTarget || []).slice().reverse());
   199|   }
   200|   private getAncestors(target: Function): Function[] {
   201|     if (!target) return [];
   202|     if (!this._ancestorsMap.has(target)) {
   203|       const ancestors: Function[] = [];
   204|       for (
   205|         let baseClass = Object.getPrototypeOf(target.prototype.constructor);
   206|         typeof baseClass.prototype !== 'undefined';
   207|         baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)
   208|       ) {
   209|         ancestors.push(baseClass);
   210|       }
   211|       this._ancestorsMap.set(target, ancestors);
   212|     }
   213|     return this._ancestorsMap.get(target);
   214|   }
   215| }


# ====================================================================
# FILE: src/metadata/TransformMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import { TransformOptions } from './ExposeExcludeOptions';
     2| import { TransformationType } from '../enums';
     3| export class TransformMetadata {
     4|   constructor(
     5|     public target: Function,
     6|     public propertyName: string,
     7|     public transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
     8|     public options: TransformOptions
     9|   ) {}
    10| }


# ====================================================================
# FILE: src/metadata/TypeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import { TypeHelpOptions, TypeOptions } from './ExposeExcludeOptions';
     2| export class TypeMetadata {
     3|   constructor(
     4|     public target: Function,
     5|     public propertyName: string,
     6|     public reflectedType: any,
     7|     public typeFunction: (options?: TypeHelpOptions) => Function,
     8|     public options: TypeOptions
     9|   ) {}
    10| }


# ====================================================================
# FILE: src/storage.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| import { MetadataStorage } from './metadata/MetadataStorage';
     2| /**
     3|  * Default metadata storage is used as singleton and can be used to storage all metadatas.
     4|  */
     5| export const defaultMetadataStorage = new MetadataStorage();

