# ====================================================================
# FILE: gulpfile.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1 ---
     1| eval(require("typescript").transpile(require("fs").readFileSync("./gulpfile.ts").toString()));


# ====================================================================
# FILE: gulpfile.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-252 ---
     1| import "es6-shim";
     2| import {Gulpclass, Task, SequenceTask, MergedTask} from "gulpclass";
     3| const gulp = require("gulp");
     4| const del = require("del");
     5| const shell = require("gulp-shell");
     6| const replace = require("gulp-replace");
     7| const mocha = require("gulp-mocha");
     8| const chai = require("chai");
     9| const tslint = require("gulp-tslint");
    10| const stylish = require("tslint-stylish");
    11| const ts = require("gulp-typescript");
    12| const sourcemaps = require("gulp-sourcemaps");
    13| const istanbul = require("gulp-istanbul");
    14| const remapIstanbul = require("remap-istanbul/lib/gulpRemapIstanbul");
    15| const rename = require("gulp-rename");
    16| const file = require("gulp-file");
    17| const uglify = require("gulp-uglify");
    18| @Gulpclass()
    19| export class Gulpfile {
    20|     /**
    21|      * Cleans build folder.
    22|      */
    23|     @Task()
    24|     clean(cb: Function) {
    25|         return del(["./build/**"], cb);
    26|     }
    27|     /**
    28|      * Runs typescript files compilation.
    29|      */
    30|     @Task()
    31|     compile() {
    32|         return gulp.src("*.js", { read: false })
    33|             .pipe(shell(["tsc"]));
    34|     }
    35|     /**
    36|      * Compiles and compiles bundles.
    37|      */
    38|     @MergedTask()
    39|     compileBundles() {
    40|         const amdTsProject = ts.createProject("tsconfig.json", {
    41|             module: "amd",
    42|             outFile: "class-transformer.amd.js",
    43|             typescript: require("typescript")
    44|         });
    45|         const systemTsProject = ts.createProject("tsconfig.json", {
    46|             module: "system",
    47|             outFile: "class-transformer.system.js",
    48|             typescript: require("typescript")
    49|         });
    50|         const amdPureTsProject = ts.createProject("tsconfig.json", {
    51|             module: "amd",
    52|             outFile: "class-transformer.pure.amd.js",
    53|             noEmitHelpers: true,
    54|             noImplicitUseStrict: true,
    55|             typescript: require("typescript")
    56|         });
    57|         const systemPureTsProject = ts.createProject("tsconfig.json", {
    58|             module: "system",
    59|             outFile: "class-transformer.pure.system.js",
    60|             noEmitHelpers: true,
    61|             noImplicitUseStrict: true,
    62|             typescript: require("typescript")
    63|         });
    64|         return [
    65|             gulp.src("build/bundle/**/*.ts")
    66|                 .pipe(amdTsProject()).js
    67|                 .pipe(gulp.dest("build/package")),
    68|             gulp.src("build/bundle/**/*.ts")
    69|                 .pipe(systemTsProject()).js
    70|                 .pipe(gulp.dest("build/package")),
    71|             gulp.src("build/bundle/**/*.ts")
    72|                 .pipe(amdPureTsProject()).js
    73|                 .pipe(gulp.dest("build/package")),
    74|             gulp.src("build/bundle/**/*.ts")
    75|                 .pipe(systemPureTsProject()).js
    76|                 .pipe(gulp.dest("build/package"))
    77|         ];
    78|     }
    79|     /**
    80|      * Copies all source files into destination folder in a correct structure to build bundles.
    81|      */
    82|     @Task()
    83|     bundleCopySources() {
    84|         return gulp.src(["./src/**/*.ts"])
    85|             .pipe(gulp.dest("./build/bundle/class-transformer"));
    86|     }
    87|     /**
    88|      * Creates special main file for bundle build.
    89|      */
    90|     @Task()
    91|     bundleCopyMainFile() {
    92|         return gulp.src("./package.json", { read: false })
    93|             .pipe(file("class-transformer.ts", `export * from "./class-transformer/index";`))
    94|             .pipe(gulp.dest("./build/bundle"));
    95|     }
    96|     /**
    97|      * Uglifys bundles.
    98|      */
    99|     @MergedTask()
   100|     uglify() {
   101|         return [
   102|             gulp.src(`./build/package/class-transformer.pure.amd.js`)
   103|                 .pipe(uglify())
   104|                 .pipe(rename(`class-transformer.pure.amd.min.js`))
   105|                 .pipe(gulp.dest("./build/package")),
   106|             gulp.src(`./build/package/class-transformer.pure.system.js`)
   107|                 .pipe(uglify())
   108|                 .pipe(rename(`class-transformer.pure.system.min.js`))
   109|                 .pipe(gulp.dest("./build/package")),
   110|             gulp.src(`./build/package/class-transformer.amd.js`)
   111|                 .pipe(uglify())
   112|                 .pipe(rename(`class-transformer.amd.min.js`))
   113|                 .pipe(gulp.dest("./build/package")),
   114|             gulp.src(`./build/package/class-transformer.system.js`)
   115|                 .pipe(uglify())
   116|                 .pipe(rename(`class-transformer.system.min.js`))
   117|                 .pipe(gulp.dest("./build/package")),
   118|         ];
   119|     }
   120|     /**
   121|      * Publishes a package to npm from ./build/package directory.
   122|      */
   123|     @Task()
   124|     npmPublish() {
   125|         return gulp.src("*.js", { read: false })
   126|             .pipe(shell([
   127|                 "cd ./build/package && npm publish"
   128|             ]));
   129|     }
   130|     /**
   131|      * Copies all sources to the package directory.
   132|      */
   133|     @MergedTask()
   134|     packageCompile() {
   135|         const tsProject = ts.createProject("tsconfig.json");
   136|         const tsResult = gulp.src(["./src/**/*.ts", "./typings/**/*.ts"])
   137|             .pipe(sourcemaps.init())
   138|             .pipe(tsProject());
   139|         return [
   140|             tsResult.dts.pipe(gulp.dest("./build/package")),
   141|             tsResult.js
   142|                 .pipe(sourcemaps.write(".", { sourceRoot: "", includeContent: true }))
   143|                 .pipe(gulp.dest("./build/package"))
   144|         ];
   145|     }
   146|     /**
   147|      * Moves all compiled files to the final package directory.
   148|      */
   149|     @Task()
   150|     packageMoveCompiledFiles() {
   151|         return gulp.src("./build/package/src/**/*")
   152|             .pipe(gulp.dest("./build/package"));
   153|     }
   154|     /**
   155|      * Moves all compiled files to the final package directory.
   156|      */
   157|     @Task()
   158|     packageClearCompileDirectory(cb: Function) {
   159|         return del([
   160|             "./build/package/src/**"
   161|         ], cb);
   162|     }
   163|     /**
   164|      * Change the "private" state of the packaged package.json file to public.
   165|      */
   166|     @Task()
   167|     packagePreparePackageFile() {
   168|         return gulp.src("./package.json")
   169|             .pipe(replace("\"private\": true,", "\"private\": false,"))
   170|             .pipe(gulp.dest("./build/package"));
   171|     }
   172|     /**
   173|      * This task will replace all typescript code blocks in the README (since npm does not support typescript syntax
   174|      * highlighting) and copy this README file into the package folder.
   175|      */
   176|     @Task()
   177|     packageReadmeFile() {
   178|         return gulp.src("./README.md")
   179|             .pipe(replace(/```typescript([\s\S]*?)```/g, "```javascript$1```"))
   180|             .pipe(gulp.dest("./build/package"));
   181|     }
   182|     /**
   183|      * Creates a package that can be published to npm.
   184|      */
   185|     @SequenceTask()
   186|     package() {
   187|         return [
   188|             "clean",
   189|             ["bundleCopySources", "bundleCopyMainFile"],
   190|             ["compile", "compileBundles"],
   191|             ["uglify"],
   192|             "packageCompile",
   193|             "packageMoveCompiledFiles",
   194|             "packageClearCompileDirectory",
   195|             ["packagePreparePackageFile", "packageReadmeFile"]
   196|         ];
   197|     }
   198|     /**
   199|      * Creates a package and publishes it to npm.
   200|      */
   201|     @SequenceTask()
   202|     publish() {
   203|         return ["package", "npmPublish"];
   204|     }
   205|     /**
   206|      * Runs ts linting to validate source code.
   207|      */
   208|     @Task()
   209|     tslint() {
   210|         return gulp.src(["./src/**/*.ts", "./test/**/*.ts", "./sample/**/*.ts"])
   211|             .pipe(tslint())
   212|             .pipe(tslint.report(stylish, {
   213|                 emitError: true,
   214|                 sort: true,
   215|                 bell: true
   216|             }));
   217|     }
   218|     /**
   219|      * Runs before test coverage, required step to perform a test coverage.
   220|      */
   221|     @Task()
   222|     coveragePre() {
   223|         return gulp.src(["./build/es5/src/**/*.js"])
   224|             .pipe(istanbul())
   225|             .pipe(istanbul.hookRequire());
   226|     }
   227|     /**
   228|      * Runs post coverage operations.
   229|      */
   230|     @Task("coveragePost", ["coveragePre"])
   231|     coveragePost() {
   232|         chai.should();
   233|         chai.use(require("sinon-chai"));
   234|         chai.use(require("chai-as-promised"));
   235|         return gulp.src(["./build/es5/test/functional/**/*.js"])
   236|             .pipe(mocha())
   237|             .pipe(istanbul.writeReports());
   238|     }
   239|     @Task()
   240|     coverageRemap() {
   241|         return gulp.src("./coverage/coverage-final.json")
   242|             .pipe(remapIstanbul())
   243|             .pipe(gulp.dest("./coverage"));
   244|     }
   245|     /**
   246|      * Compiles the code and runs tests.
   247|      */
   248|     @SequenceTask()
   249|     tests() {
   250|         return ["compile", "coveragePost", "coverageRemap", "tslint"];
   251|     }
   252| }


# ====================================================================
# FILE: sample/sample1-simple-usage/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {Type, Exclude} from "../../src/decorators";
     2| import {Photo} from "./Photo";
     3| export class Album {
     4|     id: string;
     5|     @Exclude()
     6|     name: string;
     7|     @Type(() => Photo)
     8|     photos: Photo[];
     9| }


# ====================================================================
# FILE: sample/sample1-simple-usage/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| import {Type} from "../../src/decorators";
     2| import {Album} from "./Album";
     3| import {User} from "./User";
     4| export class Photo {
     5|     id: string;
     6|     filename: string;
     7|     description: string;
     8|     tags: string[];
     9|     @Type(() => User)
    10|     author: User;
    11|     @Type(() => Album)
    12|     albums: Album[];
    13|     get name() {
    14|         return this.id + "_" + this.filename;
    15|     }
    16|     getAlbums() {
    17|         console.log("this is not serialized/deserialized");
    18|         return this.albums;
    19|     }
    20| }


# ====================================================================
# FILE: sample/sample1-simple-usage/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {Type} from "../../src/decorators";
     2| export class User {
     3|     @Type(() => Number)
     4|     id: number;
     5|     firstName: string;
     6|     lastName: string;
     7|     @Type(() => Date)
     8|     registrationDate: Date;
     9| }


# ====================================================================
# FILE: sample/sample1-simple-usage/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| import "es6-shim";
     2| import "reflect-metadata";
     3| import {plainToClass, classToPlain} from "../../src/index";
     4| import {Photo} from "./Photo";
     5| let photoJson = {
     6|     id: "1",
     7|     filename: "myphoto.jpg",
     8|     description: "about my photo",
     9|     tags: [
    10|         "me",
    11|         "iam"
    12|     ],
    13|     author: {
    14|         id: "2",
    15|         firstName: "Johny",
    16|         lastName: "Cage"
    17|     },
    18|     albums: [{
    19|         id: "1",
    20|         name: "My life"
    21|     },
    22|     {
    23|         id: "2",
    24|         name: "My young years"
    25|     }]
    26| };
    27| let photo = plainToClass(Photo, photoJson);
    28| console.log("deserialized object: " , photo);
    29| let newPhotoJson = classToPlain(photo);
    30| console.log("serialized object: " , newPhotoJson);
    31| console.log("-------------------------------");
    32| let photosJson = [{
    33|     id: "1",
    34|     filename: "myphoto.jpg",
    35|     description: "about my photo",
    36|     author: {
    37|         id: "2",
    38|         firstName: "Johny",
    39|         lastName: "Cage",
    40|         registrationDate: "1995-12-17T03:24:00"
    41|     },
    42|     albums: [{
    43|         id: "1",
    44|         name: "My life"
    45|     },
    46|     {
    47|         id: "2",
    48|         name: "My young years"
    49|     }]
    50| },
    51| {
    52|     id: "2",
    53|     filename: "hisphoto.jpg",
    54|     description: "about his photo",
    55|     author: {
    56|         id: "2",
    57|         firstName: "Johny",
    58|         lastName: "Cage"
    59|     },
    60|     albums: [{
    61|         id: "1",
    62|         name: "My life"
    63|     },
    64|     {
    65|         id: "2",
    66|         name: "My young years"
    67|     }]
    68| }];
    69| let photos = plainToClass(Photo, photosJson);
    70| console.log("deserialized array: " , photos);
    71| let newPhotosJson = classToPlain(photos);
    72| console.log("serialized array: " , newPhotosJson);


# ====================================================================
# FILE: sample/sample2-iheritance/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import {Type, Exclude} from "../../src/decorators";
     2| import {Photo} from "./Photo";
     3| import {Authorable} from "./Authorable";
     4| export class Album extends Authorable {
     5|     id: string;
     6|     @Exclude()
     7|     name: string;
     8|     @Type(() => Photo)
     9|     photos: Photo[];
    10| }


# ====================================================================
# FILE: sample/sample2-iheritance/Authorable.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {Type, Exclude} from "../../src/decorators";
     2| import {User} from "./User";
     3| export class Authorable {
     4|     authorName: string;
     5|     @Exclude()
     6|     authorEmail: string;
     7|     @Type(() => User)
     8|     author: User;
     9| }


# ====================================================================
# FILE: sample/sample2-iheritance/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-12 ---
     1| import {Type, Exclude} from "../../src/decorators";
     2| import {Album} from "./Album";
     3| import {Authorable} from "./Authorable";
     4| export class Photo extends Authorable {
     5|     id: string;
     6|     filename: string;
     7|     description: string;
     8|     @Exclude() // this will ignore skipping inherited from Authorable class
     9|     authorEmail: string;
    10|     @Type(() => Album)
    11|     albums: Album[];
    12| }


# ====================================================================
# FILE: sample/sample2-iheritance/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {Type} from "../../src/decorators";
     2| export class User {
     3|     @Type(() => Number)
     4|     id: number;
     5|     firstName: string;
     6|     lastName: string;
     7|     @Type(() => Date)
     8|     registrationDate: Date;
     9| }


# ====================================================================
# FILE: sample/sample2-iheritance/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| import "es6-shim";
     2| import "reflect-metadata";
     3| import {classToPlain, plainToClass} from "../../src/index";
     4| import {Photo} from "./Photo";
     5| let photoJson = {
     6|     id: "1",
     7|     filename: "myphoto.jpg",
     8|     description: "about my photo",
     9|     authorName: "Johny.Cage",
    10|     authorEmail: "johny@cage.com",
    11|     author: {
    12|         id: "2",
    13|         firstName: "Johny",
    14|         lastName: "Cage"
    15|     },
    16|     albums: [{
    17|         id: "1",
    18|         authorName: "Johny.Cage",
    19|         authorEmail: "johny@cage.com",
    20|         name: "My life"
    21|     },
    22|     {
    23|         id: "2",
    24|         authorName: "Johny.Cage",
    25|         authorEmail: "johny@cage.com",
    26|         name: "My young years"
    27|     }]
    28| };
    29| let photo = plainToClass(Photo, photoJson);
    30| console.log("deserialized object: " , photo);
    31| let newPhotoJson = classToPlain(photo);
    32| console.log("serialized object: " , newPhotoJson);
    33| console.log("-------------------------------");
    34| let photosJson = [{
    35|     id: "1",
    36|     filename: "myphoto.jpg",
    37|     description: "about my photo",
    38|     author: {
    39|         id: "2",
    40|         firstName: "Johny",
    41|         lastName: "Cage",
    42|         registrationDate: "1995-12-17T03:24:00"
    43|     },
    44|     albums: [{
    45|         id: "1",
    46|         name: "My life"
    47|     },
    48|     {
    49|         id: "2",
    50|         name: "My young years"
    51|     }]
    52| },
    53| {
    54|     id: "2",
    55|     filename: "hisphoto.jpg",
    56|     description: "about his photo",
    57|     author: {
    58|         id: "2",
    59|         firstName: "Johny",
    60|         lastName: "Cage"
    61|     },
    62|     albums: [{
    63|         id: "1",
    64|         name: "My life"
    65|     },
    66|     {
    67|         id: "2",
    68|         name: "My young years"
    69|     }]
    70| }];
    71| let photos = plainToClass(Photo, photosJson);
    72| console.log("deserialized array: " , photos);
    73| let newPhotosJson = classToPlain(photos);
    74| console.log("serialized array: " , newPhotosJson);


# ====================================================================
# FILE: sample/sample3-custom-arrays/Album.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| export class Album {
     2|     id: string;
     3|     name: string;
     4| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/AlbumArray.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| import {Album} from "./Album";
     2| export class AlbumArray extends Array<Album> {
     3|     findByName(name: string) {
     4|         return this.find(album => album.name === name);
     5|     }
     6| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/Photo.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-11 ---
     1| import {Album} from "./Album";
     2| import {AlbumArray} from "./AlbumArray";
     3| import {Type} from "../../src/decorators";
     4| export class Photo {
     5|     id: string;
     6|     filename: string;
     7|     description: string;
     8|     tags: string[];
     9|     @Type(() => Album)
    10|     albums: AlbumArray;
    11| }


# ====================================================================
# FILE: sample/sample3-custom-arrays/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import "es6-shim";
     2| import "reflect-metadata";
     3| import {classToPlain, plainToClass} from "../../src/index";
     4| import {Photo} from "./Photo";
     5| let photoJson = {
     6|     id: "1",
     7|     filename: "myphoto.jpg",
     8|     description: "about my photo",
     9|     tags: [
    10|         "me",
    11|         "iam"
    12|     ],
    13|     albums: [{
    14|         id: "1",
    15|         name: "My life"
    16|     },
    17|     {
    18|         id: "2",
    19|         name: "My young years"
    20|     }]
    21| };
    22| let photo = plainToClass(Photo, photoJson);
    23| console.log("deserialized object: " , photo);
    24| console.log("-----------------------------");
    25| console.log("Trying to find album: ", photo.albums.findByName("My life"));
    26| console.log("-----------------------------");
    27| let newPhotoJson = classToPlain(photo);
    28| console.log("serialized object: " , newPhotoJson);
    29| console.log("-----------------------------");


# ====================================================================
# FILE: sample/sample4-generics/SimpleCollection.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| export class SimpleCollection<T> {
     2|     items: T[];
     3|     count: number;
     4| }


# ====================================================================
# FILE: sample/sample4-generics/SuperCollection.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| import {Type, Exclude} from "../../src/decorators";
     2| export class SuperCollection<T> {
     3|     @Exclude()
     4|     private type: Function;
     5|     @Type(options => {
     6|         return (options.newObject as SuperCollection<T>).type;
     7|     })
     8|     items: T[];
     9|     count: number;
    10|     constructor(type: Function) {
    11|         this.type = type;
    12|     }
    13| }


# ====================================================================
# FILE: sample/sample4-generics/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| import {Exclude} from "../../src/decorators";
     2| export class User {
     3|     id: number;
     4|     firstName: string;
     5|     lastName: string;
     6|     @Exclude()
     7|     password: string;
     8|     constructor(id: number, firstName: string, lastName: string, password: string) {
     9|         this.id = id;
    10|         this.firstName = firstName;
    11|         this.lastName = lastName;
    12|         this.password = password;
    13|     }
    14|     get name() {
    15|         return this.firstName + " " + this.lastName;
    16|     }
    17| }


# ====================================================================
# FILE: sample/sample4-generics/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| import "es6-shim";
     2| import "reflect-metadata";
     3| import {SimpleCollection} from "./SimpleCollection";
     4| import {User} from "./User";
     5| import {classToPlain, plainToClass, plainToClassFromExist} from "../../src/index";
     6| import {SuperCollection} from "./SuperCollection";
     7| let collection = new SimpleCollection<User>();
     8| collection.items = [
     9|     new User(1, "Johny", "Cage", "*******"),
    10|     new User(2, "Dima", "Cage", "*******")
    11| ];
    12| collection.count = 2;
    13| let collectionJson = {
    14|     items: [{
    15|         id: 1,
    16|         firstName: "Johny",
    17|         lastName: "Cage",
    18|         password: "*******",
    19|     }, {
    20|         id: 2,
    21|         firstName: "Dima",
    22|         lastName: "Cage",
    23|         password: "*******",
    24|     }]
    25| };
    26| console.log(plainToClassFromExist(new SuperCollection<User>(User), collectionJson));


# ====================================================================
# FILE: sample/sample5-custom-transformer/User.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import {Type, Transform} from "../../src/decorators";
     2| import * as moment from "moment";
     3| export class User {
     4|     id: number;
     5|     name: string;
     6|     @Type(() => Date)
     7|     @Transform(value => value.toString(), { toPlainOnly: true })
     8|     @Transform(value => moment(value), { toClassOnly: true })
     9|     date: Date;
    10| }


# ====================================================================
# FILE: sample/sample5-custom-transformer/app.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| import "es6-shim";
     2| import "reflect-metadata";
     3| import {plainToClass, classToPlain} from "../../src/index";
     4| import {User} from "./User";
     5| let userJson = {
     6|     id: 1,
     7|     name: "Johny Cage",
     8|     date: new Date().valueOf()
     9| };
    10| console.log(plainToClass(User, userJson));
    11| const user = new User();
    12| user.id = 1;
    13| user.name = "Johny Cage";
    14| user.date = new Date();
    15| console.log(classToPlain(user));


# ====================================================================
# FILE: src/ClassTransformOptions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| /**
     2|  * Allows to specify a map of Types in the object without using @Type decorator.
     3|  * This is useful when you have external classes.
     4|  */
     5| export interface TargetMap {
     6|     /**
     7|      * Target which Types are being specified.
     8|      */
     9|     target: Function;
    10|     /**
    11|      * List of properties and their Types.
    12|      */
    13|     properties: { [key: string]: Function };
    14| }
    15| /**
    16|  * Options to be passed during transformation.
    17|  */
    18| export interface ClassTransformOptions {
    19|     /**
    20|      * Exclusion strategy. By default exposeAll is used, which means that it will expose all properties are transformed
    21|      * by default.
    22|      */
    23|     strategy?: "excludeAll"|"exposeAll";
    24|     /**
    25|      * Indicates if extraneous properties should be excluded from the value when converting a plain value to a class.
    26|      */
    27|     excludeExtraneousValues?: boolean;
    28|     /**
    29|      * Only properties with given groups gonna be transformed.
    30|      */
    31|     groups?: string[];
    32|     /**
    33|      * Only properties with "since" > version < "until" gonna be transformed.
    34|      */
    35|     version?: number;
    36|     /**
    37|      * Excludes properties with the given prefixes. For example, if you mark your private properties with "_" and "__"
    38|      * you can set this option's value to ["_", "__"] and all private properties will be skipped.
    39|      * This works only for "exposeAll" strategy.
    40|      */
    41|     excludePrefixes?: string[];
    42|     /**
    43|      * If set to true then class transformer will ignore all @Expose and @Exclude decorators and what inside them.
    44|      * This option is useful if you want to kinda clone your object but do not apply decorators affects.
    45|      */
    46|     ignoreDecorators?: boolean;
    47|     /**
    48|      * Target maps allows to set a Types of the transforming object without using @Type decorator.
    49|      * This is useful when you are transforming external classes, or if you already have type metadata for
    50|      * objects and you don't want to set it up again.
    51|      */
    52|     targetMaps?: TargetMap[];
    53|     /**
    54|      * If set to true then class transformer will perform a circular check. (circular check is turned off by default)
    55|      * This option is useful when you know for sure that your types might have a circular dependency.
    56|      */
    57|     enableCircularCheck?: boolean;
    58|     /**
    59|      * If set to true then class transformer will try to convert properties implicitly to their target type based on their typing information.
    60|      *
    61|      * DEFAULT: `false`
    62|      */
    63|     enableImplicitConversion?: boolean;
    64| }


# ====================================================================
# FILE: src/ClassTransformer.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| import {ClassTransformOptions} from "./ClassTransformOptions";
     2| import {TransformOperationExecutor, TransformationType} from "./TransformOperationExecutor";
     3| export type ClassType<T> = {
     4|     new (...args: any[]): T;
     5| };
     6| export class ClassTransformer {
     7|     /**
     8|      * Converts class (constructor) object to plain (literal) object. Also works with arrays.
     9|      */
    10|     classToPlain<T extends Object>(object: T, options?: ClassTransformOptions): Object;
    11|     classToPlain<T extends Object>(object: T[], options?: ClassTransformOptions): Object[];
    12|     classToPlain<T extends Object>(object: T|T[], options?: ClassTransformOptions): Object|Object[] {
    13|         const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
    14|         return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
    15|     }
    16|     /**
    17|      * Converts class (constructor) object to plain (literal) object.
    18|      * Uses given plain object as source object (it means fills given plain object with data from class object).
    19|      * Also works with arrays.
    20|      */
    21|     classToPlainFromExist<T extends Object, P>(object: T, plainObject: P, options?: ClassTransformOptions): T;
    22|     classToPlainFromExist<T extends Object, P>(object: T, plainObjects: P[], options?: ClassTransformOptions): T[];
    23|     classToPlainFromExist<T extends Object, P>(object: T, plainObject: P|P[], options?: ClassTransformOptions): T|T[] {
    24|         const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_PLAIN, options || {});
    25|         return executor.transform(plainObject, object, undefined, undefined, undefined, undefined);
    26|     }
    27|     /**
    28|      * Converts plain (literal) object to class (constructor) object. Also works with arrays.
    29|      */
    30|     plainToClass<T extends Object, V extends Array<any>>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T[];
    31|     plainToClass<T extends Object, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
    32|     plainToClass<T extends Object, V>(cls: ClassType<T>, plain: V|V[], options?: ClassTransformOptions): T|T[] {
    33|         const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
    34|         return executor.transform(undefined, plain, cls, undefined, undefined, undefined);
    35|     }
    36|     /**
    37|      * Converts plain (literal) object to class (constructor) object.
    38|      * Uses given object as source object (it means fills given object with data from plain object).
    39|      * Also works with arrays.
    40|      */
    41|     plainToClassFromExist<T extends Object, V extends Array<any>>(clsObject: T, plain: V, options?: ClassTransformOptions): T;
    42|     plainToClassFromExist<T extends Object, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T[];
    43|     plainToClassFromExist<T extends Object, V>(clsObject: T, plain: V|V[], options?: ClassTransformOptions): T|T[] {
    44|         const executor = new TransformOperationExecutor(TransformationType.PLAIN_TO_CLASS, options || {});
    45|         return executor.transform(clsObject, plain, undefined, undefined, undefined, undefined);
    46|     }
    47|     /**
    48|      * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
    49|      */
    50|     classToClass<T>(object: T, options?: ClassTransformOptions): T;
    51|     classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
    52|     classToClass<T>(object: T|T[], options?: ClassTransformOptions): T|T[] {
    53|         const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
    54|         return executor.transform(undefined, object, undefined, undefined, undefined, undefined);
    55|     }
    56|     /**
    57|      * Converts class (constructor) object to plain (literal) object.
    58|      * Uses given plain object as source object (it means fills given plain object with data from class object).
    59|      * Also works with arrays.
    60|      */
    61|     classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
    62|     classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
    63|     classToClassFromExist<T>(object: T, fromObject: T|T[], options?: ClassTransformOptions): T|T[] {
    64|         const executor = new TransformOperationExecutor(TransformationType.CLASS_TO_CLASS, options || {});
    65|         return executor.transform(fromObject, object, undefined, undefined, undefined, undefined);
    66|     }
    67|     /**
    68|      * Serializes given object to a JSON string.
    69|      */
    70|     serialize<T>(object: T, options?: ClassTransformOptions): string;
    71|     serialize<T>(object: T[], options?: ClassTransformOptions): string;
    72|     serialize<T>(object: T|T[], options?: ClassTransformOptions): string {
    73|         return JSON.stringify(this.classToPlain(object, options));
    74|     }
    75|     /**
    76|      * Deserializes given JSON string to a object of the given class.
    77|      */
    78|     deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
    79|         const jsonObject: T = JSON.parse(json);
    80|         return this.plainToClass(cls, jsonObject, options);
    81|     }
    82|     /**
    83|      * Deserializes given JSON string to an array of objects of the given class.
    84|      */
    85|     deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
    86|         const jsonObject: any[] = JSON.parse(json);
    87|         return this.plainToClass(cls, jsonObject, options);
    88|     }
    89| }


# ====================================================================
# FILE: src/TransformOperationExecutor.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-339 ---
     1| import { ClassTransformOptions } from "./ClassTransformOptions";
     2| import { defaultMetadataStorage } from "./storage";
     3| import { TypeHelpOptions, TypeOptions } from "./metadata/ExposeExcludeOptions";
     4| import { TypeMetadata } from "./metadata/TypeMetadata";
     5| export enum TransformationType {
     6|     PLAIN_TO_CLASS,
     7|     CLASS_TO_PLAIN,
     8|     CLASS_TO_CLASS
     9| }
    10| export class TransformOperationExecutor {
    11|     private recursionStack = new Set<Object>();
    12|     constructor(private transformationType: TransformationType,
    13|         private options: ClassTransformOptions) {
    14|     }
    15|     transform(source: Object | Object[] | any,
    16|         value: Object | Object[] | any,
    17|         targetType: Function | TypeMetadata,
    18|         arrayType: Function,
    19|         isMap: boolean,
    20|         level: number = 0) {
    21|         if (Array.isArray(value) || value instanceof Set) {
    22|             const newValue = arrayType && this.transformationType === TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
    23|             (value as any[]).forEach((subValue, index) => {
    24|                 const subSource = source ? source[index] : undefined;
    25|                 if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
    26|                     let realTargetType;
    27|                     if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
    28|                         if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
    29|                             realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[(targetType as { options: TypeOptions }).options.discriminator.property]);
    30|                             const options: TypeHelpOptions = { newObject: newValue, object: subValue, property: undefined };
    31|                             const newType = targetType.typeFunction(options);
    32|                             realTargetType === undefined ? realTargetType = newType : realTargetType = realTargetType.value;
    33|                             if (!targetType.options.keepDiscriminatorProperty) delete subValue[targetType.options.discriminator.property];
    34|                         }
    35|                         if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
    36|                             realTargetType = subValue.constructor;
    37|                         }
    38|                         if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
    39|                             subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
    40|                         }
    41|                     } else {
    42|                         realTargetType = targetType;
    43|                     }
    44|                     const value = this.transform(subSource, subValue, realTargetType, undefined, subValue instanceof Map, level + 1);
    45|                     if (newValue instanceof Set) {
    46|                         newValue.add(value);
    47|                     } else {
    48|                         newValue.push(value);
    49|                     }
    50|                 } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
    51|                     if (newValue instanceof Set) {
    52|                         newValue.add(subValue);
    53|                     } else {
    54|                         newValue.push(subValue);
    55|                     }
    56|                 }
    57|             });
    58|             return newValue;
    59|         } else if (targetType === String && !isMap) {
    60|             if (value === null || value === undefined)
    61|                 return value;
    62|             return String(value);
    63|         } else if (targetType === Number && !isMap) {
    64|             if (value === null || value === undefined)
    65|                 return value;
    66|             return Number(value);
    67|         } else if (targetType === Boolean && !isMap) {
    68|             if (value === null || value === undefined)
    69|                 return value;
    70|             return Boolean(value);
    71|         } else if ((targetType === Date || value instanceof Date) && !isMap) {
    72|             if (value instanceof Date) {
    73|                 return new Date(value.valueOf());
    74|             }
    75|             if (value === null || value === undefined)
    76|                 return value;
    77|             return new Date(value);
    78|         } else if (testForBuffer() && (targetType === Buffer || value instanceof Buffer) && !isMap) {
    79|             if (value === null || value === undefined)
    80|                 return value;
    81|             return Buffer.from(value);
    82|         } else if (typeof value === "object" && value !== null) {
    83|             if (!targetType && value.constructor !== Object/* && TransformationType === TransformationType.CLASS_TO_PLAIN*/) targetType = value.constructor;
    84|             if (!targetType && source) targetType = source.constructor;
    85|             if (this.options.enableCircularCheck) {
    86|                 this.recursionStack.add(value);
    87|             }
    88|             const keys = this.getKeys((targetType as Function), value);
    89|             let newValue: any = source ? source : {};
    90|             if (!source && (this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)) {
    91|                 if (isMap) {
    92|                     newValue = new Map();
    93|                 } else if (targetType) {
    94|                     newValue = new (targetType as any)();
    95|                 } else {
    96|                     newValue = {};
    97|                 }
    98|             }
    99|             for (let key of keys) {
   100|                 let valueKey = key, newValueKey = key, propertyName = key;
   101|                 if (!this.options.ignoreDecorators && targetType) {
   102|                     if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   103|                         const exposeMetadata = defaultMetadataStorage.findExposeMetadataByCustomName((targetType as Function), key);
   104|                         if (exposeMetadata) {
   105|                             propertyName = exposeMetadata.propertyName;
   106|                             newValueKey = exposeMetadata.propertyName;
   107|                         }
   108|                     } else if (this.transformationType === TransformationType.CLASS_TO_PLAIN || this.transformationType === TransformationType.CLASS_TO_CLASS) {
   109|                         const exposeMetadata = defaultMetadataStorage.findExposeMetadata((targetType as Function), key);
   110|                         if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
   111|                             newValueKey = exposeMetadata.options.name;
   112|                         }
   113|                     }
   114|                 }
   115|                 let subValue: any = undefined;
   116|                 if (value instanceof Map) {
   117|                     subValue = value.get(valueKey);
   118|                 } else if (value[valueKey] instanceof Function) {
   119|                     subValue = value[valueKey]();
   120|                 } else {
   121|                     subValue = value[valueKey];
   122|                 }
   123|                 let type: any = undefined, isSubValueMap = subValue instanceof Map;
   124|                 if (targetType && isMap) {
   125|                     type = targetType;
   126|                 } else if (targetType) {
   127|                     const metadata = defaultMetadataStorage.findTypeMetadata((targetType as Function), propertyName);
   128|                     if (metadata) {
   129|                         const options: TypeHelpOptions = { newObject: newValue, object: value, property: propertyName };
   130|                         const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
   131|                         if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {
   132|                             if (!(value[valueKey] instanceof Array)) {
   133|                                 if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   134|                                     type = metadata.options.discriminator.subTypes.find((subType) => {
   135|                                         if (subValue && metadata.options.discriminator.property in subValue) {
   136|                                             return subType.name === subValue[metadata.options.discriminator.property]
   137|                                         }
   138|                                     });
   139|                                     type === undefined ? type = newType : type = type.value;
   140|                                     if (!metadata.options.keepDiscriminatorProperty) {
   141|                                         if (subValue && metadata.options.discriminator.property in subValue) {
   142|                                             delete subValue[metadata.options.discriminator.property];
   143|                                         }
   144|                                     }
   145|                                 }
   146|                                 if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
   147|                                     type = subValue.constructor;
   148|                                 }
   149|                                 if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
   150|                                     subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
   151|                                 }
   152|                             } else {
   153|                                 type = metadata;
   154|                             }
   155|                         } else {
   156|                             type = newType;
   157|                         }
   158|                         isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
   159|                     } else if (this.options.targetMaps) { // try to find a type in target maps
   160|                         this.options.targetMaps
   161|                             .filter(map => map.target === targetType && !!map.properties[propertyName])
   162|                             .forEach(map => type = map.properties[propertyName]);
   163|                     } else if(this.options.enableImplicitConversion && this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   164|                         const reflectedType = Reflect.getMetadata("design:type", (targetType as Function).prototype, propertyName);
   165|                         if (reflectedType) {
   166|                             type = reflectedType;
   167|                         }
   168|                     }
   169|                 }
   170|                 const arrayType = Array.isArray(value[valueKey]) ? this.getReflectedType((targetType as Function), propertyName) : undefined;
   171|                 const subSource = source ? source[valueKey] : undefined;
   172|                 if (newValue.constructor.prototype) {
   173|                     const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
   174|                     if ((this.transformationType === TransformationType.PLAIN_TO_CLASS || this.transformationType === TransformationType.CLASS_TO_CLASS)
   175|                         && ((descriptor && !descriptor.set) || newValue[newValueKey] instanceof Function)) //  || TransformationType === TransformationType.CLASS_TO_CLASS
   176|                         continue;
   177|                 }
   178|                 if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
   179|                     let transformKey = this.transformationType === TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
   180|                     let finalValue;
   181|                     if (this.transformationType === TransformationType.CLASS_TO_PLAIN) {
   182|                         finalValue = value[transformKey];
   183|                         finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);
   184|                         finalValue = (value[transformKey] === finalValue) ? subValue : finalValue;
   185|                         finalValue = this.transform(subSource, finalValue, type, arrayType, isSubValueMap, level + 1);
   186|                     } else {
   187|                         finalValue = this.transform(subSource, subValue, type, arrayType, isSubValueMap, level + 1);
   188|                         finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), transformKey, value, this.transformationType);
   189|                     }
   190|                     if (newValue instanceof Map) {
   191|                         newValue.set(newValueKey, finalValue);
   192|                     } else {
   193|                         newValue[newValueKey] = finalValue;
   194|                     }
   195|                 } else if (this.transformationType === TransformationType.CLASS_TO_CLASS) {
   196|                     let finalValue = subValue;
   197|                     finalValue = this.applyCustomTransformations(finalValue, (targetType as Function), key, value, this.transformationType);
   198|                     if (newValue instanceof Map) {
   199|                         newValue.set(newValueKey, finalValue);
   200|                     } else {
   201|                         newValue[newValueKey] = finalValue;
   202|                     }
   203|                 }
   204|             }
   205|             if (this.options.enableCircularCheck) {
   206|                 this.recursionStack.delete(value);
   207|             }
   208|             return newValue;
   209|         } else {
   210|             return value;
   211|         }
   212|     }
   213|     private applyCustomTransformations(value: any, target: Function, key: string, obj: any, transformationType: TransformationType) {
   214|         let metadatas = defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
   215|         if (this.options.version !== undefined) {
   216|             metadatas = metadatas.filter(metadata => {
   217|                 if (!metadata.options)
   218|                     return true;
   219|                 return this.checkVersion(metadata.options.since, metadata.options.until);
   220|             });
   221|         }
   222|         if (this.options.groups && this.options.groups.length) {
   223|             metadatas = metadatas.filter(metadata => {
   224|                 if (!metadata.options)
   225|                     return true;
   226|                 return this.checkGroups(metadata.options.groups);
   227|             });
   228|         } else {
   229|             metadatas = metadatas.filter(metadata => {
   230|                 return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
   231|             });
   232|         }
   233|         metadatas.forEach(metadata => {
   234|             value = metadata.transformFn(value, obj, transformationType);
   235|         });
   236|         return value;
   237|     }
   238|     private isCircular(object: Object) {
   239|         return this.recursionStack.has(object);
   240|     }
   241|     private getReflectedType(target: Function, propertyName: string) {
   242|         if (!target) return undefined;
   243|         const meta = defaultMetadataStorage.findTypeMetadata(target, propertyName);
   244|         return meta ? meta.reflectedType : undefined;
   245|     }
   246|     private getKeys(target: Function, object: Object): string[] {
   247|         let strategy = defaultMetadataStorage.getStrategy(target);
   248|         if (strategy === "none")
   249|             strategy = this.options.strategy || "exposeAll"; // exposeAll is default strategy
   250|         let keys: any[] = [];
   251|         if (strategy === "exposeAll") {
   252|             if (object instanceof Map) {
   253|                 keys = Array.from(object.keys());
   254|             } else {
   255|                 keys = Object.keys(object);
   256|             }
   257|         }
   258|         if (!this.options.ignoreDecorators && target) {
   259|             let exposedProperties = defaultMetadataStorage.getExposedProperties(target, this.transformationType);
   260|             if (this.transformationType === TransformationType.PLAIN_TO_CLASS) {
   261|                 exposedProperties = exposedProperties.map(key => {
   262|                     const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   263|                     if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
   264|                         return exposeMetadata.options.name;
   265|                     }
   266|                     return key;
   267|                 });
   268|             }
   269|             if (this.options.excludeExtraneousValues) {
   270|                 keys = exposedProperties;
   271|             } else {
   272|                 keys = keys.concat(exposedProperties);
   273|             }
   274|             const excludedProperties = defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
   275|             if (excludedProperties.length > 0) {
   276|                 keys = keys.filter(key => {
   277|                     return excludedProperties.indexOf(key) === -1;
   278|                 });
   279|             }
   280|             if (this.options.version !== undefined) {
   281|                 keys = keys.filter(key => {
   282|                     const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   283|                     if (!exposeMetadata || !exposeMetadata.options)
   284|                         return true;
   285|                     return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
   286|                 });
   287|             }
   288|             if (this.options.groups && this.options.groups.length) {
   289|                 keys = keys.filter(key => {
   290|                     const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   291|                     if (!exposeMetadata || !exposeMetadata.options)
   292|                         return true;
   293|                     return this.checkGroups(exposeMetadata.options.groups);
   294|                 });
   295|             } else {
   296|                 keys = keys.filter(key => {
   297|                     const exposeMetadata = defaultMetadataStorage.findExposeMetadata(target, key);
   298|                     return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
   299|                 });
   300|             }
   301|         }
   302|         if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
   303|             keys = keys.filter(key => this.options.excludePrefixes.every(prefix => {
   304|                 return key.substr(0, prefix.length) !== prefix;
   305|             }));
   306|         }
   307|         keys = keys.filter((key, index, self) => {
   308|             return self.indexOf(key) === index;
   309|         });
   310|         return keys;
   311|     }
   312|     private checkVersion(since: number, until: number) {
   313|         let decision = true;
   314|         if (decision && since)
   315|             decision = this.options.version >= since;
   316|         if (decision && until)
   317|             decision = this.options.version < until;
   318|         return decision;
   319|     }
   320|     private checkGroups(groups: string[]) {
   321|         if (!groups)
   322|             return true;
   323|         return this.options.groups.some(optionGroup => groups.indexOf(optionGroup) !== -1);
   324|     }
   325| }
   326| function instantiateArrayType(arrayType: Function): Array<any> | Set<any> {
   327|     const array = new (arrayType as any)();
   328|     if (!(array instanceof Set) && !("push" in array)) {
   329|         return [];
   330|     }
   331|     return array;
   332| }
   333| export function testForBuffer(): boolean {
   334|     try {
   335|         Buffer
   336|         return true;
   337|     } catch { }
   338|     return false;
   339| }


# ====================================================================
# FILE: src/decorators.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| import {ClassTransformer} from "./ClassTransformer";
     2| import {defaultMetadataStorage} from "./storage";
     3| import {TypeMetadata} from "./metadata/TypeMetadata";
     4| import {ExposeMetadata} from "./metadata/ExposeMetadata";
     5| import {ExposeOptions, ExcludeOptions, TypeHelpOptions, TransformOptions, Discriminator, TypeOptions} from "./metadata/ExposeExcludeOptions";
     6| import {ExcludeMetadata} from "./metadata/ExcludeMetadata";
     7| import {TransformMetadata} from "./metadata/TransformMetadata";
     8| import {ClassTransformOptions} from "./ClassTransformOptions";
     9| import {TransformationType} from "./TransformOperationExecutor";
    10| /**
    11|  * Defines a custom logic for value transformation.
    12|  */
    13| export function Transform(transformFn: (value: any, obj: any, transformationType: TransformationType) => any, options?: TransformOptions) {
    14|     return function(target: any, key: string) {
    15|         const metadata = new TransformMetadata(target.constructor, key, transformFn, options);
    16|         defaultMetadataStorage.addTransformMetadata(metadata);
    17|     };
    18| }
    19| /**
    20|  * Specifies a type of the property.
    21|  * The given TypeFunction can return a constructor. A discriminator can be given in the options.
    22|  */
    23| export function Type(typeFunction?: (type?: TypeHelpOptions) => Function, options?: TypeOptions) {
    24|     return function(target: any, key: string) {
    25|         const type = (Reflect as any).getMetadata("design:type", target, key);
    26|         const metadata = new TypeMetadata(target.constructor, key, type, typeFunction, options);
    27|         defaultMetadataStorage.addTypeMetadata(metadata);
    28|     };
    29| }
    30| /**
    31|  * Marks property as included in the process of transformation. By default it includes the property for both
    32|  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
    33|  * you want to skip this property.
    34|  */
    35| export function Expose(options?: ExposeOptions) {
    36|     return function(object: Object|Function, propertyName?: string) {
    37|         const metadata = new ExposeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});
    38|         defaultMetadataStorage.addExposeMetadata(metadata);
    39|     };
    40| }
    41| /**
    42|  * Marks property as excluded from the process of transformation. By default it excludes the property for both
    43|  * constructorToPlain and plainToConstructor transformations, however you can specify on which of transformation types
    44|  * you want to skip this property.
    45|  */
    46| export function Exclude(options?: ExcludeOptions) {
    47|     return function(object: Object|Function, propertyName?: string) {
    48|         const metadata = new ExcludeMetadata(object instanceof Function ? object : object.constructor, propertyName, options || {});
    49|         defaultMetadataStorage.addExcludeMetadata(metadata);
    50|     };
    51| }
    52| /**
    53|  * Transform the object from class to plain object and return only with the exposed properties.
    54|  */
    55| export function TransformClassToPlain(params?: ClassTransformOptions): Function {
    56|     return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
    57|         const classTransformer: ClassTransformer = new ClassTransformer();
    58|         const originalMethod = descriptor.value;
    59|         descriptor.value = function(...args: any[]) {
    60|             const result: any = originalMethod.apply(this, args);
    61|             const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
    62|             return isPromise ? result.then((data: any) => classTransformer.classToPlain(data, params)) : classTransformer.classToPlain(result, params);
    63|         };
    64|     };
    65| }
    66| /**
    67|  * Return the class instance only with the exposed properties.
    68|  */
    69| export function TransformClassToClass(params?: ClassTransformOptions): Function {
    70|     return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
    71|         const classTransformer: ClassTransformer = new ClassTransformer();
    72|         const originalMethod = descriptor.value;
    73|         descriptor.value = function(...args: any[]) {
    74|             const result: any = originalMethod.apply(this, args);
    75|             const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
    76|             return isPromise ? result.then((data: any) => classTransformer.classToClass(data, params)) : classTransformer.classToClass(result, params);
    77|         };
    78|     };
    79| }
    80| /**
    81|  * Return the class instance only with the exposed properties.
    82|  */
    83| export function TransformPlainToClass(classType: any, params?: ClassTransformOptions): Function {
    84|     return function (target: Function, propertyKey: string, descriptor: PropertyDescriptor) {
    85|         const classTransformer: ClassTransformer = new ClassTransformer();
    86|         const originalMethod = descriptor.value;
    87|         descriptor.value = function(...args: any[]) {
    88|             const result: any = originalMethod.apply(this, args);
    89|             const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
    90|             return isPromise ? result.then((data: any) => classTransformer.plainToClass(classType, data, params)) : classTransformer.plainToClass(classType, result, params);
    91|         };
    92|     };
    93| }


# ====================================================================
# FILE: src/index.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| import {ClassTransformer, ClassType} from "./ClassTransformer";
     2| import {ClassTransformOptions} from "./ClassTransformOptions";
     3| export {ClassTransformer} from "./ClassTransformer";
     4| export {ClassTransformOptions} from "./ClassTransformOptions";
     5| export * from "./metadata/ExposeExcludeOptions";
     6| export * from "./decorators";
     7| const classTransformer = new ClassTransformer();
     8| /**
     9|  * Converts class (constructor) object to plain (literal) object. Also works with arrays.
    10|  */
    11| export function classToPlain<T>(object: T, options?: ClassTransformOptions): Object;
    12| export function classToPlain<T>(object: T[], options?: ClassTransformOptions): Object[];
    13| export function classToPlain<T>(object: T|T[], options?: ClassTransformOptions): Object|Object[] {
    14|     return classTransformer.classToPlain(object, options);
    15| }
    16| /**
    17|  * Converts class (constructor) object to plain (literal) object.
    18|  * Uses given plain object as source object (it means fills given plain object with data from class object).
    19|  * Also works with arrays.
    20|  */
    21| export function classToPlainFromExist<T>(object: T, plainObject: Object, options?: ClassTransformOptions): Object;
    22| export function classToPlainFromExist<T>(object: T, plainObjects: Object[], options?: ClassTransformOptions): Object[];
    23| export function classToPlainFromExist<T>(object: T, plainObject: Object|Object[], options?: ClassTransformOptions): Object|Object[] {
    24|     return classTransformer.classToPlainFromExist(object, plainObject, options);
    25| }
    26| /**
    27|  * Converts plain (literal) object to class (constructor) object. Also works with arrays.
    28|  */
    29| export function plainToClass<T, V>(cls: ClassType<T>, plain: V[], options?: ClassTransformOptions): T[];
    30| export function plainToClass<T, V>(cls: ClassType<T>, plain: V, options?: ClassTransformOptions): T;
    31| export function plainToClass<T, V>(cls: ClassType<T>, plain: V|V[], options?: ClassTransformOptions): T|T[] {
    32|     return classTransformer.plainToClass(cls, plain as any, options);
    33| }
    34| /**
    35|  * Converts plain (literal) object to class (constructor) object.
    36|  * Uses given object as source object (it means fills given object with data from plain object).
    37|  *  Also works with arrays.
    38|  */
    39| export function plainToClassFromExist<T, V>(clsObject: T[], plain: V[], options?: ClassTransformOptions): T[];
    40| export function plainToClassFromExist<T, V>(clsObject: T, plain: V, options?: ClassTransformOptions): T;
    41| export function plainToClassFromExist<T, V>(clsObject: T, plain: V|V[], options?: ClassTransformOptions): T|T[] {
    42|     return classTransformer.plainToClassFromExist(clsObject, plain, options);
    43| }
    44| /**
    45|  * Converts class (constructor) object to new class (constructor) object. Also works with arrays.
    46|  */
    47| export function classToClass<T>(object: T, options?: ClassTransformOptions): T;
    48| export function classToClass<T>(object: T[], options?: ClassTransformOptions): T[];
    49| export function classToClass<T>(object: T|T[], options?: ClassTransformOptions): T|T[] {
    50|     return classTransformer.classToClass(object, options);
    51| }
    52| /**
    53|  * Converts class (constructor) object to plain (literal) object.
    54|  * Uses given plain object as source object (it means fills given plain object with data from class object).
    55|  * Also works with arrays.
    56|  */
    57| export function classToClassFromExist<T>(object: T, fromObject: T, options?: ClassTransformOptions): T;
    58| export function classToClassFromExist<T>(object: T, fromObjects: T[], options?: ClassTransformOptions): T[];
    59| export function classToClassFromExist<T>(object: T, fromObject: T|T[], options?: ClassTransformOptions): T|T[] {
    60|     return classTransformer.classToClassFromExist(object, fromObject, options);
    61| }
    62| /**
    63|  * Serializes given object to a JSON string.
    64|  */
    65| export function serialize<T>(object: T, options?: ClassTransformOptions): string;
    66| export function serialize<T>(object: T[], options?: ClassTransformOptions): string;
    67| export function serialize<T>(object: T|T[], options?: ClassTransformOptions): string {
    68|     return classTransformer.serialize(object, options);
    69| }
    70| /**
    71|  * Deserializes given JSON string to a object of the given class.
    72|  */
    73| export function deserialize<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T {
    74|     return classTransformer.deserialize(cls, json, options);
    75| }
    76| /**
    77|  * Deserializes given JSON string to an array of objects of the given class.
    78|  */
    79| export function deserializeArray<T>(cls: ClassType<T>, json: string, options?: ClassTransformOptions): T[] {
    80|     return classTransformer.deserializeArray(cls, json, options);
    81| }
    82| /**
    83|  * Enum representing the different transformation types.
    84|  */
    85| export enum TransformationType {
    86|     PLAIN_TO_CLASS,
    87|     CLASS_TO_PLAIN,
    88|     CLASS_TO_CLASS
    89| }


# ====================================================================
# FILE: src/metadata/ExcludeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-7 ---
     1| import {ExcludeOptions} from "./ExposeExcludeOptions";
     2| export class ExcludeMetadata {
     3|     constructor(public target: Function,
     4|                 public propertyName: string,
     5|                 public options: ExcludeOptions) {
     6|     }
     7| }


# ====================================================================
# FILE: src/metadata/ExposeExcludeOptions.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| export interface TransformOptions {
     2|     since?: number;
     3|     until?: number;
     4|     groups?: string[];
     5|     toClassOnly?: boolean;
     6|     toPlainOnly?: boolean;
     7| }
     8| export interface TypeOptions {
     9|     discriminator?: Discriminator;
    10|     /**
    11|      * Is false by default.
    12|      */
    13|     keepDiscriminatorProperty?: boolean;
    14| }
    15| export interface TypeHelpOptions {
    16|     newObject: any;
    17|     object: Object;
    18|     property: string;
    19| }
    20| export interface ExposeOptions {
    21|     name?: string;
    22|     since?: number;
    23|     until?: number;
    24|     groups?: string[];
    25|     toClassOnly?: boolean;
    26|     toPlainOnly?: boolean;
    27| }
    28| export interface ExcludeOptions {
    29|     toClassOnly?: boolean;
    30|     toPlainOnly?: boolean;
    31| }
    32| export interface Discriminator {
    33|     property: string;
    34|     subTypes: JsonSubType[];
    35| }
    36| export interface JsonSubType {
    37|     value: new (...args: any[]) => any;
    38|     name: string;
    39| }


# ====================================================================
# FILE: src/metadata/ExposeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-7 ---
     1| import {ExposeOptions} from "./ExposeExcludeOptions";
     2| export class ExposeMetadata {
     3|     constructor(public target: Function,
     4|                 public propertyName: string,
     5|                 public options: ExposeOptions) {
     6|     }
     7| }


# ====================================================================
# FILE: src/metadata/MetadataStorage.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-191 ---
     1| import {TypeMetadata} from "./TypeMetadata";
     2| import {ExposeMetadata} from "./ExposeMetadata";
     3| import {ExcludeMetadata} from "./ExcludeMetadata";
     4| import {TransformationType} from "../TransformOperationExecutor";
     5| import {TransformMetadata} from "./TransformMetadata";
     6| /**
     7|  * Storage all library metadata.
     8|  */
     9| export class MetadataStorage {
    10|     private _typeMetadatas = new Map<Function, Map<string, TypeMetadata>>();
    11|     private _transformMetadatas = new Map<Function, Map<string, TransformMetadata[]>>();
    12|     private _exposeMetadatas = new Map<Function, Map<string, ExposeMetadata>>();
    13|     private _excludeMetadatas = new Map<Function, Map<string, ExcludeMetadata>>();
    14|     private _ancestorsMap = new Map<Function, Function[]>();
    15|     addTypeMetadata(metadata: TypeMetadata) {
    16|         if (!this._typeMetadatas.has(metadata.target)) {
    17|             this._typeMetadatas.set(metadata.target, new Map<string, TypeMetadata>());
    18|     }
    19|         this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    20|     }
    21|     addTransformMetadata(metadata: TransformMetadata) {
    22|         if (!this._transformMetadatas.has(metadata.target)) {
    23|             this._transformMetadatas.set(metadata.target, new Map<string, TransformMetadata[]>());
    24|     }
    25|         if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
    26|             this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
    27|         }
    28|         this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
    29|     }
    30|     addExposeMetadata(metadata: ExposeMetadata) {
    31|         if (!this._exposeMetadatas.has(metadata.target)) {
    32|             this._exposeMetadatas.set(metadata.target, new Map<string, ExposeMetadata>());
    33|     }
    34|         this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    35|     }
    36|     addExcludeMetadata(metadata: ExcludeMetadata) {
    37|         if (!this._excludeMetadatas.has(metadata.target)) {
    38|             this._excludeMetadatas.set(metadata.target, new Map<string, ExcludeMetadata>());
    39|     }
    40|         this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
    41|     }
    42|     findTransformMetadatas(target: Function, propertyName: string, transformationType: TransformationType): TransformMetadata[] {
    43|         return this.findMetadatas(this._transformMetadatas, target, propertyName)
    44|             .filter(metadata => {
    45|                 if (!metadata.options)
    46|                     return true;
    47|                 if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
    48|                     return true;
    49|                 if (metadata.options.toClassOnly === true) {
    50|                     return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
    51|                 }
    52|                 if (metadata.options.toPlainOnly === true) {
    53|                     return transformationType === TransformationType.CLASS_TO_PLAIN;
    54|                 }
    55|                 return true;
    56|             });
    57|     }
    58|     findExcludeMetadata(target: Function, propertyName: string): ExcludeMetadata {
    59|         return this.findMetadata(this._excludeMetadatas, target, propertyName);
    60|     }
    61|     findExposeMetadata(target: Function, propertyName: string): ExposeMetadata {
    62|         return this.findMetadata(this._exposeMetadatas, target, propertyName);
    63|     }
    64|     findExposeMetadataByCustomName(target: Function, name: string): ExposeMetadata {
    65|         return this.getExposedMetadatas(target).find(metadata => {
    66|             return metadata.options && metadata.options.name === name;
    67|         });
    68|     }
    69|     findTypeMetadata(target: Function, propertyName: string) {
    70|         return this.findMetadata(this._typeMetadatas, target, propertyName);
    71|     }
    72|     getStrategy(target: Function): "excludeAll"|"exposeAll"|"none" {
    73|         const excludeMap = this._excludeMetadatas.get(target);
    74|         const exclude = excludeMap && excludeMap.get(undefined);
    75|         const exposeMap = this._exposeMetadatas.get(target);
    76|         const expose = exposeMap && exposeMap.get(undefined);
    77|         if ((exclude && expose) || (!exclude && !expose)) return "none";
    78|         return exclude ? "excludeAll" : "exposeAll";
    79|     }
    80|     getExposedMetadatas(target: Function): ExposeMetadata[] {
    81|         return this.getMetadata(this._exposeMetadatas, target);
    82|     }
    83|     getExcludedMetadatas(target: Function): ExcludeMetadata[] {
    84|         return this.getMetadata(this._excludeMetadatas, target);
    85|     }
    86|     getExposedProperties(target: Function, transformationType: TransformationType): string[] {
    87|         return this.getExposedMetadatas(target)
    88|             .filter(metadata => {
    89|                 if (!metadata.options)
    90|                     return true;
    91|                 if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
    92|                     return true;
    93|                 if (metadata.options.toClassOnly === true) {
    94|                     return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
    95|                 }
    96|                 if (metadata.options.toPlainOnly === true) {
    97|                     return transformationType === TransformationType.CLASS_TO_PLAIN;
    98|                 }
    99|                 return true;
   100|             })
   101|             .map(metadata => metadata.propertyName);
   102|     }
   103|     getExcludedProperties(target: Function, transformationType: TransformationType): string[] {
   104|         return this.getExcludedMetadatas(target)
   105|             .filter(metadata => {
   106|                 if (!metadata.options)
   107|                     return true;
   108|                 if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
   109|                     return true;
   110|                 if (metadata.options.toClassOnly === true) {
   111|                     return transformationType === TransformationType.CLASS_TO_CLASS ||  transformationType === TransformationType.PLAIN_TO_CLASS;
   112|                 }
   113|                 if (metadata.options.toPlainOnly === true) {
   114|                     return transformationType === TransformationType.CLASS_TO_PLAIN;
   115|                 }
   116|                 return true;
   117|             })
   118|             .map(metadata => metadata.propertyName);
   119|     }
   120|     clear() {
   121|         this._typeMetadatas.clear();
   122|         this._exposeMetadatas.clear();
   123|         this._excludeMetadatas.clear();
   124|         this._ancestorsMap.clear();
   125|     }
   126|     private getMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<String, T>>, target: Function): T[] {
   127|         const metadataFromTargetMap = metadatas.get(target);
   128|         let metadataFromTarget: T[];
   129|         if (metadataFromTargetMap) {
   130|             metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter(meta => meta.propertyName !== undefined);
   131|         }
   132|         let metadataFromAncestors: T[] = [];
   133|         for (const ancestor of this.getAncestors(target)) {
   134|             const ancestorMetadataMap = metadatas.get(ancestor);
   135|             if (ancestorMetadataMap) {
   136|                 const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter(meta => meta.propertyName !== undefined);
   137|                 metadataFromAncestors.push(...metadataFromAncestor);
   138|             }
   139|         }        
   140|         return metadataFromAncestors.concat(metadataFromTarget || []);
   141|     }
   142|     private findMetadata<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T>>, target: Function, propertyName: string): T {
   143|         const metadataFromTargetMap = metadatas.get(target);
   144|         if (metadataFromTargetMap) {
   145|             const metadataFromTarget = metadataFromTargetMap.get(propertyName);  
   146|             if (metadataFromTarget) {
   147|                 return metadataFromTarget;
   148|             }
   149|         }
   150|         for (const ancestor of this.getAncestors(target)) {
   151|             const ancestorMetadataMap = metadatas.get(ancestor);
   152|             if (ancestorMetadataMap) {
   153|                 const ancestorResult = ancestorMetadataMap.get(propertyName);
   154|                 if (ancestorResult) {
   155|                   return ancestorResult;
   156|                 }
   157|             }
   158|         }
   159|         return undefined;
   160|     }
   161|     private findMetadatas<T extends { target: Function, propertyName: string }>(metadatas: Map<Function, Map<string, T[]>>, target: Function, propertyName: string): T[] {
   162|         const metadataFromTargetMap = metadatas.get(target);
   163|         let metadataFromTarget: T[];
   164|         if (metadataFromTargetMap) {
   165|             metadataFromTarget = metadataFromTargetMap.get(propertyName);    
   166|         }
   167|         let metadataFromAncestorsTarget: T[] = [];
   168|         for (const ancestor of this.getAncestors(target)) {
   169|             const ancestorMetadataMap = metadatas.get(ancestor);
   170|             if (ancestorMetadataMap) {
   171|                 if (ancestorMetadataMap.has(propertyName)) {
   172|                   metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
   173|                 }
   174|             }
   175|         }
   176|         return (metadataFromAncestorsTarget).reverse().concat((metadataFromTarget || []).reverse());
   177|     }
   178|     private getAncestors(target: Function): Function[] {
   179|         if (!target) return [];
   180|         if (!this._ancestorsMap.has(target)) {
   181|             let ancestors: Function[] = [];
   182|             for (let baseClass = Object.getPrototypeOf(target.prototype.constructor);
   183|                  typeof baseClass.prototype !== "undefined";
   184|                  baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
   185|                 ancestors.push(baseClass);
   186|             }
   187|             this._ancestorsMap.set(target, ancestors);
   188|         }
   189|         return this._ancestorsMap.get(target);
   190|     }
   191| }


# ====================================================================
# FILE: src/metadata/TransformMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {TransformOptions} from "./ExposeExcludeOptions";
     2| import {TransformationType} from "../TransformOperationExecutor";
     3| export class TransformMetadata {
     4|     constructor(public target: Function,
     5|                 public propertyName: string,
     6|                 public transformFn: (value: any, obj: any, transformationType: TransformationType) => any,
     7|                 public options: TransformOptions) {
     8|     }
     9| }


# ====================================================================
# FILE: src/metadata/TypeMetadata.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-9 ---
     1| import {TypeHelpOptions, Discriminator, TypeOptions} from "./ExposeExcludeOptions";
     2| export class TypeMetadata {
     3|     constructor(public target: Function,
     4|                 public propertyName: string,
     5|                 public reflectedType: any,
     6|                 public typeFunction: (options?: TypeHelpOptions) => Function,
     7|                 public options: TypeOptions) {
     8|     }
     9| }


# ====================================================================
# FILE: src/storage.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| import {MetadataStorage} from "./metadata/MetadataStorage";
     2| /**
     3|  * Default metadata storage is used as singleton and can be used to storage all metadatas.
     4|  */
     5| export const defaultMetadataStorage = new MetadataStorage();

