--- a/karma.conf.js
+++ b/karma.conf.js
@@ -25,21 +25,20 @@
     frameworks: frameworks,
     files: files,
     exclude: [
     ],
     preprocessors: {
       'tests/unit/**.js': preprocessors,
       'tests/karma/**.js': preprocessors,
       'lib/prime.worker.js': workerPreprocessors
     },
     webpack: {
-      mode: 'development',
       devtool: 'inline-source-map',
       node: {
         Buffer: false,
         process: false,
         crypto: false,
         setImmediate: false
       }
     },
     browserify: {
       debug: true

--- a/lib/util.js
+++ b/lib/util.js
@@ -2174,20 +2174,107 @@
  */
 util.makeLink = function(path, query, fragment) {
   path = jQuery.isArray(path) ? path.join('/') : path;
   var qstr = jQuery.param(query || {});
   fragment = fragment || '';
   return path +
     ((qstr.length > 0) ? ('?' + qstr) : '') +
     ((fragment.length > 0) ? ('#' + fragment) : '');
 };
 /**
+ * Follows a path of keys deep into an object hierarchy and set a value.
+ * If a key does not exist or it's value is not an object, create an
+ * object in it's place. This can be destructive to a object tree if
+ * leaf nodes are given as non-final path keys.
+ * Used to avoid exceptions from missing parts of the path.
+ *
+ * SECURITY NOTE: Do not use unsafe inputs. Doing so could expose a prototype
+ * pollution security issue.
+ *
+ * @param object the starting object.
+ * @param keys an array of string keys.
+ * @param value the value to set.
+ */
+util.setPath = function(object, keys, value) {
+  if(typeof(object) === 'object' && object !== null) {
+    var i = 0;
+    var len = keys.length;
+    while(i < len) {
+      var next = keys[i++];
+      if(i == len) {
+        object[next] = value;
+      } else {
+        var hasNext = (next in object);
+        if(!hasNext ||
+          (hasNext && typeof(object[next]) !== 'object') ||
+          (hasNext && object[next] === null)) {
+          object[next] = {};
+        }
+        object = object[next];
+      }
+    }
+  }
+};
+/**
+ * Follows a path of keys deep into an object hierarchy and return a value.
+ * If a key does not exist, create an object in it's place.
+ * Used to avoid exceptions from missing parts of the path.
+ *
+ * @param object the starting object.
+ * @param keys an array of string keys.
+ * @param _default value to return if path not found.
+ *
+ * @return the value at the path if found, else default if given, else
+ *         undefined.
+ */
+util.getPath = function(object, keys, _default) {
+  var i = 0;
+  var len = keys.length;
+  var hasNext = true;
+  while(hasNext && i < len &&
+    typeof(object) === 'object' && object !== null) {
+    var next = keys[i++];
+    hasNext = next in object;
+    if(hasNext) {
+      object = object[next];
+    }
+  }
+  return (hasNext ? object : _default);
+};
+/**
+ * Follow a path of keys deep into an object hierarchy and delete the
+ * last one. If a key does not exist, do nothing.
+ * Used to avoid exceptions from missing parts of the path.
+ *
+ * @param object the starting object.
+ * @param keys an array of string keys.
+ */
+util.deletePath = function(object, keys) {
+  if(typeof(object) === 'object' && object !== null) {
+    var i = 0;
+    var len = keys.length;
+    while(i < len) {
+      var next = keys[i++];
+      if(i == len) {
+        delete object[next];
+      } else {
+        if(!(next in object) ||
+          (typeof(object[next]) !== 'object') ||
+          (object[next] === null)) {
+           break;
+        }
+        object = object[next];
+      }
+    }
+  }
+};
+/**
  * Check if an object is empty.
  *
  * Taken from:
  * http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object-from-json/679937#679937
  *
  * @param object the object to check.
  */
 util.isEmpty = function(obj) {
   for(var prop in obj) {
     if(obj.hasOwnProperty(prop)) {

--- a/webpack.config.js
+++ b/webpack.config.js
@@ -1,18 +1,19 @@
 /**
  * Forge webpack build rules.
  *
  * @author Digital Bazaar, Inc.
  *
  * Copyright 2011-2016 Digital Bazaar, Inc.
  */
 const path = require('path');
+const webpack = require('webpack');
 module.exports = [];
 const outputs = [
   {
     entry: ['./lib/index.js'],
     filenameBase: 'forge'
   },
   {
     entry: ['./lib/index.all.js'],
     filenameBase: 'forge.all'
   },
@@ -29,55 +30,51 @@
       forge: info.entry
     },
     node: {
       Buffer: false,
       process: false,
       crypto: false,
       setImmediate: false
     }
   };
   const bundle = Object.assign({}, common, {
-    mode: 'development',
     output: {
       path: path.join(__dirname, 'dist'),
       filename: info.filenameBase + '.js',
       library: info.library || '[name]',
       libraryTarget: info.libraryTarget || 'umd'
     }
   });
   if(info.library === null) {
     delete bundle.output.library;
   }
   if(info.libraryTarget === null) {
     delete bundle.output.libraryTarget;
   }
   const minify = Object.assign({}, common, {
-    mode: 'production',
     output: {
       path: path.join(__dirname, 'dist'),
       filename: info.filenameBase + '.min.js',
       library: info.library || '[name]',
       libraryTarget: info.libraryTarget || 'umd'
     },
     devtool: 'cheap-module-source-map',
     plugins: [
-      /*
       new webpack.optimize.UglifyJsPlugin({
         sourceMap: true,
         compress: {
           warnings: true
         },
         output: {
           comments: false
         }
       })
-      */
     ]
   });
   if(info.library === null) {
     delete minify.output.library;
   }
   if(info.libraryTarget === null) {
     delete minify.output.libraryTarget;
   }
   module.exports.push(bundle);
   module.exports.push(minify);
