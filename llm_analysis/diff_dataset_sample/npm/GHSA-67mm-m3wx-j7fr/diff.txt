--- a/src/index.ts
+++ b/src/index.ts
@@ -1,16 +1,11 @@
-import {
-  execFile,
-  execFileSync,
-  ExecFileSyncOptions,
-  ExecException,
-} from "child_process";
+import { exec, execSync, ExecSyncOptions, ExecException } from "child_process";
 import { existsSync } from "fs";
 import createDebugger from "debug";
 const debug = createDebugger("gitlog");
 const delimiter = "\t";
 const fieldMap = {
   hash: "%H",
   abbrevHash: "%h",
   treeHash: "%T",
   abbrevTreeHash: "%t",
   parentHashes: "%P",
@@ -104,47 +99,47 @@
   committer?: string;
   /** Show commits more recent than a specific date. */
   since?: string;
   /** Show commits more recent than a specific date. */
   after?: string;
   /** Show commits older than a specific date */
   until?: string;
   /** Show commits older than a specific date */
   before?: string;
   /** Specify some options to be passed to the .exec() method */
-  execOptions?: ExecFileSyncOptions;
+  execOptions?: ExecSyncOptions;
 }
 const defaultOptions = {
   number: 10,
   fields: defaultFields,
   nameStatus: true,
   includeMergeCommitFiles: false,
   findCopiesHarder: false,
   all: false,
 };
 /** Add optional parameter to command */
-function addOptionalArguments<Field extends string = DefaultField>(
-  command: string[],
+function addOptional<Field extends string = DefaultField>(
+  command: string,
   options: GitlogOptions<Field>
 ) {
   let commandWithOptions = command;
   const cmdOptional = [
     "author",
     "since",
     "after",
     "until",
     "before",
     "committer",
   ] as const;
   for (let i = cmdOptional.length; i--; ) {
     if (options[cmdOptional[i]]) {
-      commandWithOptions.push(`--${cmdOptional[i]}=${options[cmdOptional[i]]}`);
+      commandWithOptions += ` --${cmdOptional[i]}="${options[cmdOptional[i]]}"`;
     }
   }
   return commandWithOptions;
 }
 /** Parse the output of "git log" for commit information */
 const parseCommits = <T extends string>(
   commits: string[],
   fields: readonly T[],
   nameStatus: boolean
 ) => {
@@ -194,60 +189,56 @@
         const arr = parsed[notOptFields[pos]];
         if (Array.isArray(arr)) {
           arr.push(commitField);
         }
       }
     });
     return parsed as Commit;
   });
 };
 /** Run "git log" and return the result as JSON */
-function createCommandArguments<
-  T extends CommitField | DefaultField = DefaultField
->(options: GitlogOptions<T>) {
-  let command: string[] = ["log", "-l0"];
+function createCommand<T extends CommitField | DefaultField = DefaultField>(
+  options: GitlogOptions<T>
+) {
+  let command = "git log -l0 ";
   if (options.findCopiesHarder) {
-    command.push("--find-copies-harder");
+    command += "--find-copies-harder ";
   }
   if (options.all) {
-    command.push("--all");
+    command += "--all ";
   }
   if (options.includeMergeCommitFiles) {
-    command.push("-m");
-  }
-  command.push(`-n ${options.number}`);
-  command = addOptionalArguments(command, options);
-  let prettyArgument: string = "--pretty=@begin@";
+    command += "-m ";
+  }
+  command += `-n ${options.number}`;
+  command = addOptional(command, options);
+  command += ' --pretty="@begin@';
   if (options.fields) {
     options.fields.forEach((field) => {
       if (!fieldMap[field] && !notOptFields.includes(field as any)) {
         throw new Error(`Unknown field: ${field}`);
       }
-      prettyArgument += delimiter + fieldMap[field];
+      command += delimiter + fieldMap[field];
     });
   }
-  prettyArgument += "@end@";
-  command.push(prettyArgument);
+  command += '@end@"';
   if (options.branch) {
-    command.push(options.branch);
+    command += ` ${options.branch}`;
   }
   if (options.nameStatus && !options.fileLineRange) {
-    command.push("--name-status");
+    command += " --name-status";
   }
   if (options.fileLineRange) {
-    command.push(
-      `-L ${options.fileLineRange.startLine},${options.fileLineRange.endLine}:${options.fileLineRange.file}`
-    );
+    command += ` -L ${options.fileLineRange.startLine},${options.fileLineRange.endLine}:${options.fileLineRange.file}`;
   }
   if (options.file) {
-    command.push("--");
-    command.push(options.file);
+    command += ` -- ${options.file}`;
   }
   debug("command", options.execOptions, command);
   return command;
 }
 type GitlogError = ExecException | string | null;
 type CommitBase<Field extends string> = Record<Field, string>;
 type CommitBaseWithFiles<Field extends string> = Record<
   Field | "status",
   string
 > & { files: string[] };
@@ -275,35 +266,31 @@
     throw new Error("Repo required!");
   }
   if (!existsSync(userOptions.repo)) {
     throw new Error("Repo location does not exist");
   }
   const options = {
     ...(defaultOptions as any),
     ...userOptions,
   };
   const execOptions = { cwd: userOptions.repo, ...userOptions.execOptions };
-  const commandArguments = createCommandArguments(options);
+  const command = createCommand(options);
   if (!cb) {
-    const stdout = execFileSync(
-      "git",
-      commandArguments,
-      execOptions
-    ).toString();
+    const stdout = execSync(command, execOptions).toString();
     const commits = stdout.split("@begin@");
     if (commits[0] === "") {
       commits.shift();
     }
     debug("commits", commits);
     return parseCommits(commits, options.fields, options.nameStatus);
   }
-  execFile("git", commandArguments, execOptions, (err, stdout, stderr) => {
+  exec(command, execOptions, (err, stdout, stderr) => {
     debug("stdout", stdout);
     const commits = stdout.split("@begin@");
     if (commits[0] === "") {
       commits.shift();
     }
     debug("commits", commits);
     cb(
       stderr || err,
       parseCommits(commits, options.fields, options.nameStatus)
     );
