# ====================================================================
# FILE: src/update-state.ts
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-73 ---
     1| export function updateState(update: any, state: any) {
     2|     const updatedState = deepClone(state);
     3|     const hasChanges = updateStateInternal(update, updatedState);
     4|     return {
     5|         hasChanges,
     6|         state: updatedState,
     7|     };
     8| }
     9| export function deepClone<T>(o: T): T {
    10|     return JSON.parse(JSON.stringify(o));
    11| }
    12| const arrayItemKeyMap = new Map<string, string>([
    13|     ['openState', 'openDirection'],
    14|     ['currentSensorStateData', 'name'],
    15| ]);
    16| const ignoreKeys: any[] = ['__proto__', 'constructor', 'prototype'];
    17| function updateArrayState(update: any[], state: any[], path = ''): boolean {
    18|     let hasChanges = false;
    19|     const key = arrayItemKeyMap.get(path);
    20|     if (key) {
    21|         for (const [index, item] of update.entries()) {
    22|             const keyValue = item[key];
    23|             const stateItem = state.find(stateChild => stateChild[key] === keyValue);
    24|             if (stateItem) {
    25|                 if (updateStateInternal(item, stateItem, `${path}[${index}]`)) {
    26|                     hasChanges = true;
    27|                 }
    28|             } else {
    29|             }
    30|         }
    31|     } else {
    32|         state.splice(0, state.length, ...update);
    33|         return true;
    34|     }
    35|     return hasChanges;
    36| }
    37| function updateStateInternal(update: any, state: any, path = ''): boolean {
    38|     if (Array.isArray(update)) {
    39|         if (!Array.isArray(state)) {
    40|             throw new Error(`${path} is not an array in state`);
    41|         }
    42|         return updateArrayState(update, state, path);
    43|     }
    44|     let hasChanges = false;
    45|     for (const [key, newValue] of entries(update)) {
    46|         if (ignoreKeys.includes(key)) { continue; }
    47|         const oldValue = state[key];
    48|         const newType = typeof newValue;
    49|         const oldType = typeof oldValue;
    50|         if (newType !== oldType) {
    51|             if (newType === 'object' && oldType === 'undefined' && Object.keys(newValue).length === 0) {
    52|                 continue;
    53|             }
    54|         }
    55|         if (newType === 'object' && oldType === 'object') {
    56|             const keyString = String(key);
    57|             const currentPath = path && path.endsWith('.') ? `${path}.${keyString}` : `${path}${keyString}`;
    58|             if (updateStateInternal(newValue, oldValue as any, currentPath)) {
    59|                 hasChanges = true;
    60|             }
    61|             continue;
    62|         }
    63|         if (newValue !== oldValue) {
    64|             state[key] = newValue;
    65|             hasChanges = true;
    66|             continue;
    67|         }
    68|     }
    69|     return hasChanges;
    70| }
    71| function entries<T extends object>(o: T): [keyof T, any][] {
    72|     return Object.entries(o) as any;
    73| }

