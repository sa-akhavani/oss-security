# ====================================================================
# FILE: babel.config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-12 ---
     1| module.exports = {
     2|   presets: [
     3|     [
     4|       '@babel/preset-env',
     5|       {
     6|         targets: {
     7|           node: 'current',
     8|         },
     9|       },
    10|     ],
    11|   ],
    12| };


# ====================================================================
# FILE: jest.config.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-50 ---
     1| const { TEST_HOST } = require('./test/config/server.js');
     2| const sharedConfig = {
     3|   errorOnDeprecated: true,
     4|   globals: {
     5|     TEST_HOST,
     6|   },
     7|   globalSetup: './test/config/jest.setup.js',
     8|   globalTeardown: './test/config/jest.teardown.js',
     9|   resetModules: true,
    10|   restoreMocks: true,
    11| };
    12| module.exports = {
    13|   globals: sharedConfig.globals,
    14|   projects: [
    15|     {
    16|       ...sharedConfig,
    17|       displayName: 'unit',
    18|       setupFilesAfterEnv: ['<rootDir>/test/config/jest.setup-tests.js'],
    19|       testMatch: ['<rootDir>/test/unit/*.test.js'],
    20|       testURL: `${TEST_HOST}/_blank.html`,
    21|     },
    22|     {
    23|       ...sharedConfig,
    24|       displayName: 'integration',
    25|       setupFilesAfterEnv: ['<rootDir>/test/config/jest.setup-tests.js'],
    26|       testMatch: ['<rootDir>/test/integration/*.test.js'],
    27|       testURL: `${TEST_HOST}/_blank.html`,
    28|     },
    29|     {
    30|       ...sharedConfig,
    31|       displayName: 'e2e',
    32|       preset: 'jest-playwright-preset',
    33|       setupFilesAfterEnv: [
    34|         '<rootDir>/test/config/jest-playwright.setup-tests.js',
    35|       ],
    36|       testEnvironmentOptions: {
    37|         'jest-playwright': {
    38|           browsers: [
    39|             'chromium',
    40|             'firefox',
    41|             'webkit',
    42|           ],
    43|           launchOptions: {
    44|           },
    45|         },
    46|       },
    47|       testMatch: ['<rootDir>/test/e2e/*.test.js'],
    48|     },
    49|   ],
    50| };


# ====================================================================
# FILE: packages/docsify-server-renderer/index.js
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| import { readFileSync } from 'fs';
     2| import { resolve, basename } from 'path';
     3| import resolvePathname from 'resolve-pathname';
     4| import fetch from 'node-fetch';
     5| import debug from 'debug';
     6| import DOMPurify from 'dompurify';
     7| import { AbstractHistory } from '../../src/core/router/history/abstract';
     8| import { Compiler } from '../../src/core/render/compiler';
     9| import { isAbsolutePath } from '../../src/core/router/util';
    10| import * as tpl from '../../src/core/render/tpl';
    11| import { prerenderEmbed } from '../../src/core/render/embed';
    12| function cwd(...args) {
    13|   return resolve(process.cwd(), ...args);
    14| }
    15| function isExternal(url) {
    16|   let match = url.match(
    17|     /^([^:/?#]+:)?(?:\/\/([^/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
    18|   );
    19|   if (
    20|     typeof match[1] === 'string' &&
    21|     match[1].length > 0 &&
    22|     match[1].toLowerCase() !== location.protocol
    23|   ) {
    24|     return true;
    25|   }
    26|   if (
    27|     typeof match[2] === 'string' &&
    28|     match[2].length > 0 &&
    29|     match[2].replace(
    30|       new RegExp(
    31|         ':(' + { 'http:': 80, 'https:': 443 }[location.protocol] + ')?$'
    32|       ),
    33|       ''
    34|     ) !== location.host
    35|   ) {
    36|     return true;
    37|   }

# --- HUNK 2: Lines 85-127 ---
    85|     if (loadNavbar) {
    86|       const name = loadNavbar === true ? '_navbar.md' : loadNavbar;
    87|       const navbarFile = this._getPath(resolve(url, `./${name}`));
    88|       this._renderHtml('navbar', await this._render(navbarFile, 'navbar'));
    89|     }
    90|     if (coverpage) {
    91|       let path = null;
    92|       if (typeof coverpage === 'string') {
    93|         if (url === '/') {
    94|           path = coverpage;
    95|         }
    96|       } else if (Array.isArray(coverpage)) {
    97|         path = coverpage.indexOf(url) > -1 && '_coverpage.md';
    98|       } else {
    99|         const cover = coverpage[url];
   100|         path = cover === true ? '_coverpage.md' : cover;
   101|       }
   102|       const coverFile = this._getPath(resolve(url, `./${path}`));
   103|       this._renderHtml('cover', await this._render(coverFile), 'cover');
   104|     }
   105|     const html = this.isRemoteUrl
   106|       ? DOMPurify.sanitize(this.html, { ADD_TAGS: ['script'] })
   107|       : this.html;
   108|     this.html = this.template;
   109|     return html;
   110|   }
   111|   _renderHtml(match, content) {
   112|     this.html = this.html.replace(new RegExp(`<!--${match}-->`, 'g'), content);
   113|     return this.html;
   114|   }
   115|   async _render(path, type) {
   116|     let html = await this._loadFile(path);
   117|     const { subMaxLevel, maxLevel } = this.config;
   118|     let tokens;
   119|     switch (type) {
   120|       case 'sidebar':
   121|         html =
   122|           this.compiler.sidebar(html, maxLevel) +
   123|           `<script>window.__SUB_SIDEBAR__ = ${JSON.stringify(
   124|             this.compiler.subSidebar(subMaxLevel)
   125|           )}</script>`;
   126|         break;
   127|       case 'cover':


# ====================================================================
# FILE: src/core/event/scroll.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| import Tweezer from 'tweezer.js';
     2| import { isMobile } from '../util/env';
     3| import * as dom from '../util/dom';
     4| import { removeParams } from '../router/util';
     5| import config from '../config';
     6| const nav = {};
     7| let hoverOver = false;
     8| let scroller = null;
     9| let enableScrollEvent = true;
    10| let coverHeight = 0;
    11| function scrollTo(el, offset = 0) {
    12|   if (scroller) {
    13|     scroller.stop();
    14|   }
    15|   enableScrollEvent = false;
    16|   scroller = new Tweezer({
    17|     start: window.pageYOffset,
    18|     end:
    19|       Math.round(el.getBoundingClientRect().top) + window.pageYOffset - offset,
    20|     duration: 500,
    21|   })
    22|     .on('tick', v => window.scrollTo(0, v))
    23|     .on('done', () => {
    24|       enableScrollEvent = true;
    25|       scroller = null;
    26|     })
    27|     .begin();
    28| }
    29| function highlight(path) {
    30|   if (!enableScrollEvent) {
    31|     return;
    32|   }
    33|   const sidebar = dom.getNode('.sidebar');
    34|   const anchors = dom.findAll('.anchor');
    35|   const wrap = dom.find(sidebar, '.sidebar-nav');
    36|   let active = dom.find(sidebar, 'li.active');
    37|   const doc = document.documentElement;
    38|   const top = ((doc && doc.scrollTop) || document.body.scrollTop) - coverHeight;
    39|   let last;


# ====================================================================
# FILE: src/core/event/sidebar.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 54-90 ---
    54| }
    55| /**
    56|  * Get and active link
    57|  * @param  {Object} router Router
    58|  * @param  {String|Element} el Target element
    59|  * @param  {Boolean} isParent Active parent
    60|  * @param  {Boolean} autoTitle Automatically set title
    61|  * @return {Element} Active element
    62|  */
    63| export function getAndActive(router, el, isParent, autoTitle) {
    64|   el = dom.getNode(el);
    65|   let links = [];
    66|   if (el !== null && el !== undefined) {
    67|     links = dom.findAll(el, 'a');
    68|   }
    69|   const hash = decodeURI(router.toURL(router.getCurrentPath()));
    70|   let target;
    71|   links
    72|     .sort((a, b) => b.href.length - a.href.length)
    73|     .forEach(a => {
    74|       const href = decodeURI(a.getAttribute('href'));
    75|       const node = isParent ? a.parentNode : a;
    76|       a.title = a.title || a.innerText;
    77|       if (hash.indexOf(href) === 0 && !target) {
    78|         target = a;
    79|         dom.toggleClass(node, 'add', 'active');
    80|       } else {
    81|         dom.toggleClass(node, 'remove', 'active');
    82|       }
    83|     });
    84|   if (autoTitle) {
    85|     dom.$.title = target
    86|       ? target.title || `${target.innerText} - ${title}`
    87|       : title;
    88|   }
    89|   return target;
    90| }


# ====================================================================
# FILE: src/core/fetch/index.js
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| /* eslint-disable no-unused-vars */
     2| import { callHook } from '../init/lifecycle';
     3| import { getParentPath, stringifyQuery } from '../router/util';
     4| import { noop } from '../util/core';
     5| import { getAndActive } from '../event/sidebar';
     6| import { get } from './ajax';
     7| function loadNested(path, qs, file, next, vm, first) {
     8|   path = first ? path : path.replace(/\/$/, '');
     9|   path = getParentPath(path);
    10|   if (!path) {
    11|     return;
    12|   }
    13|   get(
    14|     vm.router.getFile(path + file) + qs,
    15|     false,
    16|     vm.config.requestHeaders
    17|   ).then(next, _ => loadNested(path, qs, file, next, vm));
    18| }
    19| function isExternal(url) {
    20|   let match = url.match(
    21|     /^([^:/?#]+:)?(?:\/\/([^/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
    22|   );
    23|   if (
    24|     typeof match[1] === 'string' &&
    25|     match[1].length > 0 &&
    26|     match[1].toLowerCase() !== location.protocol
    27|   ) {
    28|     return true;
    29|   }
    30|   if (
    31|     typeof match[2] === 'string' &&
    32|     match[2].length > 0 &&
    33|     match[2].replace(
    34|       new RegExp(
    35|         ':(' + { 'http:': 80, 'https:': 443 }[location.protocol] + ')?$'
    36|       ),
    37|       ''
    38|     ) !== location.host
    39|   ) {
    40|     return true;
    41|   }

# --- HUNK 2: Lines 47-140 ---
    47|   const request = (url, hasbar, requestHeaders) => {
    48|     abort();
    49|     last = get(url, true, requestHeaders);
    50|     return last;
    51|   };
    52|   const get404Path = (path, config) => {
    53|     const { notFoundPage, ext } = config;
    54|     const defaultPath = '_404' + (ext || '.md');
    55|     let key;
    56|     let path404;
    57|     switch (typeof notFoundPage) {
    58|       case 'boolean':
    59|         path404 = defaultPath;
    60|         break;
    61|       case 'string':
    62|         path404 = notFoundPage;
    63|         break;
    64|       case 'object':
    65|         key = Object.keys(notFoundPage)
    66|           .sort((a, b) => b.length - a.length)
    67|           .filter(k => path.match(new RegExp('^' + k)))[0];
    68|         path404 = (key && notFoundPage[key]) || defaultPath;
    69|         break;
    70|       default:
    71|         break;
    72|     }
    73|     return path404;
    74|   };
    75|   proto._loadSideAndNav = function(path, qs, loadSidebar, cb) {
    76|     return () => {
    77|       if (!loadSidebar) {
    78|         return cb();
    79|       }
    80|       const fn = result => {
    81|         this._renderSidebar(result);
    82|         cb();
    83|       };
    84|       loadNested(path, qs, loadSidebar, fn, this, true);
    85|     };
    86|   };
    87|   proto._fetch = function(cb = noop) {
    88|     const { query } = this.route;
    89|     let { path } = this.route;
    90|     if (isExternal(path)) {
    91|       history.replaceState(null, '', '#');
    92|       this.router.normalize();
    93|     } else {
    94|       const qs = stringifyQuery(query, ['id']);
    95|       const { loadNavbar, requestHeaders, loadSidebar } = this.config;
    96|       const file = this.router.getFile(path);
    97|       const req = request(file + qs, true, requestHeaders);
    98|       this.isRemoteUrl = isExternal(file);
    99|       this.isHTML = /\.html$/g.test(file);
   100|       req.then(
   101|         (text, opt) =>
   102|           this._renderMain(
   103|             text,
   104|             opt,
   105|             this._loadSideAndNav(path, qs, loadSidebar, cb)
   106|           ),
   107|         _ => {
   108|           this._fetchFallbackPage(path, qs, cb) || this._fetch404(file, qs, cb);
   109|         }
   110|       );
   111|       loadNavbar &&
   112|         loadNested(
   113|           path,
   114|           qs,
   115|           loadNavbar,
   116|           text => this._renderNav(text),
   117|           this,
   118|           true
   119|         );
   120|     }
   121|   };
   122|   proto._fetchCover = function() {
   123|     const { coverpage, requestHeaders } = this.config;
   124|     const query = this.route.query;
   125|     const root = getParentPath(this.route.path);
   126|     if (coverpage) {
   127|       let path = null;
   128|       const routePath = this.route.path;
   129|       if (typeof coverpage === 'string') {
   130|         if (routePath === '/') {
   131|           path = coverpage;
   132|         }
   133|       } else if (Array.isArray(coverpage)) {
   134|         path = coverpage.indexOf(routePath) > -1 && '_coverpage';
   135|       } else {
   136|         const cover = coverpage[routePath];
   137|         path = cover === true ? '_coverpage' : cover;
   138|       }
   139|       const coverOnly = Boolean(path) && this.config.onlyCover;
   140|       if (path) {


# ====================================================================
# FILE: src/core/init/lifecycle.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| import { noop } from '../util/core';
     2| export function initLifecycle(vm) {
     3|   const hooks = [
     4|     'init',
     5|     'mounted',
     6|     'beforeEach',
     7|     'afterEach',
     8|     'doneEach',
     9|     'ready',
    10|   ];
    11|   vm._hooks = {};
    12|   vm._lifecycle = {};
    13|   hooks.forEach(hook => {
    14|     const arr = (vm._hooks[hook] = []);
    15|     vm._lifecycle[hook] = fn => arr.push(fn);
    16|   });
    17| }
    18| export function callHook(vm, hookName, data, next = noop) {
    19|   const queue = vm._hooks[hookName];
    20|   const step = function(index) {
    21|     const hookFn = queue[index];
    22|     if (index >= queue.length) {
    23|       next(data);
    24|     } else if (typeof hookFn === 'function') {
    25|       if (hookFn.length === 2) {
    26|         hookFn(data, result => {
    27|           data = result;
    28|           step(index + 1);
    29|         });
    30|       } else {
    31|         const result = hookFn(data);
    32|         data = result === undefined ? data : result;
    33|         step(index + 1);
    34|       }
    35|     } else {
    36|       step(index + 1);
    37|     }
    38|   };
    39|   step(0);
    40| }


# ====================================================================
# FILE: src/core/render/compiler.js
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| import marked from 'marked';
     2| import { isAbsolutePath, getPath, getParentPath } from '../router/util';
     3| import { isFn, merge, cached, isPrimitive } from '../util/core';
     4| import { tree as treeTpl } from './tpl';
     5| import { genTree } from './gen-tree';
     6| import { slugify } from './slugify';
     7| import { emojify } from './emojify';
     8| import { getAndRemoveConfig, removeAtag } from './utils';
     9| import { imageCompiler } from './compiler/image';
    10| import { highlightCodeCompiler } from './compiler/code';
    11| import { paragraphCompiler } from './compiler/paragraph';
    12| import { taskListCompiler } from './compiler/taskList';
    13| import { taskListItemCompiler } from './compiler/taskListItem';
    14| import { linkCompiler } from './compiler/link';
    15| const cachedLinks = {};
    16| const compileMedia = {
    17|   markdown(url) {
    18|     return {
    19|       url,
    20|     };
    21|   },
    22|   mermaid(url) {
    23|     return {
    24|       url,
    25|     };
    26|   },
    27|   iframe(url, title) {
    28|     return {

# --- HUNK 2: Lines 162-220 ---
   162|       const re = cachedLinks[n] || (cachedLinks[n] = new RegExp(`^${n}$`));
   163|       if (re.test(link)) {
   164|         return link;
   165|       }
   166|     }
   167|   }
   168|   _initRenderer() {
   169|     const renderer = new marked.Renderer();
   170|     const { linkTarget, linkRel, router, contentBase } = this;
   171|     const _self = this;
   172|     const origin = {};
   173|     /**
   174|      * Render anchor tag
   175|      * @link https://github.com/markedjs/marked#overriding-renderer-methods
   176|      * @param {String} text Text content
   177|      * @param {Number} level Type of heading (h<level> tag)
   178|      * @returns {String} Heading element
   179|      */
   180|     origin.heading = renderer.heading = function(text, level) {
   181|       let { str, config } = getAndRemoveConfig(text);
   182|       const nextToc = { level, title: removeAtag(str) };
   183|       if (/<!-- {docsify-ignore} -->/g.test(str)) {
   184|         str = str.replace('<!-- {docsify-ignore} -->', '');
   185|         nextToc.title = removeAtag(str);
   186|         nextToc.ignoreSubHeading = true;
   187|       }
   188|       if (/{docsify-ignore}/g.test(str)) {
   189|         str = str.replace('{docsify-ignore}', '');
   190|         nextToc.title = removeAtag(str);
   191|         nextToc.ignoreSubHeading = true;
   192|       }
   193|       if (/<!-- {docsify-ignore-all} -->/g.test(str)) {
   194|         str = str.replace('<!-- {docsify-ignore-all} -->', '');
   195|         nextToc.title = removeAtag(str);
   196|         nextToc.ignoreAllSubs = true;
   197|       }
   198|       if (/{docsify-ignore-all}/g.test(str)) {
   199|         str = str.replace('{docsify-ignore-all}', '');
   200|         nextToc.title = removeAtag(str);
   201|         nextToc.ignoreAllSubs = true;
   202|       }
   203|       const slug = slugify(config.id || str);
   204|       const url = router.toURL(router.getCurrentPath(), { id: slug });
   205|       nextToc.slug = url;
   206|       _self.toc.push(nextToc);
   207|       return `<h${level} id="${slug}"><a href="${url}" data-id="${slug}" class="anchor"><span>${str}</span></a></h${level}>`;
   208|     };
   209|     origin.code = highlightCodeCompiler({ renderer });
   210|     origin.link = linkCompiler({
   211|       renderer,
   212|       router,
   213|       linkTarget,
   214|       linkRel,
   215|       compilerClass: _self,
   216|     });
   217|     origin.paragraph = paragraphCompiler({ renderer });
   218|     origin.image = imageCompiler({ renderer, contentBase, router });
   219|     origin.list = taskListCompiler({ renderer });
   220|     origin.listitem = taskListItemCompiler({ renderer });

# --- HUNK 3: Lines 223-263 ---
   223|   }
   224|   /**
   225|    * Compile sidebar
   226|    * @param {String} text Text content
   227|    * @param {Number} level Type of heading (h<level> tag)
   228|    * @returns {String} Sidebar element
   229|    */
   230|   sidebar(text, level) {
   231|     const { toc } = this;
   232|     const currentPath = this.router.getCurrentPath();
   233|     let html = '';
   234|     if (text) {
   235|       html = this.compile(text);
   236|     } else {
   237|       for (let i = 0; i < toc.length; i++) {
   238|         if (toc[i].ignoreSubHeading) {
   239|           const deletedHeaderLevel = toc[i].level;
   240|           toc.splice(i, 1);
   241|           for (
   242|             let j = i;
   243|             j < toc.length && deletedHeaderLevel < toc[j].level;
   244|             j++
   245|           ) {
   246|             toc.splice(j, 1) && j-- && i++;
   247|           }
   248|           i--;
   249|         }
   250|       }
   251|       const tree = this.cacheTree[currentPath] || genTree(toc, level);
   252|       html = treeTpl(tree, '<ul>{inner}</ul>');
   253|       this.cacheTree[currentPath] = tree;
   254|     }
   255|     return html;
   256|   }
   257|   /**
   258|    * Compile sub sidebar
   259|    * @param {Number} level Type of heading (h<level> tag)
   260|    * @returns {String} Sub-sidebar element
   261|    */
   262|   subSidebar(level) {
   263|     if (!level) {


# ====================================================================
# FILE: src/core/render/compiler/code.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-12 ---
     1| import Prism from 'prismjs';
     2| import 'prismjs/components/prism-markup-templating';
     3| export const highlightCodeCompiler = ({ renderer }) =>
     4|   (renderer.code = function(code, lang = 'markup') {
     5|     const langOrMarkup = Prism.languages[lang] || Prism.languages.markup;
     6|     const text = Prism.highlight(
     7|       code.replace(/@DOCSIFY_QM@/g, '`'),
     8|       langOrMarkup,
     9|       lang
    10|     );
    11|     return `<pre v-pre data-lang="${lang}"><code class="lang-${lang}">${text}</code></pre>`;
    12|   });


# ====================================================================
# FILE: src/core/render/compiler/headline.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| import { getAndRemoveConfig, removeAtag } from '../utils';
     2| import { slugify } from './slugify';
     3| export const headingCompiler = ({ renderer, router, _self }) =>
     4|   (renderer.code = (text, level) => {
     5|     let { str, config } = getAndRemoveConfig(text);
     6|     const nextToc = { level, title: removeAtag(str) };
     7|     if (/<!-- {docsify-ignore} -->/g.test(str)) {
     8|       str = str.replace('<!-- {docsify-ignore} -->', '');
     9|       nextToc.title = removeAtag(str);
    10|       nextToc.ignoreSubHeading = true;
    11|     }
    12|     if (/{docsify-ignore}/g.test(str)) {
    13|       str = str.replace('{docsify-ignore}', '');
    14|       nextToc.title = removeAtag(str);
    15|       nextToc.ignoreSubHeading = true;
    16|     }
    17|     if (/<!-- {docsify-ignore-all} -->/g.test(str)) {
    18|       str = str.replace('<!-- {docsify-ignore-all} -->', '');
    19|       nextToc.title = removeAtag(str);
    20|       nextToc.ignoreAllSubs = true;
    21|     }
    22|     if (/{docsify-ignore-all}/g.test(str)) {
    23|       str = str.replace('{docsify-ignore-all}', '');
    24|       nextToc.title = removeAtag(str);
    25|       nextToc.ignoreAllSubs = true;
    26|     }
    27|     const slug = slugify(config.id || str);
    28|     const url = router.toURL(router.getCurrentPath(), { id: slug });
    29|     nextToc.slug = url;
    30|     _self.toc.push(nextToc);
    31|     return `<h${level} id="${slug}"><a href="${url}" data-id="${slug}" class="anchor"><span>${str}</span></a></h${level}>`;
    32|   });


# ====================================================================
# FILE: src/core/render/compiler/link.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 9-49 ---
     9| }) =>
    10|   (renderer.link = (href, title = '', text) => {
    11|     let attrs = [];
    12|     const { str, config } = getAndRemoveConfig(title);
    13|     linkTarget = config.target || linkTarget;
    14|     linkRel =
    15|       linkTarget === '_blank'
    16|         ? compilerClass.config.externalLinkRel || 'noopener'
    17|         : '';
    18|     title = str;
    19|     if (
    20|       !isAbsolutePath(href) &&
    21|       !compilerClass._matchNotCompileLink(href) &&
    22|       !config.ignore
    23|     ) {
    24|       if (href === compilerClass.config.homepage) {
    25|         href = 'README';
    26|       }
    27|       href = router.toURL(href, null, router.getCurrentPath());
    28|     } else {
    29|       if (!isAbsolutePath(href) && href.slice(0, 2) === './') {
    30|         href =
    31|           document.URL.replace(/\/(?!.*\/).*/, '/').replace('#/./', '') + href;
    32|       }
    33|       attrs.push(href.indexOf('mailto:') === 0 ? '' : `target="${linkTarget}"`);
    34|       attrs.push(
    35|         href.indexOf('mailto:') === 0
    36|           ? ''
    37|           : linkRel !== ''
    38|           ? ` rel="${linkRel}"`
    39|           : ''
    40|       );
    41|     }
    42|     if (
    43|       config.crossorgin &&
    44|       linkTarget === '_self' &&
    45|       compilerClass.config.routerMode === 'history'
    46|     ) {
    47|       if (compilerClass.config.crossOriginLinks.indexOf(href) === -1) {
    48|         compilerClass.config.crossOriginLinks.push(href);
    49|       }


# ====================================================================
# FILE: src/core/render/embed.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 3-43 ---
     3| import { merge } from '../util/core';
     4| const cached = {};
     5| function walkFetchEmbed({ embedTokens, compile, fetch }, cb) {
     6|   let token;
     7|   let step = 0;
     8|   let count = 1;
     9|   if (!embedTokens.length) {
    10|     return cb({});
    11|   }
    12|   while ((token = embedTokens[step++])) {
    13|     const next = (function(token) {
    14|       return text => {
    15|         let embedToken;
    16|         if (text) {
    17|           if (token.embed.type === 'markdown') {
    18|             let path = token.embed.url.split('/');
    19|             path.pop();
    20|             path = path.join('/');
    21|             text = text.replace(/\[([^[\]]+)\]\(([^)]+)\)/g, x => {
    22|               const linkBeginIndex = x.indexOf('(');
    23|               if (x.slice(linkBeginIndex, linkBeginIndex + 2) === '(.') {
    24|                 return (
    25|                   x.substring(0, linkBeginIndex) +
    26|                   `(${window.location.protocol}//${window.location.host}${path}/` +
    27|                   x.substring(linkBeginIndex + 1, x.length - 1) +
    28|                   ')'
    29|                 );
    30|               }
    31|               return x;
    32|             });
    33|             const frontMatterInstalled =
    34|               ($docsify.frontMatter || {}).installed || false;
    35|             if (frontMatterInstalled === true) {
    36|               text = $docsify.frontMatter.parseMarkdown(text);
    37|             }
    38|             embedToken = compile.lexer(text);
    39|           } else if (token.embed.type === 'code') {
    40|             if (token.embed.fragment) {
    41|               const fragment = token.embed.fragment;
    42|               const pattern = new RegExp(
    43|                 `(?:###|\\/\\/\\/)\\s*\\[${fragment}\\]([\\s\\S]*)(?:###|\\/\\/\\/)\\s*\\[${fragment}\\]`


# ====================================================================
# FILE: src/core/render/index.js
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-201 ---
     1| /* eslint-disable no-unused-vars */
     2| import tinydate from 'tinydate';
     3| import DOMPurify from 'dompurify';
     4| import * as dom from '../util/dom';
     5| import cssVars from '../util/polyfill/css-vars';
     6| import { callHook } from '../init/lifecycle';
     7| import { getAndActive, sticky } from '../event/sidebar';
     8| import { getPath, isAbsolutePath } from '../router/util';
     9| import { isMobile, inBrowser } from '../util/env';
    10| import { isPrimitive } from '../util/core';
    11| import { scrollActiveSidebar } from '../event/scroll';
    12| import { Compiler } from './compiler';
    13| import * as tpl from './tpl';
    14| import { prerenderEmbed } from './embed';
    15| let vueGlobalData;
    16| function executeScript() {
    17|   const script = dom
    18|     .findAll('.markdown-section>script')
    19|     .filter(s => !/template/.test(s.type))[0];
    20|   if (!script) {
    21|     return false;
    22|   }
    23|   const code = script.innerText.trim();
    24|   if (!code) {
    25|     return false;
    26|   }
    27|   new Function(code)();
    28| }
    29| function formatUpdated(html, updated, fn) {
    30|   updated =
    31|     typeof fn === 'function'
    32|       ? fn(updated)
    33|       : typeof fn === 'string'
    34|       ? tinydate(fn)(new Date(updated))
    35|       : updated;
    36|   return html.replace(/{docsify-updated}/g, updated);
    37| }
    38| function renderMain(html) {
    39|   const docsifyConfig = this.config;
    40|   const markdownElm = dom.find('.markdown-section');
    41|   const vueVersion =
    42|     'Vue' in window &&
    43|     window.Vue.version &&
    44|     Number(window.Vue.version.charAt(0));
    45|   const isMountedVue = elm => {
    46|     const isVue2 = Boolean(elm.__vue__ && elm.__vue__._isVue);
    47|     const isVue3 = Boolean(elm._vnode && elm._vnode.__v_skip);
    48|     return isVue2 || isVue3;
    49|   };
    50|   if (!html) {
    51|     html = '<h1>404 - Not found</h1>';
    52|   }
    53|   if ('Vue' in window) {
    54|     const mountedElms = dom
    55|       .findAll('.markdown-section > *')
    56|       .filter(elm => isMountedVue(elm));
    57|     for (const mountedElm of mountedElms) {
    58|       if (vueVersion === 2) {
    59|         mountedElm.__vue__.$destroy();
    60|       } else if (vueVersion === 3) {
    61|         mountedElm.__vue_app__.unmount();
    62|       }
    63|     }
    64|   }
    65|   this._renderTo(markdownElm, html);
    66|   !docsifyConfig.loadSidebar && this._renderSidebar();
    67|   if (
    68|     docsifyConfig.executeScript ||
    69|     ('Vue' in window && docsifyConfig.executeScript !== false)
    70|   ) {
    71|     executeScript();
    72|   }
    73|   if ('Vue' in window) {
    74|     const vueMountData = [];
    75|     const vueComponentNames = Object.keys(docsifyConfig.vueComponents || {});
    76|     if (vueVersion === 2 && vueComponentNames.length) {
    77|       vueComponentNames.forEach(name => {
    78|         const isNotRegistered = !window.Vue.options.components[name];
    79|         if (isNotRegistered) {
    80|           window.Vue.component(name, docsifyConfig.vueComponents[name]);
    81|         }
    82|       });
    83|     }
    84|     if (
    85|       !vueGlobalData &&
    86|       docsifyConfig.vueGlobalOptions &&
    87|       typeof docsifyConfig.vueGlobalOptions.data === 'function'
    88|     ) {
    89|       vueGlobalData = docsifyConfig.vueGlobalOptions.data();
    90|     }
    91|     vueMountData.push(
    92|       ...Object.entries(docsifyConfig.vueMounts || {})
    93|         .map(([cssSelector, vueConfig]) => [
    94|           dom.find(markdownElm, cssSelector),
    95|           vueConfig,
    96|         ])
    97|         .filter(([elm, vueConfig]) => elm)
    98|     );
    99|     if (docsifyConfig.vueGlobalOptions || vueComponentNames.length) {
   100|       const reHasBraces = /{{2}[^{}]*}{2}/;
   101|       const reHasDirective = /<[^>/]+\s([@:]|v-)[\w-:.[\]]+[=>\s]/;
   102|       vueMountData.push(
   103|         ...dom
   104|           .findAll('.markdown-section > *')
   105|           .filter(elm => !vueMountData.some(([e, c]) => e === elm))
   106|           .filter(elm => {
   107|             const isVueMount =
   108|               elm.tagName.toLowerCase() in
   109|                 (docsifyConfig.vueComponents || {}) ||
   110|               elm.querySelector(vueComponentNames.join(',') || null) ||
   111|               reHasBraces.test(elm.outerHTML) ||
   112|               reHasDirective.test(elm.outerHTML);
   113|             return isVueMount;
   114|           })
   115|           .map(elm => {
   116|             const vueConfig = Object.assign(
   117|               {},
   118|               docsifyConfig.vueGlobalOptions || {}
   119|             );
   120|             if (vueGlobalData) {
   121|               vueConfig.data = function() {
   122|                 return vueGlobalData;
   123|               };
   124|             }
   125|             return [elm, vueConfig];
   126|           })
   127|       );
   128|     }
   129|     for (const [mountElm, vueConfig] of vueMountData) {
   130|       const isVueAttr = 'data-isvue';
   131|       const isSkipElm =
   132|         mountElm.matches('pre, script') ||
   133|         isMountedVue(mountElm) ||
   134|         mountElm.querySelector(`[${isVueAttr}]`);
   135|       if (!isSkipElm) {
   136|         mountElm.setAttribute(isVueAttr, '');
   137|         if (vueVersion === 2) {
   138|           vueConfig.el = undefined;
   139|           new window.Vue(vueConfig).$mount(mountElm);
   140|         } else if (vueVersion === 3) {
   141|           const app = window.Vue.createApp(vueConfig);
   142|           vueComponentNames.forEach(name => {
   143|             const config = docsifyConfig.vueComponents[name];
   144|             app.component(name, config);
   145|           });
   146|           app.mount(mountElm);
   147|         }
   148|       }
   149|     }
   150|   }
   151| }
   152| function renderNameLink(vm) {
   153|   const el = dom.getNode('.app-name-link');
   154|   const nameLink = vm.config.nameLink;
   155|   const path = vm.route.path;
   156|   if (!el) {
   157|     return;
   158|   }
   159|   if (isPrimitive(vm.config.nameLink)) {
   160|     el.setAttribute('href', nameLink);
   161|   } else if (typeof nameLink === 'object') {
   162|     const match = Object.keys(nameLink).filter(
   163|       key => path.indexOf(key) > -1
   164|     )[0];
   165|     el.setAttribute('href', nameLink[match]);
   166|   }
   167| }
   168| export function renderMixin(proto) {
   169|   proto._renderTo = function(el, content, replace) {
   170|     const node = dom.getNode(el);
   171|     if (node) {
   172|       node[replace ? 'outerHTML' : 'innerHTML'] = content;
   173|     }
   174|   };
   175|   proto._renderSidebar = function(text) {
   176|     const { maxLevel, subMaxLevel, loadSidebar, hideSidebar } = this.config;
   177|     if (hideSidebar) {
   178|       [
   179|         document.querySelector('aside.sidebar'),
   180|         document.querySelector('button.sidebar-toggle'),
   181|       ].forEach(node => node.parentNode.removeChild(node));
   182|       document.querySelector('section.content').style.right = 'unset';
   183|       document.querySelector('section.content').style.left = 'unset';
   184|       document.querySelector('section.content').style.position = 'relative';
   185|       document.querySelector('section.content').style.width = '100%';
   186|       return null;
   187|     }
   188|     this._renderTo('.sidebar-nav', this.compiler.sidebar(text, maxLevel));
   189|     const activeEl = getAndActive(this.router, '.sidebar-nav', true, true);
   190|     if (loadSidebar && activeEl) {
   191|       activeEl.parentNode.innerHTML +=
   192|         this.compiler.subSidebar(subMaxLevel) || '';
   193|     } else {
   194|       this.compiler.subSidebar();
   195|     }
   196|     this._bindEventOnRendered(activeEl);
   197|   };
   198|   proto._bindEventOnRendered = function(activeEl) {
   199|     const { autoHeader } = this.config;
   200|     scrollActiveSidebar(this.router);
   201|     if (autoHeader && activeEl) {

# --- HUNK 2: Lines 207-265 ---
   207|         dom.before(main, wrapper.children[0]);
   208|       }
   209|     }
   210|   };
   211|   proto._renderNav = function(text) {
   212|     text && this._renderTo('nav', this.compiler.compile(text));
   213|     if (this.config.loadNavbar) {
   214|       getAndActive(this.router, 'nav');
   215|     }
   216|   };
   217|   proto._renderMain = function(text, opt = {}, next) {
   218|     if (!text) {
   219|       return renderMain.call(this, text);
   220|     }
   221|     callHook(this, 'beforeEach', text, result => {
   222|       let html;
   223|       const callback = () => {
   224|         if (opt.updatedAt) {
   225|           html = formatUpdated(html, opt.updatedAt, this.config.formatUpdated);
   226|         }
   227|         callHook(this, 'afterEach', html, hookData =>
   228|           renderMain.call(this, hookData)
   229|         );
   230|       };
   231|       if (this.isHTML) {
   232|         html = this.result = text;
   233|         callback();
   234|         next();
   235|       } else {
   236|         prerenderEmbed(
   237|           {
   238|             compiler: this.compiler,
   239|             raw: result,
   240|           },
   241|           tokens => {
   242|             html = this.compiler.compile(tokens);
   243|             html = this.isRemoteUrl
   244|               ? DOMPurify.sanitize(html, { ADD_TAGS: ['script'] })
   245|               : html;
   246|             callback();
   247|             next();
   248|           }
   249|         );
   250|       }
   251|     });
   252|   };
   253|   proto._renderCover = function(text, coverOnly) {
   254|     const el = dom.getNode('.cover');
   255|     dom.toggleClass(
   256|       dom.getNode('main'),
   257|       coverOnly ? 'add' : 'remove',
   258|       'hidden'
   259|     );
   260|     if (!text) {
   261|       dom.toggleClass(el, 'remove', 'show');
   262|       return;
   263|     }
   264|     dom.toggleClass(el, 'add', 'show');
   265|     let html = this.coverIsHTML ? text : this.compiler.cover(text);

# --- HUNK 3: Lines 275-315 ---
   275|         if (!isAbsolutePath(m[1])) {
   276|           path = getPath(this.router.getBasePath(), m[1]);
   277|         }
   278|         el.style.backgroundImage = `url(${path})`;
   279|         el.style.backgroundSize = 'cover';
   280|         el.style.backgroundPosition = 'center center';
   281|       }
   282|       html = html.replace(m[0], '');
   283|     }
   284|     this._renderTo('.cover-main', html);
   285|     sticky();
   286|   };
   287|   proto._updateRender = function() {
   288|     renderNameLink(this);
   289|   };
   290| }
   291| export function initRender(vm) {
   292|   const config = vm.config;
   293|   vm.compiler = new Compiler(config, vm.router);
   294|   if (inBrowser) {
   295|     /* eslint-disable-next-line camelcase */
   296|     window.__current_docsify_compiler__ = vm.compiler;
   297|   }
   298|   const id = config.el || '#app';
   299|   const navEl = dom.find('nav') || dom.create('nav');
   300|   const el = dom.find(id);
   301|   let html = '';
   302|   let navAppendToTarget = dom.body;
   303|   if (el) {
   304|     if (config.repo) {
   305|       html += tpl.corner(config.repo, config.cornerExternalLinkTarge);
   306|     }
   307|     if (config.coverpage) {
   308|       html += tpl.cover();
   309|     }
   310|     if (config.logo) {
   311|       const isBase64 = /^data:image/.test(config.logo);
   312|       const isExternal = /(?:http[s]?:)?\/\//.test(config.logo);
   313|       const isRelative = /^\./.test(config.logo);
   314|       if (!isBase64 && !isExternal && !isRelative) {
   315|         config.logo = getPath(vm.router.getBasePath(), config.logo);


# ====================================================================
# FILE: src/core/render/slugify.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| import { hasOwn } from '../util/core';
     2| let cache = {};
     3| const re = /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g;
     4| function lower(string) {
     5|   return string.toLowerCase();
     6| }
     7| export function slugify(str) {
     8|   if (typeof str !== 'string') {
     9|     return '';
    10|   }
    11|   let slug = str
    12|     .trim()
    13|     .replace(/[A-Z]+/g, lower)
    14|     .replace(/<[^>]+>/g, '')
    15|     .replace(re, '')
    16|     .replace(/\s/g, '-')
    17|     .replace(/-+/g, '-')
    18|     .replace(/^(\d)/, '_$1');
    19|   let count = cache[slug];
    20|   count = hasOwn.call(cache, slug) ? count + 1 : 0;
    21|   cache[slug] = count;
    22|   if (count) {
    23|     slug = slug + '-' + count;
    24|   }
    25|   return slug;
    26| }
    27| slugify.clear = function() {
    28|   cache = {};
    29| };


# ====================================================================
# FILE: src/core/render/tpl.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 64-97 ---
    64|     `hsl(${Math.floor(Math.random() * 255) + SL}) 100%)`;
    65|   return (
    66|     `<section class="cover show" style="background: ${bgc}">` +
    67|     '<div class="mask"></div>' +
    68|     '<div class="cover-main"><!--cover--></div>' +
    69|     '</section>'
    70|   );
    71| }
    72| /**
    73|  * Render tree
    74|  * @param  {Array} toc Array of TOC section links
    75|  * @param  {String} tpl TPL list
    76|  * @return {String} Rendered tree
    77|  */
    78| export function tree(toc, tpl = '<ul class="app-sub-sidebar">{inner}</ul>') {
    79|   if (!toc || !toc.length) {
    80|     return '';
    81|   }
    82|   let innerHTML = '';
    83|   toc.forEach(node => {
    84|     const title = node.title.replace(/(<([^>]+)>)/g, '');
    85|     innerHTML += `<li><a class="section-link" href="${node.slug}" title="${title}">${node.title}</a></li>`;
    86|     if (node.children) {
    87|       innerHTML += tree(node.children, tpl);
    88|     }
    89|   });
    90|   return tpl.replace('{inner}', innerHTML);
    91| }
    92| export function helper(className, content) {
    93|   return `<p class="${className}">${content.slice(5).trim()}</p>`;
    94| }
    95| export function theme(color) {
    96|   return `<style>:root{--theme-color: ${color};}</style>`;
    97| }


# ====================================================================
# FILE: src/core/render/utils.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 18-46 ---
    18|  *
    19|  * @return {object}  The original string and parsed object, { str, config }.
    20|  */
    21| export function getAndRemoveConfig(str = '') {
    22|   const config = {};
    23|   if (str) {
    24|     str = str
    25|       .replace(/^'/, '')
    26|       .replace(/'$/, '')
    27|       .replace(/(?:^|\s):([\w-]+:?)=?([\w-%]+)?/g, (m, key, value) => {
    28|         if (key.indexOf(':') === -1) {
    29|           config[key] = (value && value.replace(/&quot;/g, '')) || true;
    30|           return '';
    31|         }
    32|         return m;
    33|       })
    34|       .trim();
    35|   }
    36|   return { str, config };
    37| }
    38| /**
    39|  * Remove the <a> tag from sidebar when the header with link, details see issue 1069
    40|  * @param {string}   str   The string to deal with.
    41|  *
    42|  * @return {string}   str   The string after delete the <a> element.
    43|  */
    44| export function removeAtag(str = '') {
    45|   return str.replace(/(<\/?a.*?>)/gi, '');
    46| }


# ====================================================================
# FILE: src/core/router/history/hash.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| import { noop } from '../../util/core';
     2| import { on } from '../../util/dom';
     3| import { parseQuery, cleanPath, replaceSlug, endsWith } from '../util';
     4| import { History } from './base';
     5| function replaceHash(path) {
     6|   const i = location.href.indexOf('#');
     7|   location.replace(location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
     8| }
     9| export class HashHistory extends History {
    10|   constructor(config) {
    11|     super(config);
    12|     this.mode = 'hash';
    13|   }
    14|   getBasePath() {
    15|     const path = window.location.pathname || '';
    16|     const base = this.config.basePath;
    17|     const basePath = endsWith(path, '.html')
    18|       ? path + '#/' + base
    19|       : path + '/' + base;
    20|     return /^(\/|https?:)/g.test(base) ? base : cleanPath(basePath);
    21|   }
    22|   getCurrentPath() {
    23|     const href = location.href;
    24|     const index = href.indexOf('#');
    25|     return index === -1 ? '' : href.slice(index + 1);
    26|   }
    27|   onchange(cb = noop) {
    28|     let navigating = false;
    29|     on('click', e => {
    30|       const el = e.target.tagName === 'A' ? e.target : e.target.parentNode;
    31|       if (el && el.tagName === 'A' && !/_blank/.test(el.target)) {
    32|         navigating = true;
    33|       }
    34|     });
    35|     on('hashchange', e => {
    36|       const source = navigating ? 'navigate' : 'history';
    37|       navigating = false;
    38|       cb({ event: e, source });
    39|     });
    40|   }


# ====================================================================
# FILE: src/core/router/util.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 39-95 ---
    39|   }
    40|   const matchingParts = path.match(/(\S*\/)[^/]+$/);
    41|   return matchingParts ? matchingParts[1] : '';
    42| });
    43| export const cleanPath = cached(path => {
    44|   return path.replace(/^\/+/, '/').replace(/([^:])\/{2,}/g, '$1/');
    45| });
    46| export const resolvePath = cached(path => {
    47|   const segments = path.replace(/^\//, '').split('/');
    48|   let resolved = [];
    49|   for (let i = 0, len = segments.length; i < len; i++) {
    50|     const segment = segments[i];
    51|     if (segment === '..') {
    52|       resolved.pop();
    53|     } else if (segment !== '.') {
    54|       resolved.push(segment);
    55|     }
    56|   }
    57|   return '/' + resolved.join('/');
    58| });
    59| /**
    60|  * Normalises the URI path to handle the case where Docsify is
    61|  * hosted off explicit files, i.e. /index.html. This function
    62|  * eliminates any path segments that contain `#` fragments.
    63|  *
    64|  * This is used to map browser URIs to markdown file sources.
    65|  *
    66|  * For example:
    67|  *
    68|  * http://example.org/base/index.html#/blah
    69|  *
    70|  * would be mapped to:
    71|  *
    72|  * http://example.org/base/blah.md.
    73|  *
    74|  * See here for more information:
    75|  *
    76|  * https://github.com/docsifyjs/docsify/pull/1372
    77|  *
    78|  * @param {string} path The URI path to normalise
    79|  * @return {string} { path, query }
    80|  */
    81| function normaliseFragment(path) {
    82|   return path
    83|     .split('/')
    84|     .filter(p => p.indexOf('#') === -1)
    85|     .join('/');
    86| }
    87| export function getPath(...args) {
    88|   return cleanPath(args.map(normaliseFragment).join('/'));
    89| }
    90| export const replaceSlug = cached(path => {
    91|   return path.replace('#', '?id=');
    92| });
    93| export function endsWith(str, suffix) {
    94|   return str.indexOf(suffix, str.length - suffix.length) !== -1;
    95| }


# ====================================================================
# FILE: src/plugins/emoji.js
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| /* eslint-disable camelcase */
     2| const AllGithubEmoji = {
     3|   '100': 'unicode/1f4af',
     4|   '1234': 'unicode/1f522',
     5|   '+1': 'unicode/1f44d',
     6|   '-1': 'unicode/1f44e',
     7|   '1st_place_medal': 'unicode/1f947',
     8|   '2nd_place_medal': 'unicode/1f948',
     9|   '3rd_place_medal': 'unicode/1f949',
    10|   '8ball': 'unicode/1f3b1',
    11|   a: 'unicode/1f170',
    12|   ab: 'unicode/1f18e',
    13|   abacus: 'unicode/1f9ee',
    14|   abc: 'unicode/1f524',
    15|   abcd: 'unicode/1f521',
    16|   accept: 'unicode/1f251',
    17|   adhesive_bandage: 'unicode/1fa79',
    18|   adult: 'unicode/1f9d1',
    19|   aerial_tramway: 'unicode/1f6a1',
    20|   afghanistan: 'unicode/1f1e6-1f1eb',
    21|   airplane: 'unicode/2708',

# --- HUNK 2: Lines 1783-1812 ---
  1783|   yellow_circle: 'unicode/1f7e1',
  1784|   yellow_heart: 'unicode/1f49b',
  1785|   yellow_square: 'unicode/1f7e8',
  1786|   yemen: 'unicode/1f1fe-1f1ea',
  1787|   yen: 'unicode/1f4b4',
  1788|   yin_yang: 'unicode/262f',
  1789|   yo_yo: 'unicode/1fa80',
  1790|   yum: 'unicode/1f60b',
  1791|   zambia: 'unicode/1f1ff-1f1f2',
  1792|   zany_face: 'unicode/1f92a',
  1793|   zap: 'unicode/26a1',
  1794|   zebra: 'unicode/1f993',
  1795|   zero: 'unicode/0030-20e3',
  1796|   zimbabwe: 'unicode/1f1ff-1f1fc',
  1797|   zipper_mouth_face: 'unicode/1f910',
  1798|   zombie: 'unicode/1f9df',
  1799|   zombie_man: 'unicode/1f9df-2642',
  1800|   zombie_woman: 'unicode/1f9df-2640',
  1801|   zzz: 'unicode/1f4a4',
  1802| };
  1803| /* eslint-enable camelcase */
  1804| window.emojify = function(match, $1) {
  1805|   return AllGithubEmoji.hasOwnProperty($1) === false
  1806|     ? match
  1807|     : '<img class="emoji" src="https://github.githubassets.com/images/icons/emoji/' +
  1808|         AllGithubEmoji[$1] +
  1809|         '.png" alt="' +
  1810|         $1 +
  1811|         '" />';
  1812| };


# ====================================================================
# FILE: src/plugins/search/search.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 37-241 ---
    37|         path &&
    38|         paths.indexOf(path) === -1 &&
    39|         !Docsify.util.isAbsolutePath(originHref)
    40|       ) {
    41|         paths.push(path);
    42|       }
    43|     });
    44|   return paths;
    45| }
    46| function getTableData(token) {
    47|   if (!token.text && token.type === 'table') {
    48|     token.cells.unshift(token.header);
    49|     token.text = token.cells
    50|       .map(function(rows) {
    51|         return rows.join(' | ');
    52|       })
    53|       .join(' |\n ');
    54|   }
    55|   return token.text;
    56| }
    57| function getListData(token) {
    58|   if (!token.text && token.type === 'list') {
    59|     token.text = token.raw;
    60|   }
    61|   return token.text;
    62| }
    63| function saveData(maxAge, expireKey, indexKey) {
    64|   localStorage.setItem(expireKey, Date.now() + maxAge);
    65|   localStorage.setItem(indexKey, JSON.stringify(INDEXS));
    66| }
    67| export function genIndex(path, content = '', router, depth) {
    68|   const tokens = window.marked.lexer(content);
    69|   const slugify = window.Docsify.slugify;
    70|   const index = {};
    71|   let slug;
    72|   let title = '';
    73|   tokens.forEach(token => {
    74|     if (token.type === 'heading' && token.depth <= depth) {
    75|       const { str, config } = getAndRemoveConfig(token.text);
    76|       if (config.id) {
    77|         slug = router.toURL(path, { id: slugify(config.id) });
    78|       } else {
    79|         slug = router.toURL(path, { id: slugify(escapeHtml(token.text)) });
    80|       }
    81|       if (str) {
    82|         title = str
    83|           .replace(/<!-- {docsify-ignore} -->/, '')
    84|           .replace(/{docsify-ignore}/, '')
    85|           .replace(/<!-- {docsify-ignore-all} -->/, '')
    86|           .replace(/{docsify-ignore-all}/, '')
    87|           .trim();
    88|       }
    89|       index[slug] = { slug, title: title, body: '' };
    90|     } else {
    91|       if (!slug) {
    92|         return;
    93|       }
    94|       if (!index[slug]) {
    95|         index[slug] = { slug, title: '', body: '' };
    96|       } else if (index[slug].body) {
    97|         token.text = getTableData(token);
    98|         token.text = getListData(token);
    99|         index[slug].body += '\n' + (token.text || '');
   100|       } else {
   101|         token.text = getTableData(token);
   102|         token.text = getListData(token);
   103|         index[slug].body = index[slug].body
   104|           ? index[slug].body + token.text
   105|           : token.text;
   106|       }
   107|     }
   108|   });
   109|   slugify.clear();
   110|   return index;
   111| }
   112| export function ignoreDiacriticalMarks(keyword) {
   113|   if (keyword && keyword.normalize) {
   114|     return keyword.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
   115|   }
   116|   return keyword;
   117| }
   118| /**
   119|  * @param {String} query Search query
   120|  * @returns {Array} Array of results
   121|  */
   122| export function search(query) {
   123|   const matchingResults = [];
   124|   let data = [];
   125|   Object.keys(INDEXS).forEach(key => {
   126|     data = data.concat(Object.keys(INDEXS[key]).map(page => INDEXS[key][page]));
   127|   });
   128|   query = query.trim();
   129|   let keywords = query.split(/[\s\-\\/]+/);
   130|   if (keywords.length !== 1) {
   131|     keywords = [].concat(query, keywords);
   132|   }
   133|   for (let i = 0; i < data.length; i++) {
   134|     const post = data[i];
   135|     let matchesScore = 0;
   136|     let resultStr = '';
   137|     let handlePostTitle = '';
   138|     let handlePostContent = '';
   139|     const postTitle = post.title && post.title.trim();
   140|     const postContent = post.body && post.body.trim();
   141|     const postUrl = post.slug || '';
   142|     if (postTitle) {
   143|       keywords.forEach(keyword => {
   144|         const regEx = new RegExp(
   145|           ignoreDiacriticalMarks(keyword).replace(
   146|             /[|\\{}()[\]^$+*?.]/g,
   147|             '\\$&'
   148|           ),
   149|           'gi'
   150|         );
   151|         let indexTitle = -1;
   152|         let indexContent = -1;
   153|         handlePostTitle = postTitle
   154|           ? ignoreDiacriticalMarks(postTitle)
   155|           : postTitle;
   156|         handlePostContent = postContent
   157|           ? ignoreDiacriticalMarks(postContent)
   158|           : postContent;
   159|         indexTitle = postTitle ? handlePostTitle.search(regEx) : -1;
   160|         indexContent = postContent ? handlePostContent.search(regEx) : -1;
   161|         if (indexTitle >= 0 || indexContent >= 0) {
   162|           matchesScore += indexTitle >= 0 ? 3 : indexContent >= 0 ? 2 : 0;
   163|           if (indexContent < 0) {
   164|             indexContent = 0;
   165|           }
   166|           let start = 0;
   167|           let end = 0;
   168|           start = indexContent < 11 ? 0 : indexContent - 10;
   169|           end = start === 0 ? 70 : indexContent + keyword.length + 60;
   170|           if (postContent && end > postContent.length) {
   171|             end = postContent.length;
   172|           }
   173|           const matchContent =
   174|             '...' +
   175|             handlePostContent
   176|               .substring(start, end)
   177|               .replace(
   178|                 regEx,
   179|                 word => `<em class="search-keyword">${word}</em>`
   180|               ) +
   181|             '...';
   182|           resultStr += matchContent;
   183|         }
   184|       });
   185|       if (matchesScore > 0) {
   186|         const matchingPost = {
   187|           title: handlePostTitle,
   188|           content: postContent ? resultStr : '',
   189|           url: postUrl,
   190|           score: matchesScore,
   191|         };
   192|         matchingResults.push(matchingPost);
   193|       }
   194|     }
   195|   }
   196|   return matchingResults.sort((r1, r2) => r2.score - r1.score);
   197| }
   198| export function init(config, vm) {
   199|   const isAuto = config.paths === 'auto';
   200|   const paths = isAuto ? getAllPaths(vm.router) : config.paths;
   201|   let namespaceSuffix = '';
   202|   if (paths.length && isAuto && config.pathNamespaces) {
   203|     const path = paths[0];
   204|     if (Array.isArray(config.pathNamespaces)) {
   205|       namespaceSuffix =
   206|         config.pathNamespaces.filter(
   207|           prefix => path.slice(0, prefix.length) === prefix
   208|         )[0] || namespaceSuffix;
   209|     } else if (config.pathNamespaces instanceof RegExp) {
   210|       const matches = path.match(config.pathNamespaces);
   211|       if (matches) {
   212|         namespaceSuffix = matches[0];
   213|       }
   214|     }
   215|     const isExistHome = paths.indexOf(namespaceSuffix + '/') === -1;
   216|     const isExistReadme = paths.indexOf(namespaceSuffix + '/README') === -1;
   217|     if (isExistHome && isExistReadme) {
   218|       paths.unshift(namespaceSuffix + '/');
   219|     }
   220|   } else if (paths.indexOf('/') === -1 && paths.indexOf('/README') === -1) {
   221|     paths.unshift('/');
   222|   }
   223|   const expireKey = resolveExpireKey(config.namespace) + namespaceSuffix;
   224|   const indexKey = resolveIndexKey(config.namespace) + namespaceSuffix;
   225|   const isExpired = localStorage.getItem(expireKey) < Date.now();
   226|   INDEXS = JSON.parse(localStorage.getItem(indexKey));
   227|   if (isExpired) {
   228|     INDEXS = {};
   229|   } else if (!isAuto) {
   230|     return;
   231|   }
   232|   const len = paths.length;
   233|   let count = 0;
   234|   paths.forEach(path => {
   235|     if (INDEXS[path]) {
   236|       return count++;
   237|     }
   238|     Docsify.get(vm.router.getFile(path), false, vm.config.requestHeaders).then(
   239|       result => {
   240|         INDEXS[path] = genIndex(path, result, vm.router, config.depth);
   241|         len === ++count && saveData(config.maxAge, expireKey, indexKey);

