--- a/babel.config.js
+++ b//dev/null
@@ -1,12 +0,0 @@
-module.exports = {
-  presets: [
-    [
-      '@babel/preset-env',
-      {
-        targets: {
-          node: 'current',
-        },
-      },
-    ],
-  ],
-};

--- a//dev/null
+++ b/cypress/integration/routing/fallback.spec.js
@@ -0,0 +1,7 @@
+context('config.fallbackLanguages', () => {
+  it('fallbacks respecting aliases', () => {
+    cy.visit('http://localhost:3000/#/es/');
+    cy.get('.sidebar-nav').contains('Changelog').click();
+    cy.get('#main').should('contain', 'Bug Fixes');
+  })
+});

--- a//dev/null
+++ b/cypress/integration/sidebar/config.spec.js
@@ -0,0 +1,290 @@
+context('sidebar.configurations', () => {
+  beforeEach(() => {
+    cy.visit('http://localhost:3000');
+  });
+  const quickStartIds = [
+    'initialize',
+    'writing-content',
+    'preview-your-site',
+    'manual-initialization',
+    'loading-dialog',
+  ];
+  quickStartIds.forEach(id => {
+    it('go to #quickstart?id=' + id, () => {
+      cy.get(
+        '.sidebar-nav > :nth-child(1) > :nth-child(1) > ul > :nth-child(1) > a'
+      ).click();
+      cy.get(`a.section-link[href='#/quickstart?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const configurationIds = [
+    'el',
+    'repo',
+    'maxlevel',
+    'loadnavbar',
+    'loadsidebar',
+    'hidesidebar',
+    'submaxlevel',
+    'auto2top',
+    'homepage',
+    'basepath',
+    'relativepath',
+    'coverpage',
+    'logo',
+    'name',
+    'namelink',
+    'markdown',
+    'themecolor',
+    'alias',
+    'autoheader',
+    'executescript',
+    'noemoji',
+    'mergenavbar',
+    'formatupdated',
+    'externallinktarget',
+    'cornerexternallinktarget',
+    'externallinkrel',
+    'routermode',
+    'nocompilelinks',
+    'onlycover',
+    'requestheaders',
+    'ext',
+    'fallbacklanguages',
+    'notfoundpage',
+  ];
+  configurationIds.forEach(id => {
+    it('go to #configuration?id=' + id, () => {
+      cy.get('[href="#/configuration"]').click();
+      cy.get(`a.section-link[href='#/configuration?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500); // its more far from the cover
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const morePagesIds = [
+    'sidebar',
+    'nested-sidebars',
+    'set-page-titles-from-sidebar-selection',
+    'table-of-contents',
+    'ignoring-subheaders',
+  ];
+  morePagesIds.forEach(id => {
+    it('go to #more-pages?id=' + id, () => {
+      cy.get('[href="#/more-pages"]').click();
+      cy.get(`a.section-link[href='#/more-pages?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const customNavbarIds = [
+    'html',
+    'markdown',
+    'nesting',
+    'combining-custom-navbars-with-the-emoji-plugin',
+  ];
+  customNavbarIds.forEach(id => {
+    it('go to #custom-navbar?id=' + id, () => {
+      cy.get('[href="#/custom-navbar"]').click();
+      cy.get(`a.section-link[href='#/custom-navbar?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const coverIds = [
+    'basic-usage',
+    'custom-background',
+    'coverpage-as-homepage',
+    'multiple-covers',
+  ];
+  coverIds.forEach(id => {
+    it('go to #cover?id=' + id, () => {
+      cy.get('[href="#/cover"]').click();
+      cy.get(`a.section-link[href='#/cover?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const themesIds = ['other-themes'];
+  themesIds.forEach(id => {
+    it('go to #themes?id=' + id, () => {
+      cy.get('[href="#/themes"]').click();
+      cy.get(`a.section-link[href='#/themes?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const pluginsIds = [
+    'full-text-search',
+    'google-analytics',
+    'emoji',
+    'external-script',
+    'zoom-image',
+    'edit-on-github',
+    'demo-code-with-instant-preview-and-jsfiddle-integration',
+    'copy-to-clipboard',
+    'disqus',
+    'gitalk',
+    'pagination',
+    'tabs',
+    'more-plugins',
+  ];
+  pluginsIds.forEach(id => {
+    it('go to #plugins?id=' + id, () => {
+      cy.get('[href="#/plugins"]').click();
+      cy.get(`a.section-link[href='#/plugins?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const writeAPluginIds = ['full-configuration', 'example', 'tips'];
+  writeAPluginIds.forEach(id => {
+    it('go to #write-a-plugin?id=' + id, () => {
+      cy.get('[href="#/write-a-plugin"]').click();
+      cy.get(`a.section-link[href='#/write-a-plugin?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const markdownIds = ['supports-mermaid'];
+  markdownIds.forEach(id => {
+    it('go to #markdown?id=' + id, () => {
+      cy.get('[href="#/markdown"]').click();
+      cy.get(`a.section-link[href='#/markdown?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  it('go to #Language-highlight', () => {
+    cy.get('a[href="#/language-highlight"]')
+      .click()
+      .then(() => {
+        cy.wait(500);
+        cy.matchImageSnapshot();
+      });
+  });
+  const helpersIds = [
+    'important-content',
+    'general-tips',
+    'ignore-to-compile-link',
+    'set-target-attribute-for-link',
+    'disable-link',
+    'github-task-lists',
+    'customise-id-for-headings',
+    'markdown-in-html-tag',
+  ];
+  helpersIds.forEach(id => {
+    it('go to #helpers?id=' + id, () => {
+      cy.get('[href="#/helpers"]').click();
+      cy.get(`a.section-link[href='#/helpers?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const vueIds = ['basic-usage', 'combine-vuep-to-write-playground'];
+  vueIds.forEach(id => {
+    it('go to #vue?id=' + id, () => {
+      cy.get('[href="#/vue"]').click();
+      cy.get(`a.section-link[href='#/vue?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const cdnIds = [
+    'latest-version',
+    'specific-version',
+    'compressed-file',
+    'other-cdn',
+  ];
+  cdnIds.forEach(id => {
+    it('go to #cdn?id=' + id, () => {
+      cy.get('[href="#/cdn"]').click();
+      cy.get(`a.section-link[href='#/cdn?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const pwaIds = ['create-serviceworker', 'register', 'enjoy-it'];
+  pwaIds.forEach(id => {
+    it('go to #pwa?id=' + id, () => {
+      cy.get('[href="#/pwa"]').click();
+      cy.get(`a.section-link[href='#/pwa?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const ssrIds = [
+    'why-ssr',
+    'quick-start',
+    'custom-template',
+    'configuration',
+    'deploy-for-your-vps',
+  ];
+  ssrIds.forEach(id => {
+    it('go to #ssr?id=' + id, () => {
+      cy.get('[href="#/ssr"]').click();
+      cy.get(`a.section-link[href='#/ssr?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+  const embedFilesIds = [
+    'embedded-file-type',
+    'embedded-code-fragments',
+    'tag-attribute',
+    'the-code-block-highlight',
+  ];
+  embedFilesIds.forEach(id => {
+    it('go to #embed-files?id=' + id, () => {
+      cy.get('[href="#/embed-files"]').click();
+      cy.get(`a.section-link[href='#/embed-files?id=${id}']`)
+        .click()
+        .then(() => {
+          cy.wait(500);
+          cy.matchImageSnapshot();
+        });
+    });
+  });
+});

--- a//dev/null
+++ b/cypress/live.server.js
@@ -0,0 +1,11 @@
+const path = require('path')
+const LiveServer = require('live-server')
+const fixturePath = path.join(__dirname, './fixtures/docs')
+const args = process.argv.slice(2)
+console.log('[e2e tests] : args passed to live server', args)
+const params = {
+  port: args[0] || 3000,
+  root: args[1] || fixturePath,
+  open: false
+}
+LiveServer.start(params)

--- a//dev/null
+++ b/cypress/plugins/index.js
@@ -0,0 +1,4 @@
+const { addMatchImageSnapshotPlugin } = require('cypress-image-snapshot/plugin')
+module.exports = (on, config) => {
+  addMatchImageSnapshotPlugin(on, config)
+}

--- a//dev/null
+++ b/cypress/setup.js
@@ -0,0 +1,58 @@
+const copyDir = require('copy-dir')
+const path = require('path')
+const fs = require('fs')
+const { spawn } = require('child_process')
+const setup = async () => {
+  const PORT = process.env.PORT || 3000
+  global.__LIVESERVER__ = null
+  global.PORT = PORT
+  /**
+   * IN this test suite, we are going to test our docs site with all the css,js linked to our local build packages
+   *
+   *  1.1 Copy ../docs --> ./fixtures/docs
+   *  1.2 copy lib,themes --> ./fixtures/
+   *  2. change the content of fixtures/docs/index.html to use all the links from our local build
+   *  3. now jest runner will run to test all the *.spec.js files
+   *
+   */
+  const shippedDirs = ['lib', 'themes']
+  const docsPath = path.join(process.cwd(), './docs')
+  const fixtureDocsPath = path.join(__dirname, './fixtures/docs')
+  console.log('[cypress test docs] Copying the docs --> cypress/fixtures/docs')
+  copyDir.sync(docsPath, fixtureDocsPath)
+  shippedDirs.forEach(dir => {
+    const fromPath = path.join(process.cwd(), dir)
+    const toPath = path.join(__dirname, `./fixtures/docs/${dir}`)
+    console.log(
+      `[cypress test docs] Copying  ${dir} --> cypress/fixtures/docs/${dir}`
+    )
+    copyDir.sync(fromPath, toPath)
+  })
+  console.log(
+    '[cypress test docs] Replacing content the tpl/index.html --> cypress/fixtures/docs/index.html'
+  )
+  const indexHTMLtplPath = path.join(
+    __dirname,
+    './fixtures/tpl/docs.index.html'
+  )
+  const fixtureIndexPath = path.join(__dirname, './fixtures/docs/index.html')
+  const data = fs.readFileSync(indexHTMLtplPath, 'utf8')
+  const fixturePath = path.join(__dirname, './fixtures/docs')
+  fs.writeFileSync(fixtureIndexPath, data, 'utf8')
+  const child = spawn('node', [
+    path.join(__dirname, './live.server.js'),
+    PORT,
+    fixturePath
+  ])
+  child.on('exit', code => {
+    console.log(`Child process exited with code ${code}`)
+  })
+  child.stdout.on('data', data => {
+    console.log(`stdout: ${data}`)
+  })
+  child.stderr.on('data', data => {
+    console.log(`stderr: ${data}`)
+  })
+  global.__LIVESERVER__ = child
+}
+setup()

--- a//dev/null
+++ b/cypress/support/commands.js
@@ -0,0 +1,15 @@
+import { addMatchImageSnapshotCommand } from 'cypress-image-snapshot/command'
+addMatchImageSnapshotCommand({
+  failureThreshold: 10.0,
+  failureThresholdType: 'percent',
+  customDiffConfig: { threshold: 10.0 },
+  capture: 'viewport',
+  timeout: '60000'
+})
+Cypress.Commands.add('setResolution', size => {
+  if (Cypress._.isArray(size)) {
+    cy.viewport(size[0], size[1])
+  } else {
+    cy.viewport(size)
+  }
+})

--- a//dev/null
+++ b/cypress/support/index.js
@@ -0,0 +1 @@
+import './commands'

--- a/jest.config.js
+++ b//dev/null
@@ -1,50 +0,0 @@
-const { TEST_HOST } = require('./test/config/server.js');
-const sharedConfig = {
-  errorOnDeprecated: true,
-  globals: {
-    TEST_HOST,
-  },
-  globalSetup: './test/config/jest.setup.js',
-  globalTeardown: './test/config/jest.teardown.js',
-  resetModules: true,
-  restoreMocks: true,
-};
-module.exports = {
-  globals: sharedConfig.globals,
-  projects: [
-    {
-      ...sharedConfig,
-      displayName: 'unit',
-      setupFilesAfterEnv: ['<rootDir>/test/config/jest.setup-tests.js'],
-      testMatch: ['<rootDir>/test/unit/*.test.js'],
-      testURL: `${TEST_HOST}/_blank.html`,
-    },
-    {
-      ...sharedConfig,
-      displayName: 'integration',
-      setupFilesAfterEnv: ['<rootDir>/test/config/jest.setup-tests.js'],
-      testMatch: ['<rootDir>/test/integration/*.test.js'],
-      testURL: `${TEST_HOST}/_blank.html`,
-    },
-    {
-      ...sharedConfig,
-      displayName: 'e2e',
-      preset: 'jest-playwright-preset',
-      setupFilesAfterEnv: [
-        '<rootDir>/test/config/jest-playwright.setup-tests.js',
-      ],
-      testEnvironmentOptions: {
-        'jest-playwright': {
-          browsers: [
-            'chromium',
-            'firefox',
-            'webkit',
-          ],
-          launchOptions: {
-          },
-        },
-      },
-      testMatch: ['<rootDir>/test/e2e/*.test.js'],
-    },
-  ],
-};

--- a/packages/docsify-server-renderer/index.js
+++ b/packages/docsify-server-renderer/index.js
@@ -7,21 +7,21 @@
 import { AbstractHistory } from '../../src/core/router/history/abstract';
 import { Compiler } from '../../src/core/render/compiler';
 import { isAbsolutePath } from '../../src/core/router/util';
 import * as tpl from '../../src/core/render/tpl';
 import { prerenderEmbed } from '../../src/core/render/embed';
 function cwd(...args) {
   return resolve(process.cwd(), ...args);
 }
 function isExternal(url) {
   let match = url.match(
-    /^([^:/?#]+:)?(?:\/\/([^/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
+    /^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
   );
   if (
     typeof match[1] === 'string' &&
     match[1].length > 0 &&
     match[1].toLowerCase() !== location.protocol
   ) {
     return true;
   }
   if (
     typeof match[2] === 'string' &&
@@ -95,23 +95,21 @@
         }
       } else if (Array.isArray(coverpage)) {
         path = coverpage.indexOf(url) > -1 && '_coverpage.md';
       } else {
         const cover = coverpage[url];
         path = cover === true ? '_coverpage.md' : cover;
       }
       const coverFile = this._getPath(resolve(url, `./${path}`));
       this._renderHtml('cover', await this._render(coverFile), 'cover');
     }
-    const html = this.isRemoteUrl
-      ? DOMPurify.sanitize(this.html, { ADD_TAGS: ['script'] })
-      : this.html;
+    const html = this.isRemoteUrl ? DOMPurify.sanitize(this.html) : this.html;
     this.html = this.template;
     return html;
   }
   _renderHtml(match, content) {
     this.html = this.html.replace(new RegExp(`<!--${match}-->`, 'g'), content);
     return this.html;
   }
   async _render(path, type) {
     let html = await this._loadFile(path);
     const { subMaxLevel, maxLevel } = this.config;

--- a/src/core/event/scroll.js
+++ b/src/core/event/scroll.js
@@ -8,22 +8,21 @@
 let scroller = null;
 let enableScrollEvent = true;
 let coverHeight = 0;
 function scrollTo(el, offset = 0) {
   if (scroller) {
     scroller.stop();
   }
   enableScrollEvent = false;
   scroller = new Tweezer({
     start: window.pageYOffset,
-    end:
-      Math.round(el.getBoundingClientRect().top) + window.pageYOffset - offset,
+    end: el.getBoundingClientRect().top + window.pageYOffset - offset,
     duration: 500,
   })
     .on('tick', v => window.scrollTo(0, v))
     .on('done', () => {
       enableScrollEvent = true;
       scroller = null;
     })
     .begin();
 }
 function highlight(path) {

--- a/src/core/event/sidebar.js
+++ b/src/core/event/sidebar.js
@@ -64,23 +64,23 @@
   el = dom.getNode(el);
   let links = [];
   if (el !== null && el !== undefined) {
     links = dom.findAll(el, 'a');
   }
   const hash = decodeURI(router.toURL(router.getCurrentPath()));
   let target;
   links
     .sort((a, b) => b.href.length - a.href.length)
     .forEach(a => {
-      const href = decodeURI(a.getAttribute('href'));
+      const href = a.getAttribute('href');
       const node = isParent ? a.parentNode : a;
-      a.title = a.title || a.innerText;
+      a.title = a.innerText;
       if (hash.indexOf(href) === 0 && !target) {
         target = a;
         dom.toggleClass(node, 'add', 'active');
       } else {
         dom.toggleClass(node, 'remove', 'active');
       }
     });
   if (autoTitle) {
     dom.$.title = target
       ? target.title || `${target.innerText} - ${title}`

--- a/src/core/fetch/index.js
+++ b/src/core/fetch/index.js
@@ -11,21 +11,21 @@
     return;
   }
   get(
     vm.router.getFile(path + file) + qs,
     false,
     vm.config.requestHeaders
   ).then(next, _ => loadNested(path, qs, file, next, vm));
 }
 function isExternal(url) {
   let match = url.match(
-    /^([^:/?#]+:)?(?:\/\/([^/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
+    /^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/
   );
   if (
     typeof match[1] === 'string' &&
     match[1].length > 0 &&
     match[1].toLowerCase() !== location.protocol
   ) {
     return true;
   }
   if (
     typeof match[2] === 'string' &&
@@ -57,74 +57,68 @@
     switch (typeof notFoundPage) {
       case 'boolean':
         path404 = defaultPath;
         break;
       case 'string':
         path404 = notFoundPage;
         break;
       case 'object':
         key = Object.keys(notFoundPage)
           .sort((a, b) => b.length - a.length)
-          .filter(k => path.match(new RegExp('^' + k)))[0];
+          .find(key => path.match(new RegExp('^' + key)));
         path404 = (key && notFoundPage[key]) || defaultPath;
         break;
       default:
         break;
     }
     return path404;
   };
   proto._loadSideAndNav = function(path, qs, loadSidebar, cb) {
     return () => {
       if (!loadSidebar) {
         return cb();
       }
       const fn = result => {
         this._renderSidebar(result);
         cb();
       };
       loadNested(path, qs, loadSidebar, fn, this, true);
     };
   };
   proto._fetch = function(cb = noop) {
-    const { query } = this.route;
-    let { path } = this.route;
-    if (isExternal(path)) {
-      history.replaceState(null, '', '#');
-      this.router.normalize();
-    } else {
-      const qs = stringifyQuery(query, ['id']);
-      const { loadNavbar, requestHeaders, loadSidebar } = this.config;
-      const file = this.router.getFile(path);
-      const req = request(file + qs, true, requestHeaders);
-      this.isRemoteUrl = isExternal(file);
-      this.isHTML = /\.html$/g.test(file);
-      req.then(
-        (text, opt) =>
-          this._renderMain(
-            text,
-            opt,
-            this._loadSideAndNav(path, qs, loadSidebar, cb)
-          ),
-        _ => {
-          this._fetchFallbackPage(path, qs, cb) || this._fetch404(file, qs, cb);
-        }
+    const { path, query } = this.route;
+    const qs = stringifyQuery(query, ['id']);
+    const { loadNavbar, requestHeaders, loadSidebar } = this.config;
+    const file = this.router.getFile(path);
+    const req = request(file + qs, true, requestHeaders);
+    this.isRemoteUrl = isExternal(file);
+    this.isHTML = /\.html$/g.test(file);
+    req.then(
+      (text, opt) =>
+        this._renderMain(
+          text,
+          opt,
+          this._loadSideAndNav(path, qs, loadSidebar, cb)
+        ),
+      _ => {
+        this._fetchFallbackPage(path, qs, cb) || this._fetch404(file, qs, cb);
+      }
+    );
+    loadNavbar &&
+      loadNested(
+        path,
+        qs,
+        loadNavbar,
+        text => this._renderNav(text),
+        this,
+        true
       );
-      loadNavbar &&
-        loadNested(
-          path,
-          qs,
-          loadNavbar,
-          text => this._renderNav(text),
-          this,
-          true
-        );
-    }
   };
   proto._fetchCover = function() {
     const { coverpage, requestHeaders } = this.config;
     const query = this.route.query;
     const root = getParentPath(this.route.path);
     if (coverpage) {
       let path = null;
       const routePath = this.route.path;
       if (typeof coverpage === 'string') {
         if (routePath === '/') {

--- a/src/core/init/lifecycle.js
+++ b/src/core/init/lifecycle.js
@@ -8,33 +8,33 @@
     'doneEach',
     'ready',
   ];
   vm._hooks = {};
   vm._lifecycle = {};
   hooks.forEach(hook => {
     const arr = (vm._hooks[hook] = []);
     vm._lifecycle[hook] = fn => arr.push(fn);
   });
 }
-export function callHook(vm, hookName, data, next = noop) {
-  const queue = vm._hooks[hookName];
+export function callHook(vm, hook, data, next = noop) {
+  const queue = vm._hooks[hook];
   const step = function(index) {
-    const hookFn = queue[index];
+    const hook = queue[index];
     if (index >= queue.length) {
       next(data);
-    } else if (typeof hookFn === 'function') {
-      if (hookFn.length === 2) {
-        hookFn(data, result => {
+    } else if (typeof hook === 'function') {
+      if (hook.length === 2) {
+        hook(data, result => {
           data = result;
           step(index + 1);
         });
       } else {
-        const result = hookFn(data);
+        const result = hook(data);
         data = result === undefined ? data : result;
         step(index + 1);
       }
     } else {
       step(index + 1);
     }
   };
   step(0);
 }

--- a/src/core/render/compiler.js
+++ b/src/core/render/compiler.js
@@ -1,18 +1,18 @@
 import marked from 'marked';
 import { isAbsolutePath, getPath, getParentPath } from '../router/util';
 import { isFn, merge, cached, isPrimitive } from '../util/core';
 import { tree as treeTpl } from './tpl';
 import { genTree } from './gen-tree';
 import { slugify } from './slugify';
 import { emojify } from './emojify';
-import { getAndRemoveConfig, removeAtag } from './utils';
+import { getAndRemoveConfig } from './utils';
 import { imageCompiler } from './compiler/image';
 import { highlightCodeCompiler } from './compiler/code';
 import { paragraphCompiler } from './compiler/paragraph';
 import { taskListCompiler } from './compiler/taskList';
 import { taskListItemCompiler } from './compiler/taskListItem';
 import { linkCompiler } from './compiler/link';
 const cachedLinks = {};
 const compileMedia = {
   markdown(url) {
     return {
@@ -172,39 +172,39 @@
     const origin = {};
     /**
      * Render anchor tag
      * @link https://github.com/markedjs/marked#overriding-renderer-methods
      * @param {String} text Text content
      * @param {Number} level Type of heading (h<level> tag)
      * @returns {String} Heading element
      */
     origin.heading = renderer.heading = function(text, level) {
       let { str, config } = getAndRemoveConfig(text);
-      const nextToc = { level, title: removeAtag(str) };
+      const nextToc = { level, title: str };
       if (/<!-- {docsify-ignore} -->/g.test(str)) {
         str = str.replace('<!-- {docsify-ignore} -->', '');
-        nextToc.title = removeAtag(str);
+        nextToc.title = str;
         nextToc.ignoreSubHeading = true;
       }
       if (/{docsify-ignore}/g.test(str)) {
         str = str.replace('{docsify-ignore}', '');
-        nextToc.title = removeAtag(str);
+        nextToc.title = str;
         nextToc.ignoreSubHeading = true;
       }
       if (/<!-- {docsify-ignore-all} -->/g.test(str)) {
         str = str.replace('<!-- {docsify-ignore-all} -->', '');
-        nextToc.title = removeAtag(str);
+        nextToc.title = str;
         nextToc.ignoreAllSubs = true;
       }
       if (/{docsify-ignore-all}/g.test(str)) {
         str = str.replace('{docsify-ignore-all}', '');
-        nextToc.title = removeAtag(str);
+        nextToc.title = str;
         nextToc.ignoreAllSubs = true;
       }
       const slug = slugify(config.id || str);
       const url = router.toURL(router.getCurrentPath(), { id: slug });
       nextToc.slug = url;
       _self.toc.push(nextToc);
       return `<h${level} id="${slug}"><a href="${url}" data-id="${slug}" class="anchor"><span>${str}</span></a></h${level}>`;
     };
     origin.code = highlightCodeCompiler({ renderer });
     origin.link = linkCompiler({
@@ -233,21 +233,21 @@
     let html = '';
     if (text) {
       html = this.compile(text);
     } else {
       for (let i = 0; i < toc.length; i++) {
         if (toc[i].ignoreSubHeading) {
           const deletedHeaderLevel = toc[i].level;
           toc.splice(i, 1);
           for (
             let j = i;
-            j < toc.length && deletedHeaderLevel < toc[j].level;
+            deletedHeaderLevel < toc[j].level && j < toc.length;
             j++
           ) {
             toc.splice(j, 1) && j-- && i++;
           }
           i--;
         }
       }
       const tree = this.cacheTree[currentPath] || genTree(toc, level);
       html = treeTpl(tree, '<ul>{inner}</ul>');
       this.cacheTree[currentPath] = tree;

--- a/src/core/render/compiler/code.js
+++ b/src/core/render/compiler/code.js
@@ -1,12 +1,11 @@
 import Prism from 'prismjs';
 import 'prismjs/components/prism-markup-templating';
 export const highlightCodeCompiler = ({ renderer }) =>
-  (renderer.code = function(code, lang = 'markup') {
+  (renderer.code = function(code, lang = '') {
     const langOrMarkup = Prism.languages[lang] || Prism.languages.markup;
     const text = Prism.highlight(
       code.replace(/@DOCSIFY_QM@/g, '`'),
-      langOrMarkup,
-      lang
+      langOrMarkup
     );
     return `<pre v-pre data-lang="${lang}"><code class="lang-${lang}">${text}</code></pre>`;
   });

--- a/src/core/render/compiler/headline.js
+++ b/src/core/render/compiler/headline.js
@@ -1,32 +1,32 @@
-import { getAndRemoveConfig, removeAtag } from '../utils';
+import { getAndRemoveConfig } from '../utils';
 import { slugify } from './slugify';
 export const headingCompiler = ({ renderer, router, _self }) =>
   (renderer.code = (text, level) => {
     let { str, config } = getAndRemoveConfig(text);
-    const nextToc = { level, title: removeAtag(str) };
+    const nextToc = { level, title: str };
     if (/<!-- {docsify-ignore} -->/g.test(str)) {
       str = str.replace('<!-- {docsify-ignore} -->', '');
-      nextToc.title = removeAtag(str);
+      nextToc.title = str;
       nextToc.ignoreSubHeading = true;
     }
     if (/{docsify-ignore}/g.test(str)) {
       str = str.replace('{docsify-ignore}', '');
-      nextToc.title = removeAtag(str);
+      nextToc.title = str;
       nextToc.ignoreSubHeading = true;
     }
     if (/<!-- {docsify-ignore-all} -->/g.test(str)) {
       str = str.replace('<!-- {docsify-ignore-all} -->', '');
-      nextToc.title = removeAtag(str);
+      nextToc.title = str;
       nextToc.ignoreAllSubs = true;
     }
     if (/{docsify-ignore-all}/g.test(str)) {
       str = str.replace('{docsify-ignore-all}', '');
-      nextToc.title = removeAtag(str);
+      nextToc.title = str;
       nextToc.ignoreAllSubs = true;
     }
     const slug = slugify(config.id || str);
     const url = router.toURL(router.getCurrentPath(), { id: slug });
     nextToc.slug = url;
     _self.toc.push(nextToc);
     return `<h${level} id="${slug}"><a href="${url}" data-id="${slug}" class="anchor"><span>${str}</span></a></h${level}>`;
   });

--- a/src/core/render/compiler/link.js
+++ b/src/core/render/compiler/link.js
@@ -19,21 +19,21 @@
     if (
       !isAbsolutePath(href) &&
       !compilerClass._matchNotCompileLink(href) &&
       !config.ignore
     ) {
       if (href === compilerClass.config.homepage) {
         href = 'README';
       }
       href = router.toURL(href, null, router.getCurrentPath());
     } else {
-      if (!isAbsolutePath(href) && href.slice(0, 2) === './') {
+      if (!isAbsolutePath(href) && href.startsWith('./')) {
         href =
           document.URL.replace(/\/(?!.*\/).*/, '/').replace('#/./', '') + href;
       }
       attrs.push(href.indexOf('mailto:') === 0 ? '' : `target="${linkTarget}"`);
       attrs.push(
         href.indexOf('mailto:') === 0
           ? ''
           : linkRel !== ''
           ? ` rel="${linkRel}"`
           : ''

--- a/src/core/render/embed.js
+++ b/src/core/render/embed.js
@@ -13,21 +13,21 @@
     const next = (function(token) {
       return text => {
         let embedToken;
         if (text) {
           if (token.embed.type === 'markdown') {
             let path = token.embed.url.split('/');
             path.pop();
             path = path.join('/');
             text = text.replace(/\[([^[\]]+)\]\(([^)]+)\)/g, x => {
               const linkBeginIndex = x.indexOf('(');
-              if (x.slice(linkBeginIndex, linkBeginIndex + 2) === '(.') {
+              if (x.substring(linkBeginIndex).startsWith('(.')) {
                 return (
                   x.substring(0, linkBeginIndex) +
                   `(${window.location.protocol}//${window.location.host}${path}/` +
                   x.substring(linkBeginIndex + 1, x.length - 1) +
                   ')'
                 );
               }
               return x;
             });
             const frontMatterInstalled =

--- a/src/core/render/index.js
+++ b/src/core/render/index.js
@@ -5,155 +5,62 @@
 import cssVars from '../util/polyfill/css-vars';
 import { callHook } from '../init/lifecycle';
 import { getAndActive, sticky } from '../event/sidebar';
 import { getPath, isAbsolutePath } from '../router/util';
 import { isMobile, inBrowser } from '../util/env';
 import { isPrimitive } from '../util/core';
 import { scrollActiveSidebar } from '../event/scroll';
 import { Compiler } from './compiler';
 import * as tpl from './tpl';
 import { prerenderEmbed } from './embed';
-let vueGlobalData;
 function executeScript() {
   const script = dom
     .findAll('.markdown-section>script')
     .filter(s => !/template/.test(s.type))[0];
   if (!script) {
     return false;
   }
   const code = script.innerText.trim();
   if (!code) {
     return false;
   }
-  new Function(code)();
+  setTimeout(_ => {
+    window.__EXECUTE_RESULT__ = new Function(code)();
+  }, 0);
 }
 function formatUpdated(html, updated, fn) {
   updated =
     typeof fn === 'function'
       ? fn(updated)
       : typeof fn === 'string'
       ? tinydate(fn)(new Date(updated))
       : updated;
   return html.replace(/{docsify-updated}/g, updated);
 }
 function renderMain(html) {
-  const docsifyConfig = this.config;
-  const markdownElm = dom.find('.markdown-section');
-  const vueVersion =
-    'Vue' in window &&
-    window.Vue.version &&
-    Number(window.Vue.version.charAt(0));
-  const isMountedVue = elm => {
-    const isVue2 = Boolean(elm.__vue__ && elm.__vue__._isVue);
-    const isVue3 = Boolean(elm._vnode && elm._vnode.__v_skip);
-    return isVue2 || isVue3;
-  };
   if (!html) {
     html = '<h1>404 - Not found</h1>';
   }
-  if ('Vue' in window) {
-    const mountedElms = dom
-      .findAll('.markdown-section > *')
-      .filter(elm => isMountedVue(elm));
-    for (const mountedElm of mountedElms) {
-      if (vueVersion === 2) {
-        mountedElm.__vue__.$destroy();
-      } else if (vueVersion === 3) {
-        mountedElm.__vue_app__.unmount();
-      }
-    }
-  }
-  this._renderTo(markdownElm, html);
-  !docsifyConfig.loadSidebar && this._renderSidebar();
+  this._renderTo('.markdown-section', html);
+  !this.config.loadSidebar && this._renderSidebar();
   if (
-    docsifyConfig.executeScript ||
-    ('Vue' in window && docsifyConfig.executeScript !== false)
+    this.config.executeScript !== false &&
+    typeof window.Vue !== 'undefined' &&
+    !executeScript()
   ) {
-    executeScript();
-  }
-  if ('Vue' in window) {
-    const vueMountData = [];
-    const vueComponentNames = Object.keys(docsifyConfig.vueComponents || {});
-    if (vueVersion === 2 && vueComponentNames.length) {
-      vueComponentNames.forEach(name => {
-        const isNotRegistered = !window.Vue.options.components[name];
-        if (isNotRegistered) {
-          window.Vue.component(name, docsifyConfig.vueComponents[name]);
-        }
-      });
-    }
-    if (
-      !vueGlobalData &&
-      docsifyConfig.vueGlobalOptions &&
-      typeof docsifyConfig.vueGlobalOptions.data === 'function'
-    ) {
-      vueGlobalData = docsifyConfig.vueGlobalOptions.data();
-    }
-    vueMountData.push(
-      ...Object.entries(docsifyConfig.vueMounts || {})
-        .map(([cssSelector, vueConfig]) => [
-          dom.find(markdownElm, cssSelector),
-          vueConfig,
-        ])
-        .filter(([elm, vueConfig]) => elm)
-    );
-    if (docsifyConfig.vueGlobalOptions || vueComponentNames.length) {
-      const reHasBraces = /{{2}[^{}]*}{2}/;
-      const reHasDirective = /<[^>/]+\s([@:]|v-)[\w-:.[\]]+[=>\s]/;
-      vueMountData.push(
-        ...dom
-          .findAll('.markdown-section > *')
-          .filter(elm => !vueMountData.some(([e, c]) => e === elm))
-          .filter(elm => {
-            const isVueMount =
-              elm.tagName.toLowerCase() in
-                (docsifyConfig.vueComponents || {}) ||
-              elm.querySelector(vueComponentNames.join(',') || null) ||
-              reHasBraces.test(elm.outerHTML) ||
-              reHasDirective.test(elm.outerHTML);
-            return isVueMount;
-          })
-          .map(elm => {
-            const vueConfig = Object.assign(
-              {},
-              docsifyConfig.vueGlobalOptions || {}
-            );
-            if (vueGlobalData) {
-              vueConfig.data = function() {
-                return vueGlobalData;
-              };
-            }
-            return [elm, vueConfig];
-          })
-      );
-    }
-    for (const [mountElm, vueConfig] of vueMountData) {
-      const isVueAttr = 'data-isvue';
-      const isSkipElm =
-        mountElm.matches('pre, script') ||
-        isMountedVue(mountElm) ||
-        mountElm.querySelector(`[${isVueAttr}]`);
-      if (!isSkipElm) {
-        mountElm.setAttribute(isVueAttr, '');
-        if (vueVersion === 2) {
-          vueConfig.el = undefined;
-          new window.Vue(vueConfig).$mount(mountElm);
-        } else if (vueVersion === 3) {
-          const app = window.Vue.createApp(vueConfig);
-          vueComponentNames.forEach(name => {
-            const config = docsifyConfig.vueComponents[name];
-            app.component(name, config);
-          });
-          app.mount(mountElm);
-        }
-      }
-    }
+    setTimeout(_ => {
+      const vueVM = window.__EXECUTE_RESULT__;
+      vueVM && vueVM.$destroy && vueVM.$destroy();
+      window.__EXECUTE_RESULT__ = new window.Vue().$mount('#main');
+    }, 0);
+  } else {
+    this.config.executeScript && executeScript();
   }
 }
 function renderNameLink(vm) {
   const el = dom.getNode('.app-name-link');
   const nameLink = vm.config.nameLink;
   const path = vm.route.path;
   if (!el) {
     return;
   }
   if (isPrimitive(vm.config.nameLink)) {
@@ -168,24 +75,22 @@
 export function renderMixin(proto) {
   proto._renderTo = function(el, content, replace) {
     const node = dom.getNode(el);
     if (node) {
       node[replace ? 'outerHTML' : 'innerHTML'] = content;
     }
   };
   proto._renderSidebar = function(text) {
     const { maxLevel, subMaxLevel, loadSidebar, hideSidebar } = this.config;
     if (hideSidebar) {
-      [
-        document.querySelector('aside.sidebar'),
-        document.querySelector('button.sidebar-toggle'),
-      ].forEach(node => node.parentNode.removeChild(node));
+      document.querySelector('aside.sidebar').remove();
+      document.querySelector('button.sidebar-toggle').remove();
       document.querySelector('section.content').style.right = 'unset';
       document.querySelector('section.content').style.left = 'unset';
       document.querySelector('section.content').style.position = 'relative';
       document.querySelector('section.content').style.width = '100%';
       return null;
     }
     this._renderTo('.sidebar-nav', this.compiler.sidebar(text, maxLevel));
     const activeEl = getAndActive(this.router, '.sidebar-nav', true, true);
     if (loadSidebar && activeEl) {
       activeEl.parentNode.innerHTML +=
@@ -217,39 +122,35 @@
   proto._renderMain = function(text, opt = {}, next) {
     if (!text) {
       return renderMain.call(this, text);
     }
     callHook(this, 'beforeEach', text, result => {
       let html;
       const callback = () => {
         if (opt.updatedAt) {
           html = formatUpdated(html, opt.updatedAt, this.config.formatUpdated);
         }
-        callHook(this, 'afterEach', html, hookData =>
-          renderMain.call(this, hookData)
-        );
+        callHook(this, 'afterEach', html, text => renderMain.call(this, text));
       };
       if (this.isHTML) {
         html = this.result = text;
         callback();
         next();
       } else {
         prerenderEmbed(
           {
             compiler: this.compiler,
             raw: result,
           },
           tokens => {
             html = this.compiler.compile(tokens);
-            html = this.isRemoteUrl
-              ? DOMPurify.sanitize(html, { ADD_TAGS: ['script'] })
-              : html;
+            html = this.isRemoteUrl ? DOMPurify.sanitize(html) : html;
             callback();
             next();
           }
         );
       }
     });
   };
   proto._renderCover = function(text, coverOnly) {
     const el = dom.getNode('.cover');
     dom.toggleClass(
@@ -285,21 +186,20 @@
     sticky();
   };
   proto._updateRender = function() {
     renderNameLink(this);
   };
 }
 export function initRender(vm) {
   const config = vm.config;
   vm.compiler = new Compiler(config, vm.router);
   if (inBrowser) {
-    /* eslint-disable-next-line camelcase */
     window.__current_docsify_compiler__ = vm.compiler;
   }
   const id = config.el || '#app';
   const navEl = dom.find('nav') || dom.create('nav');
   const el = dom.find(id);
   let html = '';
   let navAppendToTarget = dom.body;
   if (el) {
     if (config.repo) {
       html += tpl.corner(config.repo, config.cornerExternalLinkTarge);

--- a/src/core/render/slugify.js
+++ b/src/core/render/slugify.js
@@ -4,21 +4,21 @@
 function lower(string) {
   return string.toLowerCase();
 }
 export function slugify(str) {
   if (typeof str !== 'string') {
     return '';
   }
   let slug = str
     .trim()
     .replace(/[A-Z]+/g, lower)
-    .replace(/<[^>]+>/g, '')
+    .replace(/<[^>\d]+>/g, '')
     .replace(re, '')
     .replace(/\s/g, '-')
     .replace(/-+/g, '-')
     .replace(/^(\d)/, '_$1');
   let count = cache[slug];
   count = hasOwn.call(cache, slug) ? count + 1 : 0;
   cache[slug] = count;
   if (count) {
     slug = slug + '-' + count;
   }

--- a/src/core/render/tpl.js
+++ b/src/core/render/tpl.js
@@ -74,22 +74,21 @@
  * @param  {Array} toc Array of TOC section links
  * @param  {String} tpl TPL list
  * @return {String} Rendered tree
  */
 export function tree(toc, tpl = '<ul class="app-sub-sidebar">{inner}</ul>') {
   if (!toc || !toc.length) {
     return '';
   }
   let innerHTML = '';
   toc.forEach(node => {
-    const title = node.title.replace(/(<([^>]+)>)/g, '');
-    innerHTML += `<li><a class="section-link" href="${node.slug}" title="${title}">${node.title}</a></li>`;
+    innerHTML += `<li><a class="section-link" href="${node.slug}" title="${node.title}">${node.title}</a></li>`;
     if (node.children) {
       innerHTML += tree(node.children, tpl);
     }
   });
   return tpl.replace('{inner}', innerHTML);
 }
 export function helper(className, content) {
   return `<p class="${className}">${content.slice(5).trim()}</p>`;
 }
 export function theme(color) {

--- a/src/core/render/utils.js
+++ b/src/core/render/utils.js
@@ -28,19 +28,10 @@
         if (key.indexOf(':') === -1) {
           config[key] = (value && value.replace(/&quot;/g, '')) || true;
           return '';
         }
         return m;
       })
       .trim();
   }
   return { str, config };
 }
-/**
- * Remove the <a> tag from sidebar when the header with link, details see issue 1069
- * @param {string}   str   The string to deal with.
- *
- * @return {string}   str   The string after delete the <a> element.
- */
-export function removeAtag(str = '') {
-  return str.replace(/(<\/?a.*?>)/gi, '');
-}

--- a/src/core/router/history/hash.js
+++ b/src/core/router/history/hash.js
@@ -1,30 +1,27 @@
 import { noop } from '../../util/core';
 import { on } from '../../util/dom';
-import { parseQuery, cleanPath, replaceSlug, endsWith } from '../util';
+import { parseQuery, cleanPath, replaceSlug } from '../util';
 import { History } from './base';
 function replaceHash(path) {
   const i = location.href.indexOf('#');
   location.replace(location.href.slice(0, i >= 0 ? i : 0) + '#' + path);
 }
 export class HashHistory extends History {
   constructor(config) {
     super(config);
     this.mode = 'hash';
   }
   getBasePath() {
     const path = window.location.pathname || '';
     const base = this.config.basePath;
-    const basePath = endsWith(path, '.html')
-      ? path + '#/' + base
-      : path + '/' + base;
-    return /^(\/|https?:)/g.test(base) ? base : cleanPath(basePath);
+    return /^(\/|https?:)/g.test(base) ? base : cleanPath(path + '/' + base);
   }
   getCurrentPath() {
     const href = location.href;
     const index = href.indexOf('#');
     return index === -1 ? '' : href.slice(index + 1);
   }
   onchange(cb = noop) {
     let navigating = false;
     on('click', e => {
       const el = e.target.tagName === 'A' ? e.target : e.target.parentNode;

--- a/src/core/router/util.js
+++ b/src/core/router/util.js
@@ -49,47 +49,16 @@
   for (let i = 0, len = segments.length; i < len; i++) {
     const segment = segments[i];
     if (segment === '..') {
       resolved.pop();
     } else if (segment !== '.') {
       resolved.push(segment);
     }
   }
   return '/' + resolved.join('/');
 });
-/**
- * Normalises the URI path to handle the case where Docsify is
- * hosted off explicit files, i.e. /index.html. This function
- * eliminates any path segments that contain `#` fragments.
- *
- * This is used to map browser URIs to markdown file sources.
- *
- * For example:
- *
- * http://example.org/base/index.html#/blah
- *
- * would be mapped to:
- *
- * http://example.org/base/blah.md.
- *
- * See here for more information:
- *
- * https://github.com/docsifyjs/docsify/pull/1372
- *
- * @param {string} path The URI path to normalise
- * @return {string} { path, query }
- */
-function normaliseFragment(path) {
-  return path
-    .split('/')
-    .filter(p => p.indexOf('#') === -1)
-    .join('/');
-}
 export function getPath(...args) {
-  return cleanPath(args.map(normaliseFragment).join('/'));
+  return cleanPath(args.join('/'));
 }
 export const replaceSlug = cached(path => {
   return path.replace('#', '?id=');
 });
-export function endsWith(str, suffix) {
-  return str.indexOf(suffix, str.length - suffix.length) !== -1;
-}

--- a/src/plugins/emoji.js
+++ b/src/plugins/emoji.js
@@ -1,11 +1,10 @@
-/* eslint-disable camelcase */
 const AllGithubEmoji = {
   '100': 'unicode/1f4af',
   '1234': 'unicode/1f522',
   '+1': 'unicode/1f44d',
   '-1': 'unicode/1f44e',
   '1st_place_medal': 'unicode/1f947',
   '2nd_place_medal': 'unicode/1f948',
   '3rd_place_medal': 'unicode/1f949',
   '8ball': 'unicode/1f3b1',
   a: 'unicode/1f170',
@@ -1793,20 +1792,19 @@
   zap: 'unicode/26a1',
   zebra: 'unicode/1f993',
   zero: 'unicode/0030-20e3',
   zimbabwe: 'unicode/1f1ff-1f1fc',
   zipper_mouth_face: 'unicode/1f910',
   zombie: 'unicode/1f9df',
   zombie_man: 'unicode/1f9df-2642',
   zombie_woman: 'unicode/1f9df-2640',
   zzz: 'unicode/1f4a4',
 };
-/* eslint-enable camelcase */
 window.emojify = function(match, $1) {
   return AllGithubEmoji.hasOwnProperty($1) === false
     ? match
     : '<img class="emoji" src="https://github.githubassets.com/images/icons/emoji/' +
         AllGithubEmoji[$1] +
         '.png" alt="' +
         $1 +
         '" />';
 };

--- a/src/plugins/search/search.js
+++ b/src/plugins/search/search.js
@@ -47,185 +47,143 @@
   if (!token.text && token.type === 'table') {
     token.cells.unshift(token.header);
     token.text = token.cells
       .map(function(rows) {
         return rows.join(' | ');
       })
       .join(' |\n ');
   }
   return token.text;
 }
-function getListData(token) {
-  if (!token.text && token.type === 'list') {
-    token.text = token.raw;
-  }
-  return token.text;
-}
 function saveData(maxAge, expireKey, indexKey) {
   localStorage.setItem(expireKey, Date.now() + maxAge);
   localStorage.setItem(indexKey, JSON.stringify(INDEXS));
 }
 export function genIndex(path, content = '', router, depth) {
   const tokens = window.marked.lexer(content);
   const slugify = window.Docsify.slugify;
   const index = {};
   let slug;
-  let title = '';
   tokens.forEach(token => {
     if (token.type === 'heading' && token.depth <= depth) {
       const { str, config } = getAndRemoveConfig(token.text);
       if (config.id) {
         slug = router.toURL(path, { id: slugify(config.id) });
       } else {
         slug = router.toURL(path, { id: slugify(escapeHtml(token.text)) });
       }
-      if (str) {
-        title = str
-          .replace(/<!-- {docsify-ignore} -->/, '')
-          .replace(/{docsify-ignore}/, '')
-          .replace(/<!-- {docsify-ignore-all} -->/, '')
-          .replace(/{docsify-ignore-all}/, '')
-          .trim();
-      }
-      index[slug] = { slug, title: title, body: '' };
+      index[slug] = { slug, title: str, body: '' };
     } else {
       if (!slug) {
         return;
       }
       if (!index[slug]) {
         index[slug] = { slug, title: '', body: '' };
       } else if (index[slug].body) {
         token.text = getTableData(token);
-        token.text = getListData(token);
         index[slug].body += '\n' + (token.text || '');
       } else {
         token.text = getTableData(token);
-        token.text = getListData(token);
         index[slug].body = index[slug].body
           ? index[slug].body + token.text
           : token.text;
       }
     }
   });
   slugify.clear();
   return index;
-}
-export function ignoreDiacriticalMarks(keyword) {
-  if (keyword && keyword.normalize) {
-    return keyword.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
-  }
-  return keyword;
 }
 /**
  * @param {String} query Search query
  * @returns {Array} Array of results
  */
 export function search(query) {
   const matchingResults = [];
   let data = [];
   Object.keys(INDEXS).forEach(key => {
     data = data.concat(Object.keys(INDEXS[key]).map(page => INDEXS[key][page]));
   });
   query = query.trim();
   let keywords = query.split(/[\s\-ï¼Œ\\/]+/);
   if (keywords.length !== 1) {
     keywords = [].concat(query, keywords);
   }
   for (let i = 0; i < data.length; i++) {
     const post = data[i];
     let matchesScore = 0;
     let resultStr = '';
-    let handlePostTitle = '';
-    let handlePostContent = '';
     const postTitle = post.title && post.title.trim();
     const postContent = post.body && post.body.trim();
     const postUrl = post.slug || '';
     if (postTitle) {
       keywords.forEach(keyword => {
         const regEx = new RegExp(
-          ignoreDiacriticalMarks(keyword).replace(
-            /[|\\{}()[\]^$+*?.]/g,
-            '\\$&'
-          ),
+          keyword.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'),
           'gi'
         );
         let indexTitle = -1;
         let indexContent = -1;
-        handlePostTitle = postTitle
-          ? ignoreDiacriticalMarks(postTitle)
-          : postTitle;
-        handlePostContent = postContent
-          ? ignoreDiacriticalMarks(postContent)
-          : postContent;
-        indexTitle = postTitle ? handlePostTitle.search(regEx) : -1;
-        indexContent = postContent ? handlePostContent.search(regEx) : -1;
+        indexTitle = postTitle ? postTitle.search(regEx) : -1;
+        indexContent = postContent ? postContent.search(regEx) : -1;
         if (indexTitle >= 0 || indexContent >= 0) {
           matchesScore += indexTitle >= 0 ? 3 : indexContent >= 0 ? 2 : 0;
           if (indexContent < 0) {
             indexContent = 0;
           }
           let start = 0;
           let end = 0;
           start = indexContent < 11 ? 0 : indexContent - 10;
           end = start === 0 ? 70 : indexContent + keyword.length + 60;
           if (postContent && end > postContent.length) {
             end = postContent.length;
           }
           const matchContent =
             '...' +
-            handlePostContent
+            escapeHtml(postContent)
               .substring(start, end)
               .replace(
                 regEx,
                 word => `<em class="search-keyword">${word}</em>`
               ) +
             '...';
           resultStr += matchContent;
         }
       });
       if (matchesScore > 0) {
         const matchingPost = {
-          title: handlePostTitle,
+          title: escapeHtml(postTitle),
           content: postContent ? resultStr : '',
           url: postUrl,
           score: matchesScore,
         };
         matchingResults.push(matchingPost);
       }
     }
   }
   return matchingResults.sort((r1, r2) => r2.score - r1.score);
 }
 export function init(config, vm) {
   const isAuto = config.paths === 'auto';
   const paths = isAuto ? getAllPaths(vm.router) : config.paths;
   let namespaceSuffix = '';
-  if (paths.length && isAuto && config.pathNamespaces) {
+  if (isAuto && config.pathNamespaces) {
     const path = paths[0];
     if (Array.isArray(config.pathNamespaces)) {
       namespaceSuffix =
-        config.pathNamespaces.filter(
-          prefix => path.slice(0, prefix.length) === prefix
-        )[0] || namespaceSuffix;
+        config.pathNamespaces.find(prefix => path.startsWith(prefix)) ||
+        namespaceSuffix;
     } else if (config.pathNamespaces instanceof RegExp) {
       const matches = path.match(config.pathNamespaces);
       if (matches) {
         namespaceSuffix = matches[0];
       }
     }
-    const isExistHome = paths.indexOf(namespaceSuffix + '/') === -1;
-    const isExistReadme = paths.indexOf(namespaceSuffix + '/README') === -1;
-    if (isExistHome && isExistReadme) {
-      paths.unshift(namespaceSuffix + '/');
-    }
-  } else if (paths.indexOf('/') === -1 && paths.indexOf('/README') === -1) {
-    paths.unshift('/');
   }
   const expireKey = resolveExpireKey(config.namespace) + namespaceSuffix;
   const indexKey = resolveIndexKey(config.namespace) + namespaceSuffix;
   const isExpired = localStorage.getItem(expireKey) < Date.now();
   INDEXS = JSON.parse(localStorage.getItem(indexKey));
   if (isExpired) {
     INDEXS = {};
   } else if (!isAuto) {
     return;
   }
