--- a/lib/bestzip.js
+++ b/lib/bestzip.js
@@ -2,93 +2,84 @@
 const cp = require("child_process");
 const fs = require("fs");
 const path = require("path");
 const archiver = require("archiver");
 const async = require("async");
 const glob = require("glob");
 const which = require("which");
 function hasNativeZip() {
   return Boolean(which.sync("zip", { nothrow: true }));
 }
-function expandSources(cwd, source, done) {
-  const globOpts = {
-    cwd,
-    dot: false, // ignore .dotfiles
-    noglobstar: true, // treat ** as *
-    noext: true, // no (a|b)
-    nobrace: true // no {a,b}
-  };
-  if (Array.isArray(source)) {
-    return async.concat(
-      source,
-      (_source, next) => expandSources(cwd, _source, next),
-      done
-    );
-  }
-  if (typeof source !== "string") {
-    throw new Error(`source is (${typeof source}) `);
-  }
-  if (glob.hasMagic(source, globOpts)) {
-    glob(source, globOpts, done);
-  } else {
-    process.nextTick(() => {
-      done(null, [source]);
-    });
-  }
-}
-function walkDir(fullPath) {
-  const files = fs.readdirSync(fullPath).map(f => {
-    const filePath = path.join(fullPath, f);
-    const stats = fs.statSync(filePath);
-    if (stats.isDirectory()) {
-      return walkDir(filePath);
-    }
-    return filePath;
-  });
-  return files.reduce((acc, cur) => acc.concat(cur), []);
-}
 const nativeZip = options =>
   new Promise((resolve, reject) => {
-    const cwd = options.cwd || process.cwd();
-    const command = "zip";
-    expandSources(cwd, options.source, (err, sources) => {
-      const args = ["--quiet", "--recurse-paths", options.destination].concat(
-        sources
-      );
-      const zipProcess = cp.spawn(command, args, {
-        stdio: "inherit",
-        cwd
-      });
-      zipProcess.on("error", reject);
-      zipProcess.on("close", exitCode => {
-        if (exitCode === 0) {
-          resolve();
-        } else {
-          reject(
-            new Error(
-              `Unexpected exit code from native zip: ${exitCode}\n executed command '${command} ${args.join(
-                " "
-              )}'\n executed in directory '${cwd}'`
-            )
-          );
-        }
-      });
+    const sources = Array.isArray(options.source)
+      ? options.source.join(" ")
+      : options.source;
+    const command = `zip --quiet --recurse-paths ${
+      options.destination
+    } ${sources}`;
+    const zipProcess = cp.exec(command, {
+      stdio: "inherit",
+      cwd: options.cwd
+    });
+    zipProcess.on("error", reject);
+    zipProcess.on("close", exitCode => {
+      if (exitCode === 0) {
+        resolve();
+      } else {
+        reject(
+          new Error(
+            `Unexpected exit code from native zip command: ${exitCode}\n executed command '${command}'\n executed inin directory '${options.cwd ||
+              process.cwd()}'`
+          )
+        );
+      }
     });
   });
 const nodeZip = options =>
   new Promise((resolve, reject) => {
     const cwd = options.cwd || process.cwd();
     const output = fs.createWriteStream(path.resolve(cwd, options.destination));
     const archive = archiver("zip");
     output.on("close", resolve);
     archive.on("error", reject);
     archive.pipe(output);
+    const globOpts = {
+      cwd: cwd,
+      dot: false, // ignore .dotfiles
+      noglobstar: true, // treat ** as *
+      noext: true, // no (a|b)
+      nobrace: true // no {a,b}
+    };
+    function findSource(source, next) {
+      if (glob.hasMagic(source, globOpts)) {
+        glob(source, globOpts, function(err, files) {
+          if (err) {
+            return next(err);
+          }
+          async.forEach(files, addSource, next);
+        });
+      } else {
+        addSource(source, next);
+      }
+    }
+    function walkDir(fullPath) {
+      const files = fs.readdirSync(fullPath).map(f => {
+        const filePath = path.join(fullPath, f);
+        const stats = fs.statSync(filePath);
+        if (stats.isDirectory()) {
+          return walkDir(filePath);
+        }
+        return filePath;
+      });
+      return files.reduce((acc, cur) => acc.concat(cur), []);
+    }
     function addSource(source, next) {
       const fullPath = path.resolve(cwd, source);
       const destPath = source;
       fs.stat(fullPath, function(err, stats) {
         if (err) {
           return next(err);
         }
         if (stats.isDirectory()) {
           const files = walkDir(fullPath);
           files.forEach(f => {
@@ -96,30 +87,28 @@
             archive.file(f, {
               name: destPath + subPath
             });
           });
         } else if (stats.isFile()) {
           archive.file(fullPath, { stats: stats, name: destPath });
         }
         next();
       });
     }
-    expandSources(cwd, options.source, (err, expandedSources) => {
+    const sources = Array.isArray(options.source)
+      ? options.source
+      : [options.source];
+    async.forEach(sources, findSource, function(err) {
       if (err) {
         return reject(err);
       }
-      async.forEach(expandedSources, addSource, err => {
-        if (err) {
-          return reject(err);
-        }
-        archive.finalize();
-      });
+      archive.finalize();
     });
   });
 function zip(options) {
   const compatMode = typeof options === "string";
   if (compatMode) {
     options = {
       source: arguments[1],
       destination: arguments[0]
     };
   }
