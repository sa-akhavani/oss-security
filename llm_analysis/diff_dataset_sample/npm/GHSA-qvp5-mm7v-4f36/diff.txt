--- a/packages/strapi-admin/config/functions/bootstrap.js
+++ b/packages/strapi-admin/config/functions/bootstrap.js
@@ -9,14 +9,14 @@
   const { conditionProvider } = strapi.admin.services.permission;
   conditionProvider.registerMany(adminConditions.conditions);
 };
 module.exports = async () => {
   registerAdminConditions();
   registerPermissionActions();
   await strapi.admin.services.permission.cleanPermissionInDatabase();
   await strapi.admin.services.permission.ensureBoundPermissionsInDatabase();
   await strapi.admin.services.user.migrateUsers();
   await strapi.admin.services.role.createRolesIfNoneExist();
-  await strapi.admin.services.role.resetSuperAdminPermissions();
+  await strapi.admin.services.permission.resetSuperAdminPermissions();
   await strapi.admin.services.role.displayWarningIfNoSuperAdmin();
   await strapi.admin.services.user.displayWarningIfUsersDontHaveRole();
 };

--- a/packages/strapi-admin/controllers/role.js
+++ b/packages/strapi-admin/controllers/role.js
@@ -99,19 +99,16 @@
       const modifiedPermissions = input.permissions
         .filter(p => existingPermissions.get(p.action).section === 'contentTypes')
         .map(p => ({
           ...p,
           conditions: role.code === AUTHOR_CODE ? ['admin::is-creator'] : [],
         }));
       permissionsToAssign.push(...modifiedPermissions);
     } else {
       permissionsToAssign = input.permissions;
     }
-    const permissions = await strapi.admin.services.role.assignPermissions(
-      role.id,
-      permissionsToAssign
-    );
+    const permissions = await strapi.admin.services.permission.assign(role.id, permissionsToAssign);
     ctx.body = {
       data: permissions,
     };
   },
 };

--- a/packages/strapi-admin/ee/controllers/role.js
+++ b/packages/strapi-admin/ee/controllers/role.js
@@ -72,19 +72,16 @@
         const err = new yup.ValidationError("Super admin permissions can't be edited.");
         throw formatYupErrors(err);
       }
       await validatedUpdatePermissionsInput(input);
     } catch (err) {
       return ctx.badRequest('ValidationError', err);
     }
     if (!role) {
       return ctx.notFound('role.notFound');
     }
-    const permissions = await strapi.admin.services.role.assignPermissions(
-      role.id,
-      input.permissions
-    );
+    const permissions = await strapi.admin.services.permission.assign(role.id, input.permissions);
     ctx.body = {
       data: permissions,
     };
   },
 };

--- a/packages/strapi-admin/services/metrics.js
+++ b/packages/strapi-admin/services/metrics.js
@@ -1,13 +1,9 @@
 'use strict';
 const sendDidInviteUser = async () => {
   const numberOfUsers = await strapi.admin.services.user.count();
   const numberOfRoles = await strapi.admin.services.role.count();
   return strapi.telemetry.send('didInviteUser', { numberOfRoles, numberOfUsers });
 };
-const sendDidUpdateRolePermissions = async () => {
-  return strapi.telemetry.send('didUpdateRolePermissions');
-};
 module.exports = {
   sendDidInviteUser,
-  sendDidUpdateRolePermissions,
 };

--- a/packages/strapi-admin/services/permission.js
+++ b/packages/strapi-admin/services/permission.js
@@ -1,23 +1,37 @@
 'use strict';
 const _ = require('lodash');
 const { flatMap, filter } = require('lodash/fp');
 const pmap = require('p-map');
+const { validatePermissionsExist } = require('../validation/permission');
 const createPermissionsManager = require('./permission/permissions-manager');
 const createConditionProvider = require('./permission/condition-provider');
 const createPermissionEngine = require('./permission/engine');
 const actionProvider = require('./permission/action-provider');
 const { EDITOR_CODE } = require('./constants');
 const { getBoundActionsBySubject, BOUND_ACTIONS_FOR_FIELDS } = require('../domain/role');
 const { createPermission } = require('../domain/permission');
 const conditionProvider = createConditionProvider();
 const engine = createPermissionEngine(conditionProvider);
+const fieldsToCompare = ['action', 'subject', 'fields', 'conditions'];
+const getPermissionWithSortedFields = perm => {
+  const sortedPerm = _.cloneDeep(perm);
+  if (Array.isArray(sortedPerm.fields)) {
+    sortedPerm.fields.sort();
+  }
+  return sortedPerm;
+};
+const arePermissionsEqual = (perm1, perm2) =>
+  _.isEqual(
+    _.pick(getPermissionWithSortedFields(perm1), fieldsToCompare),
+    _.pick(getPermissionWithSortedFields(perm2), fieldsToCompare)
+  );
 /**
  * Removes unwanted fields from a permission
  * @param perm
  * @returns {*}
  */
 const sanitizePermission = perm => ({
   ..._.pick(perm, ['id', 'action', 'subject', 'fields']),
   conditions: strapi.admin.services.condition.removeUnkownConditionIds(perm.conditions),
 });
 /**
@@ -53,20 +67,59 @@
 const update = async (params, attributes) => {
   return strapi.query('permission', 'admin').update(params, attributes);
 };
 /**
  * Find assigned permissions in the database
  * @param params query params to find the permissions
  * @returns {Promise<array<Object>>}
  */
 const find = (params = {}) => {
   return strapi.query('permission', 'admin').find(params, []);
+};
+/**
+ * Assign permissions to a role
+ * @param {string|int} roleId - role ID
+ * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role
+ */
+const assign = async (roleId, permissions = []) => {
+  try {
+    await validatePermissionsExist(permissions);
+  } catch (err) {
+    throw strapi.errors.badRequest('ValidationError', err);
+  }
+  const permissionsWithRole = permissions.map(permission =>
+    createPermission({
+      ...permission,
+      conditions: strapi.admin.services.condition.removeUnkownConditionIds(permission.conditions),
+      role: roleId,
+    })
+  );
+  const existingPermissions = await find({ role: roleId, _limit: -1 });
+  const permissionsToAdd = _.differenceWith(
+    permissionsWithRole,
+    existingPermissions,
+    arePermissionsEqual
+  );
+  const permissionsToDelete = _.differenceWith(
+    existingPermissions,
+    permissionsWithRole,
+    arePermissionsEqual
+  );
+  const permissionsToReturn = _.differenceBy(existingPermissions, permissionsToDelete, 'id');
+  if (permissionsToDelete.length > 0) {
+    await deleteByIds(permissionsToDelete.map(p => p.id));
+  }
+  if (permissionsToAdd.length > 0) {
+    const createdPermissions = await createMany(permissionsToAdd);
+    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));
+  }
+  return permissionsToReturn;
 };
 /**
  * Find all permissions for a user
  * @param roles
  * @returns {Promise<*[]|*>}
  */
 const findUserPermissions = async ({ roles }) => {
   if (!_.isArray(roles)) {
     return [];
   }
@@ -148,24 +201,52 @@
           action,
           subject: contentType.uid,
           role: editorRole.id,
           fields: BOUND_ACTIONS_FOR_FIELDS.includes(action) ? fields : null,
         })
       );
       await createMany(permissions);
     }
   }
 };
+/**
+ * Reset super admin permissions (giving it all permissions)
+ * @returns {Promise<>}
+ */
+const resetSuperAdminPermissions = async () => {
+  const superAdminRole = await strapi.admin.services.role.getSuperAdmin();
+  if (!superAdminRole) {
+    return;
+  }
+  const allActions = strapi.admin.services.permission.actionProvider.getAll();
+  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');
+  const permissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(
+    contentTypesActions
+  );
+  const otherActions = allActions.filter(a => a.section !== 'contentTypes');
+  otherActions.forEach(action => {
+    if (action.subjects) {
+      const newPerms = action.subjects.map(subject =>
+        createPermission({ action: action.actionId, subject })
+      );
+      permissions.push(...newPerms);
+    } else {
+      permissions.push(createPermission({ action: action.actionId }));
+    }
+  });
+  await assign(superAdminRole.id, permissions);
+};
 module.exports = {
-  createMany,
   find,
   deleteByRolesIds,
   deleteByIds,
+  assign,
   sanitizePermission,
   findUserPermissions,
   actionProvider,
   createPermissionsManager,
   engine,
   conditionProvider,
   cleanPermissionInDatabase,
+  resetSuperAdminPermissions,
   ensureBoundPermissionsInDatabase,
 };

--- a/packages/strapi-admin/services/role.js
+++ b/packages/strapi-admin/services/role.js
@@ -1,36 +1,22 @@
 'use strict';
 const _ = require('lodash');
 const { set } = require('lodash/fp');
 const { generateTimestampCode, stringIncludes } = require('strapi-utils');
 const { SUPER_ADMIN_CODE } = require('./constants');
 const { createPermission } = require('../domain/permission');
-const { validatePermissionsExist } = require('../validation/permission');
 const ACTIONS = {
   publish: 'plugins::content-manager.explorer.publish',
 };
 const sanitizeRole = role => {
   return _.omit(role, ['users', 'permissions']);
 };
-const fieldsToCompare = ['action', 'subject', 'fields', 'conditions'];
-const getPermissionWithSortedFields = perm => {
-  const sortedPerm = _.cloneDeep(perm);
-  if (Array.isArray(sortedPerm.fields)) {
-    sortedPerm.fields.sort();
-  }
-  return sortedPerm;
-};
-const arePermissionsEqual = (perm1, perm2) =>
-  _.isEqual(
-    _.pick(getPermissionWithSortedFields(perm1), fieldsToCompare),
-    _.pick(getPermissionWithSortedFields(perm2), fieldsToCompare)
-  );
 /**
  * Create and save a role in database
  * @param attributes A partial role object
  * @returns {Promise<role>}
  */
 const create = async attributes => {
   const alreadyExists = await exists({ name: attributes.name });
   if (alreadyExists) {
     throw strapi.errors.badRequest('ValidationError', {
       name: [`The name must be unique and a role with name \`${attributes.name}\` already exists.`],
@@ -163,21 +149,21 @@
  * @returns {Promise<role>}
  */
 const getSuperAdmin = () => findOne({ code: SUPER_ADMIN_CODE });
 /** Returns admin role with userCount
  * @returns {Promise<role>}
  */
 const getSuperAdminWithUsersCount = () => findOneWithUsersCount({ code: SUPER_ADMIN_CODE });
 /** Create superAdmin, Author and Editor role is no role already exist
  * @returns {Promise<>}
  */
-const createRolesIfNoneExist = async () => {
+const createRolesIfNoneExist = async ({ createPermissionsForAdmin = false } = {}) => {
   const someRolesExist = await exists();
   if (someRolesExist) {
     return;
   }
   const allActions = strapi.admin.services.permission.actionProvider.getAll();
   const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');
   const superAdminRole = await create({
     name: 'Super Admin',
     code: 'strapi-super-admin',
     description: 'Super Admins can access and manage all features and settings.',
@@ -197,22 +183,25 @@
     contentTypesActions,
     {
       restrictedSubjects: ['plugins::users-permissions.user'],
     }
   );
   const authorPermissions = editorPermissions
     .filter(({ action }) => action !== ACTIONS.publish)
     .map(set('conditions', ['admin::is-creator']));
   editorPermissions.push(...getDefaultPluginPermissions());
   authorPermissions.push(...getDefaultPluginPermissions({ isAuthor: true }));
-  await addPermissions(editorRole.id, editorPermissions);
-  await addPermissions(authorRole.id, authorPermissions);
+  await strapi.admin.services.permission.assign(editorRole.id, editorPermissions);
+  await strapi.admin.services.permission.assign(authorRole.id, authorPermissions);
+  if (createPermissionsForAdmin) {
+    await strapi.admin.services.permission.resetSuperAdminPermissions();
+  }
 };
 const getDefaultPluginPermissions = ({ isAuthor = false } = {}) => {
   const conditions = isAuthor ? ['admin::is-creator'] : null;
   return [
     { action: 'plugins::upload.read', conditions },
     { action: 'plugins::upload.assets.create' },
     { action: 'plugins::upload.assets.update', conditions },
     { action: 'plugins::upload.assets.download' },
     { action: 'plugins::upload.assets.copy-link' },
   ].map(createPermission);
@@ -222,109 +211,28 @@
  * @returns {Promise<>}
  */
 const displayWarningIfNoSuperAdmin = async () => {
   const superAdminRole = await getSuperAdminWithUsersCount();
   const someUsersExists = await strapi.admin.services.user.exists();
   if (!superAdminRole) {
     strapi.log.warn("Your application doesn't have a super admin role.");
   } else if (someUsersExists && superAdminRole.usersCount === 0) {
     strapi.log.warn("Your application doesn't have a super admin user.");
   }
-};
-/**
- * Assign permissions to a role
- * @param {string|int} roleId - role ID
- * @param {Array<Permission{action,subject,fields,conditions}>} permissions - permissions to assign to the role
- */
-const assignPermissions = async (roleId, permissions = []) => {
-  try {
-    await validatePermissionsExist(permissions);
-  } catch (err) {
-    throw strapi.errors.badRequest('ValidationError', err);
-  }
-  const superAdmin = await strapi.admin.services.role.getSuperAdmin();
-  const isSuperAdmin = superAdmin && superAdmin.id === roleId;
-  const permissionsWithRole = permissions.map(permission =>
-    createPermission({
-      ...permission,
-      conditions: strapi.admin.services.condition.removeUnkownConditionIds(permission.conditions),
-      role: roleId,
-    })
-  );
-  const existingPermissions = await strapi.admin.services.permission.find({
-    role: roleId,
-    _limit: -1,
-  });
-  const permissionsToAdd = _.differenceWith(
-    permissionsWithRole,
-    existingPermissions,
-    arePermissionsEqual
-  );
-  const permissionsToDelete = _.differenceWith(
-    existingPermissions,
-    permissionsWithRole,
-    arePermissionsEqual
-  );
-  const permissionsToReturn = _.differenceBy(existingPermissions, permissionsToDelete, 'id');
-  if (permissionsToDelete.length > 0) {
-    await strapi.admin.services.permission.deleteByIds(permissionsToDelete.map(p => p.id));
-  }
-  if (permissionsToAdd.length > 0) {
-    const createdPermissions = await addPermissions(roleId, permissionsToAdd);
-    permissionsToReturn.push(...createdPermissions.map(p => ({ ...p, role: p.role.id })));
-  }
-  if (!isSuperAdmin && (permissionsToAdd.length || permissionsToDelete.length)) {
-    await strapi.admin.services.metrics.sendDidUpdateRolePermissions();
-  }
-  return permissionsToReturn;
-};
-const addPermissions = async (roleId, permissions) => {
-  const permissionsWithRole = permissions.map(set('role', roleId));
-  return strapi.admin.services.permission.createMany(permissionsWithRole);
-};
-/**
- * Reset super admin permissions (giving it all permissions)
- * @returns {Promise<>}
- */
-const resetSuperAdminPermissions = async () => {
-  const superAdminRole = await strapi.admin.services.role.getSuperAdmin();
-  if (!superAdminRole) {
-    return;
-  }
-  const allActions = strapi.admin.services.permission.actionProvider.getAll();
-  const contentTypesActions = allActions.filter(a => a.section === 'contentTypes');
-  const permissions = strapi.admin.services['content-type'].getPermissionsWithNestedFields(
-    contentTypesActions
-  );
-  const otherActions = allActions.filter(a => a.section !== 'contentTypes');
-  otherActions.forEach(action => {
-    if (action.subjects) {
-      const newPerms = action.subjects.map(subject =>
-        createPermission({ action: action.actionId, subject })
-      );
-      permissions.push(...newPerms);
-    } else {
-      permissions.push(createPermission({ action: action.actionId }));
-    }
-  });
-  await assignPermissions(superAdminRole.id, permissions);
 };
 module.exports = {
   sanitizeRole,
   create,
   findOne,
   findOneWithUsersCount,
   find,
   findAllWithUsersCount,
   update,
   exists,
   count,
   deleteByIds,
   getUsersCount,
   getSuperAdmin,
   getSuperAdminWithUsersCount,
   createRolesIfNoneExist,
   displayWarningIfNoSuperAdmin,
-  addPermissions,
-  assignPermissions,
-  resetSuperAdminPermissions,
-};
+};

--- a/packages/strapi-connector-bookshelf/lib/build-database-schema.js
+++ b/packages/strapi-connector-bookshelf/lib/build-database-schema.js
@@ -1,22 +1,24 @@
 const _ = require('lodash');
 const { singular } = require('pluralize');
 const { contentTypes: contentTypesUtils } = require('strapi-utils');
-const { storeDefinition, getColumnsWhereDefinitionChanged } = require('./utils/store-definition');
-const { migrateDraftAndPublish } = require('./database-migration');
-const { getManyRelations } = require('./utils/associations');
+const { storeDefinition, didDefinitionChange } = require('./utils/store-definition');
+const { getDraftAndPublishMigrationWay, migrateDraftAndPublish } = require('./database-migration');
 module.exports = async ({ ORM, loadedModel, definition, connection, model }) => {
-  await createOrUpdateTables({ ORM, loadedModel, definition, connection, model });
-  await migrateDraftAndPublish({ definition, ORM });
-  await storeDefinition(definition, ORM);
-};
-const createOrUpdateTables = async ({ ORM, loadedModel, definition, connection, model }) => {
+  const definitionDidChange = await didDefinitionChange(definition, ORM);
+  if (!definitionDidChange) {
+    return;
+  }
+  const draftAndPublishMigrationWay = await getDraftAndPublishMigrationWay({ definition, ORM });
+  if (draftAndPublishMigrationWay === 'disable') {
+    await migrateDraftAndPublish({ definition, ORM, way: 'disable' });
+  }
   if (loadedModel.hasTimestamps) {
     definition.attributes[loadedModel.hasTimestamps[0]] = { type: 'currentTimestamp' };
     definition.attributes[loadedModel.hasTimestamps[1]] = { type: 'currentTimestamp' };
   }
   if (connection.options && connection.options.autoMigration !== false) {
     await createOrUpdateTable({
       table: loadedModel.tableName,
       attributes: definition.attributes,
       definition,
       ORM,
@@ -37,21 +39,23 @@
     if (connection.options && connection.options.autoMigration !== false) {
       await createOrUpdateTable({
         table: `${loadedModel.tableName}_morph`,
         attributes,
         definition,
         ORM,
         model,
       });
     }
   }
-  const manyRelations = getManyRelations(definition);
+  const manyRelations = definition.associations.filter(({ nature }) =>
+    ['manyToMany', 'manyWay'].includes(nature)
+  );
   for (const manyRelation of manyRelations) {
     const { plugin, collection, via, dominant, alias } = manyRelation;
     if (dominant) {
       const targetCollection = strapi.db.getModel(collection, plugin);
       const targetAttr = via
         ? targetCollection.attributes[via]
         : {
             attribute: singular(definition.collectionName),
             column: definition.primaryKey,
           };
@@ -68,27 +72,24 @@
       const table = manyRelation.tableCollectionName;
       if (connection.options && connection.options.autoMigration !== false) {
         await createOrUpdateTable({ table, attributes, definition, ORM, model });
       }
     }
   }
   if (loadedModel.hasTimestamps) {
     delete definition.attributes[loadedModel.hasTimestamps[0]];
     delete definition.attributes[loadedModel.hasTimestamps[1]];
   }
-};
-const getColumnInfo = async (columnName, tableName, ORM) => {
-  const exists = await ORM.knex.schema.hasColumn(tableName, columnName);
-  return {
-    columnName,
-    exists,
-  };
+  if (draftAndPublishMigrationWay === 'enable') {
+    await migrateDraftAndPublish({ definition, ORM, way: 'enable' });
+  }
+  await storeDefinition(definition, ORM);
 };
 const isColumn = ({ definition, attribute, name }) => {
   if (!_.has(attribute, 'type')) {
     const relation = definition.associations.find(association => {
       return association.alias === name;
     });
     if (!relation) return false;
     if (['oneToOne', 'manyToOne', 'oneWay'].includes(relation.nature)) {
       return true;
     }
@@ -215,99 +216,94 @@
   const createTable = (table, { trx = ORM.knex, ...opts } = {}) => {
     return trx.schema.createTable(table, tbl => {
       createIdType(tbl);
       createColumns(tbl, attributes, { ...opts, tableExists: false });
     });
   };
   if (!tableExists) {
     await createTable(table);
     return;
   }
-  const attributesNames = Object.keys(attributes);
-  const columnsInfo = await Promise.all(
-    attributesNames.map(attributeName => getColumnInfo(attributeName, table, ORM))
+  const columns = Object.keys(attributes);
+  const columnsExist = await Promise.all(
+    columns.map(attribute => ORM.knex.schema.hasColumn(table, attribute))
   );
-  const nameOfColumnsToAdd = columnsInfo.filter(info => !info.exists).map(info => info.columnName);
-  const columnsToAdd = _.pick(attributes, nameOfColumnsToAdd);
+  const columnsToAdd = {};
+  columnsExist.forEach((columnExist, index) => {
+    const attribute = attributes[columns[index]];
+    if (!columnExist) {
+      columnsToAdd[columns[index]] = attribute;
+    }
+  });
   if (Object.keys(columnsToAdd).length > 0) {
     await ORM.knex.schema.table(table, tbl => {
       createColumns(tbl, columnsToAdd, { tableExists });
     });
   }
-  const attrsNameWithoutTimestamps = attributesNames.filter(
-    columnName => !(definition.options.timestamps || []).includes(columnName)
-  );
-  const columnsToAlter = getColumnsWhereDefinitionChanged(
-    attrsNameWithoutTimestamps,
-    definition,
-    ORM
-  );
-  if (columnsToAlter.length > 0) {
-    if (definition.client === 'sqlite3') {
-      const tmpTable = `tmp_${table}`;
-      const rebuildTable = async trx => {
-        await trx.schema.renameTable(table, tmpTable);
-        await Promise.all(
-          attributesNames.map(key => trx.raw('DROP INDEX IF EXISTS ??', uniqueColName(table, key)))
+  if (definition.client === 'sqlite3') {
+    const tmpTable = `tmp_${table}`;
+    const rebuildTable = async trx => {
+      await trx.schema.renameTable(table, tmpTable);
+      await Promise.all(
+        columns.map(key => trx.raw('DROP INDEX IF EXISTS ??', uniqueColName(table, key)))
+      );
+      await createTable(table, { trx });
+      const attrs = Object.keys(attributes).filter(attribute =>
+        isColumn({
+          definition,
+          attribute: attributes[attribute],
+          name: attribute,
+        })
+      );
+      const allAttrs = ['id', ...attrs];
+      await trx.insert(qb => qb.select(allAttrs).from(tmpTable)).into(table);
+      await trx.schema.dropTableIfExists(tmpTable);
+    };
+    try {
+      await ORM.knex.transaction(trx => rebuildTable(trx));
+    } catch (err) {
+      if (err.message.includes('UNIQUE constraint failed')) {
+        strapi.log.error(
+          `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.stack}`
         );
-        await createTable(table, { trx });
-        const attrs = attributesNames.filter(attributeName =>
-          isColumn({
-            definition,
-            attribute: attributes[attributeName],
-            name: attributeName,
-          })
+      } else {
+        strapi.log.error(`Migration failed`);
+        strapi.log.error(err);
+      }
+      return false;
+    }
+  } else {
+    const alterTable = async trx => {
+      await Promise.all(
+        columns.map(col => {
+          return ORM.knex.schema
+            .alterTable(table, tbl => {
+              tbl.dropUnique(col, uniqueColName(table, col));
+            })
+            .catch(() => {});
+        })
+      );
+      await trx.schema.alterTable(table, tbl => {
+        alterColumns(tbl, _.pick(attributes, columns), {
+          tableExists,
+        });
+      });
+    };
+    try {
+      await ORM.knex.transaction(trx => alterTable(trx));
+    } catch (err) {
+      if (err.code === '23505' && definition.client === 'pg') {
+        strapi.log.error(
+          `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.message}\n\t- ${err.detail}`
         );
-        const allAttrs = ['id', ...attrs];
-        await trx.insert(qb => qb.select(allAttrs).from(tmpTable)).into(table);
-        await trx.schema.dropTableIfExists(tmpTable);
-      };
-      try {
-        await ORM.knex.transaction(trx => rebuildTable(trx));
-      } catch (err) {
-        if (err.message.includes('UNIQUE constraint failed')) {
-          strapi.log.error(
-            `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.stack}`
-          );
-        } else {
-          strapi.log.error(`Migration failed`);
-          strapi.log.error(err);
-        }
-        return false;
-      }
-    } else {
-      const alterTable = async trx => {
-        await Promise.all(
-          columnsToAlter.map(col => {
-            return ORM.knex.schema
-              .alterTable(table, tbl => {
-                tbl.dropUnique(col, uniqueColName(table, col));
-              })
-              .catch(() => {});
-          })
+      } else if (definition.client === 'mysql' && err.errno === 1062) {
+        strapi.log.error(
+          `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.sqlMessage}`
         );
-        await trx.schema.alterTable(table, tbl => {
-          alterColumns(tbl, _.pick(attributes, columnsToAlter), {
-            tableExists,
-          });
-        });
-      };
-      try {
-        await ORM.knex.transaction(trx => alterTable(trx));
-      } catch (err) {
-        if (err.code === '23505' && definition.client === 'pg') {
-          strapi.log.error(
-            `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.message}\n\t- ${err.detail}`
-          );
-        } else if (definition.client === 'mysql' && err.errno === 1062) {
-          strapi.log.error(
-            `Unique constraint fails, make sure to update your data and restart to apply the unique constraint.\n\t- ${err.sqlMessage}`
-          );
-        } else {
-          strapi.log.error(`Migration failed`);
-          strapi.log.error(err);
-        }
-        return false;
-      }
+      } else {
+        strapi.log.error(`Migration failed`);
+        strapi.log.error(err);
+      }
+      return false;
     }
   }
 };

--- a/packages/strapi-connector-bookshelf/lib/buildQuery.js
+++ b/packages/strapi-connector-bookshelf/lib/buildQuery.js
@@ -4,21 +4,21 @@
 const BOOLEAN_OPERATORS = ['or'];
 /**
  * Build filters on a bookshelf query
  * @param {Object} options - Options
  * @param {Object} options.model - Bookshelf model
  * @param {Object} options.filters - Filters params (start, limit, sort, where)
  */
 const buildQuery = ({ model, filters }) => qb => {
   if (_.has(filters, 'where') && Array.isArray(filters.where) && filters.where.length > 0) {
     qb.distinct();
-    buildJoinsAndFilter(qb, model, filters);
+    buildJoinsAndFilter(qb, model, filters.where);
   }
   if (_.has(filters, 'sort')) {
     qb.orderBy(
       filters.sort.map(({ field, order }) => ({
         column: field,
         order,
       }))
     );
   }
   if (_.has(filters, 'start')) {
@@ -31,24 +31,23 @@
     runPopulateQueries(
       toQueries({ publicationState: { query: filters.publicationState, model } }),
       qb
     );
   }
 };
 /**
  * Add joins and where filters
  * @param {Object} qb - knex query builder
  * @param {Object} model - Bookshelf model
- * @param {Object} filters - The query filters
+ * @param {Array<Object>} whereClauses - an array of where clause
  */
-const buildJoinsAndFilter = (qb, model, filters) => {
-  const { where: whereClauses } = filters;
+const buildJoinsAndFilter = (qb, model, whereClauses) => {
   /**
    * Returns an alias for a name (simple incremental alias name)
    * @param {string} name - name to alias
    */
   const aliasMap = {};
   const generateAlias = name => {
     if (!aliasMap[name]) {
       aliasMap[name] = 1;
     }
     const alias = `${name}_${aliasMap[name]}`;
@@ -169,40 +168,24 @@
         return { field, operator, value: value.map(v => buildWhereClauses(v, { model })) };
       }
       const path = generateNestedJoins(field, tree);
       return {
         field: path,
         operator,
         value,
       };
     });
   };
-  /**
-   * Add queries on tree's joins (deep search) based on given filters
-   * @param tree - joins tree
-   */
-  const addFiltersQueriesToJoinTree = tree => {
-    _.each(tree.joins, value => {
-      const { alias, model } = value;
-      runPopulateQueries(
-        toQueries({
-          publicationState: { query: filters.publicationState, model, alias },
-        }),
-        qb
-      );
-      addFiltersQueriesToJoinTree(value);
-    });
-  };
   const aliasedWhereClauses = buildWhereClauses(whereClauses, { model });
+  buildJoinsFromTree(qb, tree);
   aliasedWhereClauses.forEach(w => buildWhereClause({ qb, ...w }));
-  buildJoinsFromTree(qb, tree);
-  addFiltersQueriesToJoinTree(tree);
+  return;
 };
 /**
  * Builds a sql where clause
  * @param {Object} options - Options
  * @param {Object} options.qb - Bookshelf (knex) query builder
  * @param {Object} options.model - Bookshelf model
  * @param {Object} options.field - Filtered field
  * @param {Object} options.operator - Filter operator (=,in,not eq etc..)
  * @param {Object} options.value - Filter value
  */

--- a/packages/strapi-connector-bookshelf/lib/database-migration.js
+++ b/packages/strapi-connector-bookshelf/lib/database-migration.js
@@ -11,22 +11,21 @@
   if (previousDraftAndPublish === actualDraftAndPublish) {
     return 'none';
   }
   if (!previousDraftAndPublish && actualDraftAndPublish) {
     return 'enable';
   }
   if (previousDraftAndPublish && !actualDraftAndPublish) {
     return 'disable';
   }
 };
-const migrateDraftAndPublish = async ({ definition, ORM }) => {
-  const way = await getDraftAndPublishMigrationWay({ definition, ORM });
+const migrateDraftAndPublish = async ({ definition, ORM, way }) => {
   if (way === 'enable') {
     const now = new Date();
     let publishedAtValue = now;
     if (_.get(definition, 'options.timestamps', false)) {
       const createdAtColumn = _.get(definition, 'options.timestamps.0', 'created_at');
       publishedAtValue = ORM.knex.ref(createdAtColumn);
     }
     await ORM.knex(definition.collectionName)
       .update({ [PUBLISHED_AT_ATTRIBUTE]: publishedAtValue })
       .where(PUBLISHED_AT_ATTRIBUTE, null);
@@ -34,20 +33,21 @@
       .update({ [PUBLISHED_AT_ATTRIBUTE]: now })
       .where(PUBLISHED_AT_ATTRIBUTE, null);
   } else if (way === 'disable') {
     await ORM.knex(definition.collectionName)
       .delete()
       .where(PUBLISHED_AT_ATTRIBUTE, null);
     const publishedAtColumnExists = await ORM.knex.schema.hasColumn(
       definition.collectionName,
       PUBLISHED_AT_ATTRIBUTE
     );
-    if (publishedAtColumnExists) {
+    if (definition.client !== 'sqlite3' && publishedAtColumnExists) {
       await ORM.knex.schema.table(definition.collectionName, table => {
         table.dropColumn(PUBLISHED_AT_ATTRIBUTE);
       });
     }
   }
 };
 module.exports = {
+  getDraftAndPublishMigrationWay,
   migrateDraftAndPublish,
 };

--- a/packages/strapi-connector-bookshelf/lib/mount-models.js
+++ b/packages/strapi-connector-bookshelf/lib/mount-models.js
@@ -60,25 +60,25 @@
     }
     definition.globalName = _.upperFirst(_.camelCase(definition.globalId));
     definition.associations = [];
     GLOBALS[definition.globalId] = {};
     definition.orm = 'bookshelf';
     definition.databaseName = getDatabaseName(connection);
     definition.client = _.get(connection.settings, 'client');
     definition.primaryKey = 'id';
     definition.primaryKeyType = 'integer';
     target[model].allAttributes = { ...definition.attributes };
-    const createdAtCol = _.get(definition, 'options.timestamps.0', 'created_at');
+    const createAtCol = _.get(definition, 'options.timestamps.0', 'created_at');
     const updatedAtCol = _.get(definition, 'options.timestamps.1', 'updated_at');
     if (_.get(definition, 'options.timestamps', false)) {
-      _.set(definition, 'options.timestamps', [createdAtCol, updatedAtCol]);
-      target[model].allAttributes[createdAtCol] = { type: 'timestamp' };
+      _.set(definition, 'options.timestamps', [createAtCol, updatedAtCol]);
+      target[model].allAttributes[createAtCol] = { type: 'timestamp' };
       target[model].allAttributes[updatedAtCol] = { type: 'timestamp' };
     } else {
       _.set(definition, 'options.timestamps', false);
     }
     const loadedModel = _.assign(
       {
         requireFetch: false,
         tableName: definition.collectionName,
         hasTimestamps: definition.options.timestamps,
         associations: [],

--- a/packages/strapi-connector-bookshelf/lib/utils/associations.js
+++ b/packages/strapi-connector-bookshelf/lib/utils/associations.js
@@ -1,11 +1,7 @@
 'use strict';
 const isPolymorphic = ({ assoc }) => {
   return assoc.nature.toLowerCase().indexOf('morph') !== -1;
 };
-const getManyRelations = definition => {
-  return definition.associations.filter(({ nature }) => ['manyToMany', 'manyWay'].includes(nature));
-};
 module.exports = {
   isPolymorphic,
-  getManyRelations,
 };

--- a/packages/strapi-connector-bookshelf/lib/utils/populate-queries.js
+++ b/packages/strapi-connector-bookshelf/lib/utils/populate-queries.js
@@ -2,23 +2,23 @@
 const _ = require('lodash');
 const {
   contentTypes: {
     hasDraftAndPublish,
     constants: { DP_PUB_STATE_LIVE, DP_PUB_STATE_PREVIEW, PUBLISHED_AT_ATTRIBUTE },
   },
 } = require('strapi-utils');
 const optionsMap = {
   publicationState: {
     queries: {
-      [DP_PUB_STATE_LIVE]: ({ model, alias }) => qb => {
+      [DP_PUB_STATE_LIVE]: ({ model }) => qb => {
         const { collectionName } = model;
-        qb.whereNotNull(`${alias || collectionName}.${PUBLISHED_AT_ATTRIBUTE}`);
+        qb.whereNotNull(`${collectionName}.${PUBLISHED_AT_ATTRIBUTE}`);
       },
       [DP_PUB_STATE_PREVIEW]: () => null,
     },
     validate({ model, query: publicationState }) {
       return hasDraftAndPublish(model) && _.has(this.queries, publicationState);
     },
   },
 };
 const availableOptions = Object.keys(optionsMap);
 const isValidOption = option => availableOptions.includes(option);

--- a/packages/strapi-connector-bookshelf/lib/utils/store-definition.js
+++ b/packages/strapi-connector-bookshelf/lib/utils/store-definition.js
@@ -20,24 +20,21 @@
   const defData = {
     key: `model_def_${definition.uid}`,
     type: 'object',
     value: defToStore,
   };
   if (existingDef) {
     return strapi.models['core_store'].forge({ id: existingDef.id }).save(defData);
   }
   return strapi.models['core_store'].forge(defData).save();
 };
-const getColumnsWhereDefinitionChanged = async (columnsName, definition, ORM) => {
-  const previousDefinitionRow = await getDefinitionFromStore(definition, ORM);
-  const previousDefinition = JSON.parse(_.get(previousDefinitionRow, 'value', null));
-  return columnsName.filter(columnName => {
-    const previousAttribute = _.get(previousDefinition, ['attributes', columnName], null);
-    const actualAttribute = _.get(definition, ['attributes', columnName], null);
-    return !_.isEqual(previousAttribute, actualAttribute);
-  });
+const didDefinitionChange = async (definition, ORM) => {
+  const previousDefRow = await getDefinitionFromStore(definition, ORM);
+  const previousDefJSON = _.get(previousDefRow, 'value', null);
+  const actualDefJSON = formatDefinitionToStore(definition);
+  return previousDefJSON !== actualDefJSON;
 };
 module.exports = {
   storeDefinition,
+  didDefinitionChange,
   getDefinitionFromStore,
-  getColumnsWhereDefinitionChanged,
 };

--- a/packages/strapi-connector-mongoose/lib/buildQuery.js
+++ b/packages/strapi-connector-mongoose/lib/buildQuery.js
@@ -1,21 +1,18 @@
 'use strict';
 const _ = require('lodash');
 var semver = require('semver');
 const utils = require('./utils')();
 const populateQueries = require('./utils/populate-queries');
 const {
   hasDeepFilters,
-  contentTypes: {
-    constants: { DP_PUB_STATES },
-    hasDraftAndPublish,
-  },
+  contentTypes: { hasDraftAndPublish },
 } = require('strapi-utils');
 const combineSearchAndWhere = (search = [], wheres = []) => {
   const criterias = {};
   if (search.length > 0 && wheres.length > 0) {
     criterias.$and = [{ $and: wheres }, { $or: search }];
   } else if (search.length > 0) {
     criterias.$or = search;
   } else if (wheres.length > 0) {
     criterias.$and = wheres;
   }
@@ -113,23 +110,24 @@
  * @param {Object} options.model - The model you are querying
  * @param {Object} options.filters - An object with the possible filters (start, limit, sort, where)
  * @param {Object} options.populate - An array of paths to populate
  */
 const buildDeepQuery = ({ model, filters, search, populate }) => {
   const { populatePaths, wherePaths } = computePopulatedPaths({
     model,
     populate,
     where: filters.where,
   });
+  const customQueryOptions = _.pick(filters, ['publicationState']);
   let query = model
     .aggregate(
-      buildQueryAggregate(model, filters, {
+      buildQueryAggregate(model, {
         paths: _.merge({}, populatePaths, wherePaths),
       })
     )
     .append(buildQueryMatches(model, filters, search));
   return {
     /**
      * Overrides the promise to rehydrate mongoose docs after the aggregation query
      */
     then(...args) {
       return query
@@ -139,21 +137,22 @@
         .then(results => results.map(el => el._id))
         .then(ids => {
           if (ids.length === 0) return [];
           const query = model
             .find(
               {
                 _id: {
                   $in: ids,
                 },
               },
-              null
+              null,
+              { custom: customQueryOptions }
             )
             .populate(populate);
           return applyQueryParams({ model, query, filters });
         })
         .then(...args);
     },
     catch(...args) {
       return this.then(r => r).catch(...args);
     },
     /**
@@ -241,171 +240,149 @@
       return value.map(where => recursiveCastedWherePaths(where, { model }));
     }
     return findModelPath({ rootModel: model, path: field });
   });
   return _.flattenDeep(paths).filter(path => !!path);
 };
 /**
  * Builds an object based on paths:
  * [
  *    'articles',
- *    'articles.tags.category',
+ *    'articles.tags.cateogry',
  *    'articles.tags.label',
  * ] => {
  *  articles: {
  *    tags: {
  *      category: {},
  *      label: {}
  *    }
  *  }
  * }
  * @param {Array<string>} paths - A list of paths to transform
  */
 const pathsToTree = paths => paths.reduce((acc, path) => _.merge(acc, _.set({}, path, {})), {});
 /**
- * Builds the aggregations pipeline of the query
+ * Builds the aggregations pipeling of the query
  * @param {Object} model - Queried model
- * @param {Object} filters - The query filters
  * @param {Object} options - Options
  * @param {Object} options.paths - A tree of paths to aggregate e.g { article : { tags : { label: {}}}}
  */
-const buildQueryAggregate = (model, filters, { paths } = {}) => {
+const buildQueryAggregate = (model, { paths } = {}) => {
   return Object.keys(paths).reduce((acc, key) => {
-    return acc.concat(buildLookup({ model, key, paths: paths[key], filters }));
+    return acc.concat(buildLookup({ model, key, paths: paths[key] }));
   }, []);
 };
 /**
  * Builds a lookup aggregation for a specific key
  * @param {Object} options - Options
  * @param {Object} options.model - Queried model
  * @param {string} options.key - The attribute name to lookup on the model
  * @param {Object} options.paths - A tree of paths to aggregate inside the current lookup e.g { { tags : { label: {}}}
  */
-const buildLookup = ({ model, key, paths, filters }) => {
+const buildLookup = ({ model, key, paths }) => {
   const assoc = model.associations.find(a => a.alias === key);
   const assocModel = strapi.db.getModelByAssoc(assoc);
   if (!assocModel) return [];
   return [
     {
       $lookup: {
         from: assocModel.collectionName,
         as: assoc.alias,
         let: {
           localId: '$_id',
           localAlias: `$${assoc.alias}`,
         },
         pipeline: []
-          .concat(buildLookupMatch({ assoc, assocModel, filters }))
-          .concat(buildQueryAggregate(assocModel, filters, { paths })),
+          .concat(buildLookupMatch({ assoc }))
+          .concat(buildQueryAggregate(assocModel, { paths })),
       },
     },
   ];
 };
 /**
  * Build a lookup match expression (equivalent to a SQL join condition)
  * @param {Object} options - Options
- * @param {Object} options.assoc - The association on which is based the matching expression
- */
-const buildLookupMatch = ({ assoc, assocModel, filters = {} }) => {
-  const defaultMatches = [];
-  if (hasDraftAndPublish(assocModel) && DP_PUB_STATES.includes(filters.publicationState)) {
-    const dpQuery = populateQueries.publicationState[filters.publicationState];
-    if (_.isObject(dpQuery)) {
-      defaultMatches.push(dpQuery);
-    }
-  }
+ * @param {Object} options.assoc - The association on which is based the ematching xpression
+ */
+const buildLookupMatch = ({ assoc }) => {
   switch (assoc.nature) {
     case 'oneToOne': {
       return [
         {
           $match: {
-            $and: defaultMatches.concat({
-              $expr: {
-                $eq: [`$${assoc.via}`, '$$localId'],
-              },
-            }),
-          },
-        },
-      ];
-    }
-    case 'oneToMany': {
-      return {
-        $match: {
-          $and: defaultMatches.concat({
             $expr: {
               $eq: [`$${assoc.via}`, '$$localId'],
             },
-          }),
+          },
+        },
+      ];
+    }
+    case 'oneToMany': {
+      return {
+        $match: {
+          $expr: {
+            $eq: [`$${assoc.via}`, '$$localId'],
+          },
         },
       };
     }
     case 'oneWay':
     case 'manyToOne': {
       return {
         $match: {
-          $and: defaultMatches.concat({
-            $expr: {
-              $eq: ['$$localAlias', '$_id'],
-            },
-          }),
+          $expr: {
+            $eq: ['$$localAlias', '$_id'],
+          },
         },
       };
     }
     case 'manyWay': {
       return {
         $match: {
-          $and: defaultMatches.concat({
-            $expr: {
-              $in: ['$_id', '$$localAlias'],
-            },
-          }),
+          $expr: {
+            $in: ['$_id', '$$localAlias'],
+          },
         },
       };
     }
     case 'manyToMany': {
       if (assoc.dominant === true) {
         return {
           $match: {
-            $and: defaultMatches.concat({
-              $expr: {
-                $in: ['$_id', '$$localAlias'],
-              },
-            }),
+            $expr: {
+              $in: ['$_id', '$$localAlias'],
+            },
           },
         };
       }
       return {
         $match: {
-          $and: defaultMatches.concat({
-            $expr: {
-              $in: ['$$localId', `$${assoc.via}`],
-            },
-          }),
+          $expr: {
+            $in: ['$$localId', `$${assoc.via}`],
+          },
         },
       };
     }
     case 'manyToManyMorph':
     case 'oneToManyMorph': {
       return [
         {
           $unwind: { path: `$${assoc.via}`, preserveNullAndEmptyArrays: true },
         },
         {
           $match: {
-            $and: defaultMatches.concat({
-              $expr: {
-                $and: [
-                  { $eq: [`$${assoc.via}.ref`, '$$localId'] },
-                  { $eq: [`$${assoc.via}.${assoc.filter}`, assoc.alias] },
-                ],
-              },
-            }),
+            $expr: {
+              $and: [
+                { $eq: [`$${assoc.via}.ref`, '$$localId'] },
+                { $eq: [`$${assoc.via}.${assoc.filter}`, assoc.alias] },
+              ],
+            },
           },
         },
       ];
     }
     default:
       return [];
   }
 };
 /**
  * Match query for lookups

--- a/packages/strapi-connector-mongoose/lib/database-migration.js
+++ b/packages/strapi-connector-mongoose/lib/database-migration.js
@@ -1,21 +1,21 @@
 'use strict';
 const _ = require('lodash');
 const { contentTypes: contentTypesUtils } = require('strapi-utils');
 const { PUBLISHED_AT_ATTRIBUTE } = contentTypesUtils.constants;
 const { getDefinitionFromStore } = require('./utils/store-definition');
 const getDraftAndPublishMigrationWay = async (definition, ORM) => {
   const previousDefRow = await getDefinitionFromStore(definition, ORM);
   const previousDef = JSON.parse(_.get(previousDefRow, 'value', null));
   const previousDraftAndPublish = contentTypesUtils.hasDraftAndPublish(previousDef);
   const actualDraftAndPublish = contentTypesUtils.hasDraftAndPublish(definition);
-  if (!previousDefRow || previousDraftAndPublish === actualDraftAndPublish) {
+  if (previousDraftAndPublish === actualDraftAndPublish) {
     return 'none';
   }
   if (!previousDraftAndPublish && actualDraftAndPublish) {
     return 'enable';
   }
   if (previousDraftAndPublish && !actualDraftAndPublish) {
     return 'disable';
   }
 };
 const migrateDraftAndPublish = async ({ definition, model, ORM }) => {

--- a/packages/strapi-plugin-content-manager/admin/src/components/PreviewWysiwyg/index.js
+++ b/packages/strapi-plugin-content-manager/admin/src/components/PreviewWysiwyg/index.js
@@ -1,25 +1,24 @@
 /* eslint-disable react/no-danger */
 /**
  *
  * PreviewWysiwyg
  *
  */
 import React, { memo, useMemo } from 'react';
 import PropTypes from 'prop-types';
 import useWysiwyg from '../../hooks/useWysiwyg';
 import md from './utils/mdRenderer';
-import sanitizeHtml from './utils/satinizeHtml';
 import Wrapper from './Wrapper';
 const PreviewWysiwyg = ({ data }) => {
   const { isFullscreen } = useWysiwyg();
-  const html = useMemo(() => sanitizeHtml(md.render(data || '')), [data]);
+  const html = useMemo(() => md.render(data || ''), [data]);
   return (
     <Wrapper isFullscreen={isFullscreen}>
       <div dangerouslySetInnerHTML={{ __html: html }} />
     </Wrapper>
   );
 };
 PreviewWysiwyg.defaultProps = {
   data: '',
 };
 PreviewWysiwyg.propTypes = {

--- a/packages/strapi-plugin-content-manager/admin/src/components/PreviewWysiwyg/utils/satinizeHtml.js
+++ b//dev/null
@@ -1,12 +0,0 @@
-import sanitizeHtml from 'sanitize-html';
-const options = {
-  ...sanitizeHtml.defaults,
-  allowedTags: false,
-  allowedAttributes: {
-    '*': ['href', 'align', 'alt', 'center', 'width', 'height', 'type', 'controls', 'target'],
-    img: ['src', 'alt'],
-    source: ['src', 'type'],
-  },
-};
-const clean = dirty => sanitizeHtml(dirty, options);
-export default clean;

--- a/packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js
+++ b/packages/strapi-plugin-upload/admin/src/containers/InputModalStepperProvider/index.js
@@ -1,13 +1,13 @@
 import React, { useReducer, useEffect, useState } from 'react';
 import PropTypes from 'prop-types';
-import { request, generateSearchFromFilters, useGlobalContext } from 'strapi-helper-plugin';
+import { auth, request, generateSearchFromFilters, useGlobalContext } from 'strapi-helper-plugin';
 import { clone, get, isEmpty, set } from 'lodash';
 import { useIntl } from 'react-intl';
 import axios from 'axios';
 import pluginId from '../../pluginId';
 import {
   getFilesToDownload,
   getRequestUrl,
   getYupError,
   compactParams,
   createNewFilesToUploadArray,
@@ -67,21 +67,22 @@
   const downloadFiles = async () => {
     const files = getFilesToDownload(filesToUpload);
     if (files.length > 0) {
       emitEvent('didSelectFile', { source: 'url', location: 'content-manager' });
     }
     try {
       await Promise.all(
         files.map(file => {
           const { source } = file;
           return axios
-            .get(file.fileURL, {
+            .get(`${strapi.backendURL}/${pluginId}/proxy?url=${file.fileURL}`, {
+              headers: { Authorization: `Bearer ${auth.getToken()}` },
               responseType: 'blob',
               cancelToken: source.token,
               timeout: 60000,
             })
             .then(({ data }) => {
               const createdFile = new File([data], file.fileURL, {
                 type: data.type,
               });
               dispatch({
                 type: 'FILE_DOWNLOADED',

--- a/packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js
+++ b/packages/strapi-plugin-upload/admin/src/containers/ModalStepper/index.js
@@ -1,15 +1,22 @@
 import React, { useCallback, useEffect, useState, useReducer, useRef } from 'react';
 import axios from 'axios';
 import PropTypes from 'prop-types';
 import { isEqual, isEmpty, get, set } from 'lodash';
-import { Modal, ModalFooter, PopUpWarning, useGlobalContext, request } from 'strapi-helper-plugin';
+import {
+  Modal,
+  ModalFooter,
+  PopUpWarning,
+  useGlobalContext,
+  auth,
+  request,
+} from 'strapi-helper-plugin';
 import { Button } from '@buffetjs/core';
 import pluginId from '../../pluginId';
 import { getFilesToDownload, getTrad, getYupError, urlSchema } from '../../utils';
 import { useAppContext } from '../../hooks';
 import ModalHeader from '../../components/ModalHeader';
 import stepper from './stepper';
 import init from './init';
 import reducer, { initialState } from './reducer';
 const ModalStepper = ({
   initialFileToEdit,
@@ -67,21 +74,22 @@
   downloadFilesRef.current = async () => {
     const files = getFilesToDownload(filesToUpload);
     if (files.length > 0) {
       emitEvent('didSelectFile', { source: 'url', location: 'upload' });
     }
     try {
       await Promise.all(
         files.map(file => {
           const { source } = file;
           return axios
-            .get(file.fileURL, {
+            .get(`${strapi.backendURL}/${pluginId}/proxy?url=${file.fileURL}`, {
+              headers: { Authorization: `Bearer ${auth.getToken()}` },
               responseType: 'blob',
               cancelToken: source.token,
               timeout: 60000,
             })
             .then(({ data }) => {
               const fileName = file.fileInfo.name;
               const createdFile = new File([data], fileName, {
                 type: data.type,
               });
               dispatch({

--- a//dev/null
+++ b/packages/strapi-plugin-upload/controllers/proxy.js
@@ -0,0 +1,35 @@
+'use strict';
+const _ = require('lodash');
+const fetch = require('node-fetch');
+const isValidDomain = require('is-valid-domain');
+module.exports = {
+  async uploadProxy(ctx) {
+    try {
+      const url = new URL(ctx.query.url);
+      if (!['http:', 'https:'].includes(url.protocol)) {
+        throw new Error('Unexpected url protocol');
+      }
+      if (!isValidDomain(url.hostname)) {
+        throw new Error('Invalid url hostname');
+      }
+    } catch (err) {
+      ctx.status = 400;
+      ctx.body = 'Invalid URL';
+      return;
+    }
+    try {
+      const res = await fetch(new URL(ctx.query.url), {
+        headers: _.omit(ctx.request.headers, ['origin', 'host', 'authorization']),
+      });
+      for (const [key, value] of res.headers.entries()) {
+        ctx.set(key, value);
+      }
+      ctx.status = res.status;
+      ctx.body = res.body;
+    } catch (err) {
+      strapi.log.error(err);
+      ctx.status = 500;
+      ctx.body = 'Internal Server Error';
+    }
+  },
+};
