# ====================================================================
# FILE: cmd/server.go
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| package cmd
     2| import (
     3| 	"fmt"
     4| 	"net/url"
     5| 	"os"
     6| 	"path/filepath"
     7| 	"strings"
     8| 	homedir "github.com/mitchellh/go-homedir"
     9| 	"github.com/moby/patternmatcher"
    10| 	"github.com/pkg/errors"
    11| 	"github.com/spf13/cobra"
    12| 	"github.com/spf13/viper"
    13| 	"github.com/runatlantis/atlantis/server"
    14| 	"github.com/runatlantis/atlantis/server/events/vcs/bitbucketcloud"
    15| 	"github.com/runatlantis/atlantis/server/logging"
    16| )
    17| const (
    18| 	CheckoutStrategyBranch = "branch"
    19| 	CheckoutStrategyMerge  = "merge"
    20| )
    21| const (
    22| 	TFDistributionTerraform = "terraform"
    23| 	TFDistributionOpenTofu  = "opentofu"
    24| )
    25| const (
    26| 	ADWebhookPasswordFlag            = "azuredevops-webhook-password" // nolint: gosec
    27| 	ADWebhookUserFlag                = "azuredevops-webhook-user"
    28| 	ADTokenFlag                      = "azuredevops-token" // nolint: gosec
    29| 	ADUserFlag                       = "azuredevops-user"
    30| 	ADHostnameFlag                   = "azuredevops-hostname"
    31| 	AllowCommandsFlag                = "allow-commands"
    32| 	AllowForkPRsFlag                 = "allow-fork-prs"
    33| 	AtlantisURLFlag                  = "atlantis-url"
    34| 	AutoDiscoverModeFlag             = "autodiscover-mode"
    35| 	AutomergeFlag                    = "automerge"
    36| 	ParallelPlanFlag                 = "parallel-plan"
    37| 	ParallelApplyFlag                = "parallel-apply"
    38| 	AutoplanModules                  = "autoplan-modules"
    39| 	AutoplanModulesFromProjects      = "autoplan-modules-from-projects"
    40| 	AutoplanFileListFlag             = "autoplan-file-list"
    41| 	BitbucketBaseURLFlag             = "bitbucket-base-url"
    42| 	BitbucketTokenFlag               = "bitbucket-token"
    43| 	BitbucketUserFlag                = "bitbucket-user"

# --- HUNK 2: Lines 97-178 ---
    97| 	PortFlag                         = "port"
    98| 	RedisDB                          = "redis-db"
    99| 	RedisHost                        = "redis-host"
   100| 	RedisPassword                    = "redis-password"
   101| 	RedisPort                        = "redis-port"
   102| 	RedisTLSEnabled                  = "redis-tls-enabled"
   103| 	RedisInsecureSkipVerify          = "redis-insecure-skip-verify"
   104| 	RepoConfigFlag                   = "repo-config"
   105| 	RepoConfigJSONFlag               = "repo-config-json"
   106| 	RepoAllowlistFlag                = "repo-allowlist"
   107| 	SilenceNoProjectsFlag            = "silence-no-projects"
   108| 	SilenceForkPRErrorsFlag          = "silence-fork-pr-errors"
   109| 	SilenceVCSStatusNoPlans          = "silence-vcs-status-no-plans"
   110| 	SilenceVCSStatusNoProjectsFlag   = "silence-vcs-status-no-projects"
   111| 	SilenceAllowlistErrorsFlag       = "silence-allowlist-errors"
   112| 	SkipCloneNoChanges               = "skip-clone-no-changes"
   113| 	SlackTokenFlag                   = "slack-token"
   114| 	SSLCertFileFlag                  = "ssl-cert-file"
   115| 	SSLKeyFileFlag                   = "ssl-key-file"
   116| 	RestrictFileList                 = "restrict-file-list"
   117| 	TFDistributionFlag               = "tf-distribution"
   118| 	TFDownloadFlag                   = "tf-download"
   119| 	TFDownloadURLFlag                = "tf-download-url"
   120| 	UseTFPluginCache                 = "use-tf-plugin-cache"
   121| 	VarFileAllowlistFlag             = "var-file-allowlist"
   122| 	VCSStatusName                    = "vcs-status-name"
   123| 	TFEHostnameFlag                  = "tfe-hostname"
   124| 	TFELocalExecutionModeFlag        = "tfe-local-execution-mode"
   125| 	TFETokenFlag                     = "tfe-token"
   126| 	WriteGitCredsFlag                = "write-git-creds" // nolint: gosec
   127| 	WebBasicAuthFlag                 = "web-basic-auth"
   128| 	WebUsernameFlag                  = "web-username"
   129| 	WebPasswordFlag                  = "web-password"
   130| 	WebsocketCheckOrigin             = "websocket-check-origin"
   131| 	DefaultADBasicUser                  = ""
   132| 	DefaultADBasicPassword              = ""
   133| 	DefaultADHostname                   = "dev.azure.com"
   134| 	DefaultAutoDiscoverMode             = "auto"
   135| 	DefaultAutoplanFileList             = "**/*.tf,**/*.tfvars,**/*.tfvars.json,**/terragrunt.hcl,**/.terraform.lock.hcl"
   136| 	DefaultAllowCommands                = "version,plan,apply,unlock,approve_policies"
   137| 	DefaultCheckoutStrategy             = CheckoutStrategyBranch
   138| 	DefaultCheckoutDepth                = 0
   139| 	DefaultBitbucketBaseURL             = bitbucketcloud.BaseURL
   140| 	DefaultDataDir                      = "~/.atlantis"
   141| 	DefaultEmojiReaction                = ""
   142| 	DefaultExecutableName               = "atlantis"
   143| 	DefaultMarkdownTemplateOverridesDir = "~/.markdown_templates"
   144| 	DefaultGHHostname                   = "github.com"
   145| 	DefaultGiteaBaseURL                 = "https://gitea.com"
   146| 	DefaultGiteaPageSize                = 30
   147| 	DefaultGitlabHostname               = "gitlab.com"
   148| 	DefaultLockingDBType                = "boltdb"
   149| 	DefaultLogLevel                     = "info"
   150| 	DefaultMaxCommentsPerCommand        = 100
   151| 	DefaultParallelPoolSize             = 15
   152| 	DefaultStatsNamespace               = "atlantis"
   153| 	DefaultPort                         = 4141
   154| 	DefaultRedisDB                      = 0
   155| 	DefaultRedisPort                    = 6379
   156| 	DefaultRedisTLSEnabled              = false
   157| 	DefaultRedisInsecureSkipVerify      = false
   158| 	DefaultTFDistribution               = TFDistributionTerraform
   159| 	DefaultTFDownloadURL                = "https://releases.hashicorp.com"
   160| 	DefaultTFDownload                   = true
   161| 	DefaultTFEHostname                  = "app.terraform.io"
   162| 	DefaultVCSStatusName                = "atlantis"
   163| 	DefaultWebBasicAuth                 = false
   164| 	DefaultWebUsername                  = "atlantis"
   165| 	DefaultWebPassword                  = "atlantis"
   166| )
   167| var stringFlags = map[string]stringFlag{
   168| 	ADTokenFlag: {
   169| 		description: "Azure DevOps token of API user. Can also be specified via the ATLANTIS_AZUREDEVOPS_TOKEN environment variable.",
   170| 	},
   171| 	ADUserFlag: {
   172| 		description: "Azure DevOps username of API user.",
   173| 	},
   174| 	ADWebhookPasswordFlag: {
   175| 		description: "Azure DevOps basic HTTP authentication password for inbound webhooks " +
   176| 			"(see https://docs.microsoft.com/en-us/azure/devops/service-hooks/authorize?view=azure-devops)." +
   177| 			" SECURITY WARNING: If not specified, Atlantis won't be able to validate that the incoming webhook call came from your Azure DevOps org. " +
   178| 			"This means that an attacker could spoof calls to Atlantis and cause it to perform malicious actions. " +

# --- HUNK 3: Lines 367-410 ---
   367| 	RepoConfigFlag: {
   368| 		description: "Path to a repo config file, used to customize how Atlantis runs on each repo. See runatlantis.io/docs for more details.",
   369| 	},
   370| 	RepoConfigJSONFlag: {
   371| 		description: "Specify repo config as a JSON string. Useful if you don't want to write a config file to disk.",
   372| 	},
   373| 	RepoAllowlistFlag: {
   374| 		description: "Comma separated list of repositories that Atlantis will operate on. " +
   375| 			"The format is {hostname}/{owner}/{repo}, ex. github.com/runatlantis/atlantis. '*' matches any characters until the next comma. Examples: " +
   376| 			"all repos: '*' (not secure), an entire hostname: 'internalgithub.com/*' or an organization: 'github.com/runatlantis/*'." +
   377| 			" For Bitbucket Server, {owner} is the name of the project (not the key).",
   378| 	},
   379| 	SlackTokenFlag: {
   380| 		description: "API token for Slack notifications.",
   381| 	},
   382| 	SSLCertFileFlag: {
   383| 		description: "File containing x509 Certificate used for serving HTTPS. If the cert is signed by a CA, the file should be the concatenation of the server's certificate, any intermediates, and the CA's certificate.",
   384| 	},
   385| 	SSLKeyFileFlag: {
   386| 		description: fmt.Sprintf("File containing x509 private key matching --%s.", SSLCertFileFlag),
   387| 	},
   388| 	TFDistributionFlag: {
   389| 		description:  fmt.Sprintf("Which TF distribution to use. Can be set to %s or %s.", TFDistributionTerraform, TFDistributionOpenTofu),
   390| 		defaultValue: DefaultTFDistribution,
   391| 	},
   392| 	TFDownloadURLFlag: {
   393| 		description:  "Base URL to download Terraform versions from.",
   394| 		defaultValue: DefaultTFDownloadURL,
   395| 	},
   396| 	TFEHostnameFlag: {
   397| 		description:  "Hostname of your Terraform Enterprise installation. If using Terraform Cloud no need to set.",
   398| 		defaultValue: DefaultTFEHostname,
   399| 	},
   400| 	TFETokenFlag: {
   401| 		description: "API token for Terraform Cloud/Enterprise. This will be used to generate a ~/.terraformrc file." +
   402| 			" Only set if using TFC/E as a remote backend." +
   403| 			" Should be specified via the ATLANTIS_TFE_TOKEN environment variable for security.",
   404| 	},
   405| 	DefaultTFVersionFlag: {
   406| 		description: "Terraform version to default to (ex. v0.12.0). Will download if not yet on disk." +
   407| 			" If not set, Atlantis uses the terraform binary in its PATH.",
   408| 	},
   409| 	VarFileAllowlistFlag: {
   410| 		description: "Comma-separated list of additional paths where variable definition files can be read from." +

# --- HUNK 4: Lines 815-884 ---
   815| 		c.MarkdownTemplateOverridesDir = DefaultMarkdownTemplateOverridesDir
   816| 	}
   817| 	if !v.IsSet("max-comments-per-command") {
   818| 		c.MaxCommentsPerCommand = DefaultMaxCommentsPerCommand
   819| 	}
   820| 	if c.ParallelPoolSize == 0 {
   821| 		c.ParallelPoolSize = DefaultParallelPoolSize
   822| 	}
   823| 	if c.StatsNamespace == "" {
   824| 		c.StatsNamespace = DefaultStatsNamespace
   825| 	}
   826| 	if c.Port == 0 {
   827| 		c.Port = DefaultPort
   828| 	}
   829| 	if c.RedisDB == 0 {
   830| 		c.RedisDB = DefaultRedisDB
   831| 	}
   832| 	if c.RedisPort == 0 {
   833| 		c.RedisPort = DefaultRedisPort
   834| 	}
   835| 	if c.TFDistribution == "" {
   836| 		c.TFDistribution = DefaultTFDistribution
   837| 	}
   838| 	if c.TFDownloadURL == "" {
   839| 		c.TFDownloadURL = DefaultTFDownloadURL
   840| 	}
   841| 	if c.VCSStatusName == "" {
   842| 		c.VCSStatusName = DefaultVCSStatusName
   843| 	}
   844| 	if c.TFEHostname == "" {
   845| 		c.TFEHostname = DefaultTFEHostname
   846| 	}
   847| 	if c.WebUsername == "" {
   848| 		c.WebUsername = DefaultWebUsername
   849| 	}
   850| 	if c.WebPassword == "" {
   851| 		c.WebPassword = DefaultWebPassword
   852| 	}
   853| 	if c.AutoDiscoverModeFlag == "" {
   854| 		c.AutoDiscoverModeFlag = DefaultAutoDiscoverMode
   855| 	}
   856| }
   857| func (s *ServerCmd) validate(userConfig server.UserConfig) error {
   858| 	userConfig.LogLevel = strings.ToLower(userConfig.LogLevel)
   859| 	if !isValidLogLevel(userConfig.LogLevel) {
   860| 		return fmt.Errorf("invalid log level: must be one of %v", ValidLogLevels)
   861| 	}
   862| 	if userConfig.TFDistribution != TFDistributionTerraform && userConfig.TFDistribution != TFDistributionOpenTofu {
   863| 		return fmt.Errorf("invalid tf distribution: expected one of %s or %s",
   864| 			TFDistributionTerraform, TFDistributionOpenTofu)
   865| 	}
   866| 	checkoutStrategy := userConfig.CheckoutStrategy
   867| 	if checkoutStrategy != CheckoutStrategyBranch && checkoutStrategy != CheckoutStrategyMerge {
   868| 		return fmt.Errorf("invalid checkout strategy: not one of %s or %s",
   869| 			CheckoutStrategyBranch, CheckoutStrategyMerge)
   870| 	}
   871| 	if (userConfig.SSLKeyFile == "") != (userConfig.SSLCertFile == "") {
   872| 		return fmt.Errorf("--%s and --%s are both required for ssl", SSLKeyFileFlag, SSLCertFileFlag)
   873| 	}
   874| 	vcsErr := fmt.Errorf("--%s/--%s or --%s/--%s or --%s/--%s or --%s/--%s or --%s/--%s or --%s/--%s or --%s/--%s must be set", GHUserFlag, GHTokenFlag, GHAppIDFlag, GHAppKeyFileFlag, GHAppIDFlag, GHAppKeyFlag, GiteaUserFlag, GiteaTokenFlag, GitlabUserFlag, GitlabTokenFlag, BitbucketUserFlag, BitbucketTokenFlag, ADUserFlag, ADTokenFlag)
   875| 	if ((userConfig.GithubUser == "") != (userConfig.GithubToken == "")) ||
   876| 		((userConfig.GiteaUser == "") != (userConfig.GiteaToken == "")) ||
   877| 		((userConfig.GitlabUser == "") != (userConfig.GitlabToken == "")) ||
   878| 		((userConfig.BitbucketUser == "") != (userConfig.BitbucketToken == "")) ||
   879| 		((userConfig.AzureDevopsUser == "") != (userConfig.AzureDevopsToken == "")) {
   880| 		return vcsErr
   881| 	}
   882| 	if (userConfig.GithubAppID != 0) && ((userConfig.GithubAppKey == "") && (userConfig.GithubAppKeyFile == "")) {
   883| 		return vcsErr
   884| 	}


# ====================================================================
# FILE: e2e/github.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package main
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"log"
     6| 	"os"
     7| 	"os/exec"
     8| 	"strings"
     9| 	"github.com/google/go-github/v63/github"
    10| )
    11| type GithubClient struct {
    12| 	client    *github.Client
    13| 	username  string
    14| 	ownerName string
    15| 	repoName  string
    16| 	token     string
    17| }
    18| func NewGithubClient() *GithubClient {
    19| 	githubUsername := os.Getenv("ATLANTIS_GH_USER")
    20| 	if githubUsername == "" {
    21| 		log.Fatalf("ATLANTIS_GH_USER cannot be empty")
    22| 	}
    23| 	githubToken := os.Getenv("ATLANTIS_GH_TOKEN")
    24| 	if githubToken == "" {
    25| 		log.Fatalf("ATLANTIS_GH_TOKEN cannot be empty")
    26| 	}
    27| 	ownerName := os.Getenv("GITHUB_REPO_OWNER_NAME")
    28| 	if ownerName == "" {
    29| 		ownerName = "runatlantis"

# --- HUNK 2: Lines 38-85 ---
    38| 	}
    39| 	ghClient := github.NewClient(tp.Client())
    40| 	return &GithubClient{
    41| 		client:    ghClient,
    42| 		username:  githubUsername,
    43| 		ownerName: ownerName,
    44| 		repoName:  repoName,
    45| 		token:     githubToken,
    46| 	}
    47| }
    48| func (g GithubClient) Clone(cloneDir string) error {
    49| 	repoURL := fmt.Sprintf("https://%s:%s@github.com/%s/%s.git", g.username, g.token, g.ownerName, g.repoName)
    50| 	cloneCmd := exec.Command("git", "clone", repoURL, cloneDir)
    51| 	log.Printf("git cloning into %q", cloneDir)
    52| 	if output, err := cloneCmd.CombinedOutput(); err != nil {
    53| 		return fmt.Errorf("failed to clone repository: %v: %s", err, string(output))
    54| 	}
    55| 	return nil
    56| }
    57| func (g GithubClient) CreateAtlantisWebhook(ctx context.Context, hookURL string) (int64, error) {
    58| 	contentType := "json"
    59| 	hookConfig := &github.HookConfig{
    60| 		ContentType: &contentType,
    61| 		URL:         &hookURL,
    62| 	}
    63| 	atlantisHook := &github.Hook{
    64| 		Events: []string{"issue_comment", "pull_request", "push"},
    65| 		Config: hookConfig,
    66| 		Active: github.Bool(true),
    67| 	}
    68| 	hook, _, err := g.client.Repositories.CreateHook(ctx, g.ownerName, g.repoName, atlantisHook)
    69| 	if err != nil {
    70| 		return 0, err
    71| 	}
    72| 	log.Println(hook.GetURL())
    73| 	return hook.GetID(), nil
    74| }
    75| func (g GithubClient) DeleteAtlantisHook(ctx context.Context, hookID int64) error {
    76| 	_, err := g.client.Repositories.DeleteHook(ctx, g.ownerName, g.repoName, hookID)
    77| 	if err != nil {
    78| 		return err
    79| 	}
    80| 	log.Printf("deleted webhook id %d", hookID)
    81| 	return nil
    82| }
    83| func (g GithubClient) CreatePullRequest(ctx context.Context, title, branchName string) (string, int, error) {
    84| 	head := fmt.Sprintf("%s:%s", g.ownerName, branchName)
    85| 	body := ""


# ====================================================================
# FILE: runatlantis.io/.vitepress/sidebars.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 20-60 ---
    20|           { text: "Installing Guide", link: "/docs/installation-guide" },
    21|           { text: "Requirements", link: "/docs/requirements" },
    22|           { text: "Git Host Access Credentials", link: "/docs/access-credentials" },
    23|           { text: "Webhook Secrets", link: "/docs/webhook-secrets" },
    24|           { text: "Deployment", link: "/docs/deployment" },
    25|           { text: "Configuring Webhooks", link: "/docs/configuring-webhooks" },
    26|           { text: "Provider Credentials", link: "/docs/provider-credentials" },
    27|         ]
    28|       },
    29|       {
    30|         text: "Configuring Atlantis",
    31|         collapsed: true,
    32|         items: [
    33|           { text: "Overview", link: "/docs/configuring-atlantis" },
    34|           { text: "Server Configuration", link: "/docs/server-configuration" },
    35|           { text: "Server Side Repo Config", link: "/docs/server-side-repo-config" },
    36|           { text: "Pre Workflow Hooks", link: "/docs/pre-workflow-hooks" },
    37|           { text: "Post Workflow Hooks", link: "/docs/post-workflow-hooks" },
    38|           { text: "Conftest Policy Checking", link: "/docs/policy-checking" },
    39|           { text: "Custom Workflows", link: "/docs/custom-workflows" },
    40|           { text: "Repo and Project Permissions", link: "/docs/repo-and-project-permissions" },
    41|           { text: "Repo Level atlantis.yaml", link: "/docs/repo-level-atlantis-yaml" },
    42|           { text: "Upgrading atlantis.yaml", link: "/docs/upgrading-atlantis-yaml" },
    43|           { text: "Command Requirements", link: "/docs/command-requirements" },
    44|           { text: "Checkout Strategy", link: "/docs/checkout-strategy" },
    45|           { text: "Terraform Versions", link: "/docs/terraform-versions" },
    46|           { text: "Terraform Cloud", link: "/docs/terraform-cloud" },
    47|           { text: "Using Slack Hooks", link: "/docs/using-slack-hooks" },
    48|           { text: "Stats", link: "/docs/stats" },
    49|           { text: "FAQ", link: "/docs/faq" },
    50|         ]
    51|       },
    52|       {
    53|         text: "Using Atlantis",
    54|         collapsed: true,
    55|         items: [
    56|           { text: "Overview", link: "/docs/using-atlantis" },
    57|           { text: "API endpoints", link: "/docs/api-endpoints" },
    58|         ]
    59|       },
    60|       {


# ====================================================================
# FILE: scripts/pin_ci_terraform_providers.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| RANDOM_PROVIDER_VERSION="3.6.1"
     2| NULL_PROVIDER_VERSION="3.2.3"
     3| TEST_REPOS_DIR="server/controllers/events/testdata/test-repos"
     4| for file in $(find $TEST_REPOS_DIR -name '*.tf')
     5| do
     6|     basename=$(basename $file)
     7|     if [[ "$basename" == "versions.tf" ]]
     8|     then
     9|         continue
    10|     fi
    11|     if [[ "$basename" != "main.tf" ]]
    12|     then
    13|         echo "Found unexpected file: $file"
    14|         exit 1
    15|     fi
    16|     has_null_provider=false
    17|     has_random_provider=false
    18|     version_file="$(dirname $file)/versions.tf"
    19|     for resource in $(cat $file | grep '^resource' | awk '{print $2}' | tr -d '"')
    20|     do
    21|         if [[ "$resource" == "null_resource" ]]
    22|         then


# ====================================================================
# FILE: server/controllers/events/events_controller.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package events
     2| import (
     3| 	"encoding/json"
     4| 	"fmt"
     5| 	"io"
     6| 	"net/http"
     7| 	"strings"
     8| 	"github.com/google/go-github/v63/github"
     9| 	"github.com/mcdafydd/go-azuredevops/azuredevops"
    10| 	"github.com/microcosm-cc/bluemonday"
    11| 	"github.com/pkg/errors"
    12| 	"github.com/runatlantis/atlantis/server/events"
    13| 	"github.com/runatlantis/atlantis/server/events/models"
    14| 	"github.com/runatlantis/atlantis/server/events/vcs"
    15| 	"github.com/runatlantis/atlantis/server/events/vcs/bitbucketcloud"
    16| 	"github.com/runatlantis/atlantis/server/events/vcs/bitbucketserver"
    17| 	"github.com/runatlantis/atlantis/server/events/vcs/gitea"
    18| 	"github.com/runatlantis/atlantis/server/logging"
    19| 	tally "github.com/uber-go/tally/v4"
    20| 	gitlab "github.com/xanzy/go-gitlab"
    21| )
    22| const githubHeader = "X-Github-Event"
    23| const gitlabHeader = "X-Gitlab-Event"
    24| const azuredevopsHeader = "Request-Id"
    25| const giteaHeader = "X-Gitea-Event"
    26| const giteaEventTypeHeader = "X-Gitea-Event-Type"
    27| const giteaSignatureHeader = "X-Gitea-Signature"
    28| const giteaRequestIDHeader = "X-Gitea-Delivery"


# ====================================================================
# FILE: server/controllers/events/github_request_validator.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package events
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"io"
     6| 	"net/http"
     7| 	"github.com/google/go-github/v63/github"
     8| )
     9| type GithubRequestValidator interface {
    10| 	Validate(r *http.Request, secret []byte) ([]byte, error)
    11| }
    12| type DefaultGithubRequestValidator struct{}
    13| func (d *DefaultGithubRequestValidator) Validate(r *http.Request, secret []byte) ([]byte, error) {
    14| 	if len(secret) != 0 {
    15| 		return d.validateAgainstSecret(r, secret)
    16| 	}
    17| 	return d.validateWithoutSecret(r)
    18| }
    19| func (d *DefaultGithubRequestValidator) validateAgainstSecret(r *http.Request, secret []byte) ([]byte, error) {
    20| 	payload, err := github.ValidatePayload(r, secret)
    21| 	if err != nil {
    22| 		return nil, err
    23| 	}
    24| 	return payload, nil
    25| }
    26| func (d *DefaultGithubRequestValidator) validateWithoutSecret(r *http.Request) ([]byte, error) {
    27| 	switch ct := r.Header.Get("Content-Type"); ct {


# ====================================================================
# FILE: server/controllers/github_app_controller.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 83-123 ---
    83| 		Events: []string{
    84| 			"check_run",
    85| 			"create",
    86| 			"delete",
    87| 			"issue_comment",
    88| 			"issues",
    89| 			"pull_request_review_comment",
    90| 			"pull_request_review",
    91| 			"pull_request",
    92| 			"push",
    93| 		},
    94| 		Permissions: map[string]string{
    95| 			"checks":           "write",
    96| 			"contents":         "write",
    97| 			"issues":           "write",
    98| 			"pull_requests":    "write",
    99| 			"repository_hooks": "write",
   100| 			"statuses":         "write",
   101| 			"administration":   "read",
   102| 			"members":          "read",
   103| 			"actions":          "read",
   104| 		},
   105| 	}
   106| 	url := &url.URL{
   107| 		Scheme: "https",
   108| 		Host:   g.GithubHostname,
   109| 		Path:   "/settings/apps/new",
   110| 	}
   111| 	if g.GithubOrg != "" {
   112| 		url.Path = fmt.Sprintf("organizations/%s%s", g.GithubOrg, url.Path)
   113| 	}
   114| 	jsonManifest, err := json.MarshalIndent(manifest, "", " ")
   115| 	if err != nil {
   116| 		g.respond(w, logging.Error, http.StatusBadRequest, "Failed to serialize manifest: %s", err)
   117| 		return
   118| 	}
   119| 	err = web_templates.GithubAppSetupTemplate.Execute(w, web_templates.GithubSetupData{
   120| 		Target:   url.String(),
   121| 		Manifest: string(jsonManifest),
   122| 	})
   123| 	if err != nil {


# ====================================================================
# FILE: server/core/config/raw/global_cfg.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| package raw
     2| import (
     3| 	"fmt"
     4| 	"regexp"
     5| 	"strings"
     6| 	validation "github.com/go-ozzo/ozzo-validation"
     7| 	"github.com/pkg/errors"
     8| 	"github.com/runatlantis/atlantis/server/core/config/valid"
     9| 	"github.com/runatlantis/atlantis/server/utils"
    10| )
    11| type GlobalCfg struct {
    12| 	Repos      []Repo              `yaml:"repos" json:"repos"`
    13| 	Workflows  map[string]Workflow `yaml:"workflows" json:"workflows"`
    14| 	PolicySets PolicySets          `yaml:"policies" json:"policies"`
    15| 	Metrics    Metrics             `yaml:"metrics" json:"metrics"`
    16| 	TeamAuthz  TeamAuthz           `yaml:"team_authz" json:"team_authz"`
    17| }
    18| type Repo struct {
    19| 	ID                        string         `yaml:"id" json:"id"`
    20| 	Branch                    string         `yaml:"branch" json:"branch"`
    21| 	RepoConfigFile            string         `yaml:"repo_config_file" json:"repo_config_file"`
    22| 	PlanRequirements          []string       `yaml:"plan_requirements" json:"plan_requirements"`
    23| 	ApplyRequirements         []string       `yaml:"apply_requirements" json:"apply_requirements"`
    24| 	ImportRequirements        []string       `yaml:"import_requirements" json:"import_requirements"`
    25| 	PreWorkflowHooks          []WorkflowHook `yaml:"pre_workflow_hooks" json:"pre_workflow_hooks"`
    26| 	Workflow                  *string        `yaml:"workflow,omitempty" json:"workflow,omitempty"`
    27| 	PostWorkflowHooks         []WorkflowHook `yaml:"post_workflow_hooks" json:"post_workflow_hooks"`
    28| 	AllowedWorkflows          []string       `yaml:"allowed_workflows,omitempty" json:"allowed_workflows,omitempty"`
    29| 	AllowedOverrides          []string       `yaml:"allowed_overrides" json:"allowed_overrides"`
    30| 	AllowCustomWorkflows      *bool          `yaml:"allow_custom_workflows,omitempty" json:"allow_custom_workflows,omitempty"`
    31| 	DeleteSourceBranchOnMerge *bool          `yaml:"delete_source_branch_on_merge,omitempty" json:"delete_source_branch_on_merge,omitempty"`
    32| 	RepoLocking               *bool          `yaml:"repo_locking,omitempty" json:"repo_locking,omitempty"`
    33| 	RepoLocks                 *RepoLocks     `yaml:"repo_locks,omitempty" json:"repo_locks,omitempty"`
    34| 	PolicyCheck               *bool          `yaml:"policy_check,omitempty" json:"policy_check,omitempty"`
    35| 	CustomPolicyCheck         *bool          `yaml:"custom_policy_check,omitempty" json:"custom_policy_check,omitempty"`
    36| 	AutoDiscover              *AutoDiscover  `yaml:"autodiscover,omitempty" json:"autodiscover,omitempty"`

# --- HUNK 2: Lines 119-159 ---
   119| 		workflows[k] = validatedWorkflow
   120| 		if k == valid.DefaultWorkflowName {
   121| 			defaultCfg.Repos[0].Workflow = &validatedWorkflow
   122| 		}
   123| 	}
   124| 	for k, v := range defaultCfg.Workflows {
   125| 		if _, ok := workflows[k]; !ok {
   126| 			workflows[k] = v
   127| 		}
   128| 	}
   129| 	var repos []valid.Repo
   130| 	for _, r := range g.Repos {
   131| 		repos = append(repos, r.ToValid(workflows, globalPlanReqs, globalApplyReqs, globalImportReqs))
   132| 	}
   133| 	repos = append(defaultCfg.Repos, repos...)
   134| 	return valid.GlobalCfg{
   135| 		Repos:      repos,
   136| 		Workflows:  workflows,
   137| 		PolicySets: g.PolicySets.ToValid(),
   138| 		Metrics:    g.Metrics.ToValid(),
   139| 		TeamAuthz:  g.TeamAuthz.ToValid(),
   140| 	}
   141| }
   142| func (r Repo) HasRegexID() bool {
   143| 	return strings.HasPrefix(r.ID, "/") && strings.HasSuffix(r.ID, "/")
   144| }
   145| func (r Repo) HasRegexBranch() bool {
   146| 	return strings.HasPrefix(r.Branch, "/") && strings.HasSuffix(r.Branch, "/")
   147| }
   148| func (r Repo) Validate() error {
   149| 	idValid := func(value interface{}) error {
   150| 		id := value.(string)
   151| 		if !r.HasRegexID() {
   152| 			return nil
   153| 		}
   154| 		_, err := regexp.Compile(id[1 : len(id)-1])
   155| 		return errors.Wrapf(err, "parsing: %s", id)
   156| 	}
   157| 	branchValid := func(value interface{}) error {
   158| 		branch := value.(string)
   159| 		if branch == "" {


# ====================================================================
# FILE: server/core/config/raw/policies.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 39-79 ---
    39| type PolicyOwners struct {
    40| 	Users []string `yaml:"users,omitempty" json:"users,omitempty"`
    41| 	Teams []string `yaml:"teams,omitempty" json:"teams,omitempty"`
    42| }
    43| func (o PolicyOwners) ToValid() valid.PolicyOwners {
    44| 	var policyOwners valid.PolicyOwners
    45| 	if len(o.Users) > 0 {
    46| 		policyOwners.Users = o.Users
    47| 	}
    48| 	if len(o.Teams) > 0 {
    49| 		policyOwners.Teams = o.Teams
    50| 	}
    51| 	return policyOwners
    52| }
    53| type PolicySet struct {
    54| 	Path               string       `yaml:"path" json:"path"`
    55| 	Source             string       `yaml:"source" json:"source"`
    56| 	Name               string       `yaml:"name" json:"name"`
    57| 	Owners             PolicyOwners `yaml:"owners,omitempty" json:"owners,omitempty"`
    58| 	ApproveCount       int          `yaml:"approve_count,omitempty" json:"approve_count,omitempty"`
    59| 	PreventSelfApprove bool         `yaml:"prevent_self_approve,omitempty" json:"prevent_self_approve,omitempty"`
    60| }
    61| func (p PolicySet) Validate() error {
    62| 	return validation.ValidateStruct(&p,
    63| 		validation.Field(&p.Name, validation.Required.Error("is required")),
    64| 		validation.Field(&p.Owners),
    65| 		validation.Field(&p.ApproveCount),
    66| 		validation.Field(&p.Path, validation.Required.Error("is required")),
    67| 		validation.Field(&p.Source, validation.In(valid.LocalPolicySet, valid.GithubPolicySet).Error("only 'local' and 'github' source types are supported")),
    68| 	)
    69| }
    70| func (p PolicySet) ToValid() valid.PolicySet {
    71| 	var policySet valid.PolicySet
    72| 	policySet.Name = p.Name
    73| 	policySet.Path = p.Path
    74| 	policySet.Source = p.Source
    75| 	policySet.ApproveCount = p.ApproveCount
    76| 	policySet.PreventSelfApprove = p.PreventSelfApprove
    77| 	policySet.Owners = p.Owners.ToValid()
    78| 	return policySet
    79| }


# ====================================================================
# FILE: server/core/config/raw/team_authz.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| package raw
     2| import "github.com/runatlantis/atlantis/server/core/config/valid"
     3| type TeamAuthz struct {
     4| 	Command string   `yaml:"command" json:"command"`
     5| 	Args    []string `yaml:"args" json:"args"`
     6| }
     7| func (t *TeamAuthz) ToValid() valid.TeamAuthz {
     8| 	var v valid.TeamAuthz
     9| 	v.Command = t.Command
    10| 	v.Args = make([]string, 0)
    11| 	if t.Args != nil {
    12| 		v.Args = append(v.Args, t.Args...)
    13| 	}
    14| 	return v
    15| }


# ====================================================================
# FILE: server/core/config/valid/global_cfg.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 16-56 ---
    16| const ImportRequirementsKey = "import_requirements"
    17| const WorkflowKey = "workflow"
    18| const AllowedOverridesKey = "allowed_overrides"
    19| const AllowCustomWorkflowsKey = "allow_custom_workflows"
    20| const DefaultWorkflowName = "default"
    21| const DeleteSourceBranchOnMergeKey = "delete_source_branch_on_merge"
    22| const RepoLockingKey = "repo_locking"
    23| const RepoLocksKey = "repo_locks"
    24| const PolicyCheckKey = "policy_check"
    25| const CustomPolicyCheckKey = "custom_policy_check"
    26| const AutoDiscoverKey = "autodiscover"
    27| const SilencePRCommentsKey = "silence_pr_comments"
    28| var AllowedSilencePRComments = []string{"plan", "apply"}
    29| const DefaultAtlantisFile = "atlantis.yaml"
    30| var NonOverrideableApplyReqs = []string{PoliciesPassedCommandReq}
    31| type GlobalCfg struct {
    32| 	Repos      []Repo
    33| 	Workflows  map[string]Workflow
    34| 	PolicySets PolicySets
    35| 	Metrics    Metrics
    36| 	TeamAuthz  TeamAuthz
    37| }
    38| type Metrics struct {
    39| 	Statsd     *Statsd
    40| 	Prometheus *Prometheus
    41| }
    42| type Statsd struct {
    43| 	Port string
    44| 	Host string
    45| }
    46| type Prometheus struct {
    47| 	Endpoint string
    48| }
    49| type Repo struct {
    50| 	ID string
    51| 	IDRegex                   *regexp.Regexp
    52| 	BranchRegex               *regexp.Regexp
    53| 	RepoConfigFile            string
    54| 	PlanRequirements          []string
    55| 	ApplyRequirements         []string
    56| 	ImportRequirements        []string

# --- HUNK 2: Lines 187-229 ---
   187| 				RepoConfigFile:            args.RepoConfigFile,
   188| 				PlanRequirements:          commandReqs,
   189| 				ApplyRequirements:         commandReqs,
   190| 				ImportRequirements:        commandReqs,
   191| 				PreWorkflowHooks:          args.PreWorkflowHooks,
   192| 				Workflow:                  &defaultWorkflow,
   193| 				PostWorkflowHooks:         args.PostWorkflowHooks,
   194| 				AllowedWorkflows:          allowedWorkflows,
   195| 				AllowedOverrides:          allowedOverrides,
   196| 				AllowCustomWorkflows:      &allowCustomWorkflows,
   197| 				DeleteSourceBranchOnMerge: &deleteSourceBranchOnMerge,
   198| 				RepoLocks:                 &repoLocks,
   199| 				PolicyCheck:               &policyCheck,
   200| 				CustomPolicyCheck:         &customPolicyCheck,
   201| 				AutoDiscover:              &autoDiscover,
   202| 				SilencePRComments:         silencePRComments,
   203| 			},
   204| 		},
   205| 		Workflows: map[string]Workflow{
   206| 			DefaultWorkflowName: defaultWorkflow,
   207| 		},
   208| 		TeamAuthz: TeamAuthz{
   209| 			Args: make([]string, 0),
   210| 		},
   211| 	}
   212| }
   213| func (r Repo) IDMatches(otherID string) bool {
   214| 	if r.ID != "" {
   215| 		return r.ID == otherID
   216| 	}
   217| 	return r.IDRegex.MatchString(otherID)
   218| }
   219| func (r Repo) BranchMatches(other string) bool {
   220| 	if r.BranchRegex == nil {
   221| 		return true
   222| 	}
   223| 	return r.BranchRegex.MatchString(other)
   224| }
   225| func (r Repo) IDString() string {
   226| 	if r.ID != "" {
   227| 		return r.ID
   228| 	}
   229| 	return "/" + r.IDRegex.String() + "/"


# ====================================================================
# FILE: server/core/config/valid/team_authz.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| package valid
     2| type TeamAuthz struct {
     3| 	Command string   `yaml:"command" json:"command"`
     4| 	Args    []string `yaml:"args" json:"args"`
     5| }


# ====================================================================
# FILE: server/core/runtime/external_team_allowlist_runner.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| package runtime
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"os"
     6| 	"os/exec"
     7| 	"strings"
     8| 	"github.com/runatlantis/atlantis/server/events/models"
     9| )
    10| type ExternalTeamAllowlistRunner interface {
    11| 	Run(ctx models.TeamAllowlistCheckerContext, shell, shellArgs, command string) (string, error)
    12| }
    13| type DefaultExternalTeamAllowlistRunner struct{}
    14| func (r DefaultExternalTeamAllowlistRunner) Run(ctx models.TeamAllowlistCheckerContext, shell, shellArgs, command string) (string, error) {
    15| 	shellArgsSlice := append(strings.Split(shellArgs, " "), command)
    16| 	cmd := exec.CommandContext(context.TODO(), shell, shellArgsSlice...) // #nosec
    17| 	baseEnvVars := os.Environ()
    18| 	customEnvVars := map[string]string{
    19| 		"BASE_BRANCH_NAME": ctx.Pull.BaseBranch,
    20| 		"BASE_REPO_NAME":   ctx.BaseRepo.Name,
    21| 		"BASE_REPO_OWNER":  ctx.BaseRepo.Owner,
    22| 		"COMMENT_ARGS":     strings.Join(ctx.EscapedCommentArgs, ","),
    23| 		"HEAD_BRANCH_NAME": ctx.Pull.HeadBranch,
    24| 		"HEAD_COMMIT":      ctx.Pull.HeadCommit,
    25| 		"HEAD_REPO_NAME":   ctx.HeadRepo.Name,
    26| 		"HEAD_REPO_OWNER":  ctx.HeadRepo.Owner,
    27| 		"PULL_AUTHOR":      ctx.Pull.Author,
    28| 		"PULL_NUM":         fmt.Sprintf("%d", ctx.Pull.Num),
    29| 		"PULL_URL":         ctx.Pull.URL,
    30| 		"USER_NAME":        ctx.User.Username,
    31| 		"COMMAND_NAME":     ctx.CommandName,
    32| 		"PROJECT_NAME":     ctx.ProjectName,
    33| 		"REPO_ROOT":        ctx.RepoDir,
    34| 		"REPO_REL_PATH":    ctx.RepoRelDir,
    35| 	}
    36| 	finalEnvVars := baseEnvVars
    37| 	for key, val := range customEnvVars {
    38| 		finalEnvVars = append(finalEnvVars, fmt.Sprintf("%s=%s", key, val))
    39| 	}
    40| 	cmd.Env = finalEnvVars
    41| 	out, err := cmd.CombinedOutput()
    42| 	if err != nil {
    43| 		err = fmt.Errorf("%s: running %q: \n%s", err, shell+" "+shellArgs+" "+command, out)
    44| 		ctx.Log.Debug("error: %s", err)
    45| 		return string(out), err
    46| 	}
    47| 	return strings.TrimSpace(string(out)), nil
    48| }


# ====================================================================
# FILE: server/core/runtime/mocks/mock_external_team_allowlist_runner.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-112 ---
     1| package mocks
     2| import (
     3| 	pegomock "github.com/petergtz/pegomock/v4"
     4| 	models "github.com/runatlantis/atlantis/server/events/models"
     5| 	"reflect"
     6| 	"time"
     7| )
     8| type MockExternalTeamAllowlistRunner struct {
     9| 	fail func(message string, callerSkip ...int)
    10| }
    11| func NewMockExternalTeamAllowlistRunner(options ...pegomock.Option) *MockExternalTeamAllowlistRunner {
    12| 	mock := &MockExternalTeamAllowlistRunner{}
    13| 	for _, option := range options {
    14| 		option.Apply(mock)
    15| 	}
    16| 	return mock
    17| }
    18| func (mock *MockExternalTeamAllowlistRunner) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    19| func (mock *MockExternalTeamAllowlistRunner) FailHandler() pegomock.FailHandler      { return mock.fail }
    20| func (mock *MockExternalTeamAllowlistRunner) Run(ctx models.TeamAllowlistCheckerContext, shell string, shellArgs string, command string) (string, error) {
    21| 	if mock == nil {
    22| 		panic("mock must not be nil. Use myMock := NewMockExternalTeamAllowlistRunner().")
    23| 	}
    24| 	_params := []pegomock.Param{ctx, shell, shellArgs, command}
    25| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("Run", _params, []reflect.Type{reflect.TypeOf((*string)(nil)).Elem(), reflect.TypeOf((*error)(nil)).Elem()})
    26| 	var _ret0 string
    27| 	var _ret1 error
    28| 	if len(_result) != 0 {
    29| 		if _result[0] != nil {
    30| 			_ret0 = _result[0].(string)
    31| 		}
    32| 		if _result[1] != nil {
    33| 			_ret1 = _result[1].(error)
    34| 		}
    35| 	}
    36| 	return _ret0, _ret1
    37| }
    38| func (mock *MockExternalTeamAllowlistRunner) VerifyWasCalledOnce() *VerifierMockExternalTeamAllowlistRunner {
    39| 	return &VerifierMockExternalTeamAllowlistRunner{
    40| 		mock:                   mock,
    41| 		invocationCountMatcher: pegomock.Times(1),
    42| 	}
    43| }
    44| func (mock *MockExternalTeamAllowlistRunner) VerifyWasCalled(invocationCountMatcher pegomock.InvocationCountMatcher) *VerifierMockExternalTeamAllowlistRunner {
    45| 	return &VerifierMockExternalTeamAllowlistRunner{
    46| 		mock:                   mock,
    47| 		invocationCountMatcher: invocationCountMatcher,
    48| 	}
    49| }
    50| func (mock *MockExternalTeamAllowlistRunner) VerifyWasCalledInOrder(invocationCountMatcher pegomock.InvocationCountMatcher, inOrderContext *pegomock.InOrderContext) *VerifierMockExternalTeamAllowlistRunner {
    51| 	return &VerifierMockExternalTeamAllowlistRunner{
    52| 		mock:                   mock,
    53| 		invocationCountMatcher: invocationCountMatcher,
    54| 		inOrderContext:         inOrderContext,
    55| 	}
    56| }
    57| func (mock *MockExternalTeamAllowlistRunner) VerifyWasCalledEventually(invocationCountMatcher pegomock.InvocationCountMatcher, timeout time.Duration) *VerifierMockExternalTeamAllowlistRunner {
    58| 	return &VerifierMockExternalTeamAllowlistRunner{
    59| 		mock:                   mock,
    60| 		invocationCountMatcher: invocationCountMatcher,
    61| 		timeout:                timeout,
    62| 	}
    63| }
    64| type VerifierMockExternalTeamAllowlistRunner struct {
    65| 	mock                   *MockExternalTeamAllowlistRunner
    66| 	invocationCountMatcher pegomock.InvocationCountMatcher
    67| 	inOrderContext         *pegomock.InOrderContext
    68| 	timeout                time.Duration
    69| }
    70| func (verifier *VerifierMockExternalTeamAllowlistRunner) Run(ctx models.TeamAllowlistCheckerContext, shell string, shellArgs string, command string) *MockExternalTeamAllowlistRunner_Run_OngoingVerification {
    71| 	_params := []pegomock.Param{ctx, shell, shellArgs, command}
    72| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "Run", _params, verifier.timeout)
    73| 	return &MockExternalTeamAllowlistRunner_Run_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
    74| }
    75| type MockExternalTeamAllowlistRunner_Run_OngoingVerification struct {
    76| 	mock              *MockExternalTeamAllowlistRunner
    77| 	methodInvocations []pegomock.MethodInvocation
    78| }
    79| func (c *MockExternalTeamAllowlistRunner_Run_OngoingVerification) GetCapturedArguments() (models.TeamAllowlistCheckerContext, string, string, string) {
    80| 	ctx, shell, shellArgs, command := c.GetAllCapturedArguments()
    81| 	return ctx[len(ctx)-1], shell[len(shell)-1], shellArgs[len(shellArgs)-1], command[len(command)-1]
    82| }
    83| func (c *MockExternalTeamAllowlistRunner_Run_OngoingVerification) GetAllCapturedArguments() (_param0 []models.TeamAllowlistCheckerContext, _param1 []string, _param2 []string, _param3 []string) {
    84| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
    85| 	if len(_params) > 0 {
    86| 		if len(_params) > 0 {
    87| 			_param0 = make([]models.TeamAllowlistCheckerContext, len(c.methodInvocations))
    88| 			for u, param := range _params[0] {
    89| 				_param0[u] = param.(models.TeamAllowlistCheckerContext)
    90| 			}
    91| 		}
    92| 		if len(_params) > 1 {
    93| 			_param1 = make([]string, len(c.methodInvocations))
    94| 			for u, param := range _params[1] {
    95| 				_param1[u] = param.(string)
    96| 			}
    97| 		}
    98| 		if len(_params) > 2 {
    99| 			_param2 = make([]string, len(c.methodInvocations))
   100| 			for u, param := range _params[2] {
   101| 				_param2[u] = param.(string)
   102| 			}
   103| 		}
   104| 		if len(_params) > 3 {
   105| 			_param3 = make([]string, len(c.methodInvocations))
   106| 			for u, param := range _params[3] {
   107| 				_param3[u] = param.(string)
   108| 			}
   109| 		}
   110| 	}
   111| 	return
   112| }


# ====================================================================
# FILE: server/core/runtime/policy/mocks/mock_downloader.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| package mocks
     2| import (
     3| 	pegomock "github.com/petergtz/pegomock/v4"
     4| 	"reflect"
     5| 	"time"
     6| )
     7| type MockDownloader struct {
     8| 	fail func(message string, callerSkip ...int)
     9| }
    10| func NewMockDownloader(options ...pegomock.Option) *MockDownloader {
    11| 	mock := &MockDownloader{}
    12| 	for _, option := range options {
    13| 		option.Apply(mock)
    14| 	}
    15| 	return mock
    16| }
    17| func (mock *MockDownloader) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    18| func (mock *MockDownloader) FailHandler() pegomock.FailHandler      { return mock.fail }
    19| func (mock *MockDownloader) GetAny(dst string, src string) error {
    20| 	if mock == nil {
    21| 		panic("mock must not be nil. Use myMock := NewMockDownloader().")
    22| 	}
    23| 	_params := []pegomock.Param{dst, src}
    24| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("GetAny", _params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
    25| 	var _ret0 error
    26| 	if len(_result) != 0 {
    27| 		if _result[0] != nil {
    28| 			_ret0 = _result[0].(error)
    29| 		}
    30| 	}
    31| 	return _ret0
    32| }
    33| func (mock *MockDownloader) VerifyWasCalledOnce() *VerifierMockDownloader {
    34| 	return &VerifierMockDownloader{
    35| 		mock:                   mock,
    36| 		invocationCountMatcher: pegomock.Times(1),
    37| 	}
    38| }
    39| func (mock *MockDownloader) VerifyWasCalled(invocationCountMatcher pegomock.InvocationCountMatcher) *VerifierMockDownloader {
    40| 	return &VerifierMockDownloader{
    41| 		mock:                   mock,
    42| 		invocationCountMatcher: invocationCountMatcher,
    43| 	}
    44| }
    45| func (mock *MockDownloader) VerifyWasCalledInOrder(invocationCountMatcher pegomock.InvocationCountMatcher, inOrderContext *pegomock.InOrderContext) *VerifierMockDownloader {
    46| 	return &VerifierMockDownloader{
    47| 		mock:                   mock,
    48| 		invocationCountMatcher: invocationCountMatcher,
    49| 		inOrderContext:         inOrderContext,
    50| 	}
    51| }
    52| func (mock *MockDownloader) VerifyWasCalledEventually(invocationCountMatcher pegomock.InvocationCountMatcher, timeout time.Duration) *VerifierMockDownloader {
    53| 	return &VerifierMockDownloader{
    54| 		mock:                   mock,
    55| 		invocationCountMatcher: invocationCountMatcher,
    56| 		timeout:                timeout,
    57| 	}
    58| }
    59| type VerifierMockDownloader struct {
    60| 	mock                   *MockDownloader
    61| 	invocationCountMatcher pegomock.InvocationCountMatcher
    62| 	inOrderContext         *pegomock.InOrderContext
    63| 	timeout                time.Duration
    64| }
    65| func (verifier *VerifierMockDownloader) GetAny(dst string, src string) *MockDownloader_GetAny_OngoingVerification {
    66| 	_params := []pegomock.Param{dst, src}
    67| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "GetAny", _params, verifier.timeout)
    68| 	return &MockDownloader_GetAny_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
    69| }
    70| type MockDownloader_GetAny_OngoingVerification struct {
    71| 	mock              *MockDownloader
    72| 	methodInvocations []pegomock.MethodInvocation
    73| }
    74| func (c *MockDownloader_GetAny_OngoingVerification) GetCapturedArguments() (string, string) {
    75| 	dst, src := c.GetAllCapturedArguments()
    76| 	return dst[len(dst)-1], src[len(src)-1]
    77| }
    78| func (c *MockDownloader_GetAny_OngoingVerification) GetAllCapturedArguments() (_param0 []string, _param1 []string) {
    79| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
    80| 	if len(_params) > 0 {
    81| 		if len(_params) > 0 {
    82| 			_param0 = make([]string, len(c.methodInvocations))
    83| 			for u, param := range _params[0] {
    84| 				_param0[u] = param.(string)
    85| 			}
    86| 		}
    87| 		if len(_params) > 1 {
    88| 			_param1 = make([]string, len(c.methodInvocations))
    89| 			for u, param := range _params[1] {
    90| 				_param1[u] = param.(string)
    91| 			}
    92| 		}
    93| 	}
    94| 	return
    95| }


# ====================================================================
# FILE: server/core/terraform/distribution.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-102 ---
     1| package terraform
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"sort"
     6| 	"github.com/hashicorp/go-version"
     7| 	"github.com/hashicorp/hc-install/product"
     8| 	"github.com/hashicorp/hc-install/releases"
     9| 	"github.com/opentofu/tofudl"
    10| )
    11| type Distribution interface {
    12| 	BinName() string
    13| 	Downloader() Downloader
    14| 	ResolveConstraint(context.Context, string) (*version.Version, error)
    15| }
    16| type DistributionOpenTofu struct {
    17| 	downloader Downloader
    18| }
    19| func NewDistributionOpenTofu() Distribution {
    20| 	return &DistributionOpenTofu{
    21| 		downloader: &TofuDownloader{},
    22| 	}
    23| }
    24| func NewDistributionOpenTofuWithDownloader(downloader Downloader) Distribution {
    25| 	return &DistributionOpenTofu{
    26| 		downloader: downloader,
    27| 	}
    28| }
    29| func (*DistributionOpenTofu) BinName() string {
    30| 	return "tofu"
    31| }
    32| func (d *DistributionOpenTofu) Downloader() Downloader {
    33| 	return d.downloader
    34| }
    35| func (*DistributionOpenTofu) ResolveConstraint(ctx context.Context, constraintStr string) (*version.Version, error) {
    36| 	dl, err := tofudl.New()
    37| 	if err != nil {
    38| 		return nil, err
    39| 	}
    40| 	vc, err := version.NewConstraint(constraintStr)
    41| 	if err != nil {
    42| 		return nil, fmt.Errorf("error parsing constraint string: %s", err)
    43| 	}
    44| 	allVersions, err := dl.ListVersions(ctx)
    45| 	if err != nil {
    46| 		return nil, fmt.Errorf("error listing OpenTofu versions: %s", err)
    47| 	}
    48| 	var versions []*version.Version
    49| 	for _, ver := range allVersions {
    50| 		v, err := version.NewVersion(string(ver.ID))
    51| 		if err != nil {
    52| 			return nil, err
    53| 		}
    54| 		if vc.Check(v) {
    55| 			versions = append(versions, v)
    56| 		}
    57| 	}
    58| 	sort.Sort(version.Collection(versions))
    59| 	if len(versions) == 0 {
    60| 		return nil, fmt.Errorf("no OpenTofu versions found for constraints %s", constraintStr)
    61| 	}
    62| 	version := versions[len(versions)-1]
    63| 	return version, nil
    64| }
    65| type DistributionTerraform struct {
    66| 	downloader Downloader
    67| }
    68| func NewDistributionTerraform() Distribution {
    69| 	return &DistributionTerraform{
    70| 		downloader: &TerraformDownloader{},
    71| 	}
    72| }
    73| func NewDistributionTerraformWithDownloader(downloader Downloader) Distribution {
    74| 	return &DistributionTerraform{
    75| 		downloader: downloader,
    76| 	}
    77| }
    78| func (*DistributionTerraform) BinName() string {
    79| 	return "terraform"
    80| }
    81| func (d *DistributionTerraform) Downloader() Downloader {
    82| 	return d.downloader
    83| }
    84| func (*DistributionTerraform) ResolveConstraint(ctx context.Context, constraintStr string) (*version.Version, error) {
    85| 	vc, err := version.NewConstraint(constraintStr)
    86| 	if err != nil {
    87| 		return nil, fmt.Errorf("error parsing constraint string: %s", err)
    88| 	}
    89| 	constrainedVersions := &releases.Versions{
    90| 		Product:     product.Terraform,
    91| 		Constraints: vc,
    92| 	}
    93| 	installCandidates, err := constrainedVersions.List(ctx)
    94| 	if err != nil {
    95| 		return nil, fmt.Errorf("error listing available versions: %s", err)
    96| 	}
    97| 	if len(installCandidates) == 0 {
    98| 		return nil, fmt.Errorf("no Terraform versions found for constraints %s", constraintStr)
    99| 	}
   100| 	versionDownloader := installCandidates[len(installCandidates)-1]
   101| 	return versionDownloader.(*releases.ExactVersion).Version, nil
   102| }


# ====================================================================
# FILE: server/core/terraform/downloader.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| package terraform
     2| import (
     3| 	"context"
     4| 	"os"
     5| 	"path/filepath"
     6| 	"github.com/hashicorp/go-version"
     7| 	install "github.com/hashicorp/hc-install"
     8| 	"github.com/hashicorp/hc-install/product"
     9| 	"github.com/hashicorp/hc-install/releases"
    10| 	"github.com/hashicorp/hc-install/src"
    11| 	"github.com/opentofu/tofudl"
    12| )
    13| type Downloader interface {
    14| 	Install(ctx context.Context, dir string, downloadURL string, v *version.Version) (string, error)
    15| }
    16| type TofuDownloader struct{}
    17| func (d *TofuDownloader) Install(ctx context.Context, dir string, _downloadURL string, v *version.Version) (string, error) {
    18| 	dl, err := tofudl.New()
    19| 	if err != nil {
    20| 		return "", err
    21| 	}
    22| 	binary, err := dl.Download(ctx, tofudl.DownloadOptVersion(tofudl.Version(v.String())))
    23| 	if err != nil {
    24| 		return "", err
    25| 	}
    26| 	file := filepath.Join(dir, "tofu"+v.String())
    27| 	if err := os.WriteFile(file, binary, 0755); /* #nosec G306 */ err != nil {
    28| 		return "", err
    29| 	}
    30| 	return file, nil
    31| }
    32| type TerraformDownloader struct{}
    33| func (d *TerraformDownloader) Install(ctx context.Context, dir string, downloadURL string, v *version.Version) (string, error) {
    34| 	installer := install.NewInstaller()
    35| 	execPath, err := installer.Install(ctx, []src.Installable{
    36| 		&releases.ExactVersion{
    37| 			Product:    product.Terraform,
    38| 			Version:    v,
    39| 			InstallDir: dir,
    40| 			ApiBaseURL: downloadURL,
    41| 		},
    42| 	})
    43| 	if err != nil {
    44| 		return "", err
    45| 	}
    46| 	newPath := filepath.Join(dir, "terraform"+v.String())
    47| 	if err := os.Rename(execPath, newPath); err != nil {
    48| 		return "", err
    49| 	}
    50| 	return newPath, nil
    51| }


# ====================================================================
# FILE: server/core/terraform/mocks/mock_downloader.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-113 ---
     1| package mocks
     2| import (
     3| 	context "context"
     4| 	go_version "github.com/hashicorp/go-version"
     5| 	pegomock "github.com/petergtz/pegomock/v4"
     6| 	"reflect"
     7| 	"time"
     8| )
     9| type MockDownloader struct {
    10| 	fail func(message string, callerSkip ...int)
    11| }
    12| func NewMockDownloader(options ...pegomock.Option) *MockDownloader {
    13| 	mock := &MockDownloader{}
    14| 	for _, option := range options {
    15| 		option.Apply(mock)
    16| 	}
    17| 	return mock
    18| }
    19| func (mock *MockDownloader) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    20| func (mock *MockDownloader) FailHandler() pegomock.FailHandler      { return mock.fail }
    21| func (mock *MockDownloader) Install(ctx context.Context, dir string, downloadURL string, v *go_version.Version) (string, error) {
    22| 	if mock == nil {
    23| 		panic("mock must not be nil. Use myMock := NewMockDownloader().")
    24| 	}
    25| 	_params := []pegomock.Param{ctx, dir, downloadURL, v}
    26| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("Install", _params, []reflect.Type{reflect.TypeOf((*string)(nil)).Elem(), reflect.TypeOf((*error)(nil)).Elem()})
    27| 	var _ret0 string
    28| 	var _ret1 error
    29| 	if len(_result) != 0 {
    30| 		if _result[0] != nil {
    31| 			_ret0 = _result[0].(string)
    32| 		}
    33| 		if _result[1] != nil {
    34| 			_ret1 = _result[1].(error)
    35| 		}
    36| 	}
    37| 	return _ret0, _ret1
    38| }
    39| func (mock *MockDownloader) VerifyWasCalledOnce() *VerifierMockDownloader {
    40| 	return &VerifierMockDownloader{
    41| 		mock:                   mock,
    42| 		invocationCountMatcher: pegomock.Times(1),
    43| 	}
    44| }
    45| func (mock *MockDownloader) VerifyWasCalled(invocationCountMatcher pegomock.InvocationCountMatcher) *VerifierMockDownloader {
    46| 	return &VerifierMockDownloader{
    47| 		mock:                   mock,
    48| 		invocationCountMatcher: invocationCountMatcher,
    49| 	}
    50| }
    51| func (mock *MockDownloader) VerifyWasCalledInOrder(invocationCountMatcher pegomock.InvocationCountMatcher, inOrderContext *pegomock.InOrderContext) *VerifierMockDownloader {
    52| 	return &VerifierMockDownloader{
    53| 		mock:                   mock,
    54| 		invocationCountMatcher: invocationCountMatcher,
    55| 		inOrderContext:         inOrderContext,
    56| 	}
    57| }
    58| func (mock *MockDownloader) VerifyWasCalledEventually(invocationCountMatcher pegomock.InvocationCountMatcher, timeout time.Duration) *VerifierMockDownloader {
    59| 	return &VerifierMockDownloader{
    60| 		mock:                   mock,
    61| 		invocationCountMatcher: invocationCountMatcher,
    62| 		timeout:                timeout,
    63| 	}
    64| }
    65| type VerifierMockDownloader struct {
    66| 	mock                   *MockDownloader
    67| 	invocationCountMatcher pegomock.InvocationCountMatcher
    68| 	inOrderContext         *pegomock.InOrderContext
    69| 	timeout                time.Duration
    70| }
    71| func (verifier *VerifierMockDownloader) Install(ctx context.Context, dir string, downloadURL string, v *go_version.Version) *MockDownloader_Install_OngoingVerification {
    72| 	_params := []pegomock.Param{ctx, dir, downloadURL, v}
    73| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "Install", _params, verifier.timeout)
    74| 	return &MockDownloader_Install_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
    75| }
    76| type MockDownloader_Install_OngoingVerification struct {
    77| 	mock              *MockDownloader
    78| 	methodInvocations []pegomock.MethodInvocation
    79| }
    80| func (c *MockDownloader_Install_OngoingVerification) GetCapturedArguments() (context.Context, string, string, *go_version.Version) {
    81| 	ctx, dir, downloadURL, v := c.GetAllCapturedArguments()
    82| 	return ctx[len(ctx)-1], dir[len(dir)-1], downloadURL[len(downloadURL)-1], v[len(v)-1]
    83| }
    84| func (c *MockDownloader_Install_OngoingVerification) GetAllCapturedArguments() (_param0 []context.Context, _param1 []string, _param2 []string, _param3 []*go_version.Version) {
    85| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
    86| 	if len(_params) > 0 {
    87| 		if len(_params) > 0 {
    88| 			_param0 = make([]context.Context, len(c.methodInvocations))
    89| 			for u, param := range _params[0] {
    90| 				_param0[u] = param.(context.Context)
    91| 			}
    92| 		}
    93| 		if len(_params) > 1 {
    94| 			_param1 = make([]string, len(c.methodInvocations))
    95| 			for u, param := range _params[1] {
    96| 				_param1[u] = param.(string)
    97| 			}
    98| 		}
    99| 		if len(_params) > 2 {
   100| 			_param2 = make([]string, len(c.methodInvocations))
   101| 			for u, param := range _params[2] {
   102| 				_param2[u] = param.(string)
   103| 			}
   104| 		}
   105| 		if len(_params) > 3 {
   106| 			_param3 = make([]*go_version.Version, len(c.methodInvocations))
   107| 			for u, param := range _params[3] {
   108| 				_param3[u] = param.(*go_version.Version)
   109| 			}
   110| 		}
   111| 	}
   112| 	return
   113| }


# ====================================================================
# FILE: server/core/terraform/mocks/mock_terraform_client.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 6-216 ---
     6| 	logging "github.com/runatlantis/atlantis/server/logging"
     7| 	"reflect"
     8| 	"time"
     9| )
    10| type MockClient struct {
    11| 	fail func(message string, callerSkip ...int)
    12| }
    13| func NewMockClient(options ...pegomock.Option) *MockClient {
    14| 	mock := &MockClient{}
    15| 	for _, option := range options {
    16| 		option.Apply(mock)
    17| 	}
    18| 	return mock
    19| }
    20| func (mock *MockClient) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    21| func (mock *MockClient) FailHandler() pegomock.FailHandler      { return mock.fail }
    22| func (mock *MockClient) DetectVersion(log logging.SimpleLogging, projectDirectory string) *go_version.Version {
    23| 	if mock == nil {
    24| 		panic("mock must not be nil. Use myMock := NewMockClient().")
    25| 	}
    26| 	_params := []pegomock.Param{log, projectDirectory}
    27| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("DetectVersion", _params, []reflect.Type{reflect.TypeOf((**go_version.Version)(nil)).Elem()})
    28| 	var _ret0 *go_version.Version
    29| 	if len(_result) != 0 {
    30| 		if _result[0] != nil {
    31| 			_ret0 = _result[0].(*go_version.Version)
    32| 		}
    33| 	}
    34| 	return _ret0
    35| }
    36| func (mock *MockClient) EnsureVersion(log logging.SimpleLogging, v *go_version.Version) error {
    37| 	if mock == nil {
    38| 		panic("mock must not be nil. Use myMock := NewMockClient().")
    39| 	}
    40| 	_params := []pegomock.Param{log, v}
    41| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("EnsureVersion", _params, []reflect.Type{reflect.TypeOf((*error)(nil)).Elem()})
    42| 	var _ret0 error
    43| 	if len(_result) != 0 {
    44| 		if _result[0] != nil {
    45| 			_ret0 = _result[0].(error)
    46| 		}
    47| 	}
    48| 	return _ret0
    49| }
    50| func (mock *MockClient) RunCommandWithVersion(ctx command.ProjectContext, path string, args []string, envs map[string]string, v *go_version.Version, workspace string) (string, error) {
    51| 	if mock == nil {
    52| 		panic("mock must not be nil. Use myMock := NewMockClient().")
    53| 	}
    54| 	_params := []pegomock.Param{ctx, path, args, envs, v, workspace}
    55| 	_result := pegomock.GetGenericMockFrom(mock).Invoke("RunCommandWithVersion", _params, []reflect.Type{reflect.TypeOf((*string)(nil)).Elem(), reflect.TypeOf((*error)(nil)).Elem()})
    56| 	var _ret0 string
    57| 	var _ret1 error
    58| 	if len(_result) != 0 {
    59| 		if _result[0] != nil {
    60| 			_ret0 = _result[0].(string)
    61| 		}
    62| 		if _result[1] != nil {
    63| 			_ret1 = _result[1].(error)
    64| 		}
    65| 	}
    66| 	return _ret0, _ret1
    67| }
    68| func (mock *MockClient) VerifyWasCalledOnce() *VerifierMockClient {
    69| 	return &VerifierMockClient{
    70| 		mock:                   mock,
    71| 		invocationCountMatcher: pegomock.Times(1),
    72| 	}
    73| }
    74| func (mock *MockClient) VerifyWasCalled(invocationCountMatcher pegomock.InvocationCountMatcher) *VerifierMockClient {
    75| 	return &VerifierMockClient{
    76| 		mock:                   mock,
    77| 		invocationCountMatcher: invocationCountMatcher,
    78| 	}
    79| }
    80| func (mock *MockClient) VerifyWasCalledInOrder(invocationCountMatcher pegomock.InvocationCountMatcher, inOrderContext *pegomock.InOrderContext) *VerifierMockClient {
    81| 	return &VerifierMockClient{
    82| 		mock:                   mock,
    83| 		invocationCountMatcher: invocationCountMatcher,
    84| 		inOrderContext:         inOrderContext,
    85| 	}
    86| }
    87| func (mock *MockClient) VerifyWasCalledEventually(invocationCountMatcher pegomock.InvocationCountMatcher, timeout time.Duration) *VerifierMockClient {
    88| 	return &VerifierMockClient{
    89| 		mock:                   mock,
    90| 		invocationCountMatcher: invocationCountMatcher,
    91| 		timeout:                timeout,
    92| 	}
    93| }
    94| type VerifierMockClient struct {
    95| 	mock                   *MockClient
    96| 	invocationCountMatcher pegomock.InvocationCountMatcher
    97| 	inOrderContext         *pegomock.InOrderContext
    98| 	timeout                time.Duration
    99| }
   100| func (verifier *VerifierMockClient) DetectVersion(log logging.SimpleLogging, projectDirectory string) *MockClient_DetectVersion_OngoingVerification {
   101| 	_params := []pegomock.Param{log, projectDirectory}
   102| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "DetectVersion", _params, verifier.timeout)
   103| 	return &MockClient_DetectVersion_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
   104| }
   105| type MockClient_DetectVersion_OngoingVerification struct {
   106| 	mock              *MockClient
   107| 	methodInvocations []pegomock.MethodInvocation
   108| }
   109| func (c *MockClient_DetectVersion_OngoingVerification) GetCapturedArguments() (logging.SimpleLogging, string) {
   110| 	log, projectDirectory := c.GetAllCapturedArguments()
   111| 	return log[len(log)-1], projectDirectory[len(projectDirectory)-1]
   112| }
   113| func (c *MockClient_DetectVersion_OngoingVerification) GetAllCapturedArguments() (_param0 []logging.SimpleLogging, _param1 []string) {
   114| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
   115| 	if len(_params) > 0 {
   116| 		if len(_params) > 0 {
   117| 			_param0 = make([]logging.SimpleLogging, len(c.methodInvocations))
   118| 			for u, param := range _params[0] {
   119| 				_param0[u] = param.(logging.SimpleLogging)
   120| 			}
   121| 		}
   122| 		if len(_params) > 1 {
   123| 			_param1 = make([]string, len(c.methodInvocations))
   124| 			for u, param := range _params[1] {
   125| 				_param1[u] = param.(string)
   126| 			}
   127| 		}
   128| 	}
   129| 	return
   130| }
   131| func (verifier *VerifierMockClient) EnsureVersion(log logging.SimpleLogging, v *go_version.Version) *MockClient_EnsureVersion_OngoingVerification {
   132| 	_params := []pegomock.Param{log, v}
   133| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "EnsureVersion", _params, verifier.timeout)
   134| 	return &MockClient_EnsureVersion_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
   135| }
   136| type MockClient_EnsureVersion_OngoingVerification struct {
   137| 	mock              *MockClient
   138| 	methodInvocations []pegomock.MethodInvocation
   139| }
   140| func (c *MockClient_EnsureVersion_OngoingVerification) GetCapturedArguments() (logging.SimpleLogging, *go_version.Version) {
   141| 	log, v := c.GetAllCapturedArguments()
   142| 	return log[len(log)-1], v[len(v)-1]
   143| }
   144| func (c *MockClient_EnsureVersion_OngoingVerification) GetAllCapturedArguments() (_param0 []logging.SimpleLogging, _param1 []*go_version.Version) {
   145| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
   146| 	if len(_params) > 0 {
   147| 		if len(_params) > 0 {
   148| 			_param0 = make([]logging.SimpleLogging, len(c.methodInvocations))
   149| 			for u, param := range _params[0] {
   150| 				_param0[u] = param.(logging.SimpleLogging)
   151| 			}
   152| 		}
   153| 		if len(_params) > 1 {
   154| 			_param1 = make([]*go_version.Version, len(c.methodInvocations))
   155| 			for u, param := range _params[1] {
   156| 				_param1[u] = param.(*go_version.Version)
   157| 			}
   158| 		}
   159| 	}
   160| 	return
   161| }
   162| func (verifier *VerifierMockClient) RunCommandWithVersion(ctx command.ProjectContext, path string, args []string, envs map[string]string, v *go_version.Version, workspace string) *MockClient_RunCommandWithVersion_OngoingVerification {
   163| 	_params := []pegomock.Param{ctx, path, args, envs, v, workspace}
   164| 	methodInvocations := pegomock.GetGenericMockFrom(verifier.mock).Verify(verifier.inOrderContext, verifier.invocationCountMatcher, "RunCommandWithVersion", _params, verifier.timeout)
   165| 	return &MockClient_RunCommandWithVersion_OngoingVerification{mock: verifier.mock, methodInvocations: methodInvocations}
   166| }
   167| type MockClient_RunCommandWithVersion_OngoingVerification struct {
   168| 	mock              *MockClient
   169| 	methodInvocations []pegomock.MethodInvocation
   170| }
   171| func (c *MockClient_RunCommandWithVersion_OngoingVerification) GetCapturedArguments() (command.ProjectContext, string, []string, map[string]string, *go_version.Version, string) {
   172| 	ctx, path, args, envs, v, workspace := c.GetAllCapturedArguments()
   173| 	return ctx[len(ctx)-1], path[len(path)-1], args[len(args)-1], envs[len(envs)-1], v[len(v)-1], workspace[len(workspace)-1]
   174| }
   175| func (c *MockClient_RunCommandWithVersion_OngoingVerification) GetAllCapturedArguments() (_param0 []command.ProjectContext, _param1 []string, _param2 [][]string, _param3 []map[string]string, _param4 []*go_version.Version, _param5 []string) {
   176| 	_params := pegomock.GetGenericMockFrom(c.mock).GetInvocationParams(c.methodInvocations)
   177| 	if len(_params) > 0 {
   178| 		if len(_params) > 0 {
   179| 			_param0 = make([]command.ProjectContext, len(c.methodInvocations))
   180| 			for u, param := range _params[0] {
   181| 				_param0[u] = param.(command.ProjectContext)
   182| 			}
   183| 		}
   184| 		if len(_params) > 1 {
   185| 			_param1 = make([]string, len(c.methodInvocations))
   186| 			for u, param := range _params[1] {
   187| 				_param1[u] = param.(string)
   188| 			}
   189| 		}
   190| 		if len(_params) > 2 {
   191| 			_param2 = make([][]string, len(c.methodInvocations))
   192| 			for u, param := range _params[2] {
   193| 				_param2[u] = param.([]string)
   194| 			}
   195| 		}
   196| 		if len(_params) > 3 {
   197| 			_param3 = make([]map[string]string, len(c.methodInvocations))
   198| 			for u, param := range _params[3] {
   199| 				_param3[u] = param.(map[string]string)
   200| 			}
   201| 		}
   202| 		if len(_params) > 4 {
   203| 			_param4 = make([]*go_version.Version, len(c.methodInvocations))
   204| 			for u, param := range _params[4] {
   205| 				_param4[u] = param.(*go_version.Version)
   206| 			}
   207| 		}
   208| 		if len(_params) > 5 {
   209| 			_param5 = make([]string, len(c.methodInvocations))
   210| 			for u, param := range _params[5] {
   211| 				_param5[u] = param.(string)
   212| 			}
   213| 		}
   214| 	}
   215| 	return
   216| }


# ====================================================================
# FILE: server/core/terraform/terraform_client.go
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-190 ---
     1| package terraform
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"os"
     6| 	"os/exec"
     7| 	"path/filepath"
     8| 	"regexp"
     9| 	"strings"
    10| 	"sync"
    11| 	"time"
    12| 	"github.com/hashicorp/go-version"
    13| 	"github.com/hashicorp/terraform-config-inspect/tfconfig"
    14| 	"github.com/mitchellh/go-homedir"
    15| 	"github.com/pkg/errors"
    16| 	"github.com/runatlantis/atlantis/server/core/runtime/models"
    17| 	"github.com/runatlantis/atlantis/server/events/command"
    18| 	"github.com/runatlantis/atlantis/server/events/terraform/ansi"
    19| 	"github.com/runatlantis/atlantis/server/jobs"
    20| 	"github.com/runatlantis/atlantis/server/logging"
    21| )
    22| var LogStreamingValidCmds = [...]string{"init", "plan", "apply"}
    23| type Client interface {
    24| 	RunCommandWithVersion(ctx command.ProjectContext, path string, args []string, envs map[string]string, v *version.Version, workspace string) (string, error)
    25| 	EnsureVersion(log logging.SimpleLogging, v *version.Version) error
    26| 	DetectVersion(log logging.SimpleLogging, projectDirectory string) *version.Version
    27| }
    28| type DefaultClient struct {
    29| 	distribution Distribution
    30| 	defaultVersion *version.Version
    31| 	terraformPluginCacheDir string
    32| 	binDir                  string
    33| 	overrideTF string
    34| 	downloadBaseURL string
    35| 	downloadAllowed bool
    36| 	versions map[string]string
    37| 	versionsLock *sync.Mutex
    38| 	usePluginCache bool
    39| 	projectCmdOutputHandler jobs.ProjectCommandOutputHandler
    40| }
    41| var versionRegex = regexp.MustCompile("(?:Terraform|OpenTofu) v(.*?)(\\s.*)?\n")
    42| func NewClientWithDefaultVersion(
    43| 	log logging.SimpleLogging,
    44| 	distribution Distribution,
    45| 	binDir string,
    46| 	cacheDir string,
    47| 	tfeToken string,
    48| 	tfeHostname string,
    49| 	defaultVersionStr string,
    50| 	defaultVersionFlagName string,
    51| 	tfDownloadURL string,
    52| 	tfDownloadAllowed bool,
    53| 	usePluginCache bool,
    54| 	fetchAsync bool,
    55| 	projectCmdOutputHandler jobs.ProjectCommandOutputHandler,
    56| ) (*DefaultClient, error) {
    57| 	var finalDefaultVersion *version.Version
    58| 	var localVersion *version.Version
    59| 	versions := make(map[string]string)
    60| 	var versionsLock sync.Mutex
    61| 	localPath, err := exec.LookPath(distribution.BinName())
    62| 	if err != nil && defaultVersionStr == "" {
    63| 		return nil, fmt.Errorf("%s not found in $PATH. Set --%s or download terraform from https://developer.hashicorp.com/terraform/downloads", distribution.BinName(), defaultVersionFlagName)
    64| 	}
    65| 	if err == nil {
    66| 		localVersion, err = getVersion(localPath)
    67| 		if err != nil {
    68| 			return nil, err
    69| 		}
    70| 		versions[localVersion.String()] = localPath
    71| 		if defaultVersionStr == "" {
    72| 			finalDefaultVersion = localVersion
    73| 		}
    74| 	}
    75| 	if defaultVersionStr != "" {
    76| 		defaultVersion, err := version.NewVersion(defaultVersionStr)
    77| 		if err != nil {
    78| 			return nil, err
    79| 		}
    80| 		finalDefaultVersion = defaultVersion
    81| 		ensureVersionFunc := func() {
    82| 			versionsLock.Lock()
    83| 			_, err := ensureVersion(log, distribution, versions, defaultVersion, binDir, tfDownloadURL, tfDownloadAllowed)
    84| 			versionsLock.Unlock()
    85| 			if err != nil {
    86| 				log.Err("could not download %s %s: %s", distribution.BinName(), defaultVersion.String(), err)
    87| 			}
    88| 		}
    89| 		if fetchAsync {
    90| 			go ensureVersionFunc()
    91| 		} else {
    92| 			ensureVersionFunc()
    93| 		}
    94| 	}
    95| 	if tfeToken != "" {
    96| 		home, err := homedir.Dir()
    97| 		if err != nil {
    98| 			return nil, errors.Wrap(err, "getting home dir to write ~/.terraformrc file")
    99| 		}
   100| 		if err := generateRCFile(tfeToken, tfeHostname, home); err != nil {
   101| 			return nil, err
   102| 		}
   103| 	}
   104| 	return &DefaultClient{
   105| 		distribution:            distribution,
   106| 		defaultVersion:          finalDefaultVersion,
   107| 		terraformPluginCacheDir: cacheDir,
   108| 		binDir:                  binDir,
   109| 		downloadBaseURL:         tfDownloadURL,
   110| 		downloadAllowed:         tfDownloadAllowed,
   111| 		versionsLock:            &versionsLock,
   112| 		versions:                versions,
   113| 		usePluginCache:          usePluginCache,
   114| 		projectCmdOutputHandler: projectCmdOutputHandler,
   115| 	}, nil
   116| }
   117| func NewTestClient(
   118| 	log logging.SimpleLogging,
   119| 	distribution Distribution,
   120| 	binDir string,
   121| 	cacheDir string,
   122| 	tfeToken string,
   123| 	tfeHostname string,
   124| 	defaultVersionStr string,
   125| 	defaultVersionFlagName string,
   126| 	tfDownloadURL string,
   127| 	tfDownloadAllowed bool,
   128| 	usePluginCache bool,
   129| 	projectCmdOutputHandler jobs.ProjectCommandOutputHandler,
   130| ) (*DefaultClient, error) {
   131| 	return NewClientWithDefaultVersion(
   132| 		log,
   133| 		distribution,
   134| 		binDir,
   135| 		cacheDir,
   136| 		tfeToken,
   137| 		tfeHostname,
   138| 		defaultVersionStr,
   139| 		defaultVersionFlagName,
   140| 		tfDownloadURL,
   141| 		tfDownloadAllowed,
   142| 		usePluginCache,
   143| 		false,
   144| 		projectCmdOutputHandler,
   145| 	)
   146| }
   147| func NewClient(
   148| 	log logging.SimpleLogging,
   149| 	distribution Distribution,
   150| 	binDir string,
   151| 	cacheDir string,
   152| 	tfeToken string,
   153| 	tfeHostname string,
   154| 	defaultVersionStr string,
   155| 	defaultVersionFlagName string,
   156| 	tfDownloadURL string,
   157| 	tfDownloadAllowed bool,
   158| 	usePluginCache bool,
   159| 	projectCmdOutputHandler jobs.ProjectCommandOutputHandler,
   160| ) (*DefaultClient, error) {
   161| 	return NewClientWithDefaultVersion(
   162| 		log,
   163| 		distribution,
   164| 		binDir,
   165| 		cacheDir,
   166| 		tfeToken,
   167| 		tfeHostname,
   168| 		defaultVersionStr,
   169| 		defaultVersionFlagName,
   170| 		tfDownloadURL,
   171| 		tfDownloadAllowed,
   172| 		usePluginCache,
   173| 		true,
   174| 		projectCmdOutputHandler,
   175| 	)
   176| }
   177| func (c *DefaultClient) DefaultVersion() *version.Version {
   178| 	return c.defaultVersion
   179| }
   180| func (c *DefaultClient) TerraformBinDir() string {
   181| 	return c.binDir
   182| }
   183| func (c *DefaultClient) ExtractExactRegex(log logging.SimpleLogging, version string) []string {
   184| 	re := regexp.MustCompile(`^=?\s*([0-9.]+)\s*$`)
   185| 	matched := re.FindStringSubmatch(version)
   186| 	if len(matched) == 0 {
   187| 		log.Debug("exact version regex not found in the version %q", version)
   188| 		return nil
   189| 	}
   190| 	tfVersions := []string{matched[1]}

# --- HUNK 2: Lines 199-252 ---
   199| 	if len(module.RequiredCore) != 1 {
   200| 		log.Info("cannot determine which version to use from terraform configuration, detected %d possibilities.", len(module.RequiredCore))
   201| 		return nil
   202| 	}
   203| 	requiredVersionSetting := module.RequiredCore[0]
   204| 	log.Debug("Found required_version setting of %q", requiredVersionSetting)
   205| 	if !c.downloadAllowed {
   206| 		log.Debug("terraform downloads disabled.")
   207| 		matched := c.ExtractExactRegex(log, requiredVersionSetting)
   208| 		if len(matched) == 0 {
   209| 			log.Debug("did not specify exact version in terraform configuration, found %q", requiredVersionSetting)
   210| 			return nil
   211| 		}
   212| 		version, err := version.NewVersion(matched[0])
   213| 		if err != nil {
   214| 			log.Err("error parsing version string: %s", err)
   215| 			return nil
   216| 		}
   217| 		return version
   218| 	}
   219| 	downloadVersion, err := c.distribution.ResolveConstraint(context.Background(), requiredVersionSetting)
   220| 	if err != nil {
   221| 		log.Err("%s", err)
   222| 		return nil
   223| 	}
   224| 	return downloadVersion
   225| }
   226| func (c *DefaultClient) EnsureVersion(log logging.SimpleLogging, v *version.Version) error {
   227| 	if v == nil {
   228| 		v = c.defaultVersion
   229| 	}
   230| 	var err error
   231| 	c.versionsLock.Lock()
   232| 	_, err = ensureVersion(log, c.distribution, c.versions, v, c.binDir, c.downloadBaseURL, c.downloadAllowed)
   233| 	c.versionsLock.Unlock()
   234| 	if err != nil {
   235| 		return err
   236| 	}
   237| 	return nil
   238| }
   239| func (c *DefaultClient) RunCommandWithVersion(ctx command.ProjectContext, path string, args []string, customEnvVars map[string]string, v *version.Version, workspace string) (string, error) {
   240| 	if isAsyncEligibleCommand(args[0]) {
   241| 		_, outCh := c.RunCommandAsync(ctx, path, args, customEnvVars, v, workspace)
   242| 		var lines []string
   243| 		var err error
   244| 		for line := range outCh {
   245| 			if line.Err != nil {
   246| 				err = line.Err
   247| 				break
   248| 			}
   249| 			lines = append(lines, line.Line)
   250| 		}
   251| 		output := strings.Join(lines, "\n")
   252| 		output = ansi.Strip(output)

# --- HUNK 3: Lines 276-316 ---
   276| func (c *DefaultClient) prepExecCmd(log logging.SimpleLogging, v *version.Version, workspace string, path string, args []string) (string, *exec.Cmd, error) {
   277| 	tfCmd, envVars, err := c.prepCmd(log, v, workspace, path, args)
   278| 	if err != nil {
   279| 		return "", nil, err
   280| 	}
   281| 	cmd := exec.Command("sh", "-c", tfCmd)
   282| 	cmd.Dir = path
   283| 	cmd.Env = envVars
   284| 	return tfCmd, cmd, nil
   285| }
   286| func (c *DefaultClient) prepCmd(log logging.SimpleLogging, v *version.Version, workspace string, path string, args []string) (string, []string, error) {
   287| 	if v == nil {
   288| 		v = c.defaultVersion
   289| 	}
   290| 	var binPath string
   291| 	if c.overrideTF != "" {
   292| 		binPath = c.overrideTF
   293| 	} else {
   294| 		var err error
   295| 		c.versionsLock.Lock()
   296| 		binPath, err = ensureVersion(log, c.distribution, c.versions, v, c.binDir, c.downloadBaseURL, c.downloadAllowed)
   297| 		c.versionsLock.Unlock()
   298| 		if err != nil {
   299| 			return "", nil, err
   300| 		}
   301| 	}
   302| 	envVars := []string{
   303| 		"TF_IN_AUTOMATION=true",
   304| 		fmt.Sprintf("WORKSPACE=%s", workspace),
   305| 		fmt.Sprintf("ATLANTIS_TERRAFORM_VERSION=%s", v.String()),
   306| 		fmt.Sprintf("DIR=%s", path),
   307| 	}
   308| 	if c.usePluginCache {
   309| 		envVars = append(envVars, fmt.Sprintf("TF_PLUGIN_CACHE_DIR=%s", c.terraformPluginCacheDir))
   310| 	}
   311| 	envVars = append(envVars, os.Environ()...)
   312| 	tfCmd := fmt.Sprintf("%s %s", binPath, strings.Join(args, " "))
   313| 	return tfCmd, envVars, nil
   314| }
   315| func (c *DefaultClient) RunCommandAsync(ctx command.ProjectContext, path string, args []string, customEnvVars map[string]string, v *version.Version, workspace string) (chan<- string, <-chan models.Line) {
   316| 	cmd, envVars, err := c.prepCmd(ctx.Log, v, workspace, path, args)

# --- HUNK 4: Lines 323-397 ---
   323| 			close(inCh)
   324| 		}()
   325| 		return inCh, outCh
   326| 	}
   327| 	for key, val := range customEnvVars {
   328| 		envVars = append(envVars, fmt.Sprintf("%s=%s", key, val))
   329| 	}
   330| 	runner := models.NewShellCommandRunner(cmd, envVars, path, true, c.projectCmdOutputHandler)
   331| 	inCh, outCh := runner.RunCommandAsync(ctx)
   332| 	return inCh, outCh
   333| }
   334| func MustConstraint(v string) version.Constraints {
   335| 	c, err := version.NewConstraint(v)
   336| 	if err != nil {
   337| 		panic(err)
   338| 	}
   339| 	return c
   340| }
   341| func ensureVersion(
   342| 	log logging.SimpleLogging,
   343| 	dist Distribution,
   344| 	versions map[string]string,
   345| 	v *version.Version,
   346| 	binDir string,
   347| 	downloadURL string,
   348| 	downloadsAllowed bool,
   349| ) (string, error) {
   350| 	if binPath, ok := versions[v.String()]; ok {
   351| 		return binPath, nil
   352| 	}
   353| 	binFile := dist.BinName() + v.String()
   354| 	if binPath, err := exec.LookPath(binFile); err == nil {
   355| 		versions[v.String()] = binPath
   356| 		return binPath, nil
   357| 	}
   358| 	dest := filepath.Join(binDir, binFile)
   359| 	if _, err := os.Stat(dest); err == nil {
   360| 		versions[v.String()] = dest
   361| 		return dest, nil
   362| 	}
   363| 	if !downloadsAllowed {
   364| 		return "", fmt.Errorf(
   365| 			"could not find %s version %s in PATH or %s, and downloads are disabled",
   366| 			dist.BinName(),
   367| 			v.String(),
   368| 			binDir,
   369| 		)
   370| 	}
   371| 	log.Info("could not find %s version %s in PATH or %s", dist.BinName(), v.String(), binDir)
   372| 	log.Info("downloading %s version %s from download URL %s", dist.BinName(), v.String(), downloadURL)
   373| 	execPath, err := dist.Downloader().Install(context.Background(), binDir, downloadURL, v)
   374| 	if err != nil {
   375| 		return "", errors.Wrapf(err, "error downloading terraform version %s", v.String())
   376| 	}
   377| 	log.Info("Downloaded %s %s to %s", dist.BinName(), v.String(), execPath)
   378| 	versions[v.String()] = execPath
   379| 	return execPath, nil
   380| }
   381| func generateRCFile(tfeToken string, tfeHostname string, home string) error {
   382| 	const rcFilename = ".terraformrc"
   383| 	rcFile := filepath.Join(home, rcFilename)
   384| 	config := fmt.Sprintf(rcFileContents, tfeHostname, tfeToken)
   385| 	if _, err := os.Stat(rcFile); err == nil {
   386| 		currContents, err := os.ReadFile(rcFile) // nolint: gosec
   387| 		if err != nil {
   388| 			return errors.Wrapf(err, "trying to read %s to ensure we're not overwriting it", rcFile)
   389| 		}
   390| 		if config != string(currContents) {
   391| 			return fmt.Errorf("can't write TFE token to %s because that file has contents that would be overwritten", rcFile)
   392| 		}
   393| 		return nil
   394| 	}
   395| 	if err := os.WriteFile(rcFile, []byte(config), 0600); err != nil {
   396| 		return errors.Wrapf(err, "writing generated %s file with TFE token to %s", rcFilename, rcFile)
   397| 	}

# --- HUNK 5: Lines 403-422 ---
   403| 			return true
   404| 		}
   405| 	}
   406| 	return false
   407| }
   408| func getVersion(tfBinary string) (*version.Version, error) {
   409| 	versionOutBytes, err := exec.Command(tfBinary, "version").Output() // #nosec
   410| 	versionOutput := string(versionOutBytes)
   411| 	if err != nil {
   412| 		return nil, errors.Wrapf(err, "running terraform version: %s", versionOutput)
   413| 	}
   414| 	match := versionRegex.FindStringSubmatch(versionOutput)
   415| 	if len(match) <= 1 {
   416| 		return nil, fmt.Errorf("could not parse terraform version from %s", versionOutput)
   417| 	}
   418| 	return version.NewVersion(match[1])
   419| }
   420| var rcFileContents = `credentials "%s" {
   421|   token = %q
   422| }`


# ====================================================================
# FILE: server/events/command/context.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 4-25 ---
     4| 	"github.com/runatlantis/atlantis/server/logging"
     5| 	tally "github.com/uber-go/tally/v4"
     6| )
     7| type Trigger int
     8| const (
     9| 	AutoTrigger Trigger = iota
    10| 	CommentTrigger
    11| )
    12| type Context struct {
    13| 	HeadRepo models.Repo
    14| 	Pull     models.PullRequest
    15| 	Scope    tally.Scope
    16| 	User models.User
    17| 	Log  logging.SimpleLogging
    18| 	PullRequestStatus models.PullReqStatus
    19| 	PullStatus *models.PullStatus
    20| 	PolicySet string
    21| 	ClearPolicyApproval bool
    22| 	Trigger Trigger
    23| 	API bool
    24| 	TeamAllowlistChecker TeamAllowlistChecker
    25| }


# ====================================================================
# FILE: server/events/command/project_context.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 38-78 ---
    38| 	ProjectName string
    39| 	RepoConfigVersion int
    40| 	RePlanCmd string
    41| 	RepoRelDir string
    42| 	Steps []valid.Step
    43| 	TerraformVersion *version.Version
    44| 	User models.User
    45| 	Verbose bool
    46| 	Workspace string
    47| 	PolicySets valid.PolicySets
    48| 	PolicySetTarget string
    49| 	ClearPolicyApproval bool
    50| 	DeleteSourceBranchOnMerge bool
    51| 	RepoLocksMode valid.RepoLocksMode
    52| 	RepoConfigFile string
    53| 	JobID string
    54| 	ExecutionOrderGroup int
    55| 	AbortOnExcecutionOrderFail bool
    56| 	CustomPolicyCheck bool
    57| 	SilencePRComments []string
    58| 	TeamAllowlistChecker TeamAllowlistChecker
    59| }
    60| func (p ProjectContext) SetProjectScopeTags(scope tally.Scope) tally.Scope {
    61| 	v := ""
    62| 	if p.TerraformVersion != nil {
    63| 		v = p.TerraformVersion.String()
    64| 	}
    65| 	tags := ProjectScopeTags{
    66| 		BaseRepo:         p.BaseRepo.FullName,
    67| 		PrNumber:         strconv.Itoa(p.Pull.Num),
    68| 		Project:          p.ProjectName,
    69| 		ProjectPath:      p.RepoRelDir,
    70| 		TerraformVersion: v,
    71| 		Workspace:        p.Workspace,
    72| 	}
    73| 	return scope.Tagged(tags.Loadtags())
    74| }
    75| func (p ProjectContext) GetShowResultFileName() string {
    76| 	if p.ProjectName == "" {
    77| 		return fmt.Sprintf("%s.json", p.Workspace)
    78| 	}


# ====================================================================
# FILE: server/events/command/team_allowlist_checker.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| package command
     2| import (
     3| 	"strings"
     4| 	"github.com/runatlantis/atlantis/server/events/models"
     5| )
     6| const wildcard = "*"
     7| type mapOfStrings map[string]string
     8| type TeamAllowlistChecker interface {
     9| 	HasRules() bool
    10| 	IsCommandAllowedForTeam(ctx models.TeamAllowlistCheckerContext, team, command string) bool
    11| 	IsCommandAllowedForAnyTeam(ctx models.TeamAllowlistCheckerContext, teams []string, command string) bool
    12| }
    13| type DefaultTeamAllowlistChecker struct {
    14| 	rules []mapOfStrings
    15| }
    16| func NewTeamAllowlistChecker(allowlist string) (*DefaultTeamAllowlistChecker, error) {
    17| 	var rules []mapOfStrings
    18| 	pairs := strings.Split(allowlist, ",")
    19| 	if pairs[0] != "" {
    20| 		for _, pair := range pairs {
    21| 			values := strings.Split(pair, ":")
    22| 			team := strings.TrimSpace(values[0])
    23| 			command := strings.TrimSpace(values[1])
    24| 			m := mapOfStrings{team: command}
    25| 			rules = append(rules, m)
    26| 		}
    27| 	}
    28| 	return &DefaultTeamAllowlistChecker{
    29| 		rules: rules,
    30| 	}, nil
    31| }
    32| func (checker *DefaultTeamAllowlistChecker) HasRules() bool {
    33| 	return len(checker.rules) > 0
    34| }
    35| func (checker *DefaultTeamAllowlistChecker) IsCommandAllowedForTeam(_ models.TeamAllowlistCheckerContext, team string, command string) bool {
    36| 	for _, rule := range checker.rules {
    37| 		for key, value := range rule {
    38| 			if (key == wildcard || strings.EqualFold(key, team)) && (value == wildcard || strings.EqualFold(value, command)) {
    39| 				return true
    40| 			}
    41| 		}
    42| 	}
    43| 	return false
    44| }
    45| func (checker *DefaultTeamAllowlistChecker) IsCommandAllowedForAnyTeam(ctx models.TeamAllowlistCheckerContext, teams []string, command string) bool {
    46| 	if len(teams) == 0 {
    47| 		for _, rule := range checker.rules {
    48| 			for key, value := range rule {
    49| 				if (key == wildcard) && (value == wildcard || strings.EqualFold(value, command)) {
    50| 					return true
    51| 				}
    52| 			}
    53| 		}
    54| 	} else {
    55| 		for _, t := range teams {
    56| 			if checker.IsCommandAllowedForTeam(ctx, t, command) {
    57| 				return true
    58| 			}
    59| 		}
    60| 	}
    61| 	return false
    62| }


# ====================================================================
# FILE: server/events/command_runner.go
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-25 ---
     1| package events
     2| import (
     3| 	"fmt"
     4| 	"strconv"
     5| 	"github.com/google/go-github/v63/github"
     6| 	"github.com/mcdafydd/go-azuredevops/azuredevops"
     7| 	"github.com/pkg/errors"
     8| 	"github.com/runatlantis/atlantis/server/core/config/valid"
     9| 	"github.com/runatlantis/atlantis/server/events/command"
    10| 	"github.com/runatlantis/atlantis/server/events/models"
    11| 	"github.com/runatlantis/atlantis/server/events/vcs"
    12| 	"github.com/runatlantis/atlantis/server/events/vcs/gitea"
    13| 	"github.com/runatlantis/atlantis/server/logging"
    14| 	"github.com/runatlantis/atlantis/server/metrics"
    15| 	"github.com/runatlantis/atlantis/server/recovery"
    16| 	"github.com/runatlantis/atlantis/server/utils"
    17| 	tally "github.com/uber-go/tally/v4"
    18| 	gitlab "github.com/xanzy/go-gitlab"
    19| )
    20| const (
    21| 	ShutdownComment = "Atlantis server is shutting down, please try again later."
    22| )
    23| type CommandRunner interface {
    24| 	RunCommentCommand(baseRepo models.Repo, maybeHeadRepo *models.Repo, maybePull *models.PullRequest, user models.User, pullNum int, cmd *CommentCommand)
    25| 	RunAutoplanCommand(baseRepo models.Repo, headRepo models.Repo, pull models.PullRequest, user models.User)

# --- HUNK 2: Lines 52-126 ---
    52| 	AzureDevopsPullGetter    AzureDevopsPullGetter
    53| 	GitlabMergeRequestGetter GitlabMergeRequestGetter
    54| 	GiteaPullGetter          *gitea.GiteaClient
    55| 	DisableAutoplan      bool
    56| 	DisableAutoplanLabel string
    57| 	EventParser          EventParsing
    58| 	FailOnPreWorkflowHookError bool
    59| 	Logger                     logging.SimpleLogging
    60| 	GlobalCfg                  valid.GlobalCfg
    61| 	StatsScope                 tally.Scope
    62| 	AllowForkPRs bool
    63| 	ParallelPoolSize int
    64| 	AllowForkPRsFlag string
    65| 	SilenceForkPRErrors bool
    66| 	SilenceForkPRErrorsFlag        string
    67| 	CommentCommandRunnerByCmd      map[command.Name]CommentCommandRunner
    68| 	Drainer                        *Drainer
    69| 	PreWorkflowHooksCommandRunner  PreWorkflowHooksCommandRunner
    70| 	PostWorkflowHooksCommandRunner PostWorkflowHooksCommandRunner
    71| 	PullStatusFetcher              PullStatusFetcher
    72| 	TeamAllowlistChecker           command.TeamAllowlistChecker
    73| 	VarFileAllowlistChecker        *VarFileAllowlistChecker
    74| 	CommitStatusUpdater            CommitStatusUpdater
    75| }
    76| func (c *DefaultCommandRunner) RunAutoplanCommand(baseRepo models.Repo, headRepo models.Repo, pull models.PullRequest, user models.User) {
    77| 	if opStarted := c.Drainer.StartOp(); !opStarted {
    78| 		if commentErr := c.VCSClient.CreateComment(c.Logger, baseRepo, pull.Num, ShutdownComment, command.Plan.String()); commentErr != nil {
    79| 			c.Logger.Log(logging.Error, "unable to comment that Atlantis is shutting down: %s", commentErr)
    80| 		}
    81| 		return
    82| 	}
    83| 	defer c.Drainer.OpDone()
    84| 	log := c.buildLogger(baseRepo.FullName, pull.Num)
    85| 	defer c.logPanics(baseRepo, pull.Num, log)
    86| 	status, err := c.PullStatusFetcher.GetPullStatus(pull)
    87| 	if err != nil {
    88| 		log.Err("Unable to fetch pull status, this is likely a bug.", err)
    89| 	}
    90| 	scope := c.StatsScope.SubScope("autoplan")
    91| 	timer := scope.Timer(metrics.ExecutionTimeMetric).Start()
    92| 	defer timer.Stop()
    93| 	if c.TeamAllowlistChecker != nil && c.TeamAllowlistChecker.HasRules() {
    94| 		err := c.fetchUserTeams(baseRepo, &user)
    95| 		if err != nil {
    96| 			c.Logger.Err("Unable to fetch user teams: %s", err)
    97| 			return
    98| 		}
    99| 		ok, err := c.checkUserPermissions(baseRepo, user, "plan")
   100| 		if err != nil {
   101| 			c.Logger.Err("Unable to check user permissions: %s", err)
   102| 			return
   103| 		}
   104| 		if !ok {
   105| 			return
   106| 		}
   107| 	}
   108| 	ctx := &command.Context{
   109| 		User:       user,
   110| 		Log:        log,
   111| 		Scope:      scope,
   112| 		Pull:       pull,
   113| 		HeadRepo:   headRepo,
   114| 		PullStatus: status,
   115| 		Trigger:    command.AutoTrigger,
   116| 	}
   117| 	if !c.validateCtxAndComment(ctx, command.Autoplan) {
   118| 		return
   119| 	}
   120| 	if c.DisableAutoplan {
   121| 		return
   122| 	}
   123| 	if len(c.DisableAutoplanLabel) > 0 {
   124| 		labels, err := c.VCSClient.GetPullLabels(ctx.Log, baseRepo, pull)
   125| 		if err != nil {
   126| 			ctx.Log.Err("Unable to get pull labels. Proceeding with %s command.", err, command.Plan)

# --- HUNK 3: Lines 150-268 ---
   150| 		}
   151| 		ctx.Log.Err("'fail-on-pre-workflow-hook-error' not set so running %s command.", command.Plan)
   152| 	}
   153| 	autoPlanRunner := buildCommentCommandRunner(c, command.Plan)
   154| 	autoPlanRunner.Run(ctx, nil)
   155| 	err = c.PostWorkflowHooksCommandRunner.RunPostHooks(ctx, cmd)
   156| 	if err != nil {
   157| 		ctx.Log.Err("Error running post-workflow hooks %s.", err)
   158| 	}
   159| }
   160| func (c *DefaultCommandRunner) commentUserDoesNotHavePermissions(baseRepo models.Repo, pullNum int, user models.User, cmd *CommentCommand) {
   161| 	errMsg := fmt.Sprintf("```\nError: User @%s does not have permissions to execute '%s' command.\n```", user.Username, cmd.Name.String())
   162| 	if err := c.VCSClient.CreateComment(c.Logger, baseRepo, pullNum, errMsg, ""); err != nil {
   163| 		c.Logger.Err("unable to comment on pull request: %s", err)
   164| 	}
   165| }
   166| func (c *DefaultCommandRunner) checkUserPermissions(repo models.Repo, user models.User, cmdName string) (bool, error) {
   167| 	if c.TeamAllowlistChecker == nil || !c.TeamAllowlistChecker.HasRules() {
   168| 		return true, nil
   169| 	}
   170| 	ctx := models.TeamAllowlistCheckerContext{
   171| 		BaseRepo:    repo,
   172| 		CommandName: cmdName,
   173| 		Log:         c.Logger,
   174| 		Pull:        models.PullRequest{},
   175| 		User:        user,
   176| 		Verbose:     false,
   177| 		API:         false,
   178| 	}
   179| 	ok := c.TeamAllowlistChecker.IsCommandAllowedForAnyTeam(ctx, user.Teams, cmdName)
   180| 	if !ok {
   181| 		return false, nil
   182| 	}
   183| 	return true, nil
   184| }
   185| func (c *DefaultCommandRunner) checkVarFilesInPlanCommandAllowlisted(cmd *CommentCommand) error {
   186| 	if cmd == nil || cmd.CommandName() != command.Plan {
   187| 		return nil
   188| 	}
   189| 	return c.VarFileAllowlistChecker.Check(cmd.Flags)
   190| }
   191| func (c *DefaultCommandRunner) RunCommentCommand(baseRepo models.Repo, maybeHeadRepo *models.Repo, maybePull *models.PullRequest, user models.User, pullNum int, cmd *CommentCommand) {
   192| 	if opStarted := c.Drainer.StartOp(); !opStarted {
   193| 		if commentErr := c.VCSClient.CreateComment(c.Logger, baseRepo, pullNum, ShutdownComment, ""); commentErr != nil {
   194| 			c.Logger.Log(logging.Error, "unable to comment that Atlantis is shutting down: %s", commentErr)
   195| 		}
   196| 		return
   197| 	}
   198| 	defer c.Drainer.OpDone()
   199| 	log := c.buildLogger(baseRepo.FullName, pullNum)
   200| 	defer c.logPanics(baseRepo, pullNum, log)
   201| 	scope := c.StatsScope.SubScope("comment")
   202| 	if cmd != nil {
   203| 		scope = scope.SubScope(cmd.Name.String())
   204| 	}
   205| 	timer := scope.Timer(metrics.ExecutionTimeMetric).Start()
   206| 	defer timer.Stop()
   207| 	if c.TeamAllowlistChecker != nil && c.TeamAllowlistChecker.HasRules() {
   208| 		err := c.fetchUserTeams(baseRepo, &user)
   209| 		if err != nil {
   210| 			c.Logger.Err("Unable to fetch user teams: %s", err)
   211| 			return
   212| 		}
   213| 		ok, err := c.checkUserPermissions(baseRepo, user, cmd.Name.String())
   214| 		if err != nil {
   215| 			c.Logger.Err("Unable to check user permissions: %s", err)
   216| 			return
   217| 		}
   218| 		if !ok {
   219| 			c.commentUserDoesNotHavePermissions(baseRepo, pullNum, user, cmd)
   220| 			return
   221| 		}
   222| 	}
   223| 	if err := c.checkVarFilesInPlanCommandAllowlisted(cmd); err != nil {
   224| 		errMsg := fmt.Sprintf("```\n%s\n```", err.Error())
   225| 		if commentErr := c.VCSClient.CreateComment(c.Logger, baseRepo, pullNum, errMsg, ""); commentErr != nil {
   226| 			c.Logger.Err("unable to comment on pull request: %s", commentErr)
   227| 		}
   228| 		return
   229| 	}
   230| 	headRepo, pull, err := c.ensureValidRepoMetadata(baseRepo, maybeHeadRepo, maybePull, user, pullNum, log)
   231| 	if err != nil {
   232| 		return
   233| 	}
   234| 	status, err := c.PullStatusFetcher.GetPullStatus(pull)
   235| 	if err != nil {
   236| 		log.Err("Unable to fetch pull status, this is likely a bug.", err)
   237| 	}
   238| 	ctx := &command.Context{
   239| 		User:                 user,
   240| 		Log:                  log,
   241| 		Pull:                 pull,
   242| 		PullStatus:           status,
   243| 		HeadRepo:             headRepo,
   244| 		Scope:                scope,
   245| 		Trigger:              command.CommentTrigger,
   246| 		PolicySet:            cmd.PolicySet,
   247| 		ClearPolicyApproval:  cmd.ClearPolicyApproval,
   248| 		TeamAllowlistChecker: c.TeamAllowlistChecker,
   249| 	}
   250| 	if !c.validateCtxAndComment(ctx, cmd.Name) {
   251| 		return
   252| 	}
   253| 	err = c.PreWorkflowHooksCommandRunner.RunPreHooks(ctx, cmd)
   254| 	if err != nil {
   255| 		ctx.Log.Err("Error running pre-workflow hooks %s.", err)
   256| 		if c.FailOnPreWorkflowHookError {
   257| 			ctx.Log.Err("'fail-on-pre-workflow-hook-error' set, so not running %s command.", cmd.Name.String())
   258| 			switch cmd.Name {
   259| 			case command.Plan:
   260| 				if err := c.CommitStatusUpdater.UpdateCombined(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull, models.FailedCommitStatus, command.Plan); err != nil {
   261| 					ctx.Log.Warn("unable to update plan commit status: %s", err)
   262| 				}
   263| 			case command.Apply:
   264| 				if err := c.CommitStatusUpdater.UpdateCombined(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull, models.FailedCommitStatus, command.Apply); err != nil {
   265| 					ctx.Log.Warn("unable to update apply commit status: %s", err)
   266| 				}
   267| 			}
   268| 			return

# --- HUNK 4: Lines 355-402 ---
   355| 		if maybePull == nil {
   356| 			err = errors.New("pull request should not be nilthis is a bug")
   357| 			break
   358| 		}
   359| 		pull = *maybePull
   360| 	case models.AzureDevops:
   361| 		pull, headRepo, err = c.getAzureDevopsData(log, baseRepo, pullNum)
   362| 	case models.Gitea:
   363| 		pull, headRepo, err = c.getGiteaData(log, baseRepo, pullNum)
   364| 	default:
   365| 		err = errors.New("Unknown VCS typethis is a bug")
   366| 	}
   367| 	if err != nil {
   368| 		log.Err(err.Error())
   369| 		if commentErr := c.VCSClient.CreateComment(c.Logger, baseRepo, pullNum, fmt.Sprintf("`Error: %s`", err), ""); commentErr != nil {
   370| 			log.Err("unable to comment: %s", commentErr)
   371| 		}
   372| 	}
   373| 	return
   374| }
   375| func (c *DefaultCommandRunner) fetchUserTeams(repo models.Repo, user *models.User) error {
   376| 	teams, err := c.VCSClient.GetTeamNamesForUser(repo, *user)
   377| 	if err != nil {
   378| 		return err
   379| 	}
   380| 	user.Teams = teams
   381| 	return nil
   382| }
   383| func (c *DefaultCommandRunner) validateCtxAndComment(ctx *command.Context, commandName command.Name) bool {
   384| 	if !c.AllowForkPRs && ctx.HeadRepo.Owner != ctx.Pull.BaseRepo.Owner {
   385| 		if c.SilenceForkPRErrors {
   386| 			return false
   387| 		}
   388| 		ctx.Log.Info("command was run on a fork pull request which is disallowed")
   389| 		if err := c.VCSClient.CreateComment(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull.Num, fmt.Sprintf("Atlantis commands can't be run on fork pull requests. To enable, set --%s  or, to disable this message, set --%s", c.AllowForkPRsFlag, c.SilenceForkPRErrorsFlag), ""); err != nil {
   390| 			ctx.Log.Err("unable to comment: %s", err)
   391| 		}
   392| 		return false
   393| 	}
   394| 	if ctx.Pull.State != models.OpenPullState && commandName != command.Unlock {
   395| 		ctx.Log.Info("command was run on closed pull request")
   396| 		if err := c.VCSClient.CreateComment(ctx.Log, ctx.Pull.BaseRepo, ctx.Pull.Num, "Atlantis commands can't be run on closed pull requests", ""); err != nil {
   397| 			ctx.Log.Err("unable to comment: %s", err)
   398| 		}
   399| 		return false
   400| 	}
   401| 	repo := c.GlobalCfg.MatchingRepo(ctx.Pull.BaseRepo.ID())
   402| 	if !repo.BranchMatches(ctx.Pull.BaseBranch) {


# ====================================================================
# FILE: server/events/event_parser.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| package events
     2| import (
     3| 	"encoding/json"
     4| 	"fmt"
     5| 	"net/url"
     6| 	"path"
     7| 	"strings"
     8| 	giteasdk "code.gitea.io/sdk/gitea"
     9| 	"github.com/go-playground/validator/v10"
    10| 	"github.com/google/go-github/v63/github"
    11| 	lru "github.com/hashicorp/golang-lru/v2"
    12| 	"github.com/mcdafydd/go-azuredevops/azuredevops"
    13| 	"github.com/pkg/errors"
    14| 	"github.com/runatlantis/atlantis/server/events/command"
    15| 	"github.com/runatlantis/atlantis/server/events/models"
    16| 	"github.com/runatlantis/atlantis/server/events/vcs/bitbucketcloud"
    17| 	"github.com/runatlantis/atlantis/server/events/vcs/bitbucketserver"
    18| 	"github.com/runatlantis/atlantis/server/events/vcs/gitea"
    19| 	"github.com/runatlantis/atlantis/server/logging"
    20| 	"github.com/xanzy/go-gitlab"
    21| )
    22| const gitlabPullOpened = "opened"
    23| const usagesCols = 90
    24| var lastBitbucketSha, _ = lru.New[string, string](300)
    25| type PullCommand interface {
    26| 	Dir() string
    27| 	CommandName() command.Name
    28| 	SubCommandName() string
    29| 	IsVerbose() bool
    30| 	IsAutoplan() bool


# ====================================================================
# FILE: server/events/external_team_allowlist_checker.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| package events
     2| import (
     3| 	"fmt"
     4| 	"strings"
     5| 	"github.com/runatlantis/atlantis/server/core/runtime"
     6| 	"github.com/runatlantis/atlantis/server/events/models"
     7| )
     8| type ExternalTeamAllowlistChecker struct {
     9| 	Command                     string
    10| 	ExtraArgs                   []string
    11| 	ExternalTeamAllowlistRunner runtime.ExternalTeamAllowlistRunner
    12| }
    13| func (checker *ExternalTeamAllowlistChecker) HasRules() bool {
    14| 	return true
    15| }
    16| func (checker *ExternalTeamAllowlistChecker) IsCommandAllowedForTeam(ctx models.TeamAllowlistCheckerContext, team string, command string) bool {
    17| 	cmd := checker.buildCommandString(ctx, []string{team}, command)
    18| 	out, err := checker.ExternalTeamAllowlistRunner.Run(ctx, "sh", "-c", cmd)
    19| 	if err != nil {
    20| 		return false
    21| 	}
    22| 	return checker.checkOutputResults(out)
    23| }
    24| func (checker *ExternalTeamAllowlistChecker) IsCommandAllowedForAnyTeam(ctx models.TeamAllowlistCheckerContext, teams []string, command string) bool {
    25| 	cmd := checker.buildCommandString(ctx, teams, command)
    26| 	out, err := checker.ExternalTeamAllowlistRunner.Run(ctx, "sh", "-c", cmd)
    27| 	if err != nil {
    28| 		return false
    29| 	}
    30| 	return checker.checkOutputResults(out)
    31| }
    32| func (checker *ExternalTeamAllowlistChecker) buildCommandString(ctx models.TeamAllowlistCheckerContext, teams []string, command string) string {
    33| 	cmdArr := append([]string{checker.Command}, checker.ExtraArgs...)
    34| 	orgTeams := make([]string, len(teams))
    35| 	for i, team := range teams {
    36| 		orgTeams[i] = fmt.Sprintf("%s/%s", ctx.BaseRepo.Owner, team)
    37| 	}
    38| 	teamStr := strings.Join(orgTeams, " ")
    39| 	return strings.Join(append(cmdArr, command, ctx.BaseRepo.FullName, teamStr), " ")
    40| }
    41| func (checker *ExternalTeamAllowlistChecker) checkOutputResults(output string) bool {
    42| 	lines := strings.Split(strings.TrimSpace(output), "\n")
    43| 	lastLine := lines[len(lines)-1]
    44| 	return strings.EqualFold(lastLine, "pass")
    45| }


# ====================================================================
# FILE: server/events/mocks/mock_event_parsing.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| package mocks
     2| import (
     3| 	gitea "code.gitea.io/sdk/gitea"
     4| 	github "github.com/google/go-github/v63/github"
     5| 	azuredevops "github.com/mcdafydd/go-azuredevops/azuredevops"
     6| 	pegomock "github.com/petergtz/pegomock/v4"
     7| 	models "github.com/runatlantis/atlantis/server/events/models"
     8| 	gitea0 "github.com/runatlantis/atlantis/server/events/vcs/gitea"
     9| 	logging "github.com/runatlantis/atlantis/server/logging"
    10| 	go_gitlab "github.com/xanzy/go-gitlab"
    11| 	"reflect"
    12| 	"time"
    13| )
    14| type MockEventParsing struct {
    15| 	fail func(message string, callerSkip ...int)
    16| }
    17| func NewMockEventParsing(options ...pegomock.Option) *MockEventParsing {
    18| 	mock := &MockEventParsing{}
    19| 	for _, option := range options {
    20| 		option.Apply(mock)
    21| 	}
    22| 	return mock
    23| }
    24| func (mock *MockEventParsing) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }


# ====================================================================
# FILE: server/events/mocks/mock_github_pull_getter.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| package mocks
     2| import (
     3| 	github "github.com/google/go-github/v63/github"
     4| 	pegomock "github.com/petergtz/pegomock/v4"
     5| 	models "github.com/runatlantis/atlantis/server/events/models"
     6| 	logging "github.com/runatlantis/atlantis/server/logging"
     7| 	"reflect"
     8| 	"time"
     9| )
    10| type MockGithubPullGetter struct {
    11| 	fail func(message string, callerSkip ...int)
    12| }
    13| func NewMockGithubPullGetter(options ...pegomock.Option) *MockGithubPullGetter {
    14| 	mock := &MockGithubPullGetter{}
    15| 	for _, option := range options {
    16| 		option.Apply(mock)
    17| 	}
    18| 	return mock
    19| }
    20| func (mock *MockGithubPullGetter) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    21| func (mock *MockGithubPullGetter) FailHandler() pegomock.FailHandler      { return mock.fail }
    22| func (mock *MockGithubPullGetter) GetPullRequest(logger logging.SimpleLogging, repo models.Repo, pullNum int) (*github.PullRequest, error) {
    23| 	if mock == nil {


# ====================================================================
# FILE: server/events/models/models.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 104-144 ---
   104| 	OpenedPullEvent PullRequestEventType = iota
   105| 	UpdatedPullEvent
   106| 	ClosedPullEvent
   107| 	OtherPullEvent
   108| )
   109| func (p PullRequestEventType) String() string {
   110| 	switch p {
   111| 	case OpenedPullEvent:
   112| 		return "opened"
   113| 	case UpdatedPullEvent:
   114| 		return "updated"
   115| 	case ClosedPullEvent:
   116| 		return "closed"
   117| 	case OtherPullEvent:
   118| 		return "other"
   119| 	}
   120| 	return "<missing String() implementation>"
   121| }
   122| type User struct {
   123| 	Username string
   124| 	Teams    []string
   125| }
   126| type ProjectLock struct {
   127| 	Project Project
   128| 	Pull PullRequest
   129| 	User User
   130| 	Workspace string
   131| 	Time time.Time
   132| }
   133| type Project struct {
   134| 	ProjectName string
   135| 	RepoFullName string
   136| 	Path string
   137| }
   138| func (p Project) String() string {
   139| 	return fmt.Sprintf("repofullname=%s path=%s", p.RepoFullName, p.Path)
   140| }
   141| type Plan struct {
   142| 	Project Project
   143| 	LocalPath string
   144| }

# --- HUNK 2: Lines 359-413 ---
   359| 	case ErroredPlanStatus:
   360| 		return "plan_errored"
   361| 	case PlannedPlanStatus:
   362| 		return "planned"
   363| 	case PlannedNoChangesPlanStatus:
   364| 		return "planned_no_changes"
   365| 	case ErroredApplyStatus:
   366| 		return "apply_errored"
   367| 	case AppliedPlanStatus:
   368| 		return "applied"
   369| 	case DiscardedPlanStatus:
   370| 		return "plan_discarded"
   371| 	case ErroredPolicyCheckStatus:
   372| 		return "policy_check_errored"
   373| 	case PassedPolicyCheckStatus:
   374| 		return "policy_check_passed"
   375| 	default:
   376| 		panic("missing String() impl for ProjectPlanStatus")
   377| 	}
   378| }
   379| type TeamAllowlistCheckerContext struct {
   380| 	BaseRepo Repo
   381| 	CommandName string
   382| 	EscapedCommentArgs []string
   383| 	HeadRepo Repo
   384| 	Log logging.SimpleLogging
   385| 	Pull PullRequest
   386| 	ProjectName string
   387| 	RepoDir string
   388| 	RepoRelDir string
   389| 	User User
   390| 	Verbose bool
   391| 	Workspace string
   392| 	API bool
   393| }
   394| type WorkflowHookCommandContext struct {
   395| 	BaseRepo Repo
   396| 	CommandName string
   397| 	EscapedCommentArgs []string
   398| 	HeadRepo Repo
   399| 	HookDescription string
   400| 	HookID string
   401| 	HookStepName string
   402| 	Log logging.SimpleLogging
   403| 	Pull PullRequest
   404| 	ProjectName string
   405| 	RepoRelDir string
   406| 	User User
   407| 	Verbose bool
   408| 	Workspace string
   409| 	API bool
   410| }
   411| type PlanSuccessStats struct {
   412| 	Import, Add, Change, Destroy int
   413| 	Changes, ChangesOutside      bool


# ====================================================================
# FILE: server/events/project_command_builder.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| package events
     2| import (
     3| 	"fmt"
     4| 	"os"
     5| 	"path/filepath"
     6| 	"slices"
     7| 	"sort"
     8| 	"strings"
     9| 	tally "github.com/uber-go/tally/v4"
    10| 	"github.com/runatlantis/atlantis/server/core/config/valid"
    11| 	"github.com/runatlantis/atlantis/server/core/terraform"
    12| 	"github.com/runatlantis/atlantis/server/logging"
    13| 	"github.com/runatlantis/atlantis/server/metrics"
    14| 	"github.com/pkg/errors"
    15| 	"github.com/runatlantis/atlantis/server/core/config"
    16| 	"github.com/runatlantis/atlantis/server/events/command"
    17| 	"github.com/runatlantis/atlantis/server/events/models"
    18| 	"github.com/runatlantis/atlantis/server/events/vcs"
    19| )
    20| const (
    21| 	DefaultRepoRelDir = "."
    22| 	DefaultWorkspace = "default"
    23| 	DefaultDeleteSourceBranchOnMerge = false
    24| 	DefaultAbortOnExcecutionOrderFail = false
    25| )
    26| func NewInstrumentedProjectCommandBuilder(

# --- HUNK 2: Lines 401-461 ---
   401| 			projCtxs = append(projCtxs,
   402| 				p.ProjectCommandContextBuilder.BuildProjectContext(
   403| 					ctx,
   404| 					cmdName,
   405| 					subCmdName,
   406| 					pCfg,
   407| 					commentFlags,
   408| 					repoDir,
   409| 					automerge,
   410| 					parallelApply,
   411| 					parallelPlan,
   412| 					verbose,
   413| 					abortOnExcecutionOrderFail,
   414| 					p.TerraformExecutor,
   415| 				)...)
   416| 		}
   417| 	}
   418| 	sort.Slice(projCtxs, func(i, j int) bool {
   419| 		return projCtxs[i].ExecutionOrderGroup < projCtxs[j].ExecutionOrderGroup
   420| 	})
   421| 	projCtxs = slices.DeleteFunc(projCtxs, func(projCtx command.ProjectContext) bool {
   422| 		if projCtx.TeamAllowlistChecker == nil || !projCtx.TeamAllowlistChecker.HasRules() {
   423| 			return false
   424| 		}
   425| 		ctx := models.TeamAllowlistCheckerContext{
   426| 			BaseRepo:           projCtx.BaseRepo,
   427| 			CommandName:        projCtx.CommandName.String(),
   428| 			EscapedCommentArgs: projCtx.EscapedCommentArgs,
   429| 			HeadRepo:           projCtx.HeadRepo,
   430| 			Log:                projCtx.Log,
   431| 			Pull:               projCtx.Pull,
   432| 			ProjectName:        projCtx.ProjectName,
   433| 			RepoDir:            repoDir,
   434| 			RepoRelDir:         projCtx.RepoRelDir,
   435| 			User:               projCtx.User,
   436| 			Verbose:            projCtx.Verbose,
   437| 			Workspace:          projCtx.Workspace,
   438| 			API:                false,
   439| 		}
   440| 		return !projCtx.TeamAllowlistChecker.IsCommandAllowedForAnyTeam(ctx, projCtx.User.Teams, projCtx.CommandName.String())
   441| 	})
   442| 	return projCtxs, nil
   443| }
   444| func (p *DefaultProjectCommandBuilder) buildProjectPlanCommand(ctx *command.Context, cmd *CommentCommand) ([]command.ProjectContext, error) {
   445| 	workspace := DefaultWorkspace
   446| 	if cmd.Workspace != "" {
   447| 		workspace = cmd.Workspace
   448| 	}
   449| 	var pcc []command.ProjectContext
   450| 	ctx.Log.Debug("building plan command")
   451| 	unlockFn, err := p.WorkingDirLocker.TryLock(ctx.Pull.BaseRepo.FullName, ctx.Pull.Num, workspace, DefaultRepoRelDir)
   452| 	if err != nil {
   453| 		return pcc, err
   454| 	}
   455| 	defer unlockFn()
   456| 	ctx.Log.Debug("cloning repository")
   457| 	_, _, err = p.WorkingDir.Clone(ctx.Log, ctx.HeadRepo, ctx.Pull, DefaultWorkspace)
   458| 	if err != nil {
   459| 		return pcc, err
   460| 	}
   461| 	defaultRepoDir, err := p.WorkingDir.GetWorkingDir(ctx.Pull.BaseRepo, ctx.Pull, DefaultWorkspace)

# --- HUNK 3: Lines 711-759 ---
   711| 		projCfg = p.GlobalCfg.DefaultProjCfg(ctx.Log, ctx.Pull.BaseRepo.ID(), repoRelDir, workspace)
   712| 		projCtxs = append(projCtxs,
   713| 			p.ProjectCommandContextBuilder.BuildProjectContext(
   714| 				ctx,
   715| 				cmd,
   716| 				subCmd,
   717| 				projCfg,
   718| 				commentFlags,
   719| 				repoDir,
   720| 				automerge,
   721| 				parallelApply,
   722| 				parallelPlan,
   723| 				verbose,
   724| 				abortOnExcecutionOrderFail,
   725| 				p.TerraformExecutor,
   726| 			)...)
   727| 	}
   728| 	if err := p.validateWorkspaceAllowed(repoCfgPtr, repoRelDir, workspace); err != nil {
   729| 		return []command.ProjectContext{}, err
   730| 	}
   731| 	projCtxs = slices.DeleteFunc(projCtxs, func(projCtx command.ProjectContext) bool {
   732| 		if projCtx.TeamAllowlistChecker == nil || !projCtx.TeamAllowlistChecker.HasRules() {
   733| 			return false
   734| 		}
   735| 		ctx := models.TeamAllowlistCheckerContext{
   736| 			BaseRepo:           projCtx.BaseRepo,
   737| 			CommandName:        projCtx.CommandName.String(),
   738| 			EscapedCommentArgs: projCtx.EscapedCommentArgs,
   739| 			HeadRepo:           projCtx.HeadRepo,
   740| 			Log:                projCtx.Log,
   741| 			Pull:               projCtx.Pull,
   742| 			ProjectName:        projCtx.ProjectName,
   743| 			RepoDir:            repoDir,
   744| 			RepoRelDir:         projCtx.RepoRelDir,
   745| 			User:               projCtx.User,
   746| 			Verbose:            projCtx.Verbose,
   747| 			Workspace:          projCtx.Workspace,
   748| 			API:                false,
   749| 		}
   750| 		return !projCtx.TeamAllowlistChecker.IsCommandAllowedForAnyTeam(ctx, projCtx.User.Teams, projCtx.CommandName.String())
   751| 	})
   752| 	return projCtxs, nil
   753| }
   754| func (p *DefaultProjectCommandBuilder) validateWorkspaceAllowed(repoCfg *valid.RepoCfg, repoRelDir string, workspace string) error {
   755| 	if repoCfg == nil {
   756| 		return nil
   757| 	}
   758| 	return repoCfg.ValidateWorkspaceAllowed(repoRelDir, workspace)
   759| }


# ====================================================================
# FILE: server/events/project_command_context_builder.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 97-137 ---
    97| 		prjCfg.TerraformVersion = terraformClient.DetectVersion(ctx.Log, filepath.Join(repoDir, prjCfg.RepoRelDir))
    98| 	}
    99| 	projectCmdContext := newProjectCommandContext(
   100| 		ctx,
   101| 		cmdName,
   102| 		cb.CommentBuilder.BuildApplyComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name, prjCfg.AutoMergeDisabled),
   103| 		cb.CommentBuilder.BuildApprovePoliciesComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name),
   104| 		cb.CommentBuilder.BuildPlanComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name, commentFlags),
   105| 		prjCfg,
   106| 		steps,
   107| 		prjCfg.PolicySets,
   108| 		escapeArgs(commentFlags),
   109| 		automerge,
   110| 		parallelApply,
   111| 		parallelPlan,
   112| 		verbose,
   113| 		abortOnExcecutionOrderFail,
   114| 		ctx.Scope,
   115| 		ctx.PullRequestStatus,
   116| 		ctx.PullStatus,
   117| 		ctx.TeamAllowlistChecker,
   118| 	)
   119| 	projectCmds = append(projectCmds, projectCmdContext)
   120| 	return
   121| }
   122| type PolicyCheckProjectCommandContextBuilder struct {
   123| 	ProjectCommandContextBuilder *DefaultProjectCommandContextBuilder
   124| 	CommentBuilder               CommentBuilder
   125| }
   126| func (cb *PolicyCheckProjectCommandContextBuilder) BuildProjectContext(
   127| 	ctx *command.Context,
   128| 	cmdName command.Name,
   129| 	subCmdName string,
   130| 	prjCfg valid.MergedProjectCfg,
   131| 	commentFlags []string,
   132| 	repoDir string,
   133| 	automerge, parallelApply, parallelPlan, verbose, abortOnExcecutionOrderFail bool,
   134| 	terraformClient terraform.Client,
   135| ) (projectCmds []command.ProjectContext) {
   136| 	if prjCfg.PolicyCheck {
   137| 		ctx.Log.Debug("PolicyChecks are enabled")

# --- HUNK 2: Lines 159-221 ---
   159| 		ctx.Log.Debug("Building project command context for %s", command.PolicyCheck)
   160| 		steps := prjCfg.Workflow.PolicyCheck.Steps
   161| 		projectCmds = append(projectCmds, newProjectCommandContext(
   162| 			ctx,
   163| 			command.PolicyCheck,
   164| 			cb.CommentBuilder.BuildApplyComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name, prjCfg.AutoMergeDisabled),
   165| 			cb.CommentBuilder.BuildApprovePoliciesComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name),
   166| 			cb.CommentBuilder.BuildPlanComment(prjCfg.RepoRelDir, prjCfg.Workspace, prjCfg.Name, commentFlags),
   167| 			prjCfg,
   168| 			steps,
   169| 			prjCfg.PolicySets,
   170| 			escapeArgs(commentFlags),
   171| 			automerge,
   172| 			parallelApply,
   173| 			parallelPlan,
   174| 			verbose,
   175| 			abortOnExcecutionOrderFail,
   176| 			ctx.Scope,
   177| 			ctx.PullRequestStatus,
   178| 			ctx.PullStatus,
   179| 			ctx.TeamAllowlistChecker,
   180| 		))
   181| 	}
   182| 	return
   183| }
   184| func newProjectCommandContext(ctx *command.Context,
   185| 	cmd command.Name,
   186| 	applyCmd string,
   187| 	approvePoliciesCmd string,
   188| 	planCmd string,
   189| 	projCfg valid.MergedProjectCfg,
   190| 	steps []valid.Step,
   191| 	policySets valid.PolicySets,
   192| 	escapedCommentArgs []string,
   193| 	automergeEnabled bool,
   194| 	parallelApplyEnabled bool,
   195| 	parallelPlanEnabled bool,
   196| 	verbose bool,
   197| 	abortOnExcecutionOrderFail bool,
   198| 	scope tally.Scope,
   199| 	pullReqStatus models.PullReqStatus,
   200| 	pullStatus *models.PullStatus,
   201| 	teamAllowlistChecker command.TeamAllowlistChecker,
   202| ) command.ProjectContext {
   203| 	var projectPlanStatus models.ProjectPlanStatus
   204| 	var projectPolicyStatus []models.PolicySetStatus
   205| 	if ctx.PullStatus != nil {
   206| 		for _, project := range ctx.PullStatus.Projects {
   207| 			if projCfg.Name == "" && project.RepoRelDir == projCfg.RepoRelDir {
   208| 				projectPlanStatus = project.Status
   209| 				projectPolicyStatus = project.PolicyStatus
   210| 				break
   211| 			}
   212| 			if projCfg.Name != "" && project.ProjectName == projCfg.Name {
   213| 				projectPlanStatus = project.Status
   214| 				projectPolicyStatus = project.PolicyStatus
   215| 				break
   216| 			}
   217| 		}
   218| 	}
   219| 	return command.ProjectContext{
   220| 		CommandName:                cmd,
   221| 		ApplyCmd:                   applyCmd,

# --- HUNK 3: Lines 241-274 ---
   241| 		ProjectName:                projCfg.Name,
   242| 		PlanRequirements:           projCfg.PlanRequirements,
   243| 		ApplyRequirements:          projCfg.ApplyRequirements,
   244| 		ImportRequirements:         projCfg.ImportRequirements,
   245| 		RePlanCmd:                  planCmd,
   246| 		RepoRelDir:                 projCfg.RepoRelDir,
   247| 		RepoConfigVersion:          projCfg.RepoCfgVersion,
   248| 		TerraformVersion:           projCfg.TerraformVersion,
   249| 		User:                       ctx.User,
   250| 		Verbose:                    verbose,
   251| 		Workspace:                  projCfg.Workspace,
   252| 		PolicySets:                 policySets,
   253| 		PolicySetTarget:            ctx.PolicySet,
   254| 		ClearPolicyApproval:        ctx.ClearPolicyApproval,
   255| 		PullReqStatus:              pullReqStatus,
   256| 		PullStatus:                 pullStatus,
   257| 		JobID:                      uuid.New().String(),
   258| 		ExecutionOrderGroup:        projCfg.ExecutionOrderGroup,
   259| 		AbortOnExcecutionOrderFail: abortOnExcecutionOrderFail,
   260| 		SilencePRComments:          projCfg.SilencePRComments,
   261| 		TeamAllowlistChecker:       teamAllowlistChecker,
   262| 	}
   263| }
   264| func escapeArgs(args []string) []string {
   265| 	var escaped []string
   266| 	for _, arg := range args {
   267| 		var escapedArg string
   268| 		for i := range arg {
   269| 			escapedArg += "\\" + string(arg[i])
   270| 		}
   271| 		escaped = append(escaped, escapedArg)
   272| 	}
   273| 	return escaped
   274| }


# ====================================================================
# FILE: server/events/vcs/gh_app_creds_rotator.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 29-54 ---
    29| }
    30| var _ GitCredsTokenRotator = (*githubAppTokenRotator)(nil)
    31| func (r *githubAppTokenRotator) GenerateJob() (scheduled.JobDefinition, error) {
    32| 	return scheduled.JobDefinition{
    33| 		Job:    r,
    34| 		Period: 30 * time.Second,
    35| 	}, r.rotate()
    36| }
    37| func (r *githubAppTokenRotator) Run() {
    38| 	err := r.rotate()
    39| 	if err != nil {
    40| 		r.log.Err(err.Error())
    41| 	}
    42| }
    43| func (r *githubAppTokenRotator) rotate() error {
    44| 	r.log.Debug("Refreshing git tokens for Github App")
    45| 	token, err := r.githubCredentials.GetToken()
    46| 	if err != nil {
    47| 		return errors.Wrap(err, "Getting github token")
    48| 	}
    49| 	r.log.Debug("Token successfully refreshed")
    50| 	if err := WriteGitCreds("x-access-token", token, r.githubHostname, r.homeDirPath, r.log, true); err != nil {
    51| 		return errors.Wrap(err, "Writing ~/.git-credentials file")
    52| 	}
    53| 	return nil
    54| }


# ====================================================================
# FILE: server/events/vcs/github_client.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-79 ---
     1| package vcs
     2| import (
     3| 	"context"
     4| 	"encoding/base64"
     5| 	"fmt"
     6| 	"net/http"
     7| 	"strconv"
     8| 	"strings"
     9| 	"time"
    10| 	"github.com/google/go-github/v63/github"
    11| 	"github.com/pkg/errors"
    12| 	"github.com/runatlantis/atlantis/server/events/command"
    13| 	"github.com/runatlantis/atlantis/server/events/models"
    14| 	"github.com/runatlantis/atlantis/server/events/vcs/common"
    15| 	"github.com/runatlantis/atlantis/server/logging"
    16| 	"github.com/shurcooL/githubv4"
    17| )
    18| const maxCommentLength = 65536
    19| var (
    20| 	clientMutationID            = githubv4.NewString("atlantis")
    21| 	pullRequestDismissalMessage = *githubv4.NewString("Dismissing reviews because of plan changes")
    22| )
    23| type GithubRepoIdCacheEntry struct {
    24| 	RepoId     githubv4.Int
    25| 	LookupTime time.Time
    26| }
    27| type GitHubRepoIdCache struct {
    28| 	cache map[githubv4.String]GithubRepoIdCacheEntry
    29| }
    30| func NewGitHubRepoIdCache() GitHubRepoIdCache {
    31| 	return GitHubRepoIdCache{
    32| 		cache: make(map[githubv4.String]GithubRepoIdCacheEntry),
    33| 	}
    34| }
    35| func (c *GitHubRepoIdCache) Get(key githubv4.String) (githubv4.Int, bool) {
    36| 	entry, ok := c.cache[key]
    37| 	if !ok {
    38| 		return githubv4.Int(0), false
    39| 	}
    40| 	if time.Since(entry.LookupTime) > time.Hour {
    41| 		delete(c.cache, key)
    42| 		return githubv4.Int(0), false
    43| 	}
    44| 	return entry.RepoId, true
    45| }
    46| func (c *GitHubRepoIdCache) Set(key githubv4.String, value githubv4.Int) {
    47| 	c.cache[key] = GithubRepoIdCacheEntry{
    48| 		RepoId:     value,
    49| 		LookupTime: time.Now(),
    50| 	}
    51| }
    52| type GithubClient struct {
    53| 	user                  string
    54| 	client                *github.Client
    55| 	v4Client              *githubv4.Client
    56| 	ctx                   context.Context
    57| 	config                GithubConfig
    58| 	maxCommentsPerCommand int
    59| 	repoIdCache           GitHubRepoIdCache
    60| }
    61| type GithubAppTemporarySecrets struct {
    62| 	ID int64
    63| 	Key string
    64| 	Name string
    65| 	WebhookSecret string
    66| 	URL string
    67| }
    68| type GithubReview struct {
    69| 	ID          githubv4.ID
    70| 	SubmittedAt githubv4.DateTime
    71| 	Author      struct {
    72| 		Login githubv4.String
    73| 	}
    74| }
    75| type GithubPRReviewSummary struct {
    76| 	ReviewDecision githubv4.String
    77| 	Reviews        []GithubReview
    78| }
    79| func NewGithubClient(hostname string, credentials GithubCredentials, config GithubConfig, maxCommentsPerCommand int, logger logging.SimpleLogging) (*GithubClient, error) {

# --- HUNK 2: Lines 91-131 ---
    91| 		apiURL := resolveGithubAPIURL(hostname)
    92| 		client, err = github.NewEnterpriseClient(apiURL.String(), apiURL.String(), transport) //nolint:staticcheck
    93| 		if err != nil {
    94| 			return nil, err
    95| 		}
    96| 		graphqlURL = fmt.Sprintf("https://%s/api/graphql", apiURL.Host)
    97| 	}
    98| 	v4Client := githubv4.NewEnterpriseClient(graphqlURL, transport)
    99| 	user, err := credentials.GetUser()
   100| 	logger.Debug("GH User: %s", user)
   101| 	if err != nil {
   102| 		return nil, errors.Wrap(err, "getting user")
   103| 	}
   104| 	return &GithubClient{
   105| 		user:                  user,
   106| 		client:                client,
   107| 		v4Client:              v4Client,
   108| 		ctx:                   context.Background(),
   109| 		config:                config,
   110| 		maxCommentsPerCommand: maxCommentsPerCommand,
   111| 		repoIdCache:           NewGitHubRepoIdCache(),
   112| 	}, nil
   113| }
   114| func (g *GithubClient) GetModifiedFiles(logger logging.SimpleLogging, repo models.Repo, pull models.PullRequest) ([]string, error) {
   115| 	logger.Debug("Getting modified files for GitHub pull request %d", pull.Num)
   116| 	var files []string
   117| 	nextPage := 0
   118| listloop:
   119| 	for {
   120| 		opts := github.ListOptions{
   121| 			PerPage: 300,
   122| 		}
   123| 		if nextPage != 0 {
   124| 			opts.Page = nextPage
   125| 		}
   126| 		maxAttempts := 5
   127| 		attemptDelay := 0 * time.Second
   128| 		for i := 0; i < maxAttempts; i++ {
   129| 			time.Sleep(attemptDelay)
   130| 			attemptDelay = 2*attemptDelay + 1*time.Second
   131| 			pageFiles, resp, err := g.client.PullRequests.ListFiles(g.ctx, repo.Owner, repo.Name, pull.Num, &opts)

# --- HUNK 3: Lines 149-190 ---
   149| 				break listloop
   150| 			}
   151| 			nextPage = resp.NextPage
   152| 			break
   153| 		}
   154| 	}
   155| 	return files, nil
   156| }
   157| func (g *GithubClient) CreateComment(logger logging.SimpleLogging, repo models.Repo, pullNum int, comment string, command string) error {
   158| 	logger.Debug("Creating comment on GitHub pull request %d", pullNum)
   159| 	var sepStart string
   160| 	sepEnd := "\n```\n</details>" +
   161| 		"\n<br>\n\n**Warning**: Output length greater than max comment size. Continued in next comment."
   162| 	if command != "" {
   163| 		sepStart = fmt.Sprintf("Continued %s output from previous comment.\n<details><summary>Show Output</summary>\n\n", command) +
   164| 			"```diff\n"
   165| 	} else {
   166| 		sepStart = "Continued from previous comment.\n<details><summary>Show Output</summary>\n\n" +
   167| 			"```diff\n"
   168| 	}
   169| 	truncationHeader := "> [!WARNING]\n" +
   170| 		"> **Warning**: Command output is larger than the maximum number of comments per command. Output truncated.\n"
   171| 	comments := common.SplitComment(comment, maxCommentLength, sepEnd, sepStart, g.maxCommentsPerCommand, truncationHeader)
   172| 	for i := range comments {
   173| 		_, resp, err := g.client.Issues.CreateComment(g.ctx, repo.Owner, repo.Name, pullNum, &github.IssueComment{Body: &comments[i]})
   174| 		if resp != nil {
   175| 			logger.Debug("POST /repos/%v/%v/issues/%d/comments returned: %v", repo.Owner, repo.Name, pullNum, resp.StatusCode)
   176| 		}
   177| 		if err != nil {
   178| 			return err
   179| 		}
   180| 	}
   181| 	return nil
   182| }
   183| func (g *GithubClient) ReactToComment(logger logging.SimpleLogging, repo models.Repo, _ int, commentID int64, reaction string) error {
   184| 	logger.Debug("Adding reaction to GitHub pull request comment %d", commentID)
   185| 	_, resp, err := g.client.Reactions.CreateIssueCommentReaction(g.ctx, repo.Owner, repo.Name, commentID, reaction)
   186| 	if resp != nil {
   187| 		logger.Debug("POST /repos/%v/%v/issues/comments/%d/reactions returned: %v", repo.Owner, repo.Name, commentID, resp.StatusCode)
   188| 	}
   189| 	return err
   190| }

# --- HUNK 4: Lines 330-676 ---
   330| 		DismissPullRequestReview struct {
   331| 			PullRequestReview struct {
   332| 				ID githubv4.ID
   333| 			}
   334| 		} `graphql:"dismissPullRequestReview(input: $input)"`
   335| 	}
   336| 	for _, review := range reviewStatus.Reviews {
   337| 		input := githubv4.DismissPullRequestReviewInput{
   338| 			PullRequestReviewID: review.ID,
   339| 			Message:             pullRequestDismissalMessage,
   340| 			ClientMutationID:    clientMutationID,
   341| 		}
   342| 		mutationResult := &mutation
   343| 		err := g.v4Client.Mutate(g.ctx, mutationResult, input, nil)
   344| 		if err != nil {
   345| 			return errors.Wrap(err, "dismissing reviewDecision")
   346| 		}
   347| 	}
   348| 	return nil
   349| }
   350| type PageInfo struct {
   351| 	EndCursor   *githubv4.String
   352| 	HasNextPage githubv4.Boolean
   353| }
   354| type WorkflowFileReference struct {
   355| 	Path         githubv4.String
   356| 	RepositoryId githubv4.Int
   357| 	Sha          *githubv4.String
   358| }
   359| func (original WorkflowFileReference) Copy() WorkflowFileReference {
   360| 	copy := WorkflowFileReference{
   361| 		Path:         original.Path,
   362| 		RepositoryId: original.RepositoryId,
   363| 		Sha:          new(githubv4.String),
   364| 	}
   365| 	if original.Sha != nil {
   366| 		*copy.Sha = *original.Sha
   367| 	}
   368| 	return copy
   369| }
   370| type WorkflowRun struct {
   371| 	File struct {
   372| 		Path              githubv4.String
   373| 		RepositoryFileUrl githubv4.String
   374| 		RepositoryName    githubv4.String
   375| 	}
   376| }
   377| type CheckRun struct {
   378| 	Name       githubv4.String
   379| 	Conclusion githubv4.String
   380| 	IsRequired githubv4.Boolean `graphql:"isRequired(pullRequestNumber: $number)"`
   381| 	CheckSuite struct {
   382| 		WorkflowRun *WorkflowRun
   383| 	}
   384| }
   385| func (original CheckRun) Copy() CheckRun {
   386| 	copy := CheckRun{
   387| 		Name:       original.Name,
   388| 		Conclusion: original.Conclusion,
   389| 		IsRequired: original.IsRequired,
   390| 		CheckSuite: original.CheckSuite,
   391| 	}
   392| 	if original.CheckSuite.WorkflowRun != nil {
   393| 		copy.CheckSuite.WorkflowRun = new(WorkflowRun)
   394| 		*copy.CheckSuite.WorkflowRun = *original.CheckSuite.WorkflowRun
   395| 	}
   396| 	return copy
   397| }
   398| type StatusContext struct {
   399| 	Context githubv4.String
   400| 	State   githubv4.String
   401| 	IsRequired githubv4.Boolean `graphql:"isRequired(pullRequestNumber: $number)"`
   402| }
   403| func (g *GithubClient) LookupRepoId(repo githubv4.String) (githubv4.Int, error) {
   404| 	if repoId, ok := g.repoIdCache.Get(repo); ok {
   405| 		return repoId, nil
   406| 	}
   407| 	repoSplit := strings.Split(string(repo), "/")
   408| 	if len(repoSplit) != 2 {
   409| 		return githubv4.Int(0), fmt.Errorf("invalid repository name: %s", repo)
   410| 	}
   411| 	var query struct {
   412| 		Repository struct {
   413| 			DatabaseId githubv4.Int
   414| 		} `graphql:"repository(owner: $owner, name: $name)"`
   415| 	}
   416| 	variables := map[string]interface{}{
   417| 		"owner": githubv4.String(repoSplit[0]),
   418| 		"name":  githubv4.String(repoSplit[1]),
   419| 	}
   420| 	err := g.v4Client.Query(g.ctx, &query, variables)
   421| 	if err != nil {
   422| 		return githubv4.Int(0), errors.Wrap(err, "getting repository id from GraphQL")
   423| 	}
   424| 	g.repoIdCache.Set(repo, query.Repository.DatabaseId)
   425| 	return query.Repository.DatabaseId, nil
   426| }
   427| func (g *GithubClient) WorkflowRunMatchesWorkflowFileReference(workflowRun WorkflowRun, workflowFileReference WorkflowFileReference) (bool, error) {
   428| 	repoId, err := g.LookupRepoId(workflowRun.File.RepositoryName)
   429| 	if err != nil {
   430| 		return false, err
   431| 	}
   432| 	if !(repoId == workflowFileReference.RepositoryId && workflowRun.File.Path == workflowFileReference.Path) {
   433| 		return false, nil
   434| 	} else if workflowFileReference.Sha != nil {
   435| 		return strings.Contains(string(workflowRun.File.RepositoryFileUrl), string(*workflowFileReference.Sha)), nil
   436| 	} else {
   437| 		return true, nil
   438| 	}
   439| }
   440| func (g *GithubClient) GetPullRequestMergeabilityInfo(
   441| 	repo models.Repo,
   442| 	pull *github.PullRequest,
   443| ) (
   444| 	reviewDecision githubv4.String,
   445| 	requiredChecks []githubv4.String,
   446| 	requiredWorkflows []WorkflowFileReference,
   447| 	checkRuns []CheckRun,
   448| 	statusContexts []StatusContext,
   449| 	err error,
   450| ) {
   451| 	var query struct {
   452| 		Repository struct {
   453| 			PullRequest struct {
   454| 				ReviewDecision githubv4.String
   455| 				BaseRef        struct {
   456| 					BranchProtectionRule struct {
   457| 						RequiredStatusChecks []struct {
   458| 							Context githubv4.String
   459| 						}
   460| 					}
   461| 					Rules struct {
   462| 						PageInfo PageInfo
   463| 						Nodes    []struct {
   464| 							Type              githubv4.String
   465| 							RepositoryRuleset struct {
   466| 								Enforcement githubv4.String
   467| 							}
   468| 							Parameters struct {
   469| 								RequiredStatusChecksParameters struct {
   470| 									RequiredStatusChecks []struct {
   471| 										Context githubv4.String
   472| 									}
   473| 								} `graphql:"... on RequiredStatusChecksParameters"`
   474| 								WorkflowsParameters struct {
   475| 									Workflows []WorkflowFileReference
   476| 								} `graphql:"... on WorkflowsParameters"`
   477| 							}
   478| 						}
   479| 					} `graphql:"rules(first: 100, after: $ruleCursor)"`
   480| 				}
   481| 				Commits struct {
   482| 					Nodes []struct {
   483| 						Commit struct {
   484| 							StatusCheckRollup struct {
   485| 								Contexts struct {
   486| 									PageInfo PageInfo
   487| 									Nodes    []struct {
   488| 										Typename      githubv4.String `graphql:"__typename"`
   489| 										CheckRun      CheckRun        `graphql:"... on CheckRun"`
   490| 										StatusContext StatusContext   `graphql:"... on StatusContext"`
   491| 									}
   492| 								} `graphql:"contexts(first: 100, after: $contextCursor)"`
   493| 							}
   494| 						}
   495| 					}
   496| 				} `graphql:"commits(last: 1)"`
   497| 			} `graphql:"pullRequest(number: $number)"`
   498| 		} `graphql:"repository(owner: $owner, name: $name)"`
   499| 	}
   500| 	variables := map[string]interface{}{
   501| 		"owner":         githubv4.String(repo.Owner),
   502| 		"name":          githubv4.String(repo.Name),
   503| 		"number":        githubv4.Int(*pull.Number),
   504| 		"ruleCursor":    (*githubv4.String)(nil),
   505| 		"contextCursor": (*githubv4.String)(nil),
   506| 	}
   507| 	requiredChecksSet := make(map[githubv4.String]any)
   508| pagination:
   509| 	for {
   510| 		err = g.v4Client.Query(g.ctx, &query, variables)
   511| 		if err != nil {
   512| 			break pagination
   513| 		}
   514| 		reviewDecision = query.Repository.PullRequest.ReviewDecision
   515| 		for _, rule := range query.Repository.PullRequest.BaseRef.BranchProtectionRule.RequiredStatusChecks {
   516| 			requiredChecksSet[rule.Context] = struct{}{}
   517| 		}
   518| 		for _, rule := range query.Repository.PullRequest.BaseRef.Rules.Nodes {
   519| 			if rule.RepositoryRuleset.Enforcement != "ACTIVE" {
   520| 				continue
   521| 			}
   522| 			switch rule.Type {
   523| 			case "REQUIRED_STATUS_CHECKS":
   524| 				for _, context := range rule.Parameters.RequiredStatusChecksParameters.RequiredStatusChecks {
   525| 					requiredChecksSet[context.Context] = struct{}{}
   526| 				}
   527| 			case "WORKFLOWS":
   528| 				for _, workflow := range rule.Parameters.WorkflowsParameters.Workflows {
   529| 					requiredWorkflows = append(requiredWorkflows, workflow.Copy())
   530| 				}
   531| 			default:
   532| 				continue
   533| 			}
   534| 		}
   535| 		if len(query.Repository.PullRequest.Commits.Nodes) == 0 {
   536| 			err = errors.New("no commits found on PR")
   537| 			break pagination
   538| 		}
   539| 		for _, context := range query.Repository.PullRequest.Commits.Nodes[0].Commit.StatusCheckRollup.Contexts.Nodes {
   540| 			switch context.Typename {
   541| 			case "CheckRun":
   542| 				checkRuns = append(checkRuns, context.CheckRun.Copy())
   543| 			case "StatusContext":
   544| 				statusContexts = append(statusContexts, context.StatusContext)
   545| 			default:
   546| 				err = fmt.Errorf("unknown type of status check, %q", context.Typename)
   547| 				break pagination
   548| 			}
   549| 		}
   550| 		if !query.Repository.PullRequest.BaseRef.Rules.PageInfo.HasNextPage &&
   551| 			!query.Repository.PullRequest.Commits.Nodes[0].Commit.StatusCheckRollup.Contexts.PageInfo.HasNextPage {
   552| 			break pagination
   553| 		}
   554| 		if query.Repository.PullRequest.BaseRef.Rules.PageInfo.EndCursor != nil {
   555| 			variables["ruleCursor"] = query.Repository.PullRequest.BaseRef.Rules.PageInfo.EndCursor
   556| 		}
   557| 		if query.Repository.PullRequest.Commits.Nodes[0].Commit.StatusCheckRollup.Contexts.PageInfo.EndCursor != nil {
   558| 			variables["contextCursor"] = query.Repository.PullRequest.Commits.Nodes[0].Commit.StatusCheckRollup.Contexts.PageInfo.EndCursor
   559| 		}
   560| 	}
   561| 	if err != nil {
   562| 		return "", nil, nil, nil, nil, errors.Wrap(err, "fetching rulesets, branch protections and status checks from GraphQL")
   563| 	}
   564| 	for context := range requiredChecksSet {
   565| 		requiredChecks = append(requiredChecks, context)
   566| 	}
   567| 	return reviewDecision, requiredChecks, requiredWorkflows, checkRuns, statusContexts, nil
   568| }
   569| func CheckRunPassed(checkRun CheckRun) bool {
   570| 	return checkRun.Conclusion == "SUCCESS" || checkRun.Conclusion == "SKIPPED" || checkRun.Conclusion == "NEUTRAL"
   571| }
   572| func StatusContextPassed(statusContext StatusContext, vcsstatusname string) bool {
   573| 	return strings.HasPrefix(string(statusContext.Context), fmt.Sprintf("%s/%s", vcsstatusname, command.Apply.String())) ||
   574| 		statusContext.State == "SUCCESS"
   575| }
   576| func ExpectedCheckPassed(expectedContext githubv4.String, checkRuns []CheckRun, statusContexts []StatusContext, vcsstatusname string) bool {
   577| 	for _, checkRun := range checkRuns {
   578| 		if checkRun.Name == expectedContext {
   579| 			return CheckRunPassed(checkRun)
   580| 		}
   581| 	}
   582| 	for _, statusContext := range statusContexts {
   583| 		if statusContext.Context == expectedContext {
   584| 			return StatusContextPassed(statusContext, vcsstatusname)
   585| 		}
   586| 	}
   587| 	return false
   588| }
   589| func (g *GithubClient) ExpectedWorkflowPassed(expectedWorkflow WorkflowFileReference, checkRuns []CheckRun) (bool, error) {
   590| 	for _, checkRun := range checkRuns {
   591| 		if checkRun.CheckSuite.WorkflowRun == nil {
   592| 			continue
   593| 		}
   594| 		match, err := g.WorkflowRunMatchesWorkflowFileReference(*checkRun.CheckSuite.WorkflowRun, expectedWorkflow)
   595| 		if err != nil {
   596| 			return false, err
   597| 		}
   598| 		if match {
   599| 			return CheckRunPassed(checkRun), nil
   600| 		}
   601| 	}
   602| 	return false, nil
   603| }
   604| func (g *GithubClient) IsMergeableMinusApply(logger logging.SimpleLogging, repo models.Repo, pull *github.PullRequest, vcsstatusname string) (bool, error) {
   605| 	if pull.Number == nil {
   606| 		return false, errors.New("pull request number is nil")
   607| 	}
   608| 	reviewDecision, requiredChecks, requiredWorkflows, checkRuns, statusContexts, err := g.GetPullRequestMergeabilityInfo(repo, pull)
   609| 	if err != nil {
   610| 		return false, err
   611| 	}
   612| 	notMergeablePrefix := fmt.Sprintf("Pull Request %s/%s:%s is not mergeable", repo.Owner, repo.Name, strconv.Itoa(*pull.Number))
   613| 	if reviewDecision != "APPROVED" && len(reviewDecision) != 0 {
   614| 		logger.Debug("%s: Review Decision: %s", notMergeablePrefix, reviewDecision)
   615| 		return false, nil
   616| 	}
   617| 	for _, requiredCheck := range requiredChecks {
   618| 		if !ExpectedCheckPassed(requiredCheck, checkRuns, statusContexts, vcsstatusname) {
   619| 			logger.Debug("%s: Expected Required Check: %s", notMergeablePrefix, requiredCheck)
   620| 			return false, nil
   621| 		}
   622| 	}
   623| 	for _, requiredWorkflow := range requiredWorkflows {
   624| 		passed, err := g.ExpectedWorkflowPassed(requiredWorkflow, checkRuns)
   625| 		if err != nil {
   626| 			return false, err
   627| 		}
   628| 		if !passed {
   629| 			logger.Debug("%s: Expected Required Workflow: RepositoryId: %d Path: %s", notMergeablePrefix, requiredWorkflow.RepositoryId, requiredWorkflow.Path)
   630| 			return false, nil
   631| 		}
   632| 	}
   633| 	return true, nil
   634| }
   635| func (g *GithubClient) PullIsMergeable(logger logging.SimpleLogging, repo models.Repo, pull models.PullRequest, vcsstatusname string) (bool, error) {
   636| 	logger.Debug("Checking if GitHub pull request %d is mergeable", pull.Num)
   637| 	githubPR, err := g.GetPullRequest(logger, repo, pull.Num)
   638| 	if err != nil {
   639| 		return false, errors.Wrap(err, "getting pull request")
   640| 	}
   641| 	switch githubPR.GetMergeableState() {
   642| 	case "clean", "unstable", "has_hooks":
   643| 		return true, nil
   644| 	case "blocked":
   645| 		if g.config.AllowMergeableBypassApply {
   646| 			logger.Debug("AllowMergeableBypassApply feature flag is enabled - attempting to bypass apply from mergeable requirements")
   647| 			isMergeableMinusApply, err := g.IsMergeableMinusApply(logger, repo, githubPR, vcsstatusname)
   648| 			if err != nil {
   649| 				return false, errors.Wrap(err, "getting pull request status")
   650| 			}
   651| 			return isMergeableMinusApply, nil
   652| 		}
   653| 		return false, nil
   654| 	default:
   655| 		return false, nil
   656| 	}
   657| }
   658| func (g *GithubClient) GetPullRequest(logger logging.SimpleLogging, repo models.Repo, num int) (*github.PullRequest, error) {
   659| 	logger.Debug("Getting GitHub pull request %d", num)
   660| 	var err error
   661| 	var pull *github.PullRequest
   662| 	maxAttempts := 5
   663| 	attemptDelay := 0 * time.Second
   664| 	for i := 0; i < maxAttempts; i++ {
   665| 		time.Sleep(attemptDelay)
   666| 		attemptDelay = 2*attemptDelay + 1*time.Second
   667| 		pull, resp, err := g.client.PullRequests.Get(g.ctx, repo.Owner, repo.Name, num)
   668| 		if resp != nil {
   669| 			logger.Debug("GET /repos/%v/%v/pulls/%d returned: %v", repo.Owner, repo.Name, num, resp.StatusCode)
   670| 		}
   671| 		if err == nil {
   672| 			return pull, nil
   673| 		}
   674| 		ghErr, ok := err.(*github.ErrorResponse)
   675| 		if !ok || ghErr.Response.StatusCode != 404 {
   676| 			return pull, err


# ====================================================================
# FILE: server/events/vcs/github_credentials.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package vcs
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"net/http"
     6| 	"net/url"
     7| 	"strings"
     8| 	"github.com/bradleyfalzon/ghinstallation/v2"
     9| 	"github.com/google/go-github/v63/github"
    10| 	"github.com/pkg/errors"
    11| )
    12| type GithubCredentials interface {
    13| 	Client() (*http.Client, error)
    14| 	GetToken() (string, error)
    15| 	GetUser() (string, error)
    16| }
    17| type GithubAnonymousCredentials struct{}
    18| func (c *GithubAnonymousCredentials) Client() (*http.Client, error) {
    19| 	tr := http.DefaultTransport
    20| 	return &http.Client{Transport: tr}, nil
    21| }
    22| func (c *GithubAnonymousCredentials) GetUser() (string, error) {
    23| 	return "anonymous", nil
    24| }
    25| func (c *GithubAnonymousCredentials) GetToken() (string, error) {
    26| 	return "", nil
    27| }
    28| type GithubUserCredentials struct {
    29| 	User  string


# ====================================================================
# FILE: server/events/vcs/instrumented_client.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-24 ---
     1| package vcs
     2| import (
     3| 	"strconv"
     4| 	"github.com/google/go-github/v63/github"
     5| 	"github.com/runatlantis/atlantis/server/events/models"
     6| 	"github.com/runatlantis/atlantis/server/logging"
     7| 	"github.com/runatlantis/atlantis/server/metrics"
     8| 	tally "github.com/uber-go/tally/v4"
     9| )
    10| func NewInstrumentedGithubClient(client *GithubClient, statsScope tally.Scope, logger logging.SimpleLogging) IGithubClient {
    11| 	scope := statsScope.SubScope("github")
    12| 	instrumentedGHClient := &InstrumentedClient{
    13| 		Client:     client,
    14| 		StatsScope: scope,
    15| 		Logger:     logger,
    16| 	}
    17| 	return &InstrumentedGithubClient{
    18| 		InstrumentedClient: instrumentedGHClient,
    19| 		PullRequestGetter:  client,
    20| 		StatsScope:         scope,
    21| 		Logger:             logger,
    22| 	}
    23| }
    24| type GithubPullRequestGetter interface {


# ====================================================================
# FILE: server/events/vcs/mocks/mock_github_pull_request_getter.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| package mocks
     2| import (
     3| 	github "github.com/google/go-github/v63/github"
     4| 	pegomock "github.com/petergtz/pegomock/v4"
     5| 	models "github.com/runatlantis/atlantis/server/events/models"
     6| 	logging "github.com/runatlantis/atlantis/server/logging"
     7| 	"reflect"
     8| 	"time"
     9| )
    10| type MockGithubPullRequestGetter struct {
    11| 	fail func(message string, callerSkip ...int)
    12| }
    13| func NewMockGithubPullRequestGetter(options ...pegomock.Option) *MockGithubPullRequestGetter {
    14| 	mock := &MockGithubPullRequestGetter{}
    15| 	for _, option := range options {
    16| 		option.Apply(mock)
    17| 	}
    18| 	return mock
    19| }
    20| func (mock *MockGithubPullRequestGetter) SetFailHandler(fh pegomock.FailHandler) { mock.fail = fh }
    21| func (mock *MockGithubPullRequestGetter) FailHandler() pegomock.FailHandler      { return mock.fail }
    22| func (mock *MockGithubPullRequestGetter) GetPullRequest(logger logging.SimpleLogging, repo models.Repo, pullNum int) (*github.PullRequest, error) {
    23| 	if mock == nil {


# ====================================================================
# FILE: server/server.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 319-377 ---
   319| 			"parsing --%s flag %q", config.AtlantisURLFlag, userConfig.AtlantisURL)
   320| 	}
   321| 	underlyingRouter := mux.NewRouter()
   322| 	router := &Router{
   323| 		AtlantisURL:               parsedURL,
   324| 		LockViewRouteIDQueryParam: LockViewRouteIDQueryParam,
   325| 		LockViewRouteName:         LockViewRouteName,
   326| 		ProjectJobsViewRouteName:  ProjectJobsViewRouteName,
   327| 		Underlying:                underlyingRouter,
   328| 	}
   329| 	var projectCmdOutputHandler jobs.ProjectCommandOutputHandler
   330| 	if userConfig.TFEToken != "" && !userConfig.TFELocalExecutionMode {
   331| 		projectCmdOutputHandler = &jobs.NoopProjectOutputHandler{}
   332| 	} else {
   333| 		projectCmdOutput := make(chan *jobs.ProjectCmdOutputLine)
   334| 		projectCmdOutputHandler = jobs.NewAsyncProjectCommandOutputHandler(
   335| 			projectCmdOutput,
   336| 			logger,
   337| 		)
   338| 	}
   339| 	distribution := terraform.NewDistributionTerraform()
   340| 	if userConfig.TFDistribution == "opentofu" {
   341| 		distribution = terraform.NewDistributionOpenTofu()
   342| 	}
   343| 	terraformClient, err := terraform.NewClient(
   344| 		logger,
   345| 		distribution,
   346| 		binDir,
   347| 		cacheDir,
   348| 		userConfig.TFEToken,
   349| 		userConfig.TFEHostname,
   350| 		userConfig.DefaultTFVersion,
   351| 		config.DefaultTFVersionFlag,
   352| 		userConfig.TFDownloadURL,
   353| 		userConfig.TFDownload,
   354| 		userConfig.UseTFPluginCache,
   355| 		projectCmdOutputHandler)
   356| 	if err != nil && flag.Lookup("test.v") == nil {
   357| 		return nil, errors.Wrap(err, fmt.Sprintf("initializing %s", userConfig.TFDistribution))
   358| 	}
   359| 	markdownRenderer := events.NewMarkdownRenderer(
   360| 		gitlabClient.SupportsCommonMark(),
   361| 		userConfig.DisableApplyAll,
   362| 		disableApply,
   363| 		userConfig.DisableMarkdownFolding,
   364| 		userConfig.DisableRepoLocking,
   365| 		userConfig.EnableDiffMarkdownFormat,
   366| 		userConfig.MarkdownTemplateOverridesDir,
   367| 		userConfig.ExecutableName,
   368| 		userConfig.HideUnchangedPlanComments,
   369| 	)
   370| 	var lockingClient locking.Locker
   371| 	var applyLockingClient locking.ApplyLocker
   372| 	var backend locking.Backend
   373| 	switch dbtype := userConfig.LockingDBType; dbtype {
   374| 	case "redis":
   375| 		logger.Info("Utilizing Redis DB")
   376| 		backend, err = redis.New(userConfig.RedisHost, userConfig.RedisPort, userConfig.RedisPassword, userConfig.RedisTLSEnabled, userConfig.RedisInsecureSkipVerify, userConfig.RedisDB)
   377| 		if err != nil {

# --- HUNK 2: Lines 519-559 ---
   519| 		userConfig.SkipCloneNoChanges,
   520| 		userConfig.EnableRegExpCmd,
   521| 		userConfig.Automerge,
   522| 		userConfig.ParallelPlan,
   523| 		userConfig.ParallelApply,
   524| 		userConfig.AutoplanModulesFromProjects,
   525| 		userConfig.AutoplanFileList,
   526| 		userConfig.RestrictFileList,
   527| 		userConfig.SilenceNoProjects,
   528| 		userConfig.IncludeGitUntrackedFiles,
   529| 		userConfig.AutoDiscoverModeFlag,
   530| 		statsScope,
   531| 		terraformClient,
   532| 	)
   533| 	showStepRunner, err := runtime.NewShowStepRunner(terraformClient, defaultTfVersion)
   534| 	if err != nil {
   535| 		return nil, errors.Wrap(err, "initializing show step runner")
   536| 	}
   537| 	policyCheckStepRunner, err := runtime.NewPolicyCheckStepRunner(
   538| 		defaultTfVersion,
   539| 		policy.NewConfTestExecutorWorkflow(logger, binDir, &policy.ConfTestGoGetterVersionDownloader{}),
   540| 	)
   541| 	if err != nil {
   542| 		return nil, errors.Wrap(err, "initializing policy check step runner")
   543| 	}
   544| 	applyRequirementHandler := &events.DefaultCommandRequirementHandler{
   545| 		WorkingDir: workingDir,
   546| 	}
   547| 	projectCommandRunner := &events.DefaultProjectCommandRunner{
   548| 		VcsClient:        vcsClient,
   549| 		Locker:           projectLocker,
   550| 		LockURLGenerator: router,
   551| 		InitStepRunner: &runtime.InitStepRunner{
   552| 			TerraformExecutor: terraformClient,
   553| 			DefaultTFVersion:  defaultTfVersion,
   554| 		},
   555| 		PlanStepRunner:        runtime.NewPlanStepRunner(terraformClient, defaultTfVersion, commitStatusUpdater, terraformClient),
   556| 		ShowStepRunner:        showStepRunner,
   557| 		PolicyCheckStepRunner: policyCheckStepRunner,
   558| 		ApplyStepRunner: &runtime.ApplyStepRunner{
   559| 			TerraformExecutor:   terraformClient,

# --- HUNK 3: Lines 673-752 ---
   673| 		pullUpdater,
   674| 		pullReqStatusFetcher,
   675| 		projectCommandBuilder,
   676| 		instrumentedProjectCmdRunner,
   677| 		userConfig.SilenceNoProjects,
   678| 	)
   679| 	stateCommandRunner := events.NewStateCommandRunner(
   680| 		pullUpdater,
   681| 		projectCommandBuilder,
   682| 		instrumentedProjectCmdRunner,
   683| 	)
   684| 	commentCommandRunnerByCmd := map[command.Name]events.CommentCommandRunner{
   685| 		command.Plan:            planCommandRunner,
   686| 		command.Apply:           applyCommandRunner,
   687| 		command.ApprovePolicies: approvePoliciesCommandRunner,
   688| 		command.Unlock:          unlockCommandRunner,
   689| 		command.Version:         versionCommandRunner,
   690| 		command.Import:          importCommandRunner,
   691| 		command.State:           stateCommandRunner,
   692| 	}
   693| 	var teamAllowlistChecker command.TeamAllowlistChecker
   694| 	if globalCfg.TeamAuthz.Command != "" {
   695| 		teamAllowlistChecker = &events.ExternalTeamAllowlistChecker{
   696| 			Command:                     globalCfg.TeamAuthz.Command,
   697| 			ExtraArgs:                   globalCfg.TeamAuthz.Args,
   698| 			ExternalTeamAllowlistRunner: &runtime.DefaultExternalTeamAllowlistRunner{},
   699| 		}
   700| 	} else {
   701| 		teamAllowlistChecker, err = command.NewTeamAllowlistChecker(userConfig.GithubTeamAllowlist)
   702| 		if err != nil {
   703| 			return nil, err
   704| 		}
   705| 	}
   706| 	varFileAllowlistChecker, err := events.NewVarFileAllowlistChecker(userConfig.VarFileAllowlist)
   707| 	if err != nil {
   708| 		return nil, err
   709| 	}
   710| 	commandRunner := &events.DefaultCommandRunner{
   711| 		VCSClient:                      vcsClient,
   712| 		GithubPullGetter:               githubClient,
   713| 		GitlabMergeRequestGetter:       gitlabClient,
   714| 		AzureDevopsPullGetter:          azuredevopsClient,
   715| 		GiteaPullGetter:                giteaClient,
   716| 		CommentCommandRunnerByCmd:      commentCommandRunnerByCmd,
   717| 		EventParser:                    eventParser,
   718| 		FailOnPreWorkflowHookError:     userConfig.FailOnPreWorkflowHookError,
   719| 		Logger:                         logger,
   720| 		GlobalCfg:                      globalCfg,
   721| 		StatsScope:                     statsScope.SubScope("cmd"),
   722| 		AllowForkPRs:                   userConfig.AllowForkPRs,
   723| 		AllowForkPRsFlag:               config.AllowForkPRsFlag,
   724| 		SilenceForkPRErrors:            userConfig.SilenceForkPRErrors,
   725| 		SilenceForkPRErrorsFlag:        config.SilenceForkPRErrorsFlag,
   726| 		DisableAutoplan:                userConfig.DisableAutoplan,
   727| 		DisableAutoplanLabel:           userConfig.DisableAutoplanLabel,
   728| 		Drainer:                        drainer,
   729| 		PreWorkflowHooksCommandRunner:  preWorkflowHooksCommandRunner,
   730| 		PostWorkflowHooksCommandRunner: postWorkflowHooksCommandRunner,
   731| 		PullStatusFetcher:              backend,
   732| 		TeamAllowlistChecker:           teamAllowlistChecker,
   733| 		VarFileAllowlistChecker:        varFileAllowlistChecker,
   734| 		CommitStatusUpdater:            commitStatusUpdater,
   735| 	}
   736| 	repoAllowlist, err := events.NewRepoAllowlistChecker(userConfig.RepoAllowlist)
   737| 	if err != nil {
   738| 		return nil, err
   739| 	}
   740| 	locksController := &controllers.LocksController{
   741| 		AtlantisVersion:    config.AtlantisVersion,
   742| 		AtlantisURL:        parsedURL,
   743| 		Locker:             lockingClient,
   744| 		ApplyLocker:        applyLockingClient,
   745| 		Logger:             logger,
   746| 		VCSClient:          vcsClient,
   747| 		LockDetailTemplate: web_templates.LockTemplate,
   748| 		WorkingDir:         workingDir,
   749| 		WorkingDirLocker:   workingDirLocker,
   750| 		Backend:            backend,
   751| 		DeleteLockCommand:  deleteLockCommand,
   752| 	}


# ====================================================================
# FILE: server/user_config.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 77-117 ---
    77| 	QuietPolicyChecks               bool   `mapstructure:"quiet-policy-checks"`
    78| 	RedisDB                         int    `mapstructure:"redis-db"`
    79| 	RedisHost                       string `mapstructure:"redis-host"`
    80| 	RedisPassword                   string `mapstructure:"redis-password"`
    81| 	RedisPort                       int    `mapstructure:"redis-port"`
    82| 	RedisTLSEnabled                 bool   `mapstructure:"redis-tls-enabled"`
    83| 	RedisInsecureSkipVerify         bool   `mapstructure:"redis-insecure-skip-verify"`
    84| 	RepoConfig                      string `mapstructure:"repo-config"`
    85| 	RepoConfigJSON                  string `mapstructure:"repo-config-json"`
    86| 	RepoAllowlist                   string `mapstructure:"repo-allowlist"`
    87| 	SilenceNoProjects   bool `mapstructure:"silence-no-projects"`
    88| 	SilenceForkPRErrors bool `mapstructure:"silence-fork-pr-errors"`
    89| 	SilenceVCSStatusNoPlans bool `mapstructure:"silence-vcs-status-no-plans"`
    90| 	SilenceVCSStatusNoProjects bool            `mapstructure:"silence-vcs-status-no-projects"`
    91| 	SilenceAllowlistErrors     bool            `mapstructure:"silence-allowlist-errors"`
    92| 	SkipCloneNoChanges         bool            `mapstructure:"skip-clone-no-changes"`
    93| 	SlackToken                 string          `mapstructure:"slack-token"`
    94| 	SSLCertFile                string          `mapstructure:"ssl-cert-file"`
    95| 	SSLKeyFile                 string          `mapstructure:"ssl-key-file"`
    96| 	RestrictFileList           bool            `mapstructure:"restrict-file-list"`
    97| 	TFDistribution             string          `mapstructure:"tf-distribution"`
    98| 	TFDownload                 bool            `mapstructure:"tf-download"`
    99| 	TFDownloadURL              string          `mapstructure:"tf-download-url"`
   100| 	TFEHostname                string          `mapstructure:"tfe-hostname"`
   101| 	TFELocalExecutionMode      bool            `mapstructure:"tfe-local-execution-mode"`
   102| 	TFEToken                   string          `mapstructure:"tfe-token"`
   103| 	VarFileAllowlist           string          `mapstructure:"var-file-allowlist"`
   104| 	VCSStatusName              string          `mapstructure:"vcs-status-name"`
   105| 	DefaultTFVersion           string          `mapstructure:"default-tf-version"`
   106| 	Webhooks                   []WebhookConfig `mapstructure:"webhooks" flag:"false"`
   107| 	WebBasicAuth               bool            `mapstructure:"web-basic-auth"`
   108| 	WebUsername                string          `mapstructure:"web-username"`
   109| 	WebPassword                string          `mapstructure:"web-password"`
   110| 	WriteGitCreds              bool            `mapstructure:"write-git-creds"`
   111| 	WebsocketCheckOrigin       bool            `mapstructure:"websocket-check-origin"`
   112| 	UseTFPluginCache           bool            `mapstructure:"use-tf-plugin-cache"`
   113| }
   114| func (u UserConfig) ToAllowCommandNames() ([]command.Name, error) {
   115| 	var allowCommands []command.Name
   116| 	var hasAll bool
   117| 	for _, input := range strings.Split(u.AllowCommands, ",") {

