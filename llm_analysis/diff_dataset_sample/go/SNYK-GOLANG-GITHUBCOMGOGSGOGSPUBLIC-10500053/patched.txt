# ====================================================================
# FILE: docker/build/finalize.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| set -xe
     2| if [ "$(uname -m)" = "aarch64" ]; then
     3|   export arch='arm64'
     4|   export checksum='c3805a85d17f4454c23d7059bcb97e1ec1af272b90126e79ed002342de08389b'
     5| elif [ "$(uname -m)" = "armv7l" ]; then
     6|   export arch='armhf'
     7|   export checksum='e5866286277ff2a2159fb9196fea13e0a59d3f1091ea46ddb985160b94b6841b'
     8| else
     9|   export arch='amd64'
    10|   export checksum='bbc4136d03ab138b1ad66fa4fc051bafc6cc7ffae632b069a53657279a450de3'
    11| fi
    12| wget --quiet https://github.com/tianon/gosu/releases/download/1.17/gosu-${arch} -O /usr/sbin/gosu
    13| echo "${checksum}  /usr/sbin/gosu" | sha256sum -cs
    14| chmod +x /usr/sbin/gosu
    15| addgroup -S git
    16| adduser -G git -H -D -g 'Gogs Git User' git -h /data/git -s /bin/bash && usermod -p '*' git && passwd -u git
    17| echo "export GOGS_CUSTOM=${GOGS_CUSTOM}" >> /etc/profile
    18| rm -rf /app/gogs/build
    19| rm -rf /app/gogs/docker/build
    20| rm /app/gogs/docker/nsswitch.conf
    21| rm /app/gogs/docker/README.md


# ====================================================================
# FILE: docker/build/install-task.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-15 ---
     1| set -xe
     2| if [ "$(uname -m)" = "aarch64" ]; then
     3|   export arch='arm64'
     4|   export checksum='17f325293d08f6f964e0530842e9ef1410dd5f83ee6475b493087391032b0cfd'
     5| elif [ "$(uname -m)" = "armv7l" ]; then
     6|   export arch='arm'
     7|   export checksum='e5b0261e9f6563ce3ace9e038520eb59d2c77c8d85f2b47ab41e1fe7cf321528'
     8| else
     9|   export arch='amd64'
    10|   export checksum='a35462ec71410cccfc428072de830e4478bc57a919d0131ef7897759270dff8f'
    11| fi
    12| wget --quiet https://github.com/go-task/task/releases/download/v3.40.1/task_linux_${arch}.tar.gz -O task_linux_${arch}.tar.gz
    13| echo "${checksum}  task_linux_${arch}.tar.gz" | sha256sum -cs
    14| tar -xzf task_linux_${arch}.tar.gz
    15| mv task /usr/local/bin/task


# ====================================================================
# FILE: gogs.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| package main
     2| import (
     3| 	"os"
     4| 	"github.com/urfave/cli"
     5| 	log "unknwon.dev/clog/v2"
     6| 	"gogs.io/gogs/internal/cmd"
     7| 	"gogs.io/gogs/internal/conf"
     8| )
     9| func init() {
    10| 	conf.App.Version = "0.13.1"
    11| }
    12| func main() {
    13| 	app := cli.NewApp()
    14| 	app.Name = "Gogs"
    15| 	app.Usage = "A painless self-hosted Git service"
    16| 	app.Version = conf.App.Version
    17| 	app.Commands = []cli.Command{
    18| 		cmd.Web,
    19| 		cmd.Serv,
    20| 		cmd.Hook,
    21| 		cmd.Cert,
    22| 		cmd.Admin,
    23| 		cmd.Import,
    24| 		cmd.Backup,
    25| 		cmd.Restore,
    26| 	}
    27| 	if err := app.Run(os.Args); err != nil {
    28| 		log.Fatal("Failed to start application: %v", err)
    29| 	}
    30| }


# ====================================================================
# FILE: internal/db/issue.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 273-313 ---
   273| 		}
   274| 	}
   275| 	return nil
   276| }
   277| func (issue *Issue) ClearLabels(doer *User) (err error) {
   278| 	sess := x.NewSession()
   279| 	defer sess.Close()
   280| 	if err = sess.Begin(); err != nil {
   281| 		return err
   282| 	}
   283| 	if err = issue.clearLabels(sess); err != nil {
   284| 		return err
   285| 	}
   286| 	if err = sess.Commit(); err != nil {
   287| 		return fmt.Errorf("Commit: %v", err)
   288| 	}
   289| 	if issue.IsPull {
   290| 		err = issue.PullRequest.LoadIssue()
   291| 		if err != nil {
   292| 			log.Error("LoadIssue: %v", err)
   293| 			return err
   294| 		}
   295| 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_PULL_REQUEST, &api.PullRequestPayload{
   296| 			Action:      api.HOOK_ISSUE_LABEL_CLEARED,
   297| 			Index:       issue.Index,
   298| 			PullRequest: issue.PullRequest.APIFormat(),
   299| 			Repository:  issue.Repo.APIFormatLegacy(nil),
   300| 			Sender:      doer.APIFormat(),
   301| 		})
   302| 	} else {
   303| 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_ISSUES, &api.IssuesPayload{
   304| 			Action:     api.HOOK_ISSUE_LABEL_CLEARED,
   305| 			Index:      issue.Index,
   306| 			Issue:      issue.APIFormat(),
   307| 			Repository: issue.Repo.APIFormatLegacy(nil),
   308| 			Sender:     doer.APIFormat(),
   309| 		})
   310| 	}
   311| 	if err != nil {
   312| 		log.Error("PrepareWebhooks [is_pull: %v]: %v", issue.IsPull, err)
   313| 	}


# ====================================================================
# FILE: internal/db/milestone.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 259-299 ---
   259| 	defer sess.Close()
   260| 	if err = sess.Begin(); err != nil {
   261| 		return err
   262| 	}
   263| 	if err = changeMilestoneAssign(sess, issue, oldMilestoneID); err != nil {
   264| 		return err
   265| 	}
   266| 	if err = sess.Commit(); err != nil {
   267| 		return fmt.Errorf("Commit: %v", err)
   268| 	}
   269| 	var hookAction api.HookIssueAction
   270| 	if issue.MilestoneID > 0 {
   271| 		hookAction = api.HOOK_ISSUE_MILESTONED
   272| 	} else {
   273| 		hookAction = api.HOOK_ISSUE_DEMILESTONED
   274| 	}
   275| 	if issue.IsPull {
   276| 		err = issue.PullRequest.LoadIssue()
   277| 		if err != nil {
   278| 			log.Error("LoadIssue: %v", err)
   279| 			return err
   280| 		}
   281| 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_PULL_REQUEST, &api.PullRequestPayload{
   282| 			Action:      hookAction,
   283| 			Index:       issue.Index,
   284| 			PullRequest: issue.PullRequest.APIFormat(),
   285| 			Repository:  issue.Repo.APIFormatLegacy(nil),
   286| 			Sender:      doer.APIFormat(),
   287| 		})
   288| 	} else {
   289| 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_ISSUES, &api.IssuesPayload{
   290| 			Action:     hookAction,
   291| 			Index:      issue.Index,
   292| 			Issue:      issue.APIFormat(),
   293| 			Repository: issue.Repo.APIFormatLegacy(nil),
   294| 			Sender:     doer.APIFormat(),
   295| 		})
   296| 	}
   297| 	if err != nil {
   298| 		log.Error("PrepareWebhooks [is_pull: %v]: %v", issue.IsPull, err)
   299| 	}


# ====================================================================
# FILE: internal/db/release.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 80-120 ---
    80| 		Body:            r.Note,
    81| 		Draft:           r.IsDraft,
    82| 		Prerelease:      r.IsPrerelease,
    83| 		Author:          r.Publisher.APIFormat(),
    84| 		Created:         r.Created,
    85| 	}
    86| }
    87| func IsReleaseExist(repoID int64, tagName string) (bool, error) {
    88| 	if tagName == "" {
    89| 		return false, nil
    90| 	}
    91| 	return x.Get(&Release{RepoID: repoID, LowerTagName: strings.ToLower(tagName)})
    92| }
    93| func createTag(gitRepo *git.Repository, r *Release) error {
    94| 	if !r.IsDraft {
    95| 		if !gitRepo.HasTag(r.TagName) {
    96| 			commit, err := gitRepo.BranchCommit(r.Target)
    97| 			if err != nil {
    98| 				return fmt.Errorf("get branch commit: %v", err)
    99| 			}
   100| 			r.TagName = strings.TrimLeft(r.TagName, "-")
   101| 			if err = gitRepo.CreateTag(r.TagName, commit.ID.String()); err != nil {
   102| 				if strings.Contains(err.Error(), "is not a valid tag name") {
   103| 					return ErrInvalidTagName{r.TagName}
   104| 				}
   105| 				return err
   106| 			}
   107| 		} else {
   108| 			commit, err := gitRepo.TagCommit(r.TagName)
   109| 			if err != nil {
   110| 				return fmt.Errorf("get tag commit: %v", err)
   111| 			}
   112| 			r.Sha1 = commit.ID.String()
   113| 			r.NumCommits, err = commit.CommitsCount()
   114| 			if err != nil {
   115| 				return fmt.Errorf("count commits: %v", err)
   116| 			}
   117| 		}
   118| 	}
   119| 	return nil
   120| }


# ====================================================================
# FILE: internal/db/repo_editor.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 152-241 ---
   152| 	err = git.Push(localPath, "origin", opts.NewBranch,
   153| 		git.PushOptions{
   154| 			CommandOptions: git.CommandOptions{
   155| 				Envs: ComposeHookEnvs(ComposeHookEnvsOptions{
   156| 					AuthUser:  doer,
   157| 					OwnerName: repo.MustOwner().Name,
   158| 					OwnerSalt: repo.MustOwner().Salt,
   159| 					RepoID:    repo.ID,
   160| 					RepoName:  repo.Name,
   161| 					RepoPath:  repo.RepoPath(),
   162| 				}),
   163| 			},
   164| 		},
   165| 	)
   166| 	if err != nil {
   167| 		return fmt.Errorf("git push origin %s: %v", opts.NewBranch, err)
   168| 	}
   169| 	return nil
   170| }
   171| func (repo *Repository) GetDiffPreview(branch, treePath, content string) (diff *gitutil.Diff, err error) {
   172| 	if isRepositoryGitPath(treePath) {
   173| 		return nil, errors.Errorf("bad tree path %q", treePath)
   174| 	}
   175| 	repoWorkingPool.CheckIn(com.ToStr(repo.ID))
   176| 	defer repoWorkingPool.CheckOut(com.ToStr(repo.ID))
   177| 	if err = repo.DiscardLocalRepoBranchChanges(branch); err != nil {
   178| 		return nil, fmt.Errorf("discard local repo branch[%s] changes: %v", branch, err)
   179| 	} else if err = repo.UpdateLocalCopyBranch(branch); err != nil {
   180| 		return nil, fmt.Errorf("update local copy branch[%s]: %v", branch, err)
   181| 	}
   182| 	localPath := repo.LocalCopyPath()
   183| 	filePath := path.Join(localPath, treePath)
   184| 	if err = os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
   185| 		return nil, err
   186| 	}
   187| 	if err = os.WriteFile(filePath, []byte(content), 0600); err != nil {
   188| 		return nil, fmt.Errorf("write file: %v", err)
   189| 	}
   190| 	cmd := exec.Command("git", "diff", "--end-of-options", treePath)
   191| 	cmd.Dir = localPath
   192| 	cmd.Stderr = os.Stderr
   193| 	stdout, err := cmd.StdoutPipe()
   194| 	if err != nil {
   195| 		return nil, fmt.Errorf("get stdout pipe: %v", err)
   196| 	}
   197| 	if err = cmd.Start(); err != nil {
   198| 		return nil, fmt.Errorf("start: %v", err)
   199| 	}
   200| 	pid := process.Add(fmt.Sprintf("GetDiffPreview [repo_path: %s]", repo.RepoPath()), cmd)
   201| 	defer process.Remove(pid)
   202| 	diff, err = gitutil.ParseDiff(stdout, conf.Git.MaxDiffFiles, conf.Git.MaxDiffLines, conf.Git.MaxDiffLineChars)
   203| 	if err != nil {
   204| 		return nil, fmt.Errorf("parse diff: %v", err)
   205| 	}
   206| 	if err = cmd.Wait(); err != nil {
   207| 		return nil, fmt.Errorf("wait: %v", err)
   208| 	}
   209| 	return diff, nil
   210| }
   211| type DeleteRepoFileOptions struct {
   212| 	LastCommitID string
   213| 	OldBranch    string
   214| 	NewBranch    string
   215| 	TreePath     string
   216| 	Message      string
   217| }
   218| func (repo *Repository) DeleteRepoFile(doer *User, opts DeleteRepoFileOptions) (err error) {
   219| 	if isRepositoryGitPath(opts.TreePath) {
   220| 		return errors.Errorf("bad tree path %q", opts.TreePath)
   221| 	}
   222| 	repoWorkingPool.CheckIn(com.ToStr(repo.ID))
   223| 	defer repoWorkingPool.CheckOut(com.ToStr(repo.ID))
   224| 	if err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {
   225| 		return fmt.Errorf("discard local repo branch[%s] changes: %v", opts.OldBranch, err)
   226| 	} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {
   227| 		return fmt.Errorf("update local copy branch[%s]: %v", opts.OldBranch, err)
   228| 	}
   229| 	if opts.OldBranch != opts.NewBranch {
   230| 		if err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {
   231| 			return fmt.Errorf("checkout new branch[%s] from old branch[%s]: %v", opts.NewBranch, opts.OldBranch, err)
   232| 		}
   233| 	}
   234| 	localPath := repo.LocalCopyPath()
   235| 	if err = os.Remove(path.Join(localPath, opts.TreePath)); err != nil {
   236| 		return fmt.Errorf("remove file %q: %v", opts.TreePath, err)
   237| 	}
   238| 	if err = git.Add(localPath, git.AddOptions{All: true}); err != nil {
   239| 		return fmt.Errorf("git add --all: %v", err)
   240| 	}
   241| 	err = git.CreateCommit(


# ====================================================================
# FILE: internal/route/api/v1/repo/contents.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| package repo
     2| import (
     3| 	"encoding/base64"
     4| 	"fmt"
     5| 	"net/http"
     6| 	"path"
     7| 	"github.com/gogs/git-module"
     8| 	"github.com/pkg/errors"
     9| 	"gogs.io/gogs/internal/context"
    10| 	"gogs.io/gogs/internal/db"
    11| 	"gogs.io/gogs/internal/gitutil"
    12| 	"gogs.io/gogs/internal/pathutil"
    13| 	"gogs.io/gogs/internal/repoutil"
    14| )
    15| type links struct {
    16| 	Git  string `json:"git"`
    17| 	Self string `json:"self"`
    18| 	HTML string `json:"html"`
    19| }
    20| type repoContent struct {
    21| 	Type            string `json:"type"`
    22| 	Target          string `json:"target,omitempty"`
    23| 	SubmoduleGitURL string `json:"submodule_git_url,omitempty"`
    24| 	Encoding        string `json:"encoding,omitempty"`
    25| 	Size            int64  `json:"size"`
    26| 	Name            string `json:"name"`
    27| 	Path            string `json:"path"`
    28| 	Content         string `json:"content,omitempty"`
    29| 	Sha             string `json:"sha"`
    30| 	URL             string `json:"url"`
    31| 	GitURL          string `json:"git_url"`
    32| 	HTMLURL         string `json:"html_url"`

# --- HUNK 2: Lines 83-123 ---
    83| 	}
    84| 	content.Links.Git = content.GitURL
    85| 	return content, nil
    86| }
    87| func GetContents(c *context.APIContext) {
    88| 	repoPath := repoutil.RepositoryPath(c.Params(":username"), c.Params(":reponame"))
    89| 	gitRepo, err := git.Open(repoPath)
    90| 	if err != nil {
    91| 		c.Error(err, "open repository")
    92| 		return
    93| 	}
    94| 	ref := c.Query("ref")
    95| 	if ref == "" {
    96| 		ref = c.Repo.Repository.DefaultBranch
    97| 	}
    98| 	commit, err := gitRepo.CatFileCommit(ref)
    99| 	if err != nil {
   100| 		c.NotFoundOrError(gitutil.NewError(err), "get commit")
   101| 		return
   102| 	}
   103| 	treePath := pathutil.Clean(c.Params("*"))
   104| 	entry, err := commit.TreeEntry(treePath)
   105| 	if err != nil {
   106| 		c.NotFoundOrError(gitutil.NewError(err), "get tree entry")
   107| 		return
   108| 	}
   109| 	if !entry.IsTree() {
   110| 		content, err := toRepoContent(c, ref, treePath, commit, entry)
   111| 		if err != nil {
   112| 			c.Errorf(err, "convert %q to repoContent", treePath)
   113| 			return
   114| 		}
   115| 		c.JSONSuccess(content)
   116| 		return
   117| 	}
   118| 	dir, err := gitRepo.LsTree(entry.ID().String())
   119| 	if err != nil {
   120| 		c.NotFoundOrError(gitutil.NewError(err), "get tree")
   121| 		return
   122| 	}
   123| 	entries, err := dir.Entries()

# --- HUNK 3: Lines 138-178 ---
   138| 			return
   139| 		}
   140| 		contents = append(contents, content)
   141| 	}
   142| 	c.JSONSuccess(contents)
   143| }
   144| type PutContentsRequest struct {
   145| 	Message string `json:"message" binding:"Required"`
   146| 	Content string `json:"content" binding:"Required"`
   147| 	Branch  string `json:"branch"`
   148| }
   149| func PutContents(c *context.APIContext, r PutContentsRequest) {
   150| 	content, err := base64.StdEncoding.DecodeString(r.Content)
   151| 	if err != nil {
   152| 		c.Error(err, "decoding base64")
   153| 		return
   154| 	}
   155| 	if r.Branch == "" {
   156| 		r.Branch = c.Repo.Repository.DefaultBranch
   157| 	}
   158| 	treePath := pathutil.Clean(c.Params("*"))
   159| 	err = c.Repo.Repository.UpdateRepoFile(
   160| 		c.User,
   161| 		db.UpdateRepoFileOptions{
   162| 			OldBranch:   c.Repo.Repository.DefaultBranch,
   163| 			NewBranch:   r.Branch,
   164| 			OldTreeName: treePath,
   165| 			NewTreeName: treePath,
   166| 			Message:     r.Message,
   167| 			Content:     string(content),
   168| 		},
   169| 	)
   170| 	if err != nil {
   171| 		c.Error(err, "updating repository file")
   172| 		return
   173| 	}
   174| 	repoPath := repoutil.RepositoryPath(c.Params(":username"), c.Params(":reponame"))
   175| 	gitRepo, err := git.Open(repoPath)
   176| 	if err != nil {
   177| 		c.Error(err, "open repository")
   178| 		return


# ====================================================================
# FILE: internal/route/install.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 251-297 ---
   251| 	cfg.Section("database").Key("SCHEMA").SetValue(conf.Database.Schema)
   252| 	cfg.Section("database").Key("USER").SetValue(conf.Database.User)
   253| 	cfg.Section("database").Key("PASSWORD").SetValue(conf.Database.Password)
   254| 	cfg.Section("database").Key("SSL_MODE").SetValue(conf.Database.SSLMode)
   255| 	cfg.Section("database").Key("PATH").SetValue(conf.Database.Path)
   256| 	cfg.Section("").Key("BRAND_NAME").SetValue(f.AppName)
   257| 	cfg.Section("repository").Key("ROOT").SetValue(f.RepoRootPath)
   258| 	cfg.Section("repository").Key("DEFAULT_BRANCH").SetValue(f.DefaultBranch)
   259| 	cfg.Section("").Key("RUN_USER").SetValue(f.RunUser)
   260| 	cfg.Section("server").Key("DOMAIN").SetValue(f.Domain)
   261| 	cfg.Section("server").Key("HTTP_PORT").SetValue(f.HTTPPort)
   262| 	cfg.Section("server").Key("EXTERNAL_URL").SetValue(f.AppUrl)
   263| 	if f.SSHPort == 0 {
   264| 		cfg.Section("server").Key("DISABLE_SSH").SetValue("true")
   265| 	} else {
   266| 		cfg.Section("server").Key("DISABLE_SSH").SetValue("false")
   267| 		cfg.Section("server").Key("SSH_PORT").SetValue(com.ToStr(f.SSHPort))
   268| 		cfg.Section("server").Key("START_SSH_SERVER").SetValue(com.ToStr(f.UseBuiltinSSHServer))
   269| 	}
   270| 	if len(strings.TrimSpace(f.SMTPHost)) > 0 {
   271| 		cfg.Section("email").Key("ENABLED").SetValue("true")
   272| 		cfg.Section("email").Key("HOST").SetValue(f.SMTPHost)
   273| 		cfg.Section("email").Key("FROM").SetValue(f.SMTPFrom)
   274| 		cfg.Section("email").Key("USER").SetValue(f.SMTPUser)
   275| 		cfg.Section("email").Key("PASSWORD").SetValue(f.SMTPPasswd)
   276| 	} else {
   277| 		cfg.Section("email").Key("ENABLED").SetValue("false")
   278| 	}
   279| 	cfg.Section("server").Key("OFFLINE_MODE").SetValue(com.ToStr(f.OfflineMode))
   280| 	cfg.Section("auth").Key("REQUIRE_EMAIL_CONFIRMATION").SetValue(com.ToStr(f.RegisterConfirm))
   281| 	cfg.Section("auth").Key("DISABLE_REGISTRATION").SetValue(com.ToStr(f.DisableRegistration))
   282| 	cfg.Section("auth").Key("ENABLE_REGISTRATION_CAPTCHA").SetValue(com.ToStr(f.EnableCaptcha))
   283| 	cfg.Section("auth").Key("REQUIRE_SIGNIN_VIEW").SetValue(com.ToStr(f.RequireSignInView))
   284| 	cfg.Section("user").Key("ENABLE_EMAIL_NOTIFICATION").SetValue(com.ToStr(f.MailNotify))
   285| 	cfg.Section("picture").Key("DISABLE_GRAVATAR").SetValue(com.ToStr(f.DisableGravatar))
   286| 	cfg.Section("picture").Key("ENABLE_FEDERATED_AVATAR").SetValue(com.ToStr(f.EnableFederatedAvatar))
   287| 	cfg.Section("").Key("RUN_MODE").SetValue("prod")
   288| 	cfg.Section("session").Key("PROVIDER").SetValue("file")
   289| 	mode := "file"
   290| 	if f.EnableConsoleMode {
   291| 		mode = "console, file"
   292| 	}
   293| 	cfg.Section("log").Key("MODE").SetValue(mode)
   294| 	cfg.Section("log").Key("LEVEL").SetValue("Info")
   295| 	cfg.Section("log").Key("ROOT_PATH").SetValue(f.LogRootPath)
   296| 	cfg.Section("security").Key("INSTALL_LOCK").SetValue("true")
   297| 	secretKey, err := strutil.RandomChars(15)


# ====================================================================
# FILE: internal/route/repo/editor.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 150-202 ---
   150| 		}
   151| 		if index != len(treeNames)-1 {
   152| 			if !entry.IsTree() {
   153| 				c.FormErr("TreePath")
   154| 				c.RenderWithErr(c.Tr("repo.editor.directory_is_a_file", part), tmplEditorEdit, &f)
   155| 				return
   156| 			}
   157| 		} else {
   158| 			if entry.IsSymlink() {
   159| 				c.FormErr("TreePath")
   160| 				c.RenderWithErr(c.Tr("repo.editor.file_is_a_symlink", part), tmplEditorEdit, &f)
   161| 				return
   162| 			} else if entry.IsTree() {
   163| 				c.FormErr("TreePath")
   164| 				c.RenderWithErr(c.Tr("repo.editor.filename_is_a_directory", part), tmplEditorEdit, &f)
   165| 				return
   166| 			}
   167| 		}
   168| 	}
   169| 	if !isNewFile {
   170| 		entry, err := c.Repo.Commit.TreeEntry(oldTreePath)
   171| 		if err != nil {
   172| 			if gitutil.IsErrRevisionNotExist(err) {
   173| 				c.FormErr("TreePath")
   174| 				c.RenderWithErr(c.Tr("repo.editor.file_editing_no_longer_exists", oldTreePath), tmplEditorEdit, &f)
   175| 			} else {
   176| 				c.Error(err, "get tree entry")
   177| 			}
   178| 			return
   179| 		}
   180| 		if entry.IsSymlink() {
   181| 			c.FormErr("TreePath")
   182| 			c.RenderWithErr(c.Tr("repo.editor.file_is_a_symlink", oldTreePath), tmplEditorEdit, &f)
   183| 			return
   184| 		}
   185| 		if lastCommit != c.Repo.CommitID {
   186| 			files, err := c.Repo.Commit.FilesChangedAfter(lastCommit)
   187| 			if err != nil {
   188| 				c.Error(err, "get changed files")
   189| 				return
   190| 			}
   191| 			for _, file := range files {
   192| 				if file == f.TreePath {
   193| 					c.RenderWithErr(c.Tr("repo.editor.file_changed_while_editing", c.Repo.RepoLink+"/compare/"+lastCommit+"..."+c.Repo.CommitID), tmplEditorEdit, &f)
   194| 					return
   195| 				}
   196| 			}
   197| 		}
   198| 	}
   199| 	if oldTreePath != f.TreePath {
   200| 		entry, err := c.Repo.Commit.TreeEntry(f.TreePath)
   201| 		if err != nil {
   202| 			if !gitutil.IsErrRevisionNotExist(err) {

# --- HUNK 2: Lines 232-272 ---
   232| 		IsNewFile:   isNewFile,
   233| 	}); err != nil {
   234| 		log.Error("Failed to update repo file: %v", err)
   235| 		c.FormErr("TreePath")
   236| 		c.RenderWithErr(c.Tr("repo.editor.fail_to_update_file", f.TreePath, errors.InternalServerError), tmplEditorEdit, &f)
   237| 		return
   238| 	}
   239| 	if f.IsNewBrnach() && c.Repo.PullRequest.Allowed {
   240| 		c.Redirect(c.Repo.PullRequestURL(oldBranchName, f.NewBranchName))
   241| 	} else {
   242| 		c.Redirect(c.Repo.RepoLink + "/src/" + branchName + "/" + f.TreePath)
   243| 	}
   244| }
   245| func EditFilePost(c *context.Context, f form.EditRepoFile) {
   246| 	editFilePost(c, f, false)
   247| }
   248| func NewFilePost(c *context.Context, f form.EditRepoFile) {
   249| 	editFilePost(c, f, true)
   250| }
   251| func DiffPreviewPost(c *context.Context, f form.EditPreviewDiff) {
   252| 	treePath := pathutil.Clean(c.Repo.TreePath)
   253| 	entry, err := c.Repo.Commit.TreeEntry(treePath)
   254| 	if err != nil {
   255| 		c.Error(err, "get tree entry")
   256| 		return
   257| 	} else if entry.IsTree() {
   258| 		c.Status(http.StatusUnprocessableEntity)
   259| 		return
   260| 	}
   261| 	diff, err := c.Repo.Repository.GetDiffPreview(c.Repo.BranchName, treePath, f.Content)
   262| 	if err != nil {
   263| 		c.Error(err, "get diff preview")
   264| 		return
   265| 	}
   266| 	if diff.NumFiles() == 0 {
   267| 		c.PlainText(http.StatusOK, c.Tr("repo.editor.no_changes_to_show"))
   268| 		return
   269| 	}
   270| 	c.Data["File"] = diff.Files[0]
   271| 	c.Success(tmplEditorDiffPreview)
   272| }


# ====================================================================
# FILE: internal/ssh/ssh.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| package ssh
     2| import (
     3| 	"context"
     4| 	"io"
     5| 	"net"
     6| 	"os"
     7| 	"os/exec"
     8| 	"path/filepath"
     9| 	"strings"
    10| 	"syscall"
    11| 	"github.com/pkg/errors"
    12| 	"github.com/sourcegraph/run"
    13| 	"github.com/unknwon/com"
    14| 	"golang.org/x/crypto/ssh"
    15| 	log "unknwon.dev/clog/v2"
    16| 	"gogs.io/gogs/internal/conf"
    17| 	"gogs.io/gogs/internal/db"
    18| 	"gogs.io/gogs/internal/osutil"
    19| )
    20| func cleanCommand(cmd string) string {
    21| 	i := strings.Index(cmd, "git")
    22| 	if i == -1 {
    23| 		return cmd

# --- HUNK 2: Lines 26-65 ---
    26| }
    27| func handleServerConn(keyID string, chans <-chan ssh.NewChannel) {
    28| 	for newChan := range chans {
    29| 		if newChan.ChannelType() != "session" {
    30| 			_ = newChan.Reject(ssh.UnknownChannelType, "unknown channel type")
    31| 			continue
    32| 		}
    33| 		ch, reqs, err := newChan.Accept()
    34| 		if err != nil {
    35| 			log.Error("Error accepting channel: %v", err)
    36| 			continue
    37| 		}
    38| 		go func(in <-chan *ssh.Request) {
    39| 			defer func() {
    40| 				_ = ch.Close()
    41| 			}()
    42| 			for req := range in {
    43| 				payload := cleanCommand(string(req.Payload))
    44| 				switch req.Type {
    45| 				case "env":
    46| 				case "exec":
    47| 					cmdName := strings.TrimLeft(payload, "'()")
    48| 					log.Trace("SSH: Payload: %v", cmdName)
    49| 					args := []string{"serv", "key-" + keyID, "--config=" + conf.CustomConf}
    50| 					log.Trace("SSH: Arguments: %v", args)
    51| 					cmd := exec.Command(conf.AppPath(), args...)
    52| 					cmd.Env = append(os.Environ(), "SSH_ORIGINAL_COMMAND="+cmdName)
    53| 					stdout, err := cmd.StdoutPipe()
    54| 					if err != nil {
    55| 						log.Error("SSH: StdoutPipe: %v", err)
    56| 						return
    57| 					}
    58| 					stderr, err := cmd.StderrPipe()
    59| 					if err != nil {
    60| 						log.Error("SSH: StderrPipe: %v", err)
    61| 						return
    62| 					}
    63| 					input, err := cmd.StdinPipe()
    64| 					if err != nil {
    65| 						log.Error("SSH: StdinPipe: %v", err)

# --- HUNK 3: Lines 107-149 ---
   107| 				} else {
   108| 					log.Error("SSH: Error on handshaking: %v", err)
   109| 				}
   110| 				return
   111| 			}
   112| 			log.Trace("SSH: Connection from %s (%s)", sConn.RemoteAddr(), sConn.ClientVersion())
   113| 			go ssh.DiscardRequests(reqs)
   114| 			go handleServerConn(sConn.Permissions.Extensions["key-id"], chans)
   115| 		}()
   116| 	}
   117| }
   118| func Listen(opts conf.SSHOpts, appDataPath string) {
   119| 	config := &ssh.ServerConfig{
   120| 		Config: ssh.Config{
   121| 			Ciphers: opts.ServerCiphers,
   122| 			MACs:    opts.ServerMACs,
   123| 		},
   124| 		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
   125| 			pkey, err := db.SearchPublicKeyByContent(strings.TrimSpace(string(ssh.MarshalAuthorizedKey(key))))
   126| 			if err != nil {
   127| 				if !db.IsErrKeyNotExist(err) {
   128| 					log.Error("SearchPublicKeyByContent: %v", err)
   129| 				}
   130| 				return nil, err
   131| 			}
   132| 			return &ssh.Permissions{Extensions: map[string]string{"key-id": com.ToStr(pkey.ID)}}, nil
   133| 		},
   134| 	}
   135| 	keys, err := setupHostKeys(appDataPath, opts.ServerAlgorithms)
   136| 	if err != nil {
   137| 		log.Fatal("SSH: Failed to setup host keys: %v", err)
   138| 	}
   139| 	for _, key := range keys {
   140| 		config.AddHostKey(key)
   141| 	}
   142| 	go listen(config, opts.ListenHost, opts.ListenPort)
   143| }
   144| func setupHostKeys(appDataPath string, algorithms []string) ([]ssh.Signer, error) {
   145| 	dir := filepath.Join(appDataPath, "ssh")
   146| 	err := os.MkdirAll(dir, os.ModePerm)
   147| 	if err != nil {
   148| 		return nil, errors.Wrapf(err, "create host key directory")
   149| 	}

