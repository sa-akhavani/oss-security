--- a/docker/build/finalize.sh
+++ b/docker/build/finalize.sh
@@ -1,21 +1,21 @@
 set -xe
 if [ "$(uname -m)" = "aarch64" ]; then
   export arch='arm64'
-  export checksum='c3805a85d17f4454c23d7059bcb97e1ec1af272b90126e79ed002342de08389b'
+  export checksum='73244a858f5514a927a0f2510d533b4b57169b64d2aa3f9d98d92a7a7df80cea'
 elif [ "$(uname -m)" = "armv7l" ]; then
   export arch='armhf'
-  export checksum='e5866286277ff2a2159fb9196fea13e0a59d3f1091ea46ddb985160b94b6841b'
+  export checksum='abb1489357358b443789571d52b5410258ddaca525ee7ac3ba0dd91d34484589'
 else
   export arch='amd64'
-  export checksum='bbc4136d03ab138b1ad66fa4fc051bafc6cc7ffae632b069a53657279a450de3'
+  export checksum='bd8be776e97ec2b911190a82d9ab3fa6c013ae6d3121eea3d0bfd5c82a0eaf8c'
 fi
-wget --quiet https://github.com/tianon/gosu/releases/download/1.17/gosu-${arch} -O /usr/sbin/gosu
+wget --quiet https://github.com/tianon/gosu/releases/download/1.14/gosu-${arch} -O /usr/sbin/gosu
 echo "${checksum}  /usr/sbin/gosu" | sha256sum -cs
 chmod +x /usr/sbin/gosu
 addgroup -S git
 adduser -G git -H -D -g 'Gogs Git User' git -h /data/git -s /bin/bash && usermod -p '*' git && passwd -u git
 echo "export GOGS_CUSTOM=${GOGS_CUSTOM}" >> /etc/profile
 rm -rf /app/gogs/build
 rm -rf /app/gogs/docker/build
 rm /app/gogs/docker/nsswitch.conf
 rm /app/gogs/docker/README.md

--- a/docker/build/install-task.sh
+++ b/docker/build/install-task.sh
@@ -1,15 +1,15 @@
 set -xe
 if [ "$(uname -m)" = "aarch64" ]; then
   export arch='arm64'
-  export checksum='17f325293d08f6f964e0530842e9ef1410dd5f83ee6475b493087391032b0cfd'
+  export checksum='44fad3d61ad39d0abff33f90fdbb99a666524dbeab08dc9d138d5d3a532ff68a'
 elif [ "$(uname -m)" = "armv7l" ]; then
   export arch='arm'
-  export checksum='e5b0261e9f6563ce3ace9e038520eb59d2c77c8d85f2b47ab41e1fe7cf321528'
+  export checksum='b10ae7d85749025740097b0c349b946fbabd417c7ee4d2df8ccc5604750accd9'
 else
   export arch='amd64'
-  export checksum='a35462ec71410cccfc428072de830e4478bc57a919d0131ef7897759270dff8f'
+  export checksum='b9c5986f33a53094751b5e22ccc33e050b4a0a485658442121331cbb724e631e'
 fi
-wget --quiet https://github.com/go-task/task/releases/download/v3.40.1/task_linux_${arch}.tar.gz -O task_linux_${arch}.tar.gz
+wget --quiet https://github.com/go-task/task/releases/download/v3.12.1/task_linux_${arch}.tar.gz -O task_linux_${arch}.tar.gz
 echo "${checksum}  task_linux_${arch}.tar.gz" | sha256sum -cs
 tar -xzf task_linux_${arch}.tar.gz
 mv task /usr/local/bin/task

--- a/gogs.go
+++ b/gogs.go
@@ -1,20 +1,20 @@
 package main
 import (
 	"os"
 	"github.com/urfave/cli"
 	log "unknwon.dev/clog/v2"
 	"gogs.io/gogs/internal/cmd"
 	"gogs.io/gogs/internal/conf"
 )
 func init() {
-	conf.App.Version = "0.13.1"
+	conf.App.Version = "0.13.0"
 }
 func main() {
 	app := cli.NewApp()
 	app.Name = "Gogs"
 	app.Usage = "A painless self-hosted Git service"
 	app.Version = conf.App.Version
 	app.Commands = []cli.Command{
 		cmd.Web,
 		cmd.Serv,
 		cmd.Hook,

--- a/internal/db/issue.go
+++ b/internal/db/issue.go
@@ -283,21 +283,21 @@
 	if err = issue.clearLabels(sess); err != nil {
 		return err
 	}
 	if err = sess.Commit(); err != nil {
 		return fmt.Errorf("Commit: %v", err)
 	}
 	if issue.IsPull {
 		err = issue.PullRequest.LoadIssue()
 		if err != nil {
 			log.Error("LoadIssue: %v", err)
-			return err
+			return
 		}
 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_PULL_REQUEST, &api.PullRequestPayload{
 			Action:      api.HOOK_ISSUE_LABEL_CLEARED,
 			Index:       issue.Index,
 			PullRequest: issue.PullRequest.APIFormat(),
 			Repository:  issue.Repo.APIFormatLegacy(nil),
 			Sender:      doer.APIFormat(),
 		})
 	} else {
 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_ISSUES, &api.IssuesPayload{

--- a/internal/db/milestone.go
+++ b/internal/db/milestone.go
@@ -269,21 +269,21 @@
 	var hookAction api.HookIssueAction
 	if issue.MilestoneID > 0 {
 		hookAction = api.HOOK_ISSUE_MILESTONED
 	} else {
 		hookAction = api.HOOK_ISSUE_DEMILESTONED
 	}
 	if issue.IsPull {
 		err = issue.PullRequest.LoadIssue()
 		if err != nil {
 			log.Error("LoadIssue: %v", err)
-			return err
+			return
 		}
 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_PULL_REQUEST, &api.PullRequestPayload{
 			Action:      hookAction,
 			Index:       issue.Index,
 			PullRequest: issue.PullRequest.APIFormat(),
 			Repository:  issue.Repo.APIFormatLegacy(nil),
 			Sender:      doer.APIFormat(),
 		})
 	} else {
 		err = PrepareWebhooks(issue.Repo, HOOK_EVENT_ISSUES, &api.IssuesPayload{

--- a/internal/db/release.go
+++ b/internal/db/release.go
@@ -90,21 +90,21 @@
 	}
 	return x.Get(&Release{RepoID: repoID, LowerTagName: strings.ToLower(tagName)})
 }
 func createTag(gitRepo *git.Repository, r *Release) error {
 	if !r.IsDraft {
 		if !gitRepo.HasTag(r.TagName) {
 			commit, err := gitRepo.BranchCommit(r.Target)
 			if err != nil {
 				return fmt.Errorf("get branch commit: %v", err)
 			}
-			r.TagName = strings.TrimLeft(r.TagName, "-")
+			r.TagName = strings.TrimPrefix(r.TagName, "--")
 			if err = gitRepo.CreateTag(r.TagName, commit.ID.String()); err != nil {
 				if strings.Contains(err.Error(), "is not a valid tag name") {
 					return ErrInvalidTagName{r.TagName}
 				}
 				return err
 			}
 		} else {
 			commit, err := gitRepo.TagCommit(r.TagName)
 			if err != nil {
 				return fmt.Errorf("get tag commit: %v", err)

--- a/internal/db/repo_editor.go
+++ b/internal/db/repo_editor.go
@@ -162,39 +162,36 @@
 				}),
 			},
 		},
 	)
 	if err != nil {
 		return fmt.Errorf("git push origin %s: %v", opts.NewBranch, err)
 	}
 	return nil
 }
 func (repo *Repository) GetDiffPreview(branch, treePath, content string) (diff *gitutil.Diff, err error) {
-	if isRepositoryGitPath(treePath) {
-		return nil, errors.Errorf("bad tree path %q", treePath)
-	}
 	repoWorkingPool.CheckIn(com.ToStr(repo.ID))
 	defer repoWorkingPool.CheckOut(com.ToStr(repo.ID))
 	if err = repo.DiscardLocalRepoBranchChanges(branch); err != nil {
 		return nil, fmt.Errorf("discard local repo branch[%s] changes: %v", branch, err)
 	} else if err = repo.UpdateLocalCopyBranch(branch); err != nil {
 		return nil, fmt.Errorf("update local copy branch[%s]: %v", branch, err)
 	}
 	localPath := repo.LocalCopyPath()
 	filePath := path.Join(localPath, treePath)
 	if err = os.MkdirAll(filepath.Dir(filePath), os.ModePerm); err != nil {
 		return nil, err
 	}
 	if err = os.WriteFile(filePath, []byte(content), 0600); err != nil {
 		return nil, fmt.Errorf("write file: %v", err)
 	}
-	cmd := exec.Command("git", "diff", "--end-of-options", treePath)
+	cmd := exec.Command("git", "diff", treePath)
 	cmd.Dir = localPath
 	cmd.Stderr = os.Stderr
 	stdout, err := cmd.StdoutPipe()
 	if err != nil {
 		return nil, fmt.Errorf("get stdout pipe: %v", err)
 	}
 	if err = cmd.Start(); err != nil {
 		return nil, fmt.Errorf("start: %v", err)
 	}
 	pid := process.Add(fmt.Sprintf("GetDiffPreview [repo_path: %s]", repo.RepoPath()), cmd)
@@ -209,23 +206,20 @@
 	return diff, nil
 }
 type DeleteRepoFileOptions struct {
 	LastCommitID string
 	OldBranch    string
 	NewBranch    string
 	TreePath     string
 	Message      string
 }
 func (repo *Repository) DeleteRepoFile(doer *User, opts DeleteRepoFileOptions) (err error) {
-	if isRepositoryGitPath(opts.TreePath) {
-		return errors.Errorf("bad tree path %q", opts.TreePath)
-	}
 	repoWorkingPool.CheckIn(com.ToStr(repo.ID))
 	defer repoWorkingPool.CheckOut(com.ToStr(repo.ID))
 	if err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {
 		return fmt.Errorf("discard local repo branch[%s] changes: %v", opts.OldBranch, err)
 	} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {
 		return fmt.Errorf("update local copy branch[%s]: %v", opts.OldBranch, err)
 	}
 	if opts.OldBranch != opts.NewBranch {
 		if err := repo.CheckoutNewBranch(opts.OldBranch, opts.NewBranch); err != nil {
 			return fmt.Errorf("checkout new branch[%s] from old branch[%s]: %v", opts.NewBranch, opts.OldBranch, err)

--- a/internal/route/api/v1/repo/contents.go
+++ b/internal/route/api/v1/repo/contents.go
@@ -2,21 +2,20 @@
 import (
 	"encoding/base64"
 	"fmt"
 	"net/http"
 	"path"
 	"github.com/gogs/git-module"
 	"github.com/pkg/errors"
 	"gogs.io/gogs/internal/context"
 	"gogs.io/gogs/internal/db"
 	"gogs.io/gogs/internal/gitutil"
-	"gogs.io/gogs/internal/pathutil"
 	"gogs.io/gogs/internal/repoutil"
 )
 type links struct {
 	Git  string `json:"git"`
 	Self string `json:"self"`
 	HTML string `json:"html"`
 }
 type repoContent struct {
 	Type            string `json:"type"`
 	Target          string `json:"target,omitempty"`
@@ -93,21 +92,21 @@
 	}
 	ref := c.Query("ref")
 	if ref == "" {
 		ref = c.Repo.Repository.DefaultBranch
 	}
 	commit, err := gitRepo.CatFileCommit(ref)
 	if err != nil {
 		c.NotFoundOrError(gitutil.NewError(err), "get commit")
 		return
 	}
-	treePath := pathutil.Clean(c.Params("*"))
+	treePath := c.Params("*")
 	entry, err := commit.TreeEntry(treePath)
 	if err != nil {
 		c.NotFoundOrError(gitutil.NewError(err), "get tree entry")
 		return
 	}
 	if !entry.IsTree() {
 		content, err := toRepoContent(c, ref, treePath, commit, entry)
 		if err != nil {
 			c.Errorf(err, "convert %q to repoContent", treePath)
 			return
@@ -148,21 +147,21 @@
 }
 func PutContents(c *context.APIContext, r PutContentsRequest) {
 	content, err := base64.StdEncoding.DecodeString(r.Content)
 	if err != nil {
 		c.Error(err, "decoding base64")
 		return
 	}
 	if r.Branch == "" {
 		r.Branch = c.Repo.Repository.DefaultBranch
 	}
-	treePath := pathutil.Clean(c.Params("*"))
+	treePath := c.Params("*")
 	err = c.Repo.Repository.UpdateRepoFile(
 		c.User,
 		db.UpdateRepoFileOptions{
 			OldBranch:   c.Repo.Repository.DefaultBranch,
 			NewBranch:   r.Branch,
 			OldTreeName: treePath,
 			NewTreeName: treePath,
 			Message:     r.Message,
 			Content:     string(content),
 		},

--- a/internal/route/install.go
+++ b/internal/route/install.go
@@ -261,27 +261,27 @@
 	cfg.Section("server").Key("HTTP_PORT").SetValue(f.HTTPPort)
 	cfg.Section("server").Key("EXTERNAL_URL").SetValue(f.AppUrl)
 	if f.SSHPort == 0 {
 		cfg.Section("server").Key("DISABLE_SSH").SetValue("true")
 	} else {
 		cfg.Section("server").Key("DISABLE_SSH").SetValue("false")
 		cfg.Section("server").Key("SSH_PORT").SetValue(com.ToStr(f.SSHPort))
 		cfg.Section("server").Key("START_SSH_SERVER").SetValue(com.ToStr(f.UseBuiltinSSHServer))
 	}
 	if len(strings.TrimSpace(f.SMTPHost)) > 0 {
-		cfg.Section("email").Key("ENABLED").SetValue("true")
-		cfg.Section("email").Key("HOST").SetValue(f.SMTPHost)
-		cfg.Section("email").Key("FROM").SetValue(f.SMTPFrom)
-		cfg.Section("email").Key("USER").SetValue(f.SMTPUser)
-		cfg.Section("email").Key("PASSWORD").SetValue(f.SMTPPasswd)
+		cfg.Section("mailer").Key("ENABLED").SetValue("true")
+		cfg.Section("mailer").Key("HOST").SetValue(f.SMTPHost)
+		cfg.Section("mailer").Key("FROM").SetValue(f.SMTPFrom)
+		cfg.Section("mailer").Key("USER").SetValue(f.SMTPUser)
+		cfg.Section("mailer").Key("PASSWD").SetValue(f.SMTPPasswd)
 	} else {
-		cfg.Section("email").Key("ENABLED").SetValue("false")
+		cfg.Section("mailer").Key("ENABLED").SetValue("false")
 	}
 	cfg.Section("server").Key("OFFLINE_MODE").SetValue(com.ToStr(f.OfflineMode))
 	cfg.Section("auth").Key("REQUIRE_EMAIL_CONFIRMATION").SetValue(com.ToStr(f.RegisterConfirm))
 	cfg.Section("auth").Key("DISABLE_REGISTRATION").SetValue(com.ToStr(f.DisableRegistration))
 	cfg.Section("auth").Key("ENABLE_REGISTRATION_CAPTCHA").SetValue(com.ToStr(f.EnableCaptcha))
 	cfg.Section("auth").Key("REQUIRE_SIGNIN_VIEW").SetValue(com.ToStr(f.RequireSignInView))
 	cfg.Section("user").Key("ENABLE_EMAIL_NOTIFICATION").SetValue(com.ToStr(f.MailNotify))
 	cfg.Section("picture").Key("DISABLE_GRAVATAR").SetValue(com.ToStr(f.DisableGravatar))
 	cfg.Section("picture").Key("ENABLE_FEDERATED_AVATAR").SetValue(com.ToStr(f.EnableFederatedAvatar))
 	cfg.Section("").Key("RUN_MODE").SetValue("prod")

--- a/internal/route/repo/editor.go
+++ b/internal/route/repo/editor.go
@@ -160,33 +160,28 @@
 				c.RenderWithErr(c.Tr("repo.editor.file_is_a_symlink", part), tmplEditorEdit, &f)
 				return
 			} else if entry.IsTree() {
 				c.FormErr("TreePath")
 				c.RenderWithErr(c.Tr("repo.editor.filename_is_a_directory", part), tmplEditorEdit, &f)
 				return
 			}
 		}
 	}
 	if !isNewFile {
-		entry, err := c.Repo.Commit.TreeEntry(oldTreePath)
+		_, err := c.Repo.Commit.TreeEntry(oldTreePath)
 		if err != nil {
 			if gitutil.IsErrRevisionNotExist(err) {
 				c.FormErr("TreePath")
 				c.RenderWithErr(c.Tr("repo.editor.file_editing_no_longer_exists", oldTreePath), tmplEditorEdit, &f)
 			} else {
 				c.Error(err, "get tree entry")
 			}
-			return
-		}
-		if entry.IsSymlink() {
-			c.FormErr("TreePath")
-			c.RenderWithErr(c.Tr("repo.editor.file_is_a_symlink", oldTreePath), tmplEditorEdit, &f)
 			return
 		}
 		if lastCommit != c.Repo.CommitID {
 			files, err := c.Repo.Commit.FilesChangedAfter(lastCommit)
 			if err != nil {
 				c.Error(err, "get changed files")
 				return
 			}
 			for _, file := range files {
 				if file == f.TreePath {
@@ -242,21 +237,21 @@
 		c.Redirect(c.Repo.RepoLink + "/src/" + branchName + "/" + f.TreePath)
 	}
 }
 func EditFilePost(c *context.Context, f form.EditRepoFile) {
 	editFilePost(c, f, false)
 }
 func NewFilePost(c *context.Context, f form.EditRepoFile) {
 	editFilePost(c, f, true)
 }
 func DiffPreviewPost(c *context.Context, f form.EditPreviewDiff) {
-	treePath := pathutil.Clean(c.Repo.TreePath)
+	treePath := c.Repo.TreePath
 	entry, err := c.Repo.Commit.TreeEntry(treePath)
 	if err != nil {
 		c.Error(err, "get tree entry")
 		return
 	} else if entry.IsTree() {
 		c.Status(http.StatusUnprocessableEntity)
 		return
 	}
 	diff, err := c.Repo.Repository.GetDiffPreview(c.Repo.BranchName, treePath, f.Content)
 	if err != nil {

--- a/internal/ssh/ssh.go
+++ b/internal/ssh/ssh.go
@@ -1,13 +1,14 @@
 package ssh
 import (
 	"context"
+	"fmt"
 	"io"
 	"net"
 	"os"
 	"os/exec"
 	"path/filepath"
 	"strings"
 	"syscall"
 	"github.com/pkg/errors"
 	"github.com/sourcegraph/run"
 	"github.com/unknwon/com"
@@ -36,20 +37,37 @@
 			continue
 		}
 		go func(in <-chan *ssh.Request) {
 			defer func() {
 				_ = ch.Close()
 			}()
 			for req := range in {
 				payload := cleanCommand(string(req.Payload))
 				switch req.Type {
 				case "env":
+					var env struct {
+						Name  string
+						Value string
+					}
+					if err := ssh.Unmarshal(req.Payload, &env); err != nil {
+						log.Warn("SSH: Invalid env payload %q: %v", req.Payload, err)
+						continue
+					}
+					if env.Name == "" || env.Value == "" {
+						log.Warn("SSH: Invalid env arguments: %+v", env)
+						continue
+					}
+					_, stderr, err := com.ExecCmd("env", fmt.Sprintf("%s=%s", env.Name, env.Value))
+					if err != nil {
+						log.Error("env: %v - %s", err, stderr)
+						return
+					}
 				case "exec":
 					cmdName := strings.TrimLeft(payload, "'()")
 					log.Trace("SSH: Payload: %v", cmdName)
 					args := []string{"serv", "key-" + keyID, "--config=" + conf.CustomConf}
 					log.Trace("SSH: Arguments: %v", args)
 					cmd := exec.Command(conf.AppPath(), args...)
 					cmd.Env = append(os.Environ(), "SSH_ORIGINAL_COMMAND="+cmdName)
 					stdout, err := cmd.StdoutPipe()
 					if err != nil {
 						log.Error("SSH: StdoutPipe: %v", err)
@@ -117,23 +135,21 @@
 }
 func Listen(opts conf.SSHOpts, appDataPath string) {
 	config := &ssh.ServerConfig{
 		Config: ssh.Config{
 			Ciphers: opts.ServerCiphers,
 			MACs:    opts.ServerMACs,
 		},
 		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
 			pkey, err := db.SearchPublicKeyByContent(strings.TrimSpace(string(ssh.MarshalAuthorizedKey(key))))
 			if err != nil {
-				if !db.IsErrKeyNotExist(err) {
-					log.Error("SearchPublicKeyByContent: %v", err)
-				}
+				log.Error("SearchPublicKeyByContent: %v", err)
 				return nil, err
 			}
 			return &ssh.Permissions{Extensions: map[string]string{"key-id": com.ToStr(pkey.ID)}}, nil
 		},
 	}
 	keys, err := setupHostKeys(appDataPath, opts.ServerAlgorithms)
 	if err != nil {
 		log.Fatal("SSH: Failed to setup host keys: %v", err)
 	}
 	for _, key := range keys {
