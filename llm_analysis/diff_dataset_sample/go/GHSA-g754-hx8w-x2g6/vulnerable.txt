# ====================================================================
# FILE: conn_id_generator.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 111-156 ---
   111| 	connID, err := m.generator.GenerateConnectionID()
   112| 	if err != nil {
   113| 		return err
   114| 	}
   115| 	m.activeSrcConnIDs[m.highestSeq+1] = connID
   116| 	m.connRunners.AddConnectionID(connID)
   117| 	m.queueControlFrame(&wire.NewConnectionIDFrame{
   118| 		SequenceNumber:      m.highestSeq + 1,
   119| 		ConnectionID:        connID,
   120| 		StatelessResetToken: m.statelessResetter.GetStatelessResetToken(connID),
   121| 	})
   122| 	m.highestSeq++
   123| 	return nil
   124| }
   125| func (m *connIDGenerator) SetHandshakeComplete(connIDExpiry monotime.Time) {
   126| 	if m.initialClientDestConnID != nil {
   127| 		m.queueConnIDForRetiring(*m.initialClientDestConnID, connIDExpiry)
   128| 		m.initialClientDestConnID = nil
   129| 	}
   130| }
   131| func (m *connIDGenerator) NextRetireTime() monotime.Time {
   132| 	if len(m.connIDsToRetire) == 0 {
   133| 		return 0
   134| 	}
   135| 	return m.connIDsToRetire[0].t
   136| }
   137| func (m *connIDGenerator) RemoveRetiredConnIDs(now monotime.Time) {
   138| 	if len(m.connIDsToRetire) == 0 {
   139| 		return
   140| 	}
   141| 	for _, c := range m.connIDsToRetire {
   142| 		if c.t.After(now) {
   143| 			break
   144| 		}
   145| 		m.connRunners.RemoveConnectionID(c.connID)
   146| 		m.connIDsToRetire = m.connIDsToRetire[1:]
   147| 	}
   148| }
   149| func (m *connIDGenerator) RemoveAll() {
   150| 	if m.initialClientDestConnID != nil {
   151| 		m.connRunners.RemoveConnectionID(*m.initialClientDestConnID)
   152| 	}
   153| 	for _, connID := range m.activeSrcConnIDs {
   154| 		m.connRunners.RemoveConnectionID(connID)
   155| 	}
   156| 	for _, c := range m.connIDsToRetire {


# ====================================================================
# FILE: connection.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 687-729 ---
   687| 				deadline = keepAliveTime
   688| 			} else {
   689| 				deadline = c.nextIdleTimeoutTime()
   690| 			}
   691| 		}
   692| 	}
   693| 	if c.blocked == blockModeHardBlocked {
   694| 		c.timer.Reset(monotime.Until(deadline))
   695| 		return
   696| 	}
   697| 	if t := c.receivedPacketHandler.GetAlarmTimeout(); !t.IsZero() && t.Before(deadline) {
   698| 		deadline = t
   699| 	}
   700| 	if t := c.sentPacketHandler.GetLossDetectionTimeout(); !t.IsZero() && t.Before(deadline) {
   701| 		deadline = t
   702| 	}
   703| 	if c.blocked == blockModeCongestionLimited {
   704| 		c.timer.Reset(monotime.Until(deadline))
   705| 		return
   706| 	}
   707| 	if t := c.connIDGenerator.NextRetireTime(); !t.IsZero() && t.Before(deadline) {
   708| 		deadline = t
   709| 	}
   710| 	if !c.pacingDeadline.IsZero() && c.pacingDeadline.Before(deadline) {
   711| 		deadline = c.pacingDeadline
   712| 	}
   713| 	c.timer.Reset(monotime.Until(deadline))
   714| }
   715| func (c *Conn) idleTimeoutStartTime() monotime.Time {
   716| 	startTime := c.lastPacketReceivedTime
   717| 	if t := c.firstAckElicitingPacketAfterIdleSentTime; !t.IsZero() && t.After(startTime) {
   718| 		startTime = t
   719| 	}
   720| 	return startTime
   721| }
   722| func (c *Conn) switchToNewPath(tr *Transport, now monotime.Time) {
   723| 	initialPacketSize := protocol.ByteCount(c.config.InitialPacketSize)
   724| 	c.sentPacketHandler.MigratedPath(now, initialPacketSize)
   725| 	maxPacketSize := protocol.ByteCount(protocol.MaxPacketBufferSize)
   726| 	if c.peerParams.MaxUDPPayloadSize > 0 && c.peerParams.MaxUDPPayloadSize < maxPacketSize {
   727| 		maxPacketSize = c.peerParams.MaxUDPPayloadSize
   728| 	}
   729| 	c.mtuDiscoverer.Reset(now, initialPacketSize, maxPacketSize)


# ====================================================================
# FILE: http3/client.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 18-123 ---
    18| const (
    19| 	MethodGet0RTT = "GET_0RTT"
    20| 	MethodHead0RTT = "HEAD_0RTT"
    21| )
    22| const (
    23| 	defaultUserAgent              = "quic-go HTTP/3"
    24| 	defaultMaxResponseHeaderBytes = 10 * 1 << 20 // 10 MB
    25| )
    26| type errConnUnusable struct{ e error }
    27| func (e *errConnUnusable) Unwrap() error { return e.e }
    28| func (e *errConnUnusable) Error() string { return fmt.Sprintf("http3: conn unusable: %s", e.e.Error()) }
    29| const max1xxResponses = 5 // arbitrary bound on number of informational responses
    30| var defaultQuicConfig = &quic.Config{
    31| 	MaxIncomingStreams: -1, // don't allow the server to create bidirectional streams
    32| 	KeepAlivePeriod:    10 * time.Second,
    33| }
    34| type ClientConn struct {
    35| 	conn *Conn
    36| 	enableDatagrams bool
    37| 	additionalSettings map[uint64]uint64
    38| 	maxResponseHeaderBytes uint64
    39| 	disableCompression bool
    40| 	logger *slog.Logger
    41| 	requestWriter *requestWriter
    42| 	decoder       *qpack.Decoder
    43| }
    44| var _ http.RoundTripper = &ClientConn{}
    45| func newClientConn(
    46| 	conn *quic.Conn,
    47| 	enableDatagrams bool,
    48| 	additionalSettings map[uint64]uint64,
    49| 	streamHijacker func(FrameType, quic.ConnectionTracingID, *quic.Stream, error) (hijacked bool, err error),
    50| 	uniStreamHijacker func(StreamType, quic.ConnectionTracingID, *quic.ReceiveStream, error) (hijacked bool),
    51| 	maxResponseHeaderBytes int64,
    52| 	disableCompression bool,
    53| 	logger *slog.Logger,
    54| ) *ClientConn {
    55| 	c := &ClientConn{
    56| 		enableDatagrams:    enableDatagrams,
    57| 		additionalSettings: additionalSettings,
    58| 		disableCompression: disableCompression,
    59| 		logger:             logger,
    60| 	}
    61| 	if maxResponseHeaderBytes <= 0 {
    62| 		c.maxResponseHeaderBytes = defaultMaxResponseHeaderBytes
    63| 	} else {
    64| 		c.maxResponseHeaderBytes = uint64(maxResponseHeaderBytes)
    65| 	}
    66| 	c.decoder = qpack.NewDecoder(func(hf qpack.HeaderField) {})
    67| 	c.requestWriter = newRequestWriter()
    68| 	c.conn = newConnection(
    69| 		conn.Context(),
    70| 		conn,
    71| 		c.enableDatagrams,
    72| 		false, // client
    73| 		c.logger,
    74| 		0,
    75| 	)
    76| 	go func() {
    77| 		if err := c.setupConn(); err != nil {
    78| 			if c.logger != nil {
    79| 				c.logger.Debug("Setting up connection failed", "error", err)
    80| 			}
    81| 			c.conn.CloseWithError(quic.ApplicationErrorCode(ErrCodeInternalError), "")
    82| 		}
    83| 	}()
    84| 	if streamHijacker != nil {
    85| 		go c.handleBidirectionalStreams(streamHijacker)
    86| 	}
    87| 	go c.conn.handleUnidirectionalStreams(uniStreamHijacker)
    88| 	return c
    89| }
    90| func (c *ClientConn) OpenRequestStream(ctx context.Context) (*RequestStream, error) {
    91| 	return c.conn.openRequestStream(ctx, c.requestWriter, nil, c.disableCompression, c.maxResponseHeaderBytes)
    92| }
    93| func (c *ClientConn) setupConn() error {
    94| 	str, err := c.conn.OpenUniStream()
    95| 	if err != nil {
    96| 		return err
    97| 	}
    98| 	b := make([]byte, 0, 64)
    99| 	b = quicvarint.Append(b, streamTypeControlStream)
   100| 	b = (&settingsFrame{Datagram: c.enableDatagrams, Other: c.additionalSettings}).Append(b)
   101| 	if c.conn.qlogger != nil {
   102| 		sf := qlog.SettingsFrame{
   103| 			Other: maps.Clone(c.additionalSettings),
   104| 		}
   105| 		if c.enableDatagrams {
   106| 			sf.Datagram = pointer(true)
   107| 		}
   108| 		c.conn.qlogger.RecordEvent(qlog.FrameCreated{
   109| 			StreamID: str.StreamID(),
   110| 			Raw:      qlog.RawInfo{Length: len(b)},
   111| 			Frame:    qlog.Frame{Frame: sf},
   112| 		})
   113| 	}
   114| 	_, err = str.Write(b)
   115| 	return err
   116| }
   117| func (c *ClientConn) handleBidirectionalStreams(streamHijacker func(FrameType, quic.ConnectionTracingID, *quic.Stream, error) (hijacked bool, err error)) {
   118| 	for {
   119| 		str, err := c.conn.conn.AcceptStream(context.Background())
   120| 		if err != nil {
   121| 			if c.logger != nil {
   122| 				c.logger.Debug("accepting bidirectional stream failed", "error", err)
   123| 			}

# --- HUNK 2: Lines 237-298 ---
   237| 	sr := &cancelingReader{str: str, r: body}
   238| 	if contentLength == -1 {
   239| 		_, err := io.CopyBuffer(str, sr, buf)
   240| 		return err
   241| 	}
   242| 	n, err := io.CopyBuffer(str, io.LimitReader(sr, contentLength), buf)
   243| 	if err != nil {
   244| 		return err
   245| 	}
   246| 	var extra int64
   247| 	extra, err = io.CopyBuffer(io.Discard, sr, buf)
   248| 	n += extra
   249| 	if n > contentLength {
   250| 		str.CancelWrite(quic.StreamErrorCode(ErrCodeRequestCanceled))
   251| 		return fmt.Errorf("http: ContentLength=%d with Body length %d", contentLength, n)
   252| 	}
   253| 	return err
   254| }
   255| func (c *ClientConn) doRequest(req *http.Request, str *RequestStream) (*http.Response, error) {
   256| 	trace := httptrace.ContextClientTrace(req.Context())
   257| 	if err := str.sendRequestHeader(req); err != nil {
   258| 		traceWroteRequest(trace, err)
   259| 		return nil, err
   260| 	}
   261| 	if req.Body == nil {
   262| 		traceWroteRequest(trace, nil)
   263| 		str.Close()
   264| 	} else {
   265| 		go func() {
   266| 			contentLength := int64(-1)
   267| 			if req.ContentLength > 0 {
   268| 				contentLength = req.ContentLength
   269| 			}
   270| 			err := c.sendRequestBody(str, req.Body, contentLength)
   271| 			traceWroteRequest(trace, err)
   272| 			if err != nil {
   273| 				if c.logger != nil {
   274| 					c.logger.Debug("error writing request", "error", err)
   275| 				}
   276| 			}
   277| 			str.Close()
   278| 		}()
   279| 	}
   280| 	var num1xx int // number of informational 1xx headers received
   281| 	var res *http.Response
   282| 	for {
   283| 		var err error
   284| 		res, err = str.ReadResponse()
   285| 		if err != nil {
   286| 			return nil, err
   287| 		}
   288| 		resCode := res.StatusCode
   289| 		is1xx := 100 <= resCode && resCode <= 199
   290| 		is1xxNonTerminal := is1xx && resCode != http.StatusSwitchingProtocols
   291| 		if is1xxNonTerminal {
   292| 			num1xx++
   293| 			if num1xx > max1xxResponses {
   294| 				str.CancelRead(quic.StreamErrorCode(ErrCodeExcessiveLoad))
   295| 				str.CancelWrite(quic.StreamErrorCode(ErrCodeExcessiveLoad))
   296| 				return nil, errors.New("http3: too many 1xx informational responses")
   297| 			}
   298| 			traceGot1xxResponse(trace, resCode, textproto.MIMEHeader(res.Header))


# ====================================================================
# FILE: http3/conn.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 39-79 ---
    39| }
    40| func newConnection(
    41| 	ctx context.Context,
    42| 	quicConn *quic.Conn,
    43| 	enableDatagrams bool,
    44| 	isServer bool,
    45| 	logger *slog.Logger,
    46| 	idleTimeout time.Duration,
    47| ) *Conn {
    48| 	var qlogger qlogwriter.Recorder
    49| 	if qlogTrace := quicConn.QlogTrace(); qlogTrace != nil && qlogTrace.SupportsSchemas(qlog.EventSchema) {
    50| 		qlogger = qlogTrace.AddProducer()
    51| 	}
    52| 	c := &Conn{
    53| 		ctx:              ctx,
    54| 		conn:             quicConn,
    55| 		isServer:         isServer,
    56| 		logger:           logger,
    57| 		idleTimeout:      idleTimeout,
    58| 		enableDatagrams:  enableDatagrams,
    59| 		decoder:          qpack.NewDecoder(func(hf qpack.HeaderField) {}),
    60| 		receivedSettings: make(chan struct{}),
    61| 		streams:          make(map[quic.StreamID]*stateTrackingStream),
    62| 		maxStreamID:      invalidStreamID,
    63| 		lastStreamID:     invalidStreamID,
    64| 		qlogger:          qlogger,
    65| 	}
    66| 	if idleTimeout > 0 {
    67| 		c.idleTimer = time.AfterFunc(idleTimeout, c.onIdleTimer)
    68| 	}
    69| 	return c
    70| }
    71| func (c *Conn) OpenStream() (*quic.Stream, error) {
    72| 	return c.conn.OpenStream()
    73| }
    74| func (c *Conn) OpenStreamSync(ctx context.Context) (*quic.Stream, error) {
    75| 	return c.conn.OpenStreamSync(ctx)
    76| }
    77| func (c *Conn) OpenUniStream() (*quic.SendStream, error) {
    78| 	return c.conn.OpenUniStream()
    79| }

# --- HUNK 2: Lines 96-136 ---
    96| 	c.CloseWithError(quic.ApplicationErrorCode(ErrCodeNoError), "idle timeout")
    97| }
    98| func (c *Conn) clearStream(id quic.StreamID) {
    99| 	c.streamMx.Lock()
   100| 	defer c.streamMx.Unlock()
   101| 	delete(c.streams, id)
   102| 	if c.idleTimeout > 0 && len(c.streams) == 0 {
   103| 		c.idleTimer.Reset(c.idleTimeout)
   104| 	}
   105| 	if c.maxStreamID != invalidStreamID {
   106| 		if len(c.streams) == 0 {
   107| 			c.CloseWithError(quic.ApplicationErrorCode(ErrCodeNoError), "")
   108| 		}
   109| 	}
   110| }
   111| func (c *Conn) openRequestStream(
   112| 	ctx context.Context,
   113| 	requestWriter *requestWriter,
   114| 	reqDone chan<- struct{},
   115| 	disableCompression bool,
   116| 	maxHeaderBytes uint64,
   117| ) (*RequestStream, error) {
   118| 	c.streamMx.Lock()
   119| 	maxStreamID := c.maxStreamID
   120| 	var nextStreamID quic.StreamID
   121| 	if c.lastStreamID == invalidStreamID {
   122| 		nextStreamID = 0
   123| 	} else {
   124| 		nextStreamID = c.lastStreamID + 4
   125| 	}
   126| 	c.streamMx.Unlock()
   127| 	if maxStreamID != invalidStreamID && nextStreamID >= maxStreamID {
   128| 		return nil, errGoAway
   129| 	}
   130| 	str, err := c.OpenStreamSync(ctx)
   131| 	if err != nil {
   132| 		return nil, err
   133| 	}
   134| 	hstr := newStateTrackingStream(str, c, func(b []byte) error { return c.sendDatagram(str.StreamID(), b) })
   135| 	c.streamMx.Lock()
   136| 	c.streams[str.StreamID()] = hstr

# --- HUNK 3: Lines 138-195 ---
   138| 	c.streamMx.Unlock()
   139| 	rsp := &http.Response{}
   140| 	trace := httptrace.ContextClientTrace(ctx)
   141| 	return newRequestStream(
   142| 		newStream(hstr, c, trace, func(r io.Reader, hf *headersFrame) error {
   143| 			hdr, err := c.decodeTrailers(r, str.StreamID(), hf, maxHeaderBytes)
   144| 			if err != nil {
   145| 				return err
   146| 			}
   147| 			rsp.Trailer = hdr
   148| 			return nil
   149| 		}, c.qlogger),
   150| 		requestWriter,
   151| 		reqDone,
   152| 		c.decoder,
   153| 		disableCompression,
   154| 		maxHeaderBytes,
   155| 		rsp,
   156| 	), nil
   157| }
   158| func (c *Conn) decodeTrailers(r io.Reader, streamID quic.StreamID, hf *headersFrame, maxHeaderBytes uint64) (http.Header, error) {
   159| 	if hf.Length > maxHeaderBytes {
   160| 		maybeQlogInvalidHeadersFrame(c.qlogger, streamID, hf.Length)
   161| 		return nil, fmt.Errorf("HEADERS frame too large: %d bytes (max: %d)", hf.Length, maxHeaderBytes)
   162| 	}
   163| 	b := make([]byte, hf.Length)
   164| 	if _, err := io.ReadFull(r, b); err != nil {
   165| 		return nil, err
   166| 	}
   167| 	fields, err := c.decoder.DecodeFull(b)
   168| 	if err != nil {
   169| 		maybeQlogInvalidHeadersFrame(c.qlogger, streamID, hf.Length)
   170| 		return nil, err
   171| 	}
   172| 	if c.qlogger != nil {
   173| 		qlogParsedHeadersFrame(c.qlogger, streamID, hf, fields)
   174| 	}
   175| 	return parseTrailers(fields)
   176| }
   177| func (c *Conn) acceptStream(ctx context.Context) (*stateTrackingStream, error) {
   178| 	str, err := c.conn.AcceptStream(ctx)
   179| 	if err != nil {
   180| 		return nil, err
   181| 	}
   182| 	strID := str.StreamID()
   183| 	hstr := newStateTrackingStream(str, c, func(b []byte) error { return c.sendDatagram(strID, b) })
   184| 	c.streamMx.Lock()
   185| 	c.streams[strID] = hstr
   186| 	if c.idleTimeout > 0 {
   187| 		if len(c.streams) == 1 {
   188| 			c.idleTimer.Stop()
   189| 		}
   190| 	}
   191| 	c.streamMx.Unlock()
   192| 	return hstr, nil
   193| }
   194| func (c *Conn) CloseWithError(code quic.ApplicationErrorCode, msg string) error {
   195| 	if c.idleTimer != nil {


# ====================================================================
# FILE: http3/error_codes.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-45 ---
     1| package http3
     2| import (
     3| 	"fmt"
     4| 	"github.com/quic-go/quic-go"
     5| )
     6| type ErrCode quic.ApplicationErrorCode
     7| const (
     8| 	ErrCodeNoError              ErrCode = 0x100
     9| 	ErrCodeGeneralProtocolError ErrCode = 0x101
    10| 	ErrCodeInternalError        ErrCode = 0x102
    11| 	ErrCodeStreamCreationError  ErrCode = 0x103
    12| 	ErrCodeClosedCriticalStream ErrCode = 0x104
    13| 	ErrCodeFrameUnexpected      ErrCode = 0x105
    14| 	ErrCodeFrameError           ErrCode = 0x106
    15| 	ErrCodeExcessiveLoad        ErrCode = 0x107
    16| 	ErrCodeIDError              ErrCode = 0x108
    17| 	ErrCodeSettingsError        ErrCode = 0x109
    18| 	ErrCodeMissingSettings      ErrCode = 0x10a
    19| 	ErrCodeRequestRejected      ErrCode = 0x10b
    20| 	ErrCodeRequestCanceled      ErrCode = 0x10c
    21| 	ErrCodeRequestIncomplete    ErrCode = 0x10d
    22| 	ErrCodeMessageError         ErrCode = 0x10e
    23| 	ErrCodeConnectError         ErrCode = 0x10f
    24| 	ErrCodeVersionFallback      ErrCode = 0x110
    25| 	ErrCodeDatagramError        ErrCode = 0x33
    26| )
    27| func (e ErrCode) String() string {
    28| 	s := e.string()
    29| 	if s != "" {
    30| 		return s
    31| 	}
    32| 	return fmt.Sprintf("unknown error code: %#x", uint16(e))
    33| }
    34| func (e ErrCode) string() string {
    35| 	switch e {
    36| 	case ErrCodeNoError:
    37| 		return "H3_NO_ERROR"
    38| 	case ErrCodeGeneralProtocolError:
    39| 		return "H3_GENERAL_PROTOCOL_ERROR"
    40| 	case ErrCodeInternalError:
    41| 		return "H3_INTERNAL_ERROR"
    42| 	case ErrCodeStreamCreationError:
    43| 		return "H3_STREAM_CREATION_ERROR"
    44| 	case ErrCodeClosedCriticalStream:
    45| 		return "H3_CLOSED_CRITICAL_STREAM"

# --- HUNK 2: Lines 52-75 ---
    52| 	case ErrCodeIDError:
    53| 		return "H3_ID_ERROR"
    54| 	case ErrCodeSettingsError:
    55| 		return "H3_SETTINGS_ERROR"
    56| 	case ErrCodeMissingSettings:
    57| 		return "H3_MISSING_SETTINGS"
    58| 	case ErrCodeRequestRejected:
    59| 		return "H3_REQUEST_REJECTED"
    60| 	case ErrCodeRequestCanceled:
    61| 		return "H3_REQUEST_CANCELLED"
    62| 	case ErrCodeRequestIncomplete:
    63| 		return "H3_INCOMPLETE_REQUEST"
    64| 	case ErrCodeMessageError:
    65| 		return "H3_MESSAGE_ERROR"
    66| 	case ErrCodeConnectError:
    67| 		return "H3_CONNECT_ERROR"
    68| 	case ErrCodeVersionFallback:
    69| 		return "H3_VERSION_FALLBACK"
    70| 	case ErrCodeDatagramError:
    71| 		return "H3_DATAGRAM_ERROR"
    72| 	default:
    73| 		return ""
    74| 	}
    75| }


# ====================================================================
# FILE: http3/frames.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 138-213 ---
   138| 		}
   139| 		r.Reset()
   140| 	}
   141| }
   142| type dataFrame struct {
   143| 	Length uint64
   144| }
   145| func (f *dataFrame) Append(b []byte) []byte {
   146| 	b = quicvarint.Append(b, 0x0)
   147| 	return quicvarint.Append(b, f.Length)
   148| }
   149| type headersFrame struct {
   150| 	Length    uint64
   151| 	headerLen int // number of bytes read for type and length field
   152| }
   153| func (f *headersFrame) Append(b []byte) []byte {
   154| 	b = quicvarint.Append(b, 0x1)
   155| 	return quicvarint.Append(b, f.Length)
   156| }
   157| const (
   158| 	settingExtendedConnect = 0x8
   159| 	settingDatagram = 0x33
   160| )
   161| type settingsFrame struct {
   162| 	Datagram        bool // HTTP Datagrams, RFC 9297
   163| 	ExtendedConnect bool // Extended CONNECT, RFC 9220
   164| 	Other map[uint64]uint64 // all settings that we don't explicitly recognize
   165| }
   166| func pointer[T any](v T) *T {
   167| 	return &v
   168| }
   169| func parseSettingsFrame(r *countingByteReader, l uint64, streamID quic.StreamID, qlogger qlogwriter.Recorder) (*settingsFrame, error) {
   170| 	if l > 8*(1<<10) {
   171| 		return nil, fmt.Errorf("unexpected size for SETTINGS frame: %d", l)
   172| 	}
   173| 	buf := make([]byte, l)
   174| 	if _, err := io.ReadFull(r, buf); err != nil {
   175| 		if err == io.ErrUnexpectedEOF {
   176| 			return nil, io.EOF
   177| 		}
   178| 		return nil, err
   179| 	}
   180| 	frame := &settingsFrame{}
   181| 	b := bytes.NewReader(buf)
   182| 	var settingsFrame qlog.SettingsFrame
   183| 	var readDatagram, readExtendedConnect bool
   184| 	for b.Len() > 0 {
   185| 		id, err := quicvarint.Read(b)
   186| 		if err != nil { // should not happen. We allocated the whole frame already.
   187| 			return nil, err
   188| 		}
   189| 		val, err := quicvarint.Read(b)
   190| 		if err != nil { // should not happen. We allocated the whole frame already.
   191| 			return nil, err
   192| 		}
   193| 		switch id {
   194| 		case settingExtendedConnect:
   195| 			if readExtendedConnect {
   196| 				return nil, fmt.Errorf("duplicate setting: %d", id)
   197| 			}
   198| 			readExtendedConnect = true
   199| 			if val != 0 && val != 1 {
   200| 				return nil, fmt.Errorf("invalid value for SETTINGS_ENABLE_CONNECT_PROTOCOL: %d", val)
   201| 			}
   202| 			frame.ExtendedConnect = val == 1
   203| 			if qlogger != nil {
   204| 				settingsFrame.ExtendedConnect = pointer(frame.ExtendedConnect)
   205| 			}
   206| 		case settingDatagram:
   207| 			if readDatagram {
   208| 				return nil, fmt.Errorf("duplicate setting: %d", id)
   209| 			}
   210| 			readDatagram = true
   211| 			if val != 0 && val != 1 {
   212| 				return nil, fmt.Errorf("invalid value for SETTINGS_H3_DATAGRAM: %d", val)
   213| 			}

# --- HUNK 2: Lines 224-273 ---
   224| 			}
   225| 			frame.Other[id] = val
   226| 		}
   227| 	}
   228| 	if qlogger != nil {
   229| 		settingsFrame.Other = maps.Clone(frame.Other)
   230| 		qlogger.RecordEvent(qlog.FrameParsed{
   231| 			StreamID: streamID,
   232| 			Raw: qlog.RawInfo{
   233| 				Length:        r.NumRead,
   234| 				PayloadLength: int(l),
   235| 			},
   236| 			Frame: qlog.Frame{Frame: settingsFrame},
   237| 		})
   238| 	}
   239| 	return frame, nil
   240| }
   241| func (f *settingsFrame) Append(b []byte) []byte {
   242| 	b = quicvarint.Append(b, 0x4)
   243| 	var l int
   244| 	for id, val := range f.Other {
   245| 		l += quicvarint.Len(id) + quicvarint.Len(val)
   246| 	}
   247| 	if f.Datagram {
   248| 		l += quicvarint.Len(settingDatagram) + quicvarint.Len(1)
   249| 	}
   250| 	if f.ExtendedConnect {
   251| 		l += quicvarint.Len(settingExtendedConnect) + quicvarint.Len(1)
   252| 	}
   253| 	b = quicvarint.Append(b, uint64(l))
   254| 	if f.Datagram {
   255| 		b = quicvarint.Append(b, settingDatagram)
   256| 		b = quicvarint.Append(b, 1)
   257| 	}
   258| 	if f.ExtendedConnect {
   259| 		b = quicvarint.Append(b, settingExtendedConnect)
   260| 		b = quicvarint.Append(b, 1)
   261| 	}
   262| 	for id, val := range f.Other {
   263| 		b = quicvarint.Append(b, id)
   264| 		b = quicvarint.Append(b, val)
   265| 	}
   266| 	return b
   267| }
   268| type goAwayFrame struct {
   269| 	StreamID quic.StreamID
   270| }
   271| func parseGoAwayFrame(r *countingByteReader, l uint64, streamID quic.StreamID, qlogger qlogwriter.Recorder) (*goAwayFrame, error) {
   272| 	frame := &goAwayFrame{}
   273| 	startLen := r.NumRead


# ====================================================================
# FILE: http3/headers.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| package http3
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"net/http"
     6| 	"net/textproto"
     7| 	"net/url"
     8| 	"strconv"
     9| 	"strings"
    10| 	"golang.org/x/net/http/httpguts"
    11| 	"github.com/quic-go/qpack"
    12| )
    13| type header struct {
    14| 	Path      string
    15| 	Method    string
    16| 	Authority string
    17| 	Scheme    string
    18| 	Status    string
    19| 	Protocol string
    20| 	ContentLength int64
    21| 	Headers http.Header
    22| }
    23| var invalidHeaderFields = [...]string{
    24| 	"connection",
    25| 	"keep-alive",
    26| 	"proxy-connection",
    27| 	"transfer-encoding",
    28| 	"upgrade",
    29| }
    30| func parseHeaders(headers []qpack.HeaderField, isRequest bool) (header, error) {
    31| 	hdr := header{Headers: make(http.Header, len(headers))}
    32| 	var readFirstRegularHeader, readContentLength bool
    33| 	var contentLengthStr string
    34| 	for _, h := range headers {
    35| 		if strings.ToLower(h.Name) != h.Name {
    36| 			return header{}, fmt.Errorf("header field is not lower-case: %s", h.Name)
    37| 		}
    38| 		if !httpguts.ValidHeaderFieldValue(h.Value) {
    39| 			return header{}, fmt.Errorf("invalid header field value for %s: %q", h.Name, h.Value)
    40| 		}
    41| 		if h.IsPseudo() {
    42| 			if readFirstRegularHeader {
    43| 				return header{}, fmt.Errorf("received pseudo header %s after a regular header field", h.Name)
    44| 			}
    45| 			var isResponsePseudoHeader bool  // pseudo headers are either valid for requests or for responses
    46| 			var isDuplicatePseudoHeader bool // pseudo headers are allowed to appear exactly once
    47| 			switch h.Name {
    48| 			case ":path":
    49| 				isDuplicatePseudoHeader = hdr.Path != ""
    50| 				hdr.Path = h.Value
    51| 			case ":method":
    52| 				isDuplicatePseudoHeader = hdr.Method != ""
    53| 				hdr.Method = h.Value
    54| 			case ":authority":

# --- HUNK 2: Lines 96-147 ---
    96| 					contentLengthStr = h.Value
    97| 				} else if contentLengthStr != h.Value {
    98| 					return header{}, fmt.Errorf("contradicting content lengths (%s and %s)", contentLengthStr, h.Value)
    99| 				}
   100| 			default:
   101| 				hdr.Headers.Add(h.Name, h.Value)
   102| 			}
   103| 		}
   104| 	}
   105| 	hdr.ContentLength = -1
   106| 	if len(contentLengthStr) > 0 {
   107| 		cl, err := strconv.ParseUint(contentLengthStr, 10, 63)
   108| 		if err != nil {
   109| 			return header{}, fmt.Errorf("invalid content length: %w", err)
   110| 		}
   111| 		hdr.Headers.Set("Content-Length", contentLengthStr)
   112| 		hdr.ContentLength = int64(cl)
   113| 	}
   114| 	return hdr, nil
   115| }
   116| func parseTrailers(headers []qpack.HeaderField) (http.Header, error) {
   117| 	h := make(http.Header, len(headers))
   118| 	for _, field := range headers {
   119| 		if field.IsPseudo() {
   120| 			return nil, fmt.Errorf("http3: received pseudo header in trailer: %s", field.Name)
   121| 		}
   122| 		h.Add(field.Name, field.Value)
   123| 	}
   124| 	return h, nil
   125| }
   126| func requestFromHeaders(headerFields []qpack.HeaderField) (*http.Request, error) {
   127| 	hdr, err := parseHeaders(headerFields, true)
   128| 	if err != nil {
   129| 		return nil, err
   130| 	}
   131| 	if len(hdr.Headers["Cookie"]) > 0 {
   132| 		hdr.Headers.Set("Cookie", strings.Join(hdr.Headers["Cookie"], "; "))
   133| 	}
   134| 	isConnect := hdr.Method == http.MethodConnect
   135| 	isExtendedConnected := isConnect && hdr.Protocol != ""
   136| 	if isExtendedConnected {
   137| 		if hdr.Scheme == "" || hdr.Path == "" || hdr.Authority == "" {
   138| 			return nil, errors.New("extended CONNECT: :scheme, :path and :authority must not be empty")
   139| 		}
   140| 	} else if isConnect {
   141| 		if hdr.Path != "" || hdr.Authority == "" { // normal CONNECT
   142| 			return nil, errors.New(":path must be empty and :authority must not be empty")
   143| 		}
   144| 	} else if len(hdr.Path) == 0 || len(hdr.Authority) == 0 || len(hdr.Method) == 0 {
   145| 		return nil, errors.New(":path, :authority and :method must not be empty")
   146| 	}
   147| 	if !isExtendedConnected && len(hdr.Protocol) > 0 {

# --- HUNK 3: Lines 167-208 ---
   167| 	} else {
   168| 		u, err = url.ParseRequestURI(hdr.Path)
   169| 		if err != nil {
   170| 			return nil, fmt.Errorf("invalid content length: %w", err)
   171| 		}
   172| 		requestURI = hdr.Path
   173| 	}
   174| 	return &http.Request{
   175| 		Method:        hdr.Method,
   176| 		URL:           u,
   177| 		Proto:         protocol,
   178| 		ProtoMajor:    3,
   179| 		ProtoMinor:    0,
   180| 		Header:        hdr.Headers,
   181| 		Body:          nil,
   182| 		ContentLength: hdr.ContentLength,
   183| 		Host:          hdr.Authority,
   184| 		RequestURI:    requestURI,
   185| 	}, nil
   186| }
   187| func updateResponseFromHeaders(rsp *http.Response, headerFields []qpack.HeaderField) error {
   188| 	hdr, err := parseHeaders(headerFields, false)
   189| 	if err != nil {
   190| 		return err
   191| 	}
   192| 	if hdr.Status == "" {
   193| 		return errors.New("missing :status field")
   194| 	}
   195| 	rsp.Proto = "HTTP/3.0"
   196| 	rsp.ProtoMajor = 3
   197| 	rsp.Header = hdr.Headers
   198| 	processTrailers(rsp)
   199| 	rsp.ContentLength = hdr.ContentLength
   200| 	status, err := strconv.Atoi(hdr.Status)
   201| 	if err != nil {
   202| 		return fmt.Errorf("invalid status code: %w", err)
   203| 	}
   204| 	rsp.StatusCode = status
   205| 	rsp.Status = hdr.Status + " " + http.StatusText(status)
   206| 	return nil
   207| }
   208| func processTrailers(rsp *http.Response) {


# ====================================================================
# FILE: http3/qlog/frame.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 63-113 ---
    63| 		}
    64| 		h.WriteToken(jsontext.EndArray)
    65| 	}
    66| 	h.WriteToken(jsontext.EndObject)
    67| 	return h.err
    68| }
    69| type GoAwayFrame struct {
    70| 	StreamID quic.StreamID
    71| }
    72| func (f *GoAwayFrame) encode(enc *jsontext.Encoder) error {
    73| 	h := encoderHelper{enc: enc}
    74| 	h.WriteToken(jsontext.BeginObject)
    75| 	h.WriteToken(jsontext.String("frame_type"))
    76| 	h.WriteToken(jsontext.String("goaway"))
    77| 	h.WriteToken(jsontext.String("id"))
    78| 	h.WriteToken(jsontext.Uint(uint64(f.StreamID)))
    79| 	h.WriteToken(jsontext.EndObject)
    80| 	return h.err
    81| }
    82| type SettingsFrame struct {
    83| 	Datagram        *bool
    84| 	ExtendedConnect *bool
    85| 	Other           map[uint64]uint64
    86| }
    87| func (f *SettingsFrame) encode(enc *jsontext.Encoder) error {
    88| 	h := encoderHelper{enc: enc}
    89| 	h.WriteToken(jsontext.BeginObject)
    90| 	h.WriteToken(jsontext.String("frame_type"))
    91| 	h.WriteToken(jsontext.String("settings"))
    92| 	h.WriteToken(jsontext.String("settings"))
    93| 	h.WriteToken(jsontext.BeginArray)
    94| 	if f.Datagram != nil {
    95| 		h.WriteToken(jsontext.BeginObject)
    96| 		h.WriteToken(jsontext.String("name"))
    97| 		h.WriteToken(jsontext.String("settings_h3_datagram"))
    98| 		h.WriteToken(jsontext.String("value"))
    99| 		h.WriteToken(jsontext.Bool(*f.Datagram))
   100| 		h.WriteToken(jsontext.EndObject)
   101| 	}
   102| 	if f.ExtendedConnect != nil {
   103| 		h.WriteToken(jsontext.BeginObject)
   104| 		h.WriteToken(jsontext.String("name"))
   105| 		h.WriteToken(jsontext.String("settings_enable_connect_protocol"))
   106| 		h.WriteToken(jsontext.String("value"))
   107| 		h.WriteToken(jsontext.Bool(*f.ExtendedConnect))
   108| 		h.WriteToken(jsontext.EndObject)
   109| 	}
   110| 	if len(f.Other) > 0 {
   111| 		for k, v := range f.Other {
   112| 			h.WriteToken(jsontext.BeginObject)
   113| 			h.WriteToken(jsontext.String("name"))


# ====================================================================
# FILE: http3/server.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 271-318 ---
   271| func (s *Server) removeListener(l *QUICListener) {
   272| 	s.mutex.Lock()
   273| 	defer s.mutex.Unlock()
   274| 	s.listeners = slices.DeleteFunc(s.listeners, func(info listener) bool {
   275| 		return info.ln == l
   276| 	})
   277| 	s.generateAltSvcHeader()
   278| }
   279| func (s *Server) handleConn(conn *quic.Conn) error {
   280| 	var qlogger qlogwriter.Recorder
   281| 	if qlogTrace := conn.QlogTrace(); qlogTrace != nil && qlogTrace.SupportsSchemas(qlog.EventSchema) {
   282| 		qlogger = qlogTrace.AddProducer()
   283| 	}
   284| 	ctrlStr, err := conn.OpenUniStream()
   285| 	if err != nil {
   286| 		return fmt.Errorf("opening the control stream failed: %w", err)
   287| 	}
   288| 	b := make([]byte, 0, 64)
   289| 	b = quicvarint.Append(b, streamTypeControlStream) // stream type
   290| 	b = (&settingsFrame{
   291| 		Datagram:        s.EnableDatagrams,
   292| 		ExtendedConnect: true,
   293| 		Other:           s.AdditionalSettings,
   294| 	}).Append(b)
   295| 	if qlogger != nil {
   296| 		sf := qlog.SettingsFrame{
   297| 			ExtendedConnect: pointer(true),
   298| 			Other:           maps.Clone(s.AdditionalSettings),
   299| 		}
   300| 		if s.EnableDatagrams {
   301| 			sf.Datagram = pointer(true)
   302| 		}
   303| 		qlogger.RecordEvent(qlog.FrameCreated{
   304| 			StreamID: ctrlStr.StreamID(),
   305| 			Raw:      qlog.RawInfo{Length: len(b)},
   306| 			Frame:    qlog.Frame{Frame: sf},
   307| 		})
   308| 	}
   309| 	ctrlStr.Write(b)
   310| 	connCtx := conn.Context()
   311| 	connCtx = context.WithValue(connCtx, ServerContextKey, s)
   312| 	connCtx = context.WithValue(connCtx, http.LocalAddrContextKey, conn.LocalAddr())
   313| 	connCtx = context.WithValue(connCtx, RemoteAddrContextKey, conn.RemoteAddr())
   314| 	if s.ConnContext != nil {
   315| 		connCtx = s.ConnContext(connCtx, conn)
   316| 		if connCtx == nil {
   317| 			panic("http3: ConnContext returned nil")
   318| 		}

# --- HUNK 2: Lines 366-467 ---
   366| 				_, _ = ctrlStr.Write((&goAwayFrame{StreamID: nextStreamID}).Append(nil))
   367| 			}()
   368| 			ctx = s.closeCtx
   369| 			continue
   370| 		}
   371| 		if inGracefulShutdown {
   372| 			str.CancelRead(quic.StreamErrorCode(ErrCodeRequestRejected))
   373| 			str.CancelWrite(quic.StreamErrorCode(ErrCodeRequestRejected))
   374| 			continue
   375| 		}
   376| 		nextStreamID = str.StreamID() + 4
   377| 		wg.Add(1)
   378| 		go func() {
   379| 			defer wg.Done()
   380| 			s.handleRequest(hconn, str, hconn.decoder, qlogger)
   381| 		}()
   382| 	}
   383| 	wg.Wait()
   384| 	return handleErr
   385| }
   386| func (s *Server) maxHeaderBytes() uint64 {
   387| 	if s.MaxHeaderBytes <= 0 {
   388| 		return http.DefaultMaxHeaderBytes
   389| 	}
   390| 	return uint64(s.MaxHeaderBytes)
   391| }
   392| func (s *Server) handleRequest(
   393| 	conn *Conn,
   394| 	str datagramStream,
   395| 	decoder *qpack.Decoder,
   396| 	qlogger qlogwriter.Recorder,
   397| ) {
   398| 	var ufh unknownFrameHandlerFunc
   399| 	if s.StreamHijacker != nil {
   400| 		ufh = func(ft FrameType, e error) (processed bool, err error) {
   401| 			return s.StreamHijacker(
   402| 				ft,
   403| 				conn.Context().Value(quic.ConnectionTracingKey).(quic.ConnectionTracingID),
   404| 				str.QUICStream(),
   405| 				e,
   406| 			)
   407| 		}
   408| 	}
   409| 	fp := &frameParser{closeConn: conn.CloseWithError, r: str, unknownFrameHandler: ufh}
   410| 	frame, err := fp.ParseNext(qlogger)
   411| 	if err != nil {
   412| 		if !errors.Is(err, errHijacked) {
   413| 			str.CancelRead(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   414| 			str.CancelWrite(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   415| 		}
   416| 		return
   417| 	}
   418| 	hf, ok := frame.(*headersFrame)
   419| 	if !ok {
   420| 		conn.CloseWithError(quic.ApplicationErrorCode(ErrCodeFrameUnexpected), "expected first frame to be a HEADERS frame")
   421| 		return
   422| 	}
   423| 	if hf.Length > s.maxHeaderBytes() {
   424| 		maybeQlogInvalidHeadersFrame(qlogger, str.StreamID(), hf.Length)
   425| 		str.CancelRead(quic.StreamErrorCode(ErrCodeFrameError))
   426| 		str.CancelWrite(quic.StreamErrorCode(ErrCodeFrameError))
   427| 		return
   428| 	}
   429| 	headerBlock := make([]byte, hf.Length)
   430| 	if _, err := io.ReadFull(str, headerBlock); err != nil {
   431| 		maybeQlogInvalidHeadersFrame(qlogger, str.StreamID(), hf.Length)
   432| 		str.CancelRead(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   433| 		str.CancelWrite(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   434| 		return
   435| 	}
   436| 	hfs, err := decoder.DecodeFull(headerBlock)
   437| 	if err != nil {
   438| 		conn.CloseWithError(quic.ApplicationErrorCode(ErrCodeGeneralProtocolError), "expected first frame to be a HEADERS frame")
   439| 		return
   440| 	}
   441| 	if qlogger != nil {
   442| 		qlogParsedHeadersFrame(qlogger, str.StreamID(), hf, hfs)
   443| 	}
   444| 	req, err := requestFromHeaders(hfs)
   445| 	if err != nil {
   446| 		str.CancelRead(quic.StreamErrorCode(ErrCodeMessageError))
   447| 		str.CancelWrite(quic.StreamErrorCode(ErrCodeMessageError))
   448| 		return
   449| 	}
   450| 	connState := conn.ConnectionState().TLS
   451| 	req.TLS = &connState
   452| 	req.RemoteAddr = conn.RemoteAddr().String()
   453| 	contentLength := int64(-1)
   454| 	if _, ok := req.Header["Content-Length"]; ok && req.ContentLength >= 0 {
   455| 		contentLength = req.ContentLength
   456| 	}
   457| 	hstr := newStream(str, conn, nil, nil, qlogger)
   458| 	body := newRequestBody(hstr, contentLength, conn.Context(), conn.ReceivedSettings(), conn.Settings)
   459| 	req.Body = body
   460| 	if s.Logger != nil {
   461| 		s.Logger.Debug("handling request", "method", req.Method, "host", req.Host, "uri", req.RequestURI)
   462| 	}
   463| 	ctx, cancel := context.WithCancel(conn.Context())
   464| 	req = req.WithContext(ctx)
   465| 	context.AfterFunc(str.Context(), cancel)
   466| 	r := newResponseWriter(hstr, conn, req.Method == http.MethodHead, s.Logger)
   467| 	handler := s.Handler

# --- HUNK 3: Lines 489-528 ---
   489| 		handler.ServeHTTP(r, req)
   490| 	}()
   491| 	if r.wasStreamHijacked() {
   492| 		return
   493| 	}
   494| 	if panicked {
   495| 		str.CancelRead(quic.StreamErrorCode(ErrCodeInternalError))
   496| 		str.CancelWrite(quic.StreamErrorCode(ErrCodeInternalError))
   497| 		return
   498| 	}
   499| 	if !r.headerWritten {
   500| 		if _, haveCL := r.header["Content-Length"]; !haveCL {
   501| 			r.header.Set("Content-Length", strconv.FormatInt(r.numWritten, 10))
   502| 		}
   503| 	}
   504| 	r.Flush()
   505| 	r.flushTrailers()
   506| 	str.CancelRead(quic.StreamErrorCode(ErrCodeNoError))
   507| 	str.Close()
   508| }
   509| func (s *Server) Close() error {
   510| 	s.mutex.Lock()
   511| 	defer s.mutex.Unlock()
   512| 	s.closed = true
   513| 	if s.closeCtx == nil {
   514| 		return nil
   515| 	}
   516| 	s.closeCancel()
   517| 	var err error
   518| 	for _, l := range s.listeners {
   519| 		if l.createdLocally {
   520| 			if cerr := (*l.ln).Close(); cerr != nil && err == nil {
   521| 				err = cerr
   522| 			}
   523| 		}
   524| 	}
   525| 	if s.connCount.Load() == 0 {
   526| 		return err
   527| 	}
   528| 	<-s.connHandlingDone


# ====================================================================
# FILE: http3/stream.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 117-171 ---
   117| 	}
   118| 	return s.datagramStream.Write(b)
   119| }
   120| func (s *Stream) writeUnframed(b []byte) (int, error) {
   121| 	return s.datagramStream.Write(b)
   122| }
   123| func (s *Stream) StreamID() quic.StreamID {
   124| 	return s.datagramStream.StreamID()
   125| }
   126| func (s *Stream) SendDatagram(b []byte) error {
   127| 	return s.datagramStream.SendDatagram(b)
   128| }
   129| func (s *Stream) ReceiveDatagram(ctx context.Context) ([]byte, error) {
   130| 	return s.datagramStream.ReceiveDatagram(ctx)
   131| }
   132| type RequestStream struct {
   133| 	str *Stream
   134| 	responseBody io.ReadCloser // set by ReadResponse
   135| 	decoder            *qpack.Decoder
   136| 	requestWriter      *requestWriter
   137| 	maxHeaderBytes     uint64
   138| 	reqDone            chan<- struct{}
   139| 	disableCompression bool
   140| 	response           *http.Response
   141| 	sentRequest   bool
   142| 	requestedGzip bool
   143| 	isConnect     bool
   144| }
   145| func newRequestStream(
   146| 	str *Stream,
   147| 	requestWriter *requestWriter,
   148| 	reqDone chan<- struct{},
   149| 	decoder *qpack.Decoder,
   150| 	disableCompression bool,
   151| 	maxHeaderBytes uint64,
   152| 	rsp *http.Response,
   153| ) *RequestStream {
   154| 	return &RequestStream{
   155| 		str:                str,
   156| 		requestWriter:      requestWriter,
   157| 		reqDone:            reqDone,
   158| 		decoder:            decoder,
   159| 		disableCompression: disableCompression,
   160| 		maxHeaderBytes:     maxHeaderBytes,
   161| 		response:           rsp,
   162| 	}
   163| }
   164| func (s *RequestStream) Read(b []byte) (int, error) {
   165| 	if s.responseBody == nil {
   166| 		return 0, errors.New("http3: invalid use of RequestStream.Read before ReadResponse")
   167| 	}
   168| 	return s.responseBody.Read(b)
   169| }
   170| func (s *RequestStream) StreamID() quic.StreamID {
   171| 	return s.str.StreamID()

# --- HUNK 2: Lines 219-284 ---
   219| 	}
   220| 	s.isConnect = req.Method == http.MethodConnect
   221| 	s.sentRequest = true
   222| 	return s.requestWriter.WriteRequestHeader(s.str.datagramStream, req, s.requestedGzip, s.str.StreamID(), s.str.qlogger)
   223| }
   224| func (s *RequestStream) ReadResponse() (*http.Response, error) {
   225| 	if !s.sentRequest {
   226| 		return nil, errors.New("http3: invalid duplicate use of RequestStream.ReadResponse before SendRequestHeader")
   227| 	}
   228| 	frame, err := s.str.frameParser.ParseNext(s.str.qlogger)
   229| 	if err != nil {
   230| 		s.str.CancelRead(quic.StreamErrorCode(ErrCodeFrameError))
   231| 		s.str.CancelWrite(quic.StreamErrorCode(ErrCodeFrameError))
   232| 		return nil, fmt.Errorf("http3: parsing frame failed: %w", err)
   233| 	}
   234| 	hf, ok := frame.(*headersFrame)
   235| 	if !ok {
   236| 		s.str.conn.CloseWithError(quic.ApplicationErrorCode(ErrCodeFrameUnexpected), "expected first frame to be a HEADERS frame")
   237| 		return nil, errors.New("http3: expected first frame to be a HEADERS frame")
   238| 	}
   239| 	if hf.Length > s.maxHeaderBytes {
   240| 		maybeQlogInvalidHeadersFrame(s.str.qlogger, s.str.StreamID(), hf.Length)
   241| 		s.str.CancelRead(quic.StreamErrorCode(ErrCodeFrameError))
   242| 		s.str.CancelWrite(quic.StreamErrorCode(ErrCodeFrameError))
   243| 		return nil, fmt.Errorf("http3: HEADERS frame too large: %d bytes (max: %d)", hf.Length, s.maxHeaderBytes)
   244| 	}
   245| 	headerBlock := make([]byte, hf.Length)
   246| 	if _, err := io.ReadFull(s.str.datagramStream, headerBlock); err != nil {
   247| 		maybeQlogInvalidHeadersFrame(s.str.qlogger, s.str.StreamID(), hf.Length)
   248| 		s.str.CancelRead(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   249| 		s.str.CancelWrite(quic.StreamErrorCode(ErrCodeRequestIncomplete))
   250| 		return nil, fmt.Errorf("http3: failed to read response headers: %w", err)
   251| 	}
   252| 	hfs, err := s.decoder.DecodeFull(headerBlock)
   253| 	if err != nil {
   254| 		maybeQlogInvalidHeadersFrame(s.str.qlogger, s.str.StreamID(), hf.Length)
   255| 		s.str.conn.CloseWithError(quic.ApplicationErrorCode(ErrCodeGeneralProtocolError), "")
   256| 		return nil, fmt.Errorf("http3: failed to decode response headers: %w", err)
   257| 	}
   258| 	if s.str.qlogger != nil {
   259| 		qlogParsedHeadersFrame(s.str.qlogger, s.str.StreamID(), hf, hfs)
   260| 	}
   261| 	res := s.response
   262| 	if err := updateResponseFromHeaders(res, hfs); err != nil {
   263| 		s.str.CancelRead(quic.StreamErrorCode(ErrCodeMessageError))
   264| 		s.str.CancelWrite(quic.StreamErrorCode(ErrCodeMessageError))
   265| 		return nil, fmt.Errorf("http3: invalid response: %w", err)
   266| 	}
   267| 	respBody := newResponseBody(s.str, res.ContentLength, s.reqDone)
   268| 	isInformational := res.StatusCode >= 100 && res.StatusCode < 200
   269| 	isNoContent := res.StatusCode == http.StatusNoContent
   270| 	isSuccessfulConnect := s.isConnect && res.StatusCode >= 200 && res.StatusCode < 300
   271| 	if (isInformational || isNoContent || isSuccessfulConnect) && res.ContentLength == -1 {
   272| 		res.ContentLength = 0
   273| 	}
   274| 	if s.requestedGzip && res.Header.Get("Content-Encoding") == "gzip" {
   275| 		res.Header.Del("Content-Encoding")
   276| 		res.Header.Del("Content-Length")
   277| 		res.ContentLength = -1
   278| 		s.responseBody = newGzipReader(respBody)
   279| 		res.Uncompressed = true
   280| 	} else {
   281| 		s.responseBody = respBody
   282| 	}
   283| 	res.Body = s.responseBody
   284| 	return res, nil


# ====================================================================
# FILE: http3/transport.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 33-73 ---
    33| 	dialing    chan struct{} // closed as soon as quic.Dial(Early) returned
    34| 	dialErr    error
    35| 	conn       *quic.Conn
    36| 	clientConn clientConn
    37| 	useCount atomic.Int64
    38| }
    39| func (r *roundTripperWithCount) Close() error {
    40| 	r.cancel()
    41| 	<-r.dialing
    42| 	if r.conn != nil {
    43| 		return r.conn.CloseWithError(0, "")
    44| 	}
    45| 	return nil
    46| }
    47| type Transport struct {
    48| 	TLSClientConfig *tls.Config
    49| 	QUICConfig *quic.Config
    50| 	Dial func(ctx context.Context, addr string, tlsCfg *tls.Config, cfg *quic.Config) (*quic.Conn, error)
    51| 	EnableDatagrams bool
    52| 	AdditionalSettings map[uint64]uint64
    53| 	MaxResponseHeaderBytes int64
    54| 	DisableCompression bool
    55| 	StreamHijacker    func(FrameType, quic.ConnectionTracingID, *quic.Stream, error) (hijacked bool, err error)
    56| 	UniStreamHijacker func(StreamType, quic.ConnectionTracingID, *quic.ReceiveStream, error) (hijacked bool)
    57| 	Logger *slog.Logger
    58| 	mutex sync.Mutex
    59| 	initOnce sync.Once
    60| 	initErr  error
    61| 	newClientConn func(*quic.Conn) clientConn
    62| 	clients   map[string]*roundTripperWithCount
    63| 	transport *quic.Transport
    64| 	closed    bool
    65| }
    66| var (
    67| 	_ http.RoundTripper = &Transport{}
    68| 	_ io.Closer         = &Transport{}
    69| )
    70| var (
    71| 	ErrNoCachedConn = errors.New("http3: no cached connection was available")
    72| 	ErrTransportClosed = errors.New("http3: transport is closed")
    73| )


# ====================================================================
# FILE: internal/ackhandler/received_packet_tracker.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 102-158 ---
   102| 	}
   103| 	return nil
   104| }
   105| func (h *appDataReceivedPacketTracker) IgnoreBelow(pn protocol.PacketNumber) {
   106| 	if pn <= h.ignoreBelow {
   107| 		return
   108| 	}
   109| 	h.ignoreBelow = pn
   110| 	h.packetHistory.DeleteBelow(pn)
   111| 	if h.logger.Debug() {
   112| 		h.logger.Debugf("\tIgnoring all packets below %d.", pn)
   113| 	}
   114| }
   115| func (h *appDataReceivedPacketTracker) isMissing(p protocol.PacketNumber) bool {
   116| 	if h.lastAck == nil || p < h.ignoreBelow {
   117| 		return false
   118| 	}
   119| 	return p < h.lastAck.LargestAcked() && !h.lastAck.AcksPacket(p)
   120| }
   121| func (h *appDataReceivedPacketTracker) hasNewMissingPackets() bool {
   122| 	if h.largestObserved < reorderingThreshold {
   123| 		return false
   124| 	}
   125| 	highestMissing := h.packetHistory.HighestMissingUpTo(h.largestObserved - reorderingThreshold)
   126| 	if highestMissing == protocol.InvalidPacketNumber {
   127| 		return false
   128| 	}
   129| 	if highestMissing < h.lastAck.LargestAcked() {
   130| 		return false
   131| 	}
   132| 	return highestMissing > h.lastAck.LargestAcked()-reorderingThreshold
   133| }
   134| func (h *appDataReceivedPacketTracker) shouldQueueACK(pn protocol.PacketNumber, ecn protocol.ECN, wasMissing bool) bool {
   135| 	if h.lastAck == nil {
   136| 		h.logger.Debugf("\tQueueing ACK because the first packet should be acknowledged.")
   137| 		return true
   138| 	}
   139| 	if wasMissing {
   140| 		if h.logger.Debug() {
   141| 			h.logger.Debugf("\tQueueing ACK because packet %d was missing before.", pn)
   142| 		}
   143| 		return true
   144| 	}
   145| 	if h.ackElicitingPacketsReceivedSinceLastAck >= packetsBeforeAck {
   146| 		if h.logger.Debug() {
   147| 			h.logger.Debugf("\tQueueing ACK because packet %d packets were received after the last ACK (using initial threshold: %d).", h.ackElicitingPacketsReceivedSinceLastAck, packetsBeforeAck)
   148| 		}
   149| 		return true
   150| 	}
   151| 	if h.hasNewMissingPackets() {
   152| 		h.logger.Debugf("\tQueuing ACK because there's a new missing packet to report.")
   153| 		return true
   154| 	}
   155| 	if ecn == protocol.ECNCE {
   156| 		h.logger.Debugf("\tQueuing ACK because the packet was ECN-CE marked.")
   157| 		return true
   158| 	}


# ====================================================================
# FILE: qlogwriter/writer.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 57-96 ---
    57| 	enc := jsontext.NewEncoder(buf)
    58| 	if _, err := buf.Write(recordSeparator); err != nil {
    59| 		panic(fmt.Sprintf("qlog encoding into a bytes.Buffer failed: %s", err))
    60| 	}
    61| 	if err := (&traceHeader{
    62| 		VantagePointType: pers,
    63| 		GroupID:          odcid,
    64| 		ReferenceTime:    now,
    65| 		EventSchemas:     eventSchemas,
    66| 	}).Encode(enc); err != nil {
    67| 		panic(fmt.Sprintf("qlog encoding into a bytes.Buffer failed: %s", err))
    68| 	}
    69| 	_, encodeErr := w.Write(buf.Bytes())
    70| 	return &FileSeq{
    71| 		w:             w,
    72| 		referenceTime: now,
    73| 		enc:           jsontext.NewEncoder(w),
    74| 		runStopped:    make(chan struct{}),
    75| 		encodeErr:     encodeErr,
    76| 		events:        make(chan event, eventChanSize),
    77| 	}
    78| }
    79| func (t *FileSeq) SupportsSchemas(schema string) bool {
    80| 	return slices.Contains(t.eventSchemas, schema)
    81| }
    82| func (t *FileSeq) AddProducer() Recorder {
    83| 	t.mx.Lock()
    84| 	defer t.mx.Unlock()
    85| 	if t.closed {
    86| 		return nil
    87| 	}
    88| 	t.producers++
    89| 	return &Writer{t: t}
    90| }
    91| func (t *FileSeq) record(eventTime time.Time, details Event) {
    92| 	t.mx.Lock()
    93| 	if t.closed {
    94| 		t.mx.Unlock()
    95| 		return
    96| 	}

