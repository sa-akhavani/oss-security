# ====================================================================
# FILE: commands/bake.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 39-83 ---
    39| 	"go.opentelemetry.io/otel/attribute"
    40| )
    41| type bakeOptions struct {
    42| 	files     []string
    43| 	overrides []string
    44| 	sbom       string
    45| 	provenance string
    46| 	allow      []string
    47| 	builder      string
    48| 	metadataFile string
    49| 	exportPush   bool
    50| 	exportLoad   bool
    51| 	callFunc     string
    52| 	print bool
    53| 	list  string
    54| 	listTargets bool
    55| 	listVars    bool
    56| }
    57| func runBake(ctx context.Context, dockerCli command.Cli, targets []string, in bakeOptions, cFlags commonFlags) (err error) {
    58| 	mp := dockerCli.MeterProvider()
    59| 	ctx, end, err := tracing.TraceCurrentCommand(ctx, append([]string{"bake"}, targets...),
    60| 		attribute.String("builder", in.builder),
    61| 		attribute.StringSlice("targets", targets),
    62| 		attribute.StringSlice("files", in.files),
    63| 	)
    64| 	if err != nil {
    65| 		return err
    66| 	}
    67| 	defer func() {
    68| 		end(err)
    69| 	}()
    70| 	url, cmdContext, targets := bakeArgs(targets)
    71| 	if len(targets) == 0 {
    72| 		targets = []string{"default"}
    73| 	}
    74| 	callFunc, err := buildflags.ParseCallFunc(in.callFunc)
    75| 	if err != nil {
    76| 		return err
    77| 	}
    78| 	overrides := in.overrides
    79| 	if in.exportPush {
    80| 		overrides = append(overrides, "*.push=true")
    81| 	}
    82| 	if in.exportLoad {
    83| 		overrides = append(overrides, "*.load=true")

# --- HUNK 2: Lines 229-269 ---
   229| 			if err != nil {
   230| 				return err
   231| 			}
   232| 			opt.CallFunc.Name = cf.Name
   233| 		}
   234| 	}
   235| 	exp, err := ent.Validate(bo)
   236| 	if err != nil {
   237| 		return err
   238| 	}
   239| 	if progressMode != progressui.RawJSONMode {
   240| 		if err := exp.Prompt(ctx, url != "", &syncWriter{w: dockerCli.Err(), wait: printer.Wait}); err != nil {
   241| 			return err
   242| 		}
   243| 	}
   244| 	if printer.IsDone() {
   245| 		if err := makePrinter(); err != nil {
   246| 			return err
   247| 		}
   248| 	}
   249| 	if err := saveLocalStateGroup(dockerCli, in, targets, bo); err != nil {
   250| 		return err
   251| 	}
   252| 	done := timeBuildCommand(mp, attributes)
   253| 	resp, retErr := build.Build(ctx, nodes, bo, dockerutil.NewClient(dockerCli), confutil.NewConfig(dockerCli), printer)
   254| 	if err := printer.Wait(); retErr == nil {
   255| 		retErr = err
   256| 	}
   257| 	if retErr != nil {
   258| 		err = wrapBuildError(retErr, true)
   259| 	}
   260| 	done(err)
   261| 	if err != nil {
   262| 		return err
   263| 	}
   264| 	if progressMode != progressui.QuietMode && progressMode != progressui.RawJSONMode {
   265| 		desktop.PrintBuildDetails(os.Stderr, printer.BuildRefs(), term)
   266| 	}
   267| 	if len(in.metadataFile) > 0 {
   268| 		dt := make(map[string]interface{})
   269| 		for t, r := range resp {

# --- HUNK 3: Lines 407-474 ---
   407| 	flags.BoolVar(&options.exportLoad, "load", false, `Shorthand for "--set=*.output=type=docker"`)
   408| 	flags.BoolVar(&options.exportPush, "push", false, `Shorthand for "--set=*.output=type=registry"`)
   409| 	flags.StringVar(&options.sbom, "sbom", "", `Shorthand for "--set=*.attest=type=sbom"`)
   410| 	flags.StringVar(&options.provenance, "provenance", "", `Shorthand for "--set=*.attest=type=provenance"`)
   411| 	flags.StringArrayVar(&options.overrides, "set", nil, `Override target value (e.g., "targetpattern.key=value")`)
   412| 	flags.StringVar(&options.callFunc, "call", "build", `Set method for evaluating build ("check", "outline", "targets")`)
   413| 	flags.StringArrayVar(&options.allow, "allow", nil, "Allow build to access specified resources")
   414| 	flags.VarPF(callAlias(&options.callFunc, "check"), "check", "", `Shorthand for "--call=check"`)
   415| 	flags.Lookup("check").NoOptDefVal = "true"
   416| 	flags.BoolVar(&options.print, "print", false, "Print the options without building")
   417| 	flags.StringVar(&options.list, "list", "", "List targets or variables")
   418| 	flags.BoolVar(&options.listTargets, "list-targets", false, "List available targets")
   419| 	flags.MarkHidden("list-targets")
   420| 	flags.MarkDeprecated("list-targets", "list-targets is deprecated, use list=targets instead")
   421| 	flags.BoolVar(&options.listVars, "list-variables", false, "List defined variables")
   422| 	flags.MarkHidden("list-variables")
   423| 	flags.MarkDeprecated("list-variables", "list-variables is deprecated, use list=variables instead")
   424| 	commonBuildFlags(&cFlags, flags)
   425| 	return cmd
   426| }
   427| func saveLocalStateGroup(dockerCli command.Cli, in bakeOptions, targets []string, bo map[string]build.Options) error {
   428| 	l, err := localstate.New(confutil.NewConfig(dockerCli))
   429| 	if err != nil {
   430| 		return err
   431| 	}
   432| 	defer l.MigrateIfNeeded()
   433| 	prm := confutil.MetadataProvenance()
   434| 	if len(in.metadataFile) == 0 {
   435| 		prm = confutil.MetadataProvenanceModeDisabled
   436| 	}
   437| 	groupRef := identity.NewID()
   438| 	refs := make([]string, 0, len(bo))
   439| 	for k, b := range bo {
   440| 		if b.CallFunc != nil {
   441| 			continue
   442| 		}
   443| 		b.Ref = identity.NewID()
   444| 		b.GroupRef = groupRef
   445| 		b.ProvenanceResponseMode = prm
   446| 		refs = append(refs, b.Ref)
   447| 		bo[k] = b
   448| 	}
   449| 	if len(refs) == 0 {
   450| 		return nil
   451| 	}
   452| 	return l.SaveGroup(groupRef, localstate.StateGroup{
   453| 		Refs:    refs,
   454| 		Targets: targets,
   455| 	})
   456| }
   457| func bakeArgs(args []string) (url, cmdContext string, targets []string) {
   458| 	cmdContext, targets = "cwd://", args
   459| 	if len(targets) == 0 || !build.IsRemoteURL(targets[0]) {
   460| 		return url, cmdContext, targets
   461| 	}
   462| 	url, targets = targets[0], targets[1:]
   463| 	if len(targets) == 0 || !build.IsRemoteURL(targets[0]) {
   464| 		return url, cmdContext, targets
   465| 	}
   466| 	cmdContext, targets = targets[0], targets[1:]
   467| 	return url, cmdContext, targets
   468| }
   469| func readBakeFiles(ctx context.Context, nodes []builder.Node, url string, names []string, stdin io.Reader, pw progress.Writer) (files []bake.File, inp *bake.Input, err error) {
   470| 	var lnames []string // local
   471| 	var rnames []string // remote
   472| 	var anames []string // both
   473| 	for _, v := range names {
   474| 		if strings.HasPrefix(v, "cwd://") {


# ====================================================================
# FILE: commands/build.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 232-276 ---
   232| 		contextPath := o.contextPath
   233| 		dockerfile := o.dockerfileName
   234| 		if dockerfile == "" {
   235| 			dockerfile = "Dockerfile"
   236| 		}
   237| 		if contextPath != "-" && osutil.IsLocalDir(contextPath) {
   238| 			contextPath = osutil.ToAbs(contextPath)
   239| 		}
   240| 		salt := o.cfg.TryNodeIdentifier()
   241| 		h := sha256.New()
   242| 		for _, s := range []string{target, contextPath, dockerfile, salt} {
   243| 			_, _ = io.WriteString(h, s)
   244| 			h.Write([]byte{0})
   245| 		}
   246| 		o.result = hex.EncodeToString(h.Sum(nil))
   247| 	})
   248| 	return o.result
   249| }
   250| func runBuild(ctx context.Context, dockerCli command.Cli, options buildOptions) (err error) {
   251| 	mp := dockerCli.MeterProvider()
   252| 	ctx, end, err := tracing.TraceCurrentCommand(ctx, []string{"build", options.contextPath},
   253| 		attribute.String("builder", options.builder),
   254| 		attribute.String("context", options.contextPath),
   255| 		attribute.String("dockerfile", options.dockerfileName),
   256| 	)
   257| 	if err != nil {
   258| 		return err
   259| 	}
   260| 	defer func() {
   261| 		end(err)
   262| 	}()
   263| 	opts, err := options.toControllerOptions()
   264| 	if err != nil {
   265| 		return err
   266| 	}
   267| 	if options.imageIDFile != "" {
   268| 		if err := os.Remove(options.imageIDFile); err != nil && !os.IsNotExist(err) {
   269| 			return errors.Wrap(err, "removing image ID file")
   270| 		}
   271| 	}
   272| 	contextPathHash := options.contextPath
   273| 	if absContextPath, err := filepath.Abs(contextPathHash); err == nil {
   274| 		contextPathHash = absContextPath
   275| 	}
   276| 	b, err := builder.New(dockerCli,


# ====================================================================
# FILE: localstate/localstate.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-93 ---
     1| package localstate
     2| import (
     3| 	"context"
     4| 	"encoding/json"
     5| 	"fmt"
     6| 	"os"
     7| 	"path/filepath"
     8| 	"strconv"
     9| 	"sync"
    10| 	"github.com/docker/buildx/util/confutil"
    11| 	"github.com/pkg/errors"
    12| 	"golang.org/x/sync/errgroup"
    13| )
    14| const (
    15| 	version  = 2
    16| 	refsDir  = "refs"
    17| 	groupDir = "__group__"
    18| )
    19| type State struct {
    20| 	Target string
    21| 	LocalPath string
    22| 	DockerfilePath string
    23| 	GroupRef string `json:",omitempty"`
    24| }
    25| type StateGroup struct {
    26| 	Targets []string `json:",omitempty"`
    27| 	Refs []string
    28| }
    29| type LocalState struct {
    30| 	cfg *confutil.Config
    31| }
    32| func New(cfg *confutil.Config) (*LocalState, error) {
    33| 	if cfg.Dir() == "" {
    34| 		return nil, errors.Errorf("config dir empty")
    35| 	}
    36| 	if err := cfg.MkdirAll(refsDir, 0700); err != nil {
    37| 		return nil, err
    38| 	}
    39| 	return &LocalState{cfg: cfg}, nil
    40| }
    41| func (ls *LocalState) ReadRef(builderName, nodeName, id string) (*State, error) {
    42| 	if err := ls.validate(builderName, nodeName, id); err != nil {
    43| 		return nil, err
    44| 	}
    45| 	dt, err := os.ReadFile(filepath.Join(ls.cfg.Dir(), refsDir, builderName, nodeName, id))
    46| 	if err != nil {
    47| 		return nil, err
    48| 	}
    49| 	var st State
    50| 	if err := json.Unmarshal(dt, &st); err != nil {
    51| 		return nil, err
    52| 	}
    53| 	return &st, nil
    54| }
    55| func (ls *LocalState) SaveRef(builderName, nodeName, id string, st State) error {
    56| 	if err := ls.validate(builderName, nodeName, id); err != nil {
    57| 		return err
    58| 	}
    59| 	refDir := filepath.Join(refsDir, builderName, nodeName)
    60| 	if err := ls.cfg.MkdirAll(refDir, 0700); err != nil {
    61| 		return err
    62| 	}
    63| 	dt, err := json.Marshal(st)
    64| 	if err != nil {
    65| 		return err
    66| 	}
    67| 	return ls.cfg.AtomicWriteFile(filepath.Join(refDir, id), dt, 0644)
    68| }
    69| func (ls *LocalState) GroupDir() string {
    70| 	return filepath.Join(ls.cfg.Dir(), refsDir, groupDir)
    71| }
    72| func (ls *LocalState) ReadGroup(id string) (*StateGroup, error) {
    73| 	dt, err := os.ReadFile(filepath.Join(ls.GroupDir(), id))
    74| 	if err != nil {
    75| 		return nil, err
    76| 	}
    77| 	var stg StateGroup
    78| 	if err := json.Unmarshal(dt, &stg); err != nil {
    79| 		return nil, err
    80| 	}
    81| 	return &stg, nil
    82| }
    83| func (ls *LocalState) SaveGroup(id string, stg StateGroup) error {
    84| 	refDir := filepath.Join(refsDir, groupDir)
    85| 	if err := ls.cfg.MkdirAll(refDir, 0700); err != nil {
    86| 		return err
    87| 	}
    88| 	dt, err := json.Marshal(stg)
    89| 	if err != nil {
    90| 		return err
    91| 	}
    92| 	return ls.cfg.AtomicWriteFile(filepath.Join(refDir, id), dt, 0600)
    93| }

# --- HUNK 2: Lines 159-210 ---
   159| 	}
   160| 	if err := eg.Wait(); err != nil {
   161| 		return err
   162| 	}
   163| 	for gid, refs := range grefs {
   164| 		if s, ok := srefs[gid]; ok {
   165| 			if len(s) != len(refs) {
   166| 				continue
   167| 			}
   168| 			if err := ls.removeGroup(gid); err != nil {
   169| 				return err
   170| 			}
   171| 		}
   172| 	}
   173| 	return os.RemoveAll(dir)
   174| }
   175| func (ls *LocalState) removeGroup(id string) error {
   176| 	if id == "" {
   177| 		return errors.Errorf("group ref empty")
   178| 	}
   179| 	f := filepath.Join(ls.GroupDir(), id)
   180| 	if _, err := os.Lstat(f); err != nil {
   181| 		if !os.IsNotExist(err) {
   182| 			return err
   183| 		}
   184| 		return nil
   185| 	}
   186| 	return os.Remove(f)
   187| }
   188| func (ls *LocalState) validate(builderName, nodeName, id string) error {
   189| 	if builderName == "" {
   190| 		return errors.Errorf("builder name empty")
   191| 	}
   192| 	if nodeName == "" {
   193| 		return errors.Errorf("node name empty")
   194| 	}
   195| 	if id == "" {
   196| 		return errors.Errorf("ref ID empty")
   197| 	}
   198| 	return nil
   199| }
   200| func (ls *LocalState) readVersion() int {
   201| 	if vdt, err := os.ReadFile(filepath.Join(ls.cfg.Dir(), refsDir, "version")); err == nil {
   202| 		if v, err := strconv.Atoi(string(vdt)); err == nil {
   203| 			return v
   204| 		}
   205| 	}
   206| 	return 1
   207| }
   208| func (ls *LocalState) writeVersion(version int) error {
   209| 	return ls.cfg.AtomicWriteFile(filepath.Join(refsDir, "version"), []byte(strconv.Itoa(version)), 0600)
   210| }


# ====================================================================
# FILE: localstate/migrate.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| package localstate
     2| import (
     3| 	"encoding/json"
     4| 	"os"
     5| 	"path/filepath"
     6| 	"github.com/pkg/errors"
     7| )
     8| func (ls *LocalState) MigrateIfNeeded() error {
     9| 	currentVersion := ls.readVersion()
    10| 	if currentVersion == version {
    11| 		return nil
    12| 	}
    13| 	migrations := map[int]func(*LocalState) error{
    14| 		2: (*LocalState).migration2,
    15| 	}
    16| 	for v := currentVersion + 1; v <= version; v++ {
    17| 		migration, found := migrations[v]
    18| 		if !found {
    19| 			return errors.Errorf("localstate migration v%d not found", v)
    20| 		}
    21| 		if err := migration(ls); err != nil {
    22| 			return errors.Wrapf(err, "localstate migration v%d failed", v)
    23| 		}
    24| 	}
    25| 	return ls.writeVersion(version)
    26| }
    27| func (ls *LocalState) migration2() error {
    28| 	return filepath.Walk(ls.GroupDir(), func(path string, info os.FileInfo, err error) error {
    29| 		if err != nil {
    30| 			return err
    31| 		}
    32| 		if info.IsDir() {
    33| 			return nil
    34| 		}
    35| 		dt, err := os.ReadFile(path)
    36| 		if err != nil {
    37| 			return err
    38| 		}
    39| 		var stg StateGroup
    40| 		if err := json.Unmarshal(dt, &stg); err != nil {
    41| 			return err
    42| 		}
    43| 		mdt, err := json.Marshal(stg)
    44| 		if err != nil {
    45| 			return err
    46| 		}
    47| 		if err := os.WriteFile(path, mdt, 0600); err != nil {
    48| 			return err
    49| 		}
    50| 		return nil
    51| 	})
    52| }


# ====================================================================
# FILE: util/tracing/trace.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| package tracing
     2| import (
     3| 	"context"
     4| 	"strings"
     5| 	"github.com/moby/buildkit/util/tracing/delegated"
     6| 	"github.com/moby/buildkit/util/tracing/detect"
     7| 	"go.opentelemetry.io/otel"
     8| 	"go.opentelemetry.io/otel/attribute"
     9| 	sdktrace "go.opentelemetry.io/otel/sdk/trace"
    10| 	"go.opentelemetry.io/otel/trace"
    11| )
    12| func TraceCurrentCommand(ctx context.Context, args []string, attrs ...attribute.KeyValue) (context.Context, func(error), error) {
    13| 	opts := []sdktrace.TracerProviderOption{
    14| 		sdktrace.WithResource(detect.Resource()),
    15| 		sdktrace.WithBatcher(delegated.DefaultExporter),
    16| 	}
    17| 	if exp, err := detect.NewSpanExporter(ctx); err != nil {
    18| 		otel.Handle(err)
    19| 	} else if !detect.IsNoneSpanExporter(exp) {
    20| 		opts = append(opts, sdktrace.WithBatcher(exp))
    21| 	}
    22| 	tp := sdktrace.NewTracerProvider(opts...)
    23| 	ctx, span := tp.Tracer("").Start(ctx, strings.Join(args, " "), trace.WithAttributes(
    24| 		attrs...,
    25| 	))
    26| 	return ctx, func(err error) {
    27| 		if err != nil {
    28| 			span.RecordError(err)
    29| 		}
    30| 		span.End()
    31| 		_ = tp.Shutdown(context.TODO())
    32| 	}, nil
    33| }

