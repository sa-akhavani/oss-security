# ====================================================================
# FILE: cmd/gh-action-integration-generator/main.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-55 ---
     1| package main
     2| import (
     3| 	"bytes"
     4| 	"fmt"
     5| 	"log"
     6| 	"os/exec"
     7| 	"strings"
     8| )
     9| func findTests() []string {
    10| 	rgBin, err := exec.LookPath("rg")
    11| 	if err != nil {
    12| 		log.Fatalf("failed to find rg (ripgrep) binary")
    13| 	}
    14| 	args := []string{
    15| 		"--regexp", "func (Test.+)\\(.*",
    16| 		"../../integration/",
    17| 		"--replace", "$1",
    18| 		"--sort", "path",
    19| 		"--no-line-number",
    20| 		"--no-filename",
    21| 		"--no-heading",
    22| 	}
    23| 	cmd := exec.Command(rgBin, args...)
    24| 	var out bytes.Buffer
    25| 	cmd.Stdout = &out
    26| 	err = cmd.Run()
    27| 	if err != nil {
    28| 		log.Fatalf("failed to run command: %s", err)
    29| 	}
    30| 	tests := strings.Split(strings.TrimSpace(out.String()), "\n")
    31| 	return tests
    32| }
    33| func updateYAML(tests []string) {
    34| 	testsForYq := fmt.Sprintf("[%s]", strings.Join(tests, ", "))
    35| 	yqCommand := fmt.Sprintf(
    36| 		"yq eval '.jobs.integration-test.strategy.matrix.test = %s' ../../.github/workflows/test-integration.yaml -i",
    37| 		testsForYq,
    38| 	)
    39| 	cmd := exec.Command("bash", "-c", yqCommand)
    40| 	var out bytes.Buffer
    41| 	cmd.Stdout = &out
    42| 	err := cmd.Run()
    43| 	if err != nil {
    44| 		log.Fatalf("failed to run yq command: %s", err)
    45| 	}
    46| 	fmt.Println("YAML file updated successfully")
    47| }
    48| func main() {
    49| 	tests := findTests()
    50| 	quotedTests := make([]string, len(tests))
    51| 	for i, test := range tests {
    52| 		quotedTests[i] = fmt.Sprintf("\"%s\"", test)
    53| 	}
    54| 	updateYAML(quotedTests)
    55| }


# ====================================================================
# FILE: cmd/headscale/cli/api_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-182 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"strconv"
     5| 	"time"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"github.com/juanfont/headscale/hscontrol/util"
     8| 	"github.com/prometheus/common/model"
     9| 	"github.com/pterm/pterm"
    10| 	"github.com/rs/zerolog/log"
    11| 	"github.com/spf13/cobra"
    12| 	"google.golang.org/protobuf/types/known/timestamppb"
    13| )
    14| const (
    15| 	DefaultAPIKeyExpiry = "90d"
    16| )
    17| func init() {
    18| 	rootCmd.AddCommand(apiKeysCmd)
    19| 	apiKeysCmd.AddCommand(listAPIKeys)
    20| 	createAPIKeyCmd.Flags().
    21| 		StringP("expiration", "e", DefaultAPIKeyExpiry, "Human-readable expiration of the key (e.g. 30m, 24h)")
    22| 	apiKeysCmd.AddCommand(createAPIKeyCmd)
    23| 	expireAPIKeyCmd.Flags().StringP("prefix", "p", "", "ApiKey prefix")
    24| 	if err := expireAPIKeyCmd.MarkFlagRequired("prefix"); err != nil {
    25| 		log.Fatal().Err(err).Msg("")
    26| 	}
    27| 	apiKeysCmd.AddCommand(expireAPIKeyCmd)
    28| 	deleteAPIKeyCmd.Flags().StringP("prefix", "p", "", "ApiKey prefix")
    29| 	if err := deleteAPIKeyCmd.MarkFlagRequired("prefix"); err != nil {
    30| 		log.Fatal().Err(err).Msg("")
    31| 	}
    32| 	apiKeysCmd.AddCommand(deleteAPIKeyCmd)
    33| }
    34| var apiKeysCmd = &cobra.Command{
    35| 	Use:     "apikeys",
    36| 	Short:   "Handle the Api keys in Headscale",
    37| 	Aliases: []string{"apikey", "api"},
    38| }
    39| var listAPIKeys = &cobra.Command{
    40| 	Use:     "list",
    41| 	Short:   "List the Api keys for headscale",
    42| 	Aliases: []string{"ls", "show"},
    43| 	Run: func(cmd *cobra.Command, args []string) {
    44| 		output, _ := cmd.Flags().GetString("output")
    45| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    46| 		defer cancel()
    47| 		defer conn.Close()
    48| 		request := &v1.ListApiKeysRequest{}
    49| 		response, err := client.ListApiKeys(ctx, request)
    50| 		if err != nil {
    51| 			ErrorOutput(
    52| 				err,
    53| 				fmt.Sprintf("Error getting the list of keys: %s", err),
    54| 				output,
    55| 			)
    56| 		}
    57| 		if output != "" {
    58| 			SuccessOutput(response.GetApiKeys(), "", output)
    59| 		}
    60| 		tableData := pterm.TableData{
    61| 			{"ID", "Prefix", "Expiration", "Created"},
    62| 		}
    63| 		for _, key := range response.GetApiKeys() {
    64| 			expiration := "-"
    65| 			if key.GetExpiration() != nil {
    66| 				expiration = ColourTime(key.GetExpiration().AsTime())
    67| 			}
    68| 			tableData = append(tableData, []string{
    69| 				strconv.FormatUint(key.GetId(), util.Base10),
    70| 				key.GetPrefix(),
    71| 				expiration,
    72| 				key.GetCreatedAt().AsTime().Format(HeadscaleDateTimeFormat),
    73| 			})
    74| 		}
    75| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
    76| 		if err != nil {
    77| 			ErrorOutput(
    78| 				err,
    79| 				fmt.Sprintf("Failed to render pterm table: %s", err),
    80| 				output,
    81| 			)
    82| 		}
    83| 	},
    84| }
    85| var createAPIKeyCmd = &cobra.Command{
    86| 	Use:   "create",
    87| 	Short: "Creates a new Api key",
    88| 	Long: `
    89| Creates a new Api key, the Api key is only visible on creation
    90| and cannot be retrieved again.
    91| If you loose a key, create a new one and revoke (expire) the old one.`,
    92| 	Aliases: []string{"c", "new"},
    93| 	Run: func(cmd *cobra.Command, args []string) {
    94| 		output, _ := cmd.Flags().GetString("output")
    95| 		request := &v1.CreateApiKeyRequest{}
    96| 		durationStr, _ := cmd.Flags().GetString("expiration")
    97| 		duration, err := model.ParseDuration(durationStr)
    98| 		if err != nil {
    99| 			ErrorOutput(
   100| 				err,
   101| 				fmt.Sprintf("Could not parse duration: %s\n", err),
   102| 				output,
   103| 			)
   104| 		}
   105| 		expiration := time.Now().UTC().Add(time.Duration(duration))
   106| 		request.Expiration = timestamppb.New(expiration)
   107| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   108| 		defer cancel()
   109| 		defer conn.Close()
   110| 		response, err := client.CreateApiKey(ctx, request)
   111| 		if err != nil {
   112| 			ErrorOutput(
   113| 				err,
   114| 				fmt.Sprintf("Cannot create Api Key: %s\n", err),
   115| 				output,
   116| 			)
   117| 		}
   118| 		SuccessOutput(response.GetApiKey(), response.GetApiKey(), output)
   119| 	},
   120| }
   121| var expireAPIKeyCmd = &cobra.Command{
   122| 	Use:     "expire",
   123| 	Short:   "Expire an ApiKey",
   124| 	Aliases: []string{"revoke", "exp", "e"},
   125| 	Run: func(cmd *cobra.Command, args []string) {
   126| 		output, _ := cmd.Flags().GetString("output")
   127| 		prefix, err := cmd.Flags().GetString("prefix")
   128| 		if err != nil {
   129| 			ErrorOutput(
   130| 				err,
   131| 				fmt.Sprintf("Error getting prefix from CLI flag: %s", err),
   132| 				output,
   133| 			)
   134| 		}
   135| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   136| 		defer cancel()
   137| 		defer conn.Close()
   138| 		request := &v1.ExpireApiKeyRequest{
   139| 			Prefix: prefix,
   140| 		}
   141| 		response, err := client.ExpireApiKey(ctx, request)
   142| 		if err != nil {
   143| 			ErrorOutput(
   144| 				err,
   145| 				fmt.Sprintf("Cannot expire Api Key: %s\n", err),
   146| 				output,
   147| 			)
   148| 		}
   149| 		SuccessOutput(response, "Key expired", output)
   150| 	},
   151| }
   152| var deleteAPIKeyCmd = &cobra.Command{
   153| 	Use:     "delete",
   154| 	Short:   "Delete an ApiKey",
   155| 	Aliases: []string{"remove", "del"},
   156| 	Run: func(cmd *cobra.Command, args []string) {
   157| 		output, _ := cmd.Flags().GetString("output")
   158| 		prefix, err := cmd.Flags().GetString("prefix")
   159| 		if err != nil {
   160| 			ErrorOutput(
   161| 				err,
   162| 				fmt.Sprintf("Error getting prefix from CLI flag: %s", err),
   163| 				output,
   164| 			)
   165| 		}
   166| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   167| 		defer cancel()
   168| 		defer conn.Close()
   169| 		request := &v1.DeleteApiKeyRequest{
   170| 			Prefix: prefix,
   171| 		}
   172| 		response, err := client.DeleteApiKey(ctx, request)
   173| 		if err != nil {
   174| 			ErrorOutput(
   175| 				err,
   176| 				fmt.Sprintf("Cannot delete Api Key: %s\n", err),
   177| 				output,
   178| 			)
   179| 		}
   180| 		SuccessOutput(response, "Key deleted", output)
   181| 	},
   182| }


# ====================================================================
# FILE: cmd/headscale/cli/debug.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-106 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     5| 	"github.com/rs/zerolog/log"
     6| 	"github.com/spf13/cobra"
     7| 	"google.golang.org/grpc/status"
     8| 	"tailscale.com/types/key"
     9| )
    10| const (
    11| 	errPreAuthKeyMalformed = Error("key is malformed. expected 64 hex characters with `nodekey` prefix")
    12| )
    13| type Error string
    14| func (e Error) Error() string { return string(e) }
    15| func init() {
    16| 	rootCmd.AddCommand(debugCmd)
    17| 	createNodeCmd.Flags().StringP("name", "", "", "Name")
    18| 	err := createNodeCmd.MarkFlagRequired("name")
    19| 	if err != nil {
    20| 		log.Fatal().Err(err).Msg("")
    21| 	}
    22| 	createNodeCmd.Flags().StringP("user", "u", "", "User")
    23| 	createNodeCmd.Flags().StringP("namespace", "n", "", "User")
    24| 	createNodeNamespaceFlag := createNodeCmd.Flags().Lookup("namespace")
    25| 	createNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    26| 	createNodeNamespaceFlag.Hidden = true
    27| 	err = createNodeCmd.MarkFlagRequired("user")
    28| 	if err != nil {
    29| 		log.Fatal().Err(err).Msg("")
    30| 	}
    31| 	createNodeCmd.Flags().StringP("key", "k", "", "Key")
    32| 	err = createNodeCmd.MarkFlagRequired("key")
    33| 	if err != nil {
    34| 		log.Fatal().Err(err).Msg("")
    35| 	}
    36| 	createNodeCmd.Flags().
    37| 		StringSliceP("route", "r", []string{}, "List (or repeated flags) of routes to advertise")
    38| 	debugCmd.AddCommand(createNodeCmd)
    39| }
    40| var debugCmd = &cobra.Command{
    41| 	Use:   "debug",
    42| 	Short: "debug and testing commands",
    43| 	Long:  "debug contains extra commands used for debugging and testing headscale",
    44| }
    45| var createNodeCmd = &cobra.Command{
    46| 	Use:   "create-node",
    47| 	Short: "Create a node that can be registered with `nodes register <>` command",
    48| 	Run: func(cmd *cobra.Command, args []string) {
    49| 		output, _ := cmd.Flags().GetString("output")
    50| 		user, err := cmd.Flags().GetString("user")
    51| 		if err != nil {
    52| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    53| 		}
    54| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    55| 		defer cancel()
    56| 		defer conn.Close()
    57| 		name, err := cmd.Flags().GetString("name")
    58| 		if err != nil {
    59| 			ErrorOutput(
    60| 				err,
    61| 				fmt.Sprintf("Error getting node from flag: %s", err),
    62| 				output,
    63| 			)
    64| 		}
    65| 		machineKey, err := cmd.Flags().GetString("key")
    66| 		if err != nil {
    67| 			ErrorOutput(
    68| 				err,
    69| 				fmt.Sprintf("Error getting key from flag: %s", err),
    70| 				output,
    71| 			)
    72| 		}
    73| 		var mkey key.MachinePublic
    74| 		err = mkey.UnmarshalText([]byte(machineKey))
    75| 		if err != nil {
    76| 			ErrorOutput(
    77| 				err,
    78| 				fmt.Sprintf("Failed to parse machine key from flag: %s", err),
    79| 				output,
    80| 			)
    81| 		}
    82| 		routes, err := cmd.Flags().GetStringSlice("route")
    83| 		if err != nil {
    84| 			ErrorOutput(
    85| 				err,
    86| 				fmt.Sprintf("Error getting routes from flag: %s", err),
    87| 				output,
    88| 			)
    89| 		}
    90| 		request := &v1.DebugCreateNodeRequest{
    91| 			Key:    machineKey,
    92| 			Name:   name,
    93| 			User:   user,
    94| 			Routes: routes,
    95| 		}
    96| 		response, err := client.DebugCreateNode(ctx, request)
    97| 		if err != nil {
    98| 			ErrorOutput(
    99| 				err,
   100| 				fmt.Sprintf("Cannot create node: %s", status.Convert(err).Message()),
   101| 				output,
   102| 			)
   103| 		}
   104| 		SuccessOutput(response.GetNode(), "Node created", output)
   105| 	},
   106| }


# ====================================================================
# FILE: cmd/headscale/cli/nodes.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"log"
     5| 	"net/netip"
     6| 	"slices"
     7| 	"strconv"
     8| 	"strings"
     9| 	"time"
    10| 	survey "github.com/AlecAivazis/survey/v2"
    11| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    12| 	"github.com/juanfont/headscale/hscontrol/util"
    13| 	"github.com/pterm/pterm"
    14| 	"github.com/spf13/cobra"
    15| 	"google.golang.org/grpc/status"
    16| 	"tailscale.com/types/key"
    17| )
    18| func init() {
    19| 	rootCmd.AddCommand(nodeCmd)
    20| 	listNodesCmd.Flags().StringP("user", "u", "", "Filter by user")
    21| 	listNodesCmd.Flags().BoolP("tags", "t", false, "Show tags")
    22| 	listNodesCmd.Flags().StringP("namespace", "n", "", "User")
    23| 	listNodesNamespaceFlag := listNodesCmd.Flags().Lookup("namespace")
    24| 	listNodesNamespaceFlag.Deprecated = deprecateNamespaceMessage
    25| 	listNodesNamespaceFlag.Hidden = true
    26| 	nodeCmd.AddCommand(listNodesCmd)
    27| 	registerNodeCmd.Flags().StringP("user", "u", "", "User")
    28| 	registerNodeCmd.Flags().StringP("namespace", "n", "", "User")
    29| 	registerNodeNamespaceFlag := registerNodeCmd.Flags().Lookup("namespace")
    30| 	registerNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    31| 	registerNodeNamespaceFlag.Hidden = true
    32| 	err := registerNodeCmd.MarkFlagRequired("user")

# --- HUNK 2: Lines 63-323 ---
    63| 		log.Fatalf(err.Error())
    64| 	}
    65| 	moveNodeCmd.Flags().StringP("user", "u", "", "New user")
    66| 	moveNodeCmd.Flags().StringP("namespace", "n", "", "User")
    67| 	moveNodeNamespaceFlag := moveNodeCmd.Flags().Lookup("namespace")
    68| 	moveNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    69| 	moveNodeNamespaceFlag.Hidden = true
    70| 	err = moveNodeCmd.MarkFlagRequired("user")
    71| 	if err != nil {
    72| 		log.Fatalf(err.Error())
    73| 	}
    74| 	nodeCmd.AddCommand(moveNodeCmd)
    75| 	tagCmd.Flags().Uint64P("identifier", "i", 0, "Node identifier (ID)")
    76| 	err = tagCmd.MarkFlagRequired("identifier")
    77| 	if err != nil {
    78| 		log.Fatalf(err.Error())
    79| 	}
    80| 	tagCmd.Flags().
    81| 		StringSliceP("tags", "t", []string{}, "List of tags to add to the node")
    82| 	nodeCmd.AddCommand(tagCmd)
    83| 	nodeCmd.AddCommand(backfillNodeIPsCmd)
    84| }
    85| var nodeCmd = &cobra.Command{
    86| 	Use:     "nodes",
    87| 	Short:   "Manage the nodes of Headscale",
    88| 	Aliases: []string{"node", "machine", "machines"},
    89| }
    90| var registerNodeCmd = &cobra.Command{
    91| 	Use:   "register",
    92| 	Short: "Registers a node to your network",
    93| 	Run: func(cmd *cobra.Command, args []string) {
    94| 		output, _ := cmd.Flags().GetString("output")
    95| 		user, err := cmd.Flags().GetString("user")
    96| 		if err != nil {
    97| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    98| 		}
    99| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   100| 		defer cancel()
   101| 		defer conn.Close()
   102| 		machineKey, err := cmd.Flags().GetString("key")
   103| 		if err != nil {
   104| 			ErrorOutput(
   105| 				err,
   106| 				fmt.Sprintf("Error getting node key from flag: %s", err),
   107| 				output,
   108| 			)
   109| 		}
   110| 		request := &v1.RegisterNodeRequest{
   111| 			Key:  machineKey,
   112| 			User: user,
   113| 		}
   114| 		response, err := client.RegisterNode(ctx, request)
   115| 		if err != nil {
   116| 			ErrorOutput(
   117| 				err,
   118| 				fmt.Sprintf(
   119| 					"Cannot register node: %s\n",
   120| 					status.Convert(err).Message(),
   121| 				),
   122| 				output,
   123| 			)
   124| 		}
   125| 		SuccessOutput(
   126| 			response.GetNode(),
   127| 			fmt.Sprintf("Node %s registered", response.GetNode().GetGivenName()), output)
   128| 	},
   129| }
   130| var listNodesCmd = &cobra.Command{
   131| 	Use:     "list",
   132| 	Short:   "List nodes",
   133| 	Aliases: []string{"ls", "show"},
   134| 	Run: func(cmd *cobra.Command, args []string) {
   135| 		output, _ := cmd.Flags().GetString("output")
   136| 		user, err := cmd.Flags().GetString("user")
   137| 		if err != nil {
   138| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   139| 		}
   140| 		showTags, err := cmd.Flags().GetBool("tags")
   141| 		if err != nil {
   142| 			ErrorOutput(err, fmt.Sprintf("Error getting tags flag: %s", err), output)
   143| 		}
   144| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   145| 		defer cancel()
   146| 		defer conn.Close()
   147| 		request := &v1.ListNodesRequest{
   148| 			User: user,
   149| 		}
   150| 		response, err := client.ListNodes(ctx, request)
   151| 		if err != nil {
   152| 			ErrorOutput(
   153| 				err,
   154| 				fmt.Sprintf("Cannot get nodes: %s", status.Convert(err).Message()),
   155| 				output,
   156| 			)
   157| 		}
   158| 		if output != "" {
   159| 			SuccessOutput(response.GetNodes(), "", output)
   160| 		}
   161| 		tableData, err := nodesToPtables(user, showTags, response.GetNodes())
   162| 		if err != nil {
   163| 			ErrorOutput(err, fmt.Sprintf("Error converting to table: %s", err), output)
   164| 		}
   165| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   166| 		if err != nil {
   167| 			ErrorOutput(
   168| 				err,
   169| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   170| 				output,
   171| 			)
   172| 		}
   173| 	},
   174| }
   175| var expireNodeCmd = &cobra.Command{
   176| 	Use:     "expire",
   177| 	Short:   "Expire (log out) a node in your network",
   178| 	Long:    "Expiring a node will keep the node in the database and force it to reauthenticate.",
   179| 	Aliases: []string{"logout", "exp", "e"},
   180| 	Run: func(cmd *cobra.Command, args []string) {
   181| 		output, _ := cmd.Flags().GetString("output")
   182| 		identifier, err := cmd.Flags().GetUint64("identifier")
   183| 		if err != nil {
   184| 			ErrorOutput(
   185| 				err,
   186| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   187| 				output,
   188| 			)
   189| 			return
   190| 		}
   191| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   192| 		defer cancel()
   193| 		defer conn.Close()
   194| 		request := &v1.ExpireNodeRequest{
   195| 			NodeId: identifier,
   196| 		}
   197| 		response, err := client.ExpireNode(ctx, request)
   198| 		if err != nil {
   199| 			ErrorOutput(
   200| 				err,
   201| 				fmt.Sprintf(
   202| 					"Cannot expire node: %s\n",
   203| 					status.Convert(err).Message(),
   204| 				),
   205| 				output,
   206| 			)
   207| 			return
   208| 		}
   209| 		SuccessOutput(response.GetNode(), "Node expired", output)
   210| 	},
   211| }
   212| var renameNodeCmd = &cobra.Command{
   213| 	Use:   "rename NEW_NAME",
   214| 	Short: "Renames a node in your network",
   215| 	Run: func(cmd *cobra.Command, args []string) {
   216| 		output, _ := cmd.Flags().GetString("output")
   217| 		identifier, err := cmd.Flags().GetUint64("identifier")
   218| 		if err != nil {
   219| 			ErrorOutput(
   220| 				err,
   221| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   222| 				output,
   223| 			)
   224| 			return
   225| 		}
   226| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   227| 		defer cancel()
   228| 		defer conn.Close()
   229| 		newName := ""
   230| 		if len(args) > 0 {
   231| 			newName = args[0]
   232| 		}
   233| 		request := &v1.RenameNodeRequest{
   234| 			NodeId:  identifier,
   235| 			NewName: newName,
   236| 		}
   237| 		response, err := client.RenameNode(ctx, request)
   238| 		if err != nil {
   239| 			ErrorOutput(
   240| 				err,
   241| 				fmt.Sprintf(
   242| 					"Cannot rename node: %s\n",
   243| 					status.Convert(err).Message(),
   244| 				),
   245| 				output,
   246| 			)
   247| 			return
   248| 		}
   249| 		SuccessOutput(response.GetNode(), "Node renamed", output)
   250| 	},
   251| }
   252| var deleteNodeCmd = &cobra.Command{
   253| 	Use:     "delete",
   254| 	Short:   "Delete a node",
   255| 	Aliases: []string{"del"},
   256| 	Run: func(cmd *cobra.Command, args []string) {
   257| 		output, _ := cmd.Flags().GetString("output")
   258| 		identifier, err := cmd.Flags().GetUint64("identifier")
   259| 		if err != nil {
   260| 			ErrorOutput(
   261| 				err,
   262| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   263| 				output,
   264| 			)
   265| 			return
   266| 		}
   267| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   268| 		defer cancel()
   269| 		defer conn.Close()
   270| 		getRequest := &v1.GetNodeRequest{
   271| 			NodeId: identifier,
   272| 		}
   273| 		getResponse, err := client.GetNode(ctx, getRequest)
   274| 		if err != nil {
   275| 			ErrorOutput(
   276| 				err,
   277| 				fmt.Sprintf(
   278| 					"Error getting node node: %s",
   279| 					status.Convert(err).Message(),
   280| 				),
   281| 				output,
   282| 			)
   283| 			return
   284| 		}
   285| 		deleteRequest := &v1.DeleteNodeRequest{
   286| 			NodeId: identifier,
   287| 		}
   288| 		confirm := false
   289| 		force, _ := cmd.Flags().GetBool("force")
   290| 		if !force {
   291| 			prompt := &survey.Confirm{
   292| 				Message: fmt.Sprintf(
   293| 					"Do you want to remove the node %s?",
   294| 					getResponse.GetNode().GetName(),
   295| 				),
   296| 			}
   297| 			err = survey.AskOne(prompt, &confirm)
   298| 			if err != nil {
   299| 				return
   300| 			}
   301| 		}
   302| 		if confirm || force {
   303| 			response, err := client.DeleteNode(ctx, deleteRequest)
   304| 			if output != "" {
   305| 				SuccessOutput(response, "", output)
   306| 				return
   307| 			}
   308| 			if err != nil {
   309| 				ErrorOutput(
   310| 					err,
   311| 					fmt.Sprintf(
   312| 						"Error deleting node: %s",
   313| 						status.Convert(err).Message(),
   314| 					),
   315| 					output,
   316| 				)
   317| 				return
   318| 			}
   319| 			SuccessOutput(
   320| 				map[string]string{"Result": "Node deleted"},
   321| 				"Node deleted",
   322| 				output,
   323| 			)

# --- HUNK 3: Lines 333-612 ---
   333| 	Run: func(cmd *cobra.Command, args []string) {
   334| 		output, _ := cmd.Flags().GetString("output")
   335| 		identifier, err := cmd.Flags().GetUint64("identifier")
   336| 		if err != nil {
   337| 			ErrorOutput(
   338| 				err,
   339| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   340| 				output,
   341| 			)
   342| 			return
   343| 		}
   344| 		user, err := cmd.Flags().GetString("user")
   345| 		if err != nil {
   346| 			ErrorOutput(
   347| 				err,
   348| 				fmt.Sprintf("Error getting user: %s", err),
   349| 				output,
   350| 			)
   351| 			return
   352| 		}
   353| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   354| 		defer cancel()
   355| 		defer conn.Close()
   356| 		getRequest := &v1.GetNodeRequest{
   357| 			NodeId: identifier,
   358| 		}
   359| 		_, err = client.GetNode(ctx, getRequest)
   360| 		if err != nil {
   361| 			ErrorOutput(
   362| 				err,
   363| 				fmt.Sprintf(
   364| 					"Error getting node: %s",
   365| 					status.Convert(err).Message(),
   366| 				),
   367| 				output,
   368| 			)
   369| 			return
   370| 		}
   371| 		moveRequest := &v1.MoveNodeRequest{
   372| 			NodeId: identifier,
   373| 			User:   user,
   374| 		}
   375| 		moveResponse, err := client.MoveNode(ctx, moveRequest)
   376| 		if err != nil {
   377| 			ErrorOutput(
   378| 				err,
   379| 				fmt.Sprintf(
   380| 					"Error moving node: %s",
   381| 					status.Convert(err).Message(),
   382| 				),
   383| 				output,
   384| 			)
   385| 			return
   386| 		}
   387| 		SuccessOutput(moveResponse.GetNode(), "Node moved to another user", output)
   388| 	},
   389| }
   390| var backfillNodeIPsCmd = &cobra.Command{
   391| 	Use:   "backfillips",
   392| 	Short: "Backfill IPs missing from nodes",
   393| 	Long: `
   394| Backfill IPs can be used to add/remove IPs from nodes
   395| based on the current configuration of Headscale.
   396| If there are nodes that does not have IPv4 or IPv6
   397| even if prefixes for both are configured in the config,
   398| this command can be used to assign IPs of the sort to
   399| all nodes that are missing.
   400| If you remove IPv4 or IPv6 prefixes from the config,
   401| it can be run to remove the IPs that should no longer
   402| be assigned to nodes.`,
   403| 	Run: func(cmd *cobra.Command, args []string) {
   404| 		var err error
   405| 		output, _ := cmd.Flags().GetString("output")
   406| 		confirm := false
   407| 		prompt := &survey.Confirm{
   408| 			Message: "Are you sure that you want to assign/remove IPs to/from nodes?",
   409| 		}
   410| 		err = survey.AskOne(prompt, &confirm)
   411| 		if err != nil {
   412| 			return
   413| 		}
   414| 		if confirm {
   415| 			ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   416| 			defer cancel()
   417| 			defer conn.Close()
   418| 			changes, err := client.BackfillNodeIPs(ctx, &v1.BackfillNodeIPsRequest{Confirmed: confirm})
   419| 			if err != nil {
   420| 				ErrorOutput(
   421| 					err,
   422| 					fmt.Sprintf(
   423| 						"Error backfilling IPs: %s",
   424| 						status.Convert(err).Message(),
   425| 					),
   426| 					output,
   427| 				)
   428| 				return
   429| 			}
   430| 			SuccessOutput(changes, "Node IPs backfilled successfully", output)
   431| 		}
   432| 	},
   433| }
   434| func nodesToPtables(
   435| 	currentUser string,
   436| 	showTags bool,
   437| 	nodes []*v1.Node,
   438| ) (pterm.TableData, error) {
   439| 	tableHeader := []string{
   440| 		"ID",
   441| 		"Hostname",
   442| 		"Name",
   443| 		"MachineKey",
   444| 		"NodeKey",
   445| 		"User",
   446| 		"IP addresses",
   447| 		"Ephemeral",
   448| 		"Last seen",
   449| 		"Expiration",
   450| 		"Connected",
   451| 		"Expired",
   452| 	}
   453| 	if showTags {
   454| 		tableHeader = append(tableHeader, []string{
   455| 			"ForcedTags",
   456| 			"InvalidTags",
   457| 			"ValidTags",
   458| 		}...)
   459| 	}
   460| 	tableData := pterm.TableData{tableHeader}
   461| 	for _, node := range nodes {
   462| 		var ephemeral bool
   463| 		if node.GetPreAuthKey() != nil && node.GetPreAuthKey().GetEphemeral() {
   464| 			ephemeral = true
   465| 		}
   466| 		var lastSeen time.Time
   467| 		var lastSeenTime string
   468| 		if node.GetLastSeen() != nil {
   469| 			lastSeen = node.GetLastSeen().AsTime()
   470| 			lastSeenTime = lastSeen.Format("2006-01-02 15:04:05")
   471| 		}
   472| 		var expiry time.Time
   473| 		var expiryTime string
   474| 		if node.GetExpiry() != nil {
   475| 			expiry = node.GetExpiry().AsTime()
   476| 			expiryTime = expiry.Format("2006-01-02 15:04:05")
   477| 		} else {
   478| 			expiryTime = "N/A"
   479| 		}
   480| 		var machineKey key.MachinePublic
   481| 		err := machineKey.UnmarshalText(
   482| 			[]byte(node.GetMachineKey()),
   483| 		)
   484| 		if err != nil {
   485| 			machineKey = key.MachinePublic{}
   486| 		}
   487| 		var nodeKey key.NodePublic
   488| 		err = nodeKey.UnmarshalText(
   489| 			[]byte(node.GetNodeKey()),
   490| 		)
   491| 		if err != nil {
   492| 			return nil, err
   493| 		}
   494| 		var online string
   495| 		if node.GetOnline() {
   496| 			online = pterm.LightGreen("online")
   497| 		} else {
   498| 			online = pterm.LightRed("offline")
   499| 		}
   500| 		var expired string
   501| 		if expiry.IsZero() || expiry.After(time.Now()) {
   502| 			expired = pterm.LightGreen("no")
   503| 		} else {
   504| 			expired = pterm.LightRed("yes")
   505| 		}
   506| 		var forcedTags string
   507| 		for _, tag := range node.GetForcedTags() {
   508| 			forcedTags += "," + tag
   509| 		}
   510| 		forcedTags = strings.TrimLeft(forcedTags, ",")
   511| 		var invalidTags string
   512| 		for _, tag := range node.GetInvalidTags() {
   513| 			if !slices.Contains(node.GetForcedTags(), tag) {
   514| 				invalidTags += "," + pterm.LightRed(tag)
   515| 			}
   516| 		}
   517| 		invalidTags = strings.TrimLeft(invalidTags, ",")
   518| 		var validTags string
   519| 		for _, tag := range node.GetValidTags() {
   520| 			if !slices.Contains(node.GetForcedTags(), tag) {
   521| 				validTags += "," + pterm.LightGreen(tag)
   522| 			}
   523| 		}
   524| 		validTags = strings.TrimLeft(validTags, ",")
   525| 		var user string
   526| 		if currentUser == "" || (currentUser == node.GetUser().GetName()) {
   527| 			user = pterm.LightMagenta(node.GetUser().GetName())
   528| 		} else {
   529| 			user = pterm.LightYellow(node.GetUser().GetName())
   530| 		}
   531| 		var IPV4Address string
   532| 		var IPV6Address string
   533| 		for _, addr := range node.GetIpAddresses() {
   534| 			if netip.MustParseAddr(addr).Is4() {
   535| 				IPV4Address = addr
   536| 			} else {
   537| 				IPV6Address = addr
   538| 			}
   539| 		}
   540| 		nodeData := []string{
   541| 			strconv.FormatUint(node.GetId(), util.Base10),
   542| 			node.GetName(),
   543| 			node.GetGivenName(),
   544| 			machineKey.ShortString(),
   545| 			nodeKey.ShortString(),
   546| 			user,
   547| 			strings.Join([]string{IPV4Address, IPV6Address}, ", "),
   548| 			strconv.FormatBool(ephemeral),
   549| 			lastSeenTime,
   550| 			expiryTime,
   551| 			online,
   552| 			expired,
   553| 		}
   554| 		if showTags {
   555| 			nodeData = append(nodeData, []string{forcedTags, invalidTags, validTags}...)
   556| 		}
   557| 		tableData = append(
   558| 			tableData,
   559| 			nodeData,
   560| 		)
   561| 	}
   562| 	return tableData, nil
   563| }
   564| var tagCmd = &cobra.Command{
   565| 	Use:     "tag",
   566| 	Short:   "Manage the tags of a node",
   567| 	Aliases: []string{"tags", "t"},
   568| 	Run: func(cmd *cobra.Command, args []string) {
   569| 		output, _ := cmd.Flags().GetString("output")
   570| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   571| 		defer cancel()
   572| 		defer conn.Close()
   573| 		identifier, err := cmd.Flags().GetUint64("identifier")
   574| 		if err != nil {
   575| 			ErrorOutput(
   576| 				err,
   577| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   578| 				output,
   579| 			)
   580| 			return
   581| 		}
   582| 		tagsToSet, err := cmd.Flags().GetStringSlice("tags")
   583| 		if err != nil {
   584| 			ErrorOutput(
   585| 				err,
   586| 				fmt.Sprintf("Error retrieving list of tags to add to node, %v", err),
   587| 				output,
   588| 			)
   589| 			return
   590| 		}
   591| 		request := &v1.SetTagsRequest{
   592| 			NodeId: identifier,
   593| 			Tags:   tagsToSet,
   594| 		}
   595| 		resp, err := client.SetTags(ctx, request)
   596| 		if err != nil {
   597| 			ErrorOutput(
   598| 				err,
   599| 				fmt.Sprintf("Error while sending tags to headscale: %s", err),
   600| 				output,
   601| 			)
   602| 			return
   603| 		}
   604| 		if resp != nil {
   605| 			SuccessOutput(
   606| 				resp.GetNode(),
   607| 				"Node updated",
   608| 				output,
   609| 			)
   610| 		}
   611| 	},
   612| }


# ====================================================================
# FILE: cmd/headscale/cli/policy.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-68 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"io"
     5| 	"os"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"github.com/rs/zerolog/log"
     8| 	"github.com/spf13/cobra"
     9| )
    10| func init() {
    11| 	rootCmd.AddCommand(policyCmd)
    12| 	policyCmd.AddCommand(getPolicy)
    13| 	setPolicy.Flags().StringP("file", "f", "", "Path to a policy file in HuJSON format")
    14| 	if err := setPolicy.MarkFlagRequired("file"); err != nil {
    15| 		log.Fatal().Err(err).Msg("")
    16| 	}
    17| 	policyCmd.AddCommand(setPolicy)
    18| }
    19| var policyCmd = &cobra.Command{
    20| 	Use:   "policy",
    21| 	Short: "Manage the Headscale ACL Policy",
    22| }
    23| var getPolicy = &cobra.Command{
    24| 	Use:     "get",
    25| 	Short:   "Print the current ACL Policy",
    26| 	Aliases: []string{"show", "view", "fetch"},
    27| 	Run: func(cmd *cobra.Command, args []string) {
    28| 		output, _ := cmd.Flags().GetString("output")
    29| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    30| 		defer cancel()
    31| 		defer conn.Close()
    32| 		request := &v1.GetPolicyRequest{}
    33| 		response, err := client.GetPolicy(ctx, request)
    34| 		if err != nil {
    35| 			ErrorOutput(err, fmt.Sprintf("Failed loading ACL Policy: %s", err), output)
    36| 		}
    37| 		SuccessOutput("", response.GetPolicy(), "")
    38| 	},
    39| }
    40| var setPolicy = &cobra.Command{
    41| 	Use:   "set",
    42| 	Short: "Updates the ACL Policy",
    43| 	Long: `
    44| 	Updates the existing ACL Policy with the provided policy. The policy must be a valid HuJSON object.
    45| 	This command only works when the acl.policy_mode is set to "db", and the policy will be stored in the database.`,
    46| 	Aliases: []string{"put", "update"},
    47| 	Run: func(cmd *cobra.Command, args []string) {
    48| 		output, _ := cmd.Flags().GetString("output")
    49| 		policyPath, _ := cmd.Flags().GetString("file")
    50| 		f, err := os.Open(policyPath)
    51| 		if err != nil {
    52| 			ErrorOutput(err, fmt.Sprintf("Error opening the policy file: %s", err), output)
    53| 		}
    54| 		defer f.Close()
    55| 		policyBytes, err := io.ReadAll(f)
    56| 		if err != nil {
    57| 			ErrorOutput(err, fmt.Sprintf("Error reading the policy file: %s", err), output)
    58| 		}
    59| 		request := &v1.SetPolicyRequest{Policy: string(policyBytes)}
    60| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    61| 		defer cancel()
    62| 		defer conn.Close()
    63| 		if _, err := client.SetPolicy(ctx, request); err != nil {
    64| 			ErrorOutput(err, fmt.Sprintf("Failed to set ACL Policy: %s", err), output)
    65| 		}
    66| 		SuccessOutput(nil, "Policy updated.", "")
    67| 	},
    68| }


# ====================================================================
# FILE: cmd/headscale/cli/preauthkeys.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 34-196 ---
    34| 		Bool("ephemeral", false, "Preauthkey for ephemeral nodes")
    35| 	createPreAuthKeyCmd.Flags().
    36| 		StringP("expiration", "e", DefaultPreAuthKeyExpiry, "Human-readable expiration of the key (e.g. 30m, 24h)")
    37| 	createPreAuthKeyCmd.Flags().
    38| 		StringSlice("tags", []string{}, "Tags to automatically assign to node")
    39| }
    40| var preauthkeysCmd = &cobra.Command{
    41| 	Use:     "preauthkeys",
    42| 	Short:   "Handle the preauthkeys in Headscale",
    43| 	Aliases: []string{"preauthkey", "authkey", "pre"},
    44| }
    45| var listPreAuthKeys = &cobra.Command{
    46| 	Use:     "list",
    47| 	Short:   "List the preauthkeys for this user",
    48| 	Aliases: []string{"ls", "show"},
    49| 	Run: func(cmd *cobra.Command, args []string) {
    50| 		output, _ := cmd.Flags().GetString("output")
    51| 		user, err := cmd.Flags().GetString("user")
    52| 		if err != nil {
    53| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    54| 		}
    55| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    56| 		defer cancel()
    57| 		defer conn.Close()
    58| 		request := &v1.ListPreAuthKeysRequest{
    59| 			User: user,
    60| 		}
    61| 		response, err := client.ListPreAuthKeys(ctx, request)
    62| 		if err != nil {
    63| 			ErrorOutput(
    64| 				err,
    65| 				fmt.Sprintf("Error getting the list of keys: %s", err),
    66| 				output,
    67| 			)
    68| 			return
    69| 		}
    70| 		if output != "" {
    71| 			SuccessOutput(response.GetPreAuthKeys(), "", output)
    72| 		}
    73| 		tableData := pterm.TableData{
    74| 			{
    75| 				"ID",
    76| 				"Key",
    77| 				"Reusable",
    78| 				"Ephemeral",
    79| 				"Used",
    80| 				"Expiration",
    81| 				"Created",
    82| 				"Tags",
    83| 			},
    84| 		}
    85| 		for _, key := range response.GetPreAuthKeys() {
    86| 			expiration := "-"
    87| 			if key.GetExpiration() != nil {
    88| 				expiration = ColourTime(key.GetExpiration().AsTime())
    89| 			}
    90| 			aclTags := ""
    91| 			for _, tag := range key.GetAclTags() {
    92| 				aclTags += "," + tag
    93| 			}
    94| 			aclTags = strings.TrimLeft(aclTags, ",")
    95| 			tableData = append(tableData, []string{
    96| 				key.GetId(),
    97| 				key.GetKey(),
    98| 				strconv.FormatBool(key.GetReusable()),
    99| 				strconv.FormatBool(key.GetEphemeral()),
   100| 				strconv.FormatBool(key.GetUsed()),
   101| 				expiration,
   102| 				key.GetCreatedAt().AsTime().Format("2006-01-02 15:04:05"),
   103| 				aclTags,
   104| 			})
   105| 		}
   106| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   107| 		if err != nil {
   108| 			ErrorOutput(
   109| 				err,
   110| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   111| 				output,
   112| 			)
   113| 		}
   114| 	},
   115| }
   116| var createPreAuthKeyCmd = &cobra.Command{
   117| 	Use:     "create",
   118| 	Short:   "Creates a new preauthkey in the specified user",
   119| 	Aliases: []string{"c", "new"},
   120| 	Run: func(cmd *cobra.Command, args []string) {
   121| 		output, _ := cmd.Flags().GetString("output")
   122| 		user, err := cmd.Flags().GetString("user")
   123| 		if err != nil {
   124| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   125| 		}
   126| 		reusable, _ := cmd.Flags().GetBool("reusable")
   127| 		ephemeral, _ := cmd.Flags().GetBool("ephemeral")
   128| 		tags, _ := cmd.Flags().GetStringSlice("tags")
   129| 		request := &v1.CreatePreAuthKeyRequest{
   130| 			User:      user,
   131| 			Reusable:  reusable,
   132| 			Ephemeral: ephemeral,
   133| 			AclTags:   tags,
   134| 		}
   135| 		durationStr, _ := cmd.Flags().GetString("expiration")
   136| 		duration, err := model.ParseDuration(durationStr)
   137| 		if err != nil {
   138| 			ErrorOutput(
   139| 				err,
   140| 				fmt.Sprintf("Could not parse duration: %s\n", err),
   141| 				output,
   142| 			)
   143| 		}
   144| 		expiration := time.Now().UTC().Add(time.Duration(duration))
   145| 		log.Trace().
   146| 			Dur("expiration", time.Duration(duration)).
   147| 			Msg("expiration has been set")
   148| 		request.Expiration = timestamppb.New(expiration)
   149| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   150| 		defer cancel()
   151| 		defer conn.Close()
   152| 		response, err := client.CreatePreAuthKey(ctx, request)
   153| 		if err != nil {
   154| 			ErrorOutput(
   155| 				err,
   156| 				fmt.Sprintf("Cannot create Pre Auth Key: %s\n", err),
   157| 				output,
   158| 			)
   159| 		}
   160| 		SuccessOutput(response.GetPreAuthKey(), response.GetPreAuthKey().GetKey(), output)
   161| 	},
   162| }
   163| var expirePreAuthKeyCmd = &cobra.Command{
   164| 	Use:     "expire KEY",
   165| 	Short:   "Expire a preauthkey",
   166| 	Aliases: []string{"revoke", "exp", "e"},
   167| 	Args: func(cmd *cobra.Command, args []string) error {
   168| 		if len(args) < 1 {
   169| 			return errMissingParameter
   170| 		}
   171| 		return nil
   172| 	},
   173| 	Run: func(cmd *cobra.Command, args []string) {
   174| 		output, _ := cmd.Flags().GetString("output")
   175| 		user, err := cmd.Flags().GetString("user")
   176| 		if err != nil {
   177| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   178| 		}
   179| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   180| 		defer cancel()
   181| 		defer conn.Close()
   182| 		request := &v1.ExpirePreAuthKeyRequest{
   183| 			User: user,
   184| 			Key:  args[0],
   185| 		}
   186| 		response, err := client.ExpirePreAuthKey(ctx, request)
   187| 		if err != nil {
   188| 			ErrorOutput(
   189| 				err,
   190| 				fmt.Sprintf("Cannot expire Pre Auth Key: %s\n", err),
   191| 				output,
   192| 			)
   193| 		}
   194| 		SuccessOutput(response, "Key expired", output)
   195| 	},
   196| }


# ====================================================================
# FILE: cmd/headscale/cli/root.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-79 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"os"
     5| 	"runtime"
     6| 	"github.com/juanfont/headscale/hscontrol/types"
     7| 	"github.com/rs/zerolog"
     8| 	"github.com/rs/zerolog/log"
     9| 	"github.com/spf13/cobra"
    10| 	"github.com/spf13/viper"
    11| 	"github.com/tcnksm/go-latest"
    12| )
    13| const (
    14| 	deprecateNamespaceMessage = "use --user"
    15| )
    16| var cfgFile string = ""
    17| func init() {
    18| 	if len(os.Args) > 1 &&
    19| 		(os.Args[1] == "version" || os.Args[1] == "mockoidc" || os.Args[1] == "completion") {
    20| 		return
    21| 	}
    22| 	cobra.OnInitialize(initConfig)
    23| 	rootCmd.PersistentFlags().
    24| 		StringVarP(&cfgFile, "config", "c", "", "config file (default is /etc/headscale/config.yaml)")
    25| 	rootCmd.PersistentFlags().
    26| 		StringP("output", "o", "", "Output format. Empty for human-readable, 'json', 'json-line' or 'yaml'")
    27| 	rootCmd.PersistentFlags().
    28| 		Bool("force", false, "Disable prompts and forces the execution")
    29| }
    30| func initConfig() {
    31| 	if cfgFile == "" {
    32| 		cfgFile = os.Getenv("HEADSCALE_CONFIG")
    33| 	}
    34| 	if cfgFile != "" {
    35| 		err := types.LoadConfig(cfgFile, true)
    36| 		if err != nil {
    37| 			log.Fatal().Caller().Err(err).Msgf("Error loading config file %s", cfgFile)
    38| 		}
    39| 	} else {
    40| 		err := types.LoadConfig("", false)
    41| 		if err != nil {
    42| 			log.Fatal().Caller().Err(err).Msgf("Error loading config")
    43| 		}
    44| 	}
    45| 	machineOutput := HasMachineOutputFlag()
    46| 	if machineOutput {
    47| 		zerolog.SetGlobalLevel(zerolog.Disabled)
    48| 	}
    49| 	disableUpdateCheck := viper.GetBool("disable_check_updates")
    50| 	if !disableUpdateCheck && !machineOutput {
    51| 		if (runtime.GOOS == "linux" || runtime.GOOS == "darwin") &&
    52| 			Version != "dev" {
    53| 			githubTag := &latest.GithubTag{
    54| 				Owner:      "juanfont",
    55| 				Repository: "headscale",
    56| 			}
    57| 			res, err := latest.Check(githubTag, Version)
    58| 			if err == nil && res.Outdated {
    59| 				log.Warn().Msgf(
    60| 					"An updated version of Headscale has been found (%s vs. your current %s). Check it out https://github.com/juanfont/headscale/releases\n",
    61| 					res.Current,
    62| 					Version,
    63| 				)
    64| 			}
    65| 		}
    66| 	}
    67| }
    68| var rootCmd = &cobra.Command{
    69| 	Use:   "headscale",
    70| 	Short: "headscale - a Tailscale control server",
    71| 	Long: `
    72| headscale is an open source implementation of the Tailscale control server
    73| https://github.com/juanfont/headscale`,
    74| }
    75| func Execute() {
    76| 	if err := rootCmd.Execute(); err != nil {
    77| 		fmt.Fprintln(os.Stderr, err)
    78| 		os.Exit(1)
    79| 	}


# ====================================================================
# FILE: cmd/headscale/cli/routes.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"log"
     5| 	"net/netip"
     6| 	"strconv"
     7| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     8| 	"github.com/juanfont/headscale/hscontrol/types"
     9| 	"github.com/pterm/pterm"
    10| 	"github.com/spf13/cobra"
    11| 	"google.golang.org/grpc/status"
    12| )
    13| const (
    14| 	Base10 = 10
    15| )
    16| func init() {
    17| 	rootCmd.AddCommand(routesCmd)
    18| 	listRoutesCmd.Flags().Uint64P("identifier", "i", 0, "Node identifier (ID)")
    19| 	routesCmd.AddCommand(listRoutesCmd)
    20| 	enableRouteCmd.Flags().Uint64P("route", "r", 0, "Route identifier (ID)")
    21| 	err := enableRouteCmd.MarkFlagRequired("route")
    22| 	if err != nil {
    23| 		log.Fatalf(err.Error())
    24| 	}
    25| 	routesCmd.AddCommand(enableRouteCmd)
    26| 	disableRouteCmd.Flags().Uint64P("route", "r", 0, "Route identifier (ID)")
    27| 	err = disableRouteCmd.MarkFlagRequired("route")
    28| 	if err != nil {

# --- HUNK 2: Lines 37-226 ---
    37| 	routesCmd.AddCommand(deleteRouteCmd)
    38| }
    39| var routesCmd = &cobra.Command{
    40| 	Use:     "routes",
    41| 	Short:   "Manage the routes of Headscale",
    42| 	Aliases: []string{"r", "route"},
    43| }
    44| var listRoutesCmd = &cobra.Command{
    45| 	Use:     "list",
    46| 	Short:   "List all routes",
    47| 	Aliases: []string{"ls", "show"},
    48| 	Run: func(cmd *cobra.Command, args []string) {
    49| 		output, _ := cmd.Flags().GetString("output")
    50| 		machineID, err := cmd.Flags().GetUint64("identifier")
    51| 		if err != nil {
    52| 			ErrorOutput(
    53| 				err,
    54| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
    55| 				output,
    56| 			)
    57| 		}
    58| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    59| 		defer cancel()
    60| 		defer conn.Close()
    61| 		var routes []*v1.Route
    62| 		if machineID == 0 {
    63| 			response, err := client.GetRoutes(ctx, &v1.GetRoutesRequest{})
    64| 			if err != nil {
    65| 				ErrorOutput(
    66| 					err,
    67| 					fmt.Sprintf("Cannot get nodes: %s", status.Convert(err).Message()),
    68| 					output,
    69| 				)
    70| 			}
    71| 			if output != "" {
    72| 				SuccessOutput(response.GetRoutes(), "", output)
    73| 			}
    74| 			routes = response.GetRoutes()
    75| 		} else {
    76| 			response, err := client.GetNodeRoutes(ctx, &v1.GetNodeRoutesRequest{
    77| 				NodeId: machineID,
    78| 			})
    79| 			if err != nil {
    80| 				ErrorOutput(
    81| 					err,
    82| 					fmt.Sprintf("Cannot get routes for node %d: %s", machineID, status.Convert(err).Message()),
    83| 					output,
    84| 				)
    85| 			}
    86| 			if output != "" {
    87| 				SuccessOutput(response.GetRoutes(), "", output)
    88| 			}
    89| 			routes = response.GetRoutes()
    90| 		}
    91| 		tableData := routesToPtables(routes)
    92| 		if err != nil {
    93| 			ErrorOutput(err, fmt.Sprintf("Error converting to table: %s", err), output)
    94| 		}
    95| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
    96| 		if err != nil {
    97| 			ErrorOutput(
    98| 				err,
    99| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   100| 				output,
   101| 			)
   102| 		}
   103| 	},
   104| }
   105| var enableRouteCmd = &cobra.Command{
   106| 	Use:   "enable",
   107| 	Short: "Set a route as enabled",
   108| 	Long:  `This command will make as enabled a given route.`,
   109| 	Run: func(cmd *cobra.Command, args []string) {
   110| 		output, _ := cmd.Flags().GetString("output")
   111| 		routeID, err := cmd.Flags().GetUint64("route")
   112| 		if err != nil {
   113| 			ErrorOutput(
   114| 				err,
   115| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   116| 				output,
   117| 			)
   118| 		}
   119| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   120| 		defer cancel()
   121| 		defer conn.Close()
   122| 		response, err := client.EnableRoute(ctx, &v1.EnableRouteRequest{
   123| 			RouteId: routeID,
   124| 		})
   125| 		if err != nil {
   126| 			ErrorOutput(
   127| 				err,
   128| 				fmt.Sprintf("Cannot enable route %d: %s", routeID, status.Convert(err).Message()),
   129| 				output,
   130| 			)
   131| 		}
   132| 		if output != "" {
   133| 			SuccessOutput(response, "", output)
   134| 		}
   135| 	},
   136| }
   137| var disableRouteCmd = &cobra.Command{
   138| 	Use:   "disable",
   139| 	Short: "Set as disabled a given route",
   140| 	Long:  `This command will make as disabled a given route.`,
   141| 	Run: func(cmd *cobra.Command, args []string) {
   142| 		output, _ := cmd.Flags().GetString("output")
   143| 		routeID, err := cmd.Flags().GetUint64("route")
   144| 		if err != nil {
   145| 			ErrorOutput(
   146| 				err,
   147| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   148| 				output,
   149| 			)
   150| 		}
   151| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   152| 		defer cancel()
   153| 		defer conn.Close()
   154| 		response, err := client.DisableRoute(ctx, &v1.DisableRouteRequest{
   155| 			RouteId: routeID,
   156| 		})
   157| 		if err != nil {
   158| 			ErrorOutput(
   159| 				err,
   160| 				fmt.Sprintf("Cannot disable route %d: %s", routeID, status.Convert(err).Message()),
   161| 				output,
   162| 			)
   163| 		}
   164| 		if output != "" {
   165| 			SuccessOutput(response, "", output)
   166| 		}
   167| 	},
   168| }
   169| var deleteRouteCmd = &cobra.Command{
   170| 	Use:   "delete",
   171| 	Short: "Delete a given route",
   172| 	Long:  `This command will delete a given route.`,
   173| 	Run: func(cmd *cobra.Command, args []string) {
   174| 		output, _ := cmd.Flags().GetString("output")
   175| 		routeID, err := cmd.Flags().GetUint64("route")
   176| 		if err != nil {
   177| 			ErrorOutput(
   178| 				err,
   179| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   180| 				output,
   181| 			)
   182| 		}
   183| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   184| 		defer cancel()
   185| 		defer conn.Close()
   186| 		response, err := client.DeleteRoute(ctx, &v1.DeleteRouteRequest{
   187| 			RouteId: routeID,
   188| 		})
   189| 		if err != nil {
   190| 			ErrorOutput(
   191| 				err,
   192| 				fmt.Sprintf("Cannot delete route %d: %s", routeID, status.Convert(err).Message()),
   193| 				output,
   194| 			)
   195| 		}
   196| 		if output != "" {
   197| 			SuccessOutput(response, "", output)
   198| 		}
   199| 	},
   200| }
   201| func routesToPtables(routes []*v1.Route) pterm.TableData {
   202| 	tableData := pterm.TableData{{"ID", "Node", "Prefix", "Advertised", "Enabled", "Primary"}}
   203| 	for _, route := range routes {
   204| 		var isPrimaryStr string
   205| 		prefix, err := netip.ParsePrefix(route.GetPrefix())
   206| 		if err != nil {
   207| 			log.Printf("Error parsing prefix %s: %s", route.GetPrefix(), err)
   208| 			continue
   209| 		}
   210| 		if prefix == types.ExitRouteV4 || prefix == types.ExitRouteV6 {
   211| 			isPrimaryStr = "-"
   212| 		} else {
   213| 			isPrimaryStr = strconv.FormatBool(route.GetIsPrimary())
   214| 		}
   215| 		tableData = append(tableData,
   216| 			[]string{
   217| 				strconv.FormatUint(route.GetId(), Base10),
   218| 				route.GetNode().GetGivenName(),
   219| 				route.GetPrefix(),
   220| 				strconv.FormatBool(route.GetAdvertised()),
   221| 				strconv.FormatBool(route.GetEnabled()),
   222| 				isPrimaryStr,
   223| 			})
   224| 	}
   225| 	return tableData
   226| }


# ====================================================================
# FILE: cmd/headscale/cli/serve.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package cli
     2| import (
     3| 	"errors"
     4| 	"net/http"
     5| 	"github.com/rs/zerolog/log"
     6| 	"github.com/spf13/cobra"
     7| )
     8| func init() {
     9| 	rootCmd.AddCommand(serveCmd)
    10| }
    11| var serveCmd = &cobra.Command{
    12| 	Use:   "serve",
    13| 	Short: "Launches the headscale server",
    14| 	Args: func(cmd *cobra.Command, args []string) error {
    15| 		return nil
    16| 	},
    17| 	Run: func(cmd *cobra.Command, args []string) {
    18| 		app, err := newHeadscaleServerWithConfig()
    19| 		if err != nil {
    20| 			log.Fatal().Caller().Err(err).Msg("Error initializing")
    21| 		}
    22| 		err = app.Serve()
    23| 		if err != nil && !errors.Is(err, http.ErrServerClosed) {
    24| 			log.Fatal().Caller().Err(err).Msg("Headscale ran into an error and had to shut down.")
    25| 		}
    26| 	},
    27| }


# ====================================================================
# FILE: cmd/headscale/cli/users.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-193 ---
     1| package cli
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	survey "github.com/AlecAivazis/survey/v2"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"github.com/pterm/pterm"
     8| 	"github.com/rs/zerolog/log"
     9| 	"github.com/spf13/cobra"
    10| 	"google.golang.org/grpc/status"
    11| )
    12| func init() {
    13| 	rootCmd.AddCommand(userCmd)
    14| 	userCmd.AddCommand(createUserCmd)
    15| 	userCmd.AddCommand(listUsersCmd)
    16| 	userCmd.AddCommand(destroyUserCmd)
    17| 	userCmd.AddCommand(renameUserCmd)
    18| }
    19| var errMissingParameter = errors.New("missing parameters")
    20| var userCmd = &cobra.Command{
    21| 	Use:     "users",
    22| 	Short:   "Manage the users of Headscale",
    23| 	Aliases: []string{"user", "namespace", "namespaces", "ns"},
    24| }
    25| var createUserCmd = &cobra.Command{
    26| 	Use:     "create NAME",
    27| 	Short:   "Creates a new user",
    28| 	Aliases: []string{"c", "new"},
    29| 	Args: func(cmd *cobra.Command, args []string) error {
    30| 		if len(args) < 1 {
    31| 			return errMissingParameter
    32| 		}
    33| 		return nil
    34| 	},
    35| 	Run: func(cmd *cobra.Command, args []string) {
    36| 		output, _ := cmd.Flags().GetString("output")
    37| 		userName := args[0]
    38| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    39| 		defer cancel()
    40| 		defer conn.Close()
    41| 		log.Trace().Interface("client", client).Msg("Obtained gRPC client")
    42| 		request := &v1.CreateUserRequest{Name: userName}
    43| 		log.Trace().Interface("request", request).Msg("Sending CreateUser request")
    44| 		response, err := client.CreateUser(ctx, request)
    45| 		if err != nil {
    46| 			ErrorOutput(
    47| 				err,
    48| 				fmt.Sprintf(
    49| 					"Cannot create user: %s",
    50| 					status.Convert(err).Message(),
    51| 				),
    52| 				output,
    53| 			)
    54| 		}
    55| 		SuccessOutput(response.GetUser(), "User created", output)
    56| 	},
    57| }
    58| var destroyUserCmd = &cobra.Command{
    59| 	Use:     "destroy NAME",
    60| 	Short:   "Destroys a user",
    61| 	Aliases: []string{"delete"},
    62| 	Args: func(cmd *cobra.Command, args []string) error {
    63| 		if len(args) < 1 {
    64| 			return errMissingParameter
    65| 		}
    66| 		return nil
    67| 	},
    68| 	Run: func(cmd *cobra.Command, args []string) {
    69| 		output, _ := cmd.Flags().GetString("output")
    70| 		userName := args[0]
    71| 		request := &v1.GetUserRequest{
    72| 			Name: userName,
    73| 		}
    74| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
    75| 		defer cancel()
    76| 		defer conn.Close()
    77| 		_, err := client.GetUser(ctx, request)
    78| 		if err != nil {
    79| 			ErrorOutput(
    80| 				err,
    81| 				fmt.Sprintf("Error: %s", status.Convert(err).Message()),
    82| 				output,
    83| 			)
    84| 		}
    85| 		confirm := false
    86| 		force, _ := cmd.Flags().GetBool("force")
    87| 		if !force {
    88| 			prompt := &survey.Confirm{
    89| 				Message: fmt.Sprintf(
    90| 					"Do you want to remove the user '%s' and any associated preauthkeys?",
    91| 					userName,
    92| 				),
    93| 			}
    94| 			err := survey.AskOne(prompt, &confirm)
    95| 			if err != nil {
    96| 				return
    97| 			}
    98| 		}
    99| 		if confirm || force {
   100| 			request := &v1.DeleteUserRequest{Name: userName}
   101| 			response, err := client.DeleteUser(ctx, request)
   102| 			if err != nil {
   103| 				ErrorOutput(
   104| 					err,
   105| 					fmt.Sprintf(
   106| 						"Cannot destroy user: %s",
   107| 						status.Convert(err).Message(),
   108| 					),
   109| 					output,
   110| 				)
   111| 			}
   112| 			SuccessOutput(response, "User destroyed", output)
   113| 		} else {
   114| 			SuccessOutput(map[string]string{"Result": "User not destroyed"}, "User not destroyed", output)
   115| 		}
   116| 	},
   117| }
   118| var listUsersCmd = &cobra.Command{
   119| 	Use:     "list",
   120| 	Short:   "List all the users",
   121| 	Aliases: []string{"ls", "show"},
   122| 	Run: func(cmd *cobra.Command, args []string) {
   123| 		output, _ := cmd.Flags().GetString("output")
   124| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   125| 		defer cancel()
   126| 		defer conn.Close()
   127| 		request := &v1.ListUsersRequest{}
   128| 		response, err := client.ListUsers(ctx, request)
   129| 		if err != nil {
   130| 			ErrorOutput(
   131| 				err,
   132| 				fmt.Sprintf("Cannot get users: %s", status.Convert(err).Message()),
   133| 				output,
   134| 			)
   135| 		}
   136| 		if output != "" {
   137| 			SuccessOutput(response.GetUsers(), "", output)
   138| 		}
   139| 		tableData := pterm.TableData{{"ID", "Name", "Created"}}
   140| 		for _, user := range response.GetUsers() {
   141| 			tableData = append(
   142| 				tableData,
   143| 				[]string{
   144| 					user.GetId(),
   145| 					user.GetName(),
   146| 					user.GetCreatedAt().AsTime().Format("2006-01-02 15:04:05"),
   147| 				},
   148| 			)
   149| 		}
   150| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   151| 		if err != nil {
   152| 			ErrorOutput(
   153| 				err,
   154| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   155| 				output,
   156| 			)
   157| 		}
   158| 	},
   159| }
   160| var renameUserCmd = &cobra.Command{
   161| 	Use:     "rename OLD_NAME NEW_NAME",
   162| 	Short:   "Renames a user",
   163| 	Aliases: []string{"mv"},
   164| 	Args: func(cmd *cobra.Command, args []string) error {
   165| 		expectedArguments := 2
   166| 		if len(args) < expectedArguments {
   167| 			return errMissingParameter
   168| 		}
   169| 		return nil
   170| 	},
   171| 	Run: func(cmd *cobra.Command, args []string) {
   172| 		output, _ := cmd.Flags().GetString("output")
   173| 		ctx, client, conn, cancel := newHeadscaleCLIWithConfig()
   174| 		defer cancel()
   175| 		defer conn.Close()
   176| 		request := &v1.RenameUserRequest{
   177| 			OldName: args[0],
   178| 			NewName: args[1],
   179| 		}
   180| 		response, err := client.RenameUser(ctx, request)
   181| 		if err != nil {
   182| 			ErrorOutput(
   183| 				err,
   184| 				fmt.Sprintf(
   185| 					"Cannot rename user: %s",
   186| 					status.Convert(err).Message(),
   187| 				),
   188| 				output,
   189| 			)
   190| 		}
   191| 		SuccessOutput(response.GetUser(), "User renamed", output)
   192| 	},
   193| }


# ====================================================================
# FILE: cmd/headscale/cli/utils.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-161 ---
     1| package cli
     2| import (
     3| 	"context"
     4| 	"crypto/tls"
     5| 	"encoding/json"
     6| 	"fmt"
     7| 	"os"
     8| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     9| 	"github.com/juanfont/headscale/hscontrol"
    10| 	"github.com/juanfont/headscale/hscontrol/types"
    11| 	"github.com/juanfont/headscale/hscontrol/util"
    12| 	"github.com/rs/zerolog/log"
    13| 	"google.golang.org/grpc"
    14| 	"google.golang.org/grpc/credentials"
    15| 	"google.golang.org/grpc/credentials/insecure"
    16| 	"gopkg.in/yaml.v3"
    17| )
    18| const (
    19| 	HeadscaleDateTimeFormat = "2006-01-02 15:04:05"
    20| 	SocketWritePermissions  = 0o666
    21| )
    22| func newHeadscaleServerWithConfig() (*hscontrol.Headscale, error) {
    23| 	cfg, err := types.LoadServerConfig()
    24| 	if err != nil {
    25| 		return nil, fmt.Errorf(
    26| 			"failed to load configuration while creating headscale instance: %w",
    27| 			err,
    28| 		)
    29| 	}
    30| 	app, err := hscontrol.NewHeadscale(cfg)
    31| 	if err != nil {
    32| 		return nil, err
    33| 	}
    34| 	return app, nil
    35| }
    36| func newHeadscaleCLIWithConfig() (context.Context, v1.HeadscaleServiceClient, *grpc.ClientConn, context.CancelFunc) {
    37| 	cfg, err := types.LoadCLIConfig()
    38| 	if err != nil {
    39| 		log.Fatal().
    40| 			Err(err).
    41| 			Caller().
    42| 			Msgf("Failed to load configuration")
    43| 		os.Exit(-1) // we get here if logging is suppressed (i.e., json output)
    44| 	}
    45| 	log.Debug().
    46| 		Dur("timeout", cfg.CLI.Timeout).
    47| 		Msgf("Setting timeout")
    48| 	ctx, cancel := context.WithTimeout(context.Background(), cfg.CLI.Timeout)
    49| 	grpcOptions := []grpc.DialOption{
    50| 		grpc.WithBlock(),
    51| 	}
    52| 	address := cfg.CLI.Address
    53| 	if address == "" {
    54| 		log.Debug().
    55| 			Str("socket", cfg.UnixSocket).
    56| 			Msgf("HEADSCALE_CLI_ADDRESS environment is not set, connecting to unix socket.")
    57| 		address = cfg.UnixSocket
    58| 		socket, err := os.OpenFile(cfg.UnixSocket, os.O_WRONLY, SocketWritePermissions) // nolint
    59| 		if err != nil {
    60| 			if os.IsPermission(err) {
    61| 				log.Fatal().
    62| 					Err(err).
    63| 					Str("socket", cfg.UnixSocket).
    64| 					Msgf("Unable to read/write to headscale socket, do you have the correct permissions?")
    65| 			}
    66| 		}
    67| 		socket.Close()
    68| 		grpcOptions = append(
    69| 			grpcOptions,
    70| 			grpc.WithTransportCredentials(insecure.NewCredentials()),
    71| 			grpc.WithContextDialer(util.GrpcSocketDialer),
    72| 		)
    73| 	} else {
    74| 		apiKey := cfg.CLI.APIKey
    75| 		if apiKey == "" {
    76| 			log.Fatal().Caller().Msgf("HEADSCALE_CLI_API_KEY environment variable needs to be set.")
    77| 		}
    78| 		grpcOptions = append(grpcOptions,
    79| 			grpc.WithPerRPCCredentials(tokenAuth{
    80| 				token: apiKey,
    81| 			}),
    82| 		)
    83| 		if cfg.CLI.Insecure {
    84| 			tlsConfig := &tls.Config{
    85| 				InsecureSkipVerify: true,
    86| 			}
    87| 			grpcOptions = append(grpcOptions,
    88| 				grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)),
    89| 			)
    90| 		} else {
    91| 			grpcOptions = append(grpcOptions,
    92| 				grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, "")),
    93| 			)
    94| 		}
    95| 	}
    96| 	log.Trace().Caller().Str("address", address).Msg("Connecting via gRPC")
    97| 	conn, err := grpc.DialContext(ctx, address, grpcOptions...)
    98| 	if err != nil {
    99| 		log.Fatal().Caller().Err(err).Msgf("Could not connect: %v", err)
   100| 		os.Exit(-1) // we get here if logging is suppressed (i.e., json output)
   101| 	}
   102| 	client := v1.NewHeadscaleServiceClient(conn)
   103| 	return ctx, client, conn, cancel
   104| }
   105| func output(result interface{}, override string, outputFormat string) string {
   106| 	var jsonBytes []byte
   107| 	var err error
   108| 	switch outputFormat {
   109| 	case "json":
   110| 		jsonBytes, err = json.MarshalIndent(result, "", "\t")
   111| 		if err != nil {
   112| 			log.Fatal().Err(err).Msg("failed to unmarshal output")
   113| 		}
   114| 	case "json-line":
   115| 		jsonBytes, err = json.Marshal(result)
   116| 		if err != nil {
   117| 			log.Fatal().Err(err).Msg("failed to unmarshal output")
   118| 		}
   119| 	case "yaml":
   120| 		jsonBytes, err = yaml.Marshal(result)
   121| 		if err != nil {
   122| 			log.Fatal().Err(err).Msg("failed to unmarshal output")
   123| 		}
   124| 	default:
   125| 		return override
   126| 	}
   127| 	return string(jsonBytes)
   128| }
   129| func SuccessOutput(result interface{}, override string, outputFormat string) {
   130| 	fmt.Println(output(result, override, outputFormat))
   131| 	os.Exit(0)
   132| }
   133| func ErrorOutput(errResult error, override string, outputFormat string) {
   134| 	type errOutput struct {
   135| 		Error string `json:"error"`
   136| 	}
   137| 	fmt.Fprintf(os.Stderr, "%s\n", output(errOutput{errResult.Error()}, override, outputFormat))
   138| 	os.Exit(1)
   139| }
   140| func HasMachineOutputFlag() bool {
   141| 	for _, arg := range os.Args {
   142| 		if arg == "json" || arg == "json-line" || arg == "yaml" {
   143| 			return true
   144| 		}
   145| 	}
   146| 	return false
   147| }
   148| type tokenAuth struct {
   149| 	token string
   150| }
   151| func (t tokenAuth) GetRequestMetadata(
   152| 	ctx context.Context,
   153| 	in ...string,
   154| ) (map[string]string, error) {
   155| 	return map[string]string{
   156| 		"authorization": "Bearer " + t.token,
   157| 	}, nil
   158| }
   159| func (tokenAuth) RequireTransportSecurity() bool {
   160| 	return true
   161| }


# ====================================================================
# FILE: cmd/headscale/headscale.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-34 ---
     1| package main
     2| import (
     3| 	"os"
     4| 	"time"
     5| 	"github.com/jagottsicher/termcolor"
     6| 	"github.com/juanfont/headscale/cmd/headscale/cli"
     7| 	"github.com/rs/zerolog"
     8| 	"github.com/rs/zerolog/log"
     9| )
    10| func main() {
    11| 	var colors bool
    12| 	switch l := termcolor.SupportLevel(os.Stderr); l {
    13| 	case termcolor.Level16M:
    14| 		colors = true
    15| 	case termcolor.Level256:
    16| 		colors = true
    17| 	case termcolor.LevelBasic:
    18| 		colors = true
    19| 	case termcolor.LevelNone:
    20| 		colors = false
    21| 	default:
    22| 		colors = false
    23| 	}
    24| 	if _, noColorIsSet := os.LookupEnv("NO_COLOR"); noColorIsSet {
    25| 		colors = false
    26| 	}
    27| 	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
    28| 	log.Logger = log.Output(zerolog.ConsoleWriter{
    29| 		Out:        os.Stderr,
    30| 		TimeFormat: time.RFC3339,
    31| 		NoColor:    !colors,
    32| 	})
    33| 	cli.Execute()
    34| }


# ====================================================================
# FILE: gen/go/headscale/v1/apikey.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 272-578 ---
   272| func (*ListApiKeysResponse) ProtoMessage() {}
   273| func (x *ListApiKeysResponse) ProtoReflect() protoreflect.Message {
   274| 	mi := &file_headscale_v1_apikey_proto_msgTypes[6]
   275| 	if protoimpl.UnsafeEnabled && x != nil {
   276| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   277| 		if ms.LoadMessageInfo() == nil {
   278| 			ms.StoreMessageInfo(mi)
   279| 		}
   280| 		return ms
   281| 	}
   282| 	return mi.MessageOf(x)
   283| }
   284| func (*ListApiKeysResponse) Descriptor() ([]byte, []int) {
   285| 	return file_headscale_v1_apikey_proto_rawDescGZIP(), []int{6}
   286| }
   287| func (x *ListApiKeysResponse) GetApiKeys() []*ApiKey {
   288| 	if x != nil {
   289| 		return x.ApiKeys
   290| 	}
   291| 	return nil
   292| }
   293| type DeleteApiKeyRequest struct {
   294| 	state         protoimpl.MessageState
   295| 	sizeCache     protoimpl.SizeCache
   296| 	unknownFields protoimpl.UnknownFields
   297| 	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
   298| }
   299| func (x *DeleteApiKeyRequest) Reset() {
   300| 	*x = DeleteApiKeyRequest{}
   301| 	if protoimpl.UnsafeEnabled {
   302| 		mi := &file_headscale_v1_apikey_proto_msgTypes[7]
   303| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   304| 		ms.StoreMessageInfo(mi)
   305| 	}
   306| }
   307| func (x *DeleteApiKeyRequest) String() string {
   308| 	return protoimpl.X.MessageStringOf(x)
   309| }
   310| func (*DeleteApiKeyRequest) ProtoMessage() {}
   311| func (x *DeleteApiKeyRequest) ProtoReflect() protoreflect.Message {
   312| 	mi := &file_headscale_v1_apikey_proto_msgTypes[7]
   313| 	if protoimpl.UnsafeEnabled && x != nil {
   314| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   315| 		if ms.LoadMessageInfo() == nil {
   316| 			ms.StoreMessageInfo(mi)
   317| 		}
   318| 		return ms
   319| 	}
   320| 	return mi.MessageOf(x)
   321| }
   322| func (*DeleteApiKeyRequest) Descriptor() ([]byte, []int) {
   323| 	return file_headscale_v1_apikey_proto_rawDescGZIP(), []int{7}
   324| }
   325| func (x *DeleteApiKeyRequest) GetPrefix() string {
   326| 	if x != nil {
   327| 		return x.Prefix
   328| 	}
   329| 	return ""
   330| }
   331| type DeleteApiKeyResponse struct {
   332| 	state         protoimpl.MessageState
   333| 	sizeCache     protoimpl.SizeCache
   334| 	unknownFields protoimpl.UnknownFields
   335| }
   336| func (x *DeleteApiKeyResponse) Reset() {
   337| 	*x = DeleteApiKeyResponse{}
   338| 	if protoimpl.UnsafeEnabled {
   339| 		mi := &file_headscale_v1_apikey_proto_msgTypes[8]
   340| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   341| 		ms.StoreMessageInfo(mi)
   342| 	}
   343| }
   344| func (x *DeleteApiKeyResponse) String() string {
   345| 	return protoimpl.X.MessageStringOf(x)
   346| }
   347| func (*DeleteApiKeyResponse) ProtoMessage() {}
   348| func (x *DeleteApiKeyResponse) ProtoReflect() protoreflect.Message {
   349| 	mi := &file_headscale_v1_apikey_proto_msgTypes[8]
   350| 	if protoimpl.UnsafeEnabled && x != nil {
   351| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   352| 		if ms.LoadMessageInfo() == nil {
   353| 			ms.StoreMessageInfo(mi)
   354| 		}
   355| 		return ms
   356| 	}
   357| 	return mi.MessageOf(x)
   358| }
   359| func (*DeleteApiKeyResponse) Descriptor() ([]byte, []int) {
   360| 	return file_headscale_v1_apikey_proto_rawDescGZIP(), []int{8}
   361| }
   362| var File_headscale_v1_apikey_proto protoreflect.FileDescriptor
   363| var file_headscale_v1_apikey_proto_rawDesc = []byte{
   364| 	0x0a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x61,
   365| 	0x70, 0x69, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61,
   366| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   367| 	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
   368| 	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xe0, 0x01, 0x0a, 0x06, 0x41,
   369| 	0x70, 0x69, 0x4b, 0x65, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
   370| 	0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
   371| 	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x3a, 0x0a,
   372| 	0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
   373| 	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
   374| 	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x65,
   375| 	0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65,
   376| 	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
   377| 	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
   378| 	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74,
   379| 	0x65, 0x64, 0x41, 0x74, 0x12, 0x37, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x65,
   380| 	0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
   381| 	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
   382| 	0x61, 0x6d, 0x70, 0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x65, 0x6e, 0x22, 0x51, 0x0a,
   383| 	0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71,
   384| 	0x75, 0x65, 0x73, 0x74, 0x12, 0x3a, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69,
   385| 	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   386| 	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
   387| 	0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
   388| 	0x22, 0x2f, 0x0a, 0x14, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79,
   389| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x61, 0x70, 0x69, 0x5f,
   390| 	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x61, 0x70, 0x69, 0x4b, 0x65,
   391| 	0x79, 0x22, 0x2d, 0x0a, 0x13, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65,
   392| 	0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66,
   393| 	0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78,
   394| 	0x22, 0x16, 0x0a, 0x14, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79,
   395| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x14, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74,
   396| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x46,
   397| 	0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73,
   398| 	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x08, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79,
   399| 	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   400| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x07, 0x61,
   401| 	0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x22, 0x2d, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
   402| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a,
   403| 	0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70,
   404| 	0x72, 0x65, 0x66, 0x69, 0x78, 0x22, 0x16, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41,
   405| 	0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x29, 0x5a,
   406| 	0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e,
   407| 	0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67,
   408| 	0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
   409| }
   410| var (
   411| 	file_headscale_v1_apikey_proto_rawDescOnce sync.Once
   412| 	file_headscale_v1_apikey_proto_rawDescData = file_headscale_v1_apikey_proto_rawDesc
   413| )
   414| func file_headscale_v1_apikey_proto_rawDescGZIP() []byte {
   415| 	file_headscale_v1_apikey_proto_rawDescOnce.Do(func() {
   416| 		file_headscale_v1_apikey_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_apikey_proto_rawDescData)
   417| 	})
   418| 	return file_headscale_v1_apikey_proto_rawDescData
   419| }
   420| var file_headscale_v1_apikey_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
   421| var file_headscale_v1_apikey_proto_goTypes = []any{
   422| 	(*ApiKey)(nil),                // 0: headscale.v1.ApiKey
   423| 	(*CreateApiKeyRequest)(nil),   // 1: headscale.v1.CreateApiKeyRequest
   424| 	(*CreateApiKeyResponse)(nil),  // 2: headscale.v1.CreateApiKeyResponse
   425| 	(*ExpireApiKeyRequest)(nil),   // 3: headscale.v1.ExpireApiKeyRequest
   426| 	(*ExpireApiKeyResponse)(nil),  // 4: headscale.v1.ExpireApiKeyResponse
   427| 	(*ListApiKeysRequest)(nil),    // 5: headscale.v1.ListApiKeysRequest
   428| 	(*ListApiKeysResponse)(nil),   // 6: headscale.v1.ListApiKeysResponse
   429| 	(*DeleteApiKeyRequest)(nil),   // 7: headscale.v1.DeleteApiKeyRequest
   430| 	(*DeleteApiKeyResponse)(nil),  // 8: headscale.v1.DeleteApiKeyResponse
   431| 	(*timestamppb.Timestamp)(nil), // 9: google.protobuf.Timestamp
   432| }
   433| var file_headscale_v1_apikey_proto_depIdxs = []int32{
   434| 	9, // 0: headscale.v1.ApiKey.expiration:type_name -> google.protobuf.Timestamp
   435| 	9, // 1: headscale.v1.ApiKey.created_at:type_name -> google.protobuf.Timestamp
   436| 	9, // 2: headscale.v1.ApiKey.last_seen:type_name -> google.protobuf.Timestamp
   437| 	9, // 3: headscale.v1.CreateApiKeyRequest.expiration:type_name -> google.protobuf.Timestamp
   438| 	0, // 4: headscale.v1.ListApiKeysResponse.api_keys:type_name -> headscale.v1.ApiKey
   439| 	5, // [5:5] is the sub-list for method output_type
   440| 	5, // [5:5] is the sub-list for method input_type
   441| 	5, // [5:5] is the sub-list for extension type_name
   442| 	5, // [5:5] is the sub-list for extension extendee
   443| 	0, // [0:5] is the sub-list for field type_name
   444| }
   445| func init() { file_headscale_v1_apikey_proto_init() }
   446| func file_headscale_v1_apikey_proto_init() {
   447| 	if File_headscale_v1_apikey_proto != nil {
   448| 		return
   449| 	}
   450| 	if !protoimpl.UnsafeEnabled {
   451| 		file_headscale_v1_apikey_proto_msgTypes[0].Exporter = func(v any, i int) any {
   452| 			switch v := v.(*ApiKey); i {
   453| 			case 0:
   454| 				return &v.state
   455| 			case 1:
   456| 				return &v.sizeCache
   457| 			case 2:
   458| 				return &v.unknownFields
   459| 			default:
   460| 				return nil
   461| 			}
   462| 		}
   463| 		file_headscale_v1_apikey_proto_msgTypes[1].Exporter = func(v any, i int) any {
   464| 			switch v := v.(*CreateApiKeyRequest); i {
   465| 			case 0:
   466| 				return &v.state
   467| 			case 1:
   468| 				return &v.sizeCache
   469| 			case 2:
   470| 				return &v.unknownFields
   471| 			default:
   472| 				return nil
   473| 			}
   474| 		}
   475| 		file_headscale_v1_apikey_proto_msgTypes[2].Exporter = func(v any, i int) any {
   476| 			switch v := v.(*CreateApiKeyResponse); i {
   477| 			case 0:
   478| 				return &v.state
   479| 			case 1:
   480| 				return &v.sizeCache
   481| 			case 2:
   482| 				return &v.unknownFields
   483| 			default:
   484| 				return nil
   485| 			}
   486| 		}
   487| 		file_headscale_v1_apikey_proto_msgTypes[3].Exporter = func(v any, i int) any {
   488| 			switch v := v.(*ExpireApiKeyRequest); i {
   489| 			case 0:
   490| 				return &v.state
   491| 			case 1:
   492| 				return &v.sizeCache
   493| 			case 2:
   494| 				return &v.unknownFields
   495| 			default:
   496| 				return nil
   497| 			}
   498| 		}
   499| 		file_headscale_v1_apikey_proto_msgTypes[4].Exporter = func(v any, i int) any {
   500| 			switch v := v.(*ExpireApiKeyResponse); i {
   501| 			case 0:
   502| 				return &v.state
   503| 			case 1:
   504| 				return &v.sizeCache
   505| 			case 2:
   506| 				return &v.unknownFields
   507| 			default:
   508| 				return nil
   509| 			}
   510| 		}
   511| 		file_headscale_v1_apikey_proto_msgTypes[5].Exporter = func(v any, i int) any {
   512| 			switch v := v.(*ListApiKeysRequest); i {
   513| 			case 0:
   514| 				return &v.state
   515| 			case 1:
   516| 				return &v.sizeCache
   517| 			case 2:
   518| 				return &v.unknownFields
   519| 			default:
   520| 				return nil
   521| 			}
   522| 		}
   523| 		file_headscale_v1_apikey_proto_msgTypes[6].Exporter = func(v any, i int) any {
   524| 			switch v := v.(*ListApiKeysResponse); i {
   525| 			case 0:
   526| 				return &v.state
   527| 			case 1:
   528| 				return &v.sizeCache
   529| 			case 2:
   530| 				return &v.unknownFields
   531| 			default:
   532| 				return nil
   533| 			}
   534| 		}
   535| 		file_headscale_v1_apikey_proto_msgTypes[7].Exporter = func(v any, i int) any {
   536| 			switch v := v.(*DeleteApiKeyRequest); i {
   537| 			case 0:
   538| 				return &v.state
   539| 			case 1:
   540| 				return &v.sizeCache
   541| 			case 2:
   542| 				return &v.unknownFields
   543| 			default:
   544| 				return nil
   545| 			}
   546| 		}
   547| 		file_headscale_v1_apikey_proto_msgTypes[8].Exporter = func(v any, i int) any {
   548| 			switch v := v.(*DeleteApiKeyResponse); i {
   549| 			case 0:
   550| 				return &v.state
   551| 			case 1:
   552| 				return &v.sizeCache
   553| 			case 2:
   554| 				return &v.unknownFields
   555| 			default:
   556| 				return nil
   557| 			}
   558| 		}
   559| 	}
   560| 	type x struct{}
   561| 	out := protoimpl.TypeBuilder{
   562| 		File: protoimpl.DescBuilder{
   563| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   564| 			RawDescriptor: file_headscale_v1_apikey_proto_rawDesc,
   565| 			NumEnums:      0,
   566| 			NumMessages:   9,
   567| 			NumExtensions: 0,
   568| 			NumServices:   0,
   569| 		},
   570| 		GoTypes:           file_headscale_v1_apikey_proto_goTypes,
   571| 		DependencyIndexes: file_headscale_v1_apikey_proto_depIdxs,
   572| 		MessageInfos:      file_headscale_v1_apikey_proto_msgTypes,
   573| 	}.Build()
   574| 	File_headscale_v1_apikey_proto = out.File
   575| 	file_headscale_v1_apikey_proto_rawDesc = nil
   576| 	file_headscale_v1_apikey_proto_goTypes = nil
   577| 	file_headscale_v1_apikey_proto_depIdxs = nil
   578| }


# ====================================================================
# FILE: gen/go/headscale/v1/device.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 764-959 ---
   764| 	0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x52,
   765| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x11, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69,
   766| 	0x73, 0x65, 0x64, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,
   767| 	0x52, 0x10, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x52, 0x6f, 0x75, 0x74,
   768| 	0x65, 0x73, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
   769| 	0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   770| 	0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70,
   771| 	0x72, 0x6f, 0x74, 0x6f, 0x33,
   772| }
   773| var (
   774| 	file_headscale_v1_device_proto_rawDescOnce sync.Once
   775| 	file_headscale_v1_device_proto_rawDescData = file_headscale_v1_device_proto_rawDesc
   776| )
   777| func file_headscale_v1_device_proto_rawDescGZIP() []byte {
   778| 	file_headscale_v1_device_proto_rawDescOnce.Do(func() {
   779| 		file_headscale_v1_device_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_device_proto_rawDescData)
   780| 	})
   781| 	return file_headscale_v1_device_proto_rawDescData
   782| }
   783| var file_headscale_v1_device_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
   784| var file_headscale_v1_device_proto_goTypes = []any{
   785| 	(*Latency)(nil),                    // 0: headscale.v1.Latency
   786| 	(*ClientSupports)(nil),             // 1: headscale.v1.ClientSupports
   787| 	(*ClientConnectivity)(nil),         // 2: headscale.v1.ClientConnectivity
   788| 	(*GetDeviceRequest)(nil),           // 3: headscale.v1.GetDeviceRequest
   789| 	(*GetDeviceResponse)(nil),          // 4: headscale.v1.GetDeviceResponse
   790| 	(*DeleteDeviceRequest)(nil),        // 5: headscale.v1.DeleteDeviceRequest
   791| 	(*DeleteDeviceResponse)(nil),       // 6: headscale.v1.DeleteDeviceResponse
   792| 	(*GetDeviceRoutesRequest)(nil),     // 7: headscale.v1.GetDeviceRoutesRequest
   793| 	(*GetDeviceRoutesResponse)(nil),    // 8: headscale.v1.GetDeviceRoutesResponse
   794| 	(*EnableDeviceRoutesRequest)(nil),  // 9: headscale.v1.EnableDeviceRoutesRequest
   795| 	(*EnableDeviceRoutesResponse)(nil), // 10: headscale.v1.EnableDeviceRoutesResponse
   796| 	nil,                                // 11: headscale.v1.ClientConnectivity.LatencyEntry
   797| 	(*timestamppb.Timestamp)(nil),      // 12: google.protobuf.Timestamp
   798| }
   799| var file_headscale_v1_device_proto_depIdxs = []int32{
   800| 	11, // 0: headscale.v1.ClientConnectivity.latency:type_name -> headscale.v1.ClientConnectivity.LatencyEntry
   801| 	1,  // 1: headscale.v1.ClientConnectivity.client_supports:type_name -> headscale.v1.ClientSupports
   802| 	12, // 2: headscale.v1.GetDeviceResponse.created:type_name -> google.protobuf.Timestamp
   803| 	12, // 3: headscale.v1.GetDeviceResponse.last_seen:type_name -> google.protobuf.Timestamp
   804| 	12, // 4: headscale.v1.GetDeviceResponse.expires:type_name -> google.protobuf.Timestamp
   805| 	2,  // 5: headscale.v1.GetDeviceResponse.client_connectivity:type_name -> headscale.v1.ClientConnectivity
   806| 	0,  // 6: headscale.v1.ClientConnectivity.LatencyEntry.value:type_name -> headscale.v1.Latency
   807| 	7,  // [7:7] is the sub-list for method output_type
   808| 	7,  // [7:7] is the sub-list for method input_type
   809| 	7,  // [7:7] is the sub-list for extension type_name
   810| 	7,  // [7:7] is the sub-list for extension extendee
   811| 	0,  // [0:7] is the sub-list for field type_name
   812| }
   813| func init() { file_headscale_v1_device_proto_init() }
   814| func file_headscale_v1_device_proto_init() {
   815| 	if File_headscale_v1_device_proto != nil {
   816| 		return
   817| 	}
   818| 	if !protoimpl.UnsafeEnabled {
   819| 		file_headscale_v1_device_proto_msgTypes[0].Exporter = func(v any, i int) any {
   820| 			switch v := v.(*Latency); i {
   821| 			case 0:
   822| 				return &v.state
   823| 			case 1:
   824| 				return &v.sizeCache
   825| 			case 2:
   826| 				return &v.unknownFields
   827| 			default:
   828| 				return nil
   829| 			}
   830| 		}
   831| 		file_headscale_v1_device_proto_msgTypes[1].Exporter = func(v any, i int) any {
   832| 			switch v := v.(*ClientSupports); i {
   833| 			case 0:
   834| 				return &v.state
   835| 			case 1:
   836| 				return &v.sizeCache
   837| 			case 2:
   838| 				return &v.unknownFields
   839| 			default:
   840| 				return nil
   841| 			}
   842| 		}
   843| 		file_headscale_v1_device_proto_msgTypes[2].Exporter = func(v any, i int) any {
   844| 			switch v := v.(*ClientConnectivity); i {
   845| 			case 0:
   846| 				return &v.state
   847| 			case 1:
   848| 				return &v.sizeCache
   849| 			case 2:
   850| 				return &v.unknownFields
   851| 			default:
   852| 				return nil
   853| 			}
   854| 		}
   855| 		file_headscale_v1_device_proto_msgTypes[3].Exporter = func(v any, i int) any {
   856| 			switch v := v.(*GetDeviceRequest); i {
   857| 			case 0:
   858| 				return &v.state
   859| 			case 1:
   860| 				return &v.sizeCache
   861| 			case 2:
   862| 				return &v.unknownFields
   863| 			default:
   864| 				return nil
   865| 			}
   866| 		}
   867| 		file_headscale_v1_device_proto_msgTypes[4].Exporter = func(v any, i int) any {
   868| 			switch v := v.(*GetDeviceResponse); i {
   869| 			case 0:
   870| 				return &v.state
   871| 			case 1:
   872| 				return &v.sizeCache
   873| 			case 2:
   874| 				return &v.unknownFields
   875| 			default:
   876| 				return nil
   877| 			}
   878| 		}
   879| 		file_headscale_v1_device_proto_msgTypes[5].Exporter = func(v any, i int) any {
   880| 			switch v := v.(*DeleteDeviceRequest); i {
   881| 			case 0:
   882| 				return &v.state
   883| 			case 1:
   884| 				return &v.sizeCache
   885| 			case 2:
   886| 				return &v.unknownFields
   887| 			default:
   888| 				return nil
   889| 			}
   890| 		}
   891| 		file_headscale_v1_device_proto_msgTypes[6].Exporter = func(v any, i int) any {
   892| 			switch v := v.(*DeleteDeviceResponse); i {
   893| 			case 0:
   894| 				return &v.state
   895| 			case 1:
   896| 				return &v.sizeCache
   897| 			case 2:
   898| 				return &v.unknownFields
   899| 			default:
   900| 				return nil
   901| 			}
   902| 		}
   903| 		file_headscale_v1_device_proto_msgTypes[7].Exporter = func(v any, i int) any {
   904| 			switch v := v.(*GetDeviceRoutesRequest); i {
   905| 			case 0:
   906| 				return &v.state
   907| 			case 1:
   908| 				return &v.sizeCache
   909| 			case 2:
   910| 				return &v.unknownFields
   911| 			default:
   912| 				return nil
   913| 			}
   914| 		}
   915| 		file_headscale_v1_device_proto_msgTypes[8].Exporter = func(v any, i int) any {
   916| 			switch v := v.(*GetDeviceRoutesResponse); i {
   917| 			case 0:
   918| 				return &v.state
   919| 			case 1:
   920| 				return &v.sizeCache
   921| 			case 2:
   922| 				return &v.unknownFields
   923| 			default:
   924| 				return nil
   925| 			}
   926| 		}
   927| 		file_headscale_v1_device_proto_msgTypes[9].Exporter = func(v any, i int) any {
   928| 			switch v := v.(*EnableDeviceRoutesRequest); i {
   929| 			case 0:
   930| 				return &v.state
   931| 			case 1:
   932| 				return &v.sizeCache
   933| 			case 2:
   934| 				return &v.unknownFields
   935| 			default:
   936| 				return nil
   937| 			}
   938| 		}
   939| 		file_headscale_v1_device_proto_msgTypes[10].Exporter = func(v any, i int) any {
   940| 			switch v := v.(*EnableDeviceRoutesResponse); i {
   941| 			case 0:
   942| 				return &v.state
   943| 			case 1:
   944| 				return &v.sizeCache
   945| 			case 2:
   946| 				return &v.unknownFields
   947| 			default:
   948| 				return nil
   949| 			}
   950| 		}
   951| 	}
   952| 	type x struct{}
   953| 	out := protoimpl.TypeBuilder{
   954| 		File: protoimpl.DescBuilder{
   955| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   956| 			RawDescriptor: file_headscale_v1_device_proto_rawDesc,
   957| 			NumEnums:      0,
   958| 			NumMessages:   12,
   959| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/headscale.pb.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2-400 ---
     2| import (
     3| 	_ "google.golang.org/genproto/googleapis/api/annotations"
     4| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     5| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     6| 	reflect "reflect"
     7| )
     8| const (
     9| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    10| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    11| )
    12| var File_headscale_v1_headscale_proto protoreflect.FileDescriptor
    13| var file_headscale_v1_headscale_proto_rawDesc = []byte{
    14| 	0x0a, 0x1c, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x68,
    15| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c,
    16| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1c, 0x67, 0x6f,
    17| 	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74,
    18| 	0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61, 0x64,
    19| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72,
    20| 	0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76,
    21| 	0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f,
    22| 	0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31,
    23| 	0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x68, 0x65, 0x61,
    24| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73,
    25| 	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
    26| 	0x65, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74,
    27| 	0x6f, 0x1a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f,
    28| 	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x32, 0xcf, 0x1a, 0x0a,
    29| 	0x10, 0x48, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
    30| 	0x65, 0x12, 0x63, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1c, 0x2e, 0x68,
    31| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55,
    32| 	0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x68, 0x65, 0x61,
    33| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65,
    34| 	0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93, 0x02,
    35| 	0x15, 0x12, 0x13, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f,
    36| 	0x7b, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x68, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
    37| 	0x55, 0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
    38| 	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
    39| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
    40| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52,
    41| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x17, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x11, 0x3a,
    42| 	0x01, 0x2a, 0x22, 0x0c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72,
    43| 	0x12, 0x82, 0x01, 0x0a, 0x0a, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12,
    44| 	0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52,
    45| 	0x65, 0x6e, 0x61, 0x6d, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    46| 	0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
    47| 	0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    48| 	0x73, 0x65, 0x22, 0x31, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2b, 0x22, 0x29, 0x2f, 0x61, 0x70, 0x69,
    49| 	0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x6f, 0x6c, 0x64, 0x5f, 0x6e, 0x61,
    50| 	0x6d, 0x65, 0x7d, 0x2f, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x2f, 0x7b, 0x6e, 0x65, 0x77, 0x5f,
    51| 	0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x6c, 0x0a, 0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55,
    52| 	0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
    53| 	0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71,
    54| 	0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
    55| 	0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65,
    56| 	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x15, 0x2a, 0x13,
    57| 	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x6e, 0x61,
    58| 	0x6d, 0x65, 0x7d, 0x12, 0x62, 0x0a, 0x09, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73,
    59| 	0x12, 0x1e, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
    60| 	0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    61| 	0x1a, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
    62| 	0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    63| 	0x65, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e, 0x12, 0x0c, 0x2f, 0x61, 0x70, 0x69, 0x2f,
    64| 	0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x12, 0x80, 0x01, 0x0a, 0x10, 0x43, 0x72, 0x65, 0x61,
    65| 	0x74, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x12, 0x25, 0x2e, 0x68,
    66| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61,
    67| 	0x74, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75,
    68| 	0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
    69| 	0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68,
    70| 	0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1d, 0x82, 0xd3, 0xe4,
    71| 	0x93, 0x02, 0x17, 0x3a, 0x01, 0x2a, 0x22, 0x12, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
    72| 	0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x12, 0x87, 0x01, 0x0a, 0x10, 0x45,
    73| 	0x78, 0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x12,
    74| 	0x25, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45,
    75| 	0x78, 0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52,
    76| 	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
    77| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65, 0x41,
    78| 	0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x24,
    79| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1e, 0x3a, 0x01, 0x2a, 0x22, 0x19, 0x2f, 0x61, 0x70, 0x69, 0x2f,
    80| 	0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x2f, 0x65, 0x78,
    81| 	0x70, 0x69, 0x72, 0x65, 0x12, 0x7a, 0x0a, 0x0f, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x72, 0x65, 0x41,
    82| 	0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x24, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
    83| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x72, 0x65, 0x41, 0x75,
    84| 	0x74, 0x68, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e,
    85| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73,
    86| 	0x74, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73, 0x70,
    87| 	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1a, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x14, 0x12, 0x12, 0x2f, 0x61,
    88| 	0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79,
    89| 	0x12, 0x7d, 0x0a, 0x0f, 0x44, 0x65, 0x62, 0x75, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e,
    90| 	0x6f, 0x64, 0x65, 0x12, 0x24, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
    91| 	0x76, 0x31, 0x2e, 0x44, 0x65, 0x62, 0x75, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f,
    92| 	0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x68, 0x65, 0x61, 0x64,
    93| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x62, 0x75, 0x67, 0x43, 0x72,
    94| 	0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    95| 	0x22, 0x1d, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x17, 0x3a, 0x01, 0x2a, 0x22, 0x12, 0x2f, 0x61, 0x70,
    96| 	0x69, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x12,
    97| 	0x66, 0x0a, 0x07, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1c, 0x2e, 0x68, 0x65, 0x61,
    98| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64,
    99| 	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
   100| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x52,
   101| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1e, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x18, 0x12,
   102| 	0x16, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b, 0x6e,
   103| 	0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x12, 0x6e, 0x0a, 0x07, 0x53, 0x65, 0x74, 0x54, 0x61,
   104| 	0x67, 0x73, 0x12, 0x1c, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   105| 	0x31, 0x2e, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
   106| 	0x1a, 0x1d, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
   107| 	0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   108| 	0x26, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x20, 0x3a, 0x01, 0x2a, 0x22, 0x1b, 0x2f, 0x61, 0x70, 0x69,
   109| 	0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69,
   110| 	0x64, 0x7d, 0x2f, 0x74, 0x61, 0x67, 0x73, 0x12, 0x74, 0x0a, 0x0c, 0x52, 0x65, 0x67, 0x69, 0x73,
   111| 	0x74, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   112| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4e,
   113| 	0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61,
   114| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74,
   115| 	0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1d,
   116| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x17, 0x22, 0x15, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
   117| 	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x12, 0x6f, 0x0a,
   118| 	0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1f, 0x2e, 0x68, 0x65,
   119| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74,
   120| 	0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68,
   121| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65,
   122| 	0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1e,
   123| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x18, 0x2a, 0x16, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
   124| 	0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x12, 0x76,
   125| 	0x0a, 0x0a, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1f, 0x2e, 0x68,
   126| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69,
   127| 	0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e,
   128| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70,
   129| 	0x69, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   130| 	0x25, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1f, 0x22, 0x1d, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31,
   131| 	0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f,
   132| 	0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x81, 0x01, 0x0a, 0x0a, 0x52, 0x65, 0x6e, 0x61, 0x6d,
   133| 	0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   134| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52,
   135| 	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   136| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4e, 0x6f, 0x64, 0x65,
   137| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x30, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x2a,
   138| 	0x22, 0x28, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b,
   139| 	0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x2f,
   140| 	0x7b, 0x6e, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x62, 0x0a, 0x09, 0x4c, 0x69,
   141| 	0x73, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x12, 0x1e, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   142| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73,
   143| 	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   144| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73,
   145| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x0e,
   146| 	0x12, 0x0c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x12, 0x6e,
   147| 	0x0a, 0x08, 0x4d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x1d, 0x2e, 0x68, 0x65, 0x61,
   148| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x76, 0x65, 0x4e, 0x6f,
   149| 	0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1e, 0x2e, 0x68, 0x65, 0x61, 0x64,
   150| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x64,
   151| 	0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x23, 0x82, 0xd3, 0xe4, 0x93, 0x02,
   152| 	0x1d, 0x22, 0x1b, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f,
   153| 	0x7b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x12, 0x80,
   154| 	0x01, 0x0a, 0x0f, 0x42, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c, 0x6c, 0x4e, 0x6f, 0x64, 0x65, 0x49,
   155| 	0x50, 0x73, 0x12, 0x24, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   156| 	0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c, 0x6c, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x50,
   157| 	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
   158| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x42, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c, 0x6c,
   159| 	0x4e, 0x6f, 0x64, 0x65, 0x49, 0x50, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   160| 	0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1a, 0x22, 0x18, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31,
   161| 	0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x62, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c, 0x6c, 0x69, 0x70,
   162| 	0x73, 0x12, 0x64, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x1e,
   163| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65,
   164| 	0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f,
   165| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65,
   166| 	0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   167| 	0x16, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31,
   168| 	0x2f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x7c, 0x0a, 0x0b, 0x45, 0x6e, 0x61, 0x62, 0x6c,
   169| 	0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   170| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74,
   171| 	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
   172| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f,
   173| 	0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x28, 0x82, 0xd3, 0xe4,
   174| 	0x93, 0x02, 0x22, 0x22, 0x20, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75,
   175| 	0x74, 0x65, 0x73, 0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x65,
   176| 	0x6e, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x80, 0x01, 0x0a, 0x0c, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c,
   177| 	0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   178| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75,
   179| 	0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64,
   180| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,
   181| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x29, 0x82,
   182| 	0xd3, 0xe4, 0x93, 0x02, 0x23, 0x22, 0x21, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72,
   183| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d,
   184| 	0x2f, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x7f, 0x0a, 0x0d, 0x47, 0x65, 0x74, 0x4e,
   185| 	0x6f, 0x64, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64,
   186| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65,
   187| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e,
   188| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74,
   189| 	0x4e, 0x6f, 0x64, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
   190| 	0x73, 0x65, 0x22, 0x25, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1f, 0x12, 0x1d, 0x2f, 0x61, 0x70, 0x69,
   191| 	0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2f, 0x7b, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69,
   192| 	0x64, 0x7d, 0x2f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x75, 0x0a, 0x0b, 0x44, 0x65, 0x6c,
   193| 	0x65, 0x74, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
   194| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f,
   195| 	0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61,
   196| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
   197| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x21, 0x82,
   198| 	0xd3, 0xe4, 0x93, 0x02, 0x1b, 0x2a, 0x19, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72,
   199| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d,
   200| 	0x12, 0x70, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79,
   201| 	0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
   202| 	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75,
   203| 	0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
   204| 	0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52,
   205| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x3a,
   206| 	0x01, 0x2a, 0x22, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x6b,
   207| 	0x65, 0x79, 0x12, 0x77, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b,
   208| 	0x65, 0x79, 0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   209| 	0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65,
   210| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   211| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65,
   212| 	0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02,
   213| 	0x1a, 0x3a, 0x01, 0x2a, 0x22, 0x15, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70,
   214| 	0x69, 0x6b, 0x65, 0x79, 0x2f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x6a, 0x0a, 0x0b, 0x4c,
   215| 	0x69, 0x73, 0x74, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61,
   216| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x70,
   217| 	0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68,
   218| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74,
   219| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   220| 	0x16, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31,
   221| 	0x2f, 0x61, 0x70, 0x69, 0x6b, 0x65, 0x79, 0x12, 0x76, 0x0a, 0x0c, 0x44, 0x65, 0x6c, 0x65, 0x74,
   222| 	0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   223| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x41, 0x70, 0x69,
   224| 	0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61,
   225| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
   226| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1f,
   227| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x19, 0x2a, 0x17, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
   228| 	0x61, 0x70, 0x69, 0x6b, 0x65, 0x79, 0x2f, 0x7b, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x7d, 0x12,
   229| 	0x64, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x1e, 0x2e, 0x68,
   230| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x50,
   231| 	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x68,
   232| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x50,
   233| 	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x16, 0x82,
   234| 	0xd3, 0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70,
   235| 	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x67, 0x0a, 0x09, 0x53, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69,
   236| 	0x63, 0x79, 0x12, 0x1e, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   237| 	0x31, 0x2e, 0x53, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
   238| 	0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   239| 	0x31, 0x2e, 0x53, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
   240| 	0x6e, 0x73, 0x65, 0x22, 0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x3a, 0x01, 0x2a, 0x1a, 0x0e,
   241| 	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x42, 0x29,
   242| 	0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61,
   243| 	0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f,
   244| 	0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
   245| 	0x33,
   246| }
   247| var file_headscale_v1_headscale_proto_goTypes = []any{
   248| 	(*GetUserRequest)(nil),           // 0: headscale.v1.GetUserRequest
   249| 	(*CreateUserRequest)(nil),        // 1: headscale.v1.CreateUserRequest
   250| 	(*RenameUserRequest)(nil),        // 2: headscale.v1.RenameUserRequest
   251| 	(*DeleteUserRequest)(nil),        // 3: headscale.v1.DeleteUserRequest
   252| 	(*ListUsersRequest)(nil),         // 4: headscale.v1.ListUsersRequest
   253| 	(*CreatePreAuthKeyRequest)(nil),  // 5: headscale.v1.CreatePreAuthKeyRequest
   254| 	(*ExpirePreAuthKeyRequest)(nil),  // 6: headscale.v1.ExpirePreAuthKeyRequest
   255| 	(*ListPreAuthKeysRequest)(nil),   // 7: headscale.v1.ListPreAuthKeysRequest
   256| 	(*DebugCreateNodeRequest)(nil),   // 8: headscale.v1.DebugCreateNodeRequest
   257| 	(*GetNodeRequest)(nil),           // 9: headscale.v1.GetNodeRequest
   258| 	(*SetTagsRequest)(nil),           // 10: headscale.v1.SetTagsRequest
   259| 	(*RegisterNodeRequest)(nil),      // 11: headscale.v1.RegisterNodeRequest
   260| 	(*DeleteNodeRequest)(nil),        // 12: headscale.v1.DeleteNodeRequest
   261| 	(*ExpireNodeRequest)(nil),        // 13: headscale.v1.ExpireNodeRequest
   262| 	(*RenameNodeRequest)(nil),        // 14: headscale.v1.RenameNodeRequest
   263| 	(*ListNodesRequest)(nil),         // 15: headscale.v1.ListNodesRequest
   264| 	(*MoveNodeRequest)(nil),          // 16: headscale.v1.MoveNodeRequest
   265| 	(*BackfillNodeIPsRequest)(nil),   // 17: headscale.v1.BackfillNodeIPsRequest
   266| 	(*GetRoutesRequest)(nil),         // 18: headscale.v1.GetRoutesRequest
   267| 	(*EnableRouteRequest)(nil),       // 19: headscale.v1.EnableRouteRequest
   268| 	(*DisableRouteRequest)(nil),      // 20: headscale.v1.DisableRouteRequest
   269| 	(*GetNodeRoutesRequest)(nil),     // 21: headscale.v1.GetNodeRoutesRequest
   270| 	(*DeleteRouteRequest)(nil),       // 22: headscale.v1.DeleteRouteRequest
   271| 	(*CreateApiKeyRequest)(nil),      // 23: headscale.v1.CreateApiKeyRequest
   272| 	(*ExpireApiKeyRequest)(nil),      // 24: headscale.v1.ExpireApiKeyRequest
   273| 	(*ListApiKeysRequest)(nil),       // 25: headscale.v1.ListApiKeysRequest
   274| 	(*DeleteApiKeyRequest)(nil),      // 26: headscale.v1.DeleteApiKeyRequest
   275| 	(*GetPolicyRequest)(nil),         // 27: headscale.v1.GetPolicyRequest
   276| 	(*SetPolicyRequest)(nil),         // 28: headscale.v1.SetPolicyRequest
   277| 	(*GetUserResponse)(nil),          // 29: headscale.v1.GetUserResponse
   278| 	(*CreateUserResponse)(nil),       // 30: headscale.v1.CreateUserResponse
   279| 	(*RenameUserResponse)(nil),       // 31: headscale.v1.RenameUserResponse
   280| 	(*DeleteUserResponse)(nil),       // 32: headscale.v1.DeleteUserResponse
   281| 	(*ListUsersResponse)(nil),        // 33: headscale.v1.ListUsersResponse
   282| 	(*CreatePreAuthKeyResponse)(nil), // 34: headscale.v1.CreatePreAuthKeyResponse
   283| 	(*ExpirePreAuthKeyResponse)(nil), // 35: headscale.v1.ExpirePreAuthKeyResponse
   284| 	(*ListPreAuthKeysResponse)(nil),  // 36: headscale.v1.ListPreAuthKeysResponse
   285| 	(*DebugCreateNodeResponse)(nil),  // 37: headscale.v1.DebugCreateNodeResponse
   286| 	(*GetNodeResponse)(nil),          // 38: headscale.v1.GetNodeResponse
   287| 	(*SetTagsResponse)(nil),          // 39: headscale.v1.SetTagsResponse
   288| 	(*RegisterNodeResponse)(nil),     // 40: headscale.v1.RegisterNodeResponse
   289| 	(*DeleteNodeResponse)(nil),       // 41: headscale.v1.DeleteNodeResponse
   290| 	(*ExpireNodeResponse)(nil),       // 42: headscale.v1.ExpireNodeResponse
   291| 	(*RenameNodeResponse)(nil),       // 43: headscale.v1.RenameNodeResponse
   292| 	(*ListNodesResponse)(nil),        // 44: headscale.v1.ListNodesResponse
   293| 	(*MoveNodeResponse)(nil),         // 45: headscale.v1.MoveNodeResponse
   294| 	(*BackfillNodeIPsResponse)(nil),  // 46: headscale.v1.BackfillNodeIPsResponse
   295| 	(*GetRoutesResponse)(nil),        // 47: headscale.v1.GetRoutesResponse
   296| 	(*EnableRouteResponse)(nil),      // 48: headscale.v1.EnableRouteResponse
   297| 	(*DisableRouteResponse)(nil),     // 49: headscale.v1.DisableRouteResponse
   298| 	(*GetNodeRoutesResponse)(nil),    // 50: headscale.v1.GetNodeRoutesResponse
   299| 	(*DeleteRouteResponse)(nil),      // 51: headscale.v1.DeleteRouteResponse
   300| 	(*CreateApiKeyResponse)(nil),     // 52: headscale.v1.CreateApiKeyResponse
   301| 	(*ExpireApiKeyResponse)(nil),     // 53: headscale.v1.ExpireApiKeyResponse
   302| 	(*ListApiKeysResponse)(nil),      // 54: headscale.v1.ListApiKeysResponse
   303| 	(*DeleteApiKeyResponse)(nil),     // 55: headscale.v1.DeleteApiKeyResponse
   304| 	(*GetPolicyResponse)(nil),        // 56: headscale.v1.GetPolicyResponse
   305| 	(*SetPolicyResponse)(nil),        // 57: headscale.v1.SetPolicyResponse
   306| }
   307| var file_headscale_v1_headscale_proto_depIdxs = []int32{
   308| 	0,  // 0: headscale.v1.HeadscaleService.GetUser:input_type -> headscale.v1.GetUserRequest
   309| 	1,  // 1: headscale.v1.HeadscaleService.CreateUser:input_type -> headscale.v1.CreateUserRequest
   310| 	2,  // 2: headscale.v1.HeadscaleService.RenameUser:input_type -> headscale.v1.RenameUserRequest
   311| 	3,  // 3: headscale.v1.HeadscaleService.DeleteUser:input_type -> headscale.v1.DeleteUserRequest
   312| 	4,  // 4: headscale.v1.HeadscaleService.ListUsers:input_type -> headscale.v1.ListUsersRequest
   313| 	5,  // 5: headscale.v1.HeadscaleService.CreatePreAuthKey:input_type -> headscale.v1.CreatePreAuthKeyRequest
   314| 	6,  // 6: headscale.v1.HeadscaleService.ExpirePreAuthKey:input_type -> headscale.v1.ExpirePreAuthKeyRequest
   315| 	7,  // 7: headscale.v1.HeadscaleService.ListPreAuthKeys:input_type -> headscale.v1.ListPreAuthKeysRequest
   316| 	8,  // 8: headscale.v1.HeadscaleService.DebugCreateNode:input_type -> headscale.v1.DebugCreateNodeRequest
   317| 	9,  // 9: headscale.v1.HeadscaleService.GetNode:input_type -> headscale.v1.GetNodeRequest
   318| 	10, // 10: headscale.v1.HeadscaleService.SetTags:input_type -> headscale.v1.SetTagsRequest
   319| 	11, // 11: headscale.v1.HeadscaleService.RegisterNode:input_type -> headscale.v1.RegisterNodeRequest
   320| 	12, // 12: headscale.v1.HeadscaleService.DeleteNode:input_type -> headscale.v1.DeleteNodeRequest
   321| 	13, // 13: headscale.v1.HeadscaleService.ExpireNode:input_type -> headscale.v1.ExpireNodeRequest
   322| 	14, // 14: headscale.v1.HeadscaleService.RenameNode:input_type -> headscale.v1.RenameNodeRequest
   323| 	15, // 15: headscale.v1.HeadscaleService.ListNodes:input_type -> headscale.v1.ListNodesRequest
   324| 	16, // 16: headscale.v1.HeadscaleService.MoveNode:input_type -> headscale.v1.MoveNodeRequest
   325| 	17, // 17: headscale.v1.HeadscaleService.BackfillNodeIPs:input_type -> headscale.v1.BackfillNodeIPsRequest
   326| 	18, // 18: headscale.v1.HeadscaleService.GetRoutes:input_type -> headscale.v1.GetRoutesRequest
   327| 	19, // 19: headscale.v1.HeadscaleService.EnableRoute:input_type -> headscale.v1.EnableRouteRequest
   328| 	20, // 20: headscale.v1.HeadscaleService.DisableRoute:input_type -> headscale.v1.DisableRouteRequest
   329| 	21, // 21: headscale.v1.HeadscaleService.GetNodeRoutes:input_type -> headscale.v1.GetNodeRoutesRequest
   330| 	22, // 22: headscale.v1.HeadscaleService.DeleteRoute:input_type -> headscale.v1.DeleteRouteRequest
   331| 	23, // 23: headscale.v1.HeadscaleService.CreateApiKey:input_type -> headscale.v1.CreateApiKeyRequest
   332| 	24, // 24: headscale.v1.HeadscaleService.ExpireApiKey:input_type -> headscale.v1.ExpireApiKeyRequest
   333| 	25, // 25: headscale.v1.HeadscaleService.ListApiKeys:input_type -> headscale.v1.ListApiKeysRequest
   334| 	26, // 26: headscale.v1.HeadscaleService.DeleteApiKey:input_type -> headscale.v1.DeleteApiKeyRequest
   335| 	27, // 27: headscale.v1.HeadscaleService.GetPolicy:input_type -> headscale.v1.GetPolicyRequest
   336| 	28, // 28: headscale.v1.HeadscaleService.SetPolicy:input_type -> headscale.v1.SetPolicyRequest
   337| 	29, // 29: headscale.v1.HeadscaleService.GetUser:output_type -> headscale.v1.GetUserResponse
   338| 	30, // 30: headscale.v1.HeadscaleService.CreateUser:output_type -> headscale.v1.CreateUserResponse
   339| 	31, // 31: headscale.v1.HeadscaleService.RenameUser:output_type -> headscale.v1.RenameUserResponse
   340| 	32, // 32: headscale.v1.HeadscaleService.DeleteUser:output_type -> headscale.v1.DeleteUserResponse
   341| 	33, // 33: headscale.v1.HeadscaleService.ListUsers:output_type -> headscale.v1.ListUsersResponse
   342| 	34, // 34: headscale.v1.HeadscaleService.CreatePreAuthKey:output_type -> headscale.v1.CreatePreAuthKeyResponse
   343| 	35, // 35: headscale.v1.HeadscaleService.ExpirePreAuthKey:output_type -> headscale.v1.ExpirePreAuthKeyResponse
   344| 	36, // 36: headscale.v1.HeadscaleService.ListPreAuthKeys:output_type -> headscale.v1.ListPreAuthKeysResponse
   345| 	37, // 37: headscale.v1.HeadscaleService.DebugCreateNode:output_type -> headscale.v1.DebugCreateNodeResponse
   346| 	38, // 38: headscale.v1.HeadscaleService.GetNode:output_type -> headscale.v1.GetNodeResponse
   347| 	39, // 39: headscale.v1.HeadscaleService.SetTags:output_type -> headscale.v1.SetTagsResponse
   348| 	40, // 40: headscale.v1.HeadscaleService.RegisterNode:output_type -> headscale.v1.RegisterNodeResponse
   349| 	41, // 41: headscale.v1.HeadscaleService.DeleteNode:output_type -> headscale.v1.DeleteNodeResponse
   350| 	42, // 42: headscale.v1.HeadscaleService.ExpireNode:output_type -> headscale.v1.ExpireNodeResponse
   351| 	43, // 43: headscale.v1.HeadscaleService.RenameNode:output_type -> headscale.v1.RenameNodeResponse
   352| 	44, // 44: headscale.v1.HeadscaleService.ListNodes:output_type -> headscale.v1.ListNodesResponse
   353| 	45, // 45: headscale.v1.HeadscaleService.MoveNode:output_type -> headscale.v1.MoveNodeResponse
   354| 	46, // 46: headscale.v1.HeadscaleService.BackfillNodeIPs:output_type -> headscale.v1.BackfillNodeIPsResponse
   355| 	47, // 47: headscale.v1.HeadscaleService.GetRoutes:output_type -> headscale.v1.GetRoutesResponse
   356| 	48, // 48: headscale.v1.HeadscaleService.EnableRoute:output_type -> headscale.v1.EnableRouteResponse
   357| 	49, // 49: headscale.v1.HeadscaleService.DisableRoute:output_type -> headscale.v1.DisableRouteResponse
   358| 	50, // 50: headscale.v1.HeadscaleService.GetNodeRoutes:output_type -> headscale.v1.GetNodeRoutesResponse
   359| 	51, // 51: headscale.v1.HeadscaleService.DeleteRoute:output_type -> headscale.v1.DeleteRouteResponse
   360| 	52, // 52: headscale.v1.HeadscaleService.CreateApiKey:output_type -> headscale.v1.CreateApiKeyResponse
   361| 	53, // 53: headscale.v1.HeadscaleService.ExpireApiKey:output_type -> headscale.v1.ExpireApiKeyResponse
   362| 	54, // 54: headscale.v1.HeadscaleService.ListApiKeys:output_type -> headscale.v1.ListApiKeysResponse
   363| 	55, // 55: headscale.v1.HeadscaleService.DeleteApiKey:output_type -> headscale.v1.DeleteApiKeyResponse
   364| 	56, // 56: headscale.v1.HeadscaleService.GetPolicy:output_type -> headscale.v1.GetPolicyResponse
   365| 	57, // 57: headscale.v1.HeadscaleService.SetPolicy:output_type -> headscale.v1.SetPolicyResponse
   366| 	29, // [29:58] is the sub-list for method output_type
   367| 	0,  // [0:29] is the sub-list for method input_type
   368| 	0,  // [0:0] is the sub-list for extension type_name
   369| 	0,  // [0:0] is the sub-list for extension extendee
   370| 	0,  // [0:0] is the sub-list for field type_name
   371| }
   372| func init() { file_headscale_v1_headscale_proto_init() }
   373| func file_headscale_v1_headscale_proto_init() {
   374| 	if File_headscale_v1_headscale_proto != nil {
   375| 		return
   376| 	}
   377| 	file_headscale_v1_user_proto_init()
   378| 	file_headscale_v1_preauthkey_proto_init()
   379| 	file_headscale_v1_node_proto_init()
   380| 	file_headscale_v1_routes_proto_init()
   381| 	file_headscale_v1_apikey_proto_init()
   382| 	file_headscale_v1_policy_proto_init()
   383| 	type x struct{}
   384| 	out := protoimpl.TypeBuilder{
   385| 		File: protoimpl.DescBuilder{
   386| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   387| 			RawDescriptor: file_headscale_v1_headscale_proto_rawDesc,
   388| 			NumEnums:      0,
   389| 			NumMessages:   0,
   390| 			NumExtensions: 0,
   391| 			NumServices:   1,
   392| 		},
   393| 		GoTypes:           file_headscale_v1_headscale_proto_goTypes,
   394| 		DependencyIndexes: file_headscale_v1_headscale_proto_depIdxs,
   395| 	}.Build()
   396| 	File_headscale_v1_headscale_proto = out.File
   397| 	file_headscale_v1_headscale_proto_rawDesc = nil
   398| 	file_headscale_v1_headscale_proto_goTypes = nil
   399| 	file_headscale_v1_headscale_proto_depIdxs = nil
   400| }


# ====================================================================
# FILE: gen/go/headscale/v1/headscale.pb.gw.go
# Total hunks: 11
# ====================================================================
# --- HUNK 1: Lines 48-97 ---
    48| 	var (
    49| 		val string
    50| 		ok  bool
    51| 		err error
    52| 		_   = err
    53| 	)
    54| 	val, ok = pathParams["name"]
    55| 	if !ok {
    56| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
    57| 	}
    58| 	protoReq.Name, err = runtime.String(val)
    59| 	if err != nil {
    60| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
    61| 	}
    62| 	msg, err := server.GetUser(ctx, &protoReq)
    63| 	return msg, metadata, err
    64| }
    65| func request_HeadscaleService_CreateUser_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    66| 	var protoReq CreateUserRequest
    67| 	var metadata runtime.ServerMetadata
    68| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
    69| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
    70| 	}
    71| 	msg, err := client.CreateUser(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
    72| 	return msg, metadata, err
    73| }
    74| func local_request_HeadscaleService_CreateUser_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    75| 	var protoReq CreateUserRequest
    76| 	var metadata runtime.ServerMetadata
    77| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
    78| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
    79| 	}
    80| 	msg, err := server.CreateUser(ctx, &protoReq)
    81| 	return msg, metadata, err
    82| }
    83| func request_HeadscaleService_RenameUser_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    84| 	var protoReq RenameUserRequest
    85| 	var metadata runtime.ServerMetadata
    86| 	var (
    87| 		val string
    88| 		ok  bool
    89| 		err error
    90| 		_   = err
    91| 	)
    92| 	val, ok = pathParams["old_name"]
    93| 	if !ok {
    94| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "old_name")
    95| 	}
    96| 	protoReq.OldName, err = runtime.String(val)
    97| 	if err != nil {

# --- HUNK 2: Lines 174-647 ---
   174| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
   175| 	}
   176| 	msg, err := server.DeleteUser(ctx, &protoReq)
   177| 	return msg, metadata, err
   178| }
   179| func request_HeadscaleService_ListUsers_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   180| 	var protoReq ListUsersRequest
   181| 	var metadata runtime.ServerMetadata
   182| 	msg, err := client.ListUsers(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   183| 	return msg, metadata, err
   184| }
   185| func local_request_HeadscaleService_ListUsers_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   186| 	var protoReq ListUsersRequest
   187| 	var metadata runtime.ServerMetadata
   188| 	msg, err := server.ListUsers(ctx, &protoReq)
   189| 	return msg, metadata, err
   190| }
   191| func request_HeadscaleService_CreatePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   192| 	var protoReq CreatePreAuthKeyRequest
   193| 	var metadata runtime.ServerMetadata
   194| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   195| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   196| 	}
   197| 	msg, err := client.CreatePreAuthKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   198| 	return msg, metadata, err
   199| }
   200| func local_request_HeadscaleService_CreatePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   201| 	var protoReq CreatePreAuthKeyRequest
   202| 	var metadata runtime.ServerMetadata
   203| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   204| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   205| 	}
   206| 	msg, err := server.CreatePreAuthKey(ctx, &protoReq)
   207| 	return msg, metadata, err
   208| }
   209| func request_HeadscaleService_ExpirePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   210| 	var protoReq ExpirePreAuthKeyRequest
   211| 	var metadata runtime.ServerMetadata
   212| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   213| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   214| 	}
   215| 	msg, err := client.ExpirePreAuthKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   216| 	return msg, metadata, err
   217| }
   218| func local_request_HeadscaleService_ExpirePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   219| 	var protoReq ExpirePreAuthKeyRequest
   220| 	var metadata runtime.ServerMetadata
   221| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   222| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   223| 	}
   224| 	msg, err := server.ExpirePreAuthKey(ctx, &protoReq)
   225| 	return msg, metadata, err
   226| }
   227| var (
   228| 	filter_HeadscaleService_ListPreAuthKeys_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   229| )
   230| func request_HeadscaleService_ListPreAuthKeys_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   231| 	var protoReq ListPreAuthKeysRequest
   232| 	var metadata runtime.ServerMetadata
   233| 	if err := req.ParseForm(); err != nil {
   234| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   235| 	}
   236| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListPreAuthKeys_0); err != nil {
   237| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   238| 	}
   239| 	msg, err := client.ListPreAuthKeys(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   240| 	return msg, metadata, err
   241| }
   242| func local_request_HeadscaleService_ListPreAuthKeys_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   243| 	var protoReq ListPreAuthKeysRequest
   244| 	var metadata runtime.ServerMetadata
   245| 	if err := req.ParseForm(); err != nil {
   246| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   247| 	}
   248| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListPreAuthKeys_0); err != nil {
   249| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   250| 	}
   251| 	msg, err := server.ListPreAuthKeys(ctx, &protoReq)
   252| 	return msg, metadata, err
   253| }
   254| func request_HeadscaleService_DebugCreateNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   255| 	var protoReq DebugCreateNodeRequest
   256| 	var metadata runtime.ServerMetadata
   257| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   258| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   259| 	}
   260| 	msg, err := client.DebugCreateNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   261| 	return msg, metadata, err
   262| }
   263| func local_request_HeadscaleService_DebugCreateNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   264| 	var protoReq DebugCreateNodeRequest
   265| 	var metadata runtime.ServerMetadata
   266| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   267| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   268| 	}
   269| 	msg, err := server.DebugCreateNode(ctx, &protoReq)
   270| 	return msg, metadata, err
   271| }
   272| func request_HeadscaleService_GetNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   273| 	var protoReq GetNodeRequest
   274| 	var metadata runtime.ServerMetadata
   275| 	var (
   276| 		val string
   277| 		ok  bool
   278| 		err error
   279| 		_   = err
   280| 	)
   281| 	val, ok = pathParams["node_id"]
   282| 	if !ok {
   283| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   284| 	}
   285| 	protoReq.NodeId, err = runtime.Uint64(val)
   286| 	if err != nil {
   287| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   288| 	}
   289| 	msg, err := client.GetNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   290| 	return msg, metadata, err
   291| }
   292| func local_request_HeadscaleService_GetNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   293| 	var protoReq GetNodeRequest
   294| 	var metadata runtime.ServerMetadata
   295| 	var (
   296| 		val string
   297| 		ok  bool
   298| 		err error
   299| 		_   = err
   300| 	)
   301| 	val, ok = pathParams["node_id"]
   302| 	if !ok {
   303| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   304| 	}
   305| 	protoReq.NodeId, err = runtime.Uint64(val)
   306| 	if err != nil {
   307| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   308| 	}
   309| 	msg, err := server.GetNode(ctx, &protoReq)
   310| 	return msg, metadata, err
   311| }
   312| func request_HeadscaleService_SetTags_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   313| 	var protoReq SetTagsRequest
   314| 	var metadata runtime.ServerMetadata
   315| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   316| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   317| 	}
   318| 	var (
   319| 		val string
   320| 		ok  bool
   321| 		err error
   322| 		_   = err
   323| 	)
   324| 	val, ok = pathParams["node_id"]
   325| 	if !ok {
   326| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   327| 	}
   328| 	protoReq.NodeId, err = runtime.Uint64(val)
   329| 	if err != nil {
   330| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   331| 	}
   332| 	msg, err := client.SetTags(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   333| 	return msg, metadata, err
   334| }
   335| func local_request_HeadscaleService_SetTags_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   336| 	var protoReq SetTagsRequest
   337| 	var metadata runtime.ServerMetadata
   338| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   339| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   340| 	}
   341| 	var (
   342| 		val string
   343| 		ok  bool
   344| 		err error
   345| 		_   = err
   346| 	)
   347| 	val, ok = pathParams["node_id"]
   348| 	if !ok {
   349| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   350| 	}
   351| 	protoReq.NodeId, err = runtime.Uint64(val)
   352| 	if err != nil {
   353| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   354| 	}
   355| 	msg, err := server.SetTags(ctx, &protoReq)
   356| 	return msg, metadata, err
   357| }
   358| var (
   359| 	filter_HeadscaleService_RegisterNode_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   360| )
   361| func request_HeadscaleService_RegisterNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   362| 	var protoReq RegisterNodeRequest
   363| 	var metadata runtime.ServerMetadata
   364| 	if err := req.ParseForm(); err != nil {
   365| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   366| 	}
   367| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_RegisterNode_0); err != nil {
   368| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   369| 	}
   370| 	msg, err := client.RegisterNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   371| 	return msg, metadata, err
   372| }
   373| func local_request_HeadscaleService_RegisterNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   374| 	var protoReq RegisterNodeRequest
   375| 	var metadata runtime.ServerMetadata
   376| 	if err := req.ParseForm(); err != nil {
   377| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   378| 	}
   379| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_RegisterNode_0); err != nil {
   380| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   381| 	}
   382| 	msg, err := server.RegisterNode(ctx, &protoReq)
   383| 	return msg, metadata, err
   384| }
   385| func request_HeadscaleService_DeleteNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   386| 	var protoReq DeleteNodeRequest
   387| 	var metadata runtime.ServerMetadata
   388| 	var (
   389| 		val string
   390| 		ok  bool
   391| 		err error
   392| 		_   = err
   393| 	)
   394| 	val, ok = pathParams["node_id"]
   395| 	if !ok {
   396| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   397| 	}
   398| 	protoReq.NodeId, err = runtime.Uint64(val)
   399| 	if err != nil {
   400| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   401| 	}
   402| 	msg, err := client.DeleteNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   403| 	return msg, metadata, err
   404| }
   405| func local_request_HeadscaleService_DeleteNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   406| 	var protoReq DeleteNodeRequest
   407| 	var metadata runtime.ServerMetadata
   408| 	var (
   409| 		val string
   410| 		ok  bool
   411| 		err error
   412| 		_   = err
   413| 	)
   414| 	val, ok = pathParams["node_id"]
   415| 	if !ok {
   416| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   417| 	}
   418| 	protoReq.NodeId, err = runtime.Uint64(val)
   419| 	if err != nil {
   420| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   421| 	}
   422| 	msg, err := server.DeleteNode(ctx, &protoReq)
   423| 	return msg, metadata, err
   424| }
   425| func request_HeadscaleService_ExpireNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   426| 	var protoReq ExpireNodeRequest
   427| 	var metadata runtime.ServerMetadata
   428| 	var (
   429| 		val string
   430| 		ok  bool
   431| 		err error
   432| 		_   = err
   433| 	)
   434| 	val, ok = pathParams["node_id"]
   435| 	if !ok {
   436| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   437| 	}
   438| 	protoReq.NodeId, err = runtime.Uint64(val)
   439| 	if err != nil {
   440| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   441| 	}
   442| 	msg, err := client.ExpireNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   443| 	return msg, metadata, err
   444| }
   445| func local_request_HeadscaleService_ExpireNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   446| 	var protoReq ExpireNodeRequest
   447| 	var metadata runtime.ServerMetadata
   448| 	var (
   449| 		val string
   450| 		ok  bool
   451| 		err error
   452| 		_   = err
   453| 	)
   454| 	val, ok = pathParams["node_id"]
   455| 	if !ok {
   456| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   457| 	}
   458| 	protoReq.NodeId, err = runtime.Uint64(val)
   459| 	if err != nil {
   460| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   461| 	}
   462| 	msg, err := server.ExpireNode(ctx, &protoReq)
   463| 	return msg, metadata, err
   464| }
   465| func request_HeadscaleService_RenameNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   466| 	var protoReq RenameNodeRequest
   467| 	var metadata runtime.ServerMetadata
   468| 	var (
   469| 		val string
   470| 		ok  bool
   471| 		err error
   472| 		_   = err
   473| 	)
   474| 	val, ok = pathParams["node_id"]
   475| 	if !ok {
   476| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   477| 	}
   478| 	protoReq.NodeId, err = runtime.Uint64(val)
   479| 	if err != nil {
   480| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   481| 	}
   482| 	val, ok = pathParams["new_name"]
   483| 	if !ok {
   484| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "new_name")
   485| 	}
   486| 	protoReq.NewName, err = runtime.String(val)
   487| 	if err != nil {
   488| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "new_name", err)
   489| 	}
   490| 	msg, err := client.RenameNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   491| 	return msg, metadata, err
   492| }
   493| func local_request_HeadscaleService_RenameNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   494| 	var protoReq RenameNodeRequest
   495| 	var metadata runtime.ServerMetadata
   496| 	var (
   497| 		val string
   498| 		ok  bool
   499| 		err error
   500| 		_   = err
   501| 	)
   502| 	val, ok = pathParams["node_id"]
   503| 	if !ok {
   504| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   505| 	}
   506| 	protoReq.NodeId, err = runtime.Uint64(val)
   507| 	if err != nil {
   508| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   509| 	}
   510| 	val, ok = pathParams["new_name"]
   511| 	if !ok {
   512| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "new_name")
   513| 	}
   514| 	protoReq.NewName, err = runtime.String(val)
   515| 	if err != nil {
   516| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "new_name", err)
   517| 	}
   518| 	msg, err := server.RenameNode(ctx, &protoReq)
   519| 	return msg, metadata, err
   520| }
   521| var (
   522| 	filter_HeadscaleService_ListNodes_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   523| )
   524| func request_HeadscaleService_ListNodes_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   525| 	var protoReq ListNodesRequest
   526| 	var metadata runtime.ServerMetadata
   527| 	if err := req.ParseForm(); err != nil {
   528| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   529| 	}
   530| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListNodes_0); err != nil {
   531| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   532| 	}
   533| 	msg, err := client.ListNodes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   534| 	return msg, metadata, err
   535| }
   536| func local_request_HeadscaleService_ListNodes_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   537| 	var protoReq ListNodesRequest
   538| 	var metadata runtime.ServerMetadata
   539| 	if err := req.ParseForm(); err != nil {
   540| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   541| 	}
   542| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListNodes_0); err != nil {
   543| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   544| 	}
   545| 	msg, err := server.ListNodes(ctx, &protoReq)
   546| 	return msg, metadata, err
   547| }
   548| var (
   549| 	filter_HeadscaleService_MoveNode_0 = &utilities.DoubleArray{Encoding: map[string]int{"node_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
   550| )
   551| func request_HeadscaleService_MoveNode_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   552| 	var protoReq MoveNodeRequest
   553| 	var metadata runtime.ServerMetadata
   554| 	var (
   555| 		val string
   556| 		ok  bool
   557| 		err error
   558| 		_   = err
   559| 	)
   560| 	val, ok = pathParams["node_id"]
   561| 	if !ok {
   562| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   563| 	}
   564| 	protoReq.NodeId, err = runtime.Uint64(val)
   565| 	if err != nil {
   566| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   567| 	}
   568| 	if err := req.ParseForm(); err != nil {
   569| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   570| 	}
   571| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_MoveNode_0); err != nil {
   572| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   573| 	}
   574| 	msg, err := client.MoveNode(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   575| 	return msg, metadata, err
   576| }
   577| func local_request_HeadscaleService_MoveNode_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   578| 	var protoReq MoveNodeRequest
   579| 	var metadata runtime.ServerMetadata
   580| 	var (
   581| 		val string
   582| 		ok  bool
   583| 		err error
   584| 		_   = err
   585| 	)
   586| 	val, ok = pathParams["node_id"]
   587| 	if !ok {
   588| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   589| 	}
   590| 	protoReq.NodeId, err = runtime.Uint64(val)
   591| 	if err != nil {
   592| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   593| 	}
   594| 	if err := req.ParseForm(); err != nil {
   595| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   596| 	}
   597| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_MoveNode_0); err != nil {
   598| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   599| 	}
   600| 	msg, err := server.MoveNode(ctx, &protoReq)
   601| 	return msg, metadata, err
   602| }
   603| var (
   604| 	filter_HeadscaleService_BackfillNodeIPs_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   605| )
   606| func request_HeadscaleService_BackfillNodeIPs_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   607| 	var protoReq BackfillNodeIPsRequest
   608| 	var metadata runtime.ServerMetadata
   609| 	if err := req.ParseForm(); err != nil {
   610| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   611| 	}
   612| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_BackfillNodeIPs_0); err != nil {
   613| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   614| 	}
   615| 	msg, err := client.BackfillNodeIPs(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   616| 	return msg, metadata, err
   617| }
   618| func local_request_HeadscaleService_BackfillNodeIPs_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   619| 	var protoReq BackfillNodeIPsRequest
   620| 	var metadata runtime.ServerMetadata
   621| 	if err := req.ParseForm(); err != nil {
   622| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   623| 	}
   624| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_BackfillNodeIPs_0); err != nil {
   625| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   626| 	}
   627| 	msg, err := server.BackfillNodeIPs(ctx, &protoReq)
   628| 	return msg, metadata, err
   629| }
   630| func request_HeadscaleService_GetRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   631| 	var protoReq GetRoutesRequest
   632| 	var metadata runtime.ServerMetadata
   633| 	msg, err := client.GetRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   634| 	return msg, metadata, err
   635| }
   636| func local_request_HeadscaleService_GetRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   637| 	var protoReq GetRoutesRequest
   638| 	var metadata runtime.ServerMetadata
   639| 	msg, err := server.GetRoutes(ctx, &protoReq)
   640| 	return msg, metadata, err
   641| }
   642| func request_HeadscaleService_EnableRoute_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   643| 	var protoReq EnableRouteRequest
   644| 	var metadata runtime.ServerMetadata
   645| 	var (
   646| 		val string
   647| 		ok  bool

# --- HUNK 3: Lines 702-779 ---
   702| func local_request_HeadscaleService_DisableRoute_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   703| 	var protoReq DisableRouteRequest
   704| 	var metadata runtime.ServerMetadata
   705| 	var (
   706| 		val string
   707| 		ok  bool
   708| 		err error
   709| 		_   = err
   710| 	)
   711| 	val, ok = pathParams["route_id"]
   712| 	if !ok {
   713| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   714| 	}
   715| 	protoReq.RouteId, err = runtime.Uint64(val)
   716| 	if err != nil {
   717| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   718| 	}
   719| 	msg, err := server.DisableRoute(ctx, &protoReq)
   720| 	return msg, metadata, err
   721| }
   722| func request_HeadscaleService_GetNodeRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   723| 	var protoReq GetNodeRoutesRequest
   724| 	var metadata runtime.ServerMetadata
   725| 	var (
   726| 		val string
   727| 		ok  bool
   728| 		err error
   729| 		_   = err
   730| 	)
   731| 	val, ok = pathParams["node_id"]
   732| 	if !ok {
   733| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   734| 	}
   735| 	protoReq.NodeId, err = runtime.Uint64(val)
   736| 	if err != nil {
   737| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   738| 	}
   739| 	msg, err := client.GetNodeRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   740| 	return msg, metadata, err
   741| }
   742| func local_request_HeadscaleService_GetNodeRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   743| 	var protoReq GetNodeRoutesRequest
   744| 	var metadata runtime.ServerMetadata
   745| 	var (
   746| 		val string
   747| 		ok  bool
   748| 		err error
   749| 		_   = err
   750| 	)
   751| 	val, ok = pathParams["node_id"]
   752| 	if !ok {
   753| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "node_id")
   754| 	}
   755| 	protoReq.NodeId, err = runtime.Uint64(val)
   756| 	if err != nil {
   757| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "node_id", err)
   758| 	}
   759| 	msg, err := server.GetNodeRoutes(ctx, &protoReq)
   760| 	return msg, metadata, err
   761| }
   762| func request_HeadscaleService_DeleteRoute_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   763| 	var protoReq DeleteRouteRequest
   764| 	var metadata runtime.ServerMetadata
   765| 	var (
   766| 		val string
   767| 		ok  bool
   768| 		err error
   769| 		_   = err
   770| 	)
   771| 	val, ok = pathParams["route_id"]
   772| 	if !ok {
   773| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   774| 	}
   775| 	protoReq.RouteId, err = runtime.Uint64(val)
   776| 	if err != nil {
   777| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   778| 	}
   779| 	msg, err := client.DeleteRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))

# --- HUNK 4: Lines 785-939 ---
   785| 	var (
   786| 		val string
   787| 		ok  bool
   788| 		err error
   789| 		_   = err
   790| 	)
   791| 	val, ok = pathParams["route_id"]
   792| 	if !ok {
   793| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   794| 	}
   795| 	protoReq.RouteId, err = runtime.Uint64(val)
   796| 	if err != nil {
   797| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   798| 	}
   799| 	msg, err := server.DeleteRoute(ctx, &protoReq)
   800| 	return msg, metadata, err
   801| }
   802| func request_HeadscaleService_CreateApiKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   803| 	var protoReq CreateApiKeyRequest
   804| 	var metadata runtime.ServerMetadata
   805| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   806| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   807| 	}
   808| 	msg, err := client.CreateApiKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   809| 	return msg, metadata, err
   810| }
   811| func local_request_HeadscaleService_CreateApiKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   812| 	var protoReq CreateApiKeyRequest
   813| 	var metadata runtime.ServerMetadata
   814| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   815| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   816| 	}
   817| 	msg, err := server.CreateApiKey(ctx, &protoReq)
   818| 	return msg, metadata, err
   819| }
   820| func request_HeadscaleService_ExpireApiKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   821| 	var protoReq ExpireApiKeyRequest
   822| 	var metadata runtime.ServerMetadata
   823| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   824| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   825| 	}
   826| 	msg, err := client.ExpireApiKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   827| 	return msg, metadata, err
   828| }
   829| func local_request_HeadscaleService_ExpireApiKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   830| 	var protoReq ExpireApiKeyRequest
   831| 	var metadata runtime.ServerMetadata
   832| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   833| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   834| 	}
   835| 	msg, err := server.ExpireApiKey(ctx, &protoReq)
   836| 	return msg, metadata, err
   837| }
   838| func request_HeadscaleService_ListApiKeys_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   839| 	var protoReq ListApiKeysRequest
   840| 	var metadata runtime.ServerMetadata
   841| 	msg, err := client.ListApiKeys(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   842| 	return msg, metadata, err
   843| }
   844| func local_request_HeadscaleService_ListApiKeys_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   845| 	var protoReq ListApiKeysRequest
   846| 	var metadata runtime.ServerMetadata
   847| 	msg, err := server.ListApiKeys(ctx, &protoReq)
   848| 	return msg, metadata, err
   849| }
   850| func request_HeadscaleService_DeleteApiKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   851| 	var protoReq DeleteApiKeyRequest
   852| 	var metadata runtime.ServerMetadata
   853| 	var (
   854| 		val string
   855| 		ok  bool
   856| 		err error
   857| 		_   = err
   858| 	)
   859| 	val, ok = pathParams["prefix"]
   860| 	if !ok {
   861| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "prefix")
   862| 	}
   863| 	protoReq.Prefix, err = runtime.String(val)
   864| 	if err != nil {
   865| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "prefix", err)
   866| 	}
   867| 	msg, err := client.DeleteApiKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   868| 	return msg, metadata, err
   869| }
   870| func local_request_HeadscaleService_DeleteApiKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   871| 	var protoReq DeleteApiKeyRequest
   872| 	var metadata runtime.ServerMetadata
   873| 	var (
   874| 		val string
   875| 		ok  bool
   876| 		err error
   877| 		_   = err
   878| 	)
   879| 	val, ok = pathParams["prefix"]
   880| 	if !ok {
   881| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "prefix")
   882| 	}
   883| 	protoReq.Prefix, err = runtime.String(val)
   884| 	if err != nil {
   885| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "prefix", err)
   886| 	}
   887| 	msg, err := server.DeleteApiKey(ctx, &protoReq)
   888| 	return msg, metadata, err
   889| }
   890| func request_HeadscaleService_GetPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   891| 	var protoReq GetPolicyRequest
   892| 	var metadata runtime.ServerMetadata
   893| 	msg, err := client.GetPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   894| 	return msg, metadata, err
   895| }
   896| func local_request_HeadscaleService_GetPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   897| 	var protoReq GetPolicyRequest
   898| 	var metadata runtime.ServerMetadata
   899| 	msg, err := server.GetPolicy(ctx, &protoReq)
   900| 	return msg, metadata, err
   901| }
   902| func request_HeadscaleService_SetPolicy_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   903| 	var protoReq SetPolicyRequest
   904| 	var metadata runtime.ServerMetadata
   905| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   906| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   907| 	}
   908| 	msg, err := client.SetPolicy(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   909| 	return msg, metadata, err
   910| }
   911| func local_request_HeadscaleService_SetPolicy_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   912| 	var protoReq SetPolicyRequest
   913| 	var metadata runtime.ServerMetadata
   914| 	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
   915| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   916| 	}
   917| 	msg, err := server.SetPolicy(ctx, &protoReq)
   918| 	return msg, metadata, err
   919| }
   920| func RegisterHeadscaleServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server HeadscaleServiceServer) error {
   921| 	mux.Handle("GET", pattern_HeadscaleService_GetUser_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
   922| 		ctx, cancel := context.WithCancel(req.Context())
   923| 		defer cancel()
   924| 		var stream runtime.ServerTransportStream
   925| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
   926| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
   927| 		var err error
   928| 		var annotatedContext context.Context
   929| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetUser", runtime.WithHTTPPathPattern("/api/v1/user/{name}"))
   930| 		if err != nil {
   931| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
   932| 			return
   933| 		}
   934| 		resp, md, err := local_request_HeadscaleService_GetUser_0(annotatedContext, inboundMarshaler, server, req, pathParams)
   935| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
   936| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
   937| 		if err != nil {
   938| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
   939| 			return

# --- HUNK 5: Lines 1077-1335 ---
  1077| 		defer cancel()
  1078| 		var stream runtime.ServerTransportStream
  1079| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1080| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1081| 		var err error
  1082| 		var annotatedContext context.Context
  1083| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListPreAuthKeys", runtime.WithHTTPPathPattern("/api/v1/preauthkey"))
  1084| 		if err != nil {
  1085| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1086| 			return
  1087| 		}
  1088| 		resp, md, err := local_request_HeadscaleService_ListPreAuthKeys_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1089| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1090| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1091| 		if err != nil {
  1092| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1093| 			return
  1094| 		}
  1095| 		forward_HeadscaleService_ListPreAuthKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1096| 	})
  1097| 	mux.Handle("POST", pattern_HeadscaleService_DebugCreateNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1098| 		ctx, cancel := context.WithCancel(req.Context())
  1099| 		defer cancel()
  1100| 		var stream runtime.ServerTransportStream
  1101| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1102| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1103| 		var err error
  1104| 		var annotatedContext context.Context
  1105| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DebugCreateNode", runtime.WithHTTPPathPattern("/api/v1/debug/node"))
  1106| 		if err != nil {
  1107| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1108| 			return
  1109| 		}
  1110| 		resp, md, err := local_request_HeadscaleService_DebugCreateNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1111| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1112| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1113| 		if err != nil {
  1114| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1115| 			return
  1116| 		}
  1117| 		forward_HeadscaleService_DebugCreateNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1118| 	})
  1119| 	mux.Handle("GET", pattern_HeadscaleService_GetNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1120| 		ctx, cancel := context.WithCancel(req.Context())
  1121| 		defer cancel()
  1122| 		var stream runtime.ServerTransportStream
  1123| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1124| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1125| 		var err error
  1126| 		var annotatedContext context.Context
  1127| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}"))
  1128| 		if err != nil {
  1129| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1130| 			return
  1131| 		}
  1132| 		resp, md, err := local_request_HeadscaleService_GetNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1133| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1134| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1135| 		if err != nil {
  1136| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1137| 			return
  1138| 		}
  1139| 		forward_HeadscaleService_GetNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1140| 	})
  1141| 	mux.Handle("POST", pattern_HeadscaleService_SetTags_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1142| 		ctx, cancel := context.WithCancel(req.Context())
  1143| 		defer cancel()
  1144| 		var stream runtime.ServerTransportStream
  1145| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1146| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1147| 		var err error
  1148| 		var annotatedContext context.Context
  1149| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetTags", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/tags"))
  1150| 		if err != nil {
  1151| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1152| 			return
  1153| 		}
  1154| 		resp, md, err := local_request_HeadscaleService_SetTags_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1155| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1156| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1157| 		if err != nil {
  1158| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1159| 			return
  1160| 		}
  1161| 		forward_HeadscaleService_SetTags_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1162| 	})
  1163| 	mux.Handle("POST", pattern_HeadscaleService_RegisterNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1164| 		ctx, cancel := context.WithCancel(req.Context())
  1165| 		defer cancel()
  1166| 		var stream runtime.ServerTransportStream
  1167| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1168| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1169| 		var err error
  1170| 		var annotatedContext context.Context
  1171| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RegisterNode", runtime.WithHTTPPathPattern("/api/v1/node/register"))
  1172| 		if err != nil {
  1173| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1174| 			return
  1175| 		}
  1176| 		resp, md, err := local_request_HeadscaleService_RegisterNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1177| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1178| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1179| 		if err != nil {
  1180| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1181| 			return
  1182| 		}
  1183| 		forward_HeadscaleService_RegisterNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1184| 	})
  1185| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1186| 		ctx, cancel := context.WithCancel(req.Context())
  1187| 		defer cancel()
  1188| 		var stream runtime.ServerTransportStream
  1189| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1190| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1191| 		var err error
  1192| 		var annotatedContext context.Context
  1193| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}"))
  1194| 		if err != nil {
  1195| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1196| 			return
  1197| 		}
  1198| 		resp, md, err := local_request_HeadscaleService_DeleteNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1199| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1200| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1201| 		if err != nil {
  1202| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1203| 			return
  1204| 		}
  1205| 		forward_HeadscaleService_DeleteNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1206| 	})
  1207| 	mux.Handle("POST", pattern_HeadscaleService_ExpireNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1208| 		ctx, cancel := context.WithCancel(req.Context())
  1209| 		defer cancel()
  1210| 		var stream runtime.ServerTransportStream
  1211| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1212| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1213| 		var err error
  1214| 		var annotatedContext context.Context
  1215| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ExpireNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/expire"))
  1216| 		if err != nil {
  1217| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1218| 			return
  1219| 		}
  1220| 		resp, md, err := local_request_HeadscaleService_ExpireNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1221| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1222| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1223| 		if err != nil {
  1224| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1225| 			return
  1226| 		}
  1227| 		forward_HeadscaleService_ExpireNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1228| 	})
  1229| 	mux.Handle("POST", pattern_HeadscaleService_RenameNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1230| 		ctx, cancel := context.WithCancel(req.Context())
  1231| 		defer cancel()
  1232| 		var stream runtime.ServerTransportStream
  1233| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1234| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1235| 		var err error
  1236| 		var annotatedContext context.Context
  1237| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RenameNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/rename/{new_name}"))
  1238| 		if err != nil {
  1239| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1240| 			return
  1241| 		}
  1242| 		resp, md, err := local_request_HeadscaleService_RenameNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1243| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1244| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1245| 		if err != nil {
  1246| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1247| 			return
  1248| 		}
  1249| 		forward_HeadscaleService_RenameNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1250| 	})
  1251| 	mux.Handle("GET", pattern_HeadscaleService_ListNodes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1252| 		ctx, cancel := context.WithCancel(req.Context())
  1253| 		defer cancel()
  1254| 		var stream runtime.ServerTransportStream
  1255| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1256| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1257| 		var err error
  1258| 		var annotatedContext context.Context
  1259| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListNodes", runtime.WithHTTPPathPattern("/api/v1/node"))
  1260| 		if err != nil {
  1261| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1262| 			return
  1263| 		}
  1264| 		resp, md, err := local_request_HeadscaleService_ListNodes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1265| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1266| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1267| 		if err != nil {
  1268| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1269| 			return
  1270| 		}
  1271| 		forward_HeadscaleService_ListNodes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1272| 	})
  1273| 	mux.Handle("POST", pattern_HeadscaleService_MoveNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1274| 		ctx, cancel := context.WithCancel(req.Context())
  1275| 		defer cancel()
  1276| 		var stream runtime.ServerTransportStream
  1277| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1278| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1279| 		var err error
  1280| 		var annotatedContext context.Context
  1281| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/MoveNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/user"))
  1282| 		if err != nil {
  1283| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1284| 			return
  1285| 		}
  1286| 		resp, md, err := local_request_HeadscaleService_MoveNode_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1287| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1288| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1289| 		if err != nil {
  1290| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1291| 			return
  1292| 		}
  1293| 		forward_HeadscaleService_MoveNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1294| 	})
  1295| 	mux.Handle("POST", pattern_HeadscaleService_BackfillNodeIPs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1296| 		ctx, cancel := context.WithCancel(req.Context())
  1297| 		defer cancel()
  1298| 		var stream runtime.ServerTransportStream
  1299| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1300| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1301| 		var err error
  1302| 		var annotatedContext context.Context
  1303| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/BackfillNodeIPs", runtime.WithHTTPPathPattern("/api/v1/node/backfillips"))
  1304| 		if err != nil {
  1305| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1306| 			return
  1307| 		}
  1308| 		resp, md, err := local_request_HeadscaleService_BackfillNodeIPs_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1309| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1310| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1311| 		if err != nil {
  1312| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1313| 			return
  1314| 		}
  1315| 		forward_HeadscaleService_BackfillNodeIPs_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1316| 	})
  1317| 	mux.Handle("GET", pattern_HeadscaleService_GetRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1318| 		ctx, cancel := context.WithCancel(req.Context())
  1319| 		defer cancel()
  1320| 		var stream runtime.ServerTransportStream
  1321| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1322| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1323| 		var err error
  1324| 		var annotatedContext context.Context
  1325| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetRoutes", runtime.WithHTTPPathPattern("/api/v1/routes"))
  1326| 		if err != nil {
  1327| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1328| 			return
  1329| 		}
  1330| 		resp, md, err := local_request_HeadscaleService_GetRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1331| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1332| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1333| 		if err != nil {
  1334| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1335| 			return

# --- HUNK 6: Lines 1363-1423 ---
  1363| 		defer cancel()
  1364| 		var stream runtime.ServerTransportStream
  1365| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1366| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1367| 		var err error
  1368| 		var annotatedContext context.Context
  1369| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DisableRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}/disable"))
  1370| 		if err != nil {
  1371| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1372| 			return
  1373| 		}
  1374| 		resp, md, err := local_request_HeadscaleService_DisableRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1375| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1376| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1377| 		if err != nil {
  1378| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1379| 			return
  1380| 		}
  1381| 		forward_HeadscaleService_DisableRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1382| 	})
  1383| 	mux.Handle("GET", pattern_HeadscaleService_GetNodeRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1384| 		ctx, cancel := context.WithCancel(req.Context())
  1385| 		defer cancel()
  1386| 		var stream runtime.ServerTransportStream
  1387| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1388| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1389| 		var err error
  1390| 		var annotatedContext context.Context
  1391| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetNodeRoutes", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/routes"))
  1392| 		if err != nil {
  1393| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1394| 			return
  1395| 		}
  1396| 		resp, md, err := local_request_HeadscaleService_GetNodeRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1397| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1398| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1399| 		if err != nil {
  1400| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1401| 			return
  1402| 		}
  1403| 		forward_HeadscaleService_GetNodeRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1404| 	})
  1405| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1406| 		ctx, cancel := context.WithCancel(req.Context())
  1407| 		defer cancel()
  1408| 		var stream runtime.ServerTransportStream
  1409| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1410| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1411| 		var err error
  1412| 		var annotatedContext context.Context
  1413| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}"))
  1414| 		if err != nil {
  1415| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1416| 			return
  1417| 		}
  1418| 		resp, md, err := local_request_HeadscaleService_DeleteRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1419| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1420| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1421| 		if err != nil {
  1422| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1423| 			return

# --- HUNK 7: Lines 1473-1596 ---
  1473| 		defer cancel()
  1474| 		var stream runtime.ServerTransportStream
  1475| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1476| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1477| 		var err error
  1478| 		var annotatedContext context.Context
  1479| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListApiKeys", runtime.WithHTTPPathPattern("/api/v1/apikey"))
  1480| 		if err != nil {
  1481| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1482| 			return
  1483| 		}
  1484| 		resp, md, err := local_request_HeadscaleService_ListApiKeys_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1485| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1486| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1487| 		if err != nil {
  1488| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1489| 			return
  1490| 		}
  1491| 		forward_HeadscaleService_ListApiKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1492| 	})
  1493| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteApiKey_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1494| 		ctx, cancel := context.WithCancel(req.Context())
  1495| 		defer cancel()
  1496| 		var stream runtime.ServerTransportStream
  1497| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1498| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1499| 		var err error
  1500| 		var annotatedContext context.Context
  1501| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteApiKey", runtime.WithHTTPPathPattern("/api/v1/apikey/{prefix}"))
  1502| 		if err != nil {
  1503| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1504| 			return
  1505| 		}
  1506| 		resp, md, err := local_request_HeadscaleService_DeleteApiKey_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1507| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1508| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1509| 		if err != nil {
  1510| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1511| 			return
  1512| 		}
  1513| 		forward_HeadscaleService_DeleteApiKey_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1514| 	})
  1515| 	mux.Handle("GET", pattern_HeadscaleService_GetPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1516| 		ctx, cancel := context.WithCancel(req.Context())
  1517| 		defer cancel()
  1518| 		var stream runtime.ServerTransportStream
  1519| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1520| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1521| 		var err error
  1522| 		var annotatedContext context.Context
  1523| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetPolicy", runtime.WithHTTPPathPattern("/api/v1/policy"))
  1524| 		if err != nil {
  1525| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1526| 			return
  1527| 		}
  1528| 		resp, md, err := local_request_HeadscaleService_GetPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1529| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1530| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1531| 		if err != nil {
  1532| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1533| 			return
  1534| 		}
  1535| 		forward_HeadscaleService_GetPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1536| 	})
  1537| 	mux.Handle("PUT", pattern_HeadscaleService_SetPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1538| 		ctx, cancel := context.WithCancel(req.Context())
  1539| 		defer cancel()
  1540| 		var stream runtime.ServerTransportStream
  1541| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1542| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1543| 		var err error
  1544| 		var annotatedContext context.Context
  1545| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetPolicy", runtime.WithHTTPPathPattern("/api/v1/policy"))
  1546| 		if err != nil {
  1547| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1548| 			return
  1549| 		}
  1550| 		resp, md, err := local_request_HeadscaleService_SetPolicy_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1551| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1552| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1553| 		if err != nil {
  1554| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1555| 			return
  1556| 		}
  1557| 		forward_HeadscaleService_SetPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1558| 	})
  1559| 	return nil
  1560| }
  1561| func RegisterHeadscaleServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
  1562| 	conn, err := grpc.NewClient(endpoint, opts...)
  1563| 	if err != nil {
  1564| 		return err
  1565| 	}
  1566| 	defer func() {
  1567| 		if err != nil {
  1568| 			if cerr := conn.Close(); cerr != nil {
  1569| 				grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
  1570| 			}
  1571| 			return
  1572| 		}
  1573| 		go func() {
  1574| 			<-ctx.Done()
  1575| 			if cerr := conn.Close(); cerr != nil {
  1576| 				grpclog.Errorf("Failed to close conn to %s: %v", endpoint, cerr)
  1577| 			}
  1578| 		}()
  1579| 	}()
  1580| 	return RegisterHeadscaleServiceHandler(ctx, mux, conn)
  1581| }
  1582| func RegisterHeadscaleServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
  1583| 	return RegisterHeadscaleServiceHandlerClient(ctx, mux, NewHeadscaleServiceClient(conn))
  1584| }
  1585| func RegisterHeadscaleServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client HeadscaleServiceClient) error {
  1586| 	mux.Handle("GET", pattern_HeadscaleService_GetUser_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1587| 		ctx, cancel := context.WithCancel(req.Context())
  1588| 		defer cancel()
  1589| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1590| 		var err error
  1591| 		var annotatedContext context.Context
  1592| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetUser", runtime.WithHTTPPathPattern("/api/v1/user/{name}"))
  1593| 		if err != nil {
  1594| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1595| 			return
  1596| 		}

# --- HUNK 8: Lines 1718-1946 ---
  1718| 	})
  1719| 	mux.Handle("GET", pattern_HeadscaleService_ListPreAuthKeys_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1720| 		ctx, cancel := context.WithCancel(req.Context())
  1721| 		defer cancel()
  1722| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1723| 		var err error
  1724| 		var annotatedContext context.Context
  1725| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListPreAuthKeys", runtime.WithHTTPPathPattern("/api/v1/preauthkey"))
  1726| 		if err != nil {
  1727| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1728| 			return
  1729| 		}
  1730| 		resp, md, err := request_HeadscaleService_ListPreAuthKeys_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1731| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1732| 		if err != nil {
  1733| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1734| 			return
  1735| 		}
  1736| 		forward_HeadscaleService_ListPreAuthKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1737| 	})
  1738| 	mux.Handle("POST", pattern_HeadscaleService_DebugCreateNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1739| 		ctx, cancel := context.WithCancel(req.Context())
  1740| 		defer cancel()
  1741| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1742| 		var err error
  1743| 		var annotatedContext context.Context
  1744| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DebugCreateNode", runtime.WithHTTPPathPattern("/api/v1/debug/node"))
  1745| 		if err != nil {
  1746| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1747| 			return
  1748| 		}
  1749| 		resp, md, err := request_HeadscaleService_DebugCreateNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1750| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1751| 		if err != nil {
  1752| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1753| 			return
  1754| 		}
  1755| 		forward_HeadscaleService_DebugCreateNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1756| 	})
  1757| 	mux.Handle("GET", pattern_HeadscaleService_GetNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1758| 		ctx, cancel := context.WithCancel(req.Context())
  1759| 		defer cancel()
  1760| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1761| 		var err error
  1762| 		var annotatedContext context.Context
  1763| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}"))
  1764| 		if err != nil {
  1765| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1766| 			return
  1767| 		}
  1768| 		resp, md, err := request_HeadscaleService_GetNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1769| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1770| 		if err != nil {
  1771| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1772| 			return
  1773| 		}
  1774| 		forward_HeadscaleService_GetNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1775| 	})
  1776| 	mux.Handle("POST", pattern_HeadscaleService_SetTags_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1777| 		ctx, cancel := context.WithCancel(req.Context())
  1778| 		defer cancel()
  1779| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1780| 		var err error
  1781| 		var annotatedContext context.Context
  1782| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetTags", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/tags"))
  1783| 		if err != nil {
  1784| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1785| 			return
  1786| 		}
  1787| 		resp, md, err := request_HeadscaleService_SetTags_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1788| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1789| 		if err != nil {
  1790| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1791| 			return
  1792| 		}
  1793| 		forward_HeadscaleService_SetTags_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1794| 	})
  1795| 	mux.Handle("POST", pattern_HeadscaleService_RegisterNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1796| 		ctx, cancel := context.WithCancel(req.Context())
  1797| 		defer cancel()
  1798| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1799| 		var err error
  1800| 		var annotatedContext context.Context
  1801| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RegisterNode", runtime.WithHTTPPathPattern("/api/v1/node/register"))
  1802| 		if err != nil {
  1803| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1804| 			return
  1805| 		}
  1806| 		resp, md, err := request_HeadscaleService_RegisterNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1807| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1808| 		if err != nil {
  1809| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1810| 			return
  1811| 		}
  1812| 		forward_HeadscaleService_RegisterNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1813| 	})
  1814| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1815| 		ctx, cancel := context.WithCancel(req.Context())
  1816| 		defer cancel()
  1817| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1818| 		var err error
  1819| 		var annotatedContext context.Context
  1820| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}"))
  1821| 		if err != nil {
  1822| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1823| 			return
  1824| 		}
  1825| 		resp, md, err := request_HeadscaleService_DeleteNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1826| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1827| 		if err != nil {
  1828| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1829| 			return
  1830| 		}
  1831| 		forward_HeadscaleService_DeleteNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1832| 	})
  1833| 	mux.Handle("POST", pattern_HeadscaleService_ExpireNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1834| 		ctx, cancel := context.WithCancel(req.Context())
  1835| 		defer cancel()
  1836| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1837| 		var err error
  1838| 		var annotatedContext context.Context
  1839| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ExpireNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/expire"))
  1840| 		if err != nil {
  1841| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1842| 			return
  1843| 		}
  1844| 		resp, md, err := request_HeadscaleService_ExpireNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1845| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1846| 		if err != nil {
  1847| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1848| 			return
  1849| 		}
  1850| 		forward_HeadscaleService_ExpireNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1851| 	})
  1852| 	mux.Handle("POST", pattern_HeadscaleService_RenameNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1853| 		ctx, cancel := context.WithCancel(req.Context())
  1854| 		defer cancel()
  1855| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1856| 		var err error
  1857| 		var annotatedContext context.Context
  1858| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RenameNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/rename/{new_name}"))
  1859| 		if err != nil {
  1860| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1861| 			return
  1862| 		}
  1863| 		resp, md, err := request_HeadscaleService_RenameNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1864| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1865| 		if err != nil {
  1866| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1867| 			return
  1868| 		}
  1869| 		forward_HeadscaleService_RenameNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1870| 	})
  1871| 	mux.Handle("GET", pattern_HeadscaleService_ListNodes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1872| 		ctx, cancel := context.WithCancel(req.Context())
  1873| 		defer cancel()
  1874| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1875| 		var err error
  1876| 		var annotatedContext context.Context
  1877| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListNodes", runtime.WithHTTPPathPattern("/api/v1/node"))
  1878| 		if err != nil {
  1879| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1880| 			return
  1881| 		}
  1882| 		resp, md, err := request_HeadscaleService_ListNodes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1883| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1884| 		if err != nil {
  1885| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1886| 			return
  1887| 		}
  1888| 		forward_HeadscaleService_ListNodes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1889| 	})
  1890| 	mux.Handle("POST", pattern_HeadscaleService_MoveNode_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1891| 		ctx, cancel := context.WithCancel(req.Context())
  1892| 		defer cancel()
  1893| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1894| 		var err error
  1895| 		var annotatedContext context.Context
  1896| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/MoveNode", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/user"))
  1897| 		if err != nil {
  1898| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1899| 			return
  1900| 		}
  1901| 		resp, md, err := request_HeadscaleService_MoveNode_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1902| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1903| 		if err != nil {
  1904| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1905| 			return
  1906| 		}
  1907| 		forward_HeadscaleService_MoveNode_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1908| 	})
  1909| 	mux.Handle("POST", pattern_HeadscaleService_BackfillNodeIPs_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1910| 		ctx, cancel := context.WithCancel(req.Context())
  1911| 		defer cancel()
  1912| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1913| 		var err error
  1914| 		var annotatedContext context.Context
  1915| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/BackfillNodeIPs", runtime.WithHTTPPathPattern("/api/v1/node/backfillips"))
  1916| 		if err != nil {
  1917| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1918| 			return
  1919| 		}
  1920| 		resp, md, err := request_HeadscaleService_BackfillNodeIPs_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1921| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1922| 		if err != nil {
  1923| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1924| 			return
  1925| 		}
  1926| 		forward_HeadscaleService_BackfillNodeIPs_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1927| 	})
  1928| 	mux.Handle("GET", pattern_HeadscaleService_GetRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1929| 		ctx, cancel := context.WithCancel(req.Context())
  1930| 		defer cancel()
  1931| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1932| 		var err error
  1933| 		var annotatedContext context.Context
  1934| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetRoutes", runtime.WithHTTPPathPattern("/api/v1/routes"))
  1935| 		if err != nil {
  1936| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1937| 			return
  1938| 		}
  1939| 		resp, md, err := request_HeadscaleService_GetRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1940| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1941| 		if err != nil {
  1942| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1943| 			return
  1944| 		}
  1945| 		forward_HeadscaleService_GetRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1946| 	})

# --- HUNK 9: Lines 1965-2022 ---
  1965| 	})
  1966| 	mux.Handle("POST", pattern_HeadscaleService_DisableRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1967| 		ctx, cancel := context.WithCancel(req.Context())
  1968| 		defer cancel()
  1969| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1970| 		var err error
  1971| 		var annotatedContext context.Context
  1972| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DisableRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}/disable"))
  1973| 		if err != nil {
  1974| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1975| 			return
  1976| 		}
  1977| 		resp, md, err := request_HeadscaleService_DisableRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1978| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1979| 		if err != nil {
  1980| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1981| 			return
  1982| 		}
  1983| 		forward_HeadscaleService_DisableRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1984| 	})
  1985| 	mux.Handle("GET", pattern_HeadscaleService_GetNodeRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1986| 		ctx, cancel := context.WithCancel(req.Context())
  1987| 		defer cancel()
  1988| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1989| 		var err error
  1990| 		var annotatedContext context.Context
  1991| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetNodeRoutes", runtime.WithHTTPPathPattern("/api/v1/node/{node_id}/routes"))
  1992| 		if err != nil {
  1993| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1994| 			return
  1995| 		}
  1996| 		resp, md, err := request_HeadscaleService_GetNodeRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1997| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1998| 		if err != nil {
  1999| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2000| 			return
  2001| 		}
  2002| 		forward_HeadscaleService_GetNodeRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2003| 	})
  2004| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  2005| 		ctx, cancel := context.WithCancel(req.Context())
  2006| 		defer cancel()
  2007| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  2008| 		var err error
  2009| 		var annotatedContext context.Context
  2010| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}"))
  2011| 		if err != nil {
  2012| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  2013| 			return
  2014| 		}
  2015| 		resp, md, err := request_HeadscaleService_DeleteRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  2016| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  2017| 		if err != nil {
  2018| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2019| 			return
  2020| 		}
  2021| 		forward_HeadscaleService_DeleteRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2022| 	})

# --- HUNK 10: Lines 2059-2200 ---
  2059| 		forward_HeadscaleService_ExpireApiKey_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2060| 	})
  2061| 	mux.Handle("GET", pattern_HeadscaleService_ListApiKeys_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  2062| 		ctx, cancel := context.WithCancel(req.Context())
  2063| 		defer cancel()
  2064| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  2065| 		var err error
  2066| 		var annotatedContext context.Context
  2067| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListApiKeys", runtime.WithHTTPPathPattern("/api/v1/apikey"))
  2068| 		if err != nil {
  2069| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  2070| 			return
  2071| 		}
  2072| 		resp, md, err := request_HeadscaleService_ListApiKeys_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  2073| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  2074| 		if err != nil {
  2075| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2076| 			return
  2077| 		}
  2078| 		forward_HeadscaleService_ListApiKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2079| 	})
  2080| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteApiKey_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  2081| 		ctx, cancel := context.WithCancel(req.Context())
  2082| 		defer cancel()
  2083| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  2084| 		var err error
  2085| 		var annotatedContext context.Context
  2086| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteApiKey", runtime.WithHTTPPathPattern("/api/v1/apikey/{prefix}"))
  2087| 		if err != nil {
  2088| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  2089| 			return
  2090| 		}
  2091| 		resp, md, err := request_HeadscaleService_DeleteApiKey_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  2092| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  2093| 		if err != nil {
  2094| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2095| 			return
  2096| 		}
  2097| 		forward_HeadscaleService_DeleteApiKey_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2098| 	})
  2099| 	mux.Handle("GET", pattern_HeadscaleService_GetPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  2100| 		ctx, cancel := context.WithCancel(req.Context())
  2101| 		defer cancel()
  2102| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  2103| 		var err error
  2104| 		var annotatedContext context.Context
  2105| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetPolicy", runtime.WithHTTPPathPattern("/api/v1/policy"))
  2106| 		if err != nil {
  2107| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  2108| 			return
  2109| 		}
  2110| 		resp, md, err := request_HeadscaleService_GetPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  2111| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  2112| 		if err != nil {
  2113| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2114| 			return
  2115| 		}
  2116| 		forward_HeadscaleService_GetPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2117| 	})
  2118| 	mux.Handle("PUT", pattern_HeadscaleService_SetPolicy_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  2119| 		ctx, cancel := context.WithCancel(req.Context())
  2120| 		defer cancel()
  2121| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  2122| 		var err error
  2123| 		var annotatedContext context.Context
  2124| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetPolicy", runtime.WithHTTPPathPattern("/api/v1/policy"))
  2125| 		if err != nil {
  2126| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  2127| 			return
  2128| 		}
  2129| 		resp, md, err := request_HeadscaleService_SetPolicy_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  2130| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  2131| 		if err != nil {
  2132| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  2133| 			return
  2134| 		}
  2135| 		forward_HeadscaleService_SetPolicy_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  2136| 	})
  2137| 	return nil
  2138| }
  2139| var (
  2140| 	pattern_HeadscaleService_GetUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "user", "name"}, ""))
  2141| 	pattern_HeadscaleService_CreateUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "user"}, ""))
  2142| 	pattern_HeadscaleService_RenameUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4, 1, 0, 4, 1, 5, 5}, []string{"api", "v1", "user", "old_name", "rename", "new_name"}, ""))
  2143| 	pattern_HeadscaleService_DeleteUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "user", "name"}, ""))
  2144| 	pattern_HeadscaleService_ListUsers_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "user"}, ""))
  2145| 	pattern_HeadscaleService_CreatePreAuthKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "preauthkey"}, ""))
  2146| 	pattern_HeadscaleService_ExpirePreAuthKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "preauthkey", "expire"}, ""))
  2147| 	pattern_HeadscaleService_ListPreAuthKeys_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "preauthkey"}, ""))
  2148| 	pattern_HeadscaleService_DebugCreateNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "debug", "node"}, ""))
  2149| 	pattern_HeadscaleService_GetNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "node", "node_id"}, ""))
  2150| 	pattern_HeadscaleService_SetTags_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "node", "node_id", "tags"}, ""))
  2151| 	pattern_HeadscaleService_RegisterNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "node", "register"}, ""))
  2152| 	pattern_HeadscaleService_DeleteNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "node", "node_id"}, ""))
  2153| 	pattern_HeadscaleService_ExpireNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "node", "node_id", "expire"}, ""))
  2154| 	pattern_HeadscaleService_RenameNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4, 1, 0, 4, 1, 5, 5}, []string{"api", "v1", "node", "node_id", "rename", "new_name"}, ""))
  2155| 	pattern_HeadscaleService_ListNodes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "node"}, ""))
  2156| 	pattern_HeadscaleService_MoveNode_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "node", "node_id", "user"}, ""))
  2157| 	pattern_HeadscaleService_BackfillNodeIPs_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "node", "backfillips"}, ""))
  2158| 	pattern_HeadscaleService_GetRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "routes"}, ""))
  2159| 	pattern_HeadscaleService_EnableRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "routes", "route_id", "enable"}, ""))
  2160| 	pattern_HeadscaleService_DisableRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "routes", "route_id", "disable"}, ""))
  2161| 	pattern_HeadscaleService_GetNodeRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "node", "node_id", "routes"}, ""))
  2162| 	pattern_HeadscaleService_DeleteRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "routes", "route_id"}, ""))
  2163| 	pattern_HeadscaleService_CreateApiKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "apikey"}, ""))
  2164| 	pattern_HeadscaleService_ExpireApiKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "apikey", "expire"}, ""))
  2165| 	pattern_HeadscaleService_ListApiKeys_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "apikey"}, ""))
  2166| 	pattern_HeadscaleService_DeleteApiKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "apikey", "prefix"}, ""))
  2167| 	pattern_HeadscaleService_GetPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "policy"}, ""))
  2168| 	pattern_HeadscaleService_SetPolicy_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "policy"}, ""))
  2169| )
  2170| var (
  2171| 	forward_HeadscaleService_GetUser_0 = runtime.ForwardResponseMessage
  2172| 	forward_HeadscaleService_CreateUser_0 = runtime.ForwardResponseMessage
  2173| 	forward_HeadscaleService_RenameUser_0 = runtime.ForwardResponseMessage
  2174| 	forward_HeadscaleService_DeleteUser_0 = runtime.ForwardResponseMessage
  2175| 	forward_HeadscaleService_ListUsers_0 = runtime.ForwardResponseMessage
  2176| 	forward_HeadscaleService_CreatePreAuthKey_0 = runtime.ForwardResponseMessage
  2177| 	forward_HeadscaleService_ExpirePreAuthKey_0 = runtime.ForwardResponseMessage
  2178| 	forward_HeadscaleService_ListPreAuthKeys_0 = runtime.ForwardResponseMessage
  2179| 	forward_HeadscaleService_DebugCreateNode_0 = runtime.ForwardResponseMessage
  2180| 	forward_HeadscaleService_GetNode_0 = runtime.ForwardResponseMessage
  2181| 	forward_HeadscaleService_SetTags_0 = runtime.ForwardResponseMessage
  2182| 	forward_HeadscaleService_RegisterNode_0 = runtime.ForwardResponseMessage
  2183| 	forward_HeadscaleService_DeleteNode_0 = runtime.ForwardResponseMessage
  2184| 	forward_HeadscaleService_ExpireNode_0 = runtime.ForwardResponseMessage
  2185| 	forward_HeadscaleService_RenameNode_0 = runtime.ForwardResponseMessage
  2186| 	forward_HeadscaleService_ListNodes_0 = runtime.ForwardResponseMessage
  2187| 	forward_HeadscaleService_MoveNode_0 = runtime.ForwardResponseMessage
  2188| 	forward_HeadscaleService_BackfillNodeIPs_0 = runtime.ForwardResponseMessage
  2189| 	forward_HeadscaleService_GetRoutes_0 = runtime.ForwardResponseMessage
  2190| 	forward_HeadscaleService_EnableRoute_0 = runtime.ForwardResponseMessage
  2191| 	forward_HeadscaleService_DisableRoute_0 = runtime.ForwardResponseMessage
  2192| 	forward_HeadscaleService_GetNodeRoutes_0 = runtime.ForwardResponseMessage
  2193| 	forward_HeadscaleService_DeleteRoute_0 = runtime.ForwardResponseMessage
  2194| 	forward_HeadscaleService_CreateApiKey_0 = runtime.ForwardResponseMessage
  2195| 	forward_HeadscaleService_ExpireApiKey_0 = runtime.ForwardResponseMessage
  2196| 	forward_HeadscaleService_ListApiKeys_0 = runtime.ForwardResponseMessage
  2197| 	forward_HeadscaleService_DeleteApiKey_0 = runtime.ForwardResponseMessage
  2198| 	forward_HeadscaleService_GetPolicy_0 = runtime.ForwardResponseMessage
  2199| 	forward_HeadscaleService_SetPolicy_0 = runtime.ForwardResponseMessage
  2200| )


# ====================================================================
# FILE: gen/go/headscale/v1/headscale_grpc.pb.go
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| package v1
     2| import (
     3| 	context "context"
     4| 	grpc "google.golang.org/grpc"
     5| 	codes "google.golang.org/grpc/codes"
     6| 	status "google.golang.org/grpc/status"
     7| )
     8| const _ = grpc.SupportPackageIsVersion7
     9| const (
    10| 	HeadscaleService_GetUser_FullMethodName          = "/headscale.v1.HeadscaleService/GetUser"
    11| 	HeadscaleService_CreateUser_FullMethodName       = "/headscale.v1.HeadscaleService/CreateUser"
    12| 	HeadscaleService_RenameUser_FullMethodName       = "/headscale.v1.HeadscaleService/RenameUser"
    13| 	HeadscaleService_DeleteUser_FullMethodName       = "/headscale.v1.HeadscaleService/DeleteUser"
    14| 	HeadscaleService_ListUsers_FullMethodName        = "/headscale.v1.HeadscaleService/ListUsers"
    15| 	HeadscaleService_CreatePreAuthKey_FullMethodName = "/headscale.v1.HeadscaleService/CreatePreAuthKey"
    16| 	HeadscaleService_ExpirePreAuthKey_FullMethodName = "/headscale.v1.HeadscaleService/ExpirePreAuthKey"
    17| 	HeadscaleService_ListPreAuthKeys_FullMethodName  = "/headscale.v1.HeadscaleService/ListPreAuthKeys"
    18| 	HeadscaleService_DebugCreateNode_FullMethodName  = "/headscale.v1.HeadscaleService/DebugCreateNode"
    19| 	HeadscaleService_GetNode_FullMethodName          = "/headscale.v1.HeadscaleService/GetNode"
    20| 	HeadscaleService_SetTags_FullMethodName          = "/headscale.v1.HeadscaleService/SetTags"
    21| 	HeadscaleService_RegisterNode_FullMethodName     = "/headscale.v1.HeadscaleService/RegisterNode"
    22| 	HeadscaleService_DeleteNode_FullMethodName       = "/headscale.v1.HeadscaleService/DeleteNode"
    23| 	HeadscaleService_ExpireNode_FullMethodName       = "/headscale.v1.HeadscaleService/ExpireNode"
    24| 	HeadscaleService_RenameNode_FullMethodName       = "/headscale.v1.HeadscaleService/RenameNode"
    25| 	HeadscaleService_ListNodes_FullMethodName        = "/headscale.v1.HeadscaleService/ListNodes"
    26| 	HeadscaleService_MoveNode_FullMethodName         = "/headscale.v1.HeadscaleService/MoveNode"
    27| 	HeadscaleService_BackfillNodeIPs_FullMethodName  = "/headscale.v1.HeadscaleService/BackfillNodeIPs"
    28| 	HeadscaleService_GetRoutes_FullMethodName        = "/headscale.v1.HeadscaleService/GetRoutes"
    29| 	HeadscaleService_EnableRoute_FullMethodName      = "/headscale.v1.HeadscaleService/EnableRoute"
    30| 	HeadscaleService_DisableRoute_FullMethodName     = "/headscale.v1.HeadscaleService/DisableRoute"
    31| 	HeadscaleService_GetNodeRoutes_FullMethodName    = "/headscale.v1.HeadscaleService/GetNodeRoutes"
    32| 	HeadscaleService_DeleteRoute_FullMethodName      = "/headscale.v1.HeadscaleService/DeleteRoute"
    33| 	HeadscaleService_CreateApiKey_FullMethodName     = "/headscale.v1.HeadscaleService/CreateApiKey"
    34| 	HeadscaleService_ExpireApiKey_FullMethodName     = "/headscale.v1.HeadscaleService/ExpireApiKey"
    35| 	HeadscaleService_ListApiKeys_FullMethodName      = "/headscale.v1.HeadscaleService/ListApiKeys"
    36| 	HeadscaleService_DeleteApiKey_FullMethodName     = "/headscale.v1.HeadscaleService/DeleteApiKey"
    37| 	HeadscaleService_GetPolicy_FullMethodName        = "/headscale.v1.HeadscaleService/GetPolicy"
    38| 	HeadscaleService_SetPolicy_FullMethodName        = "/headscale.v1.HeadscaleService/SetPolicy"
    39| )
    40| type HeadscaleServiceClient interface {
    41| 	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
    42| 	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
    43| 	RenameUser(ctx context.Context, in *RenameUserRequest, opts ...grpc.CallOption) (*RenameUserResponse, error)
    44| 	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
    45| 	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
    46| 	CreatePreAuthKey(ctx context.Context, in *CreatePreAuthKeyRequest, opts ...grpc.CallOption) (*CreatePreAuthKeyResponse, error)
    47| 	ExpirePreAuthKey(ctx context.Context, in *ExpirePreAuthKeyRequest, opts ...grpc.CallOption) (*ExpirePreAuthKeyResponse, error)
    48| 	ListPreAuthKeys(ctx context.Context, in *ListPreAuthKeysRequest, opts ...grpc.CallOption) (*ListPreAuthKeysResponse, error)
    49| 	DebugCreateNode(ctx context.Context, in *DebugCreateNodeRequest, opts ...grpc.CallOption) (*DebugCreateNodeResponse, error)
    50| 	GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error)
    51| 	SetTags(ctx context.Context, in *SetTagsRequest, opts ...grpc.CallOption) (*SetTagsResponse, error)
    52| 	RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error)
    53| 	DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error)
    54| 	ExpireNode(ctx context.Context, in *ExpireNodeRequest, opts ...grpc.CallOption) (*ExpireNodeResponse, error)
    55| 	RenameNode(ctx context.Context, in *RenameNodeRequest, opts ...grpc.CallOption) (*RenameNodeResponse, error)
    56| 	ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error)
    57| 	MoveNode(ctx context.Context, in *MoveNodeRequest, opts ...grpc.CallOption) (*MoveNodeResponse, error)
    58| 	BackfillNodeIPs(ctx context.Context, in *BackfillNodeIPsRequest, opts ...grpc.CallOption) (*BackfillNodeIPsResponse, error)
    59| 	GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (*GetRoutesResponse, error)
    60| 	EnableRoute(ctx context.Context, in *EnableRouteRequest, opts ...grpc.CallOption) (*EnableRouteResponse, error)
    61| 	DisableRoute(ctx context.Context, in *DisableRouteRequest, opts ...grpc.CallOption) (*DisableRouteResponse, error)
    62| 	GetNodeRoutes(ctx context.Context, in *GetNodeRoutesRequest, opts ...grpc.CallOption) (*GetNodeRoutesResponse, error)
    63| 	DeleteRoute(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*DeleteRouteResponse, error)
    64| 	CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error)
    65| 	ExpireApiKey(ctx context.Context, in *ExpireApiKeyRequest, opts ...grpc.CallOption) (*ExpireApiKeyResponse, error)
    66| 	ListApiKeys(ctx context.Context, in *ListApiKeysRequest, opts ...grpc.CallOption) (*ListApiKeysResponse, error)
    67| 	DeleteApiKey(ctx context.Context, in *DeleteApiKeyRequest, opts ...grpc.CallOption) (*DeleteApiKeyResponse, error)
    68| 	GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error)
    69| 	SetPolicy(ctx context.Context, in *SetPolicyRequest, opts ...grpc.CallOption) (*SetPolicyResponse, error)
    70| }
    71| type headscaleServiceClient struct {
    72| 	cc grpc.ClientConnInterface
    73| }
    74| func NewHeadscaleServiceClient(cc grpc.ClientConnInterface) HeadscaleServiceClient {
    75| 	return &headscaleServiceClient{cc}
    76| }
    77| func (c *headscaleServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
    78| 	out := new(GetUserResponse)
    79| 	err := c.cc.Invoke(ctx, HeadscaleService_GetUser_FullMethodName, in, out, opts...)
    80| 	if err != nil {
    81| 		return nil, err
    82| 	}
    83| 	return out, nil
    84| }
    85| func (c *headscaleServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
    86| 	out := new(CreateUserResponse)
    87| 	err := c.cc.Invoke(ctx, HeadscaleService_CreateUser_FullMethodName, in, out, opts...)
    88| 	if err != nil {
    89| 		return nil, err

# --- HUNK 2: Lines 121-448 ---
   121| 		return nil, err
   122| 	}
   123| 	return out, nil
   124| }
   125| func (c *headscaleServiceClient) ExpirePreAuthKey(ctx context.Context, in *ExpirePreAuthKeyRequest, opts ...grpc.CallOption) (*ExpirePreAuthKeyResponse, error) {
   126| 	out := new(ExpirePreAuthKeyResponse)
   127| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpirePreAuthKey_FullMethodName, in, out, opts...)
   128| 	if err != nil {
   129| 		return nil, err
   130| 	}
   131| 	return out, nil
   132| }
   133| func (c *headscaleServiceClient) ListPreAuthKeys(ctx context.Context, in *ListPreAuthKeysRequest, opts ...grpc.CallOption) (*ListPreAuthKeysResponse, error) {
   134| 	out := new(ListPreAuthKeysResponse)
   135| 	err := c.cc.Invoke(ctx, HeadscaleService_ListPreAuthKeys_FullMethodName, in, out, opts...)
   136| 	if err != nil {
   137| 		return nil, err
   138| 	}
   139| 	return out, nil
   140| }
   141| func (c *headscaleServiceClient) DebugCreateNode(ctx context.Context, in *DebugCreateNodeRequest, opts ...grpc.CallOption) (*DebugCreateNodeResponse, error) {
   142| 	out := new(DebugCreateNodeResponse)
   143| 	err := c.cc.Invoke(ctx, HeadscaleService_DebugCreateNode_FullMethodName, in, out, opts...)
   144| 	if err != nil {
   145| 		return nil, err
   146| 	}
   147| 	return out, nil
   148| }
   149| func (c *headscaleServiceClient) GetNode(ctx context.Context, in *GetNodeRequest, opts ...grpc.CallOption) (*GetNodeResponse, error) {
   150| 	out := new(GetNodeResponse)
   151| 	err := c.cc.Invoke(ctx, HeadscaleService_GetNode_FullMethodName, in, out, opts...)
   152| 	if err != nil {
   153| 		return nil, err
   154| 	}
   155| 	return out, nil
   156| }
   157| func (c *headscaleServiceClient) SetTags(ctx context.Context, in *SetTagsRequest, opts ...grpc.CallOption) (*SetTagsResponse, error) {
   158| 	out := new(SetTagsResponse)
   159| 	err := c.cc.Invoke(ctx, HeadscaleService_SetTags_FullMethodName, in, out, opts...)
   160| 	if err != nil {
   161| 		return nil, err
   162| 	}
   163| 	return out, nil
   164| }
   165| func (c *headscaleServiceClient) RegisterNode(ctx context.Context, in *RegisterNodeRequest, opts ...grpc.CallOption) (*RegisterNodeResponse, error) {
   166| 	out := new(RegisterNodeResponse)
   167| 	err := c.cc.Invoke(ctx, HeadscaleService_RegisterNode_FullMethodName, in, out, opts...)
   168| 	if err != nil {
   169| 		return nil, err
   170| 	}
   171| 	return out, nil
   172| }
   173| func (c *headscaleServiceClient) DeleteNode(ctx context.Context, in *DeleteNodeRequest, opts ...grpc.CallOption) (*DeleteNodeResponse, error) {
   174| 	out := new(DeleteNodeResponse)
   175| 	err := c.cc.Invoke(ctx, HeadscaleService_DeleteNode_FullMethodName, in, out, opts...)
   176| 	if err != nil {
   177| 		return nil, err
   178| 	}
   179| 	return out, nil
   180| }
   181| func (c *headscaleServiceClient) ExpireNode(ctx context.Context, in *ExpireNodeRequest, opts ...grpc.CallOption) (*ExpireNodeResponse, error) {
   182| 	out := new(ExpireNodeResponse)
   183| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpireNode_FullMethodName, in, out, opts...)
   184| 	if err != nil {
   185| 		return nil, err
   186| 	}
   187| 	return out, nil
   188| }
   189| func (c *headscaleServiceClient) RenameNode(ctx context.Context, in *RenameNodeRequest, opts ...grpc.CallOption) (*RenameNodeResponse, error) {
   190| 	out := new(RenameNodeResponse)
   191| 	err := c.cc.Invoke(ctx, HeadscaleService_RenameNode_FullMethodName, in, out, opts...)
   192| 	if err != nil {
   193| 		return nil, err
   194| 	}
   195| 	return out, nil
   196| }
   197| func (c *headscaleServiceClient) ListNodes(ctx context.Context, in *ListNodesRequest, opts ...grpc.CallOption) (*ListNodesResponse, error) {
   198| 	out := new(ListNodesResponse)
   199| 	err := c.cc.Invoke(ctx, HeadscaleService_ListNodes_FullMethodName, in, out, opts...)
   200| 	if err != nil {
   201| 		return nil, err
   202| 	}
   203| 	return out, nil
   204| }
   205| func (c *headscaleServiceClient) MoveNode(ctx context.Context, in *MoveNodeRequest, opts ...grpc.CallOption) (*MoveNodeResponse, error) {
   206| 	out := new(MoveNodeResponse)
   207| 	err := c.cc.Invoke(ctx, HeadscaleService_MoveNode_FullMethodName, in, out, opts...)
   208| 	if err != nil {
   209| 		return nil, err
   210| 	}
   211| 	return out, nil
   212| }
   213| func (c *headscaleServiceClient) BackfillNodeIPs(ctx context.Context, in *BackfillNodeIPsRequest, opts ...grpc.CallOption) (*BackfillNodeIPsResponse, error) {
   214| 	out := new(BackfillNodeIPsResponse)
   215| 	err := c.cc.Invoke(ctx, HeadscaleService_BackfillNodeIPs_FullMethodName, in, out, opts...)
   216| 	if err != nil {
   217| 		return nil, err
   218| 	}
   219| 	return out, nil
   220| }
   221| func (c *headscaleServiceClient) GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (*GetRoutesResponse, error) {
   222| 	out := new(GetRoutesResponse)
   223| 	err := c.cc.Invoke(ctx, HeadscaleService_GetRoutes_FullMethodName, in, out, opts...)
   224| 	if err != nil {
   225| 		return nil, err
   226| 	}
   227| 	return out, nil
   228| }
   229| func (c *headscaleServiceClient) EnableRoute(ctx context.Context, in *EnableRouteRequest, opts ...grpc.CallOption) (*EnableRouteResponse, error) {
   230| 	out := new(EnableRouteResponse)
   231| 	err := c.cc.Invoke(ctx, HeadscaleService_EnableRoute_FullMethodName, in, out, opts...)
   232| 	if err != nil {
   233| 		return nil, err
   234| 	}
   235| 	return out, nil
   236| }
   237| func (c *headscaleServiceClient) DisableRoute(ctx context.Context, in *DisableRouteRequest, opts ...grpc.CallOption) (*DisableRouteResponse, error) {
   238| 	out := new(DisableRouteResponse)
   239| 	err := c.cc.Invoke(ctx, HeadscaleService_DisableRoute_FullMethodName, in, out, opts...)
   240| 	if err != nil {
   241| 		return nil, err
   242| 	}
   243| 	return out, nil
   244| }
   245| func (c *headscaleServiceClient) GetNodeRoutes(ctx context.Context, in *GetNodeRoutesRequest, opts ...grpc.CallOption) (*GetNodeRoutesResponse, error) {
   246| 	out := new(GetNodeRoutesResponse)
   247| 	err := c.cc.Invoke(ctx, HeadscaleService_GetNodeRoutes_FullMethodName, in, out, opts...)
   248| 	if err != nil {
   249| 		return nil, err
   250| 	}
   251| 	return out, nil
   252| }
   253| func (c *headscaleServiceClient) DeleteRoute(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*DeleteRouteResponse, error) {
   254| 	out := new(DeleteRouteResponse)
   255| 	err := c.cc.Invoke(ctx, HeadscaleService_DeleteRoute_FullMethodName, in, out, opts...)
   256| 	if err != nil {
   257| 		return nil, err
   258| 	}
   259| 	return out, nil
   260| }
   261| func (c *headscaleServiceClient) CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error) {
   262| 	out := new(CreateApiKeyResponse)
   263| 	err := c.cc.Invoke(ctx, HeadscaleService_CreateApiKey_FullMethodName, in, out, opts...)
   264| 	if err != nil {
   265| 		return nil, err
   266| 	}
   267| 	return out, nil
   268| }
   269| func (c *headscaleServiceClient) ExpireApiKey(ctx context.Context, in *ExpireApiKeyRequest, opts ...grpc.CallOption) (*ExpireApiKeyResponse, error) {
   270| 	out := new(ExpireApiKeyResponse)
   271| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpireApiKey_FullMethodName, in, out, opts...)
   272| 	if err != nil {
   273| 		return nil, err
   274| 	}
   275| 	return out, nil
   276| }
   277| func (c *headscaleServiceClient) ListApiKeys(ctx context.Context, in *ListApiKeysRequest, opts ...grpc.CallOption) (*ListApiKeysResponse, error) {
   278| 	out := new(ListApiKeysResponse)
   279| 	err := c.cc.Invoke(ctx, HeadscaleService_ListApiKeys_FullMethodName, in, out, opts...)
   280| 	if err != nil {
   281| 		return nil, err
   282| 	}
   283| 	return out, nil
   284| }
   285| func (c *headscaleServiceClient) DeleteApiKey(ctx context.Context, in *DeleteApiKeyRequest, opts ...grpc.CallOption) (*DeleteApiKeyResponse, error) {
   286| 	out := new(DeleteApiKeyResponse)
   287| 	err := c.cc.Invoke(ctx, HeadscaleService_DeleteApiKey_FullMethodName, in, out, opts...)
   288| 	if err != nil {
   289| 		return nil, err
   290| 	}
   291| 	return out, nil
   292| }
   293| func (c *headscaleServiceClient) GetPolicy(ctx context.Context, in *GetPolicyRequest, opts ...grpc.CallOption) (*GetPolicyResponse, error) {
   294| 	out := new(GetPolicyResponse)
   295| 	err := c.cc.Invoke(ctx, HeadscaleService_GetPolicy_FullMethodName, in, out, opts...)
   296| 	if err != nil {
   297| 		return nil, err
   298| 	}
   299| 	return out, nil
   300| }
   301| func (c *headscaleServiceClient) SetPolicy(ctx context.Context, in *SetPolicyRequest, opts ...grpc.CallOption) (*SetPolicyResponse, error) {
   302| 	out := new(SetPolicyResponse)
   303| 	err := c.cc.Invoke(ctx, HeadscaleService_SetPolicy_FullMethodName, in, out, opts...)
   304| 	if err != nil {
   305| 		return nil, err
   306| 	}
   307| 	return out, nil
   308| }
   309| type HeadscaleServiceServer interface {
   310| 	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
   311| 	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
   312| 	RenameUser(context.Context, *RenameUserRequest) (*RenameUserResponse, error)
   313| 	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
   314| 	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
   315| 	CreatePreAuthKey(context.Context, *CreatePreAuthKeyRequest) (*CreatePreAuthKeyResponse, error)
   316| 	ExpirePreAuthKey(context.Context, *ExpirePreAuthKeyRequest) (*ExpirePreAuthKeyResponse, error)
   317| 	ListPreAuthKeys(context.Context, *ListPreAuthKeysRequest) (*ListPreAuthKeysResponse, error)
   318| 	DebugCreateNode(context.Context, *DebugCreateNodeRequest) (*DebugCreateNodeResponse, error)
   319| 	GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error)
   320| 	SetTags(context.Context, *SetTagsRequest) (*SetTagsResponse, error)
   321| 	RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error)
   322| 	DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error)
   323| 	ExpireNode(context.Context, *ExpireNodeRequest) (*ExpireNodeResponse, error)
   324| 	RenameNode(context.Context, *RenameNodeRequest) (*RenameNodeResponse, error)
   325| 	ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error)
   326| 	MoveNode(context.Context, *MoveNodeRequest) (*MoveNodeResponse, error)
   327| 	BackfillNodeIPs(context.Context, *BackfillNodeIPsRequest) (*BackfillNodeIPsResponse, error)
   328| 	GetRoutes(context.Context, *GetRoutesRequest) (*GetRoutesResponse, error)
   329| 	EnableRoute(context.Context, *EnableRouteRequest) (*EnableRouteResponse, error)
   330| 	DisableRoute(context.Context, *DisableRouteRequest) (*DisableRouteResponse, error)
   331| 	GetNodeRoutes(context.Context, *GetNodeRoutesRequest) (*GetNodeRoutesResponse, error)
   332| 	DeleteRoute(context.Context, *DeleteRouteRequest) (*DeleteRouteResponse, error)
   333| 	CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error)
   334| 	ExpireApiKey(context.Context, *ExpireApiKeyRequest) (*ExpireApiKeyResponse, error)
   335| 	ListApiKeys(context.Context, *ListApiKeysRequest) (*ListApiKeysResponse, error)
   336| 	DeleteApiKey(context.Context, *DeleteApiKeyRequest) (*DeleteApiKeyResponse, error)
   337| 	GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error)
   338| 	SetPolicy(context.Context, *SetPolicyRequest) (*SetPolicyResponse, error)
   339| 	mustEmbedUnimplementedHeadscaleServiceServer()
   340| }
   341| type UnimplementedHeadscaleServiceServer struct {
   342| }
   343| func (UnimplementedHeadscaleServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
   344| 	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
   345| }
   346| func (UnimplementedHeadscaleServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
   347| 	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
   348| }
   349| func (UnimplementedHeadscaleServiceServer) RenameUser(context.Context, *RenameUserRequest) (*RenameUserResponse, error) {
   350| 	return nil, status.Errorf(codes.Unimplemented, "method RenameUser not implemented")
   351| }
   352| func (UnimplementedHeadscaleServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
   353| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
   354| }
   355| func (UnimplementedHeadscaleServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
   356| 	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
   357| }
   358| func (UnimplementedHeadscaleServiceServer) CreatePreAuthKey(context.Context, *CreatePreAuthKeyRequest) (*CreatePreAuthKeyResponse, error) {
   359| 	return nil, status.Errorf(codes.Unimplemented, "method CreatePreAuthKey not implemented")
   360| }
   361| func (UnimplementedHeadscaleServiceServer) ExpirePreAuthKey(context.Context, *ExpirePreAuthKeyRequest) (*ExpirePreAuthKeyResponse, error) {
   362| 	return nil, status.Errorf(codes.Unimplemented, "method ExpirePreAuthKey not implemented")
   363| }
   364| func (UnimplementedHeadscaleServiceServer) ListPreAuthKeys(context.Context, *ListPreAuthKeysRequest) (*ListPreAuthKeysResponse, error) {
   365| 	return nil, status.Errorf(codes.Unimplemented, "method ListPreAuthKeys not implemented")
   366| }
   367| func (UnimplementedHeadscaleServiceServer) DebugCreateNode(context.Context, *DebugCreateNodeRequest) (*DebugCreateNodeResponse, error) {
   368| 	return nil, status.Errorf(codes.Unimplemented, "method DebugCreateNode not implemented")
   369| }
   370| func (UnimplementedHeadscaleServiceServer) GetNode(context.Context, *GetNodeRequest) (*GetNodeResponse, error) {
   371| 	return nil, status.Errorf(codes.Unimplemented, "method GetNode not implemented")
   372| }
   373| func (UnimplementedHeadscaleServiceServer) SetTags(context.Context, *SetTagsRequest) (*SetTagsResponse, error) {
   374| 	return nil, status.Errorf(codes.Unimplemented, "method SetTags not implemented")
   375| }
   376| func (UnimplementedHeadscaleServiceServer) RegisterNode(context.Context, *RegisterNodeRequest) (*RegisterNodeResponse, error) {
   377| 	return nil, status.Errorf(codes.Unimplemented, "method RegisterNode not implemented")
   378| }
   379| func (UnimplementedHeadscaleServiceServer) DeleteNode(context.Context, *DeleteNodeRequest) (*DeleteNodeResponse, error) {
   380| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
   381| }
   382| func (UnimplementedHeadscaleServiceServer) ExpireNode(context.Context, *ExpireNodeRequest) (*ExpireNodeResponse, error) {
   383| 	return nil, status.Errorf(codes.Unimplemented, "method ExpireNode not implemented")
   384| }
   385| func (UnimplementedHeadscaleServiceServer) RenameNode(context.Context, *RenameNodeRequest) (*RenameNodeResponse, error) {
   386| 	return nil, status.Errorf(codes.Unimplemented, "method RenameNode not implemented")
   387| }
   388| func (UnimplementedHeadscaleServiceServer) ListNodes(context.Context, *ListNodesRequest) (*ListNodesResponse, error) {
   389| 	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
   390| }
   391| func (UnimplementedHeadscaleServiceServer) MoveNode(context.Context, *MoveNodeRequest) (*MoveNodeResponse, error) {
   392| 	return nil, status.Errorf(codes.Unimplemented, "method MoveNode not implemented")
   393| }
   394| func (UnimplementedHeadscaleServiceServer) BackfillNodeIPs(context.Context, *BackfillNodeIPsRequest) (*BackfillNodeIPsResponse, error) {
   395| 	return nil, status.Errorf(codes.Unimplemented, "method BackfillNodeIPs not implemented")
   396| }
   397| func (UnimplementedHeadscaleServiceServer) GetRoutes(context.Context, *GetRoutesRequest) (*GetRoutesResponse, error) {
   398| 	return nil, status.Errorf(codes.Unimplemented, "method GetRoutes not implemented")
   399| }
   400| func (UnimplementedHeadscaleServiceServer) EnableRoute(context.Context, *EnableRouteRequest) (*EnableRouteResponse, error) {
   401| 	return nil, status.Errorf(codes.Unimplemented, "method EnableRoute not implemented")
   402| }
   403| func (UnimplementedHeadscaleServiceServer) DisableRoute(context.Context, *DisableRouteRequest) (*DisableRouteResponse, error) {
   404| 	return nil, status.Errorf(codes.Unimplemented, "method DisableRoute not implemented")
   405| }
   406| func (UnimplementedHeadscaleServiceServer) GetNodeRoutes(context.Context, *GetNodeRoutesRequest) (*GetNodeRoutesResponse, error) {
   407| 	return nil, status.Errorf(codes.Unimplemented, "method GetNodeRoutes not implemented")
   408| }
   409| func (UnimplementedHeadscaleServiceServer) DeleteRoute(context.Context, *DeleteRouteRequest) (*DeleteRouteResponse, error) {
   410| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoute not implemented")
   411| }
   412| func (UnimplementedHeadscaleServiceServer) CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error) {
   413| 	return nil, status.Errorf(codes.Unimplemented, "method CreateApiKey not implemented")
   414| }
   415| func (UnimplementedHeadscaleServiceServer) ExpireApiKey(context.Context, *ExpireApiKeyRequest) (*ExpireApiKeyResponse, error) {
   416| 	return nil, status.Errorf(codes.Unimplemented, "method ExpireApiKey not implemented")
   417| }
   418| func (UnimplementedHeadscaleServiceServer) ListApiKeys(context.Context, *ListApiKeysRequest) (*ListApiKeysResponse, error) {
   419| 	return nil, status.Errorf(codes.Unimplemented, "method ListApiKeys not implemented")
   420| }
   421| func (UnimplementedHeadscaleServiceServer) DeleteApiKey(context.Context, *DeleteApiKeyRequest) (*DeleteApiKeyResponse, error) {
   422| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteApiKey not implemented")
   423| }
   424| func (UnimplementedHeadscaleServiceServer) GetPolicy(context.Context, *GetPolicyRequest) (*GetPolicyResponse, error) {
   425| 	return nil, status.Errorf(codes.Unimplemented, "method GetPolicy not implemented")
   426| }
   427| func (UnimplementedHeadscaleServiceServer) SetPolicy(context.Context, *SetPolicyRequest) (*SetPolicyResponse, error) {
   428| 	return nil, status.Errorf(codes.Unimplemented, "method SetPolicy not implemented")
   429| }
   430| func (UnimplementedHeadscaleServiceServer) mustEmbedUnimplementedHeadscaleServiceServer() {}
   431| type UnsafeHeadscaleServiceServer interface {
   432| 	mustEmbedUnimplementedHeadscaleServiceServer()
   433| }
   434| func RegisterHeadscaleServiceServer(s grpc.ServiceRegistrar, srv HeadscaleServiceServer) {
   435| 	s.RegisterService(&HeadscaleService_ServiceDesc, srv)
   436| }
   437| func _HeadscaleService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   438| 	in := new(GetUserRequest)
   439| 	if err := dec(in); err != nil {
   440| 		return nil, err
   441| 	}
   442| 	if interceptor == nil {
   443| 		return srv.(HeadscaleServiceServer).GetUser(ctx, in)
   444| 	}
   445| 	info := &grpc.UnaryServerInfo{
   446| 		Server:     srv,
   447| 		FullMethod: HeadscaleService_GetUser_FullMethodName,
   448| 	}

# --- HUNK 3: Lines 553-759 ---
   553| 	}
   554| 	return interceptor(ctx, in, info, handler)
   555| }
   556| func _HeadscaleService_ListPreAuthKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   557| 	in := new(ListPreAuthKeysRequest)
   558| 	if err := dec(in); err != nil {
   559| 		return nil, err
   560| 	}
   561| 	if interceptor == nil {
   562| 		return srv.(HeadscaleServiceServer).ListPreAuthKeys(ctx, in)
   563| 	}
   564| 	info := &grpc.UnaryServerInfo{
   565| 		Server:     srv,
   566| 		FullMethod: HeadscaleService_ListPreAuthKeys_FullMethodName,
   567| 	}
   568| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   569| 		return srv.(HeadscaleServiceServer).ListPreAuthKeys(ctx, req.(*ListPreAuthKeysRequest))
   570| 	}
   571| 	return interceptor(ctx, in, info, handler)
   572| }
   573| func _HeadscaleService_DebugCreateNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   574| 	in := new(DebugCreateNodeRequest)
   575| 	if err := dec(in); err != nil {
   576| 		return nil, err
   577| 	}
   578| 	if interceptor == nil {
   579| 		return srv.(HeadscaleServiceServer).DebugCreateNode(ctx, in)
   580| 	}
   581| 	info := &grpc.UnaryServerInfo{
   582| 		Server:     srv,
   583| 		FullMethod: HeadscaleService_DebugCreateNode_FullMethodName,
   584| 	}
   585| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   586| 		return srv.(HeadscaleServiceServer).DebugCreateNode(ctx, req.(*DebugCreateNodeRequest))
   587| 	}
   588| 	return interceptor(ctx, in, info, handler)
   589| }
   590| func _HeadscaleService_GetNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   591| 	in := new(GetNodeRequest)
   592| 	if err := dec(in); err != nil {
   593| 		return nil, err
   594| 	}
   595| 	if interceptor == nil {
   596| 		return srv.(HeadscaleServiceServer).GetNode(ctx, in)
   597| 	}
   598| 	info := &grpc.UnaryServerInfo{
   599| 		Server:     srv,
   600| 		FullMethod: HeadscaleService_GetNode_FullMethodName,
   601| 	}
   602| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   603| 		return srv.(HeadscaleServiceServer).GetNode(ctx, req.(*GetNodeRequest))
   604| 	}
   605| 	return interceptor(ctx, in, info, handler)
   606| }
   607| func _HeadscaleService_SetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   608| 	in := new(SetTagsRequest)
   609| 	if err := dec(in); err != nil {
   610| 		return nil, err
   611| 	}
   612| 	if interceptor == nil {
   613| 		return srv.(HeadscaleServiceServer).SetTags(ctx, in)
   614| 	}
   615| 	info := &grpc.UnaryServerInfo{
   616| 		Server:     srv,
   617| 		FullMethod: HeadscaleService_SetTags_FullMethodName,
   618| 	}
   619| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   620| 		return srv.(HeadscaleServiceServer).SetTags(ctx, req.(*SetTagsRequest))
   621| 	}
   622| 	return interceptor(ctx, in, info, handler)
   623| }
   624| func _HeadscaleService_RegisterNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   625| 	in := new(RegisterNodeRequest)
   626| 	if err := dec(in); err != nil {
   627| 		return nil, err
   628| 	}
   629| 	if interceptor == nil {
   630| 		return srv.(HeadscaleServiceServer).RegisterNode(ctx, in)
   631| 	}
   632| 	info := &grpc.UnaryServerInfo{
   633| 		Server:     srv,
   634| 		FullMethod: HeadscaleService_RegisterNode_FullMethodName,
   635| 	}
   636| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   637| 		return srv.(HeadscaleServiceServer).RegisterNode(ctx, req.(*RegisterNodeRequest))
   638| 	}
   639| 	return interceptor(ctx, in, info, handler)
   640| }
   641| func _HeadscaleService_DeleteNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   642| 	in := new(DeleteNodeRequest)
   643| 	if err := dec(in); err != nil {
   644| 		return nil, err
   645| 	}
   646| 	if interceptor == nil {
   647| 		return srv.(HeadscaleServiceServer).DeleteNode(ctx, in)
   648| 	}
   649| 	info := &grpc.UnaryServerInfo{
   650| 		Server:     srv,
   651| 		FullMethod: HeadscaleService_DeleteNode_FullMethodName,
   652| 	}
   653| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   654| 		return srv.(HeadscaleServiceServer).DeleteNode(ctx, req.(*DeleteNodeRequest))
   655| 	}
   656| 	return interceptor(ctx, in, info, handler)
   657| }
   658| func _HeadscaleService_ExpireNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   659| 	in := new(ExpireNodeRequest)
   660| 	if err := dec(in); err != nil {
   661| 		return nil, err
   662| 	}
   663| 	if interceptor == nil {
   664| 		return srv.(HeadscaleServiceServer).ExpireNode(ctx, in)
   665| 	}
   666| 	info := &grpc.UnaryServerInfo{
   667| 		Server:     srv,
   668| 		FullMethod: HeadscaleService_ExpireNode_FullMethodName,
   669| 	}
   670| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   671| 		return srv.(HeadscaleServiceServer).ExpireNode(ctx, req.(*ExpireNodeRequest))
   672| 	}
   673| 	return interceptor(ctx, in, info, handler)
   674| }
   675| func _HeadscaleService_RenameNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   676| 	in := new(RenameNodeRequest)
   677| 	if err := dec(in); err != nil {
   678| 		return nil, err
   679| 	}
   680| 	if interceptor == nil {
   681| 		return srv.(HeadscaleServiceServer).RenameNode(ctx, in)
   682| 	}
   683| 	info := &grpc.UnaryServerInfo{
   684| 		Server:     srv,
   685| 		FullMethod: HeadscaleService_RenameNode_FullMethodName,
   686| 	}
   687| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   688| 		return srv.(HeadscaleServiceServer).RenameNode(ctx, req.(*RenameNodeRequest))
   689| 	}
   690| 	return interceptor(ctx, in, info, handler)
   691| }
   692| func _HeadscaleService_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   693| 	in := new(ListNodesRequest)
   694| 	if err := dec(in); err != nil {
   695| 		return nil, err
   696| 	}
   697| 	if interceptor == nil {
   698| 		return srv.(HeadscaleServiceServer).ListNodes(ctx, in)
   699| 	}
   700| 	info := &grpc.UnaryServerInfo{
   701| 		Server:     srv,
   702| 		FullMethod: HeadscaleService_ListNodes_FullMethodName,
   703| 	}
   704| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   705| 		return srv.(HeadscaleServiceServer).ListNodes(ctx, req.(*ListNodesRequest))
   706| 	}
   707| 	return interceptor(ctx, in, info, handler)
   708| }
   709| func _HeadscaleService_MoveNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   710| 	in := new(MoveNodeRequest)
   711| 	if err := dec(in); err != nil {
   712| 		return nil, err
   713| 	}
   714| 	if interceptor == nil {
   715| 		return srv.(HeadscaleServiceServer).MoveNode(ctx, in)
   716| 	}
   717| 	info := &grpc.UnaryServerInfo{
   718| 		Server:     srv,
   719| 		FullMethod: HeadscaleService_MoveNode_FullMethodName,
   720| 	}
   721| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   722| 		return srv.(HeadscaleServiceServer).MoveNode(ctx, req.(*MoveNodeRequest))
   723| 	}
   724| 	return interceptor(ctx, in, info, handler)
   725| }
   726| func _HeadscaleService_BackfillNodeIPs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   727| 	in := new(BackfillNodeIPsRequest)
   728| 	if err := dec(in); err != nil {
   729| 		return nil, err
   730| 	}
   731| 	if interceptor == nil {
   732| 		return srv.(HeadscaleServiceServer).BackfillNodeIPs(ctx, in)
   733| 	}
   734| 	info := &grpc.UnaryServerInfo{
   735| 		Server:     srv,
   736| 		FullMethod: HeadscaleService_BackfillNodeIPs_FullMethodName,
   737| 	}
   738| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   739| 		return srv.(HeadscaleServiceServer).BackfillNodeIPs(ctx, req.(*BackfillNodeIPsRequest))
   740| 	}
   741| 	return interceptor(ctx, in, info, handler)
   742| }
   743| func _HeadscaleService_GetRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   744| 	in := new(GetRoutesRequest)
   745| 	if err := dec(in); err != nil {
   746| 		return nil, err
   747| 	}
   748| 	if interceptor == nil {
   749| 		return srv.(HeadscaleServiceServer).GetRoutes(ctx, in)
   750| 	}
   751| 	info := &grpc.UnaryServerInfo{
   752| 		Server:     srv,
   753| 		FullMethod: HeadscaleService_GetRoutes_FullMethodName,
   754| 	}
   755| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   756| 		return srv.(HeadscaleServiceServer).GetRoutes(ctx, req.(*GetRoutesRequest))
   757| 	}
   758| 	return interceptor(ctx, in, info, handler)
   759| }

# --- HUNK 4: Lines 774-827 ---
   774| 	}
   775| 	return interceptor(ctx, in, info, handler)
   776| }
   777| func _HeadscaleService_DisableRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   778| 	in := new(DisableRouteRequest)
   779| 	if err := dec(in); err != nil {
   780| 		return nil, err
   781| 	}
   782| 	if interceptor == nil {
   783| 		return srv.(HeadscaleServiceServer).DisableRoute(ctx, in)
   784| 	}
   785| 	info := &grpc.UnaryServerInfo{
   786| 		Server:     srv,
   787| 		FullMethod: HeadscaleService_DisableRoute_FullMethodName,
   788| 	}
   789| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   790| 		return srv.(HeadscaleServiceServer).DisableRoute(ctx, req.(*DisableRouteRequest))
   791| 	}
   792| 	return interceptor(ctx, in, info, handler)
   793| }
   794| func _HeadscaleService_GetNodeRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   795| 	in := new(GetNodeRoutesRequest)
   796| 	if err := dec(in); err != nil {
   797| 		return nil, err
   798| 	}
   799| 	if interceptor == nil {
   800| 		return srv.(HeadscaleServiceServer).GetNodeRoutes(ctx, in)
   801| 	}
   802| 	info := &grpc.UnaryServerInfo{
   803| 		Server:     srv,
   804| 		FullMethod: HeadscaleService_GetNodeRoutes_FullMethodName,
   805| 	}
   806| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   807| 		return srv.(HeadscaleServiceServer).GetNodeRoutes(ctx, req.(*GetNodeRoutesRequest))
   808| 	}
   809| 	return interceptor(ctx, in, info, handler)
   810| }
   811| func _HeadscaleService_DeleteRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   812| 	in := new(DeleteRouteRequest)
   813| 	if err := dec(in); err != nil {
   814| 		return nil, err
   815| 	}
   816| 	if interceptor == nil {
   817| 		return srv.(HeadscaleServiceServer).DeleteRoute(ctx, in)
   818| 	}
   819| 	info := &grpc.UnaryServerInfo{
   820| 		Server:     srv,
   821| 		FullMethod: HeadscaleService_DeleteRoute_FullMethodName,
   822| 	}
   823| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   824| 		return srv.(HeadscaleServiceServer).DeleteRoute(ctx, req.(*DeleteRouteRequest))
   825| 	}
   826| 	return interceptor(ctx, in, info, handler)
   827| }

# --- HUNK 5: Lines 856-1053 ---
   856| 	}
   857| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   858| 		return srv.(HeadscaleServiceServer).ExpireApiKey(ctx, req.(*ExpireApiKeyRequest))
   859| 	}
   860| 	return interceptor(ctx, in, info, handler)
   861| }
   862| func _HeadscaleService_ListApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   863| 	in := new(ListApiKeysRequest)
   864| 	if err := dec(in); err != nil {
   865| 		return nil, err
   866| 	}
   867| 	if interceptor == nil {
   868| 		return srv.(HeadscaleServiceServer).ListApiKeys(ctx, in)
   869| 	}
   870| 	info := &grpc.UnaryServerInfo{
   871| 		Server:     srv,
   872| 		FullMethod: HeadscaleService_ListApiKeys_FullMethodName,
   873| 	}
   874| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   875| 		return srv.(HeadscaleServiceServer).ListApiKeys(ctx, req.(*ListApiKeysRequest))
   876| 	}
   877| 	return interceptor(ctx, in, info, handler)
   878| }
   879| func _HeadscaleService_DeleteApiKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   880| 	in := new(DeleteApiKeyRequest)
   881| 	if err := dec(in); err != nil {
   882| 		return nil, err
   883| 	}
   884| 	if interceptor == nil {
   885| 		return srv.(HeadscaleServiceServer).DeleteApiKey(ctx, in)
   886| 	}
   887| 	info := &grpc.UnaryServerInfo{
   888| 		Server:     srv,
   889| 		FullMethod: HeadscaleService_DeleteApiKey_FullMethodName,
   890| 	}
   891| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   892| 		return srv.(HeadscaleServiceServer).DeleteApiKey(ctx, req.(*DeleteApiKeyRequest))
   893| 	}
   894| 	return interceptor(ctx, in, info, handler)
   895| }
   896| func _HeadscaleService_GetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   897| 	in := new(GetPolicyRequest)
   898| 	if err := dec(in); err != nil {
   899| 		return nil, err
   900| 	}
   901| 	if interceptor == nil {
   902| 		return srv.(HeadscaleServiceServer).GetPolicy(ctx, in)
   903| 	}
   904| 	info := &grpc.UnaryServerInfo{
   905| 		Server:     srv,
   906| 		FullMethod: HeadscaleService_GetPolicy_FullMethodName,
   907| 	}
   908| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   909| 		return srv.(HeadscaleServiceServer).GetPolicy(ctx, req.(*GetPolicyRequest))
   910| 	}
   911| 	return interceptor(ctx, in, info, handler)
   912| }
   913| func _HeadscaleService_SetPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   914| 	in := new(SetPolicyRequest)
   915| 	if err := dec(in); err != nil {
   916| 		return nil, err
   917| 	}
   918| 	if interceptor == nil {
   919| 		return srv.(HeadscaleServiceServer).SetPolicy(ctx, in)
   920| 	}
   921| 	info := &grpc.UnaryServerInfo{
   922| 		Server:     srv,
   923| 		FullMethod: HeadscaleService_SetPolicy_FullMethodName,
   924| 	}
   925| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   926| 		return srv.(HeadscaleServiceServer).SetPolicy(ctx, req.(*SetPolicyRequest))
   927| 	}
   928| 	return interceptor(ctx, in, info, handler)
   929| }
   930| var HeadscaleService_ServiceDesc = grpc.ServiceDesc{
   931| 	ServiceName: "headscale.v1.HeadscaleService",
   932| 	HandlerType: (*HeadscaleServiceServer)(nil),
   933| 	Methods: []grpc.MethodDesc{
   934| 		{
   935| 			MethodName: "GetUser",
   936| 			Handler:    _HeadscaleService_GetUser_Handler,
   937| 		},
   938| 		{
   939| 			MethodName: "CreateUser",
   940| 			Handler:    _HeadscaleService_CreateUser_Handler,
   941| 		},
   942| 		{
   943| 			MethodName: "RenameUser",
   944| 			Handler:    _HeadscaleService_RenameUser_Handler,
   945| 		},
   946| 		{
   947| 			MethodName: "DeleteUser",
   948| 			Handler:    _HeadscaleService_DeleteUser_Handler,
   949| 		},
   950| 		{
   951| 			MethodName: "ListUsers",
   952| 			Handler:    _HeadscaleService_ListUsers_Handler,
   953| 		},
   954| 		{
   955| 			MethodName: "CreatePreAuthKey",
   956| 			Handler:    _HeadscaleService_CreatePreAuthKey_Handler,
   957| 		},
   958| 		{
   959| 			MethodName: "ExpirePreAuthKey",
   960| 			Handler:    _HeadscaleService_ExpirePreAuthKey_Handler,
   961| 		},
   962| 		{
   963| 			MethodName: "ListPreAuthKeys",
   964| 			Handler:    _HeadscaleService_ListPreAuthKeys_Handler,
   965| 		},
   966| 		{
   967| 			MethodName: "DebugCreateNode",
   968| 			Handler:    _HeadscaleService_DebugCreateNode_Handler,
   969| 		},
   970| 		{
   971| 			MethodName: "GetNode",
   972| 			Handler:    _HeadscaleService_GetNode_Handler,
   973| 		},
   974| 		{
   975| 			MethodName: "SetTags",
   976| 			Handler:    _HeadscaleService_SetTags_Handler,
   977| 		},
   978| 		{
   979| 			MethodName: "RegisterNode",
   980| 			Handler:    _HeadscaleService_RegisterNode_Handler,
   981| 		},
   982| 		{
   983| 			MethodName: "DeleteNode",
   984| 			Handler:    _HeadscaleService_DeleteNode_Handler,
   985| 		},
   986| 		{
   987| 			MethodName: "ExpireNode",
   988| 			Handler:    _HeadscaleService_ExpireNode_Handler,
   989| 		},
   990| 		{
   991| 			MethodName: "RenameNode",
   992| 			Handler:    _HeadscaleService_RenameNode_Handler,
   993| 		},
   994| 		{
   995| 			MethodName: "ListNodes",
   996| 			Handler:    _HeadscaleService_ListNodes_Handler,
   997| 		},
   998| 		{
   999| 			MethodName: "MoveNode",
  1000| 			Handler:    _HeadscaleService_MoveNode_Handler,
  1001| 		},
  1002| 		{
  1003| 			MethodName: "BackfillNodeIPs",
  1004| 			Handler:    _HeadscaleService_BackfillNodeIPs_Handler,
  1005| 		},
  1006| 		{
  1007| 			MethodName: "GetRoutes",
  1008| 			Handler:    _HeadscaleService_GetRoutes_Handler,
  1009| 		},
  1010| 		{
  1011| 			MethodName: "EnableRoute",
  1012| 			Handler:    _HeadscaleService_EnableRoute_Handler,
  1013| 		},
  1014| 		{
  1015| 			MethodName: "DisableRoute",
  1016| 			Handler:    _HeadscaleService_DisableRoute_Handler,
  1017| 		},
  1018| 		{
  1019| 			MethodName: "GetNodeRoutes",
  1020| 			Handler:    _HeadscaleService_GetNodeRoutes_Handler,
  1021| 		},
  1022| 		{
  1023| 			MethodName: "DeleteRoute",
  1024| 			Handler:    _HeadscaleService_DeleteRoute_Handler,
  1025| 		},
  1026| 		{
  1027| 			MethodName: "CreateApiKey",
  1028| 			Handler:    _HeadscaleService_CreateApiKey_Handler,
  1029| 		},
  1030| 		{
  1031| 			MethodName: "ExpireApiKey",
  1032| 			Handler:    _HeadscaleService_ExpireApiKey_Handler,
  1033| 		},
  1034| 		{
  1035| 			MethodName: "ListApiKeys",
  1036| 			Handler:    _HeadscaleService_ListApiKeys_Handler,
  1037| 		},
  1038| 		{
  1039| 			MethodName: "DeleteApiKey",
  1040| 			Handler:    _HeadscaleService_DeleteApiKey_Handler,
  1041| 		},
  1042| 		{
  1043| 			MethodName: "GetPolicy",
  1044| 			Handler:    _HeadscaleService_GetPolicy_Handler,
  1045| 		},
  1046| 		{
  1047| 			MethodName: "SetPolicy",
  1048| 			Handler:    _HeadscaleService_SetPolicy_Handler,
  1049| 		},
  1050| 	},
  1051| 	Streams:  []grpc.StreamDesc{},
  1052| 	Metadata: "headscale/v1/headscale.proto",
  1053| }


# ====================================================================
# FILE: gen/go/headscale/v1/node.pb.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1484 ---
     1| package v1
     2| import (
     3| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     4| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     5| 	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
     6| 	reflect "reflect"
     7| 	sync "sync"
     8| )
     9| const (
    10| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    11| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    12| )
    13| type RegisterMethod int32
    14| const (
    15| 	RegisterMethod_REGISTER_METHOD_UNSPECIFIED RegisterMethod = 0
    16| 	RegisterMethod_REGISTER_METHOD_AUTH_KEY    RegisterMethod = 1
    17| 	RegisterMethod_REGISTER_METHOD_CLI         RegisterMethod = 2
    18| 	RegisterMethod_REGISTER_METHOD_OIDC        RegisterMethod = 3
    19| )
    20| var (
    21| 	RegisterMethod_name = map[int32]string{
    22| 		0: "REGISTER_METHOD_UNSPECIFIED",
    23| 		1: "REGISTER_METHOD_AUTH_KEY",
    24| 		2: "REGISTER_METHOD_CLI",
    25| 		3: "REGISTER_METHOD_OIDC",
    26| 	}
    27| 	RegisterMethod_value = map[string]int32{
    28| 		"REGISTER_METHOD_UNSPECIFIED": 0,
    29| 		"REGISTER_METHOD_AUTH_KEY":    1,
    30| 		"REGISTER_METHOD_CLI":         2,
    31| 		"REGISTER_METHOD_OIDC":        3,
    32| 	}
    33| )
    34| func (x RegisterMethod) Enum() *RegisterMethod {
    35| 	p := new(RegisterMethod)
    36| 	*p = x
    37| 	return p
    38| }
    39| func (x RegisterMethod) String() string {
    40| 	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
    41| }
    42| func (RegisterMethod) Descriptor() protoreflect.EnumDescriptor {
    43| 	return file_headscale_v1_node_proto_enumTypes[0].Descriptor()
    44| }
    45| func (RegisterMethod) Type() protoreflect.EnumType {
    46| 	return &file_headscale_v1_node_proto_enumTypes[0]
    47| }
    48| func (x RegisterMethod) Number() protoreflect.EnumNumber {
    49| 	return protoreflect.EnumNumber(x)
    50| }
    51| func (RegisterMethod) EnumDescriptor() ([]byte, []int) {
    52| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{0}
    53| }
    54| type Node struct {
    55| 	state         protoimpl.MessageState
    56| 	sizeCache     protoimpl.SizeCache
    57| 	unknownFields protoimpl.UnknownFields
    58| 	Id             uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
    59| 	MachineKey     string                 `protobuf:"bytes,2,opt,name=machine_key,json=machineKey,proto3" json:"machine_key,omitempty"`
    60| 	NodeKey        string                 `protobuf:"bytes,3,opt,name=node_key,json=nodeKey,proto3" json:"node_key,omitempty"`
    61| 	DiscoKey       string                 `protobuf:"bytes,4,opt,name=disco_key,json=discoKey,proto3" json:"disco_key,omitempty"`
    62| 	IpAddresses    []string               `protobuf:"bytes,5,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
    63| 	Name           string                 `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
    64| 	User           *User                  `protobuf:"bytes,7,opt,name=user,proto3" json:"user,omitempty"`
    65| 	LastSeen       *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
    66| 	Expiry         *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=expiry,proto3" json:"expiry,omitempty"`
    67| 	PreAuthKey     *PreAuthKey            `protobuf:"bytes,11,opt,name=pre_auth_key,json=preAuthKey,proto3" json:"pre_auth_key,omitempty"`
    68| 	CreatedAt      *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
    69| 	RegisterMethod RegisterMethod         `protobuf:"varint,13,opt,name=register_method,json=registerMethod,proto3,enum=headscale.v1.RegisterMethod" json:"register_method,omitempty"`
    70| 	ForcedTags     []string               `protobuf:"bytes,18,rep,name=forced_tags,json=forcedTags,proto3" json:"forced_tags,omitempty"`
    71| 	InvalidTags    []string               `protobuf:"bytes,19,rep,name=invalid_tags,json=invalidTags,proto3" json:"invalid_tags,omitempty"`
    72| 	ValidTags      []string               `protobuf:"bytes,20,rep,name=valid_tags,json=validTags,proto3" json:"valid_tags,omitempty"`
    73| 	GivenName      string                 `protobuf:"bytes,21,opt,name=given_name,json=givenName,proto3" json:"given_name,omitempty"`
    74| 	Online         bool                   `protobuf:"varint,22,opt,name=online,proto3" json:"online,omitempty"`
    75| }
    76| func (x *Node) Reset() {
    77| 	*x = Node{}
    78| 	if protoimpl.UnsafeEnabled {
    79| 		mi := &file_headscale_v1_node_proto_msgTypes[0]
    80| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    81| 		ms.StoreMessageInfo(mi)
    82| 	}
    83| }
    84| func (x *Node) String() string {
    85| 	return protoimpl.X.MessageStringOf(x)
    86| }
    87| func (*Node) ProtoMessage() {}
    88| func (x *Node) ProtoReflect() protoreflect.Message {
    89| 	mi := &file_headscale_v1_node_proto_msgTypes[0]
    90| 	if protoimpl.UnsafeEnabled && x != nil {
    91| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    92| 		if ms.LoadMessageInfo() == nil {
    93| 			ms.StoreMessageInfo(mi)
    94| 		}
    95| 		return ms
    96| 	}
    97| 	return mi.MessageOf(x)
    98| }
    99| func (*Node) Descriptor() ([]byte, []int) {
   100| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{0}
   101| }
   102| func (x *Node) GetId() uint64 {
   103| 	if x != nil {
   104| 		return x.Id
   105| 	}
   106| 	return 0
   107| }
   108| func (x *Node) GetMachineKey() string {
   109| 	if x != nil {
   110| 		return x.MachineKey
   111| 	}
   112| 	return ""
   113| }
   114| func (x *Node) GetNodeKey() string {
   115| 	if x != nil {
   116| 		return x.NodeKey
   117| 	}
   118| 	return ""
   119| }
   120| func (x *Node) GetDiscoKey() string {
   121| 	if x != nil {
   122| 		return x.DiscoKey
   123| 	}
   124| 	return ""
   125| }
   126| func (x *Node) GetIpAddresses() []string {
   127| 	if x != nil {
   128| 		return x.IpAddresses
   129| 	}
   130| 	return nil
   131| }
   132| func (x *Node) GetName() string {
   133| 	if x != nil {
   134| 		return x.Name
   135| 	}
   136| 	return ""
   137| }
   138| func (x *Node) GetUser() *User {
   139| 	if x != nil {
   140| 		return x.User
   141| 	}
   142| 	return nil
   143| }
   144| func (x *Node) GetLastSeen() *timestamppb.Timestamp {
   145| 	if x != nil {
   146| 		return x.LastSeen
   147| 	}
   148| 	return nil
   149| }
   150| func (x *Node) GetExpiry() *timestamppb.Timestamp {
   151| 	if x != nil {
   152| 		return x.Expiry
   153| 	}
   154| 	return nil
   155| }
   156| func (x *Node) GetPreAuthKey() *PreAuthKey {
   157| 	if x != nil {
   158| 		return x.PreAuthKey
   159| 	}
   160| 	return nil
   161| }
   162| func (x *Node) GetCreatedAt() *timestamppb.Timestamp {
   163| 	if x != nil {
   164| 		return x.CreatedAt
   165| 	}
   166| 	return nil
   167| }
   168| func (x *Node) GetRegisterMethod() RegisterMethod {
   169| 	if x != nil {
   170| 		return x.RegisterMethod
   171| 	}
   172| 	return RegisterMethod_REGISTER_METHOD_UNSPECIFIED
   173| }
   174| func (x *Node) GetForcedTags() []string {
   175| 	if x != nil {
   176| 		return x.ForcedTags
   177| 	}
   178| 	return nil
   179| }
   180| func (x *Node) GetInvalidTags() []string {
   181| 	if x != nil {
   182| 		return x.InvalidTags
   183| 	}
   184| 	return nil
   185| }
   186| func (x *Node) GetValidTags() []string {
   187| 	if x != nil {
   188| 		return x.ValidTags
   189| 	}
   190| 	return nil
   191| }
   192| func (x *Node) GetGivenName() string {
   193| 	if x != nil {
   194| 		return x.GivenName
   195| 	}
   196| 	return ""
   197| }
   198| func (x *Node) GetOnline() bool {
   199| 	if x != nil {
   200| 		return x.Online
   201| 	}
   202| 	return false
   203| }
   204| type RegisterNodeRequest struct {
   205| 	state         protoimpl.MessageState
   206| 	sizeCache     protoimpl.SizeCache
   207| 	unknownFields protoimpl.UnknownFields
   208| 	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   209| 	Key  string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
   210| }
   211| func (x *RegisterNodeRequest) Reset() {
   212| 	*x = RegisterNodeRequest{}
   213| 	if protoimpl.UnsafeEnabled {
   214| 		mi := &file_headscale_v1_node_proto_msgTypes[1]
   215| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   216| 		ms.StoreMessageInfo(mi)
   217| 	}
   218| }
   219| func (x *RegisterNodeRequest) String() string {
   220| 	return protoimpl.X.MessageStringOf(x)
   221| }
   222| func (*RegisterNodeRequest) ProtoMessage() {}
   223| func (x *RegisterNodeRequest) ProtoReflect() protoreflect.Message {
   224| 	mi := &file_headscale_v1_node_proto_msgTypes[1]
   225| 	if protoimpl.UnsafeEnabled && x != nil {
   226| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   227| 		if ms.LoadMessageInfo() == nil {
   228| 			ms.StoreMessageInfo(mi)
   229| 		}
   230| 		return ms
   231| 	}
   232| 	return mi.MessageOf(x)
   233| }
   234| func (*RegisterNodeRequest) Descriptor() ([]byte, []int) {
   235| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{1}
   236| }
   237| func (x *RegisterNodeRequest) GetUser() string {
   238| 	if x != nil {
   239| 		return x.User
   240| 	}
   241| 	return ""
   242| }
   243| func (x *RegisterNodeRequest) GetKey() string {
   244| 	if x != nil {
   245| 		return x.Key
   246| 	}
   247| 	return ""
   248| }
   249| type RegisterNodeResponse struct {
   250| 	state         protoimpl.MessageState
   251| 	sizeCache     protoimpl.SizeCache
   252| 	unknownFields protoimpl.UnknownFields
   253| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   254| }
   255| func (x *RegisterNodeResponse) Reset() {
   256| 	*x = RegisterNodeResponse{}
   257| 	if protoimpl.UnsafeEnabled {
   258| 		mi := &file_headscale_v1_node_proto_msgTypes[2]
   259| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   260| 		ms.StoreMessageInfo(mi)
   261| 	}
   262| }
   263| func (x *RegisterNodeResponse) String() string {
   264| 	return protoimpl.X.MessageStringOf(x)
   265| }
   266| func (*RegisterNodeResponse) ProtoMessage() {}
   267| func (x *RegisterNodeResponse) ProtoReflect() protoreflect.Message {
   268| 	mi := &file_headscale_v1_node_proto_msgTypes[2]
   269| 	if protoimpl.UnsafeEnabled && x != nil {
   270| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   271| 		if ms.LoadMessageInfo() == nil {
   272| 			ms.StoreMessageInfo(mi)
   273| 		}
   274| 		return ms
   275| 	}
   276| 	return mi.MessageOf(x)
   277| }
   278| func (*RegisterNodeResponse) Descriptor() ([]byte, []int) {
   279| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{2}
   280| }
   281| func (x *RegisterNodeResponse) GetNode() *Node {
   282| 	if x != nil {
   283| 		return x.Node
   284| 	}
   285| 	return nil
   286| }
   287| type GetNodeRequest struct {
   288| 	state         protoimpl.MessageState
   289| 	sizeCache     protoimpl.SizeCache
   290| 	unknownFields protoimpl.UnknownFields
   291| 	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   292| }
   293| func (x *GetNodeRequest) Reset() {
   294| 	*x = GetNodeRequest{}
   295| 	if protoimpl.UnsafeEnabled {
   296| 		mi := &file_headscale_v1_node_proto_msgTypes[3]
   297| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   298| 		ms.StoreMessageInfo(mi)
   299| 	}
   300| }
   301| func (x *GetNodeRequest) String() string {
   302| 	return protoimpl.X.MessageStringOf(x)
   303| }
   304| func (*GetNodeRequest) ProtoMessage() {}
   305| func (x *GetNodeRequest) ProtoReflect() protoreflect.Message {
   306| 	mi := &file_headscale_v1_node_proto_msgTypes[3]
   307| 	if protoimpl.UnsafeEnabled && x != nil {
   308| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   309| 		if ms.LoadMessageInfo() == nil {
   310| 			ms.StoreMessageInfo(mi)
   311| 		}
   312| 		return ms
   313| 	}
   314| 	return mi.MessageOf(x)
   315| }
   316| func (*GetNodeRequest) Descriptor() ([]byte, []int) {
   317| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{3}
   318| }
   319| func (x *GetNodeRequest) GetNodeId() uint64 {
   320| 	if x != nil {
   321| 		return x.NodeId
   322| 	}
   323| 	return 0
   324| }
   325| type GetNodeResponse struct {
   326| 	state         protoimpl.MessageState
   327| 	sizeCache     protoimpl.SizeCache
   328| 	unknownFields protoimpl.UnknownFields
   329| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   330| }
   331| func (x *GetNodeResponse) Reset() {
   332| 	*x = GetNodeResponse{}
   333| 	if protoimpl.UnsafeEnabled {
   334| 		mi := &file_headscale_v1_node_proto_msgTypes[4]
   335| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   336| 		ms.StoreMessageInfo(mi)
   337| 	}
   338| }
   339| func (x *GetNodeResponse) String() string {
   340| 	return protoimpl.X.MessageStringOf(x)
   341| }
   342| func (*GetNodeResponse) ProtoMessage() {}
   343| func (x *GetNodeResponse) ProtoReflect() protoreflect.Message {
   344| 	mi := &file_headscale_v1_node_proto_msgTypes[4]
   345| 	if protoimpl.UnsafeEnabled && x != nil {
   346| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   347| 		if ms.LoadMessageInfo() == nil {
   348| 			ms.StoreMessageInfo(mi)
   349| 		}
   350| 		return ms
   351| 	}
   352| 	return mi.MessageOf(x)
   353| }
   354| func (*GetNodeResponse) Descriptor() ([]byte, []int) {
   355| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{4}
   356| }
   357| func (x *GetNodeResponse) GetNode() *Node {
   358| 	if x != nil {
   359| 		return x.Node
   360| 	}
   361| 	return nil
   362| }
   363| type SetTagsRequest struct {
   364| 	state         protoimpl.MessageState
   365| 	sizeCache     protoimpl.SizeCache
   366| 	unknownFields protoimpl.UnknownFields
   367| 	NodeId uint64   `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   368| 	Tags   []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
   369| }
   370| func (x *SetTagsRequest) Reset() {
   371| 	*x = SetTagsRequest{}
   372| 	if protoimpl.UnsafeEnabled {
   373| 		mi := &file_headscale_v1_node_proto_msgTypes[5]
   374| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   375| 		ms.StoreMessageInfo(mi)
   376| 	}
   377| }
   378| func (x *SetTagsRequest) String() string {
   379| 	return protoimpl.X.MessageStringOf(x)
   380| }
   381| func (*SetTagsRequest) ProtoMessage() {}
   382| func (x *SetTagsRequest) ProtoReflect() protoreflect.Message {
   383| 	mi := &file_headscale_v1_node_proto_msgTypes[5]
   384| 	if protoimpl.UnsafeEnabled && x != nil {
   385| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   386| 		if ms.LoadMessageInfo() == nil {
   387| 			ms.StoreMessageInfo(mi)
   388| 		}
   389| 		return ms
   390| 	}
   391| 	return mi.MessageOf(x)
   392| }
   393| func (*SetTagsRequest) Descriptor() ([]byte, []int) {
   394| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{5}
   395| }
   396| func (x *SetTagsRequest) GetNodeId() uint64 {
   397| 	if x != nil {
   398| 		return x.NodeId
   399| 	}
   400| 	return 0
   401| }
   402| func (x *SetTagsRequest) GetTags() []string {
   403| 	if x != nil {
   404| 		return x.Tags
   405| 	}
   406| 	return nil
   407| }
   408| type SetTagsResponse struct {
   409| 	state         protoimpl.MessageState
   410| 	sizeCache     protoimpl.SizeCache
   411| 	unknownFields protoimpl.UnknownFields
   412| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   413| }
   414| func (x *SetTagsResponse) Reset() {
   415| 	*x = SetTagsResponse{}
   416| 	if protoimpl.UnsafeEnabled {
   417| 		mi := &file_headscale_v1_node_proto_msgTypes[6]
   418| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   419| 		ms.StoreMessageInfo(mi)
   420| 	}
   421| }
   422| func (x *SetTagsResponse) String() string {
   423| 	return protoimpl.X.MessageStringOf(x)
   424| }
   425| func (*SetTagsResponse) ProtoMessage() {}
   426| func (x *SetTagsResponse) ProtoReflect() protoreflect.Message {
   427| 	mi := &file_headscale_v1_node_proto_msgTypes[6]
   428| 	if protoimpl.UnsafeEnabled && x != nil {
   429| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   430| 		if ms.LoadMessageInfo() == nil {
   431| 			ms.StoreMessageInfo(mi)
   432| 		}
   433| 		return ms
   434| 	}
   435| 	return mi.MessageOf(x)
   436| }
   437| func (*SetTagsResponse) Descriptor() ([]byte, []int) {
   438| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{6}
   439| }
   440| func (x *SetTagsResponse) GetNode() *Node {
   441| 	if x != nil {
   442| 		return x.Node
   443| 	}
   444| 	return nil
   445| }
   446| type DeleteNodeRequest struct {
   447| 	state         protoimpl.MessageState
   448| 	sizeCache     protoimpl.SizeCache
   449| 	unknownFields protoimpl.UnknownFields
   450| 	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   451| }
   452| func (x *DeleteNodeRequest) Reset() {
   453| 	*x = DeleteNodeRequest{}
   454| 	if protoimpl.UnsafeEnabled {
   455| 		mi := &file_headscale_v1_node_proto_msgTypes[7]
   456| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   457| 		ms.StoreMessageInfo(mi)
   458| 	}
   459| }
   460| func (x *DeleteNodeRequest) String() string {
   461| 	return protoimpl.X.MessageStringOf(x)
   462| }
   463| func (*DeleteNodeRequest) ProtoMessage() {}
   464| func (x *DeleteNodeRequest) ProtoReflect() protoreflect.Message {
   465| 	mi := &file_headscale_v1_node_proto_msgTypes[7]
   466| 	if protoimpl.UnsafeEnabled && x != nil {
   467| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   468| 		if ms.LoadMessageInfo() == nil {
   469| 			ms.StoreMessageInfo(mi)
   470| 		}
   471| 		return ms
   472| 	}
   473| 	return mi.MessageOf(x)
   474| }
   475| func (*DeleteNodeRequest) Descriptor() ([]byte, []int) {
   476| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{7}
   477| }
   478| func (x *DeleteNodeRequest) GetNodeId() uint64 {
   479| 	if x != nil {
   480| 		return x.NodeId
   481| 	}
   482| 	return 0
   483| }
   484| type DeleteNodeResponse struct {
   485| 	state         protoimpl.MessageState
   486| 	sizeCache     protoimpl.SizeCache
   487| 	unknownFields protoimpl.UnknownFields
   488| }
   489| func (x *DeleteNodeResponse) Reset() {
   490| 	*x = DeleteNodeResponse{}
   491| 	if protoimpl.UnsafeEnabled {
   492| 		mi := &file_headscale_v1_node_proto_msgTypes[8]
   493| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   494| 		ms.StoreMessageInfo(mi)
   495| 	}
   496| }
   497| func (x *DeleteNodeResponse) String() string {
   498| 	return protoimpl.X.MessageStringOf(x)
   499| }
   500| func (*DeleteNodeResponse) ProtoMessage() {}
   501| func (x *DeleteNodeResponse) ProtoReflect() protoreflect.Message {
   502| 	mi := &file_headscale_v1_node_proto_msgTypes[8]
   503| 	if protoimpl.UnsafeEnabled && x != nil {
   504| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   505| 		if ms.LoadMessageInfo() == nil {
   506| 			ms.StoreMessageInfo(mi)
   507| 		}
   508| 		return ms
   509| 	}
   510| 	return mi.MessageOf(x)
   511| }
   512| func (*DeleteNodeResponse) Descriptor() ([]byte, []int) {
   513| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{8}
   514| }
   515| type ExpireNodeRequest struct {
   516| 	state         protoimpl.MessageState
   517| 	sizeCache     protoimpl.SizeCache
   518| 	unknownFields protoimpl.UnknownFields
   519| 	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   520| }
   521| func (x *ExpireNodeRequest) Reset() {
   522| 	*x = ExpireNodeRequest{}
   523| 	if protoimpl.UnsafeEnabled {
   524| 		mi := &file_headscale_v1_node_proto_msgTypes[9]
   525| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   526| 		ms.StoreMessageInfo(mi)
   527| 	}
   528| }
   529| func (x *ExpireNodeRequest) String() string {
   530| 	return protoimpl.X.MessageStringOf(x)
   531| }
   532| func (*ExpireNodeRequest) ProtoMessage() {}
   533| func (x *ExpireNodeRequest) ProtoReflect() protoreflect.Message {
   534| 	mi := &file_headscale_v1_node_proto_msgTypes[9]
   535| 	if protoimpl.UnsafeEnabled && x != nil {
   536| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   537| 		if ms.LoadMessageInfo() == nil {
   538| 			ms.StoreMessageInfo(mi)
   539| 		}
   540| 		return ms
   541| 	}
   542| 	return mi.MessageOf(x)
   543| }
   544| func (*ExpireNodeRequest) Descriptor() ([]byte, []int) {
   545| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{9}
   546| }
   547| func (x *ExpireNodeRequest) GetNodeId() uint64 {
   548| 	if x != nil {
   549| 		return x.NodeId
   550| 	}
   551| 	return 0
   552| }
   553| type ExpireNodeResponse struct {
   554| 	state         protoimpl.MessageState
   555| 	sizeCache     protoimpl.SizeCache
   556| 	unknownFields protoimpl.UnknownFields
   557| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   558| }
   559| func (x *ExpireNodeResponse) Reset() {
   560| 	*x = ExpireNodeResponse{}
   561| 	if protoimpl.UnsafeEnabled {
   562| 		mi := &file_headscale_v1_node_proto_msgTypes[10]
   563| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   564| 		ms.StoreMessageInfo(mi)
   565| 	}
   566| }
   567| func (x *ExpireNodeResponse) String() string {
   568| 	return protoimpl.X.MessageStringOf(x)
   569| }
   570| func (*ExpireNodeResponse) ProtoMessage() {}
   571| func (x *ExpireNodeResponse) ProtoReflect() protoreflect.Message {
   572| 	mi := &file_headscale_v1_node_proto_msgTypes[10]
   573| 	if protoimpl.UnsafeEnabled && x != nil {
   574| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   575| 		if ms.LoadMessageInfo() == nil {
   576| 			ms.StoreMessageInfo(mi)
   577| 		}
   578| 		return ms
   579| 	}
   580| 	return mi.MessageOf(x)
   581| }
   582| func (*ExpireNodeResponse) Descriptor() ([]byte, []int) {
   583| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{10}
   584| }
   585| func (x *ExpireNodeResponse) GetNode() *Node {
   586| 	if x != nil {
   587| 		return x.Node
   588| 	}
   589| 	return nil
   590| }
   591| type RenameNodeRequest struct {
   592| 	state         protoimpl.MessageState
   593| 	sizeCache     protoimpl.SizeCache
   594| 	unknownFields protoimpl.UnknownFields
   595| 	NodeId  uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   596| 	NewName string `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
   597| }
   598| func (x *RenameNodeRequest) Reset() {
   599| 	*x = RenameNodeRequest{}
   600| 	if protoimpl.UnsafeEnabled {
   601| 		mi := &file_headscale_v1_node_proto_msgTypes[11]
   602| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   603| 		ms.StoreMessageInfo(mi)
   604| 	}
   605| }
   606| func (x *RenameNodeRequest) String() string {
   607| 	return protoimpl.X.MessageStringOf(x)
   608| }
   609| func (*RenameNodeRequest) ProtoMessage() {}
   610| func (x *RenameNodeRequest) ProtoReflect() protoreflect.Message {
   611| 	mi := &file_headscale_v1_node_proto_msgTypes[11]
   612| 	if protoimpl.UnsafeEnabled && x != nil {
   613| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   614| 		if ms.LoadMessageInfo() == nil {
   615| 			ms.StoreMessageInfo(mi)
   616| 		}
   617| 		return ms
   618| 	}
   619| 	return mi.MessageOf(x)
   620| }
   621| func (*RenameNodeRequest) Descriptor() ([]byte, []int) {
   622| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{11}
   623| }
   624| func (x *RenameNodeRequest) GetNodeId() uint64 {
   625| 	if x != nil {
   626| 		return x.NodeId
   627| 	}
   628| 	return 0
   629| }
   630| func (x *RenameNodeRequest) GetNewName() string {
   631| 	if x != nil {
   632| 		return x.NewName
   633| 	}
   634| 	return ""
   635| }
   636| type RenameNodeResponse struct {
   637| 	state         protoimpl.MessageState
   638| 	sizeCache     protoimpl.SizeCache
   639| 	unknownFields protoimpl.UnknownFields
   640| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   641| }
   642| func (x *RenameNodeResponse) Reset() {
   643| 	*x = RenameNodeResponse{}
   644| 	if protoimpl.UnsafeEnabled {
   645| 		mi := &file_headscale_v1_node_proto_msgTypes[12]
   646| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   647| 		ms.StoreMessageInfo(mi)
   648| 	}
   649| }
   650| func (x *RenameNodeResponse) String() string {
   651| 	return protoimpl.X.MessageStringOf(x)
   652| }
   653| func (*RenameNodeResponse) ProtoMessage() {}
   654| func (x *RenameNodeResponse) ProtoReflect() protoreflect.Message {
   655| 	mi := &file_headscale_v1_node_proto_msgTypes[12]
   656| 	if protoimpl.UnsafeEnabled && x != nil {
   657| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   658| 		if ms.LoadMessageInfo() == nil {
   659| 			ms.StoreMessageInfo(mi)
   660| 		}
   661| 		return ms
   662| 	}
   663| 	return mi.MessageOf(x)
   664| }
   665| func (*RenameNodeResponse) Descriptor() ([]byte, []int) {
   666| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{12}
   667| }
   668| func (x *RenameNodeResponse) GetNode() *Node {
   669| 	if x != nil {
   670| 		return x.Node
   671| 	}
   672| 	return nil
   673| }
   674| type ListNodesRequest struct {
   675| 	state         protoimpl.MessageState
   676| 	sizeCache     protoimpl.SizeCache
   677| 	unknownFields protoimpl.UnknownFields
   678| 	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   679| }
   680| func (x *ListNodesRequest) Reset() {
   681| 	*x = ListNodesRequest{}
   682| 	if protoimpl.UnsafeEnabled {
   683| 		mi := &file_headscale_v1_node_proto_msgTypes[13]
   684| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   685| 		ms.StoreMessageInfo(mi)
   686| 	}
   687| }
   688| func (x *ListNodesRequest) String() string {
   689| 	return protoimpl.X.MessageStringOf(x)
   690| }
   691| func (*ListNodesRequest) ProtoMessage() {}
   692| func (x *ListNodesRequest) ProtoReflect() protoreflect.Message {
   693| 	mi := &file_headscale_v1_node_proto_msgTypes[13]
   694| 	if protoimpl.UnsafeEnabled && x != nil {
   695| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   696| 		if ms.LoadMessageInfo() == nil {
   697| 			ms.StoreMessageInfo(mi)
   698| 		}
   699| 		return ms
   700| 	}
   701| 	return mi.MessageOf(x)
   702| }
   703| func (*ListNodesRequest) Descriptor() ([]byte, []int) {
   704| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{13}
   705| }
   706| func (x *ListNodesRequest) GetUser() string {
   707| 	if x != nil {
   708| 		return x.User
   709| 	}
   710| 	return ""
   711| }
   712| type ListNodesResponse struct {
   713| 	state         protoimpl.MessageState
   714| 	sizeCache     protoimpl.SizeCache
   715| 	unknownFields protoimpl.UnknownFields
   716| 	Nodes []*Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
   717| }
   718| func (x *ListNodesResponse) Reset() {
   719| 	*x = ListNodesResponse{}
   720| 	if protoimpl.UnsafeEnabled {
   721| 		mi := &file_headscale_v1_node_proto_msgTypes[14]
   722| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   723| 		ms.StoreMessageInfo(mi)
   724| 	}
   725| }
   726| func (x *ListNodesResponse) String() string {
   727| 	return protoimpl.X.MessageStringOf(x)
   728| }
   729| func (*ListNodesResponse) ProtoMessage() {}
   730| func (x *ListNodesResponse) ProtoReflect() protoreflect.Message {
   731| 	mi := &file_headscale_v1_node_proto_msgTypes[14]
   732| 	if protoimpl.UnsafeEnabled && x != nil {
   733| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   734| 		if ms.LoadMessageInfo() == nil {
   735| 			ms.StoreMessageInfo(mi)
   736| 		}
   737| 		return ms
   738| 	}
   739| 	return mi.MessageOf(x)
   740| }
   741| func (*ListNodesResponse) Descriptor() ([]byte, []int) {
   742| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{14}
   743| }
   744| func (x *ListNodesResponse) GetNodes() []*Node {
   745| 	if x != nil {
   746| 		return x.Nodes
   747| 	}
   748| 	return nil
   749| }
   750| type MoveNodeRequest struct {
   751| 	state         protoimpl.MessageState
   752| 	sizeCache     protoimpl.SizeCache
   753| 	unknownFields protoimpl.UnknownFields
   754| 	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   755| 	User   string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
   756| }
   757| func (x *MoveNodeRequest) Reset() {
   758| 	*x = MoveNodeRequest{}
   759| 	if protoimpl.UnsafeEnabled {
   760| 		mi := &file_headscale_v1_node_proto_msgTypes[15]
   761| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   762| 		ms.StoreMessageInfo(mi)
   763| 	}
   764| }
   765| func (x *MoveNodeRequest) String() string {
   766| 	return protoimpl.X.MessageStringOf(x)
   767| }
   768| func (*MoveNodeRequest) ProtoMessage() {}
   769| func (x *MoveNodeRequest) ProtoReflect() protoreflect.Message {
   770| 	mi := &file_headscale_v1_node_proto_msgTypes[15]
   771| 	if protoimpl.UnsafeEnabled && x != nil {
   772| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   773| 		if ms.LoadMessageInfo() == nil {
   774| 			ms.StoreMessageInfo(mi)
   775| 		}
   776| 		return ms
   777| 	}
   778| 	return mi.MessageOf(x)
   779| }
   780| func (*MoveNodeRequest) Descriptor() ([]byte, []int) {
   781| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{15}
   782| }
   783| func (x *MoveNodeRequest) GetNodeId() uint64 {
   784| 	if x != nil {
   785| 		return x.NodeId
   786| 	}
   787| 	return 0
   788| }
   789| func (x *MoveNodeRequest) GetUser() string {
   790| 	if x != nil {
   791| 		return x.User
   792| 	}
   793| 	return ""
   794| }
   795| type MoveNodeResponse struct {
   796| 	state         protoimpl.MessageState
   797| 	sizeCache     protoimpl.SizeCache
   798| 	unknownFields protoimpl.UnknownFields
   799| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   800| }
   801| func (x *MoveNodeResponse) Reset() {
   802| 	*x = MoveNodeResponse{}
   803| 	if protoimpl.UnsafeEnabled {
   804| 		mi := &file_headscale_v1_node_proto_msgTypes[16]
   805| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   806| 		ms.StoreMessageInfo(mi)
   807| 	}
   808| }
   809| func (x *MoveNodeResponse) String() string {
   810| 	return protoimpl.X.MessageStringOf(x)
   811| }
   812| func (*MoveNodeResponse) ProtoMessage() {}
   813| func (x *MoveNodeResponse) ProtoReflect() protoreflect.Message {
   814| 	mi := &file_headscale_v1_node_proto_msgTypes[16]
   815| 	if protoimpl.UnsafeEnabled && x != nil {
   816| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   817| 		if ms.LoadMessageInfo() == nil {
   818| 			ms.StoreMessageInfo(mi)
   819| 		}
   820| 		return ms
   821| 	}
   822| 	return mi.MessageOf(x)
   823| }
   824| func (*MoveNodeResponse) Descriptor() ([]byte, []int) {
   825| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{16}
   826| }
   827| func (x *MoveNodeResponse) GetNode() *Node {
   828| 	if x != nil {
   829| 		return x.Node
   830| 	}
   831| 	return nil
   832| }
   833| type DebugCreateNodeRequest struct {
   834| 	state         protoimpl.MessageState
   835| 	sizeCache     protoimpl.SizeCache
   836| 	unknownFields protoimpl.UnknownFields
   837| 	User   string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   838| 	Key    string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
   839| 	Name   string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
   840| 	Routes []string `protobuf:"bytes,4,rep,name=routes,proto3" json:"routes,omitempty"`
   841| }
   842| func (x *DebugCreateNodeRequest) Reset() {
   843| 	*x = DebugCreateNodeRequest{}
   844| 	if protoimpl.UnsafeEnabled {
   845| 		mi := &file_headscale_v1_node_proto_msgTypes[17]
   846| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   847| 		ms.StoreMessageInfo(mi)
   848| 	}
   849| }
   850| func (x *DebugCreateNodeRequest) String() string {
   851| 	return protoimpl.X.MessageStringOf(x)
   852| }
   853| func (*DebugCreateNodeRequest) ProtoMessage() {}
   854| func (x *DebugCreateNodeRequest) ProtoReflect() protoreflect.Message {
   855| 	mi := &file_headscale_v1_node_proto_msgTypes[17]
   856| 	if protoimpl.UnsafeEnabled && x != nil {
   857| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   858| 		if ms.LoadMessageInfo() == nil {
   859| 			ms.StoreMessageInfo(mi)
   860| 		}
   861| 		return ms
   862| 	}
   863| 	return mi.MessageOf(x)
   864| }
   865| func (*DebugCreateNodeRequest) Descriptor() ([]byte, []int) {
   866| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{17}
   867| }
   868| func (x *DebugCreateNodeRequest) GetUser() string {
   869| 	if x != nil {
   870| 		return x.User
   871| 	}
   872| 	return ""
   873| }
   874| func (x *DebugCreateNodeRequest) GetKey() string {
   875| 	if x != nil {
   876| 		return x.Key
   877| 	}
   878| 	return ""
   879| }
   880| func (x *DebugCreateNodeRequest) GetName() string {
   881| 	if x != nil {
   882| 		return x.Name
   883| 	}
   884| 	return ""
   885| }
   886| func (x *DebugCreateNodeRequest) GetRoutes() []string {
   887| 	if x != nil {
   888| 		return x.Routes
   889| 	}
   890| 	return nil
   891| }
   892| type DebugCreateNodeResponse struct {
   893| 	state         protoimpl.MessageState
   894| 	sizeCache     protoimpl.SizeCache
   895| 	unknownFields protoimpl.UnknownFields
   896| 	Node *Node `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
   897| }
   898| func (x *DebugCreateNodeResponse) Reset() {
   899| 	*x = DebugCreateNodeResponse{}
   900| 	if protoimpl.UnsafeEnabled {
   901| 		mi := &file_headscale_v1_node_proto_msgTypes[18]
   902| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   903| 		ms.StoreMessageInfo(mi)
   904| 	}
   905| }
   906| func (x *DebugCreateNodeResponse) String() string {
   907| 	return protoimpl.X.MessageStringOf(x)
   908| }
   909| func (*DebugCreateNodeResponse) ProtoMessage() {}
   910| func (x *DebugCreateNodeResponse) ProtoReflect() protoreflect.Message {
   911| 	mi := &file_headscale_v1_node_proto_msgTypes[18]
   912| 	if protoimpl.UnsafeEnabled && x != nil {
   913| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   914| 		if ms.LoadMessageInfo() == nil {
   915| 			ms.StoreMessageInfo(mi)
   916| 		}
   917| 		return ms
   918| 	}
   919| 	return mi.MessageOf(x)
   920| }
   921| func (*DebugCreateNodeResponse) Descriptor() ([]byte, []int) {
   922| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{18}
   923| }
   924| func (x *DebugCreateNodeResponse) GetNode() *Node {
   925| 	if x != nil {
   926| 		return x.Node
   927| 	}
   928| 	return nil
   929| }
   930| type BackfillNodeIPsRequest struct {
   931| 	state         protoimpl.MessageState
   932| 	sizeCache     protoimpl.SizeCache
   933| 	unknownFields protoimpl.UnknownFields
   934| 	Confirmed bool `protobuf:"varint,1,opt,name=confirmed,proto3" json:"confirmed,omitempty"`
   935| }
   936| func (x *BackfillNodeIPsRequest) Reset() {
   937| 	*x = BackfillNodeIPsRequest{}
   938| 	if protoimpl.UnsafeEnabled {
   939| 		mi := &file_headscale_v1_node_proto_msgTypes[19]
   940| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   941| 		ms.StoreMessageInfo(mi)
   942| 	}
   943| }
   944| func (x *BackfillNodeIPsRequest) String() string {
   945| 	return protoimpl.X.MessageStringOf(x)
   946| }
   947| func (*BackfillNodeIPsRequest) ProtoMessage() {}
   948| func (x *BackfillNodeIPsRequest) ProtoReflect() protoreflect.Message {
   949| 	mi := &file_headscale_v1_node_proto_msgTypes[19]
   950| 	if protoimpl.UnsafeEnabled && x != nil {
   951| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   952| 		if ms.LoadMessageInfo() == nil {
   953| 			ms.StoreMessageInfo(mi)
   954| 		}
   955| 		return ms
   956| 	}
   957| 	return mi.MessageOf(x)
   958| }
   959| func (*BackfillNodeIPsRequest) Descriptor() ([]byte, []int) {
   960| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{19}
   961| }
   962| func (x *BackfillNodeIPsRequest) GetConfirmed() bool {
   963| 	if x != nil {
   964| 		return x.Confirmed
   965| 	}
   966| 	return false
   967| }
   968| type BackfillNodeIPsResponse struct {
   969| 	state         protoimpl.MessageState
   970| 	sizeCache     protoimpl.SizeCache
   971| 	unknownFields protoimpl.UnknownFields
   972| 	Changes []string `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes,omitempty"`
   973| }
   974| func (x *BackfillNodeIPsResponse) Reset() {
   975| 	*x = BackfillNodeIPsResponse{}
   976| 	if protoimpl.UnsafeEnabled {
   977| 		mi := &file_headscale_v1_node_proto_msgTypes[20]
   978| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   979| 		ms.StoreMessageInfo(mi)
   980| 	}
   981| }
   982| func (x *BackfillNodeIPsResponse) String() string {
   983| 	return protoimpl.X.MessageStringOf(x)
   984| }
   985| func (*BackfillNodeIPsResponse) ProtoMessage() {}
   986| func (x *BackfillNodeIPsResponse) ProtoReflect() protoreflect.Message {
   987| 	mi := &file_headscale_v1_node_proto_msgTypes[20]
   988| 	if protoimpl.UnsafeEnabled && x != nil {
   989| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   990| 		if ms.LoadMessageInfo() == nil {
   991| 			ms.StoreMessageInfo(mi)
   992| 		}
   993| 		return ms
   994| 	}
   995| 	return mi.MessageOf(x)
   996| }
   997| func (*BackfillNodeIPsResponse) Descriptor() ([]byte, []int) {
   998| 	return file_headscale_v1_node_proto_rawDescGZIP(), []int{20}
   999| }
  1000| func (x *BackfillNodeIPsResponse) GetChanges() []string {
  1001| 	if x != nil {
  1002| 		return x.Changes
  1003| 	}
  1004| 	return nil
  1005| }
  1006| var File_headscale_v1_node_proto protoreflect.FileDescriptor
  1007| var file_headscale_v1_node_proto_rawDesc = []byte{
  1008| 	0x0a, 0x17, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6e,
  1009| 	0x6f, 0x64, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61, 0x64, 0x73,
  1010| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f,
  1011| 	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
  1012| 	0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
  1013| 	0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65,
  1014| 	0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
  1015| 	0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
  1016| 	0x22, 0x9f, 0x05, 0x0a, 0x04, 0x4e, 0x6f, 0x64, 0x65, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18,
  1017| 	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63,
  1018| 	0x68, 0x69, 0x6e, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
  1019| 	0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x6f,
  1020| 	0x64, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6e, 0x6f,
  1021| 	0x64, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x1b, 0x0a, 0x09, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x5f, 0x6b,
  1022| 	0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x4b,
  1023| 	0x65, 0x79, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73,
  1024| 	0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x70, 0x41, 0x64, 0x64, 0x72,
  1025| 	0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20,
  1026| 	0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x26, 0x0a, 0x04, 0x75, 0x73, 0x65,
  1027| 	0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
  1028| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x04, 0x75, 0x73, 0x65,
  1029| 	0x72, 0x12, 0x37, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x65, 0x6e, 0x18, 0x08,
  1030| 	0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
  1031| 	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
  1032| 	0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x65, 0x6e, 0x12, 0x32, 0x0a, 0x06, 0x65, 0x78,
  1033| 	0x70, 0x69, 0x72, 0x79, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
  1034| 	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
  1035| 	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x12, 0x3a,
  1036| 	0x0a, 0x0c, 0x70, 0x72, 0x65, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x0b,
  1037| 	0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
  1038| 	0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x0a,
  1039| 	0x70, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72,
  1040| 	0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
  1041| 	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
  1042| 	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61,
  1043| 	0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x45, 0x0a, 0x0f, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65,
  1044| 	0x72, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c,
  1045| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
  1046| 	0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x52, 0x0e, 0x72, 0x65,
  1047| 	0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x1f, 0x0a, 0x0b,
  1048| 	0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x12, 0x20, 0x03, 0x28,
  1049| 	0x09, 0x52, 0x0a, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x54, 0x61, 0x67, 0x73, 0x12, 0x21, 0x0a,
  1050| 	0x0c, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x13, 0x20,
  1051| 	0x03, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x54, 0x61, 0x67, 0x73,
  1052| 	0x12, 0x1d, 0x0a, 0x0a, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x14,
  1053| 	0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x54, 0x61, 0x67, 0x73, 0x12,
  1054| 	0x1d, 0x0a, 0x0a, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x15, 0x20,
  1055| 	0x01, 0x28, 0x09, 0x52, 0x09, 0x67, 0x69, 0x76, 0x65, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16,
  1056| 	0x0a, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x16, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
  1057| 	0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x4a, 0x04, 0x08, 0x09, 0x10, 0x0a, 0x4a, 0x04, 0x08, 0x0e,
  1058| 	0x10, 0x12, 0x22, 0x3b, 0x0a, 0x13, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f,
  1059| 	0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65,
  1060| 	0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x10, 0x0a,
  1061| 	0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x22,
  1062| 	0x3e, 0x0a, 0x14, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65, 0x52,
  1063| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18,
  1064| 	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
  1065| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22,
  1066| 	0x29, 0x0a, 0x0e, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
  1067| 	0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
  1068| 	0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x22, 0x39, 0x0a, 0x0f, 0x47, 0x65,
  1069| 	0x74, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a,
  1070| 	0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65,
  1071| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52,
  1072| 	0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22, 0x3d, 0x0a, 0x0e, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73,
  1073| 	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f,
  1074| 	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64,
  1075| 	0x12, 0x12, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04,
  1076| 	0x74, 0x61, 0x67, 0x73, 0x22, 0x39, 0x0a, 0x0f, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52,
  1077| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18,
  1078| 	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
  1079| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22,
  1080| 	0x2c, 0x0a, 0x11, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71,
  1081| 	0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18,
  1082| 	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x22, 0x14, 0x0a,
  1083| 	0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
  1084| 	0x6e, 0x73, 0x65, 0x22, 0x2c, 0x0a, 0x11, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4e, 0x6f, 0x64,
  1085| 	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65,
  1086| 	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49,
  1087| 	0x64, 0x22, 0x3c, 0x0a, 0x12, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52,
  1088| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18,
  1089| 	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
  1090| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22,
  1091| 	0x47, 0x0a, 0x11, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71,
  1092| 	0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18,
  1093| 	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x12, 0x19, 0x0a,
  1094| 	0x08, 0x6e, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
  1095| 	0x07, 0x6e, 0x65, 0x77, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x3c, 0x0a, 0x12, 0x52, 0x65, 0x6e, 0x61,
  1096| 	0x6d, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x26,
  1097| 	0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68,
  1098| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65,
  1099| 	0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22, 0x26, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74, 0x4e, 0x6f,
  1100| 	0x64, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73,
  1101| 	0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x3d,
  1102| 	0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
  1103| 	0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x05, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
  1104| 	0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
  1105| 	0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x05, 0x6e, 0x6f, 0x64, 0x65, 0x73, 0x22, 0x3e, 0x0a,
  1106| 	0x0f, 0x4d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
  1107| 	0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
  1108| 	0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65,
  1109| 	0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x3a, 0x0a,
  1110| 	0x10, 0x4d, 0x6f, 0x76, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
  1111| 	0x65, 0x12, 0x26, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
  1112| 	0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e,
  1113| 	0x6f, 0x64, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22, 0x6a, 0x0a, 0x16, 0x44, 0x65, 0x62,
  1114| 	0x75, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x71, 0x75,
  1115| 	0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28,
  1116| 	0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02,
  1117| 	0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
  1118| 	0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a,
  1119| 	0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x06, 0x72,
  1120| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x41, 0x0a, 0x17, 0x44, 0x65, 0x62, 0x75, 0x67, 0x43, 0x72,
  1121| 	0x65, 0x61, 0x74, 0x65, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
  1122| 	0x12, 0x26, 0x0a, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12,
  1123| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f,
  1124| 	0x64, 0x65, 0x52, 0x04, 0x6e, 0x6f, 0x64, 0x65, 0x22, 0x36, 0x0a, 0x16, 0x42, 0x61, 0x63, 0x6b,
  1125| 	0x66, 0x69, 0x6c, 0x6c, 0x4e, 0x6f, 0x64, 0x65, 0x49, 0x50, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
  1126| 	0x73, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x65, 0x64, 0x18,
  1127| 	0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x72, 0x6d, 0x65, 0x64,
  1128| 	0x22, 0x33, 0x0a, 0x17, 0x42, 0x61, 0x63, 0x6b, 0x66, 0x69, 0x6c, 0x6c, 0x4e, 0x6f, 0x64, 0x65,
  1129| 	0x49, 0x50, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x63,
  1130| 	0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07, 0x63, 0x68,
  1131| 	0x61, 0x6e, 0x67, 0x65, 0x73, 0x2a, 0x82, 0x01, 0x0a, 0x0e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74,
  1132| 	0x65, 0x72, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x1f, 0x0a, 0x1b, 0x52, 0x45, 0x47, 0x49,
  1133| 	0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x55, 0x4e, 0x53, 0x50,
  1134| 	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x52, 0x45, 0x47,
  1135| 	0x49, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x41, 0x55, 0x54,
  1136| 	0x48, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x47, 0x49, 0x53,
  1137| 	0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x43, 0x4c, 0x49, 0x10, 0x02,
  1138| 	0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54,
  1139| 	0x48, 0x4f, 0x44, 0x5f, 0x4f, 0x49, 0x44, 0x43, 0x10, 0x03, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69,
  1140| 	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e,
  1141| 	0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f,
  1142| 	0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
  1143| }
  1144| var (
  1145| 	file_headscale_v1_node_proto_rawDescOnce sync.Once
  1146| 	file_headscale_v1_node_proto_rawDescData = file_headscale_v1_node_proto_rawDesc
  1147| )
  1148| func file_headscale_v1_node_proto_rawDescGZIP() []byte {
  1149| 	file_headscale_v1_node_proto_rawDescOnce.Do(func() {
  1150| 		file_headscale_v1_node_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_node_proto_rawDescData)
  1151| 	})
  1152| 	return file_headscale_v1_node_proto_rawDescData
  1153| }
  1154| var file_headscale_v1_node_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
  1155| var file_headscale_v1_node_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
  1156| var file_headscale_v1_node_proto_goTypes = []any{
  1157| 	(RegisterMethod)(0),             // 0: headscale.v1.RegisterMethod
  1158| 	(*Node)(nil),                    // 1: headscale.v1.Node
  1159| 	(*RegisterNodeRequest)(nil),     // 2: headscale.v1.RegisterNodeRequest
  1160| 	(*RegisterNodeResponse)(nil),    // 3: headscale.v1.RegisterNodeResponse
  1161| 	(*GetNodeRequest)(nil),          // 4: headscale.v1.GetNodeRequest
  1162| 	(*GetNodeResponse)(nil),         // 5: headscale.v1.GetNodeResponse
  1163| 	(*SetTagsRequest)(nil),          // 6: headscale.v1.SetTagsRequest
  1164| 	(*SetTagsResponse)(nil),         // 7: headscale.v1.SetTagsResponse
  1165| 	(*DeleteNodeRequest)(nil),       // 8: headscale.v1.DeleteNodeRequest
  1166| 	(*DeleteNodeResponse)(nil),      // 9: headscale.v1.DeleteNodeResponse
  1167| 	(*ExpireNodeRequest)(nil),       // 10: headscale.v1.ExpireNodeRequest
  1168| 	(*ExpireNodeResponse)(nil),      // 11: headscale.v1.ExpireNodeResponse
  1169| 	(*RenameNodeRequest)(nil),       // 12: headscale.v1.RenameNodeRequest
  1170| 	(*RenameNodeResponse)(nil),      // 13: headscale.v1.RenameNodeResponse
  1171| 	(*ListNodesRequest)(nil),        // 14: headscale.v1.ListNodesRequest
  1172| 	(*ListNodesResponse)(nil),       // 15: headscale.v1.ListNodesResponse
  1173| 	(*MoveNodeRequest)(nil),         // 16: headscale.v1.MoveNodeRequest
  1174| 	(*MoveNodeResponse)(nil),        // 17: headscale.v1.MoveNodeResponse
  1175| 	(*DebugCreateNodeRequest)(nil),  // 18: headscale.v1.DebugCreateNodeRequest
  1176| 	(*DebugCreateNodeResponse)(nil), // 19: headscale.v1.DebugCreateNodeResponse
  1177| 	(*BackfillNodeIPsRequest)(nil),  // 20: headscale.v1.BackfillNodeIPsRequest
  1178| 	(*BackfillNodeIPsResponse)(nil), // 21: headscale.v1.BackfillNodeIPsResponse
  1179| 	(*User)(nil),                    // 22: headscale.v1.User
  1180| 	(*timestamppb.Timestamp)(nil),   // 23: google.protobuf.Timestamp
  1181| 	(*PreAuthKey)(nil),              // 24: headscale.v1.PreAuthKey
  1182| }
  1183| var file_headscale_v1_node_proto_depIdxs = []int32{
  1184| 	22, // 0: headscale.v1.Node.user:type_name -> headscale.v1.User
  1185| 	23, // 1: headscale.v1.Node.last_seen:type_name -> google.protobuf.Timestamp
  1186| 	23, // 2: headscale.v1.Node.expiry:type_name -> google.protobuf.Timestamp
  1187| 	24, // 3: headscale.v1.Node.pre_auth_key:type_name -> headscale.v1.PreAuthKey
  1188| 	23, // 4: headscale.v1.Node.created_at:type_name -> google.protobuf.Timestamp
  1189| 	0,  // 5: headscale.v1.Node.register_method:type_name -> headscale.v1.RegisterMethod
  1190| 	1,  // 6: headscale.v1.RegisterNodeResponse.node:type_name -> headscale.v1.Node
  1191| 	1,  // 7: headscale.v1.GetNodeResponse.node:type_name -> headscale.v1.Node
  1192| 	1,  // 8: headscale.v1.SetTagsResponse.node:type_name -> headscale.v1.Node
  1193| 	1,  // 9: headscale.v1.ExpireNodeResponse.node:type_name -> headscale.v1.Node
  1194| 	1,  // 10: headscale.v1.RenameNodeResponse.node:type_name -> headscale.v1.Node
  1195| 	1,  // 11: headscale.v1.ListNodesResponse.nodes:type_name -> headscale.v1.Node
  1196| 	1,  // 12: headscale.v1.MoveNodeResponse.node:type_name -> headscale.v1.Node
  1197| 	1,  // 13: headscale.v1.DebugCreateNodeResponse.node:type_name -> headscale.v1.Node
  1198| 	14, // [14:14] is the sub-list for method output_type
  1199| 	14, // [14:14] is the sub-list for method input_type
  1200| 	14, // [14:14] is the sub-list for extension type_name
  1201| 	14, // [14:14] is the sub-list for extension extendee
  1202| 	0,  // [0:14] is the sub-list for field type_name
  1203| }
  1204| func init() { file_headscale_v1_node_proto_init() }
  1205| func file_headscale_v1_node_proto_init() {
  1206| 	if File_headscale_v1_node_proto != nil {
  1207| 		return
  1208| 	}
  1209| 	file_headscale_v1_preauthkey_proto_init()
  1210| 	file_headscale_v1_user_proto_init()
  1211| 	if !protoimpl.UnsafeEnabled {
  1212| 		file_headscale_v1_node_proto_msgTypes[0].Exporter = func(v any, i int) any {
  1213| 			switch v := v.(*Node); i {
  1214| 			case 0:
  1215| 				return &v.state
  1216| 			case 1:
  1217| 				return &v.sizeCache
  1218| 			case 2:
  1219| 				return &v.unknownFields
  1220| 			default:
  1221| 				return nil
  1222| 			}
  1223| 		}
  1224| 		file_headscale_v1_node_proto_msgTypes[1].Exporter = func(v any, i int) any {
  1225| 			switch v := v.(*RegisterNodeRequest); i {
  1226| 			case 0:
  1227| 				return &v.state
  1228| 			case 1:
  1229| 				return &v.sizeCache
  1230| 			case 2:
  1231| 				return &v.unknownFields
  1232| 			default:
  1233| 				return nil
  1234| 			}
  1235| 		}
  1236| 		file_headscale_v1_node_proto_msgTypes[2].Exporter = func(v any, i int) any {
  1237| 			switch v := v.(*RegisterNodeResponse); i {
  1238| 			case 0:
  1239| 				return &v.state
  1240| 			case 1:
  1241| 				return &v.sizeCache
  1242| 			case 2:
  1243| 				return &v.unknownFields
  1244| 			default:
  1245| 				return nil
  1246| 			}
  1247| 		}
  1248| 		file_headscale_v1_node_proto_msgTypes[3].Exporter = func(v any, i int) any {
  1249| 			switch v := v.(*GetNodeRequest); i {
  1250| 			case 0:
  1251| 				return &v.state
  1252| 			case 1:
  1253| 				return &v.sizeCache
  1254| 			case 2:
  1255| 				return &v.unknownFields
  1256| 			default:
  1257| 				return nil
  1258| 			}
  1259| 		}
  1260| 		file_headscale_v1_node_proto_msgTypes[4].Exporter = func(v any, i int) any {
  1261| 			switch v := v.(*GetNodeResponse); i {
  1262| 			case 0:
  1263| 				return &v.state
  1264| 			case 1:
  1265| 				return &v.sizeCache
  1266| 			case 2:
  1267| 				return &v.unknownFields
  1268| 			default:
  1269| 				return nil
  1270| 			}
  1271| 		}
  1272| 		file_headscale_v1_node_proto_msgTypes[5].Exporter = func(v any, i int) any {
  1273| 			switch v := v.(*SetTagsRequest); i {
  1274| 			case 0:
  1275| 				return &v.state
  1276| 			case 1:
  1277| 				return &v.sizeCache
  1278| 			case 2:
  1279| 				return &v.unknownFields
  1280| 			default:
  1281| 				return nil
  1282| 			}
  1283| 		}
  1284| 		file_headscale_v1_node_proto_msgTypes[6].Exporter = func(v any, i int) any {
  1285| 			switch v := v.(*SetTagsResponse); i {
  1286| 			case 0:
  1287| 				return &v.state
  1288| 			case 1:
  1289| 				return &v.sizeCache
  1290| 			case 2:
  1291| 				return &v.unknownFields
  1292| 			default:
  1293| 				return nil
  1294| 			}
  1295| 		}
  1296| 		file_headscale_v1_node_proto_msgTypes[7].Exporter = func(v any, i int) any {
  1297| 			switch v := v.(*DeleteNodeRequest); i {
  1298| 			case 0:
  1299| 				return &v.state
  1300| 			case 1:
  1301| 				return &v.sizeCache
  1302| 			case 2:
  1303| 				return &v.unknownFields
  1304| 			default:
  1305| 				return nil
  1306| 			}
  1307| 		}
  1308| 		file_headscale_v1_node_proto_msgTypes[8].Exporter = func(v any, i int) any {
  1309| 			switch v := v.(*DeleteNodeResponse); i {
  1310| 			case 0:
  1311| 				return &v.state
  1312| 			case 1:
  1313| 				return &v.sizeCache
  1314| 			case 2:
  1315| 				return &v.unknownFields
  1316| 			default:
  1317| 				return nil
  1318| 			}
  1319| 		}
  1320| 		file_headscale_v1_node_proto_msgTypes[9].Exporter = func(v any, i int) any {
  1321| 			switch v := v.(*ExpireNodeRequest); i {
  1322| 			case 0:
  1323| 				return &v.state
  1324| 			case 1:
  1325| 				return &v.sizeCache
  1326| 			case 2:
  1327| 				return &v.unknownFields
  1328| 			default:
  1329| 				return nil
  1330| 			}
  1331| 		}
  1332| 		file_headscale_v1_node_proto_msgTypes[10].Exporter = func(v any, i int) any {
  1333| 			switch v := v.(*ExpireNodeResponse); i {
  1334| 			case 0:
  1335| 				return &v.state
  1336| 			case 1:
  1337| 				return &v.sizeCache
  1338| 			case 2:
  1339| 				return &v.unknownFields
  1340| 			default:
  1341| 				return nil
  1342| 			}
  1343| 		}
  1344| 		file_headscale_v1_node_proto_msgTypes[11].Exporter = func(v any, i int) any {
  1345| 			switch v := v.(*RenameNodeRequest); i {
  1346| 			case 0:
  1347| 				return &v.state
  1348| 			case 1:
  1349| 				return &v.sizeCache
  1350| 			case 2:
  1351| 				return &v.unknownFields
  1352| 			default:
  1353| 				return nil
  1354| 			}
  1355| 		}
  1356| 		file_headscale_v1_node_proto_msgTypes[12].Exporter = func(v any, i int) any {
  1357| 			switch v := v.(*RenameNodeResponse); i {
  1358| 			case 0:
  1359| 				return &v.state
  1360| 			case 1:
  1361| 				return &v.sizeCache
  1362| 			case 2:
  1363| 				return &v.unknownFields
  1364| 			default:
  1365| 				return nil
  1366| 			}
  1367| 		}
  1368| 		file_headscale_v1_node_proto_msgTypes[13].Exporter = func(v any, i int) any {
  1369| 			switch v := v.(*ListNodesRequest); i {
  1370| 			case 0:
  1371| 				return &v.state
  1372| 			case 1:
  1373| 				return &v.sizeCache
  1374| 			case 2:
  1375| 				return &v.unknownFields
  1376| 			default:
  1377| 				return nil
  1378| 			}
  1379| 		}
  1380| 		file_headscale_v1_node_proto_msgTypes[14].Exporter = func(v any, i int) any {
  1381| 			switch v := v.(*ListNodesResponse); i {
  1382| 			case 0:
  1383| 				return &v.state
  1384| 			case 1:
  1385| 				return &v.sizeCache
  1386| 			case 2:
  1387| 				return &v.unknownFields
  1388| 			default:
  1389| 				return nil
  1390| 			}
  1391| 		}
  1392| 		file_headscale_v1_node_proto_msgTypes[15].Exporter = func(v any, i int) any {
  1393| 			switch v := v.(*MoveNodeRequest); i {
  1394| 			case 0:
  1395| 				return &v.state
  1396| 			case 1:
  1397| 				return &v.sizeCache
  1398| 			case 2:
  1399| 				return &v.unknownFields
  1400| 			default:
  1401| 				return nil
  1402| 			}
  1403| 		}
  1404| 		file_headscale_v1_node_proto_msgTypes[16].Exporter = func(v any, i int) any {
  1405| 			switch v := v.(*MoveNodeResponse); i {
  1406| 			case 0:
  1407| 				return &v.state
  1408| 			case 1:
  1409| 				return &v.sizeCache
  1410| 			case 2:
  1411| 				return &v.unknownFields
  1412| 			default:
  1413| 				return nil
  1414| 			}
  1415| 		}
  1416| 		file_headscale_v1_node_proto_msgTypes[17].Exporter = func(v any, i int) any {
  1417| 			switch v := v.(*DebugCreateNodeRequest); i {
  1418| 			case 0:
  1419| 				return &v.state
  1420| 			case 1:
  1421| 				return &v.sizeCache
  1422| 			case 2:
  1423| 				return &v.unknownFields
  1424| 			default:
  1425| 				return nil
  1426| 			}
  1427| 		}
  1428| 		file_headscale_v1_node_proto_msgTypes[18].Exporter = func(v any, i int) any {
  1429| 			switch v := v.(*DebugCreateNodeResponse); i {
  1430| 			case 0:
  1431| 				return &v.state
  1432| 			case 1:
  1433| 				return &v.sizeCache
  1434| 			case 2:
  1435| 				return &v.unknownFields
  1436| 			default:
  1437| 				return nil
  1438| 			}
  1439| 		}
  1440| 		file_headscale_v1_node_proto_msgTypes[19].Exporter = func(v any, i int) any {
  1441| 			switch v := v.(*BackfillNodeIPsRequest); i {
  1442| 			case 0:
  1443| 				return &v.state
  1444| 			case 1:
  1445| 				return &v.sizeCache
  1446| 			case 2:
  1447| 				return &v.unknownFields
  1448| 			default:
  1449| 				return nil
  1450| 			}
  1451| 		}
  1452| 		file_headscale_v1_node_proto_msgTypes[20].Exporter = func(v any, i int) any {
  1453| 			switch v := v.(*BackfillNodeIPsResponse); i {
  1454| 			case 0:
  1455| 				return &v.state
  1456| 			case 1:
  1457| 				return &v.sizeCache
  1458| 			case 2:
  1459| 				return &v.unknownFields
  1460| 			default:
  1461| 				return nil
  1462| 			}
  1463| 		}
  1464| 	}
  1465| 	type x struct{}
  1466| 	out := protoimpl.TypeBuilder{
  1467| 		File: protoimpl.DescBuilder{
  1468| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
  1469| 			RawDescriptor: file_headscale_v1_node_proto_rawDesc,
  1470| 			NumEnums:      1,
  1471| 			NumMessages:   21,
  1472| 			NumExtensions: 0,
  1473| 			NumServices:   0,
  1474| 		},
  1475| 		GoTypes:           file_headscale_v1_node_proto_goTypes,
  1476| 		DependencyIndexes: file_headscale_v1_node_proto_depIdxs,
  1477| 		EnumInfos:         file_headscale_v1_node_proto_enumTypes,
  1478| 		MessageInfos:      file_headscale_v1_node_proto_msgTypes,
  1479| 	}.Build()
  1480| 	File_headscale_v1_node_proto = out.File
  1481| 	file_headscale_v1_node_proto_rawDesc = nil
  1482| 	file_headscale_v1_node_proto_goTypes = nil
  1483| 	file_headscale_v1_node_proto_depIdxs = nil
  1484| }


# ====================================================================
# FILE: gen/go/headscale/v1/policy.pb.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-300 ---
     1| package v1
     2| import (
     3| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     4| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     5| 	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
     6| 	reflect "reflect"
     7| 	sync "sync"
     8| )
     9| const (
    10| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    11| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    12| )
    13| type SetPolicyRequest struct {
    14| 	state         protoimpl.MessageState
    15| 	sizeCache     protoimpl.SizeCache
    16| 	unknownFields protoimpl.UnknownFields
    17| 	Policy string `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
    18| }
    19| func (x *SetPolicyRequest) Reset() {
    20| 	*x = SetPolicyRequest{}
    21| 	if protoimpl.UnsafeEnabled {
    22| 		mi := &file_headscale_v1_policy_proto_msgTypes[0]
    23| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    24| 		ms.StoreMessageInfo(mi)
    25| 	}
    26| }
    27| func (x *SetPolicyRequest) String() string {
    28| 	return protoimpl.X.MessageStringOf(x)
    29| }
    30| func (*SetPolicyRequest) ProtoMessage() {}
    31| func (x *SetPolicyRequest) ProtoReflect() protoreflect.Message {
    32| 	mi := &file_headscale_v1_policy_proto_msgTypes[0]
    33| 	if protoimpl.UnsafeEnabled && x != nil {
    34| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    35| 		if ms.LoadMessageInfo() == nil {
    36| 			ms.StoreMessageInfo(mi)
    37| 		}
    38| 		return ms
    39| 	}
    40| 	return mi.MessageOf(x)
    41| }
    42| func (*SetPolicyRequest) Descriptor() ([]byte, []int) {
    43| 	return file_headscale_v1_policy_proto_rawDescGZIP(), []int{0}
    44| }
    45| func (x *SetPolicyRequest) GetPolicy() string {
    46| 	if x != nil {
    47| 		return x.Policy
    48| 	}
    49| 	return ""
    50| }
    51| type SetPolicyResponse struct {
    52| 	state         protoimpl.MessageState
    53| 	sizeCache     protoimpl.SizeCache
    54| 	unknownFields protoimpl.UnknownFields
    55| 	Policy    string                 `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
    56| 	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
    57| }
    58| func (x *SetPolicyResponse) Reset() {
    59| 	*x = SetPolicyResponse{}
    60| 	if protoimpl.UnsafeEnabled {
    61| 		mi := &file_headscale_v1_policy_proto_msgTypes[1]
    62| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    63| 		ms.StoreMessageInfo(mi)
    64| 	}
    65| }
    66| func (x *SetPolicyResponse) String() string {
    67| 	return protoimpl.X.MessageStringOf(x)
    68| }
    69| func (*SetPolicyResponse) ProtoMessage() {}
    70| func (x *SetPolicyResponse) ProtoReflect() protoreflect.Message {
    71| 	mi := &file_headscale_v1_policy_proto_msgTypes[1]
    72| 	if protoimpl.UnsafeEnabled && x != nil {
    73| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    74| 		if ms.LoadMessageInfo() == nil {
    75| 			ms.StoreMessageInfo(mi)
    76| 		}
    77| 		return ms
    78| 	}
    79| 	return mi.MessageOf(x)
    80| }
    81| func (*SetPolicyResponse) Descriptor() ([]byte, []int) {
    82| 	return file_headscale_v1_policy_proto_rawDescGZIP(), []int{1}
    83| }
    84| func (x *SetPolicyResponse) GetPolicy() string {
    85| 	if x != nil {
    86| 		return x.Policy
    87| 	}
    88| 	return ""
    89| }
    90| func (x *SetPolicyResponse) GetUpdatedAt() *timestamppb.Timestamp {
    91| 	if x != nil {
    92| 		return x.UpdatedAt
    93| 	}
    94| 	return nil
    95| }
    96| type GetPolicyRequest struct {
    97| 	state         protoimpl.MessageState
    98| 	sizeCache     protoimpl.SizeCache
    99| 	unknownFields protoimpl.UnknownFields
   100| }
   101| func (x *GetPolicyRequest) Reset() {
   102| 	*x = GetPolicyRequest{}
   103| 	if protoimpl.UnsafeEnabled {
   104| 		mi := &file_headscale_v1_policy_proto_msgTypes[2]
   105| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   106| 		ms.StoreMessageInfo(mi)
   107| 	}
   108| }
   109| func (x *GetPolicyRequest) String() string {
   110| 	return protoimpl.X.MessageStringOf(x)
   111| }
   112| func (*GetPolicyRequest) ProtoMessage() {}
   113| func (x *GetPolicyRequest) ProtoReflect() protoreflect.Message {
   114| 	mi := &file_headscale_v1_policy_proto_msgTypes[2]
   115| 	if protoimpl.UnsafeEnabled && x != nil {
   116| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   117| 		if ms.LoadMessageInfo() == nil {
   118| 			ms.StoreMessageInfo(mi)
   119| 		}
   120| 		return ms
   121| 	}
   122| 	return mi.MessageOf(x)
   123| }
   124| func (*GetPolicyRequest) Descriptor() ([]byte, []int) {
   125| 	return file_headscale_v1_policy_proto_rawDescGZIP(), []int{2}
   126| }
   127| type GetPolicyResponse struct {
   128| 	state         protoimpl.MessageState
   129| 	sizeCache     protoimpl.SizeCache
   130| 	unknownFields protoimpl.UnknownFields
   131| 	Policy    string                 `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
   132| 	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
   133| }
   134| func (x *GetPolicyResponse) Reset() {
   135| 	*x = GetPolicyResponse{}
   136| 	if protoimpl.UnsafeEnabled {
   137| 		mi := &file_headscale_v1_policy_proto_msgTypes[3]
   138| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   139| 		ms.StoreMessageInfo(mi)
   140| 	}
   141| }
   142| func (x *GetPolicyResponse) String() string {
   143| 	return protoimpl.X.MessageStringOf(x)
   144| }
   145| func (*GetPolicyResponse) ProtoMessage() {}
   146| func (x *GetPolicyResponse) ProtoReflect() protoreflect.Message {
   147| 	mi := &file_headscale_v1_policy_proto_msgTypes[3]
   148| 	if protoimpl.UnsafeEnabled && x != nil {
   149| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   150| 		if ms.LoadMessageInfo() == nil {
   151| 			ms.StoreMessageInfo(mi)
   152| 		}
   153| 		return ms
   154| 	}
   155| 	return mi.MessageOf(x)
   156| }
   157| func (*GetPolicyResponse) Descriptor() ([]byte, []int) {
   158| 	return file_headscale_v1_policy_proto_rawDescGZIP(), []int{3}
   159| }
   160| func (x *GetPolicyResponse) GetPolicy() string {
   161| 	if x != nil {
   162| 		return x.Policy
   163| 	}
   164| 	return ""
   165| }
   166| func (x *GetPolicyResponse) GetUpdatedAt() *timestamppb.Timestamp {
   167| 	if x != nil {
   168| 		return x.UpdatedAt
   169| 	}
   170| 	return nil
   171| }
   172| var File_headscale_v1_policy_proto protoreflect.FileDescriptor
   173| var file_headscale_v1_policy_proto_rawDesc = []byte{
   174| 	0x0a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x70,
   175| 	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61,
   176| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   177| 	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
   178| 	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x2a, 0x0a, 0x10, 0x53, 0x65,
   179| 	0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16,
   180| 	0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
   181| 	0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x22, 0x66, 0x0a, 0x11, 0x53, 0x65, 0x74, 0x50, 0x6f, 0x6c,
   182| 	0x69, 0x63, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x70,
   183| 	0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x6f, 0x6c,
   184| 	0x69, 0x63, 0x79, 0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61,
   185| 	0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
   186| 	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
   187| 	0x61, 0x6d, 0x70, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x12,
   188| 	0x0a, 0x10, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
   189| 	0x73, 0x74, 0x22, 0x66, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52,
   190| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63,
   191| 	0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12,
   192| 	0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x02, 0x20,
   193| 	0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
   194| 	0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
   195| 	0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69,
   196| 	0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e,
   197| 	0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f,
   198| 	0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
   199| }
   200| var (
   201| 	file_headscale_v1_policy_proto_rawDescOnce sync.Once
   202| 	file_headscale_v1_policy_proto_rawDescData = file_headscale_v1_policy_proto_rawDesc
   203| )
   204| func file_headscale_v1_policy_proto_rawDescGZIP() []byte {
   205| 	file_headscale_v1_policy_proto_rawDescOnce.Do(func() {
   206| 		file_headscale_v1_policy_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_policy_proto_rawDescData)
   207| 	})
   208| 	return file_headscale_v1_policy_proto_rawDescData
   209| }
   210| var file_headscale_v1_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
   211| var file_headscale_v1_policy_proto_goTypes = []any{
   212| 	(*SetPolicyRequest)(nil),      // 0: headscale.v1.SetPolicyRequest
   213| 	(*SetPolicyResponse)(nil),     // 1: headscale.v1.SetPolicyResponse
   214| 	(*GetPolicyRequest)(nil),      // 2: headscale.v1.GetPolicyRequest
   215| 	(*GetPolicyResponse)(nil),     // 3: headscale.v1.GetPolicyResponse
   216| 	(*timestamppb.Timestamp)(nil), // 4: google.protobuf.Timestamp
   217| }
   218| var file_headscale_v1_policy_proto_depIdxs = []int32{
   219| 	4, // 0: headscale.v1.SetPolicyResponse.updated_at:type_name -> google.protobuf.Timestamp
   220| 	4, // 1: headscale.v1.GetPolicyResponse.updated_at:type_name -> google.protobuf.Timestamp
   221| 	2, // [2:2] is the sub-list for method output_type
   222| 	2, // [2:2] is the sub-list for method input_type
   223| 	2, // [2:2] is the sub-list for extension type_name
   224| 	2, // [2:2] is the sub-list for extension extendee
   225| 	0, // [0:2] is the sub-list for field type_name
   226| }
   227| func init() { file_headscale_v1_policy_proto_init() }
   228| func file_headscale_v1_policy_proto_init() {
   229| 	if File_headscale_v1_policy_proto != nil {
   230| 		return
   231| 	}
   232| 	if !protoimpl.UnsafeEnabled {
   233| 		file_headscale_v1_policy_proto_msgTypes[0].Exporter = func(v any, i int) any {
   234| 			switch v := v.(*SetPolicyRequest); i {
   235| 			case 0:
   236| 				return &v.state
   237| 			case 1:
   238| 				return &v.sizeCache
   239| 			case 2:
   240| 				return &v.unknownFields
   241| 			default:
   242| 				return nil
   243| 			}
   244| 		}
   245| 		file_headscale_v1_policy_proto_msgTypes[1].Exporter = func(v any, i int) any {
   246| 			switch v := v.(*SetPolicyResponse); i {
   247| 			case 0:
   248| 				return &v.state
   249| 			case 1:
   250| 				return &v.sizeCache
   251| 			case 2:
   252| 				return &v.unknownFields
   253| 			default:
   254| 				return nil
   255| 			}
   256| 		}
   257| 		file_headscale_v1_policy_proto_msgTypes[2].Exporter = func(v any, i int) any {
   258| 			switch v := v.(*GetPolicyRequest); i {
   259| 			case 0:
   260| 				return &v.state
   261| 			case 1:
   262| 				return &v.sizeCache
   263| 			case 2:
   264| 				return &v.unknownFields
   265| 			default:
   266| 				return nil
   267| 			}
   268| 		}
   269| 		file_headscale_v1_policy_proto_msgTypes[3].Exporter = func(v any, i int) any {
   270| 			switch v := v.(*GetPolicyResponse); i {
   271| 			case 0:
   272| 				return &v.state
   273| 			case 1:
   274| 				return &v.sizeCache
   275| 			case 2:
   276| 				return &v.unknownFields
   277| 			default:
   278| 				return nil
   279| 			}
   280| 		}
   281| 	}
   282| 	type x struct{}
   283| 	out := protoimpl.TypeBuilder{
   284| 		File: protoimpl.DescBuilder{
   285| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   286| 			RawDescriptor: file_headscale_v1_policy_proto_rawDesc,
   287| 			NumEnums:      0,
   288| 			NumMessages:   4,
   289| 			NumExtensions: 0,
   290| 			NumServices:   0,
   291| 		},
   292| 		GoTypes:           file_headscale_v1_policy_proto_goTypes,
   293| 		DependencyIndexes: file_headscale_v1_policy_proto_depIdxs,
   294| 		MessageInfos:      file_headscale_v1_policy_proto_msgTypes,
   295| 	}.Build()
   296| 	File_headscale_v1_policy_proto = out.File
   297| 	file_headscale_v1_policy_proto_rawDesc = nil
   298| 	file_headscale_v1_policy_proto_goTypes = nil
   299| 	file_headscale_v1_policy_proto_depIdxs = nil
   300| }


# ====================================================================
# FILE: gen/go/headscale/v1/preauthkey.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 416-556 ---
   416| 	0x73, 0x65, 0x12, 0x3c, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x6b,
   417| 	0x65, 0x79, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x68, 0x65, 0x61, 0x64,
   418| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68,
   419| 	0x4b, 0x65, 0x79, 0x52, 0x0b, 0x70, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73,
   420| 	0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a,
   421| 	0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   422| 	0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
   423| 	0x74, 0x6f, 0x33,
   424| }
   425| var (
   426| 	file_headscale_v1_preauthkey_proto_rawDescOnce sync.Once
   427| 	file_headscale_v1_preauthkey_proto_rawDescData = file_headscale_v1_preauthkey_proto_rawDesc
   428| )
   429| func file_headscale_v1_preauthkey_proto_rawDescGZIP() []byte {
   430| 	file_headscale_v1_preauthkey_proto_rawDescOnce.Do(func() {
   431| 		file_headscale_v1_preauthkey_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_preauthkey_proto_rawDescData)
   432| 	})
   433| 	return file_headscale_v1_preauthkey_proto_rawDescData
   434| }
   435| var file_headscale_v1_preauthkey_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
   436| var file_headscale_v1_preauthkey_proto_goTypes = []any{
   437| 	(*PreAuthKey)(nil),               // 0: headscale.v1.PreAuthKey
   438| 	(*CreatePreAuthKeyRequest)(nil),  // 1: headscale.v1.CreatePreAuthKeyRequest
   439| 	(*CreatePreAuthKeyResponse)(nil), // 2: headscale.v1.CreatePreAuthKeyResponse
   440| 	(*ExpirePreAuthKeyRequest)(nil),  // 3: headscale.v1.ExpirePreAuthKeyRequest
   441| 	(*ExpirePreAuthKeyResponse)(nil), // 4: headscale.v1.ExpirePreAuthKeyResponse
   442| 	(*ListPreAuthKeysRequest)(nil),   // 5: headscale.v1.ListPreAuthKeysRequest
   443| 	(*ListPreAuthKeysResponse)(nil),  // 6: headscale.v1.ListPreAuthKeysResponse
   444| 	(*timestamppb.Timestamp)(nil),    // 7: google.protobuf.Timestamp
   445| }
   446| var file_headscale_v1_preauthkey_proto_depIdxs = []int32{
   447| 	7, // 0: headscale.v1.PreAuthKey.expiration:type_name -> google.protobuf.Timestamp
   448| 	7, // 1: headscale.v1.PreAuthKey.created_at:type_name -> google.protobuf.Timestamp
   449| 	7, // 2: headscale.v1.CreatePreAuthKeyRequest.expiration:type_name -> google.protobuf.Timestamp
   450| 	0, // 3: headscale.v1.CreatePreAuthKeyResponse.pre_auth_key:type_name -> headscale.v1.PreAuthKey
   451| 	0, // 4: headscale.v1.ListPreAuthKeysResponse.pre_auth_keys:type_name -> headscale.v1.PreAuthKey
   452| 	5, // [5:5] is the sub-list for method output_type
   453| 	5, // [5:5] is the sub-list for method input_type
   454| 	5, // [5:5] is the sub-list for extension type_name
   455| 	5, // [5:5] is the sub-list for extension extendee
   456| 	0, // [0:5] is the sub-list for field type_name
   457| }
   458| func init() { file_headscale_v1_preauthkey_proto_init() }
   459| func file_headscale_v1_preauthkey_proto_init() {
   460| 	if File_headscale_v1_preauthkey_proto != nil {
   461| 		return
   462| 	}
   463| 	if !protoimpl.UnsafeEnabled {
   464| 		file_headscale_v1_preauthkey_proto_msgTypes[0].Exporter = func(v any, i int) any {
   465| 			switch v := v.(*PreAuthKey); i {
   466| 			case 0:
   467| 				return &v.state
   468| 			case 1:
   469| 				return &v.sizeCache
   470| 			case 2:
   471| 				return &v.unknownFields
   472| 			default:
   473| 				return nil
   474| 			}
   475| 		}
   476| 		file_headscale_v1_preauthkey_proto_msgTypes[1].Exporter = func(v any, i int) any {
   477| 			switch v := v.(*CreatePreAuthKeyRequest); i {
   478| 			case 0:
   479| 				return &v.state
   480| 			case 1:
   481| 				return &v.sizeCache
   482| 			case 2:
   483| 				return &v.unknownFields
   484| 			default:
   485| 				return nil
   486| 			}
   487| 		}
   488| 		file_headscale_v1_preauthkey_proto_msgTypes[2].Exporter = func(v any, i int) any {
   489| 			switch v := v.(*CreatePreAuthKeyResponse); i {
   490| 			case 0:
   491| 				return &v.state
   492| 			case 1:
   493| 				return &v.sizeCache
   494| 			case 2:
   495| 				return &v.unknownFields
   496| 			default:
   497| 				return nil
   498| 			}
   499| 		}
   500| 		file_headscale_v1_preauthkey_proto_msgTypes[3].Exporter = func(v any, i int) any {
   501| 			switch v := v.(*ExpirePreAuthKeyRequest); i {
   502| 			case 0:
   503| 				return &v.state
   504| 			case 1:
   505| 				return &v.sizeCache
   506| 			case 2:
   507| 				return &v.unknownFields
   508| 			default:
   509| 				return nil
   510| 			}
   511| 		}
   512| 		file_headscale_v1_preauthkey_proto_msgTypes[4].Exporter = func(v any, i int) any {
   513| 			switch v := v.(*ExpirePreAuthKeyResponse); i {
   514| 			case 0:
   515| 				return &v.state
   516| 			case 1:
   517| 				return &v.sizeCache
   518| 			case 2:
   519| 				return &v.unknownFields
   520| 			default:
   521| 				return nil
   522| 			}
   523| 		}
   524| 		file_headscale_v1_preauthkey_proto_msgTypes[5].Exporter = func(v any, i int) any {
   525| 			switch v := v.(*ListPreAuthKeysRequest); i {
   526| 			case 0:
   527| 				return &v.state
   528| 			case 1:
   529| 				return &v.sizeCache
   530| 			case 2:
   531| 				return &v.unknownFields
   532| 			default:
   533| 				return nil
   534| 			}
   535| 		}
   536| 		file_headscale_v1_preauthkey_proto_msgTypes[6].Exporter = func(v any, i int) any {
   537| 			switch v := v.(*ListPreAuthKeysResponse); i {
   538| 			case 0:
   539| 				return &v.state
   540| 			case 1:
   541| 				return &v.sizeCache
   542| 			case 2:
   543| 				return &v.unknownFields
   544| 			default:
   545| 				return nil
   546| 			}
   547| 		}
   548| 	}
   549| 	type x struct{}
   550| 	out := protoimpl.TypeBuilder{
   551| 		File: protoimpl.DescBuilder{
   552| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   553| 			RawDescriptor: file_headscale_v1_preauthkey_proto_rawDesc,
   554| 			NumEnums:      0,
   555| 			NumMessages:   7,
   556| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/routes.pb.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| package v1
     2| import (
     3| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     4| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     5| 	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
     6| 	reflect "reflect"
     7| 	sync "sync"
     8| )
     9| const (
    10| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    11| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    12| )
    13| type Route struct {
    14| 	state         protoimpl.MessageState
    15| 	sizeCache     protoimpl.SizeCache
    16| 	unknownFields protoimpl.UnknownFields
    17| 	Id         uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
    18| 	Node       *Node                  `protobuf:"bytes,2,opt,name=node,proto3" json:"node,omitempty"`
    19| 	Prefix     string                 `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
    20| 	Advertised bool                   `protobuf:"varint,4,opt,name=advertised,proto3" json:"advertised,omitempty"`
    21| 	Enabled    bool                   `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
    22| 	IsPrimary  bool                   `protobuf:"varint,6,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
    23| 	CreatedAt  *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
    24| 	UpdatedAt  *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
    25| 	DeletedAt  *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
    26| }
    27| func (x *Route) Reset() {
    28| 	*x = Route{}
    29| 	if protoimpl.UnsafeEnabled {
    30| 		mi := &file_headscale_v1_routes_proto_msgTypes[0]
    31| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    32| 		ms.StoreMessageInfo(mi)
    33| 	}
    34| }
    35| func (x *Route) String() string {
    36| 	return protoimpl.X.MessageStringOf(x)
    37| }
    38| func (*Route) ProtoMessage() {}
    39| func (x *Route) ProtoReflect() protoreflect.Message {
    40| 	mi := &file_headscale_v1_routes_proto_msgTypes[0]
    41| 	if protoimpl.UnsafeEnabled && x != nil {
    42| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    43| 		if ms.LoadMessageInfo() == nil {
    44| 			ms.StoreMessageInfo(mi)
    45| 		}
    46| 		return ms
    47| 	}
    48| 	return mi.MessageOf(x)
    49| }
    50| func (*Route) Descriptor() ([]byte, []int) {
    51| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{0}
    52| }
    53| func (x *Route) GetId() uint64 {
    54| 	if x != nil {
    55| 		return x.Id
    56| 	}
    57| 	return 0
    58| }
    59| func (x *Route) GetNode() *Node {
    60| 	if x != nil {
    61| 		return x.Node
    62| 	}
    63| 	return nil
    64| }
    65| func (x *Route) GetPrefix() string {
    66| 	if x != nil {
    67| 		return x.Prefix
    68| 	}
    69| 	return ""
    70| }
    71| func (x *Route) GetAdvertised() bool {
    72| 	if x != nil {
    73| 		return x.Advertised
    74| 	}
    75| 	return false
    76| }
    77| func (x *Route) GetEnabled() bool {
    78| 	if x != nil {
    79| 		return x.Enabled
    80| 	}
    81| 	return false

# --- HUNK 2: Lines 294-404 ---
   294| 	}
   295| }
   296| func (x *DisableRouteResponse) String() string {
   297| 	return protoimpl.X.MessageStringOf(x)
   298| }
   299| func (*DisableRouteResponse) ProtoMessage() {}
   300| func (x *DisableRouteResponse) ProtoReflect() protoreflect.Message {
   301| 	mi := &file_headscale_v1_routes_proto_msgTypes[6]
   302| 	if protoimpl.UnsafeEnabled && x != nil {
   303| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   304| 		if ms.LoadMessageInfo() == nil {
   305| 			ms.StoreMessageInfo(mi)
   306| 		}
   307| 		return ms
   308| 	}
   309| 	return mi.MessageOf(x)
   310| }
   311| func (*DisableRouteResponse) Descriptor() ([]byte, []int) {
   312| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{6}
   313| }
   314| type GetNodeRoutesRequest struct {
   315| 	state         protoimpl.MessageState
   316| 	sizeCache     protoimpl.SizeCache
   317| 	unknownFields protoimpl.UnknownFields
   318| 	NodeId uint64 `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
   319| }
   320| func (x *GetNodeRoutesRequest) Reset() {
   321| 	*x = GetNodeRoutesRequest{}
   322| 	if protoimpl.UnsafeEnabled {
   323| 		mi := &file_headscale_v1_routes_proto_msgTypes[7]
   324| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   325| 		ms.StoreMessageInfo(mi)
   326| 	}
   327| }
   328| func (x *GetNodeRoutesRequest) String() string {
   329| 	return protoimpl.X.MessageStringOf(x)
   330| }
   331| func (*GetNodeRoutesRequest) ProtoMessage() {}
   332| func (x *GetNodeRoutesRequest) ProtoReflect() protoreflect.Message {
   333| 	mi := &file_headscale_v1_routes_proto_msgTypes[7]
   334| 	if protoimpl.UnsafeEnabled && x != nil {
   335| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   336| 		if ms.LoadMessageInfo() == nil {
   337| 			ms.StoreMessageInfo(mi)
   338| 		}
   339| 		return ms
   340| 	}
   341| 	return mi.MessageOf(x)
   342| }
   343| func (*GetNodeRoutesRequest) Descriptor() ([]byte, []int) {
   344| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{7}
   345| }
   346| func (x *GetNodeRoutesRequest) GetNodeId() uint64 {
   347| 	if x != nil {
   348| 		return x.NodeId
   349| 	}
   350| 	return 0
   351| }
   352| type GetNodeRoutesResponse struct {
   353| 	state         protoimpl.MessageState
   354| 	sizeCache     protoimpl.SizeCache
   355| 	unknownFields protoimpl.UnknownFields
   356| 	Routes []*Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
   357| }
   358| func (x *GetNodeRoutesResponse) Reset() {
   359| 	*x = GetNodeRoutesResponse{}
   360| 	if protoimpl.UnsafeEnabled {
   361| 		mi := &file_headscale_v1_routes_proto_msgTypes[8]
   362| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   363| 		ms.StoreMessageInfo(mi)
   364| 	}
   365| }
   366| func (x *GetNodeRoutesResponse) String() string {
   367| 	return protoimpl.X.MessageStringOf(x)
   368| }
   369| func (*GetNodeRoutesResponse) ProtoMessage() {}
   370| func (x *GetNodeRoutesResponse) ProtoReflect() protoreflect.Message {
   371| 	mi := &file_headscale_v1_routes_proto_msgTypes[8]
   372| 	if protoimpl.UnsafeEnabled && x != nil {
   373| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   374| 		if ms.LoadMessageInfo() == nil {
   375| 			ms.StoreMessageInfo(mi)
   376| 		}
   377| 		return ms
   378| 	}
   379| 	return mi.MessageOf(x)
   380| }
   381| func (*GetNodeRoutesResponse) Descriptor() ([]byte, []int) {
   382| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{8}
   383| }
   384| func (x *GetNodeRoutesResponse) GetRoutes() []*Route {
   385| 	if x != nil {
   386| 		return x.Routes
   387| 	}
   388| 	return nil
   389| }
   390| type DeleteRouteRequest struct {
   391| 	state         protoimpl.MessageState
   392| 	sizeCache     protoimpl.SizeCache
   393| 	unknownFields protoimpl.UnknownFields
   394| 	RouteId uint64 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
   395| }
   396| func (x *DeleteRouteRequest) Reset() {
   397| 	*x = DeleteRouteRequest{}
   398| 	if protoimpl.UnsafeEnabled {
   399| 		mi := &file_headscale_v1_routes_proto_msgTypes[9]
   400| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   401| 		ms.StoreMessageInfo(mi)
   402| 	}
   403| }
   404| func (x *DeleteRouteRequest) String() string {

# --- HUNK 3: Lines 445-707 ---
   445| func (x *DeleteRouteResponse) ProtoReflect() protoreflect.Message {
   446| 	mi := &file_headscale_v1_routes_proto_msgTypes[10]
   447| 	if protoimpl.UnsafeEnabled && x != nil {
   448| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   449| 		if ms.LoadMessageInfo() == nil {
   450| 			ms.StoreMessageInfo(mi)
   451| 		}
   452| 		return ms
   453| 	}
   454| 	return mi.MessageOf(x)
   455| }
   456| func (*DeleteRouteResponse) Descriptor() ([]byte, []int) {
   457| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{10}
   458| }
   459| var File_headscale_v1_routes_proto protoreflect.FileDescriptor
   460| var file_headscale_v1_routes_proto_rawDesc = []byte{
   461| 	0x0a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x72,
   462| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61,
   463| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   464| 	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
   465| 	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61, 0x64,
   466| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6e, 0x6f, 0x64, 0x65, 0x2e, 0x70, 0x72,
   467| 	0x6f, 0x74, 0x6f, 0x22, 0xe1, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x0e, 0x0a,
   468| 	0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x26, 0x0a,
   469| 	0x04, 0x6e, 0x6f, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65,
   470| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4e, 0x6f, 0x64, 0x65, 0x52,
   471| 	0x04, 0x6e, 0x6f, 0x64, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
   472| 	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x1e, 0x0a,
   473| 	0x0a, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
   474| 	0x08, 0x52, 0x0a, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x12, 0x18, 0x0a,
   475| 	0x07, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07,
   476| 	0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x70, 0x72,
   477| 	0x69, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x50,
   478| 	0x72, 0x69, 0x6d, 0x61, 0x72, 0x79, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
   479| 	0x64, 0x5f, 0x61, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
   480| 	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
   481| 	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41,
   482| 	0x74, 0x12, 0x39, 0x0a, 0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18,
   483| 	0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
   484| 	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
   485| 	0x70, 0x52, 0x09, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a,
   486| 	0x64, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b,
   487| 	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
   488| 	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x64, 0x65,
   489| 	0x6c, 0x65, 0x74, 0x65, 0x64, 0x41, 0x74, 0x22, 0x12, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x52, 0x6f,
   490| 	0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x40, 0x0a, 0x11, 0x47,
   491| 	0x65, 0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
   492| 	0x12, 0x2b, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
   493| 	0x32, 0x13, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
   494| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x2f, 0x0a,
   495| 	0x12, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75,
   496| 	0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18,
   497| 	0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x64, 0x22, 0x15,
   498| 	0x0a, 0x13, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73,
   499| 	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x30, 0x0a, 0x13, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,
   500| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08,
   501| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07,
   502| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x64, 0x22, 0x16, 0x0a, 0x14, 0x44, 0x69, 0x73, 0x61, 0x62,
   503| 	0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   504| 	0x2f, 0x0a, 0x14, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73,
   505| 	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x17, 0x0a, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x5f,
   506| 	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x06, 0x6e, 0x6f, 0x64, 0x65, 0x49, 0x64,
   507| 	0x22, 0x44, 0x0a, 0x15, 0x47, 0x65, 0x74, 0x4e, 0x6f, 0x64, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65,
   508| 	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x06, 0x72, 0x6f, 0x75,
   509| 	0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x68, 0x65, 0x61, 0x64,
   510| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x06,
   511| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x2f, 0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
   512| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08,
   513| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07,
   514| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x64, 0x22, 0x15, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74,
   515| 	0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x29,
   516| 	0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61,
   517| 	0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f,
   518| 	0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
   519| 	0x33,
   520| }
   521| var (
   522| 	file_headscale_v1_routes_proto_rawDescOnce sync.Once
   523| 	file_headscale_v1_routes_proto_rawDescData = file_headscale_v1_routes_proto_rawDesc
   524| )
   525| func file_headscale_v1_routes_proto_rawDescGZIP() []byte {
   526| 	file_headscale_v1_routes_proto_rawDescOnce.Do(func() {
   527| 		file_headscale_v1_routes_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_routes_proto_rawDescData)
   528| 	})
   529| 	return file_headscale_v1_routes_proto_rawDescData
   530| }
   531| var file_headscale_v1_routes_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
   532| var file_headscale_v1_routes_proto_goTypes = []any{
   533| 	(*Route)(nil),                 // 0: headscale.v1.Route
   534| 	(*GetRoutesRequest)(nil),      // 1: headscale.v1.GetRoutesRequest
   535| 	(*GetRoutesResponse)(nil),     // 2: headscale.v1.GetRoutesResponse
   536| 	(*EnableRouteRequest)(nil),    // 3: headscale.v1.EnableRouteRequest
   537| 	(*EnableRouteResponse)(nil),   // 4: headscale.v1.EnableRouteResponse
   538| 	(*DisableRouteRequest)(nil),   // 5: headscale.v1.DisableRouteRequest
   539| 	(*DisableRouteResponse)(nil),  // 6: headscale.v1.DisableRouteResponse
   540| 	(*GetNodeRoutesRequest)(nil),  // 7: headscale.v1.GetNodeRoutesRequest
   541| 	(*GetNodeRoutesResponse)(nil), // 8: headscale.v1.GetNodeRoutesResponse
   542| 	(*DeleteRouteRequest)(nil),    // 9: headscale.v1.DeleteRouteRequest
   543| 	(*DeleteRouteResponse)(nil),   // 10: headscale.v1.DeleteRouteResponse
   544| 	(*Node)(nil),                  // 11: headscale.v1.Node
   545| 	(*timestamppb.Timestamp)(nil), // 12: google.protobuf.Timestamp
   546| }
   547| var file_headscale_v1_routes_proto_depIdxs = []int32{
   548| 	11, // 0: headscale.v1.Route.node:type_name -> headscale.v1.Node
   549| 	12, // 1: headscale.v1.Route.created_at:type_name -> google.protobuf.Timestamp
   550| 	12, // 2: headscale.v1.Route.updated_at:type_name -> google.protobuf.Timestamp
   551| 	12, // 3: headscale.v1.Route.deleted_at:type_name -> google.protobuf.Timestamp
   552| 	0,  // 4: headscale.v1.GetRoutesResponse.routes:type_name -> headscale.v1.Route
   553| 	0,  // 5: headscale.v1.GetNodeRoutesResponse.routes:type_name -> headscale.v1.Route
   554| 	6,  // [6:6] is the sub-list for method output_type
   555| 	6,  // [6:6] is the sub-list for method input_type
   556| 	6,  // [6:6] is the sub-list for extension type_name
   557| 	6,  // [6:6] is the sub-list for extension extendee
   558| 	0,  // [0:6] is the sub-list for field type_name
   559| }
   560| func init() { file_headscale_v1_routes_proto_init() }
   561| func file_headscale_v1_routes_proto_init() {
   562| 	if File_headscale_v1_routes_proto != nil {
   563| 		return
   564| 	}
   565| 	file_headscale_v1_node_proto_init()
   566| 	if !protoimpl.UnsafeEnabled {
   567| 		file_headscale_v1_routes_proto_msgTypes[0].Exporter = func(v any, i int) any {
   568| 			switch v := v.(*Route); i {
   569| 			case 0:
   570| 				return &v.state
   571| 			case 1:
   572| 				return &v.sizeCache
   573| 			case 2:
   574| 				return &v.unknownFields
   575| 			default:
   576| 				return nil
   577| 			}
   578| 		}
   579| 		file_headscale_v1_routes_proto_msgTypes[1].Exporter = func(v any, i int) any {
   580| 			switch v := v.(*GetRoutesRequest); i {
   581| 			case 0:
   582| 				return &v.state
   583| 			case 1:
   584| 				return &v.sizeCache
   585| 			case 2:
   586| 				return &v.unknownFields
   587| 			default:
   588| 				return nil
   589| 			}
   590| 		}
   591| 		file_headscale_v1_routes_proto_msgTypes[2].Exporter = func(v any, i int) any {
   592| 			switch v := v.(*GetRoutesResponse); i {
   593| 			case 0:
   594| 				return &v.state
   595| 			case 1:
   596| 				return &v.sizeCache
   597| 			case 2:
   598| 				return &v.unknownFields
   599| 			default:
   600| 				return nil
   601| 			}
   602| 		}
   603| 		file_headscale_v1_routes_proto_msgTypes[3].Exporter = func(v any, i int) any {
   604| 			switch v := v.(*EnableRouteRequest); i {
   605| 			case 0:
   606| 				return &v.state
   607| 			case 1:
   608| 				return &v.sizeCache
   609| 			case 2:
   610| 				return &v.unknownFields
   611| 			default:
   612| 				return nil
   613| 			}
   614| 		}
   615| 		file_headscale_v1_routes_proto_msgTypes[4].Exporter = func(v any, i int) any {
   616| 			switch v := v.(*EnableRouteResponse); i {
   617| 			case 0:
   618| 				return &v.state
   619| 			case 1:
   620| 				return &v.sizeCache
   621| 			case 2:
   622| 				return &v.unknownFields
   623| 			default:
   624| 				return nil
   625| 			}
   626| 		}
   627| 		file_headscale_v1_routes_proto_msgTypes[5].Exporter = func(v any, i int) any {
   628| 			switch v := v.(*DisableRouteRequest); i {
   629| 			case 0:
   630| 				return &v.state
   631| 			case 1:
   632| 				return &v.sizeCache
   633| 			case 2:
   634| 				return &v.unknownFields
   635| 			default:
   636| 				return nil
   637| 			}
   638| 		}
   639| 		file_headscale_v1_routes_proto_msgTypes[6].Exporter = func(v any, i int) any {
   640| 			switch v := v.(*DisableRouteResponse); i {
   641| 			case 0:
   642| 				return &v.state
   643| 			case 1:
   644| 				return &v.sizeCache
   645| 			case 2:
   646| 				return &v.unknownFields
   647| 			default:
   648| 				return nil
   649| 			}
   650| 		}
   651| 		file_headscale_v1_routes_proto_msgTypes[7].Exporter = func(v any, i int) any {
   652| 			switch v := v.(*GetNodeRoutesRequest); i {
   653| 			case 0:
   654| 				return &v.state
   655| 			case 1:
   656| 				return &v.sizeCache
   657| 			case 2:
   658| 				return &v.unknownFields
   659| 			default:
   660| 				return nil
   661| 			}
   662| 		}
   663| 		file_headscale_v1_routes_proto_msgTypes[8].Exporter = func(v any, i int) any {
   664| 			switch v := v.(*GetNodeRoutesResponse); i {
   665| 			case 0:
   666| 				return &v.state
   667| 			case 1:
   668| 				return &v.sizeCache
   669| 			case 2:
   670| 				return &v.unknownFields
   671| 			default:
   672| 				return nil
   673| 			}
   674| 		}
   675| 		file_headscale_v1_routes_proto_msgTypes[9].Exporter = func(v any, i int) any {
   676| 			switch v := v.(*DeleteRouteRequest); i {
   677| 			case 0:
   678| 				return &v.state
   679| 			case 1:
   680| 				return &v.sizeCache
   681| 			case 2:
   682| 				return &v.unknownFields
   683| 			default:
   684| 				return nil
   685| 			}
   686| 		}
   687| 		file_headscale_v1_routes_proto_msgTypes[10].Exporter = func(v any, i int) any {
   688| 			switch v := v.(*DeleteRouteResponse); i {
   689| 			case 0:
   690| 				return &v.state
   691| 			case 1:
   692| 				return &v.sizeCache
   693| 			case 2:
   694| 				return &v.unknownFields
   695| 			default:
   696| 				return nil
   697| 			}
   698| 		}
   699| 	}
   700| 	type x struct{}
   701| 	out := protoimpl.TypeBuilder{
   702| 		File: protoimpl.DescBuilder{
   703| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   704| 			RawDescriptor: file_headscale_v1_routes_proto_rawDesc,
   705| 			NumEnums:      0,
   706| 			NumMessages:   11,
   707| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/user.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 477-669 ---
   477| 	0x65, 0x73, 0x74, 0x22, 0x3d, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73,
   478| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72,
   479| 	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   480| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73, 0x65,
   481| 	0x72, 0x73, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
   482| 	0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   483| 	0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70,
   484| 	0x72, 0x6f, 0x74, 0x6f, 0x33,
   485| }
   486| var (
   487| 	file_headscale_v1_user_proto_rawDescOnce sync.Once
   488| 	file_headscale_v1_user_proto_rawDescData = file_headscale_v1_user_proto_rawDesc
   489| )
   490| func file_headscale_v1_user_proto_rawDescGZIP() []byte {
   491| 	file_headscale_v1_user_proto_rawDescOnce.Do(func() {
   492| 		file_headscale_v1_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_user_proto_rawDescData)
   493| 	})
   494| 	return file_headscale_v1_user_proto_rawDescData
   495| }
   496| var file_headscale_v1_user_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
   497| var file_headscale_v1_user_proto_goTypes = []any{
   498| 	(*User)(nil),                  // 0: headscale.v1.User
   499| 	(*GetUserRequest)(nil),        // 1: headscale.v1.GetUserRequest
   500| 	(*GetUserResponse)(nil),       // 2: headscale.v1.GetUserResponse
   501| 	(*CreateUserRequest)(nil),     // 3: headscale.v1.CreateUserRequest
   502| 	(*CreateUserResponse)(nil),    // 4: headscale.v1.CreateUserResponse
   503| 	(*RenameUserRequest)(nil),     // 5: headscale.v1.RenameUserRequest
   504| 	(*RenameUserResponse)(nil),    // 6: headscale.v1.RenameUserResponse
   505| 	(*DeleteUserRequest)(nil),     // 7: headscale.v1.DeleteUserRequest
   506| 	(*DeleteUserResponse)(nil),    // 8: headscale.v1.DeleteUserResponse
   507| 	(*ListUsersRequest)(nil),      // 9: headscale.v1.ListUsersRequest
   508| 	(*ListUsersResponse)(nil),     // 10: headscale.v1.ListUsersResponse
   509| 	(*timestamppb.Timestamp)(nil), // 11: google.protobuf.Timestamp
   510| }
   511| var file_headscale_v1_user_proto_depIdxs = []int32{
   512| 	11, // 0: headscale.v1.User.created_at:type_name -> google.protobuf.Timestamp
   513| 	0,  // 1: headscale.v1.GetUserResponse.user:type_name -> headscale.v1.User
   514| 	0,  // 2: headscale.v1.CreateUserResponse.user:type_name -> headscale.v1.User
   515| 	0,  // 3: headscale.v1.RenameUserResponse.user:type_name -> headscale.v1.User
   516| 	0,  // 4: headscale.v1.ListUsersResponse.users:type_name -> headscale.v1.User
   517| 	5,  // [5:5] is the sub-list for method output_type
   518| 	5,  // [5:5] is the sub-list for method input_type
   519| 	5,  // [5:5] is the sub-list for extension type_name
   520| 	5,  // [5:5] is the sub-list for extension extendee
   521| 	0,  // [0:5] is the sub-list for field type_name
   522| }
   523| func init() { file_headscale_v1_user_proto_init() }
   524| func file_headscale_v1_user_proto_init() {
   525| 	if File_headscale_v1_user_proto != nil {
   526| 		return
   527| 	}
   528| 	if !protoimpl.UnsafeEnabled {
   529| 		file_headscale_v1_user_proto_msgTypes[0].Exporter = func(v any, i int) any {
   530| 			switch v := v.(*User); i {
   531| 			case 0:
   532| 				return &v.state
   533| 			case 1:
   534| 				return &v.sizeCache
   535| 			case 2:
   536| 				return &v.unknownFields
   537| 			default:
   538| 				return nil
   539| 			}
   540| 		}
   541| 		file_headscale_v1_user_proto_msgTypes[1].Exporter = func(v any, i int) any {
   542| 			switch v := v.(*GetUserRequest); i {
   543| 			case 0:
   544| 				return &v.state
   545| 			case 1:
   546| 				return &v.sizeCache
   547| 			case 2:
   548| 				return &v.unknownFields
   549| 			default:
   550| 				return nil
   551| 			}
   552| 		}
   553| 		file_headscale_v1_user_proto_msgTypes[2].Exporter = func(v any, i int) any {
   554| 			switch v := v.(*GetUserResponse); i {
   555| 			case 0:
   556| 				return &v.state
   557| 			case 1:
   558| 				return &v.sizeCache
   559| 			case 2:
   560| 				return &v.unknownFields
   561| 			default:
   562| 				return nil
   563| 			}
   564| 		}
   565| 		file_headscale_v1_user_proto_msgTypes[3].Exporter = func(v any, i int) any {
   566| 			switch v := v.(*CreateUserRequest); i {
   567| 			case 0:
   568| 				return &v.state
   569| 			case 1:
   570| 				return &v.sizeCache
   571| 			case 2:
   572| 				return &v.unknownFields
   573| 			default:
   574| 				return nil
   575| 			}
   576| 		}
   577| 		file_headscale_v1_user_proto_msgTypes[4].Exporter = func(v any, i int) any {
   578| 			switch v := v.(*CreateUserResponse); i {
   579| 			case 0:
   580| 				return &v.state
   581| 			case 1:
   582| 				return &v.sizeCache
   583| 			case 2:
   584| 				return &v.unknownFields
   585| 			default:
   586| 				return nil
   587| 			}
   588| 		}
   589| 		file_headscale_v1_user_proto_msgTypes[5].Exporter = func(v any, i int) any {
   590| 			switch v := v.(*RenameUserRequest); i {
   591| 			case 0:
   592| 				return &v.state
   593| 			case 1:
   594| 				return &v.sizeCache
   595| 			case 2:
   596| 				return &v.unknownFields
   597| 			default:
   598| 				return nil
   599| 			}
   600| 		}
   601| 		file_headscale_v1_user_proto_msgTypes[6].Exporter = func(v any, i int) any {
   602| 			switch v := v.(*RenameUserResponse); i {
   603| 			case 0:
   604| 				return &v.state
   605| 			case 1:
   606| 				return &v.sizeCache
   607| 			case 2:
   608| 				return &v.unknownFields
   609| 			default:
   610| 				return nil
   611| 			}
   612| 		}
   613| 		file_headscale_v1_user_proto_msgTypes[7].Exporter = func(v any, i int) any {
   614| 			switch v := v.(*DeleteUserRequest); i {
   615| 			case 0:
   616| 				return &v.state
   617| 			case 1:
   618| 				return &v.sizeCache
   619| 			case 2:
   620| 				return &v.unknownFields
   621| 			default:
   622| 				return nil
   623| 			}
   624| 		}
   625| 		file_headscale_v1_user_proto_msgTypes[8].Exporter = func(v any, i int) any {
   626| 			switch v := v.(*DeleteUserResponse); i {
   627| 			case 0:
   628| 				return &v.state
   629| 			case 1:
   630| 				return &v.sizeCache
   631| 			case 2:
   632| 				return &v.unknownFields
   633| 			default:
   634| 				return nil
   635| 			}
   636| 		}
   637| 		file_headscale_v1_user_proto_msgTypes[9].Exporter = func(v any, i int) any {
   638| 			switch v := v.(*ListUsersRequest); i {
   639| 			case 0:
   640| 				return &v.state
   641| 			case 1:
   642| 				return &v.sizeCache
   643| 			case 2:
   644| 				return &v.unknownFields
   645| 			default:
   646| 				return nil
   647| 			}
   648| 		}
   649| 		file_headscale_v1_user_proto_msgTypes[10].Exporter = func(v any, i int) any {
   650| 			switch v := v.(*ListUsersResponse); i {
   651| 			case 0:
   652| 				return &v.state
   653| 			case 1:
   654| 				return &v.sizeCache
   655| 			case 2:
   656| 				return &v.unknownFields
   657| 			default:
   658| 				return nil
   659| 			}
   660| 		}
   661| 	}
   662| 	type x struct{}
   663| 	out := protoimpl.TypeBuilder{
   664| 		File: protoimpl.DescBuilder{
   665| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   666| 			RawDescriptor: file_headscale_v1_user_proto_rawDesc,
   667| 			NumEnums:      0,
   668| 			NumMessages:   11,
   669| 			NumExtensions: 0,


# ====================================================================
# FILE: hscontrol/app.go
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-792 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"crypto/tls"
     5| 	"errors"
     6| 	"fmt"
     7| 	"io"
     8| 	"net"
     9| 	"net/http"
    10| 	_ "net/http/pprof" // nolint
    11| 	"os"
    12| 	"os/signal"
    13| 	"path/filepath"
    14| 	"runtime"
    15| 	"strings"
    16| 	"sync"
    17| 	"syscall"
    18| 	"time"
    19| 	"github.com/coreos/go-oidc/v3/oidc"
    20| 	"github.com/davecgh/go-spew/spew"
    21| 	"github.com/gorilla/mux"
    22| 	grpcMiddleware "github.com/grpc-ecosystem/go-grpc-middleware"
    23| 	grpcRuntime "github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
    24| 	"github.com/juanfont/headscale"
    25| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    26| 	"github.com/juanfont/headscale/hscontrol/db"
    27| 	"github.com/juanfont/headscale/hscontrol/derp"
    28| 	derpServer "github.com/juanfont/headscale/hscontrol/derp/server"
    29| 	"github.com/juanfont/headscale/hscontrol/mapper"
    30| 	"github.com/juanfont/headscale/hscontrol/notifier"
    31| 	"github.com/juanfont/headscale/hscontrol/policy"
    32| 	"github.com/juanfont/headscale/hscontrol/types"
    33| 	"github.com/juanfont/headscale/hscontrol/util"
    34| 	"github.com/patrickmn/go-cache"
    35| 	zerolog "github.com/philip-bui/grpc-zerolog"
    36| 	"github.com/pkg/profile"
    37| 	"github.com/prometheus/client_golang/prometheus/promhttp"
    38| 	zl "github.com/rs/zerolog"
    39| 	"github.com/rs/zerolog/log"
    40| 	"golang.org/x/crypto/acme"
    41| 	"golang.org/x/crypto/acme/autocert"
    42| 	"golang.org/x/oauth2"
    43| 	"golang.org/x/sync/errgroup"
    44| 	"google.golang.org/grpc"
    45| 	"google.golang.org/grpc/codes"
    46| 	"google.golang.org/grpc/credentials"
    47| 	"google.golang.org/grpc/credentials/insecure"
    48| 	"google.golang.org/grpc/metadata"
    49| 	"google.golang.org/grpc/peer"
    50| 	"google.golang.org/grpc/reflection"
    51| 	"google.golang.org/grpc/status"
    52| 	"gorm.io/gorm"
    53| 	"tailscale.com/envknob"
    54| 	"tailscale.com/tailcfg"
    55| 	"tailscale.com/types/dnstype"
    56| 	"tailscale.com/types/key"
    57| 	"tailscale.com/util/dnsname"
    58| )
    59| var (
    60| 	errSTUNAddressNotSet                   = errors.New("STUN address not set")
    61| 	errUnsupportedLetsEncryptChallengeType = errors.New(
    62| 		"unknown value for Lets Encrypt challenge type",
    63| 	)
    64| 	errEmptyInitialDERPMap = errors.New(
    65| 		"initial DERPMap is empty, Headscale requires at least one entry",
    66| 	)
    67| )
    68| const (
    69| 	AuthPrefix         = "Bearer "
    70| 	updateInterval     = 5 * time.Second
    71| 	privateKeyFileMode = 0o600
    72| 	headscaleDirPerm   = 0o700
    73| 	registerCacheExpiration = time.Minute * 15
    74| 	registerCacheCleanup    = time.Minute * 20
    75| )
    76| type Headscale struct {
    77| 	cfg             *types.Config
    78| 	db              *db.HSDatabase
    79| 	ipAlloc         *db.IPAllocator
    80| 	noisePrivateKey *key.MachinePrivate
    81| 	ephemeralGC     *db.EphemeralGarbageCollector
    82| 	DERPMap    *tailcfg.DERPMap
    83| 	DERPServer *derpServer.DERPServer
    84| 	ACLPolicy *policy.ACLPolicy
    85| 	mapper       *mapper.Mapper
    86| 	nodeNotifier *notifier.Notifier
    87| 	oidcProvider *oidc.Provider
    88| 	oauth2Config *oauth2.Config
    89| 	registrationCache *cache.Cache
    90| 	pollNetMapStreamWG sync.WaitGroup
    91| }
    92| var (
    93| 	profilingEnabled = envknob.Bool("HEADSCALE_DEBUG_PROFILING_ENABLED")
    94| 	profilingPath    = envknob.String("HEADSCALE_DEBUG_PROFILING_PATH")
    95| 	tailsqlEnabled   = envknob.Bool("HEADSCALE_DEBUG_TAILSQL_ENABLED")
    96| 	tailsqlStateDir  = envknob.String("HEADSCALE_DEBUG_TAILSQL_STATE_DIR")
    97| 	tailsqlTSKey     = envknob.String("TS_AUTHKEY")
    98| 	dumpConfig       = envknob.Bool("HEADSCALE_DEBUG_DUMP_CONFIG")
    99| )
   100| func NewHeadscale(cfg *types.Config) (*Headscale, error) {
   101| 	var err error
   102| 	if profilingEnabled {
   103| 		runtime.SetBlockProfileRate(1)
   104| 	}
   105| 	noisePrivateKey, err := readOrCreatePrivateKey(cfg.NoisePrivateKeyPath)
   106| 	if err != nil {
   107| 		return nil, fmt.Errorf("failed to read or create Noise protocol private key: %w", err)
   108| 	}
   109| 	registrationCache := cache.New(
   110| 		registerCacheExpiration,
   111| 		registerCacheCleanup,
   112| 	)
   113| 	app := Headscale{
   114| 		cfg:                cfg,
   115| 		noisePrivateKey:    noisePrivateKey,
   116| 		registrationCache:  registrationCache,
   117| 		pollNetMapStreamWG: sync.WaitGroup{},
   118| 		nodeNotifier:       notifier.NewNotifier(cfg),
   119| 	}
   120| 	app.db, err = db.NewHeadscaleDatabase(
   121| 		cfg.Database,
   122| 		cfg.BaseDomain)
   123| 	if err != nil {
   124| 		return nil, err
   125| 	}
   126| 	app.ipAlloc, err = db.NewIPAllocator(app.db, cfg.PrefixV4, cfg.PrefixV6, cfg.IPAllocation)
   127| 	if err != nil {
   128| 		return nil, err
   129| 	}
   130| 	app.ephemeralGC = db.NewEphemeralGarbageCollector(func(ni types.NodeID) {
   131| 		if err := app.db.DeleteEphemeralNode(ni); err != nil {
   132| 			log.Err(err).Uint64("node.id", ni.Uint64()).Msgf("failed to delete ephemeral node")
   133| 		}
   134| 	})
   135| 	if cfg.OIDC.Issuer != "" {
   136| 		err = app.initOIDC()
   137| 		if err != nil {
   138| 			if cfg.OIDC.OnlyStartIfOIDCIsAvailable {
   139| 				return nil, err
   140| 			} else {
   141| 				log.Warn().Err(err).Msg("failed to set up OIDC provider, falling back to CLI based authentication")
   142| 			}
   143| 		}
   144| 	}
   145| 	if app.cfg.DNSConfig != nil && app.cfg.DNSConfig.Proxied { // if MagicDNS
   146| 		var magicDNSDomains []dnsname.FQDN
   147| 		if cfg.PrefixV4 != nil {
   148| 			magicDNSDomains = append(magicDNSDomains, util.GenerateIPv4DNSRootDomain(*cfg.PrefixV4)...)
   149| 		}
   150| 		if cfg.PrefixV6 != nil {
   151| 			magicDNSDomains = append(magicDNSDomains, util.GenerateIPv6DNSRootDomain(*cfg.PrefixV6)...)
   152| 		}
   153| 		if app.cfg.DNSConfig.Routes == nil {
   154| 			app.cfg.DNSConfig.Routes = make(map[string][]*dnstype.Resolver)
   155| 		}
   156| 		for _, d := range magicDNSDomains {
   157| 			app.cfg.DNSConfig.Routes[d.WithoutTrailingDot()] = nil
   158| 		}
   159| 	}
   160| 	if cfg.DERP.ServerEnabled {
   161| 		derpServerKey, err := readOrCreatePrivateKey(cfg.DERP.ServerPrivateKeyPath)
   162| 		if err != nil {
   163| 			return nil, fmt.Errorf("failed to read or create DERP server private key: %w", err)
   164| 		}
   165| 		if derpServerKey.Equal(*noisePrivateKey) {
   166| 			return nil, fmt.Errorf(
   167| 				"DERP server private key and noise private key are the same: %w",
   168| 				err,
   169| 			)
   170| 		}
   171| 		embeddedDERPServer, err := derpServer.NewDERPServer(
   172| 			cfg.ServerURL,
   173| 			key.NodePrivate(*derpServerKey),
   174| 			&cfg.DERP,
   175| 		)
   176| 		if err != nil {
   177| 			return nil, err
   178| 		}
   179| 		app.DERPServer = embeddedDERPServer
   180| 	}
   181| 	return &app, nil
   182| }
   183| func (h *Headscale) redirect(w http.ResponseWriter, req *http.Request) {
   184| 	target := h.cfg.ServerURL + req.URL.RequestURI()
   185| 	http.Redirect(w, req, target, http.StatusFound)
   186| }
   187| func (h *Headscale) expireExpiredNodes(ctx context.Context, every time.Duration) {
   188| 	ticker := time.NewTicker(every)
   189| 	lastCheck := time.Unix(0, 0)
   190| 	var update types.StateUpdate
   191| 	var changed bool
   192| 	for {
   193| 		select {
   194| 		case <-ctx.Done():
   195| 			ticker.Stop()
   196| 			return
   197| 		case <-ticker.C:
   198| 			if err := h.db.Write(func(tx *gorm.DB) error {
   199| 				lastCheck, update, changed = db.ExpireExpiredNodes(tx, lastCheck)
   200| 				return nil
   201| 			}); err != nil {
   202| 				log.Error().Err(err).Msg("database error while expiring nodes")
   203| 				continue
   204| 			}
   205| 			if changed {
   206| 				log.Trace().Interface("nodes", update.ChangePatches).Msgf("expiring nodes")
   207| 				ctx := types.NotifyCtx(context.Background(), "expire-expired", "na")
   208| 				h.nodeNotifier.NotifyAll(ctx, update)
   209| 			}
   210| 		}
   211| 	}
   212| }
   213| func (h *Headscale) scheduledDERPMapUpdateWorker(cancelChan <-chan struct{}) {
   214| 	log.Info().
   215| 		Dur("frequency", h.cfg.DERP.UpdateFrequency).
   216| 		Msg("Setting up a DERPMap update worker")
   217| 	ticker := time.NewTicker(h.cfg.DERP.UpdateFrequency)
   218| 	for {
   219| 		select {
   220| 		case <-cancelChan:
   221| 			return
   222| 		case <-ticker.C:
   223| 			log.Info().Msg("Fetching DERPMap updates")
   224| 			h.DERPMap = derp.GetDERPMap(h.cfg.DERP)
   225| 			if h.cfg.DERP.ServerEnabled && h.cfg.DERP.AutomaticallyAddEmbeddedDerpRegion {
   226| 				region, _ := h.DERPServer.GenerateRegion()
   227| 				h.DERPMap.Regions[region.RegionID] = &region
   228| 			}
   229| 			ctx := types.NotifyCtx(context.Background(), "derpmap-update", "na")
   230| 			h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   231| 				Type:    types.StateDERPUpdated,
   232| 				DERPMap: h.DERPMap,
   233| 			})
   234| 		}
   235| 	}
   236| }
   237| func (h *Headscale) grpcAuthenticationInterceptor(ctx context.Context,
   238| 	req interface{},
   239| 	info *grpc.UnaryServerInfo,
   240| 	handler grpc.UnaryHandler,
   241| ) (interface{}, error) {
   242| 	client, _ := peer.FromContext(ctx)
   243| 	log.Trace().
   244| 		Caller().
   245| 		Str("client_address", client.Addr.String()).
   246| 		Msg("Client is trying to authenticate")
   247| 	meta, ok := metadata.FromIncomingContext(ctx)
   248| 	if !ok {
   249| 		return ctx, status.Errorf(
   250| 			codes.InvalidArgument,
   251| 			"Retrieving metadata is failed",
   252| 		)
   253| 	}
   254| 	authHeader, ok := meta["authorization"]
   255| 	if !ok {
   256| 		return ctx, status.Errorf(
   257| 			codes.Unauthenticated,
   258| 			"Authorization token is not supplied",
   259| 		)
   260| 	}
   261| 	token := authHeader[0]
   262| 	if !strings.HasPrefix(token, AuthPrefix) {
   263| 		return ctx, status.Error(
   264| 			codes.Unauthenticated,
   265| 			`missing "Bearer " prefix in "Authorization" header`,
   266| 		)
   267| 	}
   268| 	valid, err := h.db.ValidateAPIKey(strings.TrimPrefix(token, AuthPrefix))
   269| 	if err != nil {
   270| 		return ctx, status.Error(codes.Internal, "failed to validate token")
   271| 	}
   272| 	if !valid {
   273| 		log.Info().
   274| 			Str("client_address", client.Addr.String()).
   275| 			Msg("invalid token")
   276| 		return ctx, status.Error(codes.Unauthenticated, "invalid token")
   277| 	}
   278| 	return handler(ctx, req)
   279| }
   280| func (h *Headscale) httpAuthenticationMiddleware(next http.Handler) http.Handler {
   281| 	return http.HandlerFunc(func(
   282| 		writer http.ResponseWriter,
   283| 		req *http.Request,
   284| 	) {
   285| 		log.Trace().
   286| 			Caller().
   287| 			Str("client_address", req.RemoteAddr).
   288| 			Msg("HTTP authentication invoked")
   289| 		authHeader := req.Header.Get("authorization")
   290| 		if !strings.HasPrefix(authHeader, AuthPrefix) {
   291| 			log.Error().
   292| 				Caller().
   293| 				Str("client_address", req.RemoteAddr).
   294| 				Msg(`missing "Bearer " prefix in "Authorization" header`)
   295| 			writer.WriteHeader(http.StatusUnauthorized)
   296| 			_, err := writer.Write([]byte("Unauthorized"))
   297| 			if err != nil {
   298| 				log.Error().
   299| 					Caller().
   300| 					Err(err).
   301| 					Msg("Failed to write response")
   302| 			}
   303| 			return
   304| 		}
   305| 		valid, err := h.db.ValidateAPIKey(strings.TrimPrefix(authHeader, AuthPrefix))
   306| 		if err != nil {
   307| 			log.Error().
   308| 				Caller().
   309| 				Err(err).
   310| 				Str("client_address", req.RemoteAddr).
   311| 				Msg("failed to validate token")
   312| 			writer.WriteHeader(http.StatusInternalServerError)
   313| 			_, err := writer.Write([]byte("Unauthorized"))
   314| 			if err != nil {
   315| 				log.Error().
   316| 					Caller().
   317| 					Err(err).
   318| 					Msg("Failed to write response")
   319| 			}
   320| 			return
   321| 		}
   322| 		if !valid {
   323| 			log.Info().
   324| 				Str("client_address", req.RemoteAddr).
   325| 				Msg("invalid token")
   326| 			writer.WriteHeader(http.StatusUnauthorized)
   327| 			_, err := writer.Write([]byte("Unauthorized"))
   328| 			if err != nil {
   329| 				log.Error().
   330| 					Caller().
   331| 					Err(err).
   332| 					Msg("Failed to write response")
   333| 			}
   334| 			return
   335| 		}
   336| 		next.ServeHTTP(writer, req)
   337| 	})
   338| }
   339| func (h *Headscale) ensureUnixSocketIsAbsent() error {
   340| 	if _, err := os.Stat(h.cfg.UnixSocket); errors.Is(err, os.ErrNotExist) {
   341| 		return nil
   342| 	}
   343| 	return os.Remove(h.cfg.UnixSocket)
   344| }
   345| func (h *Headscale) createRouter(grpcMux *grpcRuntime.ServeMux) *mux.Router {
   346| 	router := mux.NewRouter()
   347| 	router.Use(prometheusMiddleware)
   348| 	router.HandleFunc(ts2021UpgradePath, h.NoiseUpgradeHandler).Methods(http.MethodPost)
   349| 	router.HandleFunc("/health", h.HealthHandler).Methods(http.MethodGet)
   350| 	router.HandleFunc("/key", h.KeyHandler).Methods(http.MethodGet)
   351| 	router.HandleFunc("/register/{mkey}", h.RegisterWebAPI).Methods(http.MethodGet)
   352| 	router.HandleFunc("/oidc/register/{mkey}", h.RegisterOIDC).Methods(http.MethodGet)
   353| 	router.HandleFunc("/oidc/callback", h.OIDCCallback).Methods(http.MethodGet)
   354| 	router.HandleFunc("/apple", h.AppleConfigMessage).Methods(http.MethodGet)
   355| 	router.HandleFunc("/apple/{platform}", h.ApplePlatformConfig).
   356| 		Methods(http.MethodGet)
   357| 	router.HandleFunc("/windows", h.WindowsConfigMessage).Methods(http.MethodGet)
   358| 	router.HandleFunc("/swagger", headscale.SwaggerUI).Methods(http.MethodGet)
   359| 	router.HandleFunc("/swagger/v1/openapiv2.json", headscale.SwaggerAPIv1).
   360| 		Methods(http.MethodGet)
   361| 	if h.cfg.DERP.ServerEnabled {
   362| 		router.HandleFunc("/derp", h.DERPServer.DERPHandler)
   363| 		router.HandleFunc("/derp/probe", derpServer.DERPProbeHandler)
   364| 		router.HandleFunc("/bootstrap-dns", derpServer.DERPBootstrapDNSHandler(h.DERPMap))
   365| 	}
   366| 	apiRouter := router.PathPrefix("/api").Subrouter()
   367| 	apiRouter.Use(h.httpAuthenticationMiddleware)
   368| 	apiRouter.PathPrefix("/v1/").HandlerFunc(grpcMux.ServeHTTP)
   369| 	router.PathPrefix("/").HandlerFunc(notFoundHandler)
   370| 	return router
   371| }
   372| func (h *Headscale) Serve() error {
   373| 	if profilingEnabled {
   374| 		if profilingPath != "" {
   375| 			err := os.MkdirAll(profilingPath, os.ModePerm)
   376| 			if err != nil {
   377| 				log.Fatal().Err(err).Msg("failed to create profiling directory")
   378| 			}
   379| 			defer profile.Start(profile.ProfilePath(profilingPath)).Stop()
   380| 		} else {
   381| 			defer profile.Start().Stop()
   382| 		}
   383| 	}
   384| 	var err error
   385| 	if err = h.loadACLPolicy(); err != nil {
   386| 		return fmt.Errorf("failed to load ACL policy: %w", err)
   387| 	}
   388| 	if dumpConfig {
   389| 		spew.Dump(h.cfg)
   390| 	}
   391| 	h.DERPMap = derp.GetDERPMap(h.cfg.DERP)
   392| 	h.mapper = mapper.NewMapper(h.db, h.cfg, h.DERPMap, h.nodeNotifier)
   393| 	if h.cfg.DERP.ServerEnabled {
   394| 		if h.cfg.DERP.STUNAddr == "" {
   395| 			return errSTUNAddressNotSet
   396| 		}
   397| 		region, err := h.DERPServer.GenerateRegion()
   398| 		if err != nil {
   399| 			return fmt.Errorf("generating DERP region for embedded server: %w", err)
   400| 		}
   401| 		if h.cfg.DERP.AutomaticallyAddEmbeddedDerpRegion {
   402| 			h.DERPMap.Regions[region.RegionID] = &region
   403| 		}
   404| 		go h.DERPServer.ServeSTUN()
   405| 	}
   406| 	if h.cfg.DERP.AutoUpdate {
   407| 		derpMapCancelChannel := make(chan struct{})
   408| 		defer func() { derpMapCancelChannel <- struct{}{} }()
   409| 		go h.scheduledDERPMapUpdateWorker(derpMapCancelChannel)
   410| 	}
   411| 	if len(h.DERPMap.Regions) == 0 {
   412| 		return errEmptyInitialDERPMap
   413| 	}
   414| 	go h.ephemeralGC.Start()
   415| 	ephmNodes, err := h.db.ListEphemeralNodes()
   416| 	if err != nil {
   417| 		return fmt.Errorf("failed to list ephemeral nodes: %w", err)
   418| 	}
   419| 	for _, node := range ephmNodes {
   420| 		h.ephemeralGC.Schedule(node.ID, h.cfg.EphemeralNodeInactivityTimeout)
   421| 	}
   422| 	expireNodeCtx, expireNodeCancel := context.WithCancel(context.Background())
   423| 	defer expireNodeCancel()
   424| 	go h.expireExpiredNodes(expireNodeCtx, updateInterval)
   425| 	if zl.GlobalLevel() == zl.TraceLevel {
   426| 		zerolog.RespLog = true
   427| 	} else {
   428| 		zerolog.RespLog = false
   429| 	}
   430| 	errorGroup := new(errgroup.Group)
   431| 	ctx := context.Background()
   432| 	ctx, cancel := context.WithCancel(ctx)
   433| 	defer cancel()
   434| 	err = h.ensureUnixSocketIsAbsent()
   435| 	if err != nil {
   436| 		return fmt.Errorf("unable to remove old socket file: %w", err)
   437| 	}
   438| 	socketDir := filepath.Dir(h.cfg.UnixSocket)
   439| 	err = util.EnsureDir(socketDir)
   440| 	if err != nil {
   441| 		return fmt.Errorf("setting up unix socket: %w", err)
   442| 	}
   443| 	socketListener, err := net.Listen("unix", h.cfg.UnixSocket)
   444| 	if err != nil {
   445| 		return fmt.Errorf("failed to set up gRPC socket: %w", err)
   446| 	}
   447| 	if err := os.Chmod(h.cfg.UnixSocket, h.cfg.UnixSocketPermission); err != nil {
   448| 		return fmt.Errorf("failed change permission of gRPC socket: %w", err)
   449| 	}
   450| 	grpcGatewayMux := grpcRuntime.NewServeMux()
   451| 	grpcGatewayConn, err := grpc.Dial(
   452| 		h.cfg.UnixSocket,
   453| 		[]grpc.DialOption{
   454| 			grpc.WithTransportCredentials(insecure.NewCredentials()),
   455| 			grpc.WithContextDialer(util.GrpcSocketDialer),
   456| 		}...,
   457| 	)
   458| 	if err != nil {
   459| 		return fmt.Errorf("setting up gRPC gateway via socket: %w", err)
   460| 	}
   461| 	err = v1.RegisterHeadscaleServiceHandler(ctx, grpcGatewayMux, grpcGatewayConn)
   462| 	if err != nil {
   463| 		return fmt.Errorf("registering Headscale API service to gRPC: %w", err)
   464| 	}
   465| 	grpcSocket := grpc.NewServer(
   466| 	)
   467| 	v1.RegisterHeadscaleServiceServer(grpcSocket, newHeadscaleV1APIServer(h))
   468| 	reflection.Register(grpcSocket)
   469| 	errorGroup.Go(func() error { return grpcSocket.Serve(socketListener) })
   470| 	tlsConfig, err := h.getTLSSettings()
   471| 	if err != nil {
   472| 		return fmt.Errorf("configuring TLS settings: %w", err)
   473| 	}
   474| 	var grpcServer *grpc.Server
   475| 	var grpcListener net.Listener
   476| 	if tlsConfig != nil || h.cfg.GRPCAllowInsecure {
   477| 		log.Info().Msgf("Enabling remote gRPC at %s", h.cfg.GRPCAddr)
   478| 		grpcOptions := []grpc.ServerOption{
   479| 			grpc.UnaryInterceptor(
   480| 				grpcMiddleware.ChainUnaryServer(
   481| 					h.grpcAuthenticationInterceptor,
   482| 				),
   483| 			),
   484| 		}
   485| 		if tlsConfig != nil {
   486| 			grpcOptions = append(grpcOptions,
   487| 				grpc.Creds(credentials.NewTLS(tlsConfig)),
   488| 			)
   489| 		} else {
   490| 			log.Warn().Msg("gRPC is running without security")
   491| 		}
   492| 		grpcServer = grpc.NewServer(grpcOptions...)
   493| 		v1.RegisterHeadscaleServiceServer(grpcServer, newHeadscaleV1APIServer(h))
   494| 		reflection.Register(grpcServer)
   495| 		grpcListener, err = net.Listen("tcp", h.cfg.GRPCAddr)
   496| 		if err != nil {
   497| 			return fmt.Errorf("failed to bind to TCP address: %w", err)
   498| 		}
   499| 		errorGroup.Go(func() error { return grpcServer.Serve(grpcListener) })
   500| 		log.Info().
   501| 			Msgf("listening and serving gRPC on: %s", h.cfg.GRPCAddr)
   502| 	}
   503| 	router := h.createRouter(grpcGatewayMux)
   504| 	httpServer := &http.Server{
   505| 		Addr:        h.cfg.Addr,
   506| 		Handler:     router,
   507| 		ReadTimeout: types.HTTPTimeout,
   508| 		WriteTimeout: types.HTTPTimeout,
   509| 	}
   510| 	var httpListener net.Listener
   511| 	if tlsConfig != nil {
   512| 		httpServer.TLSConfig = tlsConfig
   513| 		httpListener, err = tls.Listen("tcp", h.cfg.Addr, tlsConfig)
   514| 	} else {
   515| 		httpListener, err = net.Listen("tcp", h.cfg.Addr)
   516| 	}
   517| 	if err != nil {
   518| 		return fmt.Errorf("failed to bind to TCP address: %w", err)
   519| 	}
   520| 	errorGroup.Go(func() error { return httpServer.Serve(httpListener) })
   521| 	log.Info().
   522| 		Msgf("listening and serving HTTP on: %s", h.cfg.Addr)
   523| 	debugMux := http.NewServeMux()
   524| 	debugMux.Handle("/debug/pprof/", http.DefaultServeMux)
   525| 	debugMux.HandleFunc("/debug/notifier", func(w http.ResponseWriter, r *http.Request) {
   526| 		w.WriteHeader(http.StatusOK)
   527| 		w.Write([]byte(h.nodeNotifier.String()))
   528| 	})
   529| 	debugMux.Handle("/metrics", promhttp.Handler())
   530| 	debugHTTPServer := &http.Server{
   531| 		Addr:         h.cfg.MetricsAddr,
   532| 		Handler:      debugMux,
   533| 		ReadTimeout:  types.HTTPTimeout,
   534| 		WriteTimeout: 0,
   535| 	}
   536| 	debugHTTPListener, err := net.Listen("tcp", h.cfg.MetricsAddr)
   537| 	if err != nil {
   538| 		return fmt.Errorf("failed to bind to TCP address: %w", err)
   539| 	}
   540| 	errorGroup.Go(func() error { return debugHTTPServer.Serve(debugHTTPListener) })
   541| 	log.Info().
   542| 		Msgf("listening and serving debug and metrics on: %s", h.cfg.MetricsAddr)
   543| 	var tailsqlContext context.Context
   544| 	if tailsqlEnabled {
   545| 		if h.cfg.Database.Type != types.DatabaseSqlite {
   546| 			log.Fatal().
   547| 				Str("type", h.cfg.Database.Type).
   548| 				Msgf("tailsql only support %q", types.DatabaseSqlite)
   549| 		}
   550| 		if tailsqlTSKey == "" {
   551| 			log.Fatal().Msg("tailsql requires TS_AUTHKEY to be set")
   552| 		}
   553| 		tailsqlContext = context.Background()
   554| 		go runTailSQLService(ctx, util.TSLogfWrapper(), tailsqlStateDir, h.cfg.Database.Sqlite.Path)
   555| 	}
   556| 	sigc := make(chan os.Signal, 1)
   557| 	signal.Notify(sigc,
   558| 		syscall.SIGHUP,
   559| 		syscall.SIGINT,
   560| 		syscall.SIGTERM,
   561| 		syscall.SIGQUIT,
   562| 		syscall.SIGHUP)
   563| 	sigFunc := func(c chan os.Signal) {
   564| 		for {
   565| 			sig := <-c
   566| 			switch sig {
   567| 			case syscall.SIGHUP:
   568| 				log.Info().
   569| 					Str("signal", sig.String()).
   570| 					Msg("Received SIGHUP, reloading ACL and Config")
   571| 				if err := h.loadACLPolicy(); err != nil {
   572| 					log.Error().Err(err).Msg("failed to reload ACL policy")
   573| 				}
   574| 				if h.ACLPolicy != nil {
   575| 					log.Info().
   576| 						Msg("ACL policy successfully reloaded, notifying nodes of change")
   577| 					ctx := types.NotifyCtx(context.Background(), "acl-sighup", "na")
   578| 					h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   579| 						Type: types.StateFullUpdate,
   580| 					})
   581| 				}
   582| 			default:
   583| 				info := func(msg string) { log.Info().Msg(msg) }
   584| 				log.Info().
   585| 					Str("signal", sig.String()).
   586| 					Msg("Received signal to stop, shutting down gracefully")
   587| 				expireNodeCancel()
   588| 				h.ephemeralGC.Close()
   589| 				ctx, cancel := context.WithTimeout(
   590| 					context.Background(),
   591| 					types.HTTPShutdownTimeout,
   592| 				)
   593| 				info("shutting down debug http server")
   594| 				if err := debugHTTPServer.Shutdown(ctx); err != nil {
   595| 					log.Error().Err(err).Msg("failed to shutdown prometheus http")
   596| 				}
   597| 				info("shutting down main http server")
   598| 				if err := httpServer.Shutdown(ctx); err != nil {
   599| 					log.Error().Err(err).Msg("failed to shutdown http")
   600| 				}
   601| 				info("closing node notifier")
   602| 				h.nodeNotifier.Close()
   603| 				info("waiting for netmap stream to close")
   604| 				h.pollNetMapStreamWG.Wait()
   605| 				info("shutting down grpc server (socket)")
   606| 				grpcSocket.GracefulStop()
   607| 				if grpcServer != nil {
   608| 					info("shutting down grpc server (external)")
   609| 					grpcServer.GracefulStop()
   610| 					grpcListener.Close()
   611| 				}
   612| 				if tailsqlContext != nil {
   613| 					info("shutting down tailsql")
   614| 					tailsqlContext.Done()
   615| 				}
   616| 				info("closing network listeners")
   617| 				debugHTTPListener.Close()
   618| 				httpListener.Close()
   619| 				grpcGatewayConn.Close()
   620| 				info("closing socket listener")
   621| 				socketListener.Close()
   622| 				info("closing database connection")
   623| 				err = h.db.Close()
   624| 				if err != nil {
   625| 					log.Error().Err(err).Msg("failed to close db")
   626| 				}
   627| 				log.Info().
   628| 					Msg("Headscale stopped")
   629| 				cancel()
   630| 				return
   631| 			}
   632| 		}
   633| 	}
   634| 	errorGroup.Go(func() error {
   635| 		sigFunc(sigc)
   636| 		return nil
   637| 	})
   638| 	return errorGroup.Wait()
   639| }
   640| func (h *Headscale) getTLSSettings() (*tls.Config, error) {
   641| 	var err error
   642| 	if h.cfg.TLS.LetsEncrypt.Hostname != "" {
   643| 		if !strings.HasPrefix(h.cfg.ServerURL, "https://") {
   644| 			log.Warn().
   645| 				Msg("Listening with TLS but ServerURL does not start with https://")
   646| 		}
   647| 		certManager := autocert.Manager{
   648| 			Prompt:     autocert.AcceptTOS,
   649| 			HostPolicy: autocert.HostWhitelist(h.cfg.TLS.LetsEncrypt.Hostname),
   650| 			Cache:      autocert.DirCache(h.cfg.TLS.LetsEncrypt.CacheDir),
   651| 			Client: &acme.Client{
   652| 				DirectoryURL: h.cfg.ACMEURL,
   653| 			},
   654| 			Email: h.cfg.ACMEEmail,
   655| 		}
   656| 		switch h.cfg.TLS.LetsEncrypt.ChallengeType {
   657| 		case types.TLSALPN01ChallengeType:
   658| 			return certManager.TLSConfig(), nil
   659| 		case types.HTTP01ChallengeType:
   660| 			server := &http.Server{
   661| 				Addr:        h.cfg.TLS.LetsEncrypt.Listen,
   662| 				Handler:     certManager.HTTPHandler(http.HandlerFunc(h.redirect)),
   663| 				ReadTimeout: types.HTTPTimeout,
   664| 			}
   665| 			go func() {
   666| 				err := server.ListenAndServe()
   667| 				log.Fatal().
   668| 					Caller().
   669| 					Err(err).
   670| 					Msg("failed to set up a HTTP server")
   671| 			}()
   672| 			return certManager.TLSConfig(), nil
   673| 		default:
   674| 			return nil, errUnsupportedLetsEncryptChallengeType
   675| 		}
   676| 	} else if h.cfg.TLS.CertPath == "" {
   677| 		if !strings.HasPrefix(h.cfg.ServerURL, "http://") {
   678| 			log.Warn().Msg("Listening without TLS but ServerURL does not start with http://")
   679| 		}
   680| 		return nil, err
   681| 	} else {
   682| 		if !strings.HasPrefix(h.cfg.ServerURL, "https://") {
   683| 			log.Warn().Msg("Listening with TLS but ServerURL does not start with https://")
   684| 		}
   685| 		tlsConfig := &tls.Config{
   686| 			NextProtos:   []string{"http/1.1"},
   687| 			Certificates: make([]tls.Certificate, 1),
   688| 			MinVersion:   tls.VersionTLS12,
   689| 		}
   690| 		tlsConfig.Certificates[0], err = tls.LoadX509KeyPair(h.cfg.TLS.CertPath, h.cfg.TLS.KeyPath)
   691| 		return tlsConfig, err
   692| 	}
   693| }
   694| func notFoundHandler(
   695| 	writer http.ResponseWriter,
   696| 	req *http.Request,
   697| ) {
   698| 	body, _ := io.ReadAll(req.Body)
   699| 	log.Trace().
   700| 		Interface("header", req.Header).
   701| 		Interface("proto", req.Proto).
   702| 		Interface("url", req.URL).
   703| 		Bytes("body", body).
   704| 		Msg("Request did not match")
   705| 	writer.WriteHeader(http.StatusNotFound)
   706| }
   707| func readOrCreatePrivateKey(path string) (*key.MachinePrivate, error) {
   708| 	dir := filepath.Dir(path)
   709| 	err := util.EnsureDir(dir)
   710| 	if err != nil {
   711| 		return nil, fmt.Errorf("ensuring private key directory: %w", err)
   712| 	}
   713| 	privateKey, err := os.ReadFile(path)
   714| 	if errors.Is(err, os.ErrNotExist) {
   715| 		log.Info().Str("path", path).Msg("No private key file at path, creating...")
   716| 		machineKey := key.NewMachine()
   717| 		machineKeyStr, err := machineKey.MarshalText()
   718| 		if err != nil {
   719| 			return nil, fmt.Errorf(
   720| 				"failed to convert private key to string for saving: %w",
   721| 				err,
   722| 			)
   723| 		}
   724| 		err = os.WriteFile(path, machineKeyStr, privateKeyFileMode)
   725| 		if err != nil {
   726| 			return nil, fmt.Errorf(
   727| 				"failed to save private key to disk at path %q: %w",
   728| 				path,
   729| 				err,
   730| 			)
   731| 		}
   732| 		return &machineKey, nil
   733| 	} else if err != nil {
   734| 		return nil, fmt.Errorf("failed to read private key file: %w", err)
   735| 	}
   736| 	trimmedPrivateKey := strings.TrimSpace(string(privateKey))
   737| 	var machineKey key.MachinePrivate
   738| 	if err = machineKey.UnmarshalText([]byte(trimmedPrivateKey)); err != nil {
   739| 		return nil, fmt.Errorf("failed to parse private key: %w", err)
   740| 	}
   741| 	return &machineKey, nil
   742| }
   743| func (h *Headscale) loadACLPolicy() error {
   744| 	var (
   745| 		pol *policy.ACLPolicy
   746| 		err error
   747| 	)
   748| 	switch h.cfg.Policy.Mode {
   749| 	case types.PolicyModeFile:
   750| 		path := h.cfg.Policy.Path
   751| 		if len(path) == 0 {
   752| 			return nil
   753| 		}
   754| 		absPath := util.AbsolutePathFromConfigPath(path)
   755| 		pol, err = policy.LoadACLPolicyFromPath(absPath)
   756| 		if err != nil {
   757| 			return fmt.Errorf("failed to load ACL policy from file: %w", err)
   758| 		}
   759| 		nodes, err := h.db.ListNodes()
   760| 		if err != nil {
   761| 			return fmt.Errorf("loading nodes from database to validate policy: %w", err)
   762| 		}
   763| 		_, err = pol.CompileFilterRules(nodes)
   764| 		if err != nil {
   765| 			return fmt.Errorf("verifying policy rules: %w", err)
   766| 		}
   767| 		if len(nodes) > 0 {
   768| 			_, err = pol.CompileSSHPolicy(nodes[0], nodes)
   769| 			if err != nil {
   770| 				return fmt.Errorf("verifying SSH rules: %w", err)
   771| 			}
   772| 		}
   773| 	case types.PolicyModeDB:
   774| 		p, err := h.db.GetPolicy()
   775| 		if err != nil {
   776| 			if errors.Is(err, types.ErrPolicyNotFound) {
   777| 				return nil
   778| 			}
   779| 			return fmt.Errorf("failed to get policy from database: %w", err)
   780| 		}
   781| 		pol, err = policy.LoadACLPolicyFromBytes([]byte(p.Data))
   782| 		if err != nil {
   783| 			return fmt.Errorf("failed to parse policy: %w", err)
   784| 		}
   785| 	default:
   786| 		log.Fatal().
   787| 			Str("mode", string(h.cfg.Policy.Mode)).
   788| 			Msg("Unknown ACL policy mode")
   789| 	}
   790| 	h.ACLPolicy = pol
   791| 	return nil
   792| }


# ====================================================================
# FILE: hscontrol/auth.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-572 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"encoding/json"
     5| 	"errors"
     6| 	"fmt"
     7| 	"net/http"
     8| 	"strings"
     9| 	"time"
    10| 	"github.com/juanfont/headscale/hscontrol/db"
    11| 	"github.com/juanfont/headscale/hscontrol/types"
    12| 	"github.com/juanfont/headscale/hscontrol/util"
    13| 	"github.com/rs/zerolog/log"
    14| 	"gorm.io/gorm"
    15| 	"tailscale.com/tailcfg"
    16| 	"tailscale.com/types/key"
    17| 	"tailscale.com/types/ptr"
    18| )
    19| func logAuthFunc(
    20| 	registerRequest tailcfg.RegisterRequest,
    21| 	machineKey key.MachinePublic,
    22| ) (func(string), func(string), func(error, string)) {
    23| 	return func(msg string) {
    24| 			log.Info().
    25| 				Caller().
    26| 				Str("machine_key", machineKey.ShortString()).
    27| 				Str("node_key", registerRequest.NodeKey.ShortString()).
    28| 				Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
    29| 				Str("node", registerRequest.Hostinfo.Hostname).
    30| 				Str("followup", registerRequest.Followup).
    31| 				Time("expiry", registerRequest.Expiry).
    32| 				Msg(msg)
    33| 		},
    34| 		func(msg string) {
    35| 			log.Trace().
    36| 				Caller().
    37| 				Str("machine_key", machineKey.ShortString()).
    38| 				Str("node_key", registerRequest.NodeKey.ShortString()).
    39| 				Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
    40| 				Str("node", registerRequest.Hostinfo.Hostname).
    41| 				Str("followup", registerRequest.Followup).
    42| 				Time("expiry", registerRequest.Expiry).
    43| 				Msg(msg)
    44| 		},
    45| 		func(err error, msg string) {
    46| 			log.Error().
    47| 				Caller().
    48| 				Str("machine_key", machineKey.ShortString()).
    49| 				Str("node_key", registerRequest.NodeKey.ShortString()).
    50| 				Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
    51| 				Str("node", registerRequest.Hostinfo.Hostname).
    52| 				Str("followup", registerRequest.Followup).
    53| 				Time("expiry", registerRequest.Expiry).
    54| 				Err(err).
    55| 				Msg(msg)
    56| 		}
    57| }
    58| func (h *Headscale) handleRegister(
    59| 	writer http.ResponseWriter,
    60| 	req *http.Request,
    61| 	regReq tailcfg.RegisterRequest,
    62| 	machineKey key.MachinePublic,
    63| ) {
    64| 	logInfo, logTrace, _ := logAuthFunc(regReq, machineKey)
    65| 	now := time.Now().UTC()
    66| 	logTrace("handleRegister called, looking up machine in DB")
    67| 	node, err := h.db.GetNodeByAnyKey(machineKey, regReq.NodeKey, regReq.OldNodeKey)
    68| 	logTrace("handleRegister database lookup has returned")
    69| 	if errors.Is(err, gorm.ErrRecordNotFound) {
    70| 		if regReq.Auth != nil && regReq.Auth.AuthKey != "" {
    71| 			h.handleAuthKey(writer, regReq, machineKey)
    72| 			return
    73| 		}
    74| 		if regReq.Followup != "" {
    75| 			logTrace("register request is a followup")
    76| 			if _, ok := h.registrationCache.Get(machineKey.String()); ok {
    77| 				logTrace("Node is waiting for interactive login")
    78| 				select {
    79| 				case <-req.Context().Done():
    80| 					return
    81| 				case <-time.After(registrationHoldoff):
    82| 					h.handleNewNode(writer, regReq, machineKey)
    83| 					return
    84| 				}
    85| 			}
    86| 		}
    87| 		logInfo("Node not found in database, creating new")
    88| 		newNode := types.Node{
    89| 			MachineKey: machineKey,
    90| 			Hostname:   regReq.Hostinfo.Hostname,
    91| 			NodeKey:    regReq.NodeKey,
    92| 			LastSeen:   &now,
    93| 			Expiry:     &time.Time{},
    94| 		}
    95| 		if !regReq.Expiry.IsZero() {
    96| 			logTrace("Non-zero expiry time requested")
    97| 			newNode.Expiry = &regReq.Expiry
    98| 		}
    99| 		h.registrationCache.Set(
   100| 			machineKey.String(),
   101| 			newNode,
   102| 			registerCacheExpiration,
   103| 		)
   104| 		h.handleNewNode(writer, regReq, machineKey)
   105| 		return
   106| 	}
   107| 	if node != nil {
   108| 		if err != nil || node.MachineKey.IsZero() {
   109| 			if err := h.db.NodeSetMachineKey(node, machineKey); err != nil {
   110| 				log.Error().
   111| 					Caller().
   112| 					Str("func", "RegistrationHandler").
   113| 					Str("node", node.Hostname).
   114| 					Err(err).
   115| 					Msg("Error saving machine key to database")
   116| 				return
   117| 			}
   118| 		}
   119| 		if node.NodeKey.String() == regReq.NodeKey.String() {
   120| 			if !regReq.Expiry.IsZero() &&
   121| 				regReq.Expiry.UTC().Before(now) {
   122| 				h.handleNodeLogOut(writer, *node, machineKey)
   123| 				return
   124| 			}
   125| 			if !node.IsExpired() {
   126| 				h.handleNodeWithValidRegistration(writer, *node, machineKey)
   127| 				return
   128| 			}
   129| 		}
   130| 		if node.NodeKey.String() == regReq.OldNodeKey.String() &&
   131| 			!node.IsExpired() {
   132| 			h.handleNodeKeyRefresh(
   133| 				writer,
   134| 				regReq,
   135| 				*node,
   136| 				machineKey,
   137| 			)
   138| 			return
   139| 		}
   140| 		if node.NodeKey.String() != regReq.NodeKey.String() &&
   141| 			regReq.OldNodeKey.IsZero() && !node.IsExpired() {
   142| 			h.handleNodeKeyRefresh(
   143| 				writer,
   144| 				regReq,
   145| 				*node,
   146| 				machineKey,
   147| 			)
   148| 			return
   149| 		}
   150| 		if regReq.Followup != "" {
   151| 			select {
   152| 			case <-req.Context().Done():
   153| 				return
   154| 			case <-time.After(registrationHoldoff):
   155| 			}
   156| 		}
   157| 		h.handleNodeExpiredOrLoggedOut(writer, regReq, *node, machineKey)
   158| 		node.Expiry = &time.Time{}
   159| 		node.NodeKey = regReq.NodeKey
   160| 		h.registrationCache.Set(
   161| 			machineKey.String(),
   162| 			*node,
   163| 			registerCacheExpiration,
   164| 		)
   165| 		return
   166| 	}
   167| }
   168| func (h *Headscale) handleAuthKey(
   169| 	writer http.ResponseWriter,
   170| 	registerRequest tailcfg.RegisterRequest,
   171| 	machineKey key.MachinePublic,
   172| ) {
   173| 	log.Debug().
   174| 		Caller().
   175| 		Str("node", registerRequest.Hostinfo.Hostname).
   176| 		Msgf("Processing auth key for %s", registerRequest.Hostinfo.Hostname)
   177| 	resp := tailcfg.RegisterResponse{}
   178| 	pak, err := h.db.ValidatePreAuthKey(registerRequest.Auth.AuthKey)
   179| 	if err != nil {
   180| 		log.Error().
   181| 			Caller().
   182| 			Str("node", registerRequest.Hostinfo.Hostname).
   183| 			Err(err).
   184| 			Msg("Failed authentication via AuthKey")
   185| 		resp.MachineAuthorized = false
   186| 		respBody, err := json.Marshal(resp)
   187| 		if err != nil {
   188| 			log.Error().
   189| 				Caller().
   190| 				Str("node", registerRequest.Hostinfo.Hostname).
   191| 				Err(err).
   192| 				Msg("Cannot encode message")
   193| 			http.Error(writer, "Internal server error", http.StatusInternalServerError)
   194| 			return
   195| 		}
   196| 		writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   197| 		writer.WriteHeader(http.StatusUnauthorized)
   198| 		_, err = writer.Write(respBody)
   199| 		if err != nil {
   200| 			log.Error().
   201| 				Caller().
   202| 				Err(err).
   203| 				Msg("Failed to write response")
   204| 		}
   205| 		log.Error().
   206| 			Caller().
   207| 			Str("node", registerRequest.Hostinfo.Hostname).
   208| 			Msg("Failed authentication via AuthKey")
   209| 		return
   210| 	}
   211| 	log.Debug().
   212| 		Caller().
   213| 		Str("node", registerRequest.Hostinfo.Hostname).
   214| 		Msg("Authentication key was valid, proceeding to acquire IP addresses")
   215| 	nodeKey := registerRequest.NodeKey
   216| 	node, _ := h.db.GetNodeByAnyKey(machineKey, registerRequest.NodeKey, registerRequest.OldNodeKey)
   217| 	if node != nil {
   218| 		log.Trace().
   219| 			Caller().
   220| 			Str("node", node.Hostname).
   221| 			Msg("node was already registered before, refreshing with new auth key")
   222| 		node.NodeKey = nodeKey
   223| 		if pak.ID != 0 {
   224| 			node.AuthKeyID = ptr.To(pak.ID)
   225| 		}
   226| 		node.Expiry = &registerRequest.Expiry
   227| 		node.User = pak.User
   228| 		node.UserID = pak.UserID
   229| 		err := h.db.DB.Save(node).Error
   230| 		if err != nil {
   231| 			log.Error().
   232| 				Caller().
   233| 				Str("node", node.Hostname).
   234| 				Err(err).
   235| 				Msg("failed to save node after logging in with auth key")
   236| 			return
   237| 		}
   238| 		aclTags := pak.Proto().GetAclTags()
   239| 		if len(aclTags) > 0 {
   240| 			err = h.db.SetTags(node.ID, aclTags)
   241| 			if err != nil {
   242| 				log.Error().
   243| 					Caller().
   244| 					Str("node", node.Hostname).
   245| 					Strs("aclTags", aclTags).
   246| 					Err(err).
   247| 					Msg("Failed to set tags after refreshing node")
   248| 				return
   249| 			}
   250| 		}
   251| 		ctx := types.NotifyCtx(context.Background(), "handle-authkey", "na")
   252| 		h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{Type: types.StatePeerChanged, ChangeNodes: []types.NodeID{node.ID}})
   253| 	} else {
   254| 		now := time.Now().UTC()
   255| 		nodeToRegister := types.Node{
   256| 			Hostname:       registerRequest.Hostinfo.Hostname,
   257| 			UserID:         pak.User.ID,
   258| 			User:           pak.User,
   259| 			MachineKey:     machineKey,
   260| 			RegisterMethod: util.RegisterMethodAuthKey,
   261| 			Expiry:         &registerRequest.Expiry,
   262| 			NodeKey:        nodeKey,
   263| 			LastSeen:       &now,
   264| 			ForcedTags:     pak.Proto().GetAclTags(),
   265| 		}
   266| 		ipv4, ipv6, err := h.ipAlloc.Next()
   267| 		if err != nil {
   268| 			log.Error().
   269| 				Caller().
   270| 				Str("func", "RegistrationHandler").
   271| 				Str("hostinfo.name", registerRequest.Hostinfo.Hostname).
   272| 				Err(err).
   273| 				Msg("failed to allocate IP	")
   274| 			return
   275| 		}
   276| 		pakID := uint(pak.ID)
   277| 		if pakID != 0 {
   278| 			nodeToRegister.AuthKeyID = ptr.To(pak.ID)
   279| 		}
   280| 		node, err = h.db.RegisterNode(
   281| 			nodeToRegister,
   282| 			ipv4, ipv6,
   283| 		)
   284| 		if err != nil {
   285| 			log.Error().
   286| 				Caller().
   287| 				Err(err).
   288| 				Msg("could not register node")
   289| 			http.Error(writer, "Internal server error", http.StatusInternalServerError)
   290| 			return
   291| 		}
   292| 	}
   293| 	h.db.Write(func(tx *gorm.DB) error {
   294| 		return db.UsePreAuthKey(tx, pak)
   295| 	})
   296| 	if err != nil {
   297| 		log.Error().
   298| 			Caller().
   299| 			Err(err).
   300| 			Msg("Failed to use pre-auth key")
   301| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   302| 		return
   303| 	}
   304| 	resp.MachineAuthorized = true
   305| 	resp.User = *pak.User.TailscaleUser()
   306| 	resp.Login = *pak.User.TailscaleLogin()
   307| 	respBody, err := json.Marshal(resp)
   308| 	if err != nil {
   309| 		log.Error().
   310| 			Caller().
   311| 			Str("node", registerRequest.Hostinfo.Hostname).
   312| 			Err(err).
   313| 			Msg("Cannot encode message")
   314| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   315| 		return
   316| 	}
   317| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   318| 	writer.WriteHeader(http.StatusOK)
   319| 	_, err = writer.Write(respBody)
   320| 	if err != nil {
   321| 		log.Error().
   322| 			Caller().
   323| 			Err(err).
   324| 			Msg("Failed to write response")
   325| 		return
   326| 	}
   327| 	log.Info().
   328| 		Str("node", registerRequest.Hostinfo.Hostname).
   329| 		Msg("Successfully authenticated via AuthKey")
   330| }
   331| func (h *Headscale) handleNewNode(
   332| 	writer http.ResponseWriter,
   333| 	registerRequest tailcfg.RegisterRequest,
   334| 	machineKey key.MachinePublic,
   335| ) {
   336| 	logInfo, logTrace, logErr := logAuthFunc(registerRequest, machineKey)
   337| 	resp := tailcfg.RegisterResponse{}
   338| 	logTrace("The node seems to be new, sending auth url")
   339| 	if h.oauth2Config != nil {
   340| 		resp.AuthURL = fmt.Sprintf(
   341| 			"%s/oidc/register/%s",
   342| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   343| 			machineKey.String(),
   344| 		)
   345| 	} else {
   346| 		resp.AuthURL = fmt.Sprintf("%s/register/%s",
   347| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   348| 			machineKey.String())
   349| 	}
   350| 	respBody, err := json.Marshal(resp)
   351| 	if err != nil {
   352| 		logErr(err, "Cannot encode message")
   353| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   354| 		return
   355| 	}
   356| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   357| 	writer.WriteHeader(http.StatusOK)
   358| 	_, err = writer.Write(respBody)
   359| 	if err != nil {
   360| 		logErr(err, "Failed to write response")
   361| 	}
   362| 	logInfo(fmt.Sprintf("Successfully sent auth url: %s", resp.AuthURL))
   363| }
   364| func (h *Headscale) handleNodeLogOut(
   365| 	writer http.ResponseWriter,
   366| 	node types.Node,
   367| 	machineKey key.MachinePublic,
   368| ) {
   369| 	resp := tailcfg.RegisterResponse{}
   370| 	log.Info().
   371| 		Str("node", node.Hostname).
   372| 		Msg("Client requested logout")
   373| 	now := time.Now()
   374| 	err := h.db.NodeSetExpiry(node.ID, now)
   375| 	if err != nil {
   376| 		log.Error().
   377| 			Caller().
   378| 			Err(err).
   379| 			Msg("Failed to expire node")
   380| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   381| 		return
   382| 	}
   383| 	ctx := types.NotifyCtx(context.Background(), "logout-expiry", "na")
   384| 	h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdateExpire(node.ID, now), node.ID)
   385| 	resp.AuthURL = ""
   386| 	resp.MachineAuthorized = false
   387| 	resp.NodeKeyExpired = true
   388| 	resp.User = *node.User.TailscaleUser()
   389| 	respBody, err := json.Marshal(resp)
   390| 	if err != nil {
   391| 		log.Error().
   392| 			Caller().
   393| 			Err(err).
   394| 			Msg("Cannot encode message")
   395| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   396| 		return
   397| 	}
   398| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   399| 	writer.WriteHeader(http.StatusOK)
   400| 	_, err = writer.Write(respBody)
   401| 	if err != nil {
   402| 		log.Error().
   403| 			Caller().
   404| 			Err(err).
   405| 			Msg("Failed to write response")
   406| 		return
   407| 	}
   408| 	if node.IsEphemeral() {
   409| 		changedNodes, err := h.db.DeleteNode(&node, h.nodeNotifier.LikelyConnectedMap())
   410| 		if err != nil {
   411| 			log.Error().
   412| 				Err(err).
   413| 				Str("node", node.Hostname).
   414| 				Msg("Cannot delete ephemeral node from the database")
   415| 		}
   416| 		ctx := types.NotifyCtx(context.Background(), "logout-ephemeral", "na")
   417| 		h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   418| 			Type:    types.StatePeerRemoved,
   419| 			Removed: []types.NodeID{node.ID},
   420| 		})
   421| 		if changedNodes != nil {
   422| 			h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   423| 				Type:        types.StatePeerChanged,
   424| 				ChangeNodes: changedNodes,
   425| 			})
   426| 		}
   427| 		return
   428| 	}
   429| 	log.Info().
   430| 		Caller().
   431| 		Str("node", node.Hostname).
   432| 		Msg("Successfully logged out")
   433| }
   434| func (h *Headscale) handleNodeWithValidRegistration(
   435| 	writer http.ResponseWriter,
   436| 	node types.Node,
   437| 	machineKey key.MachinePublic,
   438| ) {
   439| 	resp := tailcfg.RegisterResponse{}
   440| 	log.Debug().
   441| 		Caller().
   442| 		Str("node", node.Hostname).
   443| 		Msg("Client is registered and we have the current NodeKey. All clear to /map")
   444| 	resp.AuthURL = ""
   445| 	resp.MachineAuthorized = true
   446| 	resp.User = *node.User.TailscaleUser()
   447| 	resp.Login = *node.User.TailscaleLogin()
   448| 	respBody, err := json.Marshal(resp)
   449| 	if err != nil {
   450| 		log.Error().
   451| 			Caller().
   452| 			Err(err).
   453| 			Msg("Cannot encode message")
   454| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   455| 		return
   456| 	}
   457| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   458| 	writer.WriteHeader(http.StatusOK)
   459| 	_, err = writer.Write(respBody)
   460| 	if err != nil {
   461| 		log.Error().
   462| 			Caller().
   463| 			Err(err).
   464| 			Msg("Failed to write response")
   465| 	}
   466| 	log.Info().
   467| 		Caller().
   468| 		Str("node", node.Hostname).
   469| 		Msg("Node successfully authorized")
   470| }
   471| func (h *Headscale) handleNodeKeyRefresh(
   472| 	writer http.ResponseWriter,
   473| 	registerRequest tailcfg.RegisterRequest,
   474| 	node types.Node,
   475| 	machineKey key.MachinePublic,
   476| ) {
   477| 	resp := tailcfg.RegisterResponse{}
   478| 	log.Info().
   479| 		Caller().
   480| 		Str("node", node.Hostname).
   481| 		Msg("We have the OldNodeKey in the database. This is a key refresh")
   482| 	err := h.db.Write(func(tx *gorm.DB) error {
   483| 		return db.NodeSetNodeKey(tx, &node, registerRequest.NodeKey)
   484| 	})
   485| 	if err != nil {
   486| 		log.Error().
   487| 			Caller().
   488| 			Err(err).
   489| 			Msg("Failed to update machine key in the database")
   490| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   491| 		return
   492| 	}
   493| 	resp.AuthURL = ""
   494| 	resp.User = *node.User.TailscaleUser()
   495| 	respBody, err := json.Marshal(resp)
   496| 	if err != nil {
   497| 		log.Error().
   498| 			Caller().
   499| 			Err(err).
   500| 			Msg("Cannot encode message")
   501| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   502| 		return
   503| 	}
   504| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   505| 	writer.WriteHeader(http.StatusOK)
   506| 	_, err = writer.Write(respBody)
   507| 	if err != nil {
   508| 		log.Error().
   509| 			Caller().
   510| 			Err(err).
   511| 			Msg("Failed to write response")
   512| 	}
   513| 	log.Info().
   514| 		Caller().
   515| 		Str("node_key", registerRequest.NodeKey.ShortString()).
   516| 		Str("old_node_key", registerRequest.OldNodeKey.ShortString()).
   517| 		Str("node", node.Hostname).
   518| 		Msg("Node key successfully refreshed")
   519| }
   520| func (h *Headscale) handleNodeExpiredOrLoggedOut(
   521| 	writer http.ResponseWriter,
   522| 	regReq tailcfg.RegisterRequest,
   523| 	node types.Node,
   524| 	machineKey key.MachinePublic,
   525| ) {
   526| 	resp := tailcfg.RegisterResponse{}
   527| 	if regReq.Auth != nil && regReq.Auth.AuthKey != "" {
   528| 		h.handleAuthKey(writer, regReq, machineKey)
   529| 		return
   530| 	}
   531| 	log.Trace().
   532| 		Caller().
   533| 		Str("node", node.Hostname).
   534| 		Str("machine_key", machineKey.ShortString()).
   535| 		Str("node_key", regReq.NodeKey.ShortString()).
   536| 		Str("node_key_old", regReq.OldNodeKey.ShortString()).
   537| 		Msg("Node registration has expired or logged out. Sending a auth url to register")
   538| 	if h.oauth2Config != nil {
   539| 		resp.AuthURL = fmt.Sprintf("%s/oidc/register/%s",
   540| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   541| 			machineKey.String())
   542| 	} else {
   543| 		resp.AuthURL = fmt.Sprintf("%s/register/%s",
   544| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   545| 			machineKey.String())
   546| 	}
   547| 	respBody, err := json.Marshal(resp)
   548| 	if err != nil {
   549| 		log.Error().
   550| 			Caller().
   551| 			Err(err).
   552| 			Msg("Cannot encode message")
   553| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   554| 		return
   555| 	}
   556| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   557| 	writer.WriteHeader(http.StatusOK)
   558| 	_, err = writer.Write(respBody)
   559| 	if err != nil {
   560| 		log.Error().
   561| 			Caller().
   562| 			Err(err).
   563| 			Msg("Failed to write response")
   564| 	}
   565| 	log.Trace().
   566| 		Caller().
   567| 		Str("machine_key", machineKey.ShortString()).
   568| 		Str("node_key", regReq.NodeKey.ShortString()).
   569| 		Str("node_key_old", regReq.OldNodeKey.ShortString()).
   570| 		Str("node", node.Hostname).
   571| 		Msg("Node logged out. Sent AuthURL for reauthentication")
   572| }


# ====================================================================
# FILE: hscontrol/auth_noise.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-43 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/json"
     4| 	"io"
     5| 	"net/http"
     6| 	"github.com/rs/zerolog/log"
     7| 	"tailscale.com/tailcfg"
     8| )
     9| func (ns *noiseServer) NoiseRegistrationHandler(
    10| 	writer http.ResponseWriter,
    11| 	req *http.Request,
    12| ) {
    13| 	log.Trace().Caller().Msgf("Noise registration handler for client %s", req.RemoteAddr)
    14| 	if req.Method != http.MethodPost {
    15| 		http.Error(writer, "Wrong method", http.StatusMethodNotAllowed)
    16| 		return
    17| 	}
    18| 	log.Trace().
    19| 		Any("headers", req.Header).
    20| 		Caller().
    21| 		Msg("Headers")
    22| 	body, _ := io.ReadAll(req.Body)
    23| 	registerRequest := tailcfg.RegisterRequest{}
    24| 	if err := json.Unmarshal(body, &registerRequest); err != nil {
    25| 		log.Error().
    26| 			Caller().
    27| 			Err(err).
    28| 			Msg("Cannot parse RegisterRequest")
    29| 		http.Error(writer, "Internal error", http.StatusInternalServerError)
    30| 		return
    31| 	}
    32| 	if registerRequest.Version < MinimumCapVersion {
    33| 		log.Info().
    34| 			Caller().
    35| 			Int("min_version", int(MinimumCapVersion)).
    36| 			Int("client_version", int(registerRequest.Version)).
    37| 			Msg("unsupported client connected")
    38| 		http.Error(writer, "Internal error", http.StatusBadRequest)
    39| 		return
    40| 	}
    41| 	ns.nodeKey = registerRequest.NodeKey
    42| 	ns.headscale.handleRegister(writer, req, registerRequest, ns.conn.Peer())
    43| }


# ====================================================================
# FILE: hscontrol/db/api_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-91 ---
     1| package db
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"strings"
     6| 	"time"
     7| 	"github.com/juanfont/headscale/hscontrol/types"
     8| 	"github.com/juanfont/headscale/hscontrol/util"
     9| 	"golang.org/x/crypto/bcrypt"
    10| )
    11| const (
    12| 	apiPrefixLength = 7
    13| 	apiKeyLength    = 32
    14| )
    15| var ErrAPIKeyFailedToParse = errors.New("failed to parse ApiKey")
    16| func (hsdb *HSDatabase) CreateAPIKey(
    17| 	expiration *time.Time,
    18| ) (string, *types.APIKey, error) {
    19| 	prefix, err := util.GenerateRandomStringURLSafe(apiPrefixLength)
    20| 	if err != nil {
    21| 		return "", nil, err
    22| 	}
    23| 	toBeHashed, err := util.GenerateRandomStringURLSafe(apiKeyLength)
    24| 	if err != nil {
    25| 		return "", nil, err
    26| 	}
    27| 	keyStr := prefix + "." + toBeHashed
    28| 	hash, err := bcrypt.GenerateFromPassword([]byte(toBeHashed), bcrypt.DefaultCost)
    29| 	if err != nil {
    30| 		return "", nil, err
    31| 	}
    32| 	key := types.APIKey{
    33| 		Prefix:     prefix,
    34| 		Hash:       hash,
    35| 		Expiration: expiration,
    36| 	}
    37| 	if err := hsdb.DB.Save(&key).Error; err != nil {
    38| 		return "", nil, fmt.Errorf("failed to save API key to database: %w", err)
    39| 	}
    40| 	return keyStr, &key, nil
    41| }
    42| func (hsdb *HSDatabase) ListAPIKeys() ([]types.APIKey, error) {
    43| 	keys := []types.APIKey{}
    44| 	if err := hsdb.DB.Find(&keys).Error; err != nil {
    45| 		return nil, err
    46| 	}
    47| 	return keys, nil
    48| }
    49| func (hsdb *HSDatabase) GetAPIKey(prefix string) (*types.APIKey, error) {
    50| 	key := types.APIKey{}
    51| 	if result := hsdb.DB.First(&key, "prefix = ?", prefix); result.Error != nil {
    52| 		return nil, result.Error
    53| 	}
    54| 	return &key, nil
    55| }
    56| func (hsdb *HSDatabase) GetAPIKeyByID(id uint64) (*types.APIKey, error) {
    57| 	key := types.APIKey{}
    58| 	if result := hsdb.DB.Find(&types.APIKey{ID: id}).First(&key); result.Error != nil {
    59| 		return nil, result.Error
    60| 	}
    61| 	return &key, nil
    62| }
    63| func (hsdb *HSDatabase) DestroyAPIKey(key types.APIKey) error {
    64| 	if result := hsdb.DB.Unscoped().Delete(key); result.Error != nil {
    65| 		return result.Error
    66| 	}
    67| 	return nil
    68| }
    69| func (hsdb *HSDatabase) ExpireAPIKey(key *types.APIKey) error {
    70| 	if err := hsdb.DB.Model(&key).Update("Expiration", time.Now()).Error; err != nil {
    71| 		return err
    72| 	}
    73| 	return nil
    74| }
    75| func (hsdb *HSDatabase) ValidateAPIKey(keyStr string) (bool, error) {
    76| 	prefix, hash, found := strings.Cut(keyStr, ".")
    77| 	if !found {
    78| 		return false, ErrAPIKeyFailedToParse
    79| 	}
    80| 	key, err := hsdb.GetAPIKey(prefix)
    81| 	if err != nil {
    82| 		return false, fmt.Errorf("failed to validate api key: %w", err)
    83| 	}
    84| 	if key.Expiration.Before(time.Now()) {
    85| 		return false, nil
    86| 	}
    87| 	if err := bcrypt.CompareHashAndPassword(key.Hash, []byte(hash)); err != nil {
    88| 		return false, err
    89| 	}
    90| 	return true, nil
    91| }


# ====================================================================
# FILE: hscontrol/db/db.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-530 ---
     1| package db
     2| import (
     3| 	"context"
     4| 	"database/sql"
     5| 	"errors"
     6| 	"fmt"
     7| 	"net/netip"
     8| 	"path/filepath"
     9| 	"strconv"
    10| 	"strings"
    11| 	"time"
    12| 	"github.com/glebarez/sqlite"
    13| 	"github.com/go-gormigrate/gormigrate/v2"
    14| 	"github.com/juanfont/headscale/hscontrol/types"
    15| 	"github.com/juanfont/headscale/hscontrol/util"
    16| 	"github.com/rs/zerolog/log"
    17| 	"gorm.io/driver/postgres"
    18| 	"gorm.io/gorm"
    19| 	"gorm.io/gorm/logger"
    20| )
    21| var errDatabaseNotSupported = errors.New("database type not supported")
    22| type KV struct {
    23| 	Key   string
    24| 	Value string
    25| }
    26| type HSDatabase struct {
    27| 	DB *gorm.DB
    28| 	baseDomain string
    29| }
    30| func NewHeadscaleDatabase(
    31| 	cfg types.DatabaseConfig,
    32| 	baseDomain string,
    33| ) (*HSDatabase, error) {
    34| 	dbConn, err := openDB(cfg)
    35| 	if err != nil {
    36| 		return nil, err
    37| 	}
    38| 	migrations := gormigrate.New(
    39| 		dbConn,
    40| 		gormigrate.DefaultOptions,
    41| 		[]*gormigrate.Migration{
    42| 			{
    43| 				ID: "202312101416",
    44| 				Migrate: func(tx *gorm.DB) error {
    45| 					if cfg.Type == types.DatabasePostgres {
    46| 						tx.Exec(`create extension if not exists "uuid-ossp";`)
    47| 					}
    48| 					_ = tx.Migrator().RenameTable("namespaces", "users")
    49| 					_ = tx.Migrator().RenameTable("machines", "nodes")
    50| 					_ = tx.Migrator().
    51| 						RenameColumn(&types.Route{}, "machine_id", "node_id")
    52| 					err = tx.AutoMigrate(types.User{})
    53| 					if err != nil {
    54| 						return err
    55| 					}
    56| 					_ = tx.Migrator().
    57| 						RenameColumn(&types.Node{}, "namespace_id", "user_id")
    58| 					_ = tx.Migrator().
    59| 						RenameColumn(&types.PreAuthKey{}, "namespace_id", "user_id")
    60| 					_ = tx.Migrator().
    61| 						RenameColumn(&types.Node{}, "ip_address", "ip_addresses")
    62| 					_ = tx.Migrator().RenameColumn(&types.Node{}, "name", "hostname")
    63| 					_ = tx.Migrator().
    64| 						RenameColumn(&types.Node{}, "nickname", "given_name")
    65| 					dbConn.Model(&types.Node{}).Where("auth_key_id = ?", 0).Update("auth_key_id", nil)
    66| 					if tx.Migrator().HasColumn(&types.Node{}, "registered") {
    67| 						log.Info().
    68| 							Msg(`Database has legacy "registered" column in node, removing...`)
    69| 						nodes := types.Nodes{}
    70| 						if err := tx.Not("registered").Find(&nodes).Error; err != nil {
    71| 							log.Error().Err(err).Msg("Error accessing db")
    72| 						}
    73| 						for _, node := range nodes {
    74| 							log.Info().
    75| 								Str("node", node.Hostname).
    76| 								Str("machine_key", node.MachineKey.ShortString()).
    77| 								Msg("Deleting unregistered node")
    78| 							if err := tx.Delete(&types.Node{}, node.ID).Error; err != nil {
    79| 								log.Error().
    80| 									Err(err).
    81| 									Str("node", node.Hostname).
    82| 									Str("machine_key", node.MachineKey.ShortString()).
    83| 									Msg("Error deleting unregistered node")
    84| 							}
    85| 						}
    86| 						err := tx.Migrator().DropColumn(&types.Node{}, "registered")
    87| 						if err != nil {
    88| 							log.Error().Err(err).Msg("Error dropping registered column")
    89| 						}
    90| 					}
    91| 					if tx.Migrator().HasTable(&types.Route{}) && tx.Migrator().HasTable(&types.Node{}) {
    92| 						err := tx.Exec("delete from routes where node_id not in (select id from nodes)").Error
    93| 						if err != nil {
    94| 							return err
    95| 						}
    96| 					}
    97| 					err = tx.AutoMigrate(&types.Route{})
    98| 					if err != nil {
    99| 						return err
   100| 					}
   101| 					err = tx.AutoMigrate(&types.Node{})
   102| 					if err != nil {
   103| 						return err
   104| 					}
   105| 					type result struct {
   106| 						ID         uint64
   107| 						MachineKey string
   108| 						NodeKey    string
   109| 						DiscoKey   string
   110| 					}
   111| 					var results []result
   112| 					err = tx.Raw("SELECT id, node_key, machine_key, disco_key FROM nodes").
   113| 						Find(&results).
   114| 						Error
   115| 					if err != nil {
   116| 						return err
   117| 					}
   118| 					for _, node := range results {
   119| 						mKey := node.MachineKey
   120| 						if !strings.HasPrefix(node.MachineKey, "mkey:") {
   121| 							mKey = "mkey:" + node.MachineKey
   122| 						}
   123| 						nKey := node.NodeKey
   124| 						if !strings.HasPrefix(node.NodeKey, "nodekey:") {
   125| 							nKey = "nodekey:" + node.NodeKey
   126| 						}
   127| 						dKey := node.DiscoKey
   128| 						if !strings.HasPrefix(node.DiscoKey, "discokey:") {
   129| 							dKey = "discokey:" + node.DiscoKey
   130| 						}
   131| 						err := tx.Exec(
   132| 							"UPDATE nodes SET machine_key = @mKey, node_key = @nKey, disco_key = @dKey WHERE ID = @id",
   133| 							sql.Named("mKey", mKey),
   134| 							sql.Named("nKey", nKey),
   135| 							sql.Named("dKey", dKey),
   136| 							sql.Named("id", node.ID),
   137| 						).Error
   138| 						if err != nil {
   139| 							return err
   140| 						}
   141| 					}
   142| 					if tx.Migrator().HasColumn(&types.Node{}, "enabled_routes") {
   143| 						log.Info().
   144| 							Msgf("Database has legacy enabled_routes column in node, migrating...")
   145| 						type NodeAux struct {
   146| 							ID            uint64
   147| 							EnabledRoutes types.IPPrefixes
   148| 						}
   149| 						nodesAux := []NodeAux{}
   150| 						err := tx.Table("nodes").
   151| 							Select("id, enabled_routes").
   152| 							Scan(&nodesAux).
   153| 							Error
   154| 						if err != nil {
   155| 							log.Fatal().Err(err).Msg("Error accessing db")
   156| 						}
   157| 						for _, node := range nodesAux {
   158| 							for _, prefix := range node.EnabledRoutes {
   159| 								if err != nil {
   160| 									log.Error().
   161| 										Err(err).
   162| 										Str("enabled_route", prefix.String()).
   163| 										Msg("Error parsing enabled_route")
   164| 									continue
   165| 								}
   166| 								err = tx.Preload("Node").
   167| 									Where("node_id = ? AND prefix = ?", node.ID, types.IPPrefix(prefix)).
   168| 									First(&types.Route{}).
   169| 									Error
   170| 								if err == nil {
   171| 									log.Info().
   172| 										Str("enabled_route", prefix.String()).
   173| 										Msg("Route already migrated to new table, skipping")
   174| 									continue
   175| 								}
   176| 								route := types.Route{
   177| 									NodeID:     node.ID,
   178| 									Advertised: true,
   179| 									Enabled:    true,
   180| 									Prefix:     types.IPPrefix(prefix),
   181| 								}
   182| 								if err := tx.Create(&route).Error; err != nil {
   183| 									log.Error().Err(err).Msg("Error creating route")
   184| 								} else {
   185| 									log.Info().
   186| 										Uint64("node_id", route.NodeID).
   187| 										Str("prefix", prefix.String()).
   188| 										Msg("Route migrated")
   189| 								}
   190| 							}
   191| 						}
   192| 						err = tx.Migrator().DropColumn(&types.Node{}, "enabled_routes")
   193| 						if err != nil {
   194| 							log.Error().
   195| 								Err(err).
   196| 								Msg("Error dropping enabled_routes column")
   197| 						}
   198| 					}
   199| 					if tx.Migrator().HasColumn(&types.Node{}, "given_name") {
   200| 						nodes := types.Nodes{}
   201| 						if err := tx.Find(&nodes).Error; err != nil {
   202| 							log.Error().Err(err).Msg("Error accessing db")
   203| 						}
   204| 						for item, node := range nodes {
   205| 							if node.GivenName == "" {
   206| 								normalizedHostname, err := util.NormalizeToFQDNRulesConfigFromViper(
   207| 									node.Hostname,
   208| 								)
   209| 								if err != nil {
   210| 									log.Error().
   211| 										Caller().
   212| 										Str("hostname", node.Hostname).
   213| 										Err(err).
   214| 										Msg("Failed to normalize node hostname in DB migration")
   215| 								}
   216| 								err = tx.Model(nodes[item]).Updates(types.Node{
   217| 									GivenName: normalizedHostname,
   218| 								}).Error
   219| 								if err != nil {
   220| 									log.Error().
   221| 										Caller().
   222| 										Str("hostname", node.Hostname).
   223| 										Err(err).
   224| 										Msg("Failed to save normalized node name in DB migration")
   225| 								}
   226| 							}
   227| 						}
   228| 					}
   229| 					err = tx.AutoMigrate(&KV{})
   230| 					if err != nil {
   231| 						return err
   232| 					}
   233| 					err = tx.AutoMigrate(&types.PreAuthKey{})
   234| 					if err != nil {
   235| 						return err
   236| 					}
   237| 					err = tx.AutoMigrate(&types.PreAuthKeyACLTag{})
   238| 					if err != nil {
   239| 						return err
   240| 					}
   241| 					_ = tx.Migrator().DropTable("shared_machines")
   242| 					err = tx.AutoMigrate(&types.APIKey{})
   243| 					if err != nil {
   244| 						return err
   245| 					}
   246| 					return nil
   247| 				},
   248| 				Rollback: func(tx *gorm.DB) error {
   249| 					return nil
   250| 				},
   251| 			},
   252| 			{
   253| 				ID: "202312101430",
   254| 				Migrate: func(tx *gorm.DB) error {
   255| 					return tx.Migrator().DropTable("kvs")
   256| 				},
   257| 				Rollback: func(tx *gorm.DB) error {
   258| 					return nil
   259| 				},
   260| 			},
   261| 			{
   262| 				ID: "202402151347",
   263| 				Migrate: func(tx *gorm.DB) error {
   264| 					_ = tx.Migrator().DropColumn(&types.Node{}, "last_successful_update")
   265| 					return nil
   266| 				},
   267| 				Rollback: func(tx *gorm.DB) error {
   268| 					return nil
   269| 				},
   270| 			},
   271| 			{
   272| 				ID: "2024041121742",
   273| 				Migrate: func(tx *gorm.DB) error {
   274| 					_ = tx.Migrator().AddColumn(&types.Node{}, "ipv4")
   275| 					_ = tx.Migrator().AddColumn(&types.Node{}, "ipv6")
   276| 					type node struct {
   277| 						ID        uint64 `gorm:"column:id"`
   278| 						Addresses string `gorm:"column:ip_addresses"`
   279| 					}
   280| 					var nodes []node
   281| 					_ = tx.Raw("SELECT id, ip_addresses FROM nodes").Scan(&nodes).Error
   282| 					for _, node := range nodes {
   283| 						addrs := strings.Split(node.Addresses, ",")
   284| 						if len(addrs) == 0 {
   285| 							return fmt.Errorf("no addresses found for node(%d)", node.ID)
   286| 						}
   287| 						var v4 *netip.Addr
   288| 						var v6 *netip.Addr
   289| 						for _, addrStr := range addrs {
   290| 							addr, err := netip.ParseAddr(addrStr)
   291| 							if err != nil {
   292| 								return fmt.Errorf("parsing IP for node(%d) from database: %w", node.ID, err)
   293| 							}
   294| 							if addr.Is4() && v4 == nil {
   295| 								v4 = &addr
   296| 							}
   297| 							if addr.Is6() && v6 == nil {
   298| 								v6 = &addr
   299| 							}
   300| 						}
   301| 						if v4 != nil {
   302| 							err = tx.Model(&types.Node{}).Where("id = ?", node.ID).Update("ipv4", v4.String()).Error
   303| 							if err != nil {
   304| 								return fmt.Errorf("saving ip addresses to new columns: %w", err)
   305| 							}
   306| 						}
   307| 						if v6 != nil {
   308| 							err = tx.Model(&types.Node{}).Where("id = ?", node.ID).Update("ipv6", v6.String()).Error
   309| 							if err != nil {
   310| 								return fmt.Errorf("saving ip addresses to new columns: %w", err)
   311| 							}
   312| 						}
   313| 					}
   314| 					_ = tx.Migrator().DropColumn(&types.Node{}, "ip_addresses")
   315| 					return nil
   316| 				},
   317| 				Rollback: func(tx *gorm.DB) error {
   318| 					return nil
   319| 				},
   320| 			},
   321| 			{
   322| 				ID: "202406021630",
   323| 				Migrate: func(tx *gorm.DB) error {
   324| 					err := tx.AutoMigrate(&types.Policy{})
   325| 					if err != nil {
   326| 						return err
   327| 					}
   328| 					return nil
   329| 				},
   330| 				Rollback: func(db *gorm.DB) error { return nil },
   331| 			},
   332| 		},
   333| 	)
   334| 	if err := runMigrations(cfg, dbConn, migrations); err != nil {
   335| 		log.Fatal().Err(err).Msgf("Migration failed: %v", err)
   336| 	}
   337| 	db := HSDatabase{
   338| 		DB: dbConn,
   339| 		baseDomain: baseDomain,
   340| 	}
   341| 	return &db, err
   342| }
   343| func openDB(cfg types.DatabaseConfig) (*gorm.DB, error) {
   344| 	var dbLogger logger.Interface
   345| 	if cfg.Debug {
   346| 		dbLogger = util.NewDBLogWrapper(&log.Logger, cfg.Gorm.SlowThreshold, cfg.Gorm.SkipErrRecordNotFound, cfg.Gorm.ParameterizedQueries)
   347| 	} else {
   348| 		dbLogger = logger.Default.LogMode(logger.Silent)
   349| 	}
   350| 	switch cfg.Type {
   351| 	case types.DatabaseSqlite:
   352| 		dir := filepath.Dir(cfg.Sqlite.Path)
   353| 		err := util.EnsureDir(dir)
   354| 		if err != nil {
   355| 			return nil, fmt.Errorf("creating directory for sqlite: %w", err)
   356| 		}
   357| 		log.Info().
   358| 			Str("database", types.DatabaseSqlite).
   359| 			Str("path", cfg.Sqlite.Path).
   360| 			Msg("Opening database")
   361| 		db, err := gorm.Open(
   362| 			sqlite.Open(cfg.Sqlite.Path),
   363| 			&gorm.Config{
   364| 				PrepareStmt: cfg.Gorm.PrepareStmt,
   365| 				Logger:      dbLogger,
   366| 			},
   367| 		)
   368| 		if err := db.Exec(`
   369| 			PRAGMA foreign_keys=ON;
   370| 			PRAGMA busy_timeout=10000;
   371| 			PRAGMA auto_vacuum=INCREMENTAL;
   372| 			PRAGMA synchronous=NORMAL;
   373| 			`).Error; err != nil {
   374| 			return nil, fmt.Errorf("enabling foreign keys: %w", err)
   375| 		}
   376| 		if cfg.Sqlite.WriteAheadLog {
   377| 			if err := db.Exec(`
   378| 				PRAGMA journal_mode=WAL;
   379| 				PRAGMA wal_autocheckpoint=0;
   380| 				`).Error; err != nil {
   381| 				return nil, fmt.Errorf("setting WAL mode: %w", err)
   382| 			}
   383| 		}
   384| 		sqlDB, _ := db.DB()
   385| 		sqlDB.SetMaxIdleConns(1)
   386| 		sqlDB.SetMaxOpenConns(1)
   387| 		sqlDB.SetConnMaxIdleTime(time.Hour)
   388| 		return db, err
   389| 	case types.DatabasePostgres:
   390| 		dbString := fmt.Sprintf(
   391| 			"host=%s dbname=%s user=%s",
   392| 			cfg.Postgres.Host,
   393| 			cfg.Postgres.Name,
   394| 			cfg.Postgres.User,
   395| 		)
   396| 		log.Info().
   397| 			Str("database", types.DatabasePostgres).
   398| 			Str("path", dbString).
   399| 			Msg("Opening database")
   400| 		if sslEnabled, err := strconv.ParseBool(cfg.Postgres.Ssl); err == nil {
   401| 			if !sslEnabled {
   402| 				dbString += " sslmode=disable"
   403| 			}
   404| 		} else {
   405| 			dbString += fmt.Sprintf(" sslmode=%s", cfg.Postgres.Ssl)
   406| 		}
   407| 		if cfg.Postgres.Port != 0 {
   408| 			dbString += fmt.Sprintf(" port=%d", cfg.Postgres.Port)
   409| 		}
   410| 		if cfg.Postgres.Pass != "" {
   411| 			dbString += fmt.Sprintf(" password=%s", cfg.Postgres.Pass)
   412| 		}
   413| 		db, err := gorm.Open(postgres.Open(dbString), &gorm.Config{
   414| 			Logger: dbLogger,
   415| 		})
   416| 		if err != nil {
   417| 			return nil, err
   418| 		}
   419| 		sqlDB, _ := db.DB()
   420| 		sqlDB.SetMaxIdleConns(cfg.Postgres.MaxIdleConnections)
   421| 		sqlDB.SetMaxOpenConns(cfg.Postgres.MaxOpenConnections)
   422| 		sqlDB.SetConnMaxIdleTime(
   423| 			time.Duration(cfg.Postgres.ConnMaxIdleTimeSecs) * time.Second,
   424| 		)
   425| 		return db, nil
   426| 	}
   427| 	return nil, fmt.Errorf(
   428| 		"database of type %s is not supported: %w",
   429| 		cfg.Type,
   430| 		errDatabaseNotSupported,
   431| 	)
   432| }
   433| func runMigrations(cfg types.DatabaseConfig, dbConn *gorm.DB, migrations *gormigrate.Gormigrate) error {
   434| 	if cfg.Type == types.DatabaseSqlite {
   435| 		var fkEnabled int
   436| 		if err := dbConn.Raw("PRAGMA foreign_keys").Scan(&fkEnabled).Error; err != nil {
   437| 			return fmt.Errorf("checking foreign key status: %w", err)
   438| 		}
   439| 		if fkEnabled == 1 {
   440| 			if err := dbConn.Exec("PRAGMA foreign_keys = OFF").Error; err != nil {
   441| 				return fmt.Errorf("disabling foreign keys: %w", err)
   442| 			}
   443| 			defer dbConn.Exec("PRAGMA foreign_keys = ON")
   444| 		}
   445| 	}
   446| 	if err := migrations.Migrate(); err != nil {
   447| 		return err
   448| 	}
   449| 	if cfg.Type == types.DatabaseSqlite {
   450| 		type constraintViolation struct {
   451| 			Table           string
   452| 			RowID           int
   453| 			Parent          string
   454| 			ConstraintIndex int
   455| 		}
   456| 		var violatedConstraints []constraintViolation
   457| 		rows, err := dbConn.Raw("PRAGMA foreign_key_check").Rows()
   458| 		if err != nil {
   459| 			return err
   460| 		}
   461| 		for rows.Next() {
   462| 			var violation constraintViolation
   463| 			if err := rows.Scan(&violation.Table, &violation.RowID, &violation.Parent, &violation.ConstraintIndex); err != nil {
   464| 				return err
   465| 			}
   466| 			violatedConstraints = append(violatedConstraints, violation)
   467| 		}
   468| 		_ = rows.Close()
   469| 		if len(violatedConstraints) > 0 {
   470| 			for _, violation := range violatedConstraints {
   471| 				log.Error().
   472| 					Str("table", violation.Table).
   473| 					Int("row_id", violation.RowID).
   474| 					Str("parent", violation.Parent).
   475| 					Msg("Foreign key constraint violated")
   476| 			}
   477| 			return fmt.Errorf("foreign key constraints violated")
   478| 		}
   479| 	}
   480| 	return nil
   481| }
   482| func (hsdb *HSDatabase) PingDB(ctx context.Context) error {
   483| 	ctx, cancel := context.WithTimeout(ctx, time.Second)
   484| 	defer cancel()
   485| 	sqlDB, err := hsdb.DB.DB()
   486| 	if err != nil {
   487| 		return err
   488| 	}
   489| 	return sqlDB.PingContext(ctx)
   490| }
   491| func (hsdb *HSDatabase) Close() error {
   492| 	db, err := hsdb.DB.DB()
   493| 	if err != nil {
   494| 		return err
   495| 	}
   496| 	return db.Close()
   497| }
   498| func (hsdb *HSDatabase) Read(fn func(rx *gorm.DB) error) error {
   499| 	rx := hsdb.DB.Begin()
   500| 	defer rx.Rollback()
   501| 	return fn(rx)
   502| }
   503| func Read[T any](db *gorm.DB, fn func(rx *gorm.DB) (T, error)) (T, error) {
   504| 	rx := db.Begin()
   505| 	defer rx.Rollback()
   506| 	ret, err := fn(rx)
   507| 	if err != nil {
   508| 		var no T
   509| 		return no, err
   510| 	}
   511| 	return ret, nil
   512| }
   513| func (hsdb *HSDatabase) Write(fn func(tx *gorm.DB) error) error {
   514| 	tx := hsdb.DB.Begin()
   515| 	defer tx.Rollback()
   516| 	if err := fn(tx); err != nil {
   517| 		return err
   518| 	}
   519| 	return tx.Commit().Error
   520| }
   521| func Write[T any](db *gorm.DB, fn func(tx *gorm.DB) (T, error)) (T, error) {
   522| 	tx := db.Begin()
   523| 	defer tx.Rollback()
   524| 	ret, err := fn(tx)
   525| 	if err != nil {
   526| 		var no T
   527| 		return no, err
   528| 	}
   529| 	return ret, tx.Commit().Error
   530| }


# ====================================================================
# FILE: hscontrol/db/ip.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-225 ---
     1| package db
     2| import (
     3| 	"crypto/rand"
     4| 	"database/sql"
     5| 	"errors"
     6| 	"fmt"
     7| 	"math/big"
     8| 	"net/netip"
     9| 	"sync"
    10| 	"github.com/juanfont/headscale/hscontrol/types"
    11| 	"github.com/juanfont/headscale/hscontrol/util"
    12| 	"github.com/rs/zerolog/log"
    13| 	"go4.org/netipx"
    14| 	"gorm.io/gorm"
    15| )
    16| type IPAllocator struct {
    17| 	mu sync.Mutex
    18| 	prefix4 *netip.Prefix
    19| 	prefix6 *netip.Prefix
    20| 	prev4 netip.Addr
    21| 	prev6 netip.Addr
    22| 	strategy types.IPAllocationStrategy
    23| 	usedIPs netipx.IPSetBuilder
    24| }
    25| func NewIPAllocator(
    26| 	db *HSDatabase,
    27| 	prefix4, prefix6 *netip.Prefix,
    28| 	strategy types.IPAllocationStrategy,
    29| ) (*IPAllocator, error) {
    30| 	ret := IPAllocator{
    31| 		prefix4: prefix4,
    32| 		prefix6: prefix6,
    33| 		strategy: strategy,
    34| 	}
    35| 	var v4s []sql.NullString
    36| 	var v6s []sql.NullString
    37| 	if db != nil {
    38| 		err := db.Read(func(rx *gorm.DB) error {
    39| 			return rx.Model(&types.Node{}).Pluck("ipv4", &v4s).Error
    40| 		})
    41| 		if err != nil {
    42| 			return nil, fmt.Errorf("reading IPv4 addresses from database: %w", err)
    43| 		}
    44| 		err = db.Read(func(rx *gorm.DB) error {
    45| 			return rx.Model(&types.Node{}).Pluck("ipv6", &v6s).Error
    46| 		})
    47| 		if err != nil {
    48| 			return nil, fmt.Errorf("reading IPv6 addresses from database: %w", err)
    49| 		}
    50| 	}
    51| 	var ips netipx.IPSetBuilder
    52| 	if prefix4 != nil {
    53| 		network4, broadcast4 := util.GetIPPrefixEndpoints(*prefix4)
    54| 		ips.Add(network4)
    55| 		ips.Add(broadcast4)
    56| 		ret.prev4 = network4
    57| 	}
    58| 	if prefix6 != nil {
    59| 		network6, broadcast6 := util.GetIPPrefixEndpoints(*prefix6)
    60| 		ips.Add(network6)
    61| 		ips.Add(broadcast6)
    62| 		ret.prev6 = network6
    63| 	}
    64| 	for _, addrStr := range append(v4s, v6s...) {
    65| 		if addrStr.Valid {
    66| 			addr, err := netip.ParseAddr(addrStr.String)
    67| 			if err != nil {
    68| 				return nil, fmt.Errorf("parsing IP address from database: %w", err)
    69| 			}
    70| 			ips.Add(addr)
    71| 		}
    72| 	}
    73| 	_, err := ips.IPSet()
    74| 	if err != nil {
    75| 		return nil, fmt.Errorf(
    76| 			"building initial IP Set: %w",
    77| 			err,
    78| 		)
    79| 	}
    80| 	ret.usedIPs = ips
    81| 	return &ret, nil
    82| }
    83| func (i *IPAllocator) Next() (*netip.Addr, *netip.Addr, error) {
    84| 	i.mu.Lock()
    85| 	defer i.mu.Unlock()
    86| 	var err error
    87| 	var ret4 *netip.Addr
    88| 	var ret6 *netip.Addr
    89| 	if i.prefix4 != nil {
    90| 		ret4, err = i.next(i.prev4, i.prefix4)
    91| 		if err != nil {
    92| 			return nil, nil, fmt.Errorf("allocating IPv4 address: %w", err)
    93| 		}
    94| 		i.prev4 = *ret4
    95| 	}
    96| 	if i.prefix6 != nil {
    97| 		ret6, err = i.next(i.prev6, i.prefix6)
    98| 		if err != nil {
    99| 			return nil, nil, fmt.Errorf("allocating IPv6 address: %w", err)
   100| 		}
   101| 		i.prev6 = *ret6
   102| 	}
   103| 	return ret4, ret6, nil
   104| }
   105| var ErrCouldNotAllocateIP = errors.New("failed to allocate IP")
   106| func (i *IPAllocator) nextLocked(prev netip.Addr, prefix *netip.Prefix) (*netip.Addr, error) {
   107| 	i.mu.Lock()
   108| 	defer i.mu.Unlock()
   109| 	return i.next(prev, prefix)
   110| }
   111| func (i *IPAllocator) next(prev netip.Addr, prefix *netip.Prefix) (*netip.Addr, error) {
   112| 	var err error
   113| 	var ip netip.Addr
   114| 	switch i.strategy {
   115| 	case types.IPAllocationStrategySequential:
   116| 		ip = prev.Next()
   117| 	case types.IPAllocationStrategyRandom:
   118| 		ip, err = randomNext(*prefix)
   119| 		if err != nil {
   120| 			return nil, fmt.Errorf("getting random IP: %w", err)
   121| 		}
   122| 	}
   123| 	set, err := i.usedIPs.IPSet()
   124| 	if err != nil {
   125| 		return nil, err
   126| 	}
   127| 	for {
   128| 		if !prefix.Contains(ip) {
   129| 			return nil, ErrCouldNotAllocateIP
   130| 		}
   131| 		if set.Contains(ip) {
   132| 			switch i.strategy {
   133| 			case types.IPAllocationStrategySequential:
   134| 				ip = ip.Next()
   135| 			case types.IPAllocationStrategyRandom:
   136| 				ip, err = randomNext(*prefix)
   137| 				if err != nil {
   138| 					return nil, fmt.Errorf("getting random IP: %w", err)
   139| 				}
   140| 			}
   141| 			continue
   142| 		}
   143| 		i.usedIPs.Add(ip)
   144| 		return &ip, nil
   145| 	}
   146| }
   147| func randomNext(pfx netip.Prefix) (netip.Addr, error) {
   148| 	rang := netipx.RangeOfPrefix(pfx)
   149| 	fromIP, toIP := rang.From(), rang.To()
   150| 	var from, to big.Int
   151| 	from.SetBytes(fromIP.AsSlice())
   152| 	to.SetBytes(toIP.AsSlice())
   153| 	tempMax := big.NewInt(0).Sub(&to, &from)
   154| 	out, err := rand.Int(rand.Reader, tempMax)
   155| 	if err != nil {
   156| 		return netip.Addr{}, fmt.Errorf("generating random IP: %w", err)
   157| 	}
   158| 	valInRange := big.NewInt(0).Add(&from, out)
   159| 	ip, ok := netip.AddrFromSlice(valInRange.Bytes())
   160| 	if !ok {
   161| 		return netip.Addr{}, fmt.Errorf("generated ip bytes are invalid ip")
   162| 	}
   163| 	if !pfx.Contains(ip) {
   164| 		return netip.Addr{}, fmt.Errorf(
   165| 			"generated ip(%s) not in prefix(%s)",
   166| 			ip.String(),
   167| 			pfx.String(),
   168| 		)
   169| 	}
   170| 	return ip, nil
   171| }
   172| func (db *HSDatabase) BackfillNodeIPs(i *IPAllocator) ([]string, error) {
   173| 	var err error
   174| 	var ret []string
   175| 	err = db.Write(func(tx *gorm.DB) error {
   176| 		if i == nil {
   177| 			return errors.New("backfilling IPs: ip allocator was nil")
   178| 		}
   179| 		log.Trace().Msgf("starting to backfill IPs")
   180| 		nodes, err := ListNodes(tx)
   181| 		if err != nil {
   182| 			return fmt.Errorf("listing nodes to backfill IPs: %w", err)
   183| 		}
   184| 		for _, node := range nodes {
   185| 			log.Trace().Uint64("node.id", node.ID.Uint64()).Msg("checking if need backfill")
   186| 			changed := false
   187| 			if i.prefix4 != nil && node.IPv4 == nil {
   188| 				ret4, err := i.nextLocked(i.prev4, i.prefix4)
   189| 				if err != nil {
   190| 					return fmt.Errorf("failed to allocate ipv4 for node(%d): %w", node.ID, err)
   191| 				}
   192| 				node.IPv4 = ret4
   193| 				changed = true
   194| 				ret = append(ret, fmt.Sprintf("assigned IPv4 %q to Node(%d) %q", ret4.String(), node.ID, node.Hostname))
   195| 			}
   196| 			if i.prefix6 != nil && node.IPv6 == nil {
   197| 				ret6, err := i.nextLocked(i.prev6, i.prefix6)
   198| 				if err != nil {
   199| 					return fmt.Errorf("failed to allocate ipv6 for node(%d): %w", node.ID, err)
   200| 				}
   201| 				node.IPv6 = ret6
   202| 				changed = true
   203| 				ret = append(ret, fmt.Sprintf("assigned IPv6 %q to Node(%d) %q", ret6.String(), node.ID, node.Hostname))
   204| 			}
   205| 			if i.prefix4 == nil && node.IPv4 != nil {
   206| 				ret = append(ret, fmt.Sprintf("removing IPv4 %q from Node(%d) %q", node.IPv4.String(), node.ID, node.Hostname))
   207| 				node.IPv4 = nil
   208| 				changed = true
   209| 			}
   210| 			if i.prefix6 == nil && node.IPv6 != nil {
   211| 				ret = append(ret, fmt.Sprintf("removing IPv6 %q from Node(%d) %q", node.IPv6.String(), node.ID, node.Hostname))
   212| 				node.IPv6 = nil
   213| 				changed = true
   214| 			}
   215| 			if changed {
   216| 				err := tx.Save(node).Error
   217| 				if err != nil {
   218| 					return fmt.Errorf("saving node(%d) after adding IPs: %w", node.ID, err)
   219| 				}
   220| 			}
   221| 		}
   222| 		return nil
   223| 	})
   224| 	return ret, err
   225| }


# ====================================================================
# FILE: hscontrol/db/node.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-616 ---
     1| package db
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"net/netip"
     6| 	"sort"
     7| 	"sync"
     8| 	"time"
     9| 	"github.com/juanfont/headscale/hscontrol/types"
    10| 	"github.com/juanfont/headscale/hscontrol/util"
    11| 	"github.com/patrickmn/go-cache"
    12| 	"github.com/puzpuzpuz/xsync/v3"
    13| 	"github.com/rs/zerolog/log"
    14| 	"gorm.io/gorm"
    15| 	"tailscale.com/tailcfg"
    16| 	"tailscale.com/types/key"
    17| )
    18| const (
    19| 	NodeGivenNameHashLength = 8
    20| 	NodeGivenNameTrimSize   = 2
    21| )
    22| var (
    23| 	ErrNodeNotFound                  = errors.New("node not found")
    24| 	ErrNodeRouteIsNotAvailable       = errors.New("route is not available on node")
    25| 	ErrNodeNotFoundRegistrationCache = errors.New(
    26| 		"node not found in registration cache",
    27| 	)
    28| 	ErrCouldNotConvertNodeInterface = errors.New("failed to convert node interface")
    29| 	ErrDifferentRegisteredUser      = errors.New(
    30| 		"node was previously registered with a different user",
    31| 	)
    32| )
    33| func (hsdb *HSDatabase) ListPeers(nodeID types.NodeID) (types.Nodes, error) {
    34| 	return Read(hsdb.DB, func(rx *gorm.DB) (types.Nodes, error) {
    35| 		return ListPeers(rx, nodeID)
    36| 	})
    37| }
    38| func ListPeers(tx *gorm.DB, nodeID types.NodeID) (types.Nodes, error) {
    39| 	nodes := types.Nodes{}
    40| 	if err := tx.
    41| 		Preload("AuthKey").
    42| 		Preload("AuthKey.User").
    43| 		Preload("User").
    44| 		Preload("Routes").
    45| 		Where("id <> ?",
    46| 			nodeID).Find(&nodes).Error; err != nil {
    47| 		return types.Nodes{}, err
    48| 	}
    49| 	sort.Slice(nodes, func(i, j int) bool { return nodes[i].ID < nodes[j].ID })
    50| 	return nodes, nil
    51| }
    52| func (hsdb *HSDatabase) ListNodes() (types.Nodes, error) {
    53| 	return Read(hsdb.DB, func(rx *gorm.DB) (types.Nodes, error) {
    54| 		return ListNodes(rx)
    55| 	})
    56| }
    57| func ListNodes(tx *gorm.DB) (types.Nodes, error) {
    58| 	nodes := types.Nodes{}
    59| 	if err := tx.
    60| 		Preload("AuthKey").
    61| 		Preload("AuthKey.User").
    62| 		Preload("User").
    63| 		Preload("Routes").
    64| 		Find(&nodes).Error; err != nil {
    65| 		return nil, err
    66| 	}
    67| 	return nodes, nil
    68| }
    69| func (hsdb *HSDatabase) ListEphemeralNodes() (types.Nodes, error) {
    70| 	return Read(hsdb.DB, func(rx *gorm.DB) (types.Nodes, error) {
    71| 		nodes := types.Nodes{}
    72| 		if err := rx.Joins("AuthKey").Where(`"AuthKey"."ephemeral" = true`).Find(&nodes).Error; err != nil {
    73| 			return nil, err
    74| 		}
    75| 		return nodes, nil
    76| 	})
    77| }
    78| func (hsdb *HSDatabase) getNode(user string, name string) (*types.Node, error) {
    79| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.Node, error) {
    80| 		return getNode(rx, user, name)
    81| 	})
    82| }
    83| func getNode(tx *gorm.DB, user string, name string) (*types.Node, error) {
    84| 	nodes, err := ListNodesByUser(tx, user)
    85| 	if err != nil {
    86| 		return nil, err
    87| 	}
    88| 	for _, m := range nodes {
    89| 		if m.Hostname == name {
    90| 			return m, nil
    91| 		}
    92| 	}
    93| 	return nil, ErrNodeNotFound
    94| }
    95| func (hsdb *HSDatabase) GetNodeByID(id types.NodeID) (*types.Node, error) {
    96| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.Node, error) {
    97| 		return GetNodeByID(rx, id)
    98| 	})
    99| }
   100| func GetNodeByID(tx *gorm.DB, id types.NodeID) (*types.Node, error) {
   101| 	mach := types.Node{}
   102| 	if result := tx.
   103| 		Preload("AuthKey").
   104| 		Preload("AuthKey.User").
   105| 		Preload("User").
   106| 		Preload("Routes").
   107| 		Find(&types.Node{ID: id}).First(&mach); result.Error != nil {
   108| 		return nil, result.Error
   109| 	}
   110| 	return &mach, nil
   111| }
   112| func (hsdb *HSDatabase) GetNodeByMachineKey(machineKey key.MachinePublic) (*types.Node, error) {
   113| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.Node, error) {
   114| 		return GetNodeByMachineKey(rx, machineKey)
   115| 	})
   116| }
   117| func GetNodeByMachineKey(
   118| 	tx *gorm.DB,
   119| 	machineKey key.MachinePublic,
   120| ) (*types.Node, error) {
   121| 	mach := types.Node{}
   122| 	if result := tx.
   123| 		Preload("AuthKey").
   124| 		Preload("AuthKey.User").
   125| 		Preload("User").
   126| 		Preload("Routes").
   127| 		First(&mach, "machine_key = ?", machineKey.String()); result.Error != nil {
   128| 		return nil, result.Error
   129| 	}
   130| 	return &mach, nil
   131| }
   132| func (hsdb *HSDatabase) GetNodeByAnyKey(
   133| 	machineKey key.MachinePublic,
   134| 	nodeKey key.NodePublic,
   135| 	oldNodeKey key.NodePublic,
   136| ) (*types.Node, error) {
   137| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.Node, error) {
   138| 		return GetNodeByAnyKey(rx, machineKey, nodeKey, oldNodeKey)
   139| 	})
   140| }
   141| func GetNodeByAnyKey(
   142| 	tx *gorm.DB,
   143| 	machineKey key.MachinePublic, nodeKey key.NodePublic, oldNodeKey key.NodePublic,
   144| ) (*types.Node, error) {
   145| 	node := types.Node{}
   146| 	if result := tx.
   147| 		Preload("AuthKey").
   148| 		Preload("AuthKey.User").
   149| 		Preload("User").
   150| 		Preload("Routes").
   151| 		First(&node, "machine_key = ? OR node_key = ? OR node_key = ?",
   152| 			machineKey.String(),
   153| 			nodeKey.String(),
   154| 			oldNodeKey.String()); result.Error != nil {
   155| 		return nil, result.Error
   156| 	}
   157| 	return &node, nil
   158| }
   159| func (hsdb *HSDatabase) SetTags(
   160| 	nodeID types.NodeID,
   161| 	tags []string,
   162| ) error {
   163| 	return hsdb.Write(func(tx *gorm.DB) error {
   164| 		return SetTags(tx, nodeID, tags)
   165| 	})
   166| }
   167| func SetTags(
   168| 	tx *gorm.DB,
   169| 	nodeID types.NodeID,
   170| 	tags []string,
   171| ) error {
   172| 	if len(tags) == 0 {
   173| 		if err := tx.Model(&types.Node{}).Where("id = ?", nodeID).Update("forced_tags", types.StringList{}).Error; err != nil {
   174| 			return fmt.Errorf("failed to remove tags for node in the database: %w", err)
   175| 		}
   176| 		return nil
   177| 	}
   178| 	var newTags types.StringList
   179| 	for _, tag := range tags {
   180| 		if !util.StringOrPrefixListContains(newTags, tag) {
   181| 			newTags = append(newTags, tag)
   182| 		}
   183| 	}
   184| 	if err := tx.Model(&types.Node{}).Where("id = ?", nodeID).Update("forced_tags", newTags).Error; err != nil {
   185| 		return fmt.Errorf("failed to update tags for node in the database: %w", err)
   186| 	}
   187| 	return nil
   188| }
   189| func RenameNode(tx *gorm.DB,
   190| 	nodeID types.NodeID, newName string,
   191| ) error {
   192| 	err := util.CheckForFQDNRules(
   193| 		newName,
   194| 	)
   195| 	if err != nil {
   196| 		return fmt.Errorf("renaming node: %w", err)
   197| 	}
   198| 	uniq, err := isUnqiueName(tx, newName)
   199| 	if err != nil {
   200| 		return fmt.Errorf("checking if name is unique: %w", err)
   201| 	}
   202| 	if !uniq {
   203| 		return fmt.Errorf("name is not unique: %s", newName)
   204| 	}
   205| 	if err := tx.Model(&types.Node{}).Where("id = ?", nodeID).Update("given_name", newName).Error; err != nil {
   206| 		return fmt.Errorf("failed to rename node in the database: %w", err)
   207| 	}
   208| 	return nil
   209| }
   210| func (hsdb *HSDatabase) NodeSetExpiry(nodeID types.NodeID, expiry time.Time) error {
   211| 	return hsdb.Write(func(tx *gorm.DB) error {
   212| 		return NodeSetExpiry(tx, nodeID, expiry)
   213| 	})
   214| }
   215| func NodeSetExpiry(tx *gorm.DB,
   216| 	nodeID types.NodeID, expiry time.Time,
   217| ) error {
   218| 	return tx.Model(&types.Node{}).Where("id = ?", nodeID).Update("expiry", expiry).Error
   219| }
   220| func (hsdb *HSDatabase) DeleteNode(node *types.Node, isLikelyConnected *xsync.MapOf[types.NodeID, bool]) ([]types.NodeID, error) {
   221| 	return Write(hsdb.DB, func(tx *gorm.DB) ([]types.NodeID, error) {
   222| 		return DeleteNode(tx, node, isLikelyConnected)
   223| 	})
   224| }
   225| func DeleteNode(tx *gorm.DB,
   226| 	node *types.Node,
   227| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   228| ) ([]types.NodeID, error) {
   229| 	changed, err := deleteNodeRoutes(tx, node, isLikelyConnected)
   230| 	if err != nil {
   231| 		return changed, err
   232| 	}
   233| 	if err := tx.Unscoped().Delete(&types.Node{}, node.ID).Error; err != nil {
   234| 		return changed, err
   235| 	}
   236| 	return changed, nil
   237| }
   238| func (hsdb *HSDatabase) DeleteEphemeralNode(
   239| 	nodeID types.NodeID,
   240| ) error {
   241| 	return hsdb.Write(func(tx *gorm.DB) error {
   242| 		if err := tx.Unscoped().Delete(&types.Node{}, nodeID).Error; err != nil {
   243| 			return err
   244| 		}
   245| 		return nil
   246| 	})
   247| }
   248| func SetLastSeen(tx *gorm.DB, nodeID types.NodeID, lastSeen time.Time) error {
   249| 	return tx.Model(&types.Node{}).Where("id = ?", nodeID).Update("last_seen", lastSeen).Error
   250| }
   251| func RegisterNodeFromAuthCallback(
   252| 	tx *gorm.DB,
   253| 	cache *cache.Cache,
   254| 	mkey key.MachinePublic,
   255| 	userName string,
   256| 	nodeExpiry *time.Time,
   257| 	registrationMethod string,
   258| 	ipv4 *netip.Addr,
   259| 	ipv6 *netip.Addr,
   260| ) (*types.Node, error) {
   261| 	log.Debug().
   262| 		Str("machine_key", mkey.ShortString()).
   263| 		Str("userName", userName).
   264| 		Str("registrationMethod", registrationMethod).
   265| 		Str("expiresAt", fmt.Sprintf("%v", nodeExpiry)).
   266| 		Msg("Registering node from API/CLI or auth callback")
   267| 	if nodeInterface, ok := cache.Get(mkey.String()); ok {
   268| 		if registrationNode, ok := nodeInterface.(types.Node); ok {
   269| 			user, err := GetUser(tx, userName)
   270| 			if err != nil {
   271| 				return nil, fmt.Errorf(
   272| 					"failed to find user in register node from auth callback, %w",
   273| 					err,
   274| 				)
   275| 			}
   276| 			if registrationNode.ID != 0 &&
   277| 				registrationNode.UserID != user.ID {
   278| 				return nil, ErrDifferentRegisteredUser
   279| 			}
   280| 			registrationNode.UserID = user.ID
   281| 			registrationNode.User = *user
   282| 			registrationNode.RegisterMethod = registrationMethod
   283| 			if nodeExpiry != nil {
   284| 				registrationNode.Expiry = nodeExpiry
   285| 			}
   286| 			node, err := RegisterNode(
   287| 				tx,
   288| 				registrationNode,
   289| 				ipv4, ipv6,
   290| 			)
   291| 			if err == nil {
   292| 				cache.Delete(mkey.String())
   293| 			}
   294| 			return node, err
   295| 		} else {
   296| 			return nil, ErrCouldNotConvertNodeInterface
   297| 		}
   298| 	}
   299| 	return nil, ErrNodeNotFoundRegistrationCache
   300| }
   301| func (hsdb *HSDatabase) RegisterNode(node types.Node, ipv4 *netip.Addr, ipv6 *netip.Addr) (*types.Node, error) {
   302| 	return Write(hsdb.DB, func(tx *gorm.DB) (*types.Node, error) {
   303| 		return RegisterNode(tx, node, ipv4, ipv6)
   304| 	})
   305| }
   306| func RegisterNode(tx *gorm.DB, node types.Node, ipv4 *netip.Addr, ipv6 *netip.Addr) (*types.Node, error) {
   307| 	log.Debug().
   308| 		Str("node", node.Hostname).
   309| 		Str("machine_key", node.MachineKey.ShortString()).
   310| 		Str("node_key", node.NodeKey.ShortString()).
   311| 		Str("user", node.User.Name).
   312| 		Msg("Registering node")
   313| 	if node.IPv4 != nil || node.IPv6 != nil {
   314| 		if err := tx.Save(&node).Error; err != nil {
   315| 			return nil, fmt.Errorf("failed register existing node in the database: %w", err)
   316| 		}
   317| 		log.Trace().
   318| 			Caller().
   319| 			Str("node", node.Hostname).
   320| 			Str("machine_key", node.MachineKey.ShortString()).
   321| 			Str("node_key", node.NodeKey.ShortString()).
   322| 			Str("user", node.User.Name).
   323| 			Msg("Node authorized again")
   324| 		return &node, nil
   325| 	}
   326| 	node.IPv4 = ipv4
   327| 	node.IPv6 = ipv6
   328| 	if node.GivenName == "" {
   329| 		givenName, err := ensureUniqueGivenName(tx, node.Hostname)
   330| 		if err != nil {
   331| 			return nil, fmt.Errorf("failed to ensure unique given name: %w", err)
   332| 		}
   333| 		node.GivenName = givenName
   334| 	}
   335| 	if err := tx.Save(&node).Error; err != nil {
   336| 		return nil, fmt.Errorf("failed register(save) node in the database: %w", err)
   337| 	}
   338| 	log.Trace().
   339| 		Caller().
   340| 		Str("node", node.Hostname).
   341| 		Msg("Node registered with the database")
   342| 	return &node, nil
   343| }
   344| func NodeSetNodeKey(tx *gorm.DB, node *types.Node, nodeKey key.NodePublic) error {
   345| 	return tx.Model(node).Updates(types.Node{
   346| 		NodeKey: nodeKey,
   347| 	}).Error
   348| }
   349| func (hsdb *HSDatabase) NodeSetMachineKey(
   350| 	node *types.Node,
   351| 	machineKey key.MachinePublic,
   352| ) error {
   353| 	return hsdb.Write(func(tx *gorm.DB) error {
   354| 		return NodeSetMachineKey(tx, node, machineKey)
   355| 	})
   356| }
   357| func NodeSetMachineKey(
   358| 	tx *gorm.DB,
   359| 	node *types.Node,
   360| 	machineKey key.MachinePublic,
   361| ) error {
   362| 	return tx.Model(node).Updates(types.Node{
   363| 		MachineKey: machineKey,
   364| 	}).Error
   365| }
   366| func NodeSave(tx *gorm.DB, node *types.Node) error {
   367| 	return tx.Save(node).Error
   368| }
   369| func (hsdb *HSDatabase) GetAdvertisedRoutes(node *types.Node) ([]netip.Prefix, error) {
   370| 	return Read(hsdb.DB, func(rx *gorm.DB) ([]netip.Prefix, error) {
   371| 		return GetAdvertisedRoutes(rx, node)
   372| 	})
   373| }
   374| func GetAdvertisedRoutes(tx *gorm.DB, node *types.Node) ([]netip.Prefix, error) {
   375| 	routes := types.Routes{}
   376| 	err := tx.
   377| 		Preload("Node").
   378| 		Where("node_id = ? AND advertised = ?", node.ID, true).Find(&routes).Error
   379| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   380| 		return nil, fmt.Errorf("getting advertised routes for node(%d): %w", node.ID, err)
   381| 	}
   382| 	var prefixes []netip.Prefix
   383| 	for _, route := range routes {
   384| 		prefixes = append(prefixes, netip.Prefix(route.Prefix))
   385| 	}
   386| 	return prefixes, nil
   387| }
   388| func (hsdb *HSDatabase) GetEnabledRoutes(node *types.Node) ([]netip.Prefix, error) {
   389| 	return Read(hsdb.DB, func(rx *gorm.DB) ([]netip.Prefix, error) {
   390| 		return GetEnabledRoutes(rx, node)
   391| 	})
   392| }
   393| func GetEnabledRoutes(tx *gorm.DB, node *types.Node) ([]netip.Prefix, error) {
   394| 	routes := types.Routes{}
   395| 	err := tx.
   396| 		Preload("Node").
   397| 		Where("node_id = ? AND advertised = ? AND enabled = ?", node.ID, true, true).
   398| 		Find(&routes).Error
   399| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   400| 		return nil, fmt.Errorf("getting enabled routes for node(%d): %w", node.ID, err)
   401| 	}
   402| 	var prefixes []netip.Prefix
   403| 	for _, route := range routes {
   404| 		prefixes = append(prefixes, netip.Prefix(route.Prefix))
   405| 	}
   406| 	return prefixes, nil
   407| }
   408| func IsRoutesEnabled(tx *gorm.DB, node *types.Node, routeStr string) bool {
   409| 	route, err := netip.ParsePrefix(routeStr)
   410| 	if err != nil {
   411| 		return false
   412| 	}
   413| 	enabledRoutes, err := GetEnabledRoutes(tx, node)
   414| 	if err != nil {
   415| 		return false
   416| 	}
   417| 	for _, enabledRoute := range enabledRoutes {
   418| 		if route == enabledRoute {
   419| 			return true
   420| 		}
   421| 	}
   422| 	return false
   423| }
   424| func (hsdb *HSDatabase) enableRoutes(
   425| 	node *types.Node,
   426| 	routeStrs ...string,
   427| ) (*types.StateUpdate, error) {
   428| 	return Write(hsdb.DB, func(tx *gorm.DB) (*types.StateUpdate, error) {
   429| 		return enableRoutes(tx, node, routeStrs...)
   430| 	})
   431| }
   432| func enableRoutes(tx *gorm.DB,
   433| 	node *types.Node, routeStrs ...string,
   434| ) (*types.StateUpdate, error) {
   435| 	newRoutes := make([]netip.Prefix, len(routeStrs))
   436| 	for index, routeStr := range routeStrs {
   437| 		route, err := netip.ParsePrefix(routeStr)
   438| 		if err != nil {
   439| 			return nil, err
   440| 		}
   441| 		newRoutes[index] = route
   442| 	}
   443| 	advertisedRoutes, err := GetAdvertisedRoutes(tx, node)
   444| 	if err != nil {
   445| 		return nil, err
   446| 	}
   447| 	for _, newRoute := range newRoutes {
   448| 		if !util.StringOrPrefixListContains(advertisedRoutes, newRoute) {
   449| 			return nil, fmt.Errorf(
   450| 				"route (%s) is not available on node %s: %w",
   451| 				node.Hostname,
   452| 				newRoute, ErrNodeRouteIsNotAvailable,
   453| 			)
   454| 		}
   455| 	}
   456| 	for _, prefix := range newRoutes {
   457| 		route := types.Route{}
   458| 		err := tx.Preload("Node").
   459| 			Where("node_id = ? AND prefix = ?", node.ID, types.IPPrefix(prefix)).
   460| 			First(&route).Error
   461| 		if err == nil {
   462| 			route.Enabled = true
   463| 			if !route.IsExitRoute() {
   464| 				route.IsPrimary = isUniquePrefix(tx, route)
   465| 			}
   466| 			err = tx.Save(&route).Error
   467| 			if err != nil {
   468| 				return nil, fmt.Errorf("failed to enable route: %w", err)
   469| 			}
   470| 		} else {
   471| 			return nil, fmt.Errorf("failed to find route: %w", err)
   472| 		}
   473| 	}
   474| 	nRoutes, err := GetNodeRoutes(tx, node)
   475| 	if err != nil {
   476| 		return nil, fmt.Errorf("failed to read back routes: %w", err)
   477| 	}
   478| 	node.Routes = nRoutes
   479| 	log.Trace().
   480| 		Caller().
   481| 		Str("node", node.Hostname).
   482| 		Strs("routes", routeStrs).
   483| 		Msg("enabling routes")
   484| 	return &types.StateUpdate{
   485| 		Type:        types.StatePeerChanged,
   486| 		ChangeNodes: []types.NodeID{node.ID},
   487| 		Message:     "created in db.enableRoutes",
   488| 	}, nil
   489| }
   490| func generateGivenName(suppliedName string, randomSuffix bool) (string, error) {
   491| 	normalizedHostname, err := util.NormalizeToFQDNRulesConfigFromViper(
   492| 		suppliedName,
   493| 	)
   494| 	if err != nil {
   495| 		return "", err
   496| 	}
   497| 	if randomSuffix {
   498| 		trimmedHostnameLength := util.LabelHostnameLength - NodeGivenNameHashLength - NodeGivenNameTrimSize
   499| 		if len(normalizedHostname) > trimmedHostnameLength {
   500| 			normalizedHostname = normalizedHostname[:trimmedHostnameLength]
   501| 		}
   502| 		suffix, err := util.GenerateRandomStringDNSSafe(NodeGivenNameHashLength)
   503| 		if err != nil {
   504| 			return "", err
   505| 		}
   506| 		normalizedHostname += "-" + suffix
   507| 	}
   508| 	return normalizedHostname, nil
   509| }
   510| func isUnqiueName(tx *gorm.DB, name string) (bool, error) {
   511| 	nodes := types.Nodes{}
   512| 	if err := tx.
   513| 		Where("given_name = ?", name).Find(&nodes).Error; err != nil {
   514| 		return false, err
   515| 	}
   516| 	return len(nodes) == 0, nil
   517| }
   518| func ensureUniqueGivenName(
   519| 	tx *gorm.DB,
   520| 	name string,
   521| ) (string, error) {
   522| 	givenName, err := generateGivenName(name, false)
   523| 	if err != nil {
   524| 		return "", err
   525| 	}
   526| 	unique, err := isUnqiueName(tx, givenName)
   527| 	if err != nil {
   528| 		return "", err
   529| 	}
   530| 	if !unique {
   531| 		postfixedName, err := generateGivenName(name, true)
   532| 		if err != nil {
   533| 			return "", err
   534| 		}
   535| 		givenName = postfixedName
   536| 	}
   537| 	return givenName, nil
   538| }
   539| func ExpireExpiredNodes(tx *gorm.DB,
   540| 	lastCheck time.Time,
   541| ) (time.Time, types.StateUpdate, bool) {
   542| 	started := time.Now()
   543| 	expired := make([]*tailcfg.PeerChange, 0)
   544| 	nodes, err := ListNodes(tx)
   545| 	if err != nil {
   546| 		return time.Unix(0, 0), types.StateUpdate{}, false
   547| 	}
   548| 	for _, node := range nodes {
   549| 		if node.IsExpired() && node.Expiry.After(lastCheck) {
   550| 			expired = append(expired, &tailcfg.PeerChange{
   551| 				NodeID:    tailcfg.NodeID(node.ID),
   552| 				KeyExpiry: node.Expiry,
   553| 			})
   554| 		}
   555| 	}
   556| 	if len(expired) > 0 {
   557| 		return started, types.StateUpdate{
   558| 			Type:          types.StatePeerChangedPatch,
   559| 			ChangePatches: expired,
   560| 		}, true
   561| 	}
   562| 	return started, types.StateUpdate{}, false
   563| }
   564| type EphemeralGarbageCollector struct {
   565| 	mu sync.Mutex
   566| 	deleteFunc  func(types.NodeID)
   567| 	toBeDeleted map[types.NodeID]*time.Timer
   568| 	deleteCh chan types.NodeID
   569| 	cancelCh chan struct{}
   570| }
   571| func NewEphemeralGarbageCollector(deleteFunc func(types.NodeID)) *EphemeralGarbageCollector {
   572| 	return &EphemeralGarbageCollector{
   573| 		toBeDeleted: make(map[types.NodeID]*time.Timer),
   574| 		deleteCh:    make(chan types.NodeID, 10),
   575| 		cancelCh:    make(chan struct{}),
   576| 		deleteFunc:  deleteFunc,
   577| 	}
   578| }
   579| func (e *EphemeralGarbageCollector) Close() {
   580| 	e.cancelCh <- struct{}{}
   581| }
   582| func (e *EphemeralGarbageCollector) Schedule(nodeID types.NodeID, expiry time.Duration) {
   583| 	e.mu.Lock()
   584| 	timer := time.NewTimer(expiry)
   585| 	e.toBeDeleted[nodeID] = timer
   586| 	e.mu.Unlock()
   587| 	go func() {
   588| 		select {
   589| 		case _, ok := <-timer.C:
   590| 			if ok {
   591| 				e.deleteCh <- nodeID
   592| 			}
   593| 		}
   594| 	}()
   595| }
   596| func (e *EphemeralGarbageCollector) Cancel(nodeID types.NodeID) {
   597| 	e.mu.Lock()
   598| 	defer e.mu.Unlock()
   599| 	if timer, ok := e.toBeDeleted[nodeID]; ok {
   600| 		timer.Stop()
   601| 		delete(e.toBeDeleted, nodeID)
   602| 	}
   603| }
   604| func (e *EphemeralGarbageCollector) Start() {
   605| 	for {
   606| 		select {
   607| 		case <-e.cancelCh:
   608| 			return
   609| 		case nodeID := <-e.deleteCh:
   610| 			e.mu.Lock()
   611| 			delete(e.toBeDeleted, nodeID)
   612| 			e.mu.Unlock()
   613| 			go e.deleteFunc(nodeID)
   614| 		}
   615| 	}
   616| }


# ====================================================================
# FILE: hscontrol/db/policy.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-29 ---
     1| package db
     2| import (
     3| 	"errors"
     4| 	"github.com/juanfont/headscale/hscontrol/types"
     5| 	"gorm.io/gorm"
     6| 	"gorm.io/gorm/clause"
     7| )
     8| func (hsdb *HSDatabase) SetPolicy(policy string) (*types.Policy, error) {
     9| 	p := types.Policy{
    10| 		Data: policy,
    11| 	}
    12| 	if err := hsdb.DB.Clauses(clause.Returning{}).Create(&p).Error; err != nil {
    13| 		return nil, err
    14| 	}
    15| 	return &p, nil
    16| }
    17| func (hsdb *HSDatabase) GetPolicy() (*types.Policy, error) {
    18| 	var p types.Policy
    19| 	if err := hsdb.DB.
    20| 		Order("id DESC").
    21| 		Limit(1).
    22| 		First(&p).Error; err != nil {
    23| 		if errors.Is(err, gorm.ErrRecordNotFound) {
    24| 			return nil, types.ErrPolicyNotFound
    25| 		}
    26| 		return nil, err
    27| 	}
    28| 	return &p, nil
    29| }


# ====================================================================
# FILE: hscontrol/db/preauth_keys.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-178 ---
     1| package db
     2| import (
     3| 	"crypto/rand"
     4| 	"encoding/hex"
     5| 	"errors"
     6| 	"fmt"
     7| 	"strings"
     8| 	"time"
     9| 	"github.com/juanfont/headscale/hscontrol/types"
    10| 	"gorm.io/gorm"
    11| 	"tailscale.com/types/ptr"
    12| )
    13| var (
    14| 	ErrPreAuthKeyNotFound          = errors.New("AuthKey not found")
    15| 	ErrPreAuthKeyExpired           = errors.New("AuthKey expired")
    16| 	ErrSingleUseAuthKeyHasBeenUsed = errors.New("AuthKey has already been used")
    17| 	ErrUserMismatch                = errors.New("user mismatch")
    18| 	ErrPreAuthKeyACLTagInvalid     = errors.New("AuthKey tag is invalid")
    19| )
    20| func (hsdb *HSDatabase) CreatePreAuthKey(
    21| 	userName string,
    22| 	reusable bool,
    23| 	ephemeral bool,
    24| 	expiration *time.Time,
    25| 	aclTags []string,
    26| ) (*types.PreAuthKey, error) {
    27| 	return Write(hsdb.DB, func(tx *gorm.DB) (*types.PreAuthKey, error) {
    28| 		return CreatePreAuthKey(tx, userName, reusable, ephemeral, expiration, aclTags)
    29| 	})
    30| }
    31| func CreatePreAuthKey(
    32| 	tx *gorm.DB,
    33| 	userName string,
    34| 	reusable bool,
    35| 	ephemeral bool,
    36| 	expiration *time.Time,
    37| 	aclTags []string,
    38| ) (*types.PreAuthKey, error) {
    39| 	user, err := GetUser(tx, userName)
    40| 	if err != nil {
    41| 		return nil, err
    42| 	}
    43| 	for _, tag := range aclTags {
    44| 		if !strings.HasPrefix(tag, "tag:") {
    45| 			return nil, fmt.Errorf(
    46| 				"%w: '%s' did not begin with 'tag:'",
    47| 				ErrPreAuthKeyACLTagInvalid,
    48| 				tag,
    49| 			)
    50| 		}
    51| 	}
    52| 	now := time.Now().UTC()
    53| 	kstr, err := generateKey()
    54| 	if err != nil {
    55| 		return nil, err
    56| 	}
    57| 	key := types.PreAuthKey{
    58| 		Key:        kstr,
    59| 		UserID:     user.ID,
    60| 		User:       *user,
    61| 		Reusable:   reusable,
    62| 		Ephemeral:  ephemeral,
    63| 		CreatedAt:  &now,
    64| 		Expiration: expiration,
    65| 	}
    66| 	if err := tx.Save(&key).Error; err != nil {
    67| 		return nil, fmt.Errorf("failed to create key in the database: %w", err)
    68| 	}
    69| 	if len(aclTags) > 0 {
    70| 		seenTags := map[string]bool{}
    71| 		for _, tag := range aclTags {
    72| 			if !seenTags[tag] {
    73| 				if err := tx.Save(&types.PreAuthKeyACLTag{PreAuthKeyID: key.ID, Tag: tag}).Error; err != nil {
    74| 					return nil, fmt.Errorf(
    75| 						"failed to create key tag in the database: %w",
    76| 						err,
    77| 					)
    78| 				}
    79| 				seenTags[tag] = true
    80| 			}
    81| 		}
    82| 	}
    83| 	return &key, nil
    84| }
    85| func (hsdb *HSDatabase) ListPreAuthKeys(userName string) ([]types.PreAuthKey, error) {
    86| 	return Read(hsdb.DB, func(rx *gorm.DB) ([]types.PreAuthKey, error) {
    87| 		return ListPreAuthKeys(rx, userName)
    88| 	})
    89| }
    90| func ListPreAuthKeys(tx *gorm.DB, userName string) ([]types.PreAuthKey, error) {
    91| 	user, err := GetUser(tx, userName)
    92| 	if err != nil {
    93| 		return nil, err
    94| 	}
    95| 	keys := []types.PreAuthKey{}
    96| 	if err := tx.Preload("User").Preload("ACLTags").Where(&types.PreAuthKey{UserID: user.ID}).Find(&keys).Error; err != nil {
    97| 		return nil, err
    98| 	}
    99| 	return keys, nil
   100| }
   101| func GetPreAuthKey(tx *gorm.DB, user string, key string) (*types.PreAuthKey, error) {
   102| 	pak, err := ValidatePreAuthKey(tx, key)
   103| 	if err != nil {
   104| 		return nil, err
   105| 	}
   106| 	if pak.User.Name != user {
   107| 		return nil, ErrUserMismatch
   108| 	}
   109| 	return pak, nil
   110| }
   111| func DestroyPreAuthKey(tx *gorm.DB, pak types.PreAuthKey) error {
   112| 	return tx.Transaction(func(db *gorm.DB) error {
   113| 		if result := db.Unscoped().Where(types.PreAuthKeyACLTag{PreAuthKeyID: pak.ID}).Delete(&types.PreAuthKeyACLTag{}); result.Error != nil {
   114| 			return result.Error
   115| 		}
   116| 		if result := db.Unscoped().Delete(pak); result.Error != nil {
   117| 			return result.Error
   118| 		}
   119| 		return nil
   120| 	})
   121| }
   122| func (hsdb *HSDatabase) ExpirePreAuthKey(k *types.PreAuthKey) error {
   123| 	return hsdb.Write(func(tx *gorm.DB) error {
   124| 		return ExpirePreAuthKey(tx, k)
   125| 	})
   126| }
   127| func ExpirePreAuthKey(tx *gorm.DB, k *types.PreAuthKey) error {
   128| 	if err := tx.Model(&k).Update("Expiration", time.Now()).Error; err != nil {
   129| 		return err
   130| 	}
   131| 	return nil
   132| }
   133| func UsePreAuthKey(tx *gorm.DB, k *types.PreAuthKey) error {
   134| 	k.Used = true
   135| 	if err := tx.Save(k).Error; err != nil {
   136| 		return fmt.Errorf("failed to update key used status in the database: %w", err)
   137| 	}
   138| 	return nil
   139| }
   140| func (hsdb *HSDatabase) ValidatePreAuthKey(k string) (*types.PreAuthKey, error) {
   141| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.PreAuthKey, error) {
   142| 		return ValidatePreAuthKey(rx, k)
   143| 	})
   144| }
   145| func ValidatePreAuthKey(tx *gorm.DB, k string) (*types.PreAuthKey, error) {
   146| 	pak := types.PreAuthKey{}
   147| 	if result := tx.Preload("User").Preload("ACLTags").First(&pak, "key = ?", k); errors.Is(
   148| 		result.Error,
   149| 		gorm.ErrRecordNotFound,
   150| 	) {
   151| 		return nil, ErrPreAuthKeyNotFound
   152| 	}
   153| 	if pak.Expiration != nil && pak.Expiration.Before(time.Now()) {
   154| 		return nil, ErrPreAuthKeyExpired
   155| 	}
   156| 	if pak.Reusable { // we don't need to check if has been used before
   157| 		return &pak, nil
   158| 	}
   159| 	nodes := types.Nodes{}
   160| 	if err := tx.
   161| 		Preload("AuthKey").
   162| 		Where(&types.Node{AuthKeyID: ptr.To(pak.ID)}).
   163| 		Find(&nodes).Error; err != nil {
   164| 		return nil, err
   165| 	}
   166| 	if len(nodes) != 0 || pak.Used {
   167| 		return nil, ErrSingleUseAuthKeyHasBeenUsed
   168| 	}
   169| 	return &pak, nil
   170| }
   171| func generateKey() (string, error) {
   172| 	size := 24
   173| 	bytes := make([]byte, size)
   174| 	if _, err := rand.Read(bytes); err != nil {
   175| 		return "", err
   176| 	}
   177| 	return hex.EncodeToString(bytes), nil
   178| }


# ====================================================================
# FILE: hscontrol/db/routes.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-511 ---
     1| package db
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"net/netip"
     6| 	"sort"
     7| 	"github.com/juanfont/headscale/hscontrol/policy"
     8| 	"github.com/juanfont/headscale/hscontrol/types"
     9| 	"github.com/puzpuzpuz/xsync/v3"
    10| 	"github.com/rs/zerolog/log"
    11| 	"gorm.io/gorm"
    12| 	"tailscale.com/util/set"
    13| )
    14| var ErrRouteIsNotAvailable = errors.New("route is not available")
    15| func GetRoutes(tx *gorm.DB) (types.Routes, error) {
    16| 	var routes types.Routes
    17| 	err := tx.
    18| 		Preload("Node").
    19| 		Preload("Node.User").
    20| 		Find(&routes).Error
    21| 	if err != nil {
    22| 		return nil, err
    23| 	}
    24| 	return routes, nil
    25| }
    26| func getAdvertisedAndEnabledRoutes(tx *gorm.DB) (types.Routes, error) {
    27| 	var routes types.Routes
    28| 	err := tx.
    29| 		Preload("Node").
    30| 		Preload("Node.User").
    31| 		Where("advertised = ? AND enabled = ?", true, true).
    32| 		Find(&routes).Error
    33| 	if err != nil {
    34| 		return nil, err
    35| 	}
    36| 	return routes, nil
    37| }
    38| func getRoutesByPrefix(tx *gorm.DB, pref netip.Prefix) (types.Routes, error) {
    39| 	var routes types.Routes
    40| 	err := tx.
    41| 		Preload("Node").
    42| 		Preload("Node.User").
    43| 		Where("prefix = ?", types.IPPrefix(pref)).
    44| 		Find(&routes).Error
    45| 	if err != nil {
    46| 		return nil, err
    47| 	}
    48| 	return routes, nil
    49| }
    50| func GetNodeAdvertisedRoutes(tx *gorm.DB, node *types.Node) (types.Routes, error) {
    51| 	var routes types.Routes
    52| 	err := tx.
    53| 		Preload("Node").
    54| 		Preload("Node.User").
    55| 		Where("node_id = ? AND advertised = true", node.ID).
    56| 		Find(&routes).Error
    57| 	if err != nil {
    58| 		return nil, err
    59| 	}
    60| 	return routes, nil
    61| }
    62| func (hsdb *HSDatabase) GetNodeRoutes(node *types.Node) (types.Routes, error) {
    63| 	return Read(hsdb.DB, func(rx *gorm.DB) (types.Routes, error) {
    64| 		return GetNodeRoutes(rx, node)
    65| 	})
    66| }
    67| func GetNodeRoutes(tx *gorm.DB, node *types.Node) (types.Routes, error) {
    68| 	var routes types.Routes
    69| 	err := tx.
    70| 		Preload("Node").
    71| 		Preload("Node.User").
    72| 		Where("node_id = ?", node.ID).
    73| 		Find(&routes).Error
    74| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
    75| 		return nil, err
    76| 	}
    77| 	return routes, nil
    78| }
    79| func GetRoute(tx *gorm.DB, id uint64) (*types.Route, error) {
    80| 	var route types.Route
    81| 	err := tx.
    82| 		Preload("Node").
    83| 		Preload("Node.User").
    84| 		First(&route, id).Error
    85| 	if err != nil {
    86| 		return nil, err
    87| 	}
    88| 	return &route, nil
    89| }
    90| func EnableRoute(tx *gorm.DB, id uint64) (*types.StateUpdate, error) {
    91| 	route, err := GetRoute(tx, id)
    92| 	if err != nil {
    93| 		return nil, err
    94| 	}
    95| 	if route.IsExitRoute() {
    96| 		return enableRoutes(
    97| 			tx,
    98| 			&route.Node,
    99| 			types.ExitRouteV4.String(),
   100| 			types.ExitRouteV6.String(),
   101| 		)
   102| 	}
   103| 	return enableRoutes(tx, &route.Node, netip.Prefix(route.Prefix).String())
   104| }
   105| func DisableRoute(tx *gorm.DB,
   106| 	id uint64,
   107| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   108| ) ([]types.NodeID, error) {
   109| 	route, err := GetRoute(tx, id)
   110| 	if err != nil {
   111| 		return nil, err
   112| 	}
   113| 	var routes types.Routes
   114| 	node := route.Node
   115| 	var update []types.NodeID
   116| 	if !route.IsExitRoute() {
   117| 		route.Enabled = false
   118| 		err = tx.Save(route).Error
   119| 		if err != nil {
   120| 			return nil, err
   121| 		}
   122| 		update, err = failoverRouteTx(tx, isLikelyConnected, route)
   123| 		if err != nil {
   124| 			return nil, err
   125| 		}
   126| 	} else {
   127| 		routes, err = GetNodeRoutes(tx, &node)
   128| 		if err != nil {
   129| 			return nil, err
   130| 		}
   131| 		for i := range routes {
   132| 			if routes[i].IsExitRoute() {
   133| 				routes[i].Enabled = false
   134| 				routes[i].IsPrimary = false
   135| 				err = tx.Save(&routes[i]).Error
   136| 				if err != nil {
   137| 					return nil, err
   138| 				}
   139| 			}
   140| 		}
   141| 	}
   142| 	if update == nil {
   143| 		update = []types.NodeID{node.ID}
   144| 	}
   145| 	return update, nil
   146| }
   147| func (hsdb *HSDatabase) DeleteRoute(
   148| 	id uint64,
   149| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   150| ) ([]types.NodeID, error) {
   151| 	return Write(hsdb.DB, func(tx *gorm.DB) ([]types.NodeID, error) {
   152| 		return DeleteRoute(tx, id, isLikelyConnected)
   153| 	})
   154| }
   155| func DeleteRoute(
   156| 	tx *gorm.DB,
   157| 	id uint64,
   158| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   159| ) ([]types.NodeID, error) {
   160| 	route, err := GetRoute(tx, id)
   161| 	if err != nil {
   162| 		return nil, err
   163| 	}
   164| 	var routes types.Routes
   165| 	node := route.Node
   166| 	var update []types.NodeID
   167| 	if !route.IsExitRoute() {
   168| 		update, err = failoverRouteTx(tx, isLikelyConnected, route)
   169| 		if err != nil {
   170| 			return nil, nil
   171| 		}
   172| 		if err := tx.Unscoped().Delete(&route).Error; err != nil {
   173| 			return nil, err
   174| 		}
   175| 	} else {
   176| 		routes, err = GetNodeRoutes(tx, &node)
   177| 		if err != nil {
   178| 			return nil, err
   179| 		}
   180| 		var routesToDelete types.Routes
   181| 		for _, r := range routes {
   182| 			if r.IsExitRoute() {
   183| 				routesToDelete = append(routesToDelete, r)
   184| 			}
   185| 		}
   186| 		if err := tx.Unscoped().Delete(&routesToDelete).Error; err != nil {
   187| 			return nil, err
   188| 		}
   189| 	}
   190| 	if routes == nil {
   191| 		routes, err = GetNodeRoutes(tx, &node)
   192| 		if err != nil {
   193| 			return nil, err
   194| 		}
   195| 	}
   196| 	node.Routes = routes
   197| 	if update == nil {
   198| 		update = []types.NodeID{node.ID}
   199| 	}
   200| 	return update, nil
   201| }
   202| func deleteNodeRoutes(tx *gorm.DB, node *types.Node, isLikelyConnected *xsync.MapOf[types.NodeID, bool]) ([]types.NodeID, error) {
   203| 	routes, err := GetNodeRoutes(tx, node)
   204| 	if err != nil {
   205| 		return nil, fmt.Errorf("getting node routes: %w", err)
   206| 	}
   207| 	var changed []types.NodeID
   208| 	for i := range routes {
   209| 		if err := tx.Unscoped().Delete(&routes[i]).Error; err != nil {
   210| 			return nil, fmt.Errorf("deleting route(%d): %w", &routes[i].ID, err)
   211| 		}
   212| 		chn, err := failoverRouteTx(tx, isLikelyConnected, &routes[i])
   213| 		if err != nil {
   214| 			return changed, fmt.Errorf("failing over route after delete: %w", err)
   215| 		}
   216| 		if chn != nil {
   217| 			changed = append(changed, chn...)
   218| 		}
   219| 	}
   220| 	return changed, nil
   221| }
   222| func isUniquePrefix(tx *gorm.DB, route types.Route) bool {
   223| 	var count int64
   224| 	tx.Model(&types.Route{}).
   225| 		Where("prefix = ? AND node_id != ? AND advertised = ? AND enabled = ?",
   226| 			route.Prefix,
   227| 			route.NodeID,
   228| 			true, true).Count(&count)
   229| 	return count == 0
   230| }
   231| func getPrimaryRoute(tx *gorm.DB, prefix netip.Prefix) (*types.Route, error) {
   232| 	var route types.Route
   233| 	err := tx.
   234| 		Preload("Node").
   235| 		Where("prefix = ? AND advertised = ? AND enabled = ? AND is_primary = ?", types.IPPrefix(prefix), true, true, true).
   236| 		First(&route).Error
   237| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   238| 		return nil, err
   239| 	}
   240| 	if errors.Is(err, gorm.ErrRecordNotFound) {
   241| 		return nil, gorm.ErrRecordNotFound
   242| 	}
   243| 	return &route, nil
   244| }
   245| func (hsdb *HSDatabase) GetNodePrimaryRoutes(node *types.Node) (types.Routes, error) {
   246| 	return Read(hsdb.DB, func(rx *gorm.DB) (types.Routes, error) {
   247| 		return GetNodePrimaryRoutes(rx, node)
   248| 	})
   249| }
   250| func GetNodePrimaryRoutes(tx *gorm.DB, node *types.Node) (types.Routes, error) {
   251| 	var routes types.Routes
   252| 	err := tx.
   253| 		Preload("Node").
   254| 		Where("node_id = ? AND advertised = ? AND enabled = ? AND is_primary = ?", node.ID, true, true, true).
   255| 		Find(&routes).Error
   256| 	if err != nil {
   257| 		return nil, err
   258| 	}
   259| 	return routes, nil
   260| }
   261| func (hsdb *HSDatabase) SaveNodeRoutes(node *types.Node) (bool, error) {
   262| 	return Write(hsdb.DB, func(tx *gorm.DB) (bool, error) {
   263| 		return SaveNodeRoutes(tx, node)
   264| 	})
   265| }
   266| func SaveNodeRoutes(tx *gorm.DB, node *types.Node) (bool, error) {
   267| 	sendUpdate := false
   268| 	currentRoutes := types.Routes{}
   269| 	err := tx.Where("node_id = ?", node.ID).Find(&currentRoutes).Error
   270| 	if err != nil {
   271| 		return sendUpdate, err
   272| 	}
   273| 	advertisedRoutes := map[netip.Prefix]bool{}
   274| 	for _, prefix := range node.Hostinfo.RoutableIPs {
   275| 		advertisedRoutes[prefix] = false
   276| 	}
   277| 	log.Trace().
   278| 		Str("node", node.Hostname).
   279| 		Interface("advertisedRoutes", advertisedRoutes).
   280| 		Interface("currentRoutes", currentRoutes).
   281| 		Msg("updating routes")
   282| 	for pos, route := range currentRoutes {
   283| 		if _, ok := advertisedRoutes[netip.Prefix(route.Prefix)]; ok {
   284| 			if !route.Advertised {
   285| 				currentRoutes[pos].Advertised = true
   286| 				err := tx.Save(&currentRoutes[pos]).Error
   287| 				if err != nil {
   288| 					return sendUpdate, err
   289| 				}
   290| 				if route.Enabled {
   291| 					sendUpdate = true
   292| 				}
   293| 			}
   294| 			advertisedRoutes[netip.Prefix(route.Prefix)] = true
   295| 		} else if route.Advertised {
   296| 			currentRoutes[pos].Advertised = false
   297| 			currentRoutes[pos].Enabled = false
   298| 			err := tx.Save(&currentRoutes[pos]).Error
   299| 			if err != nil {
   300| 				return sendUpdate, err
   301| 			}
   302| 		}
   303| 	}
   304| 	for prefix, exists := range advertisedRoutes {
   305| 		if !exists {
   306| 			route := types.Route{
   307| 				NodeID:     node.ID.Uint64(),
   308| 				Prefix:     types.IPPrefix(prefix),
   309| 				Advertised: true,
   310| 				Enabled:    false,
   311| 			}
   312| 			err := tx.Create(&route).Error
   313| 			if err != nil {
   314| 				return sendUpdate, err
   315| 			}
   316| 		}
   317| 	}
   318| 	return sendUpdate, nil
   319| }
   320| func FailoverNodeRoutesIfNeccessary(
   321| 	tx *gorm.DB,
   322| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   323| 	node *types.Node,
   324| ) (*types.StateUpdate, error) {
   325| 	nodeRoutes, err := GetNodeRoutes(tx, node)
   326| 	if err != nil {
   327| 		return nil, nil
   328| 	}
   329| 	changedNodes := make(set.Set[types.NodeID])
   330| nodeRouteLoop:
   331| 	for _, nodeRoute := range nodeRoutes {
   332| 		routes, err := getRoutesByPrefix(tx, netip.Prefix(nodeRoute.Prefix))
   333| 		if err != nil {
   334| 			return nil, fmt.Errorf("getting routes by prefix: %w", err)
   335| 		}
   336| 		for _, route := range routes {
   337| 			if route.IsPrimary {
   338| 				if val, ok := isLikelyConnected.Load(route.Node.ID); ok && val {
   339| 					continue nodeRouteLoop
   340| 				}
   341| 				failover := failoverRoute(isLikelyConnected, &route, routes)
   342| 				if failover != nil {
   343| 					err := failover.save(tx)
   344| 					if err != nil {
   345| 						return nil, fmt.Errorf("saving failover routes: %w", err)
   346| 					}
   347| 					changedNodes.Add(failover.old.Node.ID)
   348| 					changedNodes.Add(failover.new.Node.ID)
   349| 					continue nodeRouteLoop
   350| 				}
   351| 			}
   352| 		}
   353| 	}
   354| 	chng := changedNodes.Slice()
   355| 	sort.SliceStable(chng, func(i, j int) bool {
   356| 		return chng[i] < chng[j]
   357| 	})
   358| 	if len(changedNodes) != 0 {
   359| 		return &types.StateUpdate{
   360| 			Type:        types.StatePeerChanged,
   361| 			ChangeNodes: chng,
   362| 			Message:     "called from db.FailoverNodeRoutesIfNeccessary",
   363| 		}, nil
   364| 	}
   365| 	return nil, nil
   366| }
   367| func failoverRouteTx(
   368| 	tx *gorm.DB,
   369| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   370| 	r *types.Route,
   371| ) ([]types.NodeID, error) {
   372| 	if r == nil {
   373| 		return nil, nil
   374| 	}
   375| 	if !r.IsPrimary {
   376| 		return nil, nil
   377| 	}
   378| 	if r.IsExitRoute() {
   379| 		return nil, nil
   380| 	}
   381| 	routes, err := getRoutesByPrefix(tx, netip.Prefix(r.Prefix))
   382| 	if err != nil {
   383| 		return nil, fmt.Errorf("getting routes by prefix: %w", err)
   384| 	}
   385| 	fo := failoverRoute(isLikelyConnected, r, routes)
   386| 	if fo == nil {
   387| 		return nil, nil
   388| 	}
   389| 	err = fo.save(tx)
   390| 	if err != nil {
   391| 		return nil, fmt.Errorf("saving failover route: %w", err)
   392| 	}
   393| 	log.Trace().
   394| 		Str("hostname", fo.new.Node.Hostname).
   395| 		Msgf("set primary to new route, was: id(%d), host(%s), now: id(%d), host(%s)", fo.old.ID, fo.old.Node.Hostname, fo.new.ID, fo.new.Node.Hostname)
   396| 	return []types.NodeID{fo.old.Node.ID, fo.new.Node.ID}, nil
   397| }
   398| type failover struct {
   399| 	old *types.Route
   400| 	new *types.Route
   401| }
   402| func (f *failover) save(tx *gorm.DB) error {
   403| 	err := tx.Save(f.old).Error
   404| 	if err != nil {
   405| 		return fmt.Errorf("saving old primary: %w", err)
   406| 	}
   407| 	err = tx.Save(f.new).Error
   408| 	if err != nil {
   409| 		return fmt.Errorf("saving new primary: %w", err)
   410| 	}
   411| 	return nil
   412| }
   413| func failoverRoute(
   414| 	isLikelyConnected *xsync.MapOf[types.NodeID, bool],
   415| 	routeToReplace *types.Route,
   416| 	altRoutes types.Routes,
   417| ) *failover {
   418| 	if routeToReplace == nil {
   419| 		return nil
   420| 	}
   421| 	if !routeToReplace.IsPrimary {
   422| 		return nil
   423| 	}
   424| 	if routeToReplace.IsExitRoute() {
   425| 		return nil
   426| 	}
   427| 	var newPrimary *types.Route
   428| 	for idx, route := range altRoutes {
   429| 		if routeToReplace.ID == route.ID {
   430| 			continue
   431| 		}
   432| 		if !route.Enabled {
   433| 			continue
   434| 		}
   435| 		if isLikelyConnected != nil {
   436| 			if val, ok := isLikelyConnected.Load(route.Node.ID); ok && val {
   437| 				newPrimary = &altRoutes[idx]
   438| 				break
   439| 			}
   440| 		}
   441| 	}
   442| 	if newPrimary == nil {
   443| 		return nil
   444| 	}
   445| 	routeToReplace.IsPrimary = false
   446| 	newPrimary.IsPrimary = true
   447| 	return &failover{
   448| 		old: routeToReplace,
   449| 		new: newPrimary,
   450| 	}
   451| }
   452| func (hsdb *HSDatabase) EnableAutoApprovedRoutes(
   453| 	aclPolicy *policy.ACLPolicy,
   454| 	node *types.Node,
   455| ) error {
   456| 	return hsdb.Write(func(tx *gorm.DB) error {
   457| 		return EnableAutoApprovedRoutes(tx, aclPolicy, node)
   458| 	})
   459| }
   460| func EnableAutoApprovedRoutes(
   461| 	tx *gorm.DB,
   462| 	aclPolicy *policy.ACLPolicy,
   463| 	node *types.Node,
   464| ) error {
   465| 	if node.IPv4 == nil && node.IPv6 == nil {
   466| 		return nil // This node has no IPAddresses, so can't possibly match any autoApprovers ACLs
   467| 	}
   468| 	routes, err := GetNodeAdvertisedRoutes(tx, node)
   469| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   470| 		return fmt.Errorf("getting advertised routes for node(%s %d): %w", node.Hostname, node.ID, err)
   471| 	}
   472| 	log.Trace().Interface("routes", routes).Msg("routes for autoapproving")
   473| 	var approvedRoutes types.Routes
   474| 	for _, advertisedRoute := range routes {
   475| 		if advertisedRoute.Enabled {
   476| 			continue
   477| 		}
   478| 		routeApprovers, err := aclPolicy.AutoApprovers.GetRouteApprovers(
   479| 			netip.Prefix(advertisedRoute.Prefix),
   480| 		)
   481| 		if err != nil {
   482| 			return fmt.Errorf("failed to resolve autoApprovers for route(%d) for node(%s %d): %w", advertisedRoute.ID, node.Hostname, node.ID, err)
   483| 		}
   484| 		log.Trace().
   485| 			Str("node", node.Hostname).
   486| 			Str("user", node.User.Name).
   487| 			Strs("routeApprovers", routeApprovers).
   488| 			Str("prefix", netip.Prefix(advertisedRoute.Prefix).String()).
   489| 			Msg("looking up route for autoapproving")
   490| 		for _, approvedAlias := range routeApprovers {
   491| 			if approvedAlias == node.User.Name {
   492| 				approvedRoutes = append(approvedRoutes, advertisedRoute)
   493| 			} else {
   494| 				approvedIps, err := aclPolicy.ExpandAlias(types.Nodes{node}, approvedAlias)
   495| 				if err != nil {
   496| 					return fmt.Errorf("expanding alias %q for autoApprovers: %w", approvedAlias, err)
   497| 				}
   498| 				if approvedIps.Contains(*node.IPv4) {
   499| 					approvedRoutes = append(approvedRoutes, advertisedRoute)
   500| 				}
   501| 			}
   502| 		}
   503| 	}
   504| 	for _, approvedRoute := range approvedRoutes {
   505| 		_, err := EnableRoute(tx, uint64(approvedRoute.ID))
   506| 		if err != nil {
   507| 			return fmt.Errorf("enabling approved route(%d): %w", approvedRoute.ID, err)
   508| 		}
   509| 	}
   510| 	return nil
   511| }


# ====================================================================
# FILE: hscontrol/db/users.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-155 ---
     1| package db
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"github.com/juanfont/headscale/hscontrol/types"
     6| 	"github.com/juanfont/headscale/hscontrol/util"
     7| 	"gorm.io/gorm"
     8| )
     9| var (
    10| 	ErrUserExists        = errors.New("user already exists")
    11| 	ErrUserNotFound      = errors.New("user not found")
    12| 	ErrUserStillHasNodes = errors.New("user not empty: node(s) found")
    13| )
    14| func (hsdb *HSDatabase) CreateUser(name string) (*types.User, error) {
    15| 	return Write(hsdb.DB, func(tx *gorm.DB) (*types.User, error) {
    16| 		return CreateUser(tx, name)
    17| 	})
    18| }
    19| func CreateUser(tx *gorm.DB, name string) (*types.User, error) {
    20| 	err := util.CheckForFQDNRules(name)
    21| 	if err != nil {
    22| 		return nil, err
    23| 	}
    24| 	user := types.User{}
    25| 	if err := tx.Where("name = ?", name).First(&user).Error; err == nil {
    26| 		return nil, ErrUserExists
    27| 	}
    28| 	user.Name = name
    29| 	if err := tx.Create(&user).Error; err != nil {
    30| 		return nil, fmt.Errorf("creating user: %w", err)
    31| 	}
    32| 	return &user, nil
    33| }
    34| func (hsdb *HSDatabase) DestroyUser(name string) error {
    35| 	return hsdb.Write(func(tx *gorm.DB) error {
    36| 		return DestroyUser(tx, name)
    37| 	})
    38| }
    39| func DestroyUser(tx *gorm.DB, name string) error {
    40| 	user, err := GetUser(tx, name)
    41| 	if err != nil {
    42| 		return ErrUserNotFound
    43| 	}
    44| 	nodes, err := ListNodesByUser(tx, name)
    45| 	if err != nil {
    46| 		return err
    47| 	}
    48| 	if len(nodes) > 0 {
    49| 		return ErrUserStillHasNodes
    50| 	}
    51| 	keys, err := ListPreAuthKeys(tx, name)
    52| 	if err != nil {
    53| 		return err
    54| 	}
    55| 	for _, key := range keys {
    56| 		err = DestroyPreAuthKey(tx, key)
    57| 		if err != nil {
    58| 			return err
    59| 		}
    60| 	}
    61| 	if result := tx.Unscoped().Delete(&user); result.Error != nil {
    62| 		return result.Error
    63| 	}
    64| 	return nil
    65| }
    66| func (hsdb *HSDatabase) RenameUser(oldName, newName string) error {
    67| 	return hsdb.Write(func(tx *gorm.DB) error {
    68| 		return RenameUser(tx, oldName, newName)
    69| 	})
    70| }
    71| func RenameUser(tx *gorm.DB, oldName, newName string) error {
    72| 	var err error
    73| 	oldUser, err := GetUser(tx, oldName)
    74| 	if err != nil {
    75| 		return err
    76| 	}
    77| 	err = util.CheckForFQDNRules(newName)
    78| 	if err != nil {
    79| 		return err
    80| 	}
    81| 	_, err = GetUser(tx, newName)
    82| 	if err == nil {
    83| 		return ErrUserExists
    84| 	}
    85| 	if !errors.Is(err, ErrUserNotFound) {
    86| 		return err
    87| 	}
    88| 	oldUser.Name = newName
    89| 	if result := tx.Save(&oldUser); result.Error != nil {
    90| 		return result.Error
    91| 	}
    92| 	return nil
    93| }
    94| func (hsdb *HSDatabase) GetUser(name string) (*types.User, error) {
    95| 	return Read(hsdb.DB, func(rx *gorm.DB) (*types.User, error) {
    96| 		return GetUser(rx, name)
    97| 	})
    98| }
    99| func GetUser(tx *gorm.DB, name string) (*types.User, error) {
   100| 	user := types.User{}
   101| 	if result := tx.First(&user, "name = ?", name); errors.Is(
   102| 		result.Error,
   103| 		gorm.ErrRecordNotFound,
   104| 	) {
   105| 		return nil, ErrUserNotFound
   106| 	}
   107| 	return &user, nil
   108| }
   109| func (hsdb *HSDatabase) ListUsers() ([]types.User, error) {
   110| 	return Read(hsdb.DB, func(rx *gorm.DB) ([]types.User, error) {
   111| 		return ListUsers(rx)
   112| 	})
   113| }
   114| func ListUsers(tx *gorm.DB) ([]types.User, error) {
   115| 	users := []types.User{}
   116| 	if err := tx.Find(&users).Error; err != nil {
   117| 		return nil, err
   118| 	}
   119| 	return users, nil
   120| }
   121| func ListNodesByUser(tx *gorm.DB, name string) (types.Nodes, error) {
   122| 	err := util.CheckForFQDNRules(name)
   123| 	if err != nil {
   124| 		return nil, err
   125| 	}
   126| 	user, err := GetUser(tx, name)
   127| 	if err != nil {
   128| 		return nil, err
   129| 	}
   130| 	nodes := types.Nodes{}
   131| 	if err := tx.Preload("AuthKey").Preload("AuthKey.User").Preload("User").Where(&types.Node{UserID: user.ID}).Find(&nodes).Error; err != nil {
   132| 		return nil, err
   133| 	}
   134| 	return nodes, nil
   135| }
   136| func (hsdb *HSDatabase) AssignNodeToUser(node *types.Node, username string) error {
   137| 	return hsdb.Write(func(tx *gorm.DB) error {
   138| 		return AssignNodeToUser(tx, node, username)
   139| 	})
   140| }
   141| func AssignNodeToUser(tx *gorm.DB, node *types.Node, username string) error {
   142| 	err := util.CheckForFQDNRules(username)
   143| 	if err != nil {
   144| 		return err
   145| 	}
   146| 	user, err := GetUser(tx, username)
   147| 	if err != nil {
   148| 		return err
   149| 	}
   150| 	node.User = *user
   151| 	if result := tx.Save(&node); result.Error != nil {
   152| 		return result.Error
   153| 	}
   154| 	return nil
   155| }


# ====================================================================
# FILE: hscontrol/derp/derp.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-100 ---
     1| package derp
     2| import (
     3| 	"context"
     4| 	"encoding/json"
     5| 	"io"
     6| 	"net/http"
     7| 	"net/url"
     8| 	"os"
     9| 	"github.com/juanfont/headscale/hscontrol/types"
    10| 	"github.com/rs/zerolog/log"
    11| 	"gopkg.in/yaml.v3"
    12| 	"tailscale.com/tailcfg"
    13| )
    14| func loadDERPMapFromPath(path string) (*tailcfg.DERPMap, error) {
    15| 	derpFile, err := os.Open(path)
    16| 	if err != nil {
    17| 		return nil, err
    18| 	}
    19| 	defer derpFile.Close()
    20| 	var derpMap tailcfg.DERPMap
    21| 	b, err := io.ReadAll(derpFile)
    22| 	if err != nil {
    23| 		return nil, err
    24| 	}
    25| 	err = yaml.Unmarshal(b, &derpMap)
    26| 	return &derpMap, err
    27| }
    28| func loadDERPMapFromURL(addr url.URL) (*tailcfg.DERPMap, error) {
    29| 	ctx, cancel := context.WithTimeout(context.Background(), types.HTTPTimeout)
    30| 	defer cancel()
    31| 	req, err := http.NewRequestWithContext(ctx, http.MethodGet, addr.String(), nil)
    32| 	if err != nil {
    33| 		return nil, err
    34| 	}
    35| 	client := http.Client{
    36| 		Timeout: types.HTTPTimeout,
    37| 	}
    38| 	resp, err := client.Do(req)
    39| 	if err != nil {
    40| 		return nil, err
    41| 	}
    42| 	defer resp.Body.Close()
    43| 	body, err := io.ReadAll(resp.Body)
    44| 	if err != nil {
    45| 		return nil, err
    46| 	}
    47| 	var derpMap tailcfg.DERPMap
    48| 	err = json.Unmarshal(body, &derpMap)
    49| 	return &derpMap, err
    50| }
    51| func mergeDERPMaps(derpMaps []*tailcfg.DERPMap) *tailcfg.DERPMap {
    52| 	result := tailcfg.DERPMap{
    53| 		OmitDefaultRegions: false,
    54| 		Regions:            map[int]*tailcfg.DERPRegion{},
    55| 	}
    56| 	for _, derpMap := range derpMaps {
    57| 		for id, region := range derpMap.Regions {
    58| 			result.Regions[id] = region
    59| 		}
    60| 	}
    61| 	return &result
    62| }
    63| func GetDERPMap(cfg types.DERPConfig) *tailcfg.DERPMap {
    64| 	var derpMaps []*tailcfg.DERPMap
    65| 	for _, path := range cfg.Paths {
    66| 		log.Debug().
    67| 			Str("func", "GetDERPMap").
    68| 			Str("path", path).
    69| 			Msg("Loading DERPMap from path")
    70| 		derpMap, err := loadDERPMapFromPath(path)
    71| 		if err != nil {
    72| 			log.Error().
    73| 				Str("func", "GetDERPMap").
    74| 				Str("path", path).
    75| 				Err(err).
    76| 				Msg("Could not load DERP map from path")
    77| 			break
    78| 		}
    79| 		derpMaps = append(derpMaps, derpMap)
    80| 	}
    81| 	for _, addr := range cfg.URLs {
    82| 		derpMap, err := loadDERPMapFromURL(addr)
    83| 		log.Debug().
    84| 			Str("func", "GetDERPMap").
    85| 			Str("url", addr.String()).
    86| 			Msg("Loading DERPMap from path")
    87| 		if err != nil {
    88| 			log.Error().
    89| 				Str("func", "GetDERPMap").
    90| 				Str("url", addr.String()).
    91| 				Err(err).
    92| 				Msg("Could not load DERP map from path")
    93| 			break
    94| 		}
    95| 		derpMaps = append(derpMaps, derpMap)
    96| 	}
    97| 	derpMap := mergeDERPMaps(derpMaps)
    98| 	log.Trace().Interface("derpMap", derpMap).Msg("DERPMap loaded")
    99| 	return derpMap
   100| }


# ====================================================================
# FILE: hscontrol/derp/server/derp_server.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-261 ---
     1| package server
     2| import (
     3| 	"context"
     4| 	"encoding/json"
     5| 	"fmt"
     6| 	"net"
     7| 	"net/http"
     8| 	"net/netip"
     9| 	"net/url"
    10| 	"strconv"
    11| 	"strings"
    12| 	"time"
    13| 	"github.com/juanfont/headscale/hscontrol/types"
    14| 	"github.com/juanfont/headscale/hscontrol/util"
    15| 	"github.com/rs/zerolog/log"
    16| 	"tailscale.com/derp"
    17| 	"tailscale.com/net/stun"
    18| 	"tailscale.com/tailcfg"
    19| 	"tailscale.com/types/key"
    20| )
    21| const fastStartHeader = "Derp-Fast-Start"
    22| type DERPServer struct {
    23| 	serverURL     string
    24| 	key           key.NodePrivate
    25| 	cfg           *types.DERPConfig
    26| 	tailscaleDERP *derp.Server
    27| }
    28| func NewDERPServer(
    29| 	serverURL string,
    30| 	derpKey key.NodePrivate,
    31| 	cfg *types.DERPConfig,
    32| ) (*DERPServer, error) {
    33| 	log.Trace().Caller().Msg("Creating new embedded DERP server")
    34| 	server := derp.NewServer(derpKey, util.TSLogfWrapper()) // nolint // zerolinter complains
    35| 	return &DERPServer{
    36| 		serverURL:     serverURL,
    37| 		key:           derpKey,
    38| 		cfg:           cfg,
    39| 		tailscaleDERP: server,
    40| 	}, nil
    41| }
    42| func (d *DERPServer) GenerateRegion() (tailcfg.DERPRegion, error) {
    43| 	serverURL, err := url.Parse(d.serverURL)
    44| 	if err != nil {
    45| 		return tailcfg.DERPRegion{}, err
    46| 	}
    47| 	var host string
    48| 	var port int
    49| 	host, portStr, err := net.SplitHostPort(serverURL.Host)
    50| 	if err != nil {
    51| 		if serverURL.Scheme == "https" {
    52| 			host = serverURL.Host
    53| 			port = 443
    54| 		} else {
    55| 			host = serverURL.Host
    56| 			port = 80
    57| 		}
    58| 	} else {
    59| 		port, err = strconv.Atoi(portStr)
    60| 		if err != nil {
    61| 			return tailcfg.DERPRegion{}, err
    62| 		}
    63| 	}
    64| 	localDERPregion := tailcfg.DERPRegion{
    65| 		RegionID:   d.cfg.ServerRegionID,
    66| 		RegionCode: d.cfg.ServerRegionCode,
    67| 		RegionName: d.cfg.ServerRegionName,
    68| 		Avoid:      false,
    69| 		Nodes: []*tailcfg.DERPNode{
    70| 			{
    71| 				Name:     fmt.Sprintf("%d", d.cfg.ServerRegionID),
    72| 				RegionID: d.cfg.ServerRegionID,
    73| 				HostName: host,
    74| 				DERPPort: port,
    75| 				IPv4:     d.cfg.IPv4,
    76| 				IPv6:     d.cfg.IPv6,
    77| 			},
    78| 		},
    79| 	}
    80| 	_, portSTUNStr, err := net.SplitHostPort(d.cfg.STUNAddr)
    81| 	if err != nil {
    82| 		return tailcfg.DERPRegion{}, err
    83| 	}
    84| 	portSTUN, err := strconv.Atoi(portSTUNStr)
    85| 	if err != nil {
    86| 		return tailcfg.DERPRegion{}, err
    87| 	}
    88| 	localDERPregion.Nodes[0].STUNPort = portSTUN
    89| 	log.Info().Caller().Msgf("DERP region: %+v", localDERPregion)
    90| 	log.Info().Caller().Msgf("DERP Nodes[0]: %+v", localDERPregion.Nodes[0])
    91| 	return localDERPregion, nil
    92| }
    93| func (d *DERPServer) DERPHandler(
    94| 	writer http.ResponseWriter,
    95| 	req *http.Request,
    96| ) {
    97| 	log.Trace().Caller().Msgf("/derp request from %v", req.RemoteAddr)
    98| 	upgrade := strings.ToLower(req.Header.Get("Upgrade"))
    99| 	if upgrade != "websocket" && upgrade != "derp" {
   100| 		if upgrade != "" {
   101| 			log.Warn().
   102| 				Caller().
   103| 				Msg("No Upgrade header in DERP server request. If headscale is behind a reverse proxy, make sure it is configured to pass WebSockets through.")
   104| 		}
   105| 		writer.Header().Set("Content-Type", "text/plain")
   106| 		writer.WriteHeader(http.StatusUpgradeRequired)
   107| 		_, err := writer.Write([]byte("DERP requires connection upgrade"))
   108| 		if err != nil {
   109| 			log.Error().
   110| 				Caller().
   111| 				Err(err).
   112| 				Msg("Failed to write response")
   113| 		}
   114| 		return
   115| 	}
   116| 	fastStart := req.Header.Get(fastStartHeader) == "1"
   117| 	hijacker, ok := writer.(http.Hijacker)
   118| 	if !ok {
   119| 		log.Error().Caller().Msg("DERP requires Hijacker interface from Gin")
   120| 		writer.Header().Set("Content-Type", "text/plain")
   121| 		writer.WriteHeader(http.StatusInternalServerError)
   122| 		_, err := writer.Write([]byte("HTTP does not support general TCP support"))
   123| 		if err != nil {
   124| 			log.Error().
   125| 				Caller().
   126| 				Err(err).
   127| 				Msg("Failed to write response")
   128| 		}
   129| 		return
   130| 	}
   131| 	netConn, conn, err := hijacker.Hijack()
   132| 	if err != nil {
   133| 		log.Error().Caller().Err(err).Msgf("Hijack failed")
   134| 		writer.Header().Set("Content-Type", "text/plain")
   135| 		writer.WriteHeader(http.StatusInternalServerError)
   136| 		_, err = writer.Write([]byte("HTTP does not support general TCP support"))
   137| 		if err != nil {
   138| 			log.Error().
   139| 				Caller().
   140| 				Err(err).
   141| 				Msg("Failed to write response")
   142| 		}
   143| 		return
   144| 	}
   145| 	log.Trace().Caller().Msgf("Hijacked connection from %v", req.RemoteAddr)
   146| 	if !fastStart {
   147| 		pubKey := d.key.Public()
   148| 		pubKeyStr, _ := pubKey.MarshalText() //nolint
   149| 		fmt.Fprintf(conn, "HTTP/1.1 101 Switching Protocols\r\n"+
   150| 			"Upgrade: DERP\r\n"+
   151| 			"Connection: Upgrade\r\n"+
   152| 			"Derp-Version: %v\r\n"+
   153| 			"Derp-Public-Key: %s\r\n\r\n",
   154| 			derp.ProtocolVersion,
   155| 			string(pubKeyStr))
   156| 	}
   157| 	d.tailscaleDERP.Accept(req.Context(), netConn, conn, netConn.RemoteAddr().String())
   158| }
   159| func DERPProbeHandler(
   160| 	writer http.ResponseWriter,
   161| 	req *http.Request,
   162| ) {
   163| 	switch req.Method {
   164| 	case http.MethodHead, http.MethodGet:
   165| 		writer.Header().Set("Access-Control-Allow-Origin", "*")
   166| 		writer.WriteHeader(http.StatusOK)
   167| 	default:
   168| 		writer.WriteHeader(http.StatusMethodNotAllowed)
   169| 		_, err := writer.Write([]byte("bogus probe method"))
   170| 		if err != nil {
   171| 			log.Error().
   172| 				Caller().
   173| 				Err(err).
   174| 				Msg("Failed to write response")
   175| 		}
   176| 	}
   177| }
   178| func DERPBootstrapDNSHandler(
   179| 	derpMap *tailcfg.DERPMap,
   180| ) func(http.ResponseWriter, *http.Request) {
   181| 	return func(
   182| 		writer http.ResponseWriter,
   183| 		req *http.Request,
   184| 	) {
   185| 		dnsEntries := make(map[string][]net.IP)
   186| 		resolvCtx, cancel := context.WithTimeout(req.Context(), time.Minute)
   187| 		defer cancel()
   188| 		var resolver net.Resolver
   189| 		for _, region := range derpMap.Regions {
   190| 			for _, node := range region.Nodes { // we don't care if we override some nodes
   191| 				addrs, err := resolver.LookupIP(resolvCtx, "ip", node.HostName)
   192| 				if err != nil {
   193| 					log.Trace().
   194| 						Caller().
   195| 						Err(err).
   196| 						Msgf("bootstrap DNS lookup failed %q", node.HostName)
   197| 					continue
   198| 				}
   199| 				dnsEntries[node.HostName] = addrs
   200| 			}
   201| 		}
   202| 		writer.Header().Set("Content-Type", "application/json")
   203| 		writer.WriteHeader(http.StatusOK)
   204| 		err := json.NewEncoder(writer).Encode(dnsEntries)
   205| 		if err != nil {
   206| 			log.Error().
   207| 				Caller().
   208| 				Err(err).
   209| 				Msg("Failed to write response")
   210| 		}
   211| 	}
   212| }
   213| func (d *DERPServer) ServeSTUN() {
   214| 	packetConn, err := net.ListenPacket("udp", d.cfg.STUNAddr)
   215| 	if err != nil {
   216| 		log.Fatal().Msgf("failed to open STUN listener: %v", err)
   217| 	}
   218| 	log.Info().Msgf("STUN server started at %s", packetConn.LocalAddr())
   219| 	udpConn, ok := packetConn.(*net.UDPConn)
   220| 	if !ok {
   221| 		log.Fatal().Msg("STUN listener is not a UDP listener")
   222| 	}
   223| 	serverSTUNListener(context.Background(), udpConn)
   224| }
   225| func serverSTUNListener(ctx context.Context, packetConn *net.UDPConn) {
   226| 	var buf [64 << 10]byte
   227| 	var (
   228| 		bytesRead int
   229| 		udpAddr   *net.UDPAddr
   230| 		err       error
   231| 	)
   232| 	for {
   233| 		bytesRead, udpAddr, err = packetConn.ReadFromUDP(buf[:])
   234| 		if err != nil {
   235| 			if ctx.Err() != nil {
   236| 				return
   237| 			}
   238| 			log.Error().Caller().Err(err).Msgf("STUN ReadFrom")
   239| 			time.Sleep(time.Second)
   240| 			continue
   241| 		}
   242| 		log.Trace().Caller().Msgf("STUN request from %v", udpAddr)
   243| 		pkt := buf[:bytesRead]
   244| 		if !stun.Is(pkt) {
   245| 			log.Trace().Caller().Msgf("UDP packet is not STUN")
   246| 			continue
   247| 		}
   248| 		txid, err := stun.ParseBindingRequest(pkt)
   249| 		if err != nil {
   250| 			log.Trace().Caller().Err(err).Msgf("STUN parse error")
   251| 			continue
   252| 		}
   253| 		addr, _ := netip.AddrFromSlice(udpAddr.IP)
   254| 		res := stun.Response(txid, netip.AddrPortFrom(addr, uint16(udpAddr.Port)))
   255| 		_, err = packetConn.WriteTo(res, udpAddr)
   256| 		if err != nil {
   257| 			log.Trace().Caller().Err(err).Msgf("Issue writing to UDP")
   258| 			continue
   259| 		}
   260| 	}
   261| }


# ====================================================================
# FILE: hscontrol/grpcv1.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-678 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"errors"
     5| 	"fmt"
     6| 	"io"
     7| 	"os"
     8| 	"sort"
     9| 	"strings"
    10| 	"time"
    11| 	"github.com/rs/zerolog/log"
    12| 	"google.golang.org/grpc/codes"
    13| 	"google.golang.org/grpc/status"
    14| 	"google.golang.org/protobuf/types/known/timestamppb"
    15| 	"gorm.io/gorm"
    16| 	"tailscale.com/tailcfg"
    17| 	"tailscale.com/types/key"
    18| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    19| 	"github.com/juanfont/headscale/hscontrol/db"
    20| 	"github.com/juanfont/headscale/hscontrol/policy"
    21| 	"github.com/juanfont/headscale/hscontrol/types"
    22| 	"github.com/juanfont/headscale/hscontrol/util"
    23| )
    24| type headscaleV1APIServer struct { // v1.HeadscaleServiceServer
    25| 	v1.UnimplementedHeadscaleServiceServer
    26| 	h *Headscale
    27| }
    28| func newHeadscaleV1APIServer(h *Headscale) v1.HeadscaleServiceServer {
    29| 	return headscaleV1APIServer{
    30| 		h: h,
    31| 	}
    32| }
    33| func (api headscaleV1APIServer) GetUser(
    34| 	ctx context.Context,
    35| 	request *v1.GetUserRequest,
    36| ) (*v1.GetUserResponse, error) {
    37| 	user, err := api.h.db.GetUser(request.GetName())
    38| 	if err != nil {
    39| 		return nil, err
    40| 	}
    41| 	return &v1.GetUserResponse{User: user.Proto()}, nil
    42| }
    43| func (api headscaleV1APIServer) CreateUser(
    44| 	ctx context.Context,
    45| 	request *v1.CreateUserRequest,
    46| ) (*v1.CreateUserResponse, error) {
    47| 	user, err := api.h.db.CreateUser(request.GetName())
    48| 	if err != nil {
    49| 		return nil, err
    50| 	}
    51| 	return &v1.CreateUserResponse{User: user.Proto()}, nil
    52| }
    53| func (api headscaleV1APIServer) RenameUser(
    54| 	ctx context.Context,
    55| 	request *v1.RenameUserRequest,
    56| ) (*v1.RenameUserResponse, error) {
    57| 	err := api.h.db.RenameUser(request.GetOldName(), request.GetNewName())
    58| 	if err != nil {
    59| 		return nil, err
    60| 	}
    61| 	user, err := api.h.db.GetUser(request.GetNewName())
    62| 	if err != nil {
    63| 		return nil, err
    64| 	}
    65| 	return &v1.RenameUserResponse{User: user.Proto()}, nil
    66| }
    67| func (api headscaleV1APIServer) DeleteUser(
    68| 	ctx context.Context,
    69| 	request *v1.DeleteUserRequest,
    70| ) (*v1.DeleteUserResponse, error) {
    71| 	err := api.h.db.DestroyUser(request.GetName())
    72| 	if err != nil {
    73| 		return nil, err
    74| 	}
    75| 	return &v1.DeleteUserResponse{}, nil
    76| }
    77| func (api headscaleV1APIServer) ListUsers(
    78| 	ctx context.Context,
    79| 	request *v1.ListUsersRequest,
    80| ) (*v1.ListUsersResponse, error) {
    81| 	users, err := api.h.db.ListUsers()
    82| 	if err != nil {
    83| 		return nil, err
    84| 	}
    85| 	response := make([]*v1.User, len(users))
    86| 	for index, user := range users {
    87| 		response[index] = user.Proto()
    88| 	}
    89| 	sort.Slice(response, func(i, j int) bool {
    90| 		return response[i].Id < response[j].Id
    91| 	})
    92| 	log.Trace().Caller().Interface("users", response).Msg("")
    93| 	return &v1.ListUsersResponse{Users: response}, nil
    94| }
    95| func (api headscaleV1APIServer) CreatePreAuthKey(
    96| 	ctx context.Context,
    97| 	request *v1.CreatePreAuthKeyRequest,
    98| ) (*v1.CreatePreAuthKeyResponse, error) {
    99| 	var expiration time.Time
   100| 	if request.GetExpiration() != nil {
   101| 		expiration = request.GetExpiration().AsTime()
   102| 	}
   103| 	for _, tag := range request.AclTags {
   104| 		err := validateTag(tag)
   105| 		if err != nil {
   106| 			return &v1.CreatePreAuthKeyResponse{
   107| 				PreAuthKey: nil,
   108| 			}, status.Error(codes.InvalidArgument, err.Error())
   109| 		}
   110| 	}
   111| 	preAuthKey, err := api.h.db.CreatePreAuthKey(
   112| 		request.GetUser(),
   113| 		request.GetReusable(),
   114| 		request.GetEphemeral(),
   115| 		&expiration,
   116| 		request.AclTags,
   117| 	)
   118| 	if err != nil {
   119| 		return nil, err
   120| 	}
   121| 	return &v1.CreatePreAuthKeyResponse{PreAuthKey: preAuthKey.Proto()}, nil
   122| }
   123| func (api headscaleV1APIServer) ExpirePreAuthKey(
   124| 	ctx context.Context,
   125| 	request *v1.ExpirePreAuthKeyRequest,
   126| ) (*v1.ExpirePreAuthKeyResponse, error) {
   127| 	err := api.h.db.Write(func(tx *gorm.DB) error {
   128| 		preAuthKey, err := db.GetPreAuthKey(tx, request.GetUser(), request.Key)
   129| 		if err != nil {
   130| 			return err
   131| 		}
   132| 		return db.ExpirePreAuthKey(tx, preAuthKey)
   133| 	})
   134| 	if err != nil {
   135| 		return nil, err
   136| 	}
   137| 	return &v1.ExpirePreAuthKeyResponse{}, nil
   138| }
   139| func (api headscaleV1APIServer) ListPreAuthKeys(
   140| 	ctx context.Context,
   141| 	request *v1.ListPreAuthKeysRequest,
   142| ) (*v1.ListPreAuthKeysResponse, error) {
   143| 	preAuthKeys, err := api.h.db.ListPreAuthKeys(request.GetUser())
   144| 	if err != nil {
   145| 		return nil, err
   146| 	}
   147| 	response := make([]*v1.PreAuthKey, len(preAuthKeys))
   148| 	for index, key := range preAuthKeys {
   149| 		response[index] = key.Proto()
   150| 	}
   151| 	sort.Slice(response, func(i, j int) bool {
   152| 		return response[i].Id < response[j].Id
   153| 	})
   154| 	return &v1.ListPreAuthKeysResponse{PreAuthKeys: response}, nil
   155| }
   156| func (api headscaleV1APIServer) RegisterNode(
   157| 	ctx context.Context,
   158| 	request *v1.RegisterNodeRequest,
   159| ) (*v1.RegisterNodeResponse, error) {
   160| 	log.Trace().
   161| 		Str("user", request.GetUser()).
   162| 		Str("machine_key", request.GetKey()).
   163| 		Msg("Registering node")
   164| 	var mkey key.MachinePublic
   165| 	err := mkey.UnmarshalText([]byte(request.GetKey()))
   166| 	if err != nil {
   167| 		return nil, err
   168| 	}
   169| 	ipv4, ipv6, err := api.h.ipAlloc.Next()
   170| 	if err != nil {
   171| 		return nil, err
   172| 	}
   173| 	node, err := db.Write(api.h.db.DB, func(tx *gorm.DB) (*types.Node, error) {
   174| 		return db.RegisterNodeFromAuthCallback(
   175| 			tx,
   176| 			api.h.registrationCache,
   177| 			mkey,
   178| 			request.GetUser(),
   179| 			nil,
   180| 			util.RegisterMethodCLI,
   181| 			ipv4, ipv6,
   182| 		)
   183| 	})
   184| 	if err != nil {
   185| 		return nil, err
   186| 	}
   187| 	return &v1.RegisterNodeResponse{Node: node.Proto()}, nil
   188| }
   189| func (api headscaleV1APIServer) GetNode(
   190| 	ctx context.Context,
   191| 	request *v1.GetNodeRequest,
   192| ) (*v1.GetNodeResponse, error) {
   193| 	node, err := api.h.db.GetNodeByID(types.NodeID(request.GetNodeId()))
   194| 	if err != nil {
   195| 		return nil, err
   196| 	}
   197| 	resp := node.Proto()
   198| 	resp.Online = api.h.nodeNotifier.IsConnected(node.ID)
   199| 	return &v1.GetNodeResponse{Node: resp}, nil
   200| }
   201| func (api headscaleV1APIServer) SetTags(
   202| 	ctx context.Context,
   203| 	request *v1.SetTagsRequest,
   204| ) (*v1.SetTagsResponse, error) {
   205| 	for _, tag := range request.GetTags() {
   206| 		err := validateTag(tag)
   207| 		if err != nil {
   208| 			return nil, err
   209| 		}
   210| 	}
   211| 	node, err := db.Write(api.h.db.DB, func(tx *gorm.DB) (*types.Node, error) {
   212| 		err := db.SetTags(tx, types.NodeID(request.GetNodeId()), request.GetTags())
   213| 		if err != nil {
   214| 			return nil, err
   215| 		}
   216| 		return db.GetNodeByID(tx, types.NodeID(request.GetNodeId()))
   217| 	})
   218| 	if err != nil {
   219| 		return &v1.SetTagsResponse{
   220| 			Node: nil,
   221| 		}, status.Error(codes.InvalidArgument, err.Error())
   222| 	}
   223| 	ctx = types.NotifyCtx(ctx, "cli-settags", node.Hostname)
   224| 	api.h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdate{
   225| 		Type:        types.StatePeerChanged,
   226| 		ChangeNodes: []types.NodeID{node.ID},
   227| 		Message:     "called from api.SetTags",
   228| 	}, node.ID)
   229| 	log.Trace().
   230| 		Str("node", node.Hostname).
   231| 		Strs("tags", request.GetTags()).
   232| 		Msg("Changing tags of node")
   233| 	return &v1.SetTagsResponse{Node: node.Proto()}, nil
   234| }
   235| func validateTag(tag string) error {
   236| 	if strings.Index(tag, "tag:") != 0 {
   237| 		return errors.New("tag must start with the string 'tag:'")
   238| 	}
   239| 	if strings.ToLower(tag) != tag {
   240| 		return errors.New("tag should be lowercase")
   241| 	}
   242| 	if len(strings.Fields(tag)) > 1 {
   243| 		return errors.New("tag should not contains space")
   244| 	}
   245| 	return nil
   246| }
   247| func (api headscaleV1APIServer) DeleteNode(
   248| 	ctx context.Context,
   249| 	request *v1.DeleteNodeRequest,
   250| ) (*v1.DeleteNodeResponse, error) {
   251| 	node, err := api.h.db.GetNodeByID(types.NodeID(request.GetNodeId()))
   252| 	if err != nil {
   253| 		return nil, err
   254| 	}
   255| 	changedNodes, err := api.h.db.DeleteNode(
   256| 		node,
   257| 		api.h.nodeNotifier.LikelyConnectedMap(),
   258| 	)
   259| 	if err != nil {
   260| 		return nil, err
   261| 	}
   262| 	ctx = types.NotifyCtx(ctx, "cli-deletenode", node.Hostname)
   263| 	api.h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   264| 		Type:    types.StatePeerRemoved,
   265| 		Removed: []types.NodeID{node.ID},
   266| 	})
   267| 	if changedNodes != nil {
   268| 		api.h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   269| 			Type:        types.StatePeerChanged,
   270| 			ChangeNodes: changedNodes,
   271| 		})
   272| 	}
   273| 	return &v1.DeleteNodeResponse{}, nil
   274| }
   275| func (api headscaleV1APIServer) ExpireNode(
   276| 	ctx context.Context,
   277| 	request *v1.ExpireNodeRequest,
   278| ) (*v1.ExpireNodeResponse, error) {
   279| 	now := time.Now()
   280| 	node, err := db.Write(api.h.db.DB, func(tx *gorm.DB) (*types.Node, error) {
   281| 		db.NodeSetExpiry(
   282| 			tx,
   283| 			types.NodeID(request.GetNodeId()),
   284| 			now,
   285| 		)
   286| 		return db.GetNodeByID(tx, types.NodeID(request.GetNodeId()))
   287| 	})
   288| 	if err != nil {
   289| 		return nil, err
   290| 	}
   291| 	ctx = types.NotifyCtx(ctx, "cli-expirenode-self", node.Hostname)
   292| 	api.h.nodeNotifier.NotifyByNodeID(
   293| 		ctx,
   294| 		types.StateUpdate{
   295| 			Type:        types.StateSelfUpdate,
   296| 			ChangeNodes: []types.NodeID{node.ID},
   297| 		},
   298| 		node.ID)
   299| 	ctx = types.NotifyCtx(ctx, "cli-expirenode-peers", node.Hostname)
   300| 	api.h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdateExpire(node.ID, now), node.ID)
   301| 	log.Trace().
   302| 		Str("node", node.Hostname).
   303| 		Time("expiry", *node.Expiry).
   304| 		Msg("node expired")
   305| 	return &v1.ExpireNodeResponse{Node: node.Proto()}, nil
   306| }
   307| func (api headscaleV1APIServer) RenameNode(
   308| 	ctx context.Context,
   309| 	request *v1.RenameNodeRequest,
   310| ) (*v1.RenameNodeResponse, error) {
   311| 	node, err := db.Write(api.h.db.DB, func(tx *gorm.DB) (*types.Node, error) {
   312| 		err := db.RenameNode(
   313| 			tx,
   314| 			types.NodeID(request.GetNodeId()),
   315| 			request.GetNewName(),
   316| 		)
   317| 		if err != nil {
   318| 			return nil, err
   319| 		}
   320| 		return db.GetNodeByID(tx, types.NodeID(request.GetNodeId()))
   321| 	})
   322| 	if err != nil {
   323| 		return nil, err
   324| 	}
   325| 	ctx = types.NotifyCtx(ctx, "cli-renamenode", node.Hostname)
   326| 	api.h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdate{
   327| 		Type:        types.StatePeerChanged,
   328| 		ChangeNodes: []types.NodeID{node.ID},
   329| 		Message:     "called from api.RenameNode",
   330| 	}, node.ID)
   331| 	log.Trace().
   332| 		Str("node", node.Hostname).
   333| 		Str("new_name", request.GetNewName()).
   334| 		Msg("node renamed")
   335| 	return &v1.RenameNodeResponse{Node: node.Proto()}, nil
   336| }
   337| func (api headscaleV1APIServer) ListNodes(
   338| 	ctx context.Context,
   339| 	request *v1.ListNodesRequest,
   340| ) (*v1.ListNodesResponse, error) {
   341| 	isLikelyConnected := api.h.nodeNotifier.LikelyConnectedMap()
   342| 	if request.GetUser() != "" {
   343| 		nodes, err := db.Read(api.h.db.DB, func(rx *gorm.DB) (types.Nodes, error) {
   344| 			return db.ListNodesByUser(rx, request.GetUser())
   345| 		})
   346| 		if err != nil {
   347| 			return nil, err
   348| 		}
   349| 		response := make([]*v1.Node, len(nodes))
   350| 		for index, node := range nodes {
   351| 			resp := node.Proto()
   352| 			if val, ok := isLikelyConnected.Load(node.ID); ok && val {
   353| 				resp.Online = true
   354| 			}
   355| 			response[index] = resp
   356| 		}
   357| 		return &v1.ListNodesResponse{Nodes: response}, nil
   358| 	}
   359| 	nodes, err := api.h.db.ListNodes()
   360| 	if err != nil {
   361| 		return nil, err
   362| 	}
   363| 	sort.Slice(nodes, func(i, j int) bool {
   364| 		return nodes[i].ID < nodes[j].ID
   365| 	})
   366| 	response := make([]*v1.Node, len(nodes))
   367| 	for index, node := range nodes {
   368| 		resp := node.Proto()
   369| 		if val, ok := isLikelyConnected.Load(node.ID); ok && val {
   370| 			resp.Online = true
   371| 		}
   372| 		validTags, invalidTags := api.h.ACLPolicy.TagsOfNode(
   373| 			node,
   374| 		)
   375| 		resp.InvalidTags = invalidTags
   376| 		resp.ValidTags = validTags
   377| 		response[index] = resp
   378| 	}
   379| 	return &v1.ListNodesResponse{Nodes: response}, nil
   380| }
   381| func (api headscaleV1APIServer) MoveNode(
   382| 	ctx context.Context,
   383| 	request *v1.MoveNodeRequest,
   384| ) (*v1.MoveNodeResponse, error) {
   385| 	node, err := api.h.db.GetNodeByID(types.NodeID(request.GetNodeId()))
   386| 	if err != nil {
   387| 		return nil, err
   388| 	}
   389| 	err = api.h.db.AssignNodeToUser(node, request.GetUser())
   390| 	if err != nil {
   391| 		return nil, err
   392| 	}
   393| 	return &v1.MoveNodeResponse{Node: node.Proto()}, nil
   394| }
   395| func (api headscaleV1APIServer) BackfillNodeIPs(
   396| 	ctx context.Context,
   397| 	request *v1.BackfillNodeIPsRequest,
   398| ) (*v1.BackfillNodeIPsResponse, error) {
   399| 	log.Trace().Msg("Backfill called")
   400| 	if !request.Confirmed {
   401| 		return nil, errors.New("not confirmed, aborting")
   402| 	}
   403| 	changes, err := api.h.db.BackfillNodeIPs(api.h.ipAlloc)
   404| 	if err != nil {
   405| 		return nil, err
   406| 	}
   407| 	return &v1.BackfillNodeIPsResponse{Changes: changes}, nil
   408| }
   409| func (api headscaleV1APIServer) GetRoutes(
   410| 	ctx context.Context,
   411| 	request *v1.GetRoutesRequest,
   412| ) (*v1.GetRoutesResponse, error) {
   413| 	routes, err := db.Read(api.h.db.DB, func(rx *gorm.DB) (types.Routes, error) {
   414| 		return db.GetRoutes(rx)
   415| 	})
   416| 	if err != nil {
   417| 		return nil, err
   418| 	}
   419| 	return &v1.GetRoutesResponse{
   420| 		Routes: types.Routes(routes).Proto(),
   421| 	}, nil
   422| }
   423| func (api headscaleV1APIServer) EnableRoute(
   424| 	ctx context.Context,
   425| 	request *v1.EnableRouteRequest,
   426| ) (*v1.EnableRouteResponse, error) {
   427| 	update, err := db.Write(api.h.db.DB, func(tx *gorm.DB) (*types.StateUpdate, error) {
   428| 		return db.EnableRoute(tx, request.GetRouteId())
   429| 	})
   430| 	if err != nil {
   431| 		return nil, err
   432| 	}
   433| 	if update != nil {
   434| 		ctx := types.NotifyCtx(ctx, "cli-enableroute", "unknown")
   435| 		api.h.nodeNotifier.NotifyAll(
   436| 			ctx, *update)
   437| 	}
   438| 	return &v1.EnableRouteResponse{}, nil
   439| }
   440| func (api headscaleV1APIServer) DisableRoute(
   441| 	ctx context.Context,
   442| 	request *v1.DisableRouteRequest,
   443| ) (*v1.DisableRouteResponse, error) {
   444| 	update, err := db.Write(api.h.db.DB, func(tx *gorm.DB) ([]types.NodeID, error) {
   445| 		return db.DisableRoute(tx, request.GetRouteId(), api.h.nodeNotifier.LikelyConnectedMap())
   446| 	})
   447| 	if err != nil {
   448| 		return nil, err
   449| 	}
   450| 	if update != nil {
   451| 		ctx := types.NotifyCtx(ctx, "cli-disableroute", "unknown")
   452| 		api.h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   453| 			Type:        types.StatePeerChanged,
   454| 			ChangeNodes: update,
   455| 		})
   456| 	}
   457| 	return &v1.DisableRouteResponse{}, nil
   458| }
   459| func (api headscaleV1APIServer) GetNodeRoutes(
   460| 	ctx context.Context,
   461| 	request *v1.GetNodeRoutesRequest,
   462| ) (*v1.GetNodeRoutesResponse, error) {
   463| 	node, err := api.h.db.GetNodeByID(types.NodeID(request.GetNodeId()))
   464| 	if err != nil {
   465| 		return nil, err
   466| 	}
   467| 	routes, err := api.h.db.GetNodeRoutes(node)
   468| 	if err != nil {
   469| 		return nil, err
   470| 	}
   471| 	return &v1.GetNodeRoutesResponse{
   472| 		Routes: types.Routes(routes).Proto(),
   473| 	}, nil
   474| }
   475| func (api headscaleV1APIServer) DeleteRoute(
   476| 	ctx context.Context,
   477| 	request *v1.DeleteRouteRequest,
   478| ) (*v1.DeleteRouteResponse, error) {
   479| 	isConnected := api.h.nodeNotifier.LikelyConnectedMap()
   480| 	update, err := db.Write(api.h.db.DB, func(tx *gorm.DB) ([]types.NodeID, error) {
   481| 		return db.DeleteRoute(tx, request.GetRouteId(), isConnected)
   482| 	})
   483| 	if err != nil {
   484| 		return nil, err
   485| 	}
   486| 	if update != nil {
   487| 		ctx := types.NotifyCtx(ctx, "cli-deleteroute", "unknown")
   488| 		api.h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   489| 			Type:        types.StatePeerChanged,
   490| 			ChangeNodes: update,
   491| 		})
   492| 	}
   493| 	return &v1.DeleteRouteResponse{}, nil
   494| }
   495| func (api headscaleV1APIServer) CreateApiKey(
   496| 	ctx context.Context,
   497| 	request *v1.CreateApiKeyRequest,
   498| ) (*v1.CreateApiKeyResponse, error) {
   499| 	var expiration time.Time
   500| 	if request.GetExpiration() != nil {
   501| 		expiration = request.GetExpiration().AsTime()
   502| 	}
   503| 	apiKey, _, err := api.h.db.CreateAPIKey(
   504| 		&expiration,
   505| 	)
   506| 	if err != nil {
   507| 		return nil, err
   508| 	}
   509| 	return &v1.CreateApiKeyResponse{ApiKey: apiKey}, nil
   510| }
   511| func (api headscaleV1APIServer) ExpireApiKey(
   512| 	ctx context.Context,
   513| 	request *v1.ExpireApiKeyRequest,
   514| ) (*v1.ExpireApiKeyResponse, error) {
   515| 	var apiKey *types.APIKey
   516| 	var err error
   517| 	apiKey, err = api.h.db.GetAPIKey(request.Prefix)
   518| 	if err != nil {
   519| 		return nil, err
   520| 	}
   521| 	err = api.h.db.ExpireAPIKey(apiKey)
   522| 	if err != nil {
   523| 		return nil, err
   524| 	}
   525| 	return &v1.ExpireApiKeyResponse{}, nil
   526| }
   527| func (api headscaleV1APIServer) ListApiKeys(
   528| 	ctx context.Context,
   529| 	request *v1.ListApiKeysRequest,
   530| ) (*v1.ListApiKeysResponse, error) {
   531| 	apiKeys, err := api.h.db.ListAPIKeys()
   532| 	if err != nil {
   533| 		return nil, err
   534| 	}
   535| 	response := make([]*v1.ApiKey, len(apiKeys))
   536| 	for index, key := range apiKeys {
   537| 		response[index] = key.Proto()
   538| 	}
   539| 	sort.Slice(response, func(i, j int) bool {
   540| 		return response[i].Id < response[j].Id
   541| 	})
   542| 	return &v1.ListApiKeysResponse{ApiKeys: response}, nil
   543| }
   544| func (api headscaleV1APIServer) DeleteApiKey(
   545| 	ctx context.Context,
   546| 	request *v1.DeleteApiKeyRequest,
   547| ) (*v1.DeleteApiKeyResponse, error) {
   548| 	var (
   549| 		apiKey *types.APIKey
   550| 		err    error
   551| 	)
   552| 	apiKey, err = api.h.db.GetAPIKey(request.Prefix)
   553| 	if err != nil {
   554| 		return nil, err
   555| 	}
   556| 	if err := api.h.db.DestroyAPIKey(*apiKey); err != nil {
   557| 		return nil, err
   558| 	}
   559| 	return &v1.DeleteApiKeyResponse{}, nil
   560| }
   561| func (api headscaleV1APIServer) GetPolicy(
   562| 	_ context.Context,
   563| 	_ *v1.GetPolicyRequest,
   564| ) (*v1.GetPolicyResponse, error) {
   565| 	switch api.h.cfg.Policy.Mode {
   566| 	case types.PolicyModeDB:
   567| 		p, err := api.h.db.GetPolicy()
   568| 		if err != nil {
   569| 			return nil, fmt.Errorf("loading ACL from database: %w", err)
   570| 		}
   571| 		return &v1.GetPolicyResponse{
   572| 			Policy:    p.Data,
   573| 			UpdatedAt: timestamppb.New(p.UpdatedAt),
   574| 		}, nil
   575| 	case types.PolicyModeFile:
   576| 		absPath := util.AbsolutePathFromConfigPath(api.h.cfg.Policy.Path)
   577| 		f, err := os.Open(absPath)
   578| 		if err != nil {
   579| 			return nil, fmt.Errorf("reading policy from path %q: %w", absPath, err)
   580| 		}
   581| 		defer f.Close()
   582| 		b, err := io.ReadAll(f)
   583| 		if err != nil {
   584| 			return nil, fmt.Errorf("reading policy from file: %w", err)
   585| 		}
   586| 		return &v1.GetPolicyResponse{Policy: string(b)}, nil
   587| 	}
   588| 	return nil, fmt.Errorf("no supported policy mode found in configuration, policy.mode: %q", api.h.cfg.Policy.Mode)
   589| }
   590| func (api headscaleV1APIServer) SetPolicy(
   591| 	_ context.Context,
   592| 	request *v1.SetPolicyRequest,
   593| ) (*v1.SetPolicyResponse, error) {
   594| 	if api.h.cfg.Policy.Mode != types.PolicyModeDB {
   595| 		return nil, types.ErrPolicyUpdateIsDisabled
   596| 	}
   597| 	p := request.GetPolicy()
   598| 	pol, err := policy.LoadACLPolicyFromBytes([]byte(p))
   599| 	if err != nil {
   600| 		return nil, fmt.Errorf("loading ACL policy file: %w", err)
   601| 	}
   602| 	nodes, err := api.h.db.ListNodes()
   603| 	if err != nil {
   604| 		return nil, fmt.Errorf("loading nodes from database to validate policy: %w", err)
   605| 	}
   606| 	_, err = pol.CompileFilterRules(nodes)
   607| 	if err != nil {
   608| 		return nil, fmt.Errorf("verifying policy rules: %w", err)
   609| 	}
   610| 	if len(nodes) > 0 {
   611| 		_, err = pol.CompileSSHPolicy(nodes[0], nodes)
   612| 		if err != nil {
   613| 			return nil, fmt.Errorf("verifying SSH rules: %w", err)
   614| 		}
   615| 	}
   616| 	updated, err := api.h.db.SetPolicy(p)
   617| 	if err != nil {
   618| 		return nil, err
   619| 	}
   620| 	api.h.ACLPolicy = pol
   621| 	ctx := types.NotifyCtx(context.Background(), "acl-update", "na")
   622| 	api.h.nodeNotifier.NotifyAll(ctx, types.StateUpdate{
   623| 		Type: types.StateFullUpdate,
   624| 	})
   625| 	response := &v1.SetPolicyResponse{
   626| 		Policy:    updated.Data,
   627| 		UpdatedAt: timestamppb.New(updated.UpdatedAt),
   628| 	}
   629| 	return response, nil
   630| }
   631| func (api headscaleV1APIServer) DebugCreateNode(
   632| 	ctx context.Context,
   633| 	request *v1.DebugCreateNodeRequest,
   634| ) (*v1.DebugCreateNodeResponse, error) {
   635| 	user, err := api.h.db.GetUser(request.GetUser())
   636| 	if err != nil {
   637| 		return nil, err
   638| 	}
   639| 	routes, err := util.StringToIPPrefix(request.GetRoutes())
   640| 	if err != nil {
   641| 		return nil, err
   642| 	}
   643| 	log.Trace().
   644| 		Caller().
   645| 		Interface("route-prefix", routes).
   646| 		Interface("route-str", request.GetRoutes()).
   647| 		Msg("")
   648| 	hostinfo := tailcfg.Hostinfo{
   649| 		RoutableIPs: routes,
   650| 		OS:          "TestOS",
   651| 		Hostname:    "DebugTestNode",
   652| 	}
   653| 	var mkey key.MachinePublic
   654| 	err = mkey.UnmarshalText([]byte(request.GetKey()))
   655| 	if err != nil {
   656| 		return nil, err
   657| 	}
   658| 	nodeKey := key.NewNode()
   659| 	newNode := types.Node{
   660| 		MachineKey: mkey,
   661| 		NodeKey:    nodeKey.Public(),
   662| 		Hostname:   request.GetName(),
   663| 		User:       *user,
   664| 		Expiry:   &time.Time{},
   665| 		LastSeen: &time.Time{},
   666| 		Hostinfo: &hostinfo,
   667| 	}
   668| 	log.Debug().
   669| 		Str("machine_key", mkey.ShortString()).
   670| 		Msg("adding debug machine via CLI, appending to registration cache")
   671| 	api.h.registrationCache.Set(
   672| 		mkey.String(),
   673| 		newNode,
   674| 		registerCacheExpiration,
   675| 	)
   676| 	return &v1.DebugCreateNodeResponse{Node: newNode.Proto()}, nil
   677| }
   678| func (api headscaleV1APIServer) mustEmbedUnimplementedHeadscaleServiceServer() {}


# ====================================================================
# FILE: hscontrol/handlers.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-183 ---
     1| package hscontrol
     2| import (
     3| 	"bytes"
     4| 	"encoding/json"
     5| 	"errors"
     6| 	"fmt"
     7| 	"html/template"
     8| 	"net/http"
     9| 	"strconv"
    10| 	"time"
    11| 	"github.com/gorilla/mux"
    12| 	"github.com/rs/zerolog/log"
    13| 	"tailscale.com/tailcfg"
    14| 	"tailscale.com/types/key"
    15| )
    16| const (
    17| 	NoiseCapabilityVersion = 39
    18| 	registrationHoldoff        = time.Second * 5
    19| 	reservedResponseHeaderSize = 4
    20| )
    21| var ErrRegisterMethodCLIDoesNotSupportExpire = errors.New(
    22| 	"machines registered with CLI does not support expire",
    23| )
    24| var ErrNoCapabilityVersion = errors.New("no capability version set")
    25| func parseCabailityVersion(req *http.Request) (tailcfg.CapabilityVersion, error) {
    26| 	clientCapabilityStr := req.URL.Query().Get("v")
    27| 	if clientCapabilityStr == "" {
    28| 		return 0, ErrNoCapabilityVersion
    29| 	}
    30| 	clientCapabilityVersion, err := strconv.Atoi(clientCapabilityStr)
    31| 	if err != nil {
    32| 		return 0, fmt.Errorf("failed to parse capability version: %w", err)
    33| 	}
    34| 	return tailcfg.CapabilityVersion(clientCapabilityVersion), nil
    35| }
    36| func (h *Headscale) KeyHandler(
    37| 	writer http.ResponseWriter,
    38| 	req *http.Request,
    39| ) {
    40| 	capVer, err := parseCabailityVersion(req)
    41| 	if err != nil {
    42| 		log.Error().
    43| 			Caller().
    44| 			Err(err).
    45| 			Msg("could not get capability version")
    46| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    47| 		writer.WriteHeader(http.StatusInternalServerError)
    48| 		return
    49| 	}
    50| 	log.Debug().
    51| 		Str("handler", "/key").
    52| 		Int("cap_ver", int(capVer)).
    53| 		Msg("New noise client")
    54| 	if capVer >= NoiseCapabilityVersion {
    55| 		resp := tailcfg.OverTLSPublicKeyResponse{
    56| 			PublicKey: h.noisePrivateKey.Public(),
    57| 		}
    58| 		writer.Header().Set("Content-Type", "application/json")
    59| 		writer.WriteHeader(http.StatusOK)
    60| 		err = json.NewEncoder(writer).Encode(resp)
    61| 		if err != nil {
    62| 			log.Error().
    63| 				Caller().
    64| 				Err(err).
    65| 				Msg("Failed to write response")
    66| 		}
    67| 		return
    68| 	}
    69| }
    70| func (h *Headscale) HealthHandler(
    71| 	writer http.ResponseWriter,
    72| 	req *http.Request,
    73| ) {
    74| 	respond := func(err error) {
    75| 		writer.Header().Set("Content-Type", "application/health+json; charset=utf-8")
    76| 		res := struct {
    77| 			Status string `json:"status"`
    78| 		}{
    79| 			Status: "pass",
    80| 		}
    81| 		if err != nil {
    82| 			writer.WriteHeader(http.StatusInternalServerError)
    83| 			log.Error().Caller().Err(err).Msg("health check failed")
    84| 			res.Status = "fail"
    85| 		}
    86| 		buf, err := json.Marshal(res)
    87| 		if err != nil {
    88| 			log.Error().Caller().Err(err).Msg("marshal failed")
    89| 		}
    90| 		_, err = writer.Write(buf)
    91| 		if err != nil {
    92| 			log.Error().Caller().Err(err).Msg("write failed")
    93| 		}
    94| 	}
    95| 	if err := h.db.PingDB(req.Context()); err != nil {
    96| 		respond(err)
    97| 		return
    98| 	}
    99| 	respond(nil)
   100| }
   101| type registerWebAPITemplateConfig struct {
   102| 	Key string
   103| }
   104| var registerWebAPITemplate = template.Must(
   105| 	template.New("registerweb").Parse(`
   106| <html>
   107| 	<head>
   108| 		<title>Registration - Headscale</title>
   109| 		<meta name=viewport content="width=device-width, initial-scale=1">
   110| 		<style>
   111| 			body {
   112| 				font-family: sans;
   113| 			}
   114| 			code {
   115| 				display: block;
   116| 				padding: 20px;
   117| 				border: 1px solid #bbb;
   118| 				background-color: #eee;
   119| 			}
   120| 		</style>
   121| 	</head>
   122| 	<body>
   123| 		<h1>headscale</h1>
   124| 		<h2>Machine registration</h2>
   125| 		<p>
   126| 			Run the command below in the headscale server to add this machine to your network:
   127| 		</p>
   128| 		<code>headscale nodes register --user USERNAME --key {{.Key}}</code>
   129| 	</body>
   130| </html>
   131| `))
   132| func (h *Headscale) RegisterWebAPI(
   133| 	writer http.ResponseWriter,
   134| 	req *http.Request,
   135| ) {
   136| 	vars := mux.Vars(req)
   137| 	machineKeyStr := vars["mkey"]
   138| 	var machineKey key.MachinePublic
   139| 	err := machineKey.UnmarshalText(
   140| 		[]byte(machineKeyStr),
   141| 	)
   142| 	if err != nil {
   143| 		log.Warn().Err(err).Msg("Failed to parse incoming nodekey")
   144| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   145| 		writer.WriteHeader(http.StatusBadRequest)
   146| 		_, err := writer.Write([]byte("Wrong params"))
   147| 		if err != nil {
   148| 			log.Error().
   149| 				Caller().
   150| 				Err(err).
   151| 				Msg("Failed to write response")
   152| 		}
   153| 		return
   154| 	}
   155| 	var content bytes.Buffer
   156| 	if err := registerWebAPITemplate.Execute(&content, registerWebAPITemplateConfig{
   157| 		Key: machineKey.String(),
   158| 	}); err != nil {
   159| 		log.Error().
   160| 			Str("func", "RegisterWebAPI").
   161| 			Err(err).
   162| 			Msg("Could not render register web API template")
   163| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   164| 		writer.WriteHeader(http.StatusInternalServerError)
   165| 		_, err = writer.Write([]byte("Could not render register web API template"))
   166| 		if err != nil {
   167| 			log.Error().
   168| 				Caller().
   169| 				Err(err).
   170| 				Msg("Failed to write response")
   171| 		}
   172| 		return
   173| 	}
   174| 	writer.Header().Set("Content-Type", "text/html; charset=utf-8")
   175| 	writer.WriteHeader(http.StatusOK)
   176| 	_, err = writer.Write(content.Bytes())
   177| 	if err != nil {
   178| 		log.Error().
   179| 			Caller().
   180| 			Err(err).
   181| 			Msg("Failed to write response")
   182| 	}
   183| }


# ====================================================================
# FILE: hscontrol/mapper/mapper.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-452 ---
     1| package mapper
     2| import (
     3| 	"encoding/binary"
     4| 	"encoding/json"
     5| 	"fmt"
     6| 	"io/fs"
     7| 	"net/url"
     8| 	"os"
     9| 	"path"
    10| 	"slices"
    11| 	"sort"
    12| 	"strings"
    13| 	"sync"
    14| 	"sync/atomic"
    15| 	"time"
    16| 	mapset "github.com/deckarep/golang-set/v2"
    17| 	"github.com/juanfont/headscale/hscontrol/db"
    18| 	"github.com/juanfont/headscale/hscontrol/notifier"
    19| 	"github.com/juanfont/headscale/hscontrol/policy"
    20| 	"github.com/juanfont/headscale/hscontrol/types"
    21| 	"github.com/juanfont/headscale/hscontrol/util"
    22| 	"github.com/klauspost/compress/zstd"
    23| 	"github.com/rs/zerolog/log"
    24| 	"tailscale.com/envknob"
    25| 	"tailscale.com/smallzstd"
    26| 	"tailscale.com/tailcfg"
    27| 	"tailscale.com/types/dnstype"
    28| )
    29| const (
    30| 	nextDNSDoHPrefix           = "https://dns.nextdns.io"
    31| 	reservedResponseHeaderSize = 4
    32| 	mapperIDLength             = 8
    33| 	debugMapResponsePerm       = 0o755
    34| )
    35| var debugDumpMapResponsePath = envknob.String("HEADSCALE_DEBUG_DUMP_MAPRESPONSE_PATH")
    36| type Mapper struct {
    37| 	db      *db.HSDatabase
    38| 	cfg     *types.Config
    39| 	derpMap *tailcfg.DERPMap
    40| 	notif   *notifier.Notifier
    41| 	uid     string
    42| 	created time.Time
    43| 	seq     uint64
    44| }
    45| type patch struct {
    46| 	timestamp time.Time
    47| 	change    *tailcfg.PeerChange
    48| }
    49| func NewMapper(
    50| 	db *db.HSDatabase,
    51| 	cfg *types.Config,
    52| 	derpMap *tailcfg.DERPMap,
    53| 	notif *notifier.Notifier,
    54| ) *Mapper {
    55| 	uid, _ := util.GenerateRandomStringDNSSafe(mapperIDLength)
    56| 	return &Mapper{
    57| 		db:      db,
    58| 		cfg:     cfg,
    59| 		derpMap: derpMap,
    60| 		notif:   notif,
    61| 		uid:     uid,
    62| 		created: time.Now(),
    63| 		seq:     0,
    64| 	}
    65| }
    66| func (m *Mapper) String() string {
    67| 	return fmt.Sprintf("Mapper: { seq: %d, uid: %s, created: %s }", m.seq, m.uid, m.created)
    68| }
    69| func generateUserProfiles(
    70| 	node *types.Node,
    71| 	peers types.Nodes,
    72| ) []tailcfg.UserProfile {
    73| 	userMap := make(map[string]types.User)
    74| 	userMap[node.User.Name] = node.User
    75| 	for _, peer := range peers {
    76| 		userMap[peer.User.Name] = peer.User // not worth checking if already is there
    77| 	}
    78| 	var profiles []tailcfg.UserProfile
    79| 	for _, user := range userMap {
    80| 		profiles = append(profiles,
    81| 			user.TailscaleUserProfile())
    82| 	}
    83| 	return profiles
    84| }
    85| func generateDNSConfig(
    86| 	cfg *types.Config,
    87| 	baseDomain string,
    88| 	node *types.Node,
    89| 	peers types.Nodes,
    90| ) *tailcfg.DNSConfig {
    91| 	if cfg.DNSConfig == nil {
    92| 		return nil
    93| 	}
    94| 	dnsConfig := cfg.DNSConfig.Clone()
    95| 	if dnsConfig.Proxied {
    96| 		if cfg.DNSUserNameInMagicDNS {
    97| 			dnsConfig.Domains = append(
    98| 				dnsConfig.Domains,
    99| 				fmt.Sprintf(
   100| 					"%s.%s",
   101| 					node.User.Name,
   102| 					baseDomain,
   103| 				),
   104| 			)
   105| 			userSet := mapset.NewSet[types.User]()
   106| 			userSet.Add(node.User)
   107| 			for _, p := range peers {
   108| 				userSet.Add(p.User)
   109| 			}
   110| 			for _, user := range userSet.ToSlice() {
   111| 				dnsRoute := fmt.Sprintf("%v.%v", user.Name, baseDomain)
   112| 				dnsConfig.Routes[dnsRoute] = nil
   113| 			}
   114| 		}
   115| 	}
   116| 	addNextDNSMetadata(dnsConfig.Resolvers, node)
   117| 	return dnsConfig
   118| }
   119| func addNextDNSMetadata(resolvers []*dnstype.Resolver, node *types.Node) {
   120| 	for _, resolver := range resolvers {
   121| 		if strings.HasPrefix(resolver.Addr, nextDNSDoHPrefix) {
   122| 			attrs := url.Values{
   123| 				"device_name":  []string{node.Hostname},
   124| 				"device_model": []string{node.Hostinfo.OS},
   125| 			}
   126| 			if len(node.IPs()) > 0 {
   127| 				attrs.Add("device_ip", node.IPs()[0].String())
   128| 			}
   129| 			resolver.Addr = fmt.Sprintf("%s?%s", resolver.Addr, attrs.Encode())
   130| 		}
   131| 	}
   132| }
   133| func (m *Mapper) fullMapResponse(
   134| 	node *types.Node,
   135| 	peers types.Nodes,
   136| 	pol *policy.ACLPolicy,
   137| 	capVer tailcfg.CapabilityVersion,
   138| ) (*tailcfg.MapResponse, error) {
   139| 	resp, err := m.baseWithConfigMapResponse(node, pol, capVer)
   140| 	if err != nil {
   141| 		return nil, err
   142| 	}
   143| 	err = appendPeerChanges(
   144| 		resp,
   145| 		true, // full change
   146| 		pol,
   147| 		node,
   148| 		capVer,
   149| 		peers,
   150| 		peers,
   151| 		m.cfg,
   152| 	)
   153| 	if err != nil {
   154| 		return nil, err
   155| 	}
   156| 	return resp, nil
   157| }
   158| func (m *Mapper) FullMapResponse(
   159| 	mapRequest tailcfg.MapRequest,
   160| 	node *types.Node,
   161| 	pol *policy.ACLPolicy,
   162| 	messages ...string,
   163| ) ([]byte, error) {
   164| 	peers, err := m.ListPeers(node.ID)
   165| 	if err != nil {
   166| 		return nil, err
   167| 	}
   168| 	resp, err := m.fullMapResponse(node, peers, pol, mapRequest.Version)
   169| 	if err != nil {
   170| 		return nil, err
   171| 	}
   172| 	return m.marshalMapResponse(mapRequest, resp, node, mapRequest.Compress, messages...)
   173| }
   174| func (m *Mapper) ReadOnlyMapResponse(
   175| 	mapRequest tailcfg.MapRequest,
   176| 	node *types.Node,
   177| 	pol *policy.ACLPolicy,
   178| 	messages ...string,
   179| ) ([]byte, error) {
   180| 	resp, err := m.baseWithConfigMapResponse(node, pol, mapRequest.Version)
   181| 	if err != nil {
   182| 		return nil, err
   183| 	}
   184| 	return m.marshalMapResponse(mapRequest, resp, node, mapRequest.Compress, messages...)
   185| }
   186| func (m *Mapper) KeepAliveResponse(
   187| 	mapRequest tailcfg.MapRequest,
   188| 	node *types.Node,
   189| ) ([]byte, error) {
   190| 	resp := m.baseMapResponse()
   191| 	resp.KeepAlive = true
   192| 	return m.marshalMapResponse(mapRequest, &resp, node, mapRequest.Compress)
   193| }
   194| func (m *Mapper) DERPMapResponse(
   195| 	mapRequest tailcfg.MapRequest,
   196| 	node *types.Node,
   197| 	derpMap *tailcfg.DERPMap,
   198| ) ([]byte, error) {
   199| 	m.derpMap = derpMap
   200| 	resp := m.baseMapResponse()
   201| 	resp.DERPMap = derpMap
   202| 	return m.marshalMapResponse(mapRequest, &resp, node, mapRequest.Compress)
   203| }
   204| func (m *Mapper) PeerChangedResponse(
   205| 	mapRequest tailcfg.MapRequest,
   206| 	node *types.Node,
   207| 	changed map[types.NodeID]bool,
   208| 	patches []*tailcfg.PeerChange,
   209| 	pol *policy.ACLPolicy,
   210| 	messages ...string,
   211| ) ([]byte, error) {
   212| 	resp := m.baseMapResponse()
   213| 	peers, err := m.ListPeers(node.ID)
   214| 	if err != nil {
   215| 		return nil, err
   216| 	}
   217| 	var removedIDs []tailcfg.NodeID
   218| 	var changedIDs []types.NodeID
   219| 	for nodeID, nodeChanged := range changed {
   220| 		if nodeChanged {
   221| 			changedIDs = append(changedIDs, nodeID)
   222| 		} else {
   223| 			removedIDs = append(removedIDs, nodeID.NodeID())
   224| 		}
   225| 	}
   226| 	changedNodes := make(types.Nodes, 0, len(changedIDs))
   227| 	for _, peer := range peers {
   228| 		if slices.Contains(changedIDs, peer.ID) {
   229| 			changedNodes = append(changedNodes, peer)
   230| 		}
   231| 	}
   232| 	err = appendPeerChanges(
   233| 		&resp,
   234| 		false, // partial change
   235| 		pol,
   236| 		node,
   237| 		mapRequest.Version,
   238| 		peers,
   239| 		changedNodes,
   240| 		m.cfg,
   241| 	)
   242| 	if err != nil {
   243| 		return nil, err
   244| 	}
   245| 	resp.PeersRemoved = removedIDs
   246| 	if patches != nil {
   247| 		resp.PeersChangedPatch = patches
   248| 	}
   249| 	tailnode, err := tailNode(node, mapRequest.Version, pol, m.cfg)
   250| 	if err != nil {
   251| 		return nil, err
   252| 	}
   253| 	resp.Node = tailnode
   254| 	return m.marshalMapResponse(mapRequest, &resp, node, mapRequest.Compress, messages...)
   255| }
   256| func (m *Mapper) PeerChangedPatchResponse(
   257| 	mapRequest tailcfg.MapRequest,
   258| 	node *types.Node,
   259| 	changed []*tailcfg.PeerChange,
   260| 	pol *policy.ACLPolicy,
   261| ) ([]byte, error) {
   262| 	resp := m.baseMapResponse()
   263| 	resp.PeersChangedPatch = changed
   264| 	return m.marshalMapResponse(mapRequest, &resp, node, mapRequest.Compress)
   265| }
   266| func (m *Mapper) marshalMapResponse(
   267| 	mapRequest tailcfg.MapRequest,
   268| 	resp *tailcfg.MapResponse,
   269| 	node *types.Node,
   270| 	compression string,
   271| 	messages ...string,
   272| ) ([]byte, error) {
   273| 	atomic.AddUint64(&m.seq, 1)
   274| 	jsonBody, err := json.Marshal(resp)
   275| 	if err != nil {
   276| 		return nil, fmt.Errorf("marshalling map response: %w", err)
   277| 	}
   278| 	if debugDumpMapResponsePath != "" {
   279| 		data := map[string]interface{}{
   280| 			"Messages":    messages,
   281| 			"MapRequest":  mapRequest,
   282| 			"MapResponse": resp,
   283| 		}
   284| 		responseType := "keepalive"
   285| 		switch {
   286| 		case resp.Peers != nil && len(resp.Peers) > 0:
   287| 			responseType = "full"
   288| 		case resp.Peers == nil && resp.PeersChanged == nil && resp.PeersChangedPatch == nil && resp.DERPMap == nil && !resp.KeepAlive:
   289| 			responseType = "self"
   290| 		case resp.PeersChanged != nil && len(resp.PeersChanged) > 0:
   291| 			responseType = "changed"
   292| 		case resp.PeersChangedPatch != nil && len(resp.PeersChangedPatch) > 0:
   293| 			responseType = "patch"
   294| 		case resp.PeersRemoved != nil && len(resp.PeersRemoved) > 0:
   295| 			responseType = "removed"
   296| 		}
   297| 		body, err := json.MarshalIndent(data, "", "  ")
   298| 		if err != nil {
   299| 			return nil, fmt.Errorf("marshalling map response: %w", err)
   300| 		}
   301| 		perms := fs.FileMode(debugMapResponsePerm)
   302| 		mPath := path.Join(debugDumpMapResponsePath, node.Hostname)
   303| 		err = os.MkdirAll(mPath, perms)
   304| 		if err != nil {
   305| 			panic(err)
   306| 		}
   307| 		now := time.Now().Format("2006-01-02T15-04-05.999999999")
   308| 		mapResponsePath := path.Join(
   309| 			mPath,
   310| 			fmt.Sprintf("%s-%s-%d-%s.json", now, m.uid, atomic.LoadUint64(&m.seq), responseType),
   311| 		)
   312| 		log.Trace().Msgf("Writing MapResponse to %s", mapResponsePath)
   313| 		err = os.WriteFile(mapResponsePath, body, perms)
   314| 		if err != nil {
   315| 			panic(err)
   316| 		}
   317| 	}
   318| 	var respBody []byte
   319| 	if compression == util.ZstdCompression {
   320| 		respBody = zstdEncode(jsonBody)
   321| 	} else {
   322| 		respBody = jsonBody
   323| 	}
   324| 	data := make([]byte, reservedResponseHeaderSize)
   325| 	binary.LittleEndian.PutUint32(data, uint32(len(respBody)))
   326| 	data = append(data, respBody...)
   327| 	return data, nil
   328| }
   329| func zstdEncode(in []byte) []byte {
   330| 	encoder, ok := zstdEncoderPool.Get().(*zstd.Encoder)
   331| 	if !ok {
   332| 		panic("invalid type in sync pool")
   333| 	}
   334| 	out := encoder.EncodeAll(in, nil)
   335| 	_ = encoder.Close()
   336| 	zstdEncoderPool.Put(encoder)
   337| 	return out
   338| }
   339| var zstdEncoderPool = &sync.Pool{
   340| 	New: func() any {
   341| 		encoder, err := smallzstd.NewEncoder(
   342| 			nil,
   343| 			zstd.WithEncoderLevel(zstd.SpeedFastest))
   344| 		if err != nil {
   345| 			panic(err)
   346| 		}
   347| 		return encoder
   348| 	},
   349| }
   350| func (m *Mapper) baseMapResponse() tailcfg.MapResponse {
   351| 	now := time.Now()
   352| 	resp := tailcfg.MapResponse{
   353| 		KeepAlive:   false,
   354| 		ControlTime: &now,
   355| 	}
   356| 	return resp
   357| }
   358| func (m *Mapper) baseWithConfigMapResponse(
   359| 	node *types.Node,
   360| 	pol *policy.ACLPolicy,
   361| 	capVer tailcfg.CapabilityVersion,
   362| ) (*tailcfg.MapResponse, error) {
   363| 	resp := m.baseMapResponse()
   364| 	tailnode, err := tailNode(node, capVer, pol, m.cfg)
   365| 	if err != nil {
   366| 		return nil, err
   367| 	}
   368| 	resp.Node = tailnode
   369| 	resp.DERPMap = m.derpMap
   370| 	resp.Domain = m.cfg.BaseDomain
   371| 	resp.CollectServices = "false"
   372| 	resp.KeepAlive = false
   373| 	resp.Debug = &tailcfg.Debug{
   374| 		DisableLogTail: !m.cfg.LogTail.Enabled,
   375| 	}
   376| 	return &resp, nil
   377| }
   378| func (m *Mapper) ListPeers(nodeID types.NodeID) (types.Nodes, error) {
   379| 	peers, err := m.db.ListPeers(nodeID)
   380| 	if err != nil {
   381| 		return nil, err
   382| 	}
   383| 	for _, peer := range peers {
   384| 		online := m.notif.IsLikelyConnected(peer.ID)
   385| 		peer.IsOnline = &online
   386| 	}
   387| 	return peers, nil
   388| }
   389| func nodeMapToList(nodes map[uint64]*types.Node) types.Nodes {
   390| 	ret := make(types.Nodes, 0)
   391| 	for _, node := range nodes {
   392| 		ret = append(ret, node)
   393| 	}
   394| 	return ret
   395| }
   396| func appendPeerChanges(
   397| 	resp *tailcfg.MapResponse,
   398| 	fullChange bool,
   399| 	pol *policy.ACLPolicy,
   400| 	node *types.Node,
   401| 	capVer tailcfg.CapabilityVersion,
   402| 	peers types.Nodes,
   403| 	changed types.Nodes,
   404| 	cfg *types.Config,
   405| ) error {
   406| 	packetFilter, err := pol.CompileFilterRules(append(peers, node))
   407| 	if err != nil {
   408| 		return err
   409| 	}
   410| 	sshPolicy, err := pol.CompileSSHPolicy(node, peers)
   411| 	if err != nil {
   412| 		return err
   413| 	}
   414| 	if len(packetFilter) > 0 {
   415| 		changed = policy.FilterNodesByACL(node, changed, packetFilter)
   416| 	}
   417| 	profiles := generateUserProfiles(node, changed)
   418| 	dnsConfig := generateDNSConfig(
   419| 		cfg,
   420| 		cfg.BaseDomain,
   421| 		node,
   422| 		peers,
   423| 	)
   424| 	tailPeers, err := tailNodes(changed, capVer, pol, cfg)
   425| 	if err != nil {
   426| 		return err
   427| 	}
   428| 	sort.SliceStable(tailPeers, func(x, y int) bool {
   429| 		return tailPeers[x].ID < tailPeers[y].ID
   430| 	})
   431| 	if fullChange {
   432| 		resp.Peers = tailPeers
   433| 	} else {
   434| 		resp.PeersChanged = tailPeers
   435| 	}
   436| 	resp.DNSConfig = dnsConfig
   437| 	resp.UserProfiles = profiles
   438| 	resp.SSHPolicy = sshPolicy
   439| 	if capVer >= 81 {
   440| 		resp.PacketFilters = map[string][]tailcfg.FilterRule{
   441| 			"base": policy.ReduceFilterRules(node, packetFilter),
   442| 		}
   443| 	} else {
   444| 		reduced := policy.ReduceFilterRules(node, packetFilter)
   445| 		if len(reduced) > 0 {
   446| 			resp.PacketFilter = reduced
   447| 		} else {
   448| 			resp.PacketFilter = packetFilter
   449| 		}
   450| 	}
   451| 	return nil
   452| }


# ====================================================================
# FILE: hscontrol/mapper/tail.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-119 ---
     1| package mapper
     2| import (
     3| 	"fmt"
     4| 	"net/netip"
     5| 	"time"
     6| 	"github.com/juanfont/headscale/hscontrol/policy"
     7| 	"github.com/juanfont/headscale/hscontrol/types"
     8| 	"github.com/samber/lo"
     9| 	"tailscale.com/tailcfg"
    10| )
    11| func tailNodes(
    12| 	nodes types.Nodes,
    13| 	capVer tailcfg.CapabilityVersion,
    14| 	pol *policy.ACLPolicy,
    15| 	cfg *types.Config,
    16| ) ([]*tailcfg.Node, error) {
    17| 	tNodes := make([]*tailcfg.Node, len(nodes))
    18| 	for index, node := range nodes {
    19| 		node, err := tailNode(
    20| 			node,
    21| 			capVer,
    22| 			pol,
    23| 			cfg,
    24| 		)
    25| 		if err != nil {
    26| 			return nil, err
    27| 		}
    28| 		tNodes[index] = node
    29| 	}
    30| 	return tNodes, nil
    31| }
    32| func tailNode(
    33| 	node *types.Node,
    34| 	capVer tailcfg.CapabilityVersion,
    35| 	pol *policy.ACLPolicy,
    36| 	cfg *types.Config,
    37| ) (*tailcfg.Node, error) {
    38| 	addrs := node.Prefixes()
    39| 	allowedIPs := append(
    40| 		[]netip.Prefix{},
    41| 		addrs...) // we append the node own IP, as it is required by the clients
    42| 	primaryPrefixes := []netip.Prefix{}
    43| 	for _, route := range node.Routes {
    44| 		if route.Enabled {
    45| 			if route.IsPrimary {
    46| 				allowedIPs = append(allowedIPs, netip.Prefix(route.Prefix))
    47| 				primaryPrefixes = append(primaryPrefixes, netip.Prefix(route.Prefix))
    48| 			} else if route.IsExitRoute() {
    49| 				allowedIPs = append(allowedIPs, netip.Prefix(route.Prefix))
    50| 			}
    51| 		}
    52| 	}
    53| 	var derp string
    54| 	if node.Hostinfo != nil && node.Hostinfo.NetInfo != nil {
    55| 		derp = fmt.Sprintf("127.3.3.40:%d", node.Hostinfo.NetInfo.PreferredDERP)
    56| 	} else {
    57| 		derp = "127.3.3.40:0" // Zero means disconnected or unknown.
    58| 	}
    59| 	var keyExpiry time.Time
    60| 	if node.Expiry != nil {
    61| 		keyExpiry = *node.Expiry
    62| 	} else {
    63| 		keyExpiry = time.Time{}
    64| 	}
    65| 	hostname, err := node.GetFQDN(cfg, cfg.BaseDomain)
    66| 	if err != nil {
    67| 		return nil, fmt.Errorf("tailNode, failed to create FQDN: %s", err)
    68| 	}
    69| 	tags, _ := pol.TagsOfNode(node)
    70| 	tags = lo.Uniq(append(tags, node.ForcedTags...))
    71| 	tNode := tailcfg.Node{
    72| 		ID:       tailcfg.NodeID(node.ID), // this is the actual ID
    73| 		StableID: node.ID.StableID(),
    74| 		Name:     hostname,
    75| 		Cap:      capVer,
    76| 		User: tailcfg.UserID(node.UserID),
    77| 		Key:       node.NodeKey,
    78| 		KeyExpiry: keyExpiry.UTC(),
    79| 		Machine:    node.MachineKey,
    80| 		DiscoKey:   node.DiscoKey,
    81| 		Addresses:  addrs,
    82| 		AllowedIPs: allowedIPs,
    83| 		Endpoints:  node.Endpoints,
    84| 		DERP:       derp,
    85| 		Hostinfo:   node.Hostinfo.View(),
    86| 		Created:    node.CreatedAt.UTC(),
    87| 		Online: node.IsOnline,
    88| 		Tags: tags,
    89| 		PrimaryRoutes: primaryPrefixes,
    90| 		MachineAuthorized: !node.IsExpired(),
    91| 		Expired:           node.IsExpired(),
    92| 	}
    93| 	if capVer >= 74 {
    94| 		tNode.CapMap = tailcfg.NodeCapMap{
    95| 			tailcfg.CapabilityFileSharing: []tailcfg.RawMessage{},
    96| 			tailcfg.CapabilityAdmin:       []tailcfg.RawMessage{},
    97| 			tailcfg.CapabilitySSH:         []tailcfg.RawMessage{},
    98| 		}
    99| 		if cfg.RandomizeClientPort {
   100| 			tNode.CapMap[tailcfg.NodeAttrRandomizeClientPort] = []tailcfg.RawMessage{}
   101| 		}
   102| 	} else {
   103| 		tNode.Capabilities = []tailcfg.NodeCapability{
   104| 			tailcfg.CapabilityFileSharing,
   105| 			tailcfg.CapabilityAdmin,
   106| 			tailcfg.CapabilitySSH,
   107| 		}
   108| 		if cfg.RandomizeClientPort {
   109| 			tNode.Capabilities = append(tNode.Capabilities, tailcfg.NodeAttrRandomizeClientPort)
   110| 		}
   111| 	}
   112| 	if capVer < 72 {
   113| 		tNode.Capabilities = append(tNode.Capabilities, tailcfg.NodeAttrDisableUPnP)
   114| 	}
   115| 	if node.IsOnline == nil || !*node.IsOnline {
   116| 		tNode.LastSeen = node.LastSeen
   117| 	}
   118| 	return &tNode, nil
   119| }


# ====================================================================
# FILE: hscontrol/metrics.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-103 ---
     1| package hscontrol
     2| import (
     3| 	"net/http"
     4| 	"strconv"
     5| 	"github.com/gorilla/mux"
     6| 	"github.com/prometheus/client_golang/prometheus"
     7| 	"github.com/prometheus/client_golang/prometheus/promauto"
     8| 	"tailscale.com/envknob"
     9| )
    10| var debugHighCardinalityMetrics = envknob.Bool("HEADSCALE_DEBUG_HIGH_CARDINALITY_METRICS")
    11| var mapResponseLastSentSeconds *prometheus.GaugeVec
    12| func init() {
    13| 	if debugHighCardinalityMetrics {
    14| 		mapResponseLastSentSeconds = promauto.NewGaugeVec(prometheus.GaugeOpts{
    15| 			Namespace: prometheusNamespace,
    16| 			Name:      "mapresponse_last_sent_seconds",
    17| 			Help:      "last sent metric to node.id",
    18| 		}, []string{"type", "id"})
    19| 	}
    20| }
    21| const prometheusNamespace = "headscale"
    22| var (
    23| 	mapResponseSent = promauto.NewCounterVec(prometheus.CounterOpts{
    24| 		Namespace: prometheusNamespace,
    25| 		Name:      "mapresponse_sent_total",
    26| 		Help:      "total count of mapresponses sent to clients",
    27| 	}, []string{"status", "type"})
    28| 	mapResponseUpdateReceived = promauto.NewCounterVec(prometheus.CounterOpts{
    29| 		Namespace: prometheusNamespace,
    30| 		Name:      "mapresponse_updates_received_total",
    31| 		Help:      "total count of mapresponse updates received on update channel",
    32| 	}, []string{"type"})
    33| 	mapResponseWriteUpdatesInStream = promauto.NewCounterVec(prometheus.CounterOpts{
    34| 		Namespace: prometheusNamespace,
    35| 		Name:      "mapresponse_write_updates_in_stream_total",
    36| 		Help:      "total count of writes that occurred in a stream session, pre-68 nodes",
    37| 	}, []string{"status"})
    38| 	mapResponseEndpointUpdates = promauto.NewCounterVec(prometheus.CounterOpts{
    39| 		Namespace: prometheusNamespace,
    40| 		Name:      "mapresponse_endpoint_updates_total",
    41| 		Help:      "total count of endpoint updates received",
    42| 	}, []string{"status"})
    43| 	mapResponseReadOnly = promauto.NewCounterVec(prometheus.CounterOpts{
    44| 		Namespace: prometheusNamespace,
    45| 		Name:      "mapresponse_readonly_requests_total",
    46| 		Help:      "total count of readonly requests received",
    47| 	}, []string{"status"})
    48| 	mapResponseEnded = promauto.NewCounterVec(prometheus.CounterOpts{
    49| 		Namespace: prometheusNamespace,
    50| 		Name:      "mapresponse_ended_total",
    51| 		Help:      "total count of new mapsessions ended",
    52| 	}, []string{"reason"})
    53| 	mapResponseClosed = promauto.NewCounterVec(prometheus.CounterOpts{
    54| 		Namespace: prometheusNamespace,
    55| 		Name:      "mapresponse_closed_total",
    56| 		Help:      "total count of calls to mapresponse close",
    57| 	}, []string{"return"})
    58| 	httpDuration = promauto.NewHistogramVec(prometheus.HistogramOpts{
    59| 		Namespace: prometheusNamespace,
    60| 		Name:      "http_duration_seconds",
    61| 		Help:      "Duration of HTTP requests.",
    62| 	}, []string{"path"})
    63| 	httpCounter = promauto.NewCounterVec(prometheus.CounterOpts{
    64| 		Namespace: prometheusNamespace,
    65| 		Name:      "http_requests_total",
    66| 		Help:      "Total number of http requests processed",
    67| 	}, []string{"code", "method", "path"},
    68| 	)
    69| )
    70| func prometheusMiddleware(next http.Handler) http.Handler {
    71| 	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    72| 		route := mux.CurrentRoute(r)
    73| 		path, _ := route.GetPathTemplate()
    74| 		if path == "/ts2021" || path == "/machine/map" || path == "/derp" || path == "/derp/probe" || path == "/bootstrap-dns" {
    75| 			next.ServeHTTP(w, r)
    76| 			return
    77| 		}
    78| 		rw := &respWriterProm{ResponseWriter: w}
    79| 		timer := prometheus.NewTimer(httpDuration.WithLabelValues(path))
    80| 		next.ServeHTTP(rw, r)
    81| 		timer.ObserveDuration()
    82| 		httpCounter.WithLabelValues(strconv.Itoa(rw.status), r.Method, path).Inc()
    83| 	})
    84| }
    85| type respWriterProm struct {
    86| 	http.ResponseWriter
    87| 	status      int
    88| 	written     int64
    89| 	wroteHeader bool
    90| }
    91| func (r *respWriterProm) WriteHeader(code int) {
    92| 	r.status = code
    93| 	r.wroteHeader = true
    94| 	r.ResponseWriter.WriteHeader(code)
    95| }
    96| func (r *respWriterProm) Write(b []byte) (int, error) {
    97| 	if !r.wroteHeader {
    98| 		r.WriteHeader(http.StatusOK)
    99| 	}
   100| 	n, err := r.ResponseWriter.Write(b)
   101| 	r.written += int64(n)
   102| 	return n, err
   103| }


# ====================================================================
# FILE: hscontrol/noise.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/binary"
     4| 	"encoding/json"
     5| 	"io"
     6| 	"net/http"
     7| 	"github.com/gorilla/mux"
     8| 	"github.com/juanfont/headscale/hscontrol/types"
     9| 	"github.com/rs/zerolog/log"
    10| 	"golang.org/x/net/http2"
    11| 	"golang.org/x/net/http2/h2c"
    12| 	"tailscale.com/control/controlbase"
    13| 	"tailscale.com/control/controlhttp"
    14| 	"tailscale.com/tailcfg"
    15| 	"tailscale.com/types/key"
    16| )
    17| const (
    18| 	ts2021UpgradePath = "/ts2021"
    19| 	earlyPayloadMagic = "\xff\xff\xffTS"
    20| 	earlyNoiseCapabilityVersion = 49
    21| )
    22| type noiseServer struct {
    23| 	headscale *Headscale
    24| 	httpBaseConfig *http.Server
    25| 	http2Server    *http2.Server
    26| 	conn           *controlbase.Conn
    27| 	machineKey     key.MachinePublic
    28| 	nodeKey        key.NodePublic

# --- HUNK 2: Lines 45-94 ---
    45| 	noiseServer := noiseServer{
    46| 		headscale: h,
    47| 		challenge: key.NewChallenge(),
    48| 	}
    49| 	noiseConn, err := controlhttp.AcceptHTTP(
    50| 		req.Context(),
    51| 		writer,
    52| 		req,
    53| 		*h.noisePrivateKey,
    54| 		noiseServer.earlyNoise,
    55| 	)
    56| 	if err != nil {
    57| 		log.Error().Err(err).Msg("noise upgrade failed")
    58| 		http.Error(writer, err.Error(), http.StatusInternalServerError)
    59| 		return
    60| 	}
    61| 	noiseServer.conn = noiseConn
    62| 	noiseServer.machineKey = noiseServer.conn.Peer()
    63| 	noiseServer.protocolVersion = noiseServer.conn.ProtocolVersion()
    64| 	router := mux.NewRouter()
    65| 	router.Use(prometheusMiddleware)
    66| 	router.HandleFunc("/machine/register", noiseServer.NoiseRegistrationHandler).
    67| 		Methods(http.MethodPost)
    68| 	router.HandleFunc("/machine/map", noiseServer.NoisePollNetMapHandler)
    69| 	server := http.Server{
    70| 		ReadTimeout: types.HTTPTimeout,
    71| 	}
    72| 	noiseServer.httpBaseConfig = &http.Server{
    73| 		Handler:           router,
    74| 		ReadHeaderTimeout: types.HTTPTimeout,
    75| 	}
    76| 	noiseServer.http2Server = &http2.Server{}
    77| 	server.Handler = h2c.NewHandler(router, noiseServer.http2Server)
    78| 	noiseServer.http2Server.ServeConn(
    79| 		noiseConn,
    80| 		&http2.ServeConnOpts{
    81| 			BaseConfig: noiseServer.httpBaseConfig,
    82| 		},
    83| 	)
    84| }
    85| func (ns *noiseServer) earlyNoise(protocolVersion int, writer io.Writer) error {
    86| 	log.Trace().
    87| 		Caller().
    88| 		Int("protocol_version", protocolVersion).
    89| 		Str("challenge", ns.challenge.Public().String()).
    90| 		Msg("earlyNoise called")
    91| 	if protocolVersion < earlyNoiseCapabilityVersion {
    92| 		log.Trace().
    93| 			Caller().
    94| 			Msgf("protocol version %d does not support early noise", protocolVersion)

# --- HUNK 3: Lines 98-171 ---
    98| 		NodeKeyChallenge: ns.challenge.Public(),
    99| 	})
   100| 	if err != nil {
   101| 		return err
   102| 	}
   103| 	var notH2Frame [5]byte
   104| 	copy(notH2Frame[:], earlyPayloadMagic)
   105| 	var lenBuf [4]byte
   106| 	binary.BigEndian.PutUint32(lenBuf[:], uint32(len(earlyJSON)))
   107| 	if _, err := writer.Write(notH2Frame[:]); err != nil {
   108| 		return err
   109| 	}
   110| 	if _, err := writer.Write(lenBuf[:]); err != nil {
   111| 		return err
   112| 	}
   113| 	if _, err := writer.Write(earlyJSON); err != nil {
   114| 		return err
   115| 	}
   116| 	return nil
   117| }
   118| const (
   119| 	MinimumCapVersion tailcfg.CapabilityVersion = 61
   120| )
   121| func (ns *noiseServer) NoisePollNetMapHandler(
   122| 	writer http.ResponseWriter,
   123| 	req *http.Request,
   124| ) {
   125| 	log.Trace().
   126| 		Str("handler", "NoisePollNetMap").
   127| 		Msg("PollNetMapHandler called")
   128| 	log.Trace().
   129| 		Any("headers", req.Header).
   130| 		Caller().
   131| 		Msg("Headers")
   132| 	body, _ := io.ReadAll(req.Body)
   133| 	mapRequest := tailcfg.MapRequest{}
   134| 	if err := json.Unmarshal(body, &mapRequest); err != nil {
   135| 		log.Error().
   136| 			Caller().
   137| 			Err(err).
   138| 			Msg("Cannot parse MapRequest")
   139| 		http.Error(writer, "Internal error", http.StatusInternalServerError)
   140| 		return
   141| 	}
   142| 	if mapRequest.Version < MinimumCapVersion {
   143| 		log.Info().
   144| 			Caller().
   145| 			Int("min_version", int(MinimumCapVersion)).
   146| 			Int("client_version", int(mapRequest.Version)).
   147| 			Msg("unsupported client connected")
   148| 		http.Error(writer, "Internal error", http.StatusBadRequest)
   149| 		return
   150| 	}
   151| 	ns.nodeKey = mapRequest.NodeKey
   152| 	node, err := ns.headscale.db.GetNodeByAnyKey(
   153| 		ns.conn.Peer(),
   154| 		mapRequest.NodeKey,
   155| 		key.NodePublic{},
   156| 	)
   157| 	if err != nil {
   158| 		log.Error().
   159| 			Str("handler", "NoisePollNetMap").
   160| 			Msgf("Failed to fetch node from the database with node key: %s", mapRequest.NodeKey.String())
   161| 		http.Error(writer, "Internal error", http.StatusInternalServerError)
   162| 		return
   163| 	}
   164| 	sess := ns.headscale.newMapSession(req.Context(), mapRequest, writer, node)
   165| 	sess.tracef("a node sending a MapRequest with Noise protocol")
   166| 	if !sess.isStreaming() {
   167| 		sess.serve()
   168| 	} else {
   169| 		sess.serveLongPoll()
   170| 	}
   171| }


# ====================================================================
# FILE: hscontrol/notifier/metrics.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-62 ---
     1| package notifier
     2| import (
     3| 	"github.com/prometheus/client_golang/prometheus"
     4| 	"github.com/prometheus/client_golang/prometheus/promauto"
     5| 	"tailscale.com/envknob"
     6| )
     7| const prometheusNamespace = "headscale"
     8| var debugHighCardinalityMetrics = envknob.Bool("HEADSCALE_DEBUG_HIGH_CARDINALITY_METRICS")
     9| var notifierUpdateSent *prometheus.CounterVec
    10| func init() {
    11| 	if debugHighCardinalityMetrics {
    12| 		notifierUpdateSent = promauto.NewCounterVec(prometheus.CounterOpts{
    13| 			Namespace: prometheusNamespace,
    14| 			Name:      "notifier_update_sent_total",
    15| 			Help:      "total count of update sent on nodes channel",
    16| 		}, []string{"status", "type", "trigger", "id"})
    17| 	} else {
    18| 		notifierUpdateSent = promauto.NewCounterVec(prometheus.CounterOpts{
    19| 			Namespace: prometheusNamespace,
    20| 			Name:      "notifier_update_sent_total",
    21| 			Help:      "total count of update sent on nodes channel",
    22| 		}, []string{"status", "type", "trigger"})
    23| 	}
    24| }
    25| var (
    26| 	notifierWaitersForLock = promauto.NewGaugeVec(prometheus.GaugeOpts{
    27| 		Namespace: prometheusNamespace,
    28| 		Name:      "notifier_waiters_for_lock",
    29| 		Help:      "gauge of waiters for the notifier lock",
    30| 	}, []string{"type", "action"})
    31| 	notifierWaitForLock = promauto.NewHistogramVec(prometheus.HistogramOpts{
    32| 		Namespace: prometheusNamespace,
    33| 		Name:      "notifier_wait_for_lock_seconds",
    34| 		Help:      "histogram of time spent waiting for the notifier lock",
    35| 		Buckets:   []float64{0.001, 0.01, 0.1, 0.3, 0.5, 1, 3, 5, 10},
    36| 	}, []string{"action"})
    37| 	notifierUpdateReceived = promauto.NewCounterVec(prometheus.CounterOpts{
    38| 		Namespace: prometheusNamespace,
    39| 		Name:      "notifier_update_received_total",
    40| 		Help:      "total count of updates received by notifier",
    41| 	}, []string{"type", "trigger"})
    42| 	notifierNodeUpdateChans = promauto.NewGauge(prometheus.GaugeOpts{
    43| 		Namespace: prometheusNamespace,
    44| 		Name:      "notifier_open_channels_total",
    45| 		Help:      "total count open channels in notifier",
    46| 	})
    47| 	notifierBatcherWaitersForLock = promauto.NewGaugeVec(prometheus.GaugeOpts{
    48| 		Namespace: prometheusNamespace,
    49| 		Name:      "notifier_batcher_waiters_for_lock",
    50| 		Help:      "gauge of waiters for the notifier batcher lock",
    51| 	}, []string{"type", "action"})
    52| 	notifierBatcherChanges = promauto.NewGaugeVec(prometheus.GaugeOpts{
    53| 		Namespace: prometheusNamespace,
    54| 		Name:      "notifier_batcher_changes_pending",
    55| 		Help:      "gauge of full changes pending in the notifier batcher",
    56| 	}, []string{})
    57| 	notifierBatcherPatches = promauto.NewGaugeVec(prometheus.GaugeOpts{
    58| 		Namespace: prometheusNamespace,
    59| 		Name:      "notifier_batcher_patches_pending",
    60| 		Help:      "gauge of patches pending in the notifier batcher",
    61| 	}, []string{})
    62| )


# ====================================================================
# FILE: hscontrol/notifier/notifier.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-367 ---
     1| package notifier
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"sort"
     6| 	"strings"
     7| 	"sync"
     8| 	"time"
     9| 	"github.com/juanfont/headscale/hscontrol/types"
    10| 	"github.com/puzpuzpuz/xsync/v3"
    11| 	"github.com/rs/zerolog/log"
    12| 	"github.com/sasha-s/go-deadlock"
    13| 	"tailscale.com/envknob"
    14| 	"tailscale.com/tailcfg"
    15| 	"tailscale.com/util/set"
    16| )
    17| var (
    18| 	debugDeadlock        = envknob.Bool("HEADSCALE_DEBUG_DEADLOCK")
    19| 	debugDeadlockTimeout = envknob.RegisterDuration("HEADSCALE_DEBUG_DEADLOCK_TIMEOUT")
    20| )
    21| func init() {
    22| 	deadlock.Opts.Disable = !debugDeadlock
    23| 	if debugDeadlock {
    24| 		deadlock.Opts.DeadlockTimeout = debugDeadlockTimeout()
    25| 		deadlock.Opts.PrintAllCurrentGoroutines = true
    26| 	}
    27| }
    28| type Notifier struct {
    29| 	l         deadlock.Mutex
    30| 	nodes     map[types.NodeID]chan<- types.StateUpdate
    31| 	connected *xsync.MapOf[types.NodeID, bool]
    32| 	b         *batcher
    33| 	cfg       *types.Config
    34| 	closed    bool
    35| }
    36| func NewNotifier(cfg *types.Config) *Notifier {
    37| 	n := &Notifier{
    38| 		nodes:     make(map[types.NodeID]chan<- types.StateUpdate),
    39| 		connected: xsync.NewMapOf[types.NodeID, bool](),
    40| 		cfg:       cfg,
    41| 		closed:    false,
    42| 	}
    43| 	b := newBatcher(cfg.Tuning.BatchChangeDelay, n)
    44| 	n.b = b
    45| 	go b.doWork()
    46| 	return n
    47| }
    48| func (n *Notifier) Close() {
    49| 	notifierWaitersForLock.WithLabelValues("lock", "close").Inc()
    50| 	n.l.Lock()
    51| 	defer n.l.Unlock()
    52| 	notifierWaitersForLock.WithLabelValues("lock", "close").Dec()
    53| 	n.closed = true
    54| 	n.b.close()
    55| 	for _, c := range n.nodes {
    56| 		close(c)
    57| 	}
    58| }
    59| func (n *Notifier) tracef(nID types.NodeID, msg string, args ...any) {
    60| 	log.Trace().
    61| 		Uint64("node.id", nID.Uint64()).
    62| 		Int("open_chans", len(n.nodes)).Msgf(msg, args...)
    63| }
    64| func (n *Notifier) AddNode(nodeID types.NodeID, c chan<- types.StateUpdate) {
    65| 	start := time.Now()
    66| 	notifierWaitersForLock.WithLabelValues("lock", "add").Inc()
    67| 	n.l.Lock()
    68| 	defer n.l.Unlock()
    69| 	notifierWaitersForLock.WithLabelValues("lock", "add").Dec()
    70| 	notifierWaitForLock.WithLabelValues("add").Observe(time.Since(start).Seconds())
    71| 	if n.closed {
    72| 		return
    73| 	}
    74| 	if curr, ok := n.nodes[nodeID]; ok {
    75| 		n.tracef(nodeID, "channel present, closing and replacing")
    76| 		close(curr)
    77| 	}
    78| 	n.nodes[nodeID] = c
    79| 	n.connected.Store(nodeID, true)
    80| 	n.tracef(nodeID, "added new channel")
    81| 	notifierNodeUpdateChans.Inc()
    82| }
    83| func (n *Notifier) RemoveNode(nodeID types.NodeID, c chan<- types.StateUpdate) bool {
    84| 	start := time.Now()
    85| 	notifierWaitersForLock.WithLabelValues("lock", "remove").Inc()
    86| 	n.l.Lock()
    87| 	defer n.l.Unlock()
    88| 	notifierWaitersForLock.WithLabelValues("lock", "remove").Dec()
    89| 	notifierWaitForLock.WithLabelValues("remove").Observe(time.Since(start).Seconds())
    90| 	if n.closed {
    91| 		return true
    92| 	}
    93| 	if len(n.nodes) == 0 {
    94| 		return true
    95| 	}
    96| 	if curr, ok := n.nodes[nodeID]; ok {
    97| 		if curr != c {
    98| 			n.tracef(nodeID, "channel has been replaced, not removing")
    99| 			return false
   100| 		}
   101| 	}
   102| 	delete(n.nodes, nodeID)
   103| 	n.connected.Store(nodeID, false)
   104| 	n.tracef(nodeID, "removed channel")
   105| 	notifierNodeUpdateChans.Dec()
   106| 	return true
   107| }
   108| func (n *Notifier) IsConnected(nodeID types.NodeID) bool {
   109| 	notifierWaitersForLock.WithLabelValues("lock", "conncheck").Inc()
   110| 	n.l.Lock()
   111| 	defer n.l.Unlock()
   112| 	notifierWaitersForLock.WithLabelValues("lock", "conncheck").Dec()
   113| 	if val, ok := n.connected.Load(nodeID); ok {
   114| 		return val
   115| 	}
   116| 	return false
   117| }
   118| func (n *Notifier) IsLikelyConnected(nodeID types.NodeID) bool {
   119| 	if val, ok := n.connected.Load(nodeID); ok {
   120| 		return val
   121| 	}
   122| 	return false
   123| }
   124| func (n *Notifier) LikelyConnectedMap() *xsync.MapOf[types.NodeID, bool] {
   125| 	return n.connected
   126| }
   127| func (n *Notifier) NotifyAll(ctx context.Context, update types.StateUpdate) {
   128| 	n.NotifyWithIgnore(ctx, update)
   129| }
   130| func (n *Notifier) NotifyWithIgnore(
   131| 	ctx context.Context,
   132| 	update types.StateUpdate,
   133| 	ignoreNodeIDs ...types.NodeID,
   134| ) {
   135| 	if n.closed {
   136| 		return
   137| 	}
   138| 	notifierUpdateReceived.WithLabelValues(update.Type.String(), types.NotifyOriginKey.Value(ctx)).Inc()
   139| 	n.b.addOrPassthrough(update)
   140| }
   141| func (n *Notifier) NotifyByNodeID(
   142| 	ctx context.Context,
   143| 	update types.StateUpdate,
   144| 	nodeID types.NodeID,
   145| ) {
   146| 	start := time.Now()
   147| 	notifierWaitersForLock.WithLabelValues("lock", "notify").Inc()
   148| 	n.l.Lock()
   149| 	defer n.l.Unlock()
   150| 	notifierWaitersForLock.WithLabelValues("lock", "notify").Dec()
   151| 	notifierWaitForLock.WithLabelValues("notify").Observe(time.Since(start).Seconds())
   152| 	if n.closed {
   153| 		return
   154| 	}
   155| 	if c, ok := n.nodes[nodeID]; ok {
   156| 		select {
   157| 		case <-ctx.Done():
   158| 			log.Error().
   159| 				Err(ctx.Err()).
   160| 				Uint64("node.id", nodeID.Uint64()).
   161| 				Any("origin", types.NotifyOriginKey.Value(ctx)).
   162| 				Any("origin-hostname", types.NotifyHostnameKey.Value(ctx)).
   163| 				Msgf("update not sent, context cancelled")
   164| 			if debugHighCardinalityMetrics {
   165| 				notifierUpdateSent.WithLabelValues("cancelled", update.Type.String(), types.NotifyOriginKey.Value(ctx), nodeID.String()).Inc()
   166| 			} else {
   167| 				notifierUpdateSent.WithLabelValues("cancelled", update.Type.String(), types.NotifyOriginKey.Value(ctx)).Inc()
   168| 			}
   169| 			return
   170| 		case c <- update:
   171| 			n.tracef(nodeID, "update successfully sent on chan, origin: %s, origin-hostname: %s", ctx.Value("origin"), ctx.Value("hostname"))
   172| 			if debugHighCardinalityMetrics {
   173| 				notifierUpdateSent.WithLabelValues("ok", update.Type.String(), types.NotifyOriginKey.Value(ctx), nodeID.String()).Inc()
   174| 			} else {
   175| 				notifierUpdateSent.WithLabelValues("ok", update.Type.String(), types.NotifyOriginKey.Value(ctx)).Inc()
   176| 			}
   177| 		}
   178| 	}
   179| }
   180| func (n *Notifier) sendAll(update types.StateUpdate) {
   181| 	start := time.Now()
   182| 	notifierWaitersForLock.WithLabelValues("lock", "send-all").Inc()
   183| 	n.l.Lock()
   184| 	defer n.l.Unlock()
   185| 	notifierWaitersForLock.WithLabelValues("lock", "send-all").Dec()
   186| 	notifierWaitForLock.WithLabelValues("send-all").Observe(time.Since(start).Seconds())
   187| 	if n.closed {
   188| 		return
   189| 	}
   190| 	for id, c := range n.nodes {
   191| 		ctx, cancel := context.WithTimeout(context.Background(), n.cfg.Tuning.NotifierSendTimeout)
   192| 		defer cancel()
   193| 		select {
   194| 		case <-ctx.Done():
   195| 			log.Error().
   196| 				Err(ctx.Err()).
   197| 				Uint64("node.id", id.Uint64()).
   198| 				Msgf("update not sent, context cancelled")
   199| 			if debugHighCardinalityMetrics {
   200| 				notifierUpdateSent.WithLabelValues("cancelled", update.Type.String(), "send-all", id.String()).Inc()
   201| 			} else {
   202| 				notifierUpdateSent.WithLabelValues("cancelled", update.Type.String(), "send-all").Inc()
   203| 			}
   204| 			return
   205| 		case c <- update:
   206| 			if debugHighCardinalityMetrics {
   207| 				notifierUpdateSent.WithLabelValues("ok", update.Type.String(), "send-all", id.String()).Inc()
   208| 			} else {
   209| 				notifierUpdateSent.WithLabelValues("ok", update.Type.String(), "send-all").Inc()
   210| 			}
   211| 		}
   212| 	}
   213| }
   214| func (n *Notifier) String() string {
   215| 	notifierWaitersForLock.WithLabelValues("lock", "string").Inc()
   216| 	n.l.Lock()
   217| 	defer n.l.Unlock()
   218| 	notifierWaitersForLock.WithLabelValues("lock", "string").Dec()
   219| 	var b strings.Builder
   220| 	fmt.Fprintf(&b, "chans (%d):\n", len(n.nodes))
   221| 	var keys []types.NodeID
   222| 	n.connected.Range(func(key types.NodeID, value bool) bool {
   223| 		keys = append(keys, key)
   224| 		return true
   225| 	})
   226| 	sort.Slice(keys, func(i, j int) bool {
   227| 		return keys[i] < keys[j]
   228| 	})
   229| 	for _, key := range keys {
   230| 		fmt.Fprintf(&b, "\t%d: %p\n", key, n.nodes[key])
   231| 	}
   232| 	b.WriteString("\n")
   233| 	fmt.Fprintf(&b, "connected (%d):\n", len(n.nodes))
   234| 	for _, key := range keys {
   235| 		val, _ := n.connected.Load(key)
   236| 		fmt.Fprintf(&b, "\t%d: %t\n", key, val)
   237| 	}
   238| 	return b.String()
   239| }
   240| type batcher struct {
   241| 	tick *time.Ticker
   242| 	mu sync.Mutex
   243| 	cancelCh chan struct{}
   244| 	changedNodeIDs set.Slice[types.NodeID]
   245| 	nodesChanged   bool
   246| 	patches        map[types.NodeID]tailcfg.PeerChange
   247| 	patchesChanged bool
   248| 	n *Notifier
   249| }
   250| func newBatcher(batchTime time.Duration, n *Notifier) *batcher {
   251| 	return &batcher{
   252| 		tick:     time.NewTicker(batchTime),
   253| 		cancelCh: make(chan struct{}),
   254| 		patches:  make(map[types.NodeID]tailcfg.PeerChange),
   255| 		n:        n,
   256| 	}
   257| }
   258| func (b *batcher) close() {
   259| 	b.cancelCh <- struct{}{}
   260| }
   261| func (b *batcher) addOrPassthrough(update types.StateUpdate) {
   262| 	notifierBatcherWaitersForLock.WithLabelValues("lock", "add").Inc()
   263| 	b.mu.Lock()
   264| 	defer b.mu.Unlock()
   265| 	notifierBatcherWaitersForLock.WithLabelValues("lock", "add").Dec()
   266| 	switch update.Type {
   267| 	case types.StatePeerChanged:
   268| 		b.changedNodeIDs.Add(update.ChangeNodes...)
   269| 		b.nodesChanged = true
   270| 		notifierBatcherChanges.WithLabelValues().Set(float64(b.changedNodeIDs.Len()))
   271| 	case types.StatePeerChangedPatch:
   272| 		for _, newPatch := range update.ChangePatches {
   273| 			if curr, ok := b.patches[types.NodeID(newPatch.NodeID)]; ok {
   274| 				overwritePatch(&curr, newPatch)
   275| 				b.patches[types.NodeID(newPatch.NodeID)] = curr
   276| 			} else {
   277| 				b.patches[types.NodeID(newPatch.NodeID)] = *newPatch
   278| 			}
   279| 		}
   280| 		b.patchesChanged = true
   281| 		notifierBatcherPatches.WithLabelValues().Set(float64(len(b.patches)))
   282| 	default:
   283| 		b.n.sendAll(update)
   284| 	}
   285| }
   286| func (b *batcher) flush() {
   287| 	notifierBatcherWaitersForLock.WithLabelValues("lock", "flush").Inc()
   288| 	b.mu.Lock()
   289| 	defer b.mu.Unlock()
   290| 	notifierBatcherWaitersForLock.WithLabelValues("lock", "flush").Dec()
   291| 	if b.nodesChanged || b.patchesChanged {
   292| 		var patches []*tailcfg.PeerChange
   293| 		for nodeID, patch := range b.patches {
   294| 			if b.changedNodeIDs.Contains(nodeID) {
   295| 				delete(b.patches, nodeID)
   296| 			} else {
   297| 				patches = append(patches, &patch)
   298| 			}
   299| 		}
   300| 		changedNodes := b.changedNodeIDs.Slice().AsSlice()
   301| 		sort.Slice(changedNodes, func(i, j int) bool {
   302| 			return changedNodes[i] < changedNodes[j]
   303| 		})
   304| 		if b.changedNodeIDs.Slice().Len() > 0 {
   305| 			update := types.StateUpdate{
   306| 				Type:        types.StatePeerChanged,
   307| 				ChangeNodes: changedNodes,
   308| 			}
   309| 			b.n.sendAll(update)
   310| 		}
   311| 		if len(patches) > 0 {
   312| 			patchUpdate := types.StateUpdate{
   313| 				Type:          types.StatePeerChangedPatch,
   314| 				ChangePatches: patches,
   315| 			}
   316| 			b.n.sendAll(patchUpdate)
   317| 		}
   318| 		b.changedNodeIDs = set.Slice[types.NodeID]{}
   319| 		notifierBatcherChanges.WithLabelValues().Set(0)
   320| 		b.nodesChanged = false
   321| 		b.patches = make(map[types.NodeID]tailcfg.PeerChange, len(b.patches))
   322| 		notifierBatcherPatches.WithLabelValues().Set(0)
   323| 		b.patchesChanged = false
   324| 	}
   325| }
   326| func (b *batcher) doWork() {
   327| 	for {
   328| 		select {
   329| 		case <-b.cancelCh:
   330| 			return
   331| 		case <-b.tick.C:
   332| 			b.flush()
   333| 		}
   334| 	}
   335| }
   336| func overwritePatch(currPatch, newPatch *tailcfg.PeerChange) {
   337| 	if newPatch.DERPRegion != 0 {
   338| 		currPatch.DERPRegion = newPatch.DERPRegion
   339| 	}
   340| 	if newPatch.Cap != 0 {
   341| 		currPatch.Cap = newPatch.Cap
   342| 	}
   343| 	if newPatch.CapMap != nil {
   344| 		currPatch.CapMap = newPatch.CapMap
   345| 	}
   346| 	if newPatch.Endpoints != nil {
   347| 		currPatch.Endpoints = newPatch.Endpoints
   348| 	}
   349| 	if newPatch.Key != nil {
   350| 		currPatch.Key = newPatch.Key
   351| 	}
   352| 	if newPatch.KeySignature != nil {
   353| 		currPatch.KeySignature = newPatch.KeySignature
   354| 	}
   355| 	if newPatch.DiscoKey != nil {
   356| 		currPatch.DiscoKey = newPatch.DiscoKey
   357| 	}
   358| 	if newPatch.Online != nil {
   359| 		currPatch.Online = newPatch.Online
   360| 	}
   361| 	if newPatch.LastSeen != nil {
   362| 		currPatch.LastSeen = newPatch.LastSeen
   363| 	}
   364| 	if newPatch.KeyExpiry != nil {
   365| 		currPatch.KeyExpiry = newPatch.KeyExpiry
   366| 	}
   367| }


# ====================================================================
# FILE: hscontrol/oidc.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-524 ---
     1| package hscontrol
     2| import (
     3| 	"bytes"
     4| 	"context"
     5| 	"crypto/rand"
     6| 	_ "embed"
     7| 	"encoding/hex"
     8| 	"errors"
     9| 	"fmt"
    10| 	"html/template"
    11| 	"net/http"
    12| 	"slices"
    13| 	"strings"
    14| 	"time"
    15| 	"github.com/coreos/go-oidc/v3/oidc"
    16| 	"github.com/gorilla/mux"
    17| 	"github.com/juanfont/headscale/hscontrol/db"
    18| 	"github.com/juanfont/headscale/hscontrol/types"
    19| 	"github.com/juanfont/headscale/hscontrol/util"
    20| 	"github.com/rs/zerolog/log"
    21| 	"golang.org/x/oauth2"
    22| 	"gorm.io/gorm"
    23| 	"tailscale.com/types/key"
    24| )
    25| const (
    26| 	randomByteSize = 16
    27| )
    28| var (
    29| 	errEmptyOIDCCallbackParams = errors.New("empty OIDC callback params")
    30| 	errNoOIDCIDToken           = errors.New("could not extract ID Token for OIDC callback")
    31| 	errOIDCAllowedDomains      = errors.New(
    32| 		"authenticated principal does not match any allowed domain",
    33| 	)
    34| 	errOIDCAllowedGroups = errors.New("authenticated principal is not in any allowed group")
    35| 	errOIDCAllowedUsers  = errors.New(
    36| 		"authenticated principal does not match any allowed user",
    37| 	)
    38| 	errOIDCInvalidNodeState = errors.New(
    39| 		"requested node state key expired before authorisation completed",
    40| 	)
    41| 	errOIDCNodeKeyMissing = errors.New("could not get node key from cache")
    42| )
    43| type IDTokenClaims struct {
    44| 	Name     string   `json:"name,omitempty"`
    45| 	Groups   []string `json:"groups,omitempty"`
    46| 	Email    string   `json:"email"`
    47| 	Username string   `json:"preferred_username,omitempty"`
    48| }
    49| func (h *Headscale) initOIDC() error {
    50| 	var err error
    51| 	if h.oauth2Config == nil {
    52| 		h.oidcProvider, err = oidc.NewProvider(context.Background(), h.cfg.OIDC.Issuer)
    53| 		if err != nil {
    54| 			return fmt.Errorf("creating OIDC provider from issuer config: %w", err)
    55| 		}
    56| 		h.oauth2Config = &oauth2.Config{
    57| 			ClientID:     h.cfg.OIDC.ClientID,
    58| 			ClientSecret: h.cfg.OIDC.ClientSecret,
    59| 			Endpoint:     h.oidcProvider.Endpoint(),
    60| 			RedirectURL: fmt.Sprintf(
    61| 				"%s/oidc/callback",
    62| 				strings.TrimSuffix(h.cfg.ServerURL, "/"),
    63| 			),
    64| 			Scopes: h.cfg.OIDC.Scope,
    65| 		}
    66| 	}
    67| 	return nil
    68| }
    69| func (h *Headscale) determineTokenExpiration(idTokenExpiration time.Time) time.Time {
    70| 	if h.cfg.OIDC.UseExpiryFromToken {
    71| 		return idTokenExpiration
    72| 	}
    73| 	return time.Now().Add(h.cfg.OIDC.Expiry)
    74| }
    75| func (h *Headscale) RegisterOIDC(
    76| 	writer http.ResponseWriter,
    77| 	req *http.Request,
    78| ) {
    79| 	vars := mux.Vars(req)
    80| 	machineKeyStr, ok := vars["mkey"]
    81| 	log.Debug().
    82| 		Caller().
    83| 		Str("machine_key", machineKeyStr).
    84| 		Bool("ok", ok).
    85| 		Msg("Received oidc register call")
    86| 	var machineKey key.MachinePublic
    87| 	err := machineKey.UnmarshalText(
    88| 		[]byte(machineKeyStr),
    89| 	)
    90| 	if err != nil {
    91| 		log.Warn().
    92| 			Err(err).
    93| 			Msg("Failed to parse incoming nodekey in OIDC registration")
    94| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    95| 		writer.WriteHeader(http.StatusBadRequest)
    96| 		_, err := writer.Write([]byte("Wrong params"))
    97| 		if err != nil {
    98| 			util.LogErr(err, "Failed to write response")
    99| 		}
   100| 		return
   101| 	}
   102| 	randomBlob := make([]byte, randomByteSize)
   103| 	if _, err := rand.Read(randomBlob); err != nil {
   104| 		util.LogErr(err, "could not read 16 bytes from rand")
   105| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   106| 		return
   107| 	}
   108| 	stateStr := hex.EncodeToString(randomBlob)[:32]
   109| 	h.registrationCache.Set(
   110| 		stateStr,
   111| 		machineKey,
   112| 		registerCacheExpiration,
   113| 	)
   114| 	extras := make([]oauth2.AuthCodeOption, 0, len(h.cfg.OIDC.ExtraParams))
   115| 	for k, v := range h.cfg.OIDC.ExtraParams {
   116| 		extras = append(extras, oauth2.SetAuthURLParam(k, v))
   117| 	}
   118| 	authURL := h.oauth2Config.AuthCodeURL(stateStr, extras...)
   119| 	log.Debug().Msgf("Redirecting to %s for authentication", authURL)
   120| 	http.Redirect(writer, req, authURL, http.StatusFound)
   121| }
   122| type oidcCallbackTemplateConfig struct {
   123| 	User string
   124| 	Verb string
   125| }
   126| var oidcCallbackTemplateContent string
   127| var oidcCallbackTemplate = template.Must(
   128| 	template.New("oidccallback").Parse(oidcCallbackTemplateContent),
   129| )
   130| func (h *Headscale) OIDCCallback(
   131| 	writer http.ResponseWriter,
   132| 	req *http.Request,
   133| ) {
   134| 	code, state, err := validateOIDCCallbackParams(writer, req)
   135| 	if err != nil {
   136| 		return
   137| 	}
   138| 	rawIDToken, err := h.getIDTokenForOIDCCallback(req.Context(), writer, code, state)
   139| 	if err != nil {
   140| 		return
   141| 	}
   142| 	idToken, err := h.verifyIDTokenForOIDCCallback(req.Context(), writer, rawIDToken)
   143| 	if err != nil {
   144| 		return
   145| 	}
   146| 	idTokenExpiry := h.determineTokenExpiration(idToken.Expiry)
   147| 	claims, err := extractIDTokenClaims(writer, idToken)
   148| 	if err != nil {
   149| 		return
   150| 	}
   151| 	if err := validateOIDCAllowedDomains(writer, h.cfg.OIDC.AllowedDomains, claims); err != nil {
   152| 		return
   153| 	}
   154| 	if err := validateOIDCAllowedGroups(writer, h.cfg.OIDC.AllowedGroups, claims); err != nil {
   155| 		return
   156| 	}
   157| 	if err := validateOIDCAllowedUsers(writer, h.cfg.OIDC.AllowedUsers, claims); err != nil {
   158| 		return
   159| 	}
   160| 	machineKey, nodeExists, err := h.validateNodeForOIDCCallback(
   161| 		writer,
   162| 		state,
   163| 		claims,
   164| 		idTokenExpiry,
   165| 	)
   166| 	if err != nil || nodeExists {
   167| 		return
   168| 	}
   169| 	userName, err := getUserName(writer, claims, h.cfg.OIDC.StripEmaildomain)
   170| 	if err != nil {
   171| 		return
   172| 	}
   173| 	log.Debug().Msg("Registering new node after successful callback")
   174| 	user, err := h.findOrCreateNewUserForOIDCCallback(writer, userName)
   175| 	if err != nil {
   176| 		return
   177| 	}
   178| 	if err := h.registerNodeForOIDCCallback(writer, user, machineKey, idTokenExpiry); err != nil {
   179| 		return
   180| 	}
   181| 	content, err := renderOIDCCallbackTemplate(writer, claims)
   182| 	if err != nil {
   183| 		return
   184| 	}
   185| 	writer.Header().Set("Content-Type", "text/html; charset=utf-8")
   186| 	writer.WriteHeader(http.StatusOK)
   187| 	if _, err := writer.Write(content.Bytes()); err != nil {
   188| 		util.LogErr(err, "Failed to write response")
   189| 	}
   190| }
   191| func validateOIDCCallbackParams(
   192| 	writer http.ResponseWriter,
   193| 	req *http.Request,
   194| ) (string, string, error) {
   195| 	code := req.URL.Query().Get("code")
   196| 	state := req.URL.Query().Get("state")
   197| 	if code == "" || state == "" {
   198| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   199| 		writer.WriteHeader(http.StatusBadRequest)
   200| 		_, err := writer.Write([]byte("Wrong params"))
   201| 		if err != nil {
   202| 			util.LogErr(err, "Failed to write response")
   203| 		}
   204| 		return "", "", errEmptyOIDCCallbackParams
   205| 	}
   206| 	return code, state, nil
   207| }
   208| func (h *Headscale) getIDTokenForOIDCCallback(
   209| 	ctx context.Context,
   210| 	writer http.ResponseWriter,
   211| 	code, state string,
   212| ) (string, error) {
   213| 	oauth2Token, err := h.oauth2Config.Exchange(ctx, code)
   214| 	if err != nil {
   215| 		util.LogErr(err, "Could not exchange code for token")
   216| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   217| 		writer.WriteHeader(http.StatusBadRequest)
   218| 		_, werr := writer.Write([]byte("Could not exchange code for token"))
   219| 		if werr != nil {
   220| 			util.LogErr(err, "Failed to write response")
   221| 		}
   222| 		return "", err
   223| 	}
   224| 	log.Trace().
   225| 		Caller().
   226| 		Str("code", code).
   227| 		Str("state", state).
   228| 		Msg("Got oidc callback")
   229| 	rawIDToken, rawIDTokenOK := oauth2Token.Extra("id_token").(string)
   230| 	if !rawIDTokenOK {
   231| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   232| 		writer.WriteHeader(http.StatusBadRequest)
   233| 		_, err := writer.Write([]byte("Could not extract ID Token"))
   234| 		if err != nil {
   235| 			util.LogErr(err, "Failed to write response")
   236| 		}
   237| 		return "", errNoOIDCIDToken
   238| 	}
   239| 	return rawIDToken, nil
   240| }
   241| func (h *Headscale) verifyIDTokenForOIDCCallback(
   242| 	ctx context.Context,
   243| 	writer http.ResponseWriter,
   244| 	rawIDToken string,
   245| ) (*oidc.IDToken, error) {
   246| 	verifier := h.oidcProvider.Verifier(&oidc.Config{ClientID: h.cfg.OIDC.ClientID})
   247| 	idToken, err := verifier.Verify(ctx, rawIDToken)
   248| 	if err != nil {
   249| 		util.LogErr(err, "failed to verify id token")
   250| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   251| 		writer.WriteHeader(http.StatusBadRequest)
   252| 		_, werr := writer.Write([]byte("Failed to verify id token"))
   253| 		if werr != nil {
   254| 			util.LogErr(err, "Failed to write response")
   255| 		}
   256| 		return nil, err
   257| 	}
   258| 	return idToken, nil
   259| }
   260| func extractIDTokenClaims(
   261| 	writer http.ResponseWriter,
   262| 	idToken *oidc.IDToken,
   263| ) (*IDTokenClaims, error) {
   264| 	var claims IDTokenClaims
   265| 	if err := idToken.Claims(&claims); err != nil {
   266| 		util.LogErr(err, "Failed to decode id token claims")
   267| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   268| 		writer.WriteHeader(http.StatusBadRequest)
   269| 		_, werr := writer.Write([]byte("Failed to decode id token claims"))
   270| 		if werr != nil {
   271| 			util.LogErr(err, "Failed to write response")
   272| 		}
   273| 		return nil, err
   274| 	}
   275| 	return &claims, nil
   276| }
   277| func validateOIDCAllowedDomains(
   278| 	writer http.ResponseWriter,
   279| 	allowedDomains []string,
   280| 	claims *IDTokenClaims,
   281| ) error {
   282| 	if len(allowedDomains) > 0 {
   283| 		if at := strings.LastIndex(claims.Email, "@"); at < 0 ||
   284| 			!slices.Contains(allowedDomains, claims.Email[at+1:]) {
   285| 			log.Trace().Msg("authenticated principal does not match any allowed domain")
   286| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   287| 			writer.WriteHeader(http.StatusBadRequest)
   288| 			_, err := writer.Write([]byte("unauthorized principal (domain mismatch)"))
   289| 			if err != nil {
   290| 				util.LogErr(err, "Failed to write response")
   291| 			}
   292| 			return errOIDCAllowedDomains
   293| 		}
   294| 	}
   295| 	return nil
   296| }
   297| func validateOIDCAllowedGroups(
   298| 	writer http.ResponseWriter,
   299| 	allowedGroups []string,
   300| 	claims *IDTokenClaims,
   301| ) error {
   302| 	if len(allowedGroups) > 0 {
   303| 		for _, group := range allowedGroups {
   304| 			if slices.Contains(claims.Groups, group) {
   305| 				return nil
   306| 			}
   307| 		}
   308| 		log.Trace().Msg("authenticated principal not in any allowed groups")
   309| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   310| 		writer.WriteHeader(http.StatusBadRequest)
   311| 		_, err := writer.Write([]byte("unauthorized principal (allowed groups)"))
   312| 		if err != nil {
   313| 			util.LogErr(err, "Failed to write response")
   314| 		}
   315| 		return errOIDCAllowedGroups
   316| 	}
   317| 	return nil
   318| }
   319| func validateOIDCAllowedUsers(
   320| 	writer http.ResponseWriter,
   321| 	allowedUsers []string,
   322| 	claims *IDTokenClaims,
   323| ) error {
   324| 	if len(allowedUsers) > 0 &&
   325| 		!slices.Contains(allowedUsers, claims.Email) {
   326| 		log.Trace().Msg("authenticated principal does not match any allowed user")
   327| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   328| 		writer.WriteHeader(http.StatusBadRequest)
   329| 		_, err := writer.Write([]byte("unauthorized principal (user mismatch)"))
   330| 		if err != nil {
   331| 			util.LogErr(err, "Failed to write response")
   332| 		}
   333| 		return errOIDCAllowedUsers
   334| 	}
   335| 	return nil
   336| }
   337| func (h *Headscale) validateNodeForOIDCCallback(
   338| 	writer http.ResponseWriter,
   339| 	state string,
   340| 	claims *IDTokenClaims,
   341| 	expiry time.Time,
   342| ) (*key.MachinePublic, bool, error) {
   343| 	machineKeyIf, machineKeyFound := h.registrationCache.Get(state)
   344| 	if !machineKeyFound {
   345| 		log.Trace().
   346| 			Msg("requested node state key expired before authorisation completed")
   347| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   348| 		writer.WriteHeader(http.StatusBadRequest)
   349| 		_, err := writer.Write([]byte("state has expired"))
   350| 		if err != nil {
   351| 			util.LogErr(err, "Failed to write response")
   352| 		}
   353| 		return nil, false, errOIDCNodeKeyMissing
   354| 	}
   355| 	var machineKey key.MachinePublic
   356| 	machineKey, machineKeyOK := machineKeyIf.(key.MachinePublic)
   357| 	if !machineKeyOK {
   358| 		log.Trace().
   359| 			Interface("got", machineKeyIf).
   360| 			Msg("requested node state key is not a nodekey")
   361| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   362| 		writer.WriteHeader(http.StatusBadRequest)
   363| 		_, err := writer.Write([]byte("state is invalid"))
   364| 		if err != nil {
   365| 			util.LogErr(err, "Failed to write response")
   366| 		}
   367| 		return nil, false, errOIDCInvalidNodeState
   368| 	}
   369| 	node, _ := h.db.GetNodeByMachineKey(machineKey)
   370| 	if node != nil {
   371| 		log.Trace().
   372| 			Caller().
   373| 			Str("node", node.Hostname).
   374| 			Msg("node already registered, reauthenticating")
   375| 		err := h.db.NodeSetExpiry(node.ID, expiry)
   376| 		if err != nil {
   377| 			util.LogErr(err, "Failed to refresh node")
   378| 			http.Error(
   379| 				writer,
   380| 				"Failed to refresh node",
   381| 				http.StatusInternalServerError,
   382| 			)
   383| 			return nil, true, err
   384| 		}
   385| 		log.Debug().
   386| 			Str("node", node.Hostname).
   387| 			Str("expiresAt", fmt.Sprintf("%v", expiry)).
   388| 			Msg("successfully refreshed node")
   389| 		var content bytes.Buffer
   390| 		if err := oidcCallbackTemplate.Execute(&content, oidcCallbackTemplateConfig{
   391| 			User: claims.Email,
   392| 			Verb: "Reauthenticated",
   393| 		}); err != nil {
   394| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   395| 			writer.WriteHeader(http.StatusInternalServerError)
   396| 			_, werr := writer.Write([]byte("Could not render OIDC callback template"))
   397| 			if werr != nil {
   398| 				util.LogErr(err, "Failed to write response")
   399| 			}
   400| 			return nil, true, fmt.Errorf("rendering OIDC callback template: %w", err)
   401| 		}
   402| 		writer.Header().Set("Content-Type", "text/html; charset=utf-8")
   403| 		writer.WriteHeader(http.StatusOK)
   404| 		_, err = writer.Write(content.Bytes())
   405| 		if err != nil {
   406| 			util.LogErr(err, "Failed to write response")
   407| 		}
   408| 		ctx := types.NotifyCtx(context.Background(), "oidc-expiry-self", node.Hostname)
   409| 		h.nodeNotifier.NotifyByNodeID(
   410| 			ctx,
   411| 			types.StateUpdate{
   412| 				Type:        types.StateSelfUpdate,
   413| 				ChangeNodes: []types.NodeID{node.ID},
   414| 			},
   415| 			node.ID,
   416| 		)
   417| 		ctx = types.NotifyCtx(context.Background(), "oidc-expiry-peers", node.Hostname)
   418| 		h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdateExpire(node.ID, expiry), node.ID)
   419| 		return nil, true, nil
   420| 	}
   421| 	return &machineKey, false, nil
   422| }
   423| func getUserName(
   424| 	writer http.ResponseWriter,
   425| 	claims *IDTokenClaims,
   426| 	stripEmaildomain bool,
   427| ) (string, error) {
   428| 	userName, err := util.NormalizeToFQDNRules(
   429| 		claims.Email,
   430| 		stripEmaildomain,
   431| 	)
   432| 	if err != nil {
   433| 		util.LogErr(err, "couldn't normalize email")
   434| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   435| 		writer.WriteHeader(http.StatusInternalServerError)
   436| 		_, werr := writer.Write([]byte("couldn't normalize email"))
   437| 		if werr != nil {
   438| 			util.LogErr(err, "Failed to write response")
   439| 		}
   440| 		return "", err
   441| 	}
   442| 	return userName, nil
   443| }
   444| func (h *Headscale) findOrCreateNewUserForOIDCCallback(
   445| 	writer http.ResponseWriter,
   446| 	userName string,
   447| ) (*types.User, error) {
   448| 	user, err := h.db.GetUser(userName)
   449| 	if errors.Is(err, db.ErrUserNotFound) {
   450| 		user, err = h.db.CreateUser(userName)
   451| 		if err != nil {
   452| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   453| 			writer.WriteHeader(http.StatusInternalServerError)
   454| 			_, werr := writer.Write([]byte("could not create user"))
   455| 			if werr != nil {
   456| 				util.LogErr(err, "Failed to write response")
   457| 			}
   458| 			return nil, fmt.Errorf("creating new user: %w", err)
   459| 		}
   460| 	} else if err != nil {
   461| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   462| 		writer.WriteHeader(http.StatusInternalServerError)
   463| 		_, werr := writer.Write([]byte("could not find or create user"))
   464| 		if werr != nil {
   465| 			util.LogErr(err, "Failed to write response")
   466| 		}
   467| 		return nil, fmt.Errorf("find or create user: %w", err)
   468| 	}
   469| 	return user, nil
   470| }
   471| func (h *Headscale) registerNodeForOIDCCallback(
   472| 	writer http.ResponseWriter,
   473| 	user *types.User,
   474| 	machineKey *key.MachinePublic,
   475| 	expiry time.Time,
   476| ) error {
   477| 	ipv4, ipv6, err := h.ipAlloc.Next()
   478| 	if err != nil {
   479| 		return err
   480| 	}
   481| 	if err := h.db.Write(func(tx *gorm.DB) error {
   482| 		if _, err := db.RegisterNodeFromAuthCallback(
   483| 			tx,
   484| 			h.registrationCache,
   485| 			*machineKey,
   486| 			user.Name,
   487| 			&expiry,
   488| 			util.RegisterMethodOIDC,
   489| 			ipv4, ipv6,
   490| 		); err != nil {
   491| 			return err
   492| 		}
   493| 		return nil
   494| 	}); err != nil {
   495| 		util.LogErr(err, "could not register node")
   496| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   497| 		writer.WriteHeader(http.StatusInternalServerError)
   498| 		_, werr := writer.Write([]byte("could not register node"))
   499| 		if werr != nil {
   500| 			util.LogErr(err, "Failed to write response")
   501| 		}
   502| 		return err
   503| 	}
   504| 	return nil
   505| }
   506| func renderOIDCCallbackTemplate(
   507| 	writer http.ResponseWriter,
   508| 	claims *IDTokenClaims,
   509| ) (*bytes.Buffer, error) {
   510| 	var content bytes.Buffer
   511| 	if err := oidcCallbackTemplate.Execute(&content, oidcCallbackTemplateConfig{
   512| 		User: claims.Email,
   513| 		Verb: "Authenticated",
   514| 	}); err != nil {
   515| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   516| 		writer.WriteHeader(http.StatusInternalServerError)
   517| 		_, werr := writer.Write([]byte("Could not render OIDC callback template"))
   518| 		if werr != nil {
   519| 			util.LogErr(err, "Failed to write response")
   520| 		}
   521| 		return nil, fmt.Errorf("rendering OIDC callback template: %w", err)
   522| 	}
   523| 	return &content, nil
   524| }


# ====================================================================
# FILE: hscontrol/platform_config.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 29-68 ---
    29| 		writer.WriteHeader(http.StatusInternalServerError)
    30| 		_, err := writer.Write([]byte("Could not render Windows index template"))
    31| 		if err != nil {
    32| 			log.Error().
    33| 				Caller().
    34| 				Err(err).
    35| 				Msg("Failed to write response")
    36| 		}
    37| 		return
    38| 	}
    39| 	writer.Header().Set("Content-Type", "text/html; charset=utf-8")
    40| 	writer.WriteHeader(http.StatusOK)
    41| 	_, err := writer.Write(payload.Bytes())
    42| 	if err != nil {
    43| 		log.Error().
    44| 			Caller().
    45| 			Err(err).
    46| 			Msg("Failed to write response")
    47| 	}
    48| }
    49| func (h *Headscale) AppleConfigMessage(
    50| 	writer http.ResponseWriter,
    51| 	req *http.Request,
    52| ) {
    53| 	appleTemplate := template.Must(template.New("apple").Parse(appleTemplate))
    54| 	config := map[string]interface{}{
    55| 		"URL": h.cfg.ServerURL,
    56| 	}
    57| 	var payload bytes.Buffer
    58| 	if err := appleTemplate.Execute(&payload, config); err != nil {
    59| 		log.Error().
    60| 			Str("handler", "AppleMobileConfig").
    61| 			Err(err).
    62| 			Msg("Could not render Apple index template")
    63| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    64| 		writer.WriteHeader(http.StatusInternalServerError)
    65| 		_, err := writer.Write([]byte("Could not render Apple index template"))
    66| 		if err != nil {
    67| 			log.Error().
    68| 				Caller().

# --- HUNK 2: Lines 206-254 ---
   206| 		_, err := writer.Write([]byte("Could not render Apple platform template"))
   207| 		if err != nil {
   208| 			log.Error().
   209| 				Caller().
   210| 				Err(err).
   211| 				Msg("Failed to write response")
   212| 		}
   213| 		return
   214| 	}
   215| 	writer.Header().
   216| 		Set("Content-Type", "application/x-apple-aspen-config; charset=utf-8")
   217| 	writer.WriteHeader(http.StatusOK)
   218| 	_, err = writer.Write(content.Bytes())
   219| 	if err != nil {
   220| 		log.Error().
   221| 			Caller().
   222| 			Err(err).
   223| 			Msg("Failed to write response")
   224| 	}
   225| }
   226| type AppleMobileConfig struct {
   227| 	UUID    uuid.UUID
   228| 	URL     string
   229| 	Payload string
   230| }
   231| type AppleMobilePlatformConfig struct {
   232| 	UUID uuid.UUID
   233| 	URL  string
   234| }
   235| var commonTemplate = textTemplate.Must(
   236| 	textTemplate.New("mobileconfig").Parse(`<?xml version="1.0" encoding="UTF-8"?>
   237| <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
   238| <plist version="1.0">
   239|   <dict>
   240|     <key>PayloadUUID</key>
   241|     <string>{{.UUID}}</string>
   242|     <key>PayloadDisplayName</key>
   243|     <string>Headscale</string>
   244|     <key>PayloadDescription</key>
   245|     <string>Configure Tailscale login server to: {{.URL}}</string>
   246|     <key>PayloadIdentifier</key>
   247|     <string>com.github.juanfont.headscale</string>
   248|     <key>PayloadRemovalDisallowed</key>
   249|     <false/>
   250|     <key>PayloadType</key>
   251|     <string>Configuration</string>
   252|     <key>PayloadVersion</key>
   253|     <integer>1</integer>
   254|     <key>PayloadContent</key>


# ====================================================================
# FILE: hscontrol/policy/acls.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-770 ---
     1| package policy
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"fmt"
     6| 	"io"
     7| 	"net/netip"
     8| 	"os"
     9| 	"strconv"
    10| 	"strings"
    11| 	"time"
    12| 	"github.com/juanfont/headscale/hscontrol/types"
    13| 	"github.com/juanfont/headscale/hscontrol/util"
    14| 	"github.com/rs/zerolog/log"
    15| 	"github.com/tailscale/hujson"
    16| 	"go4.org/netipx"
    17| 	"tailscale.com/tailcfg"
    18| )
    19| var (
    20| 	ErrEmptyPolicy       = errors.New("empty policy")
    21| 	ErrInvalidAction     = errors.New("invalid action")
    22| 	ErrInvalidGroup      = errors.New("invalid group")
    23| 	ErrInvalidTag        = errors.New("invalid tag")
    24| 	ErrInvalidPortFormat = errors.New("invalid port format")
    25| 	ErrWildcardIsNeeded  = errors.New("wildcard as port is required for the protocol")
    26| )
    27| const (
    28| 	portRangeBegin     = 0
    29| 	portRangeEnd       = 65535
    30| 	expectedTokenItems = 2
    31| )
    32| var theInternetSet *netipx.IPSet
    33| func theInternet() *netipx.IPSet {
    34| 	if theInternetSet != nil {
    35| 		return theInternetSet
    36| 	}
    37| 	var internetBuilder netipx.IPSetBuilder
    38| 	internetBuilder.AddPrefix(netip.MustParsePrefix("2000::/3"))
    39| 	internetBuilder.AddPrefix(netip.MustParsePrefix("0.0.0.0/0"))
    40| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("fc00::/7"))
    41| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("10.0.0.0/8"))
    42| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("172.16.0.0/12"))
    43| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("192.168.0.0/16"))
    44| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("fd7a:115c:a1e0::/48"))
    45| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("100.64.0.0/10"))
    46| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("fe80::/10")) // link-loca
    47| 	internetBuilder.RemovePrefix(netip.MustParsePrefix("169.254.0.0/16"))
    48| 	theInternetSet, _ := internetBuilder.IPSet()
    49| 	return theInternetSet
    50| }
    51| const (
    52| 	protocolICMP     = 1   // Internet Control Message
    53| 	protocolIGMP     = 2   // Internet Group Management
    54| 	protocolIPv4     = 4   // IPv4 encapsulation
    55| 	protocolTCP      = 6   // Transmission Control
    56| 	protocolEGP      = 8   // Exterior Gateway Protocol
    57| 	protocolIGP      = 9   // any private interior gateway (used by Cisco for their IGRP)
    58| 	protocolUDP      = 17  // User Datagram
    59| 	protocolGRE      = 47  // Generic Routing Encapsulation
    60| 	protocolESP      = 50  // Encap Security Payload
    61| 	protocolAH       = 51  // Authentication Header
    62| 	protocolIPv6ICMP = 58  // ICMP for IPv6
    63| 	protocolSCTP     = 132 // Stream Control Transmission Protocol
    64| 	ProtocolFC       = 133 // Fibre Channel
    65| )
    66| func LoadACLPolicyFromPath(path string) (*ACLPolicy, error) {
    67| 	log.Debug().
    68| 		Str("func", "LoadACLPolicy").
    69| 		Str("path", path).
    70| 		Msg("Loading ACL policy from path")
    71| 	policyFile, err := os.Open(path)
    72| 	if err != nil {
    73| 		return nil, err
    74| 	}
    75| 	defer policyFile.Close()
    76| 	policyBytes, err := io.ReadAll(policyFile)
    77| 	if err != nil {
    78| 		return nil, err
    79| 	}
    80| 	log.Debug().
    81| 		Str("path", path).
    82| 		Bytes("file", policyBytes).
    83| 		Msg("Loading ACLs")
    84| 	return LoadACLPolicyFromBytes(policyBytes)
    85| }
    86| func LoadACLPolicyFromBytes(acl []byte) (*ACLPolicy, error) {
    87| 	var policy ACLPolicy
    88| 	ast, err := hujson.Parse(acl)
    89| 	if err != nil {
    90| 		return nil, fmt.Errorf("parsing hujson, err: %w", err)
    91| 	}
    92| 	ast.Standardize()
    93| 	acl = ast.Pack()
    94| 	if err := json.Unmarshal(acl, &policy); err != nil {
    95| 		return nil, fmt.Errorf("unmarshalling policy, err: %w", err)
    96| 	}
    97| 	if policy.IsZero() {
    98| 		return nil, ErrEmptyPolicy
    99| 	}
   100| 	return &policy, nil
   101| }
   102| func GenerateFilterAndSSHRulesForTests(
   103| 	policy *ACLPolicy,
   104| 	node *types.Node,
   105| 	peers types.Nodes,
   106| ) ([]tailcfg.FilterRule, *tailcfg.SSHPolicy, error) {
   107| 	if policy == nil {
   108| 		return tailcfg.FilterAllowAll, &tailcfg.SSHPolicy{}, nil
   109| 	}
   110| 	rules, err := policy.CompileFilterRules(append(peers, node))
   111| 	if err != nil {
   112| 		return []tailcfg.FilterRule{}, &tailcfg.SSHPolicy{}, err
   113| 	}
   114| 	log.Trace().Interface("ACL", rules).Str("node", node.GivenName).Msg("ACL rules")
   115| 	sshPolicy, err := policy.CompileSSHPolicy(node, peers)
   116| 	if err != nil {
   117| 		return []tailcfg.FilterRule{}, &tailcfg.SSHPolicy{}, err
   118| 	}
   119| 	return rules, sshPolicy, nil
   120| }
   121| func (pol *ACLPolicy) CompileFilterRules(
   122| 	nodes types.Nodes,
   123| ) ([]tailcfg.FilterRule, error) {
   124| 	if pol == nil {
   125| 		return tailcfg.FilterAllowAll, nil
   126| 	}
   127| 	var rules []tailcfg.FilterRule
   128| 	for index, acl := range pol.ACLs {
   129| 		if acl.Action != "accept" {
   130| 			return nil, ErrInvalidAction
   131| 		}
   132| 		var srcIPs []string
   133| 		for srcIndex, src := range acl.Sources {
   134| 			srcs, err := pol.expandSource(src, nodes)
   135| 			if err != nil {
   136| 				return nil, fmt.Errorf("parsing policy, acl index: %d->%d: %w", index, srcIndex, err)
   137| 			}
   138| 			srcIPs = append(srcIPs, srcs...)
   139| 		}
   140| 		protocols, isWildcard, err := parseProtocol(acl.Protocol)
   141| 		if err != nil {
   142| 			return nil, fmt.Errorf("parsing policy, protocol err: %w ", err)
   143| 		}
   144| 		destPorts := []tailcfg.NetPortRange{}
   145| 		for _, dest := range acl.Destinations {
   146| 			alias, port, err := parseDestination(dest)
   147| 			if err != nil {
   148| 				return nil, err
   149| 			}
   150| 			expanded, err := pol.ExpandAlias(
   151| 				nodes,
   152| 				alias,
   153| 			)
   154| 			if err != nil {
   155| 				return nil, err
   156| 			}
   157| 			ports, err := expandPorts(port, isWildcard)
   158| 			if err != nil {
   159| 				return nil, err
   160| 			}
   161| 			var dests []tailcfg.NetPortRange
   162| 			for _, dest := range expanded.Prefixes() {
   163| 				for _, port := range *ports {
   164| 					pr := tailcfg.NetPortRange{
   165| 						IP:    dest.String(),
   166| 						Ports: port,
   167| 					}
   168| 					dests = append(dests, pr)
   169| 				}
   170| 			}
   171| 			destPorts = append(destPorts, dests...)
   172| 		}
   173| 		rules = append(rules, tailcfg.FilterRule{
   174| 			SrcIPs:   srcIPs,
   175| 			DstPorts: destPorts,
   176| 			IPProto:  protocols,
   177| 		})
   178| 	}
   179| 	return rules, nil
   180| }
   181| func ReduceFilterRules(node *types.Node, rules []tailcfg.FilterRule) []tailcfg.FilterRule {
   182| 	ret := []tailcfg.FilterRule{}
   183| 	for _, rule := range rules {
   184| 		var dests []tailcfg.NetPortRange
   185| 	DEST_LOOP:
   186| 		for _, dest := range rule.DstPorts {
   187| 			expanded, err := util.ParseIPSet(dest.IP, nil)
   188| 			if err != nil {
   189| 				continue DEST_LOOP
   190| 			}
   191| 			if node.InIPSet(expanded) {
   192| 				dests = append(dests, dest)
   193| 				continue DEST_LOOP
   194| 			}
   195| 			if node.Hostinfo != nil {
   196| 				if len(node.Hostinfo.RoutableIPs) > 0 {
   197| 					for _, routableIP := range node.Hostinfo.RoutableIPs {
   198| 						if expanded.OverlapsPrefix(routableIP) {
   199| 							dests = append(dests, dest)
   200| 							continue DEST_LOOP
   201| 						}
   202| 					}
   203| 				}
   204| 			}
   205| 		}
   206| 		if len(dests) > 0 {
   207| 			ret = append(ret, tailcfg.FilterRule{
   208| 				SrcIPs:   rule.SrcIPs,
   209| 				DstPorts: dests,
   210| 				IPProto:  rule.IPProto,
   211| 			})
   212| 		}
   213| 	}
   214| 	return ret
   215| }
   216| func (pol *ACLPolicy) CompileSSHPolicy(
   217| 	node *types.Node,
   218| 	peers types.Nodes,
   219| ) (*tailcfg.SSHPolicy, error) {
   220| 	if pol == nil {
   221| 		return nil, nil
   222| 	}
   223| 	var rules []*tailcfg.SSHRule
   224| 	acceptAction := tailcfg.SSHAction{
   225| 		Message:                  "",
   226| 		Reject:                   false,
   227| 		Accept:                   true,
   228| 		SessionDuration:          0,
   229| 		AllowAgentForwarding:     false,
   230| 		HoldAndDelegate:          "",
   231| 		AllowLocalPortForwarding: true,
   232| 	}
   233| 	rejectAction := tailcfg.SSHAction{
   234| 		Message:                  "",
   235| 		Reject:                   true,
   236| 		Accept:                   false,
   237| 		SessionDuration:          0,
   238| 		AllowAgentForwarding:     false,
   239| 		HoldAndDelegate:          "",
   240| 		AllowLocalPortForwarding: false,
   241| 	}
   242| 	for index, sshACL := range pol.SSHs {
   243| 		var dest netipx.IPSetBuilder
   244| 		for _, src := range sshACL.Destinations {
   245| 			expanded, err := pol.ExpandAlias(append(peers, node), src)
   246| 			if err != nil {
   247| 				return nil, err
   248| 			}
   249| 			dest.AddSet(expanded)
   250| 		}
   251| 		destSet, err := dest.IPSet()
   252| 		if err != nil {
   253| 			return nil, err
   254| 		}
   255| 		if !node.InIPSet(destSet) {
   256| 			continue
   257| 		}
   258| 		action := rejectAction
   259| 		switch sshACL.Action {
   260| 		case "accept":
   261| 			action = acceptAction
   262| 		case "check":
   263| 			checkAction, err := sshCheckAction(sshACL.CheckPeriod)
   264| 			if err != nil {
   265| 				return nil, fmt.Errorf("parsing SSH policy, parsing check duration, index: %d: %w", index, err)
   266| 			} else {
   267| 				action = *checkAction
   268| 			}
   269| 		default:
   270| 			return nil, fmt.Errorf("parsing SSH policy, unknown action %q, index: %d: %w", sshACL.Action, index, err)
   271| 		}
   272| 		principals := make([]*tailcfg.SSHPrincipal, 0, len(sshACL.Sources))
   273| 		for innerIndex, rawSrc := range sshACL.Sources {
   274| 			if isWildcard(rawSrc) {
   275| 				principals = append(principals, &tailcfg.SSHPrincipal{
   276| 					Any: true,
   277| 				})
   278| 			} else if isGroup(rawSrc) {
   279| 				users, err := pol.expandUsersFromGroup(rawSrc)
   280| 				if err != nil {
   281| 					return nil, fmt.Errorf("parsing SSH policy, expanding user from group, index: %d->%d: %w", index, innerIndex, err)
   282| 				}
   283| 				for _, user := range users {
   284| 					principals = append(principals, &tailcfg.SSHPrincipal{
   285| 						UserLogin: user,
   286| 					})
   287| 				}
   288| 			} else {
   289| 				expandedSrcs, err := pol.ExpandAlias(
   290| 					peers,
   291| 					rawSrc,
   292| 				)
   293| 				if err != nil {
   294| 					return nil, fmt.Errorf("parsing SSH policy, expanding alias, index: %d->%d: %w", index, innerIndex, err)
   295| 				}
   296| 				for _, expandedSrc := range expandedSrcs.Prefixes() {
   297| 					principals = append(principals, &tailcfg.SSHPrincipal{
   298| 						NodeIP: expandedSrc.Addr().String(),
   299| 					})
   300| 				}
   301| 			}
   302| 		}
   303| 		userMap := make(map[string]string, len(sshACL.Users))
   304| 		for _, user := range sshACL.Users {
   305| 			userMap[user] = "="
   306| 		}
   307| 		rules = append(rules, &tailcfg.SSHRule{
   308| 			Principals: principals,
   309| 			SSHUsers:   userMap,
   310| 			Action:     &action,
   311| 		})
   312| 	}
   313| 	return &tailcfg.SSHPolicy{
   314| 		Rules: rules,
   315| 	}, nil
   316| }
   317| func sshCheckAction(duration string) (*tailcfg.SSHAction, error) {
   318| 	sessionLength, err := time.ParseDuration(duration)
   319| 	if err != nil {
   320| 		return nil, err
   321| 	}
   322| 	return &tailcfg.SSHAction{
   323| 		Message:                  "",
   324| 		Reject:                   false,
   325| 		Accept:                   true,
   326| 		SessionDuration:          sessionLength,
   327| 		AllowAgentForwarding:     false,
   328| 		HoldAndDelegate:          "",
   329| 		AllowLocalPortForwarding: true,
   330| 	}, nil
   331| }
   332| func parseDestination(dest string) (string, string, error) {
   333| 	var tokens []string
   334| 	tokens = strings.Split(dest, ":")
   335| 	if len(tokens) < expectedTokenItems || len(tokens) > 3 {
   336| 		port := tokens[len(tokens)-1]
   337| 		maybeIPv6Str := strings.TrimSuffix(dest, ":"+port)
   338| 		log.Trace().Str("maybeIPv6Str", maybeIPv6Str).Msg("")
   339| 		filteredMaybeIPv6Str := maybeIPv6Str
   340| 		if strings.Contains(maybeIPv6Str, "/") {
   341| 			networkParts := strings.Split(maybeIPv6Str, "/")
   342| 			filteredMaybeIPv6Str = networkParts[0]
   343| 		}
   344| 		if maybeIPv6, err := netip.ParseAddr(filteredMaybeIPv6Str); err != nil && !maybeIPv6.Is6() {
   345| 			log.Trace().Err(err).Msg("trying to parse as IPv6")
   346| 			return "", "", fmt.Errorf(
   347| 				"failed to parse destination, tokens %v: %w",
   348| 				tokens,
   349| 				ErrInvalidPortFormat,
   350| 			)
   351| 		} else {
   352| 			tokens = []string{maybeIPv6Str, port}
   353| 		}
   354| 	}
   355| 	var alias string
   356| 	if len(tokens) == expectedTokenItems {
   357| 		alias = tokens[0]
   358| 	} else {
   359| 		alias = fmt.Sprintf("%s:%s", tokens[0], tokens[1])
   360| 	}
   361| 	return alias, tokens[len(tokens)-1], nil
   362| }
   363| func parseProtocol(protocol string) ([]int, bool, error) {
   364| 	switch protocol {
   365| 	case "":
   366| 		return nil, false, nil
   367| 	case "igmp":
   368| 		return []int{protocolIGMP}, true, nil
   369| 	case "ipv4", "ip-in-ip":
   370| 		return []int{protocolIPv4}, true, nil
   371| 	case "tcp":
   372| 		return []int{protocolTCP}, false, nil
   373| 	case "egp":
   374| 		return []int{protocolEGP}, true, nil
   375| 	case "igp":
   376| 		return []int{protocolIGP}, true, nil
   377| 	case "udp":
   378| 		return []int{protocolUDP}, false, nil
   379| 	case "gre":
   380| 		return []int{protocolGRE}, true, nil
   381| 	case "esp":
   382| 		return []int{protocolESP}, true, nil
   383| 	case "ah":
   384| 		return []int{protocolAH}, true, nil
   385| 	case "sctp":
   386| 		return []int{protocolSCTP}, false, nil
   387| 	case "icmp":
   388| 		return []int{protocolICMP, protocolIPv6ICMP}, true, nil
   389| 	default:
   390| 		protocolNumber, err := strconv.Atoi(protocol)
   391| 		if err != nil {
   392| 			return nil, false, fmt.Errorf("parsing protocol number: %w", err)
   393| 		}
   394| 		needsWildcard := protocolNumber != protocolTCP &&
   395| 			protocolNumber != protocolUDP &&
   396| 			protocolNumber != protocolSCTP
   397| 		return []int{protocolNumber}, needsWildcard, nil
   398| 	}
   399| }
   400| func (pol *ACLPolicy) expandSource(
   401| 	src string,
   402| 	nodes types.Nodes,
   403| ) ([]string, error) {
   404| 	ipSet, err := pol.ExpandAlias(nodes, src)
   405| 	if err != nil {
   406| 		return []string{}, err
   407| 	}
   408| 	var prefixes []string
   409| 	for _, prefix := range ipSet.Prefixes() {
   410| 		prefixes = append(prefixes, prefix.String())
   411| 	}
   412| 	return prefixes, nil
   413| }
   414| func (pol *ACLPolicy) ExpandAlias(
   415| 	nodes types.Nodes,
   416| 	alias string,
   417| ) (*netipx.IPSet, error) {
   418| 	if isWildcard(alias) {
   419| 		return util.ParseIPSet("*", nil)
   420| 	}
   421| 	build := netipx.IPSetBuilder{}
   422| 	log.Debug().
   423| 		Str("alias", alias).
   424| 		Msg("Expanding")
   425| 	if isGroup(alias) {
   426| 		return pol.expandIPsFromGroup(alias, nodes)
   427| 	}
   428| 	if isTag(alias) {
   429| 		return pol.expandIPsFromTag(alias, nodes)
   430| 	}
   431| 	if isAutoGroup(alias) {
   432| 		return expandAutoGroup(alias)
   433| 	}
   434| 	if ips, err := pol.expandIPsFromUser(alias, nodes); ips != nil {
   435| 		return ips, err
   436| 	}
   437| 	if h, ok := pol.Hosts[alias]; ok {
   438| 		log.Trace().Str("host", h.String()).Msg("ExpandAlias got hosts entry")
   439| 		return pol.ExpandAlias(nodes, h.String())
   440| 	}
   441| 	if ip, err := netip.ParseAddr(alias); err == nil {
   442| 		return pol.expandIPsFromSingleIP(ip, nodes)
   443| 	}
   444| 	if prefix, err := netip.ParsePrefix(alias); err == nil {
   445| 		return pol.expandIPsFromIPPrefix(prefix, nodes)
   446| 	}
   447| 	log.Warn().Msgf("No IPs found with the alias %v", alias)
   448| 	return build.IPSet()
   449| }
   450| func excludeCorrectlyTaggedNodes(
   451| 	aclPolicy *ACLPolicy,
   452| 	nodes types.Nodes,
   453| 	user string,
   454| ) types.Nodes {
   455| 	var out types.Nodes
   456| 	var tags []string
   457| 	for tag := range aclPolicy.TagOwners {
   458| 		owners, _ := expandOwnersFromTag(aclPolicy, user)
   459| 		ns := append(owners, user)
   460| 		if util.StringOrPrefixListContains(ns, user) {
   461| 			tags = append(tags, tag)
   462| 		}
   463| 	}
   464| 	for _, node := range nodes {
   465| 		found := false
   466| 		if node.Hostinfo == nil {
   467| 			continue
   468| 		}
   469| 		for _, t := range node.Hostinfo.RequestTags {
   470| 			if util.StringOrPrefixListContains(tags, t) {
   471| 				found = true
   472| 				break
   473| 			}
   474| 		}
   475| 		if len(node.ForcedTags) > 0 {
   476| 			found = true
   477| 		}
   478| 		if !found {
   479| 			out = append(out, node)
   480| 		}
   481| 	}
   482| 	return out
   483| }
   484| func expandPorts(portsStr string, isWild bool) (*[]tailcfg.PortRange, error) {
   485| 	if isWildcard(portsStr) {
   486| 		return &[]tailcfg.PortRange{
   487| 			{First: portRangeBegin, Last: portRangeEnd},
   488| 		}, nil
   489| 	}
   490| 	if isWild {
   491| 		return nil, ErrWildcardIsNeeded
   492| 	}
   493| 	var ports []tailcfg.PortRange
   494| 	for _, portStr := range strings.Split(portsStr, ",") {
   495| 		log.Trace().Msgf("parsing portstring: %s", portStr)
   496| 		rang := strings.Split(portStr, "-")
   497| 		switch len(rang) {
   498| 		case 1:
   499| 			port, err := strconv.ParseUint(rang[0], util.Base10, util.BitSize16)
   500| 			if err != nil {
   501| 				return nil, err
   502| 			}
   503| 			ports = append(ports, tailcfg.PortRange{
   504| 				First: uint16(port),
   505| 				Last:  uint16(port),
   506| 			})
   507| 		case expectedTokenItems:
   508| 			start, err := strconv.ParseUint(rang[0], util.Base10, util.BitSize16)
   509| 			if err != nil {
   510| 				return nil, err
   511| 			}
   512| 			last, err := strconv.ParseUint(rang[1], util.Base10, util.BitSize16)
   513| 			if err != nil {
   514| 				return nil, err
   515| 			}
   516| 			ports = append(ports, tailcfg.PortRange{
   517| 				First: uint16(start),
   518| 				Last:  uint16(last),
   519| 			})
   520| 		default:
   521| 			return nil, ErrInvalidPortFormat
   522| 		}
   523| 	}
   524| 	return &ports, nil
   525| }
   526| func expandOwnersFromTag(
   527| 	pol *ACLPolicy,
   528| 	tag string,
   529| ) ([]string, error) {
   530| 	noTagErr := fmt.Errorf(
   531| 		"%w. %v isn't owned by a TagOwner. Please add one first. https://tailscale.com/kb/1018/acls/#tag-owners",
   532| 		ErrInvalidTag,
   533| 		tag,
   534| 	)
   535| 	if pol == nil {
   536| 		return []string{}, noTagErr
   537| 	}
   538| 	var owners []string
   539| 	ows, ok := pol.TagOwners[tag]
   540| 	if !ok {
   541| 		return []string{}, noTagErr
   542| 	}
   543| 	for _, owner := range ows {
   544| 		if isGroup(owner) {
   545| 			gs, err := pol.expandUsersFromGroup(owner)
   546| 			if err != nil {
   547| 				return []string{}, err
   548| 			}
   549| 			owners = append(owners, gs...)
   550| 		} else {
   551| 			owners = append(owners, owner)
   552| 		}
   553| 	}
   554| 	return owners, nil
   555| }
   556| func (pol *ACLPolicy) expandUsersFromGroup(
   557| 	group string,
   558| ) ([]string, error) {
   559| 	var users []string
   560| 	log.Trace().Caller().Interface("pol", pol).Msg("test")
   561| 	aclGroups, ok := pol.Groups[group]
   562| 	if !ok {
   563| 		return []string{}, fmt.Errorf(
   564| 			"group %v isn't registered. %w",
   565| 			group,
   566| 			ErrInvalidGroup,
   567| 		)
   568| 	}
   569| 	for _, group := range aclGroups {
   570| 		if isGroup(group) {
   571| 			return []string{}, fmt.Errorf(
   572| 				"%w. A group cannot be composed of groups. https://tailscale.com/kb/1018/acls/#groups",
   573| 				ErrInvalidGroup,
   574| 			)
   575| 		}
   576| 		grp, err := util.NormalizeToFQDNRulesConfigFromViper(group)
   577| 		if err != nil {
   578| 			return []string{}, fmt.Errorf(
   579| 				"failed to normalize group %q, err: %w",
   580| 				group,
   581| 				ErrInvalidGroup,
   582| 			)
   583| 		}
   584| 		users = append(users, grp)
   585| 	}
   586| 	return users, nil
   587| }
   588| func (pol *ACLPolicy) expandIPsFromGroup(
   589| 	group string,
   590| 	nodes types.Nodes,
   591| ) (*netipx.IPSet, error) {
   592| 	var build netipx.IPSetBuilder
   593| 	users, err := pol.expandUsersFromGroup(group)
   594| 	if err != nil {
   595| 		return &netipx.IPSet{}, err
   596| 	}
   597| 	for _, user := range users {
   598| 		filteredNodes := filterNodesByUser(nodes, user)
   599| 		for _, node := range filteredNodes {
   600| 			node.AppendToIPSet(&build)
   601| 		}
   602| 	}
   603| 	return build.IPSet()
   604| }
   605| func (pol *ACLPolicy) expandIPsFromTag(
   606| 	alias string,
   607| 	nodes types.Nodes,
   608| ) (*netipx.IPSet, error) {
   609| 	var build netipx.IPSetBuilder
   610| 	for _, node := range nodes {
   611| 		if util.StringOrPrefixListContains(node.ForcedTags, alias) {
   612| 			node.AppendToIPSet(&build)
   613| 		}
   614| 	}
   615| 	owners, err := expandOwnersFromTag(pol, alias)
   616| 	if err != nil {
   617| 		if errors.Is(err, ErrInvalidTag) {
   618| 			ipSet, _ := build.IPSet()
   619| 			if len(ipSet.Prefixes()) == 0 {
   620| 				return ipSet, fmt.Errorf(
   621| 					"%w. %v isn't owned by a TagOwner and no forced tags are defined",
   622| 					ErrInvalidTag,
   623| 					alias,
   624| 				)
   625| 			}
   626| 			return build.IPSet()
   627| 		} else {
   628| 			return nil, err
   629| 		}
   630| 	}
   631| 	for _, user := range owners {
   632| 		nodes := filterNodesByUser(nodes, user)
   633| 		for _, node := range nodes {
   634| 			if node.Hostinfo == nil {
   635| 				continue
   636| 			}
   637| 			if util.StringOrPrefixListContains(node.Hostinfo.RequestTags, alias) {
   638| 				node.AppendToIPSet(&build)
   639| 			}
   640| 		}
   641| 	}
   642| 	return build.IPSet()
   643| }
   644| func (pol *ACLPolicy) expandIPsFromUser(
   645| 	user string,
   646| 	nodes types.Nodes,
   647| ) (*netipx.IPSet, error) {
   648| 	var build netipx.IPSetBuilder
   649| 	filteredNodes := filterNodesByUser(nodes, user)
   650| 	filteredNodes = excludeCorrectlyTaggedNodes(pol, filteredNodes, user)
   651| 	if len(filteredNodes) == 0 {
   652| 		return nil, nil // nolint
   653| 	}
   654| 	for _, node := range filteredNodes {
   655| 		node.AppendToIPSet(&build)
   656| 	}
   657| 	return build.IPSet()
   658| }
   659| func (pol *ACLPolicy) expandIPsFromSingleIP(
   660| 	ip netip.Addr,
   661| 	nodes types.Nodes,
   662| ) (*netipx.IPSet, error) {
   663| 	log.Trace().Str("ip", ip.String()).Msg("ExpandAlias got ip")
   664| 	matches := nodes.FilterByIP(ip)
   665| 	var build netipx.IPSetBuilder
   666| 	build.Add(ip)
   667| 	for _, node := range matches {
   668| 		node.AppendToIPSet(&build)
   669| 	}
   670| 	return build.IPSet()
   671| }
   672| func (pol *ACLPolicy) expandIPsFromIPPrefix(
   673| 	prefix netip.Prefix,
   674| 	nodes types.Nodes,
   675| ) (*netipx.IPSet, error) {
   676| 	log.Trace().Str("prefix", prefix.String()).Msg("expandAlias got prefix")
   677| 	var build netipx.IPSetBuilder
   678| 	build.AddPrefix(prefix)
   679| 	for _, node := range nodes {
   680| 		for _, ip := range node.IPs() {
   681| 			if prefix.Contains(ip) {
   682| 				node.AppendToIPSet(&build)
   683| 			}
   684| 		}
   685| 	}
   686| 	return build.IPSet()
   687| }
   688| func expandAutoGroup(alias string) (*netipx.IPSet, error) {
   689| 	switch {
   690| 	case strings.HasPrefix(alias, "autogroup:internet"):
   691| 		return theInternet(), nil
   692| 	default:
   693| 		return nil, fmt.Errorf("unknown autogroup %q", alias)
   694| 	}
   695| }
   696| func isWildcard(str string) bool {
   697| 	return str == "*"
   698| }
   699| func isGroup(str string) bool {
   700| 	return strings.HasPrefix(str, "group:")
   701| }
   702| func isTag(str string) bool {
   703| 	return strings.HasPrefix(str, "tag:")
   704| }
   705| func isAutoGroup(str string) bool {
   706| 	return strings.HasPrefix(str, "autogroup:")
   707| }
   708| func (pol *ACLPolicy) TagsOfNode(
   709| 	node *types.Node,
   710| ) ([]string, []string) {
   711| 	var validTags []string
   712| 	var invalidTags []string
   713| 	if node == nil {
   714| 		return validTags, invalidTags
   715| 	}
   716| 	validTagMap := make(map[string]bool)
   717| 	invalidTagMap := make(map[string]bool)
   718| 	if node.Hostinfo != nil {
   719| 		for _, tag := range node.Hostinfo.RequestTags {
   720| 			owners, err := expandOwnersFromTag(pol, tag)
   721| 			if errors.Is(err, ErrInvalidTag) {
   722| 				invalidTagMap[tag] = true
   723| 				continue
   724| 			}
   725| 			var found bool
   726| 			for _, owner := range owners {
   727| 				if node.User.Name == owner {
   728| 					found = true
   729| 				}
   730| 			}
   731| 			if found {
   732| 				validTagMap[tag] = true
   733| 			} else {
   734| 				invalidTagMap[tag] = true
   735| 			}
   736| 		}
   737| 		for tag := range invalidTagMap {
   738| 			invalidTags = append(invalidTags, tag)
   739| 		}
   740| 		for tag := range validTagMap {
   741| 			validTags = append(validTags, tag)
   742| 		}
   743| 	}
   744| 	return validTags, invalidTags
   745| }
   746| func filterNodesByUser(nodes types.Nodes, user string) types.Nodes {
   747| 	var out types.Nodes
   748| 	for _, node := range nodes {
   749| 		if node.User.Name == user {
   750| 			out = append(out, node)
   751| 		}
   752| 	}
   753| 	return out
   754| }
   755| func FilterNodesByACL(
   756| 	node *types.Node,
   757| 	nodes types.Nodes,
   758| 	filter []tailcfg.FilterRule,
   759| ) types.Nodes {
   760| 	var result types.Nodes
   761| 	for index, peer := range nodes {
   762| 		if peer.ID == node.ID {
   763| 			continue
   764| 		}
   765| 		if node.CanAccess(filter, nodes[index]) || peer.CanAccess(filter, node) {
   766| 			result = append(result, peer)
   767| 		}
   768| 	}
   769| 	return result
   770| }


# ====================================================================
# FILE: hscontrol/policy/acls_types.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| package policy
     2| import (
     3| 	"encoding/json"
     4| 	"net/netip"
     5| 	"strings"
     6| 	"github.com/tailscale/hujson"
     7| )
     8| type ACLPolicy struct {
     9| 	Groups        Groups        `json:"groups"`
    10| 	Hosts         Hosts         `json:"hosts"`
    11| 	TagOwners     TagOwners     `json:"tagOwners"`
    12| 	ACLs          []ACL         `json:"acls"`
    13| 	Tests         []ACLTest     `json:"tests"`
    14| 	AutoApprovers AutoApprovers `json:"autoApprovers"`
    15| 	SSHs          []SSH         `json:"ssh"`
    16| }
    17| type ACL struct {
    18| 	Action       string   `json:"action"`
    19| 	Protocol     string   `json:"proto"`
    20| 	Sources      []string `json:"src"`
    21| 	Destinations []string `json:"dst"`
    22| }
    23| type Groups map[string][]string
    24| type Hosts map[string]netip.Prefix
    25| type TagOwners map[string][]string
    26| type ACLTest struct {
    27| 	Source string   `json:"src"`
    28| 	Accept []string `json:"accept"`
    29| 	Deny   []string `json:"deny,omitempty"`
    30| }
    31| type AutoApprovers struct {
    32| 	Routes   map[string][]string `json:"routes"`
    33| 	ExitNode []string            `json:"exitNode"`
    34| }
    35| type SSH struct {
    36| 	Action       string   `json:"action"`
    37| 	Sources      []string `json:"src"`
    38| 	Destinations []string `json:"dst"`
    39| 	Users        []string `json:"users"`
    40| 	CheckPeriod  string   `json:"checkPeriod,omitempty"`
    41| }
    42| func (hosts *Hosts) UnmarshalJSON(data []byte) error {
    43| 	newHosts := Hosts{}
    44| 	hostIPPrefixMap := make(map[string]string)
    45| 	ast, err := hujson.Parse(data)
    46| 	if err != nil {
    47| 		return err
    48| 	}
    49| 	ast.Standardize()
    50| 	data = ast.Pack()
    51| 	err = json.Unmarshal(data, &hostIPPrefixMap)
    52| 	if err != nil {
    53| 		return err
    54| 	}
    55| 	for host, prefixStr := range hostIPPrefixMap {
    56| 		if !strings.Contains(prefixStr, "/") {
    57| 			prefixStr += "/32"
    58| 		}
    59| 		prefix, err := netip.ParsePrefix(prefixStr)
    60| 		if err != nil {
    61| 			return err
    62| 		}
    63| 		newHosts[host] = prefix
    64| 	}
    65| 	*hosts = newHosts
    66| 	return nil
    67| }
    68| func (pol ACLPolicy) IsZero() bool {
    69| 	if len(pol.Groups) == 0 && len(pol.Hosts) == 0 && len(pol.ACLs) == 0 {
    70| 		return true
    71| 	}
    72| 	return false
    73| }
    74| func (autoApprovers *AutoApprovers) GetRouteApprovers(
    75| 	prefix netip.Prefix,
    76| ) ([]string, error) {
    77| 	if prefix.Bits() == 0 {
    78| 		return autoApprovers.ExitNode, nil // 0.0.0.0/0, ::/0 or equivalent
    79| 	}
    80| 	approverAliases := make([]string, 0)
    81| 	for autoApprovedPrefix, autoApproverAliases := range autoApprovers.Routes {
    82| 		autoApprovedPrefix, err := netip.ParsePrefix(autoApprovedPrefix)
    83| 		if err != nil {
    84| 			return nil, err
    85| 		}
    86| 		if prefix.Bits() >= autoApprovedPrefix.Bits() &&
    87| 			autoApprovedPrefix.Contains(prefix.Masked().Addr()) {
    88| 			approverAliases = append(approverAliases, autoApproverAliases...)
    89| 		}
    90| 	}
    91| 	return approverAliases, nil
    92| }


# ====================================================================
# FILE: hscontrol/policy/matcher/matcher.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| package matcher
     2| import (
     3| 	"net/netip"
     4| 	"github.com/juanfont/headscale/hscontrol/util"
     5| 	"go4.org/netipx"
     6| 	"tailscale.com/tailcfg"
     7| )
     8| type Match struct {
     9| 	Srcs  *netipx.IPSet
    10| 	Dests *netipx.IPSet
    11| }
    12| func MatchFromFilterRule(rule tailcfg.FilterRule) Match {
    13| 	dests := []string{}
    14| 	for _, dest := range rule.DstPorts {
    15| 		dests = append(dests, dest.IP)
    16| 	}
    17| 	return MatchFromStrings(rule.SrcIPs, dests)
    18| }
    19| func MatchFromStrings(sources, destinations []string) Match {
    20| 	srcs := new(netipx.IPSetBuilder)
    21| 	dests := new(netipx.IPSetBuilder)
    22| 	for _, srcIP := range sources {
    23| 		set, _ := util.ParseIPSet(srcIP, nil)
    24| 		srcs.AddSet(set)
    25| 	}
    26| 	for _, dest := range destinations {
    27| 		set, _ := util.ParseIPSet(dest, nil)
    28| 		dests.AddSet(set)
    29| 	}
    30| 	srcsSet, _ := srcs.IPSet()
    31| 	destsSet, _ := dests.IPSet()
    32| 	match := Match{
    33| 		Srcs:  srcsSet,
    34| 		Dests: destsSet,
    35| 	}
    36| 	return match
    37| }
    38| func (m *Match) SrcsContainsIPs(ips []netip.Addr) bool {
    39| 	for _, ip := range ips {
    40| 		if m.Srcs.Contains(ip) {
    41| 			return true
    42| 		}
    43| 	}
    44| 	return false
    45| }
    46| func (m *Match) DestsContainsIP(ips []netip.Addr) bool {
    47| 	for _, ip := range ips {
    48| 		if m.Dests.Contains(ip) {
    49| 			return true
    50| 		}
    51| 	}
    52| 	return false
    53| }


# ====================================================================
# FILE: hscontrol/poll.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-536 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"math/rand/v2"
     6| 	"net/http"
     7| 	"slices"
     8| 	"sort"
     9| 	"strings"
    10| 	"time"
    11| 	"github.com/juanfont/headscale/hscontrol/db"
    12| 	"github.com/juanfont/headscale/hscontrol/mapper"
    13| 	"github.com/juanfont/headscale/hscontrol/types"
    14| 	"github.com/juanfont/headscale/hscontrol/util"
    15| 	"github.com/rs/zerolog/log"
    16| 	"github.com/sasha-s/go-deadlock"
    17| 	xslices "golang.org/x/exp/slices"
    18| 	"gorm.io/gorm"
    19| 	"tailscale.com/tailcfg"
    20| )
    21| const (
    22| 	keepAliveInterval = 50 * time.Second
    23| )
    24| type contextKey string
    25| const nodeNameContextKey = contextKey("nodeName")
    26| type mapSession struct {
    27| 	h      *Headscale
    28| 	req    tailcfg.MapRequest
    29| 	ctx    context.Context
    30| 	capVer tailcfg.CapabilityVersion
    31| 	mapper *mapper.Mapper
    32| 	cancelChMu deadlock.Mutex
    33| 	ch           chan types.StateUpdate
    34| 	cancelCh     chan struct{}
    35| 	cancelChOpen bool
    36| 	keepAlive       time.Duration
    37| 	keepAliveTicker *time.Ticker
    38| 	node *types.Node
    39| 	w    http.ResponseWriter
    40| 	warnf  func(string, ...any)
    41| 	infof  func(string, ...any)
    42| 	tracef func(string, ...any)
    43| 	errf   func(error, string, ...any)
    44| }
    45| func (h *Headscale) newMapSession(
    46| 	ctx context.Context,
    47| 	req tailcfg.MapRequest,
    48| 	w http.ResponseWriter,
    49| 	node *types.Node,
    50| ) *mapSession {
    51| 	warnf, infof, tracef, errf := logPollFunc(req, node)
    52| 	var updateChan chan types.StateUpdate
    53| 	if req.Stream {
    54| 		updateChan = make(chan types.StateUpdate, h.cfg.Tuning.NodeMapSessionBufferedChanSize)
    55| 		updateChan <- types.StateUpdate{
    56| 			Type: types.StateFullUpdate,
    57| 		}
    58| 	}
    59| 	ka := keepAliveInterval + (time.Duration(rand.IntN(9000)) * time.Millisecond)
    60| 	return &mapSession{
    61| 		h:      h,
    62| 		ctx:    ctx,
    63| 		req:    req,
    64| 		w:      w,
    65| 		node:   node,
    66| 		capVer: req.Version,
    67| 		mapper: h.mapper,
    68| 		ch:           updateChan,
    69| 		cancelCh:     make(chan struct{}),
    70| 		cancelChOpen: true,
    71| 		keepAlive:       ka,
    72| 		keepAliveTicker: nil,
    73| 		warnf:  warnf,
    74| 		infof:  infof,
    75| 		tracef: tracef,
    76| 		errf:   errf,
    77| 	}
    78| }
    79| func (m *mapSession) close() {
    80| 	m.cancelChMu.Lock()
    81| 	defer m.cancelChMu.Unlock()
    82| 	if !m.cancelChOpen {
    83| 		mapResponseClosed.WithLabelValues("chanclosed").Inc()
    84| 		return
    85| 	}
    86| 	m.tracef("mapSession (%p) sending message on cancel chan", m)
    87| 	select {
    88| 	case m.cancelCh <- struct{}{}:
    89| 		mapResponseClosed.WithLabelValues("sent").Inc()
    90| 		m.tracef("mapSession (%p) sent message on cancel chan", m)
    91| 	case <-time.After(30 * time.Second):
    92| 		mapResponseClosed.WithLabelValues("timeout").Inc()
    93| 		m.tracef("mapSession (%p) timed out sending close message", m)
    94| 	}
    95| }
    96| func (m *mapSession) isStreaming() bool {
    97| 	return m.req.Stream && !m.req.ReadOnly
    98| }
    99| func (m *mapSession) isEndpointUpdate() bool {
   100| 	return !m.req.Stream && !m.req.ReadOnly && m.req.OmitPeers
   101| }
   102| func (m *mapSession) isReadOnlyUpdate() bool {
   103| 	return !m.req.Stream && m.req.OmitPeers && m.req.ReadOnly
   104| }
   105| func (m *mapSession) resetKeepAlive() {
   106| 	m.keepAliveTicker.Reset(m.keepAlive)
   107| }
   108| func (m *mapSession) beforeServeLongPoll() {
   109| 	if m.node.IsEphemeral() {
   110| 		m.h.ephemeralGC.Cancel(m.node.ID)
   111| 	}
   112| }
   113| func (m *mapSession) afterServeLongPoll() {
   114| 	if m.node.IsEphemeral() {
   115| 		m.h.ephemeralGC.Schedule(m.node.ID, m.h.cfg.EphemeralNodeInactivityTimeout)
   116| 	}
   117| }
   118| func (m *mapSession) serve() {
   119| 	if m.isEndpointUpdate() {
   120| 		m.handleEndpointUpdate()
   121| 		return
   122| 	}
   123| 	if m.isReadOnlyUpdate() {
   124| 		m.handleReadOnlyRequest()
   125| 		return
   126| 	}
   127| }
   128| func (m *mapSession) serveLongPoll() {
   129| 	m.beforeServeLongPoll()
   130| 	defer func() {
   131| 		m.cancelChMu.Lock()
   132| 		m.cancelChOpen = false
   133| 		close(m.cancelCh)
   134| 		m.cancelChMu.Unlock()
   135| 		if m.h.nodeNotifier.RemoveNode(m.node.ID, m.ch) {
   136| 			m.h.updateNodeOnlineStatus(false, m.node)
   137| 			m.pollFailoverRoutes("node closing connection", m.node)
   138| 		}
   139| 		m.afterServeLongPoll()
   140| 		m.infof("node has disconnected, mapSession: %p, chan: %p", m, m.ch)
   141| 	}()
   142| 	if m.capVer < 68 {
   143| 		err := m.handleSaveNode()
   144| 		if err != nil {
   145| 			mapResponseWriteUpdatesInStream.WithLabelValues("error").Inc()
   146| 			m.close()
   147| 			return
   148| 		}
   149| 		mapResponseWriteUpdatesInStream.WithLabelValues("ok").Inc()
   150| 	}
   151| 	m.h.pollNetMapStreamWG.Add(1)
   152| 	defer m.h.pollNetMapStreamWG.Done()
   153| 	m.pollFailoverRoutes("node connected", m.node)
   154| 	rc := http.NewResponseController(m.w)
   155| 	rc.SetWriteDeadline(time.Time{})
   156| 	ctx, cancel := context.WithCancel(context.WithValue(m.ctx, nodeNameContextKey, m.node.Hostname))
   157| 	defer cancel()
   158| 	m.keepAliveTicker = time.NewTicker(m.keepAlive)
   159| 	m.h.nodeNotifier.AddNode(m.node.ID, m.ch)
   160| 	go m.h.updateNodeOnlineStatus(true, m.node)
   161| 	m.infof("node has connected, mapSession: %p, chan: %p", m, m.ch)
   162| 	for {
   163| 		select {
   164| 		case <-m.cancelCh:
   165| 			m.tracef("poll cancelled received")
   166| 			mapResponseEnded.WithLabelValues("cancelled").Inc()
   167| 			return
   168| 		case <-ctx.Done():
   169| 			m.tracef("poll context done")
   170| 			mapResponseEnded.WithLabelValues("done").Inc()
   171| 			return
   172| 		case update, ok := <-m.ch:
   173| 			if !ok {
   174| 				m.tracef("update channel closed, streaming session is likely being replaced")
   175| 				return
   176| 			}
   177| 			if slices.Contains(update.Removed, m.node.ID) {
   178| 				m.tracef("node removed, closing stream")
   179| 				return
   180| 			}
   181| 			m.tracef("received stream update: %s %s", update.Type.String(), update.Message)
   182| 			mapResponseUpdateReceived.WithLabelValues(update.Type.String()).Inc()
   183| 			var data []byte
   184| 			var err error
   185| 			var lastMessage string
   186| 			m.node, err = m.h.db.GetNodeByID(m.node.ID)
   187| 			if err != nil {
   188| 				m.errf(err, "Could not get machine from db")
   189| 				return
   190| 			}
   191| 			updateType := "full"
   192| 			switch update.Type {
   193| 			case types.StateFullUpdate:
   194| 				m.tracef("Sending Full MapResponse")
   195| 				data, err = m.mapper.FullMapResponse(m.req, m.node, m.h.ACLPolicy, fmt.Sprintf("from mapSession: %p, stream: %t", m, m.isStreaming()))
   196| 			case types.StatePeerChanged:
   197| 				changed := make(map[types.NodeID]bool, len(update.ChangeNodes))
   198| 				for _, nodeID := range update.ChangeNodes {
   199| 					changed[nodeID] = true
   200| 				}
   201| 				lastMessage = update.Message
   202| 				m.tracef(fmt.Sprintf("Sending Changed MapResponse: %v", lastMessage))
   203| 				data, err = m.mapper.PeerChangedResponse(m.req, m.node, changed, update.ChangePatches, m.h.ACLPolicy, lastMessage)
   204| 				updateType = "change"
   205| 			case types.StatePeerChangedPatch:
   206| 				m.tracef(fmt.Sprintf("Sending Changed Patch MapResponse: %v", lastMessage))
   207| 				data, err = m.mapper.PeerChangedPatchResponse(m.req, m.node, update.ChangePatches, m.h.ACLPolicy)
   208| 				updateType = "patch"
   209| 			case types.StatePeerRemoved:
   210| 				changed := make(map[types.NodeID]bool, len(update.Removed))
   211| 				for _, nodeID := range update.Removed {
   212| 					changed[nodeID] = false
   213| 				}
   214| 				m.tracef(fmt.Sprintf("Sending Changed MapResponse: %v", lastMessage))
   215| 				data, err = m.mapper.PeerChangedResponse(m.req, m.node, changed, update.ChangePatches, m.h.ACLPolicy, lastMessage)
   216| 				updateType = "remove"
   217| 			case types.StateSelfUpdate:
   218| 				lastMessage = update.Message
   219| 				m.tracef(fmt.Sprintf("Sending Changed MapResponse: %v", lastMessage))
   220| 				data, err = m.mapper.PeerChangedResponse(m.req, m.node, make(map[types.NodeID]bool), update.ChangePatches, m.h.ACLPolicy, lastMessage)
   221| 				updateType = "remove"
   222| 			case types.StateDERPUpdated:
   223| 				m.tracef("Sending DERPUpdate MapResponse")
   224| 				data, err = m.mapper.DERPMapResponse(m.req, m.node, m.h.DERPMap)
   225| 				updateType = "derp"
   226| 			}
   227| 			if err != nil {
   228| 				m.errf(err, "Could not get the create map update")
   229| 				return
   230| 			}
   231| 			if data != nil {
   232| 				startWrite := time.Now()
   233| 				_, err = m.w.Write(data)
   234| 				if err != nil {
   235| 					mapResponseSent.WithLabelValues("error", updateType).Inc()
   236| 					m.errf(err, "could not write the map response(%s), for mapSession: %p", update.Type.String(), m)
   237| 					return
   238| 				}
   239| 				err = rc.Flush()
   240| 				if err != nil {
   241| 					mapResponseSent.WithLabelValues("error", updateType).Inc()
   242| 					m.errf(err, "flushing the map response to client, for mapSession: %p", m)
   243| 					return
   244| 				}
   245| 				log.Trace().Str("node", m.node.Hostname).TimeDiff("timeSpent", time.Now(), startWrite).Str("mkey", m.node.MachineKey.String()).Msg("finished writing mapresp to node")
   246| 				if debugHighCardinalityMetrics {
   247| 					mapResponseLastSentSeconds.WithLabelValues(updateType, m.node.ID.String()).Set(float64(time.Now().Unix()))
   248| 				}
   249| 				mapResponseSent.WithLabelValues("ok", updateType).Inc()
   250| 				m.tracef("update sent")
   251| 				m.resetKeepAlive()
   252| 			}
   253| 		case <-m.keepAliveTicker.C:
   254| 			data, err := m.mapper.KeepAliveResponse(m.req, m.node)
   255| 			if err != nil {
   256| 				m.errf(err, "Error generating the keep alive msg")
   257| 				mapResponseSent.WithLabelValues("error", "keepalive").Inc()
   258| 				return
   259| 			}
   260| 			_, err = m.w.Write(data)
   261| 			if err != nil {
   262| 				m.errf(err, "Cannot write keep alive message")
   263| 				mapResponseSent.WithLabelValues("error", "keepalive").Inc()
   264| 				return
   265| 			}
   266| 			err = rc.Flush()
   267| 			if err != nil {
   268| 				m.errf(err, "flushing keep alive to client, for mapSession: %p", m)
   269| 				mapResponseSent.WithLabelValues("error", "keepalive").Inc()
   270| 				return
   271| 			}
   272| 			if debugHighCardinalityMetrics {
   273| 				mapResponseLastSentSeconds.WithLabelValues("keepalive", m.node.ID.String()).Set(float64(time.Now().Unix()))
   274| 			}
   275| 			mapResponseSent.WithLabelValues("ok", "keepalive").Inc()
   276| 		}
   277| 	}
   278| }
   279| func (m *mapSession) pollFailoverRoutes(where string, node *types.Node) {
   280| 	update, err := db.Write(m.h.db.DB, func(tx *gorm.DB) (*types.StateUpdate, error) {
   281| 		return db.FailoverNodeRoutesIfNeccessary(tx, m.h.nodeNotifier.LikelyConnectedMap(), node)
   282| 	})
   283| 	if err != nil {
   284| 		m.errf(err, fmt.Sprintf("failed to ensure failover routes, %s", where))
   285| 		return
   286| 	}
   287| 	if update != nil && !update.Empty() {
   288| 		ctx := types.NotifyCtx(context.Background(), fmt.Sprintf("poll-%s-routes-ensurefailover", strings.ReplaceAll(where, " ", "-")), node.Hostname)
   289| 		m.h.nodeNotifier.NotifyWithIgnore(ctx, *update, node.ID)
   290| 	}
   291| }
   292| func (h *Headscale) updateNodeOnlineStatus(online bool, node *types.Node) {
   293| 	change := &tailcfg.PeerChange{
   294| 		NodeID: tailcfg.NodeID(node.ID),
   295| 		Online: &online,
   296| 	}
   297| 	if !online {
   298| 		now := time.Now()
   299| 		node.LastSeen = &now
   300| 		change.LastSeen = &now
   301| 		err := h.db.Write(func(tx *gorm.DB) error {
   302| 			return db.SetLastSeen(tx, node.ID, *node.LastSeen)
   303| 		})
   304| 		if err != nil {
   305| 			log.Error().Err(err).Msg("Cannot update node LastSeen")
   306| 			return
   307| 		}
   308| 	}
   309| 	ctx := types.NotifyCtx(context.Background(), "poll-nodeupdate-onlinestatus", node.Hostname)
   310| 	h.nodeNotifier.NotifyWithIgnore(ctx, types.StateUpdate{
   311| 		Type: types.StatePeerChangedPatch,
   312| 		ChangePatches: []*tailcfg.PeerChange{
   313| 			change,
   314| 		},
   315| 	}, node.ID)
   316| }
   317| func (m *mapSession) handleEndpointUpdate() {
   318| 	m.tracef("received endpoint update")
   319| 	change := m.node.PeerChangeFromMapRequest(m.req)
   320| 	online := m.h.nodeNotifier.IsLikelyConnected(m.node.ID)
   321| 	change.Online = &online
   322| 	m.node.ApplyPeerChange(&change)
   323| 	sendUpdate, routesChanged := hostInfoChanged(m.node.Hostinfo, m.req.Hostinfo)
   324| 	if m.req.Hostinfo.NetInfo == nil {
   325| 		m.req.Hostinfo.NetInfo = m.node.Hostinfo.NetInfo
   326| 	}
   327| 	m.node.Hostinfo = m.req.Hostinfo
   328| 	logTracePeerChange(m.node.Hostname, sendUpdate, &change)
   329| 	if peerChangeEmpty(change) && !sendUpdate {
   330| 		mapResponseEndpointUpdates.WithLabelValues("noop").Inc()
   331| 		return
   332| 	}
   333| 	if routesChanged {
   334| 		var err error
   335| 		_, err = m.h.db.SaveNodeRoutes(m.node)
   336| 		if err != nil {
   337| 			m.errf(err, "Error processing node routes")
   338| 			http.Error(m.w, "", http.StatusInternalServerError)
   339| 			mapResponseEndpointUpdates.WithLabelValues("error").Inc()
   340| 			return
   341| 		}
   342| 		if m.h.ACLPolicy != nil {
   343| 			err := m.h.db.EnableAutoApprovedRoutes(m.h.ACLPolicy, m.node)
   344| 			if err != nil {
   345| 				m.errf(err, "Error running auto approved routes")
   346| 				mapResponseEndpointUpdates.WithLabelValues("error").Inc()
   347| 			}
   348| 		}
   349| 		ctx := types.NotifyCtx(context.Background(), "poll-nodeupdate-self-hostinfochange", m.node.Hostname)
   350| 		m.h.nodeNotifier.NotifyByNodeID(
   351| 			ctx,
   352| 			types.StateUpdate{
   353| 				Type:        types.StateSelfUpdate,
   354| 				ChangeNodes: []types.NodeID{m.node.ID},
   355| 			},
   356| 			m.node.ID)
   357| 	}
   358| 	if err := m.h.db.DB.Save(m.node).Error; err != nil {
   359| 		m.errf(err, "Failed to persist/update node in the database")
   360| 		http.Error(m.w, "", http.StatusInternalServerError)
   361| 		mapResponseEndpointUpdates.WithLabelValues("error").Inc()
   362| 		return
   363| 	}
   364| 	ctx := types.NotifyCtx(context.Background(), "poll-nodeupdate-peers-patch", m.node.Hostname)
   365| 	m.h.nodeNotifier.NotifyWithIgnore(
   366| 		ctx,
   367| 		types.StateUpdate{
   368| 			Type:        types.StatePeerChanged,
   369| 			ChangeNodes: []types.NodeID{m.node.ID},
   370| 			Message:     "called from handlePoll -> update",
   371| 		},
   372| 		m.node.ID)
   373| 	m.w.WriteHeader(http.StatusOK)
   374| 	mapResponseEndpointUpdates.WithLabelValues("ok").Inc()
   375| 	return
   376| }
   377| func (m *mapSession) handleSaveNode() error {
   378| 	m.tracef("saving node update from stream session")
   379| 	change := m.node.PeerChangeFromMapRequest(m.req)
   380| 	online := true
   381| 	change.Online = &online
   382| 	m.node.ApplyPeerChange(&change)
   383| 	sendUpdate, routesChanged := hostInfoChanged(m.node.Hostinfo, m.req.Hostinfo)
   384| 	m.node.Hostinfo = m.req.Hostinfo
   385| 	if peerChangeEmpty(change) || !sendUpdate {
   386| 		return nil
   387| 	}
   388| 	if routesChanged {
   389| 		var err error
   390| 		_, err = m.h.db.SaveNodeRoutes(m.node)
   391| 		if err != nil {
   392| 			return err
   393| 		}
   394| 		if m.h.ACLPolicy != nil {
   395| 			err := m.h.db.EnableAutoApprovedRoutes(m.h.ACLPolicy, m.node)
   396| 			if err != nil {
   397| 				return err
   398| 			}
   399| 		}
   400| 	}
   401| 	if err := m.h.db.DB.Save(m.node).Error; err != nil {
   402| 		return err
   403| 	}
   404| 	ctx := types.NotifyCtx(context.Background(), "pre-68-update-while-stream", m.node.Hostname)
   405| 	m.h.nodeNotifier.NotifyWithIgnore(
   406| 		ctx,
   407| 		types.StateUpdate{
   408| 			Type:        types.StatePeerChanged,
   409| 			ChangeNodes: []types.NodeID{m.node.ID},
   410| 			Message:     "called from handlePoll -> pre-68-update-while-stream",
   411| 		},
   412| 		m.node.ID)
   413| 	return nil
   414| }
   415| func (m *mapSession) handleReadOnlyRequest() {
   416| 	m.tracef("Client asked for a lite update, responding without peers")
   417| 	mapResp, err := m.mapper.ReadOnlyMapResponse(m.req, m.node, m.h.ACLPolicy)
   418| 	if err != nil {
   419| 		m.errf(err, "Failed to create MapResponse")
   420| 		http.Error(m.w, "", http.StatusInternalServerError)
   421| 		mapResponseReadOnly.WithLabelValues("error").Inc()
   422| 		return
   423| 	}
   424| 	m.w.Header().Set("Content-Type", "application/json; charset=utf-8")
   425| 	m.w.WriteHeader(http.StatusOK)
   426| 	_, err = m.w.Write(mapResp)
   427| 	if err != nil {
   428| 		m.errf(err, "Failed to write response")
   429| 		mapResponseReadOnly.WithLabelValues("error").Inc()
   430| 		return
   431| 	}
   432| 	m.w.WriteHeader(http.StatusOK)
   433| 	mapResponseReadOnly.WithLabelValues("ok").Inc()
   434| 	return
   435| }
   436| func logTracePeerChange(hostname string, hostinfoChange bool, change *tailcfg.PeerChange) {
   437| 	trace := log.Trace().Uint64("node.id", uint64(change.NodeID)).Str("hostname", hostname)
   438| 	if change.Key != nil {
   439| 		trace = trace.Str("node_key", change.Key.ShortString())
   440| 	}
   441| 	if change.DiscoKey != nil {
   442| 		trace = trace.Str("disco_key", change.DiscoKey.ShortString())
   443| 	}
   444| 	if change.Online != nil {
   445| 		trace = trace.Bool("online", *change.Online)
   446| 	}
   447| 	if change.Endpoints != nil {
   448| 		eps := make([]string, len(change.Endpoints))
   449| 		for idx, ep := range change.Endpoints {
   450| 			eps[idx] = ep.String()
   451| 		}
   452| 		trace = trace.Strs("endpoints", eps)
   453| 	}
   454| 	if hostinfoChange {
   455| 		trace = trace.Bool("hostinfo_changed", hostinfoChange)
   456| 	}
   457| 	if change.DERPRegion != 0 {
   458| 		trace = trace.Int("derp_region", change.DERPRegion)
   459| 	}
   460| 	trace.Time("last_seen", *change.LastSeen).Msg("PeerChange received")
   461| }
   462| func peerChangeEmpty(chng tailcfg.PeerChange) bool {
   463| 	return chng.Key == nil &&
   464| 		chng.DiscoKey == nil &&
   465| 		chng.Online == nil &&
   466| 		chng.Endpoints == nil &&
   467| 		chng.DERPRegion == 0 &&
   468| 		chng.LastSeen == nil &&
   469| 		chng.KeyExpiry == nil
   470| }
   471| func logPollFunc(
   472| 	mapRequest tailcfg.MapRequest,
   473| 	node *types.Node,
   474| ) (func(string, ...any), func(string, ...any), func(string, ...any), func(error, string, ...any)) {
   475| 	return func(msg string, a ...any) {
   476| 			log.Warn().
   477| 				Caller().
   478| 				Bool("readOnly", mapRequest.ReadOnly).
   479| 				Bool("omitPeers", mapRequest.OmitPeers).
   480| 				Bool("stream", mapRequest.Stream).
   481| 				Uint64("node.id", node.ID.Uint64()).
   482| 				Str("node", node.Hostname).
   483| 				Msgf(msg, a...)
   484| 		},
   485| 		func(msg string, a ...any) {
   486| 			log.Info().
   487| 				Caller().
   488| 				Bool("readOnly", mapRequest.ReadOnly).
   489| 				Bool("omitPeers", mapRequest.OmitPeers).
   490| 				Bool("stream", mapRequest.Stream).
   491| 				Uint64("node.id", node.ID.Uint64()).
   492| 				Str("node", node.Hostname).
   493| 				Msgf(msg, a...)
   494| 		},
   495| 		func(msg string, a ...any) {
   496| 			log.Trace().
   497| 				Caller().
   498| 				Bool("readOnly", mapRequest.ReadOnly).
   499| 				Bool("omitPeers", mapRequest.OmitPeers).
   500| 				Bool("stream", mapRequest.Stream).
   501| 				Uint64("node.id", node.ID.Uint64()).
   502| 				Str("node", node.Hostname).
   503| 				Msgf(msg, a...)
   504| 		},
   505| 		func(err error, msg string, a ...any) {
   506| 			log.Error().
   507| 				Caller().
   508| 				Bool("readOnly", mapRequest.ReadOnly).
   509| 				Bool("omitPeers", mapRequest.OmitPeers).
   510| 				Bool("stream", mapRequest.Stream).
   511| 				Uint64("node.id", node.ID.Uint64()).
   512| 				Str("node", node.Hostname).
   513| 				Err(err).
   514| 				Msgf(msg, a...)
   515| 		}
   516| }
   517| func hostInfoChanged(old, new *tailcfg.Hostinfo) (bool, bool) {
   518| 	if old.Equal(new) {
   519| 		return false, false
   520| 	}
   521| 	oldRoutes := old.RoutableIPs
   522| 	newRoutes := new.RoutableIPs
   523| 	sort.Slice(oldRoutes, func(i, j int) bool {
   524| 		return util.ComparePrefix(oldRoutes[i], oldRoutes[j]) > 0
   525| 	})
   526| 	sort.Slice(newRoutes, func(i, j int) bool {
   527| 		return util.ComparePrefix(newRoutes[i], newRoutes[j]) > 0
   528| 	})
   529| 	if !xslices.Equal(oldRoutes, newRoutes) {
   530| 		return true, true
   531| 	}
   532| 	if len(old.Services) != len(new.Services) {
   533| 		return true, false
   534| 	}
   535| 	return false, false
   536| }


# ====================================================================
# FILE: hscontrol/tailsql.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"net/http"
     6| 	"os"
     7| 	"github.com/tailscale/tailsql/server/tailsql"
     8| 	"tailscale.com/tsnet"
     9| 	"tailscale.com/tsweb"
    10| 	"tailscale.com/types/logger"
    11| )
    12| func runTailSQLService(ctx context.Context, logf logger.Logf, stateDir, dbPath string) error {
    13| 	opts := tailsql.Options{
    14| 		Hostname: "tailsql-headscale",
    15| 		StateDir: stateDir,
    16| 		Sources: []tailsql.DBSpec{
    17| 			{
    18| 				Source: "headscale",
    19| 				Label:  "headscale - sqlite",
    20| 				Driver: "sqlite",
    21| 				URL:    fmt.Sprintf("file:%s?mode=ro", dbPath),
    22| 				Named: map[string]string{
    23| 					"schema": `select * from sqlite_schema`,
    24| 				},
    25| 			},
    26| 		},
    27| 	}
    28| 	tsNode := &tsnet.Server{
    29| 		Dir:      os.ExpandEnv(opts.StateDir),
    30| 		Hostname: opts.Hostname,
    31| 		Logf:     logger.Discard,
    32| 	}
    33| 	defer tsNode.Close()
    34| 	logf("Starting tailscale (hostname=%q)", opts.Hostname)
    35| 	lc, err := tsNode.LocalClient()
    36| 	if err != nil {
    37| 		return fmt.Errorf("connect local client: %w", err)
    38| 	}
    39| 	opts.LocalClient = lc // for authentication
    40| 	if st, err := tsNode.Up(ctx); err != nil {
    41| 		return fmt.Errorf("starting tailscale: %w", err)
    42| 	} else {
    43| 		logf("tailscale started, node state %q", st.BackendState)
    44| 	}
    45| 	tsql, err := tailsql.NewServer(opts)
    46| 	if err != nil {
    47| 		return fmt.Errorf("creating tailsql server: %w", err)
    48| 	}
    49| 	lst, err := tsNode.Listen("tcp", ":80")
    50| 	if err != nil {
    51| 		return fmt.Errorf("listen port 80: %w", err)
    52| 	}
    53| 	if opts.ServeHTTPS {
    54| 		certDomains := tsNode.CertDomains()
    55| 		if len(certDomains) == 0 {
    56| 			return fmt.Errorf("no cert domains available for HTTPS")
    57| 		}
    58| 		base := "https://" + certDomains[0]
    59| 		go http.Serve(lst, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    60| 			target := base + r.RequestURI
    61| 			http.Redirect(w, r, target, http.StatusPermanentRedirect)
    62| 		}))
    63| 		var err error
    64| 		lst, err = tsNode.ListenTLS("tcp", ":443")
    65| 		if err != nil {
    66| 			return fmt.Errorf("listen TLS: %w", err)
    67| 		}
    68| 		logf("enabled serving via HTTPS")
    69| 	}
    70| 	mux := tsql.NewMux()
    71| 	tsweb.Debugger(mux)
    72| 	go http.Serve(lst, mux)
    73| 	logf("ailSQL started")
    74| 	<-ctx.Done()
    75| 	logf("TailSQL shutting down...")
    76| 	return tsNode.Close()
    77| }


# ====================================================================
# FILE: hscontrol/types/api_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| package types
     2| import (
     3| 	"time"
     4| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     5| 	"google.golang.org/protobuf/types/known/timestamppb"
     6| )
     7| type APIKey struct {
     8| 	ID     uint64 `gorm:"primary_key"`
     9| 	Prefix string `gorm:"uniqueIndex"`
    10| 	Hash   []byte
    11| 	CreatedAt  *time.Time
    12| 	Expiration *time.Time
    13| 	LastSeen   *time.Time
    14| }
    15| func (key *APIKey) Proto() *v1.ApiKey {
    16| 	protoKey := v1.ApiKey{
    17| 		Id:     key.ID,
    18| 		Prefix: key.Prefix,
    19| 	}
    20| 	if key.Expiration != nil {
    21| 		protoKey.Expiration = timestamppb.New(*key.Expiration)
    22| 	}
    23| 	if key.CreatedAt != nil {
    24| 		protoKey.CreatedAt = timestamppb.New(*key.CreatedAt)
    25| 	}
    26| 	if key.LastSeen != nil {
    27| 		protoKey.LastSeen = timestamppb.New(*key.LastSeen)
    28| 	}
    29| 	return &protoKey
    30| }


# ====================================================================
# FILE: hscontrol/types/common.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-132 ---
     1| package types
     2| import (
     3| 	"context"
     4| 	"database/sql/driver"
     5| 	"encoding/json"
     6| 	"errors"
     7| 	"fmt"
     8| 	"net/netip"
     9| 	"time"
    10| 	"tailscale.com/tailcfg"
    11| 	"tailscale.com/util/ctxkey"
    12| )
    13| const (
    14| 	SelfUpdateIdentifier = "self-update"
    15| 	DatabasePostgres     = "postgres"
    16| 	DatabaseSqlite       = "sqlite3"
    17| )
    18| var ErrCannotParsePrefix = errors.New("cannot parse prefix")
    19| type IPPrefix netip.Prefix
    20| func (i *IPPrefix) Scan(destination interface{}) error {
    21| 	switch value := destination.(type) {
    22| 	case string:
    23| 		prefix, err := netip.ParsePrefix(value)
    24| 		if err != nil {
    25| 			return err
    26| 		}
    27| 		*i = IPPrefix(prefix)
    28| 		return nil
    29| 	default:
    30| 		return fmt.Errorf("%w: unexpected data type %T", ErrCannotParsePrefix, destination)
    31| 	}
    32| }
    33| func (i IPPrefix) Value() (driver.Value, error) {
    34| 	prefixStr := netip.Prefix(i).String()
    35| 	return prefixStr, nil
    36| }
    37| type IPPrefixes []netip.Prefix
    38| func (i *IPPrefixes) Scan(destination interface{}) error {
    39| 	switch value := destination.(type) {
    40| 	case []byte:
    41| 		return json.Unmarshal(value, i)
    42| 	case string:
    43| 		return json.Unmarshal([]byte(value), i)
    44| 	default:
    45| 		return fmt.Errorf("%w: unexpected data type %T", ErrNodeAddressesInvalid, destination)
    46| 	}
    47| }
    48| func (i IPPrefixes) Value() (driver.Value, error) {
    49| 	bytes, err := json.Marshal(i)
    50| 	return string(bytes), err
    51| }
    52| type StringList []string
    53| func (i *StringList) Scan(destination interface{}) error {
    54| 	switch value := destination.(type) {
    55| 	case []byte:
    56| 		return json.Unmarshal(value, i)
    57| 	case string:
    58| 		return json.Unmarshal([]byte(value), i)
    59| 	default:
    60| 		return fmt.Errorf("%w: unexpected data type %T", ErrNodeAddressesInvalid, destination)
    61| 	}
    62| }
    63| func (i StringList) Value() (driver.Value, error) {
    64| 	bytes, err := json.Marshal(i)
    65| 	return string(bytes), err
    66| }
    67| type StateUpdateType int
    68| func (su StateUpdateType) String() string {
    69| 	switch su {
    70| 	case StateFullUpdate:
    71| 		return "StateFullUpdate"
    72| 	case StatePeerChanged:
    73| 		return "StatePeerChanged"
    74| 	case StatePeerChangedPatch:
    75| 		return "StatePeerChangedPatch"
    76| 	case StatePeerRemoved:
    77| 		return "StatePeerRemoved"
    78| 	case StateSelfUpdate:
    79| 		return "StateSelfUpdate"
    80| 	case StateDERPUpdated:
    81| 		return "StateDERPUpdated"
    82| 	}
    83| 	return "unknown state update type"
    84| }
    85| const (
    86| 	StateFullUpdate StateUpdateType = iota
    87| 	StatePeerChanged
    88| 	StatePeerChangedPatch
    89| 	StatePeerRemoved
    90| 	StateSelfUpdate
    91| 	StateDERPUpdated
    92| )
    93| type StateUpdate struct {
    94| 	Type StateUpdateType
    95| 	ChangeNodes []NodeID
    96| 	ChangePatches []*tailcfg.PeerChange
    97| 	Removed []NodeID
    98| 	DERPMap *tailcfg.DERPMap
    99| 	Message string
   100| }
   101| func (su *StateUpdate) Empty() bool {
   102| 	switch su.Type {
   103| 	case StatePeerChanged:
   104| 		return len(su.ChangeNodes) == 0
   105| 	case StatePeerChangedPatch:
   106| 		return len(su.ChangePatches) == 0
   107| 	case StatePeerRemoved:
   108| 		return len(su.Removed) == 0
   109| 	}
   110| 	return false
   111| }
   112| func StateUpdateExpire(nodeID NodeID, expiry time.Time) StateUpdate {
   113| 	return StateUpdate{
   114| 		Type: StatePeerChangedPatch,
   115| 		ChangePatches: []*tailcfg.PeerChange{
   116| 			{
   117| 				NodeID:    nodeID.NodeID(),
   118| 				KeyExpiry: &expiry,
   119| 			},
   120| 		},
   121| 	}
   122| }
   123| var (
   124| 	NotifyOriginKey   = ctxkey.New("notify.origin", "")
   125| 	NotifyHostnameKey = ctxkey.New("notify.hostname", "")
   126| )
   127| func NotifyCtx(ctx context.Context, origin, hostname string) context.Context {
   128| 	ctx2, _ := context.WithTimeout(ctx, 3*time.Second)
   129| 	ctx2 = NotifyOriginKey.WithValue(ctx2, origin)
   130| 	ctx2 = NotifyHostnameKey.WithValue(ctx2, hostname)
   131| 	return ctx2
   132| }


# ====================================================================
# FILE: hscontrol/types/config.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-751 ---
     1| package types
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"io/fs"
     6| 	"net/netip"
     7| 	"net/url"
     8| 	"os"
     9| 	"strings"
    10| 	"time"
    11| 	"github.com/coreos/go-oidc/v3/oidc"
    12| 	"github.com/juanfont/headscale/hscontrol/util"
    13| 	"github.com/prometheus/common/model"
    14| 	"github.com/rs/zerolog"
    15| 	"github.com/rs/zerolog/log"
    16| 	"github.com/spf13/viper"
    17| 	"go4.org/netipx"
    18| 	"tailscale.com/net/tsaddr"
    19| 	"tailscale.com/tailcfg"
    20| 	"tailscale.com/types/dnstype"
    21| 	"tailscale.com/util/set"
    22| )
    23| const (
    24| 	defaultOIDCExpiryTime               = 180 * 24 * time.Hour // 180 Days
    25| 	maxDuration           time.Duration = 1<<63 - 1
    26| )
    27| var errOidcMutuallyExclusive = errors.New(
    28| 	"oidc_client_secret and oidc_client_secret_path are mutually exclusive",
    29| )
    30| type IPAllocationStrategy string
    31| const (
    32| 	IPAllocationStrategySequential IPAllocationStrategy = "sequential"
    33| 	IPAllocationStrategyRandom     IPAllocationStrategy = "random"
    34| )
    35| type PolicyMode string
    36| const (
    37| 	PolicyModeDB   = "database"
    38| 	PolicyModeFile = "file"
    39| )
    40| type Config struct {
    41| 	ServerURL                      string
    42| 	Addr                           string
    43| 	MetricsAddr                    string
    44| 	GRPCAddr                       string
    45| 	GRPCAllowInsecure              bool
    46| 	EphemeralNodeInactivityTimeout time.Duration
    47| 	PrefixV4                       *netip.Prefix
    48| 	PrefixV6                       *netip.Prefix
    49| 	IPAllocation                   IPAllocationStrategy
    50| 	NoisePrivateKeyPath            string
    51| 	BaseDomain                     string
    52| 	Log                            LogConfig
    53| 	DisableUpdateCheck             bool
    54| 	Database DatabaseConfig
    55| 	DERP DERPConfig
    56| 	TLS TLSConfig
    57| 	ACMEURL   string
    58| 	ACMEEmail string
    59| 	DNSConfig             *tailcfg.DNSConfig
    60| 	DNSUserNameInMagicDNS bool
    61| 	UnixSocket           string
    62| 	UnixSocketPermission fs.FileMode
    63| 	OIDC OIDCConfig
    64| 	LogTail             LogTailConfig
    65| 	RandomizeClientPort bool
    66| 	CLI CLIConfig
    67| 	Policy PolicyConfig
    68| 	Tuning Tuning
    69| }
    70| type DNSConfig struct {
    71| 	MagicDNS           bool   `mapstructure:"magic_dns"`
    72| 	BaseDomain         string `mapstructure:"base_domain"`
    73| 	Nameservers        Nameservers
    74| 	SearchDomains      []string            `mapstructure:"search_domains"`
    75| 	ExtraRecords       []tailcfg.DNSRecord `mapstructure:"extra_records"`
    76| 	UserNameInMagicDNS bool                `mapstructure:"use_username_in_magic_dns"`
    77| }
    78| type Nameservers struct {
    79| 	Global []string
    80| 	Split  map[string][]string
    81| }
    82| type SqliteConfig struct {
    83| 	Path          string
    84| 	WriteAheadLog bool
    85| }
    86| type PostgresConfig struct {
    87| 	Host                string
    88| 	Port                int
    89| 	Name                string
    90| 	User                string
    91| 	Pass                string
    92| 	Ssl                 string
    93| 	MaxOpenConnections  int
    94| 	MaxIdleConnections  int
    95| 	ConnMaxIdleTimeSecs int
    96| }
    97| type GormConfig struct {
    98| 	Debug                 bool
    99| 	SlowThreshold         time.Duration
   100| 	SkipErrRecordNotFound bool
   101| 	ParameterizedQueries  bool
   102| 	PrepareStmt           bool
   103| }
   104| type DatabaseConfig struct {
   105| 	Type  string
   106| 	Debug bool
   107| 	Gorm GormConfig
   108| 	Sqlite   SqliteConfig
   109| 	Postgres PostgresConfig
   110| }
   111| type TLSConfig struct {
   112| 	CertPath string
   113| 	KeyPath  string
   114| 	LetsEncrypt LetsEncryptConfig
   115| }
   116| type LetsEncryptConfig struct {
   117| 	Listen        string
   118| 	Hostname      string
   119| 	CacheDir      string
   120| 	ChallengeType string
   121| }
   122| type OIDCConfig struct {
   123| 	OnlyStartIfOIDCIsAvailable bool
   124| 	Issuer                     string
   125| 	ClientID                   string
   126| 	ClientSecret               string
   127| 	Scope                      []string
   128| 	ExtraParams                map[string]string
   129| 	AllowedDomains             []string
   130| 	AllowedUsers               []string
   131| 	AllowedGroups              []string
   132| 	StripEmaildomain           bool
   133| 	Expiry                     time.Duration
   134| 	UseExpiryFromToken         bool
   135| }
   136| type DERPConfig struct {
   137| 	ServerEnabled                      bool
   138| 	AutomaticallyAddEmbeddedDerpRegion bool
   139| 	ServerRegionID                     int
   140| 	ServerRegionCode                   string
   141| 	ServerRegionName                   string
   142| 	ServerPrivateKeyPath               string
   143| 	STUNAddr                           string
   144| 	URLs                               []url.URL
   145| 	Paths                              []string
   146| 	AutoUpdate                         bool
   147| 	UpdateFrequency                    time.Duration
   148| 	IPv4                               string
   149| 	IPv6                               string
   150| }
   151| type LogTailConfig struct {
   152| 	Enabled bool
   153| }
   154| type CLIConfig struct {
   155| 	Address  string
   156| 	APIKey   string
   157| 	Timeout  time.Duration
   158| 	Insecure bool
   159| }
   160| type PolicyConfig struct {
   161| 	Path string
   162| 	Mode PolicyMode
   163| }
   164| type LogConfig struct {
   165| 	Format string
   166| 	Level  zerolog.Level
   167| }
   168| type Tuning struct {
   169| 	NotifierSendTimeout            time.Duration
   170| 	BatchChangeDelay               time.Duration
   171| 	NodeMapSessionBufferedChanSize int
   172| }
   173| func LoadConfig(path string, isFile bool) error {
   174| 	if isFile {
   175| 		viper.SetConfigFile(path)
   176| 	} else {
   177| 		viper.SetConfigName("config")
   178| 		if path == "" {
   179| 			viper.AddConfigPath("/etc/headscale/")
   180| 			viper.AddConfigPath("$HOME/.headscale")
   181| 			viper.AddConfigPath(".")
   182| 		} else {
   183| 			viper.AddConfigPath(path)
   184| 		}
   185| 	}
   186| 	envPrefix := "headscale"
   187| 	viper.SetEnvPrefix(envPrefix)
   188| 	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
   189| 	viper.AutomaticEnv()
   190| 	viper.SetDefault("policy.mode", "file")
   191| 	viper.SetDefault("tls_letsencrypt_cache_dir", "/var/www/.cache")
   192| 	viper.SetDefault("tls_letsencrypt_challenge_type", HTTP01ChallengeType)
   193| 	viper.SetDefault("log.level", "info")
   194| 	viper.SetDefault("log.format", TextLogFormat)
   195| 	viper.SetDefault("dns.magic_dns", true)
   196| 	viper.SetDefault("dns.base_domain", "")
   197| 	viper.SetDefault("dns.nameservers.global", []string{})
   198| 	viper.SetDefault("dns.nameservers.split", map[string]string{})
   199| 	viper.SetDefault("dns.search_domains", []string{})
   200| 	viper.SetDefault("dns.extra_records", []tailcfg.DNSRecord{})
   201| 	viper.SetDefault("derp.server.enabled", false)
   202| 	viper.SetDefault("derp.server.stun.enabled", true)
   203| 	viper.SetDefault("derp.server.automatically_add_embedded_derp_region", true)
   204| 	viper.SetDefault("unix_socket", "/var/run/headscale/headscale.sock")
   205| 	viper.SetDefault("unix_socket_permission", "0o770")
   206| 	viper.SetDefault("grpc_listen_addr", ":50443")
   207| 	viper.SetDefault("grpc_allow_insecure", false)
   208| 	viper.SetDefault("cli.timeout", "5s")
   209| 	viper.SetDefault("cli.insecure", false)
   210| 	viper.SetDefault("database.postgres.ssl", false)
   211| 	viper.SetDefault("database.postgres.max_open_conns", 10)
   212| 	viper.SetDefault("database.postgres.max_idle_conns", 10)
   213| 	viper.SetDefault("database.postgres.conn_max_idle_time_secs", 3600)
   214| 	viper.SetDefault("database.sqlite.write_ahead_log", true)
   215| 	viper.SetDefault("oidc.scope", []string{oidc.ScopeOpenID, "profile", "email"})
   216| 	viper.SetDefault("oidc.strip_email_domain", true)
   217| 	viper.SetDefault("oidc.only_start_if_oidc_is_available", true)
   218| 	viper.SetDefault("oidc.expiry", "180d")
   219| 	viper.SetDefault("oidc.use_expiry_from_token", false)
   220| 	viper.SetDefault("logtail.enabled", false)
   221| 	viper.SetDefault("randomize_client_port", false)
   222| 	viper.SetDefault("ephemeral_node_inactivity_timeout", "120s")
   223| 	viper.SetDefault("tuning.notifier_send_timeout", "800ms")
   224| 	viper.SetDefault("tuning.batch_change_delay", "800ms")
   225| 	viper.SetDefault("tuning.node_mapsession_buffered_chan_size", 30)
   226| 	viper.SetDefault("prefixes.allocation", string(IPAllocationStrategySequential))
   227| 	if err := viper.ReadInConfig(); err != nil {
   228| 		return fmt.Errorf("fatal error reading config file: %w", err)
   229| 	}
   230| 	return nil
   231| }
   232| func validateServerConfig() error {
   233| 	depr := deprecator{
   234| 		warns:  make(set.Set[string]),
   235| 		fatals: make(set.Set[string]),
   236| 	}
   237| 	depr.fatalIfNewKeyIsNotUsed("policy.path", "acl_policy_path")
   238| 	depr.warn("dns_config.override_local_dns")
   239| 	depr.fatalIfNewKeyIsNotUsed("dns.magic_dns", "dns_config.magic_dns")
   240| 	depr.fatalIfNewKeyIsNotUsed("dns.base_domain", "dns_config.base_domain")
   241| 	depr.fatalIfNewKeyIsNotUsed("dns.nameservers.global", "dns_config.nameservers")
   242| 	depr.fatalIfNewKeyIsNotUsed("dns.nameservers.split", "dns_config.restricted_nameservers")
   243| 	depr.fatalIfNewKeyIsNotUsed("dns.search_domains", "dns_config.domains")
   244| 	depr.fatalIfNewKeyIsNotUsed("dns.extra_records", "dns_config.extra_records")
   245| 	depr.warn("dns_config.use_username_in_magic_dns")
   246| 	depr.warn("dns.use_username_in_magic_dns")
   247| 	depr.Log()
   248| 	var errorText string
   249| 	if (viper.GetString("tls_letsencrypt_hostname") != "") &&
   250| 		((viper.GetString("tls_cert_path") != "") || (viper.GetString("tls_key_path") != "")) {
   251| 		errorText += "Fatal config error: set either tls_letsencrypt_hostname or tls_cert_path/tls_key_path, not both\n"
   252| 	}
   253| 	if !viper.IsSet("noise") || viper.GetString("noise.private_key_path") == "" {
   254| 		errorText += "Fatal config error: headscale now requires a new `noise.private_key_path` field in the config file for the Tailscale v2 protocol\n"
   255| 	}
   256| 	if (viper.GetString("tls_letsencrypt_hostname") != "") &&
   257| 		(viper.GetString("tls_letsencrypt_challenge_type") == TLSALPN01ChallengeType) &&
   258| 		(!strings.HasSuffix(viper.GetString("listen_addr"), ":443")) {
   259| 		log.Warn().
   260| 			Msg("Warning: when using tls_letsencrypt_hostname with TLS-ALPN-01 as challenge type, headscale must be reachable on port 443, i.e. listen_addr should probably end in :443")
   261| 	}
   262| 	if (viper.GetString("tls_letsencrypt_challenge_type") != HTTP01ChallengeType) &&
   263| 		(viper.GetString("tls_letsencrypt_challenge_type") != TLSALPN01ChallengeType) {
   264| 		errorText += "Fatal config error: the only supported values for tls_letsencrypt_challenge_type are HTTP-01 and TLS-ALPN-01\n"
   265| 	}
   266| 	if !strings.HasPrefix(viper.GetString("server_url"), "http://") &&
   267| 		!strings.HasPrefix(viper.GetString("server_url"), "https://") {
   268| 		errorText += "Fatal config error: server_url must start with https:// or http://\n"
   269| 	}
   270| 	minInactivityTimeout, _ := time.ParseDuration("65s")
   271| 	if viper.GetDuration("ephemeral_node_inactivity_timeout") <= minInactivityTimeout {
   272| 		errorText += fmt.Sprintf(
   273| 			"Fatal config error: ephemeral_node_inactivity_timeout (%s) is set too low, must be more than %s",
   274| 			viper.GetString("ephemeral_node_inactivity_timeout"),
   275| 			minInactivityTimeout,
   276| 		)
   277| 	}
   278| 	if errorText != "" {
   279| 		return errors.New(strings.TrimSuffix(errorText, "\n"))
   280| 	}
   281| 	return nil
   282| }
   283| func tlsConfig() TLSConfig {
   284| 	return TLSConfig{
   285| 		LetsEncrypt: LetsEncryptConfig{
   286| 			Hostname: viper.GetString("tls_letsencrypt_hostname"),
   287| 			Listen:   viper.GetString("tls_letsencrypt_listen"),
   288| 			CacheDir: util.AbsolutePathFromConfigPath(
   289| 				viper.GetString("tls_letsencrypt_cache_dir"),
   290| 			),
   291| 			ChallengeType: viper.GetString("tls_letsencrypt_challenge_type"),
   292| 		},
   293| 		CertPath: util.AbsolutePathFromConfigPath(
   294| 			viper.GetString("tls_cert_path"),
   295| 		),
   296| 		KeyPath: util.AbsolutePathFromConfigPath(
   297| 			viper.GetString("tls_key_path"),
   298| 		),
   299| 	}
   300| }
   301| func derpConfig() DERPConfig {
   302| 	serverEnabled := viper.GetBool("derp.server.enabled")
   303| 	serverRegionID := viper.GetInt("derp.server.region_id")
   304| 	serverRegionCode := viper.GetString("derp.server.region_code")
   305| 	serverRegionName := viper.GetString("derp.server.region_name")
   306| 	stunAddr := viper.GetString("derp.server.stun_listen_addr")
   307| 	privateKeyPath := util.AbsolutePathFromConfigPath(
   308| 		viper.GetString("derp.server.private_key_path"),
   309| 	)
   310| 	ipv4 := viper.GetString("derp.server.ipv4")
   311| 	ipv6 := viper.GetString("derp.server.ipv6")
   312| 	automaticallyAddEmbeddedDerpRegion := viper.GetBool(
   313| 		"derp.server.automatically_add_embedded_derp_region",
   314| 	)
   315| 	if serverEnabled && stunAddr == "" {
   316| 		log.Fatal().
   317| 			Msg("derp.server.stun_listen_addr must be set if derp.server.enabled is true")
   318| 	}
   319| 	urlStrs := viper.GetStringSlice("derp.urls")
   320| 	urls := make([]url.URL, len(urlStrs))
   321| 	for index, urlStr := range urlStrs {
   322| 		urlAddr, err := url.Parse(urlStr)
   323| 		if err != nil {
   324| 			log.Error().
   325| 				Str("url", urlStr).
   326| 				Err(err).
   327| 				Msg("Failed to parse url, ignoring...")
   328| 		}
   329| 		urls[index] = *urlAddr
   330| 	}
   331| 	paths := viper.GetStringSlice("derp.paths")
   332| 	if serverEnabled && !automaticallyAddEmbeddedDerpRegion && len(paths) == 0 {
   333| 		log.Fatal().
   334| 			Msg("Disabling derp.server.automatically_add_embedded_derp_region requires to configure the derp server in derp.paths")
   335| 	}
   336| 	autoUpdate := viper.GetBool("derp.auto_update_enabled")
   337| 	updateFrequency := viper.GetDuration("derp.update_frequency")
   338| 	return DERPConfig{
   339| 		ServerEnabled:                      serverEnabled,
   340| 		ServerRegionID:                     serverRegionID,
   341| 		ServerRegionCode:                   serverRegionCode,
   342| 		ServerRegionName:                   serverRegionName,
   343| 		ServerPrivateKeyPath:               privateKeyPath,
   344| 		STUNAddr:                           stunAddr,
   345| 		URLs:                               urls,
   346| 		Paths:                              paths,
   347| 		AutoUpdate:                         autoUpdate,
   348| 		UpdateFrequency:                    updateFrequency,
   349| 		IPv4:                               ipv4,
   350| 		IPv6:                               ipv6,
   351| 		AutomaticallyAddEmbeddedDerpRegion: automaticallyAddEmbeddedDerpRegion,
   352| 	}
   353| }
   354| func logtailConfig() LogTailConfig {
   355| 	enabled := viper.GetBool("logtail.enabled")
   356| 	return LogTailConfig{
   357| 		Enabled: enabled,
   358| 	}
   359| }
   360| func policyConfig() PolicyConfig {
   361| 	policyPath := viper.GetString("policy.path")
   362| 	policyMode := viper.GetString("policy.mode")
   363| 	return PolicyConfig{
   364| 		Path: policyPath,
   365| 		Mode: PolicyMode(policyMode),
   366| 	}
   367| }
   368| func logConfig() LogConfig {
   369| 	logLevelStr := viper.GetString("log.level")
   370| 	logLevel, err := zerolog.ParseLevel(logLevelStr)
   371| 	if err != nil {
   372| 		logLevel = zerolog.DebugLevel
   373| 	}
   374| 	logFormatOpt := viper.GetString("log.format")
   375| 	var logFormat string
   376| 	switch logFormatOpt {
   377| 	case JSONLogFormat:
   378| 		logFormat = JSONLogFormat
   379| 	case TextLogFormat:
   380| 		logFormat = TextLogFormat
   381| 	case "":
   382| 		logFormat = TextLogFormat
   383| 	default:
   384| 		log.Error().
   385| 			Str("func", "GetLogConfig").
   386| 			Msgf("Could not parse log format: %s. Valid choices are 'json' or 'text'", logFormatOpt)
   387| 	}
   388| 	return LogConfig{
   389| 		Format: logFormat,
   390| 		Level:  logLevel,
   391| 	}
   392| }
   393| func databaseConfig() DatabaseConfig {
   394| 	debug := viper.GetBool("database.debug")
   395| 	type_ := viper.GetString("database.type")
   396| 	skipErrRecordNotFound := viper.GetBool("database.gorm.skip_err_record_not_found")
   397| 	slowThreshold := viper.GetDuration("database.gorm.slow_threshold") * time.Millisecond
   398| 	parameterizedQueries := viper.GetBool("database.gorm.parameterized_queries")
   399| 	prepareStmt := viper.GetBool("database.gorm.prepare_stmt")
   400| 	switch type_ {
   401| 	case DatabaseSqlite, DatabasePostgres:
   402| 		break
   403| 	case "sqlite":
   404| 		type_ = "sqlite3"
   405| 	default:
   406| 		log.Fatal().
   407| 			Msgf("invalid database type %q, must be sqlite, sqlite3 or postgres", type_)
   408| 	}
   409| 	return DatabaseConfig{
   410| 		Type:  type_,
   411| 		Debug: debug,
   412| 		Gorm: GormConfig{
   413| 			Debug:                 debug,
   414| 			SkipErrRecordNotFound: skipErrRecordNotFound,
   415| 			SlowThreshold:         slowThreshold,
   416| 			ParameterizedQueries:  parameterizedQueries,
   417| 			PrepareStmt:           prepareStmt,
   418| 		},
   419| 		Sqlite: SqliteConfig{
   420| 			Path: util.AbsolutePathFromConfigPath(
   421| 				viper.GetString("database.sqlite.path"),
   422| 			),
   423| 			WriteAheadLog: viper.GetBool("database.sqlite.write_ahead_log"),
   424| 		},
   425| 		Postgres: PostgresConfig{
   426| 			Host:               viper.GetString("database.postgres.host"),
   427| 			Port:               viper.GetInt("database.postgres.port"),
   428| 			Name:               viper.GetString("database.postgres.name"),
   429| 			User:               viper.GetString("database.postgres.user"),
   430| 			Pass:               viper.GetString("database.postgres.pass"),
   431| 			Ssl:                viper.GetString("database.postgres.ssl"),
   432| 			MaxOpenConnections: viper.GetInt("database.postgres.max_open_conns"),
   433| 			MaxIdleConnections: viper.GetInt("database.postgres.max_idle_conns"),
   434| 			ConnMaxIdleTimeSecs: viper.GetInt(
   435| 				"database.postgres.conn_max_idle_time_secs",
   436| 			),
   437| 		},
   438| 	}
   439| }
   440| func dns() (DNSConfig, error) {
   441| 	var dns DNSConfig
   442| 	dns.MagicDNS = viper.GetBool("dns.magic_dns")
   443| 	dns.BaseDomain = viper.GetString("dns.base_domain")
   444| 	dns.Nameservers.Global = viper.GetStringSlice("dns.nameservers.global")
   445| 	dns.Nameservers.Split = viper.GetStringMapStringSlice("dns.nameservers.split")
   446| 	dns.SearchDomains = viper.GetStringSlice("dns.search_domains")
   447| 	if viper.IsSet("dns.extra_records") {
   448| 		var extraRecords []tailcfg.DNSRecord
   449| 		err := viper.UnmarshalKey("dns.extra_records", &extraRecords)
   450| 		if err != nil {
   451| 			return DNSConfig{}, fmt.Errorf("unmarshaling dns extra records: %w", err)
   452| 		}
   453| 		dns.ExtraRecords = extraRecords
   454| 	}
   455| 	dns.UserNameInMagicDNS = viper.GetBool("dns.use_username_in_magic_dns")
   456| 	return dns, nil
   457| }
   458| func (d *DNSConfig) globalResolvers() []*dnstype.Resolver {
   459| 	var resolvers []*dnstype.Resolver
   460| 	for _, nsStr := range d.Nameservers.Global {
   461| 		warn := ""
   462| 		if _, err := netip.ParseAddr(nsStr); err == nil {
   463| 			resolvers = append(resolvers, &dnstype.Resolver{
   464| 				Addr: nsStr,
   465| 			})
   466| 			continue
   467| 		} else {
   468| 			warn = fmt.Sprintf("Invalid global nameserver %q. Parsing error: %s ignoring", nsStr, err)
   469| 		}
   470| 		if _, err := url.Parse(nsStr); err == nil {
   471| 			resolvers = append(resolvers, &dnstype.Resolver{
   472| 				Addr: nsStr,
   473| 			})
   474| 			continue
   475| 		} else {
   476| 			warn = fmt.Sprintf("Invalid global nameserver %q. Parsing error: %s ignoring", nsStr, err)
   477| 		}
   478| 		if warn != "" {
   479| 			log.Warn().Msg(warn)
   480| 		}
   481| 	}
   482| 	return resolvers
   483| }
   484| func (d *DNSConfig) splitResolvers() map[string][]*dnstype.Resolver {
   485| 	routes := make(map[string][]*dnstype.Resolver)
   486| 	for domain, nameservers := range d.Nameservers.Split {
   487| 		var resolvers []*dnstype.Resolver
   488| 		for _, nsStr := range nameservers {
   489| 			warn := ""
   490| 			if _, err := netip.ParseAddr(nsStr); err == nil {
   491| 				resolvers = append(resolvers, &dnstype.Resolver{
   492| 					Addr: nsStr,
   493| 				})
   494| 				continue
   495| 			} else {
   496| 				warn = fmt.Sprintf("Invalid split dns nameserver %q. Parsing error: %s ignoring", nsStr, err)
   497| 			}
   498| 			if _, err := url.Parse(nsStr); err == nil {
   499| 				resolvers = append(resolvers, &dnstype.Resolver{
   500| 					Addr: nsStr,
   501| 				})
   502| 				continue
   503| 			} else {
   504| 				warn = fmt.Sprintf("Invalid split dns nameserver %q. Parsing error: %s ignoring", nsStr, err)
   505| 			}
   506| 			if warn != "" {
   507| 				log.Warn().Msg(warn)
   508| 			}
   509| 		}
   510| 		routes[domain] = resolvers
   511| 	}
   512| 	return routes
   513| }
   514| func dnsToTailcfgDNS(dns DNSConfig) *tailcfg.DNSConfig {
   515| 	cfg := tailcfg.DNSConfig{}
   516| 	if dns.BaseDomain == "" && dns.MagicDNS {
   517| 		log.Fatal().Msg("dns.base_domain must be set when using MagicDNS (dns.magic_dns)")
   518| 	}
   519| 	cfg.Proxied = dns.MagicDNS
   520| 	cfg.ExtraRecords = dns.ExtraRecords
   521| 	cfg.Resolvers = dns.globalResolvers()
   522| 	routes := dns.splitResolvers()
   523| 	cfg.Routes = routes
   524| 	if dns.BaseDomain != "" {
   525| 		cfg.Domains = []string{dns.BaseDomain}
   526| 	}
   527| 	cfg.Domains = append(cfg.Domains, dns.SearchDomains...)
   528| 	return &cfg
   529| }
   530| func prefixV4() (*netip.Prefix, error) {
   531| 	prefixV4Str := viper.GetString("prefixes.v4")
   532| 	if prefixV4Str == "" {
   533| 		return nil, nil
   534| 	}
   535| 	prefixV4, err := netip.ParsePrefix(prefixV4Str)
   536| 	if err != nil {
   537| 		return nil, fmt.Errorf("parsing IPv4 prefix from config: %w", err)
   538| 	}
   539| 	builder := netipx.IPSetBuilder{}
   540| 	builder.AddPrefix(tsaddr.CGNATRange())
   541| 	ipSet, _ := builder.IPSet()
   542| 	if !ipSet.ContainsPrefix(prefixV4) {
   543| 		log.Warn().
   544| 			Msgf("Prefix %s is not in the %s range. This is an unsupported configuration.",
   545| 				prefixV4Str, tsaddr.CGNATRange())
   546| 	}
   547| 	return &prefixV4, nil
   548| }
   549| func prefixV6() (*netip.Prefix, error) {
   550| 	prefixV6Str := viper.GetString("prefixes.v6")
   551| 	if prefixV6Str == "" {
   552| 		return nil, nil
   553| 	}
   554| 	prefixV6, err := netip.ParsePrefix(prefixV6Str)
   555| 	if err != nil {
   556| 		return nil, fmt.Errorf("parsing IPv6 prefix from config: %w", err)
   557| 	}
   558| 	builder := netipx.IPSetBuilder{}
   559| 	builder.AddPrefix(tsaddr.TailscaleULARange())
   560| 	ipSet, _ := builder.IPSet()
   561| 	if !ipSet.ContainsPrefix(prefixV6) {
   562| 		log.Warn().
   563| 			Msgf("Prefix %s is not in the %s range. This is an unsupported configuration.",
   564| 				prefixV6Str, tsaddr.TailscaleULARange())
   565| 	}
   566| 	return &prefixV6, nil
   567| }
   568| func LoadCLIConfig() (*Config, error) {
   569| 	logConfig := logConfig()
   570| 	zerolog.SetGlobalLevel(logConfig.Level)
   571| 	return &Config{
   572| 		DisableUpdateCheck: viper.GetBool("disable_check_updates"),
   573| 		UnixSocket:         viper.GetString("unix_socket"),
   574| 		CLI: CLIConfig{
   575| 			Address:  viper.GetString("cli.address"),
   576| 			APIKey:   viper.GetString("cli.api_key"),
   577| 			Timeout:  viper.GetDuration("cli.timeout"),
   578| 			Insecure: viper.GetBool("cli.insecure"),
   579| 		},
   580| 		Log: logConfig,
   581| 	}, nil
   582| }
   583| func LoadServerConfig() (*Config, error) {
   584| 	if err := validateServerConfig(); err != nil {
   585| 		return nil, err
   586| 	}
   587| 	logConfig := logConfig()
   588| 	zerolog.SetGlobalLevel(logConfig.Level)
   589| 	prefix4, err := prefixV4()
   590| 	if err != nil {
   591| 		return nil, err
   592| 	}
   593| 	prefix6, err := prefixV6()
   594| 	if err != nil {
   595| 		return nil, err
   596| 	}
   597| 	if prefix4 == nil && prefix6 == nil {
   598| 		return nil, fmt.Errorf("no IPv4 or IPv6 prefix configured, minimum one prefix is required")
   599| 	}
   600| 	allocStr := viper.GetString("prefixes.allocation")
   601| 	var alloc IPAllocationStrategy
   602| 	switch allocStr {
   603| 	case string(IPAllocationStrategySequential):
   604| 		alloc = IPAllocationStrategySequential
   605| 	case string(IPAllocationStrategyRandom):
   606| 		alloc = IPAllocationStrategyRandom
   607| 	default:
   608| 		return nil, fmt.Errorf("config error, prefixes.allocation is set to %s, which is not a valid strategy, allowed options: %s, %s", allocStr, IPAllocationStrategySequential, IPAllocationStrategyRandom)
   609| 	}
   610| 	dnsConfig, err := dns()
   611| 	if err != nil {
   612| 		return nil, err
   613| 	}
   614| 	derpConfig := derpConfig()
   615| 	logTailConfig := logtailConfig()
   616| 	randomizeClientPort := viper.GetBool("randomize_client_port")
   617| 	oidcClientSecret := viper.GetString("oidc.client_secret")
   618| 	oidcClientSecretPath := viper.GetString("oidc.client_secret_path")
   619| 	if oidcClientSecretPath != "" && oidcClientSecret != "" {
   620| 		return nil, errOidcMutuallyExclusive
   621| 	}
   622| 	if oidcClientSecretPath != "" {
   623| 		secretBytes, err := os.ReadFile(os.ExpandEnv(oidcClientSecretPath))
   624| 		if err != nil {
   625| 			return nil, err
   626| 		}
   627| 		oidcClientSecret = strings.TrimSpace(string(secretBytes))
   628| 	}
   629| 	serverURL := viper.GetString("server_url")
   630| 	if !dnsConfig.UserNameInMagicDNS && dnsConfig.BaseDomain != "" && strings.Contains(serverURL, dnsConfig.BaseDomain) {
   631| 		return nil, errors.New("server_url cannot contain the base_domain, this will cause the headscale server and embedded DERP to become unreachable from the Tailscale node.")
   632| 	}
   633| 	return &Config{
   634| 		ServerURL:          serverURL,
   635| 		Addr:               viper.GetString("listen_addr"),
   636| 		MetricsAddr:        viper.GetString("metrics_listen_addr"),
   637| 		GRPCAddr:           viper.GetString("grpc_listen_addr"),
   638| 		GRPCAllowInsecure:  viper.GetBool("grpc_allow_insecure"),
   639| 		DisableUpdateCheck: false,
   640| 		PrefixV4:     prefix4,
   641| 		PrefixV6:     prefix6,
   642| 		IPAllocation: IPAllocationStrategy(alloc),
   643| 		NoisePrivateKeyPath: util.AbsolutePathFromConfigPath(
   644| 			viper.GetString("noise.private_key_path"),
   645| 		),
   646| 		BaseDomain: dnsConfig.BaseDomain,
   647| 		DERP: derpConfig,
   648| 		EphemeralNodeInactivityTimeout: viper.GetDuration(
   649| 			"ephemeral_node_inactivity_timeout",
   650| 		),
   651| 		Database: databaseConfig(),
   652| 		TLS: tlsConfig(),
   653| 		DNSConfig:             dnsToTailcfgDNS(dnsConfig),
   654| 		DNSUserNameInMagicDNS: dnsConfig.UserNameInMagicDNS,
   655| 		ACMEEmail: viper.GetString("acme_email"),
   656| 		ACMEURL:   viper.GetString("acme_url"),
   657| 		UnixSocket:           viper.GetString("unix_socket"),
   658| 		UnixSocketPermission: util.GetFileMode("unix_socket_permission"),
   659| 		OIDC: OIDCConfig{
   660| 			OnlyStartIfOIDCIsAvailable: viper.GetBool(
   661| 				"oidc.only_start_if_oidc_is_available",
   662| 			),
   663| 			Issuer:           viper.GetString("oidc.issuer"),
   664| 			ClientID:         viper.GetString("oidc.client_id"),
   665| 			ClientSecret:     oidcClientSecret,
   666| 			Scope:            viper.GetStringSlice("oidc.scope"),
   667| 			ExtraParams:      viper.GetStringMapString("oidc.extra_params"),
   668| 			AllowedDomains:   viper.GetStringSlice("oidc.allowed_domains"),
   669| 			AllowedUsers:     viper.GetStringSlice("oidc.allowed_users"),
   670| 			AllowedGroups:    viper.GetStringSlice("oidc.allowed_groups"),
   671| 			StripEmaildomain: viper.GetBool("oidc.strip_email_domain"),
   672| 			Expiry: func() time.Duration {
   673| 				if value := viper.GetString("oidc.expiry"); value == "0" {
   674| 					return maxDuration
   675| 				} else {
   676| 					expiry, err := model.ParseDuration(value)
   677| 					if err != nil {
   678| 						log.Warn().Msg("failed to parse oidc.expiry, defaulting back to 180 days")
   679| 						return defaultOIDCExpiryTime
   680| 					}
   681| 					return time.Duration(expiry)
   682| 				}
   683| 			}(),
   684| 			UseExpiryFromToken: viper.GetBool("oidc.use_expiry_from_token"),
   685| 		},
   686| 		LogTail:             logTailConfig,
   687| 		RandomizeClientPort: randomizeClientPort,
   688| 		Policy: policyConfig(),
   689| 		CLI: CLIConfig{
   690| 			Address:  viper.GetString("cli.address"),
   691| 			APIKey:   viper.GetString("cli.api_key"),
   692| 			Timeout:  viper.GetDuration("cli.timeout"),
   693| 			Insecure: viper.GetBool("cli.insecure"),
   694| 		},
   695| 		Log: logConfig,
   696| 		Tuning: Tuning{
   697| 			NotifierSendTimeout:            viper.GetDuration("tuning.notifier_send_timeout"),
   698| 			BatchChangeDelay:               viper.GetDuration("tuning.batch_change_delay"),
   699| 			NodeMapSessionBufferedChanSize: viper.GetInt("tuning.node_mapsession_buffered_chan_size"),
   700| 		},
   701| 	}, nil
   702| }
   703| type deprecator struct {
   704| 	warns  set.Set[string]
   705| 	fatals set.Set[string]
   706| }
   707| func (d *deprecator) warnWithAlias(newKey, oldKey string) {
   708| 	viper.RegisterAlias(newKey, oldKey)
   709| 	if viper.IsSet(oldKey) {
   710| 		d.warns.Add(fmt.Sprintf("The %q configuration key is deprecated. Please use %q instead. %q will be removed in the future.", oldKey, newKey, oldKey))
   711| 	}
   712| }
   713| func (d *deprecator) fatal(newKey, oldKey string) {
   714| 	if viper.IsSet(oldKey) {
   715| 		d.fatals.Add(fmt.Sprintf("The %q configuration key is deprecated. Please use %q instead. %q has been removed.", oldKey, newKey, oldKey))
   716| 	}
   717| }
   718| func (d *deprecator) fatalIfNewKeyIsNotUsed(newKey, oldKey string) {
   719| 	if viper.IsSet(oldKey) && !viper.IsSet(newKey) {
   720| 		d.fatals.Add(fmt.Sprintf("The %q configuration key is deprecated. Please use %q instead. %q has been removed.", oldKey, newKey, oldKey))
   721| 	} else if viper.IsSet(oldKey) {
   722| 		d.warns.Add(fmt.Sprintf("The %q configuration key is deprecated. Please use %q instead. %q has been removed.", oldKey, newKey, oldKey))
   723| 	}
   724| }
   725| func (d *deprecator) warnNoAlias(newKey, oldKey string) {
   726| 	if viper.IsSet(oldKey) {
   727| 		d.warns.Add(fmt.Sprintf("The %q configuration key is deprecated. Please use %q instead. %q has been removed.", oldKey, newKey, oldKey))
   728| 	}
   729| }
   730| func (d *deprecator) warn(oldKey string) {
   731| 	if viper.IsSet(oldKey) {
   732| 		d.warns.Add(fmt.Sprintf("The %q configuration key is deprecated and has been removed. Please see the changelog for more details.", oldKey))
   733| 	}
   734| }
   735| func (d *deprecator) String() string {
   736| 	var b strings.Builder
   737| 	for _, w := range d.warns.Slice() {
   738| 		fmt.Fprintf(&b, "WARN: %s\n", w)
   739| 	}
   740| 	for _, f := range d.fatals.Slice() {
   741| 		fmt.Fprintf(&b, "FATAL: %s\n", f)
   742| 	}
   743| 	return b.String()
   744| }
   745| func (d *deprecator) Log() {
   746| 	if len(d.fatals) > 0 {
   747| 		log.Fatal().Msg("\n" + d.String())
   748| 	} else if len(d.warns) > 0 {
   749| 		log.Warn().Msg("\n" + d.String())
   750| 	}
   751| }


# ====================================================================
# FILE: hscontrol/types/const.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-12 ---
     1| package types
     2| import "time"
     3| const (
     4| 	HTTPTimeout            = 30 * time.Second
     5| 	HTTPShutdownTimeout    = 3 * time.Second
     6| 	TLSALPN01ChallengeType = "TLS-ALPN-01"
     7| 	HTTP01ChallengeType    = "HTTP-01"
     8| 	JSONLogFormat = "json"
     9| 	TextLogFormat = "text"
    10| 	KeepAliveInterval = 60 * time.Second
    11| 	MaxHostnameLength = 255
    12| )


# ====================================================================
# FILE: hscontrol/types/node.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-375 ---
     1| package types
     2| import (
     3| 	"database/sql"
     4| 	"encoding/json"
     5| 	"errors"
     6| 	"fmt"
     7| 	"net/netip"
     8| 	"strconv"
     9| 	"strings"
    10| 	"time"
    11| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    12| 	"github.com/juanfont/headscale/hscontrol/policy/matcher"
    13| 	"github.com/juanfont/headscale/hscontrol/util"
    14| 	"go4.org/netipx"
    15| 	"google.golang.org/protobuf/types/known/timestamppb"
    16| 	"gorm.io/gorm"
    17| 	"tailscale.com/tailcfg"
    18| 	"tailscale.com/types/key"
    19| )
    20| var (
    21| 	ErrNodeAddressesInvalid = errors.New("failed to parse node addresses")
    22| 	ErrHostnameTooLong      = errors.New("hostname too long, cannot except 255 ASCII chars")
    23| 	ErrNodeHasNoGivenName   = errors.New("node has no given name")
    24| 	ErrNodeUserHasNoName    = errors.New("node user has no name")
    25| )
    26| type NodeID uint64
    27| func (id NodeID) StableID() tailcfg.StableNodeID {
    28| 	return tailcfg.StableNodeID(strconv.FormatUint(uint64(id), util.Base10))
    29| }
    30| func (id NodeID) NodeID() tailcfg.NodeID {
    31| 	return tailcfg.NodeID(id)
    32| }
    33| func (id NodeID) Uint64() uint64 {
    34| 	return uint64(id)
    35| }
    36| func (id NodeID) String() string {
    37| 	return strconv.FormatUint(id.Uint64(), util.Base10)
    38| }
    39| type Node struct {
    40| 	ID NodeID `gorm:"primary_key"`
    41| 	MachineKeyDatabaseField string            `gorm:"column:machine_key;unique_index"`
    42| 	MachineKey              key.MachinePublic `gorm:"-"`
    43| 	NodeKeyDatabaseField string         `gorm:"column:node_key"`
    44| 	NodeKey              key.NodePublic `gorm:"-"`
    45| 	DiscoKeyDatabaseField string          `gorm:"column:disco_key"`
    46| 	DiscoKey              key.DiscoPublic `gorm:"-"`
    47| 	EndpointsDatabaseField StringList       `gorm:"column:endpoints"`
    48| 	Endpoints              []netip.AddrPort `gorm:"-"`
    49| 	HostinfoDatabaseField string            `gorm:"column:host_info"`
    50| 	Hostinfo              *tailcfg.Hostinfo `gorm:"-"`
    51| 	IPv4DatabaseField sql.NullString `gorm:"column:ipv4"`
    52| 	IPv4              *netip.Addr    `gorm:"-"`
    53| 	IPv6DatabaseField sql.NullString `gorm:"column:ipv6"`
    54| 	IPv6              *netip.Addr    `gorm:"-"`
    55| 	Hostname string
    56| 	GivenName string `gorm:"type:varchar(63);unique_index"`
    57| 	UserID    uint
    58| 	User      User `gorm:"constraint:OnDelete:CASCADE;"`
    59| 	RegisterMethod string
    60| 	ForcedTags StringList
    61| 	AuthKeyID *uint64     `sql:"DEFAULT:NULL"`
    62| 	AuthKey   *PreAuthKey `gorm:"constraint:OnDelete:SET NULL;"`
    63| 	LastSeen *time.Time
    64| 	Expiry   *time.Time
    65| 	Routes []Route `gorm:"constraint:OnDelete:CASCADE;"`
    66| 	CreatedAt time.Time
    67| 	UpdatedAt time.Time
    68| 	DeletedAt *time.Time
    69| 	IsOnline *bool `gorm:"-"`
    70| }
    71| type (
    72| 	Nodes []*Node
    73| )
    74| func (node Node) IsExpired() bool {
    75| 	if node.Expiry == nil || node.Expiry.IsZero() {
    76| 		return false
    77| 	}
    78| 	return time.Since(*node.Expiry) > 0
    79| }
    80| func (node *Node) IsEphemeral() bool {
    81| 	return node.AuthKey != nil && node.AuthKey.Ephemeral
    82| }
    83| func (node *Node) IPs() []netip.Addr {
    84| 	var ret []netip.Addr
    85| 	if node.IPv4 != nil {
    86| 		ret = append(ret, *node.IPv4)
    87| 	}
    88| 	if node.IPv6 != nil {
    89| 		ret = append(ret, *node.IPv6)
    90| 	}
    91| 	return ret
    92| }
    93| func (node *Node) Prefixes() []netip.Prefix {
    94| 	addrs := []netip.Prefix{}
    95| 	for _, nodeAddress := range node.IPs() {
    96| 		ip := netip.PrefixFrom(nodeAddress, nodeAddress.BitLen())
    97| 		addrs = append(addrs, ip)
    98| 	}
    99| 	return addrs
   100| }
   101| func (node *Node) IPsAsString() []string {
   102| 	var ret []string
   103| 	if node.IPv4 != nil {
   104| 		ret = append(ret, node.IPv4.String())
   105| 	}
   106| 	if node.IPv6 != nil {
   107| 		ret = append(ret, node.IPv6.String())
   108| 	}
   109| 	return ret
   110| }
   111| func (node *Node) InIPSet(set *netipx.IPSet) bool {
   112| 	for _, nodeAddr := range node.IPs() {
   113| 		if set.Contains(nodeAddr) {
   114| 			return true
   115| 		}
   116| 	}
   117| 	return false
   118| }
   119| func (node *Node) AppendToIPSet(build *netipx.IPSetBuilder) {
   120| 	for _, ip := range node.IPs() {
   121| 		build.Add(ip)
   122| 	}
   123| }
   124| func (node *Node) CanAccess(filter []tailcfg.FilterRule, node2 *Node) bool {
   125| 	src := node.IPs()
   126| 	allowedIPs := node2.IPs()
   127| 	for _, route := range node2.Routes {
   128| 		if route.Enabled {
   129| 			allowedIPs = append(allowedIPs, netip.Prefix(route.Prefix).Addr())
   130| 		}
   131| 	}
   132| 	for _, rule := range filter {
   133| 		matcher := matcher.MatchFromFilterRule(rule)
   134| 		if !matcher.SrcsContainsIPs(src) {
   135| 			continue
   136| 		}
   137| 		if matcher.DestsContainsIP(allowedIPs) {
   138| 			return true
   139| 		}
   140| 	}
   141| 	return false
   142| }
   143| func (nodes Nodes) FilterByIP(ip netip.Addr) Nodes {
   144| 	var found Nodes
   145| 	for _, node := range nodes {
   146| 		if node.IPv4 != nil && ip == *node.IPv4 {
   147| 			found = append(found, node)
   148| 			continue
   149| 		}
   150| 		if node.IPv6 != nil && ip == *node.IPv6 {
   151| 			found = append(found, node)
   152| 		}
   153| 	}
   154| 	return found
   155| }
   156| func (node *Node) BeforeSave(tx *gorm.DB) error {
   157| 	node.MachineKeyDatabaseField = node.MachineKey.String()
   158| 	node.NodeKeyDatabaseField = node.NodeKey.String()
   159| 	node.DiscoKeyDatabaseField = node.DiscoKey.String()
   160| 	var endpoints StringList
   161| 	for _, addrPort := range node.Endpoints {
   162| 		endpoints = append(endpoints, addrPort.String())
   163| 	}
   164| 	node.EndpointsDatabaseField = endpoints
   165| 	hi, err := json.Marshal(node.Hostinfo)
   166| 	if err != nil {
   167| 		return fmt.Errorf("marshalling Hostinfo to store in db: %w", err)
   168| 	}
   169| 	node.HostinfoDatabaseField = string(hi)
   170| 	if node.IPv4 != nil {
   171| 		node.IPv4DatabaseField.String, node.IPv4DatabaseField.Valid = node.IPv4.String(), true
   172| 	} else {
   173| 		node.IPv4DatabaseField.String, node.IPv4DatabaseField.Valid = "", false
   174| 	}
   175| 	if node.IPv6 != nil {
   176| 		node.IPv6DatabaseField.String, node.IPv6DatabaseField.Valid = node.IPv6.String(), true
   177| 	} else {
   178| 		node.IPv6DatabaseField.String, node.IPv6DatabaseField.Valid = "", false
   179| 	}
   180| 	return nil
   181| }
   182| func (node *Node) AfterFind(tx *gorm.DB) error {
   183| 	var machineKey key.MachinePublic
   184| 	if err := machineKey.UnmarshalText([]byte(node.MachineKeyDatabaseField)); err != nil {
   185| 		return fmt.Errorf("unmarshalling machine key from db: %w", err)
   186| 	}
   187| 	node.MachineKey = machineKey
   188| 	var nodeKey key.NodePublic
   189| 	if err := nodeKey.UnmarshalText([]byte(node.NodeKeyDatabaseField)); err != nil {
   190| 		return fmt.Errorf("unmarshalling node key from db: %w", err)
   191| 	}
   192| 	node.NodeKey = nodeKey
   193| 	if node.DiscoKeyDatabaseField != "" {
   194| 		var discoKey key.DiscoPublic
   195| 		if err := discoKey.UnmarshalText([]byte(node.DiscoKeyDatabaseField)); err != nil {
   196| 			return fmt.Errorf("unmarshalling disco key from db: %w", err)
   197| 		}
   198| 		node.DiscoKey = discoKey
   199| 	}
   200| 	endpoints := make([]netip.AddrPort, len(node.EndpointsDatabaseField))
   201| 	for idx, ep := range node.EndpointsDatabaseField {
   202| 		addrPort, err := netip.ParseAddrPort(ep)
   203| 		if err != nil {
   204| 			return fmt.Errorf("parsing endpoint from db: %w", err)
   205| 		}
   206| 		endpoints[idx] = addrPort
   207| 	}
   208| 	node.Endpoints = endpoints
   209| 	var hi tailcfg.Hostinfo
   210| 	if err := json.Unmarshal([]byte(node.HostinfoDatabaseField), &hi); err != nil {
   211| 		return fmt.Errorf("unmarshalling hostinfo from database: %w", err)
   212| 	}
   213| 	node.Hostinfo = &hi
   214| 	if node.IPv4DatabaseField.Valid {
   215| 		ip, err := netip.ParseAddr(node.IPv4DatabaseField.String)
   216| 		if err != nil {
   217| 			return fmt.Errorf("parsing IPv4 from database: %w", err)
   218| 		}
   219| 		node.IPv4 = &ip
   220| 	}
   221| 	if node.IPv6DatabaseField.Valid {
   222| 		ip, err := netip.ParseAddr(node.IPv6DatabaseField.String)
   223| 		if err != nil {
   224| 			return fmt.Errorf("parsing IPv6 from database: %w", err)
   225| 		}
   226| 		node.IPv6 = &ip
   227| 	}
   228| 	return nil
   229| }
   230| func (node *Node) Proto() *v1.Node {
   231| 	nodeProto := &v1.Node{
   232| 		Id:         uint64(node.ID),
   233| 		MachineKey: node.MachineKey.String(),
   234| 		NodeKey:  node.NodeKey.String(),
   235| 		DiscoKey: node.DiscoKey.String(),
   236| 		IpAddresses: node.IPsAsString(),
   237| 		Name:        node.Hostname,
   238| 		GivenName:   node.GivenName,
   239| 		User:        node.User.Proto(),
   240| 		ForcedTags:  node.ForcedTags,
   241| 		RegisterMethod: node.RegisterMethodToV1Enum(),
   242| 		CreatedAt: timestamppb.New(node.CreatedAt),
   243| 	}
   244| 	if node.AuthKey != nil {
   245| 		nodeProto.PreAuthKey = node.AuthKey.Proto()
   246| 	}
   247| 	if node.LastSeen != nil {
   248| 		nodeProto.LastSeen = timestamppb.New(*node.LastSeen)
   249| 	}
   250| 	if node.Expiry != nil {
   251| 		nodeProto.Expiry = timestamppb.New(*node.Expiry)
   252| 	}
   253| 	return nodeProto
   254| }
   255| func (node *Node) GetFQDN(cfg *Config, baseDomain string) (string, error) {
   256| 	if node.GivenName == "" {
   257| 		return "", fmt.Errorf("failed to create valid FQDN: %w", ErrNodeHasNoGivenName)
   258| 	}
   259| 	hostname := node.GivenName
   260| 	if baseDomain != "" {
   261| 		hostname = fmt.Sprintf(
   262| 			"%s.%s",
   263| 			node.GivenName,
   264| 			baseDomain,
   265| 		)
   266| 	}
   267| 	if cfg.DNSUserNameInMagicDNS {
   268| 		if node.User.Name == "" {
   269| 			return "", fmt.Errorf("failed to create valid FQDN: %w", ErrNodeUserHasNoName)
   270| 		}
   271| 		hostname = fmt.Sprintf(
   272| 			"%s.%s.%s",
   273| 			node.GivenName,
   274| 			node.User.Name,
   275| 			baseDomain,
   276| 		)
   277| 	}
   278| 	if len(hostname) > MaxHostnameLength {
   279| 		return "", fmt.Errorf(
   280| 			"failed to create valid FQDN (%s): %w",
   281| 			hostname,
   282| 			ErrHostnameTooLong,
   283| 		)
   284| 	}
   285| 	return hostname, nil
   286| }
   287| func (node *Node) PeerChangeFromMapRequest(req tailcfg.MapRequest) tailcfg.PeerChange {
   288| 	ret := tailcfg.PeerChange{
   289| 		NodeID: tailcfg.NodeID(node.ID),
   290| 	}
   291| 	if node.NodeKey.String() != req.NodeKey.String() {
   292| 		ret.Key = &req.NodeKey
   293| 	}
   294| 	if node.DiscoKey.String() != req.DiscoKey.String() {
   295| 		ret.DiscoKey = &req.DiscoKey
   296| 	}
   297| 	if node.Hostinfo != nil &&
   298| 		node.Hostinfo.NetInfo != nil &&
   299| 		req.Hostinfo != nil &&
   300| 		req.Hostinfo.NetInfo != nil &&
   301| 		node.Hostinfo.NetInfo.PreferredDERP != req.Hostinfo.NetInfo.PreferredDERP {
   302| 		ret.DERPRegion = req.Hostinfo.NetInfo.PreferredDERP
   303| 	}
   304| 	if req.Hostinfo != nil && req.Hostinfo.NetInfo != nil {
   305| 		if node.Hostinfo == nil {
   306| 			ret.DERPRegion = req.Hostinfo.NetInfo.PreferredDERP
   307| 		} else if node.Hostinfo.NetInfo == nil {
   308| 			ret.DERPRegion = req.Hostinfo.NetInfo.PreferredDERP
   309| 		} else {
   310| 			if node.Hostinfo.NetInfo.PreferredDERP != req.Hostinfo.NetInfo.PreferredDERP {
   311| 				ret.DERPRegion = req.Hostinfo.NetInfo.PreferredDERP
   312| 			}
   313| 		}
   314| 	}
   315| 	ret.Endpoints = req.Endpoints
   316| 	now := time.Now()
   317| 	ret.LastSeen = &now
   318| 	return ret
   319| }
   320| func (node *Node) RegisterMethodToV1Enum() v1.RegisterMethod {
   321| 	switch node.RegisterMethod {
   322| 	case "authkey":
   323| 		return v1.RegisterMethod_REGISTER_METHOD_AUTH_KEY
   324| 	case "oidc":
   325| 		return v1.RegisterMethod_REGISTER_METHOD_OIDC
   326| 	case "cli":
   327| 		return v1.RegisterMethod_REGISTER_METHOD_CLI
   328| 	default:
   329| 		return v1.RegisterMethod_REGISTER_METHOD_UNSPECIFIED
   330| 	}
   331| }
   332| func (node *Node) ApplyPeerChange(change *tailcfg.PeerChange) {
   333| 	if change.Key != nil {
   334| 		node.NodeKey = *change.Key
   335| 	}
   336| 	if change.DiscoKey != nil {
   337| 		node.DiscoKey = *change.DiscoKey
   338| 	}
   339| 	if change.Online != nil {
   340| 		node.IsOnline = change.Online
   341| 	}
   342| 	if change.Endpoints != nil {
   343| 		node.Endpoints = change.Endpoints
   344| 	}
   345| 	if change.DERPRegion != 0 {
   346| 		if node.Hostinfo == nil {
   347| 			node.Hostinfo = &tailcfg.Hostinfo{
   348| 				NetInfo: &tailcfg.NetInfo{
   349| 					PreferredDERP: change.DERPRegion,
   350| 				},
   351| 			}
   352| 		} else if node.Hostinfo.NetInfo == nil {
   353| 			node.Hostinfo.NetInfo = &tailcfg.NetInfo{
   354| 				PreferredDERP: change.DERPRegion,
   355| 			}
   356| 		} else {
   357| 			node.Hostinfo.NetInfo.PreferredDERP = change.DERPRegion
   358| 		}
   359| 	}
   360| 	node.LastSeen = change.LastSeen
   361| }
   362| func (nodes Nodes) String() string {
   363| 	temp := make([]string, len(nodes))
   364| 	for index, node := range nodes {
   365| 		temp[index] = node.Hostname
   366| 	}
   367| 	return fmt.Sprintf("[ %s ](%d)", strings.Join(temp, ", "), len(temp))
   368| }
   369| func (nodes Nodes) IDMap() map[NodeID]*Node {
   370| 	ret := map[NodeID]*Node{}
   371| 	for _, node := range nodes {
   372| 		ret[node.ID] = node
   373| 	}
   374| 	return ret
   375| }


# ====================================================================
# FILE: hscontrol/types/policy.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-13 ---
     1| package types
     2| import (
     3| 	"errors"
     4| 	"gorm.io/gorm"
     5| )
     6| var (
     7| 	ErrPolicyNotFound         = errors.New("acl policy not found")
     8| 	ErrPolicyUpdateIsDisabled = errors.New("update is disabled for modes other than 'database'")
     9| )
    10| type Policy struct {
    11| 	gorm.Model
    12| 	Data string
    13| }


# ====================================================================
# FILE: hscontrol/types/preauth_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| package types
     2| import (
     3| 	"strconv"
     4| 	"time"
     5| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     6| 	"github.com/juanfont/headscale/hscontrol/util"
     7| 	"google.golang.org/protobuf/types/known/timestamppb"
     8| )
     9| type PreAuthKey struct {
    10| 	ID        uint64 `gorm:"primary_key"`
    11| 	Key       string
    12| 	UserID    uint
    13| 	User      User `gorm:"constraint:OnDelete:CASCADE;"`
    14| 	Reusable  bool
    15| 	Ephemeral bool               `gorm:"default:false"`
    16| 	Used      bool               `gorm:"default:false"`
    17| 	ACLTags   []PreAuthKeyACLTag `gorm:"constraint:OnDelete:CASCADE;"`
    18| 	CreatedAt  *time.Time
    19| 	Expiration *time.Time
    20| }
    21| type PreAuthKeyACLTag struct {
    22| 	ID           uint64 `gorm:"primary_key"`
    23| 	PreAuthKeyID uint64
    24| 	Tag          string
    25| }
    26| func (key *PreAuthKey) Proto() *v1.PreAuthKey {
    27| 	protoKey := v1.PreAuthKey{
    28| 		User:      key.User.Name,
    29| 		Id:        strconv.FormatUint(key.ID, util.Base10),
    30| 		Key:       key.Key,
    31| 		Ephemeral: key.Ephemeral,
    32| 		Reusable:  key.Reusable,
    33| 		Used:      key.Used,
    34| 		AclTags:   make([]string, len(key.ACLTags)),
    35| 	}
    36| 	if key.Expiration != nil {
    37| 		protoKey.Expiration = timestamppb.New(*key.Expiration)
    38| 	}
    39| 	if key.CreatedAt != nil {
    40| 		protoKey.CreatedAt = timestamppb.New(*key.CreatedAt)
    41| 	}
    42| 	for idx := range key.ACLTags {
    43| 		protoKey.AclTags[idx] = key.ACLTags[idx].Tag
    44| 	}
    45| 	return &protoKey
    46| }


# ====================================================================
# FILE: hscontrol/types/routes.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-78 ---
     1| package types
     2| import (
     3| 	"fmt"
     4| 	"net/netip"
     5| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     6| 	"google.golang.org/protobuf/types/known/timestamppb"
     7| 	"gorm.io/gorm"
     8| )
     9| var (
    10| 	ExitRouteV4 = netip.MustParsePrefix("0.0.0.0/0")
    11| 	ExitRouteV6 = netip.MustParsePrefix("::/0")
    12| )
    13| type Route struct {
    14| 	gorm.Model
    15| 	NodeID uint64
    16| 	Node   Node
    17| 	Prefix IPPrefix
    18| 	Advertised bool
    19| 	Enabled    bool
    20| 	IsPrimary  bool
    21| }
    22| type Routes []Route
    23| func (r *Route) String() string {
    24| 	return fmt.Sprintf("%s:%s", r.Node.Hostname, netip.Prefix(r.Prefix).String())
    25| }
    26| func (r *Route) IsExitRoute() bool {
    27| 	return netip.Prefix(r.Prefix) == ExitRouteV4 || netip.Prefix(r.Prefix) == ExitRouteV6
    28| }
    29| func (r *Route) IsAnnouncable() bool {
    30| 	return r.Advertised && r.Enabled
    31| }
    32| func (rs Routes) Prefixes() []netip.Prefix {
    33| 	prefixes := make([]netip.Prefix, len(rs))
    34| 	for i, r := range rs {
    35| 		prefixes[i] = netip.Prefix(r.Prefix)
    36| 	}
    37| 	return prefixes
    38| }
    39| func (rs Routes) Primaries() Routes {
    40| 	res := make(Routes, 0)
    41| 	for _, route := range rs {
    42| 		if route.IsPrimary {
    43| 			res = append(res, route)
    44| 		}
    45| 	}
    46| 	return res
    47| }
    48| func (rs Routes) PrefixMap() map[IPPrefix][]Route {
    49| 	res := map[IPPrefix][]Route{}
    50| 	for _, route := range rs {
    51| 		if _, ok := res[route.Prefix]; ok {
    52| 			res[route.Prefix] = append(res[route.Prefix], route)
    53| 		} else {
    54| 			res[route.Prefix] = []Route{route}
    55| 		}
    56| 	}
    57| 	return res
    58| }
    59| func (rs Routes) Proto() []*v1.Route {
    60| 	protoRoutes := []*v1.Route{}
    61| 	for _, route := range rs {
    62| 		protoRoute := v1.Route{
    63| 			Id:         uint64(route.ID),
    64| 			Node:       route.Node.Proto(),
    65| 			Prefix:     netip.Prefix(route.Prefix).String(),
    66| 			Advertised: route.Advertised,
    67| 			Enabled:    route.Enabled,
    68| 			IsPrimary:  route.IsPrimary,
    69| 			CreatedAt:  timestamppb.New(route.CreatedAt),
    70| 			UpdatedAt:  timestamppb.New(route.UpdatedAt),
    71| 		}
    72| 		if route.DeletedAt.Valid {
    73| 			protoRoute.DeletedAt = timestamppb.New(route.DeletedAt.Time)
    74| 		}
    75| 		protoRoutes = append(protoRoutes, &protoRoute)
    76| 	}
    77| 	return protoRoutes
    78| }


# ====================================================================
# FILE: hscontrol/types/users.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-52 ---
     1| package types
     2| import (
     3| 	"strconv"
     4| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     5| 	"github.com/juanfont/headscale/hscontrol/util"
     6| 	"google.golang.org/protobuf/types/known/timestamppb"
     7| 	"gorm.io/gorm"
     8| 	"tailscale.com/tailcfg"
     9| )
    10| type User struct {
    11| 	gorm.Model
    12| 	Name string `gorm:"unique"`
    13| }
    14| func (u *User) profilePicURL() string {
    15| 	return ""
    16| }
    17| func (u *User) TailscaleUser() *tailcfg.User {
    18| 	user := tailcfg.User{
    19| 		ID:            tailcfg.UserID(u.ID),
    20| 		LoginName:     u.Name,
    21| 		DisplayName:   u.Name,
    22| 		ProfilePicURL: u.profilePicURL(),
    23| 		Logins:        []tailcfg.LoginID{},
    24| 		Created:       u.CreatedAt,
    25| 	}
    26| 	return &user
    27| }
    28| func (u *User) TailscaleLogin() *tailcfg.Login {
    29| 	login := tailcfg.Login{
    30| 		ID: tailcfg.LoginID(u.ID),
    31| 		Provider:      "",
    32| 		LoginName:     u.Name,
    33| 		DisplayName:   u.Name,
    34| 		ProfilePicURL: u.profilePicURL(),
    35| 	}
    36| 	return &login
    37| }
    38| func (u *User) TailscaleUserProfile() tailcfg.UserProfile {
    39| 	return tailcfg.UserProfile{
    40| 		ID:            tailcfg.UserID(u.ID),
    41| 		LoginName:     u.Name,
    42| 		DisplayName:   u.Name,
    43| 		ProfilePicURL: u.profilePicURL(),
    44| 	}
    45| }
    46| func (n *User) Proto() *v1.User {
    47| 	return &v1.User{
    48| 		Id:        strconv.FormatUint(uint64(n.ID), util.Base10),
    49| 		Name:      n.Name,
    50| 		CreatedAt: timestamppb.New(n.CreatedAt),
    51| 	}
    52| }


# ====================================================================
# FILE: hscontrol/util/addr.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-89 ---
     1| package util
     2| import (
     3| 	"fmt"
     4| 	"net/netip"
     5| 	"reflect"
     6| 	"strings"
     7| 	"go4.org/netipx"
     8| )
     9| var (
    10| 	zeroIP4 = netip.AddrFrom4([4]byte{})
    11| 	zeroIP6 = netip.AddrFrom16([16]byte{})
    12| )
    13| func ParseIPSet(arg string, bits *int) (*netipx.IPSet, error) {
    14| 	var ipSet netipx.IPSetBuilder
    15| 	if arg == "*" {
    16| 		ipSet.AddPrefix(netip.PrefixFrom(zeroIP4, 0))
    17| 		ipSet.AddPrefix(netip.PrefixFrom(zeroIP6, 0))
    18| 		return ipSet.IPSet()
    19| 	}
    20| 	if strings.Contains(arg, "/") {
    21| 		pfx, err := netip.ParsePrefix(arg)
    22| 		if err != nil {
    23| 			return nil, err
    24| 		}
    25| 		if pfx != pfx.Masked() {
    26| 			return nil, fmt.Errorf("%v contains non-network bits set", pfx)
    27| 		}
    28| 		ipSet.AddPrefix(pfx)
    29| 		return ipSet.IPSet()
    30| 	}
    31| 	if strings.Count(arg, "-") == 1 {
    32| 		ip1s, ip2s, _ := strings.Cut(arg, "-")
    33| 		ip1, err := netip.ParseAddr(ip1s)
    34| 		if err != nil {
    35| 			return nil, err
    36| 		}
    37| 		ip2, err := netip.ParseAddr(ip2s)
    38| 		if err != nil {
    39| 			return nil, err
    40| 		}
    41| 		r := netipx.IPRangeFrom(ip1, ip2)
    42| 		if !r.IsValid() {
    43| 			return nil, fmt.Errorf("invalid IP range %q", arg)
    44| 		}
    45| 		for _, prefix := range r.Prefixes() {
    46| 			ipSet.AddPrefix(prefix)
    47| 		}
    48| 		return ipSet.IPSet()
    49| 	}
    50| 	ip, err := netip.ParseAddr(arg)
    51| 	if err != nil {
    52| 		return nil, fmt.Errorf("invalid IP address %q", arg)
    53| 	}
    54| 	bits8 := uint8(ip.BitLen())
    55| 	if bits != nil {
    56| 		if *bits < 0 || *bits > int(bits8) {
    57| 			return nil, fmt.Errorf("invalid CIDR size %d for IP %q", *bits, arg)
    58| 		}
    59| 		bits8 = uint8(*bits)
    60| 	}
    61| 	ipSet.AddPrefix(netip.PrefixFrom(ip, int(bits8)))
    62| 	return ipSet.IPSet()
    63| }
    64| func GetIPPrefixEndpoints(na netip.Prefix) (netip.Addr, netip.Addr) {
    65| 	var network, broadcast netip.Addr
    66| 	ipRange := netipx.RangeOfPrefix(na)
    67| 	network = ipRange.From()
    68| 	broadcast = ipRange.To()
    69| 	return network, broadcast
    70| }
    71| func StringToIPPrefix(prefixes []string) ([]netip.Prefix, error) {
    72| 	result := make([]netip.Prefix, len(prefixes))
    73| 	for index, prefixStr := range prefixes {
    74| 		prefix, err := netip.ParsePrefix(prefixStr)
    75| 		if err != nil {
    76| 			return []netip.Prefix{}, err
    77| 		}
    78| 		result[index] = prefix
    79| 	}
    80| 	return result, nil
    81| }
    82| func StringOrPrefixListContains[T string | netip.Prefix](ts []T, t T) bool {
    83| 	for _, v := range ts {
    84| 		if reflect.DeepEqual(v, t) {
    85| 			return true
    86| 		}
    87| 	}
    88| 	return false
    89| }


# ====================================================================
# FILE: hscontrol/util/const.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-6 ---
     1| package util
     2| const (
     3| 	RegisterMethodAuthKey = "authkey"
     4| 	RegisterMethodOIDC    = "oidc"
     5| 	RegisterMethodCLI     = "cli"
     6| )


# ====================================================================
# FILE: hscontrol/util/dns.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-129 ---
     1| package util
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"net/netip"
     6| 	"regexp"
     7| 	"strings"
     8| 	"github.com/spf13/viper"
     9| 	"go4.org/netipx"
    10| 	"tailscale.com/util/dnsname"
    11| )
    12| const (
    13| 	ByteSize          = 8
    14| 	ipv4AddressLength = 32
    15| 	ipv6AddressLength = 128
    16| 	LabelHostnameLength = 63
    17| )
    18| var invalidCharsInUserRegex = regexp.MustCompile("[^a-z0-9-.]+")
    19| var ErrInvalidUserName = errors.New("invalid user name")
    20| func NormalizeToFQDNRulesConfigFromViper(name string) (string, error) {
    21| 	strip := viper.GetBool("oidc.strip_email_domain")
    22| 	return NormalizeToFQDNRules(name, strip)
    23| }
    24| func NormalizeToFQDNRules(name string, stripEmailDomain bool) (string, error) {
    25| 	name = strings.ToLower(name)
    26| 	name = strings.ReplaceAll(name, "'", "")
    27| 	atIdx := strings.Index(name, "@")
    28| 	if stripEmailDomain && atIdx > 0 {
    29| 		name = name[:atIdx]
    30| 	} else {
    31| 		name = strings.ReplaceAll(name, "@", ".")
    32| 	}
    33| 	name = invalidCharsInUserRegex.ReplaceAllString(name, "-")
    34| 	for _, elt := range strings.Split(name, ".") {
    35| 		if len(elt) > LabelHostnameLength {
    36| 			return "", fmt.Errorf(
    37| 				"label %v is more than 63 chars: %w",
    38| 				elt,
    39| 				ErrInvalidUserName,
    40| 			)
    41| 		}
    42| 	}
    43| 	return name, nil
    44| }
    45| func CheckForFQDNRules(name string) error {
    46| 	if len(name) > LabelHostnameLength {
    47| 		return fmt.Errorf(
    48| 			"DNS segment must not be over 63 chars. %v doesn't comply with this rule: %w",
    49| 			name,
    50| 			ErrInvalidUserName,
    51| 		)
    52| 	}
    53| 	if strings.ToLower(name) != name {
    54| 		return fmt.Errorf(
    55| 			"DNS segment should be lowercase. %v doesn't comply with this rule: %w",
    56| 			name,
    57| 			ErrInvalidUserName,
    58| 		)
    59| 	}
    60| 	if invalidCharsInUserRegex.MatchString(name) {
    61| 		return fmt.Errorf(
    62| 			"DNS segment should only be composed of lowercase ASCII letters numbers, hyphen and dots. %v doesn't comply with theses rules: %w",
    63| 			name,
    64| 			ErrInvalidUserName,
    65| 		)
    66| 	}
    67| 	return nil
    68| }
    69| func GenerateIPv4DNSRootDomain(ipPrefix netip.Prefix) []dnsname.FQDN {
    70| 	netRange := netipx.PrefixIPNet(ipPrefix)
    71| 	maskBits, _ := netRange.Mask.Size()
    72| 	lastOctet := maskBits / ByteSize
    73| 	wildcardBits := ByteSize - maskBits%ByteSize
    74| 	min := uint(netRange.IP[lastOctet])
    75| 	max := (min + 1<<uint(wildcardBits)) - 1
    76| 	rdnsSlice := []string{}
    77| 	for i := lastOctet - 1; i >= 0; i-- {
    78| 		rdnsSlice = append(rdnsSlice, fmt.Sprintf("%d", netRange.IP[i]))
    79| 	}
    80| 	rdnsSlice = append(rdnsSlice, "in-addr.arpa.")
    81| 	rdnsBase := strings.Join(rdnsSlice, ".")
    82| 	fqdns := make([]dnsname.FQDN, 0, max-min+1)
    83| 	for i := min; i <= max; i++ {
    84| 		fqdn, err := dnsname.ToFQDN(fmt.Sprintf("%d.%s", i, rdnsBase))
    85| 		if err != nil {
    86| 			continue
    87| 		}
    88| 		fqdns = append(fqdns, fqdn)
    89| 	}
    90| 	return fqdns
    91| }
    92| func GenerateIPv6DNSRootDomain(ipPrefix netip.Prefix) []dnsname.FQDN {
    93| 	const nibbleLen = 4
    94| 	maskBits, _ := netipx.PrefixIPNet(ipPrefix).Mask.Size()
    95| 	expanded := ipPrefix.Addr().StringExpanded()
    96| 	nibbleStr := strings.Map(func(r rune) rune {
    97| 		if r == ':' {
    98| 			return -1
    99| 		}
   100| 		return r
   101| 	}, expanded)
   102| 	prefixConstantParts := []string{}
   103| 	for i := 0; i < maskBits/nibbleLen; i++ {
   104| 		prefixConstantParts = append(
   105| 			[]string{string(nibbleStr[i])},
   106| 			prefixConstantParts...)
   107| 	}
   108| 	makeDomain := func(variablePrefix ...string) (dnsname.FQDN, error) {
   109| 		prefix := strings.Join(append(variablePrefix, prefixConstantParts...), ".")
   110| 		return dnsname.ToFQDN(fmt.Sprintf("%s.ip6.arpa", prefix))
   111| 	}
   112| 	var fqdns []dnsname.FQDN
   113| 	if maskBits%4 == 0 {
   114| 		dom, _ := makeDomain()
   115| 		fqdns = append(fqdns, dom)
   116| 	} else {
   117| 		domCount := 1 << (maskBits % nibbleLen)
   118| 		fqdns = make([]dnsname.FQDN, 0, domCount)
   119| 		for i := 0; i < domCount; i++ {
   120| 			varNibble := fmt.Sprintf("%x", i)
   121| 			dom, err := makeDomain(varNibble)
   122| 			if err != nil {
   123| 				continue
   124| 			}
   125| 			fqdns = append(fqdns, dom)
   126| 		}
   127| 	}
   128| 	return fqdns
   129| }


# ====================================================================
# FILE: hscontrol/util/file.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| package util
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"io/fs"
     6| 	"os"
     7| 	"path/filepath"
     8| 	"strconv"
     9| 	"strings"
    10| 	"github.com/spf13/viper"
    11| )
    12| const (
    13| 	Base8              = 8
    14| 	Base10             = 10
    15| 	BitSize16          = 16
    16| 	BitSize32          = 32
    17| 	BitSize64          = 64
    18| 	PermissionFallback = 0o700
    19| )
    20| func AbsolutePathFromConfigPath(path string) string {
    21| 	if (path != "") && !strings.HasPrefix(path, string(os.PathSeparator)) {
    22| 		dir, _ := filepath.Split(viper.ConfigFileUsed())
    23| 		if dir != "" {
    24| 			path = filepath.Join(dir, path)
    25| 		}
    26| 	}
    27| 	return path
    28| }
    29| func GetFileMode(key string) fs.FileMode {
    30| 	modeStr := viper.GetString(key)
    31| 	mode, err := strconv.ParseUint(modeStr, Base8, BitSize64)
    32| 	if err != nil {
    33| 		return PermissionFallback
    34| 	}
    35| 	return fs.FileMode(mode)
    36| }
    37| func EnsureDir(dir string) error {
    38| 	if _, err := os.Stat(dir); os.IsNotExist(err) {
    39| 		err := os.MkdirAll(dir, PermissionFallback)
    40| 		if err != nil {
    41| 			if errors.Is(err, os.ErrPermission) {
    42| 				return fmt.Errorf(
    43| 					"creating directory %s, failed with permission error, is it located somewhere Headscale can write?",
    44| 					dir,
    45| 				)
    46| 			}
    47| 			return fmt.Errorf("creating directory %s: %w", dir, err)
    48| 		}
    49| 	}
    50| 	return nil
    51| }


# ====================================================================
# FILE: hscontrol/util/key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package util
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"regexp"
     6| 	"tailscale.com/types/key"
     7| )
     8| var (
     9| 	NodePublicKeyRegex       = regexp.MustCompile("nodekey:[a-fA-F0-9]+")
    10| 	ErrCannotDecryptResponse = errors.New("cannot decrypt response")
    11| 	ZstdCompression          = "zstd"
    12| )
    13| func DecodeAndUnmarshalNaCl(
    14| 	msg []byte,
    15| 	output interface{},
    16| 	pubKey *key.MachinePublic,
    17| 	privKey *key.MachinePrivate,
    18| ) error {
    19| 	decrypted, ok := privKey.OpenFrom(*pubKey, msg)
    20| 	if !ok {
    21| 		return ErrCannotDecryptResponse
    22| 	}
    23| 	if err := json.Unmarshal(decrypted, output); err != nil {
    24| 		return err
    25| 	}
    26| 	return nil
    27| }


# ====================================================================
# FILE: hscontrol/util/log.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| package util
     2| import (
     3| 	"context"
     4| 	"errors"
     5| 	"time"
     6| 	"github.com/rs/zerolog"
     7| 	"github.com/rs/zerolog/log"
     8| 	"gorm.io/gorm"
     9| 	gormLogger "gorm.io/gorm/logger"
    10| 	"tailscale.com/types/logger"
    11| )
    12| func LogErr(err error, msg string) {
    13| 	log.Error().Caller().Err(err).Msg(msg)
    14| }
    15| func TSLogfWrapper() logger.Logf {
    16| 	return func(format string, args ...any) {
    17| 		log.Debug().Caller().Msgf(format, args...)
    18| 	}
    19| }
    20| type DBLogWrapper struct {
    21| 	Logger                *zerolog.Logger
    22| 	Level                 zerolog.Level
    23| 	Event                 *zerolog.Event
    24| 	SlowThreshold         time.Duration
    25| 	SkipErrRecordNotFound bool
    26| 	ParameterizedQueries  bool
    27| }
    28| func NewDBLogWrapper(origin *zerolog.Logger, slowThreshold time.Duration, skipErrRecordNotFound bool, parameterizedQueries bool) *DBLogWrapper {
    29| 	l := &DBLogWrapper{
    30| 		Logger:                origin,
    31| 		Level:                 origin.GetLevel(),
    32| 		SlowThreshold:         slowThreshold,
    33| 		SkipErrRecordNotFound: skipErrRecordNotFound,
    34| 		ParameterizedQueries:  parameterizedQueries,
    35| 	}
    36| 	return l
    37| }
    38| type DBLogWrapperOption func(*DBLogWrapper)
    39| func (l *DBLogWrapper) LogMode(gormLogger.LogLevel) gormLogger.Interface {
    40| 	return l
    41| }
    42| func (l *DBLogWrapper) Info(ctx context.Context, msg string, data ...interface{}) {
    43| 	l.Logger.Info().Msgf(msg, data...)
    44| }
    45| func (l *DBLogWrapper) Warn(ctx context.Context, msg string, data ...interface{}) {
    46| 	l.Logger.Warn().Msgf(msg, data...)
    47| }
    48| func (l *DBLogWrapper) Error(ctx context.Context, msg string, data ...interface{}) {
    49| 	l.Logger.Error().Msgf(msg, data...)
    50| }
    51| func (l *DBLogWrapper) Trace(ctx context.Context, begin time.Time, fc func() (sql string, rowsAffected int64), err error) {
    52| 	elapsed := time.Since(begin)
    53| 	sql, rowsAffected := fc()
    54| 	fields := map[string]interface{}{
    55| 		"duration":     elapsed,
    56| 		"sql":          sql,
    57| 		"rowsAffected": rowsAffected,
    58| 	}
    59| 	if err != nil && !(errors.Is(err, gorm.ErrRecordNotFound) && l.SkipErrRecordNotFound) {
    60| 		l.Logger.Error().Err(err).Fields(fields).Msgf("")
    61| 		return
    62| 	}
    63| 	if l.SlowThreshold != 0 && elapsed > l.SlowThreshold {
    64| 		l.Logger.Warn().Fields(fields).Msgf("")
    65| 		return
    66| 	}
    67| 	l.Logger.Debug().Fields(fields).Msgf("")
    68| }
    69| func (l *DBLogWrapper) ParamsFilter(ctx context.Context, sql string, params ...interface{}) (string, []interface{}) {
    70| 	if l.ParameterizedQueries {
    71| 		return sql, nil
    72| 	}
    73| 	return sql, params
    74| }


# ====================================================================
# FILE: hscontrol/util/net.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-20 ---
     1| package util
     2| import (
     3| 	"cmp"
     4| 	"context"
     5| 	"net"
     6| 	"net/netip"
     7| )
     8| func GrpcSocketDialer(ctx context.Context, addr string) (net.Conn, error) {
     9| 	var d net.Dialer
    10| 	return d.DialContext(ctx, "unix", addr)
    11| }
    12| func ComparePrefix(p, p2 netip.Prefix) int {
    13| 	if c := cmp.Compare(p.Addr().BitLen(), p2.Addr().BitLen()); c != 0 {
    14| 		return c
    15| 	}
    16| 	if c := cmp.Compare(p.Bits(), p2.Bits()); c != 0 {
    17| 		return c
    18| 	}
    19| 	return p.Addr().Compare(p2.Addr())
    20| }


# ====================================================================
# FILE: hscontrol/util/string.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| package util
     2| import (
     3| 	"crypto/rand"
     4| 	"encoding/base64"
     5| 	"fmt"
     6| 	"strings"
     7| 	"tailscale.com/tailcfg"
     8| )
     9| func GenerateRandomBytes(n int) ([]byte, error) {
    10| 	bytes := make([]byte, n)
    11| 	if _, err := rand.Read(bytes); err != nil {
    12| 		return nil, err
    13| 	}
    14| 	return bytes, nil
    15| }
    16| func GenerateRandomStringURLSafe(n int) (string, error) {
    17| 	b, err := GenerateRandomBytes(n)
    18| 	return base64.RawURLEncoding.EncodeToString(b), err
    19| }
    20| func GenerateRandomStringDNSSafe(size int) (string, error) {
    21| 	var str string
    22| 	var err error
    23| 	for len(str) < size {
    24| 		str, err = GenerateRandomStringURLSafe(size)
    25| 		if err != nil {
    26| 			return "", err
    27| 		}
    28| 		str = strings.ToLower(
    29| 			strings.ReplaceAll(strings.ReplaceAll(str, "_", ""), "-", ""),
    30| 		)
    31| 	}
    32| 	return str[:size], nil
    33| }
    34| func TailNodesToString(nodes []*tailcfg.Node) string {
    35| 	temp := make([]string, len(nodes))
    36| 	for index, node := range nodes {
    37| 		temp[index] = node.Name
    38| 	}
    39| 	return fmt.Sprintf("[ %s ](%d)", strings.Join(temp, ", "), len(temp))
    40| }
    41| func TailMapResponseToString(resp tailcfg.MapResponse) string {
    42| 	return fmt.Sprintf(
    43| 		"{ Node: %s, Peers: %s }",
    44| 		resp.Node.Name,
    45| 		TailNodesToString(resp.Peers),
    46| 	)
    47| }


# ====================================================================
# FILE: hscontrol/util/util.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| package util
     2| import "tailscale.com/util/cmpver"
     3| func TailscaleVersionNewerOrEqual(minimum, toCheck string) bool {
     4| 	if cmpver.Compare(minimum, toCheck) <= 0 ||
     5| 		toCheck == "unstable" ||
     6| 		toCheck == "head" {
     7| 		return true
     8| 	}
     9| 	return false
    10| }


# ====================================================================
# FILE: integration/control.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| package integration
     2| import (
     3| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     4| 	"github.com/ory/dockertest/v3"
     5| )
     6| type ControlServer interface {
     7| 	Shutdown() (string, string, error)
     8| 	SaveLog(string) (string, string, error)
     9| 	SaveProfile(string) error
    10| 	Execute(command []string) (string, error)
    11| 	WriteFile(path string, content []byte) error
    12| 	ConnectToNetwork(network *dockertest.Network) error
    13| 	GetHealthEndpoint() string
    14| 	GetEndpoint() string
    15| 	WaitForRunning() error
    16| 	CreateUser(user string) error
    17| 	CreateAuthKey(user string, reusable bool, ephemeral bool) (*v1.PreAuthKey, error)
    18| 	ListNodesInUser(user string) ([]*v1.Node, error)
    19| 	GetCert() []byte
    20| 	GetHostname() string
    21| 	GetIP() string
    22| }


# ====================================================================
# FILE: integration/hsic/config.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| package hsic
     2| import "github.com/juanfont/headscale/hscontrol/types"
     3| func MinimumConfigYAML() string {
     4| 	return `
     5| private_key_path: /tmp/private.key
     6| noise:
     7|   private_key_path: /tmp/noise_private.key
     8| `
     9| }
    10| func DefaultConfigEnv() map[string]string {
    11| 	return map[string]string{
    12| 		"HEADSCALE_LOG_LEVEL":                         "trace",
    13| 		"HEADSCALE_POLICY_PATH":                       "",
    14| 		"HEADSCALE_DATABASE_TYPE":                     "sqlite",
    15| 		"HEADSCALE_DATABASE_SQLITE_PATH":              "/tmp/integration_test_db.sqlite3",
    16| 		"HEADSCALE_EPHEMERAL_NODE_INACTIVITY_TIMEOUT": "30m",
    17| 		"HEADSCALE_PREFIXES_V4":                       "100.64.0.0/10",
    18| 		"HEADSCALE_PREFIXES_V6":                       "fd7a:115c:a1e0::/48",
    19| 		"HEADSCALE_DNS_BASE_DOMAIN":                   "headscale.net",
    20| 		"HEADSCALE_DNS_MAGIC_DNS":                     "true",
    21| 		"HEADSCALE_DNS_NAMESERVERS_GLOBAL":            "127.0.0.11 1.1.1.1",
    22| 		"HEADSCALE_PRIVATE_KEY_PATH":                  "/tmp/private.key",
    23| 		"HEADSCALE_NOISE_PRIVATE_KEY_PATH":            "/tmp/noise_private.key",
    24| 		"HEADSCALE_LISTEN_ADDR":                       "0.0.0.0:8080",
    25| 		"HEADSCALE_METRICS_LISTEN_ADDR":               "0.0.0.0:9090",
    26| 		"HEADSCALE_SERVER_URL":                        "http://headscale:8080",
    27| 		"HEADSCALE_DERP_URLS":                         "https://controlplane.tailscale.com/derpmap/default",
    28| 		"HEADSCALE_DERP_AUTO_UPDATE_ENABLED":          "false",
    29| 		"HEADSCALE_DERP_UPDATE_FREQUENCY":             "1m",
    30| 		"HEADSCALE_PREFIXES_ALLOCATION": string(types.IPAllocationStrategySequential),
    31| 	}
    32| }


# ====================================================================
# FILE: integration/hsic/hsic.go
# Total hunks: 10
# ====================================================================
# --- HUNK 1: Lines 1-256 ---
     1| package hsic
     2| import (
     3| 	"bytes"
     4| 	"crypto/rand"
     5| 	"crypto/rsa"
     6| 	"crypto/tls"
     7| 	"crypto/x509"
     8| 	"crypto/x509/pkix"
     9| 	"encoding/json"
    10| 	"encoding/pem"
    11| 	"errors"
    12| 	"fmt"
    13| 	"io"
    14| 	"log"
    15| 	"math/big"
    16| 	"net"
    17| 	"net/http"
    18| 	"net/url"
    19| 	"os"
    20| 	"path"
    21| 	"strconv"
    22| 	"strings"
    23| 	"time"
    24| 	"github.com/davecgh/go-spew/spew"
    25| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    26| 	"github.com/juanfont/headscale/hscontrol/policy"
    27| 	"github.com/juanfont/headscale/hscontrol/types"
    28| 	"github.com/juanfont/headscale/hscontrol/util"
    29| 	"github.com/juanfont/headscale/integration/dockertestutil"
    30| 	"github.com/juanfont/headscale/integration/integrationutil"
    31| 	"github.com/ory/dockertest/v3"
    32| 	"github.com/ory/dockertest/v3/docker"
    33| )
    34| const (
    35| 	hsicHashLength       = 6
    36| 	dockerContextPath    = "../."
    37| 	aclPolicyPath        = "/etc/headscale/acl.hujson"
    38| 	tlsCertPath          = "/etc/headscale/tls.cert"
    39| 	tlsKeyPath           = "/etc/headscale/tls.key"
    40| 	headscaleDefaultPort = 8080
    41| )
    42| var errHeadscaleStatusCodeNotOk = errors.New("headscale status code not ok")
    43| type fileInContainer struct {
    44| 	path     string
    45| 	contents []byte
    46| }
    47| type HeadscaleInContainer struct {
    48| 	hostname string
    49| 	pool      *dockertest.Pool
    50| 	container *dockertest.Resource
    51| 	network   *dockertest.Network
    52| 	pgContainer *dockertest.Resource
    53| 	port             int
    54| 	extraPorts       []string
    55| 	hostPortBindings map[string][]string
    56| 	aclPolicy        *policy.ACLPolicy
    57| 	env              map[string]string
    58| 	tlsCert          []byte
    59| 	tlsKey           []byte
    60| 	filesInContainer []fileInContainer
    61| 	postgres         bool
    62| }
    63| type Option = func(c *HeadscaleInContainer)
    64| func WithACLPolicy(acl *policy.ACLPolicy) Option {
    65| 	return func(hsic *HeadscaleInContainer) {
    66| 		hsic.env["HEADSCALE_POLICY_PATH"] = aclPolicyPath
    67| 		hsic.aclPolicy = acl
    68| 	}
    69| }
    70| func WithTLS() Option {
    71| 	return func(hsic *HeadscaleInContainer) {
    72| 		cert, key, err := createCertificate(hsic.hostname)
    73| 		if err != nil {
    74| 			log.Fatalf("failed to create certificates for headscale test: %s", err)
    75| 		}
    76| 		hsic.env["HEADSCALE_TLS_CERT_PATH"] = tlsCertPath
    77| 		hsic.env["HEADSCALE_TLS_KEY_PATH"] = tlsKeyPath
    78| 		hsic.tlsCert = cert
    79| 		hsic.tlsKey = key
    80| 	}
    81| }
    82| func WithConfigEnv(configEnv map[string]string) Option {
    83| 	return func(hsic *HeadscaleInContainer) {
    84| 		for key, value := range configEnv {
    85| 			hsic.env[key] = value
    86| 		}
    87| 	}
    88| }
    89| func WithPort(port int) Option {
    90| 	return func(hsic *HeadscaleInContainer) {
    91| 		hsic.port = port
    92| 	}
    93| }
    94| func WithExtraPorts(ports []string) Option {
    95| 	return func(hsic *HeadscaleInContainer) {
    96| 		hsic.extraPorts = ports
    97| 	}
    98| }
    99| func WithHostPortBindings(bindings map[string][]string) Option {
   100| 	return func(hsic *HeadscaleInContainer) {
   101| 		hsic.hostPortBindings = bindings
   102| 	}
   103| }
   104| func WithTestName(testName string) Option {
   105| 	return func(hsic *HeadscaleInContainer) {
   106| 		hash, _ := util.GenerateRandomStringDNSSafe(hsicHashLength)
   107| 		hostname := fmt.Sprintf("hs-%s-%s", testName, hash)
   108| 		hsic.hostname = hostname
   109| 	}
   110| }
   111| func WithHostnameAsServerURL() Option {
   112| 	return func(hsic *HeadscaleInContainer) {
   113| 		hsic.env["HEADSCALE_SERVER_URL"] = fmt.Sprintf("http://%s",
   114| 			net.JoinHostPort(hsic.GetHostname(),
   115| 				fmt.Sprintf("%d", hsic.port)),
   116| 		)
   117| 	}
   118| }
   119| func WithFileInContainer(path string, contents []byte) Option {
   120| 	return func(hsic *HeadscaleInContainer) {
   121| 		hsic.filesInContainer = append(hsic.filesInContainer,
   122| 			fileInContainer{
   123| 				path:     path,
   124| 				contents: contents,
   125| 			})
   126| 	}
   127| }
   128| func WithPostgres() Option {
   129| 	return func(hsic *HeadscaleInContainer) {
   130| 		hsic.postgres = true
   131| 	}
   132| }
   133| func WithIPAllocationStrategy(strategy types.IPAllocationStrategy) Option {
   134| 	return func(hsic *HeadscaleInContainer) {
   135| 		hsic.env["HEADSCALE_PREFIXES_ALLOCATION"] = string(strategy)
   136| 	}
   137| }
   138| func WithEmbeddedDERPServerOnly() Option {
   139| 	return func(hsic *HeadscaleInContainer) {
   140| 		hsic.env["HEADSCALE_DERP_URLS"] = ""
   141| 		hsic.env["HEADSCALE_DERP_SERVER_ENABLED"] = "true"
   142| 		hsic.env["HEADSCALE_DERP_SERVER_REGION_ID"] = "999"
   143| 		hsic.env["HEADSCALE_DERP_SERVER_REGION_CODE"] = "headscale"
   144| 		hsic.env["HEADSCALE_DERP_SERVER_REGION_NAME"] = "Headscale Embedded DERP"
   145| 		hsic.env["HEADSCALE_DERP_SERVER_STUN_LISTEN_ADDR"] = "0.0.0.0:3478"
   146| 		hsic.env["HEADSCALE_DERP_SERVER_PRIVATE_KEY_PATH"] = "/tmp/derp.key"
   147| 		hsic.env["DERP_DEBUG_LOGS"] = "true"
   148| 		hsic.env["DERP_PROBER_DEBUG_LOGS"] = "true"
   149| 	}
   150| }
   151| func WithTuning(batchTimeout time.Duration, mapSessionChanSize int) Option {
   152| 	return func(hsic *HeadscaleInContainer) {
   153| 		hsic.env["HEADSCALE_TUNING_BATCH_CHANGE_DELAY"] = batchTimeout.String()
   154| 		hsic.env["HEADSCALE_TUNING_NODE_MAPSESSION_BUFFERED_CHAN_SIZE"] = strconv.Itoa(mapSessionChanSize)
   155| 	}
   156| }
   157| func WithTimezone(timezone string) Option {
   158| 	return func(hsic *HeadscaleInContainer) {
   159| 		hsic.env["TZ"] = timezone
   160| 	}
   161| }
   162| func New(
   163| 	pool *dockertest.Pool,
   164| 	network *dockertest.Network,
   165| 	opts ...Option,
   166| ) (*HeadscaleInContainer, error) {
   167| 	hash, err := util.GenerateRandomStringDNSSafe(hsicHashLength)
   168| 	if err != nil {
   169| 		return nil, err
   170| 	}
   171| 	hostname := fmt.Sprintf("hs-%s", hash)
   172| 	hsic := &HeadscaleInContainer{
   173| 		hostname: hostname,
   174| 		port:     headscaleDefaultPort,
   175| 		pool:    pool,
   176| 		network: network,
   177| 		env:              DefaultConfigEnv(),
   178| 		filesInContainer: []fileInContainer{},
   179| 	}
   180| 	for _, opt := range opts {
   181| 		opt(hsic)
   182| 	}
   183| 	log.Println("NAME: ", hsic.hostname)
   184| 	portProto := fmt.Sprintf("%d/tcp", hsic.port)
   185| 	serverURL, err := url.Parse(hsic.env["HEADSCALE_SERVER_URL"])
   186| 	if err != nil {
   187| 		return nil, err
   188| 	}
   189| 	if len(hsic.tlsCert) != 0 && len(hsic.tlsKey) != 0 {
   190| 		serverURL.Scheme = "https"
   191| 		hsic.env["HEADSCALE_SERVER_URL"] = serverURL.String()
   192| 	}
   193| 	headscaleBuildOptions := &dockertest.BuildOptions{
   194| 		Dockerfile: "Dockerfile.debug",
   195| 		ContextDir: dockerContextPath,
   196| 	}
   197| 	if hsic.postgres {
   198| 		hsic.env["HEADSCALE_DATABASE_TYPE"] = "postgres"
   199| 		hsic.env["HEADSCALE_DATABASE_POSTGRES_HOST"] = fmt.Sprintf("postgres-%s", hash)
   200| 		hsic.env["HEADSCALE_DATABASE_POSTGRES_USER"] = "headscale"
   201| 		hsic.env["HEADSCALE_DATABASE_POSTGRES_PASS"] = "headscale"
   202| 		hsic.env["HEADSCALE_DATABASE_POSTGRES_NAME"] = "headscale"
   203| 		delete(hsic.env, "HEADSCALE_DATABASE_SQLITE_PATH")
   204| 		pg, err := pool.RunWithOptions(
   205| 			&dockertest.RunOptions{
   206| 				Name:       fmt.Sprintf("postgres-%s", hash),
   207| 				Repository: "postgres",
   208| 				Tag:        "latest",
   209| 				Networks:   []*dockertest.Network{network},
   210| 				Env: []string{
   211| 					"POSTGRES_USER=headscale",
   212| 					"POSTGRES_PASSWORD=headscale",
   213| 					"POSTGRES_DB=headscale",
   214| 				},
   215| 			})
   216| 		if err != nil {
   217| 			return nil, fmt.Errorf("starting postgres container: %w", err)
   218| 		}
   219| 		hsic.pgContainer = pg
   220| 	}
   221| 	env := []string{
   222| 		"HEADSCALE_DEBUG_PROFILING_ENABLED=1",
   223| 		"HEADSCALE_DEBUG_PROFILING_PATH=/tmp/profile",
   224| 		"HEADSCALE_DEBUG_DUMP_MAPRESPONSE_PATH=/tmp/mapresponses",
   225| 		"HEADSCALE_DEBUG_DEADLOCK=1",
   226| 		"HEADSCALE_DEBUG_DEADLOCK_TIMEOUT=5s",
   227| 		"HEADSCALE_DEBUG_HIGH_CARDINALITY_METRICS=1",
   228| 		"HEADSCALE_DEBUG_DUMP_CONFIG=1",
   229| 	}
   230| 	for key, value := range hsic.env {
   231| 		env = append(env, fmt.Sprintf("%s=%s", key, value))
   232| 	}
   233| 	log.Printf("ENV: \n%s", spew.Sdump(hsic.env))
   234| 	runOptions := &dockertest.RunOptions{
   235| 		Name:         hsic.hostname,
   236| 		ExposedPorts: append([]string{portProto, "9090/tcp"}, hsic.extraPorts...),
   237| 		Networks:     []*dockertest.Network{network},
   238| 		Entrypoint: []string{"/bin/bash", "-c", "/bin/sleep 3 ; headscale serve ; /bin/sleep 30"},
   239| 		Env:        env,
   240| 	}
   241| 	if len(hsic.hostPortBindings) > 0 {
   242| 		runOptions.PortBindings = map[docker.Port][]docker.PortBinding{}
   243| 		for port, hostPorts := range hsic.hostPortBindings {
   244| 			runOptions.PortBindings[docker.Port(port)] = []docker.PortBinding{}
   245| 			for _, hostPort := range hostPorts {
   246| 				runOptions.PortBindings[docker.Port(port)] = append(
   247| 					runOptions.PortBindings[docker.Port(port)],
   248| 					docker.PortBinding{HostPort: hostPort})
   249| 			}
   250| 		}
   251| 	}
   252| 	err = pool.RemoveContainerByName(hsic.hostname)
   253| 	if err != nil {
   254| 		return nil, err
   255| 	}
   256| 	container, err := pool.BuildAndRunWithBuildOptions(

# --- HUNK 2: Lines 285-481 ---
   285| 			return nil, fmt.Errorf("failed to write TLS certificate to container: %w", err)
   286| 		}
   287| 		err = hsic.WriteFile(tlsKeyPath, hsic.tlsKey)
   288| 		if err != nil {
   289| 			return nil, fmt.Errorf("failed to write TLS key to container: %w", err)
   290| 		}
   291| 	}
   292| 	for _, f := range hsic.filesInContainer {
   293| 		if err := hsic.WriteFile(f.path, f.contents); err != nil {
   294| 			return nil, fmt.Errorf("failed to write %q: %w", f.path, err)
   295| 		}
   296| 	}
   297| 	return hsic, nil
   298| }
   299| func (t *HeadscaleInContainer) ConnectToNetwork(network *dockertest.Network) error {
   300| 	return t.container.ConnectToNetwork(network)
   301| }
   302| func (t *HeadscaleInContainer) hasTLS() bool {
   303| 	return len(t.tlsCert) != 0 && len(t.tlsKey) != 0
   304| }
   305| func (t *HeadscaleInContainer) Shutdown() (string, string, error) {
   306| 	stdoutPath, stderrPath, err := t.SaveLog("/tmp/control")
   307| 	if err != nil {
   308| 		log.Printf(
   309| 			"Failed to save log from control: %s",
   310| 			fmt.Errorf("failed to save log from control: %w", err),
   311| 		)
   312| 	}
   313| 	err = t.SaveMetrics(fmt.Sprintf("/tmp/control/%s_metrics.txt", t.hostname))
   314| 	if err != nil {
   315| 		log.Printf(
   316| 			"Failed to metrics from control: %s",
   317| 			err,
   318| 		)
   319| 	}
   320| 	err = t.SendInterrupt()
   321| 	if err != nil {
   322| 		log.Printf(
   323| 			"Failed to send graceful interrupt to control: %s",
   324| 			fmt.Errorf("failed to send graceful interrupt to control: %w", err),
   325| 		)
   326| 	}
   327| 	err = t.SaveProfile("/tmp/control")
   328| 	if err != nil {
   329| 		log.Printf(
   330| 			"Failed to save profile from control: %s",
   331| 			fmt.Errorf("failed to save profile from control: %w", err),
   332| 		)
   333| 	}
   334| 	err = t.SaveMapResponses("/tmp/control")
   335| 	if err != nil {
   336| 		log.Printf(
   337| 			"Failed to save mapresponses from control: %s",
   338| 			fmt.Errorf("failed to save mapresponses from control: %w", err),
   339| 		)
   340| 	}
   341| 	if !t.postgres {
   342| 		err = t.SaveDatabase("/tmp/control")
   343| 		if err != nil {
   344| 			log.Printf(
   345| 				"Failed to save database from control: %s",
   346| 				fmt.Errorf("failed to save database from control: %w", err),
   347| 			)
   348| 		}
   349| 	}
   350| 	if t.postgres {
   351| 		t.pool.Purge(t.pgContainer)
   352| 	}
   353| 	return stdoutPath, stderrPath, t.pool.Purge(t.container)
   354| }
   355| func (t *HeadscaleInContainer) SaveLog(path string) (string, string, error) {
   356| 	return dockertestutil.SaveLog(t.pool, t.container, path)
   357| }
   358| func (t *HeadscaleInContainer) SaveMetrics(savePath string) error {
   359| 	resp, err := http.Get(fmt.Sprintf("http://%s:9090/metrics", t.hostname))
   360| 	if err != nil {
   361| 		return fmt.Errorf("getting metrics: %w", err)
   362| 	}
   363| 	defer resp.Body.Close()
   364| 	out, err := os.Create(savePath)
   365| 	if err != nil {
   366| 		return fmt.Errorf("creating file for metrics: %w", err)
   367| 	}
   368| 	defer out.Close()
   369| 	_, err = io.Copy(out, resp.Body)
   370| 	if err != nil {
   371| 		return fmt.Errorf("copy response to file: %w", err)
   372| 	}
   373| 	return nil
   374| }
   375| func (t *HeadscaleInContainer) SaveProfile(savePath string) error {
   376| 	tarFile, err := t.FetchPath("/tmp/profile")
   377| 	if err != nil {
   378| 		return err
   379| 	}
   380| 	err = os.WriteFile(
   381| 		path.Join(savePath, t.hostname+".pprof.tar"),
   382| 		tarFile,
   383| 		os.ModePerm,
   384| 	)
   385| 	if err != nil {
   386| 		return err
   387| 	}
   388| 	return nil
   389| }
   390| func (t *HeadscaleInContainer) SaveMapResponses(savePath string) error {
   391| 	tarFile, err := t.FetchPath("/tmp/mapresponses")
   392| 	if err != nil {
   393| 		return err
   394| 	}
   395| 	err = os.WriteFile(
   396| 		path.Join(savePath, t.hostname+".maps.tar"),
   397| 		tarFile,
   398| 		os.ModePerm,
   399| 	)
   400| 	if err != nil {
   401| 		return err
   402| 	}
   403| 	return nil
   404| }
   405| func (t *HeadscaleInContainer) SaveDatabase(savePath string) error {
   406| 	tarFile, err := t.FetchPath("/tmp/integration_test_db.sqlite3")
   407| 	if err != nil {
   408| 		return err
   409| 	}
   410| 	err = os.WriteFile(
   411| 		path.Join(savePath, t.hostname+".db.tar"),
   412| 		tarFile,
   413| 		os.ModePerm,
   414| 	)
   415| 	if err != nil {
   416| 		return err
   417| 	}
   418| 	return nil
   419| }
   420| func (t *HeadscaleInContainer) Execute(
   421| 	command []string,
   422| ) (string, error) {
   423| 	stdout, stderr, err := dockertestutil.ExecuteCommand(
   424| 		t.container,
   425| 		command,
   426| 		[]string{},
   427| 	)
   428| 	if err != nil {
   429| 		log.Printf("command stderr: %s\n", stderr)
   430| 		if stdout != "" {
   431| 			log.Printf("command stdout: %s\n", stdout)
   432| 		}
   433| 		return stdout, fmt.Errorf("executing command in docker: %w, stderr: %s", err, stderr)
   434| 	}
   435| 	return stdout, nil
   436| }
   437| func (t *HeadscaleInContainer) GetIP() string {
   438| 	return t.container.GetIPInNetwork(t.network)
   439| }
   440| func (t *HeadscaleInContainer) GetPort() string {
   441| 	return fmt.Sprintf("%d", t.port)
   442| }
   443| func (t *HeadscaleInContainer) GetHealthEndpoint() string {
   444| 	return fmt.Sprintf("%s/health", t.GetEndpoint())
   445| }
   446| func (t *HeadscaleInContainer) GetEndpoint() string {
   447| 	hostEndpoint := fmt.Sprintf("%s:%d",
   448| 		t.GetIP(),
   449| 		t.port)
   450| 	if t.hasTLS() {
   451| 		return fmt.Sprintf("https://%s", hostEndpoint)
   452| 	}
   453| 	return fmt.Sprintf("http://%s", hostEndpoint)
   454| }
   455| func (t *HeadscaleInContainer) GetCert() []byte {
   456| 	return t.tlsCert
   457| }
   458| func (t *HeadscaleInContainer) GetHostname() string {
   459| 	return t.hostname
   460| }
   461| func (t *HeadscaleInContainer) WaitForRunning() error {
   462| 	url := t.GetHealthEndpoint()
   463| 	log.Printf("waiting for headscale to be ready at %s", url)
   464| 	client := &http.Client{}
   465| 	if t.hasTLS() {
   466| 		insecureTransport := http.DefaultTransport.(*http.Transport).Clone()      //nolint
   467| 		insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true} //nolint
   468| 		client = &http.Client{Transport: insecureTransport}
   469| 	}
   470| 	return t.pool.Retry(func() error {
   471| 		resp, err := client.Get(url) //nolint
   472| 		if err != nil {
   473| 			return fmt.Errorf("headscale is not ready: %w", err)
   474| 		}
   475| 		if resp.StatusCode != http.StatusOK {
   476| 			return errHeadscaleStatusCodeNotOk
   477| 		}
   478| 		return nil
   479| 	})
   480| }
   481| func (t *HeadscaleInContainer) CreateUser(

# --- HUNK 3: Lines 512-597 ---
   512| 		command = append(command, "--reusable")
   513| 	}
   514| 	if ephemeral {
   515| 		command = append(command, "--ephemeral")
   516| 	}
   517| 	result, _, err := dockertestutil.ExecuteCommand(
   518| 		t.container,
   519| 		command,
   520| 		[]string{},
   521| 	)
   522| 	if err != nil {
   523| 		return nil, fmt.Errorf("failed to execute create auth key command: %w", err)
   524| 	}
   525| 	var preAuthKey v1.PreAuthKey
   526| 	err = json.Unmarshal([]byte(result), &preAuthKey)
   527| 	if err != nil {
   528| 		return nil, fmt.Errorf("failed to unmarshal auth key: %w", err)
   529| 	}
   530| 	return &preAuthKey, nil
   531| }
   532| func (t *HeadscaleInContainer) ListNodesInUser(
   533| 	user string,
   534| ) ([]*v1.Node, error) {
   535| 	command := []string{"headscale", "--user", user, "nodes", "list", "--output", "json"}
   536| 	result, _, err := dockertestutil.ExecuteCommand(
   537| 		t.container,
   538| 		command,
   539| 		[]string{},
   540| 	)
   541| 	if err != nil {
   542| 		return nil, fmt.Errorf("failed to execute list node command: %w", err)
   543| 	}
   544| 	var nodes []*v1.Node
   545| 	err = json.Unmarshal([]byte(result), &nodes)
   546| 	if err != nil {
   547| 		return nil, fmt.Errorf("failed to unmarshal nodes: %w", err)
   548| 	}
   549| 	return nodes, nil
   550| }
   551| func (t *HeadscaleInContainer) WriteFile(path string, data []byte) error {
   552| 	return integrationutil.WriteFileToContainer(t.pool, t.container, path, data)
   553| }
   554| func (t *HeadscaleInContainer) FetchPath(path string) ([]byte, error) {
   555| 	return integrationutil.FetchPathFromContainer(t.pool, t.container, path)
   556| }
   557| func (t *HeadscaleInContainer) SendInterrupt() error {
   558| 	pid, err := t.Execute([]string{"pidof", "headscale"})
   559| 	if err != nil {
   560| 		return err
   561| 	}
   562| 	_, err = t.Execute([]string{"kill", "-2", strings.Trim(pid, "'\n")})
   563| 	if err != nil {
   564| 		return err
   565| 	}
   566| 	return nil
   567| }
   568| func createCertificate(hostname string) ([]byte, []byte, error) {
   569| 	ca := &x509.Certificate{
   570| 		SerialNumber: big.NewInt(2019),
   571| 		Subject: pkix.Name{
   572| 			Organization: []string{"Headscale testing INC"},
   573| 			Country:      []string{"NL"},
   574| 			Locality:     []string{"Leiden"},
   575| 		},
   576| 		NotBefore: time.Now(),
   577| 		NotAfter:  time.Now().Add(60 * time.Hour),
   578| 		IsCA:      true,
   579| 		ExtKeyUsage: []x509.ExtKeyUsage{
   580| 			x509.ExtKeyUsageClientAuth,
   581| 			x509.ExtKeyUsageServerAuth,
   582| 		},
   583| 		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
   584| 		BasicConstraintsValid: true,
   585| 	}
   586| 	caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
   587| 	if err != nil {
   588| 		return nil, nil, err
   589| 	}
   590| 	cert := &x509.Certificate{
   591| 		SerialNumber: big.NewInt(1658),
   592| 		Subject: pkix.Name{
   593| 			CommonName:   hostname,
   594| 			Organization: []string{"Headscale testing INC"},
   595| 			Country:      []string{"NL"},
   596| 			Locality:     []string{"Leiden"},
   597| 		},


# ====================================================================
# FILE: integration/run.sh
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-61 ---
     1| run_tests() {
     2| 	test_name=$1
     3| 	num_tests=$2
     4| 	success_count=0
     5| 	failure_count=0
     6| 	runtimes=()
     7| 	echo "-------------------"
     8| 	echo "Running Tests for $test_name"
     9| 	for ((i = 1; i <= num_tests; i++)); do
    10| 		docker network prune -f >/dev/null 2>&1
    11| 		docker rm headscale-test-suite >/dev/null 2>&1 || true
    12| 		docker kill "$(docker ps -q)" >/dev/null 2>&1 || true
    13| 		echo "Run $i"
    14| 		start=$(date +%s)
    15| 		docker run \
    16| 			--tty --rm \
    17| 			--volume ~/.cache/hs-integration-go:/go \
    18| 			--name headscale-test-suite \
    19| 			--volume "$PWD:$PWD" -w "$PWD"/integration \
    20| 			--volume /var/run/docker.sock:/var/run/docker.sock \
    21| 			--volume "$PWD"/control_logs:/tmp/control \
    22| 			-e "HEADSCALE_INTEGRATION_POSTGRES" \
    23| 			golang:1 \
    24| 			go test ./... \
    25| 			-failfast \
    26| 			-timeout 120m \
    27| 			-parallel 1 \
    28| 			-run "^$test_name\$" >./control_logs/"$test_name"_"$i".log 2>&1
    29| 		status=$?
    30| 		end=$(date +%s)
    31| 		runtime=$((end - start))
    32| 		runtimes+=("$runtime")
    33| 		if [ "$status" -eq 0 ]; then
    34| 			((success_count++))
    35| 		else
    36| 			((failure_count++))
    37| 		fi
    38| 	done
    39| 	echo "-------------------"
    40| 	echo "Test Summary for $test_name"
    41| 	echo "-------------------"
    42| 	echo "Total Tests: $num_tests"
    43| 	echo "Successful Tests: $success_count"
    44| 	echo "Failed Tests: $failure_count"
    45| 	echo "Runtimes in seconds: ${runtimes[*]}"
    46| 	echo
    47| }
    48| if [ $# -ne 2 ]; then
    49| 	echo "Usage: $0 <test_name> <num_tests>"
    50| 	exit 1
    51| fi
    52| test_name=$1
    53| num_tests=$2
    54| docker network prune -f
    55| if [ "$test_name" = "all" ]; then
    56| 	rg --regexp "func (Test.+)\(.*" ./integration/ --replace '$1' --no-line-number --no-filename --no-heading | sort | while read -r test_name; do
    57| 		run_tests "$test_name" "$num_tests"
    58| 	done
    59| else
    60| 	run_tests "$test_name" "$num_tests"
    61| fi


# ====================================================================
# FILE: integration/scenario.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-350 ---
     1| package integration
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"log"
     6| 	"net/netip"
     7| 	"os"
     8| 	"sort"
     9| 	"sync"
    10| 	"testing"
    11| 	"time"
    12| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    13| 	"github.com/juanfont/headscale/hscontrol/util"
    14| 	"github.com/juanfont/headscale/integration/dockertestutil"
    15| 	"github.com/juanfont/headscale/integration/hsic"
    16| 	"github.com/juanfont/headscale/integration/tsic"
    17| 	"github.com/ory/dockertest/v3"
    18| 	"github.com/puzpuzpuz/xsync/v3"
    19| 	"github.com/samber/lo"
    20| 	"github.com/stretchr/testify/assert"
    21| 	"golang.org/x/sync/errgroup"
    22| 	"tailscale.com/envknob"
    23| )
    24| const (
    25| 	scenarioHashLength = 6
    26| )
    27| var usePostgresForTest = envknob.Bool("HEADSCALE_INTEGRATION_POSTGRES")
    28| func enabledVersions(vs map[string]bool) []string {
    29| 	var ret []string
    30| 	for version, enabled := range vs {
    31| 		if enabled {
    32| 			ret = append(ret, version)
    33| 		}
    34| 	}
    35| 	sort.Sort(sort.Reverse(sort.StringSlice(ret)))
    36| 	return ret
    37| }
    38| var (
    39| 	errNoHeadscaleAvailable = errors.New("no headscale available")
    40| 	errNoUserAvailable      = errors.New("no user available")
    41| 	errNoClientFound        = errors.New("client not found")
    42| 	tailscaleVersions2021 = map[string]bool{
    43| 		"head":     true,
    44| 		"unstable": true,
    45| 		"1.70":     true,  // CapVer: not checked
    46| 		"1.68":     true,  // CapVer: not checked
    47| 		"1.66":     true,  // CapVer: not checked
    48| 		"1.64":     true,  // CapVer: not checked
    49| 		"1.62":     true,  // CapVer: not checked
    50| 		"1.60":     true,  // CapVer: not checked
    51| 		"1.58":     true,  // CapVer: not checked
    52| 		"1.56":     true,  // CapVer: 82
    53| 		"1.54":     true,  // CapVer: 79
    54| 		"1.52":     true,  // CapVer: 79
    55| 		"1.50":     true,  // CapVer: 74
    56| 		"1.48":     true,  // CapVer: 68
    57| 		"1.46":     true,  // CapVer: 65
    58| 		"1.44":     false, // CapVer: 63
    59| 		"1.42":     false, // Oldest supported version, CapVer: 61
    60| 		"1.40":     false, // CapVer: 61
    61| 		"1.38":     false, // CapVer: 58
    62| 		"1.36":     false, // CapVer: 56
    63| 		"1.34":     false, // CapVer: 51
    64| 		"1.32":     false, // CapVer: 46
    65| 		"1.30":     false,
    66| 	}
    67| 	tailscaleVersions2019 = map[string]bool{
    68| 		"1.28": false,
    69| 		"1.26": false,
    70| 		"1.24": false, // Tailscale SSH
    71| 		"1.22": false,
    72| 		"1.20": false,
    73| 		"1.18": false,
    74| 	}
    75| 	AllVersions = append(
    76| 		enabledVersions(tailscaleVersions2021),
    77| 		enabledVersions(tailscaleVersions2019)...,
    78| 	)
    79| 	MustTestVersions = append(
    80| 		AllVersions[0:4],
    81| 		AllVersions[len(AllVersions)-2:]...,
    82| 	)
    83| )
    84| type User struct {
    85| 	Clients map[string]TailscaleClient
    86| 	createWaitGroup errgroup.Group
    87| 	joinWaitGroup   errgroup.Group
    88| 	syncWaitGroup   errgroup.Group
    89| }
    90| type Scenario struct {
    91| 	controlServers *xsync.MapOf[string, ControlServer]
    92| 	users map[string]*User
    93| 	pool    *dockertest.Pool
    94| 	network *dockertest.Network
    95| 	mu sync.Mutex
    96| }
    97| func NewScenario(maxWait time.Duration) (*Scenario, error) {
    98| 	hash, err := util.GenerateRandomStringDNSSafe(scenarioHashLength)
    99| 	if err != nil {
   100| 		return nil, err
   101| 	}
   102| 	pool, err := dockertest.NewPool("")
   103| 	if err != nil {
   104| 		return nil, fmt.Errorf("could not connect to docker: %w", err)
   105| 	}
   106| 	pool.MaxWait = maxWait
   107| 	networkName := fmt.Sprintf("hs-%s", hash)
   108| 	if overrideNetworkName := os.Getenv("HEADSCALE_TEST_NETWORK_NAME"); overrideNetworkName != "" {
   109| 		networkName = overrideNetworkName
   110| 	}
   111| 	network, err := dockertestutil.GetFirstOrCreateNetwork(pool, networkName)
   112| 	if err != nil {
   113| 		return nil, fmt.Errorf("failed to create or get network: %w", err)
   114| 	}
   115| 	err = dockertestutil.AddContainerToNetwork(pool, network, "headscale-test-suite")
   116| 	if err != nil {
   117| 		return nil, fmt.Errorf("failed to add test suite container to network: %w", err)
   118| 	}
   119| 	return &Scenario{
   120| 		controlServers: xsync.NewMapOf[string, ControlServer](),
   121| 		users:          make(map[string]*User),
   122| 		pool:    pool,
   123| 		network: network,
   124| 	}, nil
   125| }
   126| func (s *Scenario) ShutdownAssertNoPanics(t *testing.T) {
   127| 	s.controlServers.Range(func(_ string, control ControlServer) bool {
   128| 		stdoutPath, stderrPath, err := control.Shutdown()
   129| 		if err != nil {
   130| 			log.Printf(
   131| 				"Failed to shut down control: %s",
   132| 				fmt.Errorf("failed to tear down control: %w", err),
   133| 			)
   134| 		}
   135| 		if t != nil {
   136| 			stdout, err := os.ReadFile(stdoutPath)
   137| 			assert.NoError(t, err)
   138| 			assert.NotContains(t, string(stdout), "panic")
   139| 			stderr, err := os.ReadFile(stderrPath)
   140| 			assert.NoError(t, err)
   141| 			assert.NotContains(t, string(stderr), "panic")
   142| 		}
   143| 		return true
   144| 	})
   145| 	for userName, user := range s.users {
   146| 		for _, client := range user.Clients {
   147| 			log.Printf("removing client %s in user %s", client.Hostname(), userName)
   148| 			err := client.Shutdown()
   149| 			if err != nil {
   150| 				log.Printf("failed to tear down client: %s", err)
   151| 			}
   152| 		}
   153| 	}
   154| 	if err := s.pool.RemoveNetwork(s.network); err != nil {
   155| 		log.Printf("failed to remove network: %s", err)
   156| 	}
   157| }
   158| func (s *Scenario) Shutdown() {
   159| 	s.ShutdownAssertNoPanics(nil)
   160| }
   161| func (s *Scenario) Users() []string {
   162| 	users := make([]string, 0)
   163| 	for user := range s.users {
   164| 		users = append(users, user)
   165| 	}
   166| 	return users
   167| }
   168| func (s *Scenario) Headscale(opts ...hsic.Option) (ControlServer, error) {
   169| 	s.mu.Lock()
   170| 	defer s.mu.Unlock()
   171| 	if headscale, ok := s.controlServers.Load("headscale"); ok {
   172| 		return headscale, nil
   173| 	}
   174| 	if usePostgresForTest {
   175| 		opts = append(opts, hsic.WithPostgres())
   176| 	}
   177| 	headscale, err := hsic.New(s.pool, s.network, opts...)
   178| 	if err != nil {
   179| 		return nil, fmt.Errorf("failed to create headscale container: %w", err)
   180| 	}
   181| 	err = headscale.WaitForRunning()
   182| 	if err != nil {
   183| 		return nil, fmt.Errorf("failed reach headscale container: %w", err)
   184| 	}
   185| 	s.controlServers.Store("headscale", headscale)
   186| 	return headscale, nil
   187| }
   188| func (s *Scenario) CreatePreAuthKey(
   189| 	user string,
   190| 	reusable bool,
   191| 	ephemeral bool,
   192| ) (*v1.PreAuthKey, error) {
   193| 	if headscale, err := s.Headscale(); err == nil {
   194| 		key, err := headscale.CreateAuthKey(user, reusable, ephemeral)
   195| 		if err != nil {
   196| 			return nil, fmt.Errorf("failed to create user: %w", err)
   197| 		}
   198| 		return key, nil
   199| 	}
   200| 	return nil, fmt.Errorf("failed to create user: %w", errNoHeadscaleAvailable)
   201| }
   202| func (s *Scenario) CreateUser(user string) error {
   203| 	if headscale, err := s.Headscale(); err == nil {
   204| 		err := headscale.CreateUser(user)
   205| 		if err != nil {
   206| 			return fmt.Errorf("failed to create user: %w", err)
   207| 		}
   208| 		s.users[user] = &User{
   209| 			Clients: make(map[string]TailscaleClient),
   210| 		}
   211| 		return nil
   212| 	}
   213| 	return fmt.Errorf("failed to create user: %w", errNoHeadscaleAvailable)
   214| }
   215| func (s *Scenario) CreateTailscaleNodesInUser(
   216| 	userStr string,
   217| 	requestedVersion string,
   218| 	count int,
   219| 	opts ...tsic.Option,
   220| ) error {
   221| 	if user, ok := s.users[userStr]; ok {
   222| 		var versions []string
   223| 		for i := 0; i < count; i++ {
   224| 			version := requestedVersion
   225| 			if requestedVersion == "all" {
   226| 				version = MustTestVersions[i%len(MustTestVersions)]
   227| 			}
   228| 			versions = append(versions, version)
   229| 			headscale, err := s.Headscale()
   230| 			if err != nil {
   231| 				return fmt.Errorf("failed to create tailscale node (version: %s): %w", version, err)
   232| 			}
   233| 			cert := headscale.GetCert()
   234| 			hostname := headscale.GetHostname()
   235| 			opts = append(opts,
   236| 				tsic.WithHeadscaleTLS(cert),
   237| 				tsic.WithHeadscaleName(hostname),
   238| 			)
   239| 			user.createWaitGroup.Go(func() error {
   240| 				tsClient, err := tsic.New(
   241| 					s.pool,
   242| 					version,
   243| 					s.network,
   244| 					opts...,
   245| 				)
   246| 				if err != nil {
   247| 					return fmt.Errorf(
   248| 						"failed to create tailscale (%s) node: %w",
   249| 						tsClient.Hostname(),
   250| 						err,
   251| 					)
   252| 				}
   253| 				err = tsClient.WaitForNeedsLogin()
   254| 				if err != nil {
   255| 					return fmt.Errorf(
   256| 						"failed to wait for tailscaled (%s) to need login: %w",
   257| 						tsClient.Hostname(),
   258| 						err,
   259| 					)
   260| 				}
   261| 				s.mu.Lock()
   262| 				user.Clients[tsClient.Hostname()] = tsClient
   263| 				s.mu.Unlock()
   264| 				return nil
   265| 			})
   266| 		}
   267| 		if err := user.createWaitGroup.Wait(); err != nil {
   268| 			return err
   269| 		}
   270| 		log.Printf("testing versions %v, MustTestVersions %v", lo.Uniq(versions), MustTestVersions)
   271| 		return nil
   272| 	}
   273| 	return fmt.Errorf("failed to add tailscale node: %w", errNoUserAvailable)
   274| }
   275| func (s *Scenario) RunTailscaleUp(
   276| 	userStr, loginServer, authKey string,
   277| ) error {
   278| 	if user, ok := s.users[userStr]; ok {
   279| 		for _, client := range user.Clients {
   280| 			c := client
   281| 			user.joinWaitGroup.Go(func() error {
   282| 				return c.Login(loginServer, authKey)
   283| 			})
   284| 		}
   285| 		if err := user.joinWaitGroup.Wait(); err != nil {
   286| 			return err
   287| 		}
   288| 		for _, client := range user.Clients {
   289| 			err := client.WaitForRunning()
   290| 			if err != nil {
   291| 				return fmt.Errorf("%s failed to up tailscale node: %w", client.Hostname(), err)
   292| 			}
   293| 		}
   294| 		return nil
   295| 	}
   296| 	return fmt.Errorf("failed to up tailscale node: %w", errNoUserAvailable)
   297| }
   298| func (s *Scenario) CountTailscale() int {
   299| 	count := 0
   300| 	for _, user := range s.users {
   301| 		count += len(user.Clients)
   302| 	}
   303| 	return count
   304| }
   305| func (s *Scenario) WaitForTailscaleSync() error {
   306| 	tsCount := s.CountTailscale()
   307| 	err := s.WaitForTailscaleSyncWithPeerCount(tsCount - 1)
   308| 	if err != nil {
   309| 		for _, user := range s.users {
   310| 			for _, client := range user.Clients {
   311| 				peers, allOnline, _ := client.FailingPeersAsString()
   312| 				if !allOnline {
   313| 					log.Println(peers)
   314| 				}
   315| 			}
   316| 		}
   317| 	}
   318| 	return err
   319| }
   320| func (s *Scenario) WaitForTailscaleSyncWithPeerCount(peerCount int) error {
   321| 	for _, user := range s.users {
   322| 		for _, client := range user.Clients {
   323| 			c := client
   324| 			user.syncWaitGroup.Go(func() error {
   325| 				return c.WaitForPeers(peerCount)
   326| 			})
   327| 		}
   328| 		if err := user.syncWaitGroup.Wait(); err != nil {
   329| 			return err
   330| 		}
   331| 	}
   332| 	return nil
   333| }
   334| func (s *Scenario) CreateHeadscaleEnv(
   335| 	users map[string]int,
   336| 	tsOpts []tsic.Option,
   337| 	opts ...hsic.Option,
   338| ) error {
   339| 	headscale, err := s.Headscale(opts...)
   340| 	if err != nil {
   341| 		return err
   342| 	}
   343| 	for userName, clientCount := range users {
   344| 		err = s.CreateUser(userName)
   345| 		if err != nil {
   346| 			return err
   347| 		}
   348| 		err = s.CreateTailscaleNodesInUser(userName, "all", clientCount, tsOpts...)
   349| 		if err != nil {
   350| 			return err

# --- HUNK 2: Lines 425-458 ---
   425| 		}
   426| 		allIps = append(allIps, ips...)
   427| 	}
   428| 	return allIps, nil
   429| }
   430| func (s *Scenario) ListTailscaleClientsFQDNs(users ...string) ([]string, error) {
   431| 	allFQDNs := make([]string, 0)
   432| 	clients, err := s.ListTailscaleClients(users...)
   433| 	if err != nil {
   434| 		return nil, err
   435| 	}
   436| 	for _, client := range clients {
   437| 		fqdn, err := client.FQDN()
   438| 		if err != nil {
   439| 			return nil, err
   440| 		}
   441| 		allFQDNs = append(allFQDNs, fqdn)
   442| 	}
   443| 	return allFQDNs, nil
   444| }
   445| func (s *Scenario) WaitForTailscaleLogout() error {
   446| 	for _, user := range s.users {
   447| 		for _, client := range user.Clients {
   448| 			c := client
   449| 			user.syncWaitGroup.Go(func() error {
   450| 				return c.WaitForNeedsLogin()
   451| 			})
   452| 		}
   453| 		if err := user.syncWaitGroup.Wait(); err != nil {
   454| 			return err
   455| 		}
   456| 	}
   457| 	return nil
   458| }


# ====================================================================
# FILE: integration/tailscale.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-37 ---
     1| package integration
     2| import (
     3| 	"net/netip"
     4| 	"net/url"
     5| 	"github.com/juanfont/headscale/integration/dockertestutil"
     6| 	"github.com/juanfont/headscale/integration/tsic"
     7| 	"tailscale.com/ipn/ipnstate"
     8| 	"tailscale.com/net/netcheck"
     9| 	"tailscale.com/types/netmap"
    10| )
    11| type TailscaleClient interface {
    12| 	Hostname() string
    13| 	Shutdown() error
    14| 	Version() string
    15| 	Execute(
    16| 		command []string,
    17| 		options ...dockertestutil.ExecuteCommandOption,
    18| 	) (string, string, error)
    19| 	Login(loginServer, authKey string) error
    20| 	LoginWithURL(loginServer string) (*url.URL, error)
    21| 	Logout() error
    22| 	Up() error
    23| 	Down() error
    24| 	IPs() ([]netip.Addr, error)
    25| 	FQDN() (string, error)
    26| 	Status(...bool) (*ipnstate.Status, error)
    27| 	Netmap() (*netmap.NetworkMap, error)
    28| 	Netcheck() (*netcheck.Report, error)
    29| 	WaitForNeedsLogin() error
    30| 	WaitForRunning() error
    31| 	WaitForPeers(expected int) error
    32| 	Ping(hostnameOrIP string, opts ...tsic.PingOption) error
    33| 	Curl(url string, opts ...tsic.CurlOption) (string, error)
    34| 	ID() string
    35| 	ReadFile(path string) ([]byte, error)
    36| 	FailingPeersAsString() (string, bool, error)
    37| }


# ====================================================================
# FILE: integration/tsic/tsic.go
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-82 ---
     1| package tsic
     2| import (
     3| 	"archive/tar"
     4| 	"bytes"
     5| 	"context"
     6| 	"encoding/json"
     7| 	"errors"
     8| 	"fmt"
     9| 	"io"
    10| 	"log"
    11| 	"net/netip"
    12| 	"net/url"
    13| 	"os"
    14| 	"strconv"
    15| 	"strings"
    16| 	"time"
    17| 	"github.com/juanfont/headscale/hscontrol/util"
    18| 	"github.com/juanfont/headscale/integration/dockertestutil"
    19| 	"github.com/juanfont/headscale/integration/integrationutil"
    20| 	"github.com/ory/dockertest/v3"
    21| 	"github.com/ory/dockertest/v3/docker"
    22| 	"tailscale.com/ipn"
    23| 	"tailscale.com/ipn/ipnstate"
    24| 	"tailscale.com/net/netcheck"
    25| 	"tailscale.com/types/netmap"
    26| )
    27| const (
    28| 	tsicHashLength       = 6
    29| 	defaultPingTimeout   = 300 * time.Millisecond
    30| 	defaultPingCount     = 10
    31| 	dockerContextPath    = "../."
    32| 	headscaleCertPath    = "/usr/local/share/ca-certificates/headscale.crt"
    33| 	dockerExecuteTimeout = 60 * time.Second
    34| )
    35| var (
    36| 	errTailscalePingFailed             = errors.New("ping failed")
    37| 	errTailscalePingNotDERP            = errors.New("ping not via DERP")
    38| 	errTailscaleNotLoggedIn            = errors.New("tailscale not logged in")
    39| 	errTailscaleWrongPeerCount         = errors.New("wrong peer count")
    40| 	errTailscaleCannotUpWithoutAuthkey = errors.New("cannot up without authkey")
    41| 	errTailscaleNotConnected           = errors.New("tailscale not connected")
    42| 	errTailscaledNotReadyForLogin      = errors.New("tailscaled not ready for login")
    43| )
    44| func errTailscaleStatus(hostname string, err error) error {
    45| 	return fmt.Errorf("%s failed to fetch tailscale status: %w", hostname, err)
    46| }
    47| type TailscaleInContainer struct {
    48| 	version  string
    49| 	hostname string
    50| 	pool      *dockertest.Pool
    51| 	container *dockertest.Resource
    52| 	network   *dockertest.Network
    53| 	ips  []netip.Addr
    54| 	fqdn string
    55| 	headscaleCert     []byte
    56| 	headscaleHostname string
    57| 	withSSH           bool
    58| 	withTags          []string
    59| 	withEntrypoint    []string
    60| 	withExtraHosts    []string
    61| 	workdir           string
    62| 	netfilter         string
    63| }
    64| type Option = func(c *TailscaleInContainer)
    65| func WithHeadscaleTLS(cert []byte) Option {
    66| 	return func(tsic *TailscaleInContainer) {
    67| 		tsic.headscaleCert = cert
    68| 	}
    69| }
    70| func WithOrCreateNetwork(network *dockertest.Network) Option {
    71| 	return func(tsic *TailscaleInContainer) {
    72| 		if network != nil {
    73| 			tsic.network = network
    74| 			return
    75| 		}
    76| 		network, err := dockertestutil.GetFirstOrCreateNetwork(
    77| 			tsic.pool,
    78| 			fmt.Sprintf("%s-network", tsic.hostname),
    79| 		)
    80| 		if err != nil {
    81| 			log.Fatalf("failed to create network: %s", err)
    82| 		}

# --- HUNK 2: Lines 94-663 ---
    94| 	}
    95| }
    96| func WithSSH() Option {
    97| 	return func(tsic *TailscaleInContainer) {
    98| 		tsic.withSSH = true
    99| 	}
   100| }
   101| func WithDockerWorkdir(dir string) Option {
   102| 	return func(tsic *TailscaleInContainer) {
   103| 		tsic.workdir = dir
   104| 	}
   105| }
   106| func WithExtraHosts(hosts []string) Option {
   107| 	return func(tsic *TailscaleInContainer) {
   108| 		tsic.withExtraHosts = hosts
   109| 	}
   110| }
   111| func WithDockerEntrypoint(args []string) Option {
   112| 	return func(tsic *TailscaleInContainer) {
   113| 		tsic.withEntrypoint = args
   114| 	}
   115| }
   116| func WithNetfilter(state string) Option {
   117| 	return func(tsic *TailscaleInContainer) {
   118| 		tsic.netfilter = state
   119| 	}
   120| }
   121| func New(
   122| 	pool *dockertest.Pool,
   123| 	version string,
   124| 	network *dockertest.Network,
   125| 	opts ...Option,
   126| ) (*TailscaleInContainer, error) {
   127| 	hash, err := util.GenerateRandomStringDNSSafe(tsicHashLength)
   128| 	if err != nil {
   129| 		return nil, err
   130| 	}
   131| 	hostname := fmt.Sprintf("ts-%s-%s", strings.ReplaceAll(version, ".", "-"), hash)
   132| 	tsic := &TailscaleInContainer{
   133| 		version:  version,
   134| 		hostname: hostname,
   135| 		pool:    pool,
   136| 		network: network,
   137| 		withEntrypoint: []string{
   138| 			"/bin/sh",
   139| 			"-c",
   140| 			"/bin/sleep 3 ; update-ca-certificates ; tailscaled --tun=tsdev --verbose=10",
   141| 		},
   142| 	}
   143| 	for _, opt := range opts {
   144| 		opt(tsic)
   145| 	}
   146| 	tailscaleOptions := &dockertest.RunOptions{
   147| 		Name:     hostname,
   148| 		Networks: []*dockertest.Network{tsic.network},
   149| 		Entrypoint: tsic.withEntrypoint,
   150| 		ExtraHosts: tsic.withExtraHosts,
   151| 	}
   152| 	if tsic.headscaleHostname != "" {
   153| 		tailscaleOptions.ExtraHosts = []string{
   154| 			"host.docker.internal:host-gateway",
   155| 			fmt.Sprintf("%s:host-gateway", tsic.headscaleHostname),
   156| 		}
   157| 	}
   158| 	if tsic.workdir != "" {
   159| 		tailscaleOptions.WorkingDir = tsic.workdir
   160| 	}
   161| 	err = pool.RemoveContainerByName(hostname)
   162| 	if err != nil {
   163| 		return nil, err
   164| 	}
   165| 	var container *dockertest.Resource
   166| 	switch version {
   167| 	case "head":
   168| 		buildOptions := &dockertest.BuildOptions{
   169| 			Dockerfile: "Dockerfile.tailscale-HEAD",
   170| 			ContextDir: dockerContextPath,
   171| 			BuildArgs:  []docker.BuildArg{},
   172| 		}
   173| 		container, err = pool.BuildAndRunWithBuildOptions(
   174| 			buildOptions,
   175| 			tailscaleOptions,
   176| 			dockertestutil.DockerRestartPolicy,
   177| 			dockertestutil.DockerAllowLocalIPv6,
   178| 			dockertestutil.DockerAllowNetworkAdministration,
   179| 		)
   180| 	case "unstable":
   181| 		tailscaleOptions.Repository = "tailscale/tailscale"
   182| 		tailscaleOptions.Tag = version
   183| 		container, err = pool.RunWithOptions(
   184| 			tailscaleOptions,
   185| 			dockertestutil.DockerRestartPolicy,
   186| 			dockertestutil.DockerAllowLocalIPv6,
   187| 			dockertestutil.DockerAllowNetworkAdministration,
   188| 		)
   189| 	default:
   190| 		tailscaleOptions.Repository = "tailscale/tailscale"
   191| 		tailscaleOptions.Tag = "v" + version
   192| 		container, err = pool.RunWithOptions(
   193| 			tailscaleOptions,
   194| 			dockertestutil.DockerRestartPolicy,
   195| 			dockertestutil.DockerAllowLocalIPv6,
   196| 			dockertestutil.DockerAllowNetworkAdministration,
   197| 		)
   198| 	}
   199| 	if err != nil {
   200| 		return nil, fmt.Errorf(
   201| 			"%s could not start tailscale container (version: %s): %w",
   202| 			hostname,
   203| 			version,
   204| 			err,
   205| 		)
   206| 	}
   207| 	log.Printf("Created %s container\n", hostname)
   208| 	tsic.container = container
   209| 	if tsic.hasTLS() {
   210| 		err = tsic.WriteFile(headscaleCertPath, tsic.headscaleCert)
   211| 		if err != nil {
   212| 			return nil, fmt.Errorf("failed to write TLS certificate to container: %w", err)
   213| 		}
   214| 	}
   215| 	return tsic, nil
   216| }
   217| func (t *TailscaleInContainer) hasTLS() bool {
   218| 	return len(t.headscaleCert) != 0
   219| }
   220| func (t *TailscaleInContainer) Shutdown() error {
   221| 	err := t.SaveLog("/tmp/control")
   222| 	if err != nil {
   223| 		log.Printf(
   224| 			"Failed to save log from %s: %s",
   225| 			t.hostname,
   226| 			fmt.Errorf("failed to save log: %w", err),
   227| 		)
   228| 	}
   229| 	return t.pool.Purge(t.container)
   230| }
   231| func (t *TailscaleInContainer) Hostname() string {
   232| 	return t.hostname
   233| }
   234| func (t *TailscaleInContainer) Version() string {
   235| 	return t.version
   236| }
   237| func (t *TailscaleInContainer) ID() string {
   238| 	return t.container.Container.ID
   239| }
   240| func (t *TailscaleInContainer) Execute(
   241| 	command []string,
   242| 	options ...dockertestutil.ExecuteCommandOption,
   243| ) (string, string, error) {
   244| 	stdout, stderr, err := dockertestutil.ExecuteCommand(
   245| 		t.container,
   246| 		command,
   247| 		[]string{},
   248| 		options...,
   249| 	)
   250| 	if err != nil {
   251| 		if stdout != "" {
   252| 			log.Printf("command stdout: %s\n", stdout)
   253| 		}
   254| 		if strings.Contains(stderr, "NeedsLogin") {
   255| 			return stdout, stderr, errTailscaleNotLoggedIn
   256| 		}
   257| 		return stdout, stderr, err
   258| 	}
   259| 	return stdout, stderr, nil
   260| }
   261| func (t *TailscaleInContainer) Login(
   262| 	loginServer, authKey string,
   263| ) error {
   264| 	command := []string{
   265| 		"tailscale",
   266| 		"up",
   267| 		"--login-server=" + loginServer,
   268| 		"--authkey=" + authKey,
   269| 		"--hostname=" + t.hostname,
   270| 		"--accept-routes=false",
   271| 	}
   272| 	if t.withSSH {
   273| 		command = append(command, "--ssh")
   274| 	}
   275| 	if t.netfilter != "" {
   276| 		command = append(command, "--netfilter-mode="+t.netfilter)
   277| 	}
   278| 	if len(t.withTags) > 0 {
   279| 		command = append(command,
   280| 			fmt.Sprintf(`--advertise-tags=%s`, strings.Join(t.withTags, ",")),
   281| 		)
   282| 	}
   283| 	if _, _, err := t.Execute(command, dockertestutil.ExecuteCommandTimeout(dockerExecuteTimeout)); err != nil {
   284| 		return fmt.Errorf(
   285| 			"%s failed to join tailscale client (%s): %w",
   286| 			t.hostname,
   287| 			strings.Join(command, " "),
   288| 			err,
   289| 		)
   290| 	}
   291| 	return nil
   292| }
   293| func (t *TailscaleInContainer) LoginWithURL(
   294| 	loginServer string,
   295| ) (*url.URL, error) {
   296| 	command := []string{
   297| 		"tailscale",
   298| 		"up",
   299| 		"--login-server=" + loginServer,
   300| 		"--hostname=" + t.hostname,
   301| 		"--accept-routes=false",
   302| 	}
   303| 	_, stderr, err := t.Execute(command)
   304| 	if errors.Is(err, errTailscaleNotLoggedIn) {
   305| 		return nil, errTailscaleCannotUpWithoutAuthkey
   306| 	}
   307| 	urlStr := strings.ReplaceAll(stderr, "\nTo authenticate, visit:\n\n\t", "")
   308| 	urlStr = strings.TrimSpace(urlStr)
   309| 	loginURL, err := url.Parse(urlStr)
   310| 	if err != nil {
   311| 		log.Printf("Could not parse login URL: %s", err)
   312| 		log.Printf("Original join command result: %s", stderr)
   313| 		return nil, err
   314| 	}
   315| 	return loginURL, nil
   316| }
   317| func (t *TailscaleInContainer) Logout() error {
   318| 	_, _, err := t.Execute([]string{"tailscale", "logout"})
   319| 	if err != nil {
   320| 		return err
   321| 	}
   322| 	return nil
   323| }
   324| func (t *TailscaleInContainer) Up() error {
   325| 	command := []string{
   326| 		"tailscale",
   327| 		"up",
   328| 	}
   329| 	if _, _, err := t.Execute(command, dockertestutil.ExecuteCommandTimeout(dockerExecuteTimeout)); err != nil {
   330| 		return fmt.Errorf(
   331| 			"%s failed to bring tailscale client up (%s): %w",
   332| 			t.hostname,
   333| 			strings.Join(command, " "),
   334| 			err,
   335| 		)
   336| 	}
   337| 	return nil
   338| }
   339| func (t *TailscaleInContainer) Down() error {
   340| 	command := []string{
   341| 		"tailscale",
   342| 		"down",
   343| 	}
   344| 	if _, _, err := t.Execute(command, dockertestutil.ExecuteCommandTimeout(dockerExecuteTimeout)); err != nil {
   345| 		return fmt.Errorf(
   346| 			"%s failed to bring tailscale client down (%s): %w",
   347| 			t.hostname,
   348| 			strings.Join(command, " "),
   349| 			err,
   350| 		)
   351| 	}
   352| 	return nil
   353| }
   354| func (t *TailscaleInContainer) IPs() ([]netip.Addr, error) {
   355| 	if t.ips != nil && len(t.ips) != 0 {
   356| 		return t.ips, nil
   357| 	}
   358| 	ips := make([]netip.Addr, 0)
   359| 	command := []string{
   360| 		"tailscale",
   361| 		"ip",
   362| 	}
   363| 	result, _, err := t.Execute(command)
   364| 	if err != nil {
   365| 		return []netip.Addr{}, fmt.Errorf("%s failed to join tailscale client: %w", t.hostname, err)
   366| 	}
   367| 	for _, address := range strings.Split(result, "\n") {
   368| 		address = strings.TrimSuffix(address, "\n")
   369| 		if len(address) < 1 {
   370| 			continue
   371| 		}
   372| 		ip, err := netip.ParseAddr(address)
   373| 		if err != nil {
   374| 			return nil, err
   375| 		}
   376| 		ips = append(ips, ip)
   377| 	}
   378| 	return ips, nil
   379| }
   380| func (t *TailscaleInContainer) Status(save ...bool) (*ipnstate.Status, error) {
   381| 	command := []string{
   382| 		"tailscale",
   383| 		"status",
   384| 		"--json",
   385| 	}
   386| 	result, _, err := t.Execute(command)
   387| 	if err != nil {
   388| 		return nil, fmt.Errorf("failed to execute tailscale status command: %w", err)
   389| 	}
   390| 	var status ipnstate.Status
   391| 	err = json.Unmarshal([]byte(result), &status)
   392| 	if err != nil {
   393| 		return nil, fmt.Errorf("failed to unmarshal tailscale status: %w", err)
   394| 	}
   395| 	err = os.WriteFile(fmt.Sprintf("/tmp/control/%s_status.json", t.hostname), []byte(result), 0o755)
   396| 	if err != nil {
   397| 		return nil, fmt.Errorf("status netmap to /tmp/control: %w", err)
   398| 	}
   399| 	return &status, err
   400| }
   401| func (t *TailscaleInContainer) Netmap() (*netmap.NetworkMap, error) {
   402| 	if !util.TailscaleVersionNewerOrEqual("1.56", t.version) {
   403| 		panic(fmt.Sprintf("tsic.Netmap() called with unsupported version: %s", t.version))
   404| 	}
   405| 	command := []string{
   406| 		"tailscale",
   407| 		"debug",
   408| 		"netmap",
   409| 	}
   410| 	result, stderr, err := t.Execute(command)
   411| 	if err != nil {
   412| 		fmt.Printf("stderr: %s\n", stderr)
   413| 		return nil, fmt.Errorf("failed to execute tailscale debug netmap command: %w", err)
   414| 	}
   415| 	var nm netmap.NetworkMap
   416| 	err = json.Unmarshal([]byte(result), &nm)
   417| 	if err != nil {
   418| 		return nil, fmt.Errorf("failed to unmarshal tailscale netmap: %w", err)
   419| 	}
   420| 	err = os.WriteFile(fmt.Sprintf("/tmp/control/%s_netmap.json", t.hostname), []byte(result), 0o755)
   421| 	if err != nil {
   422| 		return nil, fmt.Errorf("saving netmap to /tmp/control: %w", err)
   423| 	}
   424| 	return &nm, err
   425| }
   426| func (t *TailscaleInContainer) watchIPN(ctx context.Context) (*ipn.Notify, error) {
   427| 	pr, pw := io.Pipe()
   428| 	type result struct {
   429| 		notify *ipn.Notify
   430| 		err    error
   431| 	}
   432| 	resultChan := make(chan result, 1)
   433| 	killWatcher := func() {
   434| 		stdout, stderr, err := t.Execute([]string{
   435| 			"/bin/sh", "-c", `kill $(ps aux | grep "tailscale debug watch-ipn" | grep -v grep | awk '{print $1}') || true`,
   436| 		})
   437| 		if err != nil {
   438| 			log.Printf("failed to kill tailscale watcher, \nstdout: %s\nstderr: %s\nerr: %s", stdout, stderr, err)
   439| 		}
   440| 	}
   441| 	go func() {
   442| 		_, _ = t.container.Exec(
   443| 			[]string{"/bin/sh", "-c", `tailscale debug watch-ipn | grep -v "Connected."`},
   444| 			dockertest.ExecOptions{
   445| 				StdOut: pw,
   446| 			},
   447| 		)
   448| 	}()
   449| 	go func() {
   450| 		decoder := json.NewDecoder(pr)
   451| 		for decoder.More() {
   452| 			var notify ipn.Notify
   453| 			if err := decoder.Decode(&notify); err != nil {
   454| 				resultChan <- result{nil, fmt.Errorf("parse notify: %w", err)}
   455| 			}
   456| 			if notify.NetMap != nil {
   457| 				resultChan <- result{&notify, nil}
   458| 			}
   459| 		}
   460| 	}()
   461| 	select {
   462| 	case <-ctx.Done():
   463| 		killWatcher()
   464| 		return nil, ctx.Err()
   465| 	case result := <-resultChan:
   466| 		killWatcher()
   467| 		if result.err != nil {
   468| 			return nil, result.err
   469| 		}
   470| 		return result.notify, nil
   471| 	}
   472| }
   473| func (t *TailscaleInContainer) Netcheck() (*netcheck.Report, error) {
   474| 	command := []string{
   475| 		"tailscale",
   476| 		"netcheck",
   477| 		"--format=json",
   478| 	}
   479| 	result, stderr, err := t.Execute(command)
   480| 	if err != nil {
   481| 		fmt.Printf("stderr: %s\n", stderr)
   482| 		return nil, fmt.Errorf("failed to execute tailscale debug netcheck command: %w", err)
   483| 	}
   484| 	var nm netcheck.Report
   485| 	err = json.Unmarshal([]byte(result), &nm)
   486| 	if err != nil {
   487| 		return nil, fmt.Errorf("failed to unmarshal tailscale netcheck: %w", err)
   488| 	}
   489| 	return &nm, err
   490| }
   491| func (t *TailscaleInContainer) FQDN() (string, error) {
   492| 	if t.fqdn != "" {
   493| 		return t.fqdn, nil
   494| 	}
   495| 	status, err := t.Status()
   496| 	if err != nil {
   497| 		return "", fmt.Errorf("failed to get FQDN: %w", err)
   498| 	}
   499| 	return status.Self.DNSName, nil
   500| }
   501| func (t *TailscaleInContainer) FailingPeersAsString() (string, bool, error) {
   502| 	status, err := t.Status()
   503| 	if err != nil {
   504| 		return "", false, fmt.Errorf("failed to get FQDN: %w", err)
   505| 	}
   506| 	var b strings.Builder
   507| 	fmt.Fprintf(&b, "Peers of %s\n", t.hostname)
   508| 	fmt.Fprint(&b, "Hostname\tOnline\tLastSeen\n")
   509| 	peerCount := len(status.Peers())
   510| 	onlineCount := 0
   511| 	for _, peerKey := range status.Peers() {
   512| 		peer := status.Peer[peerKey]
   513| 		if peer.Online {
   514| 			onlineCount++
   515| 		}
   516| 		fmt.Fprintf(&b, "%s\t%t\t%s\n", peer.HostName, peer.Online, peer.LastSeen)
   517| 	}
   518| 	fmt.Fprintf(&b, "Peer Count: %d, Online Count: %d\n\n", peerCount, onlineCount)
   519| 	return b.String(), peerCount == onlineCount, nil
   520| }
   521| func (t *TailscaleInContainer) WaitForNeedsLogin() error {
   522| 	return t.pool.Retry(func() error {
   523| 		status, err := t.Status()
   524| 		if err != nil {
   525| 			return errTailscaleStatus(t.hostname, err)
   526| 		}
   527| 		if status.BackendState == "NeedsLogin" {
   528| 			return nil
   529| 		}
   530| 		return errTailscaledNotReadyForLogin
   531| 	})
   532| }
   533| func (t *TailscaleInContainer) WaitForRunning() error {
   534| 	return t.pool.Retry(func() error {
   535| 		status, err := t.Status()
   536| 		if err != nil {
   537| 			return errTailscaleStatus(t.hostname, err)
   538| 		}
   539| 		if status.BackendState == "Running" {
   540| 			return nil
   541| 		}
   542| 		return errTailscaleNotConnected
   543| 	})
   544| }
   545| func (t *TailscaleInContainer) WaitForPeers(expected int) error {
   546| 	return t.pool.Retry(func() error {
   547| 		status, err := t.Status()
   548| 		if err != nil {
   549| 			return errTailscaleStatus(t.hostname, err)
   550| 		}
   551| 		if peers := status.Peers(); len(peers) != expected {
   552| 			return fmt.Errorf(
   553| 				"%s err: %w expected %d, got %d",
   554| 				t.hostname,
   555| 				errTailscaleWrongPeerCount,
   556| 				expected,
   557| 				len(peers),
   558| 			)
   559| 		} else {
   560| 			for _, peerKey := range peers {
   561| 				peer := status.Peer[peerKey]
   562| 				if !peer.Online {
   563| 					return fmt.Errorf("[%s] peer count correct, but %s is not online", t.hostname, peer.HostName)
   564| 				}
   565| 				if peer.HostName == "" {
   566| 					return fmt.Errorf("[%s] peer count correct, but %s does not have a Hostname", t.hostname, peer.HostName)
   567| 				}
   568| 				if peer.Relay == "" {
   569| 					return fmt.Errorf("[%s] peer count correct, but %s does not have a DERP", t.hostname, peer.HostName)
   570| 				}
   571| 			}
   572| 		}
   573| 		return nil
   574| 	})
   575| }
   576| type (
   577| 	PingOption = func(args *pingArgs)
   578| 	pingArgs struct {
   579| 		timeout time.Duration
   580| 		count   int
   581| 		direct  bool
   582| 	}
   583| )
   584| func WithPingTimeout(timeout time.Duration) PingOption {
   585| 	return func(args *pingArgs) {
   586| 		args.timeout = timeout
   587| 	}
   588| }
   589| func WithPingCount(count int) PingOption {
   590| 	return func(args *pingArgs) {
   591| 		args.count = count
   592| 	}
   593| }
   594| func WithPingUntilDirect(direct bool) PingOption {
   595| 	return func(args *pingArgs) {
   596| 		args.direct = direct
   597| 	}
   598| }
   599| func (t *TailscaleInContainer) Ping(hostnameOrIP string, opts ...PingOption) error {
   600| 	args := pingArgs{
   601| 		timeout: defaultPingTimeout,
   602| 		count:   defaultPingCount,
   603| 		direct:  true,
   604| 	}
   605| 	for _, opt := range opts {
   606| 		opt(&args)
   607| 	}
   608| 	command := []string{
   609| 		"tailscale", "ping",
   610| 		fmt.Sprintf("--timeout=%s", args.timeout),
   611| 		fmt.Sprintf("--c=%d", args.count),
   612| 		fmt.Sprintf("--until-direct=%s", strconv.FormatBool(args.direct)),
   613| 	}
   614| 	command = append(command, hostnameOrIP)
   615| 	result, _, err := t.Execute(
   616| 		command,
   617| 		dockertestutil.ExecuteCommandTimeout(
   618| 			time.Duration(int64(args.timeout)*int64(args.count)),
   619| 		),
   620| 	)
   621| 	if err != nil {
   622| 		log.Printf(
   623| 			"failed to run ping command from %s to %s, err: %s",
   624| 			t.Hostname(),
   625| 			hostnameOrIP,
   626| 			err,
   627| 		)
   628| 		return err
   629| 	}
   630| 	if strings.Contains(result, "is local") {
   631| 		return nil
   632| 	}
   633| 	if !strings.Contains(result, "pong") {
   634| 		return errTailscalePingFailed
   635| 	}
   636| 	if !args.direct {
   637| 		if strings.Contains(result, "via DERP") {
   638| 			return nil
   639| 		} else {
   640| 			return errTailscalePingNotDERP
   641| 		}
   642| 	}
   643| 	return nil
   644| }
   645| type (
   646| 	CurlOption = func(args *curlArgs)
   647| 	curlArgs struct {
   648| 		connectionTimeout time.Duration
   649| 		maxTime           time.Duration
   650| 		retry             int
   651| 		retryDelay        time.Duration
   652| 		retryMaxTime      time.Duration
   653| 	}
   654| )
   655| func WithCurlConnectionTimeout(timeout time.Duration) CurlOption {
   656| 	return func(args *curlArgs) {
   657| 		args.connectionTimeout = timeout
   658| 	}
   659| }
   660| func WithCurlMaxTime(t time.Duration) CurlOption {
   661| 	return func(args *curlArgs) {
   662| 		args.maxTime = t
   663| 	}

# --- HUNK 3: Lines 679-745 ---
   679| 		connectionTimeout: defaultConnectionTimeout,
   680| 		maxTime:           defaultMaxTime,
   681| 		retry:             defaultRetry,
   682| 		retryDelay:        defaultRetryDelay,
   683| 		retryMaxTime:      defaultRetryMaxTime,
   684| 	}
   685| 	for _, opt := range opts {
   686| 		opt(&args)
   687| 	}
   688| 	command := []string{
   689| 		"curl",
   690| 		"--silent",
   691| 		"--connect-timeout", fmt.Sprintf("%d", int(args.connectionTimeout.Seconds())),
   692| 		"--max-time", fmt.Sprintf("%d", int(args.maxTime.Seconds())),
   693| 		"--retry", fmt.Sprintf("%d", args.retry),
   694| 		"--retry-delay", fmt.Sprintf("%d", int(args.retryDelay.Seconds())),
   695| 		"--retry-max-time", fmt.Sprintf("%d", int(args.retryMaxTime.Seconds())),
   696| 		url,
   697| 	}
   698| 	var result string
   699| 	result, _, err := t.Execute(command)
   700| 	if err != nil {
   701| 		log.Printf(
   702| 			"failed to run curl command from %s to %s, err: %s",
   703| 			t.Hostname(),
   704| 			url,
   705| 			err,
   706| 		)
   707| 		return result, err
   708| 	}
   709| 	return result, nil
   710| }
   711| func (t *TailscaleInContainer) WriteFile(path string, data []byte) error {
   712| 	return integrationutil.WriteFileToContainer(t.pool, t.container, path, data)
   713| }
   714| func (t *TailscaleInContainer) SaveLog(path string) error {
   715| 	_, _, err := dockertestutil.SaveLog(t.pool, t.container, path)
   716| 	return err
   717| }
   718| func (t *TailscaleInContainer) ReadFile(path string) ([]byte, error) {
   719| 	tarBytes, err := integrationutil.FetchPathFromContainer(t.pool, t.container, path)
   720| 	if err != nil {
   721| 		return nil, fmt.Errorf("reading file from container: %w", err)
   722| 	}
   723| 	var out bytes.Buffer
   724| 	tr := tar.NewReader(bytes.NewReader(tarBytes))
   725| 	for {
   726| 		hdr, err := tr.Next()
   727| 		if err == io.EOF {
   728| 			break // End of archive
   729| 		}
   730| 		if err != nil {
   731| 			return nil, fmt.Errorf("reading tar header: %w", err)
   732| 		}
   733| 		if !strings.Contains(path, hdr.Name) {
   734| 			return nil, fmt.Errorf("file not found in tar archive, looking for: %s, header was: %s", path, hdr.Name)
   735| 		}
   736| 		if _, err := io.Copy(&out, tr); err != nil {
   737| 			return nil, fmt.Errorf("copying file to buffer: %w", err)
   738| 		}
   739| 		break
   740| 	}
   741| 	if out.Len() == 0 {
   742| 		return nil, fmt.Errorf("file is empty")
   743| 	}
   744| 	return out.Bytes(), nil
   745| }


# ====================================================================
# FILE: integration/utils.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-230 ---
     1| package integration
     2| import (
     3| 	"os"
     4| 	"strings"
     5| 	"sync"
     6| 	"testing"
     7| 	"time"
     8| 	"github.com/juanfont/headscale/hscontrol/util"
     9| 	"github.com/juanfont/headscale/integration/tsic"
    10| 	"github.com/stretchr/testify/assert"
    11| )
    12| const (
    13| 	derpPingTimeout = 2 * time.Second
    14| 	derpPingCount   = 10
    15| )
    16| func assertNoErr(t *testing.T, err error) {
    17| 	t.Helper()
    18| 	assertNoErrf(t, "unexpected error: %s", err)
    19| }
    20| func assertNoErrf(t *testing.T, msg string, err error) {
    21| 	t.Helper()
    22| 	if err != nil {
    23| 		t.Fatalf(msg, err)
    24| 	}
    25| }
    26| func assertNotNil(t *testing.T, thing interface{}) {
    27| 	t.Helper()
    28| 	if thing == nil {
    29| 		t.Fatal("got unexpected nil")
    30| 	}
    31| }
    32| func assertNoErrHeadscaleEnv(t *testing.T, err error) {
    33| 	t.Helper()
    34| 	assertNoErrf(t, "failed to create headscale environment: %s", err)
    35| }
    36| func assertNoErrGetHeadscale(t *testing.T, err error) {
    37| 	t.Helper()
    38| 	assertNoErrf(t, "failed to get headscale: %s", err)
    39| }
    40| func assertNoErrListClients(t *testing.T, err error) {
    41| 	t.Helper()
    42| 	assertNoErrf(t, "failed to list clients: %s", err)
    43| }
    44| func assertNoErrListClientIPs(t *testing.T, err error) {
    45| 	t.Helper()
    46| 	assertNoErrf(t, "failed to get client IPs: %s", err)
    47| }
    48| func assertNoErrSync(t *testing.T, err error) {
    49| 	t.Helper()
    50| 	assertNoErrf(t, "failed to have all clients sync up: %s", err)
    51| }
    52| func assertNoErrListFQDN(t *testing.T, err error) {
    53| 	t.Helper()
    54| 	assertNoErrf(t, "failed to list FQDNs: %s", err)
    55| }
    56| func assertNoErrLogout(t *testing.T, err error) {
    57| 	t.Helper()
    58| 	assertNoErrf(t, "failed to log out tailscale nodes: %s", err)
    59| }
    60| func assertContains(t *testing.T, str, subStr string) {
    61| 	t.Helper()
    62| 	if !strings.Contains(str, subStr) {
    63| 		t.Fatalf("%#v does not contain %#v", str, subStr)
    64| 	}
    65| }
    66| func pingAllHelper(t *testing.T, clients []TailscaleClient, addrs []string, opts ...tsic.PingOption) int {
    67| 	t.Helper()
    68| 	success := 0
    69| 	for _, client := range clients {
    70| 		for _, addr := range addrs {
    71| 			err := client.Ping(addr, opts...)
    72| 			if err != nil {
    73| 				t.Errorf("failed to ping %s from %s: %s", addr, client.Hostname(), err)
    74| 			} else {
    75| 				success++
    76| 			}
    77| 		}
    78| 	}
    79| 	return success
    80| }
    81| func pingDerpAllHelper(t *testing.T, clients []TailscaleClient, addrs []string) int {
    82| 	t.Helper()
    83| 	success := 0
    84| 	for _, client := range clients {
    85| 		for _, addr := range addrs {
    86| 			if isSelfClient(client, addr) {
    87| 				continue
    88| 			}
    89| 			err := client.Ping(
    90| 				addr,
    91| 				tsic.WithPingTimeout(derpPingTimeout),
    92| 				tsic.WithPingCount(derpPingCount),
    93| 				tsic.WithPingUntilDirect(false),
    94| 			)
    95| 			if err != nil {
    96| 				t.Fatalf("failed to ping %s from %s: %s", addr, client.Hostname(), err)
    97| 			} else {
    98| 				success++
    99| 			}
   100| 		}
   101| 	}
   102| 	return success
   103| }
   104| func assertClientsState(t *testing.T, clients []TailscaleClient) {
   105| 	t.Helper()
   106| 	var wg sync.WaitGroup
   107| 	for _, client := range clients {
   108| 		wg.Add(1)
   109| 		c := client // Avoid loop pointer
   110| 		go func() {
   111| 			defer wg.Done()
   112| 			assertValidStatus(t, c)
   113| 			assertValidNetcheck(t, c)
   114| 			assertValidNetmap(t, c)
   115| 		}()
   116| 	}
   117| 	t.Logf("waiting for client state checks to finish")
   118| 	wg.Wait()
   119| }
   120| func assertValidNetmap(t *testing.T, client TailscaleClient) {
   121| 	t.Helper()
   122| 	if !util.TailscaleVersionNewerOrEqual("1.56", client.Version()) {
   123| 		t.Logf("%q has version %q, skipping netmap check...", client.Hostname(), client.Version())
   124| 		return
   125| 	}
   126| 	t.Logf("Checking netmap of %q", client.Hostname())
   127| 	netmap, err := client.Netmap()
   128| 	if err != nil {
   129| 		t.Fatalf("getting netmap for %q: %s", client.Hostname(), err)
   130| 	}
   131| 	assert.Truef(t, netmap.SelfNode.Hostinfo().Valid(), "%q does not have Hostinfo", client.Hostname())
   132| 	if hi := netmap.SelfNode.Hostinfo(); hi.Valid() {
   133| 		assert.LessOrEqual(t, 1, netmap.SelfNode.Hostinfo().Services().Len(), "%q does not have enough services, got: %v", client.Hostname(), netmap.SelfNode.Hostinfo().Services())
   134| 	}
   135| 	assert.NotEmptyf(t, netmap.SelfNode.AllowedIPs(), "%q does not have any allowed IPs", client.Hostname())
   136| 	assert.NotEmptyf(t, netmap.SelfNode.Addresses(), "%q does not have any addresses", client.Hostname())
   137| 	if netmap.SelfNode.Online() != nil {
   138| 		assert.Truef(t, *netmap.SelfNode.Online(), "%q is not online", client.Hostname())
   139| 	} else {
   140| 		t.Errorf("Online should not be nil for %s", client.Hostname())
   141| 	}
   142| 	assert.Falsef(t, netmap.SelfNode.Key().IsZero(), "%q does not have a valid NodeKey", client.Hostname())
   143| 	assert.Falsef(t, netmap.SelfNode.Machine().IsZero(), "%q does not have a valid MachineKey", client.Hostname())
   144| 	assert.Falsef(t, netmap.SelfNode.DiscoKey().IsZero(), "%q does not have a valid DiscoKey", client.Hostname())
   145| 	for _, peer := range netmap.Peers {
   146| 		assert.NotEqualf(t, "127.3.3.40:0", peer.DERP(), "peer (%s) has no home DERP in %q's netmap, got: %s", peer.ComputedName(), client.Hostname(), peer.DERP())
   147| 		assert.Truef(t, peer.Hostinfo().Valid(), "peer (%s) of %q does not have Hostinfo", peer.ComputedName(), client.Hostname())
   148| 		if hi := peer.Hostinfo(); hi.Valid() {
   149| 			assert.LessOrEqualf(t, 3, peer.Hostinfo().Services().Len(), "peer (%s) of %q does not have enough services, got: %v", peer.ComputedName(), client.Hostname(), peer.Hostinfo().Services())
   150| 			if ni := hi.NetInfo(); ni.Valid() {
   151| 				assert.NotEqualf(t, 0, ni.PreferredDERP(), "peer (%s) has no home DERP in %q's netmap, got: %s", peer.ComputedName(), client.Hostname(), peer.Hostinfo().NetInfo().PreferredDERP())
   152| 			}
   153| 		}
   154| 		assert.NotEmptyf(t, peer.Endpoints(), "peer (%s) of %q does not have any endpoints", peer.ComputedName(), client.Hostname())
   155| 		assert.NotEmptyf(t, peer.AllowedIPs(), "peer (%s) of %q does not have any allowed IPs", peer.ComputedName(), client.Hostname())
   156| 		assert.NotEmptyf(t, peer.Addresses(), "peer (%s) of %q does not have any addresses", peer.ComputedName(), client.Hostname())
   157| 		assert.Truef(t, *peer.Online(), "peer (%s) of %q is not online", peer.ComputedName(), client.Hostname())
   158| 		assert.Falsef(t, peer.Key().IsZero(), "peer (%s) of %q does not have a valid NodeKey", peer.ComputedName(), client.Hostname())
   159| 		assert.Falsef(t, peer.Machine().IsZero(), "peer (%s) of %q does not have a valid MachineKey", peer.ComputedName(), client.Hostname())
   160| 		assert.Falsef(t, peer.DiscoKey().IsZero(), "peer (%s) of %q does not have a valid DiscoKey", peer.ComputedName(), client.Hostname())
   161| 	}
   162| }
   163| func assertValidStatus(t *testing.T, client TailscaleClient) {
   164| 	t.Helper()
   165| 	status, err := client.Status(true)
   166| 	if err != nil {
   167| 		t.Fatalf("getting status for %q: %s", client.Hostname(), err)
   168| 	}
   169| 	assert.NotEmptyf(t, status.Self.HostName, "%q does not have HostName set, likely missing Hostinfo", client.Hostname())
   170| 	assert.NotEmptyf(t, status.Self.OS, "%q does not have OS set, likely missing Hostinfo", client.Hostname())
   171| 	assert.NotEmptyf(t, status.Self.Relay, "%q does not have a relay, likely missing Hostinfo/Netinfo", client.Hostname())
   172| 	assert.NotEmptyf(t, status.Self.TailscaleIPs, "%q does not have Tailscale IPs", client.Hostname())
   173| 	if status.Self.AllowedIPs != nil {
   174| 		assert.NotEmptyf(t, status.Self.AllowedIPs, "%q does not have any allowed IPs", client.Hostname())
   175| 	}
   176| 	assert.NotEmptyf(t, status.Self.Addrs, "%q does not have any endpoints", client.Hostname())
   177| 	assert.Truef(t, status.Self.Online, "%q is not online", client.Hostname())
   178| 	assert.Truef(t, status.Self.InNetworkMap, "%q is not in network map", client.Hostname())
   179| 	for _, peer := range status.Peer {
   180| 		assert.NotEmptyf(t, peer.HostName, "peer (%s) of %q does not have HostName set, likely missing Hostinfo", peer.DNSName, client.Hostname())
   181| 		assert.NotEmptyf(t, peer.OS, "peer (%s) of %q does not have OS set, likely missing Hostinfo", peer.DNSName, client.Hostname())
   182| 		assert.NotEmptyf(t, peer.Relay, "peer (%s) of %q does not have a relay, likely missing Hostinfo/Netinfo", peer.DNSName, client.Hostname())
   183| 		assert.NotEmptyf(t, peer.TailscaleIPs, "peer (%s) of %q does not have Tailscale IPs", peer.DNSName, client.Hostname())
   184| 		if peer.AllowedIPs != nil {
   185| 			assert.NotEmptyf(t, peer.AllowedIPs, "peer (%s) of %q does not have any allowed IPs", peer.DNSName, client.Hostname())
   186| 		}
   187| 		assert.Truef(t, peer.Online, "peer (%s) of %q is not online", peer.DNSName, client.Hostname())
   188| 		assert.Truef(t, peer.InNetworkMap, "peer (%s) of %q is not in network map", peer.DNSName, client.Hostname())
   189| 		assert.Truef(t, peer.InMagicSock, "peer (%s) of %q is not tracked by magicsock", peer.DNSName, client.Hostname())
   190| 	}
   191| }
   192| func assertValidNetcheck(t *testing.T, client TailscaleClient) {
   193| 	t.Helper()
   194| 	report, err := client.Netcheck()
   195| 	if err != nil {
   196| 		t.Fatalf("getting status for %q: %s", client.Hostname(), err)
   197| 	}
   198| 	assert.NotEqualf(t, 0, report.PreferredDERP, "%q does not have a DERP relay", client.Hostname())
   199| }
   200| func isSelfClient(client TailscaleClient, addr string) bool {
   201| 	if addr == client.Hostname() {
   202| 		return true
   203| 	}
   204| 	ips, err := client.IPs()
   205| 	if err != nil {
   206| 		return false
   207| 	}
   208| 	for _, ip := range ips {
   209| 		if ip.String() == addr {
   210| 			return true
   211| 		}
   212| 	}
   213| 	return false
   214| }
   215| func isCI() bool {
   216| 	if _, ok := os.LookupEnv("CI"); ok {
   217| 		return true
   218| 	}
   219| 	if _, ok := os.LookupEnv("GITHUB_RUN_ID"); ok {
   220| 		return true
   221| 	}
   222| 	return false
   223| }
   224| func dockertestMaxWait() time.Duration {
   225| 	wait := 120 * time.Second //nolint
   226| 	if isCI() {
   227| 		wait = 300 * time.Second //nolint
   228| 	}
   229| 	return wait
   230| }

