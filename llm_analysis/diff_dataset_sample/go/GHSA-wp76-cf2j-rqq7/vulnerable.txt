# ====================================================================
# FILE: cmd/build-docker-img/main.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| package main
     2| import (
     3| 	"log"
     4| 	"github.com/juanfont/headscale/integration"
     5| 	"github.com/juanfont/headscale/integration/tsic"
     6| 	"github.com/ory/dockertest/v3"
     7| )
     8| func main() {
     9| 	log.Printf("creating docker pool")
    10| 	pool, err := dockertest.NewPool("")
    11| 	if err != nil {
    12| 		log.Fatalf("could not connect to docker: %s", err)
    13| 	}
    14| 	log.Printf("creating docker network")
    15| 	network, err := pool.CreateNetwork("docker-integration-net")
    16| 	if err != nil {
    17| 		log.Fatalf("failed to create or get network: %s", err)
    18| 	}
    19| 	for _, version := range integration.TailscaleVersions {
    20| 		log.Printf("creating container image for Tailscale (%s)", version)
    21| 		tsClient, err := tsic.New(
    22| 			pool,
    23| 			version,
    24| 			network,
    25| 		)
    26| 		if err != nil {
    27| 			log.Fatalf("failed to create tailscale node: %s", err)
    28| 		}
    29| 		err = tsClient.Shutdown()
    30| 		if err != nil {
    31| 			log.Fatalf("failed to shut down container: %s", err)
    32| 		}
    33| 	}
    34| 	network.Close()
    35| 	err = pool.RemoveNetwork(network)
    36| 	if err != nil {
    37| 		log.Fatalf("failed to remove network: %s", err)
    38| 	}
    39| }


# ====================================================================
# FILE: cmd/gh-action-integration-generator/main.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-136 ---
     1| package main
     2| import (
     3| 	"bytes"
     4| 	"fmt"
     5| 	"log"
     6| 	"os"
     7| 	"os/exec"
     8| 	"path"
     9| 	"path/filepath"
    10| 	"strings"
    11| 	"text/template"
    12| )
    13| var (
    14| 	githubWorkflowPath  = "../../.github/workflows/"
    15| 	jobFileNameTemplate = `test-integration-v2-%s.yaml`
    16| 	jobTemplate         = template.Must(
    17| 		template.New("jobTemplate").
    18| 			Parse(`# DO NOT EDIT, generated with cmd/gh-action-integration-generator/main.go
    19| # To regenerate, run "go generate" in cmd/gh-action-integration-generator/
    20| name: Integration Test v2 - {{.Name}}
    21| on: [pull_request]
    22| concurrency:
    23|   group: {{ "${{ github.workflow }}-$${{ github.head_ref || github.run_id }}" }}
    24|   cancel-in-progress: true
    25| jobs:
    26|   test:
    27|     runs-on: ubuntu-latest
    28|     steps:
    29|       - uses: actions/checkout@v3
    30|         with:
    31|           fetch-depth: 2
    32|       - name: Get changed files
    33|         id: changed-files
    34|         uses: tj-actions/changed-files@v34
    35|         with:
    36|           files: |
    37|             *.nix
    38|             go.*
    39|             **/*.go
    40|             integration_test/
    41|             config-example.yaml
    42|       - uses: cachix/install-nix-action@v18
    43|         if: {{ "${{ env.ACT }}" }} || steps.changed-files.outputs.any_changed == 'true'
    44|       - name: Run general integration tests
    45|         if: steps.changed-files.outputs.any_changed == 'true'
    46|         run: |
    47|             nix develop --command -- docker run \
    48|               --tty --rm \
    49|               --volume ~/.cache/hs-integration-go:/go \
    50|               --name headscale-test-suite \
    51|               --volume $PWD:$PWD -w $PWD/integration \
    52|               --volume /var/run/docker.sock:/var/run/docker.sock \
    53|               --volume $PWD/control_logs:/tmp/control \
    54|               golang:1 \
    55|                 go run gotest.tools/gotestsum@latest -- ./... \
    56|                   -tags ts2019 \
    57|                   -failfast \
    58|                   -timeout 120m \
    59|                   -parallel 1 \
    60|                   -run "^{{.Name}}$"
    61|       - uses: actions/upload-artifact@v3
    62|         if: always() && steps.changed-files.outputs.any_changed == 'true'
    63|         with:
    64|           name: logs
    65|           path: "control_logs/*.log"
    66|       - uses: actions/upload-artifact@v3
    67|         if: always() && steps.changed-files.outputs.any_changed == 'true'
    68|         with:
    69|           name: pprof
    70|           path: "control_logs/*.pprof.tar"
    71| `),
    72| 	)
    73| )
    74| const workflowFilePerm = 0o600
    75| func removeTests() {
    76| 	glob := fmt.Sprintf(jobFileNameTemplate, "*")
    77| 	files, err := filepath.Glob(filepath.Join(githubWorkflowPath, glob))
    78| 	if err != nil {
    79| 		log.Fatalf("failed to find test files")
    80| 	}
    81| 	for _, file := range files {
    82| 		err := os.Remove(file)
    83| 		if err != nil {
    84| 			log.Printf("failed to remove: %s", err)
    85| 		}
    86| 	}
    87| }
    88| func findTests() []string {
    89| 	rgBin, err := exec.LookPath("rg")
    90| 	if err != nil {
    91| 		log.Fatalf("failed to find rg (ripgrep) binary")
    92| 	}
    93| 	args := []string{
    94| 		"--regexp", "func (Test.+)\\(.*",
    95| 		"../../integration/",
    96| 		"--replace", "$1",
    97| 		"--sort", "path",
    98| 		"--no-line-number",
    99| 		"--no-filename",
   100| 		"--no-heading",
   101| 	}
   102| 	log.Printf("executing: %s %s", rgBin, strings.Join(args, " "))
   103| 	ripgrep := exec.Command(
   104| 		rgBin,
   105| 		args...,
   106| 	)
   107| 	result, err := ripgrep.CombinedOutput()
   108| 	if err != nil {
   109| 		log.Printf("out: %s", result)
   110| 		log.Fatalf("failed to run ripgrep: %s", err)
   111| 	}
   112| 	tests := strings.Split(string(result), "\n")
   113| 	tests = tests[:len(tests)-1]
   114| 	return tests
   115| }
   116| func main() {
   117| 	type testConfig struct {
   118| 		Name string
   119| 	}
   120| 	tests := findTests()
   121| 	removeTests()
   122| 	for _, test := range tests {
   123| 		log.Printf("generating workflow for %s", test)
   124| 		var content bytes.Buffer
   125| 		if err := jobTemplate.Execute(&content, testConfig{
   126| 			Name: test,
   127| 		}); err != nil {
   128| 			log.Fatalf("failed to render template: %s", err)
   129| 		}
   130| 		testPath := path.Join(githubWorkflowPath, fmt.Sprintf(jobFileNameTemplate, test))
   131| 		err := os.WriteFile(testPath, content.Bytes(), workflowFilePerm)
   132| 		if err != nil {
   133| 			log.Fatalf("failed to write github job: %s", err)
   134| 		}
   135| 	}
   136| }


# ====================================================================
# FILE: cmd/headscale/cli/api_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-159 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"strconv"
     5| 	"time"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"github.com/juanfont/headscale/hscontrol"
     8| 	"github.com/prometheus/common/model"
     9| 	"github.com/pterm/pterm"
    10| 	"github.com/rs/zerolog/log"
    11| 	"github.com/spf13/cobra"
    12| 	"google.golang.org/protobuf/types/known/timestamppb"
    13| )
    14| const (
    15| 	DefaultAPIKeyExpiry = "90d"
    16| )
    17| func init() {
    18| 	rootCmd.AddCommand(apiKeysCmd)
    19| 	apiKeysCmd.AddCommand(listAPIKeys)
    20| 	createAPIKeyCmd.Flags().
    21| 		StringP("expiration", "e", DefaultAPIKeyExpiry, "Human-readable expiration of the key (e.g. 30m, 24h)")
    22| 	apiKeysCmd.AddCommand(createAPIKeyCmd)
    23| 	expireAPIKeyCmd.Flags().StringP("prefix", "p", "", "ApiKey prefix")
    24| 	err := expireAPIKeyCmd.MarkFlagRequired("prefix")
    25| 	if err != nil {
    26| 		log.Fatal().Err(err).Msg("")
    27| 	}
    28| 	apiKeysCmd.AddCommand(expireAPIKeyCmd)
    29| }
    30| var apiKeysCmd = &cobra.Command{
    31| 	Use:     "apikeys",
    32| 	Short:   "Handle the Api keys in Headscale",
    33| 	Aliases: []string{"apikey", "api"},
    34| }
    35| var listAPIKeys = &cobra.Command{
    36| 	Use:     "list",
    37| 	Short:   "List the Api keys for headscale",
    38| 	Aliases: []string{"ls", "show"},
    39| 	Run: func(cmd *cobra.Command, args []string) {
    40| 		output, _ := cmd.Flags().GetString("output")
    41| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    42| 		defer cancel()
    43| 		defer conn.Close()
    44| 		request := &v1.ListApiKeysRequest{}
    45| 		response, err := client.ListApiKeys(ctx, request)
    46| 		if err != nil {
    47| 			ErrorOutput(
    48| 				err,
    49| 				fmt.Sprintf("Error getting the list of keys: %s", err),
    50| 				output,
    51| 			)
    52| 			return
    53| 		}
    54| 		if output != "" {
    55| 			SuccessOutput(response.ApiKeys, "", output)
    56| 			return
    57| 		}
    58| 		tableData := pterm.TableData{
    59| 			{"ID", "Prefix", "Expiration", "Created"},
    60| 		}
    61| 		for _, key := range response.ApiKeys {
    62| 			expiration := "-"
    63| 			if key.GetExpiration() != nil {
    64| 				expiration = ColourTime(key.Expiration.AsTime())
    65| 			}
    66| 			tableData = append(tableData, []string{
    67| 				strconv.FormatUint(key.GetId(), hscontrol.Base10),
    68| 				key.GetPrefix(),
    69| 				expiration,
    70| 				key.GetCreatedAt().AsTime().Format(HeadscaleDateTimeFormat),
    71| 			})
    72| 		}
    73| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
    74| 		if err != nil {
    75| 			ErrorOutput(
    76| 				err,
    77| 				fmt.Sprintf("Failed to render pterm table: %s", err),
    78| 				output,
    79| 			)
    80| 			return
    81| 		}
    82| 	},
    83| }
    84| var createAPIKeyCmd = &cobra.Command{
    85| 	Use:   "create",
    86| 	Short: "Creates a new Api key",
    87| 	Long: `
    88| Creates a new Api key, the Api key is only visible on creation
    89| and cannot be retrieved again.
    90| If you loose a key, create a new one and revoke (expire) the old one.`,
    91| 	Aliases: []string{"c", "new"},
    92| 	Run: func(cmd *cobra.Command, args []string) {
    93| 		output, _ := cmd.Flags().GetString("output")
    94| 		log.Trace().
    95| 			Msg("Preparing to create ApiKey")
    96| 		request := &v1.CreateApiKeyRequest{}
    97| 		durationStr, _ := cmd.Flags().GetString("expiration")
    98| 		duration, err := model.ParseDuration(durationStr)
    99| 		if err != nil {
   100| 			ErrorOutput(
   101| 				err,
   102| 				fmt.Sprintf("Could not parse duration: %s\n", err),
   103| 				output,
   104| 			)
   105| 			return
   106| 		}
   107| 		expiration := time.Now().UTC().Add(time.Duration(duration))
   108| 		log.Trace().
   109| 			Dur("expiration", time.Duration(duration)).
   110| 			Msg("expiration has been set")
   111| 		request.Expiration = timestamppb.New(expiration)
   112| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   113| 		defer cancel()
   114| 		defer conn.Close()
   115| 		response, err := client.CreateApiKey(ctx, request)
   116| 		if err != nil {
   117| 			ErrorOutput(
   118| 				err,
   119| 				fmt.Sprintf("Cannot create Api Key: %s\n", err),
   120| 				output,
   121| 			)
   122| 			return
   123| 		}
   124| 		SuccessOutput(response.ApiKey, response.ApiKey, output)
   125| 	},
   126| }
   127| var expireAPIKeyCmd = &cobra.Command{
   128| 	Use:     "expire",
   129| 	Short:   "Expire an ApiKey",
   130| 	Aliases: []string{"revoke", "exp", "e"},
   131| 	Run: func(cmd *cobra.Command, args []string) {
   132| 		output, _ := cmd.Flags().GetString("output")
   133| 		prefix, err := cmd.Flags().GetString("prefix")
   134| 		if err != nil {
   135| 			ErrorOutput(
   136| 				err,
   137| 				fmt.Sprintf("Error getting prefix from CLI flag: %s", err),
   138| 				output,
   139| 			)
   140| 			return
   141| 		}
   142| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   143| 		defer cancel()
   144| 		defer conn.Close()
   145| 		request := &v1.ExpireApiKeyRequest{
   146| 			Prefix: prefix,
   147| 		}
   148| 		response, err := client.ExpireApiKey(ctx, request)
   149| 		if err != nil {
   150| 			ErrorOutput(
   151| 				err,
   152| 				fmt.Sprintf("Cannot expire Api Key: %s\n", err),
   153| 				output,
   154| 			)
   155| 			return
   156| 		}
   157| 		SuccessOutput(response, "Key expired", output)
   158| 	},
   159| }


# ====================================================================
# FILE: cmd/headscale/cli/debug.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-111 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     5| 	"github.com/juanfont/headscale/hscontrol"
     6| 	"github.com/rs/zerolog/log"
     7| 	"github.com/spf13/cobra"
     8| 	"google.golang.org/grpc/status"
     9| )
    10| const (
    11| 	errPreAuthKeyMalformed = Error("key is malformed. expected 64 hex characters with `nodekey` prefix")
    12| )
    13| type Error string
    14| func (e Error) Error() string { return string(e) }
    15| func init() {
    16| 	rootCmd.AddCommand(debugCmd)
    17| 	createNodeCmd.Flags().StringP("name", "", "", "Name")
    18| 	err := createNodeCmd.MarkFlagRequired("name")
    19| 	if err != nil {
    20| 		log.Fatal().Err(err).Msg("")
    21| 	}
    22| 	createNodeCmd.Flags().StringP("user", "u", "", "User")
    23| 	createNodeCmd.Flags().StringP("namespace", "n", "", "User")
    24| 	createNodeNamespaceFlag := createNodeCmd.Flags().Lookup("namespace")
    25| 	createNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    26| 	createNodeNamespaceFlag.Hidden = true
    27| 	err = createNodeCmd.MarkFlagRequired("user")
    28| 	if err != nil {
    29| 		log.Fatal().Err(err).Msg("")
    30| 	}
    31| 	createNodeCmd.Flags().StringP("key", "k", "", "Key")
    32| 	err = createNodeCmd.MarkFlagRequired("key")
    33| 	if err != nil {
    34| 		log.Fatal().Err(err).Msg("")
    35| 	}
    36| 	createNodeCmd.Flags().
    37| 		StringSliceP("route", "r", []string{}, "List (or repeated flags) of routes to advertise")
    38| 	debugCmd.AddCommand(createNodeCmd)
    39| }
    40| var debugCmd = &cobra.Command{
    41| 	Use:   "debug",
    42| 	Short: "debug and testing commands",
    43| 	Long:  "debug contains extra commands used for debugging and testing headscale",
    44| }
    45| var createNodeCmd = &cobra.Command{
    46| 	Use:   "create-node",
    47| 	Short: "Create a node (machine) that can be registered with `nodes register <>` command",
    48| 	Run: func(cmd *cobra.Command, args []string) {
    49| 		output, _ := cmd.Flags().GetString("output")
    50| 		user, err := cmd.Flags().GetString("user")
    51| 		if err != nil {
    52| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    53| 			return
    54| 		}
    55| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    56| 		defer cancel()
    57| 		defer conn.Close()
    58| 		name, err := cmd.Flags().GetString("name")
    59| 		if err != nil {
    60| 			ErrorOutput(
    61| 				err,
    62| 				fmt.Sprintf("Error getting node from flag: %s", err),
    63| 				output,
    64| 			)
    65| 			return
    66| 		}
    67| 		machineKey, err := cmd.Flags().GetString("key")
    68| 		if err != nil {
    69| 			ErrorOutput(
    70| 				err,
    71| 				fmt.Sprintf("Error getting key from flag: %s", err),
    72| 				output,
    73| 			)
    74| 			return
    75| 		}
    76| 		if !hscontrol.NodePublicKeyRegex.Match([]byte(machineKey)) {
    77| 			err = errPreAuthKeyMalformed
    78| 			ErrorOutput(
    79| 				err,
    80| 				fmt.Sprintf("Error: %s", err),
    81| 				output,
    82| 			)
    83| 			return
    84| 		}
    85| 		routes, err := cmd.Flags().GetStringSlice("route")
    86| 		if err != nil {
    87| 			ErrorOutput(
    88| 				err,
    89| 				fmt.Sprintf("Error getting routes from flag: %s", err),
    90| 				output,
    91| 			)
    92| 			return
    93| 		}
    94| 		request := &v1.DebugCreateMachineRequest{
    95| 			Key:    machineKey,
    96| 			Name:   name,
    97| 			User:   user,
    98| 			Routes: routes,
    99| 		}
   100| 		response, err := client.DebugCreateMachine(ctx, request)
   101| 		if err != nil {
   102| 			ErrorOutput(
   103| 				err,
   104| 				fmt.Sprintf("Cannot create machine: %s", status.Convert(err).Message()),
   105| 				output,
   106| 			)
   107| 			return
   108| 		}
   109| 		SuccessOutput(response.Machine, "Machine created", output)
   110| 	},
   111| }


# ====================================================================
# FILE: cmd/headscale/cli/nodes.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"log"
     5| 	"net/netip"
     6| 	"strconv"
     7| 	"strings"
     8| 	"time"
     9| 	survey "github.com/AlecAivazis/survey/v2"
    10| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    11| 	"github.com/juanfont/headscale/hscontrol"
    12| 	"github.com/pterm/pterm"
    13| 	"github.com/spf13/cobra"
    14| 	"google.golang.org/grpc/status"
    15| 	"tailscale.com/types/key"
    16| )
    17| func init() {
    18| 	rootCmd.AddCommand(nodeCmd)
    19| 	listNodesCmd.Flags().StringP("user", "u", "", "Filter by user")
    20| 	listNodesCmd.Flags().BoolP("tags", "t", false, "Show tags")
    21| 	listNodesCmd.Flags().StringP("namespace", "n", "", "User")
    22| 	listNodesNamespaceFlag := listNodesCmd.Flags().Lookup("namespace")
    23| 	listNodesNamespaceFlag.Deprecated = deprecateNamespaceMessage
    24| 	listNodesNamespaceFlag.Hidden = true
    25| 	nodeCmd.AddCommand(listNodesCmd)
    26| 	registerNodeCmd.Flags().StringP("user", "u", "", "User")
    27| 	registerNodeCmd.Flags().StringP("namespace", "n", "", "User")
    28| 	registerNodeNamespaceFlag := registerNodeCmd.Flags().Lookup("namespace")
    29| 	registerNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    30| 	registerNodeNamespaceFlag.Hidden = true
    31| 	err := registerNodeCmd.MarkFlagRequired("user")

# --- HUNK 2: Lines 62-330 ---
    62| 		log.Fatalf(err.Error())
    63| 	}
    64| 	moveNodeCmd.Flags().StringP("user", "u", "", "New user")
    65| 	moveNodeCmd.Flags().StringP("namespace", "n", "", "User")
    66| 	moveNodeNamespaceFlag := moveNodeCmd.Flags().Lookup("namespace")
    67| 	moveNodeNamespaceFlag.Deprecated = deprecateNamespaceMessage
    68| 	moveNodeNamespaceFlag.Hidden = true
    69| 	err = moveNodeCmd.MarkFlagRequired("user")
    70| 	if err != nil {
    71| 		log.Fatalf(err.Error())
    72| 	}
    73| 	nodeCmd.AddCommand(moveNodeCmd)
    74| 	tagCmd.Flags().Uint64P("identifier", "i", 0, "Node identifier (ID)")
    75| 	err = tagCmd.MarkFlagRequired("identifier")
    76| 	if err != nil {
    77| 		log.Fatalf(err.Error())
    78| 	}
    79| 	tagCmd.Flags().
    80| 		StringSliceP("tags", "t", []string{}, "List of tags to add to the node")
    81| 	nodeCmd.AddCommand(tagCmd)
    82| }
    83| var nodeCmd = &cobra.Command{
    84| 	Use:     "nodes",
    85| 	Short:   "Manage the nodes of Headscale",
    86| 	Aliases: []string{"node", "machine", "machines"},
    87| }
    88| var registerNodeCmd = &cobra.Command{
    89| 	Use:   "register",
    90| 	Short: "Registers a machine to your network",
    91| 	Run: func(cmd *cobra.Command, args []string) {
    92| 		output, _ := cmd.Flags().GetString("output")
    93| 		user, err := cmd.Flags().GetString("user")
    94| 		if err != nil {
    95| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    96| 			return
    97| 		}
    98| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    99| 		defer cancel()
   100| 		defer conn.Close()
   101| 		machineKey, err := cmd.Flags().GetString("key")
   102| 		if err != nil {
   103| 			ErrorOutput(
   104| 				err,
   105| 				fmt.Sprintf("Error getting node key from flag: %s", err),
   106| 				output,
   107| 			)
   108| 			return
   109| 		}
   110| 		request := &v1.RegisterMachineRequest{
   111| 			Key:  machineKey,
   112| 			User: user,
   113| 		}
   114| 		response, err := client.RegisterMachine(ctx, request)
   115| 		if err != nil {
   116| 			ErrorOutput(
   117| 				err,
   118| 				fmt.Sprintf(
   119| 					"Cannot register machine: %s\n",
   120| 					status.Convert(err).Message(),
   121| 				),
   122| 				output,
   123| 			)
   124| 			return
   125| 		}
   126| 		SuccessOutput(
   127| 			response.Machine,
   128| 			fmt.Sprintf("Machine %s registered", response.Machine.GivenName), output)
   129| 	},
   130| }
   131| var listNodesCmd = &cobra.Command{
   132| 	Use:     "list",
   133| 	Short:   "List nodes",
   134| 	Aliases: []string{"ls", "show"},
   135| 	Run: func(cmd *cobra.Command, args []string) {
   136| 		output, _ := cmd.Flags().GetString("output")
   137| 		user, err := cmd.Flags().GetString("user")
   138| 		if err != nil {
   139| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   140| 			return
   141| 		}
   142| 		showTags, err := cmd.Flags().GetBool("tags")
   143| 		if err != nil {
   144| 			ErrorOutput(err, fmt.Sprintf("Error getting tags flag: %s", err), output)
   145| 			return
   146| 		}
   147| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   148| 		defer cancel()
   149| 		defer conn.Close()
   150| 		request := &v1.ListMachinesRequest{
   151| 			User: user,
   152| 		}
   153| 		response, err := client.ListMachines(ctx, request)
   154| 		if err != nil {
   155| 			ErrorOutput(
   156| 				err,
   157| 				fmt.Sprintf("Cannot get nodes: %s", status.Convert(err).Message()),
   158| 				output,
   159| 			)
   160| 			return
   161| 		}
   162| 		if output != "" {
   163| 			SuccessOutput(response.Machines, "", output)
   164| 			return
   165| 		}
   166| 		tableData, err := nodesToPtables(user, showTags, response.Machines)
   167| 		if err != nil {
   168| 			ErrorOutput(err, fmt.Sprintf("Error converting to table: %s", err), output)
   169| 			return
   170| 		}
   171| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   172| 		if err != nil {
   173| 			ErrorOutput(
   174| 				err,
   175| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   176| 				output,
   177| 			)
   178| 			return
   179| 		}
   180| 	},
   181| }
   182| var expireNodeCmd = &cobra.Command{
   183| 	Use:     "expire",
   184| 	Short:   "Expire (log out) a machine in your network",
   185| 	Long:    "Expiring a node will keep the node in the database and force it to reauthenticate.",
   186| 	Aliases: []string{"logout", "exp", "e"},
   187| 	Run: func(cmd *cobra.Command, args []string) {
   188| 		output, _ := cmd.Flags().GetString("output")
   189| 		identifier, err := cmd.Flags().GetUint64("identifier")
   190| 		if err != nil {
   191| 			ErrorOutput(
   192| 				err,
   193| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   194| 				output,
   195| 			)
   196| 			return
   197| 		}
   198| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   199| 		defer cancel()
   200| 		defer conn.Close()
   201| 		request := &v1.ExpireMachineRequest{
   202| 			MachineId: identifier,
   203| 		}
   204| 		response, err := client.ExpireMachine(ctx, request)
   205| 		if err != nil {
   206| 			ErrorOutput(
   207| 				err,
   208| 				fmt.Sprintf(
   209| 					"Cannot expire machine: %s\n",
   210| 					status.Convert(err).Message(),
   211| 				),
   212| 				output,
   213| 			)
   214| 			return
   215| 		}
   216| 		SuccessOutput(response.Machine, "Machine expired", output)
   217| 	},
   218| }
   219| var renameNodeCmd = &cobra.Command{
   220| 	Use:   "rename NEW_NAME",
   221| 	Short: "Renames a machine in your network",
   222| 	Run: func(cmd *cobra.Command, args []string) {
   223| 		output, _ := cmd.Flags().GetString("output")
   224| 		identifier, err := cmd.Flags().GetUint64("identifier")
   225| 		if err != nil {
   226| 			ErrorOutput(
   227| 				err,
   228| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   229| 				output,
   230| 			)
   231| 			return
   232| 		}
   233| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   234| 		defer cancel()
   235| 		defer conn.Close()
   236| 		newName := ""
   237| 		if len(args) > 0 {
   238| 			newName = args[0]
   239| 		}
   240| 		request := &v1.RenameMachineRequest{
   241| 			MachineId: identifier,
   242| 			NewName:   newName,
   243| 		}
   244| 		response, err := client.RenameMachine(ctx, request)
   245| 		if err != nil {
   246| 			ErrorOutput(
   247| 				err,
   248| 				fmt.Sprintf(
   249| 					"Cannot rename machine: %s\n",
   250| 					status.Convert(err).Message(),
   251| 				),
   252| 				output,
   253| 			)
   254| 			return
   255| 		}
   256| 		SuccessOutput(response.Machine, "Machine renamed", output)
   257| 	},
   258| }
   259| var deleteNodeCmd = &cobra.Command{
   260| 	Use:     "delete",
   261| 	Short:   "Delete a node",
   262| 	Aliases: []string{"del"},
   263| 	Run: func(cmd *cobra.Command, args []string) {
   264| 		output, _ := cmd.Flags().GetString("output")
   265| 		identifier, err := cmd.Flags().GetUint64("identifier")
   266| 		if err != nil {
   267| 			ErrorOutput(
   268| 				err,
   269| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   270| 				output,
   271| 			)
   272| 			return
   273| 		}
   274| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   275| 		defer cancel()
   276| 		defer conn.Close()
   277| 		getRequest := &v1.GetMachineRequest{
   278| 			MachineId: identifier,
   279| 		}
   280| 		getResponse, err := client.GetMachine(ctx, getRequest)
   281| 		if err != nil {
   282| 			ErrorOutput(
   283| 				err,
   284| 				fmt.Sprintf(
   285| 					"Error getting node node: %s",
   286| 					status.Convert(err).Message(),
   287| 				),
   288| 				output,
   289| 			)
   290| 			return
   291| 		}
   292| 		deleteRequest := &v1.DeleteMachineRequest{
   293| 			MachineId: identifier,
   294| 		}
   295| 		confirm := false
   296| 		force, _ := cmd.Flags().GetBool("force")
   297| 		if !force {
   298| 			prompt := &survey.Confirm{
   299| 				Message: fmt.Sprintf(
   300| 					"Do you want to remove the node %s?",
   301| 					getResponse.GetMachine().Name,
   302| 				),
   303| 			}
   304| 			err = survey.AskOne(prompt, &confirm)
   305| 			if err != nil {
   306| 				return
   307| 			}
   308| 		}
   309| 		if confirm || force {
   310| 			response, err := client.DeleteMachine(ctx, deleteRequest)
   311| 			if output != "" {
   312| 				SuccessOutput(response, "", output)
   313| 				return
   314| 			}
   315| 			if err != nil {
   316| 				ErrorOutput(
   317| 					err,
   318| 					fmt.Sprintf(
   319| 						"Error deleting node: %s",
   320| 						status.Convert(err).Message(),
   321| 					),
   322| 					output,
   323| 				)
   324| 				return
   325| 			}
   326| 			SuccessOutput(
   327| 				map[string]string{"Result": "Node deleted"},
   328| 				"Node deleted",
   329| 				output,
   330| 			)

# --- HUNK 3: Lines 340-575 ---
   340| 	Run: func(cmd *cobra.Command, args []string) {
   341| 		output, _ := cmd.Flags().GetString("output")
   342| 		identifier, err := cmd.Flags().GetUint64("identifier")
   343| 		if err != nil {
   344| 			ErrorOutput(
   345| 				err,
   346| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   347| 				output,
   348| 			)
   349| 			return
   350| 		}
   351| 		user, err := cmd.Flags().GetString("user")
   352| 		if err != nil {
   353| 			ErrorOutput(
   354| 				err,
   355| 				fmt.Sprintf("Error getting user: %s", err),
   356| 				output,
   357| 			)
   358| 			return
   359| 		}
   360| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   361| 		defer cancel()
   362| 		defer conn.Close()
   363| 		getRequest := &v1.GetMachineRequest{
   364| 			MachineId: identifier,
   365| 		}
   366| 		_, err = client.GetMachine(ctx, getRequest)
   367| 		if err != nil {
   368| 			ErrorOutput(
   369| 				err,
   370| 				fmt.Sprintf(
   371| 					"Error getting node: %s",
   372| 					status.Convert(err).Message(),
   373| 				),
   374| 				output,
   375| 			)
   376| 			return
   377| 		}
   378| 		moveRequest := &v1.MoveMachineRequest{
   379| 			MachineId: identifier,
   380| 			User:      user,
   381| 		}
   382| 		moveResponse, err := client.MoveMachine(ctx, moveRequest)
   383| 		if err != nil {
   384| 			ErrorOutput(
   385| 				err,
   386| 				fmt.Sprintf(
   387| 					"Error moving node: %s",
   388| 					status.Convert(err).Message(),
   389| 				),
   390| 				output,
   391| 			)
   392| 			return
   393| 		}
   394| 		SuccessOutput(moveResponse.Machine, "Node moved to another user", output)
   395| 	},
   396| }
   397| func nodesToPtables(
   398| 	currentUser string,
   399| 	showTags bool,
   400| 	machines []*v1.Machine,
   401| ) (pterm.TableData, error) {
   402| 	tableHeader := []string{
   403| 		"ID",
   404| 		"Hostname",
   405| 		"Name",
   406| 		"MachineKey",
   407| 		"NodeKey",
   408| 		"User",
   409| 		"IP addresses",
   410| 		"Ephemeral",
   411| 		"Last seen",
   412| 		"Expiration",
   413| 		"Online",
   414| 		"Expired",
   415| 	}
   416| 	if showTags {
   417| 		tableHeader = append(tableHeader, []string{
   418| 			"ForcedTags",
   419| 			"InvalidTags",
   420| 			"ValidTags",
   421| 		}...)
   422| 	}
   423| 	tableData := pterm.TableData{tableHeader}
   424| 	for _, machine := range machines {
   425| 		var ephemeral bool
   426| 		if machine.PreAuthKey != nil && machine.PreAuthKey.Ephemeral {
   427| 			ephemeral = true
   428| 		}
   429| 		var lastSeen time.Time
   430| 		var lastSeenTime string
   431| 		if machine.LastSeen != nil {
   432| 			lastSeen = machine.LastSeen.AsTime()
   433| 			lastSeenTime = lastSeen.Format("2006-01-02 15:04:05")
   434| 		}
   435| 		var expiry time.Time
   436| 		var expiryTime string
   437| 		if machine.Expiry != nil {
   438| 			expiry = machine.Expiry.AsTime()
   439| 			expiryTime = expiry.Format("2006-01-02 15:04:05")
   440| 		} else {
   441| 			expiryTime = "N/A"
   442| 		}
   443| 		var machineKey key.MachinePublic
   444| 		err := machineKey.UnmarshalText(
   445| 			[]byte(hscontrol.MachinePublicKeyEnsurePrefix(machine.MachineKey)),
   446| 		)
   447| 		if err != nil {
   448| 			machineKey = key.MachinePublic{}
   449| 		}
   450| 		var nodeKey key.NodePublic
   451| 		err = nodeKey.UnmarshalText(
   452| 			[]byte(hscontrol.NodePublicKeyEnsurePrefix(machine.NodeKey)),
   453| 		)
   454| 		if err != nil {
   455| 			return nil, err
   456| 		}
   457| 		var online string
   458| 		if machine.Online {
   459| 			online = pterm.LightGreen("online")
   460| 		} else {
   461| 			online = pterm.LightRed("offline")
   462| 		}
   463| 		var expired string
   464| 		if expiry.IsZero() || expiry.After(time.Now()) {
   465| 			expired = pterm.LightGreen("no")
   466| 		} else {
   467| 			expired = pterm.LightRed("yes")
   468| 		}
   469| 		var forcedTags string
   470| 		for _, tag := range machine.ForcedTags {
   471| 			forcedTags += "," + tag
   472| 		}
   473| 		forcedTags = strings.TrimLeft(forcedTags, ",")
   474| 		var invalidTags string
   475| 		for _, tag := range machine.InvalidTags {
   476| 			if !contains(machine.ForcedTags, tag) {
   477| 				invalidTags += "," + pterm.LightRed(tag)
   478| 			}
   479| 		}
   480| 		invalidTags = strings.TrimLeft(invalidTags, ",")
   481| 		var validTags string
   482| 		for _, tag := range machine.ValidTags {
   483| 			if !contains(machine.ForcedTags, tag) {
   484| 				validTags += "," + pterm.LightGreen(tag)
   485| 			}
   486| 		}
   487| 		validTags = strings.TrimLeft(validTags, ",")
   488| 		var user string
   489| 		if currentUser == "" || (currentUser == machine.User.Name) {
   490| 			user = pterm.LightMagenta(machine.User.Name)
   491| 		} else {
   492| 			user = pterm.LightYellow(machine.User.Name)
   493| 		}
   494| 		var IPV4Address string
   495| 		var IPV6Address string
   496| 		for _, addr := range machine.IpAddresses {
   497| 			if netip.MustParseAddr(addr).Is4() {
   498| 				IPV4Address = addr
   499| 			} else {
   500| 				IPV6Address = addr
   501| 			}
   502| 		}
   503| 		nodeData := []string{
   504| 			strconv.FormatUint(machine.Id, hscontrol.Base10),
   505| 			machine.Name,
   506| 			machine.GetGivenName(),
   507| 			machineKey.ShortString(),
   508| 			nodeKey.ShortString(),
   509| 			user,
   510| 			strings.Join([]string{IPV4Address, IPV6Address}, ", "),
   511| 			strconv.FormatBool(ephemeral),
   512| 			lastSeenTime,
   513| 			expiryTime,
   514| 			online,
   515| 			expired,
   516| 		}
   517| 		if showTags {
   518| 			nodeData = append(nodeData, []string{forcedTags, invalidTags, validTags}...)
   519| 		}
   520| 		tableData = append(
   521| 			tableData,
   522| 			nodeData,
   523| 		)
   524| 	}
   525| 	return tableData, nil
   526| }
   527| var tagCmd = &cobra.Command{
   528| 	Use:     "tag",
   529| 	Short:   "Manage the tags of a node",
   530| 	Aliases: []string{"tags", "t"},
   531| 	Run: func(cmd *cobra.Command, args []string) {
   532| 		output, _ := cmd.Flags().GetString("output")
   533| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   534| 		defer cancel()
   535| 		defer conn.Close()
   536| 		identifier, err := cmd.Flags().GetUint64("identifier")
   537| 		if err != nil {
   538| 			ErrorOutput(
   539| 				err,
   540| 				fmt.Sprintf("Error converting ID to integer: %s", err),
   541| 				output,
   542| 			)
   543| 			return
   544| 		}
   545| 		tagsToSet, err := cmd.Flags().GetStringSlice("tags")
   546| 		if err != nil {
   547| 			ErrorOutput(
   548| 				err,
   549| 				fmt.Sprintf("Error retrieving list of tags to add to machine, %v", err),
   550| 				output,
   551| 			)
   552| 			return
   553| 		}
   554| 		request := &v1.SetTagsRequest{
   555| 			MachineId: identifier,
   556| 			Tags:      tagsToSet,
   557| 		}
   558| 		resp, err := client.SetTags(ctx, request)
   559| 		if err != nil {
   560| 			ErrorOutput(
   561| 				err,
   562| 				fmt.Sprintf("Error while sending tags to headscale: %s", err),
   563| 				output,
   564| 			)
   565| 			return
   566| 		}
   567| 		if resp != nil {
   568| 			SuccessOutput(
   569| 				resp.GetMachine(),
   570| 				"Machine updated",
   571| 				output,
   572| 			)
   573| 		}
   574| 	},
   575| }


# ====================================================================
# FILE: cmd/headscale/cli/preauthkeys.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 34-215 ---
    34| 		Bool("ephemeral", false, "Preauthkey for ephemeral nodes")
    35| 	createPreAuthKeyCmd.Flags().
    36| 		StringP("expiration", "e", DefaultPreAuthKeyExpiry, "Human-readable expiration of the key (e.g. 30m, 24h)")
    37| 	createPreAuthKeyCmd.Flags().
    38| 		StringSlice("tags", []string{}, "Tags to automatically assign to node")
    39| }
    40| var preauthkeysCmd = &cobra.Command{
    41| 	Use:     "preauthkeys",
    42| 	Short:   "Handle the preauthkeys in Headscale",
    43| 	Aliases: []string{"preauthkey", "authkey", "pre"},
    44| }
    45| var listPreAuthKeys = &cobra.Command{
    46| 	Use:     "list",
    47| 	Short:   "List the preauthkeys for this user",
    48| 	Aliases: []string{"ls", "show"},
    49| 	Run: func(cmd *cobra.Command, args []string) {
    50| 		output, _ := cmd.Flags().GetString("output")
    51| 		user, err := cmd.Flags().GetString("user")
    52| 		if err != nil {
    53| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
    54| 			return
    55| 		}
    56| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    57| 		defer cancel()
    58| 		defer conn.Close()
    59| 		request := &v1.ListPreAuthKeysRequest{
    60| 			User: user,
    61| 		}
    62| 		response, err := client.ListPreAuthKeys(ctx, request)
    63| 		if err != nil {
    64| 			ErrorOutput(
    65| 				err,
    66| 				fmt.Sprintf("Error getting the list of keys: %s", err),
    67| 				output,
    68| 			)
    69| 			return
    70| 		}
    71| 		if output != "" {
    72| 			SuccessOutput(response.PreAuthKeys, "", output)
    73| 			return
    74| 		}
    75| 		tableData := pterm.TableData{
    76| 			{
    77| 				"ID",
    78| 				"Key",
    79| 				"Reusable",
    80| 				"Ephemeral",
    81| 				"Used",
    82| 				"Expiration",
    83| 				"Created",
    84| 				"Tags",
    85| 			},
    86| 		}
    87| 		for _, key := range response.PreAuthKeys {
    88| 			expiration := "-"
    89| 			if key.GetExpiration() != nil {
    90| 				expiration = ColourTime(key.Expiration.AsTime())
    91| 			}
    92| 			var reusable string
    93| 			if key.GetEphemeral() {
    94| 				reusable = "N/A"
    95| 			} else {
    96| 				reusable = fmt.Sprintf("%v", key.GetReusable())
    97| 			}
    98| 			aclTags := ""
    99| 			for _, tag := range key.AclTags {
   100| 				aclTags += "," + tag
   101| 			}
   102| 			aclTags = strings.TrimLeft(aclTags, ",")
   103| 			tableData = append(tableData, []string{
   104| 				key.GetId(),
   105| 				key.GetKey(),
   106| 				reusable,
   107| 				strconv.FormatBool(key.GetEphemeral()),
   108| 				strconv.FormatBool(key.GetUsed()),
   109| 				expiration,
   110| 				key.GetCreatedAt().AsTime().Format("2006-01-02 15:04:05"),
   111| 				aclTags,
   112| 			})
   113| 		}
   114| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   115| 		if err != nil {
   116| 			ErrorOutput(
   117| 				err,
   118| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   119| 				output,
   120| 			)
   121| 			return
   122| 		}
   123| 	},
   124| }
   125| var createPreAuthKeyCmd = &cobra.Command{
   126| 	Use:     "create",
   127| 	Short:   "Creates a new preauthkey in the specified user",
   128| 	Aliases: []string{"c", "new"},
   129| 	Run: func(cmd *cobra.Command, args []string) {
   130| 		output, _ := cmd.Flags().GetString("output")
   131| 		user, err := cmd.Flags().GetString("user")
   132| 		if err != nil {
   133| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   134| 			return
   135| 		}
   136| 		reusable, _ := cmd.Flags().GetBool("reusable")
   137| 		ephemeral, _ := cmd.Flags().GetBool("ephemeral")
   138| 		tags, _ := cmd.Flags().GetStringSlice("tags")
   139| 		log.Trace().
   140| 			Bool("reusable", reusable).
   141| 			Bool("ephemeral", ephemeral).
   142| 			Str("user", user).
   143| 			Msg("Preparing to create preauthkey")
   144| 		request := &v1.CreatePreAuthKeyRequest{
   145| 			User:      user,
   146| 			Reusable:  reusable,
   147| 			Ephemeral: ephemeral,
   148| 			AclTags:   tags,
   149| 		}
   150| 		durationStr, _ := cmd.Flags().GetString("expiration")
   151| 		duration, err := model.ParseDuration(durationStr)
   152| 		if err != nil {
   153| 			ErrorOutput(
   154| 				err,
   155| 				fmt.Sprintf("Could not parse duration: %s\n", err),
   156| 				output,
   157| 			)
   158| 			return
   159| 		}
   160| 		expiration := time.Now().UTC().Add(time.Duration(duration))
   161| 		log.Trace().
   162| 			Dur("expiration", time.Duration(duration)).
   163| 			Msg("expiration has been set")
   164| 		request.Expiration = timestamppb.New(expiration)
   165| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   166| 		defer cancel()
   167| 		defer conn.Close()
   168| 		response, err := client.CreatePreAuthKey(ctx, request)
   169| 		if err != nil {
   170| 			ErrorOutput(
   171| 				err,
   172| 				fmt.Sprintf("Cannot create Pre Auth Key: %s\n", err),
   173| 				output,
   174| 			)
   175| 			return
   176| 		}
   177| 		SuccessOutput(response.PreAuthKey, response.PreAuthKey.Key, output)
   178| 	},
   179| }
   180| var expirePreAuthKeyCmd = &cobra.Command{
   181| 	Use:     "expire KEY",
   182| 	Short:   "Expire a preauthkey",
   183| 	Aliases: []string{"revoke", "exp", "e"},
   184| 	Args: func(cmd *cobra.Command, args []string) error {
   185| 		if len(args) < 1 {
   186| 			return errMissingParameter
   187| 		}
   188| 		return nil
   189| 	},
   190| 	Run: func(cmd *cobra.Command, args []string) {
   191| 		output, _ := cmd.Flags().GetString("output")
   192| 		user, err := cmd.Flags().GetString("user")
   193| 		if err != nil {
   194| 			ErrorOutput(err, fmt.Sprintf("Error getting user: %s", err), output)
   195| 			return
   196| 		}
   197| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   198| 		defer cancel()
   199| 		defer conn.Close()
   200| 		request := &v1.ExpirePreAuthKeyRequest{
   201| 			User: user,
   202| 			Key:  args[0],
   203| 		}
   204| 		response, err := client.ExpirePreAuthKey(ctx, request)
   205| 		if err != nil {
   206| 			ErrorOutput(
   207| 				err,
   208| 				fmt.Sprintf("Cannot expire Pre Auth Key: %s\n", err),
   209| 				output,
   210| 			)
   211| 			return
   212| 		}
   213| 		SuccessOutput(response, "Key expired", output)
   214| 	},
   215| }


# ====================================================================
# FILE: cmd/headscale/cli/root.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"os"
     5| 	"runtime"
     6| 	"github.com/juanfont/headscale/hscontrol"
     7| 	"github.com/rs/zerolog"
     8| 	"github.com/rs/zerolog/log"
     9| 	"github.com/spf13/cobra"
    10| 	"github.com/tcnksm/go-latest"
    11| )
    12| const (
    13| 	deprecateNamespaceMessage = "use --user"
    14| )
    15| var cfgFile string = ""
    16| func init() {
    17| 	if len(os.Args) > 1 &&
    18| 		(os.Args[1] == "version" || os.Args[1] == "mockoidc" || os.Args[1] == "completion") {
    19| 		return
    20| 	}
    21| 	cobra.OnInitialize(initConfig)
    22| 	rootCmd.PersistentFlags().
    23| 		StringVarP(&cfgFile, "config", "c", "", "config file (default is /etc/headscale/config.yaml)")
    24| 	rootCmd.PersistentFlags().
    25| 		StringP("output", "o", "", "Output format. Empty for human-readable, 'json', 'json-line' or 'yaml'")
    26| 	rootCmd.PersistentFlags().
    27| 		Bool("force", false, "Disable prompts and forces the execution")
    28| }
    29| func initConfig() {
    30| 	if cfgFile == "" {
    31| 		cfgFile = os.Getenv("HEADSCALE_CONFIG")
    32| 	}
    33| 	if cfgFile != "" {
    34| 		err := hscontrol.LoadConfig(cfgFile, true)
    35| 		if err != nil {
    36| 			log.Fatal().Caller().Err(err).Msgf("Error loading config file %s", cfgFile)
    37| 		}
    38| 	} else {
    39| 		err := hscontrol.LoadConfig("", false)
    40| 		if err != nil {
    41| 			log.Fatal().Caller().Err(err).Msgf("Error loading config")
    42| 		}
    43| 	}
    44| 	cfg, err := hscontrol.GetHeadscaleConfig()
    45| 	if err != nil {
    46| 		log.Fatal().Caller().Err(err)
    47| 	}
    48| 	machineOutput := HasMachineOutputFlag()
    49| 	zerolog.SetGlobalLevel(cfg.Log.Level)
    50| 	if machineOutput {
    51| 		zerolog.SetGlobalLevel(zerolog.Disabled)
    52| 	}
    53| 	if cfg.Log.Format == hscontrol.JSONLogFormat {
    54| 		log.Logger = log.Output(os.Stdout)
    55| 	}
    56| 	if !cfg.DisableUpdateCheck && !machineOutput {
    57| 		if (runtime.GOOS == "linux" || runtime.GOOS == "darwin") &&
    58| 			Version != "dev" {
    59| 			githubTag := &latest.GithubTag{
    60| 				Owner:      "juanfont",
    61| 				Repository: "headscale",
    62| 			}
    63| 			res, err := latest.Check(githubTag, Version)
    64| 			if err == nil && res.Outdated {
    65| 				fmt.Printf(
    66| 					"An updated version of Headscale has been found (%s vs. your current %s). Check it out https://github.com/juanfont/headscale/releases\n",
    67| 					res.Current,
    68| 					Version,
    69| 				)
    70| 			}
    71| 		}
    72| 	}
    73| }
    74| var rootCmd = &cobra.Command{
    75| 	Use:   "headscale",
    76| 	Short: "headscale - a Tailscale control server",
    77| 	Long: `
    78| headscale is an open source implementation of the Tailscale control server
    79| https://github.com/juanfont/headscale`,
    80| }
    81| func Execute() {
    82| 	if err := rootCmd.Execute(); err != nil {
    83| 		fmt.Fprintln(os.Stderr, err)
    84| 		os.Exit(1)
    85| 	}


# ====================================================================
# FILE: cmd/headscale/cli/routes.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	"log"
     5| 	"net/netip"
     6| 	"strconv"
     7| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     8| 	"github.com/juanfont/headscale/hscontrol"
     9| 	"github.com/pterm/pterm"
    10| 	"github.com/spf13/cobra"
    11| 	"google.golang.org/grpc/status"
    12| )
    13| const (
    14| 	Base10 = 10
    15| )
    16| func init() {
    17| 	rootCmd.AddCommand(routesCmd)
    18| 	listRoutesCmd.Flags().Uint64P("identifier", "i", 0, "Node identifier (ID)")
    19| 	routesCmd.AddCommand(listRoutesCmd)
    20| 	enableRouteCmd.Flags().Uint64P("route", "r", 0, "Route identifier (ID)")
    21| 	err := enableRouteCmd.MarkFlagRequired("route")
    22| 	if err != nil {
    23| 		log.Fatalf(err.Error())
    24| 	}
    25| 	routesCmd.AddCommand(enableRouteCmd)
    26| 	disableRouteCmd.Flags().Uint64P("route", "r", 0, "Route identifier (ID)")
    27| 	err = disableRouteCmd.MarkFlagRequired("route")
    28| 	if err != nil {

# --- HUNK 2: Lines 37-242 ---
    37| 	routesCmd.AddCommand(deleteRouteCmd)
    38| }
    39| var routesCmd = &cobra.Command{
    40| 	Use:     "routes",
    41| 	Short:   "Manage the routes of Headscale",
    42| 	Aliases: []string{"r", "route"},
    43| }
    44| var listRoutesCmd = &cobra.Command{
    45| 	Use:     "list",
    46| 	Short:   "List all routes",
    47| 	Aliases: []string{"ls", "show"},
    48| 	Run: func(cmd *cobra.Command, args []string) {
    49| 		output, _ := cmd.Flags().GetString("output")
    50| 		machineID, err := cmd.Flags().GetUint64("identifier")
    51| 		if err != nil {
    52| 			ErrorOutput(
    53| 				err,
    54| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
    55| 				output,
    56| 			)
    57| 			return
    58| 		}
    59| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    60| 		defer cancel()
    61| 		defer conn.Close()
    62| 		var routes []*v1.Route
    63| 		if machineID == 0 {
    64| 			response, err := client.GetRoutes(ctx, &v1.GetRoutesRequest{})
    65| 			if err != nil {
    66| 				ErrorOutput(
    67| 					err,
    68| 					fmt.Sprintf("Cannot get nodes: %s", status.Convert(err).Message()),
    69| 					output,
    70| 				)
    71| 				return
    72| 			}
    73| 			if output != "" {
    74| 				SuccessOutput(response.Routes, "", output)
    75| 				return
    76| 			}
    77| 			routes = response.Routes
    78| 		} else {
    79| 			response, err := client.GetMachineRoutes(ctx, &v1.GetMachineRoutesRequest{
    80| 				MachineId: machineID,
    81| 			})
    82| 			if err != nil {
    83| 				ErrorOutput(
    84| 					err,
    85| 					fmt.Sprintf("Cannot get routes for machine %d: %s", machineID, status.Convert(err).Message()),
    86| 					output,
    87| 				)
    88| 				return
    89| 			}
    90| 			if output != "" {
    91| 				SuccessOutput(response.Routes, "", output)
    92| 				return
    93| 			}
    94| 			routes = response.Routes
    95| 		}
    96| 		tableData := routesToPtables(routes)
    97| 		if err != nil {
    98| 			ErrorOutput(err, fmt.Sprintf("Error converting to table: %s", err), output)
    99| 			return
   100| 		}
   101| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   102| 		if err != nil {
   103| 			ErrorOutput(
   104| 				err,
   105| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   106| 				output,
   107| 			)
   108| 			return
   109| 		}
   110| 	},
   111| }
   112| var enableRouteCmd = &cobra.Command{
   113| 	Use:   "enable",
   114| 	Short: "Set a route as enabled",
   115| 	Long:  `This command will make as enabled a given route.`,
   116| 	Run: func(cmd *cobra.Command, args []string) {
   117| 		output, _ := cmd.Flags().GetString("output")
   118| 		routeID, err := cmd.Flags().GetUint64("route")
   119| 		if err != nil {
   120| 			ErrorOutput(
   121| 				err,
   122| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   123| 				output,
   124| 			)
   125| 			return
   126| 		}
   127| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   128| 		defer cancel()
   129| 		defer conn.Close()
   130| 		response, err := client.EnableRoute(ctx, &v1.EnableRouteRequest{
   131| 			RouteId: routeID,
   132| 		})
   133| 		if err != nil {
   134| 			ErrorOutput(
   135| 				err,
   136| 				fmt.Sprintf("Cannot enable route %d: %s", routeID, status.Convert(err).Message()),
   137| 				output,
   138| 			)
   139| 			return
   140| 		}
   141| 		if output != "" {
   142| 			SuccessOutput(response, "", output)
   143| 			return
   144| 		}
   145| 	},
   146| }
   147| var disableRouteCmd = &cobra.Command{
   148| 	Use:   "disable",
   149| 	Short: "Set as disabled a given route",
   150| 	Long:  `This command will make as disabled a given route.`,
   151| 	Run: func(cmd *cobra.Command, args []string) {
   152| 		output, _ := cmd.Flags().GetString("output")
   153| 		routeID, err := cmd.Flags().GetUint64("route")
   154| 		if err != nil {
   155| 			ErrorOutput(
   156| 				err,
   157| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   158| 				output,
   159| 			)
   160| 			return
   161| 		}
   162| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   163| 		defer cancel()
   164| 		defer conn.Close()
   165| 		response, err := client.DisableRoute(ctx, &v1.DisableRouteRequest{
   166| 			RouteId: routeID,
   167| 		})
   168| 		if err != nil {
   169| 			ErrorOutput(
   170| 				err,
   171| 				fmt.Sprintf("Cannot disable route %d: %s", routeID, status.Convert(err).Message()),
   172| 				output,
   173| 			)
   174| 			return
   175| 		}
   176| 		if output != "" {
   177| 			SuccessOutput(response, "", output)
   178| 			return
   179| 		}
   180| 	},
   181| }
   182| var deleteRouteCmd = &cobra.Command{
   183| 	Use:   "delete",
   184| 	Short: "Delete a given route",
   185| 	Long:  `This command will delete a given route.`,
   186| 	Run: func(cmd *cobra.Command, args []string) {
   187| 		output, _ := cmd.Flags().GetString("output")
   188| 		routeID, err := cmd.Flags().GetUint64("route")
   189| 		if err != nil {
   190| 			ErrorOutput(
   191| 				err,
   192| 				fmt.Sprintf("Error getting machine id from flag: %s", err),
   193| 				output,
   194| 			)
   195| 			return
   196| 		}
   197| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   198| 		defer cancel()
   199| 		defer conn.Close()
   200| 		response, err := client.DeleteRoute(ctx, &v1.DeleteRouteRequest{
   201| 			RouteId: routeID,
   202| 		})
   203| 		if err != nil {
   204| 			ErrorOutput(
   205| 				err,
   206| 				fmt.Sprintf("Cannot delete route %d: %s", routeID, status.Convert(err).Message()),
   207| 				output,
   208| 			)
   209| 			return
   210| 		}
   211| 		if output != "" {
   212| 			SuccessOutput(response, "", output)
   213| 			return
   214| 		}
   215| 	},
   216| }
   217| func routesToPtables(routes []*v1.Route) pterm.TableData {
   218| 	tableData := pterm.TableData{{"ID", "Machine", "Prefix", "Advertised", "Enabled", "Primary"}}
   219| 	for _, route := range routes {
   220| 		var isPrimaryStr string
   221| 		prefix, err := netip.ParsePrefix(route.Prefix)
   222| 		if err != nil {
   223| 			log.Printf("Error parsing prefix %s: %s", route.Prefix, err)
   224| 			continue
   225| 		}
   226| 		if prefix == hscontrol.ExitRouteV4 || prefix == hscontrol.ExitRouteV6 {
   227| 			isPrimaryStr = "-"
   228| 		} else {
   229| 			isPrimaryStr = strconv.FormatBool(route.IsPrimary)
   230| 		}
   231| 		tableData = append(tableData,
   232| 			[]string{
   233| 				strconv.FormatUint(route.Id, Base10),
   234| 				route.Machine.GivenName,
   235| 				route.Prefix,
   236| 				strconv.FormatBool(route.Advertised),
   237| 				strconv.FormatBool(route.Enabled),
   238| 				isPrimaryStr,
   239| 			})
   240| 	}
   241| 	return tableData
   242| }


# ====================================================================
# FILE: cmd/headscale/cli/users.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-202 ---
     1| package cli
     2| import (
     3| 	"fmt"
     4| 	survey "github.com/AlecAivazis/survey/v2"
     5| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     6| 	"github.com/juanfont/headscale/hscontrol"
     7| 	"github.com/pterm/pterm"
     8| 	"github.com/rs/zerolog/log"
     9| 	"github.com/spf13/cobra"
    10| 	"google.golang.org/grpc/status"
    11| )
    12| func init() {
    13| 	rootCmd.AddCommand(userCmd)
    14| 	userCmd.AddCommand(createUserCmd)
    15| 	userCmd.AddCommand(listUsersCmd)
    16| 	userCmd.AddCommand(destroyUserCmd)
    17| 	userCmd.AddCommand(renameUserCmd)
    18| }
    19| const (
    20| 	errMissingParameter = hscontrol.Error("missing parameters")
    21| )
    22| var userCmd = &cobra.Command{
    23| 	Use:     "users",
    24| 	Short:   "Manage the users of Headscale",
    25| 	Aliases: []string{"user", "namespace", "namespaces", "ns"},
    26| }
    27| var createUserCmd = &cobra.Command{
    28| 	Use:     "create NAME",
    29| 	Short:   "Creates a new user",
    30| 	Aliases: []string{"c", "new"},
    31| 	Args: func(cmd *cobra.Command, args []string) error {
    32| 		if len(args) < 1 {
    33| 			return errMissingParameter
    34| 		}
    35| 		return nil
    36| 	},
    37| 	Run: func(cmd *cobra.Command, args []string) {
    38| 		output, _ := cmd.Flags().GetString("output")
    39| 		userName := args[0]
    40| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    41| 		defer cancel()
    42| 		defer conn.Close()
    43| 		log.Trace().Interface("client", client).Msg("Obtained gRPC client")
    44| 		request := &v1.CreateUserRequest{Name: userName}
    45| 		log.Trace().Interface("request", request).Msg("Sending CreateUser request")
    46| 		response, err := client.CreateUser(ctx, request)
    47| 		if err != nil {
    48| 			ErrorOutput(
    49| 				err,
    50| 				fmt.Sprintf(
    51| 					"Cannot create user: %s",
    52| 					status.Convert(err).Message(),
    53| 				),
    54| 				output,
    55| 			)
    56| 			return
    57| 		}
    58| 		SuccessOutput(response.User, "User created", output)
    59| 	},
    60| }
    61| var destroyUserCmd = &cobra.Command{
    62| 	Use:     "destroy NAME",
    63| 	Short:   "Destroys a user",
    64| 	Aliases: []string{"delete"},
    65| 	Args: func(cmd *cobra.Command, args []string) error {
    66| 		if len(args) < 1 {
    67| 			return errMissingParameter
    68| 		}
    69| 		return nil
    70| 	},
    71| 	Run: func(cmd *cobra.Command, args []string) {
    72| 		output, _ := cmd.Flags().GetString("output")
    73| 		userName := args[0]
    74| 		request := &v1.GetUserRequest{
    75| 			Name: userName,
    76| 		}
    77| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
    78| 		defer cancel()
    79| 		defer conn.Close()
    80| 		_, err := client.GetUser(ctx, request)
    81| 		if err != nil {
    82| 			ErrorOutput(
    83| 				err,
    84| 				fmt.Sprintf("Error: %s", status.Convert(err).Message()),
    85| 				output,
    86| 			)
    87| 			return
    88| 		}
    89| 		confirm := false
    90| 		force, _ := cmd.Flags().GetBool("force")
    91| 		if !force {
    92| 			prompt := &survey.Confirm{
    93| 				Message: fmt.Sprintf(
    94| 					"Do you want to remove the user '%s' and any associated preauthkeys?",
    95| 					userName,
    96| 				),
    97| 			}
    98| 			err := survey.AskOne(prompt, &confirm)
    99| 			if err != nil {
   100| 				return
   101| 			}
   102| 		}
   103| 		if confirm || force {
   104| 			request := &v1.DeleteUserRequest{Name: userName}
   105| 			response, err := client.DeleteUser(ctx, request)
   106| 			if err != nil {
   107| 				ErrorOutput(
   108| 					err,
   109| 					fmt.Sprintf(
   110| 						"Cannot destroy user: %s",
   111| 						status.Convert(err).Message(),
   112| 					),
   113| 					output,
   114| 				)
   115| 				return
   116| 			}
   117| 			SuccessOutput(response, "User destroyed", output)
   118| 		} else {
   119| 			SuccessOutput(map[string]string{"Result": "User not destroyed"}, "User not destroyed", output)
   120| 		}
   121| 	},
   122| }
   123| var listUsersCmd = &cobra.Command{
   124| 	Use:     "list",
   125| 	Short:   "List all the users",
   126| 	Aliases: []string{"ls", "show"},
   127| 	Run: func(cmd *cobra.Command, args []string) {
   128| 		output, _ := cmd.Flags().GetString("output")
   129| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   130| 		defer cancel()
   131| 		defer conn.Close()
   132| 		request := &v1.ListUsersRequest{}
   133| 		response, err := client.ListUsers(ctx, request)
   134| 		if err != nil {
   135| 			ErrorOutput(
   136| 				err,
   137| 				fmt.Sprintf("Cannot get users: %s", status.Convert(err).Message()),
   138| 				output,
   139| 			)
   140| 			return
   141| 		}
   142| 		if output != "" {
   143| 			SuccessOutput(response.Users, "", output)
   144| 			return
   145| 		}
   146| 		tableData := pterm.TableData{{"ID", "Name", "Created"}}
   147| 		for _, user := range response.GetUsers() {
   148| 			tableData = append(
   149| 				tableData,
   150| 				[]string{
   151| 					user.GetId(),
   152| 					user.GetName(),
   153| 					user.GetCreatedAt().AsTime().Format("2006-01-02 15:04:05"),
   154| 				},
   155| 			)
   156| 		}
   157| 		err = pterm.DefaultTable.WithHasHeader().WithData(tableData).Render()
   158| 		if err != nil {
   159| 			ErrorOutput(
   160| 				err,
   161| 				fmt.Sprintf("Failed to render pterm table: %s", err),
   162| 				output,
   163| 			)
   164| 			return
   165| 		}
   166| 	},
   167| }
   168| var renameUserCmd = &cobra.Command{
   169| 	Use:     "rename OLD_NAME NEW_NAME",
   170| 	Short:   "Renames a user",
   171| 	Aliases: []string{"mv"},
   172| 	Args: func(cmd *cobra.Command, args []string) error {
   173| 		expectedArguments := 2
   174| 		if len(args) < expectedArguments {
   175| 			return errMissingParameter
   176| 		}
   177| 		return nil
   178| 	},
   179| 	Run: func(cmd *cobra.Command, args []string) {
   180| 		output, _ := cmd.Flags().GetString("output")
   181| 		ctx, client, conn, cancel := getHeadscaleCLIClient()
   182| 		defer cancel()
   183| 		defer conn.Close()
   184| 		request := &v1.RenameUserRequest{
   185| 			OldName: args[0],
   186| 			NewName: args[1],
   187| 		}
   188| 		response, err := client.RenameUser(ctx, request)
   189| 		if err != nil {
   190| 			ErrorOutput(
   191| 				err,
   192| 				fmt.Sprintf(
   193| 					"Cannot rename user: %s",
   194| 					status.Convert(err).Message(),
   195| 				),
   196| 				output,
   197| 			)
   198| 			return
   199| 		}
   200| 		SuccessOutput(response.User, "User renamed", output)
   201| 	},
   202| }


# ====================================================================
# FILE: cmd/headscale/cli/utils.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-174 ---
     1| package cli
     2| import (
     3| 	"context"
     4| 	"crypto/tls"
     5| 	"encoding/json"
     6| 	"fmt"
     7| 	"os"
     8| 	"reflect"
     9| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    10| 	"github.com/juanfont/headscale/hscontrol"
    11| 	"github.com/rs/zerolog/log"
    12| 	"google.golang.org/grpc"
    13| 	"google.golang.org/grpc/credentials"
    14| 	"google.golang.org/grpc/credentials/insecure"
    15| 	"gopkg.in/yaml.v3"
    16| )
    17| const (
    18| 	HeadscaleDateTimeFormat = "2006-01-02 15:04:05"
    19| 	SocketWritePermissions  = 0o666
    20| )
    21| func getHeadscaleApp() (*hscontrol.Headscale, error) {
    22| 	cfg, err := hscontrol.GetHeadscaleConfig()
    23| 	if err != nil {
    24| 		return nil, fmt.Errorf(
    25| 			"failed to load configuration while creating headscale instance: %w",
    26| 			err,
    27| 		)
    28| 	}
    29| 	app, err := hscontrol.NewHeadscale(cfg)
    30| 	if err != nil {
    31| 		return nil, err
    32| 	}
    33| 	if cfg.ACL.PolicyPath != "" {
    34| 		aclPath := hscontrol.AbsolutePathFromConfigPath(cfg.ACL.PolicyPath)
    35| 		err = app.LoadACLPolicyFromPath(aclPath)
    36| 		if err != nil {
    37| 			log.Fatal().
    38| 				Str("path", aclPath).
    39| 				Err(err).
    40| 				Msg("Could not load the ACL policy")
    41| 		}
    42| 	}
    43| 	return app, nil
    44| }
    45| func getHeadscaleCLIClient() (context.Context, v1.HeadscaleServiceClient, *grpc.ClientConn, context.CancelFunc) {
    46| 	cfg, err := hscontrol.GetHeadscaleConfig()
    47| 	if err != nil {
    48| 		log.Fatal().
    49| 			Err(err).
    50| 			Caller().
    51| 			Msgf("Failed to load configuration")
    52| 		os.Exit(-1) // we get here if logging is suppressed (i.e., json output)
    53| 	}
    54| 	log.Debug().
    55| 		Dur("timeout", cfg.CLI.Timeout).
    56| 		Msgf("Setting timeout")
    57| 	ctx, cancel := context.WithTimeout(context.Background(), cfg.CLI.Timeout)
    58| 	grpcOptions := []grpc.DialOption{
    59| 		grpc.WithBlock(),
    60| 	}
    61| 	address := cfg.CLI.Address
    62| 	if address == "" {
    63| 		log.Debug().
    64| 			Str("socket", cfg.UnixSocket).
    65| 			Msgf("HEADSCALE_CLI_ADDRESS environment is not set, connecting to unix socket.")
    66| 		address = cfg.UnixSocket
    67| 		socket, err := os.OpenFile(cfg.UnixSocket, os.O_WRONLY, SocketWritePermissions) //nolint
    68| 		if err != nil {
    69| 			if os.IsPermission(err) {
    70| 				log.Fatal().
    71| 					Err(err).
    72| 					Str("socket", cfg.UnixSocket).
    73| 					Msgf("Unable to read/write to headscale socket, do you have the correct permissions?")
    74| 			}
    75| 		}
    76| 		socket.Close()
    77| 		grpcOptions = append(
    78| 			grpcOptions,
    79| 			grpc.WithTransportCredentials(insecure.NewCredentials()),
    80| 			grpc.WithContextDialer(hscontrol.GrpcSocketDialer),
    81| 		)
    82| 	} else {
    83| 		apiKey := cfg.CLI.APIKey
    84| 		if apiKey == "" {
    85| 			log.Fatal().Caller().Msgf("HEADSCALE_CLI_API_KEY environment variable needs to be set.")
    86| 		}
    87| 		grpcOptions = append(grpcOptions,
    88| 			grpc.WithPerRPCCredentials(tokenAuth{
    89| 				token: apiKey,
    90| 			}),
    91| 		)
    92| 		if cfg.CLI.Insecure {
    93| 			tlsConfig := &tls.Config{
    94| 				InsecureSkipVerify: true,
    95| 			}
    96| 			grpcOptions = append(grpcOptions,
    97| 				grpc.WithTransportCredentials(credentials.NewTLS(tlsConfig)),
    98| 			)
    99| 		} else {
   100| 			grpcOptions = append(grpcOptions,
   101| 				grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(nil, "")),
   102| 			)
   103| 		}
   104| 	}
   105| 	log.Trace().Caller().Str("address", address).Msg("Connecting via gRPC")
   106| 	conn, err := grpc.DialContext(ctx, address, grpcOptions...)
   107| 	if err != nil {
   108| 		log.Fatal().Caller().Err(err).Msgf("Could not connect: %v", err)
   109| 		os.Exit(-1) // we get here if logging is suppressed (i.e., json output)
   110| 	}
   111| 	client := v1.NewHeadscaleServiceClient(conn)
   112| 	return ctx, client, conn, cancel
   113| }
   114| func SuccessOutput(result interface{}, override string, outputFormat string) {
   115| 	var jsonBytes []byte
   116| 	var err error
   117| 	switch outputFormat {
   118| 	case "json":
   119| 		jsonBytes, err = json.MarshalIndent(result, "", "\t")
   120| 		if err != nil {
   121| 			log.Fatal().Err(err)
   122| 		}
   123| 	case "json-line":
   124| 		jsonBytes, err = json.Marshal(result)
   125| 		if err != nil {
   126| 			log.Fatal().Err(err)
   127| 		}
   128| 	case "yaml":
   129| 		jsonBytes, err = yaml.Marshal(result)
   130| 		if err != nil {
   131| 			log.Fatal().Err(err)
   132| 		}
   133| 	default:
   134| 		fmt.Println(override)
   135| 		return
   136| 	}
   137| 	fmt.Println(string(jsonBytes))
   138| }
   139| func ErrorOutput(errResult error, override string, outputFormat string) {
   140| 	type errOutput struct {
   141| 		Error string `json:"error"`
   142| 	}
   143| 	SuccessOutput(errOutput{errResult.Error()}, override, outputFormat)
   144| }
   145| func HasMachineOutputFlag() bool {
   146| 	for _, arg := range os.Args {
   147| 		if arg == "json" || arg == "json-line" || arg == "yaml" {
   148| 			return true
   149| 		}
   150| 	}
   151| 	return false
   152| }
   153| type tokenAuth struct {
   154| 	token string
   155| }
   156| func (t tokenAuth) GetRequestMetadata(
   157| 	ctx context.Context,
   158| 	in ...string,
   159| ) (map[string]string, error) {
   160| 	return map[string]string{
   161| 		"authorization": "Bearer " + t.token,
   162| 	}, nil
   163| }
   164| func (tokenAuth) RequireTransportSecurity() bool {
   165| 	return true
   166| }
   167| func contains[T string](ts []T, t T) bool {
   168| 	for _, v := range ts {
   169| 		if reflect.DeepEqual(v, t) {
   170| 			return true
   171| 		}
   172| 	}
   173| 	return false
   174| }


# ====================================================================
# FILE: cmd/headscale/headscale.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-46 ---
     1| package main
     2| import (
     3| 	"os"
     4| 	"time"
     5| 	"github.com/efekarakus/termcolor"
     6| 	"github.com/juanfont/headscale/cmd/headscale/cli"
     7| 	"github.com/pkg/profile"
     8| 	"github.com/rs/zerolog"
     9| 	"github.com/rs/zerolog/log"
    10| )
    11| func main() {
    12| 	if _, enableProfile := os.LookupEnv("HEADSCALE_PROFILING_ENABLED"); enableProfile {
    13| 		if profilePath, ok := os.LookupEnv("HEADSCALE_PROFILING_PATH"); ok {
    14| 			err := os.MkdirAll(profilePath, os.ModePerm)
    15| 			if err != nil {
    16| 				log.Fatal().Err(err).Msg("failed to create profiling directory")
    17| 			}
    18| 			defer profile.Start(profile.ProfilePath(profilePath)).Stop()
    19| 		} else {
    20| 			defer profile.Start().Stop()
    21| 		}
    22| 	}
    23| 	var colors bool
    24| 	switch l := termcolor.SupportLevel(os.Stderr); l {
    25| 	case termcolor.Level16M:
    26| 		colors = true
    27| 	case termcolor.Level256:
    28| 		colors = true
    29| 	case termcolor.LevelBasic:
    30| 		colors = true
    31| 	case termcolor.LevelNone:
    32| 		colors = false
    33| 	default:
    34| 		colors = false
    35| 	}
    36| 	if _, noColorIsSet := os.LookupEnv("NO_COLOR"); noColorIsSet {
    37| 		colors = false
    38| 	}
    39| 	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
    40| 	log.Logger = log.Output(zerolog.ConsoleWriter{
    41| 		Out:        os.Stdout,
    42| 		TimeFormat: time.RFC3339,
    43| 		NoColor:    !colors,
    44| 	})
    45| 	cli.Execute()
    46| }


# ====================================================================
# FILE: gen/go/headscale/v1/apikey.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 272-479 ---
   272| func (*ListApiKeysResponse) ProtoMessage() {}
   273| func (x *ListApiKeysResponse) ProtoReflect() protoreflect.Message {
   274| 	mi := &file_headscale_v1_apikey_proto_msgTypes[6]
   275| 	if protoimpl.UnsafeEnabled && x != nil {
   276| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   277| 		if ms.LoadMessageInfo() == nil {
   278| 			ms.StoreMessageInfo(mi)
   279| 		}
   280| 		return ms
   281| 	}
   282| 	return mi.MessageOf(x)
   283| }
   284| func (*ListApiKeysResponse) Descriptor() ([]byte, []int) {
   285| 	return file_headscale_v1_apikey_proto_rawDescGZIP(), []int{6}
   286| }
   287| func (x *ListApiKeysResponse) GetApiKeys() []*ApiKey {
   288| 	if x != nil {
   289| 		return x.ApiKeys
   290| 	}
   291| 	return nil
   292| }
   293| var File_headscale_v1_apikey_proto protoreflect.FileDescriptor
   294| var file_headscale_v1_apikey_proto_rawDesc = []byte{
   295| 	0x0a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x61,
   296| 	0x70, 0x69, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61,
   297| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   298| 	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
   299| 	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xe0, 0x01, 0x0a, 0x06, 0x41,
   300| 	0x70, 0x69, 0x4b, 0x65, 0x79, 0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
   301| 	0x04, 0x52, 0x02, 0x69, 0x64, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18,
   302| 	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x3a, 0x0a,
   303| 	0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
   304| 	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
   305| 	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x65,
   306| 	0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65,
   307| 	0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
   308| 	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
   309| 	0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74,
   310| 	0x65, 0x64, 0x41, 0x74, 0x12, 0x37, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x65,
   311| 	0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
   312| 	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
   313| 	0x61, 0x6d, 0x70, 0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x65, 0x6e, 0x22, 0x51, 0x0a,
   314| 	0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71,
   315| 	0x75, 0x65, 0x73, 0x74, 0x12, 0x3a, 0x0a, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69,
   316| 	0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   317| 	0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
   318| 	0x74, 0x61, 0x6d, 0x70, 0x52, 0x0a, 0x65, 0x78, 0x70, 0x69, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
   319| 	0x22, 0x2f, 0x0a, 0x14, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79,
   320| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x07, 0x61, 0x70, 0x69, 0x5f,
   321| 	0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x61, 0x70, 0x69, 0x4b, 0x65,
   322| 	0x79, 0x22, 0x2d, 0x0a, 0x13, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65,
   323| 	0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66,
   324| 	0x69, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78,
   325| 	0x22, 0x16, 0x0a, 0x14, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79,
   326| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x14, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74,
   327| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x46,
   328| 	0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73,
   329| 	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x08, 0x61, 0x70, 0x69, 0x5f, 0x6b, 0x65, 0x79,
   330| 	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   331| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x07, 0x61,
   332| 	0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
   333| 	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65,
   334| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76,
   335| 	0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
   336| }
   337| var (
   338| 	file_headscale_v1_apikey_proto_rawDescOnce sync.Once
   339| 	file_headscale_v1_apikey_proto_rawDescData = file_headscale_v1_apikey_proto_rawDesc
   340| )
   341| func file_headscale_v1_apikey_proto_rawDescGZIP() []byte {
   342| 	file_headscale_v1_apikey_proto_rawDescOnce.Do(func() {
   343| 		file_headscale_v1_apikey_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_apikey_proto_rawDescData)
   344| 	})
   345| 	return file_headscale_v1_apikey_proto_rawDescData
   346| }
   347| var file_headscale_v1_apikey_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
   348| var file_headscale_v1_apikey_proto_goTypes = []interface{}{
   349| 	(*ApiKey)(nil),                // 0: headscale.v1.ApiKey
   350| 	(*CreateApiKeyRequest)(nil),   // 1: headscale.v1.CreateApiKeyRequest
   351| 	(*CreateApiKeyResponse)(nil),  // 2: headscale.v1.CreateApiKeyResponse
   352| 	(*ExpireApiKeyRequest)(nil),   // 3: headscale.v1.ExpireApiKeyRequest
   353| 	(*ExpireApiKeyResponse)(nil),  // 4: headscale.v1.ExpireApiKeyResponse
   354| 	(*ListApiKeysRequest)(nil),    // 5: headscale.v1.ListApiKeysRequest
   355| 	(*ListApiKeysResponse)(nil),   // 6: headscale.v1.ListApiKeysResponse
   356| 	(*timestamppb.Timestamp)(nil), // 7: google.protobuf.Timestamp
   357| }
   358| var file_headscale_v1_apikey_proto_depIdxs = []int32{
   359| 	7, // 0: headscale.v1.ApiKey.expiration:type_name -> google.protobuf.Timestamp
   360| 	7, // 1: headscale.v1.ApiKey.created_at:type_name -> google.protobuf.Timestamp
   361| 	7, // 2: headscale.v1.ApiKey.last_seen:type_name -> google.protobuf.Timestamp
   362| 	7, // 3: headscale.v1.CreateApiKeyRequest.expiration:type_name -> google.protobuf.Timestamp
   363| 	0, // 4: headscale.v1.ListApiKeysResponse.api_keys:type_name -> headscale.v1.ApiKey
   364| 	5, // [5:5] is the sub-list for method output_type
   365| 	5, // [5:5] is the sub-list for method input_type
   366| 	5, // [5:5] is the sub-list for extension type_name
   367| 	5, // [5:5] is the sub-list for extension extendee
   368| 	0, // [0:5] is the sub-list for field type_name
   369| }
   370| func init() { file_headscale_v1_apikey_proto_init() }
   371| func file_headscale_v1_apikey_proto_init() {
   372| 	if File_headscale_v1_apikey_proto != nil {
   373| 		return
   374| 	}
   375| 	if !protoimpl.UnsafeEnabled {
   376| 		file_headscale_v1_apikey_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
   377| 			switch v := v.(*ApiKey); i {
   378| 			case 0:
   379| 				return &v.state
   380| 			case 1:
   381| 				return &v.sizeCache
   382| 			case 2:
   383| 				return &v.unknownFields
   384| 			default:
   385| 				return nil
   386| 			}
   387| 		}
   388| 		file_headscale_v1_apikey_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
   389| 			switch v := v.(*CreateApiKeyRequest); i {
   390| 			case 0:
   391| 				return &v.state
   392| 			case 1:
   393| 				return &v.sizeCache
   394| 			case 2:
   395| 				return &v.unknownFields
   396| 			default:
   397| 				return nil
   398| 			}
   399| 		}
   400| 		file_headscale_v1_apikey_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
   401| 			switch v := v.(*CreateApiKeyResponse); i {
   402| 			case 0:
   403| 				return &v.state
   404| 			case 1:
   405| 				return &v.sizeCache
   406| 			case 2:
   407| 				return &v.unknownFields
   408| 			default:
   409| 				return nil
   410| 			}
   411| 		}
   412| 		file_headscale_v1_apikey_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
   413| 			switch v := v.(*ExpireApiKeyRequest); i {
   414| 			case 0:
   415| 				return &v.state
   416| 			case 1:
   417| 				return &v.sizeCache
   418| 			case 2:
   419| 				return &v.unknownFields
   420| 			default:
   421| 				return nil
   422| 			}
   423| 		}
   424| 		file_headscale_v1_apikey_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
   425| 			switch v := v.(*ExpireApiKeyResponse); i {
   426| 			case 0:
   427| 				return &v.state
   428| 			case 1:
   429| 				return &v.sizeCache
   430| 			case 2:
   431| 				return &v.unknownFields
   432| 			default:
   433| 				return nil
   434| 			}
   435| 		}
   436| 		file_headscale_v1_apikey_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
   437| 			switch v := v.(*ListApiKeysRequest); i {
   438| 			case 0:
   439| 				return &v.state
   440| 			case 1:
   441| 				return &v.sizeCache
   442| 			case 2:
   443| 				return &v.unknownFields
   444| 			default:
   445| 				return nil
   446| 			}
   447| 		}
   448| 		file_headscale_v1_apikey_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
   449| 			switch v := v.(*ListApiKeysResponse); i {
   450| 			case 0:
   451| 				return &v.state
   452| 			case 1:
   453| 				return &v.sizeCache
   454| 			case 2:
   455| 				return &v.unknownFields
   456| 			default:
   457| 				return nil
   458| 			}
   459| 		}
   460| 	}
   461| 	type x struct{}
   462| 	out := protoimpl.TypeBuilder{
   463| 		File: protoimpl.DescBuilder{
   464| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   465| 			RawDescriptor: file_headscale_v1_apikey_proto_rawDesc,
   466| 			NumEnums:      0,
   467| 			NumMessages:   7,
   468| 			NumExtensions: 0,
   469| 			NumServices:   0,
   470| 		},
   471| 		GoTypes:           file_headscale_v1_apikey_proto_goTypes,
   472| 		DependencyIndexes: file_headscale_v1_apikey_proto_depIdxs,
   473| 		MessageInfos:      file_headscale_v1_apikey_proto_msgTypes,
   474| 	}.Build()
   475| 	File_headscale_v1_apikey_proto = out.File
   476| 	file_headscale_v1_apikey_proto_rawDesc = nil
   477| 	file_headscale_v1_apikey_proto_goTypes = nil
   478| 	file_headscale_v1_apikey_proto_depIdxs = nil
   479| }


# ====================================================================
# FILE: gen/go/headscale/v1/device.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 764-959 ---
   764| 	0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0d, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x52,
   765| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x2b, 0x0a, 0x11, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69,
   766| 	0x73, 0x65, 0x64, 0x5f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09,
   767| 	0x52, 0x10, 0x61, 0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x52, 0x6f, 0x75, 0x74,
   768| 	0x65, 0x73, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
   769| 	0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   770| 	0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70,
   771| 	0x72, 0x6f, 0x74, 0x6f, 0x33,
   772| }
   773| var (
   774| 	file_headscale_v1_device_proto_rawDescOnce sync.Once
   775| 	file_headscale_v1_device_proto_rawDescData = file_headscale_v1_device_proto_rawDesc
   776| )
   777| func file_headscale_v1_device_proto_rawDescGZIP() []byte {
   778| 	file_headscale_v1_device_proto_rawDescOnce.Do(func() {
   779| 		file_headscale_v1_device_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_device_proto_rawDescData)
   780| 	})
   781| 	return file_headscale_v1_device_proto_rawDescData
   782| }
   783| var file_headscale_v1_device_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
   784| var file_headscale_v1_device_proto_goTypes = []interface{}{
   785| 	(*Latency)(nil),                    // 0: headscale.v1.Latency
   786| 	(*ClientSupports)(nil),             // 1: headscale.v1.ClientSupports
   787| 	(*ClientConnectivity)(nil),         // 2: headscale.v1.ClientConnectivity
   788| 	(*GetDeviceRequest)(nil),           // 3: headscale.v1.GetDeviceRequest
   789| 	(*GetDeviceResponse)(nil),          // 4: headscale.v1.GetDeviceResponse
   790| 	(*DeleteDeviceRequest)(nil),        // 5: headscale.v1.DeleteDeviceRequest
   791| 	(*DeleteDeviceResponse)(nil),       // 6: headscale.v1.DeleteDeviceResponse
   792| 	(*GetDeviceRoutesRequest)(nil),     // 7: headscale.v1.GetDeviceRoutesRequest
   793| 	(*GetDeviceRoutesResponse)(nil),    // 8: headscale.v1.GetDeviceRoutesResponse
   794| 	(*EnableDeviceRoutesRequest)(nil),  // 9: headscale.v1.EnableDeviceRoutesRequest
   795| 	(*EnableDeviceRoutesResponse)(nil), // 10: headscale.v1.EnableDeviceRoutesResponse
   796| 	nil,                                // 11: headscale.v1.ClientConnectivity.LatencyEntry
   797| 	(*timestamppb.Timestamp)(nil),      // 12: google.protobuf.Timestamp
   798| }
   799| var file_headscale_v1_device_proto_depIdxs = []int32{
   800| 	11, // 0: headscale.v1.ClientConnectivity.latency:type_name -> headscale.v1.ClientConnectivity.LatencyEntry
   801| 	1,  // 1: headscale.v1.ClientConnectivity.client_supports:type_name -> headscale.v1.ClientSupports
   802| 	12, // 2: headscale.v1.GetDeviceResponse.created:type_name -> google.protobuf.Timestamp
   803| 	12, // 3: headscale.v1.GetDeviceResponse.last_seen:type_name -> google.protobuf.Timestamp
   804| 	12, // 4: headscale.v1.GetDeviceResponse.expires:type_name -> google.protobuf.Timestamp
   805| 	2,  // 5: headscale.v1.GetDeviceResponse.client_connectivity:type_name -> headscale.v1.ClientConnectivity
   806| 	0,  // 6: headscale.v1.ClientConnectivity.LatencyEntry.value:type_name -> headscale.v1.Latency
   807| 	7,  // [7:7] is the sub-list for method output_type
   808| 	7,  // [7:7] is the sub-list for method input_type
   809| 	7,  // [7:7] is the sub-list for extension type_name
   810| 	7,  // [7:7] is the sub-list for extension extendee
   811| 	0,  // [0:7] is the sub-list for field type_name
   812| }
   813| func init() { file_headscale_v1_device_proto_init() }
   814| func file_headscale_v1_device_proto_init() {
   815| 	if File_headscale_v1_device_proto != nil {
   816| 		return
   817| 	}
   818| 	if !protoimpl.UnsafeEnabled {
   819| 		file_headscale_v1_device_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
   820| 			switch v := v.(*Latency); i {
   821| 			case 0:
   822| 				return &v.state
   823| 			case 1:
   824| 				return &v.sizeCache
   825| 			case 2:
   826| 				return &v.unknownFields
   827| 			default:
   828| 				return nil
   829| 			}
   830| 		}
   831| 		file_headscale_v1_device_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
   832| 			switch v := v.(*ClientSupports); i {
   833| 			case 0:
   834| 				return &v.state
   835| 			case 1:
   836| 				return &v.sizeCache
   837| 			case 2:
   838| 				return &v.unknownFields
   839| 			default:
   840| 				return nil
   841| 			}
   842| 		}
   843| 		file_headscale_v1_device_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
   844| 			switch v := v.(*ClientConnectivity); i {
   845| 			case 0:
   846| 				return &v.state
   847| 			case 1:
   848| 				return &v.sizeCache
   849| 			case 2:
   850| 				return &v.unknownFields
   851| 			default:
   852| 				return nil
   853| 			}
   854| 		}
   855| 		file_headscale_v1_device_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
   856| 			switch v := v.(*GetDeviceRequest); i {
   857| 			case 0:
   858| 				return &v.state
   859| 			case 1:
   860| 				return &v.sizeCache
   861| 			case 2:
   862| 				return &v.unknownFields
   863| 			default:
   864| 				return nil
   865| 			}
   866| 		}
   867| 		file_headscale_v1_device_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
   868| 			switch v := v.(*GetDeviceResponse); i {
   869| 			case 0:
   870| 				return &v.state
   871| 			case 1:
   872| 				return &v.sizeCache
   873| 			case 2:
   874| 				return &v.unknownFields
   875| 			default:
   876| 				return nil
   877| 			}
   878| 		}
   879| 		file_headscale_v1_device_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
   880| 			switch v := v.(*DeleteDeviceRequest); i {
   881| 			case 0:
   882| 				return &v.state
   883| 			case 1:
   884| 				return &v.sizeCache
   885| 			case 2:
   886| 				return &v.unknownFields
   887| 			default:
   888| 				return nil
   889| 			}
   890| 		}
   891| 		file_headscale_v1_device_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
   892| 			switch v := v.(*DeleteDeviceResponse); i {
   893| 			case 0:
   894| 				return &v.state
   895| 			case 1:
   896| 				return &v.sizeCache
   897| 			case 2:
   898| 				return &v.unknownFields
   899| 			default:
   900| 				return nil
   901| 			}
   902| 		}
   903| 		file_headscale_v1_device_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
   904| 			switch v := v.(*GetDeviceRoutesRequest); i {
   905| 			case 0:
   906| 				return &v.state
   907| 			case 1:
   908| 				return &v.sizeCache
   909| 			case 2:
   910| 				return &v.unknownFields
   911| 			default:
   912| 				return nil
   913| 			}
   914| 		}
   915| 		file_headscale_v1_device_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
   916| 			switch v := v.(*GetDeviceRoutesResponse); i {
   917| 			case 0:
   918| 				return &v.state
   919| 			case 1:
   920| 				return &v.sizeCache
   921| 			case 2:
   922| 				return &v.unknownFields
   923| 			default:
   924| 				return nil
   925| 			}
   926| 		}
   927| 		file_headscale_v1_device_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
   928| 			switch v := v.(*EnableDeviceRoutesRequest); i {
   929| 			case 0:
   930| 				return &v.state
   931| 			case 1:
   932| 				return &v.sizeCache
   933| 			case 2:
   934| 				return &v.unknownFields
   935| 			default:
   936| 				return nil
   937| 			}
   938| 		}
   939| 		file_headscale_v1_device_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
   940| 			switch v := v.(*EnableDeviceRoutesResponse); i {
   941| 			case 0:
   942| 				return &v.state
   943| 			case 1:
   944| 				return &v.sizeCache
   945| 			case 2:
   946| 				return &v.unknownFields
   947| 			default:
   948| 				return nil
   949| 			}
   950| 		}
   951| 	}
   952| 	type x struct{}
   953| 	out := protoimpl.TypeBuilder{
   954| 		File: protoimpl.DescBuilder{
   955| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   956| 			RawDescriptor: file_headscale_v1_device_proto_rawDesc,
   957| 			NumEnums:      0,
   958| 			NumMessages:   12,
   959| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/headscale.pb.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 2-361 ---
     2| import (
     3| 	_ "google.golang.org/genproto/googleapis/api/annotations"
     4| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     5| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     6| 	reflect "reflect"
     7| )
     8| const (
     9| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    10| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    11| )
    12| var File_headscale_v1_headscale_proto protoreflect.FileDescriptor
    13| var file_headscale_v1_headscale_proto_rawDesc = []byte{
    14| 	0x0a, 0x1c, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x68,
    15| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c,
    16| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1c, 0x67, 0x6f,
    17| 	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74,
    18| 	0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61, 0x64,
    19| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70, 0x72,
    20| 	0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76,
    21| 	0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f,
    22| 	0x74, 0x6f, 0x1a, 0x1a, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31,
    23| 	0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19,
    24| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75,
    25| 	0x74, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73,
    26| 	0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x6b, 0x65, 0x79, 0x2e, 0x70,
    27| 	0x72, 0x6f, 0x74, 0x6f, 0x32, 0x8d, 0x18, 0x0a, 0x10, 0x48, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
    28| 	0x6c, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x63, 0x0a, 0x07, 0x47, 0x65, 0x74,
    29| 	0x55, 0x73, 0x65, 0x72, 0x12, 0x1c, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
    30| 	0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65,
    31| 	0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
    32| 	0x31, 0x2e, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    33| 	0x65, 0x22, 0x1b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x15, 0x12, 0x13, 0x2f, 0x61, 0x70, 0x69, 0x2f,
    34| 	0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x68,
    35| 	0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x68,
    36| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61,
    37| 	0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e,
    38| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65,
    39| 	0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
    40| 	0x17, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x11, 0x3a, 0x01, 0x2a, 0x22, 0x0c, 0x2f, 0x61, 0x70, 0x69,
    41| 	0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x12, 0x82, 0x01, 0x0a, 0x0a, 0x52, 0x65, 0x6e,
    42| 	0x61, 0x6d, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
    43| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x55, 0x73, 0x65,
    44| 	0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
    45| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x55, 0x73,
    46| 	0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x31, 0x82, 0xd3, 0xe4, 0x93,
    47| 	0x02, 0x2b, 0x22, 0x29, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72,
    48| 	0x2f, 0x7b, 0x6f, 0x6c, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x2f, 0x72, 0x65, 0x6e, 0x61,
    49| 	0x6d, 0x65, 0x2f, 0x7b, 0x6e, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x6c, 0x0a,
    50| 	0x0a, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1f, 0x2e, 0x68, 0x65,
    51| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74,
    52| 	0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68,
    53| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65,
    54| 	0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1b,
    55| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x15, 0x2a, 0x13, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
    56| 	0x75, 0x73, 0x65, 0x72, 0x2f, 0x7b, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12, 0x62, 0x0a, 0x09, 0x4c,
    57| 	0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73, 0x12, 0x1e, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
    58| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72,
    59| 	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
    60| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72,
    61| 	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x14, 0x82, 0xd3, 0xe4, 0x93, 0x02,
    62| 	0x0e, 0x12, 0x0c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x12,
    63| 	0x80, 0x01, 0x0a, 0x10, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74,
    64| 	0x68, 0x4b, 0x65, 0x79, 0x12, 0x25, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
    65| 	0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74,
    66| 	0x68, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26, 0x2e, 0x68, 0x65,
    67| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65, 0x61, 0x74,
    68| 	0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f,
    69| 	0x6e, 0x73, 0x65, 0x22, 0x1d, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x17, 0x3a, 0x01, 0x2a, 0x22, 0x12,
    70| 	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b,
    71| 	0x65, 0x79, 0x12, 0x87, 0x01, 0x0a, 0x10, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65,
    72| 	0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x12, 0x25, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
    73| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65,
    74| 	0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x26,
    75| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78,
    76| 	0x70, 0x69, 0x72, 0x65, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x65,
    77| 	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x24, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1e, 0x3a, 0x01,
    78| 	0x2a, 0x22, 0x19, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75,
    79| 	0x74, 0x68, 0x6b, 0x65, 0x79, 0x2f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x7a, 0x0a, 0x0f,
    80| 	0x4c, 0x69, 0x73, 0x74, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73, 0x12,
    81| 	0x24, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
    82| 	0x69, 0x73, 0x74, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73, 0x52, 0x65,
    83| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
    84| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68,
    85| 	0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x1a, 0x82, 0xd3,
    86| 	0xe4, 0x93, 0x02, 0x14, 0x12, 0x12, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x70, 0x72,
    87| 	0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x12, 0x89, 0x01, 0x0a, 0x12, 0x44, 0x65, 0x62,
    88| 	0x75, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12,
    89| 	0x27, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44,
    90| 	0x65, 0x62, 0x75, 0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e,
    91| 	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
    92| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x62, 0x75, 0x67, 0x43, 0x72, 0x65,
    93| 	0x61, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    94| 	0x73, 0x65, 0x22, 0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1a, 0x3a, 0x01, 0x2a, 0x22, 0x15, 0x2f,
    95| 	0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x64, 0x65, 0x62, 0x75, 0x67, 0x2f, 0x6d, 0x61, 0x63,
    96| 	0x68, 0x69, 0x6e, 0x65, 0x12, 0x75, 0x0a, 0x0a, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69,
    97| 	0x6e, 0x65, 0x12, 0x1f, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
    98| 	0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75,
    99| 	0x65, 0x73, 0x74, 0x1a, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
   100| 	0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73,
   101| 	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x24, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1e, 0x12, 0x1c, 0x2f,
   102| 	0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f, 0x7b,
   103| 	0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x12, 0x74, 0x0a, 0x07, 0x53,
   104| 	0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x12, 0x1c, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   105| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x71,
   106| 	0x75, 0x65, 0x73, 0x74, 0x1a, 0x1d, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
   107| 	0x2e, 0x76, 0x31, 0x2e, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
   108| 	0x6e, 0x73, 0x65, 0x22, 0x2c, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x26, 0x3a, 0x01, 0x2a, 0x22, 0x21,
   109| 	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f,
   110| 	0x7b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x74, 0x61, 0x67,
   111| 	0x73, 0x12, 0x80, 0x01, 0x0a, 0x0f, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x61,
   112| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x12, 0x24, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   113| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x61, 0x63,
   114| 	0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x68, 0x65,
   115| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73,
   116| 	0x74, 0x65, 0x72, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
   117| 	0x73, 0x65, 0x22, 0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1a, 0x22, 0x18, 0x2f, 0x61, 0x70, 0x69,
   118| 	0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f, 0x72, 0x65, 0x67, 0x69,
   119| 	0x73, 0x74, 0x65, 0x72, 0x12, 0x7e, 0x0a, 0x0d, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61,
   120| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x12, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   121| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69,
   122| 	0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x68, 0x65, 0x61, 0x64,
   123| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d,
   124| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x24,
   125| 	0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1e, 0x2a, 0x1c, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f,
   126| 	0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f, 0x7b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
   127| 	0x5f, 0x69, 0x64, 0x7d, 0x12, 0x85, 0x01, 0x0a, 0x0d, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4d,
   128| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   129| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4d, 0x61, 0x63, 0x68,
   130| 	0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x23, 0x2e, 0x68, 0x65, 0x61,
   131| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65,
   132| 	0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
   133| 	0x2b, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x25, 0x22, 0x23, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31,
   134| 	0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f, 0x7b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
   135| 	0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x90, 0x01, 0x0a,
   136| 	0x0d, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12, 0x22,
   137| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65,
   138| 	0x6e, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
   139| 	0x73, 0x74, 0x1a, 0x23, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   140| 	0x31, 0x2e, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52,
   141| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x36, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x30, 0x22,
   142| 	0x2e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
   143| 	0x2f, 0x7b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x72, 0x65,
   144| 	0x6e, 0x61, 0x6d, 0x65, 0x2f, 0x7b, 0x6e, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x7d, 0x12,
   145| 	0x6e, 0x0a, 0x0c, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x12,
   146| 	0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c,
   147| 	0x69, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65,
   148| 	0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   149| 	0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x52, 0x65,
   150| 	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x17, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x11, 0x12, 0x0f,
   151| 	0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12,
   152| 	0x7d, 0x0a, 0x0b, 0x4d, 0x6f, 0x76, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12, 0x20,
   153| 	0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x6f,
   154| 	0x76, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
   155| 	0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
   156| 	0x4d, 0x6f, 0x76, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
   157| 	0x6e, 0x73, 0x65, 0x22, 0x29, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x23, 0x22, 0x21, 0x2f, 0x61, 0x70,
   158| 	0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2f, 0x7b, 0x6d, 0x61,
   159| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x12, 0x64,
   160| 	0x0a, 0x09, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x1e, 0x2e, 0x68, 0x65,
   161| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f,
   162| 	0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x1f, 0x2e, 0x68, 0x65,
   163| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x52, 0x6f,
   164| 	0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x16, 0x82, 0xd3,
   165| 	0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f,
   166| 	0x75, 0x74, 0x65, 0x73, 0x12, 0x7c, 0x0a, 0x0b, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f,
   167| 	0x75, 0x74, 0x65, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
   168| 	0x76, 0x31, 0x2e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65,
   169| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   170| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65,
   171| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x28, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x22,
   172| 	0x22, 0x20, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73,
   173| 	0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x65, 0x6e, 0x61, 0x62,
   174| 	0x6c, 0x65, 0x12, 0x80, 0x01, 0x0a, 0x0c, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f,
   175| 	0x75, 0x74, 0x65, 0x12, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e,
   176| 	0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52,
   177| 	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   178| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75,
   179| 	0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x29, 0x82, 0xd3, 0xe4, 0x93,
   180| 	0x02, 0x23, 0x22, 0x21, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75, 0x74,
   181| 	0x65, 0x73, 0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f, 0x64, 0x69,
   182| 	0x73, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x8e, 0x01, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63,
   183| 	0x68, 0x69, 0x6e, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x25, 0x2e, 0x68, 0x65, 0x61,
   184| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63,
   185| 	0x68, 0x69, 0x6e, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
   186| 	0x74, 0x1a, 0x26, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31,
   187| 	0x2e, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65,
   188| 	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x2b, 0x82, 0xd3, 0xe4, 0x93, 0x02,
   189| 	0x25, 0x12, 0x23, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69,
   190| 	0x6e, 0x65, 0x2f, 0x7b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x2f,
   191| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x12, 0x75, 0x0a, 0x0b, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65,
   192| 	0x52, 0x6f, 0x75, 0x74, 0x65, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   193| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65,
   194| 	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   195| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f, 0x75,
   196| 	0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x21, 0x82, 0xd3, 0xe4, 0x93,
   197| 	0x02, 0x1b, 0x2a, 0x19, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x72, 0x6f, 0x75, 0x74,
   198| 	0x65, 0x73, 0x2f, 0x7b, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x7d, 0x12, 0x70, 0x0a,
   199| 	0x0c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x12, 0x21, 0x2e,
   200| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x43, 0x72, 0x65,
   201| 	0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
   202| 	0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
   203| 	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x73, 0x70,
   204| 	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x19, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x13, 0x3a, 0x01, 0x2a, 0x22,
   205| 	0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x6b, 0x65, 0x79, 0x12,
   206| 	0x77, 0x0a, 0x0c, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x12,
   207| 	0x21, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x45,
   208| 	0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65, 0x71, 0x75, 0x65,
   209| 	0x73, 0x74, 0x1a, 0x22, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76,
   210| 	0x31, 0x2e, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x52, 0x65,
   211| 	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x20, 0x82, 0xd3, 0xe4, 0x93, 0x02, 0x1a, 0x3a, 0x01,
   212| 	0x2a, 0x22, 0x15, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70, 0x69, 0x6b, 0x65,
   213| 	0x79, 0x2f, 0x65, 0x78, 0x70, 0x69, 0x72, 0x65, 0x12, 0x6a, 0x0a, 0x0b, 0x4c, 0x69, 0x73, 0x74,
   214| 	0x41, 0x70, 0x69, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x20, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   215| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x70, 0x69, 0x4b, 0x65,
   216| 	0x79, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x21, 0x2e, 0x68, 0x65, 0x61, 0x64,
   217| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x70, 0x69,
   218| 	0x4b, 0x65, 0x79, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x16, 0x82, 0xd3,
   219| 	0xe4, 0x93, 0x02, 0x10, 0x12, 0x0e, 0x2f, 0x61, 0x70, 0x69, 0x2f, 0x76, 0x31, 0x2f, 0x61, 0x70,
   220| 	0x69, 0x6b, 0x65, 0x79, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
   221| 	0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64,
   222| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62,
   223| 	0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
   224| }
   225| var file_headscale_v1_headscale_proto_goTypes = []interface{}{
   226| 	(*GetUserRequest)(nil),             // 0: headscale.v1.GetUserRequest
   227| 	(*CreateUserRequest)(nil),          // 1: headscale.v1.CreateUserRequest
   228| 	(*RenameUserRequest)(nil),          // 2: headscale.v1.RenameUserRequest
   229| 	(*DeleteUserRequest)(nil),          // 3: headscale.v1.DeleteUserRequest
   230| 	(*ListUsersRequest)(nil),           // 4: headscale.v1.ListUsersRequest
   231| 	(*CreatePreAuthKeyRequest)(nil),    // 5: headscale.v1.CreatePreAuthKeyRequest
   232| 	(*ExpirePreAuthKeyRequest)(nil),    // 6: headscale.v1.ExpirePreAuthKeyRequest
   233| 	(*ListPreAuthKeysRequest)(nil),     // 7: headscale.v1.ListPreAuthKeysRequest
   234| 	(*DebugCreateMachineRequest)(nil),  // 8: headscale.v1.DebugCreateMachineRequest
   235| 	(*GetMachineRequest)(nil),          // 9: headscale.v1.GetMachineRequest
   236| 	(*SetTagsRequest)(nil),             // 10: headscale.v1.SetTagsRequest
   237| 	(*RegisterMachineRequest)(nil),     // 11: headscale.v1.RegisterMachineRequest
   238| 	(*DeleteMachineRequest)(nil),       // 12: headscale.v1.DeleteMachineRequest
   239| 	(*ExpireMachineRequest)(nil),       // 13: headscale.v1.ExpireMachineRequest
   240| 	(*RenameMachineRequest)(nil),       // 14: headscale.v1.RenameMachineRequest
   241| 	(*ListMachinesRequest)(nil),        // 15: headscale.v1.ListMachinesRequest
   242| 	(*MoveMachineRequest)(nil),         // 16: headscale.v1.MoveMachineRequest
   243| 	(*GetRoutesRequest)(nil),           // 17: headscale.v1.GetRoutesRequest
   244| 	(*EnableRouteRequest)(nil),         // 18: headscale.v1.EnableRouteRequest
   245| 	(*DisableRouteRequest)(nil),        // 19: headscale.v1.DisableRouteRequest
   246| 	(*GetMachineRoutesRequest)(nil),    // 20: headscale.v1.GetMachineRoutesRequest
   247| 	(*DeleteRouteRequest)(nil),         // 21: headscale.v1.DeleteRouteRequest
   248| 	(*CreateApiKeyRequest)(nil),        // 22: headscale.v1.CreateApiKeyRequest
   249| 	(*ExpireApiKeyRequest)(nil),        // 23: headscale.v1.ExpireApiKeyRequest
   250| 	(*ListApiKeysRequest)(nil),         // 24: headscale.v1.ListApiKeysRequest
   251| 	(*GetUserResponse)(nil),            // 25: headscale.v1.GetUserResponse
   252| 	(*CreateUserResponse)(nil),         // 26: headscale.v1.CreateUserResponse
   253| 	(*RenameUserResponse)(nil),         // 27: headscale.v1.RenameUserResponse
   254| 	(*DeleteUserResponse)(nil),         // 28: headscale.v1.DeleteUserResponse
   255| 	(*ListUsersResponse)(nil),          // 29: headscale.v1.ListUsersResponse
   256| 	(*CreatePreAuthKeyResponse)(nil),   // 30: headscale.v1.CreatePreAuthKeyResponse
   257| 	(*ExpirePreAuthKeyResponse)(nil),   // 31: headscale.v1.ExpirePreAuthKeyResponse
   258| 	(*ListPreAuthKeysResponse)(nil),    // 32: headscale.v1.ListPreAuthKeysResponse
   259| 	(*DebugCreateMachineResponse)(nil), // 33: headscale.v1.DebugCreateMachineResponse
   260| 	(*GetMachineResponse)(nil),         // 34: headscale.v1.GetMachineResponse
   261| 	(*SetTagsResponse)(nil),            // 35: headscale.v1.SetTagsResponse
   262| 	(*RegisterMachineResponse)(nil),    // 36: headscale.v1.RegisterMachineResponse
   263| 	(*DeleteMachineResponse)(nil),      // 37: headscale.v1.DeleteMachineResponse
   264| 	(*ExpireMachineResponse)(nil),      // 38: headscale.v1.ExpireMachineResponse
   265| 	(*RenameMachineResponse)(nil),      // 39: headscale.v1.RenameMachineResponse
   266| 	(*ListMachinesResponse)(nil),       // 40: headscale.v1.ListMachinesResponse
   267| 	(*MoveMachineResponse)(nil),        // 41: headscale.v1.MoveMachineResponse
   268| 	(*GetRoutesResponse)(nil),          // 42: headscale.v1.GetRoutesResponse
   269| 	(*EnableRouteResponse)(nil),        // 43: headscale.v1.EnableRouteResponse
   270| 	(*DisableRouteResponse)(nil),       // 44: headscale.v1.DisableRouteResponse
   271| 	(*GetMachineRoutesResponse)(nil),   // 45: headscale.v1.GetMachineRoutesResponse
   272| 	(*DeleteRouteResponse)(nil),        // 46: headscale.v1.DeleteRouteResponse
   273| 	(*CreateApiKeyResponse)(nil),       // 47: headscale.v1.CreateApiKeyResponse
   274| 	(*ExpireApiKeyResponse)(nil),       // 48: headscale.v1.ExpireApiKeyResponse
   275| 	(*ListApiKeysResponse)(nil),        // 49: headscale.v1.ListApiKeysResponse
   276| }
   277| var file_headscale_v1_headscale_proto_depIdxs = []int32{
   278| 	0,  // 0: headscale.v1.HeadscaleService.GetUser:input_type -> headscale.v1.GetUserRequest
   279| 	1,  // 1: headscale.v1.HeadscaleService.CreateUser:input_type -> headscale.v1.CreateUserRequest
   280| 	2,  // 2: headscale.v1.HeadscaleService.RenameUser:input_type -> headscale.v1.RenameUserRequest
   281| 	3,  // 3: headscale.v1.HeadscaleService.DeleteUser:input_type -> headscale.v1.DeleteUserRequest
   282| 	4,  // 4: headscale.v1.HeadscaleService.ListUsers:input_type -> headscale.v1.ListUsersRequest
   283| 	5,  // 5: headscale.v1.HeadscaleService.CreatePreAuthKey:input_type -> headscale.v1.CreatePreAuthKeyRequest
   284| 	6,  // 6: headscale.v1.HeadscaleService.ExpirePreAuthKey:input_type -> headscale.v1.ExpirePreAuthKeyRequest
   285| 	7,  // 7: headscale.v1.HeadscaleService.ListPreAuthKeys:input_type -> headscale.v1.ListPreAuthKeysRequest
   286| 	8,  // 8: headscale.v1.HeadscaleService.DebugCreateMachine:input_type -> headscale.v1.DebugCreateMachineRequest
   287| 	9,  // 9: headscale.v1.HeadscaleService.GetMachine:input_type -> headscale.v1.GetMachineRequest
   288| 	10, // 10: headscale.v1.HeadscaleService.SetTags:input_type -> headscale.v1.SetTagsRequest
   289| 	11, // 11: headscale.v1.HeadscaleService.RegisterMachine:input_type -> headscale.v1.RegisterMachineRequest
   290| 	12, // 12: headscale.v1.HeadscaleService.DeleteMachine:input_type -> headscale.v1.DeleteMachineRequest
   291| 	13, // 13: headscale.v1.HeadscaleService.ExpireMachine:input_type -> headscale.v1.ExpireMachineRequest
   292| 	14, // 14: headscale.v1.HeadscaleService.RenameMachine:input_type -> headscale.v1.RenameMachineRequest
   293| 	15, // 15: headscale.v1.HeadscaleService.ListMachines:input_type -> headscale.v1.ListMachinesRequest
   294| 	16, // 16: headscale.v1.HeadscaleService.MoveMachine:input_type -> headscale.v1.MoveMachineRequest
   295| 	17, // 17: headscale.v1.HeadscaleService.GetRoutes:input_type -> headscale.v1.GetRoutesRequest
   296| 	18, // 18: headscale.v1.HeadscaleService.EnableRoute:input_type -> headscale.v1.EnableRouteRequest
   297| 	19, // 19: headscale.v1.HeadscaleService.DisableRoute:input_type -> headscale.v1.DisableRouteRequest
   298| 	20, // 20: headscale.v1.HeadscaleService.GetMachineRoutes:input_type -> headscale.v1.GetMachineRoutesRequest
   299| 	21, // 21: headscale.v1.HeadscaleService.DeleteRoute:input_type -> headscale.v1.DeleteRouteRequest
   300| 	22, // 22: headscale.v1.HeadscaleService.CreateApiKey:input_type -> headscale.v1.CreateApiKeyRequest
   301| 	23, // 23: headscale.v1.HeadscaleService.ExpireApiKey:input_type -> headscale.v1.ExpireApiKeyRequest
   302| 	24, // 24: headscale.v1.HeadscaleService.ListApiKeys:input_type -> headscale.v1.ListApiKeysRequest
   303| 	25, // 25: headscale.v1.HeadscaleService.GetUser:output_type -> headscale.v1.GetUserResponse
   304| 	26, // 26: headscale.v1.HeadscaleService.CreateUser:output_type -> headscale.v1.CreateUserResponse
   305| 	27, // 27: headscale.v1.HeadscaleService.RenameUser:output_type -> headscale.v1.RenameUserResponse
   306| 	28, // 28: headscale.v1.HeadscaleService.DeleteUser:output_type -> headscale.v1.DeleteUserResponse
   307| 	29, // 29: headscale.v1.HeadscaleService.ListUsers:output_type -> headscale.v1.ListUsersResponse
   308| 	30, // 30: headscale.v1.HeadscaleService.CreatePreAuthKey:output_type -> headscale.v1.CreatePreAuthKeyResponse
   309| 	31, // 31: headscale.v1.HeadscaleService.ExpirePreAuthKey:output_type -> headscale.v1.ExpirePreAuthKeyResponse
   310| 	32, // 32: headscale.v1.HeadscaleService.ListPreAuthKeys:output_type -> headscale.v1.ListPreAuthKeysResponse
   311| 	33, // 33: headscale.v1.HeadscaleService.DebugCreateMachine:output_type -> headscale.v1.DebugCreateMachineResponse
   312| 	34, // 34: headscale.v1.HeadscaleService.GetMachine:output_type -> headscale.v1.GetMachineResponse
   313| 	35, // 35: headscale.v1.HeadscaleService.SetTags:output_type -> headscale.v1.SetTagsResponse
   314| 	36, // 36: headscale.v1.HeadscaleService.RegisterMachine:output_type -> headscale.v1.RegisterMachineResponse
   315| 	37, // 37: headscale.v1.HeadscaleService.DeleteMachine:output_type -> headscale.v1.DeleteMachineResponse
   316| 	38, // 38: headscale.v1.HeadscaleService.ExpireMachine:output_type -> headscale.v1.ExpireMachineResponse
   317| 	39, // 39: headscale.v1.HeadscaleService.RenameMachine:output_type -> headscale.v1.RenameMachineResponse
   318| 	40, // 40: headscale.v1.HeadscaleService.ListMachines:output_type -> headscale.v1.ListMachinesResponse
   319| 	41, // 41: headscale.v1.HeadscaleService.MoveMachine:output_type -> headscale.v1.MoveMachineResponse
   320| 	42, // 42: headscale.v1.HeadscaleService.GetRoutes:output_type -> headscale.v1.GetRoutesResponse
   321| 	43, // 43: headscale.v1.HeadscaleService.EnableRoute:output_type -> headscale.v1.EnableRouteResponse
   322| 	44, // 44: headscale.v1.HeadscaleService.DisableRoute:output_type -> headscale.v1.DisableRouteResponse
   323| 	45, // 45: headscale.v1.HeadscaleService.GetMachineRoutes:output_type -> headscale.v1.GetMachineRoutesResponse
   324| 	46, // 46: headscale.v1.HeadscaleService.DeleteRoute:output_type -> headscale.v1.DeleteRouteResponse
   325| 	47, // 47: headscale.v1.HeadscaleService.CreateApiKey:output_type -> headscale.v1.CreateApiKeyResponse
   326| 	48, // 48: headscale.v1.HeadscaleService.ExpireApiKey:output_type -> headscale.v1.ExpireApiKeyResponse
   327| 	49, // 49: headscale.v1.HeadscaleService.ListApiKeys:output_type -> headscale.v1.ListApiKeysResponse
   328| 	25, // [25:50] is the sub-list for method output_type
   329| 	0,  // [0:25] is the sub-list for method input_type
   330| 	0,  // [0:0] is the sub-list for extension type_name
   331| 	0,  // [0:0] is the sub-list for extension extendee
   332| 	0,  // [0:0] is the sub-list for field type_name
   333| }
   334| func init() { file_headscale_v1_headscale_proto_init() }
   335| func file_headscale_v1_headscale_proto_init() {
   336| 	if File_headscale_v1_headscale_proto != nil {
   337| 		return
   338| 	}
   339| 	file_headscale_v1_user_proto_init()
   340| 	file_headscale_v1_preauthkey_proto_init()
   341| 	file_headscale_v1_machine_proto_init()
   342| 	file_headscale_v1_routes_proto_init()
   343| 	file_headscale_v1_apikey_proto_init()
   344| 	type x struct{}
   345| 	out := protoimpl.TypeBuilder{
   346| 		File: protoimpl.DescBuilder{
   347| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   348| 			RawDescriptor: file_headscale_v1_headscale_proto_rawDesc,
   349| 			NumEnums:      0,
   350| 			NumMessages:   0,
   351| 			NumExtensions: 0,
   352| 			NumServices:   1,
   353| 		},
   354| 		GoTypes:           file_headscale_v1_headscale_proto_goTypes,
   355| 		DependencyIndexes: file_headscale_v1_headscale_proto_depIdxs,
   356| 	}.Build()
   357| 	File_headscale_v1_headscale_proto = out.File
   358| 	file_headscale_v1_headscale_proto_rawDesc = nil
   359| 	file_headscale_v1_headscale_proto_goTypes = nil
   360| 	file_headscale_v1_headscale_proto_depIdxs = nil
   361| }


# ====================================================================
# FILE: gen/go/headscale/v1/headscale.pb.gw.go
# Total hunks: 11
# ====================================================================
# --- HUNK 1: Lines 48-105 ---
    48| 	var (
    49| 		val string
    50| 		ok  bool
    51| 		err error
    52| 		_   = err
    53| 	)
    54| 	val, ok = pathParams["name"]
    55| 	if !ok {
    56| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "name")
    57| 	}
    58| 	protoReq.Name, err = runtime.String(val)
    59| 	if err != nil {
    60| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
    61| 	}
    62| 	msg, err := server.GetUser(ctx, &protoReq)
    63| 	return msg, metadata, err
    64| }
    65| func request_HeadscaleService_CreateUser_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    66| 	var protoReq CreateUserRequest
    67| 	var metadata runtime.ServerMetadata
    68| 	newReader, berr := utilities.IOReaderFactory(req.Body)
    69| 	if berr != nil {
    70| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
    71| 	}
    72| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
    73| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
    74| 	}
    75| 	msg, err := client.CreateUser(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
    76| 	return msg, metadata, err
    77| }
    78| func local_request_HeadscaleService_CreateUser_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    79| 	var protoReq CreateUserRequest
    80| 	var metadata runtime.ServerMetadata
    81| 	newReader, berr := utilities.IOReaderFactory(req.Body)
    82| 	if berr != nil {
    83| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
    84| 	}
    85| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
    86| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
    87| 	}
    88| 	msg, err := server.CreateUser(ctx, &protoReq)
    89| 	return msg, metadata, err
    90| }
    91| func request_HeadscaleService_RenameUser_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
    92| 	var protoReq RenameUserRequest
    93| 	var metadata runtime.ServerMetadata
    94| 	var (
    95| 		val string
    96| 		ok  bool
    97| 		err error
    98| 		_   = err
    99| 	)
   100| 	val, ok = pathParams["old_name"]
   101| 	if !ok {
   102| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "old_name")
   103| 	}
   104| 	protoReq.OldName, err = runtime.String(val)
   105| 	if err != nil {

# --- HUNK 2: Lines 182-660 ---
   182| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "name", err)
   183| 	}
   184| 	msg, err := server.DeleteUser(ctx, &protoReq)
   185| 	return msg, metadata, err
   186| }
   187| func request_HeadscaleService_ListUsers_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   188| 	var protoReq ListUsersRequest
   189| 	var metadata runtime.ServerMetadata
   190| 	msg, err := client.ListUsers(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   191| 	return msg, metadata, err
   192| }
   193| func local_request_HeadscaleService_ListUsers_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   194| 	var protoReq ListUsersRequest
   195| 	var metadata runtime.ServerMetadata
   196| 	msg, err := server.ListUsers(ctx, &protoReq)
   197| 	return msg, metadata, err
   198| }
   199| func request_HeadscaleService_CreatePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   200| 	var protoReq CreatePreAuthKeyRequest
   201| 	var metadata runtime.ServerMetadata
   202| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   203| 	if berr != nil {
   204| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   205| 	}
   206| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   207| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   208| 	}
   209| 	msg, err := client.CreatePreAuthKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   210| 	return msg, metadata, err
   211| }
   212| func local_request_HeadscaleService_CreatePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   213| 	var protoReq CreatePreAuthKeyRequest
   214| 	var metadata runtime.ServerMetadata
   215| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   216| 	if berr != nil {
   217| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   218| 	}
   219| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   220| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   221| 	}
   222| 	msg, err := server.CreatePreAuthKey(ctx, &protoReq)
   223| 	return msg, metadata, err
   224| }
   225| func request_HeadscaleService_ExpirePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   226| 	var protoReq ExpirePreAuthKeyRequest
   227| 	var metadata runtime.ServerMetadata
   228| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   229| 	if berr != nil {
   230| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   231| 	}
   232| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   233| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   234| 	}
   235| 	msg, err := client.ExpirePreAuthKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   236| 	return msg, metadata, err
   237| }
   238| func local_request_HeadscaleService_ExpirePreAuthKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   239| 	var protoReq ExpirePreAuthKeyRequest
   240| 	var metadata runtime.ServerMetadata
   241| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   242| 	if berr != nil {
   243| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   244| 	}
   245| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   246| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   247| 	}
   248| 	msg, err := server.ExpirePreAuthKey(ctx, &protoReq)
   249| 	return msg, metadata, err
   250| }
   251| var (
   252| 	filter_HeadscaleService_ListPreAuthKeys_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   253| )
   254| func request_HeadscaleService_ListPreAuthKeys_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   255| 	var protoReq ListPreAuthKeysRequest
   256| 	var metadata runtime.ServerMetadata
   257| 	if err := req.ParseForm(); err != nil {
   258| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   259| 	}
   260| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListPreAuthKeys_0); err != nil {
   261| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   262| 	}
   263| 	msg, err := client.ListPreAuthKeys(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   264| 	return msg, metadata, err
   265| }
   266| func local_request_HeadscaleService_ListPreAuthKeys_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   267| 	var protoReq ListPreAuthKeysRequest
   268| 	var metadata runtime.ServerMetadata
   269| 	if err := req.ParseForm(); err != nil {
   270| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   271| 	}
   272| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListPreAuthKeys_0); err != nil {
   273| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   274| 	}
   275| 	msg, err := server.ListPreAuthKeys(ctx, &protoReq)
   276| 	return msg, metadata, err
   277| }
   278| func request_HeadscaleService_DebugCreateMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   279| 	var protoReq DebugCreateMachineRequest
   280| 	var metadata runtime.ServerMetadata
   281| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   282| 	if berr != nil {
   283| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   284| 	}
   285| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   286| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   287| 	}
   288| 	msg, err := client.DebugCreateMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   289| 	return msg, metadata, err
   290| }
   291| func local_request_HeadscaleService_DebugCreateMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   292| 	var protoReq DebugCreateMachineRequest
   293| 	var metadata runtime.ServerMetadata
   294| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   295| 	if berr != nil {
   296| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   297| 	}
   298| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   299| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   300| 	}
   301| 	msg, err := server.DebugCreateMachine(ctx, &protoReq)
   302| 	return msg, metadata, err
   303| }
   304| func request_HeadscaleService_GetMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   305| 	var protoReq GetMachineRequest
   306| 	var metadata runtime.ServerMetadata
   307| 	var (
   308| 		val string
   309| 		ok  bool
   310| 		err error
   311| 		_   = err
   312| 	)
   313| 	val, ok = pathParams["machine_id"]
   314| 	if !ok {
   315| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   316| 	}
   317| 	protoReq.MachineId, err = runtime.Uint64(val)
   318| 	if err != nil {
   319| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   320| 	}
   321| 	msg, err := client.GetMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   322| 	return msg, metadata, err
   323| }
   324| func local_request_HeadscaleService_GetMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   325| 	var protoReq GetMachineRequest
   326| 	var metadata runtime.ServerMetadata
   327| 	var (
   328| 		val string
   329| 		ok  bool
   330| 		err error
   331| 		_   = err
   332| 	)
   333| 	val, ok = pathParams["machine_id"]
   334| 	if !ok {
   335| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   336| 	}
   337| 	protoReq.MachineId, err = runtime.Uint64(val)
   338| 	if err != nil {
   339| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   340| 	}
   341| 	msg, err := server.GetMachine(ctx, &protoReq)
   342| 	return msg, metadata, err
   343| }
   344| func request_HeadscaleService_SetTags_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   345| 	var protoReq SetTagsRequest
   346| 	var metadata runtime.ServerMetadata
   347| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   348| 	if berr != nil {
   349| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   350| 	}
   351| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   352| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   353| 	}
   354| 	var (
   355| 		val string
   356| 		ok  bool
   357| 		err error
   358| 		_   = err
   359| 	)
   360| 	val, ok = pathParams["machine_id"]
   361| 	if !ok {
   362| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   363| 	}
   364| 	protoReq.MachineId, err = runtime.Uint64(val)
   365| 	if err != nil {
   366| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   367| 	}
   368| 	msg, err := client.SetTags(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   369| 	return msg, metadata, err
   370| }
   371| func local_request_HeadscaleService_SetTags_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   372| 	var protoReq SetTagsRequest
   373| 	var metadata runtime.ServerMetadata
   374| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   375| 	if berr != nil {
   376| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   377| 	}
   378| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   379| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   380| 	}
   381| 	var (
   382| 		val string
   383| 		ok  bool
   384| 		err error
   385| 		_   = err
   386| 	)
   387| 	val, ok = pathParams["machine_id"]
   388| 	if !ok {
   389| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   390| 	}
   391| 	protoReq.MachineId, err = runtime.Uint64(val)
   392| 	if err != nil {
   393| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   394| 	}
   395| 	msg, err := server.SetTags(ctx, &protoReq)
   396| 	return msg, metadata, err
   397| }
   398| var (
   399| 	filter_HeadscaleService_RegisterMachine_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   400| )
   401| func request_HeadscaleService_RegisterMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   402| 	var protoReq RegisterMachineRequest
   403| 	var metadata runtime.ServerMetadata
   404| 	if err := req.ParseForm(); err != nil {
   405| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   406| 	}
   407| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_RegisterMachine_0); err != nil {
   408| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   409| 	}
   410| 	msg, err := client.RegisterMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   411| 	return msg, metadata, err
   412| }
   413| func local_request_HeadscaleService_RegisterMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   414| 	var protoReq RegisterMachineRequest
   415| 	var metadata runtime.ServerMetadata
   416| 	if err := req.ParseForm(); err != nil {
   417| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   418| 	}
   419| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_RegisterMachine_0); err != nil {
   420| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   421| 	}
   422| 	msg, err := server.RegisterMachine(ctx, &protoReq)
   423| 	return msg, metadata, err
   424| }
   425| func request_HeadscaleService_DeleteMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   426| 	var protoReq DeleteMachineRequest
   427| 	var metadata runtime.ServerMetadata
   428| 	var (
   429| 		val string
   430| 		ok  bool
   431| 		err error
   432| 		_   = err
   433| 	)
   434| 	val, ok = pathParams["machine_id"]
   435| 	if !ok {
   436| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   437| 	}
   438| 	protoReq.MachineId, err = runtime.Uint64(val)
   439| 	if err != nil {
   440| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   441| 	}
   442| 	msg, err := client.DeleteMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   443| 	return msg, metadata, err
   444| }
   445| func local_request_HeadscaleService_DeleteMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   446| 	var protoReq DeleteMachineRequest
   447| 	var metadata runtime.ServerMetadata
   448| 	var (
   449| 		val string
   450| 		ok  bool
   451| 		err error
   452| 		_   = err
   453| 	)
   454| 	val, ok = pathParams["machine_id"]
   455| 	if !ok {
   456| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   457| 	}
   458| 	protoReq.MachineId, err = runtime.Uint64(val)
   459| 	if err != nil {
   460| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   461| 	}
   462| 	msg, err := server.DeleteMachine(ctx, &protoReq)
   463| 	return msg, metadata, err
   464| }
   465| func request_HeadscaleService_ExpireMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   466| 	var protoReq ExpireMachineRequest
   467| 	var metadata runtime.ServerMetadata
   468| 	var (
   469| 		val string
   470| 		ok  bool
   471| 		err error
   472| 		_   = err
   473| 	)
   474| 	val, ok = pathParams["machine_id"]
   475| 	if !ok {
   476| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   477| 	}
   478| 	protoReq.MachineId, err = runtime.Uint64(val)
   479| 	if err != nil {
   480| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   481| 	}
   482| 	msg, err := client.ExpireMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   483| 	return msg, metadata, err
   484| }
   485| func local_request_HeadscaleService_ExpireMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   486| 	var protoReq ExpireMachineRequest
   487| 	var metadata runtime.ServerMetadata
   488| 	var (
   489| 		val string
   490| 		ok  bool
   491| 		err error
   492| 		_   = err
   493| 	)
   494| 	val, ok = pathParams["machine_id"]
   495| 	if !ok {
   496| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   497| 	}
   498| 	protoReq.MachineId, err = runtime.Uint64(val)
   499| 	if err != nil {
   500| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   501| 	}
   502| 	msg, err := server.ExpireMachine(ctx, &protoReq)
   503| 	return msg, metadata, err
   504| }
   505| func request_HeadscaleService_RenameMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   506| 	var protoReq RenameMachineRequest
   507| 	var metadata runtime.ServerMetadata
   508| 	var (
   509| 		val string
   510| 		ok  bool
   511| 		err error
   512| 		_   = err
   513| 	)
   514| 	val, ok = pathParams["machine_id"]
   515| 	if !ok {
   516| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   517| 	}
   518| 	protoReq.MachineId, err = runtime.Uint64(val)
   519| 	if err != nil {
   520| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   521| 	}
   522| 	val, ok = pathParams["new_name"]
   523| 	if !ok {
   524| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "new_name")
   525| 	}
   526| 	protoReq.NewName, err = runtime.String(val)
   527| 	if err != nil {
   528| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "new_name", err)
   529| 	}
   530| 	msg, err := client.RenameMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   531| 	return msg, metadata, err
   532| }
   533| func local_request_HeadscaleService_RenameMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   534| 	var protoReq RenameMachineRequest
   535| 	var metadata runtime.ServerMetadata
   536| 	var (
   537| 		val string
   538| 		ok  bool
   539| 		err error
   540| 		_   = err
   541| 	)
   542| 	val, ok = pathParams["machine_id"]
   543| 	if !ok {
   544| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   545| 	}
   546| 	protoReq.MachineId, err = runtime.Uint64(val)
   547| 	if err != nil {
   548| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   549| 	}
   550| 	val, ok = pathParams["new_name"]
   551| 	if !ok {
   552| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "new_name")
   553| 	}
   554| 	protoReq.NewName, err = runtime.String(val)
   555| 	if err != nil {
   556| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "new_name", err)
   557| 	}
   558| 	msg, err := server.RenameMachine(ctx, &protoReq)
   559| 	return msg, metadata, err
   560| }
   561| var (
   562| 	filter_HeadscaleService_ListMachines_0 = &utilities.DoubleArray{Encoding: map[string]int{}, Base: []int(nil), Check: []int(nil)}
   563| )
   564| func request_HeadscaleService_ListMachines_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   565| 	var protoReq ListMachinesRequest
   566| 	var metadata runtime.ServerMetadata
   567| 	if err := req.ParseForm(); err != nil {
   568| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   569| 	}
   570| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListMachines_0); err != nil {
   571| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   572| 	}
   573| 	msg, err := client.ListMachines(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   574| 	return msg, metadata, err
   575| }
   576| func local_request_HeadscaleService_ListMachines_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   577| 	var protoReq ListMachinesRequest
   578| 	var metadata runtime.ServerMetadata
   579| 	if err := req.ParseForm(); err != nil {
   580| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   581| 	}
   582| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_ListMachines_0); err != nil {
   583| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   584| 	}
   585| 	msg, err := server.ListMachines(ctx, &protoReq)
   586| 	return msg, metadata, err
   587| }
   588| var (
   589| 	filter_HeadscaleService_MoveMachine_0 = &utilities.DoubleArray{Encoding: map[string]int{"machine_id": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
   590| )
   591| func request_HeadscaleService_MoveMachine_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   592| 	var protoReq MoveMachineRequest
   593| 	var metadata runtime.ServerMetadata
   594| 	var (
   595| 		val string
   596| 		ok  bool
   597| 		err error
   598| 		_   = err
   599| 	)
   600| 	val, ok = pathParams["machine_id"]
   601| 	if !ok {
   602| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   603| 	}
   604| 	protoReq.MachineId, err = runtime.Uint64(val)
   605| 	if err != nil {
   606| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   607| 	}
   608| 	if err := req.ParseForm(); err != nil {
   609| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   610| 	}
   611| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_MoveMachine_0); err != nil {
   612| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   613| 	}
   614| 	msg, err := client.MoveMachine(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   615| 	return msg, metadata, err
   616| }
   617| func local_request_HeadscaleService_MoveMachine_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   618| 	var protoReq MoveMachineRequest
   619| 	var metadata runtime.ServerMetadata
   620| 	var (
   621| 		val string
   622| 		ok  bool
   623| 		err error
   624| 		_   = err
   625| 	)
   626| 	val, ok = pathParams["machine_id"]
   627| 	if !ok {
   628| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   629| 	}
   630| 	protoReq.MachineId, err = runtime.Uint64(val)
   631| 	if err != nil {
   632| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   633| 	}
   634| 	if err := req.ParseForm(); err != nil {
   635| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   636| 	}
   637| 	if err := runtime.PopulateQueryParameters(&protoReq, req.Form, filter_HeadscaleService_MoveMachine_0); err != nil {
   638| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   639| 	}
   640| 	msg, err := server.MoveMachine(ctx, &protoReq)
   641| 	return msg, metadata, err
   642| }
   643| func request_HeadscaleService_GetRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   644| 	var protoReq GetRoutesRequest
   645| 	var metadata runtime.ServerMetadata
   646| 	msg, err := client.GetRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   647| 	return msg, metadata, err
   648| }
   649| func local_request_HeadscaleService_GetRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   650| 	var protoReq GetRoutesRequest
   651| 	var metadata runtime.ServerMetadata
   652| 	msg, err := server.GetRoutes(ctx, &protoReq)
   653| 	return msg, metadata, err
   654| }
   655| func request_HeadscaleService_EnableRoute_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   656| 	var protoReq EnableRouteRequest
   657| 	var metadata runtime.ServerMetadata
   658| 	var (
   659| 		val string
   660| 		ok  bool

# --- HUNK 3: Lines 715-792 ---
   715| func local_request_HeadscaleService_DisableRoute_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   716| 	var protoReq DisableRouteRequest
   717| 	var metadata runtime.ServerMetadata
   718| 	var (
   719| 		val string
   720| 		ok  bool
   721| 		err error
   722| 		_   = err
   723| 	)
   724| 	val, ok = pathParams["route_id"]
   725| 	if !ok {
   726| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   727| 	}
   728| 	protoReq.RouteId, err = runtime.Uint64(val)
   729| 	if err != nil {
   730| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   731| 	}
   732| 	msg, err := server.DisableRoute(ctx, &protoReq)
   733| 	return msg, metadata, err
   734| }
   735| func request_HeadscaleService_GetMachineRoutes_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   736| 	var protoReq GetMachineRoutesRequest
   737| 	var metadata runtime.ServerMetadata
   738| 	var (
   739| 		val string
   740| 		ok  bool
   741| 		err error
   742| 		_   = err
   743| 	)
   744| 	val, ok = pathParams["machine_id"]
   745| 	if !ok {
   746| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   747| 	}
   748| 	protoReq.MachineId, err = runtime.Uint64(val)
   749| 	if err != nil {
   750| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   751| 	}
   752| 	msg, err := client.GetMachineRoutes(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   753| 	return msg, metadata, err
   754| }
   755| func local_request_HeadscaleService_GetMachineRoutes_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   756| 	var protoReq GetMachineRoutesRequest
   757| 	var metadata runtime.ServerMetadata
   758| 	var (
   759| 		val string
   760| 		ok  bool
   761| 		err error
   762| 		_   = err
   763| 	)
   764| 	val, ok = pathParams["machine_id"]
   765| 	if !ok {
   766| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "machine_id")
   767| 	}
   768| 	protoReq.MachineId, err = runtime.Uint64(val)
   769| 	if err != nil {
   770| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "machine_id", err)
   771| 	}
   772| 	msg, err := server.GetMachineRoutes(ctx, &protoReq)
   773| 	return msg, metadata, err
   774| }
   775| func request_HeadscaleService_DeleteRoute_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   776| 	var protoReq DeleteRouteRequest
   777| 	var metadata runtime.ServerMetadata
   778| 	var (
   779| 		val string
   780| 		ok  bool
   781| 		err error
   782| 		_   = err
   783| 	)
   784| 	val, ok = pathParams["route_id"]
   785| 	if !ok {
   786| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   787| 	}
   788| 	protoReq.RouteId, err = runtime.Uint64(val)
   789| 	if err != nil {
   790| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   791| 	}
   792| 	msg, err := client.DeleteRoute(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))

# --- HUNK 4: Lines 798-898 ---
   798| 	var (
   799| 		val string
   800| 		ok  bool
   801| 		err error
   802| 		_   = err
   803| 	)
   804| 	val, ok = pathParams["route_id"]
   805| 	if !ok {
   806| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "missing parameter %s", "route_id")
   807| 	}
   808| 	protoReq.RouteId, err = runtime.Uint64(val)
   809| 	if err != nil {
   810| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "type mismatch, parameter: %s, error: %v", "route_id", err)
   811| 	}
   812| 	msg, err := server.DeleteRoute(ctx, &protoReq)
   813| 	return msg, metadata, err
   814| }
   815| func request_HeadscaleService_CreateApiKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   816| 	var protoReq CreateApiKeyRequest
   817| 	var metadata runtime.ServerMetadata
   818| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   819| 	if berr != nil {
   820| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   821| 	}
   822| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   823| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   824| 	}
   825| 	msg, err := client.CreateApiKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   826| 	return msg, metadata, err
   827| }
   828| func local_request_HeadscaleService_CreateApiKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   829| 	var protoReq CreateApiKeyRequest
   830| 	var metadata runtime.ServerMetadata
   831| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   832| 	if berr != nil {
   833| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   834| 	}
   835| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   836| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   837| 	}
   838| 	msg, err := server.CreateApiKey(ctx, &protoReq)
   839| 	return msg, metadata, err
   840| }
   841| func request_HeadscaleService_ExpireApiKey_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   842| 	var protoReq ExpireApiKeyRequest
   843| 	var metadata runtime.ServerMetadata
   844| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   845| 	if berr != nil {
   846| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   847| 	}
   848| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   849| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   850| 	}
   851| 	msg, err := client.ExpireApiKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   852| 	return msg, metadata, err
   853| }
   854| func local_request_HeadscaleService_ExpireApiKey_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   855| 	var protoReq ExpireApiKeyRequest
   856| 	var metadata runtime.ServerMetadata
   857| 	newReader, berr := utilities.IOReaderFactory(req.Body)
   858| 	if berr != nil {
   859| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", berr)
   860| 	}
   861| 	if err := marshaler.NewDecoder(newReader()).Decode(&protoReq); err != nil && err != io.EOF {
   862| 		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
   863| 	}
   864| 	msg, err := server.ExpireApiKey(ctx, &protoReq)
   865| 	return msg, metadata, err
   866| }
   867| func request_HeadscaleService_ListApiKeys_0(ctx context.Context, marshaler runtime.Marshaler, client HeadscaleServiceClient, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   868| 	var protoReq ListApiKeysRequest
   869| 	var metadata runtime.ServerMetadata
   870| 	msg, err := client.ListApiKeys(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
   871| 	return msg, metadata, err
   872| }
   873| func local_request_HeadscaleService_ListApiKeys_0(ctx context.Context, marshaler runtime.Marshaler, server HeadscaleServiceServer, req *http.Request, pathParams map[string]string) (proto.Message, runtime.ServerMetadata, error) {
   874| 	var protoReq ListApiKeysRequest
   875| 	var metadata runtime.ServerMetadata
   876| 	msg, err := server.ListApiKeys(ctx, &protoReq)
   877| 	return msg, metadata, err
   878| }
   879| func RegisterHeadscaleServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server HeadscaleServiceServer) error {
   880| 	mux.Handle("GET", pattern_HeadscaleService_GetUser_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
   881| 		ctx, cancel := context.WithCancel(req.Context())
   882| 		defer cancel()
   883| 		var stream runtime.ServerTransportStream
   884| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
   885| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
   886| 		var err error
   887| 		var annotatedContext context.Context
   888| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetUser", runtime.WithHTTPPathPattern("/api/v1/user/{name}"))
   889| 		if err != nil {
   890| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
   891| 			return
   892| 		}
   893| 		resp, md, err := local_request_HeadscaleService_GetUser_0(annotatedContext, inboundMarshaler, server, req, pathParams)
   894| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
   895| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
   896| 		if err != nil {
   897| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
   898| 			return

# --- HUNK 5: Lines 1036-1272 ---
  1036| 		defer cancel()
  1037| 		var stream runtime.ServerTransportStream
  1038| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1039| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1040| 		var err error
  1041| 		var annotatedContext context.Context
  1042| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListPreAuthKeys", runtime.WithHTTPPathPattern("/api/v1/preauthkey"))
  1043| 		if err != nil {
  1044| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1045| 			return
  1046| 		}
  1047| 		resp, md, err := local_request_HeadscaleService_ListPreAuthKeys_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1048| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1049| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1050| 		if err != nil {
  1051| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1052| 			return
  1053| 		}
  1054| 		forward_HeadscaleService_ListPreAuthKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1055| 	})
  1056| 	mux.Handle("POST", pattern_HeadscaleService_DebugCreateMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1057| 		ctx, cancel := context.WithCancel(req.Context())
  1058| 		defer cancel()
  1059| 		var stream runtime.ServerTransportStream
  1060| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1061| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1062| 		var err error
  1063| 		var annotatedContext context.Context
  1064| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DebugCreateMachine", runtime.WithHTTPPathPattern("/api/v1/debug/machine"))
  1065| 		if err != nil {
  1066| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1067| 			return
  1068| 		}
  1069| 		resp, md, err := local_request_HeadscaleService_DebugCreateMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1070| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1071| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1072| 		if err != nil {
  1073| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1074| 			return
  1075| 		}
  1076| 		forward_HeadscaleService_DebugCreateMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1077| 	})
  1078| 	mux.Handle("GET", pattern_HeadscaleService_GetMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1079| 		ctx, cancel := context.WithCancel(req.Context())
  1080| 		defer cancel()
  1081| 		var stream runtime.ServerTransportStream
  1082| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1083| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1084| 		var err error
  1085| 		var annotatedContext context.Context
  1086| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}"))
  1087| 		if err != nil {
  1088| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1089| 			return
  1090| 		}
  1091| 		resp, md, err := local_request_HeadscaleService_GetMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1092| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1093| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1094| 		if err != nil {
  1095| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1096| 			return
  1097| 		}
  1098| 		forward_HeadscaleService_GetMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1099| 	})
  1100| 	mux.Handle("POST", pattern_HeadscaleService_SetTags_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1101| 		ctx, cancel := context.WithCancel(req.Context())
  1102| 		defer cancel()
  1103| 		var stream runtime.ServerTransportStream
  1104| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1105| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1106| 		var err error
  1107| 		var annotatedContext context.Context
  1108| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetTags", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/tags"))
  1109| 		if err != nil {
  1110| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1111| 			return
  1112| 		}
  1113| 		resp, md, err := local_request_HeadscaleService_SetTags_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1114| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1115| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1116| 		if err != nil {
  1117| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1118| 			return
  1119| 		}
  1120| 		forward_HeadscaleService_SetTags_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1121| 	})
  1122| 	mux.Handle("POST", pattern_HeadscaleService_RegisterMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1123| 		ctx, cancel := context.WithCancel(req.Context())
  1124| 		defer cancel()
  1125| 		var stream runtime.ServerTransportStream
  1126| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1127| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1128| 		var err error
  1129| 		var annotatedContext context.Context
  1130| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RegisterMachine", runtime.WithHTTPPathPattern("/api/v1/machine/register"))
  1131| 		if err != nil {
  1132| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1133| 			return
  1134| 		}
  1135| 		resp, md, err := local_request_HeadscaleService_RegisterMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1136| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1137| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1138| 		if err != nil {
  1139| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1140| 			return
  1141| 		}
  1142| 		forward_HeadscaleService_RegisterMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1143| 	})
  1144| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1145| 		ctx, cancel := context.WithCancel(req.Context())
  1146| 		defer cancel()
  1147| 		var stream runtime.ServerTransportStream
  1148| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1149| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1150| 		var err error
  1151| 		var annotatedContext context.Context
  1152| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}"))
  1153| 		if err != nil {
  1154| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1155| 			return
  1156| 		}
  1157| 		resp, md, err := local_request_HeadscaleService_DeleteMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1158| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1159| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1160| 		if err != nil {
  1161| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1162| 			return
  1163| 		}
  1164| 		forward_HeadscaleService_DeleteMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1165| 	})
  1166| 	mux.Handle("POST", pattern_HeadscaleService_ExpireMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1167| 		ctx, cancel := context.WithCancel(req.Context())
  1168| 		defer cancel()
  1169| 		var stream runtime.ServerTransportStream
  1170| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1171| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1172| 		var err error
  1173| 		var annotatedContext context.Context
  1174| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ExpireMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/expire"))
  1175| 		if err != nil {
  1176| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1177| 			return
  1178| 		}
  1179| 		resp, md, err := local_request_HeadscaleService_ExpireMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1180| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1181| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1182| 		if err != nil {
  1183| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1184| 			return
  1185| 		}
  1186| 		forward_HeadscaleService_ExpireMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1187| 	})
  1188| 	mux.Handle("POST", pattern_HeadscaleService_RenameMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1189| 		ctx, cancel := context.WithCancel(req.Context())
  1190| 		defer cancel()
  1191| 		var stream runtime.ServerTransportStream
  1192| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1193| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1194| 		var err error
  1195| 		var annotatedContext context.Context
  1196| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RenameMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/rename/{new_name}"))
  1197| 		if err != nil {
  1198| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1199| 			return
  1200| 		}
  1201| 		resp, md, err := local_request_HeadscaleService_RenameMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1202| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1203| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1204| 		if err != nil {
  1205| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1206| 			return
  1207| 		}
  1208| 		forward_HeadscaleService_RenameMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1209| 	})
  1210| 	mux.Handle("GET", pattern_HeadscaleService_ListMachines_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1211| 		ctx, cancel := context.WithCancel(req.Context())
  1212| 		defer cancel()
  1213| 		var stream runtime.ServerTransportStream
  1214| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1215| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1216| 		var err error
  1217| 		var annotatedContext context.Context
  1218| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListMachines", runtime.WithHTTPPathPattern("/api/v1/machine"))
  1219| 		if err != nil {
  1220| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1221| 			return
  1222| 		}
  1223| 		resp, md, err := local_request_HeadscaleService_ListMachines_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1224| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1225| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1226| 		if err != nil {
  1227| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1228| 			return
  1229| 		}
  1230| 		forward_HeadscaleService_ListMachines_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1231| 	})
  1232| 	mux.Handle("POST", pattern_HeadscaleService_MoveMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1233| 		ctx, cancel := context.WithCancel(req.Context())
  1234| 		defer cancel()
  1235| 		var stream runtime.ServerTransportStream
  1236| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1237| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1238| 		var err error
  1239| 		var annotatedContext context.Context
  1240| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/MoveMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/user"))
  1241| 		if err != nil {
  1242| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1243| 			return
  1244| 		}
  1245| 		resp, md, err := local_request_HeadscaleService_MoveMachine_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1246| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1247| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1248| 		if err != nil {
  1249| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1250| 			return
  1251| 		}
  1252| 		forward_HeadscaleService_MoveMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1253| 	})
  1254| 	mux.Handle("GET", pattern_HeadscaleService_GetRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1255| 		ctx, cancel := context.WithCancel(req.Context())
  1256| 		defer cancel()
  1257| 		var stream runtime.ServerTransportStream
  1258| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1259| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1260| 		var err error
  1261| 		var annotatedContext context.Context
  1262| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetRoutes", runtime.WithHTTPPathPattern("/api/v1/routes"))
  1263| 		if err != nil {
  1264| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1265| 			return
  1266| 		}
  1267| 		resp, md, err := local_request_HeadscaleService_GetRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1268| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1269| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1270| 		if err != nil {
  1271| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1272| 			return

# --- HUNK 6: Lines 1300-1360 ---
  1300| 		defer cancel()
  1301| 		var stream runtime.ServerTransportStream
  1302| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1303| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1304| 		var err error
  1305| 		var annotatedContext context.Context
  1306| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DisableRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}/disable"))
  1307| 		if err != nil {
  1308| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1309| 			return
  1310| 		}
  1311| 		resp, md, err := local_request_HeadscaleService_DisableRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1312| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1313| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1314| 		if err != nil {
  1315| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1316| 			return
  1317| 		}
  1318| 		forward_HeadscaleService_DisableRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1319| 	})
  1320| 	mux.Handle("GET", pattern_HeadscaleService_GetMachineRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1321| 		ctx, cancel := context.WithCancel(req.Context())
  1322| 		defer cancel()
  1323| 		var stream runtime.ServerTransportStream
  1324| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1325| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1326| 		var err error
  1327| 		var annotatedContext context.Context
  1328| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetMachineRoutes", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/routes"))
  1329| 		if err != nil {
  1330| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1331| 			return
  1332| 		}
  1333| 		resp, md, err := local_request_HeadscaleService_GetMachineRoutes_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1334| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1335| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1336| 		if err != nil {
  1337| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1338| 			return
  1339| 		}
  1340| 		forward_HeadscaleService_GetMachineRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1341| 	})
  1342| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1343| 		ctx, cancel := context.WithCancel(req.Context())
  1344| 		defer cancel()
  1345| 		var stream runtime.ServerTransportStream
  1346| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1347| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1348| 		var err error
  1349| 		var annotatedContext context.Context
  1350| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}"))
  1351| 		if err != nil {
  1352| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1353| 			return
  1354| 		}
  1355| 		resp, md, err := local_request_HeadscaleService_DeleteRoute_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1356| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1357| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1358| 		if err != nil {
  1359| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1360| 			return

# --- HUNK 7: Lines 1410-1467 ---
  1410| 		defer cancel()
  1411| 		var stream runtime.ServerTransportStream
  1412| 		ctx = grpc.NewContextWithServerTransportStream(ctx, &stream)
  1413| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1414| 		var err error
  1415| 		var annotatedContext context.Context
  1416| 		annotatedContext, err = runtime.AnnotateIncomingContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListApiKeys", runtime.WithHTTPPathPattern("/api/v1/apikey"))
  1417| 		if err != nil {
  1418| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1419| 			return
  1420| 		}
  1421| 		resp, md, err := local_request_HeadscaleService_ListApiKeys_0(annotatedContext, inboundMarshaler, server, req, pathParams)
  1422| 		md.HeaderMD, md.TrailerMD = metadata.Join(md.HeaderMD, stream.Header()), metadata.Join(md.TrailerMD, stream.Trailer())
  1423| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1424| 		if err != nil {
  1425| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1426| 			return
  1427| 		}
  1428| 		forward_HeadscaleService_ListApiKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1429| 	})
  1430| 	return nil
  1431| }
  1432| func RegisterHeadscaleServiceHandlerFromEndpoint(ctx context.Context, mux *runtime.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
  1433| 	conn, err := grpc.Dial(endpoint, opts...)
  1434| 	if err != nil {
  1435| 		return err
  1436| 	}
  1437| 	defer func() {
  1438| 		if err != nil {
  1439| 			if cerr := conn.Close(); cerr != nil {
  1440| 				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
  1441| 			}
  1442| 			return
  1443| 		}
  1444| 		go func() {
  1445| 			<-ctx.Done()
  1446| 			if cerr := conn.Close(); cerr != nil {
  1447| 				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
  1448| 			}
  1449| 		}()
  1450| 	}()
  1451| 	return RegisterHeadscaleServiceHandler(ctx, mux, conn)
  1452| }
  1453| func RegisterHeadscaleServiceHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
  1454| 	return RegisterHeadscaleServiceHandlerClient(ctx, mux, NewHeadscaleServiceClient(conn))
  1455| }
  1456| func RegisterHeadscaleServiceHandlerClient(ctx context.Context, mux *runtime.ServeMux, client HeadscaleServiceClient) error {
  1457| 	mux.Handle("GET", pattern_HeadscaleService_GetUser_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1458| 		ctx, cancel := context.WithCancel(req.Context())
  1459| 		defer cancel()
  1460| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1461| 		var err error
  1462| 		var annotatedContext context.Context
  1463| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetUser", runtime.WithHTTPPathPattern("/api/v1/user/{name}"))
  1464| 		if err != nil {
  1465| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1466| 			return
  1467| 		}

# --- HUNK 8: Lines 1589-1798 ---
  1589| 	})
  1590| 	mux.Handle("GET", pattern_HeadscaleService_ListPreAuthKeys_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1591| 		ctx, cancel := context.WithCancel(req.Context())
  1592| 		defer cancel()
  1593| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1594| 		var err error
  1595| 		var annotatedContext context.Context
  1596| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListPreAuthKeys", runtime.WithHTTPPathPattern("/api/v1/preauthkey"))
  1597| 		if err != nil {
  1598| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1599| 			return
  1600| 		}
  1601| 		resp, md, err := request_HeadscaleService_ListPreAuthKeys_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1602| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1603| 		if err != nil {
  1604| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1605| 			return
  1606| 		}
  1607| 		forward_HeadscaleService_ListPreAuthKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1608| 	})
  1609| 	mux.Handle("POST", pattern_HeadscaleService_DebugCreateMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1610| 		ctx, cancel := context.WithCancel(req.Context())
  1611| 		defer cancel()
  1612| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1613| 		var err error
  1614| 		var annotatedContext context.Context
  1615| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DebugCreateMachine", runtime.WithHTTPPathPattern("/api/v1/debug/machine"))
  1616| 		if err != nil {
  1617| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1618| 			return
  1619| 		}
  1620| 		resp, md, err := request_HeadscaleService_DebugCreateMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1621| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1622| 		if err != nil {
  1623| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1624| 			return
  1625| 		}
  1626| 		forward_HeadscaleService_DebugCreateMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1627| 	})
  1628| 	mux.Handle("GET", pattern_HeadscaleService_GetMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1629| 		ctx, cancel := context.WithCancel(req.Context())
  1630| 		defer cancel()
  1631| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1632| 		var err error
  1633| 		var annotatedContext context.Context
  1634| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}"))
  1635| 		if err != nil {
  1636| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1637| 			return
  1638| 		}
  1639| 		resp, md, err := request_HeadscaleService_GetMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1640| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1641| 		if err != nil {
  1642| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1643| 			return
  1644| 		}
  1645| 		forward_HeadscaleService_GetMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1646| 	})
  1647| 	mux.Handle("POST", pattern_HeadscaleService_SetTags_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1648| 		ctx, cancel := context.WithCancel(req.Context())
  1649| 		defer cancel()
  1650| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1651| 		var err error
  1652| 		var annotatedContext context.Context
  1653| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/SetTags", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/tags"))
  1654| 		if err != nil {
  1655| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1656| 			return
  1657| 		}
  1658| 		resp, md, err := request_HeadscaleService_SetTags_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1659| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1660| 		if err != nil {
  1661| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1662| 			return
  1663| 		}
  1664| 		forward_HeadscaleService_SetTags_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1665| 	})
  1666| 	mux.Handle("POST", pattern_HeadscaleService_RegisterMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1667| 		ctx, cancel := context.WithCancel(req.Context())
  1668| 		defer cancel()
  1669| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1670| 		var err error
  1671| 		var annotatedContext context.Context
  1672| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RegisterMachine", runtime.WithHTTPPathPattern("/api/v1/machine/register"))
  1673| 		if err != nil {
  1674| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1675| 			return
  1676| 		}
  1677| 		resp, md, err := request_HeadscaleService_RegisterMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1678| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1679| 		if err != nil {
  1680| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1681| 			return
  1682| 		}
  1683| 		forward_HeadscaleService_RegisterMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1684| 	})
  1685| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1686| 		ctx, cancel := context.WithCancel(req.Context())
  1687| 		defer cancel()
  1688| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1689| 		var err error
  1690| 		var annotatedContext context.Context
  1691| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}"))
  1692| 		if err != nil {
  1693| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1694| 			return
  1695| 		}
  1696| 		resp, md, err := request_HeadscaleService_DeleteMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1697| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1698| 		if err != nil {
  1699| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1700| 			return
  1701| 		}
  1702| 		forward_HeadscaleService_DeleteMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1703| 	})
  1704| 	mux.Handle("POST", pattern_HeadscaleService_ExpireMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1705| 		ctx, cancel := context.WithCancel(req.Context())
  1706| 		defer cancel()
  1707| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1708| 		var err error
  1709| 		var annotatedContext context.Context
  1710| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ExpireMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/expire"))
  1711| 		if err != nil {
  1712| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1713| 			return
  1714| 		}
  1715| 		resp, md, err := request_HeadscaleService_ExpireMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1716| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1717| 		if err != nil {
  1718| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1719| 			return
  1720| 		}
  1721| 		forward_HeadscaleService_ExpireMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1722| 	})
  1723| 	mux.Handle("POST", pattern_HeadscaleService_RenameMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1724| 		ctx, cancel := context.WithCancel(req.Context())
  1725| 		defer cancel()
  1726| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1727| 		var err error
  1728| 		var annotatedContext context.Context
  1729| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/RenameMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/rename/{new_name}"))
  1730| 		if err != nil {
  1731| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1732| 			return
  1733| 		}
  1734| 		resp, md, err := request_HeadscaleService_RenameMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1735| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1736| 		if err != nil {
  1737| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1738| 			return
  1739| 		}
  1740| 		forward_HeadscaleService_RenameMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1741| 	})
  1742| 	mux.Handle("GET", pattern_HeadscaleService_ListMachines_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1743| 		ctx, cancel := context.WithCancel(req.Context())
  1744| 		defer cancel()
  1745| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1746| 		var err error
  1747| 		var annotatedContext context.Context
  1748| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListMachines", runtime.WithHTTPPathPattern("/api/v1/machine"))
  1749| 		if err != nil {
  1750| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1751| 			return
  1752| 		}
  1753| 		resp, md, err := request_HeadscaleService_ListMachines_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1754| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1755| 		if err != nil {
  1756| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1757| 			return
  1758| 		}
  1759| 		forward_HeadscaleService_ListMachines_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1760| 	})
  1761| 	mux.Handle("POST", pattern_HeadscaleService_MoveMachine_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1762| 		ctx, cancel := context.WithCancel(req.Context())
  1763| 		defer cancel()
  1764| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1765| 		var err error
  1766| 		var annotatedContext context.Context
  1767| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/MoveMachine", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/user"))
  1768| 		if err != nil {
  1769| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1770| 			return
  1771| 		}
  1772| 		resp, md, err := request_HeadscaleService_MoveMachine_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1773| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1774| 		if err != nil {
  1775| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1776| 			return
  1777| 		}
  1778| 		forward_HeadscaleService_MoveMachine_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1779| 	})
  1780| 	mux.Handle("GET", pattern_HeadscaleService_GetRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1781| 		ctx, cancel := context.WithCancel(req.Context())
  1782| 		defer cancel()
  1783| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1784| 		var err error
  1785| 		var annotatedContext context.Context
  1786| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetRoutes", runtime.WithHTTPPathPattern("/api/v1/routes"))
  1787| 		if err != nil {
  1788| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1789| 			return
  1790| 		}
  1791| 		resp, md, err := request_HeadscaleService_GetRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1792| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1793| 		if err != nil {
  1794| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1795| 			return
  1796| 		}
  1797| 		forward_HeadscaleService_GetRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1798| 	})

# --- HUNK 9: Lines 1817-1874 ---
  1817| 	})
  1818| 	mux.Handle("POST", pattern_HeadscaleService_DisableRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1819| 		ctx, cancel := context.WithCancel(req.Context())
  1820| 		defer cancel()
  1821| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1822| 		var err error
  1823| 		var annotatedContext context.Context
  1824| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DisableRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}/disable"))
  1825| 		if err != nil {
  1826| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1827| 			return
  1828| 		}
  1829| 		resp, md, err := request_HeadscaleService_DisableRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1830| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1831| 		if err != nil {
  1832| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1833| 			return
  1834| 		}
  1835| 		forward_HeadscaleService_DisableRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1836| 	})
  1837| 	mux.Handle("GET", pattern_HeadscaleService_GetMachineRoutes_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1838| 		ctx, cancel := context.WithCancel(req.Context())
  1839| 		defer cancel()
  1840| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1841| 		var err error
  1842| 		var annotatedContext context.Context
  1843| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/GetMachineRoutes", runtime.WithHTTPPathPattern("/api/v1/machine/{machine_id}/routes"))
  1844| 		if err != nil {
  1845| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1846| 			return
  1847| 		}
  1848| 		resp, md, err := request_HeadscaleService_GetMachineRoutes_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1849| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1850| 		if err != nil {
  1851| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1852| 			return
  1853| 		}
  1854| 		forward_HeadscaleService_GetMachineRoutes_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1855| 	})
  1856| 	mux.Handle("DELETE", pattern_HeadscaleService_DeleteRoute_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1857| 		ctx, cancel := context.WithCancel(req.Context())
  1858| 		defer cancel()
  1859| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1860| 		var err error
  1861| 		var annotatedContext context.Context
  1862| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/DeleteRoute", runtime.WithHTTPPathPattern("/api/v1/routes/{route_id}"))
  1863| 		if err != nil {
  1864| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1865| 			return
  1866| 		}
  1867| 		resp, md, err := request_HeadscaleService_DeleteRoute_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1868| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1869| 		if err != nil {
  1870| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1871| 			return
  1872| 		}
  1873| 		forward_HeadscaleService_DeleteRoute_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1874| 	})

# --- HUNK 10: Lines 1911-1987 ---
  1911| 		forward_HeadscaleService_ExpireApiKey_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1912| 	})
  1913| 	mux.Handle("GET", pattern_HeadscaleService_ListApiKeys_0, func(w http.ResponseWriter, req *http.Request, pathParams map[string]string) {
  1914| 		ctx, cancel := context.WithCancel(req.Context())
  1915| 		defer cancel()
  1916| 		inboundMarshaler, outboundMarshaler := runtime.MarshalerForRequest(mux, req)
  1917| 		var err error
  1918| 		var annotatedContext context.Context
  1919| 		annotatedContext, err = runtime.AnnotateContext(ctx, mux, req, "/headscale.v1.HeadscaleService/ListApiKeys", runtime.WithHTTPPathPattern("/api/v1/apikey"))
  1920| 		if err != nil {
  1921| 			runtime.HTTPError(ctx, mux, outboundMarshaler, w, req, err)
  1922| 			return
  1923| 		}
  1924| 		resp, md, err := request_HeadscaleService_ListApiKeys_0(annotatedContext, inboundMarshaler, client, req, pathParams)
  1925| 		annotatedContext = runtime.NewServerMetadataContext(annotatedContext, md)
  1926| 		if err != nil {
  1927| 			runtime.HTTPError(annotatedContext, mux, outboundMarshaler, w, req, err)
  1928| 			return
  1929| 		}
  1930| 		forward_HeadscaleService_ListApiKeys_0(annotatedContext, mux, outboundMarshaler, w, req, resp, mux.GetForwardResponseOptions()...)
  1931| 	})
  1932| 	return nil
  1933| }
  1934| var (
  1935| 	pattern_HeadscaleService_GetUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "user", "name"}, ""))
  1936| 	pattern_HeadscaleService_CreateUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "user"}, ""))
  1937| 	pattern_HeadscaleService_RenameUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4, 1, 0, 4, 1, 5, 5}, []string{"api", "v1", "user", "old_name", "rename", "new_name"}, ""))
  1938| 	pattern_HeadscaleService_DeleteUser_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "user", "name"}, ""))
  1939| 	pattern_HeadscaleService_ListUsers_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "user"}, ""))
  1940| 	pattern_HeadscaleService_CreatePreAuthKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "preauthkey"}, ""))
  1941| 	pattern_HeadscaleService_ExpirePreAuthKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "preauthkey", "expire"}, ""))
  1942| 	pattern_HeadscaleService_ListPreAuthKeys_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "preauthkey"}, ""))
  1943| 	pattern_HeadscaleService_DebugCreateMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "debug", "machine"}, ""))
  1944| 	pattern_HeadscaleService_GetMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "machine", "machine_id"}, ""))
  1945| 	pattern_HeadscaleService_SetTags_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "machine", "machine_id", "tags"}, ""))
  1946| 	pattern_HeadscaleService_RegisterMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "machine", "register"}, ""))
  1947| 	pattern_HeadscaleService_DeleteMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "machine", "machine_id"}, ""))
  1948| 	pattern_HeadscaleService_ExpireMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "machine", "machine_id", "expire"}, ""))
  1949| 	pattern_HeadscaleService_RenameMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4, 1, 0, 4, 1, 5, 5}, []string{"api", "v1", "machine", "machine_id", "rename", "new_name"}, ""))
  1950| 	pattern_HeadscaleService_ListMachines_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "machine"}, ""))
  1951| 	pattern_HeadscaleService_MoveMachine_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "machine", "machine_id", "user"}, ""))
  1952| 	pattern_HeadscaleService_GetRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "routes"}, ""))
  1953| 	pattern_HeadscaleService_EnableRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "routes", "route_id", "enable"}, ""))
  1954| 	pattern_HeadscaleService_DisableRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "routes", "route_id", "disable"}, ""))
  1955| 	pattern_HeadscaleService_GetMachineRoutes_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3, 2, 4}, []string{"api", "v1", "machine", "machine_id", "routes"}, ""))
  1956| 	pattern_HeadscaleService_DeleteRoute_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 1, 0, 4, 1, 5, 3}, []string{"api", "v1", "routes", "route_id"}, ""))
  1957| 	pattern_HeadscaleService_CreateApiKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "apikey"}, ""))
  1958| 	pattern_HeadscaleService_ExpireApiKey_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2, 2, 3}, []string{"api", "v1", "apikey", "expire"}, ""))
  1959| 	pattern_HeadscaleService_ListApiKeys_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"api", "v1", "apikey"}, ""))
  1960| )
  1961| var (
  1962| 	forward_HeadscaleService_GetUser_0 = runtime.ForwardResponseMessage
  1963| 	forward_HeadscaleService_CreateUser_0 = runtime.ForwardResponseMessage
  1964| 	forward_HeadscaleService_RenameUser_0 = runtime.ForwardResponseMessage
  1965| 	forward_HeadscaleService_DeleteUser_0 = runtime.ForwardResponseMessage
  1966| 	forward_HeadscaleService_ListUsers_0 = runtime.ForwardResponseMessage
  1967| 	forward_HeadscaleService_CreatePreAuthKey_0 = runtime.ForwardResponseMessage
  1968| 	forward_HeadscaleService_ExpirePreAuthKey_0 = runtime.ForwardResponseMessage
  1969| 	forward_HeadscaleService_ListPreAuthKeys_0 = runtime.ForwardResponseMessage
  1970| 	forward_HeadscaleService_DebugCreateMachine_0 = runtime.ForwardResponseMessage
  1971| 	forward_HeadscaleService_GetMachine_0 = runtime.ForwardResponseMessage
  1972| 	forward_HeadscaleService_SetTags_0 = runtime.ForwardResponseMessage
  1973| 	forward_HeadscaleService_RegisterMachine_0 = runtime.ForwardResponseMessage
  1974| 	forward_HeadscaleService_DeleteMachine_0 = runtime.ForwardResponseMessage
  1975| 	forward_HeadscaleService_ExpireMachine_0 = runtime.ForwardResponseMessage
  1976| 	forward_HeadscaleService_RenameMachine_0 = runtime.ForwardResponseMessage
  1977| 	forward_HeadscaleService_ListMachines_0 = runtime.ForwardResponseMessage
  1978| 	forward_HeadscaleService_MoveMachine_0 = runtime.ForwardResponseMessage
  1979| 	forward_HeadscaleService_GetRoutes_0 = runtime.ForwardResponseMessage
  1980| 	forward_HeadscaleService_EnableRoute_0 = runtime.ForwardResponseMessage
  1981| 	forward_HeadscaleService_DisableRoute_0 = runtime.ForwardResponseMessage
  1982| 	forward_HeadscaleService_GetMachineRoutes_0 = runtime.ForwardResponseMessage
  1983| 	forward_HeadscaleService_DeleteRoute_0 = runtime.ForwardResponseMessage
  1984| 	forward_HeadscaleService_CreateApiKey_0 = runtime.ForwardResponseMessage
  1985| 	forward_HeadscaleService_ExpireApiKey_0 = runtime.ForwardResponseMessage
  1986| 	forward_HeadscaleService_ListApiKeys_0 = runtime.ForwardResponseMessage
  1987| )


# ====================================================================
# FILE: gen/go/headscale/v1/headscale_grpc.pb.go
# Total hunks: 9
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| package v1
     2| import (
     3| 	context "context"
     4| 	grpc "google.golang.org/grpc"
     5| 	codes "google.golang.org/grpc/codes"
     6| 	status "google.golang.org/grpc/status"
     7| )
     8| const _ = grpc.SupportPackageIsVersion7
     9| const (
    10| 	HeadscaleService_GetUser_FullMethodName            = "/headscale.v1.HeadscaleService/GetUser"
    11| 	HeadscaleService_CreateUser_FullMethodName         = "/headscale.v1.HeadscaleService/CreateUser"
    12| 	HeadscaleService_RenameUser_FullMethodName         = "/headscale.v1.HeadscaleService/RenameUser"
    13| 	HeadscaleService_DeleteUser_FullMethodName         = "/headscale.v1.HeadscaleService/DeleteUser"
    14| 	HeadscaleService_ListUsers_FullMethodName          = "/headscale.v1.HeadscaleService/ListUsers"
    15| 	HeadscaleService_CreatePreAuthKey_FullMethodName   = "/headscale.v1.HeadscaleService/CreatePreAuthKey"
    16| 	HeadscaleService_ExpirePreAuthKey_FullMethodName   = "/headscale.v1.HeadscaleService/ExpirePreAuthKey"
    17| 	HeadscaleService_ListPreAuthKeys_FullMethodName    = "/headscale.v1.HeadscaleService/ListPreAuthKeys"
    18| 	HeadscaleService_DebugCreateMachine_FullMethodName = "/headscale.v1.HeadscaleService/DebugCreateMachine"
    19| 	HeadscaleService_GetMachine_FullMethodName         = "/headscale.v1.HeadscaleService/GetMachine"
    20| 	HeadscaleService_SetTags_FullMethodName            = "/headscale.v1.HeadscaleService/SetTags"
    21| 	HeadscaleService_RegisterMachine_FullMethodName    = "/headscale.v1.HeadscaleService/RegisterMachine"
    22| 	HeadscaleService_DeleteMachine_FullMethodName      = "/headscale.v1.HeadscaleService/DeleteMachine"
    23| 	HeadscaleService_ExpireMachine_FullMethodName      = "/headscale.v1.HeadscaleService/ExpireMachine"
    24| 	HeadscaleService_RenameMachine_FullMethodName      = "/headscale.v1.HeadscaleService/RenameMachine"
    25| 	HeadscaleService_ListMachines_FullMethodName       = "/headscale.v1.HeadscaleService/ListMachines"
    26| 	HeadscaleService_MoveMachine_FullMethodName        = "/headscale.v1.HeadscaleService/MoveMachine"
    27| 	HeadscaleService_GetRoutes_FullMethodName          = "/headscale.v1.HeadscaleService/GetRoutes"
    28| 	HeadscaleService_EnableRoute_FullMethodName        = "/headscale.v1.HeadscaleService/EnableRoute"
    29| 	HeadscaleService_DisableRoute_FullMethodName       = "/headscale.v1.HeadscaleService/DisableRoute"
    30| 	HeadscaleService_GetMachineRoutes_FullMethodName   = "/headscale.v1.HeadscaleService/GetMachineRoutes"
    31| 	HeadscaleService_DeleteRoute_FullMethodName        = "/headscale.v1.HeadscaleService/DeleteRoute"
    32| 	HeadscaleService_CreateApiKey_FullMethodName       = "/headscale.v1.HeadscaleService/CreateApiKey"
    33| 	HeadscaleService_ExpireApiKey_FullMethodName       = "/headscale.v1.HeadscaleService/ExpireApiKey"
    34| 	HeadscaleService_ListApiKeys_FullMethodName        = "/headscale.v1.HeadscaleService/ListApiKeys"
    35| )
    36| type HeadscaleServiceClient interface {
    37| 	GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error)
    38| 	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error)
    39| 	RenameUser(ctx context.Context, in *RenameUserRequest, opts ...grpc.CallOption) (*RenameUserResponse, error)
    40| 	DeleteUser(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*DeleteUserResponse, error)
    41| 	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
    42| 	CreatePreAuthKey(ctx context.Context, in *CreatePreAuthKeyRequest, opts ...grpc.CallOption) (*CreatePreAuthKeyResponse, error)
    43| 	ExpirePreAuthKey(ctx context.Context, in *ExpirePreAuthKeyRequest, opts ...grpc.CallOption) (*ExpirePreAuthKeyResponse, error)
    44| 	ListPreAuthKeys(ctx context.Context, in *ListPreAuthKeysRequest, opts ...grpc.CallOption) (*ListPreAuthKeysResponse, error)
    45| 	DebugCreateMachine(ctx context.Context, in *DebugCreateMachineRequest, opts ...grpc.CallOption) (*DebugCreateMachineResponse, error)
    46| 	GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error)
    47| 	SetTags(ctx context.Context, in *SetTagsRequest, opts ...grpc.CallOption) (*SetTagsResponse, error)
    48| 	RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*RegisterMachineResponse, error)
    49| 	DeleteMachine(ctx context.Context, in *DeleteMachineRequest, opts ...grpc.CallOption) (*DeleteMachineResponse, error)
    50| 	ExpireMachine(ctx context.Context, in *ExpireMachineRequest, opts ...grpc.CallOption) (*ExpireMachineResponse, error)
    51| 	RenameMachine(ctx context.Context, in *RenameMachineRequest, opts ...grpc.CallOption) (*RenameMachineResponse, error)
    52| 	ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error)
    53| 	MoveMachine(ctx context.Context, in *MoveMachineRequest, opts ...grpc.CallOption) (*MoveMachineResponse, error)
    54| 	GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (*GetRoutesResponse, error)
    55| 	EnableRoute(ctx context.Context, in *EnableRouteRequest, opts ...grpc.CallOption) (*EnableRouteResponse, error)
    56| 	DisableRoute(ctx context.Context, in *DisableRouteRequest, opts ...grpc.CallOption) (*DisableRouteResponse, error)
    57| 	GetMachineRoutes(ctx context.Context, in *GetMachineRoutesRequest, opts ...grpc.CallOption) (*GetMachineRoutesResponse, error)
    58| 	DeleteRoute(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*DeleteRouteResponse, error)
    59| 	CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error)
    60| 	ExpireApiKey(ctx context.Context, in *ExpireApiKeyRequest, opts ...grpc.CallOption) (*ExpireApiKeyResponse, error)
    61| 	ListApiKeys(ctx context.Context, in *ListApiKeysRequest, opts ...grpc.CallOption) (*ListApiKeysResponse, error)
    62| }
    63| type headscaleServiceClient struct {
    64| 	cc grpc.ClientConnInterface
    65| }
    66| func NewHeadscaleServiceClient(cc grpc.ClientConnInterface) HeadscaleServiceClient {
    67| 	return &headscaleServiceClient{cc}
    68| }
    69| func (c *headscaleServiceClient) GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) {
    70| 	out := new(GetUserResponse)
    71| 	err := c.cc.Invoke(ctx, HeadscaleService_GetUser_FullMethodName, in, out, opts...)
    72| 	if err != nil {
    73| 		return nil, err
    74| 	}
    75| 	return out, nil
    76| }
    77| func (c *headscaleServiceClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*CreateUserResponse, error) {
    78| 	out := new(CreateUserResponse)
    79| 	err := c.cc.Invoke(ctx, HeadscaleService_CreateUser_FullMethodName, in, out, opts...)
    80| 	if err != nil {
    81| 		return nil, err

# --- HUNK 2: Lines 113-392 ---
   113| 		return nil, err
   114| 	}
   115| 	return out, nil
   116| }
   117| func (c *headscaleServiceClient) ExpirePreAuthKey(ctx context.Context, in *ExpirePreAuthKeyRequest, opts ...grpc.CallOption) (*ExpirePreAuthKeyResponse, error) {
   118| 	out := new(ExpirePreAuthKeyResponse)
   119| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpirePreAuthKey_FullMethodName, in, out, opts...)
   120| 	if err != nil {
   121| 		return nil, err
   122| 	}
   123| 	return out, nil
   124| }
   125| func (c *headscaleServiceClient) ListPreAuthKeys(ctx context.Context, in *ListPreAuthKeysRequest, opts ...grpc.CallOption) (*ListPreAuthKeysResponse, error) {
   126| 	out := new(ListPreAuthKeysResponse)
   127| 	err := c.cc.Invoke(ctx, HeadscaleService_ListPreAuthKeys_FullMethodName, in, out, opts...)
   128| 	if err != nil {
   129| 		return nil, err
   130| 	}
   131| 	return out, nil
   132| }
   133| func (c *headscaleServiceClient) DebugCreateMachine(ctx context.Context, in *DebugCreateMachineRequest, opts ...grpc.CallOption) (*DebugCreateMachineResponse, error) {
   134| 	out := new(DebugCreateMachineResponse)
   135| 	err := c.cc.Invoke(ctx, HeadscaleService_DebugCreateMachine_FullMethodName, in, out, opts...)
   136| 	if err != nil {
   137| 		return nil, err
   138| 	}
   139| 	return out, nil
   140| }
   141| func (c *headscaleServiceClient) GetMachine(ctx context.Context, in *GetMachineRequest, opts ...grpc.CallOption) (*GetMachineResponse, error) {
   142| 	out := new(GetMachineResponse)
   143| 	err := c.cc.Invoke(ctx, HeadscaleService_GetMachine_FullMethodName, in, out, opts...)
   144| 	if err != nil {
   145| 		return nil, err
   146| 	}
   147| 	return out, nil
   148| }
   149| func (c *headscaleServiceClient) SetTags(ctx context.Context, in *SetTagsRequest, opts ...grpc.CallOption) (*SetTagsResponse, error) {
   150| 	out := new(SetTagsResponse)
   151| 	err := c.cc.Invoke(ctx, HeadscaleService_SetTags_FullMethodName, in, out, opts...)
   152| 	if err != nil {
   153| 		return nil, err
   154| 	}
   155| 	return out, nil
   156| }
   157| func (c *headscaleServiceClient) RegisterMachine(ctx context.Context, in *RegisterMachineRequest, opts ...grpc.CallOption) (*RegisterMachineResponse, error) {
   158| 	out := new(RegisterMachineResponse)
   159| 	err := c.cc.Invoke(ctx, HeadscaleService_RegisterMachine_FullMethodName, in, out, opts...)
   160| 	if err != nil {
   161| 		return nil, err
   162| 	}
   163| 	return out, nil
   164| }
   165| func (c *headscaleServiceClient) DeleteMachine(ctx context.Context, in *DeleteMachineRequest, opts ...grpc.CallOption) (*DeleteMachineResponse, error) {
   166| 	out := new(DeleteMachineResponse)
   167| 	err := c.cc.Invoke(ctx, HeadscaleService_DeleteMachine_FullMethodName, in, out, opts...)
   168| 	if err != nil {
   169| 		return nil, err
   170| 	}
   171| 	return out, nil
   172| }
   173| func (c *headscaleServiceClient) ExpireMachine(ctx context.Context, in *ExpireMachineRequest, opts ...grpc.CallOption) (*ExpireMachineResponse, error) {
   174| 	out := new(ExpireMachineResponse)
   175| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpireMachine_FullMethodName, in, out, opts...)
   176| 	if err != nil {
   177| 		return nil, err
   178| 	}
   179| 	return out, nil
   180| }
   181| func (c *headscaleServiceClient) RenameMachine(ctx context.Context, in *RenameMachineRequest, opts ...grpc.CallOption) (*RenameMachineResponse, error) {
   182| 	out := new(RenameMachineResponse)
   183| 	err := c.cc.Invoke(ctx, HeadscaleService_RenameMachine_FullMethodName, in, out, opts...)
   184| 	if err != nil {
   185| 		return nil, err
   186| 	}
   187| 	return out, nil
   188| }
   189| func (c *headscaleServiceClient) ListMachines(ctx context.Context, in *ListMachinesRequest, opts ...grpc.CallOption) (*ListMachinesResponse, error) {
   190| 	out := new(ListMachinesResponse)
   191| 	err := c.cc.Invoke(ctx, HeadscaleService_ListMachines_FullMethodName, in, out, opts...)
   192| 	if err != nil {
   193| 		return nil, err
   194| 	}
   195| 	return out, nil
   196| }
   197| func (c *headscaleServiceClient) MoveMachine(ctx context.Context, in *MoveMachineRequest, opts ...grpc.CallOption) (*MoveMachineResponse, error) {
   198| 	out := new(MoveMachineResponse)
   199| 	err := c.cc.Invoke(ctx, HeadscaleService_MoveMachine_FullMethodName, in, out, opts...)
   200| 	if err != nil {
   201| 		return nil, err
   202| 	}
   203| 	return out, nil
   204| }
   205| func (c *headscaleServiceClient) GetRoutes(ctx context.Context, in *GetRoutesRequest, opts ...grpc.CallOption) (*GetRoutesResponse, error) {
   206| 	out := new(GetRoutesResponse)
   207| 	err := c.cc.Invoke(ctx, HeadscaleService_GetRoutes_FullMethodName, in, out, opts...)
   208| 	if err != nil {
   209| 		return nil, err
   210| 	}
   211| 	return out, nil
   212| }
   213| func (c *headscaleServiceClient) EnableRoute(ctx context.Context, in *EnableRouteRequest, opts ...grpc.CallOption) (*EnableRouteResponse, error) {
   214| 	out := new(EnableRouteResponse)
   215| 	err := c.cc.Invoke(ctx, HeadscaleService_EnableRoute_FullMethodName, in, out, opts...)
   216| 	if err != nil {
   217| 		return nil, err
   218| 	}
   219| 	return out, nil
   220| }
   221| func (c *headscaleServiceClient) DisableRoute(ctx context.Context, in *DisableRouteRequest, opts ...grpc.CallOption) (*DisableRouteResponse, error) {
   222| 	out := new(DisableRouteResponse)
   223| 	err := c.cc.Invoke(ctx, HeadscaleService_DisableRoute_FullMethodName, in, out, opts...)
   224| 	if err != nil {
   225| 		return nil, err
   226| 	}
   227| 	return out, nil
   228| }
   229| func (c *headscaleServiceClient) GetMachineRoutes(ctx context.Context, in *GetMachineRoutesRequest, opts ...grpc.CallOption) (*GetMachineRoutesResponse, error) {
   230| 	out := new(GetMachineRoutesResponse)
   231| 	err := c.cc.Invoke(ctx, HeadscaleService_GetMachineRoutes_FullMethodName, in, out, opts...)
   232| 	if err != nil {
   233| 		return nil, err
   234| 	}
   235| 	return out, nil
   236| }
   237| func (c *headscaleServiceClient) DeleteRoute(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*DeleteRouteResponse, error) {
   238| 	out := new(DeleteRouteResponse)
   239| 	err := c.cc.Invoke(ctx, HeadscaleService_DeleteRoute_FullMethodName, in, out, opts...)
   240| 	if err != nil {
   241| 		return nil, err
   242| 	}
   243| 	return out, nil
   244| }
   245| func (c *headscaleServiceClient) CreateApiKey(ctx context.Context, in *CreateApiKeyRequest, opts ...grpc.CallOption) (*CreateApiKeyResponse, error) {
   246| 	out := new(CreateApiKeyResponse)
   247| 	err := c.cc.Invoke(ctx, HeadscaleService_CreateApiKey_FullMethodName, in, out, opts...)
   248| 	if err != nil {
   249| 		return nil, err
   250| 	}
   251| 	return out, nil
   252| }
   253| func (c *headscaleServiceClient) ExpireApiKey(ctx context.Context, in *ExpireApiKeyRequest, opts ...grpc.CallOption) (*ExpireApiKeyResponse, error) {
   254| 	out := new(ExpireApiKeyResponse)
   255| 	err := c.cc.Invoke(ctx, HeadscaleService_ExpireApiKey_FullMethodName, in, out, opts...)
   256| 	if err != nil {
   257| 		return nil, err
   258| 	}
   259| 	return out, nil
   260| }
   261| func (c *headscaleServiceClient) ListApiKeys(ctx context.Context, in *ListApiKeysRequest, opts ...grpc.CallOption) (*ListApiKeysResponse, error) {
   262| 	out := new(ListApiKeysResponse)
   263| 	err := c.cc.Invoke(ctx, HeadscaleService_ListApiKeys_FullMethodName, in, out, opts...)
   264| 	if err != nil {
   265| 		return nil, err
   266| 	}
   267| 	return out, nil
   268| }
   269| type HeadscaleServiceServer interface {
   270| 	GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error)
   271| 	CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error)
   272| 	RenameUser(context.Context, *RenameUserRequest) (*RenameUserResponse, error)
   273| 	DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error)
   274| 	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
   275| 	CreatePreAuthKey(context.Context, *CreatePreAuthKeyRequest) (*CreatePreAuthKeyResponse, error)
   276| 	ExpirePreAuthKey(context.Context, *ExpirePreAuthKeyRequest) (*ExpirePreAuthKeyResponse, error)
   277| 	ListPreAuthKeys(context.Context, *ListPreAuthKeysRequest) (*ListPreAuthKeysResponse, error)
   278| 	DebugCreateMachine(context.Context, *DebugCreateMachineRequest) (*DebugCreateMachineResponse, error)
   279| 	GetMachine(context.Context, *GetMachineRequest) (*GetMachineResponse, error)
   280| 	SetTags(context.Context, *SetTagsRequest) (*SetTagsResponse, error)
   281| 	RegisterMachine(context.Context, *RegisterMachineRequest) (*RegisterMachineResponse, error)
   282| 	DeleteMachine(context.Context, *DeleteMachineRequest) (*DeleteMachineResponse, error)
   283| 	ExpireMachine(context.Context, *ExpireMachineRequest) (*ExpireMachineResponse, error)
   284| 	RenameMachine(context.Context, *RenameMachineRequest) (*RenameMachineResponse, error)
   285| 	ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error)
   286| 	MoveMachine(context.Context, *MoveMachineRequest) (*MoveMachineResponse, error)
   287| 	GetRoutes(context.Context, *GetRoutesRequest) (*GetRoutesResponse, error)
   288| 	EnableRoute(context.Context, *EnableRouteRequest) (*EnableRouteResponse, error)
   289| 	DisableRoute(context.Context, *DisableRouteRequest) (*DisableRouteResponse, error)
   290| 	GetMachineRoutes(context.Context, *GetMachineRoutesRequest) (*GetMachineRoutesResponse, error)
   291| 	DeleteRoute(context.Context, *DeleteRouteRequest) (*DeleteRouteResponse, error)
   292| 	CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error)
   293| 	ExpireApiKey(context.Context, *ExpireApiKeyRequest) (*ExpireApiKeyResponse, error)
   294| 	ListApiKeys(context.Context, *ListApiKeysRequest) (*ListApiKeysResponse, error)
   295| 	mustEmbedUnimplementedHeadscaleServiceServer()
   296| }
   297| type UnimplementedHeadscaleServiceServer struct {
   298| }
   299| func (UnimplementedHeadscaleServiceServer) GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) {
   300| 	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
   301| }
   302| func (UnimplementedHeadscaleServiceServer) CreateUser(context.Context, *CreateUserRequest) (*CreateUserResponse, error) {
   303| 	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
   304| }
   305| func (UnimplementedHeadscaleServiceServer) RenameUser(context.Context, *RenameUserRequest) (*RenameUserResponse, error) {
   306| 	return nil, status.Errorf(codes.Unimplemented, "method RenameUser not implemented")
   307| }
   308| func (UnimplementedHeadscaleServiceServer) DeleteUser(context.Context, *DeleteUserRequest) (*DeleteUserResponse, error) {
   309| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
   310| }
   311| func (UnimplementedHeadscaleServiceServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
   312| 	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
   313| }
   314| func (UnimplementedHeadscaleServiceServer) CreatePreAuthKey(context.Context, *CreatePreAuthKeyRequest) (*CreatePreAuthKeyResponse, error) {
   315| 	return nil, status.Errorf(codes.Unimplemented, "method CreatePreAuthKey not implemented")
   316| }
   317| func (UnimplementedHeadscaleServiceServer) ExpirePreAuthKey(context.Context, *ExpirePreAuthKeyRequest) (*ExpirePreAuthKeyResponse, error) {
   318| 	return nil, status.Errorf(codes.Unimplemented, "method ExpirePreAuthKey not implemented")
   319| }
   320| func (UnimplementedHeadscaleServiceServer) ListPreAuthKeys(context.Context, *ListPreAuthKeysRequest) (*ListPreAuthKeysResponse, error) {
   321| 	return nil, status.Errorf(codes.Unimplemented, "method ListPreAuthKeys not implemented")
   322| }
   323| func (UnimplementedHeadscaleServiceServer) DebugCreateMachine(context.Context, *DebugCreateMachineRequest) (*DebugCreateMachineResponse, error) {
   324| 	return nil, status.Errorf(codes.Unimplemented, "method DebugCreateMachine not implemented")
   325| }
   326| func (UnimplementedHeadscaleServiceServer) GetMachine(context.Context, *GetMachineRequest) (*GetMachineResponse, error) {
   327| 	return nil, status.Errorf(codes.Unimplemented, "method GetMachine not implemented")
   328| }
   329| func (UnimplementedHeadscaleServiceServer) SetTags(context.Context, *SetTagsRequest) (*SetTagsResponse, error) {
   330| 	return nil, status.Errorf(codes.Unimplemented, "method SetTags not implemented")
   331| }
   332| func (UnimplementedHeadscaleServiceServer) RegisterMachine(context.Context, *RegisterMachineRequest) (*RegisterMachineResponse, error) {
   333| 	return nil, status.Errorf(codes.Unimplemented, "method RegisterMachine not implemented")
   334| }
   335| func (UnimplementedHeadscaleServiceServer) DeleteMachine(context.Context, *DeleteMachineRequest) (*DeleteMachineResponse, error) {
   336| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteMachine not implemented")
   337| }
   338| func (UnimplementedHeadscaleServiceServer) ExpireMachine(context.Context, *ExpireMachineRequest) (*ExpireMachineResponse, error) {
   339| 	return nil, status.Errorf(codes.Unimplemented, "method ExpireMachine not implemented")
   340| }
   341| func (UnimplementedHeadscaleServiceServer) RenameMachine(context.Context, *RenameMachineRequest) (*RenameMachineResponse, error) {
   342| 	return nil, status.Errorf(codes.Unimplemented, "method RenameMachine not implemented")
   343| }
   344| func (UnimplementedHeadscaleServiceServer) ListMachines(context.Context, *ListMachinesRequest) (*ListMachinesResponse, error) {
   345| 	return nil, status.Errorf(codes.Unimplemented, "method ListMachines not implemented")
   346| }
   347| func (UnimplementedHeadscaleServiceServer) MoveMachine(context.Context, *MoveMachineRequest) (*MoveMachineResponse, error) {
   348| 	return nil, status.Errorf(codes.Unimplemented, "method MoveMachine not implemented")
   349| }
   350| func (UnimplementedHeadscaleServiceServer) GetRoutes(context.Context, *GetRoutesRequest) (*GetRoutesResponse, error) {
   351| 	return nil, status.Errorf(codes.Unimplemented, "method GetRoutes not implemented")
   352| }
   353| func (UnimplementedHeadscaleServiceServer) EnableRoute(context.Context, *EnableRouteRequest) (*EnableRouteResponse, error) {
   354| 	return nil, status.Errorf(codes.Unimplemented, "method EnableRoute not implemented")
   355| }
   356| func (UnimplementedHeadscaleServiceServer) DisableRoute(context.Context, *DisableRouteRequest) (*DisableRouteResponse, error) {
   357| 	return nil, status.Errorf(codes.Unimplemented, "method DisableRoute not implemented")
   358| }
   359| func (UnimplementedHeadscaleServiceServer) GetMachineRoutes(context.Context, *GetMachineRoutesRequest) (*GetMachineRoutesResponse, error) {
   360| 	return nil, status.Errorf(codes.Unimplemented, "method GetMachineRoutes not implemented")
   361| }
   362| func (UnimplementedHeadscaleServiceServer) DeleteRoute(context.Context, *DeleteRouteRequest) (*DeleteRouteResponse, error) {
   363| 	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoute not implemented")
   364| }
   365| func (UnimplementedHeadscaleServiceServer) CreateApiKey(context.Context, *CreateApiKeyRequest) (*CreateApiKeyResponse, error) {
   366| 	return nil, status.Errorf(codes.Unimplemented, "method CreateApiKey not implemented")
   367| }
   368| func (UnimplementedHeadscaleServiceServer) ExpireApiKey(context.Context, *ExpireApiKeyRequest) (*ExpireApiKeyResponse, error) {
   369| 	return nil, status.Errorf(codes.Unimplemented, "method ExpireApiKey not implemented")
   370| }
   371| func (UnimplementedHeadscaleServiceServer) ListApiKeys(context.Context, *ListApiKeysRequest) (*ListApiKeysResponse, error) {
   372| 	return nil, status.Errorf(codes.Unimplemented, "method ListApiKeys not implemented")
   373| }
   374| func (UnimplementedHeadscaleServiceServer) mustEmbedUnimplementedHeadscaleServiceServer() {}
   375| type UnsafeHeadscaleServiceServer interface {
   376| 	mustEmbedUnimplementedHeadscaleServiceServer()
   377| }
   378| func RegisterHeadscaleServiceServer(s grpc.ServiceRegistrar, srv HeadscaleServiceServer) {
   379| 	s.RegisterService(&HeadscaleService_ServiceDesc, srv)
   380| }
   381| func _HeadscaleService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   382| 	in := new(GetUserRequest)
   383| 	if err := dec(in); err != nil {
   384| 		return nil, err
   385| 	}
   386| 	if interceptor == nil {
   387| 		return srv.(HeadscaleServiceServer).GetUser(ctx, in)
   388| 	}
   389| 	info := &grpc.UnaryServerInfo{
   390| 		Server:     srv,
   391| 		FullMethod: HeadscaleService_GetUser_FullMethodName,
   392| 	}

# --- HUNK 3: Lines 497-686 ---
   497| 	}
   498| 	return interceptor(ctx, in, info, handler)
   499| }
   500| func _HeadscaleService_ListPreAuthKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   501| 	in := new(ListPreAuthKeysRequest)
   502| 	if err := dec(in); err != nil {
   503| 		return nil, err
   504| 	}
   505| 	if interceptor == nil {
   506| 		return srv.(HeadscaleServiceServer).ListPreAuthKeys(ctx, in)
   507| 	}
   508| 	info := &grpc.UnaryServerInfo{
   509| 		Server:     srv,
   510| 		FullMethod: HeadscaleService_ListPreAuthKeys_FullMethodName,
   511| 	}
   512| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   513| 		return srv.(HeadscaleServiceServer).ListPreAuthKeys(ctx, req.(*ListPreAuthKeysRequest))
   514| 	}
   515| 	return interceptor(ctx, in, info, handler)
   516| }
   517| func _HeadscaleService_DebugCreateMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   518| 	in := new(DebugCreateMachineRequest)
   519| 	if err := dec(in); err != nil {
   520| 		return nil, err
   521| 	}
   522| 	if interceptor == nil {
   523| 		return srv.(HeadscaleServiceServer).DebugCreateMachine(ctx, in)
   524| 	}
   525| 	info := &grpc.UnaryServerInfo{
   526| 		Server:     srv,
   527| 		FullMethod: HeadscaleService_DebugCreateMachine_FullMethodName,
   528| 	}
   529| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   530| 		return srv.(HeadscaleServiceServer).DebugCreateMachine(ctx, req.(*DebugCreateMachineRequest))
   531| 	}
   532| 	return interceptor(ctx, in, info, handler)
   533| }
   534| func _HeadscaleService_GetMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   535| 	in := new(GetMachineRequest)
   536| 	if err := dec(in); err != nil {
   537| 		return nil, err
   538| 	}
   539| 	if interceptor == nil {
   540| 		return srv.(HeadscaleServiceServer).GetMachine(ctx, in)
   541| 	}
   542| 	info := &grpc.UnaryServerInfo{
   543| 		Server:     srv,
   544| 		FullMethod: HeadscaleService_GetMachine_FullMethodName,
   545| 	}
   546| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   547| 		return srv.(HeadscaleServiceServer).GetMachine(ctx, req.(*GetMachineRequest))
   548| 	}
   549| 	return interceptor(ctx, in, info, handler)
   550| }
   551| func _HeadscaleService_SetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   552| 	in := new(SetTagsRequest)
   553| 	if err := dec(in); err != nil {
   554| 		return nil, err
   555| 	}
   556| 	if interceptor == nil {
   557| 		return srv.(HeadscaleServiceServer).SetTags(ctx, in)
   558| 	}
   559| 	info := &grpc.UnaryServerInfo{
   560| 		Server:     srv,
   561| 		FullMethod: HeadscaleService_SetTags_FullMethodName,
   562| 	}
   563| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   564| 		return srv.(HeadscaleServiceServer).SetTags(ctx, req.(*SetTagsRequest))
   565| 	}
   566| 	return interceptor(ctx, in, info, handler)
   567| }
   568| func _HeadscaleService_RegisterMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   569| 	in := new(RegisterMachineRequest)
   570| 	if err := dec(in); err != nil {
   571| 		return nil, err
   572| 	}
   573| 	if interceptor == nil {
   574| 		return srv.(HeadscaleServiceServer).RegisterMachine(ctx, in)
   575| 	}
   576| 	info := &grpc.UnaryServerInfo{
   577| 		Server:     srv,
   578| 		FullMethod: HeadscaleService_RegisterMachine_FullMethodName,
   579| 	}
   580| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   581| 		return srv.(HeadscaleServiceServer).RegisterMachine(ctx, req.(*RegisterMachineRequest))
   582| 	}
   583| 	return interceptor(ctx, in, info, handler)
   584| }
   585| func _HeadscaleService_DeleteMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   586| 	in := new(DeleteMachineRequest)
   587| 	if err := dec(in); err != nil {
   588| 		return nil, err
   589| 	}
   590| 	if interceptor == nil {
   591| 		return srv.(HeadscaleServiceServer).DeleteMachine(ctx, in)
   592| 	}
   593| 	info := &grpc.UnaryServerInfo{
   594| 		Server:     srv,
   595| 		FullMethod: HeadscaleService_DeleteMachine_FullMethodName,
   596| 	}
   597| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   598| 		return srv.(HeadscaleServiceServer).DeleteMachine(ctx, req.(*DeleteMachineRequest))
   599| 	}
   600| 	return interceptor(ctx, in, info, handler)
   601| }
   602| func _HeadscaleService_ExpireMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   603| 	in := new(ExpireMachineRequest)
   604| 	if err := dec(in); err != nil {
   605| 		return nil, err
   606| 	}
   607| 	if interceptor == nil {
   608| 		return srv.(HeadscaleServiceServer).ExpireMachine(ctx, in)
   609| 	}
   610| 	info := &grpc.UnaryServerInfo{
   611| 		Server:     srv,
   612| 		FullMethod: HeadscaleService_ExpireMachine_FullMethodName,
   613| 	}
   614| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   615| 		return srv.(HeadscaleServiceServer).ExpireMachine(ctx, req.(*ExpireMachineRequest))
   616| 	}
   617| 	return interceptor(ctx, in, info, handler)
   618| }
   619| func _HeadscaleService_RenameMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   620| 	in := new(RenameMachineRequest)
   621| 	if err := dec(in); err != nil {
   622| 		return nil, err
   623| 	}
   624| 	if interceptor == nil {
   625| 		return srv.(HeadscaleServiceServer).RenameMachine(ctx, in)
   626| 	}
   627| 	info := &grpc.UnaryServerInfo{
   628| 		Server:     srv,
   629| 		FullMethod: HeadscaleService_RenameMachine_FullMethodName,
   630| 	}
   631| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   632| 		return srv.(HeadscaleServiceServer).RenameMachine(ctx, req.(*RenameMachineRequest))
   633| 	}
   634| 	return interceptor(ctx, in, info, handler)
   635| }
   636| func _HeadscaleService_ListMachines_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   637| 	in := new(ListMachinesRequest)
   638| 	if err := dec(in); err != nil {
   639| 		return nil, err
   640| 	}
   641| 	if interceptor == nil {
   642| 		return srv.(HeadscaleServiceServer).ListMachines(ctx, in)
   643| 	}
   644| 	info := &grpc.UnaryServerInfo{
   645| 		Server:     srv,
   646| 		FullMethod: HeadscaleService_ListMachines_FullMethodName,
   647| 	}
   648| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   649| 		return srv.(HeadscaleServiceServer).ListMachines(ctx, req.(*ListMachinesRequest))
   650| 	}
   651| 	return interceptor(ctx, in, info, handler)
   652| }
   653| func _HeadscaleService_MoveMachine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   654| 	in := new(MoveMachineRequest)
   655| 	if err := dec(in); err != nil {
   656| 		return nil, err
   657| 	}
   658| 	if interceptor == nil {
   659| 		return srv.(HeadscaleServiceServer).MoveMachine(ctx, in)
   660| 	}
   661| 	info := &grpc.UnaryServerInfo{
   662| 		Server:     srv,
   663| 		FullMethod: HeadscaleService_MoveMachine_FullMethodName,
   664| 	}
   665| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   666| 		return srv.(HeadscaleServiceServer).MoveMachine(ctx, req.(*MoveMachineRequest))
   667| 	}
   668| 	return interceptor(ctx, in, info, handler)
   669| }
   670| func _HeadscaleService_GetRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   671| 	in := new(GetRoutesRequest)
   672| 	if err := dec(in); err != nil {
   673| 		return nil, err
   674| 	}
   675| 	if interceptor == nil {
   676| 		return srv.(HeadscaleServiceServer).GetRoutes(ctx, in)
   677| 	}
   678| 	info := &grpc.UnaryServerInfo{
   679| 		Server:     srv,
   680| 		FullMethod: HeadscaleService_GetRoutes_FullMethodName,
   681| 	}
   682| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   683| 		return srv.(HeadscaleServiceServer).GetRoutes(ctx, req.(*GetRoutesRequest))
   684| 	}
   685| 	return interceptor(ctx, in, info, handler)
   686| }

# --- HUNK 4: Lines 701-754 ---
   701| 	}
   702| 	return interceptor(ctx, in, info, handler)
   703| }
   704| func _HeadscaleService_DisableRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   705| 	in := new(DisableRouteRequest)
   706| 	if err := dec(in); err != nil {
   707| 		return nil, err
   708| 	}
   709| 	if interceptor == nil {
   710| 		return srv.(HeadscaleServiceServer).DisableRoute(ctx, in)
   711| 	}
   712| 	info := &grpc.UnaryServerInfo{
   713| 		Server:     srv,
   714| 		FullMethod: HeadscaleService_DisableRoute_FullMethodName,
   715| 	}
   716| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   717| 		return srv.(HeadscaleServiceServer).DisableRoute(ctx, req.(*DisableRouteRequest))
   718| 	}
   719| 	return interceptor(ctx, in, info, handler)
   720| }
   721| func _HeadscaleService_GetMachineRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   722| 	in := new(GetMachineRoutesRequest)
   723| 	if err := dec(in); err != nil {
   724| 		return nil, err
   725| 	}
   726| 	if interceptor == nil {
   727| 		return srv.(HeadscaleServiceServer).GetMachineRoutes(ctx, in)
   728| 	}
   729| 	info := &grpc.UnaryServerInfo{
   730| 		Server:     srv,
   731| 		FullMethod: HeadscaleService_GetMachineRoutes_FullMethodName,
   732| 	}
   733| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   734| 		return srv.(HeadscaleServiceServer).GetMachineRoutes(ctx, req.(*GetMachineRoutesRequest))
   735| 	}
   736| 	return interceptor(ctx, in, info, handler)
   737| }
   738| func _HeadscaleService_DeleteRoute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   739| 	in := new(DeleteRouteRequest)
   740| 	if err := dec(in); err != nil {
   741| 		return nil, err
   742| 	}
   743| 	if interceptor == nil {
   744| 		return srv.(HeadscaleServiceServer).DeleteRoute(ctx, in)
   745| 	}
   746| 	info := &grpc.UnaryServerInfo{
   747| 		Server:     srv,
   748| 		FullMethod: HeadscaleService_DeleteRoute_FullMethodName,
   749| 	}
   750| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   751| 		return srv.(HeadscaleServiceServer).DeleteRoute(ctx, req.(*DeleteRouteRequest))
   752| 	}
   753| 	return interceptor(ctx, in, info, handler)
   754| }

# --- HUNK 5: Lines 783-913 ---
   783| 	}
   784| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   785| 		return srv.(HeadscaleServiceServer).ExpireApiKey(ctx, req.(*ExpireApiKeyRequest))
   786| 	}
   787| 	return interceptor(ctx, in, info, handler)
   788| }
   789| func _HeadscaleService_ListApiKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
   790| 	in := new(ListApiKeysRequest)
   791| 	if err := dec(in); err != nil {
   792| 		return nil, err
   793| 	}
   794| 	if interceptor == nil {
   795| 		return srv.(HeadscaleServiceServer).ListApiKeys(ctx, in)
   796| 	}
   797| 	info := &grpc.UnaryServerInfo{
   798| 		Server:     srv,
   799| 		FullMethod: HeadscaleService_ListApiKeys_FullMethodName,
   800| 	}
   801| 	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
   802| 		return srv.(HeadscaleServiceServer).ListApiKeys(ctx, req.(*ListApiKeysRequest))
   803| 	}
   804| 	return interceptor(ctx, in, info, handler)
   805| }
   806| var HeadscaleService_ServiceDesc = grpc.ServiceDesc{
   807| 	ServiceName: "headscale.v1.HeadscaleService",
   808| 	HandlerType: (*HeadscaleServiceServer)(nil),
   809| 	Methods: []grpc.MethodDesc{
   810| 		{
   811| 			MethodName: "GetUser",
   812| 			Handler:    _HeadscaleService_GetUser_Handler,
   813| 		},
   814| 		{
   815| 			MethodName: "CreateUser",
   816| 			Handler:    _HeadscaleService_CreateUser_Handler,
   817| 		},
   818| 		{
   819| 			MethodName: "RenameUser",
   820| 			Handler:    _HeadscaleService_RenameUser_Handler,
   821| 		},
   822| 		{
   823| 			MethodName: "DeleteUser",
   824| 			Handler:    _HeadscaleService_DeleteUser_Handler,
   825| 		},
   826| 		{
   827| 			MethodName: "ListUsers",
   828| 			Handler:    _HeadscaleService_ListUsers_Handler,
   829| 		},
   830| 		{
   831| 			MethodName: "CreatePreAuthKey",
   832| 			Handler:    _HeadscaleService_CreatePreAuthKey_Handler,
   833| 		},
   834| 		{
   835| 			MethodName: "ExpirePreAuthKey",
   836| 			Handler:    _HeadscaleService_ExpirePreAuthKey_Handler,
   837| 		},
   838| 		{
   839| 			MethodName: "ListPreAuthKeys",
   840| 			Handler:    _HeadscaleService_ListPreAuthKeys_Handler,
   841| 		},
   842| 		{
   843| 			MethodName: "DebugCreateMachine",
   844| 			Handler:    _HeadscaleService_DebugCreateMachine_Handler,
   845| 		},
   846| 		{
   847| 			MethodName: "GetMachine",
   848| 			Handler:    _HeadscaleService_GetMachine_Handler,
   849| 		},
   850| 		{
   851| 			MethodName: "SetTags",
   852| 			Handler:    _HeadscaleService_SetTags_Handler,
   853| 		},
   854| 		{
   855| 			MethodName: "RegisterMachine",
   856| 			Handler:    _HeadscaleService_RegisterMachine_Handler,
   857| 		},
   858| 		{
   859| 			MethodName: "DeleteMachine",
   860| 			Handler:    _HeadscaleService_DeleteMachine_Handler,
   861| 		},
   862| 		{
   863| 			MethodName: "ExpireMachine",
   864| 			Handler:    _HeadscaleService_ExpireMachine_Handler,
   865| 		},
   866| 		{
   867| 			MethodName: "RenameMachine",
   868| 			Handler:    _HeadscaleService_RenameMachine_Handler,
   869| 		},
   870| 		{
   871| 			MethodName: "ListMachines",
   872| 			Handler:    _HeadscaleService_ListMachines_Handler,
   873| 		},
   874| 		{
   875| 			MethodName: "MoveMachine",
   876| 			Handler:    _HeadscaleService_MoveMachine_Handler,
   877| 		},
   878| 		{
   879| 			MethodName: "GetRoutes",
   880| 			Handler:    _HeadscaleService_GetRoutes_Handler,
   881| 		},
   882| 		{
   883| 			MethodName: "EnableRoute",
   884| 			Handler:    _HeadscaleService_EnableRoute_Handler,
   885| 		},
   886| 		{
   887| 			MethodName: "DisableRoute",
   888| 			Handler:    _HeadscaleService_DisableRoute_Handler,
   889| 		},
   890| 		{
   891| 			MethodName: "GetMachineRoutes",
   892| 			Handler:    _HeadscaleService_GetMachineRoutes_Handler,
   893| 		},
   894| 		{
   895| 			MethodName: "DeleteRoute",
   896| 			Handler:    _HeadscaleService_DeleteRoute_Handler,
   897| 		},
   898| 		{
   899| 			MethodName: "CreateApiKey",
   900| 			Handler:    _HeadscaleService_CreateApiKey_Handler,
   901| 		},
   902| 		{
   903| 			MethodName: "ExpireApiKey",
   904| 			Handler:    _HeadscaleService_ExpireApiKey_Handler,
   905| 		},
   906| 		{
   907| 			MethodName: "ListApiKeys",
   908| 			Handler:    _HeadscaleService_ListApiKeys_Handler,
   909| 		},
   910| 	},
   911| 	Streams:  []grpc.StreamDesc{},
   912| 	Metadata: "headscale/v1/headscale.proto",
   913| }


# ====================================================================
# FILE: gen/go/headscale/v1/machine.pb.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1398 ---
     1| package v1
     2| import (
     3| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     4| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     5| 	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
     6| 	reflect "reflect"
     7| 	sync "sync"
     8| )
     9| const (
    10| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    11| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    12| )
    13| type RegisterMethod int32
    14| const (
    15| 	RegisterMethod_REGISTER_METHOD_UNSPECIFIED RegisterMethod = 0
    16| 	RegisterMethod_REGISTER_METHOD_AUTH_KEY    RegisterMethod = 1
    17| 	RegisterMethod_REGISTER_METHOD_CLI         RegisterMethod = 2
    18| 	RegisterMethod_REGISTER_METHOD_OIDC        RegisterMethod = 3
    19| )
    20| var (
    21| 	RegisterMethod_name = map[int32]string{
    22| 		0: "REGISTER_METHOD_UNSPECIFIED",
    23| 		1: "REGISTER_METHOD_AUTH_KEY",
    24| 		2: "REGISTER_METHOD_CLI",
    25| 		3: "REGISTER_METHOD_OIDC",
    26| 	}
    27| 	RegisterMethod_value = map[string]int32{
    28| 		"REGISTER_METHOD_UNSPECIFIED": 0,
    29| 		"REGISTER_METHOD_AUTH_KEY":    1,
    30| 		"REGISTER_METHOD_CLI":         2,
    31| 		"REGISTER_METHOD_OIDC":        3,
    32| 	}
    33| )
    34| func (x RegisterMethod) Enum() *RegisterMethod {
    35| 	p := new(RegisterMethod)
    36| 	*p = x
    37| 	return p
    38| }
    39| func (x RegisterMethod) String() string {
    40| 	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
    41| }
    42| func (RegisterMethod) Descriptor() protoreflect.EnumDescriptor {
    43| 	return file_headscale_v1_machine_proto_enumTypes[0].Descriptor()
    44| }
    45| func (RegisterMethod) Type() protoreflect.EnumType {
    46| 	return &file_headscale_v1_machine_proto_enumTypes[0]
    47| }
    48| func (x RegisterMethod) Number() protoreflect.EnumNumber {
    49| 	return protoreflect.EnumNumber(x)
    50| }
    51| func (RegisterMethod) EnumDescriptor() ([]byte, []int) {
    52| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{0}
    53| }
    54| type Machine struct {
    55| 	state         protoimpl.MessageState
    56| 	sizeCache     protoimpl.SizeCache
    57| 	unknownFields protoimpl.UnknownFields
    58| 	Id                   uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
    59| 	MachineKey           string                 `protobuf:"bytes,2,opt,name=machine_key,json=machineKey,proto3" json:"machine_key,omitempty"`
    60| 	NodeKey              string                 `protobuf:"bytes,3,opt,name=node_key,json=nodeKey,proto3" json:"node_key,omitempty"`
    61| 	DiscoKey             string                 `protobuf:"bytes,4,opt,name=disco_key,json=discoKey,proto3" json:"disco_key,omitempty"`
    62| 	IpAddresses          []string               `protobuf:"bytes,5,rep,name=ip_addresses,json=ipAddresses,proto3" json:"ip_addresses,omitempty"`
    63| 	Name                 string                 `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
    64| 	User                 *User                  `protobuf:"bytes,7,opt,name=user,proto3" json:"user,omitempty"`
    65| 	LastSeen             *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
    66| 	LastSuccessfulUpdate *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=last_successful_update,json=lastSuccessfulUpdate,proto3" json:"last_successful_update,omitempty"`
    67| 	Expiry               *timestamppb.Timestamp `protobuf:"bytes,10,opt,name=expiry,proto3" json:"expiry,omitempty"`
    68| 	PreAuthKey           *PreAuthKey            `protobuf:"bytes,11,opt,name=pre_auth_key,json=preAuthKey,proto3" json:"pre_auth_key,omitempty"`
    69| 	CreatedAt            *timestamppb.Timestamp `protobuf:"bytes,12,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
    70| 	RegisterMethod       RegisterMethod         `protobuf:"varint,13,opt,name=register_method,json=registerMethod,proto3,enum=headscale.v1.RegisterMethod" json:"register_method,omitempty"`
    71| 	ForcedTags           []string               `protobuf:"bytes,18,rep,name=forced_tags,json=forcedTags,proto3" json:"forced_tags,omitempty"`
    72| 	InvalidTags          []string               `protobuf:"bytes,19,rep,name=invalid_tags,json=invalidTags,proto3" json:"invalid_tags,omitempty"`
    73| 	ValidTags            []string               `protobuf:"bytes,20,rep,name=valid_tags,json=validTags,proto3" json:"valid_tags,omitempty"`
    74| 	GivenName            string                 `protobuf:"bytes,21,opt,name=given_name,json=givenName,proto3" json:"given_name,omitempty"`
    75| 	Online               bool                   `protobuf:"varint,22,opt,name=online,proto3" json:"online,omitempty"`
    76| }
    77| func (x *Machine) Reset() {
    78| 	*x = Machine{}
    79| 	if protoimpl.UnsafeEnabled {
    80| 		mi := &file_headscale_v1_machine_proto_msgTypes[0]
    81| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    82| 		ms.StoreMessageInfo(mi)
    83| 	}
    84| }
    85| func (x *Machine) String() string {
    86| 	return protoimpl.X.MessageStringOf(x)
    87| }
    88| func (*Machine) ProtoMessage() {}
    89| func (x *Machine) ProtoReflect() protoreflect.Message {
    90| 	mi := &file_headscale_v1_machine_proto_msgTypes[0]
    91| 	if protoimpl.UnsafeEnabled && x != nil {
    92| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    93| 		if ms.LoadMessageInfo() == nil {
    94| 			ms.StoreMessageInfo(mi)
    95| 		}
    96| 		return ms
    97| 	}
    98| 	return mi.MessageOf(x)
    99| }
   100| func (*Machine) Descriptor() ([]byte, []int) {
   101| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{0}
   102| }
   103| func (x *Machine) GetId() uint64 {
   104| 	if x != nil {
   105| 		return x.Id
   106| 	}
   107| 	return 0
   108| }
   109| func (x *Machine) GetMachineKey() string {
   110| 	if x != nil {
   111| 		return x.MachineKey
   112| 	}
   113| 	return ""
   114| }
   115| func (x *Machine) GetNodeKey() string {
   116| 	if x != nil {
   117| 		return x.NodeKey
   118| 	}
   119| 	return ""
   120| }
   121| func (x *Machine) GetDiscoKey() string {
   122| 	if x != nil {
   123| 		return x.DiscoKey
   124| 	}
   125| 	return ""
   126| }
   127| func (x *Machine) GetIpAddresses() []string {
   128| 	if x != nil {
   129| 		return x.IpAddresses
   130| 	}
   131| 	return nil
   132| }
   133| func (x *Machine) GetName() string {
   134| 	if x != nil {
   135| 		return x.Name
   136| 	}
   137| 	return ""
   138| }
   139| func (x *Machine) GetUser() *User {
   140| 	if x != nil {
   141| 		return x.User
   142| 	}
   143| 	return nil
   144| }
   145| func (x *Machine) GetLastSeen() *timestamppb.Timestamp {
   146| 	if x != nil {
   147| 		return x.LastSeen
   148| 	}
   149| 	return nil
   150| }
   151| func (x *Machine) GetLastSuccessfulUpdate() *timestamppb.Timestamp {
   152| 	if x != nil {
   153| 		return x.LastSuccessfulUpdate
   154| 	}
   155| 	return nil
   156| }
   157| func (x *Machine) GetExpiry() *timestamppb.Timestamp {
   158| 	if x != nil {
   159| 		return x.Expiry
   160| 	}
   161| 	return nil
   162| }
   163| func (x *Machine) GetPreAuthKey() *PreAuthKey {
   164| 	if x != nil {
   165| 		return x.PreAuthKey
   166| 	}
   167| 	return nil
   168| }
   169| func (x *Machine) GetCreatedAt() *timestamppb.Timestamp {
   170| 	if x != nil {
   171| 		return x.CreatedAt
   172| 	}
   173| 	return nil
   174| }
   175| func (x *Machine) GetRegisterMethod() RegisterMethod {
   176| 	if x != nil {
   177| 		return x.RegisterMethod
   178| 	}
   179| 	return RegisterMethod_REGISTER_METHOD_UNSPECIFIED
   180| }
   181| func (x *Machine) GetForcedTags() []string {
   182| 	if x != nil {
   183| 		return x.ForcedTags
   184| 	}
   185| 	return nil
   186| }
   187| func (x *Machine) GetInvalidTags() []string {
   188| 	if x != nil {
   189| 		return x.InvalidTags
   190| 	}
   191| 	return nil
   192| }
   193| func (x *Machine) GetValidTags() []string {
   194| 	if x != nil {
   195| 		return x.ValidTags
   196| 	}
   197| 	return nil
   198| }
   199| func (x *Machine) GetGivenName() string {
   200| 	if x != nil {
   201| 		return x.GivenName
   202| 	}
   203| 	return ""
   204| }
   205| func (x *Machine) GetOnline() bool {
   206| 	if x != nil {
   207| 		return x.Online
   208| 	}
   209| 	return false
   210| }
   211| type RegisterMachineRequest struct {
   212| 	state         protoimpl.MessageState
   213| 	sizeCache     protoimpl.SizeCache
   214| 	unknownFields protoimpl.UnknownFields
   215| 	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   216| 	Key  string `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
   217| }
   218| func (x *RegisterMachineRequest) Reset() {
   219| 	*x = RegisterMachineRequest{}
   220| 	if protoimpl.UnsafeEnabled {
   221| 		mi := &file_headscale_v1_machine_proto_msgTypes[1]
   222| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   223| 		ms.StoreMessageInfo(mi)
   224| 	}
   225| }
   226| func (x *RegisterMachineRequest) String() string {
   227| 	return protoimpl.X.MessageStringOf(x)
   228| }
   229| func (*RegisterMachineRequest) ProtoMessage() {}
   230| func (x *RegisterMachineRequest) ProtoReflect() protoreflect.Message {
   231| 	mi := &file_headscale_v1_machine_proto_msgTypes[1]
   232| 	if protoimpl.UnsafeEnabled && x != nil {
   233| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   234| 		if ms.LoadMessageInfo() == nil {
   235| 			ms.StoreMessageInfo(mi)
   236| 		}
   237| 		return ms
   238| 	}
   239| 	return mi.MessageOf(x)
   240| }
   241| func (*RegisterMachineRequest) Descriptor() ([]byte, []int) {
   242| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{1}
   243| }
   244| func (x *RegisterMachineRequest) GetUser() string {
   245| 	if x != nil {
   246| 		return x.User
   247| 	}
   248| 	return ""
   249| }
   250| func (x *RegisterMachineRequest) GetKey() string {
   251| 	if x != nil {
   252| 		return x.Key
   253| 	}
   254| 	return ""
   255| }
   256| type RegisterMachineResponse struct {
   257| 	state         protoimpl.MessageState
   258| 	sizeCache     protoimpl.SizeCache
   259| 	unknownFields protoimpl.UnknownFields
   260| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   261| }
   262| func (x *RegisterMachineResponse) Reset() {
   263| 	*x = RegisterMachineResponse{}
   264| 	if protoimpl.UnsafeEnabled {
   265| 		mi := &file_headscale_v1_machine_proto_msgTypes[2]
   266| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   267| 		ms.StoreMessageInfo(mi)
   268| 	}
   269| }
   270| func (x *RegisterMachineResponse) String() string {
   271| 	return protoimpl.X.MessageStringOf(x)
   272| }
   273| func (*RegisterMachineResponse) ProtoMessage() {}
   274| func (x *RegisterMachineResponse) ProtoReflect() protoreflect.Message {
   275| 	mi := &file_headscale_v1_machine_proto_msgTypes[2]
   276| 	if protoimpl.UnsafeEnabled && x != nil {
   277| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   278| 		if ms.LoadMessageInfo() == nil {
   279| 			ms.StoreMessageInfo(mi)
   280| 		}
   281| 		return ms
   282| 	}
   283| 	return mi.MessageOf(x)
   284| }
   285| func (*RegisterMachineResponse) Descriptor() ([]byte, []int) {
   286| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{2}
   287| }
   288| func (x *RegisterMachineResponse) GetMachine() *Machine {
   289| 	if x != nil {
   290| 		return x.Machine
   291| 	}
   292| 	return nil
   293| }
   294| type GetMachineRequest struct {
   295| 	state         protoimpl.MessageState
   296| 	sizeCache     protoimpl.SizeCache
   297| 	unknownFields protoimpl.UnknownFields
   298| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   299| }
   300| func (x *GetMachineRequest) Reset() {
   301| 	*x = GetMachineRequest{}
   302| 	if protoimpl.UnsafeEnabled {
   303| 		mi := &file_headscale_v1_machine_proto_msgTypes[3]
   304| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   305| 		ms.StoreMessageInfo(mi)
   306| 	}
   307| }
   308| func (x *GetMachineRequest) String() string {
   309| 	return protoimpl.X.MessageStringOf(x)
   310| }
   311| func (*GetMachineRequest) ProtoMessage() {}
   312| func (x *GetMachineRequest) ProtoReflect() protoreflect.Message {
   313| 	mi := &file_headscale_v1_machine_proto_msgTypes[3]
   314| 	if protoimpl.UnsafeEnabled && x != nil {
   315| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   316| 		if ms.LoadMessageInfo() == nil {
   317| 			ms.StoreMessageInfo(mi)
   318| 		}
   319| 		return ms
   320| 	}
   321| 	return mi.MessageOf(x)
   322| }
   323| func (*GetMachineRequest) Descriptor() ([]byte, []int) {
   324| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{3}
   325| }
   326| func (x *GetMachineRequest) GetMachineId() uint64 {
   327| 	if x != nil {
   328| 		return x.MachineId
   329| 	}
   330| 	return 0
   331| }
   332| type GetMachineResponse struct {
   333| 	state         protoimpl.MessageState
   334| 	sizeCache     protoimpl.SizeCache
   335| 	unknownFields protoimpl.UnknownFields
   336| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   337| }
   338| func (x *GetMachineResponse) Reset() {
   339| 	*x = GetMachineResponse{}
   340| 	if protoimpl.UnsafeEnabled {
   341| 		mi := &file_headscale_v1_machine_proto_msgTypes[4]
   342| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   343| 		ms.StoreMessageInfo(mi)
   344| 	}
   345| }
   346| func (x *GetMachineResponse) String() string {
   347| 	return protoimpl.X.MessageStringOf(x)
   348| }
   349| func (*GetMachineResponse) ProtoMessage() {}
   350| func (x *GetMachineResponse) ProtoReflect() protoreflect.Message {
   351| 	mi := &file_headscale_v1_machine_proto_msgTypes[4]
   352| 	if protoimpl.UnsafeEnabled && x != nil {
   353| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   354| 		if ms.LoadMessageInfo() == nil {
   355| 			ms.StoreMessageInfo(mi)
   356| 		}
   357| 		return ms
   358| 	}
   359| 	return mi.MessageOf(x)
   360| }
   361| func (*GetMachineResponse) Descriptor() ([]byte, []int) {
   362| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{4}
   363| }
   364| func (x *GetMachineResponse) GetMachine() *Machine {
   365| 	if x != nil {
   366| 		return x.Machine
   367| 	}
   368| 	return nil
   369| }
   370| type SetTagsRequest struct {
   371| 	state         protoimpl.MessageState
   372| 	sizeCache     protoimpl.SizeCache
   373| 	unknownFields protoimpl.UnknownFields
   374| 	MachineId uint64   `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   375| 	Tags      []string `protobuf:"bytes,2,rep,name=tags,proto3" json:"tags,omitempty"`
   376| }
   377| func (x *SetTagsRequest) Reset() {
   378| 	*x = SetTagsRequest{}
   379| 	if protoimpl.UnsafeEnabled {
   380| 		mi := &file_headscale_v1_machine_proto_msgTypes[5]
   381| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   382| 		ms.StoreMessageInfo(mi)
   383| 	}
   384| }
   385| func (x *SetTagsRequest) String() string {
   386| 	return protoimpl.X.MessageStringOf(x)
   387| }
   388| func (*SetTagsRequest) ProtoMessage() {}
   389| func (x *SetTagsRequest) ProtoReflect() protoreflect.Message {
   390| 	mi := &file_headscale_v1_machine_proto_msgTypes[5]
   391| 	if protoimpl.UnsafeEnabled && x != nil {
   392| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   393| 		if ms.LoadMessageInfo() == nil {
   394| 			ms.StoreMessageInfo(mi)
   395| 		}
   396| 		return ms
   397| 	}
   398| 	return mi.MessageOf(x)
   399| }
   400| func (*SetTagsRequest) Descriptor() ([]byte, []int) {
   401| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{5}
   402| }
   403| func (x *SetTagsRequest) GetMachineId() uint64 {
   404| 	if x != nil {
   405| 		return x.MachineId
   406| 	}
   407| 	return 0
   408| }
   409| func (x *SetTagsRequest) GetTags() []string {
   410| 	if x != nil {
   411| 		return x.Tags
   412| 	}
   413| 	return nil
   414| }
   415| type SetTagsResponse struct {
   416| 	state         protoimpl.MessageState
   417| 	sizeCache     protoimpl.SizeCache
   418| 	unknownFields protoimpl.UnknownFields
   419| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   420| }
   421| func (x *SetTagsResponse) Reset() {
   422| 	*x = SetTagsResponse{}
   423| 	if protoimpl.UnsafeEnabled {
   424| 		mi := &file_headscale_v1_machine_proto_msgTypes[6]
   425| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   426| 		ms.StoreMessageInfo(mi)
   427| 	}
   428| }
   429| func (x *SetTagsResponse) String() string {
   430| 	return protoimpl.X.MessageStringOf(x)
   431| }
   432| func (*SetTagsResponse) ProtoMessage() {}
   433| func (x *SetTagsResponse) ProtoReflect() protoreflect.Message {
   434| 	mi := &file_headscale_v1_machine_proto_msgTypes[6]
   435| 	if protoimpl.UnsafeEnabled && x != nil {
   436| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   437| 		if ms.LoadMessageInfo() == nil {
   438| 			ms.StoreMessageInfo(mi)
   439| 		}
   440| 		return ms
   441| 	}
   442| 	return mi.MessageOf(x)
   443| }
   444| func (*SetTagsResponse) Descriptor() ([]byte, []int) {
   445| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{6}
   446| }
   447| func (x *SetTagsResponse) GetMachine() *Machine {
   448| 	if x != nil {
   449| 		return x.Machine
   450| 	}
   451| 	return nil
   452| }
   453| type DeleteMachineRequest struct {
   454| 	state         protoimpl.MessageState
   455| 	sizeCache     protoimpl.SizeCache
   456| 	unknownFields protoimpl.UnknownFields
   457| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   458| }
   459| func (x *DeleteMachineRequest) Reset() {
   460| 	*x = DeleteMachineRequest{}
   461| 	if protoimpl.UnsafeEnabled {
   462| 		mi := &file_headscale_v1_machine_proto_msgTypes[7]
   463| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   464| 		ms.StoreMessageInfo(mi)
   465| 	}
   466| }
   467| func (x *DeleteMachineRequest) String() string {
   468| 	return protoimpl.X.MessageStringOf(x)
   469| }
   470| func (*DeleteMachineRequest) ProtoMessage() {}
   471| func (x *DeleteMachineRequest) ProtoReflect() protoreflect.Message {
   472| 	mi := &file_headscale_v1_machine_proto_msgTypes[7]
   473| 	if protoimpl.UnsafeEnabled && x != nil {
   474| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   475| 		if ms.LoadMessageInfo() == nil {
   476| 			ms.StoreMessageInfo(mi)
   477| 		}
   478| 		return ms
   479| 	}
   480| 	return mi.MessageOf(x)
   481| }
   482| func (*DeleteMachineRequest) Descriptor() ([]byte, []int) {
   483| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{7}
   484| }
   485| func (x *DeleteMachineRequest) GetMachineId() uint64 {
   486| 	if x != nil {
   487| 		return x.MachineId
   488| 	}
   489| 	return 0
   490| }
   491| type DeleteMachineResponse struct {
   492| 	state         protoimpl.MessageState
   493| 	sizeCache     protoimpl.SizeCache
   494| 	unknownFields protoimpl.UnknownFields
   495| }
   496| func (x *DeleteMachineResponse) Reset() {
   497| 	*x = DeleteMachineResponse{}
   498| 	if protoimpl.UnsafeEnabled {
   499| 		mi := &file_headscale_v1_machine_proto_msgTypes[8]
   500| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   501| 		ms.StoreMessageInfo(mi)
   502| 	}
   503| }
   504| func (x *DeleteMachineResponse) String() string {
   505| 	return protoimpl.X.MessageStringOf(x)
   506| }
   507| func (*DeleteMachineResponse) ProtoMessage() {}
   508| func (x *DeleteMachineResponse) ProtoReflect() protoreflect.Message {
   509| 	mi := &file_headscale_v1_machine_proto_msgTypes[8]
   510| 	if protoimpl.UnsafeEnabled && x != nil {
   511| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   512| 		if ms.LoadMessageInfo() == nil {
   513| 			ms.StoreMessageInfo(mi)
   514| 		}
   515| 		return ms
   516| 	}
   517| 	return mi.MessageOf(x)
   518| }
   519| func (*DeleteMachineResponse) Descriptor() ([]byte, []int) {
   520| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{8}
   521| }
   522| type ExpireMachineRequest struct {
   523| 	state         protoimpl.MessageState
   524| 	sizeCache     protoimpl.SizeCache
   525| 	unknownFields protoimpl.UnknownFields
   526| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   527| }
   528| func (x *ExpireMachineRequest) Reset() {
   529| 	*x = ExpireMachineRequest{}
   530| 	if protoimpl.UnsafeEnabled {
   531| 		mi := &file_headscale_v1_machine_proto_msgTypes[9]
   532| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   533| 		ms.StoreMessageInfo(mi)
   534| 	}
   535| }
   536| func (x *ExpireMachineRequest) String() string {
   537| 	return protoimpl.X.MessageStringOf(x)
   538| }
   539| func (*ExpireMachineRequest) ProtoMessage() {}
   540| func (x *ExpireMachineRequest) ProtoReflect() protoreflect.Message {
   541| 	mi := &file_headscale_v1_machine_proto_msgTypes[9]
   542| 	if protoimpl.UnsafeEnabled && x != nil {
   543| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   544| 		if ms.LoadMessageInfo() == nil {
   545| 			ms.StoreMessageInfo(mi)
   546| 		}
   547| 		return ms
   548| 	}
   549| 	return mi.MessageOf(x)
   550| }
   551| func (*ExpireMachineRequest) Descriptor() ([]byte, []int) {
   552| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{9}
   553| }
   554| func (x *ExpireMachineRequest) GetMachineId() uint64 {
   555| 	if x != nil {
   556| 		return x.MachineId
   557| 	}
   558| 	return 0
   559| }
   560| type ExpireMachineResponse struct {
   561| 	state         protoimpl.MessageState
   562| 	sizeCache     protoimpl.SizeCache
   563| 	unknownFields protoimpl.UnknownFields
   564| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   565| }
   566| func (x *ExpireMachineResponse) Reset() {
   567| 	*x = ExpireMachineResponse{}
   568| 	if protoimpl.UnsafeEnabled {
   569| 		mi := &file_headscale_v1_machine_proto_msgTypes[10]
   570| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   571| 		ms.StoreMessageInfo(mi)
   572| 	}
   573| }
   574| func (x *ExpireMachineResponse) String() string {
   575| 	return protoimpl.X.MessageStringOf(x)
   576| }
   577| func (*ExpireMachineResponse) ProtoMessage() {}
   578| func (x *ExpireMachineResponse) ProtoReflect() protoreflect.Message {
   579| 	mi := &file_headscale_v1_machine_proto_msgTypes[10]
   580| 	if protoimpl.UnsafeEnabled && x != nil {
   581| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   582| 		if ms.LoadMessageInfo() == nil {
   583| 			ms.StoreMessageInfo(mi)
   584| 		}
   585| 		return ms
   586| 	}
   587| 	return mi.MessageOf(x)
   588| }
   589| func (*ExpireMachineResponse) Descriptor() ([]byte, []int) {
   590| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{10}
   591| }
   592| func (x *ExpireMachineResponse) GetMachine() *Machine {
   593| 	if x != nil {
   594| 		return x.Machine
   595| 	}
   596| 	return nil
   597| }
   598| type RenameMachineRequest struct {
   599| 	state         protoimpl.MessageState
   600| 	sizeCache     protoimpl.SizeCache
   601| 	unknownFields protoimpl.UnknownFields
   602| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   603| 	NewName   string `protobuf:"bytes,2,opt,name=new_name,json=newName,proto3" json:"new_name,omitempty"`
   604| }
   605| func (x *RenameMachineRequest) Reset() {
   606| 	*x = RenameMachineRequest{}
   607| 	if protoimpl.UnsafeEnabled {
   608| 		mi := &file_headscale_v1_machine_proto_msgTypes[11]
   609| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   610| 		ms.StoreMessageInfo(mi)
   611| 	}
   612| }
   613| func (x *RenameMachineRequest) String() string {
   614| 	return protoimpl.X.MessageStringOf(x)
   615| }
   616| func (*RenameMachineRequest) ProtoMessage() {}
   617| func (x *RenameMachineRequest) ProtoReflect() protoreflect.Message {
   618| 	mi := &file_headscale_v1_machine_proto_msgTypes[11]
   619| 	if protoimpl.UnsafeEnabled && x != nil {
   620| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   621| 		if ms.LoadMessageInfo() == nil {
   622| 			ms.StoreMessageInfo(mi)
   623| 		}
   624| 		return ms
   625| 	}
   626| 	return mi.MessageOf(x)
   627| }
   628| func (*RenameMachineRequest) Descriptor() ([]byte, []int) {
   629| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{11}
   630| }
   631| func (x *RenameMachineRequest) GetMachineId() uint64 {
   632| 	if x != nil {
   633| 		return x.MachineId
   634| 	}
   635| 	return 0
   636| }
   637| func (x *RenameMachineRequest) GetNewName() string {
   638| 	if x != nil {
   639| 		return x.NewName
   640| 	}
   641| 	return ""
   642| }
   643| type RenameMachineResponse struct {
   644| 	state         protoimpl.MessageState
   645| 	sizeCache     protoimpl.SizeCache
   646| 	unknownFields protoimpl.UnknownFields
   647| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   648| }
   649| func (x *RenameMachineResponse) Reset() {
   650| 	*x = RenameMachineResponse{}
   651| 	if protoimpl.UnsafeEnabled {
   652| 		mi := &file_headscale_v1_machine_proto_msgTypes[12]
   653| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   654| 		ms.StoreMessageInfo(mi)
   655| 	}
   656| }
   657| func (x *RenameMachineResponse) String() string {
   658| 	return protoimpl.X.MessageStringOf(x)
   659| }
   660| func (*RenameMachineResponse) ProtoMessage() {}
   661| func (x *RenameMachineResponse) ProtoReflect() protoreflect.Message {
   662| 	mi := &file_headscale_v1_machine_proto_msgTypes[12]
   663| 	if protoimpl.UnsafeEnabled && x != nil {
   664| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   665| 		if ms.LoadMessageInfo() == nil {
   666| 			ms.StoreMessageInfo(mi)
   667| 		}
   668| 		return ms
   669| 	}
   670| 	return mi.MessageOf(x)
   671| }
   672| func (*RenameMachineResponse) Descriptor() ([]byte, []int) {
   673| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{12}
   674| }
   675| func (x *RenameMachineResponse) GetMachine() *Machine {
   676| 	if x != nil {
   677| 		return x.Machine
   678| 	}
   679| 	return nil
   680| }
   681| type ListMachinesRequest struct {
   682| 	state         protoimpl.MessageState
   683| 	sizeCache     protoimpl.SizeCache
   684| 	unknownFields protoimpl.UnknownFields
   685| 	User string `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   686| }
   687| func (x *ListMachinesRequest) Reset() {
   688| 	*x = ListMachinesRequest{}
   689| 	if protoimpl.UnsafeEnabled {
   690| 		mi := &file_headscale_v1_machine_proto_msgTypes[13]
   691| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   692| 		ms.StoreMessageInfo(mi)
   693| 	}
   694| }
   695| func (x *ListMachinesRequest) String() string {
   696| 	return protoimpl.X.MessageStringOf(x)
   697| }
   698| func (*ListMachinesRequest) ProtoMessage() {}
   699| func (x *ListMachinesRequest) ProtoReflect() protoreflect.Message {
   700| 	mi := &file_headscale_v1_machine_proto_msgTypes[13]
   701| 	if protoimpl.UnsafeEnabled && x != nil {
   702| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   703| 		if ms.LoadMessageInfo() == nil {
   704| 			ms.StoreMessageInfo(mi)
   705| 		}
   706| 		return ms
   707| 	}
   708| 	return mi.MessageOf(x)
   709| }
   710| func (*ListMachinesRequest) Descriptor() ([]byte, []int) {
   711| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{13}
   712| }
   713| func (x *ListMachinesRequest) GetUser() string {
   714| 	if x != nil {
   715| 		return x.User
   716| 	}
   717| 	return ""
   718| }
   719| type ListMachinesResponse struct {
   720| 	state         protoimpl.MessageState
   721| 	sizeCache     protoimpl.SizeCache
   722| 	unknownFields protoimpl.UnknownFields
   723| 	Machines []*Machine `protobuf:"bytes,1,rep,name=machines,proto3" json:"machines,omitempty"`
   724| }
   725| func (x *ListMachinesResponse) Reset() {
   726| 	*x = ListMachinesResponse{}
   727| 	if protoimpl.UnsafeEnabled {
   728| 		mi := &file_headscale_v1_machine_proto_msgTypes[14]
   729| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   730| 		ms.StoreMessageInfo(mi)
   731| 	}
   732| }
   733| func (x *ListMachinesResponse) String() string {
   734| 	return protoimpl.X.MessageStringOf(x)
   735| }
   736| func (*ListMachinesResponse) ProtoMessage() {}
   737| func (x *ListMachinesResponse) ProtoReflect() protoreflect.Message {
   738| 	mi := &file_headscale_v1_machine_proto_msgTypes[14]
   739| 	if protoimpl.UnsafeEnabled && x != nil {
   740| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   741| 		if ms.LoadMessageInfo() == nil {
   742| 			ms.StoreMessageInfo(mi)
   743| 		}
   744| 		return ms
   745| 	}
   746| 	return mi.MessageOf(x)
   747| }
   748| func (*ListMachinesResponse) Descriptor() ([]byte, []int) {
   749| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{14}
   750| }
   751| func (x *ListMachinesResponse) GetMachines() []*Machine {
   752| 	if x != nil {
   753| 		return x.Machines
   754| 	}
   755| 	return nil
   756| }
   757| type MoveMachineRequest struct {
   758| 	state         protoimpl.MessageState
   759| 	sizeCache     protoimpl.SizeCache
   760| 	unknownFields protoimpl.UnknownFields
   761| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   762| 	User      string `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
   763| }
   764| func (x *MoveMachineRequest) Reset() {
   765| 	*x = MoveMachineRequest{}
   766| 	if protoimpl.UnsafeEnabled {
   767| 		mi := &file_headscale_v1_machine_proto_msgTypes[15]
   768| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   769| 		ms.StoreMessageInfo(mi)
   770| 	}
   771| }
   772| func (x *MoveMachineRequest) String() string {
   773| 	return protoimpl.X.MessageStringOf(x)
   774| }
   775| func (*MoveMachineRequest) ProtoMessage() {}
   776| func (x *MoveMachineRequest) ProtoReflect() protoreflect.Message {
   777| 	mi := &file_headscale_v1_machine_proto_msgTypes[15]
   778| 	if protoimpl.UnsafeEnabled && x != nil {
   779| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   780| 		if ms.LoadMessageInfo() == nil {
   781| 			ms.StoreMessageInfo(mi)
   782| 		}
   783| 		return ms
   784| 	}
   785| 	return mi.MessageOf(x)
   786| }
   787| func (*MoveMachineRequest) Descriptor() ([]byte, []int) {
   788| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{15}
   789| }
   790| func (x *MoveMachineRequest) GetMachineId() uint64 {
   791| 	if x != nil {
   792| 		return x.MachineId
   793| 	}
   794| 	return 0
   795| }
   796| func (x *MoveMachineRequest) GetUser() string {
   797| 	if x != nil {
   798| 		return x.User
   799| 	}
   800| 	return ""
   801| }
   802| type MoveMachineResponse struct {
   803| 	state         protoimpl.MessageState
   804| 	sizeCache     protoimpl.SizeCache
   805| 	unknownFields protoimpl.UnknownFields
   806| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   807| }
   808| func (x *MoveMachineResponse) Reset() {
   809| 	*x = MoveMachineResponse{}
   810| 	if protoimpl.UnsafeEnabled {
   811| 		mi := &file_headscale_v1_machine_proto_msgTypes[16]
   812| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   813| 		ms.StoreMessageInfo(mi)
   814| 	}
   815| }
   816| func (x *MoveMachineResponse) String() string {
   817| 	return protoimpl.X.MessageStringOf(x)
   818| }
   819| func (*MoveMachineResponse) ProtoMessage() {}
   820| func (x *MoveMachineResponse) ProtoReflect() protoreflect.Message {
   821| 	mi := &file_headscale_v1_machine_proto_msgTypes[16]
   822| 	if protoimpl.UnsafeEnabled && x != nil {
   823| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   824| 		if ms.LoadMessageInfo() == nil {
   825| 			ms.StoreMessageInfo(mi)
   826| 		}
   827| 		return ms
   828| 	}
   829| 	return mi.MessageOf(x)
   830| }
   831| func (*MoveMachineResponse) Descriptor() ([]byte, []int) {
   832| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{16}
   833| }
   834| func (x *MoveMachineResponse) GetMachine() *Machine {
   835| 	if x != nil {
   836| 		return x.Machine
   837| 	}
   838| 	return nil
   839| }
   840| type DebugCreateMachineRequest struct {
   841| 	state         protoimpl.MessageState
   842| 	sizeCache     protoimpl.SizeCache
   843| 	unknownFields protoimpl.UnknownFields
   844| 	User   string   `protobuf:"bytes,1,opt,name=user,proto3" json:"user,omitempty"`
   845| 	Key    string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
   846| 	Name   string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
   847| 	Routes []string `protobuf:"bytes,4,rep,name=routes,proto3" json:"routes,omitempty"`
   848| }
   849| func (x *DebugCreateMachineRequest) Reset() {
   850| 	*x = DebugCreateMachineRequest{}
   851| 	if protoimpl.UnsafeEnabled {
   852| 		mi := &file_headscale_v1_machine_proto_msgTypes[17]
   853| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   854| 		ms.StoreMessageInfo(mi)
   855| 	}
   856| }
   857| func (x *DebugCreateMachineRequest) String() string {
   858| 	return protoimpl.X.MessageStringOf(x)
   859| }
   860| func (*DebugCreateMachineRequest) ProtoMessage() {}
   861| func (x *DebugCreateMachineRequest) ProtoReflect() protoreflect.Message {
   862| 	mi := &file_headscale_v1_machine_proto_msgTypes[17]
   863| 	if protoimpl.UnsafeEnabled && x != nil {
   864| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   865| 		if ms.LoadMessageInfo() == nil {
   866| 			ms.StoreMessageInfo(mi)
   867| 		}
   868| 		return ms
   869| 	}
   870| 	return mi.MessageOf(x)
   871| }
   872| func (*DebugCreateMachineRequest) Descriptor() ([]byte, []int) {
   873| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{17}
   874| }
   875| func (x *DebugCreateMachineRequest) GetUser() string {
   876| 	if x != nil {
   877| 		return x.User
   878| 	}
   879| 	return ""
   880| }
   881| func (x *DebugCreateMachineRequest) GetKey() string {
   882| 	if x != nil {
   883| 		return x.Key
   884| 	}
   885| 	return ""
   886| }
   887| func (x *DebugCreateMachineRequest) GetName() string {
   888| 	if x != nil {
   889| 		return x.Name
   890| 	}
   891| 	return ""
   892| }
   893| func (x *DebugCreateMachineRequest) GetRoutes() []string {
   894| 	if x != nil {
   895| 		return x.Routes
   896| 	}
   897| 	return nil
   898| }
   899| type DebugCreateMachineResponse struct {
   900| 	state         protoimpl.MessageState
   901| 	sizeCache     protoimpl.SizeCache
   902| 	unknownFields protoimpl.UnknownFields
   903| 	Machine *Machine `protobuf:"bytes,1,opt,name=machine,proto3" json:"machine,omitempty"`
   904| }
   905| func (x *DebugCreateMachineResponse) Reset() {
   906| 	*x = DebugCreateMachineResponse{}
   907| 	if protoimpl.UnsafeEnabled {
   908| 		mi := &file_headscale_v1_machine_proto_msgTypes[18]
   909| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   910| 		ms.StoreMessageInfo(mi)
   911| 	}
   912| }
   913| func (x *DebugCreateMachineResponse) String() string {
   914| 	return protoimpl.X.MessageStringOf(x)
   915| }
   916| func (*DebugCreateMachineResponse) ProtoMessage() {}
   917| func (x *DebugCreateMachineResponse) ProtoReflect() protoreflect.Message {
   918| 	mi := &file_headscale_v1_machine_proto_msgTypes[18]
   919| 	if protoimpl.UnsafeEnabled && x != nil {
   920| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   921| 		if ms.LoadMessageInfo() == nil {
   922| 			ms.StoreMessageInfo(mi)
   923| 		}
   924| 		return ms
   925| 	}
   926| 	return mi.MessageOf(x)
   927| }
   928| func (*DebugCreateMachineResponse) Descriptor() ([]byte, []int) {
   929| 	return file_headscale_v1_machine_proto_rawDescGZIP(), []int{18}
   930| }
   931| func (x *DebugCreateMachineResponse) GetMachine() *Machine {
   932| 	if x != nil {
   933| 		return x.Machine
   934| 	}
   935| 	return nil
   936| }
   937| var File_headscale_v1_machine_proto protoreflect.FileDescriptor
   938| var file_headscale_v1_machine_proto_rawDesc = []byte{
   939| 	0x0a, 0x1a, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6d,
   940| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65,
   941| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
   942| 	0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
   943| 	0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x68, 0x65, 0x61,
   944| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x75, 0x73, 0x65, 0x72, 0x2e, 0x70,
   945| 	0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f,
   946| 	0x76, 0x31, 0x2f, 0x70, 0x72, 0x65, 0x61, 0x75, 0x74, 0x68, 0x6b, 0x65, 0x79, 0x2e, 0x70, 0x72,
   947| 	0x6f, 0x74, 0x6f, 0x22, 0xee, 0x05, 0x0a, 0x07, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x12,
   948| 	0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64, 0x12,
   949| 	0x1f, 0x0a, 0x0b, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02,
   950| 	0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x4b, 0x65, 0x79,
   951| 	0x12, 0x19, 0x0a, 0x08, 0x6e, 0x6f, 0x64, 0x65, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x03, 0x20, 0x01,
   952| 	0x28, 0x09, 0x52, 0x07, 0x6e, 0x6f, 0x64, 0x65, 0x4b, 0x65, 0x79, 0x12, 0x1b, 0x0a, 0x09, 0x64,
   953| 	0x69, 0x73, 0x63, 0x6f, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08,
   954| 	0x64, 0x69, 0x73, 0x63, 0x6f, 0x4b, 0x65, 0x79, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x70, 0x5f, 0x61,
   955| 	0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b,
   956| 	0x69, 0x70, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x12, 0x12, 0x0a, 0x04, 0x6e,
   957| 	0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
   958| 	0x26, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e,
   959| 	0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65,
   960| 	0x72, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x37, 0x0a, 0x09, 0x6c, 0x61, 0x73, 0x74, 0x5f,
   961| 	0x73, 0x65, 0x65, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
   962| 	0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
   963| 	0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x08, 0x6c, 0x61, 0x73, 0x74, 0x53, 0x65, 0x65, 0x6e,
   964| 	0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73,
   965| 	0x66, 0x75, 0x6c, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b,
   966| 	0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
   967| 	0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61,
   968| 	0x73, 0x74, 0x53, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x66, 0x75, 0x6c, 0x55, 0x70, 0x64, 0x61,
   969| 	0x74, 0x65, 0x12, 0x32, 0x0a, 0x06, 0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x18, 0x0a, 0x20, 0x01,
   970| 	0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
   971| 	0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x06,
   972| 	0x65, 0x78, 0x70, 0x69, 0x72, 0x79, 0x12, 0x3a, 0x0a, 0x0c, 0x70, 0x72, 0x65, 0x5f, 0x61, 0x75,
   973| 	0x74, 0x68, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x68,
   974| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x65, 0x41,
   975| 	0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b,
   976| 	0x65, 0x79, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74,
   977| 	0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
   978| 	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
   979| 	0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x45, 0x0a,
   980| 	0x0f, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
   981| 	0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1c, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
   982| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65,
   983| 	0x74, 0x68, 0x6f, 0x64, 0x52, 0x0e, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65,
   984| 	0x74, 0x68, 0x6f, 0x64, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x64, 0x5f, 0x74,
   985| 	0x61, 0x67, 0x73, 0x18, 0x12, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0a, 0x66, 0x6f, 0x72, 0x63, 0x65,
   986| 	0x64, 0x54, 0x61, 0x67, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x69, 0x6e, 0x76, 0x61, 0x6c, 0x69, 0x64,
   987| 	0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x13, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x69, 0x6e, 0x76,
   988| 	0x61, 0x6c, 0x69, 0x64, 0x54, 0x61, 0x67, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x76, 0x61, 0x6c, 0x69,
   989| 	0x64, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x14, 0x20, 0x03, 0x28, 0x09, 0x52, 0x09, 0x76, 0x61,
   990| 	0x6c, 0x69, 0x64, 0x54, 0x61, 0x67, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x67, 0x69, 0x76, 0x65, 0x6e,
   991| 	0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x15, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x67, 0x69, 0x76,
   992| 	0x65, 0x6e, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65,
   993| 	0x18, 0x16, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x4a, 0x04,
   994| 	0x08, 0x0e, 0x10, 0x12, 0x22, 0x3e, 0x0a, 0x16, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
   995| 	0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12,
   996| 	0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73,
   997| 	0x65, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
   998| 	0x03, 0x6b, 0x65, 0x79, 0x22, 0x4a, 0x0a, 0x17, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
   999| 	0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
  1000| 	0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
  1001| 	0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e,
  1002| 	0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
  1003| 	0x22, 0x32, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65,
  1004| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
  1005| 	0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69,
  1006| 	0x6e, 0x65, 0x49, 0x64, 0x22, 0x45, 0x0a, 0x12, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69,
  1007| 	0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61,
  1008| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65,
  1009| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69,
  1010| 	0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x22, 0x43, 0x0a, 0x0e, 0x53,
  1011| 	0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
  1012| 	0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
  1013| 	0x04, 0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04,
  1014| 	0x74, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x09, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73,
  1015| 	0x22, 0x42, 0x0a, 0x0f, 0x53, 0x65, 0x74, 0x54, 0x61, 0x67, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
  1016| 	0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x18, 0x01,
  1017| 	0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65,
  1018| 	0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61, 0x63,
  1019| 	0x68, 0x69, 0x6e, 0x65, 0x22, 0x35, 0x0a, 0x14, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61,
  1020| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a,
  1021| 	0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
  1022| 	0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x64, 0x22, 0x17, 0x0a, 0x15, 0x44,
  1023| 	0x65, 0x6c, 0x65, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70,
  1024| 	0x6f, 0x6e, 0x73, 0x65, 0x22, 0x35, 0x0a, 0x14, 0x45, 0x78, 0x70, 0x69, 0x72, 0x65, 0x4d, 0x61,
  1025| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a,
  1026| 	0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04,
  1027| 	0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x64, 0x22, 0x48, 0x0a, 0x15, 0x45,
  1028| 	0x78, 0x70, 0x69, 0x72, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70,
  1029| 	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x18,
  1030| 	0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
  1031| 	0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61,
  1032| 	0x63, 0x68, 0x69, 0x6e, 0x65, 0x22, 0x50, 0x0a, 0x14, 0x52, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x4d,
  1033| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
  1034| 	0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
  1035| 	0x04, 0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x64, 0x12, 0x19, 0x0a, 0x08,
  1036| 	0x6e, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
  1037| 	0x6e, 0x65, 0x77, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0x48, 0x0a, 0x15, 0x52, 0x65, 0x6e, 0x61, 0x6d,
  1038| 	0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
  1039| 	0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
  1040| 	0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31,
  1041| 	0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
  1042| 	0x65, 0x22, 0x29, 0x0a, 0x13, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
  1043| 	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72,
  1044| 	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x22, 0x49, 0x0a, 0x14,
  1045| 	0x4c, 0x69, 0x73, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
  1046| 	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x31, 0x0a, 0x08, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73,
  1047| 	0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
  1048| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x08, 0x6d,
  1049| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x73, 0x22, 0x47, 0x0a, 0x12, 0x4d, 0x6f, 0x76, 0x65, 0x4d,
  1050| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a,
  1051| 	0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
  1052| 	0x04, 0x52, 0x09, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04,
  1053| 	0x75, 0x73, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72,
  1054| 	0x22, 0x46, 0x0a, 0x13, 0x4d, 0x6f, 0x76, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52,
  1055| 	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69,
  1056| 	0x6e, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73,
  1057| 	0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52,
  1058| 	0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x22, 0x6d, 0x0a, 0x19, 0x44, 0x65, 0x62, 0x75,
  1059| 	0x67, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65,
  1060| 	0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x75, 0x73, 0x65, 0x72, 0x18, 0x01, 0x20,
  1061| 	0x01, 0x28, 0x09, 0x52, 0x04, 0x75, 0x73, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
  1062| 	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6e,
  1063| 	0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
  1064| 	0x16, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52,
  1065| 	0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x4d, 0x0a, 0x1a, 0x44, 0x65, 0x62, 0x75, 0x67,
  1066| 	0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x73,
  1067| 	0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
  1068| 	0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61,
  1069| 	0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d,
  1070| 	0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x2a, 0x82, 0x01, 0x0a, 0x0e, 0x52, 0x65, 0x67, 0x69, 0x73,
  1071| 	0x74, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x12, 0x1f, 0x0a, 0x1b, 0x52, 0x45, 0x47,
  1072| 	0x49, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x55, 0x4e, 0x53,
  1073| 	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x1c, 0x0a, 0x18, 0x52, 0x45,
  1074| 	0x47, 0x49, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x41, 0x55,
  1075| 	0x54, 0x48, 0x5f, 0x4b, 0x45, 0x59, 0x10, 0x01, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x47, 0x49,
  1076| 	0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45, 0x54, 0x48, 0x4f, 0x44, 0x5f, 0x43, 0x4c, 0x49, 0x10,
  1077| 	0x02, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x47, 0x49, 0x53, 0x54, 0x45, 0x52, 0x5f, 0x4d, 0x45,
  1078| 	0x54, 0x48, 0x4f, 0x44, 0x5f, 0x4f, 0x49, 0x44, 0x43, 0x10, 0x03, 0x42, 0x29, 0x5a, 0x27, 0x67,
  1079| 	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f,
  1080| 	0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e,
  1081| 	0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
  1082| }
  1083| var (
  1084| 	file_headscale_v1_machine_proto_rawDescOnce sync.Once
  1085| 	file_headscale_v1_machine_proto_rawDescData = file_headscale_v1_machine_proto_rawDesc
  1086| )
  1087| func file_headscale_v1_machine_proto_rawDescGZIP() []byte {
  1088| 	file_headscale_v1_machine_proto_rawDescOnce.Do(func() {
  1089| 		file_headscale_v1_machine_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_machine_proto_rawDescData)
  1090| 	})
  1091| 	return file_headscale_v1_machine_proto_rawDescData
  1092| }
  1093| var file_headscale_v1_machine_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
  1094| var file_headscale_v1_machine_proto_msgTypes = make([]protoimpl.MessageInfo, 19)
  1095| var file_headscale_v1_machine_proto_goTypes = []interface{}{
  1096| 	(RegisterMethod)(0),                // 0: headscale.v1.RegisterMethod
  1097| 	(*Machine)(nil),                    // 1: headscale.v1.Machine
  1098| 	(*RegisterMachineRequest)(nil),     // 2: headscale.v1.RegisterMachineRequest
  1099| 	(*RegisterMachineResponse)(nil),    // 3: headscale.v1.RegisterMachineResponse
  1100| 	(*GetMachineRequest)(nil),          // 4: headscale.v1.GetMachineRequest
  1101| 	(*GetMachineResponse)(nil),         // 5: headscale.v1.GetMachineResponse
  1102| 	(*SetTagsRequest)(nil),             // 6: headscale.v1.SetTagsRequest
  1103| 	(*SetTagsResponse)(nil),            // 7: headscale.v1.SetTagsResponse
  1104| 	(*DeleteMachineRequest)(nil),       // 8: headscale.v1.DeleteMachineRequest
  1105| 	(*DeleteMachineResponse)(nil),      // 9: headscale.v1.DeleteMachineResponse
  1106| 	(*ExpireMachineRequest)(nil),       // 10: headscale.v1.ExpireMachineRequest
  1107| 	(*ExpireMachineResponse)(nil),      // 11: headscale.v1.ExpireMachineResponse
  1108| 	(*RenameMachineRequest)(nil),       // 12: headscale.v1.RenameMachineRequest
  1109| 	(*RenameMachineResponse)(nil),      // 13: headscale.v1.RenameMachineResponse
  1110| 	(*ListMachinesRequest)(nil),        // 14: headscale.v1.ListMachinesRequest
  1111| 	(*ListMachinesResponse)(nil),       // 15: headscale.v1.ListMachinesResponse
  1112| 	(*MoveMachineRequest)(nil),         // 16: headscale.v1.MoveMachineRequest
  1113| 	(*MoveMachineResponse)(nil),        // 17: headscale.v1.MoveMachineResponse
  1114| 	(*DebugCreateMachineRequest)(nil),  // 18: headscale.v1.DebugCreateMachineRequest
  1115| 	(*DebugCreateMachineResponse)(nil), // 19: headscale.v1.DebugCreateMachineResponse
  1116| 	(*User)(nil),                       // 20: headscale.v1.User
  1117| 	(*timestamppb.Timestamp)(nil),      // 21: google.protobuf.Timestamp
  1118| 	(*PreAuthKey)(nil),                 // 22: headscale.v1.PreAuthKey
  1119| }
  1120| var file_headscale_v1_machine_proto_depIdxs = []int32{
  1121| 	20, // 0: headscale.v1.Machine.user:type_name -> headscale.v1.User
  1122| 	21, // 1: headscale.v1.Machine.last_seen:type_name -> google.protobuf.Timestamp
  1123| 	21, // 2: headscale.v1.Machine.last_successful_update:type_name -> google.protobuf.Timestamp
  1124| 	21, // 3: headscale.v1.Machine.expiry:type_name -> google.protobuf.Timestamp
  1125| 	22, // 4: headscale.v1.Machine.pre_auth_key:type_name -> headscale.v1.PreAuthKey
  1126| 	21, // 5: headscale.v1.Machine.created_at:type_name -> google.protobuf.Timestamp
  1127| 	0,  // 6: headscale.v1.Machine.register_method:type_name -> headscale.v1.RegisterMethod
  1128| 	1,  // 7: headscale.v1.RegisterMachineResponse.machine:type_name -> headscale.v1.Machine
  1129| 	1,  // 8: headscale.v1.GetMachineResponse.machine:type_name -> headscale.v1.Machine
  1130| 	1,  // 9: headscale.v1.SetTagsResponse.machine:type_name -> headscale.v1.Machine
  1131| 	1,  // 10: headscale.v1.ExpireMachineResponse.machine:type_name -> headscale.v1.Machine
  1132| 	1,  // 11: headscale.v1.RenameMachineResponse.machine:type_name -> headscale.v1.Machine
  1133| 	1,  // 12: headscale.v1.ListMachinesResponse.machines:type_name -> headscale.v1.Machine
  1134| 	1,  // 13: headscale.v1.MoveMachineResponse.machine:type_name -> headscale.v1.Machine
  1135| 	1,  // 14: headscale.v1.DebugCreateMachineResponse.machine:type_name -> headscale.v1.Machine
  1136| 	15, // [15:15] is the sub-list for method output_type
  1137| 	15, // [15:15] is the sub-list for method input_type
  1138| 	15, // [15:15] is the sub-list for extension type_name
  1139| 	15, // [15:15] is the sub-list for extension extendee
  1140| 	0,  // [0:15] is the sub-list for field type_name
  1141| }
  1142| func init() { file_headscale_v1_machine_proto_init() }
  1143| func file_headscale_v1_machine_proto_init() {
  1144| 	if File_headscale_v1_machine_proto != nil {
  1145| 		return
  1146| 	}
  1147| 	file_headscale_v1_user_proto_init()
  1148| 	file_headscale_v1_preauthkey_proto_init()
  1149| 	if !protoimpl.UnsafeEnabled {
  1150| 		file_headscale_v1_machine_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
  1151| 			switch v := v.(*Machine); i {
  1152| 			case 0:
  1153| 				return &v.state
  1154| 			case 1:
  1155| 				return &v.sizeCache
  1156| 			case 2:
  1157| 				return &v.unknownFields
  1158| 			default:
  1159| 				return nil
  1160| 			}
  1161| 		}
  1162| 		file_headscale_v1_machine_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
  1163| 			switch v := v.(*RegisterMachineRequest); i {
  1164| 			case 0:
  1165| 				return &v.state
  1166| 			case 1:
  1167| 				return &v.sizeCache
  1168| 			case 2:
  1169| 				return &v.unknownFields
  1170| 			default:
  1171| 				return nil
  1172| 			}
  1173| 		}
  1174| 		file_headscale_v1_machine_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
  1175| 			switch v := v.(*RegisterMachineResponse); i {
  1176| 			case 0:
  1177| 				return &v.state
  1178| 			case 1:
  1179| 				return &v.sizeCache
  1180| 			case 2:
  1181| 				return &v.unknownFields
  1182| 			default:
  1183| 				return nil
  1184| 			}
  1185| 		}
  1186| 		file_headscale_v1_machine_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
  1187| 			switch v := v.(*GetMachineRequest); i {
  1188| 			case 0:
  1189| 				return &v.state
  1190| 			case 1:
  1191| 				return &v.sizeCache
  1192| 			case 2:
  1193| 				return &v.unknownFields
  1194| 			default:
  1195| 				return nil
  1196| 			}
  1197| 		}
  1198| 		file_headscale_v1_machine_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
  1199| 			switch v := v.(*GetMachineResponse); i {
  1200| 			case 0:
  1201| 				return &v.state
  1202| 			case 1:
  1203| 				return &v.sizeCache
  1204| 			case 2:
  1205| 				return &v.unknownFields
  1206| 			default:
  1207| 				return nil
  1208| 			}
  1209| 		}
  1210| 		file_headscale_v1_machine_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
  1211| 			switch v := v.(*SetTagsRequest); i {
  1212| 			case 0:
  1213| 				return &v.state
  1214| 			case 1:
  1215| 				return &v.sizeCache
  1216| 			case 2:
  1217| 				return &v.unknownFields
  1218| 			default:
  1219| 				return nil
  1220| 			}
  1221| 		}
  1222| 		file_headscale_v1_machine_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
  1223| 			switch v := v.(*SetTagsResponse); i {
  1224| 			case 0:
  1225| 				return &v.state
  1226| 			case 1:
  1227| 				return &v.sizeCache
  1228| 			case 2:
  1229| 				return &v.unknownFields
  1230| 			default:
  1231| 				return nil
  1232| 			}
  1233| 		}
  1234| 		file_headscale_v1_machine_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
  1235| 			switch v := v.(*DeleteMachineRequest); i {
  1236| 			case 0:
  1237| 				return &v.state
  1238| 			case 1:
  1239| 				return &v.sizeCache
  1240| 			case 2:
  1241| 				return &v.unknownFields
  1242| 			default:
  1243| 				return nil
  1244| 			}
  1245| 		}
  1246| 		file_headscale_v1_machine_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
  1247| 			switch v := v.(*DeleteMachineResponse); i {
  1248| 			case 0:
  1249| 				return &v.state
  1250| 			case 1:
  1251| 				return &v.sizeCache
  1252| 			case 2:
  1253| 				return &v.unknownFields
  1254| 			default:
  1255| 				return nil
  1256| 			}
  1257| 		}
  1258| 		file_headscale_v1_machine_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
  1259| 			switch v := v.(*ExpireMachineRequest); i {
  1260| 			case 0:
  1261| 				return &v.state
  1262| 			case 1:
  1263| 				return &v.sizeCache
  1264| 			case 2:
  1265| 				return &v.unknownFields
  1266| 			default:
  1267| 				return nil
  1268| 			}
  1269| 		}
  1270| 		file_headscale_v1_machine_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
  1271| 			switch v := v.(*ExpireMachineResponse); i {
  1272| 			case 0:
  1273| 				return &v.state
  1274| 			case 1:
  1275| 				return &v.sizeCache
  1276| 			case 2:
  1277| 				return &v.unknownFields
  1278| 			default:
  1279| 				return nil
  1280| 			}
  1281| 		}
  1282| 		file_headscale_v1_machine_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
  1283| 			switch v := v.(*RenameMachineRequest); i {
  1284| 			case 0:
  1285| 				return &v.state
  1286| 			case 1:
  1287| 				return &v.sizeCache
  1288| 			case 2:
  1289| 				return &v.unknownFields
  1290| 			default:
  1291| 				return nil
  1292| 			}
  1293| 		}
  1294| 		file_headscale_v1_machine_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
  1295| 			switch v := v.(*RenameMachineResponse); i {
  1296| 			case 0:
  1297| 				return &v.state
  1298| 			case 1:
  1299| 				return &v.sizeCache
  1300| 			case 2:
  1301| 				return &v.unknownFields
  1302| 			default:
  1303| 				return nil
  1304| 			}
  1305| 		}
  1306| 		file_headscale_v1_machine_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
  1307| 			switch v := v.(*ListMachinesRequest); i {
  1308| 			case 0:
  1309| 				return &v.state
  1310| 			case 1:
  1311| 				return &v.sizeCache
  1312| 			case 2:
  1313| 				return &v.unknownFields
  1314| 			default:
  1315| 				return nil
  1316| 			}
  1317| 		}
  1318| 		file_headscale_v1_machine_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
  1319| 			switch v := v.(*ListMachinesResponse); i {
  1320| 			case 0:
  1321| 				return &v.state
  1322| 			case 1:
  1323| 				return &v.sizeCache
  1324| 			case 2:
  1325| 				return &v.unknownFields
  1326| 			default:
  1327| 				return nil
  1328| 			}
  1329| 		}
  1330| 		file_headscale_v1_machine_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
  1331| 			switch v := v.(*MoveMachineRequest); i {
  1332| 			case 0:
  1333| 				return &v.state
  1334| 			case 1:
  1335| 				return &v.sizeCache
  1336| 			case 2:
  1337| 				return &v.unknownFields
  1338| 			default:
  1339| 				return nil
  1340| 			}
  1341| 		}
  1342| 		file_headscale_v1_machine_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
  1343| 			switch v := v.(*MoveMachineResponse); i {
  1344| 			case 0:
  1345| 				return &v.state
  1346| 			case 1:
  1347| 				return &v.sizeCache
  1348| 			case 2:
  1349| 				return &v.unknownFields
  1350| 			default:
  1351| 				return nil
  1352| 			}
  1353| 		}
  1354| 		file_headscale_v1_machine_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
  1355| 			switch v := v.(*DebugCreateMachineRequest); i {
  1356| 			case 0:
  1357| 				return &v.state
  1358| 			case 1:
  1359| 				return &v.sizeCache
  1360| 			case 2:
  1361| 				return &v.unknownFields
  1362| 			default:
  1363| 				return nil
  1364| 			}
  1365| 		}
  1366| 		file_headscale_v1_machine_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
  1367| 			switch v := v.(*DebugCreateMachineResponse); i {
  1368| 			case 0:
  1369| 				return &v.state
  1370| 			case 1:
  1371| 				return &v.sizeCache
  1372| 			case 2:
  1373| 				return &v.unknownFields
  1374| 			default:
  1375| 				return nil
  1376| 			}
  1377| 		}
  1378| 	}
  1379| 	type x struct{}
  1380| 	out := protoimpl.TypeBuilder{
  1381| 		File: protoimpl.DescBuilder{
  1382| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
  1383| 			RawDescriptor: file_headscale_v1_machine_proto_rawDesc,
  1384| 			NumEnums:      1,
  1385| 			NumMessages:   19,
  1386| 			NumExtensions: 0,
  1387| 			NumServices:   0,
  1388| 		},
  1389| 		GoTypes:           file_headscale_v1_machine_proto_goTypes,
  1390| 		DependencyIndexes: file_headscale_v1_machine_proto_depIdxs,
  1391| 		EnumInfos:         file_headscale_v1_machine_proto_enumTypes,
  1392| 		MessageInfos:      file_headscale_v1_machine_proto_msgTypes,
  1393| 	}.Build()
  1394| 	File_headscale_v1_machine_proto = out.File
  1395| 	file_headscale_v1_machine_proto_rawDesc = nil
  1396| 	file_headscale_v1_machine_proto_goTypes = nil
  1397| 	file_headscale_v1_machine_proto_depIdxs = nil
  1398| }


# ====================================================================
# FILE: gen/go/headscale/v1/preauthkey.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 416-556 ---
   416| 	0x73, 0x65, 0x12, 0x3c, 0x0a, 0x0d, 0x70, 0x72, 0x65, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x6b,
   417| 	0x65, 0x79, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x68, 0x65, 0x61, 0x64,
   418| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x50, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68,
   419| 	0x4b, 0x65, 0x79, 0x52, 0x0b, 0x70, 0x72, 0x65, 0x41, 0x75, 0x74, 0x68, 0x4b, 0x65, 0x79, 0x73,
   420| 	0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a,
   421| 	0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c,
   422| 	0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70, 0x72, 0x6f,
   423| 	0x74, 0x6f, 0x33,
   424| }
   425| var (
   426| 	file_headscale_v1_preauthkey_proto_rawDescOnce sync.Once
   427| 	file_headscale_v1_preauthkey_proto_rawDescData = file_headscale_v1_preauthkey_proto_rawDesc
   428| )
   429| func file_headscale_v1_preauthkey_proto_rawDescGZIP() []byte {
   430| 	file_headscale_v1_preauthkey_proto_rawDescOnce.Do(func() {
   431| 		file_headscale_v1_preauthkey_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_preauthkey_proto_rawDescData)
   432| 	})
   433| 	return file_headscale_v1_preauthkey_proto_rawDescData
   434| }
   435| var file_headscale_v1_preauthkey_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
   436| var file_headscale_v1_preauthkey_proto_goTypes = []interface{}{
   437| 	(*PreAuthKey)(nil),               // 0: headscale.v1.PreAuthKey
   438| 	(*CreatePreAuthKeyRequest)(nil),  // 1: headscale.v1.CreatePreAuthKeyRequest
   439| 	(*CreatePreAuthKeyResponse)(nil), // 2: headscale.v1.CreatePreAuthKeyResponse
   440| 	(*ExpirePreAuthKeyRequest)(nil),  // 3: headscale.v1.ExpirePreAuthKeyRequest
   441| 	(*ExpirePreAuthKeyResponse)(nil), // 4: headscale.v1.ExpirePreAuthKeyResponse
   442| 	(*ListPreAuthKeysRequest)(nil),   // 5: headscale.v1.ListPreAuthKeysRequest
   443| 	(*ListPreAuthKeysResponse)(nil),  // 6: headscale.v1.ListPreAuthKeysResponse
   444| 	(*timestamppb.Timestamp)(nil),    // 7: google.protobuf.Timestamp
   445| }
   446| var file_headscale_v1_preauthkey_proto_depIdxs = []int32{
   447| 	7, // 0: headscale.v1.PreAuthKey.expiration:type_name -> google.protobuf.Timestamp
   448| 	7, // 1: headscale.v1.PreAuthKey.created_at:type_name -> google.protobuf.Timestamp
   449| 	7, // 2: headscale.v1.CreatePreAuthKeyRequest.expiration:type_name -> google.protobuf.Timestamp
   450| 	0, // 3: headscale.v1.CreatePreAuthKeyResponse.pre_auth_key:type_name -> headscale.v1.PreAuthKey
   451| 	0, // 4: headscale.v1.ListPreAuthKeysResponse.pre_auth_keys:type_name -> headscale.v1.PreAuthKey
   452| 	5, // [5:5] is the sub-list for method output_type
   453| 	5, // [5:5] is the sub-list for method input_type
   454| 	5, // [5:5] is the sub-list for extension type_name
   455| 	5, // [5:5] is the sub-list for extension extendee
   456| 	0, // [0:5] is the sub-list for field type_name
   457| }
   458| func init() { file_headscale_v1_preauthkey_proto_init() }
   459| func file_headscale_v1_preauthkey_proto_init() {
   460| 	if File_headscale_v1_preauthkey_proto != nil {
   461| 		return
   462| 	}
   463| 	if !protoimpl.UnsafeEnabled {
   464| 		file_headscale_v1_preauthkey_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
   465| 			switch v := v.(*PreAuthKey); i {
   466| 			case 0:
   467| 				return &v.state
   468| 			case 1:
   469| 				return &v.sizeCache
   470| 			case 2:
   471| 				return &v.unknownFields
   472| 			default:
   473| 				return nil
   474| 			}
   475| 		}
   476| 		file_headscale_v1_preauthkey_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
   477| 			switch v := v.(*CreatePreAuthKeyRequest); i {
   478| 			case 0:
   479| 				return &v.state
   480| 			case 1:
   481| 				return &v.sizeCache
   482| 			case 2:
   483| 				return &v.unknownFields
   484| 			default:
   485| 				return nil
   486| 			}
   487| 		}
   488| 		file_headscale_v1_preauthkey_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
   489| 			switch v := v.(*CreatePreAuthKeyResponse); i {
   490| 			case 0:
   491| 				return &v.state
   492| 			case 1:
   493| 				return &v.sizeCache
   494| 			case 2:
   495| 				return &v.unknownFields
   496| 			default:
   497| 				return nil
   498| 			}
   499| 		}
   500| 		file_headscale_v1_preauthkey_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
   501| 			switch v := v.(*ExpirePreAuthKeyRequest); i {
   502| 			case 0:
   503| 				return &v.state
   504| 			case 1:
   505| 				return &v.sizeCache
   506| 			case 2:
   507| 				return &v.unknownFields
   508| 			default:
   509| 				return nil
   510| 			}
   511| 		}
   512| 		file_headscale_v1_preauthkey_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
   513| 			switch v := v.(*ExpirePreAuthKeyResponse); i {
   514| 			case 0:
   515| 				return &v.state
   516| 			case 1:
   517| 				return &v.sizeCache
   518| 			case 2:
   519| 				return &v.unknownFields
   520| 			default:
   521| 				return nil
   522| 			}
   523| 		}
   524| 		file_headscale_v1_preauthkey_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
   525| 			switch v := v.(*ListPreAuthKeysRequest); i {
   526| 			case 0:
   527| 				return &v.state
   528| 			case 1:
   529| 				return &v.sizeCache
   530| 			case 2:
   531| 				return &v.unknownFields
   532| 			default:
   533| 				return nil
   534| 			}
   535| 		}
   536| 		file_headscale_v1_preauthkey_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
   537| 			switch v := v.(*ListPreAuthKeysResponse); i {
   538| 			case 0:
   539| 				return &v.state
   540| 			case 1:
   541| 				return &v.sizeCache
   542| 			case 2:
   543| 				return &v.unknownFields
   544| 			default:
   545| 				return nil
   546| 			}
   547| 		}
   548| 	}
   549| 	type x struct{}
   550| 	out := protoimpl.TypeBuilder{
   551| 		File: protoimpl.DescBuilder{
   552| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   553| 			RawDescriptor: file_headscale_v1_preauthkey_proto_rawDesc,
   554| 			NumEnums:      0,
   555| 			NumMessages:   7,
   556| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/routes.pb.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| package v1
     2| import (
     3| 	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
     4| 	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
     5| 	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
     6| 	reflect "reflect"
     7| 	sync "sync"
     8| )
     9| const (
    10| 	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
    11| 	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
    12| )
    13| type Route struct {
    14| 	state         protoimpl.MessageState
    15| 	sizeCache     protoimpl.SizeCache
    16| 	unknownFields protoimpl.UnknownFields
    17| 	Id         uint64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
    18| 	Machine    *Machine               `protobuf:"bytes,2,opt,name=machine,proto3" json:"machine,omitempty"`
    19| 	Prefix     string                 `protobuf:"bytes,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
    20| 	Advertised bool                   `protobuf:"varint,4,opt,name=advertised,proto3" json:"advertised,omitempty"`
    21| 	Enabled    bool                   `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled,omitempty"`
    22| 	IsPrimary  bool                   `protobuf:"varint,6,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
    23| 	CreatedAt  *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
    24| 	UpdatedAt  *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
    25| 	DeletedAt  *timestamppb.Timestamp `protobuf:"bytes,9,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
    26| }
    27| func (x *Route) Reset() {
    28| 	*x = Route{}
    29| 	if protoimpl.UnsafeEnabled {
    30| 		mi := &file_headscale_v1_routes_proto_msgTypes[0]
    31| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    32| 		ms.StoreMessageInfo(mi)
    33| 	}
    34| }
    35| func (x *Route) String() string {
    36| 	return protoimpl.X.MessageStringOf(x)
    37| }
    38| func (*Route) ProtoMessage() {}
    39| func (x *Route) ProtoReflect() protoreflect.Message {
    40| 	mi := &file_headscale_v1_routes_proto_msgTypes[0]
    41| 	if protoimpl.UnsafeEnabled && x != nil {
    42| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
    43| 		if ms.LoadMessageInfo() == nil {
    44| 			ms.StoreMessageInfo(mi)
    45| 		}
    46| 		return ms
    47| 	}
    48| 	return mi.MessageOf(x)
    49| }
    50| func (*Route) Descriptor() ([]byte, []int) {
    51| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{0}
    52| }
    53| func (x *Route) GetId() uint64 {
    54| 	if x != nil {
    55| 		return x.Id
    56| 	}
    57| 	return 0
    58| }
    59| func (x *Route) GetMachine() *Machine {
    60| 	if x != nil {
    61| 		return x.Machine
    62| 	}
    63| 	return nil
    64| }
    65| func (x *Route) GetPrefix() string {
    66| 	if x != nil {
    67| 		return x.Prefix
    68| 	}
    69| 	return ""
    70| }
    71| func (x *Route) GetAdvertised() bool {
    72| 	if x != nil {
    73| 		return x.Advertised
    74| 	}
    75| 	return false
    76| }
    77| func (x *Route) GetEnabled() bool {
    78| 	if x != nil {
    79| 		return x.Enabled
    80| 	}
    81| 	return false

# --- HUNK 2: Lines 294-404 ---
   294| 	}
   295| }
   296| func (x *DisableRouteResponse) String() string {
   297| 	return protoimpl.X.MessageStringOf(x)
   298| }
   299| func (*DisableRouteResponse) ProtoMessage() {}
   300| func (x *DisableRouteResponse) ProtoReflect() protoreflect.Message {
   301| 	mi := &file_headscale_v1_routes_proto_msgTypes[6]
   302| 	if protoimpl.UnsafeEnabled && x != nil {
   303| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   304| 		if ms.LoadMessageInfo() == nil {
   305| 			ms.StoreMessageInfo(mi)
   306| 		}
   307| 		return ms
   308| 	}
   309| 	return mi.MessageOf(x)
   310| }
   311| func (*DisableRouteResponse) Descriptor() ([]byte, []int) {
   312| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{6}
   313| }
   314| type GetMachineRoutesRequest struct {
   315| 	state         protoimpl.MessageState
   316| 	sizeCache     protoimpl.SizeCache
   317| 	unknownFields protoimpl.UnknownFields
   318| 	MachineId uint64 `protobuf:"varint,1,opt,name=machine_id,json=machineId,proto3" json:"machine_id,omitempty"`
   319| }
   320| func (x *GetMachineRoutesRequest) Reset() {
   321| 	*x = GetMachineRoutesRequest{}
   322| 	if protoimpl.UnsafeEnabled {
   323| 		mi := &file_headscale_v1_routes_proto_msgTypes[7]
   324| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   325| 		ms.StoreMessageInfo(mi)
   326| 	}
   327| }
   328| func (x *GetMachineRoutesRequest) String() string {
   329| 	return protoimpl.X.MessageStringOf(x)
   330| }
   331| func (*GetMachineRoutesRequest) ProtoMessage() {}
   332| func (x *GetMachineRoutesRequest) ProtoReflect() protoreflect.Message {
   333| 	mi := &file_headscale_v1_routes_proto_msgTypes[7]
   334| 	if protoimpl.UnsafeEnabled && x != nil {
   335| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   336| 		if ms.LoadMessageInfo() == nil {
   337| 			ms.StoreMessageInfo(mi)
   338| 		}
   339| 		return ms
   340| 	}
   341| 	return mi.MessageOf(x)
   342| }
   343| func (*GetMachineRoutesRequest) Descriptor() ([]byte, []int) {
   344| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{7}
   345| }
   346| func (x *GetMachineRoutesRequest) GetMachineId() uint64 {
   347| 	if x != nil {
   348| 		return x.MachineId
   349| 	}
   350| 	return 0
   351| }
   352| type GetMachineRoutesResponse struct {
   353| 	state         protoimpl.MessageState
   354| 	sizeCache     protoimpl.SizeCache
   355| 	unknownFields protoimpl.UnknownFields
   356| 	Routes []*Route `protobuf:"bytes,1,rep,name=routes,proto3" json:"routes,omitempty"`
   357| }
   358| func (x *GetMachineRoutesResponse) Reset() {
   359| 	*x = GetMachineRoutesResponse{}
   360| 	if protoimpl.UnsafeEnabled {
   361| 		mi := &file_headscale_v1_routes_proto_msgTypes[8]
   362| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   363| 		ms.StoreMessageInfo(mi)
   364| 	}
   365| }
   366| func (x *GetMachineRoutesResponse) String() string {
   367| 	return protoimpl.X.MessageStringOf(x)
   368| }
   369| func (*GetMachineRoutesResponse) ProtoMessage() {}
   370| func (x *GetMachineRoutesResponse) ProtoReflect() protoreflect.Message {
   371| 	mi := &file_headscale_v1_routes_proto_msgTypes[8]
   372| 	if protoimpl.UnsafeEnabled && x != nil {
   373| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   374| 		if ms.LoadMessageInfo() == nil {
   375| 			ms.StoreMessageInfo(mi)
   376| 		}
   377| 		return ms
   378| 	}
   379| 	return mi.MessageOf(x)
   380| }
   381| func (*GetMachineRoutesResponse) Descriptor() ([]byte, []int) {
   382| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{8}
   383| }
   384| func (x *GetMachineRoutesResponse) GetRoutes() []*Route {
   385| 	if x != nil {
   386| 		return x.Routes
   387| 	}
   388| 	return nil
   389| }
   390| type DeleteRouteRequest struct {
   391| 	state         protoimpl.MessageState
   392| 	sizeCache     protoimpl.SizeCache
   393| 	unknownFields protoimpl.UnknownFields
   394| 	RouteId uint64 `protobuf:"varint,1,opt,name=route_id,json=routeId,proto3" json:"route_id,omitempty"`
   395| }
   396| func (x *DeleteRouteRequest) Reset() {
   397| 	*x = DeleteRouteRequest{}
   398| 	if protoimpl.UnsafeEnabled {
   399| 		mi := &file_headscale_v1_routes_proto_msgTypes[9]
   400| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   401| 		ms.StoreMessageInfo(mi)
   402| 	}
   403| }
   404| func (x *DeleteRouteRequest) String() string {

# --- HUNK 3: Lines 445-708 ---
   445| func (x *DeleteRouteResponse) ProtoReflect() protoreflect.Message {
   446| 	mi := &file_headscale_v1_routes_proto_msgTypes[10]
   447| 	if protoimpl.UnsafeEnabled && x != nil {
   448| 		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
   449| 		if ms.LoadMessageInfo() == nil {
   450| 			ms.StoreMessageInfo(mi)
   451| 		}
   452| 		return ms
   453| 	}
   454| 	return mi.MessageOf(x)
   455| }
   456| func (*DeleteRouteResponse) Descriptor() ([]byte, []int) {
   457| 	return file_headscale_v1_routes_proto_rawDescGZIP(), []int{10}
   458| }
   459| var File_headscale_v1_routes_proto protoreflect.FileDescriptor
   460| var file_headscale_v1_routes_proto_rawDesc = []byte{
   461| 	0x0a, 0x19, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x72,
   462| 	0x6f, 0x75, 0x74, 0x65, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0c, 0x68, 0x65, 0x61,
   463| 	0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
   464| 	0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
   465| 	0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1a, 0x68, 0x65, 0x61, 0x64,
   466| 	0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x76, 0x31, 0x2f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
   467| 	0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xea, 0x02, 0x0a, 0x05, 0x52, 0x6f, 0x75, 0x74, 0x65,
   468| 	0x12, 0x0e, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x02, 0x69, 0x64,
   469| 	0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
   470| 	0x0b, 0x32, 0x15, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31,
   471| 	0x2e, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x07, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
   472| 	0x65, 0x12, 0x16, 0x0a, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x03, 0x20, 0x01, 0x28,
   473| 	0x09, 0x52, 0x06, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x12, 0x1e, 0x0a, 0x0a, 0x61, 0x64, 0x76,
   474| 	0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0a, 0x61,
   475| 	0x64, 0x76, 0x65, 0x72, 0x74, 0x69, 0x73, 0x65, 0x64, 0x12, 0x18, 0x0a, 0x07, 0x65, 0x6e, 0x61,
   476| 	0x62, 0x6c, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x65, 0x6e, 0x61, 0x62,
   477| 	0x6c, 0x65, 0x64, 0x12, 0x1d, 0x0a, 0x0a, 0x69, 0x73, 0x5f, 0x70, 0x72, 0x69, 0x6d, 0x61, 0x72,
   478| 	0x79, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x09, 0x69, 0x73, 0x50, 0x72, 0x69, 0x6d, 0x61,
   479| 	0x72, 0x79, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74,
   480| 	0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
   481| 	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
   482| 	0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a,
   483| 	0x0a, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28,
   484| 	0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
   485| 	0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x75,
   486| 	0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x41, 0x74, 0x12, 0x39, 0x0a, 0x0a, 0x64, 0x65, 0x6c, 0x65,
   487| 	0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
   488| 	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
   489| 	0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x64, 0x65, 0x6c, 0x65, 0x74, 0x65,
   490| 	0x64, 0x41, 0x74, 0x22, 0x12, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73,
   491| 	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x40, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x52, 0x6f,
   492| 	0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x06,
   493| 	0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x68,
   494| 	0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x52, 0x6f, 0x75, 0x74,
   495| 	0x65, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x2f, 0x0a, 0x12, 0x45, 0x6e, 0x61,
   496| 	0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
   497| 	0x19, 0x0a, 0x08, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
   498| 	0x04, 0x52, 0x07, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x64, 0x22, 0x15, 0x0a, 0x13, 0x45, 0x6e,
   499| 	0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
   500| 	0x65, 0x22, 0x30, 0x0a, 0x13, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f, 0x75, 0x74,
   501| 	0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x75, 0x74,
   502| 	0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x72, 0x6f, 0x75, 0x74,
   503| 	0x65, 0x49, 0x64, 0x22, 0x16, 0x0a, 0x14, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x6f,
   504| 	0x75, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22, 0x38, 0x0a, 0x17, 0x47,
   505| 	0x65, 0x74, 0x4d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52,
   506| 	0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e,
   507| 	0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x09, 0x6d, 0x61, 0x63, 0x68,
   508| 	0x69, 0x6e, 0x65, 0x49, 0x64, 0x22, 0x47, 0x0a, 0x18, 0x47, 0x65, 0x74, 0x4d, 0x61, 0x63, 0x68,
   509| 	0x69, 0x6e, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
   510| 	0x65, 0x12, 0x2b, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
   511| 	0x0b, 0x32, 0x13, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31,
   512| 	0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x22, 0x2f,
   513| 	0x0a, 0x12, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65, 0x71,
   514| 	0x75, 0x65, 0x73, 0x74, 0x12, 0x19, 0x0a, 0x08, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x5f, 0x69, 0x64,
   515| 	0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x52, 0x07, 0x72, 0x6f, 0x75, 0x74, 0x65, 0x49, 0x64, 0x22,
   516| 	0x15, 0x0a, 0x13, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x52, 0x65,
   517| 	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
   518| 	0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65,
   519| 	0x61, 0x64, 0x73, 0x63, 0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76,
   520| 	0x31, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
   521| }
   522| var (
   523| 	file_headscale_v1_routes_proto_rawDescOnce sync.Once
   524| 	file_headscale_v1_routes_proto_rawDescData = file_headscale_v1_routes_proto_rawDesc
   525| )
   526| func file_headscale_v1_routes_proto_rawDescGZIP() []byte {
   527| 	file_headscale_v1_routes_proto_rawDescOnce.Do(func() {
   528| 		file_headscale_v1_routes_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_routes_proto_rawDescData)
   529| 	})
   530| 	return file_headscale_v1_routes_proto_rawDescData
   531| }
   532| var file_headscale_v1_routes_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
   533| var file_headscale_v1_routes_proto_goTypes = []interface{}{
   534| 	(*Route)(nil),                    // 0: headscale.v1.Route
   535| 	(*GetRoutesRequest)(nil),         // 1: headscale.v1.GetRoutesRequest
   536| 	(*GetRoutesResponse)(nil),        // 2: headscale.v1.GetRoutesResponse
   537| 	(*EnableRouteRequest)(nil),       // 3: headscale.v1.EnableRouteRequest
   538| 	(*EnableRouteResponse)(nil),      // 4: headscale.v1.EnableRouteResponse
   539| 	(*DisableRouteRequest)(nil),      // 5: headscale.v1.DisableRouteRequest
   540| 	(*DisableRouteResponse)(nil),     // 6: headscale.v1.DisableRouteResponse
   541| 	(*GetMachineRoutesRequest)(nil),  // 7: headscale.v1.GetMachineRoutesRequest
   542| 	(*GetMachineRoutesResponse)(nil), // 8: headscale.v1.GetMachineRoutesResponse
   543| 	(*DeleteRouteRequest)(nil),       // 9: headscale.v1.DeleteRouteRequest
   544| 	(*DeleteRouteResponse)(nil),      // 10: headscale.v1.DeleteRouteResponse
   545| 	(*Machine)(nil),                  // 11: headscale.v1.Machine
   546| 	(*timestamppb.Timestamp)(nil),    // 12: google.protobuf.Timestamp
   547| }
   548| var file_headscale_v1_routes_proto_depIdxs = []int32{
   549| 	11, // 0: headscale.v1.Route.machine:type_name -> headscale.v1.Machine
   550| 	12, // 1: headscale.v1.Route.created_at:type_name -> google.protobuf.Timestamp
   551| 	12, // 2: headscale.v1.Route.updated_at:type_name -> google.protobuf.Timestamp
   552| 	12, // 3: headscale.v1.Route.deleted_at:type_name -> google.protobuf.Timestamp
   553| 	0,  // 4: headscale.v1.GetRoutesResponse.routes:type_name -> headscale.v1.Route
   554| 	0,  // 5: headscale.v1.GetMachineRoutesResponse.routes:type_name -> headscale.v1.Route
   555| 	6,  // [6:6] is the sub-list for method output_type
   556| 	6,  // [6:6] is the sub-list for method input_type
   557| 	6,  // [6:6] is the sub-list for extension type_name
   558| 	6,  // [6:6] is the sub-list for extension extendee
   559| 	0,  // [0:6] is the sub-list for field type_name
   560| }
   561| func init() { file_headscale_v1_routes_proto_init() }
   562| func file_headscale_v1_routes_proto_init() {
   563| 	if File_headscale_v1_routes_proto != nil {
   564| 		return
   565| 	}
   566| 	file_headscale_v1_machine_proto_init()
   567| 	if !protoimpl.UnsafeEnabled {
   568| 		file_headscale_v1_routes_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
   569| 			switch v := v.(*Route); i {
   570| 			case 0:
   571| 				return &v.state
   572| 			case 1:
   573| 				return &v.sizeCache
   574| 			case 2:
   575| 				return &v.unknownFields
   576| 			default:
   577| 				return nil
   578| 			}
   579| 		}
   580| 		file_headscale_v1_routes_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
   581| 			switch v := v.(*GetRoutesRequest); i {
   582| 			case 0:
   583| 				return &v.state
   584| 			case 1:
   585| 				return &v.sizeCache
   586| 			case 2:
   587| 				return &v.unknownFields
   588| 			default:
   589| 				return nil
   590| 			}
   591| 		}
   592| 		file_headscale_v1_routes_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
   593| 			switch v := v.(*GetRoutesResponse); i {
   594| 			case 0:
   595| 				return &v.state
   596| 			case 1:
   597| 				return &v.sizeCache
   598| 			case 2:
   599| 				return &v.unknownFields
   600| 			default:
   601| 				return nil
   602| 			}
   603| 		}
   604| 		file_headscale_v1_routes_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
   605| 			switch v := v.(*EnableRouteRequest); i {
   606| 			case 0:
   607| 				return &v.state
   608| 			case 1:
   609| 				return &v.sizeCache
   610| 			case 2:
   611| 				return &v.unknownFields
   612| 			default:
   613| 				return nil
   614| 			}
   615| 		}
   616| 		file_headscale_v1_routes_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
   617| 			switch v := v.(*EnableRouteResponse); i {
   618| 			case 0:
   619| 				return &v.state
   620| 			case 1:
   621| 				return &v.sizeCache
   622| 			case 2:
   623| 				return &v.unknownFields
   624| 			default:
   625| 				return nil
   626| 			}
   627| 		}
   628| 		file_headscale_v1_routes_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
   629| 			switch v := v.(*DisableRouteRequest); i {
   630| 			case 0:
   631| 				return &v.state
   632| 			case 1:
   633| 				return &v.sizeCache
   634| 			case 2:
   635| 				return &v.unknownFields
   636| 			default:
   637| 				return nil
   638| 			}
   639| 		}
   640| 		file_headscale_v1_routes_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
   641| 			switch v := v.(*DisableRouteResponse); i {
   642| 			case 0:
   643| 				return &v.state
   644| 			case 1:
   645| 				return &v.sizeCache
   646| 			case 2:
   647| 				return &v.unknownFields
   648| 			default:
   649| 				return nil
   650| 			}
   651| 		}
   652| 		file_headscale_v1_routes_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
   653| 			switch v := v.(*GetMachineRoutesRequest); i {
   654| 			case 0:
   655| 				return &v.state
   656| 			case 1:
   657| 				return &v.sizeCache
   658| 			case 2:
   659| 				return &v.unknownFields
   660| 			default:
   661| 				return nil
   662| 			}
   663| 		}
   664| 		file_headscale_v1_routes_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
   665| 			switch v := v.(*GetMachineRoutesResponse); i {
   666| 			case 0:
   667| 				return &v.state
   668| 			case 1:
   669| 				return &v.sizeCache
   670| 			case 2:
   671| 				return &v.unknownFields
   672| 			default:
   673| 				return nil
   674| 			}
   675| 		}
   676| 		file_headscale_v1_routes_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
   677| 			switch v := v.(*DeleteRouteRequest); i {
   678| 			case 0:
   679| 				return &v.state
   680| 			case 1:
   681| 				return &v.sizeCache
   682| 			case 2:
   683| 				return &v.unknownFields
   684| 			default:
   685| 				return nil
   686| 			}
   687| 		}
   688| 		file_headscale_v1_routes_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
   689| 			switch v := v.(*DeleteRouteResponse); i {
   690| 			case 0:
   691| 				return &v.state
   692| 			case 1:
   693| 				return &v.sizeCache
   694| 			case 2:
   695| 				return &v.unknownFields
   696| 			default:
   697| 				return nil
   698| 			}
   699| 		}
   700| 	}
   701| 	type x struct{}
   702| 	out := protoimpl.TypeBuilder{
   703| 		File: protoimpl.DescBuilder{
   704| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   705| 			RawDescriptor: file_headscale_v1_routes_proto_rawDesc,
   706| 			NumEnums:      0,
   707| 			NumMessages:   11,
   708| 			NumExtensions: 0,


# ====================================================================
# FILE: gen/go/headscale/v1/user.pb.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 477-669 ---
   477| 	0x65, 0x73, 0x74, 0x22, 0x3d, 0x0a, 0x11, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73,
   478| 	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x28, 0x0a, 0x05, 0x75, 0x73, 0x65, 0x72,
   479| 	0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   480| 	0x61, 0x6c, 0x65, 0x2e, 0x76, 0x31, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x52, 0x05, 0x75, 0x73, 0x65,
   481| 	0x72, 0x73, 0x42, 0x29, 0x5a, 0x27, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
   482| 	0x2f, 0x6a, 0x75, 0x61, 0x6e, 0x66, 0x6f, 0x6e, 0x74, 0x2f, 0x68, 0x65, 0x61, 0x64, 0x73, 0x63,
   483| 	0x61, 0x6c, 0x65, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x67, 0x6f, 0x2f, 0x76, 0x31, 0x62, 0x06, 0x70,
   484| 	0x72, 0x6f, 0x74, 0x6f, 0x33,
   485| }
   486| var (
   487| 	file_headscale_v1_user_proto_rawDescOnce sync.Once
   488| 	file_headscale_v1_user_proto_rawDescData = file_headscale_v1_user_proto_rawDesc
   489| )
   490| func file_headscale_v1_user_proto_rawDescGZIP() []byte {
   491| 	file_headscale_v1_user_proto_rawDescOnce.Do(func() {
   492| 		file_headscale_v1_user_proto_rawDescData = protoimpl.X.CompressGZIP(file_headscale_v1_user_proto_rawDescData)
   493| 	})
   494| 	return file_headscale_v1_user_proto_rawDescData
   495| }
   496| var file_headscale_v1_user_proto_msgTypes = make([]protoimpl.MessageInfo, 11)
   497| var file_headscale_v1_user_proto_goTypes = []interface{}{
   498| 	(*User)(nil),                  // 0: headscale.v1.User
   499| 	(*GetUserRequest)(nil),        // 1: headscale.v1.GetUserRequest
   500| 	(*GetUserResponse)(nil),       // 2: headscale.v1.GetUserResponse
   501| 	(*CreateUserRequest)(nil),     // 3: headscale.v1.CreateUserRequest
   502| 	(*CreateUserResponse)(nil),    // 4: headscale.v1.CreateUserResponse
   503| 	(*RenameUserRequest)(nil),     // 5: headscale.v1.RenameUserRequest
   504| 	(*RenameUserResponse)(nil),    // 6: headscale.v1.RenameUserResponse
   505| 	(*DeleteUserRequest)(nil),     // 7: headscale.v1.DeleteUserRequest
   506| 	(*DeleteUserResponse)(nil),    // 8: headscale.v1.DeleteUserResponse
   507| 	(*ListUsersRequest)(nil),      // 9: headscale.v1.ListUsersRequest
   508| 	(*ListUsersResponse)(nil),     // 10: headscale.v1.ListUsersResponse
   509| 	(*timestamppb.Timestamp)(nil), // 11: google.protobuf.Timestamp
   510| }
   511| var file_headscale_v1_user_proto_depIdxs = []int32{
   512| 	11, // 0: headscale.v1.User.created_at:type_name -> google.protobuf.Timestamp
   513| 	0,  // 1: headscale.v1.GetUserResponse.user:type_name -> headscale.v1.User
   514| 	0,  // 2: headscale.v1.CreateUserResponse.user:type_name -> headscale.v1.User
   515| 	0,  // 3: headscale.v1.RenameUserResponse.user:type_name -> headscale.v1.User
   516| 	0,  // 4: headscale.v1.ListUsersResponse.users:type_name -> headscale.v1.User
   517| 	5,  // [5:5] is the sub-list for method output_type
   518| 	5,  // [5:5] is the sub-list for method input_type
   519| 	5,  // [5:5] is the sub-list for extension type_name
   520| 	5,  // [5:5] is the sub-list for extension extendee
   521| 	0,  // [0:5] is the sub-list for field type_name
   522| }
   523| func init() { file_headscale_v1_user_proto_init() }
   524| func file_headscale_v1_user_proto_init() {
   525| 	if File_headscale_v1_user_proto != nil {
   526| 		return
   527| 	}
   528| 	if !protoimpl.UnsafeEnabled {
   529| 		file_headscale_v1_user_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
   530| 			switch v := v.(*User); i {
   531| 			case 0:
   532| 				return &v.state
   533| 			case 1:
   534| 				return &v.sizeCache
   535| 			case 2:
   536| 				return &v.unknownFields
   537| 			default:
   538| 				return nil
   539| 			}
   540| 		}
   541| 		file_headscale_v1_user_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
   542| 			switch v := v.(*GetUserRequest); i {
   543| 			case 0:
   544| 				return &v.state
   545| 			case 1:
   546| 				return &v.sizeCache
   547| 			case 2:
   548| 				return &v.unknownFields
   549| 			default:
   550| 				return nil
   551| 			}
   552| 		}
   553| 		file_headscale_v1_user_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
   554| 			switch v := v.(*GetUserResponse); i {
   555| 			case 0:
   556| 				return &v.state
   557| 			case 1:
   558| 				return &v.sizeCache
   559| 			case 2:
   560| 				return &v.unknownFields
   561| 			default:
   562| 				return nil
   563| 			}
   564| 		}
   565| 		file_headscale_v1_user_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
   566| 			switch v := v.(*CreateUserRequest); i {
   567| 			case 0:
   568| 				return &v.state
   569| 			case 1:
   570| 				return &v.sizeCache
   571| 			case 2:
   572| 				return &v.unknownFields
   573| 			default:
   574| 				return nil
   575| 			}
   576| 		}
   577| 		file_headscale_v1_user_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
   578| 			switch v := v.(*CreateUserResponse); i {
   579| 			case 0:
   580| 				return &v.state
   581| 			case 1:
   582| 				return &v.sizeCache
   583| 			case 2:
   584| 				return &v.unknownFields
   585| 			default:
   586| 				return nil
   587| 			}
   588| 		}
   589| 		file_headscale_v1_user_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
   590| 			switch v := v.(*RenameUserRequest); i {
   591| 			case 0:
   592| 				return &v.state
   593| 			case 1:
   594| 				return &v.sizeCache
   595| 			case 2:
   596| 				return &v.unknownFields
   597| 			default:
   598| 				return nil
   599| 			}
   600| 		}
   601| 		file_headscale_v1_user_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
   602| 			switch v := v.(*RenameUserResponse); i {
   603| 			case 0:
   604| 				return &v.state
   605| 			case 1:
   606| 				return &v.sizeCache
   607| 			case 2:
   608| 				return &v.unknownFields
   609| 			default:
   610| 				return nil
   611| 			}
   612| 		}
   613| 		file_headscale_v1_user_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
   614| 			switch v := v.(*DeleteUserRequest); i {
   615| 			case 0:
   616| 				return &v.state
   617| 			case 1:
   618| 				return &v.sizeCache
   619| 			case 2:
   620| 				return &v.unknownFields
   621| 			default:
   622| 				return nil
   623| 			}
   624| 		}
   625| 		file_headscale_v1_user_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
   626| 			switch v := v.(*DeleteUserResponse); i {
   627| 			case 0:
   628| 				return &v.state
   629| 			case 1:
   630| 				return &v.sizeCache
   631| 			case 2:
   632| 				return &v.unknownFields
   633| 			default:
   634| 				return nil
   635| 			}
   636| 		}
   637| 		file_headscale_v1_user_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
   638| 			switch v := v.(*ListUsersRequest); i {
   639| 			case 0:
   640| 				return &v.state
   641| 			case 1:
   642| 				return &v.sizeCache
   643| 			case 2:
   644| 				return &v.unknownFields
   645| 			default:
   646| 				return nil
   647| 			}
   648| 		}
   649| 		file_headscale_v1_user_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
   650| 			switch v := v.(*ListUsersResponse); i {
   651| 			case 0:
   652| 				return &v.state
   653| 			case 1:
   654| 				return &v.sizeCache
   655| 			case 2:
   656| 				return &v.unknownFields
   657| 			default:
   658| 				return nil
   659| 			}
   660| 		}
   661| 	}
   662| 	type x struct{}
   663| 	out := protoimpl.TypeBuilder{
   664| 		File: protoimpl.DescBuilder{
   665| 			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
   666| 			RawDescriptor: file_headscale_v1_user_proto_rawDesc,
   667| 			NumEnums:      0,
   668| 			NumMessages:   11,
   669| 			NumExtensions: 0,


# ====================================================================
# FILE: hscontrol/acls.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-689 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"fmt"
     6| 	"io"
     7| 	"net/netip"
     8| 	"os"
     9| 	"path/filepath"
    10| 	"strconv"
    11| 	"strings"
    12| 	"time"
    13| 	"github.com/rs/zerolog/log"
    14| 	"github.com/tailscale/hujson"
    15| 	"go4.org/netipx"
    16| 	"gopkg.in/yaml.v3"
    17| 	"tailscale.com/envknob"
    18| 	"tailscale.com/tailcfg"
    19| )
    20| const (
    21| 	errEmptyPolicy       = Error("empty policy")
    22| 	errInvalidAction     = Error("invalid action")
    23| 	errInvalidGroup      = Error("invalid group")
    24| 	errInvalidTag        = Error("invalid tag")
    25| 	errInvalidPortFormat = Error("invalid port format")
    26| 	errWildcardIsNeeded  = Error("wildcard as port is required for the protocol")
    27| )
    28| const (
    29| 	Base8              = 8
    30| 	Base10             = 10
    31| 	BitSize16          = 16
    32| 	BitSize32          = 32
    33| 	BitSize64          = 64
    34| 	portRangeBegin     = 0
    35| 	portRangeEnd       = 65535
    36| 	expectedTokenItems = 2
    37| )
    38| const (
    39| 	protocolICMP     = 1   // Internet Control Message
    40| 	protocolIGMP     = 2   // Internet Group Management
    41| 	protocolIPv4     = 4   // IPv4 encapsulation
    42| 	protocolTCP      = 6   // Transmission Control
    43| 	protocolEGP      = 8   // Exterior Gateway Protocol
    44| 	protocolIGP      = 9   // any private interior gateway (used by Cisco for their IGRP)
    45| 	protocolUDP      = 17  // User Datagram
    46| 	protocolGRE      = 47  // Generic Routing Encapsulation
    47| 	protocolESP      = 50  // Encap Security Payload
    48| 	protocolAH       = 51  // Authentication Header
    49| 	protocolIPv6ICMP = 58  // ICMP for IPv6
    50| 	protocolSCTP     = 132 // Stream Control Transmission Protocol
    51| 	ProtocolFC       = 133 // Fibre Channel
    52| )
    53| var featureEnableSSH = envknob.RegisterBool("HEADSCALE_EXPERIMENTAL_FEATURE_SSH")
    54| func (h *Headscale) LoadACLPolicyFromPath(path string) error {
    55| 	log.Debug().
    56| 		Str("func", "LoadACLPolicy").
    57| 		Str("path", path).
    58| 		Msg("Loading ACL policy from path")
    59| 	policyFile, err := os.Open(path)
    60| 	if err != nil {
    61| 		return err
    62| 	}
    63| 	defer policyFile.Close()
    64| 	policyBytes, err := io.ReadAll(policyFile)
    65| 	if err != nil {
    66| 		return err
    67| 	}
    68| 	log.Debug().
    69| 		Str("path", path).
    70| 		Bytes("file", policyBytes).
    71| 		Msg("Loading ACLs")
    72| 	switch filepath.Ext(path) {
    73| 	case ".yml", ".yaml":
    74| 		return h.LoadACLPolicyFromBytes(policyBytes, "yaml")
    75| 	}
    76| 	return h.LoadACLPolicyFromBytes(policyBytes, "hujson")
    77| }
    78| func (h *Headscale) LoadACLPolicyFromBytes(acl []byte, format string) error {
    79| 	var policy ACLPolicy
    80| 	switch format {
    81| 	case "yaml":
    82| 		err := yaml.Unmarshal(acl, &policy)
    83| 		if err != nil {
    84| 			return err
    85| 		}
    86| 	default:
    87| 		ast, err := hujson.Parse(acl)
    88| 		if err != nil {
    89| 			return err
    90| 		}
    91| 		ast.Standardize()
    92| 		acl = ast.Pack()
    93| 		err = json.Unmarshal(acl, &policy)
    94| 		if err != nil {
    95| 			return err
    96| 		}
    97| 	}
    98| 	if policy.IsZero() {
    99| 		return errEmptyPolicy
   100| 	}
   101| 	h.aclPolicy = &policy
   102| 	return h.UpdateACLRules()
   103| }
   104| func (h *Headscale) UpdateACLRules() error {
   105| 	machines, err := h.ListMachines()
   106| 	if err != nil {
   107| 		return err
   108| 	}
   109| 	if h.aclPolicy == nil {
   110| 		return errEmptyPolicy
   111| 	}
   112| 	rules, err := h.aclPolicy.generateFilterRules(machines, h.cfg.OIDC.StripEmaildomain)
   113| 	if err != nil {
   114| 		return err
   115| 	}
   116| 	log.Trace().Interface("ACL", rules).Msg("ACL rules generated")
   117| 	h.aclRules = rules
   118| 	if featureEnableSSH() {
   119| 		sshRules, err := h.generateSSHRules()
   120| 		if err != nil {
   121| 			return err
   122| 		}
   123| 		log.Trace().Interface("SSH", sshRules).Msg("SSH rules generated")
   124| 		if h.sshPolicy == nil {
   125| 			h.sshPolicy = &tailcfg.SSHPolicy{}
   126| 		}
   127| 		h.sshPolicy.Rules = sshRules
   128| 	} else if h.aclPolicy != nil && len(h.aclPolicy.SSHs) > 0 {
   129| 		log.Info().Msg("SSH ACLs has been defined, but HEADSCALE_EXPERIMENTAL_FEATURE_SSH is not enabled, this is a unstable feature, check docs before activating")
   130| 	}
   131| 	return nil
   132| }
   133| func (pol *ACLPolicy) generateFilterRules(
   134| 	machines []Machine,
   135| 	stripEmailDomain bool,
   136| ) ([]tailcfg.FilterRule, error) {
   137| 	rules := []tailcfg.FilterRule{}
   138| 	for index, acl := range pol.ACLs {
   139| 		if acl.Action != "accept" {
   140| 			return nil, errInvalidAction
   141| 		}
   142| 		srcIPs := []string{}
   143| 		for srcIndex, src := range acl.Sources {
   144| 			srcs, err := pol.getIPsFromSource(src, machines, stripEmailDomain)
   145| 			if err != nil {
   146| 				log.Error().
   147| 					Interface("src", src).
   148| 					Int("ACL index", index).
   149| 					Int("Src index", srcIndex).
   150| 					Msgf("Error parsing ACL")
   151| 				return nil, err
   152| 			}
   153| 			srcIPs = append(srcIPs, srcs...)
   154| 		}
   155| 		protocols, needsWildcard, err := parseProtocol(acl.Protocol)
   156| 		if err != nil {
   157| 			log.Error().
   158| 				Msgf("Error parsing ACL %d. protocol unknown %s", index, acl.Protocol)
   159| 			return nil, err
   160| 		}
   161| 		destPorts := []tailcfg.NetPortRange{}
   162| 		for destIndex, dest := range acl.Destinations {
   163| 			dests, err := pol.getNetPortRangeFromDestination(
   164| 				dest,
   165| 				machines,
   166| 				needsWildcard,
   167| 				stripEmailDomain,
   168| 			)
   169| 			if err != nil {
   170| 				log.Error().
   171| 					Interface("dest", dest).
   172| 					Int("ACL index", index).
   173| 					Int("dest index", destIndex).
   174| 					Msgf("Error parsing ACL")
   175| 				return nil, err
   176| 			}
   177| 			destPorts = append(destPorts, dests...)
   178| 		}
   179| 		rules = append(rules, tailcfg.FilterRule{
   180| 			SrcIPs:   srcIPs,
   181| 			DstPorts: destPorts,
   182| 			IPProto:  protocols,
   183| 		})
   184| 	}
   185| 	return rules, nil
   186| }
   187| func (h *Headscale) generateSSHRules() ([]*tailcfg.SSHRule, error) {
   188| 	rules := []*tailcfg.SSHRule{}
   189| 	if h.aclPolicy == nil {
   190| 		return nil, errEmptyPolicy
   191| 	}
   192| 	machines, err := h.ListMachines()
   193| 	if err != nil {
   194| 		return nil, err
   195| 	}
   196| 	acceptAction := tailcfg.SSHAction{
   197| 		Message:                  "",
   198| 		Reject:                   false,
   199| 		Accept:                   true,
   200| 		SessionDuration:          0,
   201| 		AllowAgentForwarding:     false,
   202| 		HoldAndDelegate:          "",
   203| 		AllowLocalPortForwarding: true,
   204| 	}
   205| 	rejectAction := tailcfg.SSHAction{
   206| 		Message:                  "",
   207| 		Reject:                   true,
   208| 		Accept:                   false,
   209| 		SessionDuration:          0,
   210| 		AllowAgentForwarding:     false,
   211| 		HoldAndDelegate:          "",
   212| 		AllowLocalPortForwarding: false,
   213| 	}
   214| 	for index, sshACL := range h.aclPolicy.SSHs {
   215| 		action := rejectAction
   216| 		switch sshACL.Action {
   217| 		case "accept":
   218| 			action = acceptAction
   219| 		case "check":
   220| 			checkAction, err := sshCheckAction(sshACL.CheckPeriod)
   221| 			if err != nil {
   222| 				log.Error().
   223| 					Msgf("Error parsing SSH %d, check action with unparsable duration '%s'", index, sshACL.CheckPeriod)
   224| 			} else {
   225| 				action = *checkAction
   226| 			}
   227| 		default:
   228| 			log.Error().
   229| 				Msgf("Error parsing SSH %d, unknown action '%s'", index, sshACL.Action)
   230| 			return nil, err
   231| 		}
   232| 		principals := make([]*tailcfg.SSHPrincipal, 0, len(sshACL.Sources))
   233| 		for innerIndex, rawSrc := range sshACL.Sources {
   234| 			if isWildcard(rawSrc) {
   235| 				principals = append(principals, &tailcfg.SSHPrincipal{
   236| 					Any: true,
   237| 				})
   238| 			} else if isGroup(rawSrc) {
   239| 				users, err := h.aclPolicy.getUsersInGroup(rawSrc, h.cfg.OIDC.StripEmaildomain)
   240| 				if err != nil {
   241| 					log.Error().
   242| 						Msgf("Error parsing SSH %d, Source %d", index, innerIndex)
   243| 					return nil, err
   244| 				}
   245| 				for _, user := range users {
   246| 					principals = append(principals, &tailcfg.SSHPrincipal{
   247| 						UserLogin: user,
   248| 					})
   249| 				}
   250| 			} else {
   251| 				expandedSrcs, err := h.aclPolicy.expandAlias(
   252| 					machines,
   253| 					rawSrc,
   254| 					h.cfg.OIDC.StripEmaildomain,
   255| 				)
   256| 				if err != nil {
   257| 					log.Error().
   258| 						Msgf("Error parsing SSH %d, Source %d", index, innerIndex)
   259| 					return nil, err
   260| 				}
   261| 				for _, expandedSrc := range expandedSrcs.Prefixes() {
   262| 					principals = append(principals, &tailcfg.SSHPrincipal{
   263| 						NodeIP: expandedSrc.Addr().String(),
   264| 					})
   265| 				}
   266| 			}
   267| 		}
   268| 		userMap := make(map[string]string, len(sshACL.Users))
   269| 		for _, user := range sshACL.Users {
   270| 			userMap[user] = "="
   271| 		}
   272| 		rules = append(rules, &tailcfg.SSHRule{
   273| 			Principals: principals,
   274| 			SSHUsers:   userMap,
   275| 			Action:     &action,
   276| 		})
   277| 	}
   278| 	return rules, nil
   279| }
   280| func sshCheckAction(duration string) (*tailcfg.SSHAction, error) {
   281| 	sessionLength, err := time.ParseDuration(duration)
   282| 	if err != nil {
   283| 		return nil, err
   284| 	}
   285| 	return &tailcfg.SSHAction{
   286| 		Message:                  "",
   287| 		Reject:                   false,
   288| 		Accept:                   true,
   289| 		SessionDuration:          sessionLength,
   290| 		AllowAgentForwarding:     false,
   291| 		HoldAndDelegate:          "",
   292| 		AllowLocalPortForwarding: true,
   293| 	}, nil
   294| }
   295| func (pol *ACLPolicy) getIPsFromSource(
   296| 	src string,
   297| 	machines []Machine,
   298| 	stripEmaildomain bool,
   299| ) ([]string, error) {
   300| 	ipSet, err := pol.expandAlias(machines, src, stripEmaildomain)
   301| 	if err != nil {
   302| 		return []string{}, err
   303| 	}
   304| 	prefixes := []string{}
   305| 	for _, prefix := range ipSet.Prefixes() {
   306| 		prefixes = append(prefixes, prefix.String())
   307| 	}
   308| 	return prefixes, nil
   309| }
   310| func (pol *ACLPolicy) getNetPortRangeFromDestination(
   311| 	dest string,
   312| 	machines []Machine,
   313| 	needsWildcard bool,
   314| 	stripEmaildomain bool,
   315| ) ([]tailcfg.NetPortRange, error) {
   316| 	var tokens []string
   317| 	log.Trace().Str("destination", dest).Msg("generating policy destination")
   318| 	tokens = strings.Split(dest, ":")
   319| 	if len(tokens) < expectedTokenItems || len(tokens) > 3 {
   320| 		port := tokens[len(tokens)-1]
   321| 		maybeIPv6Str := strings.TrimSuffix(dest, ":"+port)
   322| 		log.Trace().Str("maybeIPv6Str", maybeIPv6Str).Msg("")
   323| 		if maybeIPv6, err := netip.ParseAddr(maybeIPv6Str); err != nil && !maybeIPv6.Is6() {
   324| 			log.Trace().Err(err).Msg("trying to parse as IPv6")
   325| 			return nil, fmt.Errorf(
   326| 				"failed to parse destination, tokens %v: %w",
   327| 				tokens,
   328| 				errInvalidPortFormat,
   329| 			)
   330| 		} else {
   331| 			tokens = []string{maybeIPv6Str, port}
   332| 		}
   333| 	}
   334| 	log.Trace().Strs("tokens", tokens).Msg("generating policy destination")
   335| 	var alias string
   336| 	if len(tokens) == expectedTokenItems {
   337| 		alias = tokens[0]
   338| 	} else {
   339| 		alias = fmt.Sprintf("%s:%s", tokens[0], tokens[1])
   340| 	}
   341| 	expanded, err := pol.expandAlias(
   342| 		machines,
   343| 		alias,
   344| 		stripEmaildomain,
   345| 	)
   346| 	if err != nil {
   347| 		return nil, err
   348| 	}
   349| 	ports, err := expandPorts(tokens[len(tokens)-1], needsWildcard)
   350| 	if err != nil {
   351| 		return nil, err
   352| 	}
   353| 	dests := []tailcfg.NetPortRange{}
   354| 	for _, dest := range expanded.Prefixes() {
   355| 		for _, port := range *ports {
   356| 			pr := tailcfg.NetPortRange{
   357| 				IP:    dest.String(),
   358| 				Ports: port,
   359| 			}
   360| 			dests = append(dests, pr)
   361| 		}
   362| 	}
   363| 	return dests, nil
   364| }
   365| func parseProtocol(protocol string) ([]int, bool, error) {
   366| 	switch protocol {
   367| 	case "":
   368| 		return nil, false, nil
   369| 	case "igmp":
   370| 		return []int{protocolIGMP}, true, nil
   371| 	case "ipv4", "ip-in-ip":
   372| 		return []int{protocolIPv4}, true, nil
   373| 	case "tcp":
   374| 		return []int{protocolTCP}, false, nil
   375| 	case "egp":
   376| 		return []int{protocolEGP}, true, nil
   377| 	case "igp":
   378| 		return []int{protocolIGP}, true, nil
   379| 	case "udp":
   380| 		return []int{protocolUDP}, false, nil
   381| 	case "gre":
   382| 		return []int{protocolGRE}, true, nil
   383| 	case "esp":
   384| 		return []int{protocolESP}, true, nil
   385| 	case "ah":
   386| 		return []int{protocolAH}, true, nil
   387| 	case "sctp":
   388| 		return []int{protocolSCTP}, false, nil
   389| 	case "icmp":
   390| 		return []int{protocolICMP, protocolIPv6ICMP}, true, nil
   391| 	default:
   392| 		protocolNumber, err := strconv.Atoi(protocol)
   393| 		if err != nil {
   394| 			return nil, false, err
   395| 		}
   396| 		needsWildcard := protocolNumber != protocolTCP &&
   397| 			protocolNumber != protocolUDP &&
   398| 			protocolNumber != protocolSCTP
   399| 		return []int{protocolNumber}, needsWildcard, nil
   400| 	}
   401| }
   402| func (pol *ACLPolicy) expandAlias(
   403| 	machines Machines,
   404| 	alias string,
   405| 	stripEmailDomain bool,
   406| ) (*netipx.IPSet, error) {
   407| 	if isWildcard(alias) {
   408| 		return parseIPSet("*", nil)
   409| 	}
   410| 	build := netipx.IPSetBuilder{}
   411| 	log.Debug().
   412| 		Str("alias", alias).
   413| 		Msg("Expanding")
   414| 	if isGroup(alias) {
   415| 		return pol.getIPsFromGroup(alias, machines, stripEmailDomain)
   416| 	}
   417| 	if isTag(alias) {
   418| 		return pol.getIPsFromTag(alias, machines, stripEmailDomain)
   419| 	}
   420| 	if ips, err := pol.getIPsForUser(alias, machines, stripEmailDomain); ips != nil {
   421| 		return ips, err
   422| 	}
   423| 	if h, ok := pol.Hosts[alias]; ok {
   424| 		log.Trace().Str("host", h.String()).Msg("expandAlias got hosts entry")
   425| 		return pol.expandAlias(machines, h.String(), stripEmailDomain)
   426| 	}
   427| 	if ip, err := netip.ParseAddr(alias); err == nil {
   428| 		return pol.getIPsFromSingleIP(ip, machines)
   429| 	}
   430| 	if prefix, err := netip.ParsePrefix(alias); err == nil {
   431| 		return pol.getIPsFromIPPrefix(prefix, machines)
   432| 	}
   433| 	log.Warn().Msgf("No IPs found with the alias %v", alias)
   434| 	return build.IPSet()
   435| }
   436| func excludeCorrectlyTaggedNodes(
   437| 	aclPolicy *ACLPolicy,
   438| 	nodes []Machine,
   439| 	user string,
   440| 	stripEmailDomain bool,
   441| ) []Machine {
   442| 	out := []Machine{}
   443| 	tags := []string{}
   444| 	for tag := range aclPolicy.TagOwners {
   445| 		owners, _ := getTagOwners(aclPolicy, user, stripEmailDomain)
   446| 		ns := append(owners, user)
   447| 		if contains(ns, user) {
   448| 			tags = append(tags, tag)
   449| 		}
   450| 	}
   451| 	for _, machine := range nodes {
   452| 		hi := machine.GetHostInfo()
   453| 		found := false
   454| 		for _, t := range hi.RequestTags {
   455| 			if contains(tags, t) {
   456| 				found = true
   457| 				break
   458| 			}
   459| 		}
   460| 		if len(machine.ForcedTags) > 0 {
   461| 			found = true
   462| 		}
   463| 		if !found {
   464| 			out = append(out, machine)
   465| 		}
   466| 	}
   467| 	return out
   468| }
   469| func expandPorts(portsStr string, needsWildcard bool) (*[]tailcfg.PortRange, error) {
   470| 	if isWildcard(portsStr) {
   471| 		return &[]tailcfg.PortRange{
   472| 			{First: portRangeBegin, Last: portRangeEnd},
   473| 		}, nil
   474| 	}
   475| 	if needsWildcard {
   476| 		return nil, errWildcardIsNeeded
   477| 	}
   478| 	ports := []tailcfg.PortRange{}
   479| 	for _, portStr := range strings.Split(portsStr, ",") {
   480| 		log.Trace().Msgf("parsing portstring: %s", portStr)
   481| 		rang := strings.Split(portStr, "-")
   482| 		switch len(rang) {
   483| 		case 1:
   484| 			port, err := strconv.ParseUint(rang[0], Base10, BitSize16)
   485| 			if err != nil {
   486| 				return nil, err
   487| 			}
   488| 			ports = append(ports, tailcfg.PortRange{
   489| 				First: uint16(port),
   490| 				Last:  uint16(port),
   491| 			})
   492| 		case expectedTokenItems:
   493| 			start, err := strconv.ParseUint(rang[0], Base10, BitSize16)
   494| 			if err != nil {
   495| 				return nil, err
   496| 			}
   497| 			last, err := strconv.ParseUint(rang[1], Base10, BitSize16)
   498| 			if err != nil {
   499| 				return nil, err
   500| 			}
   501| 			ports = append(ports, tailcfg.PortRange{
   502| 				First: uint16(start),
   503| 				Last:  uint16(last),
   504| 			})
   505| 		default:
   506| 			return nil, errInvalidPortFormat
   507| 		}
   508| 	}
   509| 	return &ports, nil
   510| }
   511| func filterMachinesByUser(machines []Machine, user string) []Machine {
   512| 	out := []Machine{}
   513| 	for _, machine := range machines {
   514| 		if machine.User.Name == user {
   515| 			out = append(out, machine)
   516| 		}
   517| 	}
   518| 	return out
   519| }
   520| func getTagOwners(
   521| 	pol *ACLPolicy,
   522| 	tag string,
   523| 	stripEmailDomain bool,
   524| ) ([]string, error) {
   525| 	var owners []string
   526| 	ows, ok := pol.TagOwners[tag]
   527| 	if !ok {
   528| 		return []string{}, fmt.Errorf(
   529| 			"%w. %v isn't owned by a TagOwner. Please add one first. https://tailscale.com/kb/1018/acls/#tag-owners",
   530| 			errInvalidTag,
   531| 			tag,
   532| 		)
   533| 	}
   534| 	for _, owner := range ows {
   535| 		if isGroup(owner) {
   536| 			gs, err := pol.getUsersInGroup(owner, stripEmailDomain)
   537| 			if err != nil {
   538| 				return []string{}, err
   539| 			}
   540| 			owners = append(owners, gs...)
   541| 		} else {
   542| 			owners = append(owners, owner)
   543| 		}
   544| 	}
   545| 	return owners, nil
   546| }
   547| func (pol *ACLPolicy) getUsersInGroup(
   548| 	group string,
   549| 	stripEmailDomain bool,
   550| ) ([]string, error) {
   551| 	users := []string{}
   552| 	log.Trace().Caller().Interface("pol", pol).Msg("test")
   553| 	aclGroups, ok := pol.Groups[group]
   554| 	if !ok {
   555| 		return []string{}, fmt.Errorf(
   556| 			"group %v isn't registered. %w",
   557| 			group,
   558| 			errInvalidGroup,
   559| 		)
   560| 	}
   561| 	for _, group := range aclGroups {
   562| 		if isGroup(group) {
   563| 			return []string{}, fmt.Errorf(
   564| 				"%w. A group cannot be composed of groups. https://tailscale.com/kb/1018/acls/#groups",
   565| 				errInvalidGroup,
   566| 			)
   567| 		}
   568| 		grp, err := NormalizeToFQDNRules(group, stripEmailDomain)
   569| 		if err != nil {
   570| 			return []string{}, fmt.Errorf(
   571| 				"failed to normalize group %q, err: %w",
   572| 				group,
   573| 				errInvalidGroup,
   574| 			)
   575| 		}
   576| 		users = append(users, grp)
   577| 	}
   578| 	return users, nil
   579| }
   580| func (pol *ACLPolicy) getIPsFromGroup(
   581| 	group string,
   582| 	machines Machines,
   583| 	stripEmailDomain bool,
   584| ) (*netipx.IPSet, error) {
   585| 	build := netipx.IPSetBuilder{}
   586| 	users, err := pol.getUsersInGroup(group, stripEmailDomain)
   587| 	if err != nil {
   588| 		return &netipx.IPSet{}, err
   589| 	}
   590| 	for _, user := range users {
   591| 		filteredMachines := filterMachinesByUser(machines, user)
   592| 		for _, machine := range filteredMachines {
   593| 			machine.IPAddresses.AppendToIPSet(&build)
   594| 		}
   595| 	}
   596| 	return build.IPSet()
   597| }
   598| func (pol *ACLPolicy) getIPsFromTag(
   599| 	alias string,
   600| 	machines Machines,
   601| 	stripEmailDomain bool,
   602| ) (*netipx.IPSet, error) {
   603| 	build := netipx.IPSetBuilder{}
   604| 	for _, machine := range machines {
   605| 		if contains(machine.ForcedTags, alias) {
   606| 			machine.IPAddresses.AppendToIPSet(&build)
   607| 		}
   608| 	}
   609| 	owners, err := getTagOwners(pol, alias, stripEmailDomain)
   610| 	if err != nil {
   611| 		if errors.Is(err, errInvalidTag) {
   612| 			ipSet, _ := build.IPSet()
   613| 			if len(ipSet.Prefixes()) == 0 {
   614| 				return ipSet, fmt.Errorf(
   615| 					"%w. %v isn't owned by a TagOwner and no forced tags are defined",
   616| 					errInvalidTag,
   617| 					alias,
   618| 				)
   619| 			}
   620| 			return build.IPSet()
   621| 		} else {
   622| 			return nil, err
   623| 		}
   624| 	}
   625| 	for _, user := range owners {
   626| 		machines := filterMachinesByUser(machines, user)
   627| 		for _, machine := range machines {
   628| 			hi := machine.GetHostInfo()
   629| 			if contains(hi.RequestTags, alias) {
   630| 				machine.IPAddresses.AppendToIPSet(&build)
   631| 			}
   632| 		}
   633| 	}
   634| 	return build.IPSet()
   635| }
   636| func (pol *ACLPolicy) getIPsForUser(
   637| 	user string,
   638| 	machines Machines,
   639| 	stripEmailDomain bool,
   640| ) (*netipx.IPSet, error) {
   641| 	build := netipx.IPSetBuilder{}
   642| 	filteredMachines := filterMachinesByUser(machines, user)
   643| 	filteredMachines = excludeCorrectlyTaggedNodes(pol, filteredMachines, user, stripEmailDomain)
   644| 	if len(filteredMachines) == 0 {
   645| 		return nil, nil //nolint
   646| 	}
   647| 	for _, machine := range filteredMachines {
   648| 		machine.IPAddresses.AppendToIPSet(&build)
   649| 	}
   650| 	return build.IPSet()
   651| }
   652| func (pol *ACLPolicy) getIPsFromSingleIP(
   653| 	ip netip.Addr,
   654| 	machines Machines,
   655| ) (*netipx.IPSet, error) {
   656| 	log.Trace().Str("ip", ip.String()).Msg("expandAlias got ip")
   657| 	matches := machines.FilterByIP(ip)
   658| 	build := netipx.IPSetBuilder{}
   659| 	build.Add(ip)
   660| 	for _, machine := range matches {
   661| 		machine.IPAddresses.AppendToIPSet(&build)
   662| 	}
   663| 	return build.IPSet()
   664| }
   665| func (pol *ACLPolicy) getIPsFromIPPrefix(
   666| 	prefix netip.Prefix,
   667| 	machines Machines,
   668| ) (*netipx.IPSet, error) {
   669| 	log.Trace().Str("prefix", prefix.String()).Msg("expandAlias got prefix")
   670| 	build := netipx.IPSetBuilder{}
   671| 	build.AddPrefix(prefix)
   672| 	for _, machine := range machines {
   673| 		for _, ip := range machine.IPAddresses {
   674| 			if prefix.Contains(ip) {
   675| 				machine.IPAddresses.AppendToIPSet(&build)
   676| 			}
   677| 		}
   678| 	}
   679| 	return build.IPSet()
   680| }
   681| func isWildcard(str string) bool {
   682| 	return str == "*"
   683| }
   684| func isGroup(str string) bool {
   685| 	return strings.HasPrefix(str, "group:")
   686| }
   687| func isTag(str string) bool {
   688| 	return strings.HasPrefix(str, "tag:")
   689| }


# ====================================================================
# FILE: hscontrol/api_common.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| package hscontrol
     2| import (
     3| 	"time"
     4| 	"github.com/rs/zerolog/log"
     5| 	"tailscale.com/tailcfg"
     6| )
     7| func (h *Headscale) generateMapResponse(
     8| 	mapRequest tailcfg.MapRequest,
     9| 	machine *Machine,
    10| ) (*tailcfg.MapResponse, error) {
    11| 	log.Trace().
    12| 		Str("func", "generateMapResponse").
    13| 		Str("machine", mapRequest.Hostinfo.Hostname).
    14| 		Msg("Creating Map response")
    15| 	node, err := h.toNode(*machine, h.cfg.BaseDomain, h.cfg.DNSConfig)
    16| 	if err != nil {
    17| 		log.Error().
    18| 			Caller().
    19| 			Str("func", "generateMapResponse").
    20| 			Err(err).
    21| 			Msg("Cannot convert to node")
    22| 		return nil, err
    23| 	}
    24| 	peers, err := h.getValidPeers(machine)
    25| 	if err != nil {
    26| 		log.Error().
    27| 			Caller().
    28| 			Str("func", "generateMapResponse").
    29| 			Err(err).
    30| 			Msg("Cannot fetch peers")
    31| 		return nil, err
    32| 	}
    33| 	profiles := h.getMapResponseUserProfiles(*machine, peers)
    34| 	nodePeers, err := h.toNodes(peers, h.cfg.BaseDomain, h.cfg.DNSConfig)
    35| 	if err != nil {
    36| 		log.Error().
    37| 			Caller().
    38| 			Str("func", "generateMapResponse").
    39| 			Err(err).
    40| 			Msg("Failed to convert peers to Tailscale nodes")
    41| 		return nil, err
    42| 	}
    43| 	dnsConfig := getMapResponseDNSConfig(
    44| 		h.cfg.DNSConfig,
    45| 		h.cfg.BaseDomain,
    46| 		*machine,
    47| 		peers,
    48| 	)
    49| 	now := time.Now()
    50| 	resp := tailcfg.MapResponse{
    51| 		KeepAlive: false,
    52| 		Node:      node,
    53| 		DERPMap: h.DERPMap,
    54| 		Peers: nodePeers,
    55| 		DNSConfig: dnsConfig,
    56| 		Domain: h.cfg.BaseDomain,
    57| 		CollectServices: "false",
    58| 		PacketFilter: h.aclRules,
    59| 		UserProfiles: profiles,
    60| 		SSHPolicy: h.sshPolicy,
    61| 		ControlTime: &now,
    62| 		Debug: &tailcfg.Debug{
    63| 			DisableLogTail:      !h.cfg.LogTail.Enabled,
    64| 			RandomizeClientPort: h.cfg.RandomizeClientPort,
    65| 		},
    66| 	}
    67| 	log.Trace().
    68| 		Str("func", "generateMapResponse").
    69| 		Str("machine", mapRequest.Hostinfo.Hostname).
    70| 		Msgf("Generated map response: %s", tailMapResponseToString(resp))
    71| 	return &resp, nil
    72| }


# ====================================================================
# FILE: hscontrol/api_key.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-114 ---
     1| package hscontrol
     2| import (
     3| 	"fmt"
     4| 	"strings"
     5| 	"time"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"golang.org/x/crypto/bcrypt"
     8| 	"google.golang.org/protobuf/types/known/timestamppb"
     9| )
    10| const (
    11| 	apiPrefixLength = 7
    12| 	apiKeyLength    = 32
    13| 	ErrAPIKeyFailedToParse = Error("Failed to parse ApiKey")
    14| )
    15| type APIKey struct {
    16| 	ID     uint64 `gorm:"primary_key"`
    17| 	Prefix string `gorm:"uniqueIndex"`
    18| 	Hash   []byte
    19| 	CreatedAt  *time.Time
    20| 	Expiration *time.Time
    21| 	LastSeen   *time.Time
    22| }
    23| func (h *Headscale) CreateAPIKey(
    24| 	expiration *time.Time,
    25| ) (string, *APIKey, error) {
    26| 	prefix, err := GenerateRandomStringURLSafe(apiPrefixLength)
    27| 	if err != nil {
    28| 		return "", nil, err
    29| 	}
    30| 	toBeHashed, err := GenerateRandomStringURLSafe(apiKeyLength)
    31| 	if err != nil {
    32| 		return "", nil, err
    33| 	}
    34| 	keyStr := prefix + "." + toBeHashed
    35| 	hash, err := bcrypt.GenerateFromPassword([]byte(toBeHashed), bcrypt.DefaultCost)
    36| 	if err != nil {
    37| 		return "", nil, err
    38| 	}
    39| 	key := APIKey{
    40| 		Prefix:     prefix,
    41| 		Hash:       hash,
    42| 		Expiration: expiration,
    43| 	}
    44| 	if err := h.db.Save(&key).Error; err != nil {
    45| 		return "", nil, fmt.Errorf("failed to save API key to database: %w", err)
    46| 	}
    47| 	return keyStr, &key, nil
    48| }
    49| func (h *Headscale) ListAPIKeys() ([]APIKey, error) {
    50| 	keys := []APIKey{}
    51| 	if err := h.db.Find(&keys).Error; err != nil {
    52| 		return nil, err
    53| 	}
    54| 	return keys, nil
    55| }
    56| func (h *Headscale) GetAPIKey(prefix string) (*APIKey, error) {
    57| 	key := APIKey{}
    58| 	if result := h.db.First(&key, "prefix = ?", prefix); result.Error != nil {
    59| 		return nil, result.Error
    60| 	}
    61| 	return &key, nil
    62| }
    63| func (h *Headscale) GetAPIKeyByID(id uint64) (*APIKey, error) {
    64| 	key := APIKey{}
    65| 	if result := h.db.Find(&APIKey{ID: id}).First(&key); result.Error != nil {
    66| 		return nil, result.Error
    67| 	}
    68| 	return &key, nil
    69| }
    70| func (h *Headscale) DestroyAPIKey(key APIKey) error {
    71| 	if result := h.db.Unscoped().Delete(key); result.Error != nil {
    72| 		return result.Error
    73| 	}
    74| 	return nil
    75| }
    76| func (h *Headscale) ExpireAPIKey(key *APIKey) error {
    77| 	if err := h.db.Model(&key).Update("Expiration", time.Now()).Error; err != nil {
    78| 		return err
    79| 	}
    80| 	return nil
    81| }
    82| func (h *Headscale) ValidateAPIKey(keyStr string) (bool, error) {
    83| 	prefix, hash, found := strings.Cut(keyStr, ".")
    84| 	if !found {
    85| 		return false, ErrAPIKeyFailedToParse
    86| 	}
    87| 	key, err := h.GetAPIKey(prefix)
    88| 	if err != nil {
    89| 		return false, fmt.Errorf("failed to validate api key: %w", err)
    90| 	}
    91| 	if key.Expiration.Before(time.Now()) {
    92| 		return false, nil
    93| 	}
    94| 	if err := bcrypt.CompareHashAndPassword(key.Hash, []byte(hash)); err != nil {
    95| 		return false, err
    96| 	}
    97| 	return true, nil
    98| }
    99| func (key *APIKey) toProto() *v1.ApiKey {
   100| 	protoKey := v1.ApiKey{
   101| 		Id:     key.ID,
   102| 		Prefix: key.Prefix,
   103| 	}
   104| 	if key.Expiration != nil {
   105| 		protoKey.Expiration = timestamppb.New(*key.Expiration)
   106| 	}
   107| 	if key.CreatedAt != nil {
   108| 		protoKey.CreatedAt = timestamppb.New(*key.CreatedAt)
   109| 	}
   110| 	if key.LastSeen != nil {
   111| 		protoKey.LastSeen = timestamppb.New(*key.LastSeen)
   112| 	}
   113| 	return &protoKey
   114| }


# ====================================================================
# FILE: hscontrol/app.go
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-776 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"crypto/tls"
     5| 	"errors"
     6| 	"fmt"
     7| 	"io"
     8| 	"net"
     9| 	"net/http"
    10| 	"os"
    11| 	"os/signal"
    12| 	"sort"
    13| 	"strconv"
    14| 	"strings"
    15| 	"sync"
    16| 	"syscall"
    17| 	"time"
    18| 	"github.com/coreos/go-oidc/v3/oidc"
    19| 	"github.com/gorilla/mux"
    20| 	grpcMiddleware "github.com/grpc-ecosystem/go-grpc-middleware"
    21| 	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
    22| 	"github.com/juanfont/headscale"
    23| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    24| 	"github.com/patrickmn/go-cache"
    25| 	zerolog "github.com/philip-bui/grpc-zerolog"
    26| 	"github.com/prometheus/client_golang/prometheus/promhttp"
    27| 	"github.com/puzpuzpuz/xsync/v2"
    28| 	zl "github.com/rs/zerolog"
    29| 	"github.com/rs/zerolog/log"
    30| 	"golang.org/x/crypto/acme"
    31| 	"golang.org/x/crypto/acme/autocert"
    32| 	"golang.org/x/oauth2"
    33| 	"golang.org/x/sync/errgroup"
    34| 	"google.golang.org/grpc"
    35| 	"google.golang.org/grpc/codes"
    36| 	"google.golang.org/grpc/credentials"
    37| 	"google.golang.org/grpc/credentials/insecure"
    38| 	"google.golang.org/grpc/metadata"
    39| 	"google.golang.org/grpc/peer"
    40| 	"google.golang.org/grpc/reflection"
    41| 	"google.golang.org/grpc/status"
    42| 	"gorm.io/gorm"
    43| 	"tailscale.com/tailcfg"
    44| 	"tailscale.com/types/dnstype"
    45| 	"tailscale.com/types/key"
    46| )
    47| const (
    48| 	errSTUNAddressNotSet                   = Error("STUN address not set")
    49| 	errUnsupportedDatabase                 = Error("unsupported DB")
    50| 	errUnsupportedLetsEncryptChallengeType = Error(
    51| 		"unknown value for Lets Encrypt challenge type",
    52| 	)
    53| )
    54| const (
    55| 	AuthPrefix          = "Bearer "
    56| 	Postgres            = "postgres"
    57| 	Sqlite              = "sqlite3"
    58| 	updateInterval      = 5000
    59| 	HTTPReadTimeout     = 30 * time.Second
    60| 	HTTPShutdownTimeout = 3 * time.Second
    61| 	privateKeyFileMode  = 0o600
    62| 	registerCacheExpiration = time.Minute * 15
    63| 	registerCacheCleanup    = time.Minute * 20
    64| 	DisabledClientAuth = "disabled"
    65| 	RelaxedClientAuth  = "relaxed"
    66| 	EnforcedClientAuth = "enforced"
    67| )
    68| type Headscale struct {
    69| 	cfg             *Config
    70| 	db              *gorm.DB
    71| 	dbString        string
    72| 	dbType          string
    73| 	dbDebug         bool
    74| 	privateKey      *key.MachinePrivate
    75| 	noisePrivateKey *key.MachinePrivate
    76| 	DERPMap    *tailcfg.DERPMap
    77| 	DERPServer *DERPServer
    78| 	aclPolicy *ACLPolicy
    79| 	aclRules  []tailcfg.FilterRule
    80| 	sshPolicy *tailcfg.SSHPolicy
    81| 	lastStateChange *xsync.MapOf[string, time.Time]
    82| 	oidcProvider *oidc.Provider
    83| 	oauth2Config *oauth2.Config
    84| 	registrationCache *cache.Cache
    85| 	ipAllocationMutex sync.Mutex
    86| 	shutdownChan       chan struct{}
    87| 	pollNetMapStreamWG sync.WaitGroup
    88| }
    89| func NewHeadscale(cfg *Config) (*Headscale, error) {
    90| 	privateKey, err := readOrCreatePrivateKey(cfg.PrivateKeyPath)
    91| 	if err != nil {
    92| 		return nil, fmt.Errorf("failed to read or create private key: %w", err)
    93| 	}
    94| 	noisePrivateKey, err := readOrCreatePrivateKey(cfg.NoisePrivateKeyPath)
    95| 	if err != nil {
    96| 		return nil, fmt.Errorf("failed to read or create Noise protocol private key: %w", err)
    97| 	}
    98| 	if privateKey.Equal(*noisePrivateKey) {
    99| 		return nil, fmt.Errorf("private key and noise private key are the same: %w", err)
   100| 	}
   101| 	var dbString string
   102| 	switch cfg.DBtype {
   103| 	case Postgres:
   104| 		dbString = fmt.Sprintf(
   105| 			"host=%s dbname=%s user=%s",
   106| 			cfg.DBhost,
   107| 			cfg.DBname,
   108| 			cfg.DBuser,
   109| 		)
   110| 		if sslEnabled, err := strconv.ParseBool(cfg.DBssl); err == nil {
   111| 			if !sslEnabled {
   112| 				dbString += " sslmode=disable"
   113| 			}
   114| 		} else {
   115| 			dbString += fmt.Sprintf(" sslmode=%s", cfg.DBssl)
   116| 		}
   117| 		if cfg.DBport != 0 {
   118| 			dbString += fmt.Sprintf(" port=%d", cfg.DBport)
   119| 		}
   120| 		if cfg.DBpass != "" {
   121| 			dbString += fmt.Sprintf(" password=%s", cfg.DBpass)
   122| 		}
   123| 	case Sqlite:
   124| 		dbString = cfg.DBpath
   125| 	default:
   126| 		return nil, errUnsupportedDatabase
   127| 	}
   128| 	registrationCache := cache.New(
   129| 		registerCacheExpiration,
   130| 		registerCacheCleanup,
   131| 	)
   132| 	app := Headscale{
   133| 		cfg:                cfg,
   134| 		dbType:             cfg.DBtype,
   135| 		dbString:           dbString,
   136| 		privateKey:         privateKey,
   137| 		noisePrivateKey:    noisePrivateKey,
   138| 		aclRules:           tailcfg.FilterAllowAll, // default allowall
   139| 		registrationCache:  registrationCache,
   140| 		pollNetMapStreamWG: sync.WaitGroup{},
   141| 		lastStateChange:    xsync.NewMapOf[time.Time](),
   142| 	}
   143| 	err = app.initDB()
   144| 	if err != nil {
   145| 		return nil, err
   146| 	}
   147| 	if cfg.OIDC.Issuer != "" {
   148| 		err = app.initOIDC()
   149| 		if err != nil {
   150| 			if cfg.OIDC.OnlyStartIfOIDCIsAvailable {
   151| 				return nil, err
   152| 			} else {
   153| 				log.Warn().Err(err).Msg("failed to set up OIDC provider, falling back to CLI based authentication")
   154| 			}
   155| 		}
   156| 	}
   157| 	if app.cfg.DNSConfig != nil && app.cfg.DNSConfig.Proxied { // if MagicDNS
   158| 		magicDNSDomains := generateMagicDNSRootDomains(app.cfg.IPPrefixes)
   159| 		if app.cfg.DNSConfig.Routes == nil {
   160| 			app.cfg.DNSConfig.Routes = make(map[string][]*dnstype.Resolver)
   161| 		}
   162| 		for _, d := range magicDNSDomains {
   163| 			app.cfg.DNSConfig.Routes[d.WithoutTrailingDot()] = nil
   164| 		}
   165| 	}
   166| 	if cfg.DERP.ServerEnabled {
   167| 		embeddedDERPServer, err := app.NewDERPServer()
   168| 		if err != nil {
   169| 			return nil, err
   170| 		}
   171| 		app.DERPServer = embeddedDERPServer
   172| 	}
   173| 	return &app, nil
   174| }
   175| func (h *Headscale) redirect(w http.ResponseWriter, req *http.Request) {
   176| 	target := h.cfg.ServerURL + req.URL.RequestURI()
   177| 	http.Redirect(w, req, target, http.StatusFound)
   178| }
   179| func (h *Headscale) expireEphemeralNodes(milliSeconds int64) {
   180| 	ticker := time.NewTicker(time.Duration(milliSeconds) * time.Millisecond)
   181| 	for range ticker.C {
   182| 		h.expireEphemeralNodesWorker()
   183| 	}
   184| }
   185| func (h *Headscale) expireExpiredMachines(milliSeconds int64) {
   186| 	ticker := time.NewTicker(time.Duration(milliSeconds) * time.Millisecond)
   187| 	for range ticker.C {
   188| 		h.expireExpiredMachinesWorker()
   189| 	}
   190| }
   191| func (h *Headscale) failoverSubnetRoutes(milliSeconds int64) {
   192| 	ticker := time.NewTicker(time.Duration(milliSeconds) * time.Millisecond)
   193| 	for range ticker.C {
   194| 		err := h.handlePrimarySubnetFailover()
   195| 		if err != nil {
   196| 			log.Error().Err(err).Msg("failed to handle primary subnet failover")
   197| 		}
   198| 	}
   199| }
   200| func (h *Headscale) expireEphemeralNodesWorker() {
   201| 	users, err := h.ListUsers()
   202| 	if err != nil {
   203| 		log.Error().Err(err).Msg("Error listing users")
   204| 		return
   205| 	}
   206| 	for _, user := range users {
   207| 		machines, err := h.ListMachinesByUser(user.Name)
   208| 		if err != nil {
   209| 			log.Error().
   210| 				Err(err).
   211| 				Str("user", user.Name).
   212| 				Msg("Error listing machines in user")
   213| 			return
   214| 		}
   215| 		expiredFound := false
   216| 		for _, machine := range machines {
   217| 			if machine.isEphemeral() && machine.LastSeen != nil &&
   218| 				time.Now().
   219| 					After(machine.LastSeen.Add(h.cfg.EphemeralNodeInactivityTimeout)) {
   220| 				expiredFound = true
   221| 				log.Info().
   222| 					Str("machine", machine.Hostname).
   223| 					Msg("Ephemeral client removed from database")
   224| 				err = h.db.Unscoped().Delete(machine).Error
   225| 				if err != nil {
   226| 					log.Error().
   227| 						Err(err).
   228| 						Str("machine", machine.Hostname).
   229| 						Msg(" Cannot delete ephemeral machine from the database")
   230| 				}
   231| 			}
   232| 		}
   233| 		if expiredFound {
   234| 			h.setLastStateChangeToNow()
   235| 		}
   236| 	}
   237| }
   238| func (h *Headscale) expireExpiredMachinesWorker() {
   239| 	users, err := h.ListUsers()
   240| 	if err != nil {
   241| 		log.Error().Err(err).Msg("Error listing users")
   242| 		return
   243| 	}
   244| 	for _, user := range users {
   245| 		machines, err := h.ListMachinesByUser(user.Name)
   246| 		if err != nil {
   247| 			log.Error().
   248| 				Err(err).
   249| 				Str("user", user.Name).
   250| 				Msg("Error listing machines in user")
   251| 			return
   252| 		}
   253| 		expiredFound := false
   254| 		for index, machine := range machines {
   255| 			if machine.isExpired() &&
   256| 				machine.Expiry.After(h.getLastStateChange(user)) {
   257| 				expiredFound = true
   258| 				err := h.ExpireMachine(&machines[index])
   259| 				if err != nil {
   260| 					log.Error().
   261| 						Err(err).
   262| 						Str("machine", machine.Hostname).
   263| 						Str("name", machine.GivenName).
   264| 						Msg(" Cannot expire machine")
   265| 				} else {
   266| 					log.Info().
   267| 						Str("machine", machine.Hostname).
   268| 						Str("name", machine.GivenName).
   269| 						Msg("Machine successfully expired")
   270| 				}
   271| 			}
   272| 		}
   273| 		if expiredFound {
   274| 			h.setLastStateChangeToNow()
   275| 		}
   276| 	}
   277| }
   278| func (h *Headscale) grpcAuthenticationInterceptor(ctx context.Context,
   279| 	req interface{},
   280| 	info *grpc.UnaryServerInfo,
   281| 	handler grpc.UnaryHandler,
   282| ) (interface{}, error) {
   283| 	client, _ := peer.FromContext(ctx)
   284| 	log.Trace().
   285| 		Caller().
   286| 		Str("client_address", client.Addr.String()).
   287| 		Msg("Client is trying to authenticate")
   288| 	meta, ok := metadata.FromIncomingContext(ctx)
   289| 	if !ok {
   290| 		log.Error().
   291| 			Caller().
   292| 			Str("client_address", client.Addr.String()).
   293| 			Msg("Retrieving metadata is failed")
   294| 		return ctx, status.Errorf(
   295| 			codes.InvalidArgument,
   296| 			"Retrieving metadata is failed",
   297| 		)
   298| 	}
   299| 	authHeader, ok := meta["authorization"]
   300| 	if !ok {
   301| 		log.Error().
   302| 			Caller().
   303| 			Str("client_address", client.Addr.String()).
   304| 			Msg("Authorization token is not supplied")
   305| 		return ctx, status.Errorf(
   306| 			codes.Unauthenticated,
   307| 			"Authorization token is not supplied",
   308| 		)
   309| 	}
   310| 	token := authHeader[0]
   311| 	if !strings.HasPrefix(token, AuthPrefix) {
   312| 		log.Error().
   313| 			Caller().
   314| 			Str("client_address", client.Addr.String()).
   315| 			Msg(`missing "Bearer " prefix in "Authorization" header`)
   316| 		return ctx, status.Error(
   317| 			codes.Unauthenticated,
   318| 			`missing "Bearer " prefix in "Authorization" header`,
   319| 		)
   320| 	}
   321| 	valid, err := h.ValidateAPIKey(strings.TrimPrefix(token, AuthPrefix))
   322| 	if err != nil {
   323| 		log.Error().
   324| 			Caller().
   325| 			Err(err).
   326| 			Str("client_address", client.Addr.String()).
   327| 			Msg("failed to validate token")
   328| 		return ctx, status.Error(codes.Internal, "failed to validate token")
   329| 	}
   330| 	if !valid {
   331| 		log.Info().
   332| 			Str("client_address", client.Addr.String()).
   333| 			Msg("invalid token")
   334| 		return ctx, status.Error(codes.Unauthenticated, "invalid token")
   335| 	}
   336| 	return handler(ctx, req)
   337| }
   338| func (h *Headscale) httpAuthenticationMiddleware(next http.Handler) http.Handler {
   339| 	return http.HandlerFunc(func(
   340| 		writer http.ResponseWriter,
   341| 		req *http.Request,
   342| 	) {
   343| 		log.Trace().
   344| 			Caller().
   345| 			Str("client_address", req.RemoteAddr).
   346| 			Msg("HTTP authentication invoked")
   347| 		authHeader := req.Header.Get("authorization")
   348| 		if !strings.HasPrefix(authHeader, AuthPrefix) {
   349| 			log.Error().
   350| 				Caller().
   351| 				Str("client_address", req.RemoteAddr).
   352| 				Msg(`missing "Bearer " prefix in "Authorization" header`)
   353| 			writer.WriteHeader(http.StatusUnauthorized)
   354| 			_, err := writer.Write([]byte("Unauthorized"))
   355| 			if err != nil {
   356| 				log.Error().
   357| 					Caller().
   358| 					Err(err).
   359| 					Msg("Failed to write response")
   360| 			}
   361| 			return
   362| 		}
   363| 		valid, err := h.ValidateAPIKey(strings.TrimPrefix(authHeader, AuthPrefix))
   364| 		if err != nil {
   365| 			log.Error().
   366| 				Caller().
   367| 				Err(err).
   368| 				Str("client_address", req.RemoteAddr).
   369| 				Msg("failed to validate token")
   370| 			writer.WriteHeader(http.StatusInternalServerError)
   371| 			_, err := writer.Write([]byte("Unauthorized"))
   372| 			if err != nil {
   373| 				log.Error().
   374| 					Caller().
   375| 					Err(err).
   376| 					Msg("Failed to write response")
   377| 			}
   378| 			return
   379| 		}
   380| 		if !valid {
   381| 			log.Info().
   382| 				Str("client_address", req.RemoteAddr).
   383| 				Msg("invalid token")
   384| 			writer.WriteHeader(http.StatusUnauthorized)
   385| 			_, err := writer.Write([]byte("Unauthorized"))
   386| 			if err != nil {
   387| 				log.Error().
   388| 					Caller().
   389| 					Err(err).
   390| 					Msg("Failed to write response")
   391| 			}
   392| 			return
   393| 		}
   394| 		next.ServeHTTP(writer, req)
   395| 	})
   396| }
   397| func (h *Headscale) ensureUnixSocketIsAbsent() error {
   398| 	if _, err := os.Stat(h.cfg.UnixSocket); errors.Is(err, os.ErrNotExist) {
   399| 		return nil
   400| 	}
   401| 	return os.Remove(h.cfg.UnixSocket)
   402| }
   403| func (h *Headscale) createRouter(grpcMux *runtime.ServeMux) *mux.Router {
   404| 	router := mux.NewRouter()
   405| 	router.HandleFunc(ts2021UpgradePath, h.NoiseUpgradeHandler).Methods(http.MethodPost)
   406| 	router.HandleFunc("/health", h.HealthHandler).Methods(http.MethodGet)
   407| 	router.HandleFunc("/key", h.KeyHandler).Methods(http.MethodGet)
   408| 	router.HandleFunc("/register/{nkey}", h.RegisterWebAPI).Methods(http.MethodGet)
   409| 	h.addLegacyHandlers(router)
   410| 	router.HandleFunc("/oidc/register/{nkey}", h.RegisterOIDC).Methods(http.MethodGet)
   411| 	router.HandleFunc("/oidc/callback", h.OIDCCallback).Methods(http.MethodGet)
   412| 	router.HandleFunc("/apple", h.AppleConfigMessage).Methods(http.MethodGet)
   413| 	router.HandleFunc("/apple/{platform}", h.ApplePlatformConfig).
   414| 		Methods(http.MethodGet)
   415| 	router.HandleFunc("/windows", h.WindowsConfigMessage).Methods(http.MethodGet)
   416| 	router.HandleFunc("/windows/tailscale.reg", h.WindowsRegConfig).
   417| 		Methods(http.MethodGet)
   418| 	router.HandleFunc("/swagger", headscale.SwaggerUI).Methods(http.MethodGet)
   419| 	router.HandleFunc("/swagger/v1/openapiv2.json", headscale.SwaggerAPIv1).
   420| 		Methods(http.MethodGet)
   421| 	if h.cfg.DERP.ServerEnabled {
   422| 		router.HandleFunc("/derp", h.DERPHandler)
   423| 		router.HandleFunc("/derp/probe", h.DERPProbeHandler)
   424| 		router.HandleFunc("/bootstrap-dns", h.DERPBootstrapDNSHandler)
   425| 	}
   426| 	apiRouter := router.PathPrefix("/api").Subrouter()
   427| 	apiRouter.Use(h.httpAuthenticationMiddleware)
   428| 	apiRouter.PathPrefix("/v1/").HandlerFunc(grpcMux.ServeHTTP)
   429| 	router.PathPrefix("/").HandlerFunc(notFoundHandler)
   430| 	return router
   431| }
   432| func (h *Headscale) Serve() error {
   433| 	var err error
   434| 	h.DERPMap = GetDERPMap(h.cfg.DERP)
   435| 	if h.cfg.DERP.ServerEnabled {
   436| 		if h.cfg.DERP.STUNAddr == "" {
   437| 			return errSTUNAddressNotSet
   438| 		}
   439| 		h.DERPMap.Regions[h.DERPServer.region.RegionID] = &h.DERPServer.region
   440| 		go h.ServeSTUN()
   441| 	}
   442| 	if h.cfg.DERP.AutoUpdate {
   443| 		derpMapCancelChannel := make(chan struct{})
   444| 		defer func() { derpMapCancelChannel <- struct{}{} }()
   445| 		go h.scheduledDERPMapUpdateWorker(derpMapCancelChannel)
   446| 	}
   447| 	go h.expireEphemeralNodes(updateInterval)
   448| 	go h.expireExpiredMachines(updateInterval)
   449| 	go h.failoverSubnetRoutes(updateInterval)
   450| 	if zl.GlobalLevel() == zl.TraceLevel {
   451| 		zerolog.RespLog = true
   452| 	} else {
   453| 		zerolog.RespLog = false
   454| 	}
   455| 	errorGroup := new(errgroup.Group)
   456| 	ctx := context.Background()
   457| 	ctx, cancel := context.WithCancel(ctx)
   458| 	defer cancel()
   459| 	err = h.ensureUnixSocketIsAbsent()
   460| 	if err != nil {
   461| 		return fmt.Errorf("unable to remove old socket file: %w", err)
   462| 	}
   463| 	socketListener, err := net.Listen("unix", h.cfg.UnixSocket)
   464| 	if err != nil {
   465| 		return fmt.Errorf("failed to set up gRPC socket: %w", err)
   466| 	}
   467| 	if err := os.Chmod(h.cfg.UnixSocket, h.cfg.UnixSocketPermission); err != nil {
   468| 		return fmt.Errorf("failed change permission of gRPC socket: %w", err)
   469| 	}
   470| 	grpcGatewayMux := runtime.NewServeMux()
   471| 	grpcGatewayConn, err := grpc.Dial(
   472| 		h.cfg.UnixSocket,
   473| 		[]grpc.DialOption{
   474| 			grpc.WithTransportCredentials(insecure.NewCredentials()),
   475| 			grpc.WithContextDialer(GrpcSocketDialer),
   476| 		}...,
   477| 	)
   478| 	if err != nil {
   479| 		return err
   480| 	}
   481| 	err = v1.RegisterHeadscaleServiceHandler(ctx, grpcGatewayMux, grpcGatewayConn)
   482| 	if err != nil {
   483| 		return err
   484| 	}
   485| 	grpcSocket := grpc.NewServer(zerolog.UnaryInterceptor())
   486| 	v1.RegisterHeadscaleServiceServer(grpcSocket, newHeadscaleV1APIServer(h))
   487| 	reflection.Register(grpcSocket)
   488| 	errorGroup.Go(func() error { return grpcSocket.Serve(socketListener) })
   489| 	tlsConfig, err := h.getTLSSettings()
   490| 	if err != nil {
   491| 		log.Error().Err(err).Msg("Failed to set up TLS configuration")
   492| 		return err
   493| 	}
   494| 	var grpcServer *grpc.Server
   495| 	var grpcListener net.Listener
   496| 	if tlsConfig != nil || h.cfg.GRPCAllowInsecure {
   497| 		log.Info().Msgf("Enabling remote gRPC at %s", h.cfg.GRPCAddr)
   498| 		grpcOptions := []grpc.ServerOption{
   499| 			grpc.UnaryInterceptor(
   500| 				grpcMiddleware.ChainUnaryServer(
   501| 					h.grpcAuthenticationInterceptor,
   502| 					zerolog.NewUnaryServerInterceptor(),
   503| 				),
   504| 			),
   505| 		}
   506| 		if tlsConfig != nil {
   507| 			grpcOptions = append(grpcOptions,
   508| 				grpc.Creds(credentials.NewTLS(tlsConfig)),
   509| 			)
   510| 		} else {
   511| 			log.Warn().Msg("gRPC is running without security")
   512| 		}
   513| 		grpcServer = grpc.NewServer(grpcOptions...)
   514| 		v1.RegisterHeadscaleServiceServer(grpcServer, newHeadscaleV1APIServer(h))
   515| 		reflection.Register(grpcServer)
   516| 		grpcListener, err = net.Listen("tcp", h.cfg.GRPCAddr)
   517| 		if err != nil {
   518| 			return fmt.Errorf("failed to bind to TCP address: %w", err)
   519| 		}
   520| 		errorGroup.Go(func() error { return grpcServer.Serve(grpcListener) })
   521| 		log.Info().
   522| 			Msgf("listening and serving gRPC on: %s", h.cfg.GRPCAddr)
   523| 	}
   524| 	router := h.createRouter(grpcGatewayMux)
   525| 	httpServer := &http.Server{
   526| 		Addr:        h.cfg.Addr,
   527| 		Handler:     router,
   528| 		ReadTimeout: HTTPReadTimeout,
   529| 		WriteTimeout: 0,
   530| 	}
   531| 	var httpListener net.Listener
   532| 	if tlsConfig != nil {
   533| 		httpServer.TLSConfig = tlsConfig
   534| 		httpListener, err = tls.Listen("tcp", h.cfg.Addr, tlsConfig)
   535| 	} else {
   536| 		httpListener, err = net.Listen("tcp", h.cfg.Addr)
   537| 	}
   538| 	if err != nil {
   539| 		return fmt.Errorf("failed to bind to TCP address: %w", err)
   540| 	}
   541| 	errorGroup.Go(func() error { return httpServer.Serve(httpListener) })
   542| 	log.Info().
   543| 		Msgf("listening and serving HTTP on: %s", h.cfg.Addr)
   544| 	promMux := http.NewServeMux()
   545| 	promMux.Handle("/metrics", promhttp.Handler())
   546| 	promHTTPServer := &http.Server{
   547| 		Addr:         h.cfg.MetricsAddr,
   548| 		Handler:      promMux,
   549| 		ReadTimeout:  HTTPReadTimeout,
   550| 		WriteTimeout: 0,
   551| 	}
   552| 	var promHTTPListener net.Listener
   553| 	promHTTPListener, err = net.Listen("tcp", h.cfg.MetricsAddr)
   554| 	if err != nil {
   555| 		return fmt.Errorf("failed to bind to TCP address: %w", err)
   556| 	}
   557| 	errorGroup.Go(func() error { return promHTTPServer.Serve(promHTTPListener) })
   558| 	log.Info().
   559| 		Msgf("listening and serving metrics on: %s", h.cfg.MetricsAddr)
   560| 	h.shutdownChan = make(chan struct{})
   561| 	sigc := make(chan os.Signal, 1)
   562| 	signal.Notify(sigc,
   563| 		syscall.SIGHUP,
   564| 		syscall.SIGINT,
   565| 		syscall.SIGTERM,
   566| 		syscall.SIGQUIT,
   567| 		syscall.SIGHUP)
   568| 	sigFunc := func(c chan os.Signal) {
   569| 		for {
   570| 			sig := <-c
   571| 			switch sig {
   572| 			case syscall.SIGHUP:
   573| 				log.Info().
   574| 					Str("signal", sig.String()).
   575| 					Msg("Received SIGHUP, reloading ACL and Config")
   576| 				if h.cfg.ACL.PolicyPath != "" {
   577| 					aclPath := AbsolutePathFromConfigPath(h.cfg.ACL.PolicyPath)
   578| 					err := h.LoadACLPolicyFromPath(aclPath)
   579| 					if err != nil {
   580| 						log.Error().Err(err).Msg("Failed to reload ACL policy")
   581| 					}
   582| 					log.Info().
   583| 						Str("path", aclPath).
   584| 						Msg("ACL policy successfully reloaded, notifying nodes of change")
   585| 					h.setLastStateChangeToNow()
   586| 				}
   587| 			default:
   588| 				log.Info().
   589| 					Str("signal", sig.String()).
   590| 					Msg("Received signal to stop, shutting down gracefully")
   591| 				close(h.shutdownChan)
   592| 				h.pollNetMapStreamWG.Wait()
   593| 				ctx, cancel := context.WithTimeout(
   594| 					context.Background(),
   595| 					HTTPShutdownTimeout,
   596| 				)
   597| 				if err := promHTTPServer.Shutdown(ctx); err != nil {
   598| 					log.Error().Err(err).Msg("Failed to shutdown prometheus http")
   599| 				}
   600| 				if err := httpServer.Shutdown(ctx); err != nil {
   601| 					log.Error().Err(err).Msg("Failed to shutdown http")
   602| 				}
   603| 				grpcSocket.GracefulStop()
   604| 				if grpcServer != nil {
   605| 					grpcServer.GracefulStop()
   606| 					grpcListener.Close()
   607| 				}
   608| 				promHTTPListener.Close()
   609| 				httpListener.Close()
   610| 				grpcGatewayConn.Close()
   611| 				socketListener.Close()
   612| 				db, err := h.db.DB()
   613| 				if err != nil {
   614| 					log.Error().Err(err).Msg("Failed to get db handle")
   615| 				}
   616| 				err = db.Close()
   617| 				if err != nil {
   618| 					log.Error().Err(err).Msg("Failed to close db")
   619| 				}
   620| 				log.Info().
   621| 					Msg("Headscale stopped")
   622| 				cancel()
   623| 			}
   624| 		}
   625| 	}
   626| 	errorGroup.Go(func() error {
   627| 		sigFunc(sigc)
   628| 		return nil
   629| 	})
   630| 	return errorGroup.Wait()
   631| }
   632| func (h *Headscale) getTLSSettings() (*tls.Config, error) {
   633| 	var err error
   634| 	if h.cfg.TLS.LetsEncrypt.Hostname != "" {
   635| 		if !strings.HasPrefix(h.cfg.ServerURL, "https://") {
   636| 			log.Warn().
   637| 				Msg("Listening with TLS but ServerURL does not start with https://")
   638| 		}
   639| 		certManager := autocert.Manager{
   640| 			Prompt:     autocert.AcceptTOS,
   641| 			HostPolicy: autocert.HostWhitelist(h.cfg.TLS.LetsEncrypt.Hostname),
   642| 			Cache:      autocert.DirCache(h.cfg.TLS.LetsEncrypt.CacheDir),
   643| 			Client: &acme.Client{
   644| 				DirectoryURL: h.cfg.ACMEURL,
   645| 			},
   646| 			Email: h.cfg.ACMEEmail,
   647| 		}
   648| 		switch h.cfg.TLS.LetsEncrypt.ChallengeType {
   649| 		case tlsALPN01ChallengeType:
   650| 			return certManager.TLSConfig(), nil
   651| 		case http01ChallengeType:
   652| 			server := &http.Server{
   653| 				Addr:        h.cfg.TLS.LetsEncrypt.Listen,
   654| 				Handler:     certManager.HTTPHandler(http.HandlerFunc(h.redirect)),
   655| 				ReadTimeout: HTTPReadTimeout,
   656| 			}
   657| 			go func() {
   658| 				err := server.ListenAndServe()
   659| 				log.Fatal().
   660| 					Caller().
   661| 					Err(err).
   662| 					Msg("failed to set up a HTTP server")
   663| 			}()
   664| 			return certManager.TLSConfig(), nil
   665| 		default:
   666| 			return nil, errUnsupportedLetsEncryptChallengeType
   667| 		}
   668| 	} else if h.cfg.TLS.CertPath == "" {
   669| 		if !strings.HasPrefix(h.cfg.ServerURL, "http://") {
   670| 			log.Warn().Msg("Listening without TLS but ServerURL does not start with http://")
   671| 		}
   672| 		return nil, err
   673| 	} else {
   674| 		if !strings.HasPrefix(h.cfg.ServerURL, "https://") {
   675| 			log.Warn().Msg("Listening with TLS but ServerURL does not start with https://")
   676| 		}
   677| 		tlsConfig := &tls.Config{
   678| 			NextProtos:   []string{"http/1.1"},
   679| 			Certificates: make([]tls.Certificate, 1),
   680| 			MinVersion:   tls.VersionTLS12,
   681| 		}
   682| 		tlsConfig.Certificates[0], err = tls.LoadX509KeyPair(h.cfg.TLS.CertPath, h.cfg.TLS.KeyPath)
   683| 		return tlsConfig, err
   684| 	}
   685| }
   686| func (h *Headscale) setLastStateChangeToNow() {
   687| 	var err error
   688| 	now := time.Now().UTC()
   689| 	users, err := h.ListUsers()
   690| 	if err != nil {
   691| 		log.Error().
   692| 			Caller().
   693| 			Err(err).
   694| 			Msg("failed to fetch all users, failing to update last changed state.")
   695| 	}
   696| 	for _, user := range users {
   697| 		lastStateUpdate.WithLabelValues(user.Name, "headscale").Set(float64(now.Unix()))
   698| 		if h.lastStateChange == nil {
   699| 			h.lastStateChange = xsync.NewMapOf[time.Time]()
   700| 		}
   701| 		h.lastStateChange.Store(user.Name, now)
   702| 	}
   703| }
   704| func (h *Headscale) getLastStateChange(users ...User) time.Time {
   705| 	times := []time.Time{}
   706| 	if len(users) > 0 {
   707| 		for _, user := range users {
   708| 			if lastChange, ok := h.lastStateChange.Load(user.Name); ok {
   709| 				times = append(times, lastChange)
   710| 			}
   711| 		}
   712| 	} else {
   713| 		h.lastStateChange.Range(func(key string, value time.Time) bool {
   714| 			times = append(times, value)
   715| 			return true
   716| 		})
   717| 	}
   718| 	sort.Slice(times, func(i, j int) bool {
   719| 		return times[i].After(times[j])
   720| 	})
   721| 	log.Trace().Msgf("Latest times %#v", times)
   722| 	if len(times) == 0 {
   723| 		return time.Now().UTC()
   724| 	} else {
   725| 		return times[0]
   726| 	}
   727| }
   728| func notFoundHandler(
   729| 	writer http.ResponseWriter,
   730| 	req *http.Request,
   731| ) {
   732| 	body, _ := io.ReadAll(req.Body)
   733| 	log.Trace().
   734| 		Interface("header", req.Header).
   735| 		Interface("proto", req.Proto).
   736| 		Interface("url", req.URL).
   737| 		Bytes("body", body).
   738| 		Msg("Request did not match")
   739| 	writer.WriteHeader(http.StatusNotFound)
   740| }
   741| func readOrCreatePrivateKey(path string) (*key.MachinePrivate, error) {
   742| 	privateKey, err := os.ReadFile(path)
   743| 	if errors.Is(err, os.ErrNotExist) {
   744| 		log.Info().Str("path", path).Msg("No private key file at path, creating...")
   745| 		machineKey := key.NewMachine()
   746| 		machineKeyStr, err := machineKey.MarshalText()
   747| 		if err != nil {
   748| 			return nil, fmt.Errorf(
   749| 				"failed to convert private key to string for saving: %w",
   750| 				err,
   751| 			)
   752| 		}
   753| 		err = os.WriteFile(path, machineKeyStr, privateKeyFileMode)
   754| 		if err != nil {
   755| 			return nil, fmt.Errorf(
   756| 				"failed to save private key to disk: %w",
   757| 				err,
   758| 			)
   759| 		}
   760| 		return &machineKey, nil
   761| 	} else if err != nil {
   762| 		return nil, fmt.Errorf("failed to read private key file: %w", err)
   763| 	}
   764| 	trimmedPrivateKey := strings.TrimSpace(string(privateKey))
   765| 	privateKeyEnsurePrefix := PrivateKeyEnsurePrefix(trimmedPrivateKey)
   766| 	var machineKey key.MachinePrivate
   767| 	if err = machineKey.UnmarshalText([]byte(privateKeyEnsurePrefix)); err != nil {
   768| 		log.Info().
   769| 			Str("path", path).
   770| 			Msg("This might be due to a legacy (headscale pre-0.12) private key. " +
   771| 				"If the key is in WireGuard format, delete the key and restart headscale. " +
   772| 				"A new key will automatically be generated. All Tailscale clients will have to be restarted")
   773| 		return nil, fmt.Errorf("failed to parse private key: %w", err)
   774| 	}
   775| 	return &machineKey, nil
   776| }


# ====================================================================
# FILE: hscontrol/config.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-546 ---
     1| package hscontrol
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"io/fs"
     6| 	"net/netip"
     7| 	"net/url"
     8| 	"os"
     9| 	"strings"
    10| 	"time"
    11| 	"github.com/coreos/go-oidc/v3/oidc"
    12| 	"github.com/prometheus/common/model"
    13| 	"github.com/rs/zerolog"
    14| 	"github.com/rs/zerolog/log"
    15| 	"github.com/spf13/viper"
    16| 	"go4.org/netipx"
    17| 	"tailscale.com/net/tsaddr"
    18| 	"tailscale.com/tailcfg"
    19| 	"tailscale.com/types/dnstype"
    20| )
    21| const (
    22| 	tlsALPN01ChallengeType = "TLS-ALPN-01"
    23| 	http01ChallengeType    = "HTTP-01"
    24| 	JSONLogFormat = "json"
    25| 	TextLogFormat = "text"
    26| 	defaultOIDCExpiryTime               = 180 * 24 * time.Hour // 180 Days
    27| 	maxDuration           time.Duration = 1<<63 - 1
    28| )
    29| var errOidcMutuallyExclusive = errors.New(
    30| 	"oidc_client_secret and oidc_client_secret_path are mutually exclusive",
    31| )
    32| type Config struct {
    33| 	ServerURL                      string
    34| 	Addr                           string
    35| 	MetricsAddr                    string
    36| 	GRPCAddr                       string
    37| 	GRPCAllowInsecure              bool
    38| 	EphemeralNodeInactivityTimeout time.Duration
    39| 	NodeUpdateCheckInterval        time.Duration
    40| 	IPPrefixes                     []netip.Prefix
    41| 	PrivateKeyPath                 string
    42| 	NoisePrivateKeyPath            string
    43| 	BaseDomain                     string
    44| 	Log                            LogConfig
    45| 	DisableUpdateCheck             bool
    46| 	DERP DERPConfig
    47| 	DBtype string
    48| 	DBpath string
    49| 	DBhost string
    50| 	DBport int
    51| 	DBname string
    52| 	DBuser string
    53| 	DBpass string
    54| 	DBssl  string
    55| 	TLS TLSConfig
    56| 	ACMEURL   string
    57| 	ACMEEmail string
    58| 	DNSConfig *tailcfg.DNSConfig
    59| 	UnixSocket           string
    60| 	UnixSocketPermission fs.FileMode
    61| 	OIDC OIDCConfig
    62| 	LogTail             LogTailConfig
    63| 	RandomizeClientPort bool
    64| 	CLI CLIConfig
    65| 	ACL ACLConfig
    66| }
    67| type TLSConfig struct {
    68| 	CertPath string
    69| 	KeyPath  string
    70| 	LetsEncrypt LetsEncryptConfig
    71| }
    72| type LetsEncryptConfig struct {
    73| 	Listen        string
    74| 	Hostname      string
    75| 	CacheDir      string
    76| 	ChallengeType string
    77| }
    78| type OIDCConfig struct {
    79| 	OnlyStartIfOIDCIsAvailable bool
    80| 	Issuer                     string
    81| 	ClientID                   string
    82| 	ClientSecret               string
    83| 	Scope                      []string
    84| 	ExtraParams                map[string]string
    85| 	AllowedDomains             []string
    86| 	AllowedUsers               []string
    87| 	AllowedGroups              []string
    88| 	StripEmaildomain           bool
    89| 	Expiry                     time.Duration
    90| 	UseExpiryFromToken         bool
    91| }
    92| type DERPConfig struct {
    93| 	ServerEnabled    bool
    94| 	ServerRegionID   int
    95| 	ServerRegionCode string
    96| 	ServerRegionName string
    97| 	STUNAddr         string
    98| 	URLs             []url.URL
    99| 	Paths            []string
   100| 	AutoUpdate       bool
   101| 	UpdateFrequency  time.Duration
   102| }
   103| type LogTailConfig struct {
   104| 	Enabled bool
   105| }
   106| type CLIConfig struct {
   107| 	Address  string
   108| 	APIKey   string
   109| 	Timeout  time.Duration
   110| 	Insecure bool
   111| }
   112| type ACLConfig struct {
   113| 	PolicyPath string
   114| }
   115| type LogConfig struct {
   116| 	Format string
   117| 	Level  zerolog.Level
   118| }
   119| func LoadConfig(path string, isFile bool) error {
   120| 	if isFile {
   121| 		viper.SetConfigFile(path)
   122| 	} else {
   123| 		viper.SetConfigName("config")
   124| 		if path == "" {
   125| 			viper.AddConfigPath("/etc/headscale/")
   126| 			viper.AddConfigPath("$HOME/.headscale")
   127| 			viper.AddConfigPath(".")
   128| 		} else {
   129| 			viper.AddConfigPath(path)
   130| 		}
   131| 	}
   132| 	viper.SetEnvPrefix("headscale")
   133| 	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
   134| 	viper.AutomaticEnv()
   135| 	viper.SetDefault("tls_letsencrypt_cache_dir", "/var/www/.cache")
   136| 	viper.SetDefault("tls_letsencrypt_challenge_type", http01ChallengeType)
   137| 	viper.SetDefault("log.level", "info")
   138| 	viper.SetDefault("log.format", TextLogFormat)
   139| 	viper.SetDefault("dns_config", nil)
   140| 	viper.SetDefault("dns_config.override_local_dns", true)
   141| 	viper.SetDefault("derp.server.enabled", false)
   142| 	viper.SetDefault("derp.server.stun.enabled", true)
   143| 	viper.SetDefault("unix_socket", "/var/run/headscale/headscale.sock")
   144| 	viper.SetDefault("unix_socket_permission", "0o770")
   145| 	viper.SetDefault("grpc_listen_addr", ":50443")
   146| 	viper.SetDefault("grpc_allow_insecure", false)
   147| 	viper.SetDefault("cli.timeout", "5s")
   148| 	viper.SetDefault("cli.insecure", false)
   149| 	viper.SetDefault("db_ssl", false)
   150| 	viper.SetDefault("oidc.scope", []string{oidc.ScopeOpenID, "profile", "email"})
   151| 	viper.SetDefault("oidc.strip_email_domain", true)
   152| 	viper.SetDefault("oidc.only_start_if_oidc_is_available", true)
   153| 	viper.SetDefault("oidc.expiry", "180d")
   154| 	viper.SetDefault("oidc.use_expiry_from_token", false)
   155| 	viper.SetDefault("logtail.enabled", false)
   156| 	viper.SetDefault("randomize_client_port", false)
   157| 	viper.SetDefault("ephemeral_node_inactivity_timeout", "120s")
   158| 	viper.SetDefault("node_update_check_interval", "10s")
   159| 	if IsCLIConfigured() {
   160| 		return nil
   161| 	}
   162| 	if err := viper.ReadInConfig(); err != nil {
   163| 		log.Warn().Err(err).Msg("Failed to read configuration from disk")
   164| 		return fmt.Errorf("fatal error reading config file: %w", err)
   165| 	}
   166| 	var errorText string
   167| 	if (viper.GetString("tls_letsencrypt_hostname") != "") &&
   168| 		((viper.GetString("tls_cert_path") != "") || (viper.GetString("tls_key_path") != "")) {
   169| 		errorText += "Fatal config error: set either tls_letsencrypt_hostname or tls_cert_path/tls_key_path, not both\n"
   170| 	}
   171| 	if !viper.IsSet("noise") || viper.GetString("noise.private_key_path") == "" {
   172| 		errorText += "Fatal config error: headscale now requires a new `noise.private_key_path` field in the config file for the Tailscale v2 protocol\n"
   173| 	}
   174| 	if (viper.GetString("tls_letsencrypt_hostname") != "") &&
   175| 		(viper.GetString("tls_letsencrypt_challenge_type") == tlsALPN01ChallengeType) &&
   176| 		(!strings.HasSuffix(viper.GetString("listen_addr"), ":443")) {
   177| 		log.Warn().
   178| 			Msg("Warning: when using tls_letsencrypt_hostname with TLS-ALPN-01 as challenge type, headscale must be reachable on port 443, i.e. listen_addr should probably end in :443")
   179| 	}
   180| 	if (viper.GetString("tls_letsencrypt_challenge_type") != http01ChallengeType) &&
   181| 		(viper.GetString("tls_letsencrypt_challenge_type") != tlsALPN01ChallengeType) {
   182| 		errorText += "Fatal config error: the only supported values for tls_letsencrypt_challenge_type are HTTP-01 and TLS-ALPN-01\n"
   183| 	}
   184| 	if !strings.HasPrefix(viper.GetString("server_url"), "http://") &&
   185| 		!strings.HasPrefix(viper.GetString("server_url"), "https://") {
   186| 		errorText += "Fatal config error: server_url must start with https:// or http://\n"
   187| 	}
   188| 	minInactivityTimeout, _ := time.ParseDuration("65s")
   189| 	if viper.GetDuration("ephemeral_node_inactivity_timeout") <= minInactivityTimeout {
   190| 		errorText += fmt.Sprintf(
   191| 			"Fatal config error: ephemeral_node_inactivity_timeout (%s) is set too low, must be more than %s",
   192| 			viper.GetString("ephemeral_node_inactivity_timeout"),
   193| 			minInactivityTimeout,
   194| 		)
   195| 	}
   196| 	maxNodeUpdateCheckInterval, _ := time.ParseDuration("60s")
   197| 	if viper.GetDuration("node_update_check_interval") > maxNodeUpdateCheckInterval {
   198| 		errorText += fmt.Sprintf(
   199| 			"Fatal config error: node_update_check_interval (%s) is set too high, must be less than %s",
   200| 			viper.GetString("node_update_check_interval"),
   201| 			maxNodeUpdateCheckInterval,
   202| 		)
   203| 	}
   204| 	if errorText != "" {
   205| 		return errors.New(strings.TrimSuffix(errorText, "\n"))
   206| 	} else {
   207| 		return nil
   208| 	}
   209| }
   210| func GetTLSConfig() TLSConfig {
   211| 	return TLSConfig{
   212| 		LetsEncrypt: LetsEncryptConfig{
   213| 			Hostname: viper.GetString("tls_letsencrypt_hostname"),
   214| 			Listen:   viper.GetString("tls_letsencrypt_listen"),
   215| 			CacheDir: AbsolutePathFromConfigPath(
   216| 				viper.GetString("tls_letsencrypt_cache_dir"),
   217| 			),
   218| 			ChallengeType: viper.GetString("tls_letsencrypt_challenge_type"),
   219| 		},
   220| 		CertPath: AbsolutePathFromConfigPath(
   221| 			viper.GetString("tls_cert_path"),
   222| 		),
   223| 		KeyPath: AbsolutePathFromConfigPath(
   224| 			viper.GetString("tls_key_path"),
   225| 		),
   226| 	}
   227| }
   228| func GetDERPConfig() DERPConfig {
   229| 	serverEnabled := viper.GetBool("derp.server.enabled")
   230| 	serverRegionID := viper.GetInt("derp.server.region_id")
   231| 	serverRegionCode := viper.GetString("derp.server.region_code")
   232| 	serverRegionName := viper.GetString("derp.server.region_name")
   233| 	stunAddr := viper.GetString("derp.server.stun_listen_addr")
   234| 	if serverEnabled && stunAddr == "" {
   235| 		log.Fatal().
   236| 			Msg("derp.server.stun_listen_addr must be set if derp.server.enabled is true")
   237| 	}
   238| 	urlStrs := viper.GetStringSlice("derp.urls")
   239| 	urls := make([]url.URL, len(urlStrs))
   240| 	for index, urlStr := range urlStrs {
   241| 		urlAddr, err := url.Parse(urlStr)
   242| 		if err != nil {
   243| 			log.Error().
   244| 				Str("url", urlStr).
   245| 				Err(err).
   246| 				Msg("Failed to parse url, ignoring...")
   247| 		}
   248| 		urls[index] = *urlAddr
   249| 	}
   250| 	paths := viper.GetStringSlice("derp.paths")
   251| 	autoUpdate := viper.GetBool("derp.auto_update_enabled")
   252| 	updateFrequency := viper.GetDuration("derp.update_frequency")
   253| 	return DERPConfig{
   254| 		ServerEnabled:    serverEnabled,
   255| 		ServerRegionID:   serverRegionID,
   256| 		ServerRegionCode: serverRegionCode,
   257| 		ServerRegionName: serverRegionName,
   258| 		STUNAddr:         stunAddr,
   259| 		URLs:             urls,
   260| 		Paths:            paths,
   261| 		AutoUpdate:       autoUpdate,
   262| 		UpdateFrequency:  updateFrequency,
   263| 	}
   264| }
   265| func GetLogTailConfig() LogTailConfig {
   266| 	enabled := viper.GetBool("logtail.enabled")
   267| 	return LogTailConfig{
   268| 		Enabled: enabled,
   269| 	}
   270| }
   271| func GetACLConfig() ACLConfig {
   272| 	policyPath := viper.GetString("acl_policy_path")
   273| 	return ACLConfig{
   274| 		PolicyPath: policyPath,
   275| 	}
   276| }
   277| func GetLogConfig() LogConfig {
   278| 	logLevelStr := viper.GetString("log.level")
   279| 	logLevel, err := zerolog.ParseLevel(logLevelStr)
   280| 	if err != nil {
   281| 		logLevel = zerolog.DebugLevel
   282| 	}
   283| 	logFormatOpt := viper.GetString("log.format")
   284| 	var logFormat string
   285| 	switch logFormatOpt {
   286| 	case "json":
   287| 		logFormat = JSONLogFormat
   288| 	case "text":
   289| 		logFormat = TextLogFormat
   290| 	case "":
   291| 		logFormat = TextLogFormat
   292| 	default:
   293| 		log.Error().
   294| 			Str("func", "GetLogConfig").
   295| 			Msgf("Could not parse log format: %s. Valid choices are 'json' or 'text'", logFormatOpt)
   296| 	}
   297| 	return LogConfig{
   298| 		Format: logFormat,
   299| 		Level:  logLevel,
   300| 	}
   301| }
   302| func GetDNSConfig() (*tailcfg.DNSConfig, string) {
   303| 	if viper.IsSet("dns_config") {
   304| 		dnsConfig := &tailcfg.DNSConfig{}
   305| 		overrideLocalDNS := viper.GetBool("dns_config.override_local_dns")
   306| 		if viper.IsSet("dns_config.nameservers") {
   307| 			nameserversStr := viper.GetStringSlice("dns_config.nameservers")
   308| 			nameservers := []netip.Addr{}
   309| 			resolvers := []*dnstype.Resolver{}
   310| 			for _, nameserverStr := range nameserversStr {
   311| 				if strings.HasPrefix(nameserverStr, "https://") {
   312| 					resolvers = append(resolvers, &dnstype.Resolver{
   313| 						Addr: nameserverStr,
   314| 					})
   315| 					continue
   316| 				}
   317| 				nameserver, err := netip.ParseAddr(nameserverStr)
   318| 				if err != nil {
   319| 					log.Error().
   320| 						Str("func", "getDNSConfig").
   321| 						Err(err).
   322| 						Msgf("Could not parse nameserver IP: %s", nameserverStr)
   323| 				}
   324| 				nameservers = append(nameservers, nameserver)
   325| 				resolvers = append(resolvers, &dnstype.Resolver{
   326| 					Addr: nameserver.String(),
   327| 				})
   328| 			}
   329| 			dnsConfig.Nameservers = nameservers
   330| 			if overrideLocalDNS {
   331| 				dnsConfig.Resolvers = resolvers
   332| 			} else {
   333| 				dnsConfig.FallbackResolvers = resolvers
   334| 			}
   335| 		}
   336| 		if viper.IsSet("dns_config.restricted_nameservers") {
   337| 			dnsConfig.Routes = make(map[string][]*dnstype.Resolver)
   338| 			domains := []string{}
   339| 			restrictedDNS := viper.GetStringMapStringSlice(
   340| 				"dns_config.restricted_nameservers",
   341| 			)
   342| 			for domain, restrictedNameservers := range restrictedDNS {
   343| 				restrictedResolvers := make(
   344| 					[]*dnstype.Resolver,
   345| 					len(restrictedNameservers),
   346| 				)
   347| 				for index, nameserverStr := range restrictedNameservers {
   348| 					nameserver, err := netip.ParseAddr(nameserverStr)
   349| 					if err != nil {
   350| 						log.Error().
   351| 							Str("func", "getDNSConfig").
   352| 							Err(err).
   353| 							Msgf("Could not parse restricted nameserver IP: %s", nameserverStr)
   354| 					}
   355| 					restrictedResolvers[index] = &dnstype.Resolver{
   356| 						Addr: nameserver.String(),
   357| 					}
   358| 				}
   359| 				dnsConfig.Routes[domain] = restrictedResolvers
   360| 				domains = append(domains, domain)
   361| 			}
   362| 			dnsConfig.Domains = domains
   363| 		}
   364| 		if viper.IsSet("dns_config.domains") {
   365| 			domains := viper.GetStringSlice("dns_config.domains")
   366| 			if len(dnsConfig.Resolvers) > 0 {
   367| 				dnsConfig.Domains = domains
   368| 			} else if domains != nil {
   369| 				log.Warn().
   370| 					Msg("Warning: dns_config.domains is set, but no nameservers are configured. Ignoring domains.")
   371| 			}
   372| 		}
   373| 		if viper.IsSet("dns_config.extra_records") {
   374| 			var extraRecords []tailcfg.DNSRecord
   375| 			err := viper.UnmarshalKey("dns_config.extra_records", &extraRecords)
   376| 			if err != nil {
   377| 				log.Error().
   378| 					Str("func", "getDNSConfig").
   379| 					Err(err).
   380| 					Msgf("Could not parse dns_config.extra_records")
   381| 			}
   382| 			dnsConfig.ExtraRecords = extraRecords
   383| 		}
   384| 		if viper.IsSet("dns_config.magic_dns") {
   385| 			dnsConfig.Proxied = viper.GetBool("dns_config.magic_dns")
   386| 		}
   387| 		var baseDomain string
   388| 		if viper.IsSet("dns_config.base_domain") {
   389| 			baseDomain = viper.GetString("dns_config.base_domain")
   390| 		} else {
   391| 			baseDomain = "headscale.net" // does not really matter when MagicDNS is not enabled
   392| 		}
   393| 		return dnsConfig, baseDomain
   394| 	}
   395| 	return nil, ""
   396| }
   397| func GetHeadscaleConfig() (*Config, error) {
   398| 	if IsCLIConfigured() {
   399| 		return &Config{
   400| 			CLI: CLIConfig{
   401| 				Address:  viper.GetString("cli.address"),
   402| 				APIKey:   viper.GetString("cli.api_key"),
   403| 				Timeout:  viper.GetDuration("cli.timeout"),
   404| 				Insecure: viper.GetBool("cli.insecure"),
   405| 			},
   406| 		}, nil
   407| 	}
   408| 	dnsConfig, baseDomain := GetDNSConfig()
   409| 	derpConfig := GetDERPConfig()
   410| 	logConfig := GetLogTailConfig()
   411| 	randomizeClientPort := viper.GetBool("randomize_client_port")
   412| 	configuredPrefixes := viper.GetStringSlice("ip_prefixes")
   413| 	parsedPrefixes := make([]netip.Prefix, 0, len(configuredPrefixes)+1)
   414| 	for i, prefixInConfig := range configuredPrefixes {
   415| 		prefix, err := netip.ParsePrefix(prefixInConfig)
   416| 		if err != nil {
   417| 			panic(fmt.Errorf("failed to parse ip_prefixes[%d]: %w", i, err))
   418| 		}
   419| 		if prefix.Addr().Is4() {
   420| 			builder := netipx.IPSetBuilder{}
   421| 			builder.AddPrefix(tsaddr.CGNATRange())
   422| 			ipSet, _ := builder.IPSet()
   423| 			if !ipSet.ContainsPrefix(prefix) {
   424| 				log.Warn().
   425| 					Msgf("Prefix %s is not in the %s range. This is an unsupported configuration.",
   426| 						prefixInConfig, tsaddr.CGNATRange())
   427| 			}
   428| 		}
   429| 		if prefix.Addr().Is6() {
   430| 			builder := netipx.IPSetBuilder{}
   431| 			builder.AddPrefix(tsaddr.TailscaleULARange())
   432| 			ipSet, _ := builder.IPSet()
   433| 			if !ipSet.ContainsPrefix(prefix) {
   434| 				log.Warn().
   435| 					Msgf("Prefix %s is not in the %s range. This is an unsupported configuration.",
   436| 						prefixInConfig, tsaddr.TailscaleULARange())
   437| 			}
   438| 		}
   439| 		parsedPrefixes = append(parsedPrefixes, prefix)
   440| 	}
   441| 	prefixes := make([]netip.Prefix, 0, len(parsedPrefixes))
   442| 	{
   443| 		normalizedPrefixes := make(map[string]int, len(parsedPrefixes))
   444| 		for i, p := range parsedPrefixes {
   445| 			normalized, _ := netipx.RangeOfPrefix(p).Prefix()
   446| 			normalizedPrefixes[normalized.String()] = i
   447| 		}
   448| 		for _, i := range normalizedPrefixes {
   449| 			prefixes = append(prefixes, parsedPrefixes[i])
   450| 		}
   451| 	}
   452| 	if len(prefixes) < 1 {
   453| 		prefixes = append(prefixes, netip.MustParsePrefix("100.64.0.0/10"))
   454| 		log.Warn().
   455| 			Msgf("'ip_prefixes' not configured, falling back to default: %v", prefixes)
   456| 	}
   457| 	oidcClientSecret := viper.GetString("oidc.client_secret")
   458| 	oidcClientSecretPath := viper.GetString("oidc.client_secret_path")
   459| 	if oidcClientSecretPath != "" && oidcClientSecret != "" {
   460| 		return nil, errOidcMutuallyExclusive
   461| 	}
   462| 	if oidcClientSecretPath != "" {
   463| 		secretBytes, err := os.ReadFile(os.ExpandEnv(oidcClientSecretPath))
   464| 		if err != nil {
   465| 			return nil, err
   466| 		}
   467| 		oidcClientSecret = string(secretBytes)
   468| 	}
   469| 	return &Config{
   470| 		ServerURL:          viper.GetString("server_url"),
   471| 		Addr:               viper.GetString("listen_addr"),
   472| 		MetricsAddr:        viper.GetString("metrics_listen_addr"),
   473| 		GRPCAddr:           viper.GetString("grpc_listen_addr"),
   474| 		GRPCAllowInsecure:  viper.GetBool("grpc_allow_insecure"),
   475| 		DisableUpdateCheck: viper.GetBool("disable_check_updates"),
   476| 		IPPrefixes: prefixes,
   477| 		PrivateKeyPath: AbsolutePathFromConfigPath(
   478| 			viper.GetString("private_key_path"),
   479| 		),
   480| 		NoisePrivateKeyPath: AbsolutePathFromConfigPath(
   481| 			viper.GetString("noise.private_key_path"),
   482| 		),
   483| 		BaseDomain: baseDomain,
   484| 		DERP: derpConfig,
   485| 		EphemeralNodeInactivityTimeout: viper.GetDuration(
   486| 			"ephemeral_node_inactivity_timeout",
   487| 		),
   488| 		NodeUpdateCheckInterval: viper.GetDuration(
   489| 			"node_update_check_interval",
   490| 		),
   491| 		DBtype: viper.GetString("db_type"),
   492| 		DBpath: AbsolutePathFromConfigPath(viper.GetString("db_path")),
   493| 		DBhost: viper.GetString("db_host"),
   494| 		DBport: viper.GetInt("db_port"),
   495| 		DBname: viper.GetString("db_name"),
   496| 		DBuser: viper.GetString("db_user"),
   497| 		DBpass: viper.GetString("db_pass"),
   498| 		DBssl:  viper.GetString("db_ssl"),
   499| 		TLS: GetTLSConfig(),
   500| 		DNSConfig: dnsConfig,
   501| 		ACMEEmail: viper.GetString("acme_email"),
   502| 		ACMEURL:   viper.GetString("acme_url"),
   503| 		UnixSocket:           viper.GetString("unix_socket"),
   504| 		UnixSocketPermission: GetFileMode("unix_socket_permission"),
   505| 		OIDC: OIDCConfig{
   506| 			OnlyStartIfOIDCIsAvailable: viper.GetBool(
   507| 				"oidc.only_start_if_oidc_is_available",
   508| 			),
   509| 			Issuer:           viper.GetString("oidc.issuer"),
   510| 			ClientID:         viper.GetString("oidc.client_id"),
   511| 			ClientSecret:     oidcClientSecret,
   512| 			Scope:            viper.GetStringSlice("oidc.scope"),
   513| 			ExtraParams:      viper.GetStringMapString("oidc.extra_params"),
   514| 			AllowedDomains:   viper.GetStringSlice("oidc.allowed_domains"),
   515| 			AllowedUsers:     viper.GetStringSlice("oidc.allowed_users"),
   516| 			AllowedGroups:    viper.GetStringSlice("oidc.allowed_groups"),
   517| 			StripEmaildomain: viper.GetBool("oidc.strip_email_domain"),
   518| 			Expiry: func() time.Duration {
   519| 				if value := viper.GetString("oidc.expiry"); value == "0" {
   520| 					return maxDuration
   521| 				} else {
   522| 					expiry, err := model.ParseDuration(value)
   523| 					if err != nil {
   524| 						log.Warn().Msg("failed to parse oidc.expiry, defaulting back to 180 days")
   525| 						return defaultOIDCExpiryTime
   526| 					}
   527| 					return time.Duration(expiry)
   528| 				}
   529| 			}(),
   530| 			UseExpiryFromToken: viper.GetBool("oidc.use_expiry_from_token"),
   531| 		},
   532| 		LogTail:             logConfig,
   533| 		RandomizeClientPort: randomizeClientPort,
   534| 		ACL: GetACLConfig(),
   535| 		CLI: CLIConfig{
   536| 			Address:  viper.GetString("cli.address"),
   537| 			APIKey:   viper.GetString("cli.api_key"),
   538| 			Timeout:  viper.GetDuration("cli.timeout"),
   539| 			Insecure: viper.GetBool("cli.insecure"),
   540| 		},
   541| 		Log: GetLogConfig(),
   542| 	}, nil
   543| }
   544| func IsCLIConfigured() bool {
   545| 	return viper.GetString("cli.address") != "" && viper.GetString("cli.api_key") != ""
   546| }


# ====================================================================
# FILE: hscontrol/db.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-307 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"database/sql/driver"
     5| 	"encoding/json"
     6| 	"errors"
     7| 	"fmt"
     8| 	"net/netip"
     9| 	"time"
    10| 	"github.com/glebarez/sqlite"
    11| 	"github.com/rs/zerolog/log"
    12| 	"gorm.io/driver/postgres"
    13| 	"gorm.io/gorm"
    14| 	"gorm.io/gorm/logger"
    15| 	"tailscale.com/tailcfg"
    16| )
    17| const (
    18| 	dbVersion = "1"
    19| 	errValueNotFound     = Error("not found")
    20| 	ErrCannotParsePrefix = Error("cannot parse prefix")
    21| )
    22| type KV struct {
    23| 	Key   string
    24| 	Value string
    25| }
    26| func (h *Headscale) initDB() error {
    27| 	db, err := h.openDB()
    28| 	if err != nil {
    29| 		return err
    30| 	}
    31| 	h.db = db
    32| 	if h.dbType == Postgres {
    33| 		db.Exec(`create extension if not exists "uuid-ossp";`)
    34| 	}
    35| 	_ = db.Migrator().RenameTable("namespaces", "users")
    36| 	err = db.AutoMigrate(&User{})
    37| 	if err != nil {
    38| 		return err
    39| 	}
    40| 	_ = db.Migrator().RenameColumn(&Machine{}, "namespace_id", "user_id")
    41| 	_ = db.Migrator().RenameColumn(&PreAuthKey{}, "namespace_id", "user_id")
    42| 	_ = db.Migrator().RenameColumn(&Machine{}, "ip_address", "ip_addresses")
    43| 	_ = db.Migrator().RenameColumn(&Machine{}, "name", "hostname")
    44| 	_ = db.Migrator().RenameColumn(&Machine{}, "nickname", "given_name")
    45| 	if db.Migrator().HasColumn(&Machine{}, "registered") {
    46| 		log.Info().
    47| 			Msg(`Database has legacy "registered" column in machine, removing...`)
    48| 		machines := Machines{}
    49| 		if err := h.db.Not("registered").Find(&machines).Error; err != nil {
    50| 			log.Error().Err(err).Msg("Error accessing db")
    51| 		}
    52| 		for _, machine := range machines {
    53| 			log.Info().
    54| 				Str("machine", machine.Hostname).
    55| 				Str("machine_key", machine.MachineKey).
    56| 				Msg("Deleting unregistered machine")
    57| 			if err := h.db.Delete(&Machine{}, machine.ID).Error; err != nil {
    58| 				log.Error().
    59| 					Err(err).
    60| 					Str("machine", machine.Hostname).
    61| 					Str("machine_key", machine.MachineKey).
    62| 					Msg("Error deleting unregistered machine")
    63| 			}
    64| 		}
    65| 		err := db.Migrator().DropColumn(&Machine{}, "registered")
    66| 		if err != nil {
    67| 			log.Error().Err(err).Msg("Error dropping registered column")
    68| 		}
    69| 	}
    70| 	err = db.AutoMigrate(&Route{})
    71| 	if err != nil {
    72| 		return err
    73| 	}
    74| 	if db.Migrator().HasColumn(&Machine{}, "enabled_routes") {
    75| 		log.Info().Msgf("Database has legacy enabled_routes column in machine, migrating...")
    76| 		type MachineAux struct {
    77| 			ID            uint64
    78| 			EnabledRoutes IPPrefixes
    79| 		}
    80| 		machinesAux := []MachineAux{}
    81| 		err := db.Table("machines").Select("id, enabled_routes").Scan(&machinesAux).Error
    82| 		if err != nil {
    83| 			log.Fatal().Err(err).Msg("Error accessing db")
    84| 		}
    85| 		for _, machine := range machinesAux {
    86| 			for _, prefix := range machine.EnabledRoutes {
    87| 				if err != nil {
    88| 					log.Error().
    89| 						Err(err).
    90| 						Str("enabled_route", prefix.String()).
    91| 						Msg("Error parsing enabled_route")
    92| 					continue
    93| 				}
    94| 				err = db.Preload("Machine").
    95| 					Where("machine_id = ? AND prefix = ?", machine.ID, IPPrefix(prefix)).
    96| 					First(&Route{}).
    97| 					Error
    98| 				if err == nil {
    99| 					log.Info().
   100| 						Str("enabled_route", prefix.String()).
   101| 						Msg("Route already migrated to new table, skipping")
   102| 					continue
   103| 				}
   104| 				route := Route{
   105| 					MachineID:  machine.ID,
   106| 					Advertised: true,
   107| 					Enabled:    true,
   108| 					Prefix:     IPPrefix(prefix),
   109| 				}
   110| 				if err := h.db.Create(&route).Error; err != nil {
   111| 					log.Error().Err(err).Msg("Error creating route")
   112| 				} else {
   113| 					log.Info().
   114| 						Uint64("machine_id", route.MachineID).
   115| 						Str("prefix", prefix.String()).
   116| 						Msg("Route migrated")
   117| 				}
   118| 			}
   119| 		}
   120| 		err = db.Migrator().DropColumn(&Machine{}, "enabled_routes")
   121| 		if err != nil {
   122| 			log.Error().Err(err).Msg("Error dropping enabled_routes column")
   123| 		}
   124| 	}
   125| 	err = db.AutoMigrate(&Machine{})
   126| 	if err != nil {
   127| 		return err
   128| 	}
   129| 	if db.Migrator().HasColumn(&Machine{}, "given_name") {
   130| 		machines := Machines{}
   131| 		if err := h.db.Find(&machines).Error; err != nil {
   132| 			log.Error().Err(err).Msg("Error accessing db")
   133| 		}
   134| 		for item, machine := range machines {
   135| 			if machine.GivenName == "" {
   136| 				normalizedHostname, err := NormalizeToFQDNRules(
   137| 					machine.Hostname,
   138| 					h.cfg.OIDC.StripEmaildomain,
   139| 				)
   140| 				if err != nil {
   141| 					log.Error().
   142| 						Caller().
   143| 						Str("hostname", machine.Hostname).
   144| 						Err(err).
   145| 						Msg("Failed to normalize machine hostname in DB migration")
   146| 				}
   147| 				err = h.RenameMachine(&machines[item], normalizedHostname)
   148| 				if err != nil {
   149| 					log.Error().
   150| 						Caller().
   151| 						Str("hostname", machine.Hostname).
   152| 						Err(err).
   153| 						Msg("Failed to save normalized machine name in DB migration")
   154| 				}
   155| 			}
   156| 		}
   157| 	}
   158| 	err = db.AutoMigrate(&KV{})
   159| 	if err != nil {
   160| 		return err
   161| 	}
   162| 	err = db.AutoMigrate(&PreAuthKey{})
   163| 	if err != nil {
   164| 		return err
   165| 	}
   166| 	err = db.AutoMigrate(&PreAuthKeyACLTag{})
   167| 	if err != nil {
   168| 		return err
   169| 	}
   170| 	_ = db.Migrator().DropTable("shared_machines")
   171| 	err = db.AutoMigrate(&APIKey{})
   172| 	if err != nil {
   173| 		return err
   174| 	}
   175| 	err = h.setValue("db_version", dbVersion)
   176| 	return err
   177| }
   178| func (h *Headscale) openDB() (*gorm.DB, error) {
   179| 	var db *gorm.DB
   180| 	var err error
   181| 	var log logger.Interface
   182| 	if h.dbDebug {
   183| 		log = logger.Default
   184| 	} else {
   185| 		log = logger.Default.LogMode(logger.Silent)
   186| 	}
   187| 	switch h.dbType {
   188| 	case Sqlite:
   189| 		db, err = gorm.Open(
   190| 			sqlite.Open(h.dbString+"?_synchronous=1&_journal_mode=WAL"),
   191| 			&gorm.Config{
   192| 				DisableForeignKeyConstraintWhenMigrating: true,
   193| 				Logger:                                   log,
   194| 			},
   195| 		)
   196| 		db.Exec("PRAGMA foreign_keys=ON")
   197| 		sqlDB, _ := db.DB()
   198| 		sqlDB.SetMaxIdleConns(1)
   199| 		sqlDB.SetMaxOpenConns(1)
   200| 		sqlDB.SetConnMaxIdleTime(time.Hour)
   201| 	case Postgres:
   202| 		db, err = gorm.Open(postgres.Open(h.dbString), &gorm.Config{
   203| 			DisableForeignKeyConstraintWhenMigrating: true,
   204| 			Logger:                                   log,
   205| 		})
   206| 	}
   207| 	if err != nil {
   208| 		return nil, err
   209| 	}
   210| 	return db, nil
   211| }
   212| func (h *Headscale) getValue(key string) (string, error) {
   213| 	var row KV
   214| 	if result := h.db.First(&row, "key = ?", key); errors.Is(
   215| 		result.Error,
   216| 		gorm.ErrRecordNotFound,
   217| 	) {
   218| 		return "", errValueNotFound
   219| 	}
   220| 	return row.Value, nil
   221| }
   222| func (h *Headscale) setValue(key string, value string) error {
   223| 	keyValue := KV{
   224| 		Key:   key,
   225| 		Value: value,
   226| 	}
   227| 	if _, err := h.getValue(key); err == nil {
   228| 		h.db.Model(&keyValue).Where("key = ?", key).Update("value", value)
   229| 		return nil
   230| 	}
   231| 	if err := h.db.Create(keyValue).Error; err != nil {
   232| 		return fmt.Errorf("failed to create key value pair in the database: %w", err)
   233| 	}
   234| 	return nil
   235| }
   236| func (h *Headscale) pingDB(ctx context.Context) error {
   237| 	ctx, cancel := context.WithTimeout(ctx, time.Second)
   238| 	defer cancel()
   239| 	db, err := h.db.DB()
   240| 	if err != nil {
   241| 		return err
   242| 	}
   243| 	return db.PingContext(ctx)
   244| }
   245| type HostInfo tailcfg.Hostinfo
   246| func (hi *HostInfo) Scan(destination interface{}) error {
   247| 	switch value := destination.(type) {
   248| 	case []byte:
   249| 		return json.Unmarshal(value, hi)
   250| 	case string:
   251| 		return json.Unmarshal([]byte(value), hi)
   252| 	default:
   253| 		return fmt.Errorf("%w: unexpected data type %T", ErrMachineAddressesInvalid, destination)
   254| 	}
   255| }
   256| func (hi HostInfo) Value() (driver.Value, error) {
   257| 	bytes, err := json.Marshal(hi)
   258| 	return string(bytes), err
   259| }
   260| type IPPrefix netip.Prefix
   261| func (i *IPPrefix) Scan(destination interface{}) error {
   262| 	switch value := destination.(type) {
   263| 	case string:
   264| 		prefix, err := netip.ParsePrefix(value)
   265| 		if err != nil {
   266| 			return err
   267| 		}
   268| 		*i = IPPrefix(prefix)
   269| 		return nil
   270| 	default:
   271| 		return fmt.Errorf("%w: unexpected data type %T", ErrCannotParsePrefix, destination)
   272| 	}
   273| }
   274| func (i IPPrefix) Value() (driver.Value, error) {
   275| 	prefixStr := netip.Prefix(i).String()
   276| 	return prefixStr, nil
   277| }
   278| type IPPrefixes []netip.Prefix
   279| func (i *IPPrefixes) Scan(destination interface{}) error {
   280| 	switch value := destination.(type) {
   281| 	case []byte:
   282| 		return json.Unmarshal(value, i)
   283| 	case string:
   284| 		return json.Unmarshal([]byte(value), i)
   285| 	default:
   286| 		return fmt.Errorf("%w: unexpected data type %T", ErrMachineAddressesInvalid, destination)
   287| 	}
   288| }
   289| func (i IPPrefixes) Value() (driver.Value, error) {
   290| 	bytes, err := json.Marshal(i)
   291| 	return string(bytes), err
   292| }
   293| type StringList []string
   294| func (i *StringList) Scan(destination interface{}) error {
   295| 	switch value := destination.(type) {
   296| 	case []byte:
   297| 		return json.Unmarshal(value, i)
   298| 	case string:
   299| 		return json.Unmarshal([]byte(value), i)
   300| 	default:
   301| 		return fmt.Errorf("%w: unexpected data type %T", ErrMachineAddressesInvalid, destination)
   302| 	}
   303| }
   304| func (i StringList) Value() (driver.Value, error) {
   305| 	bytes, err := json.Marshal(i)
   306| 	return string(bytes), err
   307| }


# ====================================================================
# FILE: hscontrol/grpcv1.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-460 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"strings"
     6| 	"time"
     7| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     8| 	"github.com/rs/zerolog/log"
     9| 	"google.golang.org/grpc/codes"
    10| 	"google.golang.org/grpc/status"
    11| 	"tailscale.com/tailcfg"
    12| 	"tailscale.com/types/key"
    13| )
    14| type headscaleV1APIServer struct { // v1.HeadscaleServiceServer
    15| 	v1.UnimplementedHeadscaleServiceServer
    16| 	h *Headscale
    17| }
    18| func newHeadscaleV1APIServer(h *Headscale) v1.HeadscaleServiceServer {
    19| 	return headscaleV1APIServer{
    20| 		h: h,
    21| 	}
    22| }
    23| func (api headscaleV1APIServer) GetUser(
    24| 	ctx context.Context,
    25| 	request *v1.GetUserRequest,
    26| ) (*v1.GetUserResponse, error) {
    27| 	user, err := api.h.GetUser(request.GetName())
    28| 	if err != nil {
    29| 		return nil, err
    30| 	}
    31| 	return &v1.GetUserResponse{User: user.toProto()}, nil
    32| }
    33| func (api headscaleV1APIServer) CreateUser(
    34| 	ctx context.Context,
    35| 	request *v1.CreateUserRequest,
    36| ) (*v1.CreateUserResponse, error) {
    37| 	user, err := api.h.CreateUser(request.GetName())
    38| 	if err != nil {
    39| 		return nil, err
    40| 	}
    41| 	return &v1.CreateUserResponse{User: user.toProto()}, nil
    42| }
    43| func (api headscaleV1APIServer) RenameUser(
    44| 	ctx context.Context,
    45| 	request *v1.RenameUserRequest,
    46| ) (*v1.RenameUserResponse, error) {
    47| 	err := api.h.RenameUser(request.GetOldName(), request.GetNewName())
    48| 	if err != nil {
    49| 		return nil, err
    50| 	}
    51| 	user, err := api.h.GetUser(request.GetNewName())
    52| 	if err != nil {
    53| 		return nil, err
    54| 	}
    55| 	return &v1.RenameUserResponse{User: user.toProto()}, nil
    56| }
    57| func (api headscaleV1APIServer) DeleteUser(
    58| 	ctx context.Context,
    59| 	request *v1.DeleteUserRequest,
    60| ) (*v1.DeleteUserResponse, error) {
    61| 	err := api.h.DestroyUser(request.GetName())
    62| 	if err != nil {
    63| 		return nil, err
    64| 	}
    65| 	return &v1.DeleteUserResponse{}, nil
    66| }
    67| func (api headscaleV1APIServer) ListUsers(
    68| 	ctx context.Context,
    69| 	request *v1.ListUsersRequest,
    70| ) (*v1.ListUsersResponse, error) {
    71| 	users, err := api.h.ListUsers()
    72| 	if err != nil {
    73| 		return nil, err
    74| 	}
    75| 	response := make([]*v1.User, len(users))
    76| 	for index, user := range users {
    77| 		response[index] = user.toProto()
    78| 	}
    79| 	log.Trace().Caller().Interface("users", response).Msg("")
    80| 	return &v1.ListUsersResponse{Users: response}, nil
    81| }
    82| func (api headscaleV1APIServer) CreatePreAuthKey(
    83| 	ctx context.Context,
    84| 	request *v1.CreatePreAuthKeyRequest,
    85| ) (*v1.CreatePreAuthKeyResponse, error) {
    86| 	var expiration time.Time
    87| 	if request.GetExpiration() != nil {
    88| 		expiration = request.GetExpiration().AsTime()
    89| 	}
    90| 	for _, tag := range request.AclTags {
    91| 		err := validateTag(tag)
    92| 		if err != nil {
    93| 			return &v1.CreatePreAuthKeyResponse{
    94| 				PreAuthKey: nil,
    95| 			}, status.Error(codes.InvalidArgument, err.Error())
    96| 		}
    97| 	}
    98| 	preAuthKey, err := api.h.CreatePreAuthKey(
    99| 		request.GetUser(),
   100| 		request.GetReusable(),
   101| 		request.GetEphemeral(),
   102| 		&expiration,
   103| 		request.AclTags,
   104| 	)
   105| 	if err != nil {
   106| 		return nil, err
   107| 	}
   108| 	return &v1.CreatePreAuthKeyResponse{PreAuthKey: preAuthKey.toProto()}, nil
   109| }
   110| func (api headscaleV1APIServer) ExpirePreAuthKey(
   111| 	ctx context.Context,
   112| 	request *v1.ExpirePreAuthKeyRequest,
   113| ) (*v1.ExpirePreAuthKeyResponse, error) {
   114| 	preAuthKey, err := api.h.GetPreAuthKey(request.GetUser(), request.Key)
   115| 	if err != nil {
   116| 		return nil, err
   117| 	}
   118| 	err = api.h.ExpirePreAuthKey(preAuthKey)
   119| 	if err != nil {
   120| 		return nil, err
   121| 	}
   122| 	return &v1.ExpirePreAuthKeyResponse{}, nil
   123| }
   124| func (api headscaleV1APIServer) ListPreAuthKeys(
   125| 	ctx context.Context,
   126| 	request *v1.ListPreAuthKeysRequest,
   127| ) (*v1.ListPreAuthKeysResponse, error) {
   128| 	preAuthKeys, err := api.h.ListPreAuthKeys(request.GetUser())
   129| 	if err != nil {
   130| 		return nil, err
   131| 	}
   132| 	response := make([]*v1.PreAuthKey, len(preAuthKeys))
   133| 	for index, key := range preAuthKeys {
   134| 		response[index] = key.toProto()
   135| 	}
   136| 	return &v1.ListPreAuthKeysResponse{PreAuthKeys: response}, nil
   137| }
   138| func (api headscaleV1APIServer) RegisterMachine(
   139| 	ctx context.Context,
   140| 	request *v1.RegisterMachineRequest,
   141| ) (*v1.RegisterMachineResponse, error) {
   142| 	log.Trace().
   143| 		Str("user", request.GetUser()).
   144| 		Str("node_key", request.GetKey()).
   145| 		Msg("Registering machine")
   146| 	machine, err := api.h.RegisterMachineFromAuthCallback(
   147| 		request.GetKey(),
   148| 		request.GetUser(),
   149| 		nil,
   150| 		RegisterMethodCLI,
   151| 	)
   152| 	if err != nil {
   153| 		return nil, err
   154| 	}
   155| 	return &v1.RegisterMachineResponse{Machine: machine.toProto()}, nil
   156| }
   157| func (api headscaleV1APIServer) GetMachine(
   158| 	ctx context.Context,
   159| 	request *v1.GetMachineRequest,
   160| ) (*v1.GetMachineResponse, error) {
   161| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   162| 	if err != nil {
   163| 		return nil, err
   164| 	}
   165| 	return &v1.GetMachineResponse{Machine: machine.toProto()}, nil
   166| }
   167| func (api headscaleV1APIServer) SetTags(
   168| 	ctx context.Context,
   169| 	request *v1.SetTagsRequest,
   170| ) (*v1.SetTagsResponse, error) {
   171| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   172| 	if err != nil {
   173| 		return nil, err
   174| 	}
   175| 	for _, tag := range request.GetTags() {
   176| 		err := validateTag(tag)
   177| 		if err != nil {
   178| 			return &v1.SetTagsResponse{
   179| 				Machine: nil,
   180| 			}, status.Error(codes.InvalidArgument, err.Error())
   181| 		}
   182| 	}
   183| 	err = api.h.SetTags(machine, request.GetTags())
   184| 	if err != nil {
   185| 		return &v1.SetTagsResponse{
   186| 			Machine: nil,
   187| 		}, status.Error(codes.Internal, err.Error())
   188| 	}
   189| 	log.Trace().
   190| 		Str("machine", machine.Hostname).
   191| 		Strs("tags", request.GetTags()).
   192| 		Msg("Changing tags of machine")
   193| 	return &v1.SetTagsResponse{Machine: machine.toProto()}, nil
   194| }
   195| func validateTag(tag string) error {
   196| 	if strings.Index(tag, "tag:") != 0 {
   197| 		return fmt.Errorf("tag must start with the string 'tag:'")
   198| 	}
   199| 	if strings.ToLower(tag) != tag {
   200| 		return fmt.Errorf("tag should be lowercase")
   201| 	}
   202| 	if len(strings.Fields(tag)) > 1 {
   203| 		return fmt.Errorf("tag should not contains space")
   204| 	}
   205| 	return nil
   206| }
   207| func (api headscaleV1APIServer) DeleteMachine(
   208| 	ctx context.Context,
   209| 	request *v1.DeleteMachineRequest,
   210| ) (*v1.DeleteMachineResponse, error) {
   211| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   212| 	if err != nil {
   213| 		return nil, err
   214| 	}
   215| 	err = api.h.DeleteMachine(
   216| 		machine,
   217| 	)
   218| 	if err != nil {
   219| 		return nil, err
   220| 	}
   221| 	return &v1.DeleteMachineResponse{}, nil
   222| }
   223| func (api headscaleV1APIServer) ExpireMachine(
   224| 	ctx context.Context,
   225| 	request *v1.ExpireMachineRequest,
   226| ) (*v1.ExpireMachineResponse, error) {
   227| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   228| 	if err != nil {
   229| 		return nil, err
   230| 	}
   231| 	api.h.ExpireMachine(
   232| 		machine,
   233| 	)
   234| 	log.Trace().
   235| 		Str("machine", machine.Hostname).
   236| 		Time("expiry", *machine.Expiry).
   237| 		Msg("machine expired")
   238| 	return &v1.ExpireMachineResponse{Machine: machine.toProto()}, nil
   239| }
   240| func (api headscaleV1APIServer) RenameMachine(
   241| 	ctx context.Context,
   242| 	request *v1.RenameMachineRequest,
   243| ) (*v1.RenameMachineResponse, error) {
   244| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   245| 	if err != nil {
   246| 		return nil, err
   247| 	}
   248| 	err = api.h.RenameMachine(
   249| 		machine,
   250| 		request.GetNewName(),
   251| 	)
   252| 	if err != nil {
   253| 		return nil, err
   254| 	}
   255| 	log.Trace().
   256| 		Str("machine", machine.Hostname).
   257| 		Str("new_name", request.GetNewName()).
   258| 		Msg("machine renamed")
   259| 	return &v1.RenameMachineResponse{Machine: machine.toProto()}, nil
   260| }
   261| func (api headscaleV1APIServer) ListMachines(
   262| 	ctx context.Context,
   263| 	request *v1.ListMachinesRequest,
   264| ) (*v1.ListMachinesResponse, error) {
   265| 	if request.GetUser() != "" {
   266| 		machines, err := api.h.ListMachinesByUser(request.GetUser())
   267| 		if err != nil {
   268| 			return nil, err
   269| 		}
   270| 		response := make([]*v1.Machine, len(machines))
   271| 		for index, machine := range machines {
   272| 			response[index] = machine.toProto()
   273| 		}
   274| 		return &v1.ListMachinesResponse{Machines: response}, nil
   275| 	}
   276| 	machines, err := api.h.ListMachines()
   277| 	if err != nil {
   278| 		return nil, err
   279| 	}
   280| 	response := make([]*v1.Machine, len(machines))
   281| 	for index, machine := range machines {
   282| 		m := machine.toProto()
   283| 		validTags, invalidTags := getTags(
   284| 			api.h.aclPolicy,
   285| 			machine,
   286| 			api.h.cfg.OIDC.StripEmaildomain,
   287| 		)
   288| 		m.InvalidTags = invalidTags
   289| 		m.ValidTags = validTags
   290| 		response[index] = m
   291| 	}
   292| 	return &v1.ListMachinesResponse{Machines: response}, nil
   293| }
   294| func (api headscaleV1APIServer) MoveMachine(
   295| 	ctx context.Context,
   296| 	request *v1.MoveMachineRequest,
   297| ) (*v1.MoveMachineResponse, error) {
   298| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   299| 	if err != nil {
   300| 		return nil, err
   301| 	}
   302| 	err = api.h.SetMachineUser(machine, request.GetUser())
   303| 	if err != nil {
   304| 		return nil, err
   305| 	}
   306| 	return &v1.MoveMachineResponse{Machine: machine.toProto()}, nil
   307| }
   308| func (api headscaleV1APIServer) GetRoutes(
   309| 	ctx context.Context,
   310| 	request *v1.GetRoutesRequest,
   311| ) (*v1.GetRoutesResponse, error) {
   312| 	routes, err := api.h.GetRoutes()
   313| 	if err != nil {
   314| 		return nil, err
   315| 	}
   316| 	return &v1.GetRoutesResponse{
   317| 		Routes: Routes(routes).toProto(),
   318| 	}, nil
   319| }
   320| func (api headscaleV1APIServer) EnableRoute(
   321| 	ctx context.Context,
   322| 	request *v1.EnableRouteRequest,
   323| ) (*v1.EnableRouteResponse, error) {
   324| 	err := api.h.EnableRoute(request.GetRouteId())
   325| 	if err != nil {
   326| 		return nil, err
   327| 	}
   328| 	return &v1.EnableRouteResponse{}, nil
   329| }
   330| func (api headscaleV1APIServer) DisableRoute(
   331| 	ctx context.Context,
   332| 	request *v1.DisableRouteRequest,
   333| ) (*v1.DisableRouteResponse, error) {
   334| 	err := api.h.DisableRoute(request.GetRouteId())
   335| 	if err != nil {
   336| 		return nil, err
   337| 	}
   338| 	return &v1.DisableRouteResponse{}, nil
   339| }
   340| func (api headscaleV1APIServer) GetMachineRoutes(
   341| 	ctx context.Context,
   342| 	request *v1.GetMachineRoutesRequest,
   343| ) (*v1.GetMachineRoutesResponse, error) {
   344| 	machine, err := api.h.GetMachineByID(request.GetMachineId())
   345| 	if err != nil {
   346| 		return nil, err
   347| 	}
   348| 	routes, err := api.h.GetMachineRoutes(machine)
   349| 	if err != nil {
   350| 		return nil, err
   351| 	}
   352| 	return &v1.GetMachineRoutesResponse{
   353| 		Routes: Routes(routes).toProto(),
   354| 	}, nil
   355| }
   356| func (api headscaleV1APIServer) DeleteRoute(
   357| 	ctx context.Context,
   358| 	request *v1.DeleteRouteRequest,
   359| ) (*v1.DeleteRouteResponse, error) {
   360| 	err := api.h.DeleteRoute(request.GetRouteId())
   361| 	if err != nil {
   362| 		return nil, err
   363| 	}
   364| 	return &v1.DeleteRouteResponse{}, nil
   365| }
   366| func (api headscaleV1APIServer) CreateApiKey(
   367| 	ctx context.Context,
   368| 	request *v1.CreateApiKeyRequest,
   369| ) (*v1.CreateApiKeyResponse, error) {
   370| 	var expiration time.Time
   371| 	if request.GetExpiration() != nil {
   372| 		expiration = request.GetExpiration().AsTime()
   373| 	}
   374| 	apiKey, _, err := api.h.CreateAPIKey(
   375| 		&expiration,
   376| 	)
   377| 	if err != nil {
   378| 		return nil, err
   379| 	}
   380| 	return &v1.CreateApiKeyResponse{ApiKey: apiKey}, nil
   381| }
   382| func (api headscaleV1APIServer) ExpireApiKey(
   383| 	ctx context.Context,
   384| 	request *v1.ExpireApiKeyRequest,
   385| ) (*v1.ExpireApiKeyResponse, error) {
   386| 	var apiKey *APIKey
   387| 	var err error
   388| 	apiKey, err = api.h.GetAPIKey(request.Prefix)
   389| 	if err != nil {
   390| 		return nil, err
   391| 	}
   392| 	err = api.h.ExpireAPIKey(apiKey)
   393| 	if err != nil {
   394| 		return nil, err
   395| 	}
   396| 	return &v1.ExpireApiKeyResponse{}, nil
   397| }
   398| func (api headscaleV1APIServer) ListApiKeys(
   399| 	ctx context.Context,
   400| 	request *v1.ListApiKeysRequest,
   401| ) (*v1.ListApiKeysResponse, error) {
   402| 	apiKeys, err := api.h.ListAPIKeys()
   403| 	if err != nil {
   404| 		return nil, err
   405| 	}
   406| 	response := make([]*v1.ApiKey, len(apiKeys))
   407| 	for index, key := range apiKeys {
   408| 		response[index] = key.toProto()
   409| 	}
   410| 	return &v1.ListApiKeysResponse{ApiKeys: response}, nil
   411| }
   412| func (api headscaleV1APIServer) DebugCreateMachine(
   413| 	ctx context.Context,
   414| 	request *v1.DebugCreateMachineRequest,
   415| ) (*v1.DebugCreateMachineResponse, error) {
   416| 	user, err := api.h.GetUser(request.GetUser())
   417| 	if err != nil {
   418| 		return nil, err
   419| 	}
   420| 	routes, err := stringToIPPrefix(request.GetRoutes())
   421| 	if err != nil {
   422| 		return nil, err
   423| 	}
   424| 	log.Trace().
   425| 		Caller().
   426| 		Interface("route-prefix", routes).
   427| 		Interface("route-str", request.GetRoutes()).
   428| 		Msg("")
   429| 	hostinfo := tailcfg.Hostinfo{
   430| 		RoutableIPs: routes,
   431| 		OS:          "TestOS",
   432| 		Hostname:    "DebugTestMachine",
   433| 	}
   434| 	givenName, err := api.h.GenerateGivenName(request.GetKey(), request.GetName())
   435| 	if err != nil {
   436| 		return nil, err
   437| 	}
   438| 	newMachine := Machine{
   439| 		MachineKey: request.GetKey(),
   440| 		Hostname:   request.GetName(),
   441| 		GivenName:  givenName,
   442| 		User:       *user,
   443| 		Expiry:               &time.Time{},
   444| 		LastSeen:             &time.Time{},
   445| 		LastSuccessfulUpdate: &time.Time{},
   446| 		HostInfo: HostInfo(hostinfo),
   447| 	}
   448| 	nodeKey := key.NodePublic{}
   449| 	err = nodeKey.UnmarshalText([]byte(request.GetKey()))
   450| 	if err != nil {
   451| 		log.Panic().Msg("can not add machine for debug. invalid node key")
   452| 	}
   453| 	api.h.registrationCache.Set(
   454| 		NodePublicKeyStripPrefix(nodeKey),
   455| 		newMachine,
   456| 		registerCacheExpiration,
   457| 	)
   458| 	return &v1.DebugCreateMachineResponse{Machine: newMachine.toProto()}, nil
   459| }
   460| func (api headscaleV1APIServer) mustEmbedUnimplementedHeadscaleServiceServer() {}


# ====================================================================
# FILE: hscontrol/handler_legacy.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| package hscontrol
     2| import (
     3| 	"net/http"
     4| 	"github.com/gorilla/mux"
     5| )
     6| func (h *Headscale) addLegacyHandlers(router *mux.Router) {
     7| 	router.HandleFunc("/machine/{mkey}/map", h.PollNetMapHandler).
     8| 		Methods(http.MethodPost)
     9| 	router.HandleFunc("/machine/{mkey}", h.RegistrationHandler).Methods(http.MethodPost)
    10| }


# ====================================================================
# FILE: hscontrol/handler_placeholder.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| package hscontrol
     2| import "github.com/gorilla/mux"
     3| func (h *Headscale) addLegacyHandlers(router *mux.Router) {
     4| }


# ====================================================================
# FILE: hscontrol/machine.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-920 ---
     1| package hscontrol
     2| import (
     3| 	"database/sql/driver"
     4| 	"errors"
     5| 	"fmt"
     6| 	"net/netip"
     7| 	"sort"
     8| 	"strconv"
     9| 	"strings"
    10| 	"time"
    11| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    12| 	"github.com/rs/zerolog/log"
    13| 	"github.com/samber/lo"
    14| 	"go4.org/netipx"
    15| 	"google.golang.org/protobuf/types/known/timestamppb"
    16| 	"gorm.io/gorm"
    17| 	"tailscale.com/tailcfg"
    18| 	"tailscale.com/types/key"
    19| )
    20| const (
    21| 	ErrMachineNotFound                  = Error("machine not found")
    22| 	ErrMachineRouteIsNotAvailable       = Error("route is not available on machine")
    23| 	ErrMachineAddressesInvalid          = Error("failed to parse machine addresses")
    24| 	ErrMachineNotFoundRegistrationCache = Error(
    25| 		"machine not found in registration cache",
    26| 	)
    27| 	ErrCouldNotConvertMachineInterface = Error("failed to convert machine interface")
    28| 	ErrHostnameTooLong                 = Error("Hostname too long")
    29| 	ErrDifferentRegisteredUser         = Error(
    30| 		"machine was previously registered with a different user",
    31| 	)
    32| 	MachineGivenNameHashLength = 8
    33| 	MachineGivenNameTrimSize   = 2
    34| )
    35| const (
    36| 	maxHostnameLength = 255
    37| )
    38| type Machine struct {
    39| 	ID          uint64 `gorm:"primary_key"`
    40| 	MachineKey  string `gorm:"type:varchar(64);unique_index"`
    41| 	NodeKey     string
    42| 	DiscoKey    string
    43| 	IPAddresses MachineAddresses
    44| 	Hostname string
    45| 	GivenName string `gorm:"type:varchar(63);unique_index"`
    46| 	UserID    uint
    47| 	User      User `gorm:"foreignKey:UserID"`
    48| 	RegisterMethod string
    49| 	ForcedTags StringList
    50| 	AuthKeyID uint
    51| 	AuthKey   *PreAuthKey
    52| 	LastSeen             *time.Time
    53| 	LastSuccessfulUpdate *time.Time
    54| 	Expiry               *time.Time
    55| 	HostInfo  HostInfo
    56| 	Endpoints StringList
    57| 	CreatedAt time.Time
    58| 	UpdatedAt time.Time
    59| 	DeletedAt *time.Time
    60| }
    61| type (
    62| 	Machines  []Machine
    63| 	MachinesP []*Machine
    64| )
    65| type MachineAddresses []netip.Addr
    66| func (ma MachineAddresses) ToStringSlice() []string {
    67| 	strSlice := make([]string, 0, len(ma))
    68| 	for _, addr := range ma {
    69| 		strSlice = append(strSlice, addr.String())
    70| 	}
    71| 	return strSlice
    72| }
    73| func (ma MachineAddresses) AppendToIPSet(build *netipx.IPSetBuilder) {
    74| 	for _, ip := range ma {
    75| 		build.Add(ip)
    76| 	}
    77| }
    78| func (ma *MachineAddresses) Scan(destination interface{}) error {
    79| 	switch value := destination.(type) {
    80| 	case string:
    81| 		addresses := strings.Split(value, ",")
    82| 		*ma = (*ma)[:0]
    83| 		for _, addr := range addresses {
    84| 			if len(addr) < 1 {
    85| 				continue
    86| 			}
    87| 			parsed, err := netip.ParseAddr(addr)
    88| 			if err != nil {
    89| 				return err
    90| 			}
    91| 			*ma = append(*ma, parsed)
    92| 		}
    93| 		return nil
    94| 	default:
    95| 		return fmt.Errorf("%w: unexpected data type %T", ErrMachineAddressesInvalid, destination)
    96| 	}
    97| }
    98| func (ma MachineAddresses) Value() (driver.Value, error) {
    99| 	addresses := strings.Join(ma.ToStringSlice(), ",")
   100| 	return addresses, nil
   101| }
   102| func (machine Machine) isExpired() bool {
   103| 	if machine.Expiry == nil || machine.Expiry.IsZero() {
   104| 		return false
   105| 	}
   106| 	return time.Now().UTC().After(*machine.Expiry)
   107| }
   108| func (machine *Machine) isOnline() bool {
   109| 	if machine.LastSeen == nil {
   110| 		return false
   111| 	}
   112| 	if machine.isExpired() {
   113| 		return false
   114| 	}
   115| 	return machine.LastSeen.After(time.Now().Add(-keepAliveInterval))
   116| }
   117| func (machine *Machine) isEphemeral() bool {
   118| 	return machine.AuthKey != nil && machine.AuthKey.Ephemeral
   119| }
   120| func (machine *Machine) canAccess(filter []tailcfg.FilterRule, machine2 *Machine) bool {
   121| 	for _, rule := range filter {
   122| 		matcher := MatchFromFilterRule(rule)
   123| 		if !matcher.SrcsContainsIPs([]netip.Addr(machine.IPAddresses)) {
   124| 			continue
   125| 		}
   126| 		if matcher.DestsContainsIP([]netip.Addr(machine2.IPAddresses)) {
   127| 			return true
   128| 		}
   129| 	}
   130| 	return false
   131| }
   132| func (h *Headscale) filterMachinesByACL(currentMachine *Machine, peers Machines) Machines {
   133| 	return filterMachinesByACL(currentMachine, peers, h.aclRules)
   134| }
   135| func filterMachinesByACL(
   136| 	machine *Machine,
   137| 	machines Machines,
   138| 	filter []tailcfg.FilterRule,
   139| ) Machines {
   140| 	result := Machines{}
   141| 	for index, peer := range machines {
   142| 		if peer.ID == machine.ID {
   143| 			continue
   144| 		}
   145| 		if machine.canAccess(filter, &machines[index]) || peer.canAccess(filter, machine) {
   146| 			result = append(result, peer)
   147| 		}
   148| 	}
   149| 	return result
   150| }
   151| func (h *Headscale) ListPeers(machine *Machine) (Machines, error) {
   152| 	log.Trace().
   153| 		Caller().
   154| 		Str("machine", machine.Hostname).
   155| 		Msg("Finding direct peers")
   156| 	machines := Machines{}
   157| 	if err := h.db.Preload("AuthKey").Preload("AuthKey.User").Preload("User").Where("node_key <> ?",
   158| 		machine.NodeKey).Find(&machines).Error; err != nil {
   159| 		log.Error().Err(err).Msg("Error accessing db")
   160| 		return Machines{}, err
   161| 	}
   162| 	sort.Slice(machines, func(i, j int) bool { return machines[i].ID < machines[j].ID })
   163| 	log.Trace().
   164| 		Caller().
   165| 		Str("machine", machine.Hostname).
   166| 		Msgf("Found peers: %s", machines.String())
   167| 	return machines, nil
   168| }
   169| func (h *Headscale) getPeers(machine *Machine) (Machines, error) {
   170| 	var peers Machines
   171| 	var err error
   172| 	if h.aclPolicy != nil {
   173| 		var machines []Machine
   174| 		machines, err = h.ListMachines()
   175| 		if err != nil {
   176| 			log.Error().Err(err).Msg("Error retrieving list of machines")
   177| 			return Machines{}, err
   178| 		}
   179| 		peers = h.filterMachinesByACL(machine, machines)
   180| 	} else {
   181| 		peers, err = h.ListPeers(machine)
   182| 		if err != nil {
   183| 			log.Error().
   184| 				Caller().
   185| 				Err(err).
   186| 				Msg("Cannot fetch peers")
   187| 			return Machines{}, err
   188| 		}
   189| 	}
   190| 	sort.Slice(peers, func(i, j int) bool { return peers[i].ID < peers[j].ID })
   191| 	log.Trace().
   192| 		Caller().
   193| 		Str("self", machine.Hostname).
   194| 		Str("peers", peers.String()).
   195| 		Msg("Peers returned to caller")
   196| 	return peers, nil
   197| }
   198| func (h *Headscale) getValidPeers(machine *Machine) (Machines, error) {
   199| 	validPeers := make(Machines, 0)
   200| 	peers, err := h.getPeers(machine)
   201| 	if err != nil {
   202| 		return Machines{}, err
   203| 	}
   204| 	for _, peer := range peers {
   205| 		if !peer.isExpired() {
   206| 			validPeers = append(validPeers, peer)
   207| 		}
   208| 	}
   209| 	return validPeers, nil
   210| }
   211| func (h *Headscale) ListMachines() ([]Machine, error) {
   212| 	machines := []Machine{}
   213| 	if err := h.db.Preload("AuthKey").Preload("AuthKey.User").Preload("User").Find(&machines).Error; err != nil {
   214| 		return nil, err
   215| 	}
   216| 	return machines, nil
   217| }
   218| func (h *Headscale) ListMachinesByGivenName(givenName string) ([]Machine, error) {
   219| 	machines := []Machine{}
   220| 	if err := h.db.Preload("AuthKey").Preload("AuthKey.User").Preload("User").Where("given_name = ?", givenName).Find(&machines).Error; err != nil {
   221| 		return nil, err
   222| 	}
   223| 	return machines, nil
   224| }
   225| func (h *Headscale) GetMachine(user string, name string) (*Machine, error) {
   226| 	machines, err := h.ListMachinesByUser(user)
   227| 	if err != nil {
   228| 		return nil, err
   229| 	}
   230| 	for _, m := range machines {
   231| 		if m.Hostname == name {
   232| 			return &m, nil
   233| 		}
   234| 	}
   235| 	return nil, ErrMachineNotFound
   236| }
   237| func (h *Headscale) GetMachineByGivenName(user string, givenName string) (*Machine, error) {
   238| 	machines, err := h.ListMachinesByUser(user)
   239| 	if err != nil {
   240| 		return nil, err
   241| 	}
   242| 	for _, m := range machines {
   243| 		if m.GivenName == givenName {
   244| 			return &m, nil
   245| 		}
   246| 	}
   247| 	return nil, ErrMachineNotFound
   248| }
   249| func (h *Headscale) GetMachineByID(id uint64) (*Machine, error) {
   250| 	m := Machine{}
   251| 	if result := h.db.Preload("AuthKey").Preload("User").Find(&Machine{ID: id}).First(&m); result.Error != nil {
   252| 		return nil, result.Error
   253| 	}
   254| 	return &m, nil
   255| }
   256| func (h *Headscale) GetMachineByMachineKey(
   257| 	machineKey key.MachinePublic,
   258| ) (*Machine, error) {
   259| 	m := Machine{}
   260| 	if result := h.db.Preload("AuthKey").Preload("User").First(&m, "machine_key = ?", MachinePublicKeyStripPrefix(machineKey)); result.Error != nil {
   261| 		return nil, result.Error
   262| 	}
   263| 	return &m, nil
   264| }
   265| func (h *Headscale) GetMachineByNodeKey(
   266| 	nodeKey key.NodePublic,
   267| ) (*Machine, error) {
   268| 	machine := Machine{}
   269| 	if result := h.db.Preload("AuthKey").Preload("User").First(&machine, "node_key = ?",
   270| 		NodePublicKeyStripPrefix(nodeKey)); result.Error != nil {
   271| 		return nil, result.Error
   272| 	}
   273| 	return &machine, nil
   274| }
   275| func (h *Headscale) GetMachineByAnyKey(
   276| 	machineKey key.MachinePublic, nodeKey key.NodePublic, oldNodeKey key.NodePublic,
   277| ) (*Machine, error) {
   278| 	machine := Machine{}
   279| 	if result := h.db.Preload("AuthKey").Preload("User").First(&machine, "machine_key = ? OR node_key = ? OR node_key = ?",
   280| 		MachinePublicKeyStripPrefix(machineKey),
   281| 		NodePublicKeyStripPrefix(nodeKey),
   282| 		NodePublicKeyStripPrefix(oldNodeKey)); result.Error != nil {
   283| 		return nil, result.Error
   284| 	}
   285| 	return &machine, nil
   286| }
   287| func (h *Headscale) UpdateMachineFromDatabase(machine *Machine) error {
   288| 	if result := h.db.Find(machine).First(&machine); result.Error != nil {
   289| 		return result.Error
   290| 	}
   291| 	return nil
   292| }
   293| func (h *Headscale) SetTags(machine *Machine, tags []string) error {
   294| 	newTags := []string{}
   295| 	for _, tag := range tags {
   296| 		if !contains(newTags, tag) {
   297| 			newTags = append(newTags, tag)
   298| 		}
   299| 	}
   300| 	machine.ForcedTags = newTags
   301| 	if err := h.UpdateACLRules(); err != nil && !errors.Is(err, errEmptyPolicy) {
   302| 		return err
   303| 	}
   304| 	h.setLastStateChangeToNow()
   305| 	if err := h.db.Save(machine).Error; err != nil {
   306| 		return fmt.Errorf("failed to update tags for machine in the database: %w", err)
   307| 	}
   308| 	return nil
   309| }
   310| func (h *Headscale) ExpireMachine(machine *Machine) error {
   311| 	now := time.Now()
   312| 	machine.Expiry = &now
   313| 	h.setLastStateChangeToNow()
   314| 	if err := h.db.Save(machine).Error; err != nil {
   315| 		return fmt.Errorf("failed to expire machine in the database: %w", err)
   316| 	}
   317| 	return nil
   318| }
   319| func (h *Headscale) RenameMachine(machine *Machine, newName string) error {
   320| 	err := CheckForFQDNRules(
   321| 		newName,
   322| 	)
   323| 	if err != nil {
   324| 		log.Error().
   325| 			Caller().
   326| 			Str("func", "RenameMachine").
   327| 			Str("machine", machine.Hostname).
   328| 			Str("newName", newName).
   329| 			Err(err)
   330| 		return err
   331| 	}
   332| 	machine.GivenName = newName
   333| 	h.setLastStateChangeToNow()
   334| 	if err := h.db.Save(machine).Error; err != nil {
   335| 		return fmt.Errorf("failed to rename machine in the database: %w", err)
   336| 	}
   337| 	return nil
   338| }
   339| func (h *Headscale) RefreshMachine(machine *Machine, expiry time.Time) error {
   340| 	now := time.Now()
   341| 	machine.LastSuccessfulUpdate = &now
   342| 	machine.Expiry = &expiry
   343| 	h.setLastStateChangeToNow()
   344| 	if err := h.db.Save(machine).Error; err != nil {
   345| 		return fmt.Errorf(
   346| 			"failed to refresh machine (update expiration) in the database: %w",
   347| 			err,
   348| 		)
   349| 	}
   350| 	return nil
   351| }
   352| func (h *Headscale) DeleteMachine(machine *Machine) error {
   353| 	err := h.DeleteMachineRoutes(machine)
   354| 	if err != nil {
   355| 		return err
   356| 	}
   357| 	if err := h.db.Delete(&machine).Error; err != nil {
   358| 		return err
   359| 	}
   360| 	return nil
   361| }
   362| func (h *Headscale) TouchMachine(machine *Machine) error {
   363| 	return h.db.Updates(Machine{
   364| 		ID:                   machine.ID,
   365| 		LastSeen:             machine.LastSeen,
   366| 		LastSuccessfulUpdate: machine.LastSuccessfulUpdate,
   367| 	}).Error
   368| }
   369| func (h *Headscale) HardDeleteMachine(machine *Machine) error {
   370| 	err := h.DeleteMachineRoutes(machine)
   371| 	if err != nil {
   372| 		return err
   373| 	}
   374| 	if err := h.db.Unscoped().Delete(&machine).Error; err != nil {
   375| 		return err
   376| 	}
   377| 	return nil
   378| }
   379| func (machine *Machine) GetHostInfo() tailcfg.Hostinfo {
   380| 	return tailcfg.Hostinfo(machine.HostInfo)
   381| }
   382| func (h *Headscale) isOutdated(machine *Machine) bool {
   383| 	if err := h.UpdateMachineFromDatabase(machine); err != nil {
   384| 		return true
   385| 	}
   386| 	lastChange := h.getLastStateChange()
   387| 	lastUpdate := machine.CreatedAt
   388| 	if machine.LastSuccessfulUpdate != nil {
   389| 		lastUpdate = *machine.LastSuccessfulUpdate
   390| 	}
   391| 	log.Trace().
   392| 		Caller().
   393| 		Str("machine", machine.Hostname).
   394| 		Time("last_successful_update", lastChange).
   395| 		Time("last_state_change", lastUpdate).
   396| 		Msgf("Checking if %s is missing updates", machine.Hostname)
   397| 	return lastUpdate.Before(lastChange)
   398| }
   399| func (machine Machine) String() string {
   400| 	return machine.Hostname
   401| }
   402| func (machines Machines) String() string {
   403| 	temp := make([]string, len(machines))
   404| 	for index, machine := range machines {
   405| 		temp[index] = machine.Hostname
   406| 	}
   407| 	return fmt.Sprintf("[ %s ](%d)", strings.Join(temp, ", "), len(temp))
   408| }
   409| func (machines MachinesP) String() string {
   410| 	temp := make([]string, len(machines))
   411| 	for index, machine := range machines {
   412| 		temp[index] = machine.Hostname
   413| 	}
   414| 	return fmt.Sprintf("[ %s ](%d)", strings.Join(temp, ", "), len(temp))
   415| }
   416| func (h *Headscale) toNodes(
   417| 	machines Machines,
   418| 	baseDomain string,
   419| 	dnsConfig *tailcfg.DNSConfig,
   420| ) ([]*tailcfg.Node, error) {
   421| 	nodes := make([]*tailcfg.Node, len(machines))
   422| 	for index, machine := range machines {
   423| 		node, err := h.toNode(machine, baseDomain, dnsConfig)
   424| 		if err != nil {
   425| 			return nil, err
   426| 		}
   427| 		nodes[index] = node
   428| 	}
   429| 	return nodes, nil
   430| }
   431| func (h *Headscale) toNode(
   432| 	machine Machine,
   433| 	baseDomain string,
   434| 	dnsConfig *tailcfg.DNSConfig,
   435| ) (*tailcfg.Node, error) {
   436| 	var nodeKey key.NodePublic
   437| 	err := nodeKey.UnmarshalText([]byte(NodePublicKeyEnsurePrefix(machine.NodeKey)))
   438| 	if err != nil {
   439| 		log.Trace().
   440| 			Caller().
   441| 			Str("node_key", machine.NodeKey).
   442| 			Msgf("Failed to parse node public key from hex")
   443| 		return nil, fmt.Errorf("failed to parse node public key: %w", err)
   444| 	}
   445| 	var machineKey key.MachinePublic
   446| 	if machine.MachineKey != "" {
   447| 		err = machineKey.UnmarshalText(
   448| 			[]byte(MachinePublicKeyEnsurePrefix(machine.MachineKey)),
   449| 		)
   450| 		if err != nil {
   451| 			return nil, fmt.Errorf("failed to parse machine public key: %w", err)
   452| 		}
   453| 	}
   454| 	var discoKey key.DiscoPublic
   455| 	if machine.DiscoKey != "" {
   456| 		err := discoKey.UnmarshalText(
   457| 			[]byte(DiscoPublicKeyEnsurePrefix(machine.DiscoKey)),
   458| 		)
   459| 		if err != nil {
   460| 			return nil, fmt.Errorf("failed to parse disco public key: %w", err)
   461| 		}
   462| 	} else {
   463| 		discoKey = key.DiscoPublic{}
   464| 	}
   465| 	addrs := []netip.Prefix{}
   466| 	for _, machineAddress := range machine.IPAddresses {
   467| 		ip := netip.PrefixFrom(machineAddress, machineAddress.BitLen())
   468| 		addrs = append(addrs, ip)
   469| 	}
   470| 	allowedIPs := append(
   471| 		[]netip.Prefix{},
   472| 		addrs...) // we append the node own IP, as it is required by the clients
   473| 	primaryRoutes, err := h.getMachinePrimaryRoutes(&machine)
   474| 	if err != nil {
   475| 		return nil, err
   476| 	}
   477| 	primaryPrefixes := Routes(primaryRoutes).toPrefixes()
   478| 	machineRoutes, err := h.GetMachineRoutes(&machine)
   479| 	if err != nil {
   480| 		return nil, err
   481| 	}
   482| 	for _, route := range machineRoutes {
   483| 		if route.Enabled && (route.IsPrimary || route.isExitRoute()) {
   484| 			allowedIPs = append(allowedIPs, netip.Prefix(route.Prefix))
   485| 		}
   486| 	}
   487| 	var derp string
   488| 	if machine.HostInfo.NetInfo != nil {
   489| 		derp = fmt.Sprintf("127.3.3.40:%d", machine.HostInfo.NetInfo.PreferredDERP)
   490| 	} else {
   491| 		derp = "127.3.3.40:0" // Zero means disconnected or unknown.
   492| 	}
   493| 	var keyExpiry time.Time
   494| 	if machine.Expiry != nil {
   495| 		keyExpiry = *machine.Expiry
   496| 	} else {
   497| 		keyExpiry = time.Time{}
   498| 	}
   499| 	var hostname string
   500| 	if dnsConfig != nil && dnsConfig.Proxied { // MagicDNS
   501| 		hostname = fmt.Sprintf(
   502| 			"%s.%s.%s",
   503| 			machine.GivenName,
   504| 			machine.User.Name,
   505| 			baseDomain,
   506| 		)
   507| 		if len(hostname) > maxHostnameLength {
   508| 			return nil, fmt.Errorf(
   509| 				"hostname %q is too long it cannot except 255 ASCII chars: %w",
   510| 				hostname,
   511| 				ErrHostnameTooLong,
   512| 			)
   513| 		}
   514| 	} else {
   515| 		hostname = machine.GivenName
   516| 	}
   517| 	hostInfo := machine.GetHostInfo()
   518| 	online := machine.isOnline()
   519| 	tags, _ := getTags(h.aclPolicy, machine, h.cfg.OIDC.StripEmaildomain)
   520| 	tags = lo.Uniq(append(tags, machine.ForcedTags...))
   521| 	node := tailcfg.Node{
   522| 		ID: tailcfg.NodeID(machine.ID), // this is the actual ID
   523| 		StableID: tailcfg.StableNodeID(
   524| 			strconv.FormatUint(machine.ID, Base10),
   525| 		), // in headscale, unlike tailcontrol server, IDs are permanent
   526| 		Name: hostname,
   527| 		User: tailcfg.UserID(machine.UserID),
   528| 		Key:       nodeKey,
   529| 		KeyExpiry: keyExpiry,
   530| 		Machine:    machineKey,
   531| 		DiscoKey:   discoKey,
   532| 		Addresses:  addrs,
   533| 		AllowedIPs: allowedIPs,
   534| 		Endpoints:  machine.Endpoints,
   535| 		DERP:       derp,
   536| 		Hostinfo:   hostInfo.View(),
   537| 		Created:    machine.CreatedAt,
   538| 		Tags: tags,
   539| 		PrimaryRoutes: primaryPrefixes,
   540| 		LastSeen:          machine.LastSeen,
   541| 		Online:            &online,
   542| 		KeepAlive:         true,
   543| 		MachineAuthorized: !machine.isExpired(),
   544| 		Capabilities: []string{
   545| 			tailcfg.CapabilityFileSharing,
   546| 			tailcfg.CapabilityAdmin,
   547| 			tailcfg.CapabilitySSH,
   548| 		},
   549| 	}
   550| 	return &node, nil
   551| }
   552| func (machine *Machine) toProto() *v1.Machine {
   553| 	machineProto := &v1.Machine{
   554| 		Id:         machine.ID,
   555| 		MachineKey: machine.MachineKey,
   556| 		NodeKey:     machine.NodeKey,
   557| 		DiscoKey:    machine.DiscoKey,
   558| 		IpAddresses: machine.IPAddresses.ToStringSlice(),
   559| 		Name:        machine.Hostname,
   560| 		GivenName:   machine.GivenName,
   561| 		User:        machine.User.toProto(),
   562| 		ForcedTags:  machine.ForcedTags,
   563| 		Online:      machine.isOnline(),
   564| 		CreatedAt: timestamppb.New(machine.CreatedAt),
   565| 	}
   566| 	if machine.AuthKey != nil {
   567| 		machineProto.PreAuthKey = machine.AuthKey.toProto()
   568| 	}
   569| 	if machine.LastSeen != nil {
   570| 		machineProto.LastSeen = timestamppb.New(*machine.LastSeen)
   571| 	}
   572| 	if machine.LastSuccessfulUpdate != nil {
   573| 		machineProto.LastSuccessfulUpdate = timestamppb.New(
   574| 			*machine.LastSuccessfulUpdate,
   575| 		)
   576| 	}
   577| 	if machine.Expiry != nil {
   578| 		machineProto.Expiry = timestamppb.New(*machine.Expiry)
   579| 	}
   580| 	return machineProto
   581| }
   582| func getTags(
   583| 	aclPolicy *ACLPolicy,
   584| 	machine Machine,
   585| 	stripEmailDomain bool,
   586| ) ([]string, []string) {
   587| 	validTags := make([]string, 0)
   588| 	invalidTags := make([]string, 0)
   589| 	if aclPolicy == nil {
   590| 		return validTags, invalidTags
   591| 	}
   592| 	validTagMap := make(map[string]bool)
   593| 	invalidTagMap := make(map[string]bool)
   594| 	for _, tag := range machine.HostInfo.RequestTags {
   595| 		owners, err := getTagOwners(aclPolicy, tag, stripEmailDomain)
   596| 		if errors.Is(err, errInvalidTag) {
   597| 			invalidTagMap[tag] = true
   598| 			continue
   599| 		}
   600| 		var found bool
   601| 		for _, owner := range owners {
   602| 			if machine.User.Name == owner {
   603| 				found = true
   604| 			}
   605| 		}
   606| 		if found {
   607| 			validTagMap[tag] = true
   608| 		} else {
   609| 			invalidTagMap[tag] = true
   610| 		}
   611| 	}
   612| 	for tag := range invalidTagMap {
   613| 		invalidTags = append(invalidTags, tag)
   614| 	}
   615| 	for tag := range validTagMap {
   616| 		validTags = append(validTags, tag)
   617| 	}
   618| 	return validTags, invalidTags
   619| }
   620| func (h *Headscale) RegisterMachineFromAuthCallback(
   621| 	nodeKeyStr string,
   622| 	userName string,
   623| 	machineExpiry *time.Time,
   624| 	registrationMethod string,
   625| ) (*Machine, error) {
   626| 	nodeKey := key.NodePublic{}
   627| 	err := nodeKey.UnmarshalText([]byte(nodeKeyStr))
   628| 	if err != nil {
   629| 		return nil, err
   630| 	}
   631| 	log.Debug().
   632| 		Str("nodeKey", nodeKey.ShortString()).
   633| 		Str("userName", userName).
   634| 		Str("registrationMethod", registrationMethod).
   635| 		Str("expiresAt", fmt.Sprintf("%v", machineExpiry)).
   636| 		Msg("Registering machine from API/CLI or auth callback")
   637| 	if machineInterface, ok := h.registrationCache.Get(NodePublicKeyStripPrefix(nodeKey)); ok {
   638| 		if registrationMachine, ok := machineInterface.(Machine); ok {
   639| 			user, err := h.GetUser(userName)
   640| 			if err != nil {
   641| 				return nil, fmt.Errorf(
   642| 					"failed to find user in register machine from auth callback, %w",
   643| 					err,
   644| 				)
   645| 			}
   646| 			if registrationMachine.ID != 0 &&
   647| 				registrationMachine.UserID != user.ID {
   648| 				return nil, ErrDifferentRegisteredUser
   649| 			}
   650| 			registrationMachine.UserID = user.ID
   651| 			registrationMachine.RegisterMethod = registrationMethod
   652| 			if machineExpiry != nil {
   653| 				registrationMachine.Expiry = machineExpiry
   654| 			}
   655| 			machine, err := h.RegisterMachine(
   656| 				registrationMachine,
   657| 			)
   658| 			if err == nil {
   659| 				h.registrationCache.Delete(nodeKeyStr)
   660| 			}
   661| 			return machine, err
   662| 		} else {
   663| 			return nil, ErrCouldNotConvertMachineInterface
   664| 		}
   665| 	}
   666| 	return nil, ErrMachineNotFoundRegistrationCache
   667| }
   668| func (h *Headscale) RegisterMachine(machine Machine,
   669| ) (*Machine, error) {
   670| 	log.Debug().
   671| 		Str("machine", machine.Hostname).
   672| 		Str("machine_key", machine.MachineKey).
   673| 		Str("node_key", machine.NodeKey).
   674| 		Str("user", machine.User.Name).
   675| 		Msg("Registering machine")
   676| 	if len(machine.IPAddresses) > 0 {
   677| 		if err := h.db.Save(&machine).Error; err != nil {
   678| 			return nil, fmt.Errorf("failed register existing machine in the database: %w", err)
   679| 		}
   680| 		log.Trace().
   681| 			Caller().
   682| 			Str("machine", machine.Hostname).
   683| 			Str("machine_key", machine.MachineKey).
   684| 			Str("node_key", machine.NodeKey).
   685| 			Str("user", machine.User.Name).
   686| 			Msg("Machine authorized again")
   687| 		return &machine, nil
   688| 	}
   689| 	h.ipAllocationMutex.Lock()
   690| 	defer h.ipAllocationMutex.Unlock()
   691| 	ips, err := h.getAvailableIPs()
   692| 	if err != nil {
   693| 		log.Error().
   694| 			Caller().
   695| 			Err(err).
   696| 			Str("machine", machine.Hostname).
   697| 			Msg("Could not find IP for the new machine")
   698| 		return nil, err
   699| 	}
   700| 	machine.IPAddresses = ips
   701| 	if err := h.db.Save(&machine).Error; err != nil {
   702| 		return nil, fmt.Errorf("failed register(save) machine in the database: %w", err)
   703| 	}
   704| 	log.Trace().
   705| 		Caller().
   706| 		Str("machine", machine.Hostname).
   707| 		Str("ip", strings.Join(ips.ToStringSlice(), ",")).
   708| 		Msg("Machine registered with the database")
   709| 	return &machine, nil
   710| }
   711| func (h *Headscale) GetAdvertisedRoutes(machine *Machine) ([]netip.Prefix, error) {
   712| 	routes := []Route{}
   713| 	err := h.db.
   714| 		Preload("Machine").
   715| 		Where("machine_id = ? AND advertised = ?", machine.ID, true).Find(&routes).Error
   716| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   717| 		log.Error().
   718| 			Caller().
   719| 			Err(err).
   720| 			Str("machine", machine.Hostname).
   721| 			Msg("Could not get advertised routes for machine")
   722| 		return nil, err
   723| 	}
   724| 	prefixes := []netip.Prefix{}
   725| 	for _, route := range routes {
   726| 		prefixes = append(prefixes, netip.Prefix(route.Prefix))
   727| 	}
   728| 	return prefixes, nil
   729| }
   730| func (h *Headscale) GetEnabledRoutes(machine *Machine) ([]netip.Prefix, error) {
   731| 	routes := []Route{}
   732| 	err := h.db.
   733| 		Preload("Machine").
   734| 		Where("machine_id = ? AND advertised = ? AND enabled = ?", machine.ID, true, true).
   735| 		Find(&routes).Error
   736| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   737| 		log.Error().
   738| 			Caller().
   739| 			Err(err).
   740| 			Str("machine", machine.Hostname).
   741| 			Msg("Could not get enabled routes for machine")
   742| 		return nil, err
   743| 	}
   744| 	prefixes := []netip.Prefix{}
   745| 	for _, route := range routes {
   746| 		prefixes = append(prefixes, netip.Prefix(route.Prefix))
   747| 	}
   748| 	return prefixes, nil
   749| }
   750| func (h *Headscale) IsRoutesEnabled(machine *Machine, routeStr string) bool {
   751| 	route, err := netip.ParsePrefix(routeStr)
   752| 	if err != nil {
   753| 		return false
   754| 	}
   755| 	enabledRoutes, err := h.GetEnabledRoutes(machine)
   756| 	if err != nil {
   757| 		log.Error().Err(err).Msg("Could not get enabled routes")
   758| 		return false
   759| 	}
   760| 	for _, enabledRoute := range enabledRoutes {
   761| 		if route == enabledRoute {
   762| 			return true
   763| 		}
   764| 	}
   765| 	return false
   766| }
   767| func (h *Headscale) enableRoutes(machine *Machine, routeStrs ...string) error {
   768| 	newRoutes := make([]netip.Prefix, len(routeStrs))
   769| 	for index, routeStr := range routeStrs {
   770| 		route, err := netip.ParsePrefix(routeStr)
   771| 		if err != nil {
   772| 			return err
   773| 		}
   774| 		newRoutes[index] = route
   775| 	}
   776| 	advertisedRoutes, err := h.GetAdvertisedRoutes(machine)
   777| 	if err != nil {
   778| 		return err
   779| 	}
   780| 	for _, newRoute := range newRoutes {
   781| 		if !contains(advertisedRoutes, newRoute) {
   782| 			return fmt.Errorf(
   783| 				"route (%s) is not available on node %s: %w",
   784| 				machine.Hostname,
   785| 				newRoute, ErrMachineRouteIsNotAvailable,
   786| 			)
   787| 		}
   788| 	}
   789| 	for _, prefix := range newRoutes {
   790| 		route := Route{}
   791| 		err := h.db.Preload("Machine").
   792| 			Where("machine_id = ? AND prefix = ?", machine.ID, IPPrefix(prefix)).
   793| 			First(&route).Error
   794| 		if err == nil {
   795| 			route.Enabled = true
   796| 			if !route.isExitRoute() {
   797| 				route.IsPrimary = h.isUniquePrefix(route)
   798| 			}
   799| 			err = h.db.Save(&route).Error
   800| 			if err != nil {
   801| 				return fmt.Errorf("failed to enable route: %w", err)
   802| 			}
   803| 		} else {
   804| 			return fmt.Errorf("failed to find route: %w", err)
   805| 		}
   806| 	}
   807| 	h.setLastStateChangeToNow()
   808| 	return nil
   809| }
   810| func (h *Headscale) EnableAutoApprovedRoutes(machine *Machine) error {
   811| 	if len(machine.IPAddresses) == 0 {
   812| 		return nil // This machine has no IPAddresses, so can't possibly match any autoApprovers ACLs
   813| 	}
   814| 	routes := []Route{}
   815| 	err := h.db.
   816| 		Preload("Machine").
   817| 		Where("machine_id = ? AND advertised = true AND enabled = false", machine.ID).
   818| 		Find(&routes).Error
   819| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   820| 		log.Error().
   821| 			Caller().
   822| 			Err(err).
   823| 			Str("machine", machine.Hostname).
   824| 			Msg("Could not get advertised routes for machine")
   825| 		return err
   826| 	}
   827| 	approvedRoutes := []Route{}
   828| 	for _, advertisedRoute := range routes {
   829| 		routeApprovers, err := h.aclPolicy.AutoApprovers.GetRouteApprovers(
   830| 			netip.Prefix(advertisedRoute.Prefix),
   831| 		)
   832| 		if err != nil {
   833| 			log.Err(err).
   834| 				Str("advertisedRoute", advertisedRoute.String()).
   835| 				Uint64("machineId", machine.ID).
   836| 				Msg("Failed to resolve autoApprovers for advertised route")
   837| 			return err
   838| 		}
   839| 		for _, approvedAlias := range routeApprovers {
   840| 			if approvedAlias == machine.User.Name {
   841| 				approvedRoutes = append(approvedRoutes, advertisedRoute)
   842| 			} else {
   843| 				approvedIps, err := h.aclPolicy.expandAlias([]Machine{*machine}, approvedAlias, h.cfg.OIDC.StripEmaildomain)
   844| 				if err != nil {
   845| 					log.Err(err).
   846| 						Str("alias", approvedAlias).
   847| 						Msg("Failed to expand alias when processing autoApprovers policy")
   848| 					return err
   849| 				}
   850| 				if approvedIps.Contains(machine.IPAddresses[0]) {
   851| 					approvedRoutes = append(approvedRoutes, advertisedRoute)
   852| 				}
   853| 			}
   854| 		}
   855| 	}
   856| 	for i, approvedRoute := range approvedRoutes {
   857| 		approvedRoutes[i].Enabled = true
   858| 		err = h.db.Save(&approvedRoutes[i]).Error
   859| 		if err != nil {
   860| 			log.Err(err).
   861| 				Str("approvedRoute", approvedRoute.String()).
   862| 				Uint64("machineId", machine.ID).
   863| 				Msg("Failed to enable approved route")
   864| 			return err
   865| 		}
   866| 	}
   867| 	return nil
   868| }
   869| func (h *Headscale) generateGivenName(suppliedName string, randomSuffix bool) (string, error) {
   870| 	normalizedHostname, err := NormalizeToFQDNRules(
   871| 		suppliedName,
   872| 		h.cfg.OIDC.StripEmaildomain,
   873| 	)
   874| 	if err != nil {
   875| 		return "", err
   876| 	}
   877| 	if randomSuffix {
   878| 		trimmedHostnameLength := labelHostnameLength - MachineGivenNameHashLength - MachineGivenNameTrimSize
   879| 		if len(normalizedHostname) > trimmedHostnameLength {
   880| 			normalizedHostname = normalizedHostname[:trimmedHostnameLength]
   881| 		}
   882| 		suffix, err := GenerateRandomStringDNSSafe(MachineGivenNameHashLength)
   883| 		if err != nil {
   884| 			return "", err
   885| 		}
   886| 		normalizedHostname += "-" + suffix
   887| 	}
   888| 	return normalizedHostname, nil
   889| }
   890| func (h *Headscale) GenerateGivenName(machineKey string, suppliedName string) (string, error) {
   891| 	givenName, err := h.generateGivenName(suppliedName, false)
   892| 	if err != nil {
   893| 		return "", err
   894| 	}
   895| 	machines, err := h.ListMachinesByGivenName(givenName)
   896| 	if err != nil {
   897| 		return "", err
   898| 	}
   899| 	for _, machine := range machines {
   900| 		if machine.MachineKey != machineKey && machine.GivenName == givenName {
   901| 			postfixedName, err := h.generateGivenName(suppliedName, true)
   902| 			if err != nil {
   903| 				return "", err
   904| 			}
   905| 			givenName = postfixedName
   906| 		}
   907| 	}
   908| 	return givenName, nil
   909| }
   910| func (machines Machines) FilterByIP(ip netip.Addr) Machines {
   911| 	found := make(Machines, 0)
   912| 	for _, machine := range machines {
   913| 		for _, mIP := range machine.IPAddresses {
   914| 			if ip == mIP {
   915| 				found = append(found, machine)
   916| 			}
   917| 		}
   918| 	}
   919| 	return found
   920| }


# ====================================================================
# FILE: hscontrol/metrics.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| package hscontrol
     2| import (
     3| 	"github.com/prometheus/client_golang/prometheus"
     4| 	"github.com/prometheus/client_golang/prometheus/promauto"
     5| )
     6| const prometheusNamespace = "headscale"
     7| var (
     8| 	lastStateUpdate = promauto.NewGaugeVec(prometheus.GaugeOpts{
     9| 		Namespace: prometheusNamespace,
    10| 		Name:      "last_update_seconds",
    11| 		Help:      "Time stamp in unix time when a machine or headscale was updated",
    12| 	}, []string{"user", "machine"})
    13| 	machineRegistrations = promauto.NewCounterVec(prometheus.CounterOpts{
    14| 		Namespace: prometheusNamespace,
    15| 		Name:      "machine_registrations_total",
    16| 		Help:      "The total amount of registered machine attempts",
    17| 	}, []string{"action", "auth", "status", "user"})
    18| 	updateRequestsFromNode = promauto.NewCounterVec(prometheus.CounterOpts{
    19| 		Namespace: prometheusNamespace,
    20| 		Name:      "update_request_from_node_total",
    21| 		Help:      "The number of updates requested by a node/update function",
    22| 	}, []string{"user", "machine", "state"})
    23| 	updateRequestsSentToNode = promauto.NewCounterVec(prometheus.CounterOpts{
    24| 		Namespace: prometheusNamespace,
    25| 		Name:      "update_request_sent_to_node_total",
    26| 		Help:      "The number of calls/messages issued on a specific nodes update channel",
    27| 	}, []string{"user", "machine", "status"})
    28| 	updateRequestsReceivedOnChannel = promauto.NewCounterVec(prometheus.CounterOpts{
    29| 		Namespace: prometheusNamespace,
    30| 		Name:      "update_request_received_on_channel_total",
    31| 		Help:      "The number of update requests received on an update channel",
    32| 	}, []string{"user", "machine"})
    33| )


# ====================================================================
# FILE: hscontrol/noise.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/binary"
     4| 	"encoding/json"
     5| 	"io"
     6| 	"net/http"
     7| 	"github.com/gorilla/mux"
     8| 	"github.com/rs/zerolog/log"
     9| 	"golang.org/x/net/http2"
    10| 	"golang.org/x/net/http2/h2c"
    11| 	"tailscale.com/control/controlbase"
    12| 	"tailscale.com/control/controlhttp"
    13| 	"tailscale.com/tailcfg"
    14| 	"tailscale.com/types/key"
    15| )
    16| const (
    17| 	ts2021UpgradePath = "/ts2021"
    18| 	earlyPayloadMagic = "\xff\xff\xffTS"
    19| 	earlyNoiseCapabilityVersion = 49
    20| )
    21| type noiseServer struct {
    22| 	headscale *Headscale
    23| 	httpBaseConfig *http.Server
    24| 	http2Server    *http2.Server
    25| 	conn           *controlbase.Conn
    26| 	machineKey     key.MachinePublic
    27| 	nodeKey        key.NodePublic

# --- HUNK 2: Lines 44-92 ---
    44| 	noiseServer := noiseServer{
    45| 		headscale: h,
    46| 		challenge: key.NewChallenge(),
    47| 	}
    48| 	noiseConn, err := controlhttp.AcceptHTTP(
    49| 		req.Context(),
    50| 		writer,
    51| 		req,
    52| 		*h.noisePrivateKey,
    53| 		noiseServer.earlyNoise,
    54| 	)
    55| 	if err != nil {
    56| 		log.Error().Err(err).Msg("noise upgrade failed")
    57| 		http.Error(writer, err.Error(), http.StatusInternalServerError)
    58| 		return
    59| 	}
    60| 	noiseServer.conn = noiseConn
    61| 	noiseServer.machineKey = noiseServer.conn.Peer()
    62| 	noiseServer.protocolVersion = noiseServer.conn.ProtocolVersion()
    63| 	router := mux.NewRouter()
    64| 	router.HandleFunc("/machine/register", noiseServer.NoiseRegistrationHandler).
    65| 		Methods(http.MethodPost)
    66| 	router.HandleFunc("/machine/map", noiseServer.NoisePollNetMapHandler)
    67| 	server := http.Server{
    68| 		ReadTimeout: HTTPReadTimeout,
    69| 	}
    70| 	noiseServer.httpBaseConfig = &http.Server{
    71| 		Handler:           router,
    72| 		ReadHeaderTimeout: HTTPReadTimeout,
    73| 	}
    74| 	noiseServer.http2Server = &http2.Server{}
    75| 	server.Handler = h2c.NewHandler(router, noiseServer.http2Server)
    76| 	noiseServer.http2Server.ServeConn(
    77| 		noiseConn,
    78| 		&http2.ServeConnOpts{
    79| 			BaseConfig: noiseServer.httpBaseConfig,
    80| 		},
    81| 	)
    82| }
    83| func (ns *noiseServer) earlyNoise(protocolVersion int, writer io.Writer) error {
    84| 	log.Trace().
    85| 		Caller().
    86| 		Int("protocol_version", protocolVersion).
    87| 		Str("challenge", ns.challenge.Public().String()).
    88| 		Msg("earlyNoise called")
    89| 	if protocolVersion < earlyNoiseCapabilityVersion {
    90| 		log.Trace().
    91| 			Caller().
    92| 			Msgf("protocol version %d does not support early noise", protocolVersion)

# --- HUNK 3: Lines 96-115 ---
    96| 		NodeKeyChallenge: ns.challenge.Public(),
    97| 	})
    98| 	if err != nil {
    99| 		return err
   100| 	}
   101| 	var notH2Frame [5]byte
   102| 	copy(notH2Frame[:], earlyPayloadMagic)
   103| 	var lenBuf [4]byte
   104| 	binary.BigEndian.PutUint32(lenBuf[:], uint32(len(earlyJSON)))
   105| 	if _, err := writer.Write(notH2Frame[:]); err != nil {
   106| 		return err
   107| 	}
   108| 	if _, err := writer.Write(lenBuf[:]); err != nil {
   109| 		return err
   110| 	}
   111| 	if _, err := writer.Write(earlyJSON); err != nil {
   112| 		return err
   113| 	}
   114| 	return nil
   115| }


# ====================================================================
# FILE: hscontrol/oidc.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-619 ---
     1| package hscontrol
     2| import (
     3| 	"bytes"
     4| 	"context"
     5| 	"crypto/rand"
     6| 	"encoding/hex"
     7| 	"errors"
     8| 	"fmt"
     9| 	"html/template"
    10| 	"net/http"
    11| 	"strings"
    12| 	"time"
    13| 	"github.com/coreos/go-oidc/v3/oidc"
    14| 	"github.com/gorilla/mux"
    15| 	"github.com/rs/zerolog/log"
    16| 	"golang.org/x/oauth2"
    17| 	"tailscale.com/types/key"
    18| )
    19| const (
    20| 	randomByteSize = 16
    21| 	errEmptyOIDCCallbackParams = Error("empty OIDC callback params")
    22| 	errNoOIDCIDToken           = Error("could not extract ID Token for OIDC callback")
    23| 	errOIDCAllowedDomains      = Error("authenticated principal does not match any allowed domain")
    24| 	errOIDCAllowedGroups       = Error("authenticated principal is not in any allowed group")
    25| 	errOIDCAllowedUsers        = Error("authenticated principal does not match any allowed user")
    26| 	errOIDCInvalidMachineState = Error(
    27| 		"requested machine state key expired before authorisation completed",
    28| 	)
    29| 	errOIDCNodeKeyMissing = Error("could not get node key from cache")
    30| )
    31| type IDTokenClaims struct {
    32| 	Name     string   `json:"name,omitempty"`
    33| 	Groups   []string `json:"groups,omitempty"`
    34| 	Email    string   `json:"email"`
    35| 	Username string   `json:"preferred_username,omitempty"`
    36| }
    37| func (h *Headscale) initOIDC() error {
    38| 	var err error
    39| 	if h.oauth2Config == nil {
    40| 		h.oidcProvider, err = oidc.NewProvider(context.Background(), h.cfg.OIDC.Issuer)
    41| 		if err != nil {
    42| 			log.Error().
    43| 				Err(err).
    44| 				Caller().
    45| 				Msgf("Could not retrieve OIDC Config: %s", err.Error())
    46| 			return err
    47| 		}
    48| 		h.oauth2Config = &oauth2.Config{
    49| 			ClientID:     h.cfg.OIDC.ClientID,
    50| 			ClientSecret: h.cfg.OIDC.ClientSecret,
    51| 			Endpoint:     h.oidcProvider.Endpoint(),
    52| 			RedirectURL: fmt.Sprintf(
    53| 				"%s/oidc/callback",
    54| 				strings.TrimSuffix(h.cfg.ServerURL, "/"),
    55| 			),
    56| 			Scopes: h.cfg.OIDC.Scope,
    57| 		}
    58| 	}
    59| 	return nil
    60| }
    61| func (h *Headscale) determineTokenExpiration(idTokenExpiration time.Time) time.Time {
    62| 	if h.cfg.OIDC.UseExpiryFromToken {
    63| 		return idTokenExpiration
    64| 	}
    65| 	return time.Now().Add(h.cfg.OIDC.Expiry)
    66| }
    67| func (h *Headscale) RegisterOIDC(
    68| 	writer http.ResponseWriter,
    69| 	req *http.Request,
    70| ) {
    71| 	vars := mux.Vars(req)
    72| 	nodeKeyStr, ok := vars["nkey"]
    73| 	log.Debug().
    74| 		Caller().
    75| 		Str("node_key", nodeKeyStr).
    76| 		Bool("ok", ok).
    77| 		Msg("Received oidc register call")
    78| 	if !NodePublicKeyRegex.Match([]byte(nodeKeyStr)) {
    79| 		log.Warn().Str("node_key", nodeKeyStr).Msg("Invalid node key passed to registration url")
    80| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    81| 		writer.WriteHeader(http.StatusUnauthorized)
    82| 		_, err := writer.Write([]byte("Unauthorized"))
    83| 		if err != nil {
    84| 			log.Error().
    85| 				Caller().
    86| 				Err(err).
    87| 				Msg("Failed to write response")
    88| 		}
    89| 		return
    90| 	}
    91| 	var nodeKey key.NodePublic
    92| 	err := nodeKey.UnmarshalText(
    93| 		[]byte(NodePublicKeyEnsurePrefix(nodeKeyStr)),
    94| 	)
    95| 	if !ok || nodeKeyStr == "" || err != nil {
    96| 		log.Warn().
    97| 			Err(err).
    98| 			Msg("Failed to parse incoming nodekey in OIDC registration")
    99| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   100| 		writer.WriteHeader(http.StatusBadRequest)
   101| 		_, err := writer.Write([]byte("Wrong params"))
   102| 		if err != nil {
   103| 			log.Error().
   104| 				Caller().
   105| 				Err(err).
   106| 				Msg("Failed to write response")
   107| 		}
   108| 		return
   109| 	}
   110| 	randomBlob := make([]byte, randomByteSize)
   111| 	if _, err := rand.Read(randomBlob); err != nil {
   112| 		log.Error().
   113| 			Caller().
   114| 			Msg("could not read 16 bytes from rand")
   115| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   116| 		return
   117| 	}
   118| 	stateStr := hex.EncodeToString(randomBlob)[:32]
   119| 	h.registrationCache.Set(stateStr, NodePublicKeyStripPrefix(nodeKey), registerCacheExpiration)
   120| 	extras := make([]oauth2.AuthCodeOption, 0, len(h.cfg.OIDC.ExtraParams))
   121| 	for k, v := range h.cfg.OIDC.ExtraParams {
   122| 		extras = append(extras, oauth2.SetAuthURLParam(k, v))
   123| 	}
   124| 	authURL := h.oauth2Config.AuthCodeURL(stateStr, extras...)
   125| 	log.Debug().Msgf("Redirecting to %s for authentication", authURL)
   126| 	http.Redirect(writer, req, authURL, http.StatusFound)
   127| }
   128| type oidcCallbackTemplateConfig struct {
   129| 	User string
   130| 	Verb string
   131| }
   132| var oidcCallbackTemplate = template.Must(
   133| 	template.New("oidccallback").Parse(`<html>
   134| 	<body>
   135| 	<h1>headscale</h1>
   136| 	<p>
   137| 			{{.Verb}} as {{.User}}, you can now close this window.
   138| 	</p>
   139| 	</body>
   140| 	</html>`),
   141| )
   142| func (h *Headscale) OIDCCallback(
   143| 	writer http.ResponseWriter,
   144| 	req *http.Request,
   145| ) {
   146| 	code, state, err := validateOIDCCallbackParams(writer, req)
   147| 	if err != nil {
   148| 		return
   149| 	}
   150| 	rawIDToken, err := h.getIDTokenForOIDCCallback(req.Context(), writer, code, state)
   151| 	if err != nil {
   152| 		return
   153| 	}
   154| 	idToken, err := h.verifyIDTokenForOIDCCallback(req.Context(), writer, rawIDToken)
   155| 	if err != nil {
   156| 		return
   157| 	}
   158| 	idTokenExpiry := h.determineTokenExpiration(idToken.Expiry)
   159| 	claims, err := extractIDTokenClaims(writer, idToken)
   160| 	if err != nil {
   161| 		return
   162| 	}
   163| 	if err := validateOIDCAllowedDomains(writer, h.cfg.OIDC.AllowedDomains, claims); err != nil {
   164| 		return
   165| 	}
   166| 	if err := validateOIDCAllowedGroups(writer, h.cfg.OIDC.AllowedGroups, claims); err != nil {
   167| 		return
   168| 	}
   169| 	if err := validateOIDCAllowedUsers(writer, h.cfg.OIDC.AllowedUsers, claims); err != nil {
   170| 		return
   171| 	}
   172| 	nodeKey, machineExists, err := h.validateMachineForOIDCCallback(
   173| 		writer,
   174| 		state,
   175| 		claims,
   176| 		idTokenExpiry,
   177| 	)
   178| 	if err != nil || machineExists {
   179| 		return
   180| 	}
   181| 	userName, err := getUserName(writer, claims, h.cfg.OIDC.StripEmaildomain)
   182| 	if err != nil {
   183| 		return
   184| 	}
   185| 	log.Debug().Msg("Registering new machine after successful callback")
   186| 	user, err := h.findOrCreateNewUserForOIDCCallback(writer, userName)
   187| 	if err != nil {
   188| 		return
   189| 	}
   190| 	if err := h.registerMachineForOIDCCallback(writer, user, nodeKey, idTokenExpiry); err != nil {
   191| 		return
   192| 	}
   193| 	content, err := renderOIDCCallbackTemplate(writer, claims)
   194| 	if err != nil {
   195| 		return
   196| 	}
   197| 	writer.Header().Set("Content-Type", "text/html; charset=utf-8")
   198| 	writer.WriteHeader(http.StatusOK)
   199| 	if _, err := writer.Write(content.Bytes()); err != nil {
   200| 		log.Error().
   201| 			Caller().
   202| 			Err(err).
   203| 			Msg("Failed to write response")
   204| 	}
   205| }
   206| func validateOIDCCallbackParams(
   207| 	writer http.ResponseWriter,
   208| 	req *http.Request,
   209| ) (string, string, error) {
   210| 	code := req.URL.Query().Get("code")
   211| 	state := req.URL.Query().Get("state")
   212| 	if code == "" || state == "" {
   213| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   214| 		writer.WriteHeader(http.StatusBadRequest)
   215| 		_, err := writer.Write([]byte("Wrong params"))
   216| 		if err != nil {
   217| 			log.Error().
   218| 				Caller().
   219| 				Err(err).
   220| 				Msg("Failed to write response")
   221| 		}
   222| 		return "", "", errEmptyOIDCCallbackParams
   223| 	}
   224| 	return code, state, nil
   225| }
   226| func (h *Headscale) getIDTokenForOIDCCallback(
   227| 	ctx context.Context,
   228| 	writer http.ResponseWriter,
   229| 	code, state string,
   230| ) (string, error) {
   231| 	oauth2Token, err := h.oauth2Config.Exchange(ctx, code)
   232| 	if err != nil {
   233| 		log.Error().
   234| 			Err(err).
   235| 			Caller().
   236| 			Msg("Could not exchange code for token")
   237| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   238| 		writer.WriteHeader(http.StatusBadRequest)
   239| 		_, werr := writer.Write([]byte("Could not exchange code for token"))
   240| 		if werr != nil {
   241| 			log.Error().
   242| 				Caller().
   243| 				Err(werr).
   244| 				Msg("Failed to write response")
   245| 		}
   246| 		return "", err
   247| 	}
   248| 	log.Trace().
   249| 		Caller().
   250| 		Str("code", code).
   251| 		Str("state", state).
   252| 		Msg("Got oidc callback")
   253| 	rawIDToken, rawIDTokenOK := oauth2Token.Extra("id_token").(string)
   254| 	if !rawIDTokenOK {
   255| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   256| 		writer.WriteHeader(http.StatusBadRequest)
   257| 		_, err := writer.Write([]byte("Could not extract ID Token"))
   258| 		if err != nil {
   259| 			log.Error().
   260| 				Caller().
   261| 				Err(err).
   262| 				Msg("Failed to write response")
   263| 		}
   264| 		return "", errNoOIDCIDToken
   265| 	}
   266| 	return rawIDToken, nil
   267| }
   268| func (h *Headscale) verifyIDTokenForOIDCCallback(
   269| 	ctx context.Context,
   270| 	writer http.ResponseWriter,
   271| 	rawIDToken string,
   272| ) (*oidc.IDToken, error) {
   273| 	verifier := h.oidcProvider.Verifier(&oidc.Config{ClientID: h.cfg.OIDC.ClientID})
   274| 	idToken, err := verifier.Verify(ctx, rawIDToken)
   275| 	if err != nil {
   276| 		log.Error().
   277| 			Err(err).
   278| 			Caller().
   279| 			Msg("failed to verify id token")
   280| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   281| 		writer.WriteHeader(http.StatusBadRequest)
   282| 		_, werr := writer.Write([]byte("Failed to verify id token"))
   283| 		if werr != nil {
   284| 			log.Error().
   285| 				Caller().
   286| 				Err(werr).
   287| 				Msg("Failed to write response")
   288| 		}
   289| 		return nil, err
   290| 	}
   291| 	return idToken, nil
   292| }
   293| func extractIDTokenClaims(
   294| 	writer http.ResponseWriter,
   295| 	idToken *oidc.IDToken,
   296| ) (*IDTokenClaims, error) {
   297| 	var claims IDTokenClaims
   298| 	if err := idToken.Claims(&claims); err != nil {
   299| 		log.Error().
   300| 			Err(err).
   301| 			Caller().
   302| 			Msg("Failed to decode id token claims")
   303| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   304| 		writer.WriteHeader(http.StatusBadRequest)
   305| 		_, werr := writer.Write([]byte("Failed to decode id token claims"))
   306| 		if werr != nil {
   307| 			log.Error().
   308| 				Caller().
   309| 				Err(werr).
   310| 				Msg("Failed to write response")
   311| 		}
   312| 		return nil, err
   313| 	}
   314| 	return &claims, nil
   315| }
   316| func validateOIDCAllowedDomains(
   317| 	writer http.ResponseWriter,
   318| 	allowedDomains []string,
   319| 	claims *IDTokenClaims,
   320| ) error {
   321| 	if len(allowedDomains) > 0 {
   322| 		if at := strings.LastIndex(claims.Email, "@"); at < 0 ||
   323| 			!IsStringInSlice(allowedDomains, claims.Email[at+1:]) {
   324| 			log.Error().Msg("authenticated principal does not match any allowed domain")
   325| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   326| 			writer.WriteHeader(http.StatusBadRequest)
   327| 			_, err := writer.Write([]byte("unauthorized principal (domain mismatch)"))
   328| 			if err != nil {
   329| 				log.Error().
   330| 					Caller().
   331| 					Err(err).
   332| 					Msg("Failed to write response")
   333| 			}
   334| 			return errOIDCAllowedDomains
   335| 		}
   336| 	}
   337| 	return nil
   338| }
   339| func validateOIDCAllowedGroups(
   340| 	writer http.ResponseWriter,
   341| 	allowedGroups []string,
   342| 	claims *IDTokenClaims,
   343| ) error {
   344| 	if len(allowedGroups) > 0 {
   345| 		for _, group := range allowedGroups {
   346| 			if IsStringInSlice(claims.Groups, group) {
   347| 				return nil
   348| 			}
   349| 		}
   350| 		log.Error().Msg("authenticated principal not in any allowed groups")
   351| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   352| 		writer.WriteHeader(http.StatusBadRequest)
   353| 		_, err := writer.Write([]byte("unauthorized principal (allowed groups)"))
   354| 		if err != nil {
   355| 			log.Error().
   356| 				Caller().
   357| 				Err(err).
   358| 				Msg("Failed to write response")
   359| 		}
   360| 		return errOIDCAllowedGroups
   361| 	}
   362| 	return nil
   363| }
   364| func validateOIDCAllowedUsers(
   365| 	writer http.ResponseWriter,
   366| 	allowedUsers []string,
   367| 	claims *IDTokenClaims,
   368| ) error {
   369| 	if len(allowedUsers) > 0 &&
   370| 		!IsStringInSlice(allowedUsers, claims.Email) {
   371| 		log.Error().Msg("authenticated principal does not match any allowed user")
   372| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   373| 		writer.WriteHeader(http.StatusBadRequest)
   374| 		_, err := writer.Write([]byte("unauthorized principal (user mismatch)"))
   375| 		if err != nil {
   376| 			log.Error().
   377| 				Caller().
   378| 				Err(err).
   379| 				Msg("Failed to write response")
   380| 		}
   381| 		return errOIDCAllowedUsers
   382| 	}
   383| 	return nil
   384| }
   385| func (h *Headscale) validateMachineForOIDCCallback(
   386| 	writer http.ResponseWriter,
   387| 	state string,
   388| 	claims *IDTokenClaims,
   389| 	expiry time.Time,
   390| ) (*key.NodePublic, bool, error) {
   391| 	nodeKeyIf, nodeKeyFound := h.registrationCache.Get(state)
   392| 	if !nodeKeyFound {
   393| 		log.Error().
   394| 			Msg("requested machine state key expired before authorisation completed")
   395| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   396| 		writer.WriteHeader(http.StatusBadRequest)
   397| 		_, err := writer.Write([]byte("state has expired"))
   398| 		if err != nil {
   399| 			log.Error().
   400| 				Caller().
   401| 				Err(err).
   402| 				Msg("Failed to write response")
   403| 		}
   404| 		return nil, false, errOIDCNodeKeyMissing
   405| 	}
   406| 	var nodeKey key.NodePublic
   407| 	nodeKeyFromCache, nodeKeyOK := nodeKeyIf.(string)
   408| 	if !nodeKeyOK {
   409| 		log.Error().
   410| 			Msg("requested machine state key is not a string")
   411| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   412| 		writer.WriteHeader(http.StatusBadRequest)
   413| 		_, err := writer.Write([]byte("state is invalid"))
   414| 		if err != nil {
   415| 			log.Error().
   416| 				Caller().
   417| 				Err(err).
   418| 				Msg("Failed to write response")
   419| 		}
   420| 		return nil, false, errOIDCInvalidMachineState
   421| 	}
   422| 	err := nodeKey.UnmarshalText(
   423| 		[]byte(NodePublicKeyEnsurePrefix(nodeKeyFromCache)),
   424| 	)
   425| 	if err != nil {
   426| 		log.Error().
   427| 			Str("nodeKey", nodeKeyFromCache).
   428| 			Bool("nodeKeyOK", nodeKeyOK).
   429| 			Msg("could not parse node public key")
   430| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   431| 		writer.WriteHeader(http.StatusBadRequest)
   432| 		_, werr := writer.Write([]byte("could not parse node public key"))
   433| 		if werr != nil {
   434| 			log.Error().
   435| 				Caller().
   436| 				Err(werr).
   437| 				Msg("Failed to write response")
   438| 		}
   439| 		return nil, false, err
   440| 	}
   441| 	machine, _ := h.GetMachineByNodeKey(nodeKey)
   442| 	if machine != nil {
   443| 		log.Trace().
   444| 			Caller().
   445| 			Str("machine", machine.Hostname).
   446| 			Msg("machine already registered, reauthenticating")
   447| 		err := h.RefreshMachine(machine, expiry)
   448| 		if err != nil {
   449| 			log.Error().
   450| 				Caller().
   451| 				Err(err).
   452| 				Msg("Failed to refresh machine")
   453| 			http.Error(
   454| 				writer,
   455| 				"Failed to refresh machine",
   456| 				http.StatusInternalServerError,
   457| 			)
   458| 			return nil, true, err
   459| 		}
   460| 		log.Debug().
   461| 			Str("machine", machine.Hostname).
   462| 			Str("expiresAt", fmt.Sprintf("%v", expiry)).
   463| 			Msg("successfully refreshed machine")
   464| 		var content bytes.Buffer
   465| 		if err := oidcCallbackTemplate.Execute(&content, oidcCallbackTemplateConfig{
   466| 			User: claims.Email,
   467| 			Verb: "Reauthenticated",
   468| 		}); err != nil {
   469| 			log.Error().
   470| 				Str("func", "OIDCCallback").
   471| 				Str("type", "reauthenticate").
   472| 				Err(err).
   473| 				Msg("Could not render OIDC callback template")
   474| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   475| 			writer.WriteHeader(http.StatusInternalServerError)
   476| 			_, werr := writer.Write([]byte("Could not render OIDC callback template"))
   477| 			if werr != nil {
   478| 				log.Error().
   479| 					Caller().
   480| 					Err(werr).
   481| 					Msg("Failed to write response")
   482| 			}
   483| 			return nil, true, err
   484| 		}
   485| 		writer.Header().Set("Content-Type", "text/html; charset=utf-8")
   486| 		writer.WriteHeader(http.StatusOK)
   487| 		_, err = writer.Write(content.Bytes())
   488| 		if err != nil {
   489| 			log.Error().
   490| 				Caller().
   491| 				Err(err).
   492| 				Msg("Failed to write response")
   493| 		}
   494| 		return nil, true, nil
   495| 	}
   496| 	return &nodeKey, false, nil
   497| }
   498| func getUserName(
   499| 	writer http.ResponseWriter,
   500| 	claims *IDTokenClaims,
   501| 	stripEmaildomain bool,
   502| ) (string, error) {
   503| 	userName, err := NormalizeToFQDNRules(
   504| 		claims.Email,
   505| 		stripEmaildomain,
   506| 	)
   507| 	if err != nil {
   508| 		log.Error().Err(err).Caller().Msgf("couldn't normalize email")
   509| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   510| 		writer.WriteHeader(http.StatusInternalServerError)
   511| 		_, werr := writer.Write([]byte("couldn't normalize email"))
   512| 		if werr != nil {
   513| 			log.Error().
   514| 				Caller().
   515| 				Err(werr).
   516| 				Msg("Failed to write response")
   517| 		}
   518| 		return "", err
   519| 	}
   520| 	return userName, nil
   521| }
   522| func (h *Headscale) findOrCreateNewUserForOIDCCallback(
   523| 	writer http.ResponseWriter,
   524| 	userName string,
   525| ) (*User, error) {
   526| 	user, err := h.GetUser(userName)
   527| 	if errors.Is(err, ErrUserNotFound) {
   528| 		user, err = h.CreateUser(userName)
   529| 		if err != nil {
   530| 			log.Error().
   531| 				Err(err).
   532| 				Caller().
   533| 				Msgf("could not create new user '%s'", userName)
   534| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   535| 			writer.WriteHeader(http.StatusInternalServerError)
   536| 			_, werr := writer.Write([]byte("could not create user"))
   537| 			if werr != nil {
   538| 				log.Error().
   539| 					Caller().
   540| 					Err(werr).
   541| 					Msg("Failed to write response")
   542| 			}
   543| 			return nil, err
   544| 		}
   545| 	} else if err != nil {
   546| 		log.Error().
   547| 			Caller().
   548| 			Err(err).
   549| 			Str("user", userName).
   550| 			Msg("could not find or create user")
   551| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   552| 		writer.WriteHeader(http.StatusInternalServerError)
   553| 		_, werr := writer.Write([]byte("could not find or create user"))
   554| 		if werr != nil {
   555| 			log.Error().
   556| 				Caller().
   557| 				Err(werr).
   558| 				Msg("Failed to write response")
   559| 		}
   560| 		return nil, err
   561| 	}
   562| 	return user, nil
   563| }
   564| func (h *Headscale) registerMachineForOIDCCallback(
   565| 	writer http.ResponseWriter,
   566| 	user *User,
   567| 	nodeKey *key.NodePublic,
   568| 	expiry time.Time,
   569| ) error {
   570| 	if _, err := h.RegisterMachineFromAuthCallback(
   571| 		nodeKey.String(),
   572| 		user.Name,
   573| 		&expiry,
   574| 		RegisterMethodOIDC,
   575| 	); err != nil {
   576| 		log.Error().
   577| 			Caller().
   578| 			Err(err).
   579| 			Msg("could not register machine")
   580| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   581| 		writer.WriteHeader(http.StatusInternalServerError)
   582| 		_, werr := writer.Write([]byte("could not register machine"))
   583| 		if werr != nil {
   584| 			log.Error().
   585| 				Caller().
   586| 				Err(werr).
   587| 				Msg("Failed to write response")
   588| 		}
   589| 		return err
   590| 	}
   591| 	return nil
   592| }
   593| func renderOIDCCallbackTemplate(
   594| 	writer http.ResponseWriter,
   595| 	claims *IDTokenClaims,
   596| ) (*bytes.Buffer, error) {
   597| 	var content bytes.Buffer
   598| 	if err := oidcCallbackTemplate.Execute(&content, oidcCallbackTemplateConfig{
   599| 		User: claims.Email,
   600| 		Verb: "Authenticated",
   601| 	}); err != nil {
   602| 		log.Error().
   603| 			Str("func", "OIDCCallback").
   604| 			Str("type", "authenticate").
   605| 			Err(err).
   606| 			Msg("Could not render OIDC callback template")
   607| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
   608| 		writer.WriteHeader(http.StatusInternalServerError)
   609| 		_, werr := writer.Write([]byte("Could not render OIDC callback template"))
   610| 		if werr != nil {
   611| 			log.Error().
   612| 				Caller().
   613| 				Err(werr).
   614| 				Msg("Failed to write response")
   615| 		}
   616| 		return nil, err
   617| 	}
   618| 	return &content, nil
   619| }


# ====================================================================
# FILE: hscontrol/platform_config.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 29-102 ---
    29| 		writer.WriteHeader(http.StatusInternalServerError)
    30| 		_, err := writer.Write([]byte("Could not render Windows index template"))
    31| 		if err != nil {
    32| 			log.Error().
    33| 				Caller().
    34| 				Err(err).
    35| 				Msg("Failed to write response")
    36| 		}
    37| 		return
    38| 	}
    39| 	writer.Header().Set("Content-Type", "text/html; charset=utf-8")
    40| 	writer.WriteHeader(http.StatusOK)
    41| 	_, err := writer.Write(payload.Bytes())
    42| 	if err != nil {
    43| 		log.Error().
    44| 			Caller().
    45| 			Err(err).
    46| 			Msg("Failed to write response")
    47| 	}
    48| }
    49| func (h *Headscale) WindowsRegConfig(
    50| 	writer http.ResponseWriter,
    51| 	req *http.Request,
    52| ) {
    53| 	config := WindowsRegistryConfig{
    54| 		URL: h.cfg.ServerURL,
    55| 	}
    56| 	var content bytes.Buffer
    57| 	if err := windowsRegTemplate.Execute(&content, config); err != nil {
    58| 		log.Error().
    59| 			Str("handler", "WindowsRegConfig").
    60| 			Err(err).
    61| 			Msg("Could not render Apple macOS template")
    62| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    63| 		writer.WriteHeader(http.StatusInternalServerError)
    64| 		_, err := writer.Write([]byte("Could not render Windows registry template"))
    65| 		if err != nil {
    66| 			log.Error().
    67| 				Caller().
    68| 				Err(err).
    69| 				Msg("Failed to write response")
    70| 		}
    71| 		return
    72| 	}
    73| 	writer.Header().Set("Content-Type", "text/x-ms-regedit; charset=utf-8")
    74| 	writer.WriteHeader(http.StatusOK)
    75| 	_, err := writer.Write(content.Bytes())
    76| 	if err != nil {
    77| 		log.Error().
    78| 			Caller().
    79| 			Err(err).
    80| 			Msg("Failed to write response")
    81| 	}
    82| }
    83| func (h *Headscale) AppleConfigMessage(
    84| 	writer http.ResponseWriter,
    85| 	req *http.Request,
    86| ) {
    87| 	appleTemplate := template.Must(template.New("apple").Parse(appleTemplate))
    88| 	config := map[string]interface{}{
    89| 		"URL": h.cfg.ServerURL,
    90| 	}
    91| 	var payload bytes.Buffer
    92| 	if err := appleTemplate.Execute(&payload, config); err != nil {
    93| 		log.Error().
    94| 			Str("handler", "AppleMobileConfig").
    95| 			Err(err).
    96| 			Msg("Could not render Apple index template")
    97| 		writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    98| 		writer.WriteHeader(http.StatusInternalServerError)
    99| 		_, err := writer.Write([]byte("Could not render Apple index template"))
   100| 		if err != nil {
   101| 			log.Error().
   102| 				Caller().

# --- HUNK 2: Lines 240-297 ---
   240| 		_, err := writer.Write([]byte("Could not render Apple platform template"))
   241| 		if err != nil {
   242| 			log.Error().
   243| 				Caller().
   244| 				Err(err).
   245| 				Msg("Failed to write response")
   246| 		}
   247| 		return
   248| 	}
   249| 	writer.Header().
   250| 		Set("Content-Type", "application/x-apple-aspen-config; charset=utf-8")
   251| 	writer.WriteHeader(http.StatusOK)
   252| 	_, err = writer.Write(content.Bytes())
   253| 	if err != nil {
   254| 		log.Error().
   255| 			Caller().
   256| 			Err(err).
   257| 			Msg("Failed to write response")
   258| 	}
   259| }
   260| type WindowsRegistryConfig struct {
   261| 	URL string
   262| }
   263| type AppleMobileConfig struct {
   264| 	UUID    uuid.UUID
   265| 	URL     string
   266| 	Payload string
   267| }
   268| type AppleMobilePlatformConfig struct {
   269| 	UUID uuid.UUID
   270| 	URL  string
   271| }
   272| var windowsRegTemplate = textTemplate.Must(
   273| 	textTemplate.New("windowsconfig").Parse(`Windows Registry Editor Version 5.00
   274| [HKEY_LOCAL_MACHINE\SOFTWARE\Tailscale IPN]
   275| "UnattendedMode"="always"
   276| "LoginURL"="{{.URL}}"
   277| `))
   278| var commonTemplate = textTemplate.Must(
   279| 	textTemplate.New("mobileconfig").Parse(`<?xml version="1.0" encoding="UTF-8"?>
   280| <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
   281| <plist version="1.0">
   282|   <dict>
   283|     <key>PayloadUUID</key>
   284|     <string>{{.UUID}}</string>
   285|     <key>PayloadDisplayName</key>
   286|     <string>Headscale</string>
   287|     <key>PayloadDescription</key>
   288|     <string>Configure Tailscale login server to: {{.URL}}</string>
   289|     <key>PayloadIdentifier</key>
   290|     <string>com.github.juanfont.headscale</string>
   291|     <key>PayloadRemovalDisallowed</key>
   292|     <false/>
   293|     <key>PayloadType</key>
   294|     <string>Configuration</string>
   295|     <key>PayloadVersion</key>
   296|     <integer>1</integer>
   297|     <key>PayloadContent</key>


# ====================================================================
# FILE: hscontrol/preauth_keys.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-189 ---
     1| package hscontrol
     2| import (
     3| 	"crypto/rand"
     4| 	"encoding/hex"
     5| 	"errors"
     6| 	"fmt"
     7| 	"strconv"
     8| 	"strings"
     9| 	"time"
    10| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    11| 	"google.golang.org/protobuf/types/known/timestamppb"
    12| 	"gorm.io/gorm"
    13| )
    14| const (
    15| 	ErrPreAuthKeyNotFound          = Error("AuthKey not found")
    16| 	ErrPreAuthKeyExpired           = Error("AuthKey expired")
    17| 	ErrSingleUseAuthKeyHasBeenUsed = Error("AuthKey has already been used")
    18| 	ErrUserMismatch                = Error("user mismatch")
    19| 	ErrPreAuthKeyACLTagInvalid     = Error("AuthKey tag is invalid")
    20| )
    21| type PreAuthKey struct {
    22| 	ID        uint64 `gorm:"primary_key"`
    23| 	Key       string
    24| 	UserID    uint
    25| 	User      User
    26| 	Reusable  bool
    27| 	Ephemeral bool `gorm:"default:false"`
    28| 	Used      bool `gorm:"default:false"`
    29| 	ACLTags   []PreAuthKeyACLTag
    30| 	CreatedAt  *time.Time
    31| 	Expiration *time.Time
    32| }
    33| type PreAuthKeyACLTag struct {
    34| 	ID           uint64 `gorm:"primary_key"`
    35| 	PreAuthKeyID uint64
    36| 	Tag          string
    37| }
    38| func (h *Headscale) CreatePreAuthKey(
    39| 	userName string,
    40| 	reusable bool,
    41| 	ephemeral bool,
    42| 	expiration *time.Time,
    43| 	aclTags []string,
    44| ) (*PreAuthKey, error) {
    45| 	user, err := h.GetUser(userName)
    46| 	if err != nil {
    47| 		return nil, err
    48| 	}
    49| 	for _, tag := range aclTags {
    50| 		if !strings.HasPrefix(tag, "tag:") {
    51| 			return nil, fmt.Errorf("%w: '%s' did not begin with 'tag:'", ErrPreAuthKeyACLTagInvalid, tag)
    52| 		}
    53| 	}
    54| 	now := time.Now().UTC()
    55| 	kstr, err := h.generateKey()
    56| 	if err != nil {
    57| 		return nil, err
    58| 	}
    59| 	key := PreAuthKey{
    60| 		Key:        kstr,
    61| 		UserID:     user.ID,
    62| 		User:       *user,
    63| 		Reusable:   reusable,
    64| 		Ephemeral:  ephemeral,
    65| 		CreatedAt:  &now,
    66| 		Expiration: expiration,
    67| 	}
    68| 	err = h.db.Transaction(func(db *gorm.DB) error {
    69| 		if err := db.Save(&key).Error; err != nil {
    70| 			return fmt.Errorf("failed to create key in the database: %w", err)
    71| 		}
    72| 		if len(aclTags) > 0 {
    73| 			seenTags := map[string]bool{}
    74| 			for _, tag := range aclTags {
    75| 				if !seenTags[tag] {
    76| 					if err := db.Save(&PreAuthKeyACLTag{PreAuthKeyID: key.ID, Tag: tag}).Error; err != nil {
    77| 						return fmt.Errorf(
    78| 							"failed to ceate key tag in the database: %w",
    79| 							err,
    80| 						)
    81| 					}
    82| 					seenTags[tag] = true
    83| 				}
    84| 			}
    85| 		}
    86| 		return nil
    87| 	})
    88| 	if err != nil {
    89| 		return nil, err
    90| 	}
    91| 	return &key, nil
    92| }
    93| func (h *Headscale) ListPreAuthKeys(userName string) ([]PreAuthKey, error) {
    94| 	user, err := h.GetUser(userName)
    95| 	if err != nil {
    96| 		return nil, err
    97| 	}
    98| 	keys := []PreAuthKey{}
    99| 	if err := h.db.Preload("User").Preload("ACLTags").Where(&PreAuthKey{UserID: user.ID}).Find(&keys).Error; err != nil {
   100| 		return nil, err
   101| 	}
   102| 	return keys, nil
   103| }
   104| func (h *Headscale) GetPreAuthKey(user string, key string) (*PreAuthKey, error) {
   105| 	pak, err := h.checkKeyValidity(key)
   106| 	if err != nil {
   107| 		return nil, err
   108| 	}
   109| 	if pak.User.Name != user {
   110| 		return nil, ErrUserMismatch
   111| 	}
   112| 	return pak, nil
   113| }
   114| func (h *Headscale) DestroyPreAuthKey(pak PreAuthKey) error {
   115| 	return h.db.Transaction(func(db *gorm.DB) error {
   116| 		if result := db.Unscoped().Where(PreAuthKeyACLTag{PreAuthKeyID: pak.ID}).Delete(&PreAuthKeyACLTag{}); result.Error != nil {
   117| 			return result.Error
   118| 		}
   119| 		if result := db.Unscoped().Delete(pak); result.Error != nil {
   120| 			return result.Error
   121| 		}
   122| 		return nil
   123| 	})
   124| }
   125| func (h *Headscale) ExpirePreAuthKey(k *PreAuthKey) error {
   126| 	if err := h.db.Model(&k).Update("Expiration", time.Now()).Error; err != nil {
   127| 		return err
   128| 	}
   129| 	return nil
   130| }
   131| func (h *Headscale) UsePreAuthKey(k *PreAuthKey) error {
   132| 	k.Used = true
   133| 	if err := h.db.Save(k).Error; err != nil {
   134| 		return fmt.Errorf("failed to update key used status in the database: %w", err)
   135| 	}
   136| 	return nil
   137| }
   138| func (h *Headscale) checkKeyValidity(k string) (*PreAuthKey, error) {
   139| 	pak := PreAuthKey{}
   140| 	if result := h.db.Preload("User").Preload("ACLTags").First(&pak, "key = ?", k); errors.Is(
   141| 		result.Error,
   142| 		gorm.ErrRecordNotFound,
   143| 	) {
   144| 		return nil, ErrPreAuthKeyNotFound
   145| 	}
   146| 	if pak.Expiration != nil && pak.Expiration.Before(time.Now()) {
   147| 		return nil, ErrPreAuthKeyExpired
   148| 	}
   149| 	if pak.Reusable || pak.Ephemeral { // we don't need to check if has been used before
   150| 		return &pak, nil
   151| 	}
   152| 	machines := []Machine{}
   153| 	if err := h.db.Preload("AuthKey").Where(&Machine{AuthKeyID: uint(pak.ID)}).Find(&machines).Error; err != nil {
   154| 		return nil, err
   155| 	}
   156| 	if len(machines) != 0 || pak.Used {
   157| 		return nil, ErrSingleUseAuthKeyHasBeenUsed
   158| 	}
   159| 	return &pak, nil
   160| }
   161| func (h *Headscale) generateKey() (string, error) {
   162| 	size := 24
   163| 	bytes := make([]byte, size)
   164| 	if _, err := rand.Read(bytes); err != nil {
   165| 		return "", err
   166| 	}
   167| 	return hex.EncodeToString(bytes), nil
   168| }
   169| func (key *PreAuthKey) toProto() *v1.PreAuthKey {
   170| 	protoKey := v1.PreAuthKey{
   171| 		User:      key.User.Name,
   172| 		Id:        strconv.FormatUint(key.ID, Base10),
   173| 		Key:       key.Key,
   174| 		Ephemeral: key.Ephemeral,
   175| 		Reusable:  key.Reusable,
   176| 		Used:      key.Used,
   177| 		AclTags:   make([]string, len(key.ACLTags)),
   178| 	}
   179| 	if key.Expiration != nil {
   180| 		protoKey.Expiration = timestamppb.New(*key.Expiration)
   181| 	}
   182| 	if key.CreatedAt != nil {
   183| 		protoKey.CreatedAt = timestamppb.New(*key.CreatedAt)
   184| 	}
   185| 	for idx := range key.ACLTags {
   186| 		protoKey.AclTags[idx] = key.ACLTags[idx].Tag
   187| 	}
   188| 	return &protoKey
   189| }


# ====================================================================
# FILE: hscontrol/protocol_common.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-666 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"fmt"
     6| 	"net/http"
     7| 	"strconv"
     8| 	"strings"
     9| 	"time"
    10| 	"github.com/rs/zerolog/log"
    11| 	"gorm.io/gorm"
    12| 	"tailscale.com/tailcfg"
    13| 	"tailscale.com/types/key"
    14| )
    15| const (
    16| 	NoiseCapabilityVersion = 39
    17| )
    18| func (h *Headscale) KeyHandler(
    19| 	writer http.ResponseWriter,
    20| 	req *http.Request,
    21| ) {
    22| 	clientCapabilityStr := req.URL.Query().Get("v")
    23| 	if clientCapabilityStr != "" {
    24| 		log.Debug().
    25| 			Str("handler", "/key").
    26| 			Str("v", clientCapabilityStr).
    27| 			Msg("New noise client")
    28| 		clientCapabilityVersion, err := strconv.Atoi(clientCapabilityStr)
    29| 		if err != nil {
    30| 			writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    31| 			writer.WriteHeader(http.StatusBadRequest)
    32| 			_, err := writer.Write([]byte("Wrong params"))
    33| 			if err != nil {
    34| 				log.Error().
    35| 					Caller().
    36| 					Err(err).
    37| 					Msg("Failed to write response")
    38| 			}
    39| 			return
    40| 		}
    41| 		if clientCapabilityVersion >= NoiseCapabilityVersion {
    42| 			resp := tailcfg.OverTLSPublicKeyResponse{
    43| 				LegacyPublicKey: h.privateKey.Public(),
    44| 				PublicKey:       h.noisePrivateKey.Public(),
    45| 			}
    46| 			writer.Header().Set("Content-Type", "application/json")
    47| 			writer.WriteHeader(http.StatusOK)
    48| 			err = json.NewEncoder(writer).Encode(resp)
    49| 			if err != nil {
    50| 				log.Error().
    51| 					Caller().
    52| 					Err(err).
    53| 					Msg("Failed to write response")
    54| 			}
    55| 			return
    56| 		}
    57| 	}
    58| 	log.Debug().
    59| 		Str("handler", "/key").
    60| 		Msg("New legacy client")
    61| 	writer.Header().Set("Content-Type", "text/plain; charset=utf-8")
    62| 	writer.WriteHeader(http.StatusOK)
    63| 	_, err := writer.Write([]byte(MachinePublicKeyStripPrefix(h.privateKey.Public())))
    64| 	if err != nil {
    65| 		log.Error().
    66| 			Caller().
    67| 			Err(err).
    68| 			Msg("Failed to write response")
    69| 	}
    70| }
    71| func (h *Headscale) handleRegisterCommon(
    72| 	writer http.ResponseWriter,
    73| 	req *http.Request,
    74| 	registerRequest tailcfg.RegisterRequest,
    75| 	machineKey key.MachinePublic,
    76| 	isNoise bool,
    77| ) {
    78| 	now := time.Now().UTC()
    79| 	machine, err := h.GetMachineByAnyKey(machineKey, registerRequest.NodeKey, registerRequest.OldNodeKey)
    80| 	if errors.Is(err, gorm.ErrRecordNotFound) {
    81| 		if registerRequest.Auth.AuthKey != "" {
    82| 			h.handleAuthKeyCommon(writer, registerRequest, machineKey, isNoise)
    83| 			return
    84| 		}
    85| 		if registerRequest.Followup != "" {
    86| 			if _, ok := h.registrationCache.Get(NodePublicKeyStripPrefix(registerRequest.NodeKey)); ok {
    87| 				log.Debug().
    88| 					Caller().
    89| 					Str("machine", registerRequest.Hostinfo.Hostname).
    90| 					Str("machine_key", machineKey.ShortString()).
    91| 					Str("node_key", registerRequest.NodeKey.ShortString()).
    92| 					Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
    93| 					Str("follow_up", registerRequest.Followup).
    94| 					Bool("noise", isNoise).
    95| 					Msg("Machine is waiting for interactive login")
    96| 				select {
    97| 				case <-req.Context().Done():
    98| 					return
    99| 				case <-time.After(registrationHoldoff):
   100| 					h.handleNewMachineCommon(writer, registerRequest, machineKey, isNoise)
   101| 					return
   102| 				}
   103| 			}
   104| 		}
   105| 		log.Info().
   106| 			Caller().
   107| 			Str("machine", registerRequest.Hostinfo.Hostname).
   108| 			Str("machine_key", machineKey.ShortString()).
   109| 			Str("node_key", registerRequest.NodeKey.ShortString()).
   110| 			Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
   111| 			Str("follow_up", registerRequest.Followup).
   112| 			Bool("noise", isNoise).
   113| 			Msg("New machine not yet in the database")
   114| 		givenName, err := h.GenerateGivenName(
   115| 			machineKey.String(),
   116| 			registerRequest.Hostinfo.Hostname,
   117| 		)
   118| 		if err != nil {
   119| 			log.Error().
   120| 				Caller().
   121| 				Str("func", "RegistrationHandler").
   122| 				Str("hostinfo.name", registerRequest.Hostinfo.Hostname).
   123| 				Err(err)
   124| 			return
   125| 		}
   126| 		newMachine := Machine{
   127| 			MachineKey: MachinePublicKeyStripPrefix(machineKey),
   128| 			Hostname:   registerRequest.Hostinfo.Hostname,
   129| 			GivenName:  givenName,
   130| 			NodeKey:    NodePublicKeyStripPrefix(registerRequest.NodeKey),
   131| 			LastSeen:   &now,
   132| 			Expiry:     &time.Time{},
   133| 		}
   134| 		if !registerRequest.Expiry.IsZero() {
   135| 			log.Trace().
   136| 				Caller().
   137| 				Bool("noise", isNoise).
   138| 				Str("machine", registerRequest.Hostinfo.Hostname).
   139| 				Time("expiry", registerRequest.Expiry).
   140| 				Msg("Non-zero expiry time requested")
   141| 			newMachine.Expiry = &registerRequest.Expiry
   142| 		}
   143| 		h.registrationCache.Set(
   144| 			newMachine.NodeKey,
   145| 			newMachine,
   146| 			registerCacheExpiration,
   147| 		)
   148| 		h.handleNewMachineCommon(writer, registerRequest, machineKey, isNoise)
   149| 		return
   150| 	}
   151| 	if machine != nil {
   152| 		var storedMachineKey key.MachinePublic
   153| 		err = storedMachineKey.UnmarshalText(
   154| 			[]byte(MachinePublicKeyEnsurePrefix(machine.MachineKey)),
   155| 		)
   156| 		if err != nil || storedMachineKey.IsZero() {
   157| 			machine.MachineKey = MachinePublicKeyStripPrefix(machineKey)
   158| 			if err := h.db.Save(&machine).Error; err != nil {
   159| 				log.Error().
   160| 					Caller().
   161| 					Str("func", "RegistrationHandler").
   162| 					Str("machine", machine.Hostname).
   163| 					Err(err).
   164| 					Msg("Error saving machine key to database")
   165| 				return
   166| 			}
   167| 		}
   168| 		if machine.NodeKey == NodePublicKeyStripPrefix(registerRequest.NodeKey) {
   169| 			if !registerRequest.Expiry.IsZero() &&
   170| 				registerRequest.Expiry.UTC().Before(now) {
   171| 				h.handleMachineLogOutCommon(writer, *machine, machineKey, isNoise)
   172| 				return
   173| 			}
   174| 			if !machine.isExpired() {
   175| 				h.handleMachineValidRegistrationCommon(writer, *machine, machineKey, isNoise)
   176| 				return
   177| 			}
   178| 		}
   179| 		if machine.NodeKey == NodePublicKeyStripPrefix(registerRequest.OldNodeKey) &&
   180| 			!machine.isExpired() {
   181| 			h.handleMachineRefreshKeyCommon(
   182| 				writer,
   183| 				registerRequest,
   184| 				*machine,
   185| 				machineKey,
   186| 				isNoise,
   187| 			)
   188| 			return
   189| 		}
   190| 		if registerRequest.Followup != "" {
   191| 			select {
   192| 			case <-req.Context().Done():
   193| 				return
   194| 			case <-time.After(registrationHoldoff):
   195| 			}
   196| 		}
   197| 		h.handleMachineExpiredOrLoggedOutCommon(writer, registerRequest, *machine, machineKey, isNoise)
   198| 		machine.Expiry = &time.Time{}
   199| 		machine.NodeKey = NodePublicKeyStripPrefix(registerRequest.NodeKey)
   200| 		h.registrationCache.Set(
   201| 			NodePublicKeyStripPrefix(registerRequest.NodeKey),
   202| 			*machine,
   203| 			registerCacheExpiration,
   204| 		)
   205| 		return
   206| 	}
   207| }
   208| func (h *Headscale) handleAuthKeyCommon(
   209| 	writer http.ResponseWriter,
   210| 	registerRequest tailcfg.RegisterRequest,
   211| 	machineKey key.MachinePublic,
   212| 	isNoise bool,
   213| ) {
   214| 	log.Debug().
   215| 		Str("func", "handleAuthKeyCommon").
   216| 		Str("machine", registerRequest.Hostinfo.Hostname).
   217| 		Bool("noise", isNoise).
   218| 		Msgf("Processing auth key for %s", registerRequest.Hostinfo.Hostname)
   219| 	resp := tailcfg.RegisterResponse{}
   220| 	pak, err := h.checkKeyValidity(registerRequest.Auth.AuthKey)
   221| 	if err != nil {
   222| 		log.Error().
   223| 			Caller().
   224| 			Str("func", "handleAuthKeyCommon").
   225| 			Bool("noise", isNoise).
   226| 			Str("machine", registerRequest.Hostinfo.Hostname).
   227| 			Err(err).
   228| 			Msg("Failed authentication via AuthKey")
   229| 		resp.MachineAuthorized = false
   230| 		respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   231| 		if err != nil {
   232| 			log.Error().
   233| 				Caller().
   234| 				Str("func", "handleAuthKeyCommon").
   235| 				Bool("noise", isNoise).
   236| 				Str("machine", registerRequest.Hostinfo.Hostname).
   237| 				Err(err).
   238| 				Msg("Cannot encode message")
   239| 			http.Error(writer, "Internal server error", http.StatusInternalServerError)
   240| 			machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", pak.User.Name).
   241| 				Inc()
   242| 			return
   243| 		}
   244| 		writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   245| 		writer.WriteHeader(http.StatusUnauthorized)
   246| 		_, err = writer.Write(respBody)
   247| 		if err != nil {
   248| 			log.Error().
   249| 				Caller().
   250| 				Bool("noise", isNoise).
   251| 				Err(err).
   252| 				Msg("Failed to write response")
   253| 		}
   254| 		log.Error().
   255| 			Caller().
   256| 			Str("func", "handleAuthKeyCommon").
   257| 			Bool("noise", isNoise).
   258| 			Str("machine", registerRequest.Hostinfo.Hostname).
   259| 			Msg("Failed authentication via AuthKey")
   260| 		if pak != nil {
   261| 			machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", pak.User.Name).
   262| 				Inc()
   263| 		} else {
   264| 			machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", "unknown").Inc()
   265| 		}
   266| 		return
   267| 	}
   268| 	log.Debug().
   269| 		Str("func", "handleAuthKeyCommon").
   270| 		Bool("noise", isNoise).
   271| 		Str("machine", registerRequest.Hostinfo.Hostname).
   272| 		Msg("Authentication key was valid, proceeding to acquire IP addresses")
   273| 	nodeKey := NodePublicKeyStripPrefix(registerRequest.NodeKey)
   274| 	machine, _ := h.GetMachineByAnyKey(machineKey, registerRequest.NodeKey, registerRequest.OldNodeKey)
   275| 	if machine != nil {
   276| 		log.Trace().
   277| 			Caller().
   278| 			Bool("noise", isNoise).
   279| 			Str("machine", machine.Hostname).
   280| 			Msg("machine was already registered before, refreshing with new auth key")
   281| 		machine.NodeKey = nodeKey
   282| 		machine.AuthKeyID = uint(pak.ID)
   283| 		err := h.RefreshMachine(machine, registerRequest.Expiry)
   284| 		if err != nil {
   285| 			log.Error().
   286| 				Caller().
   287| 				Bool("noise", isNoise).
   288| 				Str("machine", machine.Hostname).
   289| 				Err(err).
   290| 				Msg("Failed to refresh machine")
   291| 			return
   292| 		}
   293| 		aclTags := pak.toProto().AclTags
   294| 		if len(aclTags) > 0 {
   295| 			err = h.SetTags(machine, aclTags)
   296| 			if err != nil {
   297| 				log.Error().
   298| 					Caller().
   299| 					Bool("noise", isNoise).
   300| 					Str("machine", machine.Hostname).
   301| 					Strs("aclTags", aclTags).
   302| 					Err(err).
   303| 					Msg("Failed to set tags after refreshing machine")
   304| 				return
   305| 			}
   306| 		}
   307| 	} else {
   308| 		now := time.Now().UTC()
   309| 		givenName, err := h.GenerateGivenName(MachinePublicKeyStripPrefix(machineKey), registerRequest.Hostinfo.Hostname)
   310| 		if err != nil {
   311| 			log.Error().
   312| 				Caller().
   313| 				Bool("noise", isNoise).
   314| 				Str("func", "RegistrationHandler").
   315| 				Str("hostinfo.name", registerRequest.Hostinfo.Hostname).
   316| 				Err(err)
   317| 			return
   318| 		}
   319| 		machineToRegister := Machine{
   320| 			Hostname:       registerRequest.Hostinfo.Hostname,
   321| 			GivenName:      givenName,
   322| 			UserID:         pak.User.ID,
   323| 			MachineKey:     MachinePublicKeyStripPrefix(machineKey),
   324| 			RegisterMethod: RegisterMethodAuthKey,
   325| 			Expiry:         &registerRequest.Expiry,
   326| 			NodeKey:        nodeKey,
   327| 			LastSeen:       &now,
   328| 			AuthKeyID:      uint(pak.ID),
   329| 			ForcedTags:     pak.toProto().AclTags,
   330| 		}
   331| 		machine, err = h.RegisterMachine(
   332| 			machineToRegister,
   333| 		)
   334| 		if err != nil {
   335| 			log.Error().
   336| 				Caller().
   337| 				Bool("noise", isNoise).
   338| 				Err(err).
   339| 				Msg("could not register machine")
   340| 			machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", pak.User.Name).
   341| 				Inc()
   342| 			http.Error(writer, "Internal server error", http.StatusInternalServerError)
   343| 			return
   344| 		}
   345| 	}
   346| 	err = h.UsePreAuthKey(pak)
   347| 	if err != nil {
   348| 		log.Error().
   349| 			Caller().
   350| 			Bool("noise", isNoise).
   351| 			Err(err).
   352| 			Msg("Failed to use pre-auth key")
   353| 		machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", pak.User.Name).
   354| 			Inc()
   355| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   356| 		return
   357| 	}
   358| 	resp.MachineAuthorized = true
   359| 	resp.User = *pak.User.toTailscaleUser()
   360| 	resp.Login = *pak.User.toTailscaleLogin()
   361| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   362| 	if err != nil {
   363| 		log.Error().
   364| 			Caller().
   365| 			Bool("noise", isNoise).
   366| 			Str("func", "handleAuthKeyCommon").
   367| 			Str("machine", registerRequest.Hostinfo.Hostname).
   368| 			Err(err).
   369| 			Msg("Cannot encode message")
   370| 		machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "error", pak.User.Name).
   371| 			Inc()
   372| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   373| 		return
   374| 	}
   375| 	machineRegistrations.WithLabelValues("new", RegisterMethodAuthKey, "success", pak.User.Name).
   376| 		Inc()
   377| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   378| 	writer.WriteHeader(http.StatusOK)
   379| 	_, err = writer.Write(respBody)
   380| 	if err != nil {
   381| 		log.Error().
   382| 			Caller().
   383| 			Bool("noise", isNoise).
   384| 			Err(err).
   385| 			Msg("Failed to write response")
   386| 	}
   387| 	log.Info().
   388| 		Str("func", "handleAuthKeyCommon").
   389| 		Bool("noise", isNoise).
   390| 		Str("machine", registerRequest.Hostinfo.Hostname).
   391| 		Str("ips", strings.Join(machine.IPAddresses.ToStringSlice(), ", ")).
   392| 		Msg("Successfully authenticated via AuthKey")
   393| }
   394| func (h *Headscale) handleNewMachineCommon(
   395| 	writer http.ResponseWriter,
   396| 	registerRequest tailcfg.RegisterRequest,
   397| 	machineKey key.MachinePublic,
   398| 	isNoise bool,
   399| ) {
   400| 	resp := tailcfg.RegisterResponse{}
   401| 	log.Debug().
   402| 		Caller().
   403| 		Bool("noise", isNoise).
   404| 		Str("machine", registerRequest.Hostinfo.Hostname).
   405| 		Msg("The node seems to be new, sending auth url")
   406| 	if h.oauth2Config != nil {
   407| 		resp.AuthURL = fmt.Sprintf(
   408| 			"%s/oidc/register/%s",
   409| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   410| 			registerRequest.NodeKey,
   411| 		)
   412| 	} else {
   413| 		resp.AuthURL = fmt.Sprintf("%s/register/%s",
   414| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   415| 			registerRequest.NodeKey)
   416| 	}
   417| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   418| 	if err != nil {
   419| 		log.Error().
   420| 			Caller().
   421| 			Bool("noise", isNoise).
   422| 			Err(err).
   423| 			Msg("Cannot encode message")
   424| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   425| 		return
   426| 	}
   427| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   428| 	writer.WriteHeader(http.StatusOK)
   429| 	_, err = writer.Write(respBody)
   430| 	if err != nil {
   431| 		log.Error().
   432| 			Bool("noise", isNoise).
   433| 			Caller().
   434| 			Err(err).
   435| 			Msg("Failed to write response")
   436| 	}
   437| 	log.Info().
   438| 		Caller().
   439| 		Bool("noise", isNoise).
   440| 		Str("AuthURL", resp.AuthURL).
   441| 		Str("machine", registerRequest.Hostinfo.Hostname).
   442| 		Msg("Successfully sent auth url")
   443| }
   444| func (h *Headscale) handleMachineLogOutCommon(
   445| 	writer http.ResponseWriter,
   446| 	machine Machine,
   447| 	machineKey key.MachinePublic,
   448| 	isNoise bool,
   449| ) {
   450| 	resp := tailcfg.RegisterResponse{}
   451| 	log.Info().
   452| 		Bool("noise", isNoise).
   453| 		Str("machine", machine.Hostname).
   454| 		Msg("Client requested logout")
   455| 	err := h.ExpireMachine(&machine)
   456| 	if err != nil {
   457| 		log.Error().
   458| 			Caller().
   459| 			Bool("noise", isNoise).
   460| 			Str("func", "handleMachineLogOutCommon").
   461| 			Err(err).
   462| 			Msg("Failed to expire machine")
   463| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   464| 		return
   465| 	}
   466| 	resp.AuthURL = ""
   467| 	resp.MachineAuthorized = false
   468| 	resp.NodeKeyExpired = true
   469| 	resp.User = *machine.User.toTailscaleUser()
   470| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   471| 	if err != nil {
   472| 		log.Error().
   473| 			Caller().
   474| 			Bool("noise", isNoise).
   475| 			Err(err).
   476| 			Msg("Cannot encode message")
   477| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   478| 		return
   479| 	}
   480| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   481| 	writer.WriteHeader(http.StatusOK)
   482| 	_, err = writer.Write(respBody)
   483| 	if err != nil {
   484| 		log.Error().
   485| 			Bool("noise", isNoise).
   486| 			Caller().
   487| 			Err(err).
   488| 			Msg("Failed to write response")
   489| 		return
   490| 	}
   491| 	if machine.isEphemeral() {
   492| 		err = h.HardDeleteMachine(&machine)
   493| 		if err != nil {
   494| 			log.Error().
   495| 				Err(err).
   496| 				Str("machine", machine.Hostname).
   497| 				Msg("Cannot delete ephemeral machine from the database")
   498| 		}
   499| 		return
   500| 	}
   501| 	log.Info().
   502| 		Caller().
   503| 		Bool("noise", isNoise).
   504| 		Str("machine", machine.Hostname).
   505| 		Msg("Successfully logged out")
   506| }
   507| func (h *Headscale) handleMachineValidRegistrationCommon(
   508| 	writer http.ResponseWriter,
   509| 	machine Machine,
   510| 	machineKey key.MachinePublic,
   511| 	isNoise bool,
   512| ) {
   513| 	resp := tailcfg.RegisterResponse{}
   514| 	log.Debug().
   515| 		Caller().
   516| 		Bool("noise", isNoise).
   517| 		Str("machine", machine.Hostname).
   518| 		Msg("Client is registered and we have the current NodeKey. All clear to /map")
   519| 	resp.AuthURL = ""
   520| 	resp.MachineAuthorized = true
   521| 	resp.User = *machine.User.toTailscaleUser()
   522| 	resp.Login = *machine.User.toTailscaleLogin()
   523| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   524| 	if err != nil {
   525| 		log.Error().
   526| 			Caller().
   527| 			Bool("noise", isNoise).
   528| 			Err(err).
   529| 			Msg("Cannot encode message")
   530| 		machineRegistrations.WithLabelValues("update", "web", "error", machine.User.Name).
   531| 			Inc()
   532| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   533| 		return
   534| 	}
   535| 	machineRegistrations.WithLabelValues("update", "web", "success", machine.User.Name).
   536| 		Inc()
   537| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   538| 	writer.WriteHeader(http.StatusOK)
   539| 	_, err = writer.Write(respBody)
   540| 	if err != nil {
   541| 		log.Error().
   542| 			Caller().
   543| 			Bool("noise", isNoise).
   544| 			Err(err).
   545| 			Msg("Failed to write response")
   546| 	}
   547| 	log.Info().
   548| 		Caller().
   549| 		Bool("noise", isNoise).
   550| 		Str("machine", machine.Hostname).
   551| 		Msg("Machine successfully authorized")
   552| }
   553| func (h *Headscale) handleMachineRefreshKeyCommon(
   554| 	writer http.ResponseWriter,
   555| 	registerRequest tailcfg.RegisterRequest,
   556| 	machine Machine,
   557| 	machineKey key.MachinePublic,
   558| 	isNoise bool,
   559| ) {
   560| 	resp := tailcfg.RegisterResponse{}
   561| 	log.Info().
   562| 		Caller().
   563| 		Bool("noise", isNoise).
   564| 		Str("machine", machine.Hostname).
   565| 		Msg("We have the OldNodeKey in the database. This is a key refresh")
   566| 	machine.NodeKey = NodePublicKeyStripPrefix(registerRequest.NodeKey)
   567| 	if err := h.db.Save(&machine).Error; err != nil {
   568| 		log.Error().
   569| 			Caller().
   570| 			Err(err).
   571| 			Msg("Failed to update machine key in the database")
   572| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   573| 		return
   574| 	}
   575| 	resp.AuthURL = ""
   576| 	resp.User = *machine.User.toTailscaleUser()
   577| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   578| 	if err != nil {
   579| 		log.Error().
   580| 			Caller().
   581| 			Bool("noise", isNoise).
   582| 			Err(err).
   583| 			Msg("Cannot encode message")
   584| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   585| 		return
   586| 	}
   587| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   588| 	writer.WriteHeader(http.StatusOK)
   589| 	_, err = writer.Write(respBody)
   590| 	if err != nil {
   591| 		log.Error().
   592| 			Caller().
   593| 			Bool("noise", isNoise).
   594| 			Err(err).
   595| 			Msg("Failed to write response")
   596| 	}
   597| 	log.Info().
   598| 		Caller().
   599| 		Bool("noise", isNoise).
   600| 		Str("node_key", registerRequest.NodeKey.ShortString()).
   601| 		Str("old_node_key", registerRequest.OldNodeKey.ShortString()).
   602| 		Str("machine", machine.Hostname).
   603| 		Msg("Node key successfully refreshed")
   604| }
   605| func (h *Headscale) handleMachineExpiredOrLoggedOutCommon(
   606| 	writer http.ResponseWriter,
   607| 	registerRequest tailcfg.RegisterRequest,
   608| 	machine Machine,
   609| 	machineKey key.MachinePublic,
   610| 	isNoise bool,
   611| ) {
   612| 	resp := tailcfg.RegisterResponse{}
   613| 	if registerRequest.Auth.AuthKey != "" {
   614| 		h.handleAuthKeyCommon(writer, registerRequest, machineKey, isNoise)
   615| 		return
   616| 	}
   617| 	log.Trace().
   618| 		Caller().
   619| 		Bool("noise", isNoise).
   620| 		Str("machine", machine.Hostname).
   621| 		Str("machine_key", machineKey.ShortString()).
   622| 		Str("node_key", registerRequest.NodeKey.ShortString()).
   623| 		Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
   624| 		Msg("Machine registration has expired or logged out. Sending a auth url to register")
   625| 	if h.oauth2Config != nil {
   626| 		resp.AuthURL = fmt.Sprintf("%s/oidc/register/%s",
   627| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   628| 			registerRequest.NodeKey)
   629| 	} else {
   630| 		resp.AuthURL = fmt.Sprintf("%s/register/%s",
   631| 			strings.TrimSuffix(h.cfg.ServerURL, "/"),
   632| 			registerRequest.NodeKey)
   633| 	}
   634| 	respBody, err := h.marshalResponse(resp, machineKey, isNoise)
   635| 	if err != nil {
   636| 		log.Error().
   637| 			Caller().
   638| 			Bool("noise", isNoise).
   639| 			Err(err).
   640| 			Msg("Cannot encode message")
   641| 		machineRegistrations.WithLabelValues("reauth", "web", "error", machine.User.Name).
   642| 			Inc()
   643| 		http.Error(writer, "Internal server error", http.StatusInternalServerError)
   644| 		return
   645| 	}
   646| 	machineRegistrations.WithLabelValues("reauth", "web", "success", machine.User.Name).
   647| 		Inc()
   648| 	writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   649| 	writer.WriteHeader(http.StatusOK)
   650| 	_, err = writer.Write(respBody)
   651| 	if err != nil {
   652| 		log.Error().
   653| 			Caller().
   654| 			Bool("noise", isNoise).
   655| 			Err(err).
   656| 			Msg("Failed to write response")
   657| 	}
   658| 	log.Trace().
   659| 		Caller().
   660| 		Bool("noise", isNoise).
   661| 		Str("machine_key", machineKey.ShortString()).
   662| 		Str("node_key", registerRequest.NodeKey.ShortString()).
   663| 		Str("node_key_old", registerRequest.OldNodeKey.ShortString()).
   664| 		Str("machine", machine.Hostname).
   665| 		Msg("Machine logged out. Sent AuthURL for reauthentication")
   666| }


# ====================================================================
# FILE: hscontrol/protocol_common_poll.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-569 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"fmt"
     5| 	"net/http"
     6| 	"time"
     7| 	"github.com/rs/zerolog/log"
     8| 	"tailscale.com/tailcfg"
     9| )
    10| const (
    11| 	keepAliveInterval = 60 * time.Second
    12| )
    13| type contextKey string
    14| const machineNameContextKey = contextKey("machineName")
    15| func (h *Headscale) handlePollCommon(
    16| 	writer http.ResponseWriter,
    17| 	ctx context.Context,
    18| 	machine *Machine,
    19| 	mapRequest tailcfg.MapRequest,
    20| 	isNoise bool,
    21| ) {
    22| 	machine.Hostname = mapRequest.Hostinfo.Hostname
    23| 	machine.HostInfo = HostInfo(*mapRequest.Hostinfo)
    24| 	machine.DiscoKey = DiscoPublicKeyStripPrefix(mapRequest.DiscoKey)
    25| 	now := time.Now().UTC()
    26| 	err := h.processMachineRoutes(machine)
    27| 	if err != nil {
    28| 		log.Error().
    29| 			Caller().
    30| 			Err(err).
    31| 			Str("machine", machine.Hostname).
    32| 			Msg("Error processing machine routes")
    33| 	}
    34| 	if h.aclPolicy != nil {
    35| 		err := h.UpdateACLRules()
    36| 		if err != nil {
    37| 			log.Error().
    38| 				Caller().
    39| 				Bool("noise", isNoise).
    40| 				Str("machine", machine.Hostname).
    41| 				Err(err)
    42| 		}
    43| 		err = h.EnableAutoApprovedRoutes(machine)
    44| 		if err != nil {
    45| 			log.Error().
    46| 				Caller().
    47| 				Bool("noise", isNoise).
    48| 				Str("machine", machine.Hostname).
    49| 				Err(err).
    50| 				Msg("Error running auto approved routes")
    51| 		}
    52| 	}
    53| 	if !mapRequest.ReadOnly {
    54| 		machine.Endpoints = mapRequest.Endpoints
    55| 		machine.LastSeen = &now
    56| 	}
    57| 	if err := h.db.Updates(machine).Error; err != nil {
    58| 		if err != nil {
    59| 			log.Error().
    60| 				Str("handler", "PollNetMap").
    61| 				Bool("noise", isNoise).
    62| 				Str("node_key", machine.NodeKey).
    63| 				Str("machine", machine.Hostname).
    64| 				Err(err).
    65| 				Msg("Failed to persist/update machine in the database")
    66| 			http.Error(writer, "", http.StatusInternalServerError)
    67| 			return
    68| 		}
    69| 	}
    70| 	mapResp, err := h.getMapResponseData(mapRequest, machine, isNoise)
    71| 	if err != nil {
    72| 		log.Error().
    73| 			Str("handler", "PollNetMap").
    74| 			Bool("noise", isNoise).
    75| 			Str("node_key", machine.NodeKey).
    76| 			Str("machine", machine.Hostname).
    77| 			Err(err).
    78| 			Msg("Failed to get Map response")
    79| 		http.Error(writer, "", http.StatusInternalServerError)
    80| 		return
    81| 	}
    82| 	log.Debug().
    83| 		Str("handler", "PollNetMap").
    84| 		Bool("noise", isNoise).
    85| 		Str("machine", machine.Hostname).
    86| 		Bool("readOnly", mapRequest.ReadOnly).
    87| 		Bool("omitPeers", mapRequest.OmitPeers).
    88| 		Bool("stream", mapRequest.Stream).
    89| 		Msg("Client map request processed")
    90| 	if mapRequest.ReadOnly {
    91| 		log.Info().
    92| 			Str("handler", "PollNetMap").
    93| 			Bool("noise", isNoise).
    94| 			Str("machine", machine.Hostname).
    95| 			Msg("Client is starting up. Probably interested in a DERP map")
    96| 		writer.Header().Set("Content-Type", "application/json; charset=utf-8")
    97| 		writer.WriteHeader(http.StatusOK)
    98| 		_, err := writer.Write(mapResp)
    99| 		if err != nil {
   100| 			log.Error().
   101| 				Caller().
   102| 				Err(err).
   103| 				Msg("Failed to write response")
   104| 		}
   105| 		if f, ok := writer.(http.Flusher); ok {
   106| 			f.Flush()
   107| 		}
   108| 		return
   109| 	}
   110| 	h.setLastStateChangeToNow()
   111| 	log.Trace().
   112| 		Caller().
   113| 		Bool("noise", isNoise).
   114| 		Str("machine", machine.Hostname).
   115| 		Msg("Loading or creating update channel")
   116| 	const chanSize = 8
   117| 	updateChan := make(chan struct{}, chanSize)
   118| 	pollDataChan := make(chan []byte, chanSize)
   119| 	defer closeChanWithLog(pollDataChan, machine.Hostname, "pollDataChan")
   120| 	keepAliveChan := make(chan []byte)
   121| 	if mapRequest.OmitPeers && !mapRequest.Stream {
   122| 		log.Info().
   123| 			Str("handler", "PollNetMap").
   124| 			Bool("noise", isNoise).
   125| 			Str("machine", machine.Hostname).
   126| 			Msg("Client sent endpoint update and is ok with a response without peer list")
   127| 		writer.Header().Set("Content-Type", "application/json; charset=utf-8")
   128| 		writer.WriteHeader(http.StatusOK)
   129| 		_, err := writer.Write(mapResp)
   130| 		if err != nil {
   131| 			log.Error().
   132| 				Caller().
   133| 				Err(err).
   134| 				Msg("Failed to write response")
   135| 		}
   136| 		updateRequestsFromNode.WithLabelValues(machine.User.Name, machine.Hostname, "endpoint-update").
   137| 			Inc()
   138| 		updateChan <- struct{}{}
   139| 		return
   140| 	} else if mapRequest.OmitPeers && mapRequest.Stream {
   141| 		log.Warn().
   142| 			Str("handler", "PollNetMap").
   143| 			Bool("noise", isNoise).
   144| 			Str("machine", machine.Hostname).
   145| 			Msg("Ignoring request, don't know how to handle it")
   146| 		http.Error(writer, "", http.StatusBadRequest)
   147| 		return
   148| 	}
   149| 	log.Info().
   150| 		Str("handler", "PollNetMap").
   151| 		Bool("noise", isNoise).
   152| 		Str("machine", machine.Hostname).
   153| 		Msg("Client is ready to access the tailnet")
   154| 	log.Info().
   155| 		Str("handler", "PollNetMap").
   156| 		Bool("noise", isNoise).
   157| 		Str("machine", machine.Hostname).
   158| 		Msg("Sending initial map")
   159| 	pollDataChan <- mapResp
   160| 	log.Info().
   161| 		Str("handler", "PollNetMap").
   162| 		Bool("noise", isNoise).
   163| 		Str("machine", machine.Hostname).
   164| 		Msg("Notifying peers")
   165| 	updateRequestsFromNode.WithLabelValues(machine.User.Name, machine.Hostname, "full-update").
   166| 		Inc()
   167| 	updateChan <- struct{}{}
   168| 	h.pollNetMapStream(
   169| 		writer,
   170| 		ctx,
   171| 		machine,
   172| 		mapRequest,
   173| 		pollDataChan,
   174| 		keepAliveChan,
   175| 		updateChan,
   176| 		isNoise,
   177| 	)
   178| 	log.Trace().
   179| 		Str("handler", "PollNetMap").
   180| 		Bool("noise", isNoise).
   181| 		Str("machine", machine.Hostname).
   182| 		Msg("Finished stream, closing PollNetMap session")
   183| }
   184| func (h *Headscale) pollNetMapStream(
   185| 	writer http.ResponseWriter,
   186| 	ctxReq context.Context,
   187| 	machine *Machine,
   188| 	mapRequest tailcfg.MapRequest,
   189| 	pollDataChan chan []byte,
   190| 	keepAliveChan chan []byte,
   191| 	updateChan chan struct{},
   192| 	isNoise bool,
   193| ) {
   194| 	h.pollNetMapStreamWG.Add(1)
   195| 	defer h.pollNetMapStreamWG.Done()
   196| 	ctx := context.WithValue(ctxReq, machineNameContextKey, machine.Hostname)
   197| 	ctx, cancel := context.WithCancel(ctx)
   198| 	defer cancel()
   199| 	go h.scheduledPollWorker(
   200| 		ctx,
   201| 		updateChan,
   202| 		keepAliveChan,
   203| 		mapRequest,
   204| 		machine,
   205| 		isNoise,
   206| 	)
   207| 	log.Trace().
   208| 		Str("handler", "pollNetMapStream").
   209| 		Bool("noise", isNoise).
   210| 		Str("machine", machine.Hostname).
   211| 		Msg("Waiting for data to stream...")
   212| 	log.Trace().
   213| 		Str("handler", "pollNetMapStream").
   214| 		Bool("noise", isNoise).
   215| 		Str("machine", machine.Hostname).
   216| 		Msgf("pollData is %#v, keepAliveChan is %#v, updateChan is %#v", pollDataChan, keepAliveChan, updateChan)
   217| 	for {
   218| 		select {
   219| 		case data := <-pollDataChan:
   220| 			log.Trace().
   221| 				Str("handler", "PollNetMapStream").
   222| 				Bool("noise", isNoise).
   223| 				Str("machine", machine.Hostname).
   224| 				Str("channel", "pollData").
   225| 				Int("bytes", len(data)).
   226| 				Msg("Sending data received via pollData channel")
   227| 			_, err := writer.Write(data)
   228| 			if err != nil {
   229| 				log.Error().
   230| 					Str("handler", "PollNetMapStream").
   231| 					Bool("noise", isNoise).
   232| 					Str("machine", machine.Hostname).
   233| 					Str("channel", "pollData").
   234| 					Err(err).
   235| 					Msg("Cannot write data")
   236| 				return
   237| 			}
   238| 			flusher, ok := writer.(http.Flusher)
   239| 			if !ok {
   240| 				log.Error().
   241| 					Caller().
   242| 					Str("handler", "PollNetMapStream").
   243| 					Bool("noise", isNoise).
   244| 					Str("machine", machine.Hostname).
   245| 					Str("channel", "pollData").
   246| 					Msg("Cannot cast writer to http.Flusher")
   247| 			} else {
   248| 				flusher.Flush()
   249| 			}
   250| 			log.Trace().
   251| 				Str("handler", "PollNetMapStream").
   252| 				Bool("noise", isNoise).
   253| 				Str("machine", machine.Hostname).
   254| 				Str("channel", "pollData").
   255| 				Int("bytes", len(data)).
   256| 				Msg("Data from pollData channel written successfully")
   257| 			err = h.UpdateMachineFromDatabase(machine)
   258| 			if err != nil {
   259| 				log.Error().
   260| 					Str("handler", "PollNetMapStream").
   261| 					Bool("noise", isNoise).
   262| 					Str("machine", machine.Hostname).
   263| 					Str("channel", "pollData").
   264| 					Err(err).
   265| 					Msg("Cannot update machine from database")
   266| 				return
   267| 			}
   268| 			now := time.Now().UTC()
   269| 			machine.LastSeen = &now
   270| 			lastStateUpdate.WithLabelValues(machine.User.Name, machine.Hostname).
   271| 				Set(float64(now.Unix()))
   272| 			machine.LastSuccessfulUpdate = &now
   273| 			err = h.TouchMachine(machine)
   274| 			if err != nil {
   275| 				log.Error().
   276| 					Str("handler", "PollNetMapStream").
   277| 					Bool("noise", isNoise).
   278| 					Str("machine", machine.Hostname).
   279| 					Str("channel", "pollData").
   280| 					Err(err).
   281| 					Msg("Cannot update machine LastSuccessfulUpdate")
   282| 				return
   283| 			}
   284| 			log.Trace().
   285| 				Str("handler", "PollNetMapStream").
   286| 				Bool("noise", isNoise).
   287| 				Str("machine", machine.Hostname).
   288| 				Str("channel", "pollData").
   289| 				Int("bytes", len(data)).
   290| 				Msg("Machine entry in database updated successfully after sending data")
   291| 		case data := <-keepAliveChan:
   292| 			log.Trace().
   293| 				Str("handler", "PollNetMapStream").
   294| 				Str("machine", machine.Hostname).
   295| 				Str("channel", "keepAlive").
   296| 				Int("bytes", len(data)).
   297| 				Msg("Sending keep alive message")
   298| 			_, err := writer.Write(data)
   299| 			if err != nil {
   300| 				log.Error().
   301| 					Str("handler", "PollNetMapStream").
   302| 					Bool("noise", isNoise).
   303| 					Str("machine", machine.Hostname).
   304| 					Str("channel", "keepAlive").
   305| 					Err(err).
   306| 					Msg("Cannot write keep alive message")
   307| 				return
   308| 			}
   309| 			flusher, ok := writer.(http.Flusher)
   310| 			if !ok {
   311| 				log.Error().
   312| 					Caller().
   313| 					Str("handler", "PollNetMapStream").
   314| 					Bool("noise", isNoise).
   315| 					Str("machine", machine.Hostname).
   316| 					Str("channel", "keepAlive").
   317| 					Msg("Cannot cast writer to http.Flusher")
   318| 			} else {
   319| 				flusher.Flush()
   320| 			}
   321| 			log.Trace().
   322| 				Str("handler", "PollNetMapStream").
   323| 				Bool("noise", isNoise).
   324| 				Str("machine", machine.Hostname).
   325| 				Str("channel", "keepAlive").
   326| 				Int("bytes", len(data)).
   327| 				Msg("Keep alive sent successfully")
   328| 			err = h.UpdateMachineFromDatabase(machine)
   329| 			if err != nil {
   330| 				log.Error().
   331| 					Str("handler", "PollNetMapStream").
   332| 					Bool("noise", isNoise).
   333| 					Str("machine", machine.Hostname).
   334| 					Str("channel", "keepAlive").
   335| 					Err(err).
   336| 					Msg("Cannot update machine from database")
   337| 				return
   338| 			}
   339| 			now := time.Now().UTC()
   340| 			machine.LastSeen = &now
   341| 			err = h.TouchMachine(machine)
   342| 			if err != nil {
   343| 				log.Error().
   344| 					Str("handler", "PollNetMapStream").
   345| 					Bool("noise", isNoise).
   346| 					Str("machine", machine.Hostname).
   347| 					Str("channel", "keepAlive").
   348| 					Err(err).
   349| 					Msg("Cannot update machine LastSeen")
   350| 				return
   351| 			}
   352| 			log.Trace().
   353| 				Str("handler", "PollNetMapStream").
   354| 				Bool("noise", isNoise).
   355| 				Str("machine", machine.Hostname).
   356| 				Str("channel", "keepAlive").
   357| 				Int("bytes", len(data)).
   358| 				Msg("Machine updated successfully after sending keep alive")
   359| 		case <-updateChan:
   360| 			log.Trace().
   361| 				Str("handler", "PollNetMapStream").
   362| 				Bool("noise", isNoise).
   363| 				Str("machine", machine.Hostname).
   364| 				Str("channel", "update").
   365| 				Msg("Received a request for update")
   366| 			updateRequestsReceivedOnChannel.WithLabelValues(machine.User.Name, machine.Hostname).
   367| 				Inc()
   368| 			if h.isOutdated(machine) {
   369| 				var lastUpdate time.Time
   370| 				if machine.LastSuccessfulUpdate != nil {
   371| 					lastUpdate = *machine.LastSuccessfulUpdate
   372| 				}
   373| 				log.Debug().
   374| 					Str("handler", "PollNetMapStream").
   375| 					Bool("noise", isNoise).
   376| 					Str("machine", machine.Hostname).
   377| 					Time("last_successful_update", lastUpdate).
   378| 					Time("last_state_change", h.getLastStateChange(machine.User)).
   379| 					Msgf("There has been updates since the last successful update to %s", machine.Hostname)
   380| 				data, err := h.getMapResponseData(mapRequest, machine, isNoise)
   381| 				if err != nil {
   382| 					log.Error().
   383| 						Str("handler", "PollNetMapStream").
   384| 						Bool("noise", isNoise).
   385| 						Str("machine", machine.Hostname).
   386| 						Str("channel", "update").
   387| 						Err(err).
   388| 						Msg("Could not get the map update")
   389| 					return
   390| 				}
   391| 				_, err = writer.Write(data)
   392| 				if err != nil {
   393| 					log.Error().
   394| 						Str("handler", "PollNetMapStream").
   395| 						Bool("noise", isNoise).
   396| 						Str("machine", machine.Hostname).
   397| 						Str("channel", "update").
   398| 						Err(err).
   399| 						Msg("Could not write the map response")
   400| 					updateRequestsSentToNode.WithLabelValues(machine.User.Name, machine.Hostname, "failed").
   401| 						Inc()
   402| 					return
   403| 				}
   404| 				flusher, ok := writer.(http.Flusher)
   405| 				if !ok {
   406| 					log.Error().
   407| 						Caller().
   408| 						Str("handler", "PollNetMapStream").
   409| 						Bool("noise", isNoise).
   410| 						Str("machine", machine.Hostname).
   411| 						Str("channel", "update").
   412| 						Msg("Cannot cast writer to http.Flusher")
   413| 				} else {
   414| 					flusher.Flush()
   415| 				}
   416| 				log.Trace().
   417| 					Str("handler", "PollNetMapStream").
   418| 					Bool("noise", isNoise).
   419| 					Str("machine", machine.Hostname).
   420| 					Str("channel", "update").
   421| 					Msg("Updated Map has been sent")
   422| 				updateRequestsSentToNode.WithLabelValues(machine.User.Name, machine.Hostname, "success").
   423| 					Inc()
   424| 				err = h.UpdateMachineFromDatabase(machine)
   425| 				if err != nil {
   426| 					log.Error().
   427| 						Str("handler", "PollNetMapStream").
   428| 						Bool("noise", isNoise).
   429| 						Str("machine", machine.Hostname).
   430| 						Str("channel", "update").
   431| 						Err(err).
   432| 						Msg("Cannot update machine from database")
   433| 					return
   434| 				}
   435| 				now := time.Now().UTC()
   436| 				lastStateUpdate.WithLabelValues(machine.User.Name, machine.Hostname).
   437| 					Set(float64(now.Unix()))
   438| 				machine.LastSuccessfulUpdate = &now
   439| 				err = h.TouchMachine(machine)
   440| 				if err != nil {
   441| 					log.Error().
   442| 						Str("handler", "PollNetMapStream").
   443| 						Bool("noise", isNoise).
   444| 						Str("machine", machine.Hostname).
   445| 						Str("channel", "update").
   446| 						Err(err).
   447| 						Msg("Cannot update machine LastSuccessfulUpdate")
   448| 					return
   449| 				}
   450| 			} else {
   451| 				var lastUpdate time.Time
   452| 				if machine.LastSuccessfulUpdate != nil {
   453| 					lastUpdate = *machine.LastSuccessfulUpdate
   454| 				}
   455| 				log.Trace().
   456| 					Str("handler", "PollNetMapStream").
   457| 					Bool("noise", isNoise).
   458| 					Str("machine", machine.Hostname).
   459| 					Time("last_successful_update", lastUpdate).
   460| 					Time("last_state_change", h.getLastStateChange(machine.User)).
   461| 					Msgf("%s is up to date", machine.Hostname)
   462| 			}
   463| 		case <-ctx.Done():
   464| 			log.Info().
   465| 				Str("handler", "PollNetMapStream").
   466| 				Str("machine", machine.Hostname).
   467| 				Msg("The client has closed the connection")
   468| 			err := h.UpdateMachineFromDatabase(machine)
   469| 			if err != nil {
   470| 				log.Error().
   471| 					Str("handler", "PollNetMapStream").
   472| 					Bool("noise", isNoise).
   473| 					Str("machine", machine.Hostname).
   474| 					Str("channel", "Done").
   475| 					Err(err).
   476| 					Msg("Cannot update machine from database")
   477| 				return
   478| 			}
   479| 			now := time.Now().UTC()
   480| 			machine.LastSeen = &now
   481| 			err = h.TouchMachine(machine)
   482| 			if err != nil {
   483| 				log.Error().
   484| 					Str("handler", "PollNetMapStream").
   485| 					Bool("noise", isNoise).
   486| 					Str("machine", machine.Hostname).
   487| 					Str("channel", "Done").
   488| 					Err(err).
   489| 					Msg("Cannot update machine LastSeen")
   490| 			}
   491| 			return
   492| 		case <-h.shutdownChan:
   493| 			log.Info().
   494| 				Str("handler", "PollNetMapStream").
   495| 				Bool("noise", isNoise).
   496| 				Str("machine", machine.Hostname).
   497| 				Msg("The long-poll handler is shutting down")
   498| 			return
   499| 		}
   500| 	}
   501| }
   502| func (h *Headscale) scheduledPollWorker(
   503| 	ctx context.Context,
   504| 	updateChan chan struct{},
   505| 	keepAliveChan chan []byte,
   506| 	mapRequest tailcfg.MapRequest,
   507| 	machine *Machine,
   508| 	isNoise bool,
   509| ) {
   510| 	keepAliveTicker := time.NewTicker(keepAliveInterval)
   511| 	updateCheckerTicker := time.NewTicker(h.cfg.NodeUpdateCheckInterval)
   512| 	defer closeChanWithLog(
   513| 		updateChan,
   514| 		fmt.Sprint(ctx.Value(machineNameContextKey)),
   515| 		"updateChan",
   516| 	)
   517| 	defer closeChanWithLog(
   518| 		keepAliveChan,
   519| 		fmt.Sprint(ctx.Value(machineNameContextKey)),
   520| 		"keepAliveChan",
   521| 	)
   522| 	for {
   523| 		select {
   524| 		case <-ctx.Done():
   525| 			return
   526| 		case <-keepAliveTicker.C:
   527| 			data, err := h.getMapKeepAliveResponseData(mapRequest, machine, isNoise)
   528| 			if err != nil {
   529| 				log.Error().
   530| 					Str("func", "keepAlive").
   531| 					Bool("noise", isNoise).
   532| 					Err(err).
   533| 					Msg("Error generating the keep alive msg")
   534| 				return
   535| 			}
   536| 			log.Debug().
   537| 				Str("func", "keepAlive").
   538| 				Str("machine", machine.Hostname).
   539| 				Bool("noise", isNoise).
   540| 				Msg("Sending keepalive")
   541| 			select {
   542| 			case keepAliveChan <- data:
   543| 			case <-ctx.Done():
   544| 				return
   545| 			}
   546| 		case <-updateCheckerTicker.C:
   547| 			log.Debug().
   548| 				Str("func", "scheduledPollWorker").
   549| 				Str("machine", machine.Hostname).
   550| 				Bool("noise", isNoise).
   551| 				Msg("Sending update request")
   552| 			updateRequestsFromNode.WithLabelValues(machine.User.Name, machine.Hostname, "scheduled-update").
   553| 				Inc()
   554| 			select {
   555| 			case updateChan <- struct{}{}:
   556| 			case <-ctx.Done():
   557| 				return
   558| 			}
   559| 		}
   560| 	}
   561| }
   562| func closeChanWithLog[C chan []byte | chan struct{}](channel C, machine, name string) {
   563| 	log.Trace().
   564| 		Str("handler", "PollNetMap").
   565| 		Str("machine", machine).
   566| 		Str("channel", "Done").
   567| 		Msg(fmt.Sprintf("Closing %s channel", name))
   568| 	close(channel)
   569| }


# ====================================================================
# FILE: hscontrol/protocol_common_utils.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-126 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/binary"
     4| 	"encoding/json"
     5| 	"sync"
     6| 	"github.com/klauspost/compress/zstd"
     7| 	"github.com/rs/zerolog/log"
     8| 	"tailscale.com/smallzstd"
     9| 	"tailscale.com/tailcfg"
    10| 	"tailscale.com/types/key"
    11| )
    12| func (h *Headscale) getMapResponseData(
    13| 	mapRequest tailcfg.MapRequest,
    14| 	machine *Machine,
    15| 	isNoise bool,
    16| ) ([]byte, error) {
    17| 	mapResponse, err := h.generateMapResponse(mapRequest, machine)
    18| 	if err != nil {
    19| 		return nil, err
    20| 	}
    21| 	if isNoise {
    22| 		return h.marshalMapResponse(mapResponse, key.MachinePublic{}, mapRequest.Compress, isNoise)
    23| 	}
    24| 	var machineKey key.MachinePublic
    25| 	err = machineKey.UnmarshalText([]byte(MachinePublicKeyEnsurePrefix(machine.MachineKey)))
    26| 	if err != nil {
    27| 		log.Error().
    28| 			Caller().
    29| 			Err(err).
    30| 			Msg("Cannot parse client key")
    31| 		return nil, err
    32| 	}
    33| 	return h.marshalMapResponse(mapResponse, machineKey, mapRequest.Compress, isNoise)
    34| }
    35| func (h *Headscale) getMapKeepAliveResponseData(
    36| 	mapRequest tailcfg.MapRequest,
    37| 	machine *Machine,
    38| 	isNoise bool,
    39| ) ([]byte, error) {
    40| 	keepAliveResponse := tailcfg.MapResponse{
    41| 		KeepAlive: true,
    42| 	}
    43| 	if isNoise {
    44| 		return h.marshalMapResponse(keepAliveResponse, key.MachinePublic{}, mapRequest.Compress, isNoise)
    45| 	}
    46| 	var machineKey key.MachinePublic
    47| 	err := machineKey.UnmarshalText([]byte(MachinePublicKeyEnsurePrefix(machine.MachineKey)))
    48| 	if err != nil {
    49| 		log.Error().
    50| 			Caller().
    51| 			Err(err).
    52| 			Msg("Cannot parse client key")
    53| 		return nil, err
    54| 	}
    55| 	return h.marshalMapResponse(keepAliveResponse, machineKey, mapRequest.Compress, isNoise)
    56| }
    57| func (h *Headscale) marshalResponse(
    58| 	resp interface{},
    59| 	machineKey key.MachinePublic,
    60| 	isNoise bool,
    61| ) ([]byte, error) {
    62| 	jsonBody, err := json.Marshal(resp)
    63| 	if err != nil {
    64| 		log.Error().
    65| 			Caller().
    66| 			Err(err).
    67| 			Msg("Cannot marshal response")
    68| 		return nil, err
    69| 	}
    70| 	if isNoise {
    71| 		return jsonBody, nil
    72| 	}
    73| 	return h.privateKey.SealTo(machineKey, jsonBody), nil
    74| }
    75| func (h *Headscale) marshalMapResponse(
    76| 	resp interface{},
    77| 	machineKey key.MachinePublic,
    78| 	compression string,
    79| 	isNoise bool,
    80| ) ([]byte, error) {
    81| 	jsonBody, err := json.Marshal(resp)
    82| 	if err != nil {
    83| 		log.Error().
    84| 			Caller().
    85| 			Err(err).
    86| 			Msg("Cannot marshal map response")
    87| 	}
    88| 	var respBody []byte
    89| 	if compression == ZstdCompression {
    90| 		respBody = zstdEncode(jsonBody)
    91| 		if !isNoise { // if legacy protocol
    92| 			respBody = h.privateKey.SealTo(machineKey, respBody)
    93| 		}
    94| 	} else {
    95| 		if !isNoise { // if legacy protocol
    96| 			respBody = h.privateKey.SealTo(machineKey, jsonBody)
    97| 		} else {
    98| 			respBody = jsonBody
    99| 		}
   100| 	}
   101| 	data := make([]byte, reservedResponseHeaderSize)
   102| 	binary.LittleEndian.PutUint32(data, uint32(len(respBody)))
   103| 	data = append(data, respBody...)
   104| 	return data, nil
   105| }
   106| func zstdEncode(in []byte) []byte {
   107| 	encoder, ok := zstdEncoderPool.Get().(*zstd.Encoder)
   108| 	if !ok {
   109| 		panic("invalid type in sync pool")
   110| 	}
   111| 	out := encoder.EncodeAll(in, nil)
   112| 	_ = encoder.Close()
   113| 	zstdEncoderPool.Put(encoder)
   114| 	return out
   115| }
   116| var zstdEncoderPool = &sync.Pool{
   117| 	New: func() any {
   118| 		encoder, err := smallzstd.NewEncoder(
   119| 			nil,
   120| 			zstd.WithEncoderLevel(zstd.SpeedFastest))
   121| 		if err != nil {
   122| 			panic(err)
   123| 		}
   124| 		return encoder
   125| 	},
   126| }


# ====================================================================
# FILE: hscontrol/protocol_legacy.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| package hscontrol
     2| import (
     3| 	"io"
     4| 	"net/http"
     5| 	"github.com/gorilla/mux"
     6| 	"github.com/rs/zerolog/log"
     7| 	"tailscale.com/tailcfg"
     8| 	"tailscale.com/types/key"
     9| )
    10| func (h *Headscale) RegistrationHandler(
    11| 	writer http.ResponseWriter,
    12| 	req *http.Request,
    13| ) {
    14| 	vars := mux.Vars(req)
    15| 	machineKeyStr, ok := vars["mkey"]
    16| 	if !ok || machineKeyStr == "" {
    17| 		log.Error().
    18| 			Str("handler", "RegistrationHandler").
    19| 			Msg("No machine ID in request")
    20| 		http.Error(writer, "No machine ID in request", http.StatusBadRequest)
    21| 		return
    22| 	}
    23| 	body, _ := io.ReadAll(req.Body)
    24| 	var machineKey key.MachinePublic
    25| 	err := machineKey.UnmarshalText([]byte(MachinePublicKeyEnsurePrefix(machineKeyStr)))
    26| 	if err != nil {
    27| 		log.Error().
    28| 			Caller().
    29| 			Err(err).
    30| 			Msg("Cannot parse machine key")
    31| 		machineRegistrations.WithLabelValues("unknown", "web", "error", "unknown").Inc()
    32| 		http.Error(writer, "Cannot parse machine key", http.StatusBadRequest)
    33| 		return
    34| 	}
    35| 	registerRequest := tailcfg.RegisterRequest{}
    36| 	err = decode(body, &registerRequest, &machineKey, h.privateKey)
    37| 	if err != nil {
    38| 		log.Error().
    39| 			Caller().
    40| 			Err(err).
    41| 			Msg("Cannot decode message")
    42| 		machineRegistrations.WithLabelValues("unknown", "web", "error", "unknown").Inc()
    43| 		http.Error(writer, "Cannot decode message", http.StatusBadRequest)
    44| 		return
    45| 	}
    46| 	h.handleRegisterCommon(writer, req, registerRequest, machineKey, false)
    47| }


# ====================================================================
# FILE: hscontrol/protocol_legacy_poll.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-71 ---
     1| package hscontrol
     2| import (
     3| 	"errors"
     4| 	"io"
     5| 	"net/http"
     6| 	"github.com/gorilla/mux"
     7| 	"github.com/rs/zerolog/log"
     8| 	"gorm.io/gorm"
     9| 	"tailscale.com/tailcfg"
    10| 	"tailscale.com/types/key"
    11| )
    12| func (h *Headscale) PollNetMapHandler(
    13| 	writer http.ResponseWriter,
    14| 	req *http.Request,
    15| ) {
    16| 	vars := mux.Vars(req)
    17| 	machineKeyStr, ok := vars["mkey"]
    18| 	if !ok || machineKeyStr == "" {
    19| 		log.Error().
    20| 			Str("handler", "PollNetMap").
    21| 			Msg("No machine key in request")
    22| 		http.Error(writer, "No machine key in request", http.StatusBadRequest)
    23| 		return
    24| 	}
    25| 	log.Trace().
    26| 		Str("handler", "PollNetMap").
    27| 		Str("id", machineKeyStr).
    28| 		Msg("PollNetMapHandler called")
    29| 	body, _ := io.ReadAll(req.Body)
    30| 	var machineKey key.MachinePublic
    31| 	err := machineKey.UnmarshalText([]byte(MachinePublicKeyEnsurePrefix(machineKeyStr)))
    32| 	if err != nil {
    33| 		log.Error().
    34| 			Str("handler", "PollNetMap").
    35| 			Err(err).
    36| 			Msg("Cannot parse client key")
    37| 		http.Error(writer, "Cannot parse client key", http.StatusBadRequest)
    38| 		return
    39| 	}
    40| 	mapRequest := tailcfg.MapRequest{}
    41| 	err = decode(body, &mapRequest, &machineKey, h.privateKey)
    42| 	if err != nil {
    43| 		log.Error().
    44| 			Str("handler", "PollNetMap").
    45| 			Err(err).
    46| 			Msg("Cannot decode message")
    47| 		http.Error(writer, "Cannot decode message", http.StatusBadRequest)
    48| 		return
    49| 	}
    50| 	machine, err := h.GetMachineByMachineKey(machineKey)
    51| 	if err != nil {
    52| 		if errors.Is(err, gorm.ErrRecordNotFound) {
    53| 			log.Warn().
    54| 				Str("handler", "PollNetMap").
    55| 				Msgf("Ignoring request, cannot find machine with key %s", machineKey.String())
    56| 			http.Error(writer, "", http.StatusUnauthorized)
    57| 			return
    58| 		}
    59| 		log.Error().
    60| 			Str("handler", "PollNetMap").
    61| 			Msgf("Failed to fetch machine from the database with Machine key: %s", machineKey.String())
    62| 		http.Error(writer, "", http.StatusInternalServerError)
    63| 		return
    64| 	}
    65| 	log.Trace().
    66| 		Str("handler", "PollNetMap").
    67| 		Str("id", machineKeyStr).
    68| 		Str("machine", machine.Hostname).
    69| 		Msg("A machine is entering polling via the legacy protocol")
    70| 	h.handlePollCommon(writer, req.Context(), machine, mapRequest, false)
    71| }


# ====================================================================
# FILE: hscontrol/protocol_noise_poll.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| package hscontrol
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"io"
     6| 	"net/http"
     7| 	"github.com/rs/zerolog/log"
     8| 	"gorm.io/gorm"
     9| 	"tailscale.com/tailcfg"
    10| 	"tailscale.com/types/key"
    11| )
    12| func (ns *noiseServer) NoisePollNetMapHandler(
    13| 	writer http.ResponseWriter,
    14| 	req *http.Request,
    15| ) {
    16| 	log.Trace().
    17| 		Str("handler", "NoisePollNetMap").
    18| 		Msg("PollNetMapHandler called")
    19| 	log.Trace().
    20| 		Any("headers", req.Header).
    21| 		Msg("Headers")
    22| 	body, _ := io.ReadAll(req.Body)
    23| 	mapRequest := tailcfg.MapRequest{}
    24| 	if err := json.Unmarshal(body, &mapRequest); err != nil {
    25| 		log.Error().
    26| 			Caller().
    27| 			Err(err).
    28| 			Msg("Cannot parse MapRequest")
    29| 		http.Error(writer, "Internal error", http.StatusInternalServerError)
    30| 		return
    31| 	}
    32| 	ns.nodeKey = mapRequest.NodeKey
    33| 	machine, err := ns.headscale.GetMachineByAnyKey(ns.conn.Peer(), mapRequest.NodeKey, key.NodePublic{})
    34| 	if err != nil {
    35| 		if errors.Is(err, gorm.ErrRecordNotFound) {
    36| 			log.Warn().
    37| 				Str("handler", "NoisePollNetMap").
    38| 				Msgf("Ignoring request, cannot find machine with key %s", mapRequest.NodeKey.String())
    39| 			http.Error(writer, "Internal error", http.StatusNotFound)
    40| 			return
    41| 		}
    42| 		log.Error().
    43| 			Str("handler", "NoisePollNetMap").
    44| 			Msgf("Failed to fetch machine from the database with node key: %s", mapRequest.NodeKey.String())
    45| 		http.Error(writer, "Internal error", http.StatusInternalServerError)
    46| 		return
    47| 	}
    48| 	log.Debug().
    49| 		Str("handler", "NoisePollNetMap").
    50| 		Str("machine", machine.Hostname).
    51| 		Msg("A machine is entering polling via the Noise protocol")
    52| 	ns.headscale.handlePollCommon(writer, req.Context(), machine, mapRequest, true)
    53| }


# ====================================================================
# FILE: hscontrol/routes.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-335 ---
     1| package hscontrol
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"net/netip"
     6| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     7| 	"github.com/rs/zerolog/log"
     8| 	"google.golang.org/protobuf/types/known/timestamppb"
     9| 	"gorm.io/gorm"
    10| )
    11| const (
    12| 	ErrRouteIsNotAvailable = Error("route is not available")
    13| )
    14| var (
    15| 	ExitRouteV4 = netip.MustParsePrefix("0.0.0.0/0")
    16| 	ExitRouteV6 = netip.MustParsePrefix("::/0")
    17| )
    18| type Route struct {
    19| 	gorm.Model
    20| 	MachineID uint64
    21| 	Machine   Machine
    22| 	Prefix    IPPrefix
    23| 	Advertised bool
    24| 	Enabled    bool
    25| 	IsPrimary  bool
    26| }
    27| type Routes []Route
    28| func (r *Route) String() string {
    29| 	return fmt.Sprintf("%s:%s", r.Machine, netip.Prefix(r.Prefix).String())
    30| }
    31| func (r *Route) isExitRoute() bool {
    32| 	return netip.Prefix(r.Prefix) == ExitRouteV4 || netip.Prefix(r.Prefix) == ExitRouteV6
    33| }
    34| func (rs Routes) toPrefixes() []netip.Prefix {
    35| 	prefixes := make([]netip.Prefix, len(rs))
    36| 	for i, r := range rs {
    37| 		prefixes[i] = netip.Prefix(r.Prefix)
    38| 	}
    39| 	return prefixes
    40| }
    41| func (h *Headscale) GetRoutes() ([]Route, error) {
    42| 	var routes []Route
    43| 	err := h.db.Preload("Machine").Find(&routes).Error
    44| 	if err != nil {
    45| 		return nil, err
    46| 	}
    47| 	return routes, nil
    48| }
    49| func (h *Headscale) GetMachineRoutes(m *Machine) ([]Route, error) {
    50| 	var routes []Route
    51| 	err := h.db.
    52| 		Preload("Machine").
    53| 		Where("machine_id = ?", m.ID).
    54| 		Find(&routes).Error
    55| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
    56| 		return nil, err
    57| 	}
    58| 	return routes, nil
    59| }
    60| func (h *Headscale) GetRoute(id uint64) (*Route, error) {
    61| 	var route Route
    62| 	err := h.db.Preload("Machine").First(&route, id).Error
    63| 	if err != nil {
    64| 		return nil, err
    65| 	}
    66| 	return &route, nil
    67| }
    68| func (h *Headscale) EnableRoute(id uint64) error {
    69| 	route, err := h.GetRoute(id)
    70| 	if err != nil {
    71| 		return err
    72| 	}
    73| 	if route.isExitRoute() {
    74| 		return h.enableRoutes(&route.Machine, ExitRouteV4.String(), ExitRouteV6.String())
    75| 	}
    76| 	return h.enableRoutes(&route.Machine, netip.Prefix(route.Prefix).String())
    77| }
    78| func (h *Headscale) DisableRoute(id uint64) error {
    79| 	route, err := h.GetRoute(id)
    80| 	if err != nil {
    81| 		return err
    82| 	}
    83| 	if !route.isExitRoute() {
    84| 		route.Enabled = false
    85| 		route.IsPrimary = false
    86| 		err = h.db.Save(route).Error
    87| 		if err != nil {
    88| 			return err
    89| 		}
    90| 		return h.handlePrimarySubnetFailover()
    91| 	}
    92| 	routes, err := h.GetMachineRoutes(&route.Machine)
    93| 	if err != nil {
    94| 		return err
    95| 	}
    96| 	for i := range routes {
    97| 		if routes[i].isExitRoute() {
    98| 			routes[i].Enabled = false
    99| 			routes[i].IsPrimary = false
   100| 			err = h.db.Save(&routes[i]).Error
   101| 			if err != nil {
   102| 				return err
   103| 			}
   104| 		}
   105| 	}
   106| 	return h.handlePrimarySubnetFailover()
   107| }
   108| func (h *Headscale) DeleteRoute(id uint64) error {
   109| 	route, err := h.GetRoute(id)
   110| 	if err != nil {
   111| 		return err
   112| 	}
   113| 	if !route.isExitRoute() {
   114| 		if err := h.db.Unscoped().Delete(&route).Error; err != nil {
   115| 			return err
   116| 		}
   117| 		return h.handlePrimarySubnetFailover()
   118| 	}
   119| 	routes, err := h.GetMachineRoutes(&route.Machine)
   120| 	if err != nil {
   121| 		return err
   122| 	}
   123| 	routesToDelete := []Route{}
   124| 	for _, r := range routes {
   125| 		if r.isExitRoute() {
   126| 			routesToDelete = append(routesToDelete, r)
   127| 		}
   128| 	}
   129| 	if err := h.db.Unscoped().Delete(&routesToDelete).Error; err != nil {
   130| 		return err
   131| 	}
   132| 	return h.handlePrimarySubnetFailover()
   133| }
   134| func (h *Headscale) DeleteMachineRoutes(m *Machine) error {
   135| 	routes, err := h.GetMachineRoutes(m)
   136| 	if err != nil {
   137| 		return err
   138| 	}
   139| 	for i := range routes {
   140| 		if err := h.db.Unscoped().Delete(&routes[i]).Error; err != nil {
   141| 			return err
   142| 		}
   143| 	}
   144| 	return h.handlePrimarySubnetFailover()
   145| }
   146| func (h *Headscale) isUniquePrefix(route Route) bool {
   147| 	var count int64
   148| 	h.db.
   149| 		Model(&Route{}).
   150| 		Where("prefix = ? AND machine_id != ? AND advertised = ? AND enabled = ?",
   151| 			route.Prefix,
   152| 			route.MachineID,
   153| 			true, true).Count(&count)
   154| 	return count == 0
   155| }
   156| func (h *Headscale) getPrimaryRoute(prefix netip.Prefix) (*Route, error) {
   157| 	var route Route
   158| 	err := h.db.
   159| 		Preload("Machine").
   160| 		Where("prefix = ? AND advertised = ? AND enabled = ? AND is_primary = ?", IPPrefix(prefix), true, true, true).
   161| 		First(&route).Error
   162| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   163| 		return nil, err
   164| 	}
   165| 	if errors.Is(err, gorm.ErrRecordNotFound) {
   166| 		return nil, gorm.ErrRecordNotFound
   167| 	}
   168| 	return &route, nil
   169| }
   170| func (h *Headscale) getMachinePrimaryRoutes(m *Machine) ([]Route, error) {
   171| 	var routes []Route
   172| 	err := h.db.
   173| 		Preload("Machine").
   174| 		Where("machine_id = ? AND advertised = ? AND enabled = ? AND is_primary = ?", m.ID, true, true, true).
   175| 		Find(&routes).Error
   176| 	if err != nil {
   177| 		return nil, err
   178| 	}
   179| 	return routes, nil
   180| }
   181| func (h *Headscale) processMachineRoutes(machine *Machine) error {
   182| 	currentRoutes := []Route{}
   183| 	err := h.db.Where("machine_id = ?", machine.ID).Find(&currentRoutes).Error
   184| 	if err != nil {
   185| 		return err
   186| 	}
   187| 	advertisedRoutes := map[netip.Prefix]bool{}
   188| 	for _, prefix := range machine.HostInfo.RoutableIPs {
   189| 		advertisedRoutes[prefix] = false
   190| 	}
   191| 	for pos, route := range currentRoutes {
   192| 		if _, ok := advertisedRoutes[netip.Prefix(route.Prefix)]; ok {
   193| 			if !route.Advertised {
   194| 				currentRoutes[pos].Advertised = true
   195| 				err := h.db.Save(&currentRoutes[pos]).Error
   196| 				if err != nil {
   197| 					return err
   198| 				}
   199| 			}
   200| 			advertisedRoutes[netip.Prefix(route.Prefix)] = true
   201| 		} else if route.Advertised {
   202| 			currentRoutes[pos].Advertised = false
   203| 			currentRoutes[pos].Enabled = false
   204| 			err := h.db.Save(&currentRoutes[pos]).Error
   205| 			if err != nil {
   206| 				return err
   207| 			}
   208| 		}
   209| 	}
   210| 	for prefix, exists := range advertisedRoutes {
   211| 		if !exists {
   212| 			route := Route{
   213| 				MachineID:  machine.ID,
   214| 				Prefix:     IPPrefix(prefix),
   215| 				Advertised: true,
   216| 				Enabled:    false,
   217| 			}
   218| 			err := h.db.Create(&route).Error
   219| 			if err != nil {
   220| 				return err
   221| 			}
   222| 		}
   223| 	}
   224| 	return nil
   225| }
   226| func (h *Headscale) handlePrimarySubnetFailover() error {
   227| 	var routes []Route
   228| 	err := h.db.
   229| 		Preload("Machine").
   230| 		Where("advertised = ? AND enabled = ?", true, true).
   231| 		Find(&routes).Error
   232| 	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   233| 		log.Error().Err(err).Msg("error getting routes")
   234| 	}
   235| 	routesChanged := false
   236| 	for pos, route := range routes {
   237| 		if route.isExitRoute() {
   238| 			continue
   239| 		}
   240| 		if !route.IsPrimary {
   241| 			_, err := h.getPrimaryRoute(netip.Prefix(route.Prefix))
   242| 			if h.isUniquePrefix(route) || errors.Is(err, gorm.ErrRecordNotFound) {
   243| 				log.Info().
   244| 					Str("prefix", netip.Prefix(route.Prefix).String()).
   245| 					Str("machine", route.Machine.GivenName).
   246| 					Msg("Setting primary route")
   247| 				routes[pos].IsPrimary = true
   248| 				err := h.db.Save(&routes[pos]).Error
   249| 				if err != nil {
   250| 					log.Error().Err(err).Msg("error marking route as primary")
   251| 					return err
   252| 				}
   253| 				routesChanged = true
   254| 				continue
   255| 			}
   256| 		}
   257| 		if route.IsPrimary {
   258| 			if route.Machine.isOnline() {
   259| 				continue
   260| 			}
   261| 			log.Info().
   262| 				Str("machine", route.Machine.Hostname).
   263| 				Str("prefix", netip.Prefix(route.Prefix).String()).
   264| 				Msgf("machine offline, finding a new primary subnet")
   265| 			var newPrimaryRoutes []Route
   266| 			err := h.db.
   267| 				Preload("Machine").
   268| 				Where("prefix = ? AND machine_id != ? AND advertised = ? AND enabled = ?",
   269| 					route.Prefix,
   270| 					route.MachineID,
   271| 					true, true).
   272| 				Find(&newPrimaryRoutes).Error
   273| 			if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
   274| 				log.Error().Err(err).Msg("error finding new primary route")
   275| 				return err
   276| 			}
   277| 			var newPrimaryRoute *Route
   278| 			for pos, r := range newPrimaryRoutes {
   279| 				if r.Machine.isOnline() {
   280| 					newPrimaryRoute = &newPrimaryRoutes[pos]
   281| 					break
   282| 				}
   283| 			}
   284| 			if newPrimaryRoute == nil {
   285| 				log.Warn().
   286| 					Str("machine", route.Machine.Hostname).
   287| 					Str("prefix", netip.Prefix(route.Prefix).String()).
   288| 					Msgf("no alternative primary route found")
   289| 				continue
   290| 			}
   291| 			log.Info().
   292| 				Str("old_machine", route.Machine.Hostname).
   293| 				Str("prefix", netip.Prefix(route.Prefix).String()).
   294| 				Str("new_machine", newPrimaryRoute.Machine.Hostname).
   295| 				Msgf("found new primary route")
   296| 			routes[pos].IsPrimary = false
   297| 			err = h.db.Save(&routes[pos]).Error
   298| 			if err != nil {
   299| 				log.Error().Err(err).Msg("error disabling old primary route")
   300| 				return err
   301| 			}
   302| 			newPrimaryRoute.IsPrimary = true
   303| 			err = h.db.Save(&newPrimaryRoute).Error
   304| 			if err != nil {
   305| 				log.Error().Err(err).Msg("error enabling new primary route")
   306| 				return err
   307| 			}
   308| 			routesChanged = true
   309| 		}
   310| 	}
   311| 	if routesChanged {
   312| 		h.setLastStateChangeToNow()
   313| 	}
   314| 	return nil
   315| }
   316| func (rs Routes) toProto() []*v1.Route {
   317| 	protoRoutes := []*v1.Route{}
   318| 	for _, route := range rs {
   319| 		protoRoute := v1.Route{
   320| 			Id:         uint64(route.ID),
   321| 			Machine:    route.Machine.toProto(),
   322| 			Prefix:     netip.Prefix(route.Prefix).String(),
   323| 			Advertised: route.Advertised,
   324| 			Enabled:    route.Enabled,
   325| 			IsPrimary:  route.IsPrimary,
   326| 			CreatedAt:  timestamppb.New(route.CreatedAt),
   327| 			UpdatedAt:  timestamppb.New(route.UpdatedAt),
   328| 		}
   329| 		if route.DeletedAt.Valid {
   330| 			protoRoute.DeletedAt = timestamppb.New(route.DeletedAt.Time)
   331| 		}
   332| 		protoRoutes = append(protoRoutes, &protoRoute)
   333| 	}
   334| 	return protoRoutes
   335| }


# ====================================================================
# FILE: hscontrol/users.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-242 ---
     1| package hscontrol
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"regexp"
     6| 	"strconv"
     7| 	"strings"
     8| 	"time"
     9| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    10| 	"github.com/rs/zerolog/log"
    11| 	"google.golang.org/protobuf/types/known/timestamppb"
    12| 	"gorm.io/gorm"
    13| 	"tailscale.com/tailcfg"
    14| )
    15| const (
    16| 	ErrUserExists        = Error("User already exists")
    17| 	ErrUserNotFound      = Error("User not found")
    18| 	ErrUserStillHasNodes = Error("User not empty: node(s) found")
    19| 	ErrInvalidUserName   = Error("Invalid user name")
    20| )
    21| const (
    22| 	labelHostnameLength = 63
    23| )
    24| var invalidCharsInUserRegex = regexp.MustCompile("[^a-z0-9-.]+")
    25| type User struct {
    26| 	gorm.Model
    27| 	Name string `gorm:"unique"`
    28| }
    29| func (h *Headscale) CreateUser(name string) (*User, error) {
    30| 	err := CheckForFQDNRules(name)
    31| 	if err != nil {
    32| 		return nil, err
    33| 	}
    34| 	user := User{}
    35| 	if err := h.db.Where("name = ?", name).First(&user).Error; err == nil {
    36| 		return nil, ErrUserExists
    37| 	}
    38| 	user.Name = name
    39| 	if err := h.db.Create(&user).Error; err != nil {
    40| 		log.Error().
    41| 			Str("func", "CreateUser").
    42| 			Err(err).
    43| 			Msg("Could not create row")
    44| 		return nil, err
    45| 	}
    46| 	return &user, nil
    47| }
    48| func (h *Headscale) DestroyUser(name string) error {
    49| 	user, err := h.GetUser(name)
    50| 	if err != nil {
    51| 		return ErrUserNotFound
    52| 	}
    53| 	machines, err := h.ListMachinesByUser(name)
    54| 	if err != nil {
    55| 		return err
    56| 	}
    57| 	if len(machines) > 0 {
    58| 		return ErrUserStillHasNodes
    59| 	}
    60| 	keys, err := h.ListPreAuthKeys(name)
    61| 	if err != nil {
    62| 		return err
    63| 	}
    64| 	for _, key := range keys {
    65| 		err = h.DestroyPreAuthKey(key)
    66| 		if err != nil {
    67| 			return err
    68| 		}
    69| 	}
    70| 	if result := h.db.Unscoped().Delete(&user); result.Error != nil {
    71| 		return result.Error
    72| 	}
    73| 	return nil
    74| }
    75| func (h *Headscale) RenameUser(oldName, newName string) error {
    76| 	var err error
    77| 	oldUser, err := h.GetUser(oldName)
    78| 	if err != nil {
    79| 		return err
    80| 	}
    81| 	err = CheckForFQDNRules(newName)
    82| 	if err != nil {
    83| 		return err
    84| 	}
    85| 	_, err = h.GetUser(newName)
    86| 	if err == nil {
    87| 		return ErrUserExists
    88| 	}
    89| 	if !errors.Is(err, ErrUserNotFound) {
    90| 		return err
    91| 	}
    92| 	oldUser.Name = newName
    93| 	if result := h.db.Save(&oldUser); result.Error != nil {
    94| 		return result.Error
    95| 	}
    96| 	return nil
    97| }
    98| func (h *Headscale) GetUser(name string) (*User, error) {
    99| 	user := User{}
   100| 	if result := h.db.First(&user, "name = ?", name); errors.Is(
   101| 		result.Error,
   102| 		gorm.ErrRecordNotFound,
   103| 	) {
   104| 		return nil, ErrUserNotFound
   105| 	}
   106| 	return &user, nil
   107| }
   108| func (h *Headscale) ListUsers() ([]User, error) {
   109| 	users := []User{}
   110| 	if err := h.db.Find(&users).Error; err != nil {
   111| 		return nil, err
   112| 	}
   113| 	return users, nil
   114| }
   115| func (h *Headscale) ListMachinesByUser(name string) ([]Machine, error) {
   116| 	err := CheckForFQDNRules(name)
   117| 	if err != nil {
   118| 		return nil, err
   119| 	}
   120| 	user, err := h.GetUser(name)
   121| 	if err != nil {
   122| 		return nil, err
   123| 	}
   124| 	machines := []Machine{}
   125| 	if err := h.db.Preload("AuthKey").Preload("AuthKey.User").Preload("User").Where(&Machine{UserID: user.ID}).Find(&machines).Error; err != nil {
   126| 		return nil, err
   127| 	}
   128| 	return machines, nil
   129| }
   130| func (h *Headscale) SetMachineUser(machine *Machine, username string) error {
   131| 	err := CheckForFQDNRules(username)
   132| 	if err != nil {
   133| 		return err
   134| 	}
   135| 	user, err := h.GetUser(username)
   136| 	if err != nil {
   137| 		return err
   138| 	}
   139| 	machine.User = *user
   140| 	if result := h.db.Save(&machine); result.Error != nil {
   141| 		return result.Error
   142| 	}
   143| 	return nil
   144| }
   145| func (n *User) toTailscaleUser() *tailcfg.User {
   146| 	user := tailcfg.User{
   147| 		ID:            tailcfg.UserID(n.ID),
   148| 		LoginName:     n.Name,
   149| 		DisplayName:   n.Name,
   150| 		ProfilePicURL: "",
   151| 		Domain:        "headscale.net",
   152| 		Logins:        []tailcfg.LoginID{},
   153| 		Created:       time.Time{},
   154| 	}
   155| 	return &user
   156| }
   157| func (n *User) toTailscaleLogin() *tailcfg.Login {
   158| 	login := tailcfg.Login{
   159| 		ID:            tailcfg.LoginID(n.ID),
   160| 		LoginName:     n.Name,
   161| 		DisplayName:   n.Name,
   162| 		ProfilePicURL: "",
   163| 		Domain:        "headscale.net",
   164| 	}
   165| 	return &login
   166| }
   167| func (h *Headscale) getMapResponseUserProfiles(
   168| 	machine Machine,
   169| 	peers Machines,
   170| ) []tailcfg.UserProfile {
   171| 	userMap := make(map[string]User)
   172| 	userMap[machine.User.Name] = machine.User
   173| 	for _, peer := range peers {
   174| 		userMap[peer.User.Name] = peer.User // not worth checking if already is there
   175| 	}
   176| 	profiles := []tailcfg.UserProfile{}
   177| 	for _, user := range userMap {
   178| 		displayName := user.Name
   179| 		if h.cfg.BaseDomain != "" {
   180| 			displayName = fmt.Sprintf("%s@%s", user.Name, h.cfg.BaseDomain)
   181| 		}
   182| 		profiles = append(profiles,
   183| 			tailcfg.UserProfile{
   184| 				ID:          tailcfg.UserID(user.ID),
   185| 				LoginName:   user.Name,
   186| 				DisplayName: displayName,
   187| 			})
   188| 	}
   189| 	return profiles
   190| }
   191| func (n *User) toProto() *v1.User {
   192| 	return &v1.User{
   193| 		Id:        strconv.FormatUint(uint64(n.ID), Base10),
   194| 		Name:      n.Name,
   195| 		CreatedAt: timestamppb.New(n.CreatedAt),
   196| 	}
   197| }
   198| func NormalizeToFQDNRules(name string, stripEmailDomain bool) (string, error) {
   199| 	name = strings.ToLower(name)
   200| 	name = strings.ReplaceAll(name, "'", "")
   201| 	atIdx := strings.Index(name, "@")
   202| 	if stripEmailDomain && atIdx > 0 {
   203| 		name = name[:atIdx]
   204| 	} else {
   205| 		name = strings.ReplaceAll(name, "@", ".")
   206| 	}
   207| 	name = invalidCharsInUserRegex.ReplaceAllString(name, "-")
   208| 	for _, elt := range strings.Split(name, ".") {
   209| 		if len(elt) > labelHostnameLength {
   210| 			return "", fmt.Errorf(
   211| 				"label %v is more than 63 chars: %w",
   212| 				elt,
   213| 				ErrInvalidUserName,
   214| 			)
   215| 		}
   216| 	}
   217| 	return name, nil
   218| }
   219| func CheckForFQDNRules(name string) error {
   220| 	if len(name) > labelHostnameLength {
   221| 		return fmt.Errorf(
   222| 			"DNS segment must not be over 63 chars. %v doesn't comply with this rule: %w",
   223| 			name,
   224| 			ErrInvalidUserName,
   225| 		)
   226| 	}
   227| 	if strings.ToLower(name) != name {
   228| 		return fmt.Errorf(
   229| 			"DNS segment should be lowercase. %v doesn't comply with this rule: %w",
   230| 			name,
   231| 			ErrInvalidUserName,
   232| 		)
   233| 	}
   234| 	if invalidCharsInUserRegex.MatchString(name) {
   235| 		return fmt.Errorf(
   236| 			"DNS segment should only be composed of lowercase ASCII letters numbers, hyphen and dots. %v doesn't comply with theses rules: %w",
   237| 			name,
   238| 			ErrInvalidUserName,
   239| 		)
   240| 	}
   241| 	return nil
   242| }


# ====================================================================
# FILE: hscontrol/utils.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-245 ---
     1| package hscontrol
     2| import (
     3| 	"context"
     4| 	"crypto/rand"
     5| 	"encoding/base64"
     6| 	"encoding/json"
     7| 	"fmt"
     8| 	"io/fs"
     9| 	"net"
    10| 	"net/netip"
    11| 	"os"
    12| 	"path/filepath"
    13| 	"reflect"
    14| 	"regexp"
    15| 	"strconv"
    16| 	"strings"
    17| 	"github.com/rs/zerolog/log"
    18| 	"github.com/spf13/viper"
    19| 	"go4.org/netipx"
    20| 	"tailscale.com/tailcfg"
    21| 	"tailscale.com/types/key"
    22| )
    23| const (
    24| 	ErrCannotDecryptResponse = Error("cannot decrypt response")
    25| 	ErrCouldNotAllocateIP    = Error("could not find any suitable IP")
    26| 	nodePublicHexPrefix = "nodekey:"
    27| 	machinePublicHexPrefix = "mkey:"
    28| 	discoPublicHexPrefix = "discokey:"
    29| 	privateHexPrefix = "privkey:"
    30| 	PermissionFallback = 0o700
    31| 	ZstdCompression = "zstd"
    32| )
    33| var NodePublicKeyRegex = regexp.MustCompile("nodekey:[a-fA-F0-9]+")
    34| func MachinePublicKeyStripPrefix(machineKey key.MachinePublic) string {
    35| 	return strings.TrimPrefix(machineKey.String(), machinePublicHexPrefix)
    36| }
    37| func NodePublicKeyStripPrefix(nodeKey key.NodePublic) string {
    38| 	return strings.TrimPrefix(nodeKey.String(), nodePublicHexPrefix)
    39| }
    40| func DiscoPublicKeyStripPrefix(discoKey key.DiscoPublic) string {
    41| 	return strings.TrimPrefix(discoKey.String(), discoPublicHexPrefix)
    42| }
    43| func MachinePublicKeyEnsurePrefix(machineKey string) string {
    44| 	if !strings.HasPrefix(machineKey, machinePublicHexPrefix) {
    45| 		return machinePublicHexPrefix + machineKey
    46| 	}
    47| 	return machineKey
    48| }
    49| func NodePublicKeyEnsurePrefix(nodeKey string) string {
    50| 	if !strings.HasPrefix(nodeKey, nodePublicHexPrefix) {
    51| 		return nodePublicHexPrefix + nodeKey
    52| 	}
    53| 	return nodeKey
    54| }
    55| func DiscoPublicKeyEnsurePrefix(discoKey string) string {
    56| 	if !strings.HasPrefix(discoKey, discoPublicHexPrefix) {
    57| 		return discoPublicHexPrefix + discoKey
    58| 	}
    59| 	return discoKey
    60| }
    61| func PrivateKeyEnsurePrefix(privateKey string) string {
    62| 	if !strings.HasPrefix(privateKey, privateHexPrefix) {
    63| 		return privateHexPrefix + privateKey
    64| 	}
    65| 	return privateKey
    66| }
    67| type Error string
    68| func (e Error) Error() string { return string(e) }
    69| func decode(
    70| 	msg []byte,
    71| 	output interface{},
    72| 	pubKey *key.MachinePublic,
    73| 	privKey *key.MachinePrivate,
    74| ) error {
    75| 	log.Trace().
    76| 		Str("pubkey", pubKey.ShortString()).
    77| 		Int("length", len(msg)).
    78| 		Msg("Trying to decrypt")
    79| 	decrypted, ok := privKey.OpenFrom(*pubKey, msg)
    80| 	if !ok {
    81| 		return ErrCannotDecryptResponse
    82| 	}
    83| 	if err := json.Unmarshal(decrypted, output); err != nil {
    84| 		return err
    85| 	}
    86| 	return nil
    87| }
    88| func (h *Headscale) getAvailableIPs() (MachineAddresses, error) {
    89| 	var ips MachineAddresses
    90| 	var err error
    91| 	ipPrefixes := h.cfg.IPPrefixes
    92| 	for _, ipPrefix := range ipPrefixes {
    93| 		var ip *netip.Addr
    94| 		ip, err = h.getAvailableIP(ipPrefix)
    95| 		if err != nil {
    96| 			return ips, err
    97| 		}
    98| 		ips = append(ips, *ip)
    99| 	}
   100| 	return ips, err
   101| }
   102| func GetIPPrefixEndpoints(na netip.Prefix) (netip.Addr, netip.Addr) {
   103| 	var network, broadcast netip.Addr
   104| 	ipRange := netipx.RangeOfPrefix(na)
   105| 	network = ipRange.From()
   106| 	broadcast = ipRange.To()
   107| 	return network, broadcast
   108| }
   109| func (h *Headscale) getAvailableIP(ipPrefix netip.Prefix) (*netip.Addr, error) {
   110| 	usedIps, err := h.getUsedIPs()
   111| 	if err != nil {
   112| 		return nil, err
   113| 	}
   114| 	ipPrefixNetworkAddress, ipPrefixBroadcastAddress := GetIPPrefixEndpoints(ipPrefix)
   115| 	ip := ipPrefixNetworkAddress.Next()
   116| 	for {
   117| 		if !ipPrefix.Contains(ip) {
   118| 			return nil, ErrCouldNotAllocateIP
   119| 		}
   120| 		switch {
   121| 		case ip.Compare(ipPrefixBroadcastAddress) == 0:
   122| 			fallthrough
   123| 		case usedIps.Contains(ip):
   124| 			fallthrough
   125| 		case ip == netip.Addr{} || ip.IsLoopback():
   126| 			ip = ip.Next()
   127| 			continue
   128| 		default:
   129| 			return &ip, nil
   130| 		}
   131| 	}
   132| }
   133| func (h *Headscale) getUsedIPs() (*netipx.IPSet, error) {
   134| 	var addressesSlices []string
   135| 	h.db.Model(&Machine{}).Pluck("ip_addresses", &addressesSlices)
   136| 	var ips netipx.IPSetBuilder
   137| 	for _, slice := range addressesSlices {
   138| 		var machineAddresses MachineAddresses
   139| 		err := machineAddresses.Scan(slice)
   140| 		if err != nil {
   141| 			return &netipx.IPSet{}, fmt.Errorf(
   142| 				"failed to read ip from database: %w",
   143| 				err,
   144| 			)
   145| 		}
   146| 		for _, ip := range machineAddresses {
   147| 			ips.Add(ip)
   148| 		}
   149| 	}
   150| 	ipSet, err := ips.IPSet()
   151| 	if err != nil {
   152| 		return &netipx.IPSet{}, fmt.Errorf(
   153| 			"failed to build IP Set: %w",
   154| 			err,
   155| 		)
   156| 	}
   157| 	return ipSet, nil
   158| }
   159| func tailNodesToString(nodes []*tailcfg.Node) string {
   160| 	temp := make([]string, len(nodes))
   161| 	for index, node := range nodes {
   162| 		temp[index] = node.Name
   163| 	}
   164| 	return fmt.Sprintf("[ %s ](%d)", strings.Join(temp, ", "), len(temp))
   165| }
   166| func tailMapResponseToString(resp tailcfg.MapResponse) string {
   167| 	return fmt.Sprintf(
   168| 		"{ Node: %s, Peers: %s }",
   169| 		resp.Node.Name,
   170| 		tailNodesToString(resp.Peers),
   171| 	)
   172| }
   173| func GrpcSocketDialer(ctx context.Context, addr string) (net.Conn, error) {
   174| 	var d net.Dialer
   175| 	return d.DialContext(ctx, "unix", addr)
   176| }
   177| func stringToIPPrefix(prefixes []string) ([]netip.Prefix, error) {
   178| 	result := make([]netip.Prefix, len(prefixes))
   179| 	for index, prefixStr := range prefixes {
   180| 		prefix, err := netip.ParsePrefix(prefixStr)
   181| 		if err != nil {
   182| 			return []netip.Prefix{}, err
   183| 		}
   184| 		result[index] = prefix
   185| 	}
   186| 	return result, nil
   187| }
   188| func contains[T string | netip.Prefix](ts []T, t T) bool {
   189| 	for _, v := range ts {
   190| 		if reflect.DeepEqual(v, t) {
   191| 			return true
   192| 		}
   193| 	}
   194| 	return false
   195| }
   196| func GenerateRandomBytes(n int) ([]byte, error) {
   197| 	bytes := make([]byte, n)
   198| 	if _, err := rand.Read(bytes); err != nil {
   199| 		return nil, err
   200| 	}
   201| 	return bytes, nil
   202| }
   203| func GenerateRandomStringURLSafe(n int) (string, error) {
   204| 	b, err := GenerateRandomBytes(n)
   205| 	return base64.RawURLEncoding.EncodeToString(b), err
   206| }
   207| func GenerateRandomStringDNSSafe(size int) (string, error) {
   208| 	var str string
   209| 	var err error
   210| 	for len(str) < size {
   211| 		str, err = GenerateRandomStringURLSafe(size)
   212| 		if err != nil {
   213| 			return "", err
   214| 		}
   215| 		str = strings.ToLower(
   216| 			strings.ReplaceAll(strings.ReplaceAll(str, "_", ""), "-", ""),
   217| 		)
   218| 	}
   219| 	return str[:size], nil
   220| }
   221| func IsStringInSlice(slice []string, str string) bool {
   222| 	for _, s := range slice {
   223| 		if s == str {
   224| 			return true
   225| 		}
   226| 	}
   227| 	return false
   228| }
   229| func AbsolutePathFromConfigPath(path string) string {
   230| 	if (path != "") && !strings.HasPrefix(path, string(os.PathSeparator)) {
   231| 		dir, _ := filepath.Split(viper.ConfigFileUsed())
   232| 		if dir != "" {
   233| 			path = filepath.Join(dir, path)
   234| 		}
   235| 	}
   236| 	return path
   237| }
   238| func GetFileMode(key string) fs.FileMode {
   239| 	modeStr := viper.GetString(key)
   240| 	mode, err := strconv.ParseUint(modeStr, Base8, BitSize64)
   241| 	if err != nil {
   242| 		return PermissionFallback
   243| 	}
   244| 	return fs.FileMode(mode)
   245| }


# ====================================================================
# FILE: integration/control.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| package integration
     2| import (
     3| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
     4| 	"github.com/ory/dockertest/v3"
     5| )
     6| type ControlServer interface {
     7| 	Shutdown() error
     8| 	SaveLog(string) error
     9| 	SaveProfile(string) error
    10| 	Execute(command []string) (string, error)
    11| 	ConnectToNetwork(network *dockertest.Network) error
    12| 	GetHealthEndpoint() string
    13| 	GetEndpoint() string
    14| 	WaitForReady() error
    15| 	CreateUser(user string) error
    16| 	CreateAuthKey(user string, reusable bool, ephemeral bool) (*v1.PreAuthKey, error)
    17| 	ListMachinesInUser(user string) ([]*v1.Machine, error)
    18| 	GetCert() []byte
    19| 	GetHostname() string
    20| 	GetIP() string
    21| }


# ====================================================================
# FILE: integration/hsic/config.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| package hsic
     2| func DefaultConfigYAML() string {
     3| 	yaml := `
     4| log:
     5|   level: trace
     6| acl_policy_path: ""
     7| db_type: sqlite3
     8| db_path: /tmp/integration_test_db.sqlite3
     9| ephemeral_node_inactivity_timeout: 30m
    10| node_update_check_interval: 10s
    11| ip_prefixes:
    12|   - fd7a:115c:a1e0::/48
    13|   - 100.64.0.0/10
    14| dns_config:
    15|   base_domain: headscale.net
    16|   magic_dns: true
    17|   domains: []
    18|   nameservers:
    19|     - 127.0.0.11
    20|     - 1.1.1.1
    21| private_key_path: /tmp/private.key
    22| noise:
    23|   private_key_path: /tmp/noise_private.key
    24| listen_addr: 0.0.0.0:8080
    25| metrics_listen_addr: 127.0.0.1:9090
    26| server_url: http://headscale:8080
    27| derp:
    28|   urls:
    29|     - https://controlplane.tailscale.com/derpmap/default
    30|   auto_update_enabled: false
    31|   update_frequency: 1m
    32| `
    33| 	return yaml
    34| }
    35| func MinimumConfigYAML() string {
    36| 	return `
    37| private_key_path: /tmp/private.key
    38| noise:
    39|   private_key_path: /tmp/noise_private.key
    40| `
    41| }
    42| func DefaultConfigEnv() map[string]string {
    43| 	return map[string]string{
    44| 		"HEADSCALE_LOG_LEVEL":                         "trace",
    45| 		"HEADSCALE_ACL_POLICY_PATH":                   "",
    46| 		"HEADSCALE_DB_TYPE":                           "sqlite3",
    47| 		"HEADSCALE_DB_PATH":                           "/tmp/integration_test_db.sqlite3",
    48| 		"HEADSCALE_EPHEMERAL_NODE_INACTIVITY_TIMEOUT": "30m",
    49| 		"HEADSCALE_NODE_UPDATE_CHECK_INTERVAL":        "10s",
    50| 		"HEADSCALE_IP_PREFIXES":                       "fd7a:115c:a1e0::/48 100.64.0.0/10",
    51| 		"HEADSCALE_DNS_CONFIG_BASE_DOMAIN":            "headscale.net",
    52| 		"HEADSCALE_DNS_CONFIG_MAGIC_DNS":              "true",
    53| 		"HEADSCALE_DNS_CONFIG_DOMAINS":                "",
    54| 		"HEADSCALE_DNS_CONFIG_NAMESERVERS":            "127.0.0.11 1.1.1.1",
    55| 		"HEADSCALE_PRIVATE_KEY_PATH":                  "/tmp/private.key",
    56| 		"HEADSCALE_NOISE_PRIVATE_KEY_PATH":            "/tmp/noise_private.key",
    57| 		"HEADSCALE_LISTEN_ADDR":                       "0.0.0.0:8080",
    58| 		"HEADSCALE_METRICS_LISTEN_ADDR":               "127.0.0.1:9090",
    59| 		"HEADSCALE_SERVER_URL":                        "http://headscale:8080",
    60| 		"HEADSCALE_DERP_URLS":                         "https://controlplane.tailscale.com/derpmap/default",
    61| 		"HEADSCALE_DERP_AUTO_UPDATE_ENABLED":          "false",
    62| 		"HEADSCALE_DERP_UPDATE_FREQUENCY":             "1m",
    63| 	}
    64| }


# ====================================================================
# FILE: integration/hsic/hsic.go
# Total hunks: 10
# ====================================================================
# --- HUNK 1: Lines 1-187 ---
     1| package hsic
     2| import (
     3| 	"bytes"
     4| 	"crypto/rand"
     5| 	"crypto/rsa"
     6| 	"crypto/tls"
     7| 	"crypto/x509"
     8| 	"crypto/x509/pkix"
     9| 	"encoding/json"
    10| 	"encoding/pem"
    11| 	"errors"
    12| 	"fmt"
    13| 	"log"
    14| 	"math/big"
    15| 	"net"
    16| 	"net/http"
    17| 	"net/url"
    18| 	"os"
    19| 	"path"
    20| 	"strings"
    21| 	"time"
    22| 	"github.com/davecgh/go-spew/spew"
    23| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    24| 	"github.com/juanfont/headscale/hscontrol"
    25| 	"github.com/juanfont/headscale/integration/dockertestutil"
    26| 	"github.com/juanfont/headscale/integration/integrationutil"
    27| 	"github.com/ory/dockertest/v3"
    28| 	"github.com/ory/dockertest/v3/docker"
    29| )
    30| const (
    31| 	hsicHashLength       = 6
    32| 	dockerContextPath    = "../."
    33| 	aclPolicyPath        = "/etc/headscale/acl.hujson"
    34| 	tlsCertPath          = "/etc/headscale/tls.cert"
    35| 	tlsKeyPath           = "/etc/headscale/tls.key"
    36| 	headscaleDefaultPort = 8080
    37| )
    38| var errHeadscaleStatusCodeNotOk = errors.New("headscale status code not ok")
    39| type fileInContainer struct {
    40| 	path     string
    41| 	contents []byte
    42| }
    43| type HeadscaleInContainer struct {
    44| 	hostname string
    45| 	pool      *dockertest.Pool
    46| 	container *dockertest.Resource
    47| 	network   *dockertest.Network
    48| 	port             int
    49| 	extraPorts       []string
    50| 	hostPortBindings map[string][]string
    51| 	aclPolicy        *hscontrol.ACLPolicy
    52| 	env              map[string]string
    53| 	tlsCert          []byte
    54| 	tlsKey           []byte
    55| 	filesInContainer []fileInContainer
    56| }
    57| type Option = func(c *HeadscaleInContainer)
    58| func WithACLPolicy(acl *hscontrol.ACLPolicy) Option {
    59| 	return func(hsic *HeadscaleInContainer) {
    60| 		hsic.env["HEADSCALE_ACL_POLICY_PATH"] = aclPolicyPath
    61| 		hsic.aclPolicy = acl
    62| 	}
    63| }
    64| func WithTLS() Option {
    65| 	return func(hsic *HeadscaleInContainer) {
    66| 		cert, key, err := createCertificate(hsic.hostname)
    67| 		if err != nil {
    68| 			log.Fatalf("failed to create certificates for headscale test: %s", err)
    69| 		}
    70| 		hsic.env["HEADSCALE_TLS_CERT_PATH"] = tlsCertPath
    71| 		hsic.env["HEADSCALE_TLS_KEY_PATH"] = tlsKeyPath
    72| 		hsic.tlsCert = cert
    73| 		hsic.tlsKey = key
    74| 	}
    75| }
    76| func WithConfigEnv(configEnv map[string]string) Option {
    77| 	return func(hsic *HeadscaleInContainer) {
    78| 		for key, value := range configEnv {
    79| 			hsic.env[key] = value
    80| 		}
    81| 	}
    82| }
    83| func WithPort(port int) Option {
    84| 	return func(hsic *HeadscaleInContainer) {
    85| 		hsic.port = port
    86| 	}
    87| }
    88| func WithExtraPorts(ports []string) Option {
    89| 	return func(hsic *HeadscaleInContainer) {
    90| 		hsic.extraPorts = ports
    91| 	}
    92| }
    93| func WithHostPortBindings(bindings map[string][]string) Option {
    94| 	return func(hsic *HeadscaleInContainer) {
    95| 		hsic.hostPortBindings = bindings
    96| 	}
    97| }
    98| func WithTestName(testName string) Option {
    99| 	return func(hsic *HeadscaleInContainer) {
   100| 		hash, _ := hscontrol.GenerateRandomStringDNSSafe(hsicHashLength)
   101| 		hostname := fmt.Sprintf("hs-%s-%s", testName, hash)
   102| 		hsic.hostname = hostname
   103| 	}
   104| }
   105| func WithHostnameAsServerURL() Option {
   106| 	return func(hsic *HeadscaleInContainer) {
   107| 		hsic.env["HEADSCALE_SERVER_URL"] = fmt.Sprintf("http://%s",
   108| 			net.JoinHostPort(hsic.GetHostname(),
   109| 				fmt.Sprintf("%d", hsic.port)),
   110| 		)
   111| 	}
   112| }
   113| func WithFileInContainer(path string, contents []byte) Option {
   114| 	return func(hsic *HeadscaleInContainer) {
   115| 		hsic.filesInContainer = append(hsic.filesInContainer,
   116| 			fileInContainer{
   117| 				path:     path,
   118| 				contents: contents,
   119| 			})
   120| 	}
   121| }
   122| func New(
   123| 	pool *dockertest.Pool,
   124| 	network *dockertest.Network,
   125| 	opts ...Option,
   126| ) (*HeadscaleInContainer, error) {
   127| 	hash, err := hscontrol.GenerateRandomStringDNSSafe(hsicHashLength)
   128| 	if err != nil {
   129| 		return nil, err
   130| 	}
   131| 	hostname := fmt.Sprintf("hs-%s", hash)
   132| 	hsic := &HeadscaleInContainer{
   133| 		hostname: hostname,
   134| 		port:     headscaleDefaultPort,
   135| 		pool:    pool,
   136| 		network: network,
   137| 		env:              DefaultConfigEnv(),
   138| 		filesInContainer: []fileInContainer{},
   139| 	}
   140| 	for _, opt := range opts {
   141| 		opt(hsic)
   142| 	}
   143| 	log.Println("NAME: ", hsic.hostname)
   144| 	portProto := fmt.Sprintf("%d/tcp", hsic.port)
   145| 	serverURL, err := url.Parse(hsic.env["HEADSCALE_SERVER_URL"])
   146| 	if err != nil {
   147| 		return nil, err
   148| 	}
   149| 	if len(hsic.tlsCert) != 0 && len(hsic.tlsKey) != 0 {
   150| 		serverURL.Scheme = "https"
   151| 		hsic.env["HEADSCALE_SERVER_URL"] = serverURL.String()
   152| 	}
   153| 	headscaleBuildOptions := &dockertest.BuildOptions{
   154| 		Dockerfile: "Dockerfile.debug",
   155| 		ContextDir: dockerContextPath,
   156| 	}
   157| 	env := []string{
   158| 		"HEADSCALE_PROFILING_ENABLED=1",
   159| 		"HEADSCALE_PROFILING_PATH=/tmp/profile",
   160| 	}
   161| 	for key, value := range hsic.env {
   162| 		env = append(env, fmt.Sprintf("%s=%s", key, value))
   163| 	}
   164| 	log.Printf("ENV: \n%s", spew.Sdump(hsic.env))
   165| 	runOptions := &dockertest.RunOptions{
   166| 		Name:         hsic.hostname,
   167| 		ExposedPorts: append([]string{portProto}, hsic.extraPorts...),
   168| 		Networks:     []*dockertest.Network{network},
   169| 		Entrypoint: []string{"/bin/bash", "-c", "/bin/sleep 3 ; headscale serve ; /bin/sleep 30"},
   170| 		Env:        env,
   171| 	}
   172| 	if len(hsic.hostPortBindings) > 0 {
   173| 		runOptions.PortBindings = map[docker.Port][]docker.PortBinding{}
   174| 		for port, hostPorts := range hsic.hostPortBindings {
   175| 			runOptions.PortBindings[docker.Port(port)] = []docker.PortBinding{}
   176| 			for _, hostPort := range hostPorts {
   177| 				runOptions.PortBindings[docker.Port(port)] = append(
   178| 					runOptions.PortBindings[docker.Port(port)],
   179| 					docker.PortBinding{HostPort: hostPort})
   180| 			}
   181| 		}
   182| 	}
   183| 	err = pool.RemoveContainerByName(hsic.hostname)
   184| 	if err != nil {
   185| 		return nil, err
   186| 	}
   187| 	container, err := pool.BuildAndRunWithBuildOptions(

# --- HUNK 2: Lines 216-339 ---
   216| 			return nil, fmt.Errorf("failed to write TLS certificate to container: %w", err)
   217| 		}
   218| 		err = hsic.WriteFile(tlsKeyPath, hsic.tlsKey)
   219| 		if err != nil {
   220| 			return nil, fmt.Errorf("failed to write TLS key to container: %w", err)
   221| 		}
   222| 	}
   223| 	for _, f := range hsic.filesInContainer {
   224| 		if err := hsic.WriteFile(f.path, f.contents); err != nil {
   225| 			return nil, fmt.Errorf("failed to write %q: %w", f.path, err)
   226| 		}
   227| 	}
   228| 	return hsic, nil
   229| }
   230| func (t *HeadscaleInContainer) ConnectToNetwork(network *dockertest.Network) error {
   231| 	return t.container.ConnectToNetwork(network)
   232| }
   233| func (t *HeadscaleInContainer) hasTLS() bool {
   234| 	return len(t.tlsCert) != 0 && len(t.tlsKey) != 0
   235| }
   236| func (t *HeadscaleInContainer) Shutdown() error {
   237| 	err := t.SaveLog("/tmp/control")
   238| 	if err != nil {
   239| 		log.Printf(
   240| 			"Failed to save log from control: %s",
   241| 			fmt.Errorf("failed to save log from control: %w", err),
   242| 		)
   243| 	}
   244| 	err = t.SendInterrupt()
   245| 	if err != nil {
   246| 		log.Printf(
   247| 			"Failed to send graceful interrupt to control: %s",
   248| 			fmt.Errorf("failed to send graceful interrupt to control: %w", err),
   249| 		)
   250| 	}
   251| 	err = t.SaveProfile("/tmp/control")
   252| 	if err != nil {
   253| 		log.Printf(
   254| 			"Failed to save profile from control: %s",
   255| 			fmt.Errorf("failed to save profile from control: %w", err),
   256| 		)
   257| 	}
   258| 	return t.pool.Purge(t.container)
   259| }
   260| func (t *HeadscaleInContainer) SaveLog(path string) error {
   261| 	return dockertestutil.SaveLog(t.pool, t.container, path)
   262| }
   263| func (t *HeadscaleInContainer) SaveProfile(savePath string) error {
   264| 	tarFile, err := t.FetchPath("/tmp/profile")
   265| 	if err != nil {
   266| 		return err
   267| 	}
   268| 	err = os.WriteFile(
   269| 		path.Join(savePath, t.hostname+".pprof.tar"),
   270| 		tarFile,
   271| 		os.ModePerm,
   272| 	)
   273| 	if err != nil {
   274| 		return err
   275| 	}
   276| 	return nil
   277| }
   278| func (t *HeadscaleInContainer) Execute(
   279| 	command []string,
   280| ) (string, error) {
   281| 	stdout, stderr, err := dockertestutil.ExecuteCommand(
   282| 		t.container,
   283| 		command,
   284| 		[]string{},
   285| 	)
   286| 	if err != nil {
   287| 		log.Printf("command stderr: %s\n", stderr)
   288| 		if stdout != "" {
   289| 			log.Printf("command stdout: %s\n", stdout)
   290| 		}
   291| 		return "", err
   292| 	}
   293| 	return stdout, nil
   294| }
   295| func (t *HeadscaleInContainer) GetIP() string {
   296| 	return t.container.GetIPInNetwork(t.network)
   297| }
   298| func (t *HeadscaleInContainer) GetPort() string {
   299| 	return fmt.Sprintf("%d", t.port)
   300| }
   301| func (t *HeadscaleInContainer) GetHealthEndpoint() string {
   302| 	return fmt.Sprintf("%s/health", t.GetEndpoint())
   303| }
   304| func (t *HeadscaleInContainer) GetEndpoint() string {
   305| 	hostEndpoint := fmt.Sprintf("%s:%d",
   306| 		t.GetIP(),
   307| 		t.port)
   308| 	if t.hasTLS() {
   309| 		return fmt.Sprintf("https://%s", hostEndpoint)
   310| 	}
   311| 	return fmt.Sprintf("http://%s", hostEndpoint)
   312| }
   313| func (t *HeadscaleInContainer) GetCert() []byte {
   314| 	return t.tlsCert
   315| }
   316| func (t *HeadscaleInContainer) GetHostname() string {
   317| 	return t.hostname
   318| }
   319| func (t *HeadscaleInContainer) WaitForReady() error {
   320| 	url := t.GetHealthEndpoint()
   321| 	log.Printf("waiting for headscale to be ready at %s", url)
   322| 	client := &http.Client{}
   323| 	if t.hasTLS() {
   324| 		insecureTransport := http.DefaultTransport.(*http.Transport).Clone()      //nolint
   325| 		insecureTransport.TLSClientConfig = &tls.Config{InsecureSkipVerify: true} //nolint
   326| 		client = &http.Client{Transport: insecureTransport}
   327| 	}
   328| 	return t.pool.Retry(func() error {
   329| 		resp, err := client.Get(url) //nolint
   330| 		if err != nil {
   331| 			return fmt.Errorf("headscale is not ready: %w", err)
   332| 		}
   333| 		if resp.StatusCode != http.StatusOK {
   334| 			return errHeadscaleStatusCodeNotOk
   335| 		}
   336| 		return nil
   337| 	})
   338| }
   339| func (t *HeadscaleInContainer) CreateUser(

# --- HUNK 3: Lines 370-455 ---
   370| 		command = append(command, "--reusable")
   371| 	}
   372| 	if ephemeral {
   373| 		command = append(command, "--ephemeral")
   374| 	}
   375| 	result, _, err := dockertestutil.ExecuteCommand(
   376| 		t.container,
   377| 		command,
   378| 		[]string{},
   379| 	)
   380| 	if err != nil {
   381| 		return nil, fmt.Errorf("failed to execute create auth key command: %w", err)
   382| 	}
   383| 	var preAuthKey v1.PreAuthKey
   384| 	err = json.Unmarshal([]byte(result), &preAuthKey)
   385| 	if err != nil {
   386| 		return nil, fmt.Errorf("failed to unmarshal auth key: %w", err)
   387| 	}
   388| 	return &preAuthKey, nil
   389| }
   390| func (t *HeadscaleInContainer) ListMachinesInUser(
   391| 	user string,
   392| ) ([]*v1.Machine, error) {
   393| 	command := []string{"headscale", "--user", user, "nodes", "list", "--output", "json"}
   394| 	result, _, err := dockertestutil.ExecuteCommand(
   395| 		t.container,
   396| 		command,
   397| 		[]string{},
   398| 	)
   399| 	if err != nil {
   400| 		return nil, fmt.Errorf("failed to execute list node command: %w", err)
   401| 	}
   402| 	var nodes []*v1.Machine
   403| 	err = json.Unmarshal([]byte(result), &nodes)
   404| 	if err != nil {
   405| 		return nil, fmt.Errorf("failed to unmarshal nodes: %w", err)
   406| 	}
   407| 	return nodes, nil
   408| }
   409| func (t *HeadscaleInContainer) WriteFile(path string, data []byte) error {
   410| 	return integrationutil.WriteFileToContainer(t.pool, t.container, path, data)
   411| }
   412| func (t *HeadscaleInContainer) FetchPath(path string) ([]byte, error) {
   413| 	return integrationutil.FetchPathFromContainer(t.pool, t.container, path)
   414| }
   415| func (t *HeadscaleInContainer) SendInterrupt() error {
   416| 	pid, err := t.Execute([]string{"pidof", "headscale"})
   417| 	if err != nil {
   418| 		return err
   419| 	}
   420| 	_, err = t.Execute([]string{"kill", "-2", strings.Trim(pid, "'\n")})
   421| 	if err != nil {
   422| 		return err
   423| 	}
   424| 	return nil
   425| }
   426| func createCertificate(hostname string) ([]byte, []byte, error) {
   427| 	ca := &x509.Certificate{
   428| 		SerialNumber: big.NewInt(2019),
   429| 		Subject: pkix.Name{
   430| 			Organization: []string{"Headscale testing INC"},
   431| 			Country:      []string{"NL"},
   432| 			Locality:     []string{"Leiden"},
   433| 		},
   434| 		NotBefore: time.Now(),
   435| 		NotAfter:  time.Now().Add(60 * time.Minute),
   436| 		IsCA:      true,
   437| 		ExtKeyUsage: []x509.ExtKeyUsage{
   438| 			x509.ExtKeyUsageClientAuth,
   439| 			x509.ExtKeyUsageServerAuth,
   440| 		},
   441| 		KeyUsage:              x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
   442| 		BasicConstraintsValid: true,
   443| 	}
   444| 	caPrivKey, err := rsa.GenerateKey(rand.Reader, 4096)
   445| 	if err != nil {
   446| 		return nil, nil, err
   447| 	}
   448| 	cert := &x509.Certificate{
   449| 		SerialNumber: big.NewInt(1658),
   450| 		Subject: pkix.Name{
   451| 			CommonName:   hostname,
   452| 			Organization: []string{"Headscale testing INC"},
   453| 			Country:      []string{"NL"},
   454| 			Locality:     []string{"Leiden"},
   455| 		},


# ====================================================================
# FILE: integration/scenario.go
# Total hunks: 4
# ====================================================================
# --- HUNK 1: Lines 1-276 ---
     1| package integration
     2| import (
     3| 	"errors"
     4| 	"fmt"
     5| 	"log"
     6| 	"net/netip"
     7| 	"os"
     8| 	"sync"
     9| 	"time"
    10| 	v1 "github.com/juanfont/headscale/gen/go/headscale/v1"
    11| 	"github.com/juanfont/headscale/hscontrol"
    12| 	"github.com/juanfont/headscale/integration/dockertestutil"
    13| 	"github.com/juanfont/headscale/integration/hsic"
    14| 	"github.com/juanfont/headscale/integration/tsic"
    15| 	"github.com/ory/dockertest/v3"
    16| 	"github.com/puzpuzpuz/xsync/v2"
    17| )
    18| const (
    19| 	scenarioHashLength = 6
    20| 	maxWait            = 60 * time.Second
    21| )
    22| var (
    23| 	errNoHeadscaleAvailable = errors.New("no headscale available")
    24| 	errNoUserAvailable      = errors.New("no user available")
    25| 	errNoClientFound        = errors.New("client not found")
    26| 	tailscaleVersions2021 = []string{
    27| 		"head",
    28| 		"unstable",
    29| 		"1.40.0",
    30| 		"1.38.4",
    31| 		"1.36.2",
    32| 		"1.34.2",
    33| 		"1.32.3",
    34| 		"1.30.2",
    35| 	}
    36| 	tailscaleVersions2019 = []string{
    37| 		"1.28.0",
    38| 		"1.26.2",
    39| 		"1.24.2",
    40| 		"1.22.2",
    41| 		"1.20.4",
    42| 	}
    43| 	TailscaleVersions = append(
    44| 		tailscaleVersions2021,
    45| 		tailscaleVersions2019...,
    46| 	)
    47| )
    48| type User struct {
    49| 	Clients map[string]TailscaleClient
    50| 	createWaitGroup sync.WaitGroup
    51| 	joinWaitGroup   sync.WaitGroup
    52| 	syncWaitGroup   sync.WaitGroup
    53| }
    54| type Scenario struct {
    55| 	controlServers *xsync.MapOf[string, ControlServer]
    56| 	users map[string]*User
    57| 	pool    *dockertest.Pool
    58| 	network *dockertest.Network
    59| 	headscaleLock sync.Mutex
    60| }
    61| func NewScenario() (*Scenario, error) {
    62| 	hash, err := hscontrol.GenerateRandomStringDNSSafe(scenarioHashLength)
    63| 	if err != nil {
    64| 		return nil, err
    65| 	}
    66| 	pool, err := dockertest.NewPool("")
    67| 	if err != nil {
    68| 		return nil, fmt.Errorf("could not connect to docker: %w", err)
    69| 	}
    70| 	pool.MaxWait = maxWait
    71| 	networkName := fmt.Sprintf("hs-%s", hash)
    72| 	if overrideNetworkName := os.Getenv("HEADSCALE_TEST_NETWORK_NAME"); overrideNetworkName != "" {
    73| 		networkName = overrideNetworkName
    74| 	}
    75| 	network, err := dockertestutil.GetFirstOrCreateNetwork(pool, networkName)
    76| 	if err != nil {
    77| 		return nil, fmt.Errorf("failed to create or get network: %w", err)
    78| 	}
    79| 	err = dockertestutil.AddContainerToNetwork(pool, network, "headscale-test-suite")
    80| 	if err != nil {
    81| 		return nil, fmt.Errorf("failed to add test suite container to network: %w", err)
    82| 	}
    83| 	return &Scenario{
    84| 		controlServers: xsync.NewMapOf[ControlServer](),
    85| 		users:          make(map[string]*User),
    86| 		pool:    pool,
    87| 		network: network,
    88| 	}, nil
    89| }
    90| func (s *Scenario) Shutdown() error {
    91| 	s.controlServers.Range(func(_ string, control ControlServer) bool {
    92| 		err := control.Shutdown()
    93| 		if err != nil {
    94| 			log.Printf(
    95| 				"Failed to shut down control: %s",
    96| 				fmt.Errorf("failed to tear down control: %w", err),
    97| 			)
    98| 		}
    99| 		return true
   100| 	})
   101| 	for userName, user := range s.users {
   102| 		for _, client := range user.Clients {
   103| 			log.Printf("removing client %s in user %s", client.Hostname(), userName)
   104| 			err := client.Shutdown()
   105| 			if err != nil {
   106| 				return fmt.Errorf("failed to tear down client: %w", err)
   107| 			}
   108| 		}
   109| 	}
   110| 	if err := s.pool.RemoveNetwork(s.network); err != nil {
   111| 		return fmt.Errorf("failed to remove network: %w", err)
   112| 	}
   113| 	return nil
   114| }
   115| func (s *Scenario) Users() []string {
   116| 	users := make([]string, 0)
   117| 	for user := range s.users {
   118| 		users = append(users, user)
   119| 	}
   120| 	return users
   121| }
   122| func (s *Scenario) Headscale(opts ...hsic.Option) (ControlServer, error) {
   123| 	s.headscaleLock.Lock()
   124| 	defer s.headscaleLock.Unlock()
   125| 	if headscale, ok := s.controlServers.Load("headscale"); ok {
   126| 		return headscale, nil
   127| 	}
   128| 	headscale, err := hsic.New(s.pool, s.network, opts...)
   129| 	if err != nil {
   130| 		return nil, fmt.Errorf("failed to create headscale container: %w", err)
   131| 	}
   132| 	err = headscale.WaitForReady()
   133| 	if err != nil {
   134| 		return nil, fmt.Errorf("failed reach headscale container: %w", err)
   135| 	}
   136| 	s.controlServers.Store("headscale", headscale)
   137| 	return headscale, nil
   138| }
   139| func (s *Scenario) CreatePreAuthKey(
   140| 	user string,
   141| 	reusable bool,
   142| 	ephemeral bool,
   143| ) (*v1.PreAuthKey, error) {
   144| 	if headscale, err := s.Headscale(); err == nil {
   145| 		key, err := headscale.CreateAuthKey(user, reusable, ephemeral)
   146| 		if err != nil {
   147| 			return nil, fmt.Errorf("failed to create user: %w", err)
   148| 		}
   149| 		return key, nil
   150| 	}
   151| 	return nil, fmt.Errorf("failed to create user: %w", errNoHeadscaleAvailable)
   152| }
   153| func (s *Scenario) CreateUser(user string) error {
   154| 	if headscale, err := s.Headscale(); err == nil {
   155| 		err := headscale.CreateUser(user)
   156| 		if err != nil {
   157| 			return fmt.Errorf("failed to create user: %w", err)
   158| 		}
   159| 		s.users[user] = &User{
   160| 			Clients: make(map[string]TailscaleClient),
   161| 		}
   162| 		return nil
   163| 	}
   164| 	return fmt.Errorf("failed to create user: %w", errNoHeadscaleAvailable)
   165| }
   166| func (s *Scenario) CreateTailscaleNodesInUser(
   167| 	userStr string,
   168| 	requestedVersion string,
   169| 	count int,
   170| 	opts ...tsic.Option,
   171| ) error {
   172| 	if user, ok := s.users[userStr]; ok {
   173| 		for i := 0; i < count; i++ {
   174| 			version := requestedVersion
   175| 			if requestedVersion == "all" {
   176| 				version = TailscaleVersions[i%len(TailscaleVersions)]
   177| 			}
   178| 			headscale, err := s.Headscale()
   179| 			if err != nil {
   180| 				return fmt.Errorf("failed to create tailscale node (version: %s): %w", version, err)
   181| 			}
   182| 			cert := headscale.GetCert()
   183| 			hostname := headscale.GetHostname()
   184| 			user.createWaitGroup.Add(1)
   185| 			opts = append(opts,
   186| 				tsic.WithHeadscaleTLS(cert),
   187| 				tsic.WithHeadscaleName(hostname),
   188| 			)
   189| 			go func() {
   190| 				defer user.createWaitGroup.Done()
   191| 				tsClient, err := tsic.New(
   192| 					s.pool,
   193| 					version,
   194| 					s.network,
   195| 					opts...,
   196| 				)
   197| 				if err != nil {
   198| 					log.Printf("failed to create tailscale node: %s", err)
   199| 				}
   200| 				err = tsClient.WaitForReady()
   201| 				if err != nil {
   202| 					log.Printf("failed to wait for tailscaled: %s", err)
   203| 				}
   204| 				user.Clients[tsClient.Hostname()] = tsClient
   205| 			}()
   206| 		}
   207| 		user.createWaitGroup.Wait()
   208| 		return nil
   209| 	}
   210| 	return fmt.Errorf("failed to add tailscale node: %w", errNoUserAvailable)
   211| }
   212| func (s *Scenario) RunTailscaleUp(
   213| 	userStr, loginServer, authKey string,
   214| ) error {
   215| 	if user, ok := s.users[userStr]; ok {
   216| 		for _, client := range user.Clients {
   217| 			user.joinWaitGroup.Add(1)
   218| 			go func(c TailscaleClient) {
   219| 				defer user.joinWaitGroup.Done()
   220| 				_ = c.Up(loginServer, authKey)
   221| 			}(client)
   222| 			err := client.WaitForReady()
   223| 			if err != nil {
   224| 				log.Printf("error waiting for client %s to be ready: %s", client.Hostname(), err)
   225| 			}
   226| 		}
   227| 		user.joinWaitGroup.Wait()
   228| 		for _, client := range user.Clients {
   229| 			err := client.WaitForReady()
   230| 			if err != nil {
   231| 				log.Printf("client %s was not ready: %s", client.Hostname(), err)
   232| 				return fmt.Errorf("failed to up tailscale node: %w", err)
   233| 			}
   234| 		}
   235| 		return nil
   236| 	}
   237| 	return fmt.Errorf("failed to up tailscale node: %w", errNoUserAvailable)
   238| }
   239| func (s *Scenario) CountTailscale() int {
   240| 	count := 0
   241| 	for _, user := range s.users {
   242| 		count += len(user.Clients)
   243| 	}
   244| 	return count
   245| }
   246| func (s *Scenario) WaitForTailscaleSync() error {
   247| 	tsCount := s.CountTailscale()
   248| 	for _, user := range s.users {
   249| 		for _, client := range user.Clients {
   250| 			user.syncWaitGroup.Add(1)
   251| 			go func(c TailscaleClient) {
   252| 				defer user.syncWaitGroup.Done()
   253| 				_ = c.WaitForPeers(tsCount)
   254| 			}(client)
   255| 		}
   256| 		user.syncWaitGroup.Wait()
   257| 	}
   258| 	return nil
   259| }
   260| func (s *Scenario) CreateHeadscaleEnv(
   261| 	users map[string]int,
   262| 	tsOpts []tsic.Option,
   263| 	opts ...hsic.Option,
   264| ) error {
   265| 	headscale, err := s.Headscale(opts...)
   266| 	if err != nil {
   267| 		return err
   268| 	}
   269| 	for userName, clientCount := range users {
   270| 		err = s.CreateUser(userName)
   271| 		if err != nil {
   272| 			return err
   273| 		}
   274| 		err = s.CreateTailscaleNodesInUser(userName, "all", clientCount, tsOpts...)
   275| 		if err != nil {
   276| 			return err

# --- HUNK 2: Lines 351-382 ---
   351| 		}
   352| 		allIps = append(allIps, ips...)
   353| 	}
   354| 	return allIps, nil
   355| }
   356| func (s *Scenario) ListTailscaleClientsFQDNs(users ...string) ([]string, error) {
   357| 	allFQDNs := make([]string, 0)
   358| 	clients, err := s.ListTailscaleClients(users...)
   359| 	if err != nil {
   360| 		return nil, err
   361| 	}
   362| 	for _, client := range clients {
   363| 		fqdn, err := client.FQDN()
   364| 		if err != nil {
   365| 			return nil, err
   366| 		}
   367| 		allFQDNs = append(allFQDNs, fqdn)
   368| 	}
   369| 	return allFQDNs, nil
   370| }
   371| func (s *Scenario) WaitForTailscaleLogout() {
   372| 	for _, user := range s.users {
   373| 		for _, client := range user.Clients {
   374| 			user.syncWaitGroup.Add(1)
   375| 			go func(c TailscaleClient) {
   376| 				defer user.syncWaitGroup.Done()
   377| 				_ = c.WaitForLogout()
   378| 			}(client)
   379| 		}
   380| 		user.syncWaitGroup.Wait()
   381| 	}
   382| }


# ====================================================================
# FILE: integration/tailscale.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| package integration
     2| import (
     3| 	"net/netip"
     4| 	"net/url"
     5| 	"github.com/juanfont/headscale/integration/dockertestutil"
     6| 	"github.com/juanfont/headscale/integration/tsic"
     7| 	"tailscale.com/ipn/ipnstate"
     8| )
     9| type TailscaleClient interface {
    10| 	Hostname() string
    11| 	Shutdown() error
    12| 	Version() string
    13| 	Execute(command []string, options ...dockertestutil.ExecuteCommandOption) (string, string, error)
    14| 	Up(loginServer, authKey string) error
    15| 	UpWithLoginURL(loginServer string) (*url.URL, error)
    16| 	Logout() error
    17| 	IPs() ([]netip.Addr, error)
    18| 	FQDN() (string, error)
    19| 	Status() (*ipnstate.Status, error)
    20| 	WaitForReady() error
    21| 	WaitForLogout() error
    22| 	WaitForPeers(expected int) error
    23| 	Ping(hostnameOrIP string, opts ...tsic.PingOption) error
    24| 	Curl(url string, opts ...tsic.CurlOption) (string, error)
    25| 	ID() string
    26| }


# ====================================================================
# FILE: integration/tsic/tsic.go
# Total hunks: 6
# ====================================================================
# --- HUNK 1: Lines 1-69 ---
     1| package tsic
     2| import (
     3| 	"encoding/json"
     4| 	"errors"
     5| 	"fmt"
     6| 	"log"
     7| 	"net/netip"
     8| 	"net/url"
     9| 	"strconv"
    10| 	"strings"
    11| 	"time"
    12| 	"github.com/cenkalti/backoff/v4"
    13| 	"github.com/juanfont/headscale/hscontrol"
    14| 	"github.com/juanfont/headscale/integration/dockertestutil"
    15| 	"github.com/juanfont/headscale/integration/integrationutil"
    16| 	"github.com/ory/dockertest/v3"
    17| 	"github.com/ory/dockertest/v3/docker"
    18| 	"tailscale.com/ipn/ipnstate"
    19| )
    20| const (
    21| 	tsicHashLength    = 6
    22| 	defaultPingCount  = 10
    23| 	dockerContextPath = "../."
    24| 	headscaleCertPath = "/usr/local/share/ca-certificates/headscale.crt"
    25| )
    26| var (
    27| 	errTailscalePingFailed             = errors.New("ping failed")
    28| 	errTailscalePingNotDERP            = errors.New("ping not via DERP")
    29| 	errTailscaleNotLoggedIn            = errors.New("tailscale not logged in")
    30| 	errTailscaleWrongPeerCount         = errors.New("wrong peer count")
    31| 	errTailscaleCannotUpWithoutAuthkey = errors.New("cannot up without authkey")
    32| 	errTailscaleNotConnected           = errors.New("tailscale not connected")
    33| 	errTailscaleNotLoggedOut           = errors.New("tailscale not logged out")
    34| )
    35| type TailscaleInContainer struct {
    36| 	version  string
    37| 	hostname string
    38| 	pool      *dockertest.Pool
    39| 	container *dockertest.Resource
    40| 	network   *dockertest.Network
    41| 	ips  []netip.Addr
    42| 	fqdn string
    43| 	headscaleCert     []byte
    44| 	headscaleHostname string
    45| 	withSSH           bool
    46| 	withTags          []string
    47| 	withEntrypoint    []string
    48| 	withExtraHosts    []string
    49| 	workdir           string
    50| }
    51| type Option = func(c *TailscaleInContainer)
    52| func WithHeadscaleTLS(cert []byte) Option {
    53| 	return func(tsic *TailscaleInContainer) {
    54| 		tsic.headscaleCert = cert
    55| 	}
    56| }
    57| func WithOrCreateNetwork(network *dockertest.Network) Option {
    58| 	return func(tsic *TailscaleInContainer) {
    59| 		if network != nil {
    60| 			tsic.network = network
    61| 			return
    62| 		}
    63| 		network, err := dockertestutil.GetFirstOrCreateNetwork(
    64| 			tsic.pool,
    65| 			fmt.Sprintf("%s-network", tsic.hostname),
    66| 		)
    67| 		if err != nil {
    68| 			log.Fatalf("failed to create network: %s", err)
    69| 		}

# --- HUNK 2: Lines 81-447 ---
    81| 	}
    82| }
    83| func WithSSH() Option {
    84| 	return func(tsic *TailscaleInContainer) {
    85| 		tsic.withSSH = true
    86| 	}
    87| }
    88| func WithDockerWorkdir(dir string) Option {
    89| 	return func(tsic *TailscaleInContainer) {
    90| 		tsic.workdir = dir
    91| 	}
    92| }
    93| func WithExtraHosts(hosts []string) Option {
    94| 	return func(tsic *TailscaleInContainer) {
    95| 		tsic.withExtraHosts = hosts
    96| 	}
    97| }
    98| func WithDockerEntrypoint(args []string) Option {
    99| 	return func(tsic *TailscaleInContainer) {
   100| 		tsic.withEntrypoint = args
   101| 	}
   102| }
   103| func New(
   104| 	pool *dockertest.Pool,
   105| 	version string,
   106| 	network *dockertest.Network,
   107| 	opts ...Option,
   108| ) (*TailscaleInContainer, error) {
   109| 	hash, err := hscontrol.GenerateRandomStringDNSSafe(tsicHashLength)
   110| 	if err != nil {
   111| 		return nil, err
   112| 	}
   113| 	hostname := fmt.Sprintf("ts-%s-%s", strings.ReplaceAll(version, ".", "-"), hash)
   114| 	tsic := &TailscaleInContainer{
   115| 		version:  version,
   116| 		hostname: hostname,
   117| 		pool:    pool,
   118| 		network: network,
   119| 		withEntrypoint: []string{
   120| 			"/bin/bash",
   121| 			"-c",
   122| 			"/bin/sleep 3 ; update-ca-certificates ; tailscaled --tun=tsdev",
   123| 		},
   124| 	}
   125| 	for _, opt := range opts {
   126| 		opt(tsic)
   127| 	}
   128| 	tailscaleOptions := &dockertest.RunOptions{
   129| 		Name:     hostname,
   130| 		Networks: []*dockertest.Network{tsic.network},
   131| 		Entrypoint: tsic.withEntrypoint,
   132| 		ExtraHosts: tsic.withExtraHosts,
   133| 	}
   134| 	if tsic.headscaleHostname != "" {
   135| 		tailscaleOptions.ExtraHosts = []string{
   136| 			"host.docker.internal:host-gateway",
   137| 			fmt.Sprintf("%s:host-gateway", tsic.headscaleHostname),
   138| 		}
   139| 	}
   140| 	if tsic.workdir != "" {
   141| 		tailscaleOptions.WorkingDir = tsic.workdir
   142| 	}
   143| 	err = pool.RemoveContainerByName(hostname)
   144| 	if err != nil {
   145| 		return nil, err
   146| 	}
   147| 	container, err := pool.BuildAndRunWithBuildOptions(
   148| 		createTailscaleBuildOptions(version),
   149| 		tailscaleOptions,
   150| 		dockertestutil.DockerRestartPolicy,
   151| 		dockertestutil.DockerAllowLocalIPv6,
   152| 		dockertestutil.DockerAllowNetworkAdministration,
   153| 	)
   154| 	if err != nil {
   155| 		return nil, fmt.Errorf(
   156| 			"could not start tailscale container (version: %s): %w",
   157| 			version,
   158| 			err,
   159| 		)
   160| 	}
   161| 	log.Printf("Created %s container\n", hostname)
   162| 	tsic.container = container
   163| 	if tsic.hasTLS() {
   164| 		err = tsic.WriteFile(headscaleCertPath, tsic.headscaleCert)
   165| 		if err != nil {
   166| 			return nil, fmt.Errorf("failed to write TLS certificate to container: %w", err)
   167| 		}
   168| 	}
   169| 	return tsic, nil
   170| }
   171| func (t *TailscaleInContainer) hasTLS() bool {
   172| 	return len(t.headscaleCert) != 0
   173| }
   174| func (t *TailscaleInContainer) Shutdown() error {
   175| 	return t.pool.Purge(t.container)
   176| }
   177| func (t *TailscaleInContainer) Hostname() string {
   178| 	return t.hostname
   179| }
   180| func (t *TailscaleInContainer) Version() string {
   181| 	return t.version
   182| }
   183| func (t *TailscaleInContainer) ID() string {
   184| 	return t.container.Container.ID
   185| }
   186| func (t *TailscaleInContainer) Execute(
   187| 	command []string,
   188| 	options ...dockertestutil.ExecuteCommandOption,
   189| ) (string, string, error) {
   190| 	stdout, stderr, err := dockertestutil.ExecuteCommand(
   191| 		t.container,
   192| 		command,
   193| 		[]string{},
   194| 		options...,
   195| 	)
   196| 	if err != nil {
   197| 		log.Printf("command stderr: %s\n", stderr)
   198| 		if stdout != "" {
   199| 			log.Printf("command stdout: %s\n", stdout)
   200| 		}
   201| 		if strings.Contains(stderr, "NeedsLogin") {
   202| 			return stdout, stderr, errTailscaleNotLoggedIn
   203| 		}
   204| 		return stdout, stderr, err
   205| 	}
   206| 	return stdout, stderr, nil
   207| }
   208| func (t *TailscaleInContainer) Up(
   209| 	loginServer, authKey string,
   210| ) error {
   211| 	command := []string{
   212| 		"tailscale",
   213| 		"up",
   214| 		"-login-server",
   215| 		loginServer,
   216| 		"--authkey",
   217| 		authKey,
   218| 		"--hostname",
   219| 		t.hostname,
   220| 	}
   221| 	if t.withSSH {
   222| 		command = append(command, "--ssh")
   223| 	}
   224| 	if len(t.withTags) > 0 {
   225| 		command = append(command,
   226| 			fmt.Sprintf(`--advertise-tags=%s`, strings.Join(t.withTags, ",")),
   227| 		)
   228| 	}
   229| 	if _, _, err := t.Execute(command); err != nil {
   230| 		return fmt.Errorf("failed to join tailscale client: %w", err)
   231| 	}
   232| 	return nil
   233| }
   234| func (t *TailscaleInContainer) UpWithLoginURL(
   235| 	loginServer string,
   236| ) (*url.URL, error) {
   237| 	command := []string{
   238| 		"tailscale",
   239| 		"up",
   240| 		"-login-server",
   241| 		loginServer,
   242| 		"--hostname",
   243| 		t.hostname,
   244| 	}
   245| 	_, stderr, err := t.Execute(command)
   246| 	if errors.Is(err, errTailscaleNotLoggedIn) {
   247| 		return nil, errTailscaleCannotUpWithoutAuthkey
   248| 	}
   249| 	urlStr := strings.ReplaceAll(stderr, "\nTo authenticate, visit:\n\n\t", "")
   250| 	urlStr = strings.TrimSpace(urlStr)
   251| 	loginURL, err := url.Parse(urlStr)
   252| 	if err != nil {
   253| 		log.Printf("Could not parse login URL: %s", err)
   254| 		log.Printf("Original join command result: %s", stderr)
   255| 		return nil, err
   256| 	}
   257| 	return loginURL, nil
   258| }
   259| func (t *TailscaleInContainer) Logout() error {
   260| 	_, _, err := t.Execute([]string{"tailscale", "logout"})
   261| 	if err != nil {
   262| 		return err
   263| 	}
   264| 	return nil
   265| }
   266| func (t *TailscaleInContainer) IPs() ([]netip.Addr, error) {
   267| 	if t.ips != nil && len(t.ips) != 0 {
   268| 		return t.ips, nil
   269| 	}
   270| 	ips := make([]netip.Addr, 0)
   271| 	command := []string{
   272| 		"tailscale",
   273| 		"ip",
   274| 	}
   275| 	result, _, err := t.Execute(command)
   276| 	if err != nil {
   277| 		return []netip.Addr{}, fmt.Errorf("failed to join tailscale client: %w", err)
   278| 	}
   279| 	for _, address := range strings.Split(result, "\n") {
   280| 		address = strings.TrimSuffix(address, "\n")
   281| 		if len(address) < 1 {
   282| 			continue
   283| 		}
   284| 		ip, err := netip.ParseAddr(address)
   285| 		if err != nil {
   286| 			return nil, err
   287| 		}
   288| 		ips = append(ips, ip)
   289| 	}
   290| 	return ips, nil
   291| }
   292| func (t *TailscaleInContainer) Status() (*ipnstate.Status, error) {
   293| 	command := []string{
   294| 		"tailscale",
   295| 		"status",
   296| 		"--json",
   297| 	}
   298| 	result, _, err := t.Execute(command)
   299| 	if err != nil {
   300| 		return nil, fmt.Errorf("failed to execute tailscale status command: %w", err)
   301| 	}
   302| 	var status ipnstate.Status
   303| 	err = json.Unmarshal([]byte(result), &status)
   304| 	if err != nil {
   305| 		return nil, fmt.Errorf("failed to unmarshal tailscale status: %w", err)
   306| 	}
   307| 	return &status, err
   308| }
   309| func (t *TailscaleInContainer) FQDN() (string, error) {
   310| 	if t.fqdn != "" {
   311| 		return t.fqdn, nil
   312| 	}
   313| 	status, err := t.Status()
   314| 	if err != nil {
   315| 		return "", fmt.Errorf("failed to get FQDN: %w", err)
   316| 	}
   317| 	return status.Self.DNSName, nil
   318| }
   319| func (t *TailscaleInContainer) WaitForReady() error {
   320| 	return t.pool.Retry(func() error {
   321| 		status, err := t.Status()
   322| 		if err != nil {
   323| 			return fmt.Errorf("failed to fetch tailscale status: %w", err)
   324| 		}
   325| 		if status.CurrentTailnet != nil {
   326| 			return nil
   327| 		}
   328| 		if status.BackendState == "Running" {
   329| 			return nil
   330| 		}
   331| 		return errTailscaleNotConnected
   332| 	})
   333| }
   334| func (t *TailscaleInContainer) WaitForLogout() error {
   335| 	return t.pool.Retry(func() error {
   336| 		status, err := t.Status()
   337| 		if err != nil {
   338| 			return fmt.Errorf("failed to fetch tailscale status: %w", err)
   339| 		}
   340| 		if status.CurrentTailnet == nil {
   341| 			return nil
   342| 		}
   343| 		return errTailscaleNotLoggedOut
   344| 	})
   345| }
   346| func (t *TailscaleInContainer) WaitForPeers(expected int) error {
   347| 	return t.pool.Retry(func() error {
   348| 		status, err := t.Status()
   349| 		if err != nil {
   350| 			return fmt.Errorf("failed to fetch tailscale status: %w", err)
   351| 		}
   352| 		if peers := status.Peers(); len(peers) != expected {
   353| 			return errTailscaleWrongPeerCount
   354| 		}
   355| 		return nil
   356| 	})
   357| }
   358| type (
   359| 	PingOption = func(args *pingArgs)
   360| 	pingArgs struct {
   361| 		timeout time.Duration
   362| 		count   int
   363| 		direct  bool
   364| 	}
   365| )
   366| func WithPingTimeout(timeout time.Duration) PingOption {
   367| 	return func(args *pingArgs) {
   368| 		args.timeout = timeout
   369| 	}
   370| }
   371| func WithPingCount(count int) PingOption {
   372| 	return func(args *pingArgs) {
   373| 		args.count = count
   374| 	}
   375| }
   376| func WithPingUntilDirect(direct bool) PingOption {
   377| 	return func(args *pingArgs) {
   378| 		args.direct = direct
   379| 	}
   380| }
   381| func (t *TailscaleInContainer) Ping(hostnameOrIP string, opts ...PingOption) error {
   382| 	args := pingArgs{
   383| 		timeout: time.Second,
   384| 		count:   defaultPingCount,
   385| 		direct:  true,
   386| 	}
   387| 	for _, opt := range opts {
   388| 		opt(&args)
   389| 	}
   390| 	command := []string{
   391| 		"tailscale", "ping",
   392| 		fmt.Sprintf("--timeout=%s", args.timeout),
   393| 		fmt.Sprintf("--c=%d", args.count),
   394| 		fmt.Sprintf("--until-direct=%s", strconv.FormatBool(args.direct)),
   395| 	}
   396| 	command = append(command, hostnameOrIP)
   397| 	return t.pool.Retry(func() error {
   398| 		result, _, err := t.Execute(
   399| 			command,
   400| 			dockertestutil.ExecuteCommandTimeout(
   401| 				time.Duration(int64(args.timeout)*int64(args.count)),
   402| 			),
   403| 		)
   404| 		if err != nil {
   405| 			log.Printf(
   406| 				"failed to run ping command from %s to %s, err: %s",
   407| 				t.Hostname(),
   408| 				hostnameOrIP,
   409| 				err,
   410| 			)
   411| 			return err
   412| 		}
   413| 		if strings.Contains(result, "is local") {
   414| 			return nil
   415| 		}
   416| 		if !strings.Contains(result, "pong") {
   417| 			return backoff.Permanent(errTailscalePingFailed)
   418| 		}
   419| 		if !args.direct {
   420| 			if strings.Contains(result, "via DERP") {
   421| 				return nil
   422| 			} else {
   423| 				return backoff.Permanent(errTailscalePingNotDERP)
   424| 			}
   425| 		}
   426| 		return nil
   427| 	})
   428| }
   429| type (
   430| 	CurlOption = func(args *curlArgs)
   431| 	curlArgs struct {
   432| 		connectionTimeout time.Duration
   433| 		maxTime           time.Duration
   434| 		retry             int
   435| 		retryDelay        time.Duration
   436| 		retryMaxTime      time.Duration
   437| 	}
   438| )
   439| func WithCurlConnectionTimeout(timeout time.Duration) CurlOption {
   440| 	return func(args *curlArgs) {
   441| 		args.connectionTimeout = timeout
   442| 	}
   443| }
   444| func WithCurlMaxTime(t time.Duration) CurlOption {
   445| 	return func(args *curlArgs) {
   446| 		args.maxTime = t
   447| 	}

# --- HUNK 3: Lines 463-543 ---
   463| 		connectionTimeout: defaultConnectionTimeout,
   464| 		maxTime:           defaultMaxTime,
   465| 		retry:             defaultRetry,
   466| 		retryDelay:        defaultRetryDelay,
   467| 		retryMaxTime:      defaultRetryMaxTime,
   468| 	}
   469| 	for _, opt := range opts {
   470| 		opt(&args)
   471| 	}
   472| 	command := []string{
   473| 		"curl",
   474| 		"--silent",
   475| 		"--connect-timeout", fmt.Sprintf("%d", int(args.connectionTimeout.Seconds())),
   476| 		"--max-time", fmt.Sprintf("%d", int(args.maxTime.Seconds())),
   477| 		"--retry", fmt.Sprintf("%d", args.retry),
   478| 		"--retry-delay", fmt.Sprintf("%d", int(args.retryDelay.Seconds())),
   479| 		"--retry-max-time", fmt.Sprintf("%d", int(args.retryMaxTime.Seconds())),
   480| 		url,
   481| 	}
   482| 	var result string
   483| 	err := t.pool.Retry(func() error {
   484| 		var err error
   485| 		result, _, err = t.Execute(command)
   486| 		if err != nil {
   487| 			log.Printf(
   488| 				"failed to run curl command from %s to %s, err: %s",
   489| 				t.Hostname(),
   490| 				url,
   491| 				err,
   492| 			)
   493| 			return err
   494| 		}
   495| 		return nil
   496| 	})
   497| 	return result, err
   498| }
   499| func (t *TailscaleInContainer) WriteFile(path string, data []byte) error {
   500| 	return integrationutil.WriteFileToContainer(t.pool, t.container, path, data)
   501| }
   502| func createTailscaleBuildOptions(version string) *dockertest.BuildOptions {
   503| 	var tailscaleBuildOptions *dockertest.BuildOptions
   504| 	switch version {
   505| 	case "head":
   506| 		tailscaleBuildOptions = &dockertest.BuildOptions{
   507| 			Dockerfile: "Dockerfile.tailscale-HEAD",
   508| 			ContextDir: dockerContextPath,
   509| 			BuildArgs:  []docker.BuildArg{},
   510| 		}
   511| 	case "unstable":
   512| 		tailscaleBuildOptions = &dockertest.BuildOptions{
   513| 			Dockerfile: "Dockerfile.tailscale",
   514| 			ContextDir: dockerContextPath,
   515| 			BuildArgs: []docker.BuildArg{
   516| 				{
   517| 					Name:  "TAILSCALE_VERSION",
   518| 					Value: "*", // Installs the latest version https://askubuntu.com/a/824926
   519| 				},
   520| 				{
   521| 					Name:  "TAILSCALE_CHANNEL",
   522| 					Value: "unstable",
   523| 				},
   524| 			},
   525| 		}
   526| 	default:
   527| 		tailscaleBuildOptions = &dockertest.BuildOptions{
   528| 			Dockerfile: "Dockerfile.tailscale",
   529| 			ContextDir: dockerContextPath,
   530| 			BuildArgs: []docker.BuildArg{
   531| 				{
   532| 					Name:  "TAILSCALE_VERSION",
   533| 					Value: version,
   534| 				},
   535| 				{
   536| 					Name:  "TAILSCALE_CHANNEL",
   537| 					Value: "stable",
   538| 				},
   539| 			},
   540| 		}
   541| 	}
   542| 	return tailscaleBuildOptions
   543| }


# ====================================================================
# FILE: integration/utils.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 1-63 ---
     1| package integration
     2| import (
     3| 	"testing"
     4| 	"time"
     5| 	"github.com/juanfont/headscale/integration/tsic"
     6| )
     7| const (
     8| 	derpPingTimeout = 2 * time.Second
     9| 	derpPingCount   = 10
    10| )
    11| func pingAllHelper(t *testing.T, clients []TailscaleClient, addrs []string) int {
    12| 	t.Helper()
    13| 	success := 0
    14| 	for _, client := range clients {
    15| 		for _, addr := range addrs {
    16| 			err := client.Ping(addr)
    17| 			if err != nil {
    18| 				t.Errorf("failed to ping %s from %s: %s", addr, client.Hostname(), err)
    19| 			} else {
    20| 				success++
    21| 			}
    22| 		}
    23| 	}
    24| 	return success
    25| }
    26| func pingDerpAllHelper(t *testing.T, clients []TailscaleClient, addrs []string) int {
    27| 	t.Helper()
    28| 	success := 0
    29| 	for _, client := range clients {
    30| 		for _, addr := range addrs {
    31| 			if isSelfClient(client, addr) {
    32| 				continue
    33| 			}
    34| 			err := client.Ping(
    35| 				addr,
    36| 				tsic.WithPingTimeout(derpPingTimeout),
    37| 				tsic.WithPingCount(derpPingCount),
    38| 				tsic.WithPingUntilDirect(false),
    39| 			)
    40| 			if err != nil {
    41| 				t.Errorf("failed to ping %s from %s: %s", addr, client.Hostname(), err)
    42| 			} else {
    43| 				success++
    44| 			}
    45| 		}
    46| 	}
    47| 	return success
    48| }
    49| func isSelfClient(client TailscaleClient, addr string) bool {
    50| 	if addr == client.Hostname() {
    51| 		return true
    52| 	}
    53| 	ips, err := client.IPs()
    54| 	if err != nil {
    55| 		return false
    56| 	}
    57| 	for _, ip := range ips {
    58| 		if ip.String() == addr {
    59| 			return true
    60| 		}
    61| 	}
    62| 	return false
    63| }

