--- a/ssh/handshake.go
+++ b/ssh/handshake.go
@@ -4,43 +4,41 @@
 	"errors"
 	"fmt"
 	"io"
 	"log"
 	"net"
 	"strings"
 	"sync"
 )
 const debugHandshake = false
 const chanSize = 16
-const maxPendingPackets = 64
 type keyingTransport interface {
 	packetConn
 	prepareKeyChange(*algorithms, *kexResult) error
 	setStrictMode() error
 	setInitialKEXDone()
 }
 type handshakeTransport struct {
 	conn   keyingTransport
 	config *Config
 	serverVersion []byte
 	clientVersion []byte
 	hostKeys []Signer
 	publicKeyAuthAlgorithms []string
 	hostKeyAlgorithms []string
 	incoming  chan []byte
 	readError error
-	mu sync.Mutex
-	writeCond      *sync.Cond
-	writeError     error
-	sentInitPacket []byte
-	sentInitMsg    *kexInitMsg
-	pendingPackets   [][]byte
+	mu               sync.Mutex
+	writeError       error
+	sentInitPacket   []byte
+	sentInitMsg      *kexInitMsg
+	pendingPackets   [][]byte // Used when a key exchange is in progress.
 	writePacketsLeft uint32
 	writeBytesLeft   int64
 	userAuthComplete bool // whether the user authentication phase is complete
 	requestKex chan struct{}
 	startKex    chan *pendingKex
 	kexLoopDone chan struct{} // closed (with writeError non-nil) when kexLoop exits
 	hostKeyCallback HostKeyCallback
 	dialAddress     string
 	remoteAddr      net.Addr
 	bannerCallback BannerCallback
@@ -58,21 +56,20 @@
 	t := &handshakeTransport{
 		conn:          conn,
 		serverVersion: serverVersion,
 		clientVersion: clientVersion,
 		incoming:      make(chan []byte, chanSize),
 		requestKex:    make(chan struct{}, 1),
 		startKex:      make(chan *pendingKex),
 		kexLoopDone:   make(chan struct{}),
 		config: config,
 	}
-	t.writeCond = sync.NewCond(&t.mu)
 	t.resetReadThresholds()
 	t.resetWriteThresholds()
 	t.requestKex <- struct{}{}
 	return t
 }
 func newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {
 	t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
 	t.dialAddress = dialAddr
 	t.remoteAddr = addr
 	t.hostKeyCallback = config.HostKeyCallback
@@ -159,21 +156,20 @@
 func (t *handshakeTransport) getWriteError() error {
 	t.mu.Lock()
 	defer t.mu.Unlock()
 	return t.writeError
 }
 func (t *handshakeTransport) recordWriteError(err error) {
 	t.mu.Lock()
 	defer t.mu.Unlock()
 	if t.writeError == nil && err != nil {
 		t.writeError = err
-		t.writeCond.Broadcast()
 	}
 }
 func (t *handshakeTransport) requestKeyExchange() {
 	select {
 	case t.requestKex <- struct{}{}:
 	default:
 	}
 }
 func (t *handshakeTransport) resetWriteThresholds() {
 	t.writePacketsLeft = packetRekeyThreshold
@@ -229,21 +225,20 @@
 			}
 		}
 		request.done <- t.writeError
 		for _, p := range t.pendingPackets {
 			t.writeError = t.pushPacket(p)
 			if t.writeError != nil {
 				break
 			}
 		}
 		t.pendingPackets = t.pendingPackets[:0]
-		t.writeCond.Broadcast()
 		t.mu.Unlock()
 	}
 	t.conn.Close()
 	for request := range t.startKex {
 		request.done <- t.getWriteError()
 	}
 	close(t.kexLoopDone)
 }
 const packetRekeyThreshold = (1 << 31)
 func (t *handshakeTransport) resetReadThresholds() {
@@ -371,46 +366,37 @@
 		if t.userAuthComplete {
 			return errSendBannerPhase
 		}
 	case msgUserAuthSuccess:
 		t.userAuthComplete = true
 	}
 	if t.writeError != nil {
 		return t.writeError
 	}
 	if t.sentInitMsg != nil {
-		if len(t.pendingPackets) < maxPendingPackets {
-			cp := make([]byte, len(p))
-			copy(cp, p)
-			t.pendingPackets = append(t.pendingPackets, cp)
-			return nil
-		}
-		for t.sentInitMsg != nil {
-			t.writeCond.Wait()
-			if t.writeError != nil {
-				return t.writeError
-			}
-		}
+		cp := make([]byte, len(p))
+		copy(cp, p)
+		t.pendingPackets = append(t.pendingPackets, cp)
+		return nil
 	}
 	if t.writeBytesLeft > 0 {
 		t.writeBytesLeft -= int64(len(p))
 	} else {
 		t.requestKeyExchange()
 	}
 	if t.writePacketsLeft > 0 {
 		t.writePacketsLeft--
 	} else {
 		t.requestKeyExchange()
 	}
 	if err := t.pushPacket(p); err != nil {
 		t.writeError = err
-		t.writeCond.Broadcast()
 	}
 	return nil
 }
 func (t *handshakeTransport) Close() error {
 	err := t.conn.Close()
 	<-t.kexLoopDone
 	return err
 }
 func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
 	if debugHandshake {
