# ====================================================================
# FILE: ssh/handshake.go
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-85 ---
     1| package ssh
     2| import (
     3| 	"crypto/rand"
     4| 	"errors"
     5| 	"fmt"
     6| 	"io"
     7| 	"log"
     8| 	"net"
     9| 	"strings"
    10| 	"sync"
    11| )
    12| const debugHandshake = false
    13| const chanSize = 16
    14| type keyingTransport interface {
    15| 	packetConn
    16| 	prepareKeyChange(*algorithms, *kexResult) error
    17| 	setStrictMode() error
    18| 	setInitialKEXDone()
    19| }
    20| type handshakeTransport struct {
    21| 	conn   keyingTransport
    22| 	config *Config
    23| 	serverVersion []byte
    24| 	clientVersion []byte
    25| 	hostKeys []Signer
    26| 	publicKeyAuthAlgorithms []string
    27| 	hostKeyAlgorithms []string
    28| 	incoming  chan []byte
    29| 	readError error
    30| 	mu               sync.Mutex
    31| 	writeError       error
    32| 	sentInitPacket   []byte
    33| 	sentInitMsg      *kexInitMsg
    34| 	pendingPackets   [][]byte // Used when a key exchange is in progress.
    35| 	writePacketsLeft uint32
    36| 	writeBytesLeft   int64
    37| 	userAuthComplete bool // whether the user authentication phase is complete
    38| 	requestKex chan struct{}
    39| 	startKex    chan *pendingKex
    40| 	kexLoopDone chan struct{} // closed (with writeError non-nil) when kexLoop exits
    41| 	hostKeyCallback HostKeyCallback
    42| 	dialAddress     string
    43| 	remoteAddr      net.Addr
    44| 	bannerCallback BannerCallback
    45| 	algorithms *algorithms
    46| 	readPacketsLeft uint32
    47| 	readBytesLeft   int64
    48| 	sessionID []byte
    49| 	strictMode bool
    50| }
    51| type pendingKex struct {
    52| 	otherInit []byte
    53| 	done      chan error
    54| }
    55| func newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {
    56| 	t := &handshakeTransport{
    57| 		conn:          conn,
    58| 		serverVersion: serverVersion,
    59| 		clientVersion: clientVersion,
    60| 		incoming:      make(chan []byte, chanSize),
    61| 		requestKex:    make(chan struct{}, 1),
    62| 		startKex:      make(chan *pendingKex),
    63| 		kexLoopDone:   make(chan struct{}),
    64| 		config: config,
    65| 	}
    66| 	t.resetReadThresholds()
    67| 	t.resetWriteThresholds()
    68| 	t.requestKex <- struct{}{}
    69| 	return t
    70| }
    71| func newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {
    72| 	t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
    73| 	t.dialAddress = dialAddr
    74| 	t.remoteAddr = addr
    75| 	t.hostKeyCallback = config.HostKeyCallback
    76| 	t.bannerCallback = config.BannerCallback
    77| 	if config.HostKeyAlgorithms != nil {
    78| 		t.hostKeyAlgorithms = config.HostKeyAlgorithms
    79| 	} else {
    80| 		t.hostKeyAlgorithms = supportedHostKeyAlgos
    81| 	}
    82| 	go t.readLoop()
    83| 	go t.kexLoop()
    84| 	return t
    85| }

# --- HUNK 2: Lines 146-185 ---
   146| 	}
   147| 	t.recordWriteError(t.readError)
   148| 	close(t.startKex)
   149| }
   150| func (t *handshakeTransport) pushPacket(p []byte) error {
   151| 	if debugHandshake {
   152| 		t.printPacket(p, true)
   153| 	}
   154| 	return t.conn.writePacket(p)
   155| }
   156| func (t *handshakeTransport) getWriteError() error {
   157| 	t.mu.Lock()
   158| 	defer t.mu.Unlock()
   159| 	return t.writeError
   160| }
   161| func (t *handshakeTransport) recordWriteError(err error) {
   162| 	t.mu.Lock()
   163| 	defer t.mu.Unlock()
   164| 	if t.writeError == nil && err != nil {
   165| 		t.writeError = err
   166| 	}
   167| }
   168| func (t *handshakeTransport) requestKeyExchange() {
   169| 	select {
   170| 	case t.requestKex <- struct{}{}:
   171| 	default:
   172| 	}
   173| }
   174| func (t *handshakeTransport) resetWriteThresholds() {
   175| 	t.writePacketsLeft = packetRekeyThreshold
   176| 	if t.config.RekeyThreshold > 0 {
   177| 		t.writeBytesLeft = int64(t.config.RekeyThreshold)
   178| 	} else if t.algorithms != nil {
   179| 		t.writeBytesLeft = t.algorithms.w.rekeyBytes()
   180| 	} else {
   181| 		t.writeBytesLeft = 1 << 30
   182| 	}
   183| }
   184| func (t *handshakeTransport) kexLoop() {
   185| write:

# --- HUNK 3: Lines 215-254 ---
   215| 		t.writeError = err
   216| 		t.sentInitPacket = nil
   217| 		t.sentInitMsg = nil
   218| 		t.resetWriteThresholds()
   219| 	clear:
   220| 		for {
   221| 			select {
   222| 			case <-t.requestKex:
   223| 			default:
   224| 				break clear
   225| 			}
   226| 		}
   227| 		request.done <- t.writeError
   228| 		for _, p := range t.pendingPackets {
   229| 			t.writeError = t.pushPacket(p)
   230| 			if t.writeError != nil {
   231| 				break
   232| 			}
   233| 		}
   234| 		t.pendingPackets = t.pendingPackets[:0]
   235| 		t.mu.Unlock()
   236| 	}
   237| 	t.conn.Close()
   238| 	for request := range t.startKex {
   239| 		request.done <- t.getWriteError()
   240| 	}
   241| 	close(t.kexLoopDone)
   242| }
   243| const packetRekeyThreshold = (1 << 31)
   244| func (t *handshakeTransport) resetReadThresholds() {
   245| 	t.readPacketsLeft = packetRekeyThreshold
   246| 	if t.config.RekeyThreshold > 0 {
   247| 		t.readBytesLeft = int64(t.config.RekeyThreshold)
   248| 	} else if t.algorithms != nil {
   249| 		t.readBytesLeft = t.algorithms.r.rekeyBytes()
   250| 	} else {
   251| 		t.readBytesLeft = 1 << 30
   252| 	}
   253| }
   254| func (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {

# --- HUNK 4: Lines 356-412 ---
   356| var errSendBannerPhase = errors.New("ssh: SendAuthBanner outside of authentication phase")
   357| func (t *handshakeTransport) writePacket(p []byte) error {
   358| 	t.mu.Lock()
   359| 	defer t.mu.Unlock()
   360| 	switch p[0] {
   361| 	case msgKexInit:
   362| 		return errors.New("ssh: only handshakeTransport can send kexInit")
   363| 	case msgNewKeys:
   364| 		return errors.New("ssh: only handshakeTransport can send newKeys")
   365| 	case msgUserAuthBanner:
   366| 		if t.userAuthComplete {
   367| 			return errSendBannerPhase
   368| 		}
   369| 	case msgUserAuthSuccess:
   370| 		t.userAuthComplete = true
   371| 	}
   372| 	if t.writeError != nil {
   373| 		return t.writeError
   374| 	}
   375| 	if t.sentInitMsg != nil {
   376| 		cp := make([]byte, len(p))
   377| 		copy(cp, p)
   378| 		t.pendingPackets = append(t.pendingPackets, cp)
   379| 		return nil
   380| 	}
   381| 	if t.writeBytesLeft > 0 {
   382| 		t.writeBytesLeft -= int64(len(p))
   383| 	} else {
   384| 		t.requestKeyExchange()
   385| 	}
   386| 	if t.writePacketsLeft > 0 {
   387| 		t.writePacketsLeft--
   388| 	} else {
   389| 		t.requestKeyExchange()
   390| 	}
   391| 	if err := t.pushPacket(p); err != nil {
   392| 		t.writeError = err
   393| 	}
   394| 	return nil
   395| }
   396| func (t *handshakeTransport) Close() error {
   397| 	err := t.conn.Close()
   398| 	<-t.kexLoopDone
   399| 	return err
   400| }
   401| func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
   402| 	if debugHandshake {
   403| 		log.Printf("%s entered key exchange", t.id())
   404| 	}
   405| 	otherInit := &kexInitMsg{}
   406| 	if err := Unmarshal(otherInitPacket, otherInit); err != nil {
   407| 		return err
   408| 	}
   409| 	magics := handshakeMagics{
   410| 		clientVersion: t.clientVersion,
   411| 		serverVersion: t.serverVersion,
   412| 		clientKexInit: otherInitPacket,

