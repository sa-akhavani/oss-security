# ====================================================================
# FILE: ssh/handshake.go
# Total hunks: 5
# ====================================================================
# --- HUNK 1: Lines 1-88 ---
     1| package ssh
     2| import (
     3| 	"crypto/rand"
     4| 	"errors"
     5| 	"fmt"
     6| 	"io"
     7| 	"log"
     8| 	"net"
     9| 	"strings"
    10| 	"sync"
    11| )
    12| const debugHandshake = false
    13| const chanSize = 16
    14| const maxPendingPackets = 64
    15| type keyingTransport interface {
    16| 	packetConn
    17| 	prepareKeyChange(*algorithms, *kexResult) error
    18| 	setStrictMode() error
    19| 	setInitialKEXDone()
    20| }
    21| type handshakeTransport struct {
    22| 	conn   keyingTransport
    23| 	config *Config
    24| 	serverVersion []byte
    25| 	clientVersion []byte
    26| 	hostKeys []Signer
    27| 	publicKeyAuthAlgorithms []string
    28| 	hostKeyAlgorithms []string
    29| 	incoming  chan []byte
    30| 	readError error
    31| 	mu sync.Mutex
    32| 	writeCond      *sync.Cond
    33| 	writeError     error
    34| 	sentInitPacket []byte
    35| 	sentInitMsg    *kexInitMsg
    36| 	pendingPackets   [][]byte
    37| 	writePacketsLeft uint32
    38| 	writeBytesLeft   int64
    39| 	userAuthComplete bool // whether the user authentication phase is complete
    40| 	requestKex chan struct{}
    41| 	startKex    chan *pendingKex
    42| 	kexLoopDone chan struct{} // closed (with writeError non-nil) when kexLoop exits
    43| 	hostKeyCallback HostKeyCallback
    44| 	dialAddress     string
    45| 	remoteAddr      net.Addr
    46| 	bannerCallback BannerCallback
    47| 	algorithms *algorithms
    48| 	readPacketsLeft uint32
    49| 	readBytesLeft   int64
    50| 	sessionID []byte
    51| 	strictMode bool
    52| }
    53| type pendingKex struct {
    54| 	otherInit []byte
    55| 	done      chan error
    56| }
    57| func newHandshakeTransport(conn keyingTransport, config *Config, clientVersion, serverVersion []byte) *handshakeTransport {
    58| 	t := &handshakeTransport{
    59| 		conn:          conn,
    60| 		serverVersion: serverVersion,
    61| 		clientVersion: clientVersion,
    62| 		incoming:      make(chan []byte, chanSize),
    63| 		requestKex:    make(chan struct{}, 1),
    64| 		startKex:      make(chan *pendingKex),
    65| 		kexLoopDone:   make(chan struct{}),
    66| 		config: config,
    67| 	}
    68| 	t.writeCond = sync.NewCond(&t.mu)
    69| 	t.resetReadThresholds()
    70| 	t.resetWriteThresholds()
    71| 	t.requestKex <- struct{}{}
    72| 	return t
    73| }
    74| func newClientTransport(conn keyingTransport, clientVersion, serverVersion []byte, config *ClientConfig, dialAddr string, addr net.Addr) *handshakeTransport {
    75| 	t := newHandshakeTransport(conn, &config.Config, clientVersion, serverVersion)
    76| 	t.dialAddress = dialAddr
    77| 	t.remoteAddr = addr
    78| 	t.hostKeyCallback = config.HostKeyCallback
    79| 	t.bannerCallback = config.BannerCallback
    80| 	if config.HostKeyAlgorithms != nil {
    81| 		t.hostKeyAlgorithms = config.HostKeyAlgorithms
    82| 	} else {
    83| 		t.hostKeyAlgorithms = supportedHostKeyAlgos
    84| 	}
    85| 	go t.readLoop()
    86| 	go t.kexLoop()
    87| 	return t
    88| }

# --- HUNK 2: Lines 149-189 ---
   149| 	}
   150| 	t.recordWriteError(t.readError)
   151| 	close(t.startKex)
   152| }
   153| func (t *handshakeTransport) pushPacket(p []byte) error {
   154| 	if debugHandshake {
   155| 		t.printPacket(p, true)
   156| 	}
   157| 	return t.conn.writePacket(p)
   158| }
   159| func (t *handshakeTransport) getWriteError() error {
   160| 	t.mu.Lock()
   161| 	defer t.mu.Unlock()
   162| 	return t.writeError
   163| }
   164| func (t *handshakeTransport) recordWriteError(err error) {
   165| 	t.mu.Lock()
   166| 	defer t.mu.Unlock()
   167| 	if t.writeError == nil && err != nil {
   168| 		t.writeError = err
   169| 		t.writeCond.Broadcast()
   170| 	}
   171| }
   172| func (t *handshakeTransport) requestKeyExchange() {
   173| 	select {
   174| 	case t.requestKex <- struct{}{}:
   175| 	default:
   176| 	}
   177| }
   178| func (t *handshakeTransport) resetWriteThresholds() {
   179| 	t.writePacketsLeft = packetRekeyThreshold
   180| 	if t.config.RekeyThreshold > 0 {
   181| 		t.writeBytesLeft = int64(t.config.RekeyThreshold)
   182| 	} else if t.algorithms != nil {
   183| 		t.writeBytesLeft = t.algorithms.w.rekeyBytes()
   184| 	} else {
   185| 		t.writeBytesLeft = 1 << 30
   186| 	}
   187| }
   188| func (t *handshakeTransport) kexLoop() {
   189| write:

# --- HUNK 3: Lines 219-259 ---
   219| 		t.writeError = err
   220| 		t.sentInitPacket = nil
   221| 		t.sentInitMsg = nil
   222| 		t.resetWriteThresholds()
   223| 	clear:
   224| 		for {
   225| 			select {
   226| 			case <-t.requestKex:
   227| 			default:
   228| 				break clear
   229| 			}
   230| 		}
   231| 		request.done <- t.writeError
   232| 		for _, p := range t.pendingPackets {
   233| 			t.writeError = t.pushPacket(p)
   234| 			if t.writeError != nil {
   235| 				break
   236| 			}
   237| 		}
   238| 		t.pendingPackets = t.pendingPackets[:0]
   239| 		t.writeCond.Broadcast()
   240| 		t.mu.Unlock()
   241| 	}
   242| 	t.conn.Close()
   243| 	for request := range t.startKex {
   244| 		request.done <- t.getWriteError()
   245| 	}
   246| 	close(t.kexLoopDone)
   247| }
   248| const packetRekeyThreshold = (1 << 31)
   249| func (t *handshakeTransport) resetReadThresholds() {
   250| 	t.readPacketsLeft = packetRekeyThreshold
   251| 	if t.config.RekeyThreshold > 0 {
   252| 		t.readBytesLeft = int64(t.config.RekeyThreshold)
   253| 	} else if t.algorithms != nil {
   254| 		t.readBytesLeft = t.algorithms.r.rekeyBytes()
   255| 	} else {
   256| 		t.readBytesLeft = 1 << 30
   257| 	}
   258| }
   259| func (t *handshakeTransport) readOnePacket(first bool) ([]byte, error) {

# --- HUNK 4: Lines 361-426 ---
   361| var errSendBannerPhase = errors.New("ssh: SendAuthBanner outside of authentication phase")
   362| func (t *handshakeTransport) writePacket(p []byte) error {
   363| 	t.mu.Lock()
   364| 	defer t.mu.Unlock()
   365| 	switch p[0] {
   366| 	case msgKexInit:
   367| 		return errors.New("ssh: only handshakeTransport can send kexInit")
   368| 	case msgNewKeys:
   369| 		return errors.New("ssh: only handshakeTransport can send newKeys")
   370| 	case msgUserAuthBanner:
   371| 		if t.userAuthComplete {
   372| 			return errSendBannerPhase
   373| 		}
   374| 	case msgUserAuthSuccess:
   375| 		t.userAuthComplete = true
   376| 	}
   377| 	if t.writeError != nil {
   378| 		return t.writeError
   379| 	}
   380| 	if t.sentInitMsg != nil {
   381| 		if len(t.pendingPackets) < maxPendingPackets {
   382| 			cp := make([]byte, len(p))
   383| 			copy(cp, p)
   384| 			t.pendingPackets = append(t.pendingPackets, cp)
   385| 			return nil
   386| 		}
   387| 		for t.sentInitMsg != nil {
   388| 			t.writeCond.Wait()
   389| 			if t.writeError != nil {
   390| 				return t.writeError
   391| 			}
   392| 		}
   393| 	}
   394| 	if t.writeBytesLeft > 0 {
   395| 		t.writeBytesLeft -= int64(len(p))
   396| 	} else {
   397| 		t.requestKeyExchange()
   398| 	}
   399| 	if t.writePacketsLeft > 0 {
   400| 		t.writePacketsLeft--
   401| 	} else {
   402| 		t.requestKeyExchange()
   403| 	}
   404| 	if err := t.pushPacket(p); err != nil {
   405| 		t.writeError = err
   406| 		t.writeCond.Broadcast()
   407| 	}
   408| 	return nil
   409| }
   410| func (t *handshakeTransport) Close() error {
   411| 	err := t.conn.Close()
   412| 	<-t.kexLoopDone
   413| 	return err
   414| }
   415| func (t *handshakeTransport) enterKeyExchange(otherInitPacket []byte) error {
   416| 	if debugHandshake {
   417| 		log.Printf("%s entered key exchange", t.id())
   418| 	}
   419| 	otherInit := &kexInitMsg{}
   420| 	if err := Unmarshal(otherInitPacket, otherInit); err != nil {
   421| 		return err
   422| 	}
   423| 	magics := handshakeMagics{
   424| 		clientVersion: t.clientVersion,
   425| 		serverVersion: t.serverVersion,
   426| 		clientKexInit: otherInitPacket,

