# ====================================================================
# FILE: gogs.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| package main
     2| import (
     3| 	"os"
     4| 	"github.com/urfave/cli"
     5| 	log "unknwon.dev/clog/v2"
     6| 	"gogs.io/gogs/internal/cmd"
     7| 	"gogs.io/gogs/internal/conf"
     8| )
     9| func init() {
    10| 	conf.App.Version = "0.12.8"
    11| }
    12| func main() {
    13| 	app := cli.NewApp()
    14| 	app.Name = "Gogs"
    15| 	app.Usage = "A painless self-hosted Git service"
    16| 	app.Version = conf.App.Version
    17| 	app.Commands = []cli.Command{
    18| 		cmd.Web,
    19| 		cmd.Serv,
    20| 		cmd.Hook,
    21| 		cmd.Cert,
    22| 		cmd.Admin,
    23| 		cmd.Import,
    24| 		cmd.Backup,
    25| 		cmd.Restore,
    26| 	}
    27| 	if err := app.Run(os.Args); err != nil {
    28| 		log.Fatal("Failed to start application: %v", err)
    29| 	}
    30| }


# ====================================================================
# FILE: internal/db/pull.go
# Total hunks: 2
# ====================================================================
# --- HUNK 1: Lines 461-504 ---
   461| 	has, err := e.Get(pr)
   462| 	if err != nil {
   463| 		return nil, err
   464| 	} else if !has {
   465| 		return nil, ErrPullRequestNotExist{args: map[string]interface{}{"issueID": issueID}}
   466| 	}
   467| 	return pr, pr.loadAttributes(e)
   468| }
   469| func GetPullRequestByIssueID(issueID int64) (*PullRequest, error) {
   470| 	return getPullRequestByIssueID(x, issueID)
   471| }
   472| func (pr *PullRequest) Update() error {
   473| 	_, err := x.Id(pr.ID).AllCols().Update(pr)
   474| 	return err
   475| }
   476| func (pr *PullRequest) UpdateCols(cols ...string) error {
   477| 	_, err := x.Id(pr.ID).Cols(cols...).Update(pr)
   478| 	return err
   479| }
   480| func (pr *PullRequest) UpdatePatch() (err error) {
   481| 	if pr.HeadRepo == nil {
   482| 		log.Trace("PullRequest[%d].UpdatePatch: ignored cruppted data", pr.ID)
   483| 		return nil
   484| 	}
   485| 	headGitRepo, err := git.Open(pr.HeadRepo.RepoPath())
   486| 	if err != nil {
   487| 		return fmt.Errorf("open repository: %v", err)
   488| 	}
   489| 	tmpRemote := com.ToStr(time.Now().UnixNano())
   490| 	baseRepoPath := RepoPath(pr.BaseRepo.MustOwner().Name, pr.BaseRepo.Name)
   491| 	err = headGitRepo.AddRemote(tmpRemote, baseRepoPath, git.AddRemoteOptions{Fetch: true})
   492| 	if err != nil {
   493| 		return fmt.Errorf("add remote %q [repo_id: %d]: %v", tmpRemote, pr.HeadRepoID, err)
   494| 	}
   495| 	defer func() {
   496| 		if err := headGitRepo.RemoveRemote(tmpRemote); err != nil {
   497| 			log.Error("Failed to remove remote %q [repo_id: %d]: %v", tmpRemote, pr.HeadRepoID, err)
   498| 		}
   499| 	}()
   500| 	remoteBranch := "remotes/" + tmpRemote + "/" + pr.BaseBranch
   501| 	pr.MergeBase, err = headGitRepo.MergeBase(remoteBranch, pr.HeadBranch)
   502| 	if err != nil {
   503| 		return fmt.Errorf("get merge base: %v", err)
   504| 	} else if err = pr.Update(); err != nil {

# --- HUNK 2: Lines 570-609 ---
   570| 		return fmt.Errorf("find issues: %v", err)
   571| 	}
   572| 	for i := range issues {
   573| 		set[issues[i].ID] = issues[i]
   574| 	}
   575| 	for i := range prs {
   576| 		prs[i].Issue = set[prs[i].IssueID]
   577| 	}
   578| 	for i := range prs {
   579| 		if err = prs[i].loadAttributes(e); err != nil {
   580| 			return fmt.Errorf("loadAttributes [%d]: %v", prs[i].ID, err)
   581| 		}
   582| 	}
   583| 	return nil
   584| }
   585| func (prs PullRequestList) LoadAttributes() error {
   586| 	return prs.loadAttributes(x)
   587| }
   588| func addHeadRepoTasks(prs []*PullRequest) {
   589| 	for _, pr := range prs {
   590| 		log.Trace("addHeadRepoTasks[%d]: composing new test task", pr.ID)
   591| 		if err := pr.UpdatePatch(); err != nil {
   592| 			log.Error("UpdatePatch: %v", err)
   593| 			continue
   594| 		} else if err := pr.PushToBaseRepo(); err != nil {
   595| 			log.Error("PushToBaseRepo: %v", err)
   596| 			continue
   597| 		}
   598| 		pr.AddToTaskQueue()
   599| 	}
   600| }
   601| func AddTestPullRequestTask(doer *User, repoID int64, branch string, isSync bool) {
   602| 	log.Trace("AddTestPullRequestTask [head_repo_id: %d, head_branch: %s]: finding pull requests", repoID, branch)
   603| 	prs, err := GetUnmergedPullRequestsByHeadInfo(repoID, branch)
   604| 	if err != nil {
   605| 		log.Error("Find pull requests [head_repo_id: %d, head_branch: %s]: %v", repoID, branch, err)
   606| 		return
   607| 	}
   608| 	if isSync {
   609| 		if err = PullRequestList(prs).LoadAttributes(); err != nil {


# ====================================================================
# FILE: internal/db/repo.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 690-730 ---
   690| 			return repo, fmt.Errorf("cleanUpMigrateGitConfig.(wiki): %v", err)
   691| 		}
   692| 	}
   693| 	return repo, UpdateRepository(repo, false)
   694| }
   695| func initRepoCommit(tmpPath string, sig *git.Signature) (err error) {
   696| 	var stderr string
   697| 	if _, stderr, err = process.ExecDir(-1,
   698| 		tmpPath, fmt.Sprintf("initRepoCommit (git add): %s", tmpPath),
   699| 		"git", "add", "--all"); err != nil {
   700| 		return fmt.Errorf("git add: %s", stderr)
   701| 	}
   702| 	if _, stderr, err = process.ExecDir(-1,
   703| 		tmpPath, fmt.Sprintf("initRepoCommit (git commit): %s", tmpPath),
   704| 		"git", "commit", fmt.Sprintf("--author='%s <%s>'", sig.Name, sig.Email),
   705| 		"-m", "Initial commit"); err != nil {
   706| 		return fmt.Errorf("git commit: %s", stderr)
   707| 	}
   708| 	if _, stderr, err = process.ExecDir(-1,
   709| 		tmpPath, fmt.Sprintf("initRepoCommit (git push): %s", tmpPath),
   710| 		"git", "push", "origin", "master"); err != nil {
   711| 		return fmt.Errorf("git push: %s", stderr)
   712| 	}
   713| 	return nil
   714| }
   715| type CreateRepoOptions struct {
   716| 	Name        string
   717| 	Description string
   718| 	Gitignores  string
   719| 	License     string
   720| 	Readme      string
   721| 	IsPrivate   bool
   722| 	IsMirror    bool
   723| 	AutoInit    bool
   724| }
   725| func getRepoInitFile(tp, name string) ([]byte, error) {
   726| 	relPath := path.Join("conf", tp, strings.TrimLeft(path.Clean("/"+name), "/"))
   727| 	customPath := filepath.Join(conf.CustomDir(), relPath)
   728| 	if osutil.IsFile(customPath) {
   729| 		return ioutil.ReadFile(customPath)
   730| 	}


# ====================================================================
# FILE: internal/db/repo_editor.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 324-366 ---
   324| 		if IsErrUploadNotExist(err) {
   325| 			return nil
   326| 		}
   327| 		return fmt.Errorf("get upload by UUID[%s]: %v", uuid, err)
   328| 	}
   329| 	if err := DeleteUpload(upload); err != nil {
   330| 		return fmt.Errorf("delete upload: %v", err)
   331| 	}
   332| 	return nil
   333| }
   334| type UploadRepoFileOptions struct {
   335| 	LastCommitID string
   336| 	OldBranch    string
   337| 	NewBranch    string
   338| 	TreePath     string
   339| 	Message      string
   340| 	Files        []string // In UUID format
   341| }
   342| func isRepositoryGitPath(path string) bool {
   343| 	return strings.HasSuffix(path, ".git") ||
   344| 		strings.Contains(path, ".git"+string(os.PathSeparator)) ||
   345| 		strings.HasSuffix(path, ".git.") ||
   346| 		strings.Contains(path, ".git."+string(os.PathSeparator))
   347| }
   348| func (repo *Repository) UploadRepoFiles(doer *User, opts UploadRepoFileOptions) error {
   349| 	if len(opts.Files) == 0 {
   350| 		return nil
   351| 	}
   352| 	if isRepositoryGitPath(opts.TreePath) {
   353| 		return errors.Errorf("bad tree path %q", opts.TreePath)
   354| 	}
   355| 	uploads, err := GetUploadsByUUIDs(opts.Files)
   356| 	if err != nil {
   357| 		return fmt.Errorf("get uploads by UUIDs[%v]: %v", opts.Files, err)
   358| 	}
   359| 	repoWorkingPool.CheckIn(com.ToStr(repo.ID))
   360| 	defer repoWorkingPool.CheckOut(com.ToStr(repo.ID))
   361| 	if err = repo.DiscardLocalRepoBranchChanges(opts.OldBranch); err != nil {
   362| 		return fmt.Errorf("discard local repo branch[%s] changes: %v", opts.OldBranch, err)
   363| 	} else if err = repo.UpdateLocalCopyBranch(opts.OldBranch); err != nil {
   364| 		return fmt.Errorf("update local copy branch[%s]: %v", opts.OldBranch, err)
   365| 	}
   366| 	if opts.OldBranch != opts.NewBranch {


# ====================================================================
# FILE: internal/pathutil/pathutil.go
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| package pathutil
     2| import (
     3| 	"path"
     4| 	"strings"
     5| )
     6| func Clean(p string) string {
     7| 	return strings.Trim(path.Clean("/"+p), "/")
     8| }


# ====================================================================
# FILE: internal/route/repo/http.go
# Total hunks: 3
# ====================================================================
# --- HUNK 1: Lines 1-38 ---
     1| package repo
     2| import (
     3| 	"bytes"
     4| 	"compress/gzip"
     5| 	"fmt"
     6| 	"net/http"
     7| 	"os"
     8| 	"os/exec"
     9| 	"path"
    10| 	"path/filepath"
    11| 	"strconv"
    12| 	"strings"
    13| 	"time"
    14| 	"gopkg.in/macaron.v1"
    15| 	log "unknwon.dev/clog/v2"
    16| 	"gogs.io/gogs/internal/conf"
    17| 	"gogs.io/gogs/internal/db"
    18| 	"gogs.io/gogs/internal/lazyregexp"
    19| 	"gogs.io/gogs/internal/tool"
    20| )
    21| type HTTPContext struct {
    22| 	*macaron.Context
    23| 	OwnerName string
    24| 	OwnerSalt string
    25| 	RepoID    int64
    26| 	RepoName  string
    27| 	AuthUser  *db.User
    28| }
    29| func askCredentials(c *macaron.Context, status int, text string) {
    30| 	c.Header().Set("WWW-Authenticate", "Basic realm=\".\"")
    31| 	c.Error(status, text)
    32| }
    33| func HTTPContexter() macaron.Handler {
    34| 	return func(c *macaron.Context) {
    35| 		if len(conf.HTTP.AccessControlAllowOrigin) > 0 {
    36| 			c.Header().Set("Access-Control-Allow-Origin", conf.HTTP.AccessControlAllowOrigin)
    37| 			c.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, User-Agent")
    38| 			if c.Req.Method == "OPTIONS" {

# --- HUNK 2: Lines 60-100 ---
    60| 		if err != nil {
    61| 			if db.IsErrRepoNotExist(err) {
    62| 				c.Status(http.StatusNotFound)
    63| 			} else {
    64| 				c.Status(http.StatusInternalServerError)
    65| 				log.Error("Failed to get repository [owner_id: %d, name: %s]: %v", owner.ID, repoName, err)
    66| 			}
    67| 			return
    68| 		}
    69| 		if isPull && !repo.IsPrivate && !conf.Auth.RequireSigninView {
    70| 			c.Map(&HTTPContext{
    71| 				Context: c,
    72| 			})
    73| 			return
    74| 		}
    75| 		action := c.Params("*")
    76| 		if !strings.Contains(action, "git-") &&
    77| 			!strings.Contains(action, "info/") &&
    78| 			!strings.Contains(action, "HEAD") &&
    79| 			!strings.Contains(action, "objects/") {
    80| 			c.NotFound()
    81| 			return
    82| 		}
    83| 		authHead := c.Req.Header.Get("Authorization")
    84| 		if len(authHead) == 0 {
    85| 			askCredentials(c, http.StatusUnauthorized, "")
    86| 			return
    87| 		}
    88| 		auths := strings.Fields(authHead)
    89| 		if len(auths) != 2 || auths[0] != "Basic" {
    90| 			askCredentials(c, http.StatusUnauthorized, "")
    91| 			return
    92| 		}
    93| 		authUsername, authPassword, err := tool.BasicAuthDecode(auths[1])
    94| 		if err != nil {
    95| 			askCredentials(c, http.StatusUnauthorized, "")
    96| 			return
    97| 		}
    98| 		authUser, err := db.Users.Authenticate(authUsername, authPassword, -1)
    99| 		if err != nil && !db.IsErrUserNotExist(err) {
   100| 			c.Status(http.StatusInternalServerError)

# --- HUNK 3: Lines 314-358 ---
   314| 		dir += ".git"
   315| 	}
   316| 	filename := filepath.Join(conf.Repository.Root, dir)
   317| 	if _, err := os.Stat(filename); os.IsNotExist(err) {
   318| 		return "", err
   319| 	}
   320| 	return filename, nil
   321| }
   322| func HTTP(c *HTTPContext) {
   323| 	for _, route := range routes {
   324| 		reqPath := strings.ToLower(c.Req.URL.Path)
   325| 		m := route.re.FindStringSubmatch(reqPath)
   326| 		if m == nil {
   327| 			continue
   328| 		}
   329| 		if conf.Repository.DisableHTTPGit {
   330| 			c.Error(http.StatusForbidden, "Interacting with repositories by HTTP protocol is disabled")
   331| 			return
   332| 		}
   333| 		if route.method != c.Req.Method {
   334| 			c.NotFound()
   335| 			return
   336| 		}
   337| 		file := strings.TrimPrefix(reqPath, m[1]+"/")
   338| 		dir, err := getGitRepoPath(m[1])
   339| 		if err != nil {
   340| 			log.Warn("HTTP.getGitRepoPath: %v", err)
   341| 			c.NotFound()
   342| 			return
   343| 		}
   344| 		route.handler(serviceHandler{
   345| 			w:    c.Resp,
   346| 			r:    c.Req.Request,
   347| 			dir:  dir,
   348| 			file: file,
   349| 			authUser:  c.AuthUser,
   350| 			ownerName: c.OwnerName,
   351| 			ownerSalt: c.OwnerSalt,
   352| 			repoID:    c.RepoID,
   353| 			repoName:  c.RepoName,
   354| 		})
   355| 		return
   356| 	}
   357| 	c.NotFound()
   358| }

