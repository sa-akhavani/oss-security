--- a//dev/null
+++ b/src/Pixie/AliasFacade.php
@@ -0,0 +1,36 @@
+<?php namespace Pixie;
+use Pixie\QueryBuilder\QueryBuilderHandler;
+/**
+ * This class gives the ability to access non-static methods statically
+ *
+ * Class AliasFacade
+ *
+ * @package Pixie
+ */
+class AliasFacade
+{
+    /**
+     * @var QueryBuilderHandler
+     */
+    protected static $queryBuilderInstance;
+    /**
+     * @param $method
+     * @param $args
+     *
+     * @return mixed
+     */
+    public static function __callStatic($method, $args)
+    {
+        if (!static::$queryBuilderInstance) {
+            static::$queryBuilderInstance = new QueryBuilderHandler();
+        }
+        return call_user_func_array(array(static::$queryBuilderInstance, $method), $args);
+    }
+    /**
+     * @param QueryBuilderHandler $queryBuilderInstance
+     */
+    public static function setQueryBuilderInstance($queryBuilderInstance)
+    {
+        static::$queryBuilderInstance = $queryBuilderInstance;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/Connection.php
@@ -0,0 +1,149 @@
+<?php namespace Pixie;
+use Pixie\QueryBuilder\Raw;
+use Viocon\Container;
+class Connection
+{
+    /**
+     * @var Container
+     */
+    protected $container;
+    /**
+     * @var string
+     */
+    protected $adapter;
+    /**
+     * @var array
+     */
+    protected $adapterConfig;
+    /**
+     * @var \PDO
+     */
+    protected $pdoInstance;
+    /**
+     * @var Connection
+     */
+    protected static $storedConnection;
+    /**
+     * @var EventHandler
+     */
+    protected $eventHandler;
+    /**
+     * @param               $adapter
+     * @param array         $adapterConfig
+     * @param null|string   $alias
+     * @param Container     $container
+     */
+    public function __construct($adapter, array $adapterConfig, $alias = null, Container $container = null)
+    {
+        $container = $container ? : new Container();
+        $this->container = $container;
+        $this->setAdapter($adapter)->setAdapterConfig($adapterConfig)->connect();
+        $this->eventHandler = $this->container->build('\\Pixie\\EventHandler');
+        if ($alias) {
+            $this->createAlias($alias);
+        }
+    }
+    /**
+     * Create an easily accessible query builder alias
+     *
+     * @param $alias
+     */
+    public function createAlias($alias)
+    {
+        class_alias('Pixie\\AliasFacade', $alias);
+        $builder = $this->container->build('\\Pixie\\QueryBuilder\\QueryBuilderHandler', array($this));
+        AliasFacade::setQueryBuilderInstance($builder);
+    }
+    /**
+     * Returns an instance of Query Builder
+     */
+    public function getQueryBuilder()
+    {
+        return $this->container->build('\\Pixie\\QueryBuilder\\QueryBuilderHandler', array($this));
+    }
+    /**
+     * Create the connection adapter
+     */
+    protected function connect()
+    {
+        $adapter = '\\Pixie\\ConnectionAdapters\\' . ucfirst(strtolower($this->adapter));
+        $adapterInstance = $this->container->build($adapter, array($this->container));
+        $pdo = $adapterInstance->connect($this->adapterConfig);
+        $this->setPdoInstance($pdo);
+        if (!static::$storedConnection) {
+            static::$storedConnection = $this;
+        }
+    }
+    /**
+     * @param \PDO $pdo
+     *
+     * @return $this
+     */
+    public function setPdoInstance(\PDO $pdo)
+    {
+        $this->pdoInstance = $pdo;
+        return $this;
+    }
+    /**
+     * @return \PDO
+     */
+    public function getPdoInstance()
+    {
+        return $this->pdoInstance;
+    }
+    /**
+     * @param $adapter
+     *
+     * @return $this
+     */
+    public function setAdapter($adapter)
+    {
+        $this->adapter = $adapter;
+        return $this;
+    }
+    /**
+     * @return string
+     */
+    public function getAdapter()
+    {
+        return $this->adapter;
+    }
+    /**
+     * @param array $adapterConfig
+     *
+     * @return $this
+     */
+    public function setAdapterConfig(array $adapterConfig)
+    {
+        $this->adapterConfig = $adapterConfig;
+        return $this;
+    }
+    /**
+     * @return array
+     */
+    public function getAdapterConfig()
+    {
+        return $this->adapterConfig;
+    }
+    /**
+     * @return Container
+     */
+    public function getContainer()
+    {
+        return $this->container;
+    }
+    /**
+     * @return EventHandler
+     */
+    public function getEventHandler()
+    {
+        return $this->eventHandler;
+    }
+    /**
+     * @return Connection
+     */
+    public static function getStoredConnection()
+    {
+        return static::$storedConnection;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/ConnectionAdapters/BaseAdapter.php
@@ -0,0 +1,33 @@
+<?php namespace Pixie\ConnectionAdapters;
+abstract class BaseAdapter
+{
+    /**
+     * @var \Viocon\Container
+     */
+    protected $container;
+    /**
+     * @param \Viocon\Container $container
+     */
+    public function __construct(\Viocon\Container $container)
+    {
+        $this->container = $container;
+    }
+    /**
+     * @param $config
+     *
+     * @return \PDO
+     */
+    public function connect($config)
+    {
+        if (!isset($config['options'])) {
+            $config['options'] = array();
+        }
+        return $this->doConnect($config);
+    }
+    /**
+     * @param $config
+     *
+     * @return mixed
+     */
+    abstract protected function doConnect($config);
+}

--- a//dev/null
+++ b/src/Pixie/ConnectionAdapters/Mysql.php
@@ -0,0 +1,30 @@
+<?php namespace Pixie\ConnectionAdapters;
+class Mysql extends BaseAdapter
+{
+    /**
+     * @param $config
+     *
+     * @return mixed
+     */
+    protected function doConnect($config)
+    {
+        $connectionString = "mysql:dbname={$config['database']}";
+        if (isset($config['host'])) {
+            $connectionString .= ";host={$config['host']}";
+        }
+        if (isset($config['port'])) {
+            $connectionString .= ";port={$config['port']}";
+        }
+        if (isset($config['unix_socket'])) {
+            $connectionString .= ";unix_socket={$config['unix_socket']}";
+        }
+        $connection = $this->container->build(
+            '\PDO',
+            array($connectionString, $config['username'], $config['password'], $config['options'])
+        );
+        if (isset($config['charset'])) {
+            $connection->prepare("SET NAMES '{$config['charset']}'")->execute();
+        }
+        return $connection;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/ConnectionAdapters/Pgsql.php
@@ -0,0 +1,27 @@
+<?php namespace Pixie\ConnectionAdapters;
+class Pgsql extends BaseAdapter
+{
+    /**
+     * @param $config
+     *
+     * @return mixed
+     */
+    protected function doConnect($config)
+    {
+        $connectionString = "pgsql:host={$config['host']};dbname={$config['database']}";
+        if (isset($config['port'])) {
+            $connectionString .= ";port={$config['port']}";
+        }
+        $connection = $this->container->build(
+            '\PDO',
+            array($connectionString, $config['username'], $config['password'], $config['options'])
+        );
+        if (isset($config['charset'])) {
+            $connection->prepare("SET NAMES '{$config['charset']}'")->execute();
+        }
+        if (isset($config['schema'])) {
+            $connection->prepare("SET search_path TO '{$config['schema']}'")->execute();
+        }
+        return $connection;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/ConnectionAdapters/Sqlite.php
@@ -0,0 +1,17 @@
+<?php namespace Pixie\ConnectionAdapters;
+class Sqlite extends BaseAdapter
+{
+    /**
+     * @param $config
+     *
+     * @return mixed
+     */
+    public function doConnect($config)
+    {
+        $connectionString = 'sqlite:' . $config['database'];
+        return $this->container->build(
+            '\PDO',
+            array($connectionString, null, null, $config['options'])
+        );
+    }
+}

--- a//dev/null
+++ b/src/Pixie/EventHandler.php
@@ -0,0 +1,79 @@
+<?php namespace Pixie;
+use Pixie\QueryBuilder\QueryBuilderHandler;
+use Pixie\QueryBuilder\Raw;
+class EventHandler
+{
+    /**
+     * @var array
+     */
+    protected $events = array();
+    /**
+     * @var array
+     */
+    protected $firedEvents = array();
+    /**
+     * @return array
+     */
+    public function getEvents()
+    {
+        return $this->events;
+    }
+    /**
+     * @param $event
+     * @param $table
+     *
+     * @return callable|null
+     */
+    public function getEvent($event, $table = ':any')
+    {
+        if ($table instanceof Raw) {
+            return null;
+        }
+        return isset($this->events[$table][$event]) ? $this->events[$table][$event] : null;
+    }
+    /**
+     * @param          $event
+     * @param string   $table
+     * @param callable $action
+     *
+     * @return void
+     */
+    public function registerEvent($event, $table, \Closure $action)
+    {
+        $table = $table ?: ':any';
+        $this->events[$table][$event] = $action;
+    }
+    /**
+     * @param          $event
+     * @param string   $table
+     *
+     * @return void
+     */
+    public function removeEvent($event, $table = ':any')
+    {
+        unset($this->events[$table][$event]);
+    }
+    /**
+     * @param QueryBuilderHandler $queryBuilder
+     * @param                     $event
+     * @return mixed
+     */
+    public function fireEvents($queryBuilder, $event)
+    {
+        $statements = $queryBuilder->getStatements();
+        $tables = isset($statements['tables']) ? $statements['tables'] : array();
+        array_unshift($tables, ':any');
+        foreach ($tables as $table) {
+            if ($action = $this->getEvent($event, $table)) {
+                $eventId = $event . $table;
+                $handlerParams = func_get_args();
+                unset($handlerParams[1]); // we do not need $event
+                $this->firedEvents[] = $eventId;
+                $result = call_user_func_array($action, $handlerParams);
+                if (!is_null($result)) {
+                    return $result;
+                };
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/src/Pixie/Exception.php
@@ -0,0 +1,4 @@
+<?php namespace Pixie;
+class Exception extends \Exception
+{
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Adapters/BaseAdapter.php
@@ -0,0 +1,427 @@
+<?php namespace Pixie\QueryBuilder\Adapters;
+use Pixie\Connection;
+use Pixie\Exception;
+use Pixie\QueryBuilder\Raw;
+abstract class BaseAdapter
+{
+    /**
+     * @var \Pixie\Connection
+     */
+    protected $connection;
+    /**
+     * @var \Viocon\Container
+     */
+    protected $container;
+    public function __construct(Connection $connection)
+    {
+        $this->connection = $connection;
+        $this->container = $this->connection->getContainer();
+    }
+    /**
+     * Build select query string and bindings
+     *
+     * @param $statements
+     *
+     * @throws Exception
+     * @return array
+     */
+    public function select($statements)
+    {
+        if (!array_key_exists('tables', $statements)) {
+            throw new Exception('No table specified.', 3);
+        } elseif (!array_key_exists('selects', $statements)) {
+            $statements['selects'][] = '*';
+        }
+        $tables = $this->arrayStr($statements['tables'], ', ');
+        $selects = $this->arrayStr($statements['selects'], ', ');
+        list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
+        $groupBys = '';
+        if (isset($statements['groupBys']) && $groupBys = $this->arrayStr($statements['groupBys'], ', ')) {
+            $groupBys = 'GROUP BY ' . $groupBys;
+        }
+        $orderBys = '';
+        if (isset($statements['orderBys']) && is_array($statements['orderBys'])) {
+            foreach ($statements['orderBys'] as $orderBy) {
+                $orderBys .= $this->wrapSanitizer($orderBy['field']) . ' ' . $orderBy['type'] . ', ';
+            }
+            if ($orderBys = trim($orderBys, ', ')) {
+                $orderBys = 'ORDER BY ' . $orderBys;
+            }
+        }
+        $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
+        $offset = isset($statements['offset']) ? 'OFFSET ' . $statements['offset'] : '';
+        list($havingCriteria, $havingBindings) = $this->buildCriteriaWithType($statements, 'havings', 'HAVING');
+        $joinString = $this->buildJoin($statements);
+        $sqlArray = array(
+            'SELECT' . (isset($statements['distinct']) ? ' DISTINCT' : ''),
+            $selects,
+            'FROM',
+            $tables,
+            $joinString,
+            $whereCriteria,
+            $groupBys,
+            $havingCriteria,
+            $orderBys,
+            $limit,
+            $offset
+        );
+        $sql = $this->concatenateQuery($sqlArray);
+        $bindings = array_merge(
+            $whereBindings,
+            $havingBindings
+        );
+        return compact('sql', 'bindings');
+    }
+    /**
+     * Build just criteria part of the query
+     *
+     * @param      $statements
+     * @param bool $bindValues
+     *
+     * @return array
+     */
+    public function criteriaOnly($statements, $bindValues = true)
+    {
+        $sql = $bindings = array();
+        if (!isset($statements['criteria'])) {
+            return compact('sql', 'bindings');
+        }
+        list($sql, $bindings) = $this->buildCriteria($statements['criteria'], $bindValues);
+        return compact('sql', 'bindings');
+    }
+    /**
+     * Build a generic insert/ignore/replace query
+     *
+     * @param       $statements
+     * @param array $data
+     *
+     * @return array
+     * @throws Exception
+     */
+    private function doInsert($statements, array $data, $type)
+    {
+        if (!isset($statements['tables'])) {
+            throw new Exception('No table specified', 3);
+        }
+        $table = end($statements['tables']);
+        $bindings = $keys = $values = array();
+        foreach ($data as $key => $value) {
+            $keys[] = $key;
+            if ($value instanceof Raw) {
+                $values[] = (string) $value;
+            } else {
+                $values[] =  '?';
+                $bindings[] = $value;
+            }
+        }
+        $sqlArray = array(
+            $type . ' INTO',
+            $this->wrapSanitizer($table),
+            '(' . $this->arrayStr($keys, ',') . ')',
+            'VALUES',
+            '(' . $this->arrayStr($values, ',', false) . ')',
+        );
+        if (isset($statements['onduplicate'])) {
+            if (count($statements['onduplicate']) < 1) {
+                throw new Exception('No data given.', 4);
+            }
+            list($updateStatement, $updateBindings) = $this->getUpdateStatement($statements['onduplicate']);
+            $sqlArray[] = 'ON DUPLICATE KEY UPDATE ' . $updateStatement;
+            $bindings = array_merge($bindings, $updateBindings);
+        }
+        $sql = $this->concatenateQuery($sqlArray, ' ', false);
+        return compact('sql', 'bindings');
+    }
+    /**
+     * Build Insert query
+     *
+     * @param       $statements
+     * @param array $data
+     *
+     * @return array
+     * @throws Exception
+     */
+    public function insert($statements, array $data)
+    {
+        return $this->doInsert($statements, $data, 'INSERT');
+    }
+    /**
+     * Build Insert Ignore query
+     *
+     * @param       $statements
+     * @param array $data
+     *
+     * @return array
+     * @throws Exception
+     */
+    public function insertIgnore($statements, array $data)
+    {
+        return $this->doInsert($statements, $data, 'INSERT IGNORE');
+    }
+    /**
+     * Build Insert Ignore query
+     *
+     * @param       $statements
+     * @param array $data
+     *
+     * @return array
+     * @throws Exception
+     */
+    public function replace($statements, array $data)
+    {
+        return $this->doInsert($statements, $data, 'REPLACE');
+    }
+    /**
+     * Build fields assignment part of SET ... or ON DUBLICATE KEY UPDATE ... statements
+     *
+     * @param array $data
+     *
+     * @return array
+     */
+    private function getUpdateStatement($data)
+    {
+        $bindings = array();
+        $statement = '';
+        foreach ($data as $key => $value) {
+            if ($value instanceof Raw) {
+                $statement .= $this->wrapSanitizer($key) . '=' . $value . ',';
+            } else {
+                $statement .= $this->wrapSanitizer($key) . '=?,';
+                $bindings[] = $value;
+            }
+        }
+        $statement = trim($statement, ',');
+        return array($statement, $bindings);
+    }
+    /**
+     * Build update query
+     *
+     * @param       $statements
+     * @param array $data
+     *
+     * @return array
+     * @throws Exception
+     */
+    public function update($statements, array $data)
+    {
+        if (!isset($statements['tables'])) {
+            throw new Exception('No table specified', 3);
+        } elseif (count($data) < 1) {
+            throw new Exception('No data given.', 4);
+        }
+        $table = end($statements['tables']);
+        list($updateStatement, $bindings) = $this->getUpdateStatement($data);
+        list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
+        $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
+        $sqlArray = array(
+            'UPDATE',
+            $this->wrapSanitizer($table),
+            'SET ' . $updateStatement,
+            $whereCriteria,
+            $limit
+        );
+        $sql = $this->concatenateQuery($sqlArray, ' ', false);
+        $bindings = array_merge($bindings, $whereBindings);
+        return compact('sql', 'bindings');
+    }
+    /**
+     * Build delete query
+     *
+     * @param $statements
+     *
+     * @return array
+     * @throws Exception
+     */
+    public function delete($statements)
+    {
+        if (!isset($statements['tables'])) {
+            throw new Exception('No table specified', 3);
+        }
+        $table = end($statements['tables']);
+        list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
+        $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
+        $sqlArray = array('DELETE FROM', $this->wrapSanitizer($table), $whereCriteria);
+        $sql = $this->concatenateQuery($sqlArray, ' ', false);
+        $bindings = $whereBindings;
+        return compact('sql', 'bindings');
+    }
+    /**
+     * Array concatenating method, like implode.
+     * But it does wrap sanitizer and trims last glue
+     *
+     * @param array $pieces
+     * @param       $glue
+     * @param bool  $wrapSanitizer
+     *
+     * @return string
+     */
+    protected function arrayStr(array $pieces, $glue, $wrapSanitizer = true)
+    {
+        $str = '';
+        foreach ($pieces as $key => $piece) {
+            if ($wrapSanitizer) {
+                $piece = $this->wrapSanitizer($piece);
+            }
+            if (!is_int($key)) {
+                $piece = ($wrapSanitizer ? $this->wrapSanitizer($key) : $key) . ' AS ' . $piece;
+            }
+            $str .= $piece . $glue;
+        }
+        return trim($str, $glue);
+    }
+    /**
+     * Join different part of queries with a space.
+     *
+     * @param array $pieces
+     *
+     * @return string
+     */
+    protected function concatenateQuery(array $pieces)
+    {
+        $str = '';
+        foreach ($pieces as $piece) {
+            $str = trim($str) . ' ' . trim($piece);
+        }
+        return trim($str);
+    }
+    /**
+     * Build generic criteria string and bindings from statements, like "a = b and c = ?"
+     *
+     * @param      $statements
+     * @param bool $bindValues
+     *
+     * @return array
+     */
+    protected function buildCriteria($statements, $bindValues = true)
+    {
+        $criteria = '';
+        $bindings = array();
+        foreach ($statements as $statement) {
+            $key = $this->wrapSanitizer($statement['key']);
+            $value = $statement['value'];
+            if (is_null($value) && $key instanceof \Closure) {
+                $nestedCriteria = $this->container->build(
+                    '\\Pixie\\QueryBuilder\\NestedCriteria',
+                    array($this->connection)
+                );
+                $nestedCriteria = & $nestedCriteria;
+                $key($nestedCriteria);
+                $queryObject = $nestedCriteria->getQuery('criteriaOnly', true);
+                $bindings = array_merge($bindings, $queryObject->getBindings());
+                $criteria .= $statement['joiner'] . ' (' . $queryObject->getSql() . ') ';
+            } elseif (is_array($value)) {
+                $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'];
+                switch ($statement['operator']) {
+                    case 'BETWEEN':
+                        $bindings = array_merge($bindings, $statement['value']);
+                        $criteria .= ' ? AND ? ';
+                        break;
+                    default:
+                        $valuePlaceholder = '';
+                        foreach ($statement['value'] as $subValue) {
+                            $valuePlaceholder .= '?, ';
+                            $bindings[] = $subValue;
+                        }
+                        $valuePlaceholder = trim($valuePlaceholder, ', ');
+                        $criteria .= ' (' . $valuePlaceholder . ') ';
+                        break;
+                }
+            } elseif ($value instanceof Raw) {
+                $criteria .= "{$statement['joiner']} {$key} {$statement['operator']} $value ";
+            } else {
+                if (!$bindValues) {
+                    $value = $this->wrapSanitizer($value);
+                    $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'] . ' ' . $value . ' ';
+                } elseif ($statement['key'] instanceof Raw) {
+                    $criteria .= $statement['joiner'] . ' ' . $key . ' ';
+                    $bindings = array_merge($bindings, $statement['key']->getBindings());
+                } else {
+                    $valuePlaceholder = '?';
+                    $bindings[] = $value;
+                    $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'] . ' '
+                        . $valuePlaceholder . ' ';
+                }
+            }
+        }
+        $criteria = preg_replace('/^(\s?AND ?|\s?OR ?)|\s$/i', '', $criteria);
+        return array($criteria, $bindings);
+    }
+    /**
+     * Wrap values with adapter's sanitizer like, '`'
+     *
+     * @param $value
+     *
+     * @return string
+     */
+    public function wrapSanitizer($value)
+    {
+        if ($value instanceof Raw) {
+            return (string)$value;
+        } elseif ($value instanceof \Closure) {
+            return $value;
+        }
+        $valueArr = explode('.', $value, 2);
+        foreach ($valueArr as $key => $subValue) {
+            $valueArr[$key] = trim($subValue) == '*' ? $subValue : $this->sanitizer . $subValue . $this->sanitizer;
+        }
+        return implode('.', $valueArr);
+    }
+    /**
+     * Build criteria string and binding with various types added, like WHERE and Having
+     *
+     * @param      $statements
+     * @param      $key
+     * @param      $type
+     * @param bool $bindValues
+     *
+     * @return array
+     */
+    protected function buildCriteriaWithType($statements, $key, $type, $bindValues = true)
+    {
+        $criteria = '';
+        $bindings = array();
+        if (isset($statements[$key])) {
+            list($criteria, $bindings) = $this->buildCriteria($statements[$key], $bindValues);
+            if ($criteria) {
+                $criteria = $type . ' ' . $criteria;
+            }
+        }
+        return array($criteria, $bindings);
+    }
+    /**
+     * Build join string
+     *
+     * @param $statements
+     *
+     * @return array
+     */
+    protected function buildJoin($statements)
+    {
+        $sql = '';
+        if (!array_key_exists('joins', $statements) || !is_array($statements['joins'])) {
+            return $sql;
+        }
+        foreach ($statements['joins'] as $joinArr) {
+            if (is_array($joinArr['table'])) {
+                $mainTable = $joinArr['table'][0];
+                $aliasTable = $joinArr['table'][1];
+                $table = $this->wrapSanitizer($mainTable) . ' AS ' . $this->wrapSanitizer($aliasTable);
+            } else {
+                $table = $joinArr['table'] instanceof Raw ?
+                    (string) $joinArr['table'] :
+                    $this->wrapSanitizer($joinArr['table']);
+            }
+            $joinBuilder = $joinArr['joinBuilder'];
+            $sqlArr = array(
+                $sql,
+                strtoupper($joinArr['type']),
+                'JOIN',
+                $table,
+                'ON',
+                $joinBuilder->getQuery('criteriaOnly', false)->getSql()
+            );
+            $sql = $this->concatenateQuery($sqlArr);
+        }
+        return $sql;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Adapters/Mysql.php
@@ -0,0 +1,8 @@
+<?php namespace Pixie\QueryBuilder\Adapters;
+class Mysql extends BaseAdapter
+{
+    /**
+     * @var string
+     */
+    protected $sanitizer = '`';
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Adapters/Pgsql.php
@@ -0,0 +1,8 @@
+<?php namespace Pixie\QueryBuilder\Adapters;
+class Pgsql extends BaseAdapter
+{
+    /**
+     * @var string
+     */
+    protected $sanitizer = '"';
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Adapters/Sqlite.php
@@ -0,0 +1,8 @@
+<?php namespace Pixie\QueryBuilder\Adapters;
+class Sqlite extends BaseAdapter
+{
+    /**
+     * @var string
+     */
+    protected $sanitizer = '"';
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/JoinBuilder.php
@@ -0,0 +1,41 @@
+<?php namespace Pixie\QueryBuilder;
+class JoinBuilder extends QueryBuilderHandler
+{
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function on($key, $operator, $value)
+    {
+        return $this->joinHandler($key, $operator, $value, 'AND');
+    }
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function orOn($key, $operator, $value)
+    {
+        return $this->joinHandler($key, $operator, $value, 'OR');
+    }
+    /**
+     * @param        $key
+     * @param null   $operator
+     * @param null   $value
+     * @param string $joiner
+     *
+     * @return $this
+     */
+    protected function joinHandler($key, $operator = null, $value = null, $joiner = 'AND')
+    {
+        $key = $this->addTablePrefix($key);
+        $value = $this->addTablePrefix($value);
+        $this->statements['criteria'][] = compact('key', 'operator', 'value', 'joiner');
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/NestedCriteria.php
@@ -0,0 +1,18 @@
+<?php namespace Pixie\QueryBuilder;
+class NestedCriteria extends QueryBuilderHandler
+{
+    /**
+     * @param        $key
+     * @param null   $operator
+     * @param null   $value
+     * @param string $joiner
+     *
+     * @return $this
+     */
+    protected function whereHandler($key, $operator = null, $value = null, $joiner = 'AND')
+    {
+        $key = $this->addTablePrefix($key);
+        $this->statements['criteria'][] = compact('key', 'operator', 'value', 'joiner');
+        return $this;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/QueryBuilderHandler.php
@@ -0,0 +1,904 @@
+<?php namespace Pixie\QueryBuilder;
+use PDO;
+use Pixie\Connection;
+use Pixie\Exception;
+class QueryBuilderHandler
+{
+    /**
+     * @var \Viocon\Container
+     */
+    protected $container;
+    /**
+     * @var Connection
+     */
+    protected $connection;
+    /**
+     * @var array
+     */
+    protected $statements = array();
+    /**
+     * @var \PDO
+     */
+    protected $pdo;
+    /**
+     * @var null|PDOStatement
+     */
+    protected $pdoStatement = null;
+    /**
+     * @var null|string
+     */
+    protected $tablePrefix = null;
+    /**
+     * @var \Pixie\QueryBuilder\Adapters\BaseAdapter
+     */
+    protected $adapterInstance;
+    /**
+     * The PDO fetch parameters to use
+     *
+     * @var array
+     */
+    protected $fetchParameters = array(\PDO::FETCH_OBJ);
+    /**
+     * @param null|\Pixie\Connection $connection
+     *
+     * @throws \Pixie\Exception
+     */
+    public function __construct(Connection $connection = null)
+    {
+        if (is_null($connection)) {
+            if (!$connection = Connection::getStoredConnection()) {
+                throw new Exception('No database connection found.', 1);
+            }
+        }
+        $this->connection = $connection;
+        $this->container = $this->connection->getContainer();
+        $this->pdo = $this->connection->getPdoInstance();
+        $this->adapter = $this->connection->getAdapter();
+        $this->adapterConfig = $this->connection->getAdapterConfig();
+        if (isset($this->adapterConfig['prefix'])) {
+            $this->tablePrefix = $this->adapterConfig['prefix'];
+        }
+        $this->adapterInstance = $this->container->build(
+            '\\Pixie\\QueryBuilder\\Adapters\\' . ucfirst($this->adapter),
+            array($this->connection)
+        );
+        $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
+    }
+    /**
+     * Set the fetch mode
+     *
+     * @param $mode
+     * @return $this
+     */
+    public function setFetchMode($mode)
+    {
+        $this->fetchParameters = func_get_args();
+        return $this;
+    }
+    /**
+     * Fetch query results as object of specified type
+     *
+     * @param $className
+     * @param array $constructorArgs
+     * @return QueryBuilderHandler
+     */
+    public function asObject($className, $constructorArgs = array())
+    {
+        return $this->setFetchMode(\PDO::FETCH_CLASS, $className, $constructorArgs);
+    }
+    /**
+     * @param null|\Pixie\Connection $connection
+     *
+     * @return static
+     */
+    public function newQuery(Connection $connection = null)
+    {
+        if (is_null($connection)) {
+            $connection = $this->connection;
+        }
+        return new static($connection);
+    }
+    /**
+     * @param       $sql
+     * @param array $bindings
+     *
+     * @return $this
+     */
+    public function query($sql, $bindings = array())
+    {
+        list($this->pdoStatement) = $this->statement($sql, $bindings);
+        return $this;
+    }
+    /**
+     * @param       $sql
+     * @param array $bindings
+     *
+     * @return array PDOStatement and execution time as float
+     */
+    public function statement($sql, $bindings = array())
+    {
+        $start = microtime(true);
+        $pdoStatement = $this->pdo->prepare($sql);
+        foreach ($bindings as $key => $value) {
+            $pdoStatement->bindValue(
+                is_int($key) ? $key + 1 : $key,
+                $value,
+                is_int($value) || is_bool($value) ? PDO::PARAM_INT : PDO::PARAM_STR
+            );
+        }
+        $pdoStatement->execute();
+        return array($pdoStatement, microtime(true) - $start);
+    }
+    /**
+     * Get all rows
+     *
+     * @return \stdClass|null
+     */
+    public function get()
+    {
+        $eventResult = $this->fireEvents('before-select');
+        if (!is_null($eventResult)) {
+            return $eventResult;
+        };
+        $executionTime = 0;
+        if (is_null($this->pdoStatement)) {
+            $queryObject = $this->getQuery('select');
+            list($this->pdoStatement, $executionTime) = $this->statement(
+                $queryObject->getSql(),
+                $queryObject->getBindings()
+            );
+        }
+        $start = microtime(true);
+        $result = call_user_func_array(array($this->pdoStatement, 'fetchAll'), $this->fetchParameters);
+        $executionTime += microtime(true) - $start;
+        $this->pdoStatement = null;
+        $this->fireEvents('after-select', $result, $executionTime);
+        return $result;
+    }
+    /**
+     * Get first row
+     *
+     * @return \stdClass|null
+     */
+    public function first()
+    {
+        $this->limit(1);
+        $result = $this->get();
+        return empty($result) ? null : $result[0];
+    }
+    /**
+     * @param        $value
+     * @param string $fieldName
+     *
+     * @return null|\stdClass
+     */
+    public function findAll($fieldName, $value)
+    {
+        $this->where($fieldName, '=', $value);
+        return $this->get();
+    }
+    /**
+     * @param        $value
+     * @param string $fieldName
+     *
+     * @return null|\stdClass
+     */
+    public function find($value, $fieldName = 'id')
+    {
+        $this->where($fieldName, '=', $value);
+        return $this->first();
+    }
+    /**
+     * Get count of rows
+     *
+     * @return int
+     */
+    public function count()
+    {
+        $originalStatements = $this->statements;
+        unset($this->statements['orderBys']);
+        unset($this->statements['limit']);
+        unset($this->statements['offset']);
+        $count = $this->aggregate('count');
+        $this->statements = $originalStatements;
+        return $count;
+    }
+    /**
+     * @param $type
+     *
+     * @return int
+     */
+    protected function aggregate($type)
+    {
+        $mainSelects = isset($this->statements['selects']) ? $this->statements['selects'] : null;
+        $this->statements['selects'] = array($this->raw($type . '(*) as field'));
+        $row = $this->get();
+        if ($mainSelects) {
+            $this->statements['selects'] = $mainSelects;
+        } else {
+            unset($this->statements['selects']);
+        }
+        if (is_array($row[0])) {
+            return (int) $row[0]['field'];
+        } elseif (is_object($row[0])) {
+            return (int) $row[0]->field;
+        }
+        return 0;
+    }
+    /**
+     * @param string $type
+     * @param array  $dataToBePassed
+     *
+     * @return mixed
+     * @throws Exception
+     */
+    public function getQuery($type = 'select', $dataToBePassed = array())
+    {
+        $allowedTypes = array('select', 'insert', 'insertignore', 'replace', 'delete', 'update', 'criteriaonly');
+        if (!in_array(strtolower($type), $allowedTypes)) {
+            throw new Exception($type . ' is not a known type.', 2);
+        }
+        $queryArr = $this->adapterInstance->$type($this->statements, $dataToBePassed);
+        return $this->container->build(
+            '\\Pixie\\QueryBuilder\\QueryObject',
+            array($queryArr['sql'], $queryArr['bindings'], $this->pdo)
+        );
+    }
+    /**
+     * @param QueryBuilderHandler $queryBuilder
+     * @param null                $alias
+     *
+     * @return Raw
+     */
+    public function subQuery(QueryBuilderHandler $queryBuilder, $alias = null)
+    {
+        $sql = '(' . $queryBuilder->getQuery()->getRawSql() . ')';
+        if ($alias) {
+            $sql = $sql . ' as ' . $alias;
+        }
+        return $queryBuilder->raw($sql);
+    }
+    /**
+     * @param $data
+     *
+     * @return array|string
+     */
+    private function doInsert($data, $type)
+    {
+        $eventResult = $this->fireEvents('before-insert');
+        if (!is_null($eventResult)) {
+            return $eventResult;
+        }
+        if (!is_array(current($data))) {
+            $queryObject = $this->getQuery($type, $data);
+            list($result, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
+            $return = $result->rowCount() === 1 ? $this->pdo->lastInsertId() : null;
+        } else {
+            $return = array();
+            $executionTime = 0;
+            foreach ($data as $subData) {
+                $queryObject = $this->getQuery($type, $subData);
+                list($result, $time) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
+                $executionTime += $time;
+                if ($result->rowCount() === 1) {
+                    $return[] = $this->pdo->lastInsertId();
+                }
+            }
+        }
+        $this->fireEvents('after-insert', $return, $executionTime);
+        return $return;
+    }
+    /**
+     * @param $data
+     *
+     * @return array|string
+     */
+    public function insert($data)
+    {
+        return $this->doInsert($data, 'insert');
+    }
+    /**
+     * @param $data
+     *
+     * @return array|string
+     */
+    public function insertIgnore($data)
+    {
+        return $this->doInsert($data, 'insertignore');
+    }
+    /**
+     * @param $data
+     *
+     * @return array|string
+     */
+    public function replace($data)
+    {
+        return $this->doInsert($data, 'replace');
+    }
+    /**
+     * @param $data
+     *
+     * @return $this
+     */
+    public function update($data)
+    {
+        $eventResult = $this->fireEvents('before-update');
+        if (!is_null($eventResult)) {
+            return $eventResult;
+        }
+        $queryObject = $this->getQuery('update', $data);
+        list($response, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
+        $this->fireEvents('after-update', $queryObject, $executionTime);
+        return $response;
+    }
+    /**
+     * @param $data
+     *
+     * @return array|string
+     */
+    public function updateOrInsert($data)
+    {
+        if ($this->first()) {
+            return $this->update($data);
+        } else {
+            return $this->insert($data);
+        }
+    }
+    /**
+     * @param $data
+     *
+     * @return $this
+     */
+    public function onDuplicateKeyUpdate($data)
+    {
+        $this->addStatement('onduplicate', $data);
+        return $this;
+    }
+    /**
+     *
+     */
+    public function delete()
+    {
+        $eventResult = $this->fireEvents('before-delete');
+        if (!is_null($eventResult)) {
+            return $eventResult;
+        }
+        $queryObject = $this->getQuery('delete');
+        list($response, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
+        $this->fireEvents('after-delete', $queryObject, $executionTime);
+        return $response;
+    }
+    /**
+     * @param $tables Single table or multiple tables as an array or as
+     *                multiple parameters
+     *
+     * @return static
+     */
+    public function table($tables)
+    {
+        if (!is_array($tables)) {
+            $tables = func_get_args();
+        }
+        $instance = new static($this->connection);
+        $tables = $this->addTablePrefix($tables, false);
+        $instance->addStatement('tables', $tables);
+        return $instance;
+    }
+    /**
+     * @param $tables
+     *
+     * @return $this
+     */
+    public function from($tables)
+    {
+        if (!is_array($tables)) {
+            $tables = func_get_args();
+        }
+        $tables = $this->addTablePrefix($tables, false);
+        $this->addStatement('tables', $tables);
+        return $this;
+    }
+    /**
+     * @param $fields
+     *
+     * @return $this
+     */
+    public function select($fields)
+    {
+        if (!is_array($fields)) {
+            $fields = func_get_args();
+        }
+        $fields = $this->addTablePrefix($fields);
+        $this->addStatement('selects', $fields);
+        return $this;
+    }
+    /**
+     * @param $fields
+     *
+     * @return $this
+     */
+    public function selectDistinct($fields)
+    {
+        $this->select($fields);
+        $this->addStatement('distinct', true);
+        return $this;
+    }
+    /**
+     * @param $field
+     *
+     * @return $this
+     */
+    public function groupBy($field)
+    {
+        $field = $this->addTablePrefix($field);
+        $this->addStatement('groupBys', $field);
+        return $this;
+    }
+    /**
+     * @param        $fields
+     * @param string $defaultDirection
+     *
+     * @return $this
+     */
+    public function orderBy($fields, $defaultDirection = 'ASC')
+    {
+        if (!is_array($fields)) {
+            $fields = array($fields);
+        }
+        foreach ($fields as $key => $value) {
+            $field = $key;
+            $type = $value;
+            if (is_int($key)) {
+                $field = $value;
+                $type = $defaultDirection;
+            }
+            if (!$field instanceof Raw) {
+                $field = $this->addTablePrefix($field);
+            }
+            $this->statements['orderBys'][] = compact('field', 'type');
+        }
+        return $this;
+    }
+    /**
+     * @param $limit
+     *
+     * @return $this
+     */
+    public function limit($limit)
+    {
+        $this->statements['limit'] = $limit;
+        return $this;
+    }
+    /**
+     * @param $offset
+     *
+     * @return $this
+     */
+    public function offset($offset)
+    {
+        $this->statements['offset'] = $offset;
+        return $this;
+    }
+    /**
+     * @param        $key
+     * @param        $operator
+     * @param        $value
+     * @param string $joiner
+     *
+     * @return $this
+     */
+    public function having($key, $operator, $value, $joiner = 'AND')
+    {
+        $key = $this->addTablePrefix($key);
+        $this->statements['havings'][] = compact('key', 'operator', 'value', 'joiner');
+        return $this;
+    }
+    /**
+     * @param        $key
+     * @param        $operator
+     * @param        $value
+     *
+     * @return $this
+     */
+    public function orHaving($key, $operator, $value)
+    {
+        return $this->having($key, $operator, $value, 'OR');
+    }
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function where($key, $operator = null, $value = null)
+    {
+        if (func_num_args() == 2) {
+            $value = $operator;
+            $operator = '=';
+        }
+        return $this->whereHandler($key, $operator, $value);
+    }
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function orWhere($key, $operator = null, $value = null)
+    {
+        if (func_num_args() == 2) {
+            $value = $operator;
+            $operator = '=';
+        }
+        return $this->whereHandler($key, $operator, $value, 'OR');
+    }
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function whereNot($key, $operator = null, $value = null)
+    {
+        if (func_num_args() == 2) {
+            $value = $operator;
+            $operator = '=';
+        }
+        return $this->whereHandler($key, $operator, $value, 'AND NOT');
+    }
+    /**
+     * @param $key
+     * @param $operator
+     * @param $value
+     *
+     * @return $this
+     */
+    public function orWhereNot($key, $operator = null, $value = null)
+    {
+        if (func_num_args() == 2) {
+            $value = $operator;
+            $operator = '=';
+        }
+        return $this->whereHandler($key, $operator, $value, 'OR NOT');
+    }
+    /**
+     * @param       $key
+     * @param array $values
+     *
+     * @return $this
+     */
+    public function whereIn($key, $values)
+    {
+        return $this->whereHandler($key, 'IN', $values, 'AND');
+    }
+    /**
+     * @param       $key
+     * @param array $values
+     *
+     * @return $this
+     */
+    public function whereNotIn($key, $values)
+    {
+        return $this->whereHandler($key, 'NOT IN', $values, 'AND');
+    }
+    /**
+     * @param       $key
+     * @param array $values
+     *
+     * @return $this
+     */
+    public function orWhereIn($key, $values)
+    {
+        return $this->whereHandler($key, 'IN', $values, 'OR');
+    }
+    /**
+     * @param       $key
+     * @param array $values
+     *
+     * @return $this
+     */
+    public function orWhereNotIn($key, $values)
+    {
+        return $this->whereHandler($key, 'NOT IN', $values, 'OR');
+    }
+    /**
+     * @param $key
+     * @param $valueFrom
+     * @param $valueTo
+     *
+     * @return $this
+     */
+    public function whereBetween($key, $valueFrom, $valueTo)
+    {
+        return $this->whereHandler($key, 'BETWEEN', array($valueFrom, $valueTo), 'AND');
+    }
+    /**
+     * @param $key
+     * @param $valueFrom
+     * @param $valueTo
+     *
+     * @return $this
+     */
+    public function orWhereBetween($key, $valueFrom, $valueTo)
+    {
+        return $this->whereHandler($key, 'BETWEEN', array($valueFrom, $valueTo), 'OR');
+    }
+    /**
+     * @param $key
+     * @return QueryBuilderHandler
+     */
+    public function whereNull($key)
+    {
+        return $this->whereNullHandler($key);
+    }
+    /**
+     * @param $key
+     * @return QueryBuilderHandler
+     */
+    public function whereNotNull($key)
+    {
+        return $this->whereNullHandler($key, 'NOT');
+    }
+    /**
+     * @param $key
+     * @return QueryBuilderHandler
+     */
+    public function orWhereNull($key)
+    {
+        return $this->whereNullHandler($key, '', 'or');
+    }
+    /**
+     * @param $key
+     * @return QueryBuilderHandler
+     */
+    public function orWhereNotNull($key)
+    {
+        return $this->whereNullHandler($key, 'NOT', 'or');
+    }
+    protected function whereNullHandler($key, $prefix = '', $operator = '')
+    {
+        $key = $this->adapterInstance->wrapSanitizer($this->addTablePrefix($key));
+        return $this->{$operator . 'Where'}($this->raw("{$key} IS {$prefix} NULL"));
+    }
+    /**
+     * @param        $table
+     * @param        $key
+     * @param        $operator
+     * @param        $value
+     * @param string $type
+     *
+     * @return $this
+     */
+    public function join($table, $key, $operator = null, $value = null, $type = 'inner')
+    {
+        if (!$key instanceof \Closure) {
+            $key = function ($joinBuilder) use ($key, $operator, $value) {
+                $joinBuilder->on($key, $operator, $value);
+            };
+        }
+        $joinBuilder = $this->container->build('\\Pixie\\QueryBuilder\\JoinBuilder', array($this->connection));
+        $joinBuilder = & $joinBuilder;
+        $key($joinBuilder);
+        $table = $this->addTablePrefix($table, false);
+        $this->statements['joins'][] = compact('type', 'table', 'joinBuilder');
+        return $this;
+    }
+    /**
+     * Runs a transaction
+     *
+     * @param $callback
+     *
+     * @return $this
+     */
+    public function transaction(\Closure $callback)
+    {
+        try {
+            $this->pdo->beginTransaction();
+            $transaction = $this->container->build('\\Pixie\\QueryBuilder\\Transaction', array($this->connection));
+            $callback($transaction);
+            $this->pdo->commit();
+            return $this;
+        } catch (TransactionHaltException $e) {
+            return $this;
+        } catch (\Exception $e) {
+            $this->pdo->rollBack();
+            return $this;
+        }
+    }
+    /**
+     * @param      $table
+     * @param      $key
+     * @param null $operator
+     * @param null $value
+     *
+     * @return $this
+     */
+    public function leftJoin($table, $key, $operator = null, $value = null)
+    {
+        return $this->join($table, $key, $operator, $value, 'left');
+    }
+    /**
+     * @param      $table
+     * @param      $key
+     * @param null $operator
+     * @param null $value
+     *
+     * @return $this
+     */
+    public function rightJoin($table, $key, $operator = null, $value = null)
+    {
+        return $this->join($table, $key, $operator, $value, 'right');
+    }
+    /**
+     * @param      $table
+     * @param      $key
+     * @param null $operator
+     * @param null $value
+     *
+     * @return $this
+     */
+    public function innerJoin($table, $key, $operator = null, $value = null)
+    {
+        return $this->join($table, $key, $operator, $value, 'inner');
+    }
+    /**
+     * Add a raw query
+     *
+     * @param $value
+     * @param $bindings
+     *
+     * @return mixed
+     */
+    public function raw($value, $bindings = array())
+    {
+        return $this->container->build('\\Pixie\\QueryBuilder\\Raw', array($value, $bindings));
+    }
+    /**
+     * Return PDO instance
+     *
+     * @return PDO
+     */
+    public function pdo()
+    {
+        return $this->pdo;
+    }
+    /**
+     * @param Connection $connection
+     *
+     * @return $this
+     */
+    public function setConnection(Connection $connection)
+    {
+        $this->connection = $connection;
+        return $this;
+    }
+    /**
+     * @return Connection
+     */
+    public function getConnection()
+    {
+        return $this->connection;
+    }
+    /**
+     * @param        $key
+     * @param        $operator
+     * @param        $value
+     * @param string $joiner
+     *
+     * @return $this
+     */
+    protected function whereHandler($key, $operator = null, $value = null, $joiner = 'AND')
+    {
+        $key = $this->addTablePrefix($key);
+        $this->statements['wheres'][] = compact('key', 'operator', 'value', 'joiner');
+        return $this;
+    }
+    /**
+     * Add table prefix (if given) on given string.
+     *
+     * @param      $values
+     * @param bool $tableFieldMix If we have mixes of field and table names with a "."
+     *
+     * @return array|mixed
+     */
+    public function addTablePrefix($values, $tableFieldMix = true)
+    {
+        if (is_null($this->tablePrefix)) {
+            return $values;
+        }
+        $single = false;
+        if (!is_array($values)) {
+            $values = array($values);
+            $single = true;
+        }
+        $return = array();
+        foreach ($values as $key => $value) {
+            if ($value instanceof Raw || $value instanceof \Closure) {
+                $return[$key] = $value;
+                continue;
+            }
+            $target = &$value;
+            if (!is_int($key)) {
+                $target = &$key;
+            }
+            if (!$tableFieldMix || ($tableFieldMix && strpos($target, '.') !== false)) {
+                $target = $this->tablePrefix . $target;
+            }
+            $return[$key] = $value;
+        }
+        return $single ? end($return) : $return;
+    }
+    /**
+     * @param $key
+     * @param $value
+     */
+    protected function addStatement($key, $value)
+    {
+        if (!is_array($value)) {
+            $value = array($value);
+        }
+        if (!array_key_exists($key, $this->statements)) {
+            $this->statements[$key] = $value;
+        } else {
+            $this->statements[$key] = array_merge($this->statements[$key], $value);
+        }
+    }
+    /**
+     * @param $event
+     * @param $table
+     *
+     * @return callable|null
+     */
+    public function getEvent($event, $table = ':any')
+    {
+        return $this->connection->getEventHandler()->getEvent($event, $table);
+    }
+    /**
+     * @param          $event
+     * @param string   $table
+     * @param callable $action
+     *
+     * @return void
+     */
+    public function registerEvent($event, $table, \Closure $action)
+    {
+        $table = $table ?: ':any';
+        if ($table != ':any') {
+            $table = $this->addTablePrefix($table, false);
+        }
+        return $this->connection->getEventHandler()->registerEvent($event, $table, $action);
+    }
+    /**
+     * @param          $event
+     * @param string   $table
+     *
+     * @return void
+     */
+    public function removeEvent($event, $table = ':any')
+    {
+        if ($table != ':any') {
+            $table = $this->addTablePrefix($table, false);
+        }
+        return $this->connection->getEventHandler()->removeEvent($event, $table);
+    }
+    /**
+     * @param      $event
+     * @return mixed
+     */
+    public function fireEvents($event)
+    {
+        $params = func_get_args();
+        array_unshift($params, $this);
+        return call_user_func_array(array($this->connection->getEventHandler(), 'fireEvents'), $params);
+    }
+    /**
+     * @return array
+     */
+    public function getStatements()
+    {
+        return $this->statements;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/QueryObject.php
@@ -0,0 +1,80 @@
+<?php namespace Pixie\QueryBuilder;
+class QueryObject
+{
+    /**
+     * @var string
+     */
+    protected $sql;
+    /**
+     * @var array
+     */
+    protected $bindings = array();
+    /**
+     * @var \PDO
+     */
+    protected $pdo;
+    public function __construct($sql, array $bindings, \PDO $pdo)
+    {
+        $this->sql = (string)$sql;
+        $this->bindings = $bindings;
+        $this->pdo = $pdo;
+    }
+    /**
+     * @return string
+     */
+    public function getSql()
+    {
+        return $this->sql;
+    }
+    /**
+     * @return array
+     */
+    public function getBindings()
+    {
+        return $this->bindings;
+    }
+    /**
+     * Get the raw/bound sql
+     *
+     * @return string
+     */
+    public function getRawSql()
+    {
+        return $this->interpolateQuery($this->sql, $this->bindings);
+    }
+    /**
+     * Replaces any parameter placeholders in a query with the value of that
+     * parameter. Useful for debugging. Assumes anonymous parameters from
+     * $params are are in the same order as specified in $query
+     *
+     * Reference: http://stackoverflow.com/a/1376838/656489
+     *
+     * @param string $query  The sql query with parameter placeholders
+     * @param array  $params The array of substitution parameters
+     *
+     * @return string The interpolated query
+     */
+    protected function interpolateQuery($query, $params)
+    {
+        $keys = array();
+        $values = $params;
+        foreach ($params as $key => $value) {
+            if (is_string($key)) {
+                $keys[] = '/:' . $key . '/';
+            } else {
+                $keys[] = '/[?]/';
+            }
+            if (is_string($value)) {
+                $values[$key] = $this->pdo->quote($value);
+            }
+            if (is_array($value)) {
+                $values[$key] = implode(',', $this->pdo->quote($value));
+            }
+            if (is_null($value)) {
+                $values[$key] = 'NULL';
+            }
+        }
+        $query = preg_replace($keys, $values, $query, 1, $count);
+        return $query;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Raw.php
@@ -0,0 +1,28 @@
+<?php namespace Pixie\QueryBuilder;
+class Raw
+{
+    /**
+     * @var string
+     */
+    protected $value;
+    /**
+     * @var array
+     */
+    protected $bindings;
+    public function __construct($value, $bindings = array())
+    {
+        $this->value = (string)$value;
+        $this->bindings = (array)$bindings;
+    }
+    public function getBindings()
+    {
+        return $this->bindings;
+    }
+    /**
+     * @return string
+     */
+    public function __toString()
+    {
+        return (string)$this->value;
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/Transaction.php
@@ -0,0 +1,21 @@
+<?php
+namespace Pixie\QueryBuilder;
+class Transaction extends QueryBuilderHandler
+{
+    /**
+     * Commit the database changes
+     */
+    public function commit()
+    {
+        $this->pdo->commit();
+        throw new TransactionHaltException();
+    }
+    /**
+     * Rollback the database changes
+     */
+    public function rollback()
+    {
+        $this->pdo->rollBack();
+        throw new TransactionHaltException();
+    }
+}

--- a//dev/null
+++ b/src/Pixie/QueryBuilder/TransactionHaltException.php
@@ -0,0 +1,5 @@
+<?php
+namespace Pixie\QueryBuilder;
+class TransactionHaltException extends \Exception
+{
+}
