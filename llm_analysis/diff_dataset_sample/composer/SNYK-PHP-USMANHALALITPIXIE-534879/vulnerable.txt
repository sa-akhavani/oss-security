# ====================================================================
# FILE: src/Pixie/AliasFacade.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php namespace Pixie;
     2| use Pixie\QueryBuilder\QueryBuilderHandler;
     3| /**
     4|  * This class gives the ability to access non-static methods statically
     5|  *
     6|  * Class AliasFacade
     7|  *
     8|  * @package Pixie
     9|  */
    10| class AliasFacade
    11| {
    12|     /**
    13|      * @var QueryBuilderHandler
    14|      */
    15|     protected static $queryBuilderInstance;
    16|     /**
    17|      * @param $method
    18|      * @param $args
    19|      *
    20|      * @return mixed
    21|      */
    22|     public static function __callStatic($method, $args)
    23|     {
    24|         if (!static::$queryBuilderInstance) {
    25|             static::$queryBuilderInstance = new QueryBuilderHandler();
    26|         }
    27|         return call_user_func_array(array(static::$queryBuilderInstance, $method), $args);
    28|     }
    29|     /**
    30|      * @param QueryBuilderHandler $queryBuilderInstance
    31|      */
    32|     public static function setQueryBuilderInstance($queryBuilderInstance)
    33|     {
    34|         static::$queryBuilderInstance = $queryBuilderInstance;
    35|     }
    36| }


# ====================================================================
# FILE: src/Pixie/Connection.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-149 ---
     1| <?php namespace Pixie;
     2| use Pixie\QueryBuilder\Raw;
     3| use Viocon\Container;
     4| class Connection
     5| {
     6|     /**
     7|      * @var Container
     8|      */
     9|     protected $container;
    10|     /**
    11|      * @var string
    12|      */
    13|     protected $adapter;
    14|     /**
    15|      * @var array
    16|      */
    17|     protected $adapterConfig;
    18|     /**
    19|      * @var \PDO
    20|      */
    21|     protected $pdoInstance;
    22|     /**
    23|      * @var Connection
    24|      */
    25|     protected static $storedConnection;
    26|     /**
    27|      * @var EventHandler
    28|      */
    29|     protected $eventHandler;
    30|     /**
    31|      * @param               $adapter
    32|      * @param array         $adapterConfig
    33|      * @param null|string   $alias
    34|      * @param Container     $container
    35|      */
    36|     public function __construct($adapter, array $adapterConfig, $alias = null, Container $container = null)
    37|     {
    38|         $container = $container ? : new Container();
    39|         $this->container = $container;
    40|         $this->setAdapter($adapter)->setAdapterConfig($adapterConfig)->connect();
    41|         $this->eventHandler = $this->container->build('\\Pixie\\EventHandler');
    42|         if ($alias) {
    43|             $this->createAlias($alias);
    44|         }
    45|     }
    46|     /**
    47|      * Create an easily accessible query builder alias
    48|      *
    49|      * @param $alias
    50|      */
    51|     public function createAlias($alias)
    52|     {
    53|         class_alias('Pixie\\AliasFacade', $alias);
    54|         $builder = $this->container->build('\\Pixie\\QueryBuilder\\QueryBuilderHandler', array($this));
    55|         AliasFacade::setQueryBuilderInstance($builder);
    56|     }
    57|     /**
    58|      * Returns an instance of Query Builder
    59|      */
    60|     public function getQueryBuilder()
    61|     {
    62|         return $this->container->build('\\Pixie\\QueryBuilder\\QueryBuilderHandler', array($this));
    63|     }
    64|     /**
    65|      * Create the connection adapter
    66|      */
    67|     protected function connect()
    68|     {
    69|         $adapter = '\\Pixie\\ConnectionAdapters\\' . ucfirst(strtolower($this->adapter));
    70|         $adapterInstance = $this->container->build($adapter, array($this->container));
    71|         $pdo = $adapterInstance->connect($this->adapterConfig);
    72|         $this->setPdoInstance($pdo);
    73|         if (!static::$storedConnection) {
    74|             static::$storedConnection = $this;
    75|         }
    76|     }
    77|     /**
    78|      * @param \PDO $pdo
    79|      *
    80|      * @return $this
    81|      */
    82|     public function setPdoInstance(\PDO $pdo)
    83|     {
    84|         $this->pdoInstance = $pdo;
    85|         return $this;
    86|     }
    87|     /**
    88|      * @return \PDO
    89|      */
    90|     public function getPdoInstance()
    91|     {
    92|         return $this->pdoInstance;
    93|     }
    94|     /**
    95|      * @param $adapter
    96|      *
    97|      * @return $this
    98|      */
    99|     public function setAdapter($adapter)
   100|     {
   101|         $this->adapter = $adapter;
   102|         return $this;
   103|     }
   104|     /**
   105|      * @return string
   106|      */
   107|     public function getAdapter()
   108|     {
   109|         return $this->adapter;
   110|     }
   111|     /**
   112|      * @param array $adapterConfig
   113|      *
   114|      * @return $this
   115|      */
   116|     public function setAdapterConfig(array $adapterConfig)
   117|     {
   118|         $this->adapterConfig = $adapterConfig;
   119|         return $this;
   120|     }
   121|     /**
   122|      * @return array
   123|      */
   124|     public function getAdapterConfig()
   125|     {
   126|         return $this->adapterConfig;
   127|     }
   128|     /**
   129|      * @return Container
   130|      */
   131|     public function getContainer()
   132|     {
   133|         return $this->container;
   134|     }
   135|     /**
   136|      * @return EventHandler
   137|      */
   138|     public function getEventHandler()
   139|     {
   140|         return $this->eventHandler;
   141|     }
   142|     /**
   143|      * @return Connection
   144|      */
   145|     public static function getStoredConnection()
   146|     {
   147|         return static::$storedConnection;
   148|     }
   149| }


# ====================================================================
# FILE: src/Pixie/ConnectionAdapters/BaseAdapter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| <?php namespace Pixie\ConnectionAdapters;
     2| abstract class BaseAdapter
     3| {
     4|     /**
     5|      * @var \Viocon\Container
     6|      */
     7|     protected $container;
     8|     /**
     9|      * @param \Viocon\Container $container
    10|      */
    11|     public function __construct(\Viocon\Container $container)
    12|     {
    13|         $this->container = $container;
    14|     }
    15|     /**
    16|      * @param $config
    17|      *
    18|      * @return \PDO
    19|      */
    20|     public function connect($config)
    21|     {
    22|         if (!isset($config['options'])) {
    23|             $config['options'] = array();
    24|         }
    25|         return $this->doConnect($config);
    26|     }
    27|     /**
    28|      * @param $config
    29|      *
    30|      * @return mixed
    31|      */
    32|     abstract protected function doConnect($config);
    33| }


# ====================================================================
# FILE: src/Pixie/ConnectionAdapters/Mysql.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| <?php namespace Pixie\ConnectionAdapters;
     2| class Mysql extends BaseAdapter
     3| {
     4|     /**
     5|      * @param $config
     6|      *
     7|      * @return mixed
     8|      */
     9|     protected function doConnect($config)
    10|     {
    11|         $connectionString = "mysql:dbname={$config['database']}";
    12|         if (isset($config['host'])) {
    13|             $connectionString .= ";host={$config['host']}";
    14|         }
    15|         if (isset($config['port'])) {
    16|             $connectionString .= ";port={$config['port']}";
    17|         }
    18|         if (isset($config['unix_socket'])) {
    19|             $connectionString .= ";unix_socket={$config['unix_socket']}";
    20|         }
    21|         $connection = $this->container->build(
    22|             '\PDO',
    23|             array($connectionString, $config['username'], $config['password'], $config['options'])
    24|         );
    25|         if (isset($config['charset'])) {
    26|             $connection->prepare("SET NAMES '{$config['charset']}'")->execute();
    27|         }
    28|         return $connection;
    29|     }
    30| }


# ====================================================================
# FILE: src/Pixie/ConnectionAdapters/Pgsql.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-27 ---
     1| <?php namespace Pixie\ConnectionAdapters;
     2| class Pgsql extends BaseAdapter
     3| {
     4|     /**
     5|      * @param $config
     6|      *
     7|      * @return mixed
     8|      */
     9|     protected function doConnect($config)
    10|     {
    11|         $connectionString = "pgsql:host={$config['host']};dbname={$config['database']}";
    12|         if (isset($config['port'])) {
    13|             $connectionString .= ";port={$config['port']}";
    14|         }
    15|         $connection = $this->container->build(
    16|             '\PDO',
    17|             array($connectionString, $config['username'], $config['password'], $config['options'])
    18|         );
    19|         if (isset($config['charset'])) {
    20|             $connection->prepare("SET NAMES '{$config['charset']}'")->execute();
    21|         }
    22|         if (isset($config['schema'])) {
    23|             $connection->prepare("SET search_path TO '{$config['schema']}'")->execute();
    24|         }
    25|         return $connection;
    26|     }
    27| }


# ====================================================================
# FILE: src/Pixie/ConnectionAdapters/Sqlite.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-17 ---
     1| <?php namespace Pixie\ConnectionAdapters;
     2| class Sqlite extends BaseAdapter
     3| {
     4|     /**
     5|      * @param $config
     6|      *
     7|      * @return mixed
     8|      */
     9|     public function doConnect($config)
    10|     {
    11|         $connectionString = 'sqlite:' . $config['database'];
    12|         return $this->container->build(
    13|             '\PDO',
    14|             array($connectionString, null, null, $config['options'])
    15|         );
    16|     }
    17| }


# ====================================================================
# FILE: src/Pixie/EventHandler.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-79 ---
     1| <?php namespace Pixie;
     2| use Pixie\QueryBuilder\QueryBuilderHandler;
     3| use Pixie\QueryBuilder\Raw;
     4| class EventHandler
     5| {
     6|     /**
     7|      * @var array
     8|      */
     9|     protected $events = array();
    10|     /**
    11|      * @var array
    12|      */
    13|     protected $firedEvents = array();
    14|     /**
    15|      * @return array
    16|      */
    17|     public function getEvents()
    18|     {
    19|         return $this->events;
    20|     }
    21|     /**
    22|      * @param $event
    23|      * @param $table
    24|      *
    25|      * @return callable|null
    26|      */
    27|     public function getEvent($event, $table = ':any')
    28|     {
    29|         if ($table instanceof Raw) {
    30|             return null;
    31|         }
    32|         return isset($this->events[$table][$event]) ? $this->events[$table][$event] : null;
    33|     }
    34|     /**
    35|      * @param          $event
    36|      * @param string   $table
    37|      * @param callable $action
    38|      *
    39|      * @return void
    40|      */
    41|     public function registerEvent($event, $table, \Closure $action)
    42|     {
    43|         $table = $table ?: ':any';
    44|         $this->events[$table][$event] = $action;
    45|     }
    46|     /**
    47|      * @param          $event
    48|      * @param string   $table
    49|      *
    50|      * @return void
    51|      */
    52|     public function removeEvent($event, $table = ':any')
    53|     {
    54|         unset($this->events[$table][$event]);
    55|     }
    56|     /**
    57|      * @param QueryBuilderHandler $queryBuilder
    58|      * @param                     $event
    59|      * @return mixed
    60|      */
    61|     public function fireEvents($queryBuilder, $event)
    62|     {
    63|         $statements = $queryBuilder->getStatements();
    64|         $tables = isset($statements['tables']) ? $statements['tables'] : array();
    65|         array_unshift($tables, ':any');
    66|         foreach ($tables as $table) {
    67|             if ($action = $this->getEvent($event, $table)) {
    68|                 $eventId = $event . $table;
    69|                 $handlerParams = func_get_args();
    70|                 unset($handlerParams[1]); // we do not need $event
    71|                 $this->firedEvents[] = $eventId;
    72|                 $result = call_user_func_array($action, $handlerParams);
    73|                 if (!is_null($result)) {
    74|                     return $result;
    75|                 };
    76|             }
    77|         }
    78|     }
    79| }


# ====================================================================
# FILE: src/Pixie/Exception.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-4 ---
     1| <?php namespace Pixie;
     2| class Exception extends \Exception
     3| {
     4| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Adapters/BaseAdapter.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-427 ---
     1| <?php namespace Pixie\QueryBuilder\Adapters;
     2| use Pixie\Connection;
     3| use Pixie\Exception;
     4| use Pixie\QueryBuilder\Raw;
     5| abstract class BaseAdapter
     6| {
     7|     /**
     8|      * @var \Pixie\Connection
     9|      */
    10|     protected $connection;
    11|     /**
    12|      * @var \Viocon\Container
    13|      */
    14|     protected $container;
    15|     public function __construct(Connection $connection)
    16|     {
    17|         $this->connection = $connection;
    18|         $this->container = $this->connection->getContainer();
    19|     }
    20|     /**
    21|      * Build select query string and bindings
    22|      *
    23|      * @param $statements
    24|      *
    25|      * @throws Exception
    26|      * @return array
    27|      */
    28|     public function select($statements)
    29|     {
    30|         if (!array_key_exists('tables', $statements)) {
    31|             throw new Exception('No table specified.', 3);
    32|         } elseif (!array_key_exists('selects', $statements)) {
    33|             $statements['selects'][] = '*';
    34|         }
    35|         $tables = $this->arrayStr($statements['tables'], ', ');
    36|         $selects = $this->arrayStr($statements['selects'], ', ');
    37|         list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
    38|         $groupBys = '';
    39|         if (isset($statements['groupBys']) && $groupBys = $this->arrayStr($statements['groupBys'], ', ')) {
    40|             $groupBys = 'GROUP BY ' . $groupBys;
    41|         }
    42|         $orderBys = '';
    43|         if (isset($statements['orderBys']) && is_array($statements['orderBys'])) {
    44|             foreach ($statements['orderBys'] as $orderBy) {
    45|                 $orderBys .= $this->wrapSanitizer($orderBy['field']) . ' ' . $orderBy['type'] . ', ';
    46|             }
    47|             if ($orderBys = trim($orderBys, ', ')) {
    48|                 $orderBys = 'ORDER BY ' . $orderBys;
    49|             }
    50|         }
    51|         $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
    52|         $offset = isset($statements['offset']) ? 'OFFSET ' . $statements['offset'] : '';
    53|         list($havingCriteria, $havingBindings) = $this->buildCriteriaWithType($statements, 'havings', 'HAVING');
    54|         $joinString = $this->buildJoin($statements);
    55|         $sqlArray = array(
    56|             'SELECT' . (isset($statements['distinct']) ? ' DISTINCT' : ''),
    57|             $selects,
    58|             'FROM',
    59|             $tables,
    60|             $joinString,
    61|             $whereCriteria,
    62|             $groupBys,
    63|             $havingCriteria,
    64|             $orderBys,
    65|             $limit,
    66|             $offset
    67|         );
    68|         $sql = $this->concatenateQuery($sqlArray);
    69|         $bindings = array_merge(
    70|             $whereBindings,
    71|             $havingBindings
    72|         );
    73|         return compact('sql', 'bindings');
    74|     }
    75|     /**
    76|      * Build just criteria part of the query
    77|      *
    78|      * @param      $statements
    79|      * @param bool $bindValues
    80|      *
    81|      * @return array
    82|      */
    83|     public function criteriaOnly($statements, $bindValues = true)
    84|     {
    85|         $sql = $bindings = array();
    86|         if (!isset($statements['criteria'])) {
    87|             return compact('sql', 'bindings');
    88|         }
    89|         list($sql, $bindings) = $this->buildCriteria($statements['criteria'], $bindValues);
    90|         return compact('sql', 'bindings');
    91|     }
    92|     /**
    93|      * Build a generic insert/ignore/replace query
    94|      *
    95|      * @param       $statements
    96|      * @param array $data
    97|      *
    98|      * @return array
    99|      * @throws Exception
   100|      */
   101|     private function doInsert($statements, array $data, $type)
   102|     {
   103|         if (!isset($statements['tables'])) {
   104|             throw new Exception('No table specified', 3);
   105|         }
   106|         $table = end($statements['tables']);
   107|         $bindings = $keys = $values = array();
   108|         foreach ($data as $key => $value) {
   109|             $keys[] = $key;
   110|             if ($value instanceof Raw) {
   111|                 $values[] = (string) $value;
   112|             } else {
   113|                 $values[] =  '?';
   114|                 $bindings[] = $value;
   115|             }
   116|         }
   117|         $sqlArray = array(
   118|             $type . ' INTO',
   119|             $this->wrapSanitizer($table),
   120|             '(' . $this->arrayStr($keys, ',') . ')',
   121|             'VALUES',
   122|             '(' . $this->arrayStr($values, ',', false) . ')',
   123|         );
   124|         if (isset($statements['onduplicate'])) {
   125|             if (count($statements['onduplicate']) < 1) {
   126|                 throw new Exception('No data given.', 4);
   127|             }
   128|             list($updateStatement, $updateBindings) = $this->getUpdateStatement($statements['onduplicate']);
   129|             $sqlArray[] = 'ON DUPLICATE KEY UPDATE ' . $updateStatement;
   130|             $bindings = array_merge($bindings, $updateBindings);
   131|         }
   132|         $sql = $this->concatenateQuery($sqlArray, ' ', false);
   133|         return compact('sql', 'bindings');
   134|     }
   135|     /**
   136|      * Build Insert query
   137|      *
   138|      * @param       $statements
   139|      * @param array $data
   140|      *
   141|      * @return array
   142|      * @throws Exception
   143|      */
   144|     public function insert($statements, array $data)
   145|     {
   146|         return $this->doInsert($statements, $data, 'INSERT');
   147|     }
   148|     /**
   149|      * Build Insert Ignore query
   150|      *
   151|      * @param       $statements
   152|      * @param array $data
   153|      *
   154|      * @return array
   155|      * @throws Exception
   156|      */
   157|     public function insertIgnore($statements, array $data)
   158|     {
   159|         return $this->doInsert($statements, $data, 'INSERT IGNORE');
   160|     }
   161|     /**
   162|      * Build Insert Ignore query
   163|      *
   164|      * @param       $statements
   165|      * @param array $data
   166|      *
   167|      * @return array
   168|      * @throws Exception
   169|      */
   170|     public function replace($statements, array $data)
   171|     {
   172|         return $this->doInsert($statements, $data, 'REPLACE');
   173|     }
   174|     /**
   175|      * Build fields assignment part of SET ... or ON DUBLICATE KEY UPDATE ... statements
   176|      *
   177|      * @param array $data
   178|      *
   179|      * @return array
   180|      */
   181|     private function getUpdateStatement($data)
   182|     {
   183|         $bindings = array();
   184|         $statement = '';
   185|         foreach ($data as $key => $value) {
   186|             if ($value instanceof Raw) {
   187|                 $statement .= $this->wrapSanitizer($key) . '=' . $value . ',';
   188|             } else {
   189|                 $statement .= $this->wrapSanitizer($key) . '=?,';
   190|                 $bindings[] = $value;
   191|             }
   192|         }
   193|         $statement = trim($statement, ',');
   194|         return array($statement, $bindings);
   195|     }
   196|     /**
   197|      * Build update query
   198|      *
   199|      * @param       $statements
   200|      * @param array $data
   201|      *
   202|      * @return array
   203|      * @throws Exception
   204|      */
   205|     public function update($statements, array $data)
   206|     {
   207|         if (!isset($statements['tables'])) {
   208|             throw new Exception('No table specified', 3);
   209|         } elseif (count($data) < 1) {
   210|             throw new Exception('No data given.', 4);
   211|         }
   212|         $table = end($statements['tables']);
   213|         list($updateStatement, $bindings) = $this->getUpdateStatement($data);
   214|         list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
   215|         $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
   216|         $sqlArray = array(
   217|             'UPDATE',
   218|             $this->wrapSanitizer($table),
   219|             'SET ' . $updateStatement,
   220|             $whereCriteria,
   221|             $limit
   222|         );
   223|         $sql = $this->concatenateQuery($sqlArray, ' ', false);
   224|         $bindings = array_merge($bindings, $whereBindings);
   225|         return compact('sql', 'bindings');
   226|     }
   227|     /**
   228|      * Build delete query
   229|      *
   230|      * @param $statements
   231|      *
   232|      * @return array
   233|      * @throws Exception
   234|      */
   235|     public function delete($statements)
   236|     {
   237|         if (!isset($statements['tables'])) {
   238|             throw new Exception('No table specified', 3);
   239|         }
   240|         $table = end($statements['tables']);
   241|         list($whereCriteria, $whereBindings) = $this->buildCriteriaWithType($statements, 'wheres', 'WHERE');
   242|         $limit = isset($statements['limit']) ? 'LIMIT ' . $statements['limit'] : '';
   243|         $sqlArray = array('DELETE FROM', $this->wrapSanitizer($table), $whereCriteria);
   244|         $sql = $this->concatenateQuery($sqlArray, ' ', false);
   245|         $bindings = $whereBindings;
   246|         return compact('sql', 'bindings');
   247|     }
   248|     /**
   249|      * Array concatenating method, like implode.
   250|      * But it does wrap sanitizer and trims last glue
   251|      *
   252|      * @param array $pieces
   253|      * @param       $glue
   254|      * @param bool  $wrapSanitizer
   255|      *
   256|      * @return string
   257|      */
   258|     protected function arrayStr(array $pieces, $glue, $wrapSanitizer = true)
   259|     {
   260|         $str = '';
   261|         foreach ($pieces as $key => $piece) {
   262|             if ($wrapSanitizer) {
   263|                 $piece = $this->wrapSanitizer($piece);
   264|             }
   265|             if (!is_int($key)) {
   266|                 $piece = ($wrapSanitizer ? $this->wrapSanitizer($key) : $key) . ' AS ' . $piece;
   267|             }
   268|             $str .= $piece . $glue;
   269|         }
   270|         return trim($str, $glue);
   271|     }
   272|     /**
   273|      * Join different part of queries with a space.
   274|      *
   275|      * @param array $pieces
   276|      *
   277|      * @return string
   278|      */
   279|     protected function concatenateQuery(array $pieces)
   280|     {
   281|         $str = '';
   282|         foreach ($pieces as $piece) {
   283|             $str = trim($str) . ' ' . trim($piece);
   284|         }
   285|         return trim($str);
   286|     }
   287|     /**
   288|      * Build generic criteria string and bindings from statements, like "a = b and c = ?"
   289|      *
   290|      * @param      $statements
   291|      * @param bool $bindValues
   292|      *
   293|      * @return array
   294|      */
   295|     protected function buildCriteria($statements, $bindValues = true)
   296|     {
   297|         $criteria = '';
   298|         $bindings = array();
   299|         foreach ($statements as $statement) {
   300|             $key = $this->wrapSanitizer($statement['key']);
   301|             $value = $statement['value'];
   302|             if (is_null($value) && $key instanceof \Closure) {
   303|                 $nestedCriteria = $this->container->build(
   304|                     '\\Pixie\\QueryBuilder\\NestedCriteria',
   305|                     array($this->connection)
   306|                 );
   307|                 $nestedCriteria = & $nestedCriteria;
   308|                 $key($nestedCriteria);
   309|                 $queryObject = $nestedCriteria->getQuery('criteriaOnly', true);
   310|                 $bindings = array_merge($bindings, $queryObject->getBindings());
   311|                 $criteria .= $statement['joiner'] . ' (' . $queryObject->getSql() . ') ';
   312|             } elseif (is_array($value)) {
   313|                 $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'];
   314|                 switch ($statement['operator']) {
   315|                     case 'BETWEEN':
   316|                         $bindings = array_merge($bindings, $statement['value']);
   317|                         $criteria .= ' ? AND ? ';
   318|                         break;
   319|                     default:
   320|                         $valuePlaceholder = '';
   321|                         foreach ($statement['value'] as $subValue) {
   322|                             $valuePlaceholder .= '?, ';
   323|                             $bindings[] = $subValue;
   324|                         }
   325|                         $valuePlaceholder = trim($valuePlaceholder, ', ');
   326|                         $criteria .= ' (' . $valuePlaceholder . ') ';
   327|                         break;
   328|                 }
   329|             } elseif ($value instanceof Raw) {
   330|                 $criteria .= "{$statement['joiner']} {$key} {$statement['operator']} $value ";
   331|             } else {
   332|                 if (!$bindValues) {
   333|                     $value = $this->wrapSanitizer($value);
   334|                     $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'] . ' ' . $value . ' ';
   335|                 } elseif ($statement['key'] instanceof Raw) {
   336|                     $criteria .= $statement['joiner'] . ' ' . $key . ' ';
   337|                     $bindings = array_merge($bindings, $statement['key']->getBindings());
   338|                 } else {
   339|                     $valuePlaceholder = '?';
   340|                     $bindings[] = $value;
   341|                     $criteria .= $statement['joiner'] . ' ' . $key . ' ' . $statement['operator'] . ' '
   342|                         . $valuePlaceholder . ' ';
   343|                 }
   344|             }
   345|         }
   346|         $criteria = preg_replace('/^(\s?AND ?|\s?OR ?)|\s$/i', '', $criteria);
   347|         return array($criteria, $bindings);
   348|     }
   349|     /**
   350|      * Wrap values with adapter's sanitizer like, '`'
   351|      *
   352|      * @param $value
   353|      *
   354|      * @return string
   355|      */
   356|     public function wrapSanitizer($value)
   357|     {
   358|         if ($value instanceof Raw) {
   359|             return (string)$value;
   360|         } elseif ($value instanceof \Closure) {
   361|             return $value;
   362|         }
   363|         $valueArr = explode('.', $value, 2);
   364|         foreach ($valueArr as $key => $subValue) {
   365|             $valueArr[$key] = trim($subValue) == '*' ? $subValue : $this->sanitizer . $subValue . $this->sanitizer;
   366|         }
   367|         return implode('.', $valueArr);
   368|     }
   369|     /**
   370|      * Build criteria string and binding with various types added, like WHERE and Having
   371|      *
   372|      * @param      $statements
   373|      * @param      $key
   374|      * @param      $type
   375|      * @param bool $bindValues
   376|      *
   377|      * @return array
   378|      */
   379|     protected function buildCriteriaWithType($statements, $key, $type, $bindValues = true)
   380|     {
   381|         $criteria = '';
   382|         $bindings = array();
   383|         if (isset($statements[$key])) {
   384|             list($criteria, $bindings) = $this->buildCriteria($statements[$key], $bindValues);
   385|             if ($criteria) {
   386|                 $criteria = $type . ' ' . $criteria;
   387|             }
   388|         }
   389|         return array($criteria, $bindings);
   390|     }
   391|     /**
   392|      * Build join string
   393|      *
   394|      * @param $statements
   395|      *
   396|      * @return array
   397|      */
   398|     protected function buildJoin($statements)
   399|     {
   400|         $sql = '';
   401|         if (!array_key_exists('joins', $statements) || !is_array($statements['joins'])) {
   402|             return $sql;
   403|         }
   404|         foreach ($statements['joins'] as $joinArr) {
   405|             if (is_array($joinArr['table'])) {
   406|                 $mainTable = $joinArr['table'][0];
   407|                 $aliasTable = $joinArr['table'][1];
   408|                 $table = $this->wrapSanitizer($mainTable) . ' AS ' . $this->wrapSanitizer($aliasTable);
   409|             } else {
   410|                 $table = $joinArr['table'] instanceof Raw ?
   411|                     (string) $joinArr['table'] :
   412|                     $this->wrapSanitizer($joinArr['table']);
   413|             }
   414|             $joinBuilder = $joinArr['joinBuilder'];
   415|             $sqlArr = array(
   416|                 $sql,
   417|                 strtoupper($joinArr['type']),
   418|                 'JOIN',
   419|                 $table,
   420|                 'ON',
   421|                 $joinBuilder->getQuery('criteriaOnly', false)->getSql()
   422|             );
   423|             $sql = $this->concatenateQuery($sqlArr);
   424|         }
   425|         return $sql;
   426|     }
   427| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Adapters/Mysql.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| <?php namespace Pixie\QueryBuilder\Adapters;
     2| class Mysql extends BaseAdapter
     3| {
     4|     /**
     5|      * @var string
     6|      */
     7|     protected $sanitizer = '`';
     8| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Adapters/Pgsql.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| <?php namespace Pixie\QueryBuilder\Adapters;
     2| class Pgsql extends BaseAdapter
     3| {
     4|     /**
     5|      * @var string
     6|      */
     7|     protected $sanitizer = '"';
     8| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Adapters/Sqlite.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-8 ---
     1| <?php namespace Pixie\QueryBuilder\Adapters;
     2| class Sqlite extends BaseAdapter
     3| {
     4|     /**
     5|      * @var string
     6|      */
     7|     protected $sanitizer = '"';
     8| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/JoinBuilder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-41 ---
     1| <?php namespace Pixie\QueryBuilder;
     2| class JoinBuilder extends QueryBuilderHandler
     3| {
     4|     /**
     5|      * @param $key
     6|      * @param $operator
     7|      * @param $value
     8|      *
     9|      * @return $this
    10|      */
    11|     public function on($key, $operator, $value)
    12|     {
    13|         return $this->joinHandler($key, $operator, $value, 'AND');
    14|     }
    15|     /**
    16|      * @param $key
    17|      * @param $operator
    18|      * @param $value
    19|      *
    20|      * @return $this
    21|      */
    22|     public function orOn($key, $operator, $value)
    23|     {
    24|         return $this->joinHandler($key, $operator, $value, 'OR');
    25|     }
    26|     /**
    27|      * @param        $key
    28|      * @param null   $operator
    29|      * @param null   $value
    30|      * @param string $joiner
    31|      *
    32|      * @return $this
    33|      */
    34|     protected function joinHandler($key, $operator = null, $value = null, $joiner = 'AND')
    35|     {
    36|         $key = $this->addTablePrefix($key);
    37|         $value = $this->addTablePrefix($value);
    38|         $this->statements['criteria'][] = compact('key', 'operator', 'value', 'joiner');
    39|         return $this;
    40|     }
    41| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/NestedCriteria.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| <?php namespace Pixie\QueryBuilder;
     2| class NestedCriteria extends QueryBuilderHandler
     3| {
     4|     /**
     5|      * @param        $key
     6|      * @param null   $operator
     7|      * @param null   $value
     8|      * @param string $joiner
     9|      *
    10|      * @return $this
    11|      */
    12|     protected function whereHandler($key, $operator = null, $value = null, $joiner = 'AND')
    13|     {
    14|         $key = $this->addTablePrefix($key);
    15|         $this->statements['criteria'][] = compact('key', 'operator', 'value', 'joiner');
    16|         return $this;
    17|     }
    18| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/QueryBuilderHandler.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-904 ---
     1| <?php namespace Pixie\QueryBuilder;
     2| use PDO;
     3| use Pixie\Connection;
     4| use Pixie\Exception;
     5| class QueryBuilderHandler
     6| {
     7|     /**
     8|      * @var \Viocon\Container
     9|      */
    10|     protected $container;
    11|     /**
    12|      * @var Connection
    13|      */
    14|     protected $connection;
    15|     /**
    16|      * @var array
    17|      */
    18|     protected $statements = array();
    19|     /**
    20|      * @var \PDO
    21|      */
    22|     protected $pdo;
    23|     /**
    24|      * @var null|PDOStatement
    25|      */
    26|     protected $pdoStatement = null;
    27|     /**
    28|      * @var null|string
    29|      */
    30|     protected $tablePrefix = null;
    31|     /**
    32|      * @var \Pixie\QueryBuilder\Adapters\BaseAdapter
    33|      */
    34|     protected $adapterInstance;
    35|     /**
    36|      * The PDO fetch parameters to use
    37|      *
    38|      * @var array
    39|      */
    40|     protected $fetchParameters = array(\PDO::FETCH_OBJ);
    41|     /**
    42|      * @param null|\Pixie\Connection $connection
    43|      *
    44|      * @throws \Pixie\Exception
    45|      */
    46|     public function __construct(Connection $connection = null)
    47|     {
    48|         if (is_null($connection)) {
    49|             if (!$connection = Connection::getStoredConnection()) {
    50|                 throw new Exception('No database connection found.', 1);
    51|             }
    52|         }
    53|         $this->connection = $connection;
    54|         $this->container = $this->connection->getContainer();
    55|         $this->pdo = $this->connection->getPdoInstance();
    56|         $this->adapter = $this->connection->getAdapter();
    57|         $this->adapterConfig = $this->connection->getAdapterConfig();
    58|         if (isset($this->adapterConfig['prefix'])) {
    59|             $this->tablePrefix = $this->adapterConfig['prefix'];
    60|         }
    61|         $this->adapterInstance = $this->container->build(
    62|             '\\Pixie\\QueryBuilder\\Adapters\\' . ucfirst($this->adapter),
    63|             array($this->connection)
    64|         );
    65|         $this->pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
    66|     }
    67|     /**
    68|      * Set the fetch mode
    69|      *
    70|      * @param $mode
    71|      * @return $this
    72|      */
    73|     public function setFetchMode($mode)
    74|     {
    75|         $this->fetchParameters = func_get_args();
    76|         return $this;
    77|     }
    78|     /**
    79|      * Fetch query results as object of specified type
    80|      *
    81|      * @param $className
    82|      * @param array $constructorArgs
    83|      * @return QueryBuilderHandler
    84|      */
    85|     public function asObject($className, $constructorArgs = array())
    86|     {
    87|         return $this->setFetchMode(\PDO::FETCH_CLASS, $className, $constructorArgs);
    88|     }
    89|     /**
    90|      * @param null|\Pixie\Connection $connection
    91|      *
    92|      * @return static
    93|      */
    94|     public function newQuery(Connection $connection = null)
    95|     {
    96|         if (is_null($connection)) {
    97|             $connection = $this->connection;
    98|         }
    99|         return new static($connection);
   100|     }
   101|     /**
   102|      * @param       $sql
   103|      * @param array $bindings
   104|      *
   105|      * @return $this
   106|      */
   107|     public function query($sql, $bindings = array())
   108|     {
   109|         list($this->pdoStatement) = $this->statement($sql, $bindings);
   110|         return $this;
   111|     }
   112|     /**
   113|      * @param       $sql
   114|      * @param array $bindings
   115|      *
   116|      * @return array PDOStatement and execution time as float
   117|      */
   118|     public function statement($sql, $bindings = array())
   119|     {
   120|         $start = microtime(true);
   121|         $pdoStatement = $this->pdo->prepare($sql);
   122|         foreach ($bindings as $key => $value) {
   123|             $pdoStatement->bindValue(
   124|                 is_int($key) ? $key + 1 : $key,
   125|                 $value,
   126|                 is_int($value) || is_bool($value) ? PDO::PARAM_INT : PDO::PARAM_STR
   127|             );
   128|         }
   129|         $pdoStatement->execute();
   130|         return array($pdoStatement, microtime(true) - $start);
   131|     }
   132|     /**
   133|      * Get all rows
   134|      *
   135|      * @return \stdClass|null
   136|      */
   137|     public function get()
   138|     {
   139|         $eventResult = $this->fireEvents('before-select');
   140|         if (!is_null($eventResult)) {
   141|             return $eventResult;
   142|         };
   143|         $executionTime = 0;
   144|         if (is_null($this->pdoStatement)) {
   145|             $queryObject = $this->getQuery('select');
   146|             list($this->pdoStatement, $executionTime) = $this->statement(
   147|                 $queryObject->getSql(),
   148|                 $queryObject->getBindings()
   149|             );
   150|         }
   151|         $start = microtime(true);
   152|         $result = call_user_func_array(array($this->pdoStatement, 'fetchAll'), $this->fetchParameters);
   153|         $executionTime += microtime(true) - $start;
   154|         $this->pdoStatement = null;
   155|         $this->fireEvents('after-select', $result, $executionTime);
   156|         return $result;
   157|     }
   158|     /**
   159|      * Get first row
   160|      *
   161|      * @return \stdClass|null
   162|      */
   163|     public function first()
   164|     {
   165|         $this->limit(1);
   166|         $result = $this->get();
   167|         return empty($result) ? null : $result[0];
   168|     }
   169|     /**
   170|      * @param        $value
   171|      * @param string $fieldName
   172|      *
   173|      * @return null|\stdClass
   174|      */
   175|     public function findAll($fieldName, $value)
   176|     {
   177|         $this->where($fieldName, '=', $value);
   178|         return $this->get();
   179|     }
   180|     /**
   181|      * @param        $value
   182|      * @param string $fieldName
   183|      *
   184|      * @return null|\stdClass
   185|      */
   186|     public function find($value, $fieldName = 'id')
   187|     {
   188|         $this->where($fieldName, '=', $value);
   189|         return $this->first();
   190|     }
   191|     /**
   192|      * Get count of rows
   193|      *
   194|      * @return int
   195|      */
   196|     public function count()
   197|     {
   198|         $originalStatements = $this->statements;
   199|         unset($this->statements['orderBys']);
   200|         unset($this->statements['limit']);
   201|         unset($this->statements['offset']);
   202|         $count = $this->aggregate('count');
   203|         $this->statements = $originalStatements;
   204|         return $count;
   205|     }
   206|     /**
   207|      * @param $type
   208|      *
   209|      * @return int
   210|      */
   211|     protected function aggregate($type)
   212|     {
   213|         $mainSelects = isset($this->statements['selects']) ? $this->statements['selects'] : null;
   214|         $this->statements['selects'] = array($this->raw($type . '(*) as field'));
   215|         $row = $this->get();
   216|         if ($mainSelects) {
   217|             $this->statements['selects'] = $mainSelects;
   218|         } else {
   219|             unset($this->statements['selects']);
   220|         }
   221|         if (is_array($row[0])) {
   222|             return (int) $row[0]['field'];
   223|         } elseif (is_object($row[0])) {
   224|             return (int) $row[0]->field;
   225|         }
   226|         return 0;
   227|     }
   228|     /**
   229|      * @param string $type
   230|      * @param array  $dataToBePassed
   231|      *
   232|      * @return mixed
   233|      * @throws Exception
   234|      */
   235|     public function getQuery($type = 'select', $dataToBePassed = array())
   236|     {
   237|         $allowedTypes = array('select', 'insert', 'insertignore', 'replace', 'delete', 'update', 'criteriaonly');
   238|         if (!in_array(strtolower($type), $allowedTypes)) {
   239|             throw new Exception($type . ' is not a known type.', 2);
   240|         }
   241|         $queryArr = $this->adapterInstance->$type($this->statements, $dataToBePassed);
   242|         return $this->container->build(
   243|             '\\Pixie\\QueryBuilder\\QueryObject',
   244|             array($queryArr['sql'], $queryArr['bindings'], $this->pdo)
   245|         );
   246|     }
   247|     /**
   248|      * @param QueryBuilderHandler $queryBuilder
   249|      * @param null                $alias
   250|      *
   251|      * @return Raw
   252|      */
   253|     public function subQuery(QueryBuilderHandler $queryBuilder, $alias = null)
   254|     {
   255|         $sql = '(' . $queryBuilder->getQuery()->getRawSql() . ')';
   256|         if ($alias) {
   257|             $sql = $sql . ' as ' . $alias;
   258|         }
   259|         return $queryBuilder->raw($sql);
   260|     }
   261|     /**
   262|      * @param $data
   263|      *
   264|      * @return array|string
   265|      */
   266|     private function doInsert($data, $type)
   267|     {
   268|         $eventResult = $this->fireEvents('before-insert');
   269|         if (!is_null($eventResult)) {
   270|             return $eventResult;
   271|         }
   272|         if (!is_array(current($data))) {
   273|             $queryObject = $this->getQuery($type, $data);
   274|             list($result, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
   275|             $return = $result->rowCount() === 1 ? $this->pdo->lastInsertId() : null;
   276|         } else {
   277|             $return = array();
   278|             $executionTime = 0;
   279|             foreach ($data as $subData) {
   280|                 $queryObject = $this->getQuery($type, $subData);
   281|                 list($result, $time) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
   282|                 $executionTime += $time;
   283|                 if ($result->rowCount() === 1) {
   284|                     $return[] = $this->pdo->lastInsertId();
   285|                 }
   286|             }
   287|         }
   288|         $this->fireEvents('after-insert', $return, $executionTime);
   289|         return $return;
   290|     }
   291|     /**
   292|      * @param $data
   293|      *
   294|      * @return array|string
   295|      */
   296|     public function insert($data)
   297|     {
   298|         return $this->doInsert($data, 'insert');
   299|     }
   300|     /**
   301|      * @param $data
   302|      *
   303|      * @return array|string
   304|      */
   305|     public function insertIgnore($data)
   306|     {
   307|         return $this->doInsert($data, 'insertignore');
   308|     }
   309|     /**
   310|      * @param $data
   311|      *
   312|      * @return array|string
   313|      */
   314|     public function replace($data)
   315|     {
   316|         return $this->doInsert($data, 'replace');
   317|     }
   318|     /**
   319|      * @param $data
   320|      *
   321|      * @return $this
   322|      */
   323|     public function update($data)
   324|     {
   325|         $eventResult = $this->fireEvents('before-update');
   326|         if (!is_null($eventResult)) {
   327|             return $eventResult;
   328|         }
   329|         $queryObject = $this->getQuery('update', $data);
   330|         list($response, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
   331|         $this->fireEvents('after-update', $queryObject, $executionTime);
   332|         return $response;
   333|     }
   334|     /**
   335|      * @param $data
   336|      *
   337|      * @return array|string
   338|      */
   339|     public function updateOrInsert($data)
   340|     {
   341|         if ($this->first()) {
   342|             return $this->update($data);
   343|         } else {
   344|             return $this->insert($data);
   345|         }
   346|     }
   347|     /**
   348|      * @param $data
   349|      *
   350|      * @return $this
   351|      */
   352|     public function onDuplicateKeyUpdate($data)
   353|     {
   354|         $this->addStatement('onduplicate', $data);
   355|         return $this;
   356|     }
   357|     /**
   358|      *
   359|      */
   360|     public function delete()
   361|     {
   362|         $eventResult = $this->fireEvents('before-delete');
   363|         if (!is_null($eventResult)) {
   364|             return $eventResult;
   365|         }
   366|         $queryObject = $this->getQuery('delete');
   367|         list($response, $executionTime) = $this->statement($queryObject->getSql(), $queryObject->getBindings());
   368|         $this->fireEvents('after-delete', $queryObject, $executionTime);
   369|         return $response;
   370|     }
   371|     /**
   372|      * @param $tables Single table or multiple tables as an array or as
   373|      *                multiple parameters
   374|      *
   375|      * @return static
   376|      */
   377|     public function table($tables)
   378|     {
   379|         if (!is_array($tables)) {
   380|             $tables = func_get_args();
   381|         }
   382|         $instance = new static($this->connection);
   383|         $tables = $this->addTablePrefix($tables, false);
   384|         $instance->addStatement('tables', $tables);
   385|         return $instance;
   386|     }
   387|     /**
   388|      * @param $tables
   389|      *
   390|      * @return $this
   391|      */
   392|     public function from($tables)
   393|     {
   394|         if (!is_array($tables)) {
   395|             $tables = func_get_args();
   396|         }
   397|         $tables = $this->addTablePrefix($tables, false);
   398|         $this->addStatement('tables', $tables);
   399|         return $this;
   400|     }
   401|     /**
   402|      * @param $fields
   403|      *
   404|      * @return $this
   405|      */
   406|     public function select($fields)
   407|     {
   408|         if (!is_array($fields)) {
   409|             $fields = func_get_args();
   410|         }
   411|         $fields = $this->addTablePrefix($fields);
   412|         $this->addStatement('selects', $fields);
   413|         return $this;
   414|     }
   415|     /**
   416|      * @param $fields
   417|      *
   418|      * @return $this
   419|      */
   420|     public function selectDistinct($fields)
   421|     {
   422|         $this->select($fields);
   423|         $this->addStatement('distinct', true);
   424|         return $this;
   425|     }
   426|     /**
   427|      * @param $field
   428|      *
   429|      * @return $this
   430|      */
   431|     public function groupBy($field)
   432|     {
   433|         $field = $this->addTablePrefix($field);
   434|         $this->addStatement('groupBys', $field);
   435|         return $this;
   436|     }
   437|     /**
   438|      * @param        $fields
   439|      * @param string $defaultDirection
   440|      *
   441|      * @return $this
   442|      */
   443|     public function orderBy($fields, $defaultDirection = 'ASC')
   444|     {
   445|         if (!is_array($fields)) {
   446|             $fields = array($fields);
   447|         }
   448|         foreach ($fields as $key => $value) {
   449|             $field = $key;
   450|             $type = $value;
   451|             if (is_int($key)) {
   452|                 $field = $value;
   453|                 $type = $defaultDirection;
   454|             }
   455|             if (!$field instanceof Raw) {
   456|                 $field = $this->addTablePrefix($field);
   457|             }
   458|             $this->statements['orderBys'][] = compact('field', 'type');
   459|         }
   460|         return $this;
   461|     }
   462|     /**
   463|      * @param $limit
   464|      *
   465|      * @return $this
   466|      */
   467|     public function limit($limit)
   468|     {
   469|         $this->statements['limit'] = $limit;
   470|         return $this;
   471|     }
   472|     /**
   473|      * @param $offset
   474|      *
   475|      * @return $this
   476|      */
   477|     public function offset($offset)
   478|     {
   479|         $this->statements['offset'] = $offset;
   480|         return $this;
   481|     }
   482|     /**
   483|      * @param        $key
   484|      * @param        $operator
   485|      * @param        $value
   486|      * @param string $joiner
   487|      *
   488|      * @return $this
   489|      */
   490|     public function having($key, $operator, $value, $joiner = 'AND')
   491|     {
   492|         $key = $this->addTablePrefix($key);
   493|         $this->statements['havings'][] = compact('key', 'operator', 'value', 'joiner');
   494|         return $this;
   495|     }
   496|     /**
   497|      * @param        $key
   498|      * @param        $operator
   499|      * @param        $value
   500|      *
   501|      * @return $this
   502|      */
   503|     public function orHaving($key, $operator, $value)
   504|     {
   505|         return $this->having($key, $operator, $value, 'OR');
   506|     }
   507|     /**
   508|      * @param $key
   509|      * @param $operator
   510|      * @param $value
   511|      *
   512|      * @return $this
   513|      */
   514|     public function where($key, $operator = null, $value = null)
   515|     {
   516|         if (func_num_args() == 2) {
   517|             $value = $operator;
   518|             $operator = '=';
   519|         }
   520|         return $this->whereHandler($key, $operator, $value);
   521|     }
   522|     /**
   523|      * @param $key
   524|      * @param $operator
   525|      * @param $value
   526|      *
   527|      * @return $this
   528|      */
   529|     public function orWhere($key, $operator = null, $value = null)
   530|     {
   531|         if (func_num_args() == 2) {
   532|             $value = $operator;
   533|             $operator = '=';
   534|         }
   535|         return $this->whereHandler($key, $operator, $value, 'OR');
   536|     }
   537|     /**
   538|      * @param $key
   539|      * @param $operator
   540|      * @param $value
   541|      *
   542|      * @return $this
   543|      */
   544|     public function whereNot($key, $operator = null, $value = null)
   545|     {
   546|         if (func_num_args() == 2) {
   547|             $value = $operator;
   548|             $operator = '=';
   549|         }
   550|         return $this->whereHandler($key, $operator, $value, 'AND NOT');
   551|     }
   552|     /**
   553|      * @param $key
   554|      * @param $operator
   555|      * @param $value
   556|      *
   557|      * @return $this
   558|      */
   559|     public function orWhereNot($key, $operator = null, $value = null)
   560|     {
   561|         if (func_num_args() == 2) {
   562|             $value = $operator;
   563|             $operator = '=';
   564|         }
   565|         return $this->whereHandler($key, $operator, $value, 'OR NOT');
   566|     }
   567|     /**
   568|      * @param       $key
   569|      * @param array $values
   570|      *
   571|      * @return $this
   572|      */
   573|     public function whereIn($key, $values)
   574|     {
   575|         return $this->whereHandler($key, 'IN', $values, 'AND');
   576|     }
   577|     /**
   578|      * @param       $key
   579|      * @param array $values
   580|      *
   581|      * @return $this
   582|      */
   583|     public function whereNotIn($key, $values)
   584|     {
   585|         return $this->whereHandler($key, 'NOT IN', $values, 'AND');
   586|     }
   587|     /**
   588|      * @param       $key
   589|      * @param array $values
   590|      *
   591|      * @return $this
   592|      */
   593|     public function orWhereIn($key, $values)
   594|     {
   595|         return $this->whereHandler($key, 'IN', $values, 'OR');
   596|     }
   597|     /**
   598|      * @param       $key
   599|      * @param array $values
   600|      *
   601|      * @return $this
   602|      */
   603|     public function orWhereNotIn($key, $values)
   604|     {
   605|         return $this->whereHandler($key, 'NOT IN', $values, 'OR');
   606|     }
   607|     /**
   608|      * @param $key
   609|      * @param $valueFrom
   610|      * @param $valueTo
   611|      *
   612|      * @return $this
   613|      */
   614|     public function whereBetween($key, $valueFrom, $valueTo)
   615|     {
   616|         return $this->whereHandler($key, 'BETWEEN', array($valueFrom, $valueTo), 'AND');
   617|     }
   618|     /**
   619|      * @param $key
   620|      * @param $valueFrom
   621|      * @param $valueTo
   622|      *
   623|      * @return $this
   624|      */
   625|     public function orWhereBetween($key, $valueFrom, $valueTo)
   626|     {
   627|         return $this->whereHandler($key, 'BETWEEN', array($valueFrom, $valueTo), 'OR');
   628|     }
   629|     /**
   630|      * @param $key
   631|      * @return QueryBuilderHandler
   632|      */
   633|     public function whereNull($key)
   634|     {
   635|         return $this->whereNullHandler($key);
   636|     }
   637|     /**
   638|      * @param $key
   639|      * @return QueryBuilderHandler
   640|      */
   641|     public function whereNotNull($key)
   642|     {
   643|         return $this->whereNullHandler($key, 'NOT');
   644|     }
   645|     /**
   646|      * @param $key
   647|      * @return QueryBuilderHandler
   648|      */
   649|     public function orWhereNull($key)
   650|     {
   651|         return $this->whereNullHandler($key, '', 'or');
   652|     }
   653|     /**
   654|      * @param $key
   655|      * @return QueryBuilderHandler
   656|      */
   657|     public function orWhereNotNull($key)
   658|     {
   659|         return $this->whereNullHandler($key, 'NOT', 'or');
   660|     }
   661|     protected function whereNullHandler($key, $prefix = '', $operator = '')
   662|     {
   663|         $key = $this->adapterInstance->wrapSanitizer($this->addTablePrefix($key));
   664|         return $this->{$operator . 'Where'}($this->raw("{$key} IS {$prefix} NULL"));
   665|     }
   666|     /**
   667|      * @param        $table
   668|      * @param        $key
   669|      * @param        $operator
   670|      * @param        $value
   671|      * @param string $type
   672|      *
   673|      * @return $this
   674|      */
   675|     public function join($table, $key, $operator = null, $value = null, $type = 'inner')
   676|     {
   677|         if (!$key instanceof \Closure) {
   678|             $key = function ($joinBuilder) use ($key, $operator, $value) {
   679|                 $joinBuilder->on($key, $operator, $value);
   680|             };
   681|         }
   682|         $joinBuilder = $this->container->build('\\Pixie\\QueryBuilder\\JoinBuilder', array($this->connection));
   683|         $joinBuilder = & $joinBuilder;
   684|         $key($joinBuilder);
   685|         $table = $this->addTablePrefix($table, false);
   686|         $this->statements['joins'][] = compact('type', 'table', 'joinBuilder');
   687|         return $this;
   688|     }
   689|     /**
   690|      * Runs a transaction
   691|      *
   692|      * @param $callback
   693|      *
   694|      * @return $this
   695|      */
   696|     public function transaction(\Closure $callback)
   697|     {
   698|         try {
   699|             $this->pdo->beginTransaction();
   700|             $transaction = $this->container->build('\\Pixie\\QueryBuilder\\Transaction', array($this->connection));
   701|             $callback($transaction);
   702|             $this->pdo->commit();
   703|             return $this;
   704|         } catch (TransactionHaltException $e) {
   705|             return $this;
   706|         } catch (\Exception $e) {
   707|             $this->pdo->rollBack();
   708|             return $this;
   709|         }
   710|     }
   711|     /**
   712|      * @param      $table
   713|      * @param      $key
   714|      * @param null $operator
   715|      * @param null $value
   716|      *
   717|      * @return $this
   718|      */
   719|     public function leftJoin($table, $key, $operator = null, $value = null)
   720|     {
   721|         return $this->join($table, $key, $operator, $value, 'left');
   722|     }
   723|     /**
   724|      * @param      $table
   725|      * @param      $key
   726|      * @param null $operator
   727|      * @param null $value
   728|      *
   729|      * @return $this
   730|      */
   731|     public function rightJoin($table, $key, $operator = null, $value = null)
   732|     {
   733|         return $this->join($table, $key, $operator, $value, 'right');
   734|     }
   735|     /**
   736|      * @param      $table
   737|      * @param      $key
   738|      * @param null $operator
   739|      * @param null $value
   740|      *
   741|      * @return $this
   742|      */
   743|     public function innerJoin($table, $key, $operator = null, $value = null)
   744|     {
   745|         return $this->join($table, $key, $operator, $value, 'inner');
   746|     }
   747|     /**
   748|      * Add a raw query
   749|      *
   750|      * @param $value
   751|      * @param $bindings
   752|      *
   753|      * @return mixed
   754|      */
   755|     public function raw($value, $bindings = array())
   756|     {
   757|         return $this->container->build('\\Pixie\\QueryBuilder\\Raw', array($value, $bindings));
   758|     }
   759|     /**
   760|      * Return PDO instance
   761|      *
   762|      * @return PDO
   763|      */
   764|     public function pdo()
   765|     {
   766|         return $this->pdo;
   767|     }
   768|     /**
   769|      * @param Connection $connection
   770|      *
   771|      * @return $this
   772|      */
   773|     public function setConnection(Connection $connection)
   774|     {
   775|         $this->connection = $connection;
   776|         return $this;
   777|     }
   778|     /**
   779|      * @return Connection
   780|      */
   781|     public function getConnection()
   782|     {
   783|         return $this->connection;
   784|     }
   785|     /**
   786|      * @param        $key
   787|      * @param        $operator
   788|      * @param        $value
   789|      * @param string $joiner
   790|      *
   791|      * @return $this
   792|      */
   793|     protected function whereHandler($key, $operator = null, $value = null, $joiner = 'AND')
   794|     {
   795|         $key = $this->addTablePrefix($key);
   796|         $this->statements['wheres'][] = compact('key', 'operator', 'value', 'joiner');
   797|         return $this;
   798|     }
   799|     /**
   800|      * Add table prefix (if given) on given string.
   801|      *
   802|      * @param      $values
   803|      * @param bool $tableFieldMix If we have mixes of field and table names with a "."
   804|      *
   805|      * @return array|mixed
   806|      */
   807|     public function addTablePrefix($values, $tableFieldMix = true)
   808|     {
   809|         if (is_null($this->tablePrefix)) {
   810|             return $values;
   811|         }
   812|         $single = false;
   813|         if (!is_array($values)) {
   814|             $values = array($values);
   815|             $single = true;
   816|         }
   817|         $return = array();
   818|         foreach ($values as $key => $value) {
   819|             if ($value instanceof Raw || $value instanceof \Closure) {
   820|                 $return[$key] = $value;
   821|                 continue;
   822|             }
   823|             $target = &$value;
   824|             if (!is_int($key)) {
   825|                 $target = &$key;
   826|             }
   827|             if (!$tableFieldMix || ($tableFieldMix && strpos($target, '.') !== false)) {
   828|                 $target = $this->tablePrefix . $target;
   829|             }
   830|             $return[$key] = $value;
   831|         }
   832|         return $single ? end($return) : $return;
   833|     }
   834|     /**
   835|      * @param $key
   836|      * @param $value
   837|      */
   838|     protected function addStatement($key, $value)
   839|     {
   840|         if (!is_array($value)) {
   841|             $value = array($value);
   842|         }
   843|         if (!array_key_exists($key, $this->statements)) {
   844|             $this->statements[$key] = $value;
   845|         } else {
   846|             $this->statements[$key] = array_merge($this->statements[$key], $value);
   847|         }
   848|     }
   849|     /**
   850|      * @param $event
   851|      * @param $table
   852|      *
   853|      * @return callable|null
   854|      */
   855|     public function getEvent($event, $table = ':any')
   856|     {
   857|         return $this->connection->getEventHandler()->getEvent($event, $table);
   858|     }
   859|     /**
   860|      * @param          $event
   861|      * @param string   $table
   862|      * @param callable $action
   863|      *
   864|      * @return void
   865|      */
   866|     public function registerEvent($event, $table, \Closure $action)
   867|     {
   868|         $table = $table ?: ':any';
   869|         if ($table != ':any') {
   870|             $table = $this->addTablePrefix($table, false);
   871|         }
   872|         return $this->connection->getEventHandler()->registerEvent($event, $table, $action);
   873|     }
   874|     /**
   875|      * @param          $event
   876|      * @param string   $table
   877|      *
   878|      * @return void
   879|      */
   880|     public function removeEvent($event, $table = ':any')
   881|     {
   882|         if ($table != ':any') {
   883|             $table = $this->addTablePrefix($table, false);
   884|         }
   885|         return $this->connection->getEventHandler()->removeEvent($event, $table);
   886|     }
   887|     /**
   888|      * @param      $event
   889|      * @return mixed
   890|      */
   891|     public function fireEvents($event)
   892|     {
   893|         $params = func_get_args();
   894|         array_unshift($params, $this);
   895|         return call_user_func_array(array($this->connection->getEventHandler(), 'fireEvents'), $params);
   896|     }
   897|     /**
   898|      * @return array
   899|      */
   900|     public function getStatements()
   901|     {
   902|         return $this->statements;
   903|     }
   904| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/QueryObject.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| <?php namespace Pixie\QueryBuilder;
     2| class QueryObject
     3| {
     4|     /**
     5|      * @var string
     6|      */
     7|     protected $sql;
     8|     /**
     9|      * @var array
    10|      */
    11|     protected $bindings = array();
    12|     /**
    13|      * @var \PDO
    14|      */
    15|     protected $pdo;
    16|     public function __construct($sql, array $bindings, \PDO $pdo)
    17|     {
    18|         $this->sql = (string)$sql;
    19|         $this->bindings = $bindings;
    20|         $this->pdo = $pdo;
    21|     }
    22|     /**
    23|      * @return string
    24|      */
    25|     public function getSql()
    26|     {
    27|         return $this->sql;
    28|     }
    29|     /**
    30|      * @return array
    31|      */
    32|     public function getBindings()
    33|     {
    34|         return $this->bindings;
    35|     }
    36|     /**
    37|      * Get the raw/bound sql
    38|      *
    39|      * @return string
    40|      */
    41|     public function getRawSql()
    42|     {
    43|         return $this->interpolateQuery($this->sql, $this->bindings);
    44|     }
    45|     /**
    46|      * Replaces any parameter placeholders in a query with the value of that
    47|      * parameter. Useful for debugging. Assumes anonymous parameters from
    48|      * $params are are in the same order as specified in $query
    49|      *
    50|      * Reference: http://stackoverflow.com/a/1376838/656489
    51|      *
    52|      * @param string $query  The sql query with parameter placeholders
    53|      * @param array  $params The array of substitution parameters
    54|      *
    55|      * @return string The interpolated query
    56|      */
    57|     protected function interpolateQuery($query, $params)
    58|     {
    59|         $keys = array();
    60|         $values = $params;
    61|         foreach ($params as $key => $value) {
    62|             if (is_string($key)) {
    63|                 $keys[] = '/:' . $key . '/';
    64|             } else {
    65|                 $keys[] = '/[?]/';
    66|             }
    67|             if (is_string($value)) {
    68|                 $values[$key] = $this->pdo->quote($value);
    69|             }
    70|             if (is_array($value)) {
    71|                 $values[$key] = implode(',', $this->pdo->quote($value));
    72|             }
    73|             if (is_null($value)) {
    74|                 $values[$key] = 'NULL';
    75|             }
    76|         }
    77|         $query = preg_replace($keys, $values, $query, 1, $count);
    78|         return $query;
    79|     }
    80| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Raw.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| <?php namespace Pixie\QueryBuilder;
     2| class Raw
     3| {
     4|     /**
     5|      * @var string
     6|      */
     7|     protected $value;
     8|     /**
     9|      * @var array
    10|      */
    11|     protected $bindings;
    12|     public function __construct($value, $bindings = array())
    13|     {
    14|         $this->value = (string)$value;
    15|         $this->bindings = (array)$bindings;
    16|     }
    17|     public function getBindings()
    18|     {
    19|         return $this->bindings;
    20|     }
    21|     /**
    22|      * @return string
    23|      */
    24|     public function __toString()
    25|     {
    26|         return (string)$this->value;
    27|     }
    28| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/Transaction.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| <?php
     2| namespace Pixie\QueryBuilder;
     3| class Transaction extends QueryBuilderHandler
     4| {
     5|     /**
     6|      * Commit the database changes
     7|      */
     8|     public function commit()
     9|     {
    10|         $this->pdo->commit();
    11|         throw new TransactionHaltException();
    12|     }
    13|     /**
    14|      * Rollback the database changes
    15|      */
    16|     public function rollback()
    17|     {
    18|         $this->pdo->rollBack();
    19|         throw new TransactionHaltException();
    20|     }
    21| }


# ====================================================================
# FILE: src/Pixie/QueryBuilder/TransactionHaltException.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| <?php
     2| namespace Pixie\QueryBuilder;
     3| class TransactionHaltException extends \Exception
     4| {
     5| }

