# ====================================================================
# FILE: Neos.Neos/Classes/Domain/Service/UserService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-833 ---
     1| <?php
     2| namespace Neos\Neos\Domain\Service;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
    14| use Neos\Flow\Persistence\PersistenceManagerInterface;
    15| use Neos\Flow\Persistence\QueryResultInterface;
    16| use Neos\Flow\Security\Account;
    17| use Neos\Flow\Security\AccountFactory;
    18| use Neos\Flow\Security\AccountRepository;
    19| use Neos\Flow\Security\Authentication\AuthenticationManagerInterface;
    20| use Neos\Flow\Security\Authentication\Token\UsernamePassword;
    21| use Neos\Flow\Security\Authentication\TokenAndProviderFactoryInterface;
    22| use Neos\Flow\Security\Authentication\TokenInterface;
    23| use Neos\Flow\Security\Authorization\PrivilegeManagerInterface;
    24| use Neos\Flow\Security\Context;
    25| use Neos\Flow\Security\Cryptography\HashService;
    26| use Neos\Flow\Security\Exception\NoSuchRoleException;
    27| use Neos\Flow\Security\Policy\PolicyService;
    28| use Neos\Flow\Security\Policy\Role;
    29| use Neos\Flow\Session\Exception\SessionNotStartedException;
    30| use Neos\Flow\Session\SessionInterface;
    31| use Neos\Flow\Session\SessionManager;
    32| use Neos\Flow\Utility\Now;
    33| use Neos\Neos\Domain\Exception;
    34| use Neos\Neos\Domain\Model\User;
    35| use Neos\Neos\Domain\Repository\UserRepository;
    36| use Neos\Neos\Service\PublishingService;
    37| use Neos\Party\Domain\Model\AbstractParty;
    38| use Neos\Party\Domain\Model\PersonName;
    39| use Neos\Party\Domain\Repository\PartyRepository;
    40| use Neos\Party\Domain\Service\PartyService;
    41| use Neos\ContentRepository\Domain\Model\Workspace;
    42| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    43| use Neos\Neos\Utility\User as UserUtility;
    44| /**
    45|  * A service for managing users
    46|  *
    47|  * @Flow\Scope("singleton")
    48|  * @api
    49|  */
    50| class UserService
    51| {
    52|     /**
    53|      * Might be configurable in the future, for now centralising this as a "constant"
    54|      *
    55|      * @var string
    56|      */
    57|     protected $defaultAuthenticationProviderName = 'Neos.Neos:Backend';
    58|     /**
    59|      * @Flow\Inject
    60|      * @var WorkspaceRepository
    61|      */
    62|     protected $workspaceRepository;
    63|     /**
    64|      * @Flow\Inject
    65|      * @var PublishingService
    66|      */
    67|     protected $publishingService;
    68|     /**
    69|      * @Flow\Inject
    70|      * @var PartyRepository
    71|      */
    72|     protected $partyRepository;
    73|     /**
    74|      * @Flow\Inject
    75|      * @var UserRepository
    76|      */
    77|     protected $userRepository;
    78|     /**
    79|      * @Flow\Inject
    80|      * @var PartyService
    81|      */
    82|     protected $partyService;
    83|     /**
    84|      * @Flow\Inject
    85|      * @var AccountFactory
    86|      */
    87|     protected $accountFactory;
    88|     /**
    89|      * @Flow\Inject
    90|      * @var AccountRepository
    91|      */
    92|     protected $accountRepository;
    93|     /**
    94|      * @Flow\Inject
    95|      * @var PolicyService
    96|      */
    97|     protected $policyService;
    98|     /**
    99|      * @Flow\Inject
   100|      * @var AuthenticationManagerInterface
   101|      */
   102|     protected $authenticationManager;
   103|     /**
   104|      * @Flow\Inject
   105|      * @var PrivilegeManagerInterface
   106|      */
   107|     protected $privilegeManager;
   108|     /**
   109|      * @Flow\Inject
   110|      * @var Context
   111|      */
   112|     protected $securityContext;
   113|     /**
   114|      * @Flow\Inject
   115|      * @var TokenAndProviderFactoryInterface
   116|      */
   117|     protected $tokenAndProviderFactory;
   118|     /**
   119|      * @Flow\Inject
   120|      * @var HashService
   121|      */
   122|     protected $hashService;
   123|     /**
   124|      * @Flow\Inject
   125|      * @var SessionManager
   126|      */
   127|     protected $sessionManager;
   128|     /**
   129|      * @Flow\Inject
   130|      * @var PersistenceManagerInterface
   131|      */
   132|     protected $persistenceManager;
   133|     /**
   134|      * @Flow\Inject(lazy = false)
   135|      * @var Now
   136|      */
   137|     protected $now;
   138|     /**
   139|      * @var array
   140|      */
   141|     protected $runtimeUserCache = [];
   142|     /**
   143|      * Retrieves a list of all existing users
   144|      *
   145|      * @return QueryResultInterface The users
   146|      * @api
   147|      */
   148|     public function getUsers(): QueryResultInterface
   149|     {
   150|         return $this->userRepository->findAllOrderedByUsername();
   151|     }
   152|     /**
   153|      * @param string $searchTerm
   154|      * @return QueryResultInterface
   155|      */
   156|     public function searchUsers(string $searchTerm): QueryResultInterface
   157|     {
   158|         return $this->userRepository->findBySearchTerm($searchTerm);
   159|     }
   160|     /**
   161|      * Retrieves an existing user by the given username
   162|      *
   163|      * @param string $username The username
   164|      * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
   165|      * @return User|null The user, or null if the user does not exist
   166|      * @throws Exception
   167|      * @api
   168|      */
   169|     public function getUser($username, $authenticationProviderName = null)
   170|     {
   171|         $authenticationProviderName = $authenticationProviderName ?: $this->defaultAuthenticationProviderName;
   172|         $cacheIdentifier = $authenticationProviderName . '~' . $username;
   173|         if (array_key_exists($cacheIdentifier, $this->runtimeUserCache)) {
   174|             $userIdentifier = $this->runtimeUserCache[$cacheIdentifier];
   175|             return $this->partyRepository->findByIdentifier($userIdentifier);
   176|         }
   177|         $user = $this->findUserForAccount($username, $authenticationProviderName);
   178|         if ($user instanceof AbstractParty) {
   179|             $userIdentifier = $this->persistenceManager->getIdentifierByObject($user);
   180|         }
   181|         if (isset($userIdentifier) && (string)$userIdentifier !== '') {
   182|             $this->runtimeUserCache[$cacheIdentifier] = $userIdentifier;
   183|             return $this->partyRepository->findByIdentifier($userIdentifier);
   184|         }
   185|         return null;
   186|     }
   187|     /**
   188|      * Returns the username of the given user
   189|      *
   190|      * Technically, this method will look for the user's backend account (or, if authenticationProviderName is specified,
   191|      * for the account matching the given authentication provider) and return the account's identifier.
   192|      *
   193|      * @param User $user
   194|      * @param string $authenticationProviderName
   195|      * @return string The username or null if the given user does not have a backend account
   196|      */
   197|     public function getUsername(User $user, $authenticationProviderName = null)
   198|     {
   199|         $authenticationProviderName = $authenticationProviderName ?: $this->defaultAuthenticationProviderName;
   200|         foreach ($user->getAccounts() as $account) {
   201|             /** @var Account $account */
   202|             if ($account->getAuthenticationProviderName() === $authenticationProviderName) {
   203|                 return $account->getAccountIdentifier();
   204|             }
   205|         }
   206|         return null;
   207|     }
   208|     /**
   209|      * Returns the currently logged in user, if any
   210|      *
   211|      * @return User The currently logged in user, or null
   212|      * @api
   213|      */
   214|     public function getCurrentUser()
   215|     {
   216|         if ($this->securityContext->canBeInitialized() === false) {
   217|             return null;
   218|         }
   219|         $tokens = $this->securityContext->getAuthenticationTokens();
   220|         $user = array_reduce($tokens, function ($foundUser, TokenInterface $token) {
   221|             if ($foundUser !== null) {
   222|                 return $foundUser;
   223|             }
   224|             $account = $token->getAccount();
   225|             if ($account === null) {
   226|                 return $foundUser;
   227|             }
   228|             $user = $this->getNeosUserForAccount($account);
   229|             if ($user === null) {
   230|                 return $foundUser;
   231|             }
   232|             return $user;
   233|         }, null);
   234|         return $user;
   235|     }
   236|     /**
   237|      * Creates a user based on the given information
   238|      *
   239|      * The created user and account are automatically added to their respective repositories and thus be persisted.
   240|      *
   241|      * @param string $username The username of the user to be created.
   242|      * @param string $password Password of the user to be created
   243|      * @param string $firstName First name of the user to be created
   244|      * @param string $lastName Last name of the user to be created
   245|      * @param array $roleIdentifiers A list of role identifiers to assign
   246|      * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
   247|      * @return User The created user instance
   248|      * @api
   249|      */
   250|     public function createUser($username, $password, $firstName, $lastName, array $roleIdentifiers = null, $authenticationProviderName = null)
   251|     {
   252|         $user = new User();
   253|         $name = new PersonName('', $firstName, '', $lastName, '', $username);
   254|         $user->setName($name);
   255|         return $this->addUser($username, $password, $user, $roleIdentifiers, $authenticationProviderName);
   256|     }
   257|     /**
   258|      * Adds a user whose User object has been created elsewhere
   259|      *
   260|      * This method basically "creates" a user like createUser() would, except that it does not create the User
   261|      * object itself. If you need to create the User object elsewhere, for example in your ActionController, make sure
   262|      * to call this method for registering the new user instead of adding it to the PartyRepository manually.
   263|      *
   264|      * This method also creates a new user workspace for the given user if no such workspace exist.
   265|      *
   266|      * @param string $username The username of the user to be created.
   267|      * @param string $password Password of the user to be created
   268|      * @param User $user The pre-built user object to start with
   269|      * @param array $roleIdentifiers A list of role identifiers to assign
   270|      * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
   271|      * @return User The same user object
   272|      * @api
   273|      */
   274|     public function addUser($username, $password, User $user, array $roleIdentifiers = null, $authenticationProviderName = null)
   275|     {
   276|         if ($roleIdentifiers === null) {
   277|             $roleIdentifiers = ['Neos.Neos:Editor'];
   278|         }
   279|         $roleIdentifiers = $this->normalizeRoleIdentifiers($roleIdentifiers);
   280|         $account = $this->accountFactory->createAccountWithPassword($username, $password, $roleIdentifiers, $authenticationProviderName ?: $this->defaultAuthenticationProviderName);
   281|         $this->partyService->assignAccountToParty($account, $user);
   282|         $this->partyRepository->add($user);
   283|         $this->accountRepository->add($account);
   284|         $this->createPersonalWorkspace($user, $account);
   285|         $this->emitUserCreated($user);
   286|         return $user;
   287|     }
   288|     /**
   289|      * Signals that a new user, including a new account has been created.
   290|      *
   291|      * @param User $user The created user
   292|      * @return void
   293|      * @Flow\Signal
   294|      * @api
   295|      */
   296|     public function emitUserCreated(User $user)
   297|     {
   298|     }
   299|     /**
   300|      * Deletes the specified user and all remaining content in his personal workspaces
   301|      *
   302|      * @param User $user The user to delete
   303|      * @return void
   304|      * @throws IllegalObjectTypeException
   305|      * @throws SessionNotStartedException
   306|      * @throws \Exception
   307|      * @api
   308|      */
   309|     public function deleteUser(User $user)
   310|     {
   311|         $this->destroyActiveSessionsForUser($user);
   312|         foreach ($user->getAccounts() as $account) {
   313|             $this->securityContext->withoutAuthorizationChecks(function () use ($account) {
   314|                 $this->deletePersonalWorkspace($account->getAccountIdentifier());
   315|             });
   316|             $this->accountRepository->remove($account);
   317|         }
   318|         $this->removeOwnerFromUsersWorkspaces($user);
   319|         $this->partyRepository->remove($user);
   320|         $this->emitUserDeleted($user);
   321|     }
   322|     /**
   323|      * Signals that the given user has been deleted.
   324|      *
   325|      * @param User $user The created user
   326|      * @return void
   327|      * @Flow\Signal
   328|      * @api
   329|      */
   330|     public function emitUserDeleted(User $user)
   331|     {
   332|     }
   333|     /**
   334|      * Sets a new password for the given user
   335|      *
   336|      * This method will iterate over all accounts owned by the given user and, if the account uses a UsernamePasswordToken,
   337|      * sets a new password accordingly.
   338|      *
   339|      * @param User $user The user to set the password for
   340|      * @param string $password A new password
   341|      * @return void
   342|      * @throws IllegalObjectTypeException
   343|      * @throws SessionNotStartedException
   344|      * @api
   345|      */
   346|     public function setUserPassword(User $user, $password)
   347|     {
   348|         $tokens = $this->tokenAndProviderFactory->getTokens();
   349|         $indexedTokens = [];
   350|         foreach ($tokens as $token) {
   351|             /** @var TokenInterface $token */
   352|             $indexedTokens[$token->getAuthenticationProviderName()] = $token;
   353|         }
   354|         $this->destroyActiveSessionsForUser($user, true);
   355|         foreach ($user->getAccounts() as $account) {
   356|             /** @var Account $account */
   357|             $authenticationProviderName = $account->getAuthenticationProviderName();
   358|             if (isset($indexedTokens[$authenticationProviderName]) && $indexedTokens[$authenticationProviderName] instanceof UsernamePassword) {
   359|                 $account->setCredentialsSource($this->hashService->hashPassword($password));
   360|                 $this->accountRepository->update($account);
   361|             }
   362|         }
   363|     }
   364|     /**
   365|      * Updates the given user in the respective repository and potentially executes further actions depending on what
   366|      * has been changed.
   367|      *
   368|      * Note: changes to the user's account will not be committed for persistence. Please use addRoleToAccount(), removeRoleFromAccount(),
   369|      * setRolesForAccount() and setUserPassword() for changing account properties.
   370|      *
   371|      * @param User $user The modified user
   372|      * @return void
   373|      * @api
   374|      */
   375|     public function updateUser(User $user)
   376|     {
   377|         $this->partyRepository->update($user);
   378|         $this->emitUserUpdated($user);
   379|     }
   380|     /**
   381|      * Adds the specified role to all accounts of the given user and potentially carries out further actions which are needed to
   382|      * properly reflect these changes.
   383|      *
   384|      * @param User $user The user to add roles to
   385|      * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
   386|      * @return integer How often this role has been added to accounts owned by the user
   387|      * @api
   388|      */
   389|     public function addRoleToUser(User $user, $roleIdentifier)
   390|     {
   391|         $counter = 0;
   392|         foreach ($user->getAccounts() as $account) {
   393|             $counter += $this->addRoleToAccount($account, $roleIdentifier);
   394|         }
   395|         return $counter;
   396|     }
   397|     /**
   398|      * Removes the specified role from all accounts of the given user and potentially carries out further actions which are needed to
   399|      * properly reflect these changes.
   400|      *
   401|      * @param User $user The user to remove roles from
   402|      * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
   403|      * @return integer How often this role has been removed from accounts owned by the user
   404|      * @api
   405|      */
   406|     public function removeRoleFromUser(User $user, $roleIdentifier)
   407|     {
   408|         $counter = 0;
   409|         foreach ($user->getAccounts() as $account) {
   410|             $counter += $this->removeRoleFromAccount($account, $roleIdentifier);
   411|         }
   412|         return $counter;
   413|     }
   414|     /**
   415|      * Signals that the given user data has been updated.
   416|      *
   417|      * @param User $user The created user
   418|      * @return void
   419|      * @Flow\Signal
   420|      * @api
   421|      */
   422|     public function emitUserUpdated(User $user)
   423|     {
   424|     }
   425|     /**
   426|      * Overrides any assigned roles of the given account and potentially carries out further actions which are needed
   427|      * to properly reflect these changes.
   428|      *
   429|      * @param Account $account The account to assign the roles to
   430|      * @param array $newRoleIdentifiers A list of fully qualified role identifiers, or role identifiers relative to the Neos.Neos namespace
   431|      * @return void
   432|      * @api
   433|      */
   434|     public function setRolesForAccount(Account $account, array $newRoleIdentifiers)
   435|     {
   436|         $currentRoles = $account->getRoles();
   437|         foreach ($currentRoles as $roleIdentifier => $role) {
   438|             $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
   439|             if (!in_array($roleIdentifier, $newRoleIdentifiers)) {
   440|                 $this->removeRoleFromAccount($account, $roleIdentifier);
   441|             }
   442|         }
   443|         foreach ($newRoleIdentifiers as $roleIdentifier) {
   444|             if (!in_array($roleIdentifier, array_keys($currentRoles))) {
   445|                 $this->addRoleToAccount($account, $roleIdentifier);
   446|             }
   447|         }
   448|     }
   449|     /**
   450|      * Adds the specified role to the given account and potentially carries out further actions which are needed to
   451|      * properly reflect these changes.
   452|      *
   453|      * @param Account $account The account to add roles to
   454|      * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
   455|      * @return integer How often this role has been added to the given account (effectively can be 1 or 0)
   456|      * @api
   457|      */
   458|     public function addRoleToAccount(Account $account, $roleIdentifier)
   459|     {
   460|         $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
   461|         $role = $this->policyService->getRole($roleIdentifier);
   462|         if (!$account->hasRole($role)) {
   463|             $account->addRole($role);
   464|             $this->accountRepository->update($account);
   465|             $this->emitRolesAdded($account, [$role]);
   466|             return 1;
   467|         }
   468|         return 0;
   469|     }
   470|     /**
   471|      * Signals that new roles have been assigned to the given account
   472|      *
   473|      * @param Account $account The account
   474|      * @param array<Role> An array of Role objects which have been added for that account
   475|      * @return void
   476|      * @Flow\Signal
   477|      * @api
   478|      */
   479|     public function emitRolesAdded(Account $account, array $roles)
   480|     {
   481|     }
   482|     /**
   483|      * Removes the specified role from the given account and potentially carries out further actions which are needed to
   484|      * properly reflect these changes.
   485|      *
   486|      * @param Account $account The account to remove roles from
   487|      * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
   488|      * @return integer How often this role has been removed from the given account (effectively can be 1 or 0)
   489|      * @api
   490|      */
   491|     public function removeRoleFromAccount(Account $account, $roleIdentifier)
   492|     {
   493|         $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
   494|         $role = $this->policyService->getRole($roleIdentifier);
   495|         /** @var Account $account */
   496|         if ($account->hasRole($role)) {
   497|             $account->removeRole($role);
   498|             $this->accountRepository->update($account);
   499|             $this->emitRolesRemoved($account, [$role]);
   500|             return 1;
   501|         }
   502|         return 0;
   503|     }
   504|     /**
   505|      * Signals that roles have been removed to the given account
   506|      *
   507|      * @param Account $account The account
   508|      * @param array<Role> An array of Role objects which have been removed
   509|      * @return void
   510|      * @Flow\Signal
   511|      * @api
   512|      */
   513|     public function emitRolesRemoved(Account $account, array $roles)
   514|     {
   515|     }
   516|     /**
   517|      * Reactivates the given user
   518|      *
   519|      * @param User $user The user to activate
   520|      * @return void
   521|      * @api
   522|      */
   523|     public function activateUser(User $user)
   524|     {
   525|         foreach ($user->getAccounts() as $account) {
   526|             /** @var Account $account */
   527|             $account->setExpirationDate(null);
   528|             $this->accountRepository->update($account);
   529|         }
   530|         $this->emitUserActivated($user);
   531|     }
   532|     /**
   533|      * Signals that the given user has been activated
   534|      *
   535|      * @param User $user The user
   536|      * @return void
   537|      * @Flow\Signal
   538|      * @api
   539|      */
   540|     public function emitUserActivated(User $user)
   541|     {
   542|     }
   543|     /**
   544|      * Deactivates the given user
   545|      *
   546|      * @param User $user The user to deactivate
   547|      * @return void
   548|      * @throws IllegalObjectTypeException
   549|      * @throws SessionNotStartedException
   550|      * @api
   551|      */
   552|     public function deactivateUser(User $user)
   553|     {
   554|         $this->destroyActiveSessionsForUser($user);
   555|         /** @var Account $account */
   556|         foreach ($user->getAccounts() as $account) {
   557|             $account->setExpirationDate(
   558|                 \DateTime::createFromFormat(\DateTimeInterface::ATOM, $this->now->format(\DateTimeInterface::ATOM))
   559|             );
   560|             $this->accountRepository->update($account);
   561|         }
   562|         $this->emitUserDeactivated($user);
   563|     }
   564|     /**
   565|      * Checks if the current user may publish to the given workspace according to one the roles of the user's accounts
   566|      *
   567|      * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
   568|      * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
   569|      *
   570|      * @param Workspace $workspace The workspace
   571|      * @return boolean
   572|      */
   573|     public function currentUserCanPublishToWorkspace(Workspace $workspace)
   574|     {
   575|         if ($workspace->getName() === 'live') {
   576|             return $this->securityContext->hasRole('Neos.Neos:LivePublisher');
   577|         }
   578|         if ($workspace->getOwner() === $this->getCurrentUser() || $workspace->getOwner() === null) {
   579|             return true;
   580|         }
   581|         return false;
   582|     }
   583|     /**
   584|      * Checks if the current user may read the given workspace according to one the roles of the user's accounts
   585|      *
   586|      * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
   587|      * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
   588|      *
   589|      * @param Workspace $workspace The workspace
   590|      * @return boolean
   591|      */
   592|     public function currentUserCanReadWorkspace(Workspace $workspace)
   593|     {
   594|         if ($workspace->getName() === 'live') {
   595|             return true;
   596|         }
   597|         if ($workspace->getOwner() === $this->getCurrentUser() || $workspace->getOwner() === null) {
   598|             return true;
   599|         }
   600|         return false;
   601|     }
   602|     /**
   603|      * Checks if the current user may manage the given workspace according to one the roles of the user's accounts
   604|      *
   605|      * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
   606|      * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
   607|      *
   608|      * @param Workspace $workspace The workspace
   609|      * @return boolean
   610|      */
   611|     public function currentUserCanManageWorkspace(Workspace $workspace)
   612|     {
   613|         if ($workspace->isPersonalWorkspace()) {
   614|             return false;
   615|         }
   616|         if ($workspace->isInternalWorkspace()) {
   617|             return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageInternalWorkspaces');
   618|         }
   619|         if ($workspace->isPrivateWorkspace() && $workspace->getOwner() === $this->getCurrentUser()) {
   620|             return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageOwnWorkspaces');
   621|         }
   622|         if ($workspace->isPrivateWorkspace() && $workspace->getOwner() !== $this->getCurrentUser()) {
   623|             return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageAllPrivateWorkspaces');
   624|         }
   625|         return false;
   626|     }
   627|     /**
   628|      * Checks if the current user may transfer ownership of the given workspace
   629|      *
   630|      * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
   631|      * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
   632|      *
   633|      * @param Workspace $workspace The workspace
   634|      * @return boolean
   635|      */
   636|     public function currentUserCanTransferOwnershipOfWorkspace(Workspace $workspace)
   637|     {
   638|         if ($workspace->isPersonalWorkspace()) {
   639|             return false;
   640|         }
   641|         return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageInternalWorkspaces');
   642|     }
   643|     /**
   644|      * @return bool
   645|      * @throws NoSuchRoleException
   646|      * @throws \Neos\Flow\Security\Exception
   647|      */
   648|     public function currentUserIsAdministrator(): bool
   649|     {
   650|         return $this->securityContext->hasRole('Neos.Neos:Administrator');
   651|     }
   652|     /**
   653|      * Returns the default authentication provider name
   654|      *
   655|      * @return string
   656|      * @api
   657|      */
   658|     public function getDefaultAuthenticationProviderName()
   659|     {
   660|         return $this->defaultAuthenticationProviderName;
   661|     }
   662|     /**
   663|      * Signals that the given user has been activated
   664|      *
   665|      * @param User $user The user
   666|      * @return void
   667|      * @Flow\Signal
   668|      * @api
   669|      */
   670|     public function emitUserDeactivated(User $user)
   671|     {
   672|     }
   673|     /**
   674|      * Replaces role identifiers not containing a "." into fully qualified role identifiers from the Neos.Neos namespace.
   675|      *
   676|      * @param array $roleIdentifiers
   677|      * @return array
   678|      */
   679|     protected function normalizeRoleIdentifiers(array $roleIdentifiers)
   680|     {
   681|         foreach ($roleIdentifiers as &$roleIdentifier) {
   682|             $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
   683|         }
   684|         return $roleIdentifiers;
   685|     }
   686|     /**
   687|      * Replaces a role identifier not containing a "." into fully qualified role identifier from the Neos.Neos namespace.
   688|      *
   689|      * @param string $roleIdentifier
   690|      * @return string
   691|      * @throws NoSuchRoleException
   692|      */
   693|     protected function normalizeRoleIdentifier($roleIdentifier)
   694|     {
   695|         if (strpos($roleIdentifier, ':') === false) {
   696|             $roleIdentifier = 'Neos.Neos:' . $roleIdentifier;
   697|         }
   698|         if (!$this->policyService->hasRole($roleIdentifier)) {
   699|             throw new NoSuchRoleException(sprintf('The role %s does not exist.', $roleIdentifier), 1422540184);
   700|         }
   701|         return $roleIdentifier;
   702|     }
   703|     /**
   704|      * Returns an array with all roles of a user's accounts, including parent roles, the "Everybody" role and the
   705|      * "AuthenticatedUser" role, assuming that the user is logged in.
   706|      *
   707|      * @param User $user The user
   708|      * @return array
   709|      * @throws NoSuchRoleException
   710|      */
   711|     public function getAllRoles(User $user): array
   712|     {
   713|         $roles = [
   714|             'Neos.Flow:Everybody' => $this->policyService->getRole('Neos.Flow:Everybody'),
   715|             'Neos.Flow:AuthenticatedUser' => $this->policyService->getRole('Neos.Flow:AuthenticatedUser')
   716|         ];
   717|         /** @var Account $account */
   718|         foreach ($user->getAccounts() as $account) {
   719|             $accountRoles = $account->getRoles();
   720|             /** @var $currentRole Role */
   721|             foreach ($accountRoles as $currentRole) {
   722|                 if (!in_array($currentRole, $roles)) {
   723|                     $roles[$currentRole->getIdentifier()] = $currentRole;
   724|                 }
   725|                 /** @var $currentParentRole Role */
   726|                 foreach ($currentRole->getAllParentRoles() as $currentParentRole) {
   727|                     if (!in_array($currentParentRole, $roles)) {
   728|                         $roles[$currentParentRole->getIdentifier()] = $currentParentRole;
   729|                     }
   730|                 }
   731|             }
   732|         }
   733|         return $roles;
   734|     }
   735|     /**
   736|      * @param User $user
   737|      * @param bool $keepCurrentSession
   738|      * @throws SessionNotStartedException
   739|      */
   740|     private function destroyActiveSessionsForUser(User $user, bool $keepCurrentSession = false): void
   741|     {
   742|         $sessionToKeep = $keepCurrentSession ? $this->sessionManager->getCurrentSession() : null;
   743|         foreach ($user->getAccounts() as $account) {
   744|             $activeSessions = $this->sessionManager->getSessionsByTag($this->securityContext->getSessionTagForAccount($account));
   745|             foreach ($activeSessions as $activeSession) {
   746|                 /** @var SessionInterface $activeSession */
   747|                 if ($sessionToKeep instanceof SessionInterface && $activeSession->getId() === $sessionToKeep->getId()) {
   748|                     continue;
   749|                 }
   750|                 $activeSession->destroy('Requested to remove alle sessions for user ' . $account->getAccountIdentifier());
   751|             }
   752|         }
   753|     }
   754|     /**
   755|      * Creates a personal workspace for the given user's account if it does not exist already.
   756|      *
   757|      * @param User $user The new user to create a workspace for
   758|      * @param Account $account The user's backend account
   759|      * @throws IllegalObjectTypeException
   760|      */
   761|     protected function createPersonalWorkspace(User $user, Account $account)
   762|     {
   763|         $userWorkspaceName = UserUtility::getPersonalWorkspaceNameForUsername($account->getAccountIdentifier());
   764|         $userWorkspace = $this->workspaceRepository->findByIdentifier($userWorkspaceName);
   765|         if ($userWorkspace === null) {
   766|             $liveWorkspace = $this->workspaceRepository->findByIdentifier('live');
   767|             if (!($liveWorkspace instanceof Workspace)) {
   768|                 $liveWorkspace = new Workspace('live');
   769|                 $liveWorkspace->setTitle('Live');
   770|                 $this->workspaceRepository->add($liveWorkspace);
   771|             }
   772|             $userWorkspace = new Workspace($userWorkspaceName, $liveWorkspace, $user);
   773|             $userWorkspace->setTitle((string)$user->getName());
   774|             $this->workspaceRepository->add($userWorkspace);
   775|         }
   776|     }
   777|     /**
   778|      * Removes all personal workspaces of the given user's account if these workspaces exist. Also removes
   779|      * all possibly existing content of these workspaces.
   780|      *
   781|      * @param string $accountIdentifier Identifier of the user's account
   782|      * @return void
   783|      */
   784|     protected function deletePersonalWorkspace($accountIdentifier)
   785|     {
   786|         $userWorkspace = $this->workspaceRepository->findByIdentifier(UserUtility::getPersonalWorkspaceNameForUsername($accountIdentifier));
   787|         if ($userWorkspace instanceof Workspace) {
   788|             $this->publishingService->discardAllNodes($userWorkspace);
   789|             $this->workspaceRepository->remove($userWorkspace);
   790|         }
   791|     }
   792|     /**
   793|      * Removes ownership of all workspaces currently owned by the given user
   794|      *
   795|      * @param User $user The user currently owning workspaces
   796|      * @return void
   797|      */
   798|     protected function removeOwnerFromUsersWorkspaces(User $user)
   799|     {
   800|         /** @var Workspace $workspace */
   801|         foreach ($this->workspaceRepository->findByOwner($user) as $workspace) {
   802|             $workspace->setOwner(null);
   803|             $this->workspaceRepository->update($workspace);
   804|         }
   805|     }
   806|     /**
   807|      * @param string $username
   808|      * @param string $authenticationProviderName
   809|      * @return \Neos\Party\Domain\Model\AbstractParty|null
   810|      * @throws Exception
   811|      */
   812|     protected function findUserForAccount($username, $authenticationProviderName)
   813|     {
   814|         $account = $this->accountRepository->findByAccountIdentifierAndAuthenticationProviderName($username, $authenticationProviderName ?: $this->defaultAuthenticationProviderName);
   815|         if ($account === null) {
   816|             return null;
   817|         }
   818|         $user = $this->partyService->getAssignedPartyOfAccount($account);
   819|         if (!$user instanceof User) {
   820|             throw new Exception(sprintf('Unexpected user type "%s". An account with the identifier "%s" exists, but the corresponding party is not a Neos User.', get_class($user), $username), 1422270948);
   821|         }
   822|         return $user;
   823|     }
   824|     /**
   825|      * @param Account $account
   826|      * @return User|null
   827|      */
   828|     private function getNeosUserForAccount(Account $account): ?User
   829|     {
   830|         $user = $this->partyService->getAssignedPartyOfAccount($account);
   831|         return ($user instanceof User) ? $user : null;
   832|     }
   833| }

