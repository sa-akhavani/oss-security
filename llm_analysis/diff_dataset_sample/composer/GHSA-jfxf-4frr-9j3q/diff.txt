--- a//dev/null
+++ b/Neos.CliSetup/Classes/Command/WelcomeCommandController.php
@@ -0,0 +1,57 @@
+<?php
+declare(strict_types=1);
+namespace Neos\CliSetup\Command;
+/*
+ * This file is part of the Neos.CliSetup package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Cli\CommandController;
+/**
+ * @Flow\Scope("singleton")
+ */
+class WelcomeCommandController extends CommandController
+{
+    public function indexCommand(): void
+    {
+        $this->output(
+            <<<EOT
+            <info>
+                ....######          .######
+                .....#######      ...######
+                .......#######   ....######
+                .........####### ....######
+                ....#......#######...######
+                ....##.......#######.######
+                ....#####......############
+                ....#####  ......##########
+                ....#####    ......########
+                ....#####      ......######
+                .#######         ........
+            Welcome to Neos.
+            </info>
+            The following steps will help you to configure Neos:
+            1. Configure the database connection:
+               <info>./flow setup:database</info>
+            2. Create the required database tables:
+               <info>./flow doctrine:migrate</info>
+            3. Configure the image handler:
+               <info>./flow setup:imagehandler</info>
+            4. Create an admin user:
+               <info>./flow user:create --roles Administrator username password firstname lastname </info>
+            5. Create your own site package or require an existing one (choose one option):
+               - <info>./flow kickstart:site Vendor.Site</info>
+               - <info>composer require neos/demo && ./flow flow:package:rescan</info>
+            6. Import a site or create an empty one (choose one option):
+               - <info>./flow site:import Neos.Demo</info>
+               - <info>./flow site:import Vendor.Site</info>
+               - <info>./flow site:create sitename Vendor.Site Vendor.Site:Document.HomePage</info>
+            EOT
+        );
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Command/NodeCommandControllerPlugin.php
@@ -0,0 +1,1222 @@
+<?php
+namespace Neos\ContentRepository\Command;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Doctrine\ORM\EntityManagerInterface;
+use Doctrine\ORM\EntityNotFoundException;
+use Doctrine\Persistence\Proxy;
+use Doctrine\ORM\QueryBuilder;
+use Neos\ContentRepository\Exception\NodeConfigurationException;
+use Neos\ContentRepository\Exception\NodeException;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Cli\ConsoleOutput;
+use Neos\Flow\Persistence\PersistenceManagerInterface;
+use Neos\Flow\Property\Exception as PropertyException;
+use Neos\Flow\Property\PropertyMapper;
+use Neos\Flow\Security\Exception as SecurityException;
+use Neos\Utility\Arrays;
+use Neos\ContentRepository\Domain\Factory\NodeFactory;
+use Neos\ContentRepository\Domain\Model\Node;
+use Neos\ContentRepository\Domain\Model\NodeData;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\Model\NodeType;
+use Neos\ContentRepository\Domain\Model\Workspace;
+use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
+use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
+use Neos\ContentRepository\Domain\Service\ContentDimensionCombinator;
+use Neos\ContentRepository\Domain\Service\Context;
+use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
+use Neos\ContentRepository\Domain\Service\NodeTypeManager;
+use Neos\ContentRepository\Exception\NodeTypeNotFoundException;
+use Neos\ContentRepository\Utility;
+/**
+ * Plugin for the ContentRepository NodeCommandController which provides functionality for creating missing child nodes.
+ *
+ * @Flow\Scope("singleton")
+ */
+class NodeCommandControllerPlugin implements EventDispatchingNodeCommandControllerPluginInterface
+{
+    /**
+     * @Flow\Inject
+     * @var ContextFactoryInterface
+     */
+    protected $contextFactory;
+    /**
+     * @Flow\Inject
+     * @var NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * @Flow\Inject
+     * @var WorkspaceRepository
+     */
+    protected $workspaceRepository;
+    /**
+     * @Flow\Inject
+     * @var NodeFactory
+     */
+    protected $nodeFactory;
+    /**
+     * @var ConsoleOutput
+     * @deprecated It's discouraged to interact with the console output directly. Instead use the event dispatching. @see dispatch()
+     */
+    protected $output;
+    /**
+     * @Flow\Inject
+     * @var NodeDataRepository
+     */
+    protected $nodeDataRepository;
+    /**
+     * @Flow\Inject
+     * @var EntityManagerInterface
+     */
+    protected $entityManager;
+    /**
+     * @Flow\Inject
+     * @var PropertyMapper
+     */
+    protected $propertyMapper;
+    /**
+     * @var array
+     */
+    protected $pluginConfigurations = [];
+    /**
+     * @var ContentDimensionCombinator
+     * @Flow\Inject
+     */
+    protected $contentDimensionCombinator;
+    /**
+     * @Flow\Inject
+     * @var PersistenceManagerInterface
+     */
+    protected $persistenceManager;
+    /**
+     * Callbacks to be invoked when an event is triggered
+     *
+     * @see dispatch()
+     * @var \Closure[]
+     */
+    protected $eventCallbacks;
+    /**
+     * Returns a short description
+     *
+     * @param string $controllerCommandName Name of the command in question, for example "repair"
+     * @return string A piece of text to be included in the overall description of the node:xy command
+     */
+    public static function getSubCommandShortDescription($controllerCommandName)
+    {
+        switch ($controllerCommandName) {
+            case 'repair':
+                return 'Run checks for basic node integrity in the content repository';
+        }
+        return '';
+    }
+    /**
+     * Returns a piece of description for the specific task the plugin solves for the specified command
+     *
+     * @param string $controllerCommandName Name of the command in question, for example "repair"
+     * @return string A piece of text to be included in the overall description of the node:xy command
+     */
+    public static function getSubCommandDescription($controllerCommandName)
+    {
+        switch ($controllerCommandName) {
+            case 'repair':
+                return <<<'HELPTEXT'
+<u>Remove abstract and undefined node types</u>
+removeAbstractAndUndefinedNodes
+Will remove all nodes that has an abstract or undefined node type.
+<u>Remove orphan (parentless) nodes</u>
+removeOrphanNodes
+Will remove all child nodes that do not have a connection to the root node.
+<u>Remove disallowed child nodes</u>
+removeDisallowedChildNodes
+Will remove all child nodes that are disallowed according to the node type's auto-create
+configuration and constraints.
+<u>Remove undefined node properties</u>
+removeUndefinedProperties
+<u>Remove broken object references</u>
+removeBrokenEntityReferences
+Detects and removes references from nodes to entities which don't exist anymore (for
+example Image nodes referencing ImageVariant objects which are gone for some reason).
+Will remove all undefined properties according to the node type configuration.
+<u>Remove nodes with invalid dimensions</u>
+removeNodesWithInvalidDimensions
+Will check for and optionally remove nodes which have dimension values not matching
+the current content dimension configuration.
+<u>Remove nodes with invalid workspace</u>
+removeNodesWithInvalidWorkspace
+Will check for and optionally remove nodes which belong to a workspace which no longer
+exists..
+<u>Repair inconsistent node identifiers</u>
+fixNodesWithInconsistentIdentifier
+Will check for and optionally repair node identifiers which are out of sync with their
+corresponding nodes in a live workspace.
+<u>Missing child nodes</u>
+createMissingChildNodes
+For all nodes (or only those which match the --node-type filter specified with this
+command) which currently don't have child nodes as configured by the node type's
+configuration new child nodes will be created.
+<u>Reorder child nodes</u>
+reorderChildNodes
+For all nodes (or only those which match the --node-type filter specified with this
+command) which have configured child nodes, those child nodes are reordered according to the
+position from the parents NodeType configuration.
+<u>Missing default properties</u>
+addMissingDefaultValues
+For all nodes (or only those which match the --node-type filter specified with this
+command) which currently don\t have a property that have a default value configuration
+the default value for that property will be set.
+<u>Repair nodes with missing shadow nodes</u>
+repairShadowNodes
+This will reconstruct missing shadow nodes in case something went wrong in creating
+or publishing them. This must be used on a workspace other than live.
+It searches for nodes which have a corresponding node in one of the base workspaces,
+have different node paths, but don't have a corresponding shadow node with a "movedto"
+value.
+HELPTEXT;
+        }
+        return '';
+    }
+    /**
+     * A method which runs the task implemented by the plugin for the given command
+     *
+     * @param string $controllerCommandName Name of the command in question, for example "repair"
+     * @param ConsoleOutput $output (unused)
+     * @param NodeType $nodeType Only handle this node type (if specified)
+     * @param string $workspaceName Only handle this workspace (if specified)
+     * @param boolean $dryRun If true, don't do any changes, just simulate what you would do
+     * @param boolean $cleanup If false, cleanup tasks are skipped
+     * @param string $skip Skip the given check or checks (comma separated)
+     * @param string $only Only execute the given check or checks (comma separated)
+     * @return void
+     */
+    public function invokeSubCommand($controllerCommandName, ConsoleOutput $output, NodeType $nodeType = null, $workspaceName = 'live', $dryRun = false, $cleanup = true, $skip = null, $only = null)
+    {
+        /** @noinspection PhpDeprecationInspection This is only set for backwards compatibility */
+        $this->output = $output;
+        $commandMethods = [
+            'removeAbstractAndUndefinedNodes' => [ 'cleanup' => true ],
+            'removeOrphanNodes' => [ 'cleanup' => true ],
+            'removeDisallowedChildNodes' => [ 'cleanup' => true ],
+            'removeUndefinedProperties' => [ 'cleanup' => true ],
+            'removeBrokenEntityReferences' => [ 'cleanup' => true ],
+            'removeNodesWithInvalidDimensions' => [ 'cleanup' => true ],
+            'removeNodesWithInvalidWorkspace' => [ 'cleanup' => true ],
+            'fixNodesWithInconsistentIdentifier' => [ 'cleanup' => false ],
+            'createMissingChildNodes' => [ 'cleanup' => false ],
+            'reorderChildNodes' => [ 'cleanup' => false ],
+            'addMissingDefaultValues' => [ 'cleanup' => false ],
+            'repairShadowNodes' => [ 'cleanup' => false ]
+        ];
+        $skipCommandNames = Arrays::trimExplode(',', ($skip === null ? '' : $skip));
+        $onlyCommandNames = Arrays::trimExplode(',', ($only === null ? '' : $only));
+        switch ($controllerCommandName) {
+            case 'repair':
+                foreach ($commandMethods as $commandMethodName => $commandMethodConfiguration) {
+                    if (in_array($commandMethodName, $skipCommandNames)) {
+                        continue;
+                    }
+                    if ($onlyCommandNames !== [] && !in_array($commandMethodName, $onlyCommandNames)) {
+                        continue;
+                    }
+                    if (!$cleanup && $commandMethodConfiguration['cleanup']) {
+                        continue;
+                    }
+                    $this->$commandMethodName($workspaceName, $dryRun, $nodeType);
+                }
+        }
+    }
+    /**
+     * Performs checks for missing child nodes according to the node's auto-create configuration and creates
+     * them if necessary.
+     *
+     * @param string $workspaceName Name of the workspace to consider
+     * @param boolean $dryRun Simulate?
+     * @param NodeType $nodeType Only for this node type, if specified
+     * @return void
+     * @throws NodeConfigurationException
+     * @throws NodeTypeNotFoundException
+     */
+    protected function createMissingChildNodes($workspaceName, $dryRun, NodeType $nodeType = null)
+    {
+        if ($nodeType !== null) {
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type "<i>%s</i>" for missing child nodes ...', $nodeType->getName()));
+            $this->createChildNodesByNodeType($nodeType, $workspaceName, $dryRun);
+        } else {
+            $this->dispatch(self::EVENT_NOTICE, 'Checking for missing child nodes ...');
+            foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
+                /** @var NodeType $nodeType */
+                if ($nodeType->isAbstract()) {
+                    continue;
+                }
+                $this->createChildNodesByNodeType($nodeType, $workspaceName, $dryRun);
+            }
+        }
+        $this->persistenceManager->persistAll();
+    }
+    /**
+     * Create missing child nodes for the given node type
+     *
+     * @param NodeType $nodeType
+     * @param string $workspaceName
+     * @param boolean $dryRun
+     * @return void
+     * @throws NodeTypeNotFoundException
+     * @throws NodeConfigurationException
+     */
+    protected function createChildNodesByNodeType(NodeType $nodeType, $workspaceName, $dryRun)
+    {
+        $createdNodesCount = 0;
+        $updatedNodesCount = 0;
+        $incorrectNodeTypeCount = 0;
+        $nodeCreationExceptions = 0;
+        $nodeIdentifiersWhichNeedUpdate = [];
+        $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
+        $nodeTypes[$nodeType->getName()] = $nodeType;
+        if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
+            $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
+            $nodeTypeNames[$nodeType->getName()] = $nodeType;
+        } else {
+            $this->dispatch(self::EVENT_ERROR, sprintf('Node type "<i>%s</i>" does not exist', (string)$nodeType));
+            return;
+        }
+        /** @var $nodeType NodeType */
+        foreach ($nodeTypes as $nodeTypeName => $nodeType) {
+            $childNodes = $nodeType->getAutoCreatedChildNodes();
+            if (count($childNodes) === 0) {
+                continue;
+            }
+            foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
+                $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
+                $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
+                if (!$node instanceof NodeInterface) {
+                    continue;
+                }
+                foreach ($childNodes as $childNodeName => $childNodeType) {
+                    $childNode = $node->getNode($childNodeName);
+                    $childNodeIdentifier = Utility::buildAutoCreatedChildNodeIdentifier($childNodeName, $node->getIdentifier());
+                    if ($childNode === null) {
+                        $taskDescription = sprintf('Add node <i>%s</i> named "<i>%s</i>" in "<i>%s</i>"', $childNodeIdentifier, $childNodeName, $node->getPath());
+                        $taskClosure = function () use ($node, $childNodeName, $childNodeType, $childNodeIdentifier, &$nodeCreationExceptions) {
+                            try {
+                                $node->createNode($childNodeName, $childNodeType, $childNodeIdentifier);
+                            } catch (\Exception $exception) {
+                                $this->dispatch(self::EVENT_WARNING, sprintf('Could not create node named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $childNodeName, $node->getPath(), $exception->getMessage()));
+                                $nodeCreationExceptions++;
+                            }
+                        };
+                        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+                        $createdNodesCount++;
+                    } elseif ($childNode->isRemoved() === true) {
+                        $taskDescription = sprintf('Undelete node <i>%s</i> named "<i>%s</i>" in "<i>%s</i>"', $childNodeIdentifier, $childNodeName, $node->getPath());
+                        $taskClosure = function () use ($node) {
+                            $node->setRemoved(false);
+                        };
+                        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+                        $createdNodesCount++;
+                    } elseif ($childNode->getIdentifier() !== $childNodeIdentifier) {
+                        $nodeIdentifiersWhichNeedUpdate[$childNode->getIdentifier()] = $childNodeIdentifier;
+                    } elseif ($childNode->getNodeType() !== $childNodeType) {
+                        $taskDescription = sprintf('Set node type of node <i>%s</i>: <i>%s</i> => <i>%s</i>', $childNodeIdentifier, $childNode->getNodeType(), $childNodeType);
+                        $taskClosure = function () use ($childNode, $childNodeType) {
+                            $childNode->setNodeType($childNodeType);
+                        };
+                        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+                        $incorrectNodeTypeCount++;
+                    }
+                }
+            }
+        }
+        foreach ($nodeIdentifiersWhichNeedUpdate as $oldNodeIdentifier => $newNodeIdentifier) {
+            $taskDescription = sprintf('Update node identifier from <i>%s</i> to <i>%s</i> because it is not a "stable" identifier', $oldNodeIdentifier, $newNodeIdentifier);
+            $taskClosure = function () use ($oldNodeIdentifier, $newNodeIdentifier) {
+                $queryBuilder = $this->entityManager->createQueryBuilder();
+                $queryBuilder->update(NodeData::class, 'n')
+                    ->set('n.identifier', $queryBuilder->expr()->literal($newNodeIdentifier))
+                    ->where('n.identifier = :oldNodeIdentifier')
+                    ->setParameter('oldNodeIdentifier', $oldNodeIdentifier);
+                $queryBuilder->getQuery()->getResult();
+            };
+            $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+            $updatedNodesCount++;
+        }
+        if ($createdNodesCount !== 0 || $nodeCreationExceptions !== 0 || $updatedNodesCount !== 0 || $incorrectNodeTypeCount !== 0) {
+            if ($dryRun === false) {
+                if ($createdNodesCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('Created <i>%d</i> new child nodes', $createdNodesCount));
+                }
+                if ($updatedNodesCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('Updated identifier of <i>%d</i> child nodes', $updatedNodesCount));
+                }
+                if ($incorrectNodeTypeCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('Changed node type of <i>%d</i> child nodes', $incorrectNodeTypeCount));
+                }
+                if ($nodeCreationExceptions > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> Errors occurred during child node creation', $nodeCreationExceptions));
+                }
+                $this->persistenceManager->persistAll();
+            } else {
+                if ($createdNodesCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> missing child nodes need to be created', $createdNodesCount));
+                }
+                if ($updatedNodesCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> identifiers of child nodes need to be updated', $updatedNodesCount));
+                }
+                if ($incorrectNodeTypeCount > 0) {
+                    $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> child nodes have incorrect node type', $incorrectNodeTypeCount));
+                }
+            }
+        }
+    }
+    /**
+     * Performs checks for unset properties that has default values and sets them if necessary.
+     *
+     * @param string $workspaceName Name of the workspace to consider
+     * @param boolean $dryRun Simulate?
+     * @param NodeType $nodeType Only for this node type, if specified
+     * @return void
+     * @throws NodeConfigurationException
+     * @throws NodeTypeNotFoundException
+     */
+    public function addMissingDefaultValues($workspaceName, $dryRun, NodeType $nodeType = null)
+    {
+        if ($nodeType !== null) {
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type <i>%s</i> for missing default values ...', $nodeType));
+            $this->addMissingDefaultValuesByNodeType($nodeType, $workspaceName, $dryRun);
+        } else {
+            $this->dispatch(self::EVENT_NOTICE, 'Checking for missing default values ...');
+            foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
+                /** @var NodeType $nodeType */
+                if ($nodeType->isAbstract()) {
+                    continue;
+                }
+                $this->addMissingDefaultValuesByNodeType($nodeType, $workspaceName, $dryRun);
+            }
+        }
+    }
+    /**
+     * Adds missing default values for the given node type
+     *
+     * @param NodeType $nodeType
+     * @param string $workspaceName
+     * @param boolean $dryRun
+     * @return void
+     * @throws NodeConfigurationException
+     * @throws NodeTypeNotFoundException
+     */
+    public function addMissingDefaultValuesByNodeType(NodeType $nodeType, $workspaceName, $dryRun)
+    {
+        $addedMissingDefaultValuesCount = 0;
+        $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
+        $nodeTypes[$nodeType->getName()] = $nodeType;
+        if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
+            $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
+            $nodeTypeNames[$nodeType->getName()] = $nodeType;
+        } else {
+            $this->dispatch(self::EVENT_ERROR, sprintf('Node type <i>%s</i> does not exist', $nodeType));
+            return;
+        }
+        /** @var $nodeType NodeType */
+        foreach ($nodeTypes as $nodeTypeName => $nodeType) {
+            $defaultValues = $nodeType->getDefaultValuesForProperties();
+            foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
+                /** @var NodeData $nodeData */
+                $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
+                $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
+                if (!$node instanceof NodeInterface) {
+                    continue;
+                }
+                if ($node instanceof Node && !$node->dimensionsAreMatchingTargetDimensionValues()) {
+                    if ($node->getNodeData()->getDimensionValues() === []) {
+                        $this->dispatch(self::EVENT_NOTICE, sprintf('Skipping node <i>%s</i> because it has no dimension values set', $node->getPath()));
+                    } else {
+                        $this->dispatch(self::EVENT_NOTICE, sprintf('Skipping node <i>%s</i> because it has invalid dimension values: %s', $node->getPath(), json_encode($node->getNodeData()->getDimensionValues())));
+                    }
+                    continue;
+                }
+                foreach ($defaultValues as $propertyName => $defaultValue) {
+                    if ($propertyName[0] === '_' || $node->hasProperty($propertyName)) {
+                        continue;
+                    }
+                    $taskDescription = sprintf('Set default value for property named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $propertyName, $node->getPath(), $node->getNodeType()->getName());
+                    $taskClosure = function () use ($node, $propertyName, $defaultValue) {
+                        $node->setProperty($propertyName, $defaultValue);
+                    };
+                    $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+                    $addedMissingDefaultValuesCount++;
+                }
+            }
+        }
+        if ($addedMissingDefaultValuesCount !== 0) {
+            if ($dryRun === false) {
+                $this->persistenceManager->persistAll();
+                $this->dispatch(self::EVENT_NOTICE, sprintf('Added <i>%d</i> new default values', $addedMissingDefaultValuesCount));
+            } else {
+                $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> missing default values need to be set', $addedMissingDefaultValuesCount));
+            }
+        }
+    }
+    /**
+     * Performs checks for nodes with abstract or undefined node types and removes them if found.
+     *
+     * @param string $workspaceName
+     * @return void
+     */
+    protected function removeAbstractAndUndefinedNodes($workspaceName)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with abstract or undefined node types ...');
+        $abstractNodeTypes = [];
+        $nonAbstractNodeTypes = [];
+        foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
+            /** @var NodeType $nodeType */
+            if ($nodeType->isAbstract()) {
+                $abstractNodeTypes[] = $nodeType->getName();
+            } else {
+                $nonAbstractNodeTypes[] = $nodeType->getName();
+            }
+        }
+        /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder
+            ->select('n')
+            ->distinct()
+            ->from(NodeData::class, 'n')
+            ->where('n.nodeType NOT IN (:excludeNodeTypes)')
+            ->setParameter('excludeNodeTypes', $nonAbstractNodeTypes)
+            ->andWhere('n.workspace = :workspace')
+            ->setParameter('workspace', $workspaceName);
+        $nodes = $queryBuilder->getQuery()->getArrayResult();
+        $removableNodesCount = count($nodes);
+        if ($removableNodesCount === 0) {
+            return;
+        }
+        foreach ($nodes as $node) {
+            $name = $node['path'] === '/' ? '' : substr($node['path'], strrpos($node['path'], '/') + 1);
+            $type = in_array($node['nodeType'], $abstractNodeTypes) ? 'abstract' : 'undefined';
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Found node with %s node type named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>"', $type, $name, $node['nodeType'], $node['path']));
+        }
+        $taskDescription = sprintf('Remove <i>%d</i> node%s with abstract or undefined node types', $removableNodesCount, $removableNodesCount > 1 ? 's' : '');
+        $taskClosure = function () use ($nodes) {
+            foreach ($nodes as $node) {
+                $this->removeNode($node['identifier'], $node['dimensionsHash']);
+            }
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Performs checks for disallowed child nodes according to the node's auto-create configuration and constraints
+     * and removes them if found.
+     *
+     * @param string $workspaceName
+     * @return void
+     */
+    protected function removeDisallowedChildNodes($workspaceName)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for disallowed child nodes ...');
+        /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
+        $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
+        $nodes = [];
+        $nodeExceptionCount = 0;
+        $removeDisallowedChildNodes = function (NodeInterface $node) use (&$removeDisallowedChildNodes, &$nodes, &$nodeExceptionCount) {
+            try {
+                foreach ($node->getChildNodes() as $childNode) {
+                    /** @var $childNode NodeInterface */
+                    if (!$childNode->isAutoCreated() && !$node->isNodeTypeAllowedAsChildNode($childNode->getNodeType())) {
+                        $nodes[] = $childNode;
+                        $parent = $node->isAutoCreated() ? $node->getParent() : $node;
+                        $this->dispatch(self::EVENT_NOTICE, sprintf('Found disallowed node named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>", child of node "<i>%s</i>" (<i>%s</i>)', $childNode->getName(), $childNode->getNodeType()->getName(), $childNode->getPath(), $parent->getName(), $parent->getNodeType()->getName()));
+                    } else {
+                        $removeDisallowedChildNodes($childNode);
+                    }
+                }
+            } catch (\Exception $exception) {
+                $this->dispatch(self::EVENT_WARNING, sprintf('Error while traversing child nodes of node <i>%s</i>: %s (%s)', $node->getIdentifier(), $exception->getMessage(), $exception->getCode()));
+                $nodeExceptionCount++;
+            }
+        };
+        foreach ($this->contentDimensionCombinator->getAllAllowedCombinations() as $dimensionConfiguration) {
+            $context = $this->createContext($workspace->getName(), $dimensionConfiguration);
+            $removeDisallowedChildNodes($context->getRootNode());
+            $context->getFirstLevelNodeCache()->flush();
+            $this->nodeFactory->reset();
+        }
+        $disallowedChildNodesCount = count($nodes);
+        if ($disallowedChildNodesCount > 0) {
+            $taskDescription = sprintf('Remove <i>%d</i> disallowed node%s.', $disallowedChildNodesCount, $disallowedChildNodesCount > 1 ? 's' : '');
+            $taskClosure = function () use ($nodes, $workspaceName) {
+                foreach ($nodes as $node) {
+                    $this->removeNodeAndChildNodesInWorkspaceByPath($node->getPath(), $workspaceName);
+                }
+            };
+            $taskRequiresConfirmation = true;
+            $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+            if ($nodeExceptionCount > 0) {
+                $this->dispatch(self::EVENT_NOTICE, '<i>%d</i> error%s occurred during child node traversing.', $nodeExceptionCount, $nodeExceptionCount > 1 ? 's' : '');
+            }
+        }
+    }
+    /**
+     * Performs checks for orphan nodes removes them if found.
+     *
+     * @param string $workspaceName
+     * @param boolean $dryRun (unused)
+     * @param NodeType $nodeType Only for this node type, if specified
+     * @return void
+     */
+    protected function removeOrphanNodes($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for orphan nodes ...');
+        /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $workspaceList = [];
+        /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
+        $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
+        while ($workspace !== null) {
+            $workspaceList[] = $workspace->getName();
+            $workspace = $workspace->getBaseWorkspace();
+        }
+        $query = $queryBuilder
+            ->select('n')
+            ->from(NodeData::class, 'n')
+            ->leftJoin(
+                NodeData::class,
+                'n2',
+                \Doctrine\ORM\Query\Expr\Join::WITH,
+                'n.parentPathHash = n2.pathHash AND n2.workspace IN (:workspaceList)'
+            )
+            ->where('n2.path IS NULL')
+            ->andWhere($queryBuilder->expr()->not('n.path = :slash'))
+            ->andWhere('n.workspace = :workspace');
+        $parameters = ['workspaceList' => $workspaceList, 'slash' => '/', 'workspace' => $workspaceName];
+        if ($nodeType !== null) {
+            $query->andWhere('n.nodeType = :nodetype');
+            $parameters['nodetype'] = $nodeType;
+        }
+        $nodes = $query
+            ->setParameters($parameters)
+            ->getQuery()->getArrayResult();
+        $nodesToBeRemoved = count($nodes);
+        if ($nodesToBeRemoved === 0) {
+            return;
+        }
+        foreach ($nodes as $node) {
+            $name = $node['path'] === '/' ? '' : substr($node['path'], strrpos($node['path'], '/') + 1);
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Found orphan node named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>"', $name, $node['nodeType'], $node['path']));
+        }
+        $taskDescription = sprintf('Remove <i>%d</i> orphan node%s', $nodesToBeRemoved, $nodesToBeRemoved > 1 ? 's' : '');
+        $taskClosure = function () use ($nodes, $workspaceName) {
+            foreach ($nodes as $node) {
+                $this->removeNodeAndChildNodesInWorkspaceByPath($node['path'], $workspaceName);
+            }
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Performs checks for orphan nodes removes them if found.
+     *
+     * @param string $workspaceName
+     * @param boolean $dryRun (unused)
+     * @param NodeType $nodeType Only for this node type, if specified
+     * @return void
+     * @throws NodeConfigurationException
+     */
+    public function removeUndefinedProperties($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for undefined properties ...');
+        /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
+        $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
+        $nodesWithUndefinedPropertiesNodes = [];
+        $undefinedPropertiesCount = 0;
+        $nodes = $nodeType !== null ? $this->getNodeDataByNodeTypeAndWorkspace($nodeType, $workspaceName) : $this->nodeDataRepository->findByWorkspace($workspace);
+        foreach ($nodes as $nodeData) {
+            try {
+                /** @var NodeData $nodeData */
+                if ($nodeData->getNodeType()->getName() === 'unstructured') {
+                    continue;
+                }
+                $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
+                $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
+                if (!$node instanceof NodeInterface) {
+                    continue;
+                }
+                $nodeType = $node->getNodeType();
+                $nodeTypePropertyNames = array_keys($nodeType->getProperties());
+                $undefinedProperties = [];
+                foreach ($node->getProperties() as $propertyName => $propertyValue) {
+                    if (!in_array($propertyName, $nodeTypePropertyNames)) {
+                        $undefinedProperties[] = $propertyName;
+                    }
+                }
+                if ($undefinedProperties !== []) {
+                    $nodesWithUndefinedPropertiesNodes[] = ['node' => $node, 'undefinedProperties' => $undefinedProperties];
+                    foreach ($undefinedProperties as $undefinedProperty) {
+                        $undefinedPropertiesCount++;
+                        $this->dispatch(self::EVENT_NOTICE, sprintf('Found undefined property named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $undefinedProperty, $node->getPath(), $node->getNodeType()->getName()));
+                    }
+                }
+            } /** @noinspection PhpRedundantCatchClauseInspection */ catch (NodeTypeNotFoundException $exception) {
+                $this->dispatch(self::EVENT_NOTICE, sprintf('Skipped undefined node type in "%s"', $nodeData->getPath()));
+            }
+        }
+        if ($undefinedPropertiesCount > 0) {
+            $taskDescription = sprintf('Remove <i>%d</i> undefined propert%s.', $undefinedPropertiesCount, $undefinedPropertiesCount > 1 ? 'ies' : 'y');
+            $taskClosure = function () use ($nodesWithUndefinedPropertiesNodes) {
+                foreach ($nodesWithUndefinedPropertiesNodes as $nodesWithUndefinedPropertiesNode) {
+                    /** @var NodeInterface $node */
+                    $node = $nodesWithUndefinedPropertiesNode['node'];
+                    foreach ($nodesWithUndefinedPropertiesNode['undefinedProperties'] as $undefinedProperty) {
+                        if ($node->hasProperty($undefinedProperty)) {
+                            $node->removeProperty($undefinedProperty);
+                        }
+                    }
+                }
+            };
+            $taskRequiresConfirmation = true;
+            $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+        }
+        $this->persistenceManager->persistAll();
+    }
+    /**
+     * Remove broken entity references
+     *
+     * This removes references from nodes to entities which don't exist anymore.
+     *
+     * @param string $workspaceName
+     * @return void
+     * @throws NodeException
+     * @throws PropertyException
+     * @throws SecurityException
+     */
+    public function removeBrokenEntityReferences($workspaceName)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for broken entity references ...');
+        /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
+        $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
+        $nodeTypesWithEntityReferences = [];
+        foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
+            /** @var NodeType $nodeType */
+            foreach (array_keys($nodeType->getProperties()) as $propertyName) {
+                $propertyType = $nodeType->getPropertyType($propertyName);
+                if (strpos($propertyType, '\\') !== false) {
+                    if (!isset($nodeTypesWithEntityReferences[$nodeType->getName()])) {
+                        $nodeTypesWithEntityReferences[$nodeType->getName()] = [];
+                    }
+                    $nodeTypesWithEntityReferences[$nodeType->getName()][$propertyName] = $propertyType;
+                }
+            }
+        }
+        $nodesWithBrokenEntityReferences = [];
+        $brokenReferencesCount = 0;
+        foreach ($nodeTypesWithEntityReferences as $nodeTypeName => $properties) {
+            $nodeDatas = $this->nodeDataRepository->findByParentAndNodeTypeRecursively('/', $nodeTypeName, $workspace);
+            foreach ($nodeDatas as $nodeData) {
+                /** @var NodeData $nodeData */
+                foreach ($properties as $propertyName => $propertyType) {
+                    $propertyValue = $nodeData->getProperty($propertyName);
+                    $convertedProperty = null;
+                    if (is_object($propertyValue)) {
+                        $convertedProperty = $propertyValue;
+                    }
+                    if (is_string($propertyValue) && strlen($propertyValue) === 36) {
+                        $convertedProperty = $this->propertyMapper->convert($propertyValue, $propertyType);
+                        if ($convertedProperty === null) {
+                            $nodesWithBrokenEntityReferences[$nodeData->getIdentifier()][$propertyName] = $nodeData;
+                            $this->dispatch(self::EVENT_NOTICE, sprintf('Broken reference in "<i>%s</i>" (%s), property "<i>%s</i>" (<i>%s</i>) referring to <i>%s</i>.', $nodeData->getPath(), $nodeData->getIdentifier(), $propertyName, $propertyType, $propertyValue));
+                            $brokenReferencesCount ++;
+                        }
+                    }
+                    if ($convertedProperty instanceof Proxy) {
+                        try {
+                            $convertedProperty->__load();
+                        } /** @noinspection PhpRedundantCatchClauseInspection */ catch (EntityNotFoundException $e) {
+                            $nodesWithBrokenEntityReferences[$nodeData->getIdentifier()][$propertyName] = $nodeData;
+                            $this->dispatch(self::EVENT_NOTICE, sprintf('Broken reference in "<i>%s</i>" (%s), property "<i>%s</i>" (<i>%s</i>) referring to <i>%s</i>.', $nodeData->getPath(), $nodeData->getIdentifier(), $propertyName, $propertyType, $propertyValue));
+                            $brokenReferencesCount ++;
+                        }
+                    }
+                }
+            }
+        }
+        if ($brokenReferencesCount === 0) {
+            return;
+        }
+        $taskDescription = sprintf('Remove <i>%d</i> broken entity reference%s.', $brokenReferencesCount, $brokenReferencesCount > 1 ? 's' : '');
+        $taskClosure = function () use ($nodesWithBrokenEntityReferences) {
+            foreach ($nodesWithBrokenEntityReferences as $nodeIdentifier => $properties) {
+                foreach ($properties as $propertyName => $nodeData) {
+                    /** @var NodeData $nodeData */
+                    $nodeData->setProperty($propertyName, null);
+                }
+            }
+            $this->persistenceManager->persistAll();
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Creates a content context for given workspace
+     *
+     * @param string $workspaceName
+     * @param array $dimensions
+     * @return Context
+     */
+    protected function createContext($workspaceName, $dimensions)
+    {
+        return $this->contextFactory->create([
+            'workspaceName' => $workspaceName,
+            'dimensions' => $dimensions,
+            'invisibleContentShown' => true,
+            'inaccessibleContentShown' => true,
+            'removedContentShown' => true
+        ]);
+    }
+    /**
+     * Retrieves all NodeData objects of a certain node type inside a given workspace.
+     *
+     * Shadow nodes are excluded, because they will be published when publishing the moved node.
+     *
+     * @param string $nodeType
+     * @param string $workspaceName
+     * @return array<NodeData>
+     */
+    protected function getNodeDataByNodeTypeAndWorkspace($nodeType, $workspaceName)
+    {
+        /** @var QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder->select('n')
+            ->distinct()
+            ->from(NodeData::class, 'n')
+            ->where('n.nodeType = :nodeType')
+            ->andWhere('n.workspace = :workspace')
+            ->andWhere('n.movedTo IS NULL OR n.removed = :removed')
+            ->setParameter('nodeType', $nodeType)
+            ->setParameter('workspace', $workspaceName)
+            ->setParameter('removed', false, \PDO::PARAM_BOOL);
+        return $queryBuilder->getQuery()->getResult();
+    }
+    /**
+     * Removes all nodes with a specific path and their children in the given workspace.
+     *
+     * @param string $nodePath
+     * @param string $workspaceName
+     */
+    protected function removeNodeAndChildNodesInWorkspaceByPath($nodePath, $workspaceName)
+    {
+        /** @var QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder
+            ->resetDQLParts()
+            ->delete(NodeData::class, 'n')
+            ->where('n.path LIKE :path')
+            ->orWhere('n.path LIKE :subpath')
+            ->andWhere('n.workspace = :workspace')
+            ->setParameters(['path' => $nodePath, 'subpath' => $nodePath . '/%', 'workspace' => $workspaceName])
+            ->getQuery()
+            ->execute();
+    }
+    /**
+     * Removes the specified node (exactly that one)
+     *
+     * @param string $nodeIdentifier
+     * @param string $dimensionsHash
+     */
+    protected function removeNode($nodeIdentifier, $dimensionsHash)
+    {
+        /** @var QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder
+            ->resetDQLParts()
+            ->delete(NodeData::class, 'n')
+            ->where('n.identifier = :identifier')
+            ->andWhere('n.dimensionsHash = :dimensionsHash')
+            ->setParameters(['identifier' => $nodeIdentifier, 'dimensionsHash' => $dimensionsHash])
+            ->getQuery()
+            ->execute();
+    }
+    /**
+     * Remove nodes with invalid dimension values
+     *
+     * This removes nodes which have dimension values not fitting to the current dimension configuration
+     *
+     * @param string $workspaceName Name of the workspace to consider
+     * @return void
+     */
+    public function removeNodesWithInvalidDimensions($workspaceName)
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with invalid dimensions ...');
+        $allowedDimensionCombinations = $this->contentDimensionCombinator->getAllAllowedCombinations();
+        $nodesArray = $this->collectNodesWithInvalidDimensions($workspaceName, $allowedDimensionCombinations);
+        if ($nodesArray === []) {
+            return;
+        }
+        $numberOfNodes = count($nodesArray);
+        $taskDescription = sprintf('Remove <i>%d</i> node%s with invalid dimension values', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
+        $taskClosure = function () use ($nodesArray) {
+            foreach ($nodesArray as $nodeArray) {
+                $this->removeNode($nodeArray['identifier'], $nodeArray['dimensionsHash']);
+            }
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Collects all nodes of the given node type which have dimension values not fitting to the current dimension
+     * configuration.
+     *
+     * @param string $workspaceName
+     * @param array $allowedDimensionCombinations
+     * @return array
+     */
+    protected function collectNodesWithInvalidDimensions($workspaceName, array $allowedDimensionCombinations)
+    {
+        $nodes = [];
+        ksort($allowedDimensionCombinations);
+        /** @var QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder->select('n')
+            ->from(NodeData::class, 'n')
+            ->where('n.workspace = :workspace')
+            ->setParameter('workspace', $workspaceName);
+        foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
+            if ($nodeDataArray['dimensionValues'] === [] || $nodeDataArray['dimensionValues'] === '') {
+                continue;
+            }
+            $foundValidDimensionValues = false;
+            foreach ($allowedDimensionCombinations as $allowedDimensionConfiguration) {
+                ksort($allowedDimensionConfiguration);
+                ksort($nodeDataArray['dimensionValues']);
+                foreach ($allowedDimensionConfiguration as $allowedDimensionKey => $allowedDimensionValuesArray) {
+                    if (isset($nodeDataArray['dimensionValues'][$allowedDimensionKey]) && isset($nodeDataArray['dimensionValues'][$allowedDimensionKey][0])) {
+                        $actualDimensionValue = $nodeDataArray['dimensionValues'][$allowedDimensionKey][0];
+                        if (in_array($actualDimensionValue, $allowedDimensionValuesArray)) {
+                            $foundValidDimensionValues = true;
+                            break;
+                        }
+                    }
+                }
+            }
+            if (!$foundValidDimensionValues) {
+                $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> has invalid dimension values: %s', $nodeDataArray['path'], json_encode($nodeDataArray['dimensionValues'])));
+                $nodes[] = $nodeDataArray;
+            }
+        }
+        return $nodes;
+    }
+    /**
+     * Remove nodes with invalid workspace
+     *
+     * This removes nodes which refer to a workspace which does not exist.
+     *
+     * @return void
+     */
+    public function removeNodesWithInvalidWorkspace()
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with invalid workspace ...');
+        $nodesArray = $this->collectNodesWithInvalidWorkspace();
+        if ($nodesArray === []) {
+            return;
+        }
+        $numberOfNodes = count($nodesArray);
+        $taskDescription = sprintf('Remove <i>%d</i> node%s referring to an invalid workspace.', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
+        $taskClosure = function () use ($nodesArray) {
+            foreach ($nodesArray as $nodeArray) {
+                $this->removeNode($nodeArray['identifier'], $nodeArray['dimensionsHash']);
+            }
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Collects all nodes of the given node type which refer to an invalid workspace
+     * configuration.
+     *
+     * Note: due to the foreign key constraints in the database, there actually never should
+     *       be any node with n.workspace of a non-existing workspace because if that workspace
+     *       does not exist anymore, the value would turn NULL. But the query covers this nevertheless.
+     *       Better safe than sorry.
+     *
+     * @return array
+     */
+    protected function collectNodesWithInvalidWorkspace()
+    {
+        $nodes = [];
+        $workspaceNames = [];
+        foreach ($this->workspaceRepository->findAll() as $workspace) {
+            $workspaceNames[] = $workspace->getName();
+        }
+        /** @var QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder->select('n')
+            ->from(NodeData::class, 'n')
+            ->add(
+                'where',
+                $queryBuilder->expr()->orX(
+                    $queryBuilder->expr()->notIn('n.workspace', $workspaceNames),
+                    $queryBuilder->expr()->isNull('n.workspace')
+                )
+            );
+        foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> (identifier: <i>%s</i>) refers to an invalid workspace: <i>%s</i>', $nodeDataArray['path'], $nodeDataArray['identifier'], (isset($nodeDataArray['workspace']) ? $nodeDataArray['workspace'] : 'null')));
+            $nodes[] = $nodeDataArray;
+        }
+        return $nodes;
+    }
+    /**
+     * Detect and fix nodes in non-live workspaces whose identifier does not match their corresponding node in the
+     * live workspace.
+     *
+     * @return void
+     */
+    public function fixNodesWithInconsistentIdentifier()
+    {
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with inconsistent identifier ...');
+        $nodesArray = [];
+        $liveWorkspaceNames = [];
+        $nonLiveWorkspaceNames = [];
+        foreach ($this->workspaceRepository->findAll() as $workspace) {
+            /** @var Workspace $workspace */
+            if ($workspace->getBaseWorkspace() !== null) {
+                $nonLiveWorkspaceNames[] = $workspace->getName();
+            } else {
+                $liveWorkspaceNames[] = $workspace->getName();
+            }
+        }
+        foreach ($nonLiveWorkspaceNames as $workspaceName) {
+            /** @var QueryBuilder $queryBuilder */
+            $queryBuilder = $this->entityManager->createQueryBuilder();
+            $queryBuilder->select('nonlive.Persistence_Object_Identifier, nonlive.identifier, nonlive.path, live.identifier AS liveIdentifier')
+                ->from(NodeData::class, 'nonlive')
+                ->join(NodeData::class, 'live', 'WITH', 'live.path = nonlive.path AND live.dimensionsHash = nonlive.dimensionsHash AND live.identifier != nonlive.identifier')
+                ->where('nonlive.workspace = ?1')
+                ->andWhere($queryBuilder->expr()->in('live.workspace', $liveWorkspaceNames))
+                ->andWhere('nonlive.path != \'/\'')
+                ->setParameter(1, $workspaceName)
+            ;
+            foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
+                $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> in workspace <i>%s</i> has identifier <i>%s</i> but live node has identifier <i>%s</i>.', $nodeDataArray['path'], $workspaceName, $nodeDataArray['identifier'], $nodeDataArray['liveIdentifier']));
+                $nodesArray[] = $nodeDataArray;
+            }
+        }
+        if ($nodesArray === []) {
+            return;
+        }
+        $numberOfNodes = count($nodesArray);
+        $taskDescription = sprintf('Fix identifier%s of %s node%s', $numberOfNodes > 1 ? 's' : '', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
+        $taskClosure = function () use ($nodesArray) {
+            foreach ($nodesArray as $nodeArray) {
+                /** @var QueryBuilder $queryBuilder */
+                $queryBuilder = $this->entityManager->createQueryBuilder();
+                $queryBuilder->update(NodeData::class, 'nonlive')
+                    ->set('nonlive.identifier', $queryBuilder->expr()->literal($nodeArray['liveIdentifier']))
+                    ->where('nonlive.Persistence_Object_Identifier = ?1')
+                    ->setParameter(1, $nodeArray['Persistence_Object_Identifier']);
+                $result = $queryBuilder->getQuery()->getResult();
+                if ($result !== 1) {
+                    $errorMessage = 'The update query returned an unexpected result!' . PHP_EOL;
+                    $errorMessage .= sprintf('<b>Query:</b> %s', $queryBuilder->getQuery()->getSQL()) . PHP_EOL;
+                    $errorMessage .= sprintf('<b>Result:</b> %s', var_export($result, true));
+                    $this->dispatch(self::EVENT_ERROR, $errorMessage);
+                    return;
+                }
+            }
+        };
+        $taskRequiresConfirmation = true;
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
+    }
+    /**
+     * Reorder child nodes according to the current position configuration of child nodes.
+     *
+     * @param string $workspaceName Name of the workspace to consider
+     * @param boolean $dryRun Simulate?
+     * @param NodeType $nodeType Only for this node type, if specified
+     * @return void
+     * @throws NodeConfigurationException
+     * @throws NodeTypeNotFoundException
+     */
+    protected function reorderChildNodes($workspaceName, $dryRun, NodeType $nodeType = null)
+    {
+        if ($nodeType !== null) {
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type "<i>%s</i>" for child nodes that need reordering ...', $nodeType));
+            $this->reorderChildNodesByNodeType($workspaceName, $dryRun, $nodeType);
+        } else {
+            $this->dispatch(self::EVENT_NOTICE, 'Checking for child nodes that need reordering ...');
+            foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
+                /** @var NodeType $nodeType */
+                if ($nodeType->isAbstract()) {
+                    continue;
+                }
+                $this->reorderChildNodesByNodeType($workspaceName, $dryRun, $nodeType);
+            }
+        }
+        $this->persistenceManager->persistAll();
+    }
+    /**
+     * Reorder child nodes for the given node type
+     *
+     * @param string $workspaceName
+     * @param boolean $dryRun (unused)
+     * @param NodeType $nodeType
+     * @return void
+     * @throws NodeTypeNotFoundException
+     * @throws NodeConfigurationException
+     */
+    protected function reorderChildNodesByNodeType($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType)
+    {
+        $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
+        $nodeTypes[$nodeType->getName()] = $nodeType;
+        if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
+            $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
+            $nodeTypeNames[$nodeType->getName()] = $nodeType;
+        } else {
+            $this->dispatch(self::EVENT_ERROR, sprintf('Node type "<i>%s</i>" does not exist', $nodeType));
+            return;
+        }
+        /** @var $nodeType NodeType */
+        foreach ($nodeTypes as $nodeTypeName => $nodeType) {
+            $childNodes = $nodeType->getAutoCreatedChildNodes();
+            if ($childNodes === []) {
+                continue;
+            }
+            foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
+                /** @var NodeInterface $childNodeBefore */
+                $childNodeBefore = null;
+                $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
+                $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
+                if (!$node instanceof NodeInterface) {
+                    continue;
+                }
+                foreach ($childNodes as $childNodeName => $childNodeType) {
+                    $childNode = $node->getNode($childNodeName);
+                    if ($childNode) {
+                        if ($childNodeBefore && $childNodeBefore->getIndex() >= $childNode->getIndex()) {
+                            $taskDescription = sprintf('Move node named "<i>%s</i>" after node named "<i>%s</i>" in "<i>%s</i>"', $childNodeName, $childNodeBefore->getName(), $node->getPath());
+                            $taskClosure = function () use ($childNode, $childNodeBefore) {
+                                $childNode->moveAfter($childNodeBefore);
+                            };
+                            $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+                        }
+                    } else {
+                        $this->dispatch(self::EVENT_NOTICE, sprintf('Missing child node named "<i>%s</i>" in "<i>%s</i>".', $childNodeName, $node->getPath()));
+                    }
+                    $childNodeBefore = $childNode;
+                }
+            }
+        }
+    }
+    /**
+     * Repair nodes whose shadow nodes are missing
+     *
+     * This check searches for nodes which have a corresponding node in one of the base workspaces,
+     * have different node paths, but don't have a corresponding shadow node with a "movedto" value.
+     *
+     * @param string $workspaceName Currently ignored
+     * @param boolean $dryRun (unused)
+     * @param NodeType $nodeType This argument will be ignored
+     * @return void
+     */
+    protected function repairShadowNodes($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
+    {
+        /** @var Workspace $workspace */
+        $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
+        if ($workspace->getBaseWorkspace() === null) {
+            $this->dispatch(self::EVENT_NOTICE, sprintf('Repairing base workspace "<i>%s</i>", therefore skipping check for shadow nodes.', $workspaceName));
+            return;
+        }
+        $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with missing shadow nodes ...');
+        $newShadowNodes = $this->findMissingShadowNodesInWorkspace($workspace, $nodeType);
+        if ($newShadowNodes === []) {
+            return;
+        }
+        $numberOfNewShadowNodes = count($newShadowNodes);
+        $taskDescription = sprintf('Add <i>%d</i> missing shadow node%s', $numberOfNewShadowNodes, $numberOfNewShadowNodes > 1 ? 's' : '');
+        $taskClosure = function () use ($newShadowNodes) {
+            /** @var NodeData $nodeData */
+            foreach ($newShadowNodes as list('nodeData' => $nodeData, 'shadowPath' => $shadowPath)) {
+                $nodeData->createShadow($shadowPath);
+            }
+            $this->persistenceManager->persistAll();
+        };
+        $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
+    }
+    /**
+     * Collects all nodes with missing shadow nodes
+     *
+     * @param Workspace $workspace
+     * @param NodeType $nodeType
+     * @return array in the form [['nodeData' => <nodeDataInstance>, 'shadowPath' => '<shadowPath>'], ...]
+     */
+    protected function findMissingShadowNodesInWorkspace(Workspace $workspace, NodeType $nodeType = null)
+    {
+        $workspaces = array_merge([$workspace], $workspace->getBaseWorkspaces());
+        $newShadowNodes = [];
+        foreach ($workspaces as $workspace) {
+            /** @var Workspace $workspace */
+            if ($workspace->getBaseWorkspace() === null) {
+                continue;
+            }
+            /** @var QueryBuilder $queryBuilder */
+            $queryBuilder = $this->entityManager->createQueryBuilder();
+            $queryBuilder->select('n')
+                ->from(NodeData::class, 'n')
+                ->where('n.workspace = :workspace');
+            $queryBuilder->setParameter('workspace', $workspace->getName());
+            if ($nodeType !== null) {
+                $queryBuilder->andWhere('n.nodeType = :nodeType');
+                $queryBuilder->setParameter('nodeType', $nodeType->getName());
+            }
+            /** @var NodeData $nodeData */
+            foreach ($queryBuilder->getQuery()->getResult() as $nodeData) {
+                $nodeDataSeenFromParentWorkspace = $this->nodeDataRepository->findOneByIdentifier($nodeData->getIdentifier(), $workspace->getBaseWorkspace(), $nodeData->getDimensionValues());
+                if ($nodeDataSeenFromParentWorkspace === null) {
+                    continue;
+                }
+                if ($nodeDataSeenFromParentWorkspace->getPath() === $nodeData->getPath()) {
+                    continue;
+                }
+                $nodeDataOnSamePath = $this->nodeDataRepository->findOneByPath($nodeData->getPath(), $workspace->getBaseWorkspace(), $nodeData->getDimensionValues(), null);
+                if ($nodeDataOnSamePath !== null) {
+                    continue;
+                }
+                $newShadowNodes[] = ['nodeData' => $nodeData, 'shadowPath' => $nodeDataSeenFromParentWorkspace->getPath()];
+            }
+        }
+        return $newShadowNodes;
+    }
+    /**
+     * Attaches a new event handler
+     *
+     * @param string $eventIdentifier one of the EVENT_* constants
+     * @param \Closure $callback a closure to be invoked when the corresponding event was triggered
+     * @return void
+     */
+    public function on(string $eventIdentifier, \Closure $callback): void
+    {
+        $this->eventCallbacks[$eventIdentifier][] = $callback;
+    }
+    /**
+     * Trigger a custom event
+     *
+     * @param string $eventIdentifier one of the EVENT_* constants
+     * @param array $eventPayload optional arguments to be passed to the handler closure
+     * @return void
+     */
+    protected function dispatch(string $eventIdentifier, ...$eventPayload): void
+    {
+        if (!isset($this->eventCallbacks[$eventIdentifier])) {
+            return;
+        }
+        /** @var \Closure $callback */
+        foreach ($this->eventCallbacks[$eventIdentifier] as $callback) {
+            call_user_func_array($callback, $eventPayload);
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/ContentStream/ContentStreamIdentifier.php
@@ -0,0 +1,58 @@
+<?php
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\ContentStream;
+use Neos\Cache\CacheAwareInterface;
+use Neos\Flow\Utility\Algorithms;
+use Neos\Flow\Annotations as Flow;
+/**
+ * The ContentStreamIdentifier is the identifier for a Content Stream, which is
+ * a central concept in the Event-Sourced CR introduced with Neos 5.0.
+ */
+final class ContentStreamIdentifier implements \JsonSerializable, CacheAwareInterface, \Stringable
+{
+    /**
+     * @var array<string,self>
+     */
+    private static array $instances = [];
+    private function __construct(
+        private string $value
+    ) {
+    }
+    private static function instance(string $value): self
+    {
+        return self::$instances[$value] ??= new self($value);
+    }
+    public static function fromString(string $value): self
+    {
+        return self::instance($value);
+    }
+    public static function create(): self
+    {
+        return self::instance(Algorithms::generateUUID());
+    }
+    public function jsonSerialize(): string
+    {
+        return $this->value;
+    }
+    public function getCacheEntryIdentifier(): string
+    {
+        return $this->value;
+    }
+    public function __toString(): string
+    {
+        return $this->value;
+    }
+    public function equals(ContentStreamIdentifier $other): bool
+    {
+        return $this === $other;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/ContentSubgraph/NodePath.php
@@ -0,0 +1,99 @@
+<?php
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\ContentSubgraph;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\NodeAggregate\NodeName;
+use Neos\Flow\Annotations as Flow;
+/**
+ * The node path is a list of NodeNames. It can be either absolute or relative.
+ *
+ * It describes the hierarchy path of a node to a root node in a subgraph.
+ *
+ * @Flow\Proxy(false)
+ * @api
+ */
+final class NodePath implements \JsonSerializable
+{
+    /**
+     * @var string
+     */
+    private $path;
+    private function __construct(string $path)
+    {
+        if ($path !== '/') {
+            $pathParts = explode('/', ltrim($path, '/'));
+            foreach ($pathParts as $pathPart) {
+                if (preg_match(NodeInterface::MATCH_PATTERN_NAME, $pathPart) !== 1) {
+                    throw new \InvalidArgumentException(sprintf('The path "%s" is no valid NodePath because it contains a segment "%s" that is no valid NodeName', $path, $pathPart), 1548157108);
+                }
+            }
+        }
+        $this->path = $path;
+    }
+    public static function fromString(string $path): self
+    {
+        return new static($path);
+    }
+    public static function fromPathSegments(array $pathSegments): self
+    {
+        if ($pathSegments === []) {
+            return new static('/');
+        }
+        return new static('/' . implode('/', $pathSegments));
+    }
+    public function isRoot(): bool
+    {
+        return $this->path === '/';
+    }
+    public function isAbsolute(): bool
+    {
+        return strpos($this->path, '/') === 0;
+    }
+    /**
+     * IMMUTABLE function to create a new NodePath by appending a path segment. Returns a NEW NodePath object
+     * @param NodeName $nodeName
+     * @return NodePath
+     */
+    public function appendPathSegment(NodeName $nodeName): self
+    {
+        return new static($this->path . '/' . $nodeName);
+    }
+    /**
+     * @return NodeName[]
+     */
+    public function getParts(): array
+    {
+        $pathParts = explode('/', ltrim($this->path, '/'));
+        return array_map(function (string $pathPart) {
+            return NodeName::fromString($pathPart);
+        }, $pathParts);
+    }
+    public function getDepth(): int
+    {
+        if (!$this->isAbsolute()) {
+            throw new \RuntimeException(sprintf('Depth of relative node path "%s" cannot be determined', $this->path), 1548162166);
+        }
+        return count($this->getParts());
+    }
+    public function equals(NodePath $other): bool
+    {
+        return (string) $this === (string) $other;
+    }
+    public function jsonSerialize(): string
+    {
+        return $this->path;
+    }
+    public function __toString()
+    {
+        return $this->path;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/NodeAggregate/NodeAggregateIdentifier.php
@@ -0,0 +1,64 @@
+<?php
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\NodeAggregate;
+use Neos\Cache\CacheAwareInterface;
+use Neos\ContentRepository\Utility;
+use Neos\Flow\Utility\Algorithms;
+use Neos\Flow\Annotations as Flow;
+/**
+ * The NodeAggregateIdentifier supersedes the Node Identifier from Neos <= 4.x.
+ */
+final class NodeAggregateIdentifier implements \JsonSerializable, CacheAwareInterface, \Stringable
+{
+    /**
+     * A preg pattern to match against node aggregate identifiers
+     */
+    const PATTERN = '/^([a-z0-9\-]{1,255})$/';
+    private function __construct(
+        private string $value
+    ) {
+        if (!preg_match(self::PATTERN, $value)) {
+            throw new \InvalidArgumentException('Invalid node aggregate identifier "' . $value . '" (a node aggregate identifier must only contain lowercase characters, numbers and the "-" sign).', 1505840197862);
+        }
+    }
+    public static function create(): self
+    {
+        return new self(Algorithms::generateUUID());
+    }
+    public static function fromString(string $value): self
+    {
+        return new self($value);
+    }
+    /**
+     * @throws \Exception
+     */
+    public static function forAutoCreatedChildNode(NodeName $childNodeName, NodeAggregateIdentifier $nodeAggregateIdentifier): self
+    {
+        return new self(Utility::buildAutoCreatedChildNodeIdentifier((string)$childNodeName, (string)$nodeAggregateIdentifier));
+    }
+    public function equals(NodeAggregateIdentifier $other): bool
+    {
+        return $this->value === (string)$other;
+    }
+    public function jsonSerialize(): string
+    {
+        return $this->value;
+    }
+    public function __toString(): string
+    {
+        return $this->value;
+    }
+    public function getCacheEntryIdentifier(): string
+    {
+        return $this->value;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/NodeAggregate/NodeName.php
@@ -0,0 +1,47 @@
+<?php
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\NodeAggregate;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\Flow\Annotations as Flow;
+/**
+ * The Node name is the "path part" of the node; i.e. when accessing the node "/foo" via path,
+ * the node name is "foo".
+ *
+ * Semantically it describes the hierarchical relation of a node to its parent, e.g. "main" denotes the main child node.
+ * @api
+ */
+final class NodeName implements \JsonSerializable, \Stringable
+{
+    private function __construct(
+        private string $value
+    ) {
+        if (preg_match(NodeInterface::MATCH_PATTERN_NAME, $value) !== 1) {
+            throw new \InvalidArgumentException(
+                'Invalid node name "' . $value
+                    . '" (a node name must only contain lowercase characters, numbers and the "-" sign).',
+                1364290748
+            );
+        }
+    }
+    public static function fromString(string $value): self
+    {
+        return new self(strtolower($value));
+    }
+    public function jsonSerialize(): string
+    {
+        return $this->value;
+    }
+    public function __toString(): string
+    {
+        return $this->value;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/NodeType/NodeTypeName.php
@@ -0,0 +1,58 @@
+<?php
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\NodeType;
+use Neos\Flow\Annotations as Flow;
+/**
+ * Name of a Node Type; e.g. "Neos.Neos:Content"
+ *
+ * @Flow\Proxy(false)
+ * @api
+ */
+final class NodeTypeName implements \JsonSerializable, \Stringable
+{
+    const ROOT_NODE_TYPE_NAME = 'Neos.ContentRepository:Root';
+    /**
+     * @var array<string,self>
+     */
+    private static array $instances = [];
+    private function __construct(
+        private string $value
+    ) {
+        if ($value === '') {
+            throw new \InvalidArgumentException('Node type name must not be empty.', 1505835958);
+        }
+    }
+    private static function instance(string $value): self
+    {
+        return self::$instances[$value] ??= new self($value);
+    }
+    public static function fromString(string $value): self
+    {
+        return self::instance($value);
+    }
+    public function getValue(): string
+    {
+        return $this->value;
+    }
+    public function equals(self $other): bool
+    {
+        return $this === $other;
+    }
+    public function jsonSerialize(): string
+    {
+        return $this->value;
+    }
+    public function __toString(): string
+    {
+        return $this->value;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/Projection/Content/PropertyCollectionInterface.php
@@ -0,0 +1,19 @@
+<?php
+declare(strict_types=1);
+namespace Neos\ContentRepository\Domain\Projection\Content;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * @extends \ArrayAccess<string,mixed>
+ * @extends \IteratorAggregate<string,mixed>
+ */
+interface PropertyCollectionInterface extends \ArrayAccess, \IteratorAggregate
+{
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/Service/Context.php
@@ -0,0 +1,446 @@
+<?php
+namespace Neos\ContentRepository\Domain\Service;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\ContentRepository\Domain\Factory\NodeFactory;
+use Neos\ContentRepository\Domain\Model\NodeData;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\Model\Workspace;
+use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
+use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
+use Neos\ContentRepository\Domain\Service\Cache\FirstLevelNodeCache;
+use Neos\Flow\Log\Utility\LogEnvironment;
+use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
+use Psr\Log\LoggerInterface;
+/**
+ * Context
+ *
+ * @api
+ */
+class Context
+{
+    /**
+     * @Flow\Inject
+     * @var WorkspaceRepository
+     */
+    protected $workspaceRepository;
+    /**
+     * @Flow\Inject
+     * @var NodeDataRepository
+     */
+    protected $nodeDataRepository;
+    /**
+     * @Flow\Inject
+     * @var NodeFactory
+     */
+    protected $nodeFactory;
+    /**
+     * @Flow\Inject
+     * @var ContextFactoryInterface
+     */
+    protected $contextFactory;
+    /**
+     * @Flow\Inject
+     * @var LoggerInterface
+     */
+    protected $systemLogger;
+    /**
+     * @var Workspace
+     */
+    protected $workspace;
+    /**
+     * @var string
+     */
+    protected $workspaceName;
+    /**
+     * @var \DateTime
+     */
+    protected $currentDateTime;
+    /**
+     * If true, invisible content elements will be shown.
+     *
+     * @var boolean
+     */
+    protected $invisibleContentShown = false;
+    /**
+     * If true, removed content elements will be shown, even though they are removed.
+     *
+     * @var boolean
+     */
+    protected $removedContentShown = false;
+    /**
+     * If true, even content elements will be shown which are not accessible by the currently logged in account.
+     *
+     * @var boolean
+     */
+    protected $inaccessibleContentShown = false;
+    /**
+     * @var array
+     */
+    protected $dimensions = [];
+    /**
+     * @var array
+     */
+    protected $targetDimensions = [];
+    /**
+     * @Flow\IgnoreValidation
+     * @var FirstLevelNodeCache
+     */
+    protected $firstLevelNodeCache;
+    /**
+     * Creates a new Context object.
+     *
+     * NOTE: This is for internal use only, you should use the ContextFactory for creating Context instances.
+     *
+     * @param string $workspaceName Name of the current workspace
+     * @param \DateTimeInterface $currentDateTime The current date and time
+     * @param array $dimensions Array of dimensions with array of ordered values
+     * @param array $targetDimensions Array of dimensions used when creating / modifying content
+     * @param boolean $invisibleContentShown If invisible content should be returned in query results
+     * @param boolean $removedContentShown If removed content should be returned in query results
+     * @param boolean $inaccessibleContentShown If inaccessible content should be returned in query results
+     * @see ContextFactoryInterface
+     */
+    public function __construct($workspaceName, \DateTimeInterface $currentDateTime, array $dimensions, array $targetDimensions, $invisibleContentShown, $removedContentShown, $inaccessibleContentShown)
+    {
+        $this->workspaceName = $workspaceName;
+        $this->currentDateTime = $currentDateTime;
+        $this->dimensions = $dimensions;
+        $this->invisibleContentShown = $invisibleContentShown;
+        $this->removedContentShown = $removedContentShown;
+        $this->inaccessibleContentShown = $inaccessibleContentShown;
+        $this->targetDimensions = $targetDimensions;
+        $this->firstLevelNodeCache = new FirstLevelNodeCache();
+    }
+    /**
+     * Returns the current workspace.
+     *
+     * @param boolean $createWorkspaceIfNecessary DEPRECATED: If enabled, creates a workspace with the configured name if it doesn't exist already. This option is DEPRECATED, create workspace explicitly instead.
+     * @return Workspace The workspace or NULL
+     * @api
+     * @throws IllegalObjectTypeException
+     */
+    public function getWorkspace($createWorkspaceIfNecessary = true)
+    {
+        if ($this->workspace !== null) {
+            return $this->workspace;
+        }
+        $this->workspace = $this->workspaceRepository->findByIdentifier($this->workspaceName);
+        if ($this->workspace === null && $createWorkspaceIfNecessary) {
+            $liveWorkspace = $this->workspaceRepository->findByIdentifier('live');
+            $this->workspace = new Workspace($this->workspaceName, $liveWorkspace);
+            $this->workspaceRepository->add($this->workspace);
+            $this->systemLogger->notice(sprintf('Notice: %s::getWorkspace() implicitly created the new workspace "%s". This behaviour is discouraged and will be removed in future versions. Make sure to create workspaces explicitly by adding a new workspace to the Workspace Repository.', __CLASS__, $this->workspaceName), LogEnvironment::fromMethodName(__METHOD__));
+        }
+        if ($this->workspace !== null) {
+            $this->validateWorkspace($this->workspace);
+        }
+        return $this->workspace;
+    }
+    /**
+     * This method is called in order to check if a workspace is accessible.
+     *
+     * At the time of this writing, it is not possible in Flow to restrict access to Workspace through Entity Privileges
+     * because Workspaces are used at a very early stage during routing where the security context is not yet initialized.
+     * As a workaround, we use a Method Privilege which protects this validateWorkspace() method and thus prevents
+     * unauthorized access to a workspace when calling this context's getWorkspace() method.
+     *
+     * Since some privilege definitions check the "owner" property of a Workspace, we need a real Workspace object and
+     * not just the name - hence this method.
+     *
+     * @param Workspace $workspace The workspace to check
+     * @return void
+     */
+    public function validateWorkspace(Workspace $workspace)
+    {
+    }
+    /**
+     * Returns the name of the workspace.
+     *
+     * @return string
+     * @api
+     */
+    public function getWorkspaceName()
+    {
+        return $this->workspaceName;
+    }
+    /**
+     * Returns the current date and time in form of a \DateTime
+     * object.
+     *
+     * If you use this method for getting the current date and time
+     * everywhere in your code, it will be possible to simulate a certain
+     * time in unit tests or in the actual application (for realizing previews etc).
+     *
+     * @return \DateTime The current date and time - or a simulated version of it
+     * @api
+     */
+    public function getCurrentDateTime()
+    {
+        return $this->currentDateTime;
+    }
+    /**
+     * Convenience method returns the root node for
+     * this context workspace.
+     *
+     * @return NodeInterface
+     * @api
+     */
+    public function getRootNode()
+    {
+        return $this->getNode('/');
+    }
+    /**
+     * Returns a node specified by the given absolute path.
+     *
+     * @param string $path Absolute path specifying the node
+     * @return NodeInterface The specified node or NULL if no such node exists
+     * @throws \InvalidArgumentException
+     * @api
+     */
+    public function getNode($path)
+    {
+        if (!is_string($path) || $path[0] !== '/') {
+            throw new \InvalidArgumentException('Only absolute paths are allowed for Context::getNode()', 1284975105);
+        }
+        $path = strtolower($path);
+        $workspaceRootNode = $this->getWorkspace()->getRootNodeData();
+        $rootNode = $this->nodeFactory->createFromNodeData($workspaceRootNode, $this);
+        if ($path !== '/') {
+            $node = $this->firstLevelNodeCache->getByPath($path);
+            if ($node === false) {
+                $node = $rootNode->getNode(substr($path, 1));
+                $this->firstLevelNodeCache->setByPath($path, $node);
+            }
+        } else {
+            $node = $rootNode;
+        }
+        return $node;
+    }
+    /**
+     * Get a node by identifier and this context
+     *
+     * @param string $identifier The identifier of a node
+     * @return ?NodeInterface The node with the given identifier or NULL if no such node exists
+     */
+    public function getNodeByIdentifier($identifier)
+    {
+        $node = $this->firstLevelNodeCache->getByIdentifier($identifier);
+        if ($node !== false) {
+            return $node;
+        }
+        $nodeData = $this->nodeDataRepository->findOneByIdentifier($identifier, $this->getWorkspace(), $this->dimensions, $this->removedContentShown);
+        if ($nodeData !== null) {
+            $node = $this->nodeFactory->createFromNodeData($nodeData, $this);
+        } else {
+            $node = null;
+        }
+        $this->firstLevelNodeCache->setByIdentifier($identifier, $node);
+        return $node;
+    }
+    /**
+     * Get all node variants for the given identifier
+     *
+     * A variant of a node can have different dimension values and path (for non-aggregate nodes).
+     * The resulting node instances might belong to a different context.
+     *
+     * @param string $identifier The identifier of a node
+     * @return array<\Neos\ContentRepository\Domain\Model\NodeInterface>
+     */
+    public function getNodeVariantsByIdentifier($identifier)
+    {
+        $nodeVariants = [];
+        $nodeDataElements = $this->nodeDataRepository->findByIdentifierWithoutReduce($identifier, $this->getWorkspace());
+        /** @var NodeData $nodeData */
+        foreach ($nodeDataElements as $nodeData) {
+            $contextProperties = $this->getProperties();
+            $contextProperties['dimensions'] = $nodeData->getDimensionValues();
+            unset($contextProperties['targetDimensions']);
+            $adjustedContext = $this->contextFactory->create($contextProperties);
+            $nodeVariant = $this->nodeFactory->createFromNodeData($nodeData, $adjustedContext);
+            $nodeVariants[] = $nodeVariant;
+        }
+        return $nodeVariants;
+    }
+    /**
+     * Finds all nodes lying on the path specified by (and including) the given
+     * starting point and end point.
+     *
+     * @param mixed $startingPoint Either an absolute path or an actual node specifying the starting point, for example /sites/mysitecom
+     * @param mixed $endPoint Either an absolute path or an actual node specifying the end point, for example /sites/mysitecom/homepage/subpage
+     * @return array<\Neos\ContentRepository\Domain\Model\NodeInterface> The nodes found between and including the given paths or an empty array of none were found
+     * @api
+     */
+    public function getNodesOnPath($startingPoint, $endPoint)
+    {
+        $startingPointPath = ($startingPoint instanceof NodeInterface) ? $startingPoint->getPath() : $startingPoint;
+        $endPointPath = ($endPoint instanceof NodeInterface) ? $endPoint->getPath() : $endPoint;
+        $nodeDataElements = $this->nodeDataRepository->findOnPath($startingPointPath, $endPointPath, $this->getWorkspace(), $this->getDimensions(), $this->isRemovedContentShown());
+        $nodes = [];
+        foreach ($nodeDataElements as $nodeData) {
+            $node = $this->nodeFactory->createFromNodeData($nodeData, $this);
+            if ($node !== null) {
+                $nodes[] = $node;
+                $this->firstLevelNodeCache->setByPath($node->getPath(), $node);
+            }
+        }
+        return $nodes;
+    }
+    /**
+     * Adopts a node from a (possibly) different context to this context
+     *
+     * Checks if a node variant matching the exact dimensions already exists for this context and
+     * return it if found. Otherwise a new node variant for this context is created.
+     *
+     * In case the node already exists in the context but does not match the target dimensions a
+     * new, more specific node is created and returned.
+     *
+     * @param NodeInterface $node The node with a different context. If the context of the given node is the same as this context the operation will have no effect.
+     * @param boolean $recursive If true also adopt all descendant nodes which are non-aggregate
+     * @return NodeInterface A new or existing node that matches this context
+     */
+    public function adoptNode(NodeInterface $node, $recursive = false)
+    {
+        if ($node->getContext() === $this && $node->dimensionsAreMatchingTargetDimensionValues()) {
+            return $node;
+        }
+        $this->emitBeforeAdoptNode($node, $this, $recursive);
+        $existingNode = $this->getNodeByIdentifier($node->getIdentifier());
+        if ($existingNode !== null) {
+            if ($existingNode->dimensionsAreMatchingTargetDimensionValues()) {
+                $adoptedNode = $existingNode;
+            } else {
+                $adoptedNode = $existingNode->createVariantForContext($this);
+            }
+        } else {
+            $adoptedNode = $node->createVariantForContext($this);
+        }
+        $this->firstLevelNodeCache->setByIdentifier($adoptedNode->getIdentifier(), $adoptedNode);
+        if ($recursive) {
+            $childNodes = $node->getChildNodes();
+            /** @var NodeInterface $childNode */
+            foreach ($childNodes as $childNode) {
+                if (!$childNode->getNodeType()->isAggregate()) {
+                    $this->adoptNode($childNode, true);
+                }
+            }
+        }
+        $this->emitAfterAdoptNode($node, $this, $recursive);
+        return $adoptedNode;
+    }
+    /**
+     * @Flow\Signal
+     * @param NodeInterface $node
+     * @param Context $context
+     * @param $recursive
+     */
+    protected function emitBeforeAdoptNode(NodeInterface $node, Context $context, $recursive)
+    {
+    }
+    /**
+     * @Flow\Signal
+     * @param NodeInterface $node
+     * @param Context $context
+     * @param $recursive
+     */
+    protected function emitAfterAdoptNode(NodeInterface $node, Context $context, $recursive)
+    {
+    }
+    /**
+     * Tells if nodes which are usually invisible should be accessible through the Node API and queries
+     *
+     * @return boolean
+     * @see NodeFactory->filterNodeByContext()
+     * @api
+     */
+    public function isInvisibleContentShown()
+    {
+        return $this->invisibleContentShown;
+    }
+    /**
+     * Tells if nodes which have their "removed" flag set should be accessible through
+     * the Node API and queries
+     *
+     * @return boolean
+     * @see Node->filterNodeByContext()
+     * @api
+     */
+    public function isRemovedContentShown()
+    {
+        return $this->removedContentShown;
+    }
+    /**
+     * Tells if nodes which have access restrictions should be accessible through
+     * the Node API and queries even without the necessary roles / rights
+     *
+     * @return boolean
+     * @api
+     */
+    public function isInaccessibleContentShown()
+    {
+        return $this->inaccessibleContentShown;
+    }
+    /**
+     * An indexed array of dimensions with ordered list of values for matching nodes by content dimensions
+     *
+     * @return array
+     */
+    public function getDimensions()
+    {
+        return $this->dimensions;
+    }
+    /**
+     * An indexed array of dimensions with a set of values that should be applied when updating or creating
+     *
+     * @return array
+     */
+    public function getTargetDimensions()
+    {
+        return $this->targetDimensions;
+    }
+    /**
+     * An indexed array of dimensions with a set of values that should be applied when updating or creating
+     *
+     * @return array
+     */
+    public function getTargetDimensionValues()
+    {
+        return array_map(function ($value) {
+            return $value === null ? [] : [ $value ];
+        }, $this->getTargetDimensions());
+    }
+    /**
+     * Returns the properties of this context.
+     *
+     * @return array
+     */
+    public function getProperties()
+    {
+        return [
+            'workspaceName' => $this->workspaceName,
+            'currentDateTime' => $this->currentDateTime,
+            'dimensions' => $this->dimensions,
+            'targetDimensions' => $this->targetDimensions,
+            'invisibleContentShown' => $this->invisibleContentShown,
+            'removedContentShown' => $this->removedContentShown,
+            'inaccessibleContentShown' => $this->inaccessibleContentShown
+        ];
+    }
+    /**
+     * Not public API!
+     *
+     * @return FirstLevelNodeCache
+     */
+    public function getFirstLevelNodeCache()
+    {
+        return $this->firstLevelNodeCache;
+    }
+}

--- a//dev/null
+++ b/Neos.ContentRepository/Classes/Domain/Service/ImportExport/NodeExportService.php
@@ -0,0 +1,389 @@
+<?php
+namespace Neos\ContentRepository\Domain\Service\ImportExport;
+/*
+ * This file is part of the Neos.ContentRepository package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Doctrine\ORM\EntityManagerInterface;
+use Doctrine\Persistence\Proxy as DoctrineProxy;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Log\ThrowableStorageInterface;
+use Neos\Flow\Log\Utility\LogEnvironment;
+use Neos\Flow\ObjectManagement\ObjectManagerInterface;
+use Neos\Flow\Persistence\PersistenceManagerInterface;
+use Neos\Flow\Property\PropertyMapper;
+use Neos\Flow\Security\Context;
+use Neos\ContentRepository\Domain\Model\NodeData;
+use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
+use Neos\ContentRepository\Domain\Service\NodeTypeManager;
+use Neos\ContentRepository\Exception\ExportException;
+use Psr\Log\LoggerInterface;
+/**
+ * Service for exporting content repository nodes as an XML structure
+ *
+ * Internally, uses associative arrays instead of Domain Models for performance reasons, so "nodeData" in this
+ * class is always an associative array.
+ *
+ * @Flow\Scope("singleton")
+ */
+class NodeExportService
+{
+    /**
+     * @var string
+     */
+    const SUPPORTED_FORMAT_VERSION = '2.0';
+    /**
+     * @var LoggerInterface
+     */
+    private $logger;
+    /**
+     * @var ThrowableStorageInterface
+     */
+    private $throwableStorage;
+    /**
+     * @Flow\Inject
+     * @var ObjectManagerInterface
+     */
+    protected $objectManager;
+    /**
+     * @Flow\Inject
+     * @var PersistenceManagerInterface
+     */
+    protected $persistenceManager;
+    /**
+     * @Flow\Inject
+     * @var PropertyMapper
+     */
+    protected $propertyMapper;
+    /**
+     * Doctrine's Entity Manager.
+     *
+     * @Flow\Inject
+     * @var EntityManagerInterface
+     */
+    protected $entityManager;
+    /**
+     * @Flow\Inject
+     * @var NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * @Flow\Inject
+     * @var NodeDataRepository
+     */
+    protected $nodeDataRepository;
+    /**
+     * @Flow\Inject
+     * @var Context
+     */
+    protected $securityContext;
+    /**
+     * @var ImportExportPropertyMappingConfiguration
+     */
+    protected $propertyMappingConfiguration;
+    /**
+     * @var \XMLWriter
+     */
+    protected $xmlWriter;
+    /**
+     * @var array<\Exception> a list of exceptions which happened during export
+     */
+    protected $exceptionsDuringExport;
+    /**
+     * @var array Node paths that have been exported, this is used for consistency checks of broken node rootlines
+     */
+    protected $exportedNodePaths;
+    /**
+     * @param LoggerInterface $logger
+     */
+    public function injectLogger(LoggerInterface $logger)
+    {
+        $this->logger = $logger;
+    }
+    /**
+     * @param ThrowableStorageInterface $throwableStorage
+     */
+    public function injectThrowableStorage(ThrowableStorageInterface $throwableStorage)
+    {
+        $this->throwableStorage = $throwableStorage;
+    }
+    /**
+     * Exports the node data of all nodes in the given sub-tree
+     * by writing them to the given XMLWriter.
+     *
+     * @param string $startingPointNodePath path to the root node of the sub-tree to export. The specified node will not be included, only its sub nodes.
+     * @param string $workspaceName
+     * @param \XMLWriter $xmlWriter
+     * @param boolean $tidy
+     * @param boolean $endDocument
+     * @param string $resourceSavePath
+     * @param string $nodeTypeFilter Filter the node type of the nodes, allows complex expressions (e.g. "Neos.Neos:Page", "!Neos.Neos:Page,Neos.Neos:Text")
+     * @return \XMLWriter
+     */
+    public function export($startingPointNodePath = '/', $workspaceName = 'live', \XMLWriter $xmlWriter = null, $tidy = true, $endDocument = true, $resourceSavePath = null, $nodeTypeFilter = null)
+    {
+        $this->propertyMappingConfiguration = new ImportExportPropertyMappingConfiguration($resourceSavePath);
+        $this->exceptionsDuringExport = [];
+        $this->exportedNodePaths = [];
+        if ($startingPointNodePath !== '/') {
+            $startingPointParentPath = substr($startingPointNodePath, 0, strrpos($startingPointNodePath, '/'));
+            $this->exportedNodePaths[$startingPointParentPath] = true;
+        }
+        $this->xmlWriter = $xmlWriter;
+        if ($this->xmlWriter === null) {
+            $this->xmlWriter = new \XMLWriter();
+            $this->xmlWriter->openMemory();
+            $this->xmlWriter->setIndent($tidy);
+            $this->xmlWriter->startDocument('1.0', 'UTF-8');
+        }
+        $this->securityContext->withoutAuthorizationChecks(function () use ($startingPointNodePath, $workspaceName, $nodeTypeFilter) {
+            $nodeDataList = $this->findNodeDataListToExport($startingPointNodePath, $workspaceName, $nodeTypeFilter);
+            $this->exportNodeDataList($nodeDataList);
+        });
+        if ($endDocument) {
+            $this->xmlWriter->endDocument();
+        }
+        $this->handleExceptionsDuringExport();
+        return $this->xmlWriter;
+    }
+    /**
+     * Find all nodes of the specified workspace lying below the path specified by
+     * (and including) the given starting point.
+     *
+     * @param string $pathStartingPoint Absolute path specifying the starting point
+     * @param string $workspace The containing workspace
+     * @param string $nodeTypeFilter
+     * @return array an array of node-data in array format.
+     */
+    protected function findNodeDataListToExport($pathStartingPoint, $workspace = 'live', $nodeTypeFilter = null)
+    {
+        /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
+        $queryBuilder = $this->entityManager->createQueryBuilder();
+        $queryBuilder->select(
+            'n.path AS path,'
+            . ' n.identifier AS identifier,'
+            . ' n.index AS sortingIndex,'
+            . ' n.properties AS properties, '
+            . ' n.nodeType AS nodeType,'
+            . ' n.removed AS removed,'
+            . ' n.hidden,'
+            . ' n.hiddenBeforeDateTime AS hiddenBeforeDateTime,'
+            . ' n.hiddenAfterDateTime AS hiddenAfterDateTime,'
+            . ' n.creationDateTime AS creationDateTime,'
+            . ' n.lastModificationDateTime AS lastModificationDateTime,'
+            . ' n.lastPublicationDateTime AS lastPublicationDateTime,'
+            . ' n.hiddenInIndex AS hiddenInIndex,'
+            . ' n.accessRoles AS accessRoles,'
+            . ' n.version AS version,'
+            . ' n.parentPath AS parentPath,'
+            . ' n.pathHash AS pathHash,'
+            . ' n.dimensionsHash AS dimensionsHash,'
+            . ' n.parentPathHash AS parentPathHash,'
+            . ' n.dimensionValues AS dimensionValues,'
+            . ' w.name AS workspace'
+        )->distinct()
+            ->from(NodeData::class, 'n')
+            ->innerJoin('n.workspace', 'w', 'WITH', 'n.workspace=w.name')
+            ->where('n.workspace = :workspace')
+            ->setParameter('workspace', $workspace)
+            ->andWhere('n.path = :pathPrefix OR n.path LIKE :pathPrefixMatch')
+            ->setParameter('pathPrefix', $pathStartingPoint)
+            ->setParameter('pathPrefixMatch', ($pathStartingPoint === '/' ? '%' : $pathStartingPoint . '/%'))
+            ->orderBy('n.identifier', 'ASC')
+            ->orderBy('n.path', 'ASC');
+        if ($nodeTypeFilter) {
+            $this->nodeDataRepository->addNodeTypeFilterConstraintsToQueryBuilder($queryBuilder, $nodeTypeFilter);
+        }
+        $nodeDataList = $queryBuilder->getQuery()->getResult();
+        usort(
+            $nodeDataList,
+            function ($node1, $node2) {
+                return strcmp(
+                    str_replace("/", "!", $node1['path']),
+                    str_replace("/", "!", $node2['path'])
+                );
+            }
+        );
+        return $nodeDataList;
+    }
+    /**
+     * Exports the given Nodes into the XML structure, contained in <nodes> </nodes> tags.
+     *
+     * @param array $nodeDataList The nodes to export
+     * @return void The result is written directly into $this->xmlWriter
+     */
+    protected function exportNodeDataList(array &$nodeDataList)
+    {
+        $this->xmlWriter->startElement('nodes');
+        $this->xmlWriter->writeAttribute('formatVersion', self::SUPPORTED_FORMAT_VERSION);
+        $nodesStack = [];
+        foreach ($nodeDataList as $nodeData) {
+            $this->exportNodeData($nodeData, $nodesStack);
+        }
+        while (array_pop($nodesStack)) {
+            $this->xmlWriter->endElement();
+        }
+        $this->xmlWriter->endElement();
+    }
+    /**
+     * Exports a single Node into the XML structure
+     *
+     * @param array $nodeData The node data as an array
+     * @param array $nodesStack The stack keeping track of open tags, as passed by exportNodeDataList()
+     * @return void The result is written directly into $this->xmlWriter
+     */
+    protected function exportNodeData(array &$nodeData, array &$nodesStack)
+    {
+        if ($nodeData['path'] !== '/' && !isset($this->exportedNodePaths[$nodeData['parentPath']])) {
+            $this->xmlWriter->writeComment(sprintf('Skipped node with identifier "%s" and path "%s" because of a missing parent path. This is caused by a broken rootline and needs to be fixed with the "node:repair" command.', $nodeData['identifier'], $nodeData['path']));
+            return;
+        }
+        $this->exportedNodePaths[$nodeData['path']] = true;
+        if ($nodeData['parentPath'] === '/') {
+            $nodeName = substr($nodeData['path'], 1);
+        } else {
+            $nodeName = substr($nodeData['path'], strlen($nodeData['parentPath']) + 1);
+        }
+        $parentNode = end($nodesStack);
+        if (!$parentNode || $parentNode['path'] !== $nodeData['path'] || $parentNode['identifier'] !== $nodeData['identifier']) {
+            while ($parentNode && $nodeData['parentPath'] !== $parentNode['path']) {
+                $this->xmlWriter->endElement();
+                array_pop($nodesStack);
+                $parentNode = end($nodesStack);
+            }
+            $nodesStack[] = $nodeData;
+            $this->xmlWriter->startElement('node');
+            $this->xmlWriter->writeAttribute('identifier', $nodeData['identifier']);
+            $this->xmlWriter->writeAttribute('nodeName', $nodeName);
+        }
+        $this->xmlWriter->startElement('variant');
+        if ($nodeData['sortingIndex'] !== null) {
+            $this->xmlWriter->writeAttribute('sortingIndex', $nodeData['sortingIndex']);
+        }
+        foreach (
+            [
+                'workspace',
+                'nodeType',
+                'version',
+                'removed',
+                'hidden',
+                'hiddenInIndex'
+            ] as $propertyName) {
+            $this->xmlWriter->writeAttribute($propertyName, $nodeData[$propertyName]);
+        }
+        $this->xmlWriter->startElement('dimensions');
+        foreach ($nodeData['dimensionValues'] as $dimensionKey => $dimensionValues) {
+            foreach ($dimensionValues as $dimensionValue) {
+                $this->xmlWriter->writeElement($dimensionKey, $dimensionValue);
+            }
+        }
+        $this->xmlWriter->endElement();
+        foreach (
+            [
+                'accessRoles',
+                'hiddenBeforeDateTime',
+                'hiddenAfterDateTime',
+                'creationDateTime',
+                'lastModificationDateTime',
+                'lastPublicationDateTime',
+                'contentObjectProxy'
+            ] as $propertyName) {
+            $this->writeConvertedElement($nodeData, $propertyName);
+        }
+        $this->xmlWriter->startElement('properties');
+        if ($this->nodeTypeManager->hasNodeType($nodeData['nodeType'])) {
+            $nodeType = $this->nodeTypeManager->getNodeType($nodeData['nodeType']);
+            foreach ($nodeData['properties'] as $propertyName => $propertyValue) {
+                if ($nodeType->hasConfiguration('properties.' . $propertyName)) {
+                    $declaredPropertyType = $nodeType->getPropertyType($propertyName);
+                    $this->writeConvertedElement($nodeData['properties'], $propertyName, null, $declaredPropertyType);
+                }
+            }
+        } else {
+            foreach ($nodeData['properties'] as $propertyName => $propertyValue) {
+                $this->writeConvertedElement($nodeData['properties'], $propertyName);
+            }
+        }
+        $this->xmlWriter->endElement(); // "properties"
+        $this->xmlWriter->endElement(); // "variant"
+    }
+    /**
+     * Writes out a single property into the XML structure.
+     *
+     * @param array $data The data as an array, the given property name is looked up there
+     * @param string $propertyName The name of the property
+     * @param string $elementName an optional name to use, defaults to $propertyName
+     * @return void
+     */
+    protected function writeConvertedElement(array &$data, $propertyName, $elementName = null, $declaredPropertyType = null)
+    {
+        if (array_key_exists($propertyName, $data) && $data[$propertyName] !== null) {
+            $propertyValue = $data[$propertyName];
+            $this->xmlWriter->startElement($elementName ?: $propertyName);
+            if (!empty($propertyValue)) {
+                switch ($declaredPropertyType) {
+                    case null:
+                    case 'reference':
+                    case 'references':
+                        break;
+                    default:
+                        $propertyValue = $this->propertyMapper->convert($propertyValue, $declaredPropertyType);
+                        break;
+                }
+            }
+            $this->xmlWriter->writeAttribute('__type', gettype($propertyValue));
+            try {
+                if (is_object($propertyValue) && !$propertyValue instanceof \DateTimeInterface) {
+                    $objectIdentifier = $this->persistenceManager->getIdentifierByObject($propertyValue);
+                    if ($objectIdentifier !== null) {
+                        $this->xmlWriter->writeAttribute('__identifier', $objectIdentifier);
+                    }
+                    if ($propertyValue instanceof DoctrineProxy) {
+                        $className = get_parent_class($propertyValue);
+                    } else {
+                        $className = get_class($propertyValue);
+                    }
+                    $this->xmlWriter->writeAttribute('__classname', $className);
+                    $this->xmlWriter->writeAttribute('__encoding', 'json');
+                    $converted = json_encode($this->propertyMapper->convert($propertyValue, 'array', $this->propertyMappingConfiguration));
+                    $this->xmlWriter->text($converted);
+                } elseif (is_array($propertyValue)) {
+                    foreach ($propertyValue as $key => $element) {
+                        $this->writeConvertedElement($propertyValue, $key, 'entry' . $key);
+                    }
+                } else {
+                    if ($propertyValue instanceof \DateTimeInterface) {
+                        $this->xmlWriter->writeAttribute('__classname', 'DateTime');
+                    }
+                    $this->xmlWriter->text($this->propertyMapper->convert($propertyValue, 'string', $this->propertyMappingConfiguration));
+                }
+            } catch (\Exception $exception) {
+                $this->xmlWriter->writeComment(sprintf('Could not convert property "%s" to string.', $propertyName));
+                $this->xmlWriter->writeComment($exception->getMessage());
+                $logMessage = $this->throwableStorage->logThrowable($exception);
+                $this->logger->error($logMessage, LogEnvironment::fromMethodName(__METHOD__));
+                $this->exceptionsDuringExport[] = $exception;
+            }
+            $this->xmlWriter->endElement();
+        }
+    }
+    /**
+     * If $this->exceptionsDuringImport is non-empty, build up a new composite exception which contains the individual messages and
+     * re-throw that one.
+     */
+    protected function handleExceptionsDuringExport()
+    {
+        if (count($this->exceptionsDuringExport) > 0) {
+            $exceptionMessages = '';
+            foreach ($this->exceptionsDuringExport as $i => $exception) {
+                $exceptionMessages .= "\n" . $i . ': ' . get_class($exception) . "\n" . $exception->getMessage() . "\n";
+            }
+            throw new ExportException(sprintf('%s exceptions occurred during export. Please see the log for the full exceptions (including stack traces). The exception messages follow below: %s', count($this->exceptionsDuringExport), $exceptionMessages), 1409057360);
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion.Afx/Classes/Service/AfxService.php
@@ -0,0 +1,332 @@
+<?php
+namespace Neos\Fusion\Afx\Service;
+/*
+ * This file is part of the Neos.Fusion.Afx package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Afx\Parser\Parser as AfxParser;
+use Neos\Fusion\Afx\Exception\AfxException;
+/**
+ * Class AfxService
+ *
+ * @Flow\Scope("singleton")
+ */
+class AfxService
+{
+    const INDENTATION = '    ';
+    const SHORTHAND_META_PATHS = ['@if', '@process'];
+    /**
+     * @var string $afxCode the AFX code that is converted
+     * @var string $indentation Indentation to start with
+     * @return string
+     */
+    public static function convertAfxToFusion($afxCode, $indentation = '')
+    {
+        $parser = new AfxParser(trim($afxCode));
+        $ast = $parser->parse();
+        $fusion = self::astNodeListToFusion($ast, $indentation);
+        return $fusion;
+    }
+    /**
+     * @param array $astNode
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astToFusion($ast, $indentation = '')
+    {
+        switch ($ast['type']) {
+            case 'expression':
+                return self::astExpressionToFusion($ast['payload'], $indentation);
+                break;
+            case 'string':
+                return self::astStringToFusion($ast['payload'], $indentation);
+                break;
+            case 'text':
+                return self::astTextToFusion($ast['payload'], $indentation);
+                break;
+            case 'boolean':
+                return self::astBooleanToFusion($ast['payload'], $indentation);
+                break;
+            case 'node':
+                return self::astNodeToFusion($ast['payload'], $indentation);
+                break;
+            default:
+                throw new AfxException(sprintf('ast type %s is unkonwn', $ast['type']));
+        }
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astBooleanToFusion($payload, $indentation = '')
+    {
+        return 'true';
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astExpressionToFusion($payload, $indentation = '')
+    {
+        return '${' . $payload . '}';
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astStringToFusion($payload, $indentation = '')
+    {
+        return '\'' . addslashes($payload) . '\'';
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astTextToFusion($payload, $indentation = '')
+    {
+        return '\'' . addslashes($payload) . '\'';
+    }
+    /**
+     * @param array $payload
+     * @param array $attributePrefix
+     * @param string $indentation
+     * @return string
+     */
+    protected static function propListToFusion($payload, $attributePrefix, $indentation = '')
+    {
+        $fusion = '';
+        foreach ($payload as $attribute) {
+            if ($attribute['type'] === 'prop') {
+                $prop = $attribute['payload'];
+                $propName = $prop['identifier'];
+                $propFusion = self::astToFusion($prop, $indentation . self::INDENTATION);
+                if ($propFusion !== null) {
+                    $fusion .= $indentation . self::INDENTATION . $attributePrefix . $propName . ' = ' . $propFusion . PHP_EOL;
+                }
+            }
+        }
+        return $fusion;
+    }
+    /**
+     * @param array $attributes
+     * @return array
+     */
+    protected static function generatePathForShorthandFusionMetaPath(array $attributes): array
+    {
+        $indexes = [];
+        foreach ($attributes as &$attribute) {
+            if ($attribute['type'] !== 'prop') {
+                continue;
+            }
+            $path = &$attribute['payload']['identifier'];
+            $fusionPropertyPathSegments = explode('.', $path);
+            $lastPathSegment = end($fusionPropertyPathSegments);
+            if (in_array($lastPathSegment, self::SHORTHAND_META_PATHS, true)) {
+                $indexes[$path] ?? $indexes[$path] = 0;
+                $path .= '.' . substr($lastPathSegment, 1) . '_' . ++$indexes[$path];
+            }
+        }
+        return $attributes;
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astNodeToFusion($payload, $indentation = '')
+    {
+        $tagName = $payload['identifier'];
+        $childrenPropertyName = 'content';
+        $attributes = $payload['attributes'];
+        $attributes = array_filter($attributes, function ($attribute) use (&$childrenPropertyName) {
+            if ($attribute['type'] === 'prop') {
+                if ($attribute['payload']['identifier'] === '@key' || $attribute['payload']['identifier'] === '@path') {
+                    return false;
+                } elseif ($attribute['payload']['identifier'] === '@children') {
+                    if ($attribute['payload']['type'] === 'string') {
+                        $childrenPropertyName = $attribute['payload']['payload'];
+                    } else {
+                        throw new AfxException(
+                            sprintf('@children only supports string payloads %s found', $attribute['payload']['type'])
+                        );
+                    }
+                    return false;
+                }
+            }
+            return true;
+        });
+        $pathChildren = [];
+        $contentChildren = [];
+        if ($payload['children'] && count($payload['children']) > 0) {
+            foreach ($payload['children'] as $child) {
+                if ($child['type'] === 'node') {
+                    $path = null;
+                    foreach ($child['payload']['attributes'] as $attribute) {
+                        if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'] === '@path') {
+                            $pathAttribute = $attribute['payload'];
+                            if ($pathAttribute['type'] === 'string') {
+                                $path = $pathAttribute['payload'];
+                            } else {
+                                throw new AfxException(
+                                    sprintf('@path only supports string payloads %s found', $pathAttribute['type'])
+                                );
+                            }
+                        }
+                    };
+                    if ($path) {
+                        $pathChildren[$path] = $child;
+                        continue;
+                    }
+                }
+                $contentChildren[] = $child;
+            }
+        }
+        if (strpos($tagName, ':') !== false) {
+            $fusion = $tagName . ' {' . PHP_EOL;
+            $attributePrefix = '';
+        } else {
+            $fusion = 'Neos.Fusion:Tag {' . PHP_EOL;
+            $fusion .= $indentation . self::INDENTATION .'tagName = \'' .  $tagName . '\'' . PHP_EOL;
+            $attributePrefix = 'attributes.';
+            if ($payload['selfClosing'] === true) {
+                $fusion .= $indentation . self::INDENTATION .'selfClosingTag = true' . PHP_EOL;
+            }
+        }
+        if ($attributes !== []) {
+            $spreadIsPresent = false;
+            $metaAttributes = [];
+            $fusionAttributes = [];
+            $spreadsOrAttributeLists = [];
+            $attributes = self::generatePathForShorthandFusionMetaPath($attributes);
+            foreach ($attributes as $attribute) {
+                if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'][0] === '@') {
+                    $metaAttributes[] = $attribute;
+                } elseif ($attribute['type'] === 'prop' && $spreadIsPresent === false) {
+                    $fusionAttributes[] = $attribute;
+                } elseif ($attribute['type'] === 'spread') {
+                    $spreadsOrAttributeLists[] = $attribute;
+                    $spreadIsPresent = true;
+                } elseif ($attribute['type'] === 'prop') {
+                    $last = end($spreadsOrAttributeLists);
+                    $lastPos = key($spreadsOrAttributeLists);
+                    if ($last && $last['type'] === 'propList') {
+                        $last['payload'][] = $attribute;
+                        $spreadsOrAttributeLists[$lastPos] = $last;
+                    } else {
+                        $spreadsOrAttributeLists[] = [
+                            'type' => 'propList',
+                            'payload' => [$attribute]
+                        ];
+                    }
+                }
+            }
+            if ($fusionAttributes !== []) {
+                $fusion .=  self::propListToFusion($fusionAttributes, $attributePrefix, $indentation);
+            }
+            $spreadIndex = 1;
+            foreach ($spreadsOrAttributeLists as $attribute) {
+                if ($attribute['type'] === 'spread') {
+                    if ($attribute['payload']['type'] === 'expression') {
+                        $spreadFusion = self::astToFusion($attribute['payload'], $indentation . self::INDENTATION);
+                        if ($spreadFusion !== null) {
+                            $fusion .= $indentation . self::INDENTATION . $attributePrefix . '@apply.spread_' . $spreadIndex . ' = ' . $spreadFusion . PHP_EOL;
+                        }
+                    } else {
+                        throw new AfxException(
+                            sprintf('Spreads only support expression payloads %s found', $attribute['payload']['type'])
+                        );
+                    }
+                } elseif ($attribute['type'] === 'propList') {
+                    $fusion .= $indentation . self::INDENTATION . $attributePrefix . '@apply.spread_' . $spreadIndex . ' = Neos.Fusion:DataStructure {' . PHP_EOL;
+                    $fusion .=  self::propListToFusion($attribute['payload'], '', $indentation . self::INDENTATION);
+                    $fusion .= $indentation . self::INDENTATION . '}' . PHP_EOL;
+                }
+                $spreadIndex ++;
+            }
+            if ($metaAttributes !== []) {
+                $fusion .=  self::propListToFusion($metaAttributes, '', $indentation);
+            }
+        }
+        if ($pathChildren !== []) {
+            foreach ($pathChildren as $path => $child) {
+                $fusion .= $indentation . self::INDENTATION . $path . ' = ' . self::astToFusion($child, $indentation . self::INDENTATION) . PHP_EOL;
+            }
+        }
+        if ($contentChildren !== []) {
+            $childFusion = self::astNodeListToFusion($contentChildren, $indentation . self::INDENTATION);
+            if ($childFusion) {
+                $fusion .= $indentation . self::INDENTATION . $childrenPropertyName . ' = ' . $childFusion . PHP_EOL;
+            }
+        }
+        $fusion .= $indentation . '}';
+        return $fusion;
+    }
+    /**
+     * @param array $payload
+     * @param string $indentation
+     * @return string
+     */
+    protected static function astNodeListToFusion($payload, $indentation = '')
+    {
+        $index = 1;
+        $payload = array_map(function ($astNode) {
+            if ($astNode['type'] === 'text') {
+                $astNode['payload'] = preg_replace('/(^[\\s]*\\n[\\s]*|[\\s]*\\n[\\s]*$)/u', '', $astNode['payload']);
+                $astNode['payload'] = preg_replace('/([\\s]*\\n[\\s]*)+/u', ' ', $astNode['payload']);
+            }
+            return $astNode;
+        }, $payload);
+        $payload = array_filter($payload, function ($astNode) {
+            if ($astNode['type'] === 'text' && $astNode['payload'] == '') {
+                return false;
+            }
+            if ($astNode['type'] === 'comment') {
+                return false;
+            }
+            return true;
+        });
+        if (count($payload) === 0) {
+            return '\'\'';
+        } elseif (count($payload) === 1) {
+            return self::astToFusion(array_shift($payload), $indentation);
+        } else {
+            $fusion = 'Neos.Fusion:Join {' . PHP_EOL;
+            foreach ($payload as $astNode) {
+                $fusionName = 'item_' . $index;
+                if ($astNode['type'] === 'node' && $astNode['payload']['attributes'] !== []) {
+                    foreach ($astNode['payload']['attributes'] as $attribute) {
+                        if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'] === '@key') {
+                            if ($attribute['payload']['type'] === 'string') {
+                                $fusionName = $attribute['payload']['payload'];
+                            } else {
+                                throw new AfxException(
+                                    sprintf(
+                                        '@key only supports string payloads %s was given',
+                                        $attribute['payload']['type']
+                                    )
+                                );
+                            }
+                        }
+                    }
+                }
+                $nodeFusion = self::astToFusion($astNode, $indentation . self::INDENTATION);
+                if ($nodeFusion !== null) {
+                    $fusion .= $indentation . self::INDENTATION . $fusionName . ' = ' . $nodeFusion . PHP_EOL;
+                    $index++;
+                }
+            }
+            $fusion .= $indentation . '}';
+            return $fusion;
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Cache/ContentCache.php
@@ -0,0 +1,388 @@
+<?php
+namespace Neos\Fusion\Core\Cache;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Cache\CacheAwareInterface;
+use Neos\Cache\Frontend\StringFrontend;
+use Neos\Flow\Property\PropertyMapper;
+use Neos\Flow\Security\Context;
+use Neos\Flow\Utility\Algorithms;
+use Neos\Fusion\Exception;
+use Doctrine\Persistence\Proxy;
+use Neos\Fusion\Exception\CacheException;
+/**
+ * A wrapper around a Neos Flow cache which provides additional functionality for caching partial content (segments)
+ * rendered by the Fusion Runtime.
+ *
+ * The cache build process generally follows these steps:
+ *
+ *  - render the whole document as usual (for example a page) but insert special markers before and after the rendered segments
+ *  - parse the rendered document and extract segments by the previously added markers
+ *
+ * This results in two artifacts:
+ *
+ *  - an array of content segments which are later stored as cache entries (if they may be cached)
+ *  - a string called "output" which is the originally rendered output but without the markers
+ *
+ * We use non-visible ASCII characters as markers / tokens in order to minimize potential conflicts with the actual content.
+ *
+ * Note: If you choose a different cache backend for this content cache, make sure that it is one implementing
+ *       TaggableBackendInterface.
+ *
+ * @Flow\Scope("singleton")
+ */
+class ContentCache
+{
+    const CACHE_SEGMENT_START_TOKEN = "\x02";
+    const CACHE_SEGMENT_END_TOKEN = "\x03";
+    const CACHE_SEGMENT_SEPARATOR_TOKEN = "\x1f";
+    const CACHE_SEGMENT_MARKER = 'CONTENT_CACHE';
+    const CACHE_PLACEHOLDER_REGEX = "/\x02CONTENT_CACHE(?P<identifier>[a-f0-9]+)\x03CONTENT_CACHE/";
+    const EVAL_PLACEHOLDER_REGEX = "/\x02CONTENT_CACHE(?P<command>[^\x02\x1f\x03]+)\x1fCONTENT_CACHE(?P<data>[^\x02\x1f\x03]+)\x03CONTENT_CACHE/";
+    const MAXIMUM_NESTING_LEVEL = 32;
+    /**
+     * A cache entry tag that will be used by default to flush an entry on "every" change - whatever that means to
+     * the application.
+     */
+    const TAG_EVERYTHING = 'Everything';
+    const SEGMENT_TYPE_CACHED = 'cached';
+    const SEGMENT_TYPE_UNCACHED = 'uncached';
+    const SEGMENT_TYPE_DYNAMICCACHED = 'dynamiccached';
+    /**
+     * @var StringFrontend
+     * @Flow\Inject
+     */
+    protected $cache;
+    /**
+     * @var PropertyMapper
+     * @Flow\Inject
+     */
+    protected $propertyMapper;
+    /**
+     * @var Context
+     * @Flow\Inject
+     */
+    protected $securityContext;
+    /**
+     * @var string
+     */
+    protected $randomCacheMarker;
+    /**
+     * ContentCache constructor
+     */
+    public function __construct()
+    {
+        $this->randomCacheMarker = Algorithms::generateRandomString(13);
+    }
+    /**
+     * Takes the given content and adds markers for later use as a cached content segment.
+     *
+     * This function will add a start and an end token to the beginning and end of the content and generate a cache
+     * identifier based on the current Fusion path and additional values which were defined in the Fusion
+     * configuration by the site integrator.
+     *
+     * The whole cache segment (START TOKEN + IDENTIFIER + SEPARATOR TOKEN + original content + END TOKEN) is returned
+     * as a string.
+     *
+     * This method is called by the Fusion Runtime while rendering a Fusion object.
+     *
+     * @param string $content The (partial) content which should potentially be cached later on
+     * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
+     * @param array $cacheIdentifierValues The values (simple type or implementing CacheAwareInterface) that should be used to create a cache identifier, will be sorted by keys for consistent ordering
+     * @param array $tags Tags to add to the cache entry
+     * @param integer $lifetime Lifetime of the cache segment in seconds. NULL for the default lifetime and 0 for unlimited lifetime.
+     * @return string The original content, but with additional markers and a cache identifier added
+     */
+    public function createCacheSegment($content, $fusionPath, array $cacheIdentifierValues, array $tags = [], $lifetime = null)
+    {
+        $cacheIdentifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues);
+        $metadata = implode(',', $tags);
+        if ($lifetime !== null) {
+            $metadata .= ';' . $lifetime;
+        }
+        return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $cacheIdentifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $metadata . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
+    }
+    /**
+     * Similar to createCacheSegment() creates a content segment with markers added, but in contrast to that function
+     * this method is used for rendering a segment which is not supposed to be cached.
+     *
+     * This method is called by the Fusion Runtime while rendering a Fusion object.
+     *
+     * @param string $content The content rendered by the Fusion Runtime
+     * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
+     * @param array $contextVariables Fusion context variables which are needed to correctly render the specified Fusion object
+     * @return string The original content, but with additional markers added
+     */
+    public function createUncachedSegment($content, $fusionPath, array $contextVariables)
+    {
+        $serializedContext = $this->serializeContext($contextVariables);
+        return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . 'eval=' . $fusionPath . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . json_encode(['context' => $serializedContext]) . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
+    }
+    /**
+     * Similar to createUncachedSegment() creates a content segment with markers added, but in contrast to that function
+     * this method is used for rendering a segment which will be evaluated at runtime but can still be cached.
+     *
+     * This method is called by the Fusion Runtime while rendering a Fusion object.
+     *
+     * @param string $content The content rendered by the Fusion Runtime
+     * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
+     * @param array $contextVariables Fusion context variables which are needed to correctly render the specified Fusion object
+     * @param array $cacheIdentifierValues
+     * @param array $tags Tags to add to the cache entry
+     * @param integer $lifetime Lifetime of the cache segment in seconds. NULL for the default lifetime and 0 for unlimited lifetime.
+     * @param string $cacheDiscriminator The evaluated cache discriminator value
+     * @return string The original content, but with additional markers added
+     */
+    public function createDynamicCachedSegment($content, $fusionPath, array $contextVariables, array $cacheIdentifierValues, array $tags, $lifetime, $cacheDiscriminator)
+    {
+        $metadata = implode(',', $tags);
+        if ($lifetime !== null) {
+            $metadata .= ';' . $lifetime;
+        }
+        $cacheDiscriminator = md5($cacheDiscriminator);
+        $identifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues) . '_' . $cacheDiscriminator;
+        $segmentData = [
+            'path' => $fusionPath,
+            'metadata' => $metadata,
+            'context' => $this->serializeContext($contextVariables),
+        ];
+        return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . 'evalCached=' . $identifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . json_encode($segmentData) . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
+    }
+    /**
+     * Renders an identifier for a content cache entry
+     *
+     * @param string $fusionPath
+     * @param array $cacheIdentifierValues
+     * @return string An MD5 hash built from the fusionPath and certain elements of the given identifier values
+     * @throws CacheException If an invalid entry identifier value is given
+     */
+    protected function renderContentCacheEntryIdentifier($fusionPath, array $cacheIdentifierValues)
+    {
+        ksort($cacheIdentifierValues);
+        $identifierSource = '';
+        foreach ($cacheIdentifierValues as $key => $value) {
+            if ($value instanceof CacheAwareInterface) {
+                $identifierSource .= $key . '=' . $value->getCacheEntryIdentifier() . '&';
+            } elseif (is_string($value) || is_bool($value) || is_integer($value)) {
+                $identifierSource .= $key . '=' . $value . '&';
+            } elseif ($value !== null) {
+                throw new CacheException(sprintf('Invalid cache entry identifier @cache.entryIdentifier.%s for path "%s". A entry identifier value must be a string or implement CacheAwareInterface.', $key, $fusionPath), 1395846615);
+            }
+        }
+        $identifierSource .= 'securityContextHash=' . $this->securityContext->getContextHash();
+        return md5($fusionPath . '@' . $identifierSource);
+    }
+    /**
+     * Takes a string of content which includes cache segment markers, extracts the marked segments, writes those
+     * segments which can be cached to the actual cache and returns the cleaned up original content without markers.
+     *
+     * This method is called by the Fusion Runtime while rendering a Fusion object.
+     *
+     * @param string $content The content with an outer cache segment
+     * @param boolean $storeCacheEntries Whether to store extracted cache segments in the cache
+     * @return string The (pure) content without cache segment markers
+     */
+    public function processCacheSegments($content, $storeCacheEntries = true)
+    {
+        $parser = new CacheSegmentParser($content, $this->randomCacheMarker);
+        if ($storeCacheEntries) {
+            $segments = $parser->getCacheSegments();
+            foreach ($segments as $segment) {
+                $metadata = explode(';', $segment['metadata']);
+                $tagsValue = $metadata[0] === '' ? [] : ($metadata[0] === '*' ? false : explode(',', $metadata[0]));
+                if ($tagsValue !== false) {
+                    $lifetime = isset($metadata[1]) ? (integer)$metadata[1] : null;
+                    $this->cache->set($segment['identifier'], $segment['content'], $this->sanitizeTags($tagsValue), $lifetime);
+                }
+            }
+        }
+        return $parser->getOutput();
+    }
+    /**
+     * Tries to retrieve the specified content segment from the cache  further nested inline segments are retrieved
+     * as well and segments which were not cacheable are rendered.
+     *
+     * @param \Closure $uncachedCommandCallback A callback to process commands in uncached segments
+     * @param string $fusionPath Fusion path identifying the Fusion object to retrieve from the content cache
+     * @param array $cacheIdentifierValues Further values which play into the cache identifier hash, must be the same as the ones specified while the cache entry was written
+     * @param boolean $addCacheSegmentMarkersToPlaceholders If cache segment markers should be added  this makes sense if the cached segment is about to be included in a not-yet-cached segment
+     * @param string|bool $cacheDiscriminator The evaluated cache discriminator value, if any and false if the cache discriminator is disabled for the current context
+     * @return string|boolean The segment with replaced cache placeholders, or false if a segment was missing in the cache
+     * @throws Exception
+     */
+    public function getCachedSegment($uncachedCommandCallback, $fusionPath, $cacheIdentifierValues, $addCacheSegmentMarkersToPlaceholders = false, $cacheDiscriminator = null)
+    {
+        if ($cacheDiscriminator === false || ($addCacheSegmentMarkersToPlaceholders && $cacheDiscriminator !== null)) {
+            return false;
+        }
+        $cacheIdentifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues);
+        if ($cacheDiscriminator !== null) {
+            $cacheIdentifier .= '_' . md5($cacheDiscriminator);
+        }
+        $content = $this->cache->get($cacheIdentifier);
+        if ($content === false) {
+            return false;
+        }
+        $i = 0;
+        do {
+            $replaced = $this->replaceCachePlaceholders($content, $addCacheSegmentMarkersToPlaceholders);
+            if ($replaced === false) {
+                return false;
+            }
+            $replaced += $this->replaceUncachedPlaceholders($uncachedCommandCallback, $content);
+            if ($i > self::MAXIMUM_NESTING_LEVEL) {
+                throw new Exception('Maximum cache segment level reached', 1391873620);
+            }
+            $i++;
+        } while ($replaced > 0);
+        if ($addCacheSegmentMarkersToPlaceholders) {
+            return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $cacheIdentifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . '*' . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
+        } else {
+            return $content;
+        }
+    }
+    /**
+     * Find cache placeholders in a cached segment and return the identifiers
+     *
+     * @param string $content
+     * @param boolean $addCacheSegmentMarkersToPlaceholders
+     * @return integer|boolean Number of replaced placeholders or false if a placeholder couldn't be found
+     */
+    protected function replaceCachePlaceholders(&$content, $addCacheSegmentMarkersToPlaceholders)
+    {
+        $cache = $this->cache;
+        $foundMissingIdentifier = false;
+        $content = preg_replace_callback(self::CACHE_PLACEHOLDER_REGEX, function ($match) use ($cache, &$foundMissingIdentifier, $addCacheSegmentMarkersToPlaceholders) {
+            $identifier = $match['identifier'];
+            $entry = $cache->get($identifier);
+            if ($entry !== false) {
+                if ($addCacheSegmentMarkersToPlaceholders) {
+                    return ContentCache::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $identifier . ContentCache::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . '*' . ContentCache::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $entry . ContentCache::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
+                } else {
+                    return $entry;
+                }
+            } else {
+                $foundMissingIdentifier = true;
+                return '';
+            }
+        }, $content, -1, $count);
+        if ($foundMissingIdentifier) {
+            return false;
+        }
+        return $count;
+    }
+    /**
+     * Replace segments which are marked as not-cacheable by their actual content by invoking the Fusion Runtime.
+     *
+     * @param \Closure $uncachedCommandCallback
+     * @param string $content The content potentially containing not cacheable segments marked by the respective tokens
+     * @return integer Number of replaced placeholders
+     */
+    protected function replaceUncachedPlaceholders(\Closure $uncachedCommandCallback, &$content)
+    {
+        $cache = $this->cache;
+        $content = preg_replace_callback(self::EVAL_PLACEHOLDER_REGEX, function ($match) use ($uncachedCommandCallback, $cache) {
+            $command = $match['command'];
+            $additionalData = json_decode($match['data'], true);
+            return $uncachedCommandCallback($command, $additionalData, $cache);
+        }, $content, -1, $count);
+        return $count;
+    }
+    /**
+     * Generates an array of strings from the given array of context variables
+     *
+     * @param array $contextVariables
+     * @return array
+     * @throws \InvalidArgumentException
+     */
+    protected function serializeContext(array $contextVariables)
+    {
+        $serializedContextArray = [];
+        foreach ($contextVariables as $variableName => $contextValue) {
+            if ($contextValue !== null) {
+                $serializedContextArray[$variableName]['type'] = $this->getTypeForContextValue($contextValue);
+                $serializedContextArray[$variableName]['value'] = $this->propertyMapper->convert($contextValue, 'string');
+            }
+        }
+        return $serializedContextArray;
+    }
+    /**
+     * TODO: Adapt to Flow change https://review.typo3.org/#/c/33138/
+     *
+     * @param mixed $contextValue
+     * @return string
+     */
+    protected function getTypeForContextValue($contextValue)
+    {
+        if (is_object($contextValue)) {
+            if ($contextValue instanceof Proxy) {
+                $type = get_parent_class($contextValue);
+            } else {
+                $type = get_class($contextValue);
+            }
+        } else {
+            $type = gettype($contextValue);
+        }
+        return $type;
+    }
+    /**
+     * Flush content cache entries by tag
+     *
+     * @param string $tag A tag value that was assigned to a cache entry in Fusion, for example "Everything", "Node_[]", "NodeType_[]", "DescendantOf_[]" whereas "" is the node identifier or node type respectively
+     * @return integer The number of cache entries which actually have been flushed
+     */
+    public function flushByTag($tag)
+    {
+        return $this->cache->flushByTag($this->sanitizeTag($tag));
+    }
+    /**
+     * Flush content cache entries by tags
+     *
+     * @param array<string> $tags values that were assigned to a cache entry in Fusion, for example "Everything", "Node_[]", "NodeType_[]", "DescendantOf_[]" whereas "" is the node identifier or node type respectively
+     * @return integer The number of cache entries which actually have been flushed
+     */
+    public function flushByTags(array $tags): int
+    {
+        return $this->cache->flushByTags($this->sanitizeTags($tags));
+    }
+    /**
+     * Flush all content cache entries
+     *
+     * @return void
+     */
+    public function flush()
+    {
+        $this->cache->flush();
+    }
+    /**
+     * Sanitizes the given tag for use with the cache framework
+     *
+     * @param string $tag A tag which possibly contains non-allowed characters, for example "NodeType_Acme.Com:Page"
+     * @return string A cleaned up tag, for example "NodeType_Acme_Com-Page"
+     */
+    protected function sanitizeTag($tag)
+    {
+        return strtr($tag, '.:', '_-');
+    }
+    /**
+     * Sanitizes multiple tags with sanitizeTag()
+     *
+     * @param array $tags Multiple tags
+     * @return array The sanitized tags
+     */
+    protected function sanitizeTags(array $tags)
+    {
+        foreach ($tags as $key => $value) {
+            $tags[$key] = $this->sanitizeTag($value);
+        }
+        return $tags;
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Cache/ParserCache.php
@@ -0,0 +1,95 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\Cache;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Cache\Frontend\VariableFrontend;
+use Neos\Flow\Package\PackageManager;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
+use Neos\Utility\Unicode\Functions as UnicodeFunctions;
+use Neos\Utility\Files;
+/**
+ * Helper around the ParsePartials Cache.
+ * Connected in the boot to flush caches on file-change.
+ * Caches partials when requested by the Fusion Parser.
+ *
+ */
+class ParserCache
+{
+    use ParserCacheIdentifierTrait;
+    /**
+     * @Flow\Inject
+     * @var VariableFrontend
+     */
+    protected $parsePartialsCache;
+    /**
+     * @Flow\Inject
+     * @var PackageManager
+     */
+    protected $packageManager;
+    /**
+     * @Flow\InjectConfiguration(path="enableParsePartialsCache")
+     */
+    protected $enableCache;
+    public function cacheForFusionFile(?string $contextPathAndFilename, \Closure $generateValueToCache): FusionFile
+    {
+        if ($this->enableCache === false) {
+            return $generateValueToCache();
+        }
+        if ($contextPathAndFilename === null) {
+            return $generateValueToCache();
+        }
+        if (str_contains($contextPathAndFilename, '://')) {
+            $contextPathAndFilename = $this->getAbsolutePathForPackageRessourceUri($contextPathAndFilename);
+        }
+        $identifier = $this->getCacheIdentifierForFile($contextPathAndFilename);
+        return $this->cacheForIdentifier($identifier, $generateValueToCache);
+    }
+    public function cacheForDsl(string $identifier, string $code, \Closure $generateValueToCache): mixed
+    {
+        if ($this->enableCache === false) {
+            return $generateValueToCache();
+        }
+        $identifier = $this->getCacheIdentifierForDslCode($identifier, $code);
+        return $this->cacheForIdentifier($identifier, $generateValueToCache);
+    }
+    private function cacheForIdentifier(string $identifier, \Closure $generateValueToCache): mixed
+    {
+        if ($this->parsePartialsCache->has($identifier)) {
+            return $this->parsePartialsCache->get($identifier);
+        }
+        $value = $generateValueToCache();
+        $this->parsePartialsCache->set($identifier, $value);
+        return $value;
+    }
+    /**
+     * Uses the same technique to resolve a package resource URI like Flow.
+     *
+     * resource://My.Site/Private/Fusion/Foo/Bar.fusion
+     * ->
+     * FLOW_PATH_ROOT/Packages/Sites/My.Package/Resources/Private/Fusion/Foo/Bar.fusion
+     *
+     * {@see \Neos\Flow\ResourceManagement\Streams\ResourceStreamWrapper::evaluateResourcePath()}
+     * {@link https://github.com/neos/flow-development-collection/issues/2687}
+     *
+     * @throws \InvalidArgumentException
+     */
+    private function getAbsolutePathForPackageRessourceUri(string $requestedPath): string
+    {
+        $resourceUriParts = UnicodeFunctions::parse_url($requestedPath);
+        if ((isset($resourceUriParts['scheme']) === false
+            || $resourceUriParts['scheme'] !== 'resource')) {
+            throw new \InvalidArgumentException("Unsupported stream wrapper: '$requestedPath'");
+        }
+        $package = $this->packageManager->getPackage($resourceUriParts['host']);
+        return Files::concatenatePaths([$package->getResourcesPath(), $resourceUriParts['path']]);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Cache/ParserCacheFlusher.php
@@ -0,0 +1,56 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\Cache;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Cache\CacheManager;
+/**
+ * Helper around the ParsePartials Cache.
+ * Connected in the boot to flush caches on file-change.
+ *
+ */
+class ParserCacheFlusher
+{
+    use ParserCacheIdentifierTrait;
+    /**
+     * @var CacheManager
+     */
+    protected $flowCacheManager;
+    /**
+     * @param CacheManager $flowCacheManager
+     */
+    public function __construct(CacheManager $flowCacheManager)
+    {
+        $this->flowCacheManager = $flowCacheManager;
+    }
+    /**
+     * @param $fileMonitorIdentifier
+     * @param array $changedFiles
+     * @return void
+     */
+    public function flushPartialCacheOnFileChanges($fileMonitorIdentifier, array $changedFiles)
+    {
+        if ($fileMonitorIdentifier !== 'Fusion_Files') {
+            return;
+        }
+        $identifiersToFlush = [];
+        foreach ($changedFiles as $changedFile => $status) {
+            $identifiersToFlush[] = $this->getCacheIdentifierForFile($changedFile);
+        }
+        if ($identifiersToFlush !== []) {
+            $partialsCache = $this->flowCacheManager->getCache('Neos_Fusion_ParsePartials');
+            foreach ($identifiersToFlush as $identifierToFlush) {
+                if ($partialsCache->has($identifierToFlush)) {
+                    $partialsCache->remove($identifierToFlush);
+                }
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Cache/ParserCacheIdentifierTrait.php
@@ -0,0 +1,39 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\Cache;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * Identifier for the ParsePartials Cache.
+ */
+trait ParserCacheIdentifierTrait
+{
+    /**
+     * creates a comparable hash of the dsl type and content to be used as cache identifier
+     */
+    private function getCacheIdentifierForDslCode(string $identifier, string $code): string
+    {
+        return 'dsl_' . $identifier . '_' . md5($code);
+    }
+    /**
+     * creates a comparable hash of the absolute, resolved $fusionFileName
+     *
+     * @throws \InvalidArgumentException
+     */
+    private function getCacheIdentifierForFile(string $fusionFileName): string
+    {
+        $realPath = realpath($fusionFileName);
+        if ($realPath === false) {
+            throw new \InvalidArgumentException("Couldn't resolve realpath for: '$fusionFileName'");
+        }
+        $realFusionFilePathWithoutRoot = str_replace(FLOW_PATH_ROOT, '', $realPath);
+        return 'file_' . md5($realFusionFilePathWithoutRoot);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/DslFactory.php
@@ -0,0 +1,53 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\ObjectManagement\ObjectManagerInterface;
+use Neos\Fusion;
+/**
+ * This dsl factory takes care of instantiating a Fusion dsl transpilers.
+ *
+ * @Flow\Scope("singleton")
+ */
+class DslFactory
+{
+    /**
+     * @Flow\InjectConfiguration("dsl")
+     * @var
+     */
+    protected $dslSettings;
+    /**
+     * @Flow\Inject
+     * @var ObjectManagerInterface
+     */
+    protected $objectManger;
+    /**
+     * @param string $identifier
+     * @return DslInterface
+     * @throws Fusion\Exception
+     */
+    public function create(string $identifier): DslInterface
+    {
+        if (isset($this->dslSettings) && is_array($this->dslSettings) && isset($this->dslSettings[$identifier])) {
+            $dslObjectName = $this->dslSettings[$identifier];
+            if (!class_exists($dslObjectName)) {
+                throw new Fusion\Exception(sprintf('The fusion dsl-object %s was not found.', $dslObjectName), 1490776462);
+            }
+            $dslObject = new $dslObjectName();
+            if (!$dslObject instanceof DslInterface) {
+                throw new Fusion\Exception(sprintf('The fusion dsl-object was of type %s but was supposed to be of type %s', get_class($dslObject), DslInterface::class), 1490776470);
+            }
+            return new $dslObject();
+        }
+        throw new Fusion\Exception(sprintf('The fusion dsl-object for the key %s was not configured', $identifier), 1490776550);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractNode.php
@@ -0,0 +1,18 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+use Neos\Flow\Annotations as Flow;
+abstract class AbstractNode
+{
+    abstract public function visit(AstNodeVisitorInterface $visitor, ...$args);
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractOperation.php
@@ -0,0 +1,16 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+abstract class AbstractOperation extends AbstractNode
+{
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractPathSegment.php
@@ -0,0 +1,16 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+abstract class AbstractPathSegment extends AbstractNode
+{
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractPathValue.php
@@ -0,0 +1,16 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+abstract class AbstractPathValue extends AbstractNode
+{
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractStatement.php
@@ -0,0 +1,16 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+abstract class AbstractStatement extends AbstractNode
+{
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AssignedObjectPath.php
@@ -0,0 +1,28 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class AssignedObjectPath extends AbstractNode
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public ObjectPath $objectPath,
+        /** @psalm-readonly */
+        public bool $isRelative
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitAssignedObjectPath($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/Block.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class Block extends AbstractNode
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public StatementList $statementList
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitBlock($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/BoolValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class BoolValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public bool $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitBoolValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/CharValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class CharValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitCharValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/DslExpressionValue.php
@@ -0,0 +1,28 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class DslExpressionValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $identifier,
+        /** @psalm-readonly */
+        public string $code
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitDslExpressionValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/EelExpressionValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class EelExpressionValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitEelExpressionValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FloatValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class FloatValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public float $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitFloatValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FusionFile.php
@@ -0,0 +1,28 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class FusionFile extends AbstractNode
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public StatementList $statementList,
+        /** @psalm-readonly */
+        public ?string $contextPathAndFileName
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitFusionFile($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FusionObjectValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class FusionObjectValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitFusionObjectValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/IncludeStatement.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class IncludeStatement extends AbstractStatement
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $filePattern
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitIncludeStatement($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/IntValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class IntValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public int $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitIntValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/MetaPathSegment.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class MetaPathSegment extends AbstractPathSegment
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $identifier
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitMetaPathSegment($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/NullValue.php
@@ -0,0 +1,21 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class NullValue extends AbstractPathValue
+{
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitNullValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ObjectPath.php
@@ -0,0 +1,30 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class ObjectPath extends AbstractNode
+{
+    /**
+     * @psalm-readonly
+     * @var AbstractPathSegment[]
+     */
+    public $segments;
+    public function __construct(AbstractPathSegment ...$segments)
+    {
+        $this->segments = $segments;
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitObjectPath($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ObjectStatement.php
@@ -0,0 +1,32 @@
+<?php
+declare(strict_types=1);
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class ObjectStatement extends AbstractStatement
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public ObjectPath $path,
+        /** @psalm-readonly */
+        public ValueAssignment|ValueCopy|ValueUnset|null $operation,
+        /** @psalm-readonly */
+        public ?Block $block,
+        /** @psalm-readonly */
+        public int $cursor
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitObjectStatement($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/PathSegment.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class PathSegment extends AbstractPathSegment
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $identifier
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitPathSegment($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/PrototypePathSegment.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class PrototypePathSegment extends AbstractPathSegment
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $identifier
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitPrototypePathSegment($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/SimpleValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class SimpleValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public mixed $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitSimpleValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/StatementList.php
@@ -0,0 +1,30 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class StatementList extends AbstractNode
+{
+    /**
+     * @psalm-readonly
+     * @var AbstractStatement[]
+     */
+    public $statements = [];
+    public function __construct(AbstractStatement ...$statements)
+    {
+        $this->statements = $statements;
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitStatementList($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/StringValue.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class StringValue extends AbstractPathValue
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public string $value
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitStringValue($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueAssignment.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class ValueAssignment extends AbstractOperation
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public AbstractPathValue $pathValue
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitValueAssignment($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueCopy.php
@@ -0,0 +1,26 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class ValueCopy extends AbstractOperation
+{
+    public function __construct(
+        /** @psalm-readonly */
+        public AssignedObjectPath $assignedObjectPath
+    ) {
+    }
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitValueCopy($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueUnset.php
@@ -0,0 +1,21 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
+class ValueUnset extends AbstractOperation
+{
+    public function visit(AstNodeVisitorInterface $visitor, ...$args)
+    {
+        return $visitor->visitValueUnset($this, ...$args);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/AstNodeVisitorInterface.php
@@ -0,0 +1,57 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
+interface AstNodeVisitorInterface
+{
+    public function visitFusionFile(FusionFile $fusionFile);
+    public function visitStatementList(StatementList $statementList);
+    public function visitIncludeStatement(IncludeStatement $includeStatement);
+    public function visitObjectStatement(ObjectStatement $objectStatement);
+    public function visitBlock(Block $block);
+    public function visitObjectPath(ObjectPath $objectPath);
+    public function visitMetaPathSegment(MetaPathSegment $metaPathSegment);
+    public function visitPrototypePathSegment(PrototypePathSegment $prototypePathSegment);
+    public function visitPathSegment(PathSegment $pathSegment);
+    public function visitValueAssignment(ValueAssignment $valueAssignment);
+    public function visitFusionObjectValue(FusionObjectValue $fusionObjectValue);
+    public function visitDslExpressionValue(DslExpressionValue $dslExpressionValue);
+    public function visitEelExpressionValue(EelExpressionValue $eelExpressionValue);
+    public function visitFloatValue(FloatValue $floatValue);
+    public function visitIntValue(IntValue $intValue);
+    public function visitBoolValue(BoolValue $boolValue);
+    public function visitNullValue(NullValue $nullValue);
+    public function visitStringValue(StringValue $stringValue);
+    public function visitValueCopy(ValueCopy $valueCopy);
+    public function visitAssignedObjectPath(AssignedObjectPath $assignedObjectPath);
+    public function visitValueUnset(ValueUnset $valueUnset);
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Exception/ParserException.php
@@ -0,0 +1,193 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Exception;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageLinePart;
+use Neos\Fusion\Exception;
+/**
+ * 'Fluent' exception for the Fusion Parser.
+ */
+class ParserException extends Exception
+{
+    protected const RESOURCE_PATH_TO_PACKAGE_AND_CLEANED_PATH_REGEXP = <<<'REGEX'
+    `
+      ^resource://                  # flow resource wrapper
+      (?<packageKey>[^/]+)/         # Acme.Demo/
+      (?:Private/Fusion/)?              # ignore default path Private/Fusion/
+      (?:\.{1,2}/)*                       # ignore any kind of ./ or ../ greedy (also ./../../../)
+      (?<fileLocationOutOfContext>.*)       # left over is a small clean file name with folders.
+    `x
+    REGEX;
+    protected int $fluentCode;
+    protected \Closure $fluentMessageCreator;
+    protected ?\Throwable $fluentPrevious = null;
+    protected ?string $fluentFile;
+    protected string $fluentFusion;
+    protected int $fluentCursor;
+    protected bool $fluentShowColumn = true;
+    protected string $headingMessagePart;
+    protected string $asciiPreviewMessagePart;
+    protected string $helperMessagePart;
+    public function __construct()
+    {
+    }
+    public function getHeadingMessagePart(): string
+    {
+        return $this->headingMessagePart;
+    }
+    public function getAsciiPreviewMessagePart(): string
+    {
+        return $this->asciiPreviewMessagePart;
+    }
+    public function getHelperMessagePart(): string
+    {
+        return $this->helperMessagePart;
+    }
+    public function setCode(int $code): self
+    {
+        $this->fluentCode = $code;
+        return $this;
+    }
+    public function setFile(?string $file): self
+    {
+        $this->fluentFile = $file;
+        return $this;
+    }
+    public function setFusion(string $fusion): self
+    {
+        $this->fluentFusion = $fusion;
+        return $this;
+    }
+    public function setCursor(int $cursor): self
+    {
+        $this->fluentCursor = $cursor;
+        return $this;
+    }
+    public function setPrevious(?\Exception $previous): self
+    {
+        $this->fluentPrevious = $previous;
+        return $this;
+    }
+    public function setHideColumnInformation(): self
+    {
+        $this->fluentShowColumn = false;
+        return $this;
+    }
+    /**
+     * @param callable(MessageLinePart $next, MessageLinePart $prev): string $messageMaker
+     */
+    public function setMessageCreator(callable $messageCreator): self
+    {
+        if ($messageCreator instanceof \Closure === false) {
+            $messageCreator = \Closure::fromCallable($messageCreator);
+        }
+        $this->fluentMessageCreator = $messageCreator;
+        return $this;
+    }
+    public function setMessage(string $message): self
+    {
+        return $this->setMessageCreator(static function () use ($message) {
+            return $message;
+        });
+    }
+    public function build(): self
+    {
+        $fullMessage = $this->renderAndInitializeFullMessage();
+        parent::__construct($fullMessage, $this->fluentCode, $this->fluentPrevious);
+        return $this;
+    }
+    protected function renderAndInitializeFullMessage(): string
+    {
+        list(
+            $lineNumberCursor,
+            $linePartAfterCursor,
+            $linePartBeforeCursor
+            ) = self::splitAtCursorGetLinePartsAndLineNumber($this->fluentFusion, $this->fluentCursor);
+        $isEof = strlen($this->fluentFusion) === $this->fluentCursor;
+        $nextLine = new MessageLinePart($linePartAfterCursor, $isEof);
+        $prevLine = new MessageLinePart($linePartBeforeCursor);
+        $columnNumber = mb_strlen($linePartBeforeCursor) + 1;
+        $this->headingMessagePart = self::generateHeadingByFileName($this->fluentFile);
+        $this->asciiPreviewMessagePart = self::renderErrorLinePreview(
+            $this->fluentFile,
+            $linePartBeforeCursor . $linePartAfterCursor,
+            $lineNumberCursor,
+            $columnNumber,
+            $this->fluentShowColumn
+        );
+        $this->helperMessagePart = ($this->fluentMessageCreator)(
+            $nextLine,
+            $prevLine,
+        );
+        $fullMessage = $this->headingMessagePart . PHP_EOL . $this->asciiPreviewMessagePart . PHP_EOL . $this->helperMessagePart;
+        return $fullMessage;
+    }
+    protected static function renderErrorLinePreview(
+        ?string $fileName,
+        string $currentLine,
+        int $lineNumber,
+        int $columnNumber,
+        bool $renderColumnDetails = true
+    ): string {
+        $fileNameAndPosition = ($fileName ?? '<input>') . ":$lineNumber" . ($renderColumnDetails ? ":$columnNumber" : '');
+        $arrowColumn = '';
+        if ($renderColumnDetails) {
+            $spaceToArrow = str_repeat(' ', $columnNumber - 1);
+            $arrowColumn = "$spaceToArrow^ column $columnNumber";
+        }
+        $indentLine = str_repeat(' ', strlen((string)$lineNumber));
+        return <<<MESSAGE
+            $fileNameAndPosition
+            $indentLine |
+            $lineNumber | $currentLine
+            $indentLine | $arrowColumn
+            MESSAGE;
+    }
+    protected static function generateHeadingByFileName(?string $fileName): string
+    {
+        if ($fileName === null) {
+            return 'Fusion parser exception while parsing. (No context path and filename set)';
+        }
+        if (preg_match(self::RESOURCE_PATH_TO_PACKAGE_AND_CLEANED_PATH_REGEXP, $fileName, $matches) === 1) {
+            $packageKey = $matches['packageKey'];
+            $fileLocationOutOfContext = $matches['fileLocationOutOfContext'];
+            return "Fusion parser exception in '$fileLocationOutOfContext' of the package '$packageKey'.";
+        }
+        return "Fusion parser exception.";
+    }
+    /**
+     * @return array{int, string, string}
+     */
+    protected static function splitAtCursorGetLinePartsAndLineNumber(string $string, int $cursor): array
+    {
+        $stringLength = \strlen($string);
+        $lineNumberCursor = 1;
+        $linePartBeforeCursor = '';
+        $linePartAfterCursor = '';
+        for ($i = 0; $i < $stringLength; ++$i) {
+            $char = $string[$i];
+            if ($i < $cursor) {
+                if ($char === "\n") {
+                    ++$lineNumberCursor;
+                    $linePartBeforeCursor = '';
+                    continue;
+                }
+                $linePartBeforeCursor .= $char;
+                continue;
+            }
+            if ($char === "\n") {
+                break;
+            }
+            $linePartAfterCursor .= $char;
+        }
+        return [$lineNumberCursor, $linePartAfterCursor, $linePartBeforeCursor];
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Exception/ParserUnexpectedCharException.php
@@ -0,0 +1,19 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\Exception;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Exception;
+/**
+ * This exception is thrown when the Parser encounters an unexpected character
+ */
+class ParserUnexpectedCharException extends Exception
+{
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/ExceptionMessage/MessageCreator.php
@@ -0,0 +1,120 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * Creates exception messages for the Fusion parser
+ */
+class MessageCreator
+{
+    protected const VALID_OBJECT_PATH = "A valid object path is by '.' delimited path segments: alphanumeric and [:_-], prototype(Foo:Bar), in quotes, or a meta path starting with '@'.";
+    public static function forParseStatement(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        switch ($next->char()) {
+            case '/':
+                if ($next->char(1) === '*') {
+                    return "Unclosed comment.";
+                }
+                return "Unexpected single {$next->charPrint()}. You can start a comment with '//' or '/*' or '#'.";
+            case '"':
+            case '\'':
+                return "Unclosed quoted path.";
+            case '{':
+                return "Unexpected block start out of context. Check your number of curly braces.";
+            case '}':
+                return "Unexpected block end out of context. Check your number of curly braces.";
+        }
+        return "Unexpected statement starting with: {$next->charPrint()}. " . self::VALID_OBJECT_PATH;
+    }
+    public static function forParseEndOfStatement(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        switch ($next->char()) {
+            case '/':
+                if ($next->char(1) === '*') {
+                    return "Unclosed comment.";
+                }
+                return "Unexpected single {$next->charPrint()}. You can start a comment with '//' or '/*' or '#'.";
+        }
+        return "Expected end of a statement but found {$next->linePrint()}.";
+    }
+    public static function forParsePathSegment(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        switch ($next->char()) {
+            case '"':
+            case '\'':
+                return "A quoted object path starting with {$next->charPrint()} was not closed.";
+            case ' ':
+                if ($prev->char(-1) === '.') {
+                    return "No <space> is allowed after a separating '.' in an object path.";
+                }
+                return "Unexpected {$next->charPrint()} in object path.";
+        }
+        return "Unexpected object path starting with: {$next->charPrint()}. "  . self::VALID_OBJECT_PATH;
+    }
+    public static function forPathSegmentPrototypeName(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        if (preg_match('/^[a-zA-Z0-9.]++(?!:)/', $next->line()) === 1) {
+            return "Prototype name without namespace starting with {$next->charPrint()} - Default namespaces were removed. You might want to add 'Neos.Fusion:' in front.";
+        }
+        if (str_starts_with(trim($next->line()), ')')) {
+            return "A prototype name must be set. Unexpected char {$next->charPrint()}.";
+        }
+        return "Unexpected prototype name starting with: {$next->linePrint()}.";
+    }
+    public static function forParsePathOrOperator(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        if (preg_match('/.*namespace\s*:\s*$/', $prev->line()) === 1) {
+            return "It looks like you want to declare a namespace alias. The feature to alias namespaces was removed.";
+        }
+        if (preg_match('/.*include\s*$/', $prev->line()) === 1) {
+            return "Did you want to include a Fusion file? 'include: FileName.fusion'.";
+        }
+        if ($prev->char(-1) === ' ' && $next->char() === '.') {
+            return "Nested paths, separated by {$next->charPrint()} cannot contain spaces.";
+        }
+        if ($prev->char(-1) === ' ') {
+            return "Unknown operator starting with {$next->charPrint()}. (Or you have unwanted spaces in your object path).";
+        }
+        if ($next->char() === '(') {
+            return "An unquoted path segment cannot contain {$next->charPrint()}. Did you want to declare a prototype? 'prototype(Foo:Bar)'.";
+        }
+        if ($next->char() === '') {
+            return "Object path without operator or block start. Found: {$next->charPrint()}.";
+        }
+        return "Unknown operator or path segment at {$next->charPrint()}. Unquoted paths can contain only alphanumerics and [:_-]. Otherwise, put them in quotes.";
+    }
+    public static function forParseDslExpression(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        return "A dsl expression starting with {$next->linePrint(1)} was not closed.";
+    }
+    public static function forParsePathValue(MessageLinePart $next, MessageLinePart $prev): string
+    {
+        if (preg_match('/^[a-zA-Z0-9.]++(?!:)/', $next->line()) === 1) {
+            return "Unexpected {$next->linePrint()} in value assignment - It looks like an object without namespace. Default namespaces were removed. You might want to add 'Neos.Fusion:' in front.";
+        }
+        switch ($next->char()) {
+            case '':
+                return "No value specified in assignment.";
+            case '"':
+                return "Unclosed quoted string.";
+            case '\'':
+                return "Unclosed char sequence.";
+            case '`':
+                return "Template literals without DSL identifier are not supported.";
+            case '$':
+                if ($next->char(1) === '{') {
+                    return "Unclosed eel expression.";
+                }
+                return "Did you want to start an eel expression: '\${...}'?";
+        }
+        return "Unexpected character in assignment starting with {$next->charPrint()}.";
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/ExceptionMessage/MessageLinePart.php
@@ -0,0 +1,74 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+class MessageLinePart
+{
+    public function __construct(
+        protected string $linePart,
+        protected bool $isEof = false
+    ) {
+    }
+    public function line(int $offset = 0): string
+    {
+        return mb_substr($this->linePart, $offset);
+    }
+    public function linePrint(int $offset = 0): string
+    {
+        $line = $this->line($offset);
+        if (mb_strlen($line) > 1) {
+            return "'$line'";
+        }
+        return $this->charPrint($offset);
+    }
+    public function char(int $index = 0): string
+    {
+        if ($index < 0) {
+            return mb_substr($this->linePart, $index, 1);
+        }
+        return mb_substr($this->linePart, $index, $index + 1);
+    }
+    public function charPrint(int $index = 0): string
+    {
+        if ($this->isEof) {
+            return '<EOF>';
+        }
+        return self::printable($this->char($index));
+    }
+    protected static function printable(string $char): string
+    {
+        if ($char === '') {
+            return '<new line>';
+        }
+        return match (mb_ord($char)) {
+            0 => "<null>",
+            9 => "<horizontal tab>",
+            10 => "<line feed>",
+            11 => "<vertical tab>",
+            13 => "<carriage return>",
+            25 => "<end of medium>",
+            27 => "<escape>",
+            32 => "<space>",
+            34 => "<double quote>",
+            39 => "<single quote>",
+            47 => "<slash>",
+            92 => "<backslash>",
+            130 => "<single low-9 quotation mark>",
+            132 => "<double low-9 quotation mark>",
+            145 => "<left single quotation mark>",
+            146 => "<right single quotation mark>",
+            147 => "<left double quotation mark>",
+            148 => "<right double quotation mark>",
+            160 => "<non-breaking space>",
+            default => "'$char'",
+        };
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/FilePatternResolver.php
@@ -0,0 +1,127 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion;
+/**
+ * Resolve files after a pattern.
+ * The returned files will not be checked for recursion and for readability.
+ */
+class FilePatternResolver
+{
+    protected const RECURSIVE_GLOB_PATTERN = <<<'REGEX'
+    `^(?P<base>
+        [^*/]*          # simple case: path segment without '*' stop at '/'
+        (?:
+            /[^*]       # special case '/' no followed '*' is matched
+            [^*/]*      # simple case again - unrolled loop following Jeffrey Friedl
+        )*
+    )
+    /\*\*/\*            # the recursive include /**/*
+    (?P<end>
+        [^*/]*          # optional file end like .fusion or even -special.fusion but no further globbing or folders allowed
+    )$`x
+    REGEX;
+    protected const SIMPLE_GLOB_PATTERN = <<<'REGEX'
+    `^(?P<base>
+        [^*/]*          # simple case: path segment without '*' stop at '/'
+        (?:
+            /[^*]       # special case '/' no followed '*' is matched
+            [^*/]*      # simple case again - unrolled loop following Jeffrey Friedl
+        )*
+    )
+    /\*                 # the simple glob include /*
+    (?P<end>
+        [^*/]*          # optional file end like .fusion or even -special.fusion but no further globbing or folders allowed
+    )$`x
+    REGEX;
+    /**
+     * @param string $filePattern
+     * @param string|null $filePathForRelativeResolves
+     * @param string $defaultFileEndForUnspecificGlobbing
+     * @return array|string[]
+     * @throws Fusion\Exception
+     */
+    public static function resolveFilesByPattern(string $filePattern, ?string $filePathForRelativeResolves = null, string $defaultFileEndForUnspecificGlobbing = '.fusion'): array
+    {
+        $filePattern = trim($filePattern);
+        if ($filePattern === '') {
+            throw new Fusion\Exception("cannot resolve empty pattern: '$filePattern'", 1636144288);
+        }
+        if ($filePattern[0] === '/') {
+            throw new Fusion\Exception("cannot resolve absolute pattern: '$filePattern'", 1636144292);
+        }
+        if (self::isPatternStreamWrapper($filePattern) === false) {
+            $filePattern = self::resolveRelativePath($filePattern, $filePathForRelativeResolves);
+        }
+        if (str_contains($filePattern, '*') === false) {
+            return [$filePattern];
+        }
+        return self::parseGlobPatternAndResolveFiles($filePattern, $defaultFileEndForUnspecificGlobbing);
+    }
+    protected static function isPatternStreamWrapper(string $filePattern): bool
+    {
+        if (preg_match('`^(?P<protocol>[^:]+)://`', $filePattern, $matches) !== 1) {
+            return false;
+        }
+        $streamWrapper = $matches['protocol'];
+        if (in_array($streamWrapper, stream_get_wrappers(), true) === false) {
+            throw new Fusion\Exception("Unable to find the stream wrapper '$streamWrapper' while resolving the pattern: '$filePattern'", 1636144734);
+        }
+        return true;
+    }
+    protected static function resolveRelativePath(string $filePattern, ?string $filePathForRelativeResolves): string
+    {
+        if ($filePathForRelativeResolves === null) {
+            throw new Fusion\Exception('Relative file resolves are only possible with the argument $filePathForRelativeResolves passed.', 1636144731);
+        }
+        return dirname($filePathForRelativeResolves) . '/' . $filePattern;
+    }
+    protected static function parseGlobPatternAndResolveFiles(string $filePattern, string $defaultFileNameEnd): array
+    {
+        $fileIteratorCreator = match (1) {
+            preg_match(self::RECURSIVE_GLOB_PATTERN, $filePattern, $matches) => static function (string $dir): \Iterator {
+                $recursiveDirectoryIterator = new \RecursiveDirectoryIterator($dir);
+                return new \RecursiveIteratorIterator($recursiveDirectoryIterator);
+            },
+            preg_match(self::SIMPLE_GLOB_PATTERN, $filePattern, $matches) => static function (string $dir): \Iterator {
+                return new \DirectoryIterator($dir);
+            },
+            default => throw new Fusion\Exception("The include glob pattern '$filePattern' is invalid. Only globbing with /**/* or /* is supported.", 1636144713),
+        };
+        $basePath = $matches['base'];
+        $fileNameEnd = $matches['end'] === '' ? $defaultFileNameEnd : $matches['end'];
+        if (is_dir($basePath) === false) {
+            throw new Fusion\Exception("The path '$basePath' of the glob pattern '$filePattern' does not point to a directory.", 1636144717);
+        }
+        $fileIterator = $fileIteratorCreator($basePath);
+        return self::iterateOverFilesAndSelectByFileEnding($fileIterator, $fileNameEnd);
+    }
+    /**
+     * @param \Iterator|\SplFileInfo[] $fileIterator
+     * @param string $fileNameEnd when file matches this ending it will be included.
+     * @return array
+     */
+    protected static function iterateOverFilesAndSelectByFileEnding(\Iterator $fileIterator, string $fileNameEnd): array
+    {
+        $files = [];
+        foreach ($fileIterator as $fileInfo) {
+            if ($fileInfo->isDir()) {
+                continue;
+            }
+            $pathAndFilename = $fileInfo->getPathname();
+            if (str_ends_with($pathAndFilename, $fileNameEnd)) {
+                $files[] = $pathAndFilename;
+            }
+        }
+        return $files;
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Lexer.php
@@ -0,0 +1,137 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+class Lexer
+{
+    protected const PATTERN_EEL_EXPRESSION = <<<'REGEX'
+    /
+      ^\${(?P<exp>
+        (?>
+          { (?P>exp) }          # match object literal expression recursively
+          |[^{}"']+	            # simple eel expression without quoted strings
+          |"[^"\\]*			    # double quoted strings with possibly escaped double quotes
+            (?:
+              \\.			# escaped character (quote)
+              [^"\\]*		# unrolled loop following Jeffrey E.F. Friedl
+            )*"
+          |'[^'\\]*			# single quoted strings with possibly escaped single quotes
+            (?:
+              \\.			# escaped character (quote)
+              [^'\\]*		# unrolled loop following Jeffrey E.F. Friedl
+            )*'
+        )*
+      )}
+    /x
+    REGEX;
+    protected const TOKEN_REGEX = [
+        Token::SLASH_COMMENT => '/^\\/\\/.*/',
+        Token::HASH_COMMENT => '/^#.*/',
+        Token::MULTILINE_COMMENT => <<<'REGEX'
+        `^
+          /\*               # start of a comment '/*'
+          [^*]*             # match everything until special case '*'
+          (?:
+            \*[^/]          # if after the '*' there is a '/' break, else continue
+            [^*]*           # until the special case '*' is encountered - unrolled loop following Jeffrey Friedl
+          )*
+          \*/               # the end of a comment.
+        `x
+        REGEX,
+        Token::NEWLINE => '/^[\n\r]+/',
+        Token::SPACE => '/^[ \t]+/',
+        Token::TRUE_VALUE => '/^(?>true|TRUE)\\b/',
+        Token::FALSE_VALUE => '/^(?>false|FALSE)\\b/',
+        Token::NULL_VALUE => '/^(?>null|NULL)\\b/',
+        Token::INTEGER => '/^-?[0-9]+/',
+        Token::FLOAT => '/^-?[0-9]+\.[0-9]+/',
+        Token::DSL_EXPRESSION_START => '/^[a-zA-Z0-9\.]++(?=`)/',
+        Token::DSL_EXPRESSION_CONTENT => '/^`[^`]*+`/',
+        Token::EEL_EXPRESSION => self::PATTERN_EEL_EXPRESSION,
+        Token::FUSION_OBJECT_NAME => '/^[0-9a-zA-Z.]+:[0-9a-zA-Z.]+/',
+        Token::INCLUDE => '/^include\\s*:/',
+        Token::PROTOTYPE_START => '/^prototype\(/',
+        Token::META_PATH_START => '/^@/',
+        Token::OBJECT_PATH_PART => '/^[a-zA-Z0-9_:-]+/',
+        Token::ASSIGNMENT => '/^=/',
+        Token::COPY => '/^</',
+        Token::UNSET => '/^>/',
+        Token::DOT => '/^\./',
+        Token::COLON => '/^:/',
+        Token::RPAREN => '/^\)/',
+        Token::LBRACE => '/^{/',
+        Token::RBRACE => '/^}/',
+        Token::STRING_DOUBLE_QUOTED => <<<'REGEX'
+        /^
+          "[^"\\]*              # double quoted strings with possibly escaped double quotes
+            (?:
+              \\.               # escaped character (quote)
+              [^"\\]*           # unrolled loop following Jeffrey E.F. Friedl
+            )*
+          "
+        /x
+        REGEX,
+        Token::STRING_SINGLE_QUOTED => <<<'REGEX'
+        /^
+          '[^'\\]*              # single quoted strings with possibly escaped single quotes
+            (?:
+              \\.               # escaped character (quote)
+              [^'\\]*           # unrolled loop following Jeffrey E.F. Friedl
+            )*
+          '
+        /x
+        REGEX,
+        Token::FILE_PATTERN => '`^[a-zA-Z0-9.*:/_-]+`',
+    ];
+    protected string $code = '';
+    protected int $codeLen = 0;
+    protected int $cursor = 0;
+    protected ?Token $lookahead = null;
+    public function __construct(string $code)
+    {
+        $code = str_replace(["\r\n", "\r"], "\n", $code);
+        $this->code = $code;
+        $this->codeLen = strlen($code);
+    }
+    public function getCode(): string
+    {
+        return $this->code;
+    }
+    public function getCursor(): int
+    {
+        return $this->cursor;
+    }
+    public function consumeLookahead(): Token
+    {
+        $token = $this->lookahead;
+        $this->lookahead = null;
+        return $token;
+    }
+    public function getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead(int $tokenType): ?Token
+    {
+        if ($this->lookahead !== null) {
+            return $this->lookahead;
+        }
+        if ($this->cursor === $this->codeLen) {
+            return $this->lookahead = new Token(Token::EOF, '');
+        }
+        if ($tokenType === Token::EOF) {
+            return null;
+        }
+        $regexForToken = self::TOKEN_REGEX[$tokenType];
+        $remainingCode = substr($this->code, $this->cursor);
+        if (preg_match($regexForToken, $remainingCode, $matches) !== 1) {
+            return null;
+        }
+        $this->cursor += \strlen($matches[0]);
+        return $this->lookahead = new Token($tokenType, $matches[0]);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/MergedArrayTree.php
@@ -0,0 +1,103 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion;
+use Neos\Utility\Arrays;
+class MergedArrayTree
+{
+    public function __construct(
+        protected array $tree = []
+    ) {
+    }
+    public static function pathIsPrototype(array $path): bool
+    {
+        return ($path[count($path) - 2] ?? null) === '__prototypes';
+    }
+    public static function getParentPath(array $path): array
+    {
+        if (self::pathIsPrototype($path)) {
+            return array_slice($path, 0, -2);
+        }
+        return array_slice($path, 0, -1);
+    }
+    public function getTree(): array
+    {
+        return $this->tree;
+    }
+    public function removeValueInTree(array $path): void
+    {
+        $this->tree = Arrays::unsetValueByPath($this->tree, $path);
+        $this->setValueInTree($path, ['__stopInheritanceChain' => true]);
+    }
+    public function copyValueInTree(array $targetPath, array $sourcePath): void
+    {
+        $originalValue = Arrays::getValueByPath($this->tree, $sourcePath);
+        $this->setValueInTree($targetPath, $originalValue);
+    }
+    /**
+     * @param scalar|null|array $value The value to assign, either a scalar type or an array with __eelExpression etc.
+     */
+    public function setValueInTree(array $path, $value): void
+    {
+        self::arraySetOrMergeValueByPathWithCallback($this->tree, $path, $value, static function ($simpleType) {
+            return [
+                '__value' => $simpleType,
+                '__eelExpression' => null,
+                '__objectType' => null
+            ];
+        });
+    }
+    protected static function arraySetOrMergeValueByPathWithCallback(array &$subject, array $path, $value, callable $toArray): void
+    {
+        $pointer = &$subject;
+        foreach ($path as $pathSegment) {
+            if ($pointer === null) {
+                $pointer = [];
+            }
+            if (is_array($pointer) === false) {
+                $pointer = $toArray($pointer);
+            }
+            $pointer = &$pointer[$pathSegment];
+        }
+        if (is_array($pointer)) {
+            $arrayValue = is_array($value) ? $value : $toArray($value);
+            $pointer = Arrays::arrayMergeRecursiveOverrule($pointer, $arrayValue);
+            return;
+        }
+        $pointer = $value;
+    }
+    /**
+     * Precalculate merged configuration for inherited prototypes.
+     *
+     * @throws Fusion\Exception
+     */
+    public function buildPrototypeHierarchy(): void
+    {
+        if (isset($this->tree['__prototypes']) === false) {
+            return;
+        }
+        foreach (array_keys($this->tree['__prototypes']) as $prototypeName) {
+            $prototypeInheritanceHierarchy = [];
+            $currentPrototypeName = $prototypeName;
+            while (isset($this->tree['__prototypes'][$currentPrototypeName]['__prototypeObjectName'])) {
+                $currentPrototypeName = $this->tree['__prototypes'][$currentPrototypeName]['__prototypeObjectName'];
+                array_unshift($prototypeInheritanceHierarchy, $currentPrototypeName);
+                if ($prototypeName === $currentPrototypeName) {
+                    throw new Fusion\Exception(sprintf('Recursive inheritance found for prototype "%s". Prototype chain: %s', $prototypeName, implode(' < ', array_reverse($prototypeInheritanceHierarchy))), 1492801503);
+                }
+            }
+            if (count($prototypeInheritanceHierarchy)) {
+                $this->tree['__prototypes'][$prototypeName]['__prototypeChain'] = $prototypeInheritanceHierarchy;
+            }
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/MergedArrayTreeVisitor.php
@@ -0,0 +1,236 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
+use Neos\Fusion;
+use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserException;
+/**
+ * Builds the merged array tree for the Fusion runtime
+ */
+class MergedArrayTreeVisitor implements AstNodeVisitorInterface
+{
+    /**
+     * For nested blocks to determine the prefix
+     */
+    protected array $currentObjectPathStack = [];
+    protected ?string $contextPathAndFilename;
+    protected int $currentObjectStatementCursor;
+    public function __construct(
+        protected MergedArrayTree $mergedArrayTree,
+        protected \Closure $handleFileInclude,
+        protected \Closure $handleDslTranspile
+    ) {
+    }
+    public function visitFusionFile(FusionFile $fusionFile): MergedArrayTree
+    {
+        $this->contextPathAndFilename = $fusionFile->contextPathAndFileName;
+        $fusionFile->statementList->visit($this);
+        return $this->mergedArrayTree;
+    }
+    public function visitStatementList(StatementList $statementList)
+    {
+        foreach ($statementList->statements as $statement) {
+            $statement->visit($this);
+        }
+    }
+    public function visitIncludeStatement(IncludeStatement $includeStatement)
+    {
+        ($this->handleFileInclude)($this->mergedArrayTree, $includeStatement->filePattern, $this->contextPathAndFilename);
+    }
+    public function visitObjectStatement(ObjectStatement $objectStatement)
+    {
+        $this->currentObjectStatementCursor = $objectStatement->cursor;
+        $currentPath = $objectStatement->path->visit($this, $this->getCurrentObjectPathPrefix());
+        $objectStatement->operation?->visit($this, $currentPath);
+        $objectStatement->block?->visit($this, $currentPath);
+    }
+    public function visitBlock(Block $block, array $currentPath = null)
+    {
+        $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
+        array_push($this->currentObjectPathStack, $currentPath);
+        $block->statementList->visit($this);
+        array_pop($this->currentObjectPathStack);
+    }
+    public function visitObjectPath(ObjectPath $objectPath, array $objectPathPrefix = []): array
+    {
+        $path = $objectPathPrefix;
+        foreach ($objectPath->segments as $segment) {
+            $path = [...$path, ...$segment->visit($this)];
+        }
+        return $path;
+    }
+    public function visitMetaPathSegment(MetaPathSegment $metaPathSegment): array
+    {
+        return ['__meta', $metaPathSegment->identifier];
+    }
+    public function visitPrototypePathSegment(PrototypePathSegment $prototypePathSegment): array
+    {
+        return ['__prototypes', $prototypePathSegment->identifier];
+    }
+    public function visitPathSegment(PathSegment $pathSegment): array
+    {
+        $key = stripslashes($pathSegment->identifier);
+        self::validateParseTreeKey($key);
+        return [$key];
+    }
+    public function visitValueAssignment(ValueAssignment $valueAssignment, array $currentPath = null)
+    {
+        $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
+        $value = $valueAssignment->pathValue->visit($this);
+        $this->mergedArrayTree->setValueInTree($currentPath, $value);
+    }
+    public function visitFusionObjectValue(FusionObjectValue $fusionObjectValue)
+    {
+        return [
+            '__objectType' => $fusionObjectValue->value, '__value' => null, '__eelExpression' => null
+        ];
+    }
+    public function visitDslExpressionValue(DslExpressionValue $dslExpressionValue)
+    {
+        try {
+            return ($this->handleDslTranspile)($dslExpressionValue->identifier, $dslExpressionValue->code);
+        } catch (ParserException $e) {
+            throw $e;
+        } catch (\Exception $e) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1180600696)
+                ->setMessage($e->getMessage())
+                ->build();
+        }
+    }
+    public function visitEelExpressionValue(EelExpressionValue $eelExpressionValue)
+    {
+        $eelWithoutNewLines = str_replace("\n", '', $eelExpressionValue->value);
+        return [
+            '__eelExpression' => $eelWithoutNewLines, '__value' => null, '__objectType' => null
+        ];
+    }
+    public function visitFloatValue(FloatValue $floatValue)
+    {
+        return $floatValue->value;
+    }
+    public function visitIntValue(IntValue $intValue)
+    {
+        return $intValue->value;
+    }
+    public function visitBoolValue(BoolValue $boolValue)
+    {
+        return $boolValue->value;
+    }
+    public function visitNullValue(NullValue $nullValue)
+    {
+        return null;
+    }
+    public function visitStringValue(StringValue $stringValue): string
+    {
+        return $stringValue->value;
+    }
+    public function visitValueCopy(ValueCopy $valueCopy, array $currentPath = null)
+    {
+        $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
+        $sourcePath = $valueCopy->assignedObjectPath->visit($this, $this->mergedArrayTree->getParentPath($currentPath));
+        $currentPathsPrototype = $this->mergedArrayTree->pathIsPrototype($currentPath);
+        $sourcePathIsPrototype = $this->mergedArrayTree->pathIsPrototype($sourcePath);
+        if ($currentPathsPrototype && $sourcePathIsPrototype) {
+            if (count($currentPath) !== 2 || count($sourcePath) !== 2) {
+                throw $this->prepareParserException(new ParserException())
+                    ->setCode(1358418019)
+                    ->setMessage('Cannot inherit, when one of the sides is nested (e.g. foo.prototype(Bar)). Setting up prototype inheritance is only supported at the top level: prototype(Foo) < prototype(Bar)')
+                    ->build();
+            }
+            $currentPath[] = '__prototypeObjectName';
+            $this->mergedArrayTree->setValueInTree($currentPath, end($sourcePath));
+            return;
+        }
+        if ($currentPathsPrototype xor $sourcePathIsPrototype) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1358418015)
+                ->setMessage("Cannot inherit, when one of the sides is no prototype definition of the form prototype(Foo). It is only allowed to build inheritance chains with prototype objects.")
+                ->build();
+        }
+        $this->mergedArrayTree->copyValueInTree($currentPath, $sourcePath);
+    }
+    public function visitAssignedObjectPath(AssignedObjectPath $assignedObjectPath, $relativePath = [])
+    {
+        $path = [];
+        if ($assignedObjectPath->isRelative) {
+            $path = $relativePath;
+        }
+        return $assignedObjectPath->objectPath->visit($this, $path);
+    }
+    public function visitValueUnset(ValueUnset $valueUnset, array $currentPath = null)
+    {
+        $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
+        $this->mergedArrayTree->removeValueInTree($currentPath);
+    }
+    protected function getCurrentObjectPathPrefix(): array
+    {
+        $lastElementOfStack = end($this->currentObjectPathStack);
+        return ($lastElementOfStack === false) ? [] : $lastElementOfStack;
+    }
+    protected function validateParseTreeKey(string $pathKey)
+    {
+        if ($pathKey === '') {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1646988838)
+                ->setMessage("A path must not be empty.")
+                ->build();
+        }
+        if (str_starts_with($pathKey, '__')
+            && in_array($pathKey, Fusion\Core\Parser::$reservedParseTreeKeys, true)) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1437065270)
+                ->setMessage("Reversed key '$pathKey' used.")
+                ->build();
+        }
+        if (str_contains($pathKey, "\n")) {
+            $cleaned = str_replace("\n", '', $pathKey);
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1644068086)
+                ->setMessage("Key '$cleaned' cannot contain newlines.")
+                ->build();
+        }
+    }
+    protected function prepareParserException(ParserException $parserException): ParserException
+    {
+        if ($this->contextPathAndFilename === null) {
+            $fusionCode = '';
+        } else {
+            $fusionCode = file_get_contents($this->contextPathAndFilename);
+        }
+        return $parserException
+            ->setHideColumnInformation()
+            ->setFile($this->contextPathAndFilename)
+            ->setFusion($fusionCode)
+            ->setCursor($this->currentObjectStatementCursor);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/ObjectTreeParser.php
@@ -0,0 +1,472 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractPathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractPathValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
+use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageCreator;
+use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageLinePart;
+use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserException;
+use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserUnexpectedCharException;
+/**
+ * Parses a Fusion File to object ast-nodes
+ */
+class ObjectTreeParser
+{
+    protected Lexer $lexer;
+    protected ?string $contextPathAndFilename;
+    protected function __construct(Lexer $lexer, ?string $contextPathAndFilename)
+    {
+        $this->lexer = $lexer;
+        $this->contextPathAndFilename = $contextPathAndFilename;
+    }
+    public static function parse(string $sourceCode, ?string $contextPathAndFilename = null): FusionFile
+    {
+        $lexer = new Lexer($sourceCode);
+        $parser = new self($lexer, $contextPathAndFilename);
+        return $parser->parseFusionFile();
+    }
+    /**
+     * Consume the current token.
+     * Can only consume if accept was called before.
+     *
+     * @return Token
+     */
+    protected function consume(): Token
+    {
+        return $this->lexer->consumeLookahead();
+    }
+    /**
+     * Accepts a token of a given type.
+     * The Lexer will look up the regex for the token and try to match it on the current string.
+     * First match wins.
+     *
+     * @param int $tokenType
+     * @return bool
+     */
+    protected function accept(int $tokenType): bool
+    {
+        $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
+        if ($token === null) {
+            return false;
+        }
+        return $token->getType() === $tokenType;
+    }
+    /**
+     * Expects a token of a given type.
+     * The Lexer will look up the regex for the token and try to match it on the current string.
+     * First match wins.
+     *
+     * @param int $tokenType
+     * @return Token
+     * @throws ParserUnexpectedCharException
+     */
+    protected function expect(int $tokenType): Token
+    {
+        $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
+        if ($token === null || $token->getType() !== $tokenType) {
+            $tokenReadable = Token::typeToString($tokenType);
+            throw new ParserUnexpectedCharException("Expected token: '$tokenReadable'.", 1646988824);
+        }
+        return $this->lexer->consumeLookahead();
+    }
+    /**
+     * Checks, if the token type matches the current, if so consume it and return true.
+     * @param int $tokenType
+     * @return bool|null
+     */
+    protected function lazyExpect(int $tokenType): ?bool
+    {
+        $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
+        if ($token === null || $token->getType() !== $tokenType) {
+            return false;
+        }
+        $this->lexer->consumeLookahead();
+        return true;
+    }
+    /**
+     * OptionalBigGap
+     *  = ( NEWLINE / OptionalSmallGap )*
+     */
+    protected function lazyBigGap(): void
+    {
+        while (true) {
+            switch (true) {
+                case $this->accept(Token::SPACE):
+                case $this->accept(Token::NEWLINE):
+                case $this->accept(Token::SLASH_COMMENT):
+                case $this->accept(Token::HASH_COMMENT):
+                case $this->accept(Token::MULTILINE_COMMENT):
+                    $this->consume();
+                    break;
+                default:
+                    return;
+            }
+        }
+    }
+    /**
+     * OptionalSmallGap
+     *  = ( SPACE / SLASH_COMMENT / HASH_COMMENT / MULTILINE_COMMENT )*
+     */
+    protected function lazySmallGap(): void
+    {
+        while (true) {
+            switch (true) {
+                case $this->accept(Token::SPACE):
+                case $this->accept(Token::SLASH_COMMENT):
+                case $this->accept(Token::HASH_COMMENT):
+                case $this->accept(Token::MULTILINE_COMMENT):
+                    $this->consume();
+                    break;
+                default:
+                    return;
+            }
+        }
+    }
+    /**
+     * FusionFile
+     *  = StatementList
+     */
+    protected function parseFusionFile(): FusionFile
+    {
+        try {
+            return new FusionFile($this->parseStatementList(), $this->contextPathAndFilename);
+        } catch (ParserException $e) {
+            throw $e;
+        } catch (ParserUnexpectedCharException $e) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode($e->getCode())
+                ->setMessageCreator(function (MessageLinePart $nextLine) use ($e) {
+                    return "Unexpected char {$nextLine->charPrint()}. {$e->getMessage()}";
+                })
+                ->setPrevious($e)
+                ->build();
+        } catch (Fusion\Exception $e) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode($e->getCode())
+                ->setMessage('Exception while parsing: ' . $e->getMessage())
+                ->setHideColumnInformation()
+                ->setPrevious($e)
+                ->build();
+        }
+    }
+    /**
+     * StatementList
+     *  = ( Statement )*
+     *
+     * @param ?int $stopLookahead When this tokenType is encountered the loop will be stopped
+     */
+    protected function parseStatementList(?int $stopLookahead = null): StatementList
+    {
+        $statements = [];
+        $this->lazyBigGap();
+        while ($this->accept(Token::EOF) === false
+            && ($stopLookahead === null || $this->accept($stopLookahead) === false)) {
+            $statements[] = $this->parseStatement();
+            $this->lazyBigGap();
+        }
+        return new StatementList(...$statements);
+    }
+    /**
+     * Statement
+     *  = IncludeStatement / ObjectStatement
+     */
+    protected function parseStatement(): AbstractStatement
+    {
+        switch (true) {
+            case $this->accept(Token::INCLUDE):
+                return $this->parseIncludeStatement();
+            case $this->accept(Token::PROTOTYPE_START):
+            case $this->accept(Token::OBJECT_PATH_PART):
+            case $this->accept(Token::META_PATH_START):
+            case $this->accept(Token::STRING_SINGLE_QUOTED):
+            case $this->accept(Token::STRING_DOUBLE_QUOTED):
+                return $this->parseObjectStatement();
+        }
+        throw $this->prepareParserException(new ParserException())
+            ->setCode(1646988828)
+            ->setMessageCreator([MessageCreator::class, 'forParseStatement'])
+            ->build();
+    }
+    /**
+     * IncludeStatement
+     *  = INCLUDE ( STRING / CHAR / FILE_PATTERN ) EndOfStatement
+     */
+    protected function parseIncludeStatement(): IncludeStatement
+    {
+        $this->expect(Token::INCLUDE);
+        $this->lazyExpect(Token::SPACE);
+        switch (true) {
+            case $this->accept(Token::STRING_DOUBLE_QUOTED):
+            case $this->accept(Token::STRING_SINGLE_QUOTED):
+                $stringWrapped = $this->consume()->getValue();
+                $filePattern = substr($stringWrapped, 1, -1);
+                break;
+            case $this->accept(Token::FILE_PATTERN):
+                $filePattern = $this->consume()->getValue();
+                break;
+            default:
+                throw new ParserUnexpectedCharException('Expected file pattern in quotes or [a-zA-Z0-9.*:/_-]', 1646988832);
+        }
+        $this->parseEndOfStatement();
+        return new IncludeStatement($filePattern);
+    }
+    /**
+     * ObjectStatement
+     *  = ObjectPath ( ValueAssignment / ValueUnset / ValueCopy )? ( Block / EndOfStatement )
+     */
+    protected function parseObjectStatement(): ObjectStatement
+    {
+        $currentPath = $this->parseObjectPath();
+        $this->lazyExpect(Token::SPACE);
+        $cursorAfterObjectPath = $this->lexer->getCursor();
+        $operation = match (true) {
+            $this->accept(Token::ASSIGNMENT) => $this->parseValueAssignment(),
+            $this->accept(Token::UNSET) => $this->parseValueUnset(),
+            $this->accept(Token::COPY) => $this->parseValueCopy(),
+            default => null
+        };
+        $this->lazyExpect(Token::SPACE);
+        if ($this->accept(Token::LBRACE)) {
+            $block = $this->parseBlock();
+            return new ObjectStatement($currentPath, $operation, $block, $cursorAfterObjectPath);
+        }
+        if ($operation === null) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1646988835)
+                ->setMessageCreator([MessageCreator::class, 'forParsePathOrOperator'])
+                ->setCursor($cursorAfterObjectPath)
+                ->build();
+        }
+        $this->parseEndOfStatement();
+        return new ObjectStatement($currentPath, $operation, null, $cursorAfterObjectPath);
+    }
+    /**
+     * ObjectPath
+     *  = PathSegment ( '.' PathSegment )*
+     *
+     */
+    protected function parseObjectPath(): ObjectPath
+    {
+        $segments = [];
+        do {
+            $segments[] = $this->parsePathSegment();
+        } while ($this->lazyExpect(Token::DOT));
+        return new ObjectPath(...$segments);
+    }
+    /**
+     * PathSegment
+     *  = ( PROTOTYPE_START FUSION_OBJECT_NAME ')' / OBJECT_PATH_PART / '@' OBJECT_PATH_PART / STRING / CHAR )
+     */
+    protected function parsePathSegment(): AbstractPathSegment
+    {
+        switch (true) {
+            case $this->accept(Token::PROTOTYPE_START):
+                $this->consume();
+                try {
+                    $prototypeName = $this->expect(Token::FUSION_OBJECT_NAME)->getValue();
+                } catch (Fusion\Exception) {
+                    throw $this->prepareParserException(new ParserException())
+                        ->setCode(1646991578)
+                        ->setMessageCreator([MessageCreator::class, 'forPathSegmentPrototypeName'])
+                        ->build();
+                }
+                $this->expect(Token::RPAREN);
+                return new PrototypePathSegment($prototypeName);
+            case $this->accept(Token::OBJECT_PATH_PART):
+                $pathKey = $this->consume()->getValue();
+                return new PathSegment($pathKey);
+            case $this->accept(Token::META_PATH_START):
+                $this->consume();
+                $metaPathSegmentKey = $this->expect(Token::OBJECT_PATH_PART)->getValue();
+                return new MetaPathSegment($metaPathSegmentKey);
+            case $this->accept(Token::STRING_DOUBLE_QUOTED):
+            case $this->accept(Token::STRING_SINGLE_QUOTED):
+                $stringWrapped = $this->consume()->getValue();
+                $quotedPathKey = substr($stringWrapped, 1, -1);
+                return new PathSegment($quotedPathKey);
+        }
+        throw $this->prepareParserException(new ParserException())
+            ->setCode(1635708755)
+            ->setMessageCreator([MessageCreator::class, 'forParsePathSegment'])
+            ->build();
+    }
+    /**
+     * ValueAssignment
+     *  = ASSIGNMENT PathValue
+     */
+    protected function parseValueAssignment(): ValueAssignment
+    {
+        $this->expect(Token::ASSIGNMENT);
+        $this->lazyExpect(Token::SPACE);
+        $value = $this->parsePathValue();
+        return new ValueAssignment($value);
+    }
+    /**
+     * PathValue
+     *  = ( CHAR / STRING / DSL_EXPRESSION / FusionObject / EelExpression )
+     */
+    protected function parsePathValue(): AbstractPathValue
+    {
+        switch (true) {
+            case $this->accept(Token::STRING_SINGLE_QUOTED):
+                $charWrapped = $this->consume()->getValue();
+                $stringContent = substr($charWrapped, 1, -1);
+                return new StringValue(stripslashes($stringContent));
+            case $this->accept(Token::STRING_DOUBLE_QUOTED):
+                $stringWrapped = $this->consume()->getValue();
+                $stringContent = substr($stringWrapped, 1, -1);
+                return new StringValue(stripcslashes($stringContent));
+            case $this->accept(Token::FUSION_OBJECT_NAME):
+                return new FusionObjectValue($this->consume()->getValue());
+            case $this->accept(Token::DSL_EXPRESSION_START):
+                return $this->parseDslExpression();
+            case $this->accept(Token::EEL_EXPRESSION):
+                $eelWrapped = $this->consume()->getValue();
+                $eelContent = substr($eelWrapped, 2, -1);
+                return new EelExpressionValue($eelContent);
+            case $this->accept(Token::FLOAT):
+                return new FloatValue((float)$this->consume()->getValue());
+            case $this->accept(Token::INTEGER):
+                return new IntValue((int)$this->consume()->getValue());
+            case $this->accept(Token::TRUE_VALUE):
+                $this->consume();
+                return new BoolValue(true);
+            case $this->accept(Token::FALSE_VALUE):
+                $this->consume();
+                return new BoolValue(false);
+            case $this->accept(Token::NULL_VALUE):
+                $this->consume();
+                return new NullValue();
+        }
+        throw $this->prepareParserException(new ParserException())
+            ->setCode(1646988841)
+            ->setMessageCreator([MessageCreator::class, 'forParsePathValue'])
+            ->build();
+    }
+    /**
+     * DslExpression
+     *  = DSL_EXPRESSION_START DSL_EXPRESSION_CONTENT
+     */
+    protected function parseDslExpression(): DslExpressionValue
+    {
+        $dslIdentifier = $this->expect(Token::DSL_EXPRESSION_START)->getValue();
+        try {
+            $dslCode = $this->expect(Token::DSL_EXPRESSION_CONTENT)->getValue();
+        } catch (Fusion\Exception) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1490714685)
+                ->setMessageCreator([MessageCreator::class, 'forParseDslExpression'])
+                ->build();
+        }
+        $dslCode = substr($dslCode, 1, -1);
+        return new DslExpressionValue($dslIdentifier, $dslCode);
+    }
+    /**
+     * ValueUnset
+     *  = UNSET
+     */
+    protected function parseValueUnset(): ValueUnset
+    {
+        $this->expect(Token::UNSET);
+        return new ValueUnset();
+    }
+    /**
+     * ValueCopy
+     *  = COPY ObjectPathAssignment
+     */
+    protected function parseValueCopy(): ValueCopy
+    {
+        $this->expect(Token::COPY);
+        $this->lazyExpect(Token::SPACE);
+        $sourcePath = $this->parseAssignedObjectPath();
+        return new ValueCopy($sourcePath);
+    }
+    /**
+     * AssignedObjectPath
+     *  = '.'? ObjectPath
+     */
+    protected function parseAssignedObjectPath(): AssignedObjectPath
+    {
+        $isRelative = $this->lazyExpect(Token::DOT);
+        return new AssignedObjectPath($this->parseObjectPath(), $isRelative);
+    }
+    /**
+     * Block:
+     *  = '{' StatementList? '}'
+     */
+    protected function parseBlock(): Block
+    {
+        $this->expect(Token::LBRACE);
+        $cursorPositionStartOfBlock = $this->lexer->getCursor() - 1;
+        $this->parseEndOfStatement();
+        $statementList = $this->parseStatementList(Token::RBRACE);
+        try {
+            $this->expect(Token::RBRACE);
+        } catch (Fusion\Exception) {
+            throw $this->prepareParserException(new ParserException())
+                ->setCode(1646988844)
+                ->setMessage('No closing brace "}" matched this starting block. Encountered <EOF>.')
+                ->setCursor($cursorPositionStartOfBlock)
+                ->build();
+        }
+        return new Block($statementList);
+    }
+    /**
+     * EndOfStatement
+     *  = ( EOF / NEWLINE )
+     */
+    protected function parseEndOfStatement(): void
+    {
+        $this->lazySmallGap();
+        if ($this->accept(Token::EOF)) {
+            return;
+        }
+        if ($this->accept(Token::NEWLINE)) {
+            $this->consume();
+            return;
+        }
+        throw $this->prepareParserException(new ParserException())
+            ->setCode(1635878683)
+            ->setMessageCreator([MessageCreator::class, 'forParseEndOfStatement'])
+            ->build();
+    }
+    protected function prepareParserException(ParserException $parserException): ParserException
+    {
+        return $parserException
+            ->setFile($this->contextPathAndFilename)
+            ->setFusion($this->lexer->getCode())
+            ->setCursor($this->lexer->getCursor());
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ObjectTreeParser/Token.php
@@ -0,0 +1,84 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core\ObjectTreeParser;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+class Token
+{
+    public const EOF = 1;
+    public const SLASH_COMMENT = 2;
+    public const HASH_COMMENT = 3;
+    public const MULTILINE_COMMENT = 4;
+    public const SPACE = 5;
+    public const NEWLINE = 6;
+    public const INCLUDE = 7;
+    public const NAMESPACE = 8;
+    public const META_PATH_START = 9;
+    public const OBJECT_PATH_PART = 10;
+    public const PROTOTYPE_START = 11;
+    public const ASSIGNMENT = 12;
+    public const COPY = 13;
+    public const UNSET = 14;
+    public const FUSION_OBJECT_NAME = 15;
+    public const TRUE_VALUE = 16;
+    public const FALSE_VALUE = 17;
+    public const NULL_VALUE = 18;
+    public const INTEGER = 19;
+    public const FLOAT = 20;
+    public const STRING_DOUBLE_QUOTED = 21;
+    public const STRING_SINGLE_QUOTED = 22;
+    public const EEL_EXPRESSION = 23;
+    public const DSL_EXPRESSION_START = 24;
+    public const DSL_EXPRESSION_CONTENT = 25;
+    public const FILE_PATTERN = 26;
+    public const DOT = 27;
+    public const COLON = 28;
+    public const RPAREN = 29;
+    public const LBRACE = 30;
+    public const RBRACE = 31;
+    public function __construct(
+        protected int $type,
+        protected string $value,
+    ) {
+    }
+    public function getType(): int
+    {
+        return $this->type;
+    }
+    public function getValue(): string
+    {
+        return $this->value;
+    }
+    /**
+     * Returns the constant representation of a given type.
+     *
+     * @param int $type The type as an integer
+     *
+     * @return string The string representation
+     * @throws \LogicException
+     */
+    public static function typeToString(int $type): string
+    {
+        $stringRepresentation = array_search($type, static::getConstants(), true);
+        if ($stringRepresentation === false) {
+            throw new \LogicException("Token of type '$type' does not exist", 1637307344);
+        }
+        return $stringRepresentation;
+    }
+    /**
+     * @Flow\CompileStatic
+     */
+    protected static function getConstants()
+    {
+        $reflection = new \ReflectionClass(self::class);
+        return $reflection->getConstants();
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Parser.php
@@ -0,0 +1,106 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion;
+use Neos\Fusion\Core\Cache\ParserCache;
+use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
+use Neos\Fusion\Core\ObjectTreeParser\FilePatternResolver;
+use Neos\Fusion\Core\ObjectTreeParser\MergedArrayTree;
+use Neos\Fusion\Core\ObjectTreeParser\MergedArrayTreeVisitor;
+use Neos\Fusion\Core\ObjectTreeParser\ObjectTreeParser;
+use Neos\Flow\Annotations as Flow;
+/**
+ * The Fusion Parser
+ *
+ * @api
+ */
+class Parser implements ParserInterface
+{
+    /**
+     * Reserved parse tree keys for internal usage.
+     */
+    public static array $reservedParseTreeKeys = ['__meta', '__prototypes', '__stopInheritanceChain', '__prototypeObjectName', '__prototypeChain', '__value', '__objectType', '__eelExpression'];
+    /**
+     * @Flow\Inject
+     * @var DslFactory
+     */
+    protected $dslFactory;
+    /**
+     * @Flow\Inject
+     * @var ParserCache
+     */
+    protected $parserCache;
+    /**
+     * Parses the given Fusion source code, resolves includes and returns a merged array tree
+     * as the result.
+     *
+     * @param string $sourceCode The Fusion source code to parse
+     * @param string|null $contextPathAndFilename An optional path and filename used for relative Fusion file includes
+     * @param array $mergedArrayTreeUntilNow Used internally for keeping track of the built merged array tree
+     * @return array The merged array tree for the Fusion runtime, generated from the source code
+     * @throws Fusion\Exception
+     * @api
+     */
+    public function parse(string $sourceCode, ?string $contextPathAndFilename = null, array $mergedArrayTreeUntilNow = []): array
+    {
+        $fusionFile = $this->getFusionFile($sourceCode, $contextPathAndFilename);
+        $mergedArrayTree = new MergedArrayTree($mergedArrayTreeUntilNow);
+        $mergedArrayTree = $this->getMergedArrayTreeVisitor($mergedArrayTree)->visitFusionFile($fusionFile);
+        $mergedArrayTree->buildPrototypeHierarchy();
+        return $mergedArrayTree->getTree();
+    }
+    protected function handleFileInclude(MergedArrayTree $mergedArrayTree, string $filePattern, ?string $contextPathAndFilename): void
+    {
+        $filesToInclude = FilePatternResolver::resolveFilesByPattern($filePattern, $contextPathAndFilename, '.fusion');
+        foreach ($filesToInclude as $file) {
+            if (is_readable($file) === false) {
+                throw new Fusion\Exception("Could not read file '$file' of pattern '$filePattern'.", 1347977017);
+            }
+            if ($contextPathAndFilename === null
+                || stat($contextPathAndFilename) !== stat($file)) {
+                $fusionFile = $this->getFusionFile(file_get_contents($file), $file);
+                $this->getMergedArrayTreeVisitor($mergedArrayTree)->visitFusionFile($fusionFile);
+            }
+        }
+    }
+    protected function handleDslTranspile(string $identifier, string $code)
+    {
+        return $this->parserCache->cacheForDsl(
+            $identifier,
+            $code,
+            function () use ($identifier, $code) {
+                $dslObject = $this->dslFactory->create($identifier);
+                $transpiledFusion = $dslObject->transpile($code);
+                $fusionFile = ObjectTreeParser::parse('value = ' . $transpiledFusion);
+                $mergedArrayTree = $this->getMergedArrayTreeVisitor(new MergedArrayTree())->visitFusionFile($fusionFile);
+                $temporaryAst = $mergedArrayTree->getTree();
+                $dslValue = $temporaryAst['value'];
+                return $dslValue;
+            }
+        );
+    }
+    protected function getMergedArrayTreeVisitor(MergedArrayTree $mergedArrayTree): MergedArrayTreeVisitor
+    {
+        return new MergedArrayTreeVisitor(
+            $mergedArrayTree,
+            fn (...$args) => $this->handleFileInclude(...$args),
+            fn (...$args) => $this->handleDslTranspile(...$args)
+        );
+    }
+    protected function getFusionFile(string $sourceCode, ?string $contextPathAndFilename): FusionFile
+    {
+        return $this->parserCache->cacheForFusionFile(
+            $contextPathAndFilename,
+            fn () => ObjectTreeParser::parse($sourceCode, $contextPathAndFilename)
+        );
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/ParserInterface.php
@@ -0,0 +1,33 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Fusion\Core;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion;
+/**
+ * Contract for a Fusion parser
+ *
+ * @api
+ */
+interface ParserInterface
+{
+    /**
+     * Parses the given Fusion source code, resolves includes and returns a merged array tree
+     * as the result.
+     *
+     * @param string $sourceCode The Fusion source code to parse
+     * @param string|null $contextPathAndFilename An optional path and filename used for relative Fusion file includes
+     * @param array $mergedArrayTreeUntilNow Used internally for keeping track of the built merged array tree
+     * @return array The merged array tree for the Fusion runtime, generated from the source code
+     * @throws Fusion\Exception
+     * @api
+     */
+    public function parse(string $sourceCode, ?string $contextPathAndFilename = null, array $mergedArrayTreeUntilNow = []): array;
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Core/Runtime.php
@@ -0,0 +1,846 @@
+<?php
+namespace Neos\Fusion\Core;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Configuration\Exception\InvalidConfigurationException;
+use Neos\Flow\Mvc\Controller\ControllerContext;
+use Neos\Flow\Mvc\Exception\StopActionException;
+use Neos\Flow\ObjectManagement\ObjectManagerInterface;
+use Neos\Utility\Arrays;
+use Neos\Utility\ObjectAccess;
+use Neos\Utility\PositionalArraySorter;
+use Neos\Fusion\Core\Cache\RuntimeContentCache;
+use Neos\Fusion\Core\ExceptionHandlers\AbstractRenderingExceptionHandler;
+use Neos\Fusion\Exception as Exceptions;
+use Neos\Fusion\Exception;
+use Neos\Flow\Security\Exception as SecurityException;
+use Neos\Fusion\Exception\RuntimeException;
+use Neos\Fusion\FusionObjects\AbstractArrayFusionObject;
+use Neos\Fusion\FusionObjects\AbstractFusionObject;
+use Neos\Eel\Utility as EelUtility;
+/**
+ * Fusion Runtime
+ *
+ * Fusion Rendering Process
+ * ============================
+ *
+ * During rendering, all Fusion objects form a tree.
+ *
+ * When a Fusion object at a certain $fusionPath is invoked, it has
+ * access to all variables stored in the $context (which is an array).
+ *
+ * The Fusion object can then add or replace variables to this context using pushContext()
+ * or pushContextArray(), before rendering sub-Fusion objects. After rendering
+ * these, it must call popContext() to reset the context to the last state.
+ */
+class Runtime
+{
+    /**
+     * Internal constants defining how evaluate should work in case of an error
+     */
+    const BEHAVIOR_EXCEPTION = 'Exception';
+    const BEHAVIOR_RETURNNULL = 'NULL';
+    /**
+     * Internal constants defining a status of how evaluate was evaluated
+     */
+    const EVALUATION_EXECUTED = 'Executed';
+    const EVALUATION_SKIPPED = 'Skipped';
+    /**
+     * @var \Neos\Eel\CompilingEvaluator
+     * @Flow\Inject
+     */
+    protected $eelEvaluator;
+    /**
+     * @var ObjectManagerInterface
+     * @Flow\Inject
+     */
+    protected $objectManager;
+    /**
+     * Stack of evaluated "@context" values
+     *
+     * @var array
+     */
+    protected $contextStack = [];
+    /**
+     * Reference to the current context
+     *
+     * @var array
+     */
+    protected $currentContext = [];
+    /**
+     * Reference to the current apply value
+     *
+     * @var array
+     */
+    protected $currentApplyValues = [];
+    /**
+     * Default context with helper definitions
+     *
+     * @var array
+     */
+    protected $defaultContextVariables;
+    /**
+     * @var array
+     */
+    protected $runtimeConfiguration;
+    /**
+     * @var ControllerContext
+     */
+    protected $controllerContext;
+    /**
+     * @var array
+     */
+    protected $settings;
+    /**
+     * @var boolean
+     */
+    protected $debugMode = false;
+    /**
+     * @var RuntimeContentCache
+     */
+    protected $runtimeContentCache;
+    /**
+     * @var string
+     */
+    protected $lastEvaluationStatus;
+    /**
+     * Constructor for the Fusion Runtime
+     *
+     * @param array $fusionConfiguration
+     * @param ControllerContext $controllerContext
+     */
+    public function __construct(array $fusionConfiguration, ControllerContext $controllerContext)
+    {
+        $this->runtimeConfiguration = new RuntimeConfiguration($fusionConfiguration);
+        $this->controllerContext = $controllerContext;
+        $this->runtimeContentCache = new RuntimeContentCache($this);
+    }
+    /**
+     * Inject settings of this package
+     *
+     * @param array $settings The settings
+     * @return void
+     */
+    public function injectSettings(array $settings)
+    {
+        $this->settings = $settings;
+        if (isset($this->settings['debugMode'])) {
+            $this->setDebugMode($this->settings['debugMode'] === true);
+        }
+        if (isset($this->settings['enableContentCache'])) {
+            $this->setEnableContentCache($this->settings['enableContentCache'] === true);
+        }
+    }
+    /**
+     * Add a tag to the current cache segment
+     *
+     * During Fusion rendering the method can be used to add tag dynamicaly for the current cache segment.
+     *
+     * @param string $key
+     * @param string $value
+     * @return void
+     * @api
+     */
+    public function addCacheTag($key, $value)
+    {
+        if ($this->runtimeContentCache->getEnableContentCache() === false) {
+            return;
+        }
+        $this->runtimeContentCache->addTag($key, $value);
+    }
+    /**
+     * Completely replace the context array with the new $contextArray.
+     *
+     * Purely internal method, should not be called outside of Neos.Fusion.
+     *
+     * @param array $contextArray
+     * @return void
+     */
+    public function pushContextArray(array $contextArray)
+    {
+        $this->contextStack[] = $contextArray;
+        $this->currentContext = $contextArray;
+    }
+    /**
+     * Push a new context object to the rendering stack
+     *
+     * @param string $key the key inside the context
+     * @param mixed $context
+     * @return void
+     */
+    public function pushContext($key, $context)
+    {
+        $newContext = $this->currentContext;
+        $newContext[$key] = $context;
+        $this->contextStack[] = $newContext;
+        $this->currentContext = $newContext;
+    }
+    /**
+     * Remove the topmost context objects and return them
+     *
+     * @return array the topmost context objects as associative array
+     */
+    public function popContext()
+    {
+        $lastItem = array_pop($this->contextStack);
+        $this->currentContext = empty($this->contextStack) ? [] : end($this->contextStack);
+        return $lastItem;
+    }
+    /**
+     * Get the current context array
+     *
+     * @return array the array of current context objects
+     */
+    public function getCurrentContext()
+    {
+        return $this->currentContext;
+    }
+    public function popApplyValues(array $paths): void
+    {
+        foreach ($paths as $path) {
+            unset($this->currentApplyValues[$path]);
+        }
+    }
+    /**
+     * @return string
+     */
+    public function getLastEvaluationStatus()
+    {
+        return $this->lastEvaluationStatus;
+    }
+    /**
+     * Render an absolute Fusion path and return the result.
+     *
+     * Compared to $this->evaluate, this adds some more comments helpful for debugging.
+     *
+     * @param string $fusionPath
+     * @return mixed
+     * @throws \Exception
+     * @throws SecurityException
+     */
+    public function render($fusionPath)
+    {
+        try {
+            $output = $this->evaluate($fusionPath, null, self::BEHAVIOR_EXCEPTION);
+            if ($this->debugMode) {
+                $output = sprintf(
+                    '%1$s<!-- Beginning to render Fusion path "%2$s" (Context: %3$s) -->%4$s%1$s<!-- End to render Fusion path "%2$s" (Context: %3$s) -->',
+                    chr(10),
+                    $fusionPath,
+                    implode(', ', array_keys($this->currentContext)),
+                    $output
+                );
+            }
+        } catch (SecurityException $securityException) {
+            throw $securityException;
+        } catch (\Exception $exception) {
+            $output = $this->handleRenderingException($fusionPath, $exception);
+        }
+        return $output;
+    }
+    /**
+     * Handle an Exception thrown while rendering Fusion according to
+     * settings specified in Neos.Fusion.rendering.exceptionHandler
+     *
+     * @param string $fusionPath
+     * @param \Exception $exception
+     * @param boolean $useInnerExceptionHandler
+     * @return string
+     * @throws Exception
+     * @throws InvalidConfigurationException
+     * @throws SecurityException
+     * @throws StopActionException
+     */
+    public function handleRenderingException($fusionPath, \Exception $exception, $useInnerExceptionHandler = false)
+    {
+        $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
+        if (isset($fusionConfiguration['__meta']['exceptionHandler'])) {
+            $exceptionHandlerClass = $fusionConfiguration['__meta']['exceptionHandler'];
+            $invalidExceptionHandlerMessage = 'The class "%s" is not valid for property "@exceptionHandler".';
+        } else {
+            if ($useInnerExceptionHandler === true) {
+                $exceptionHandlerClass = $this->settings['rendering']['innerExceptionHandler'];
+            } else {
+                $exceptionHandlerClass = $this->settings['rendering']['exceptionHandler'];
+            }
+            $invalidExceptionHandlerMessage = 'The class "%s" is not valid for setting "Neos.Fusion.rendering.exceptionHandler".';
+        }
+        $exceptionHandler = null;
+        if ($this->objectManager->isRegistered($exceptionHandlerClass)) {
+            $exceptionHandler = $this->objectManager->get($exceptionHandlerClass);
+        }
+        if ($exceptionHandler === null || !($exceptionHandler instanceof AbstractRenderingExceptionHandler)) {
+            $message = sprintf(
+                $invalidExceptionHandlerMessage . "\n" .
+                'Please specify a fully qualified classname to a subclass of %2$s\AbstractRenderingExceptionHandler.' . "\n" .
+                'You might implement an own handler or use one of the following:' . "\n" .
+                '%2$s\AbsorbingHandler' . "\n" .
+                '%2$s\HtmlMessageHandler' . "\n" .
+                '%2$s\PlainTextHandler' . "\n" .
+                '%2$s\ThrowingHandler' . "\n" .
+                '%2$s\XmlCommentHandler',
+                $exceptionHandlerClass,
+                'Neos\Fusion\Core\ExceptionHandlers'
+            );
+            throw new InvalidConfigurationException($message, 1368788926);
+        }
+        $exceptionHandler->setRuntime($this);
+        if (array_key_exists('__objectType', $fusionConfiguration)) {
+            $fusionPath .= sprintf('<%s>', $fusionConfiguration['__objectType']);
+        }
+        $output = $exceptionHandler->handleRenderingException($fusionPath, $exception);
+        return $output;
+    }
+    /**
+     * Determine if the given Fusion path is renderable, which means it exists
+     * and has an implementation.
+     *
+     * @param string $fusionPath
+     * @return boolean
+     * @throws Exception
+     */
+    public function canRender($fusionPath)
+    {
+        $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
+        if (isset($fusionConfiguration['__eelExpression']) || isset($fusionConfiguration['__value'])) {
+            return true;
+        }
+        if (isset($fusionConfiguration['__meta']['class']) && isset($fusionConfiguration['__objectType'])) {
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Evaluate an absolute Fusion path and return the result
+     *
+     * @param string $fusionPath
+     * @param mixed $contextObject The object which will be "this" in Eel expressions. ONLY FOR INTERNAL USE!
+     * @param string $behaviorIfPathNotFound One of BEHAVIOR_EXCEPTION or BEHAVIOR_RETURNNULL
+     * @return mixed
+     *
+     * @throws StopActionException
+     * @throws SecurityException
+     * @throws Exception
+     * @throws RuntimeException
+     * @throws InvalidConfigurationException
+     */
+    public function evaluate(string $fusionPath, $contextObject = null, string $behaviorIfPathNotFound = self::BEHAVIOR_RETURNNULL)
+    {
+        $needToPopContext = false;
+        $needToPopApply = false;
+        $this->lastEvaluationStatus = self::EVALUATION_EXECUTED;
+        $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
+        if (isset($this->currentApplyValues[$fusionPath])) {
+            if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $contextObject) === false) {
+                return null;
+            }
+            $appliedValue = $this->currentApplyValues[$fusionPath]['value'];
+            if (isset($this->currentApplyValues[$fusionPath]['lazy'])) {
+                $appliedValue = $appliedValue();
+            }
+            if (isset($fusionConfiguration['__meta']['process'])) {
+                $appliedValue = $this->evaluateProcessors($appliedValue, $fusionConfiguration, $fusionPath, $contextObject);
+            }
+            return $appliedValue;
+        }
+        try {
+            if (isset($fusionConfiguration['__eelExpression']) || isset($fusionConfiguration['__value'])) {
+                return $this->evaluateExpressionOrValueInternal($fusionPath, $fusionConfiguration, $contextObject);
+            }
+        } catch (StopActionException $stopActionException) {
+            throw $stopActionException;
+        } catch (SecurityException $securityException) {
+            throw $securityException;
+        } catch (RuntimeException $runtimeException) {
+            throw $runtimeException;
+        } catch (\Exception $exception) {
+            return $this->handleRenderingException($fusionPath, $exception, true);
+        }
+        $cacheContext = $this->runtimeContentCache->enter(isset($fusionConfiguration['__meta']['cache']) ? $fusionConfiguration['__meta']['cache'] : [], $fusionPath);
+        if (!(isset($fusionConfiguration['__meta']['class']) && isset($fusionConfiguration['__objectType']))) {
+            $this->finalizePathEvaluation($cacheContext);
+            $this->throwExceptionForUnrenderablePathIfNeeded($fusionPath, $fusionConfiguration, $behaviorIfPathNotFound);
+            $this->lastEvaluationStatus = self::EVALUATION_SKIPPED;
+            return null;
+        }
+        $applyPathsToPop = [];
+        try {
+            $applyPathsToPop = $this->prepareApplyValuesForFusionPath($fusionPath, $fusionConfiguration);
+            $fusionObject = $this->instantiatefusionObject($fusionPath, $fusionConfiguration, $applyPathsToPop);
+            $needToPopContext = $this->prepareContextForFusionObject($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext);
+            $output = $this->evaluateObjectOrRetrieveFromCache($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext);
+        } catch (StopActionException $stopActionException) {
+            $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
+            throw $stopActionException;
+        } catch (SecurityException $securityException) {
+            $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
+            throw $securityException;
+        } catch (RuntimeException $runtimeException) {
+            $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
+            throw $runtimeException;
+        } catch (\Exception $exception) {
+            $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
+            return $this->handleRenderingException($fusionPath, $exception, true);
+        }
+        $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
+        return $output;
+    }
+    /**
+     * Does the evaluation of a Fusion instance, first checking the cache and if conditions and afterwards applying processors.
+     *
+     * @param AbstractFusionObject $fusionObject
+     * @param string $fusionPath
+     * @param array $fusionConfiguration
+     * @param array $cacheContext
+     * @return mixed
+     */
+    protected function evaluateObjectOrRetrieveFromCache($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext)
+    {
+        $output = null;
+        $evaluationStatus = self::EVALUATION_SKIPPED;
+        list($cacheHit, $cachedResult) = $this->runtimeContentCache->preEvaluate($cacheContext, $fusionObject);
+        if ($cacheHit) {
+            return $cachedResult;
+        }
+        $evaluateObject = true;
+        if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $fusionObject) === false) {
+            $evaluateObject = false;
+        }
+        if ($evaluateObject) {
+            $output = $fusionObject->evaluate();
+            $evaluationStatus = self::EVALUATION_EXECUTED;
+        }
+        $this->lastEvaluationStatus = $evaluationStatus;
+        if ($evaluateObject && isset($fusionConfiguration['__meta']['process'])) {
+            $output = $this->evaluateProcessors($output, $fusionConfiguration, $fusionPath, $fusionObject);
+        }
+        $output = $this->runtimeContentCache->postProcess($cacheContext, $fusionObject, $output);
+        return $output;
+    }
+    /**
+     * Evaluates an EEL expression or value, checking if conditions first and applying processors.
+     *
+     * @param string $fusionPath the Fusion path up to now
+     * @param array $fusionConfiguration Fusion configuration for the expression or value
+     * @param \Neos\Fusion\FusionObjects\AbstractFusionObject $contextObject An optional object for the "this" value inside the context
+     * @return mixed The result of the evaluation
+     * @throws Exception
+     */
+    protected function evaluateExpressionOrValueInternal($fusionPath, $fusionConfiguration, $contextObject)
+    {
+        if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $contextObject) === false) {
+            $this->lastEvaluationStatus = self::EVALUATION_SKIPPED;
+            return null;
+        }
+        if (isset($fusionConfiguration['__eelExpression'])) {
+            $evaluatedValue = $this->evaluateEelExpression($fusionConfiguration['__eelExpression'], $contextObject);
+        } else {
+            $evaluatedValue = $fusionConfiguration['__value'];
+        }
+        if (isset($fusionConfiguration['__meta']['process'])) {
+            $evaluatedValue = $this->evaluateProcessors($evaluatedValue, $fusionConfiguration, $fusionPath, $contextObject);
+        }
+        return $evaluatedValue;
+    }
+    /**
+     * Possibly prepares a new "@apply" context for the current fusionPath and pushes it to the stack.
+     * Returns true to express that new properties were pushed and have to be popped during finalizePathEvaluation.
+     *
+     * Since "@apply" are not inherited every call of this method leads to a completely new  "@apply"
+     * context, which is null by default.
+     *
+     * @param string $fusionPath
+     * @param array $fusionConfiguration
+     * @return array Paths to pop
+     * @throws Exception
+     * @throws RuntimeException
+     * @throws SecurityException
+     * @throws StopActionException
+     */
+    protected function prepareApplyValuesForFusionPath($fusionPath, $fusionConfiguration): array
+    {
+        $spreadValues = $this->evaluateApplyValues($fusionConfiguration, $fusionPath);
+        if ($spreadValues === null) {
+            return [];
+        }
+        foreach ($spreadValues as $path => $entry) {
+            $this->currentApplyValues[$path] = $entry;
+        }
+        return array_keys($spreadValues);
+    }
+    /**
+     * Possibly prepares a new context for the current FusionObject and cache context and pushes it to the stack.
+     * Returns if a new context was pushed to the stack or not.
+     *
+     * @param AbstractFusionObject $fusionObject
+     * @param string $fusionPath
+     * @param array $fusionConfiguration
+     * @param array $cacheContext
+     * @return boolean
+     * @throws Exception
+     * @throws RuntimeException
+     * @throws SecurityException
+     * @throws StopActionException
+     */
+    protected function prepareContextForFusionObject(AbstractFusionObject $fusionObject, $fusionPath, $fusionConfiguration, $cacheContext)
+    {
+        if ($cacheContext['cacheForPathDisabled'] === true) {
+            $newContextArray = [];
+            foreach ($cacheContext['configuration']['context'] as $contextVariableName) {
+                if (isset($this->currentContext[$contextVariableName])) {
+                    $newContextArray[$contextVariableName] = $this->currentContext[$contextVariableName];
+                }
+            }
+        }
+        if (isset($fusionConfiguration['__meta']['context'])) {
+            $newContextArray = isset($newContextArray) ? $newContextArray : $this->currentContext;
+            foreach ($fusionConfiguration['__meta']['context'] as $contextKey => $contextValue) {
+                $newContextArray[$contextKey] = $this->evaluate($fusionPath . '/__meta/context/' . $contextKey, $fusionObject, self::BEHAVIOR_EXCEPTION);
+            }
+        }
+        if (isset($newContextArray)) {
+            $this->pushContextArray($newContextArray);
+            return true;
+        }
+        return false;
+    }
+    /**
+     * Ends the evaluation of a fusion path by popping the context and property stack if needed and leaving the cache context.
+     *
+     * @param array $cacheContext
+     * @param boolean $needToPopContext
+     * @param array $applyPathsToPop
+     * @return void
+     */
+    protected function finalizePathEvaluation($cacheContext, $needToPopContext = false, array $applyPathsToPop = [])
+    {
+        if ($needToPopContext) {
+            $this->popContext();
+        }
+        if ($applyPathsToPop !== []) {
+            $this->popApplyValues($applyPathsToPop);
+        }
+        $this->runtimeContentCache->leave($cacheContext);
+    }
+    /**
+     * Instantiates a Fusion object specified by the given path and configuration
+     *
+     * @param string $fusionPath Path to the configuration for this object instance
+     * @param array $fusionConfiguration Configuration at the given path
+     * @param array $applyValuePaths Apply value paths for this object
+     * @return AbstractFusionObject
+     * @throws Exception
+     */
+    protected function instantiateFusionObject($fusionPath, $fusionConfiguration, array $applyValuePaths)
+    {
+        $fusionObjectType = $fusionConfiguration['__objectType'];
+        $fusionObjectClassName = isset($fusionConfiguration['__meta']['class']) ? $fusionConfiguration['__meta']['class'] : null;
+        if (!preg_match('#<[^>]*>$#', $fusionPath)) {
+            $fusionPath .= '<' . $fusionObjectType . '>';
+        }
+        if (!class_exists($fusionObjectClassName)) {
+            throw new Exception(sprintf(
+                'The implementation class `%s` defined for Fusion object of type `%s` does not exist.
+				Maybe a typo in the `@class` property.',
+                $fusionObjectClassName,
+                $fusionObjectType
+            ), 1347952109);
+        }
+        /** @var $fusionObject AbstractFusionObject */
+        $fusionObject = new $fusionObjectClassName($this, $fusionPath, $fusionObjectType);
+        if ($this->isArrayFusionObject($fusionObject)) {
+            /** @var $fusionObject AbstractArrayFusionObject */
+            if (isset($fusionConfiguration['__meta']['ignoreProperties'])) {
+                $evaluatedIgnores = $this->evaluate($fusionPath . '/__meta/ignoreProperties', $fusionObject);
+                $fusionObject->setIgnoreProperties(is_array($evaluatedIgnores) ? $evaluatedIgnores : []);
+            }
+            $this->setPropertiesOnFusionObject($fusionObject, $fusionConfiguration, $applyValuePaths);
+        }
+        return $fusionObject;
+    }
+    /**
+     * Check if the given object is an array like object that should get all properties set to iterate or process internally.
+     *
+     * @param AbstractFusionObject $fusionObject
+     * @return boolean
+     */
+    protected function isArrayFusionObject(AbstractFusionObject $fusionObject)
+    {
+        return ($fusionObject instanceof AbstractArrayFusionObject);
+    }
+    /**
+     * Set options on the given (AbstractArray)Fusion object
+     *
+     * @param AbstractArrayFusionObject $fusionObject
+     * @param array $fusionConfiguration
+     * @param array $applyValuePaths
+     * @return void
+     */
+    protected function setPropertiesOnFusionObject(AbstractArrayFusionObject $fusionObject, array $fusionConfiguration, array $applyValuePaths)
+    {
+        foreach ($fusionConfiguration as $key => $value) {
+            if (is_string($key) && $key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
+                continue;
+            }
+            ObjectAccess::setProperty($fusionObject, $key, $value);
+        }
+        if ($applyValuePaths !== []) {
+            foreach ($applyValuePaths as $path) {
+                $entry = $this->currentApplyValues[$path];
+                $key = $entry['key'];
+                if (isset($entry['lazy'])) {
+                    $valueAst = [
+                        '__eelExpression' => null,
+                        '__objectType' => 'Neos.Fusion:Lazy',
+                        '__value' => null
+                    ];
+                } else {
+                    $valueAst = [
+                        '__eelExpression' => null,
+                        '__objectType' => null,
+                        '__value' => $entry['value']
+                    ];
+                }
+                if ($meta = Arrays::getValueByPath($fusionConfiguration, [$key, '__meta'])) {
+                    $valueAst['__meta'] = $meta;
+                }
+                ObjectAccess::setProperty($fusionObject, $entry['key'], $valueAst);
+            }
+        }
+    }
+    /**
+     * Evaluate an Eel expression
+     *
+     * @param string $expression The Eel expression to evaluate
+     * @param \Neos\Fusion\FusionObjects\AbstractFusionObject $contextObject An optional object for the "this" value inside the context
+     * @return mixed The result of the evaluated Eel expression
+     * @throws Exception
+     */
+    protected function evaluateEelExpression($expression, AbstractFusionObject $contextObject = null)
+    {
+        if ($expression[0] !== '$' || $expression[1] !== '{') {
+            $expression = '${' . $expression . '}';
+        }
+        $contextVariables = array_merge($this->getDefaultContextVariables(), $this->currentContext);
+        if (isset($contextVariables['this'])) {
+            throw new Exception('Context variable "this" not allowed, as it is already reserved for a pointer to the current Fusion object.', 1344325044);
+        }
+        $contextVariables['this'] = $contextObject;
+        if ($this->eelEvaluator instanceof \Neos\Flow\ObjectManagement\DependencyInjection\DependencyProxy) {
+            $this->eelEvaluator->_activateDependency();
+        }
+        return EelUtility::evaluateEelExpression($expression, $this->eelEvaluator, $contextVariables);
+    }
+    /**
+     * Evaluate "@apply" for the given fusion key.
+     *
+     * If apply-definitions are found they are evaluated and the returned keys are combined.
+     * The result is returned as array with the following structure:
+     *
+     * [
+     *    'fusionPath/key_1' => ['key' => 'key_1', 'value' => 'evaluated value 1'],
+     *    'fusionPath/key_2' => ['key' => 'key_2', 'value' => 'evaluated value 2']
+     * ]
+     *
+     * If no apply-expression is defined null is returned instead.
+     *
+     * @param array $configurationWithEventualProperties
+     * @param string $fusionPath
+     * @return array|null
+     */
+    protected function evaluateApplyValues($configurationWithEventualProperties, $fusionPath): ?array
+    {
+        if (isset($configurationWithEventualProperties['__meta']['apply'])) {
+            $fusionObjectType = $configurationWithEventualProperties['__objectType'];
+            if (!preg_match('#<[^>]*>$#', $fusionPath)) {
+                $fusionPath .= '<' . $fusionObjectType . '>';
+            }
+            $combinedApplyValues = [];
+            $propertiesConfiguration = $configurationWithEventualProperties['__meta']['apply'];
+            $positionalArraySorter = new PositionalArraySorter($propertiesConfiguration, '__meta.position');
+            foreach ($positionalArraySorter->getSortedKeys() as $key) {
+                if ($key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
+                    continue;
+                }
+                $singleApplyPath = $fusionPath . '/__meta/apply/' . $key;
+                if (isset($propertiesConfiguration[$key]['__meta']['if']) && $this->evaluateIfCondition($propertiesConfiguration[$key], $singleApplyPath) === false) {
+                    continue;
+                }
+                if (isset($propertiesConfiguration[$key]['expression'])) {
+                    $singleApplyPath .= '/expression';
+                }
+                $singleApplyValues = $this->evaluate($singleApplyPath, null, self::BEHAVIOR_EXCEPTION);
+                if ($this->getLastEvaluationStatus() !== static::EVALUATION_SKIPPED) {
+                    if ($singleApplyValues === null) {
+                        continue;
+                    } elseif (is_array($singleApplyValues)) {
+                        foreach ($singleApplyValues as $key => $value) {
+                            if ($key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
+                                continue;
+                            }
+                            $combinedApplyValues[$fusionPath . '/' . $key] = [
+                                'key' => $key,
+                                'value' => $value
+                            ];
+                        }
+                    } elseif ($singleApplyValues instanceof \Traversable && $singleApplyValues instanceof \ArrayAccess) {
+                        for ($singleApplyValues->rewind(); ($key = $singleApplyValues->key()) !== null; $singleApplyValues->next()) {
+                            $combinedApplyValues[$fusionPath . '/' . $key] = [
+                                'key' => $key,
+                                'value' => function () use ($singleApplyValues, $key) {
+                                    return $singleApplyValues[$key];
+                                },
+                                'lazy' => true
+                            ];
+                        }
+                    }
+                }
+            }
+            return $combinedApplyValues;
+        }
+        return null;
+    }
+    /**
+     * Evaluate processors on given value.
+     *
+     * @param mixed $valueToProcess
+     * @param array $configurationWithEventualProcessors
+     * @param string $fusionPath
+     * @param AbstractFusionObject $contextObject
+     * @return mixed
+     */
+    protected function evaluateProcessors($valueToProcess, $configurationWithEventualProcessors, $fusionPath, AbstractFusionObject $contextObject = null)
+    {
+        $processorConfiguration = $configurationWithEventualProcessors['__meta']['process'];
+        $positionalArraySorter = new PositionalArraySorter($processorConfiguration, '__meta.position');
+        foreach ($positionalArraySorter->getSortedKeys() as $key) {
+            $processorPath = $fusionPath . '/__meta/process/' . $key;
+            if (isset($processorConfiguration[$key]['__meta']['if']) && $this->evaluateIfCondition($processorConfiguration[$key], $processorPath, $contextObject) === false) {
+                continue;
+            }
+            if (count($processorConfiguration[$key]) === 1 && isset($processorConfiguration[$key]['__stopInheritanceChain'])) {
+                continue;
+            }
+            if (isset($processorConfiguration[$key]['expression'])) {
+                $processorPath .= '/expression';
+            }
+            $this->pushContext('value', $valueToProcess);
+            $result = $this->evaluate($processorPath, $contextObject, self::BEHAVIOR_EXCEPTION);
+            if ($this->getLastEvaluationStatus() !== static::EVALUATION_SKIPPED) {
+                $valueToProcess = $result;
+            }
+            $this->popContext();
+        }
+        return $valueToProcess;
+    }
+    /**
+     * Evaluate eventually existing meta "@if" conditionals inside the given configuration and path.
+     *
+     * @param array $configurationWithEventualIf
+     * @param string $configurationPath
+     * @param AbstractFusionObject $contextObject
+     * @return boolean
+     */
+    protected function evaluateIfCondition($configurationWithEventualIf, $configurationPath, AbstractFusionObject $contextObject = null)
+    {
+        foreach ($configurationWithEventualIf['__meta']['if'] as $conditionKey => $conditionValue) {
+            $conditionValue = $this->evaluate($configurationPath . '/__meta/if/' . $conditionKey, $contextObject, self::BEHAVIOR_EXCEPTION);
+            if ((bool)$conditionValue === false) {
+                return false;
+            }
+        }
+        return true;
+    }
+    /**
+     * Returns the context which has been passed by the currently active MVC Controller
+     *
+     * @return ControllerContext
+     */
+    public function getControllerContext()
+    {
+        return $this->controllerContext;
+    }
+    /**
+     * Get variables from configuration that should be set in the context by default.
+     * For example Eel helpers are made available by this.
+     *
+     * @return array Array with default context variable objects.
+     */
+    protected function getDefaultContextVariables()
+    {
+        if ($this->defaultContextVariables === null) {
+            $this->defaultContextVariables = [];
+            if (isset($this->settings['defaultContext']) && is_array($this->settings['defaultContext'])) {
+                $this->defaultContextVariables = EelUtility::getDefaultContextVariables($this->settings['defaultContext']);
+            }
+            $this->defaultContextVariables['request'] = $this->controllerContext->getRequest();
+        }
+        return $this->defaultContextVariables;
+    }
+    /**
+     * Checks and throws an exception for an unrenderable path.
+     *
+     * @param string $fusionPath The Fusion path that cannot be rendered
+     * @param array $fusionConfiguration
+     * @param string $behaviorIfPathNotFound One of the BEHAVIOR_* constants
+     * @throws Exception\MissingFusionImplementationException
+     * @throws Exception\MissingFusionObjectException
+     */
+    protected function throwExceptionForUnrenderablePathIfNeeded($fusionPath, $fusionConfiguration, $behaviorIfPathNotFound)
+    {
+        if (isset($fusionConfiguration['__objectType'])) {
+            $objectType = $fusionConfiguration['__objectType'];
+            throw new Exceptions\MissingFusionImplementationException(sprintf(
+                "The Fusion object `%s` cannot be rendered:
+					Most likely you mistyped the prototype name or did not define 
+					the Fusion prototype with `prototype(%s) < prototype ...` . 
+					Other possible reasons are a missing parent-prototype or 
+					a missing `@class` annotation for prototypes without parent.
+					It is also possible your Fusion file is not read because 
+					of a missing `include:` statement.",
+                $objectType,
+                $objectType
+            ), 1332493995);
+        }
+        if ($behaviorIfPathNotFound === self::BEHAVIOR_EXCEPTION) {
+            throw new Exceptions\MissingFusionObjectException(sprintf(
+                'No Fusion object found in path "%s"
+					Please make sure to define one in your Fusion configuration.',
+                $fusionPath
+            ), 1332493990);
+        }
+    }
+    /**
+     * @param boolean $debugMode
+     * @return void
+     */
+    public function setDebugMode($debugMode)
+    {
+        $this->debugMode = $debugMode;
+    }
+    /**
+     * @return boolean
+     */
+    public function isDebugMode()
+    {
+        return $this->debugMode;
+    }
+    /**
+     * If the Fusion content cache should be enabled at all
+     *
+     * @param boolean $flag
+     * @return void
+     */
+    public function setEnableContentCache($flag)
+    {
+        $this->runtimeContentCache->setEnableContentCache($flag);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/AbstractArrayFusionObject.php
@@ -0,0 +1,155 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Utility\Exception\InvalidPositionException;
+use Neos\Utility\PositionalArraySorter;
+use Neos\Fusion\Exception as FusionException;
+use Neos\Fusion\Core\Runtime;
+/**
+ * Base class for Fusion objects that need access to arbitrary properties, like DataStructureImplementation.
+ */
+abstract class AbstractArrayFusionObject extends AbstractFusionObject implements \ArrayAccess
+{
+    /**
+     * List of properties which have been set using array access. We store this for *every* Fusion object
+     * in order to do things like:
+     * x = Foo {
+     *   a = 'foo'
+     *   b = ${this.a + 'bar'}
+     * }
+     *
+     * @var array
+     * @internal
+     */
+    protected $properties = [];
+    /**
+     * If you iterate over "properties" these in here should usually be ignored. For example additional properties in "Case" that are not "Matchers".
+     *
+     * @var array
+     */
+    protected $ignoreProperties = [];
+    /**
+     * @param array $ignoreProperties
+     * @return void
+     */
+    public function setIgnoreProperties($ignoreProperties = [])
+    {
+        $this->ignoreProperties = $ignoreProperties;
+    }
+    /**
+     * @param mixed $offset
+     * @return boolean
+     */
+    public function offsetExists($offset): bool
+    {
+        return isset($this->properties[$offset]);
+    }
+    /**
+     * @param mixed $offset
+     * @return mixed
+     */
+    public function offsetGet($offset): mixed
+    {
+        return $this->fusionValue($offset);
+    }
+    /**
+     * @param mixed $offset
+     * @param mixed $value
+     * @return void
+     */
+    public function offsetSet($offset, $value): void
+    {
+        $this->properties[$offset] = $value;
+    }
+    /**
+     * @param mixed $offset
+     * @return void
+     */
+    public function offsetUnset($offset): void
+    {
+        unset($this->properties[$offset]);
+    }
+    /**
+     * @param string|null $defaultFusionPrototypeName
+     * @return array
+     * @throws FusionException
+     * @throws \Neos\Flow\Configuration\Exception\InvalidConfigurationException
+     * @throws \Neos\Flow\Mvc\Exception\StopActionException
+     * @throws \Neos\Flow\Security\Exception
+     */
+    protected function evaluateNestedProperties(?string $defaultFusionPrototypeName = null): array
+    {
+        $sortedChildFusionKeys = $this->sortNestedProperties();
+        if (count($sortedChildFusionKeys) === 0) {
+            return [];
+        }
+        $result = [];
+        foreach ($sortedChildFusionKeys as $key) {
+            $propertyPath = $key;
+            if ($defaultFusionPrototypeName !== null && $this->isUntyped($key)) {
+                $propertyPath .= '<' . $defaultFusionPrototypeName . '>';
+            }
+            try {
+                $value = $this->fusionValue($propertyPath);
+            } catch (\Exception $e) {
+                $value = $this->runtime->handleRenderingException($this->path . '/' . $key, $e);
+            }
+            if ($value === null && $this->runtime->getLastEvaluationStatus() === Runtime::EVALUATION_SKIPPED) {
+                continue;
+            }
+            $result[$key] = $value;
+        }
+        return $result;
+    }
+    /**
+     * Sort the Fusion objects inside $this->properties depending on:
+     * - numerical ordering
+     * - position meta-property
+     *
+     * This will ignore all properties defined in "@ignoreProperties" in Fusion
+     *
+     * @see PositionalArraySorter
+     *
+     * @return array an ordered list of key value pairs
+     * @throws FusionException if the positional string has an unsupported format
+     */
+    protected function sortNestedProperties(): array
+    {
+        $arraySorter = new PositionalArraySorter($this->properties, '__meta.position');
+        try {
+            $sortedFusionKeys = $arraySorter->getSortedKeys();
+        } catch (InvalidPositionException $exception) {
+            throw new FusionException('Invalid position string', 1345126502, $exception);
+        }
+        foreach ($this->ignoreProperties as $ignoredPropertyName) {
+            $key = array_search($ignoredPropertyName, $sortedFusionKeys);
+            if ($key !== false) {
+                unset($sortedFusionKeys[$key]);
+            }
+        }
+        return $sortedFusionKeys;
+    }
+    /**
+     * Returns TRUE if the given fusion key has no type, meaning neither
+     * having a fusion objectType, eelExpression or value
+     *
+     * @param string|int $key fusion child key path to check
+     * @return bool
+     */
+    protected function isUntyped(string|int $key): bool
+    {
+        $property = $this->properties[$key];
+        if (!is_array($property)) {
+            return false;
+        }
+        return !isset($property['__objectType']) && !isset($property['__eelExpression']) && !isset($property['__value']);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/AbstractFusionObject.php
@@ -0,0 +1,122 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Core\Runtime;
+/**
+ * Base class for all Fusion objects
+ */
+abstract class AbstractFusionObject implements \ArrayAccess
+{
+    /**
+     * @var Runtime
+     */
+    protected $runtime;
+    /**
+     * The Fusion path currently being rendered
+     *
+     * @var string
+     */
+    protected $path;
+    /**
+     * Name of this Fusion object, like Neos.Neos:Text
+     *
+     * @var string
+     */
+    protected $fusionObjectName;
+    /**
+     * @var array
+     */
+    protected $fusionValueCache = [];
+    /**
+     * Constructor
+     *
+     * @param Runtime $runtime
+     * @param string $path
+     * @param string $fusionObjectName
+     */
+    public function __construct(Runtime $runtime, $path, $fusionObjectName)
+    {
+        $this->runtime = $runtime;
+        $this->path = $path;
+        $this->fusionObjectName = $fusionObjectName;
+    }
+    /**
+     * Evaluate this Fusion object and return the result
+     *
+     * @return mixed
+     */
+    abstract public function evaluate();
+    /**
+     * Get the Fusion runtime this object was created in.
+     *
+     * @return Runtime
+     */
+    public function getRuntime()
+    {
+        return $this->runtime;
+    }
+    /**
+     * Return the Fusion value relative to this Fusion object (with processors etc applied).
+     *
+     * Note that subsequent calls of fusionValue() with the same Fusion path will return the same values since the
+     * first evaluated value will be cached in memory.
+     *
+     * @param string $path
+     * @return mixed
+     */
+    protected function fusionValue($path)
+    {
+        $fullPath = $this->path . '/' . $path;
+        if (!isset($this->fusionValueCache[$fullPath])) {
+            $this->fusionValueCache[$fullPath] = $this->runtime->evaluate($fullPath, $this);
+        }
+        return $this->fusionValueCache[$fullPath];
+    }
+    /**
+     * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
+     *
+     * @param mixed $offset
+     * @return boolean
+     */
+    public function offsetExists($offset): bool
+    {
+        return ($this->fusionValue($offset) !== null);
+    }
+    /**
+     * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
+     *
+     * @param mixed $offset
+     * @return mixed
+     */
+    public function offsetGet($offset): mixed
+    {
+        return $this->fusionValue($offset);
+    }
+    /**
+     * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
+     *
+     * @param mixed $offset
+     * @param mixed $value
+     * @return void
+     */
+    public function offsetSet($offset, $value): void
+    {
+    }
+    /**
+     * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
+     *
+     * @param mixed $offset
+     * @return void
+     */
+    public function offsetUnset($offset): void
+    {
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/AugmenterImplementation.php
@@ -0,0 +1,48 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Service\HtmlAugmenter;
+/**
+ * A Fusion Augmenter-Object
+ *
+ * The fusion object can be used to add html-attributes to the rendererd content
+ *
+ * @api
+ */
+class AugmenterImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * @var HtmlAugmenter
+     * @Flow\Inject
+     */
+    protected $htmlAugmenter;
+    /**
+     * Properties that are ignored
+     *
+     * @var array
+     */
+    protected $ignoreProperties = ['__meta', 'fallbackTagName', 'content'];
+    /**
+     * @return void|string
+     */
+    public function evaluate()
+    {
+        $content = $this->fusionValue('content');
+        $fallbackTagName = $this->fusionValue('fallbackTagName');
+        $attributes = $this->evaluateNestedProperties();
+        if ($attributes && is_array($attributes) && count($attributes) > 0) {
+            return $this->htmlAugmenter->addAttributes($content, $attributes, $fallbackTagName);
+        } else {
+            return $content;
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/CaseImplementation.php
@@ -0,0 +1,92 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Exception\UnsupportedObjectTypeAtPathException;
+/**
+ * Case Fusion Object
+ *
+ * The "case" Fusion object renders its children in order. The first
+ * result which is not MATCH_NORESULT is returned.
+ *
+ * Often, this Fusion object is used together with the "Matcher" Fusion
+ * object; and all its children are by-default interpreted as "Matcher" Fusion
+ * objects if no others are specified.
+ */
+class CaseImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * This constant should be returned by individual matchers if the matcher
+     * did not match.
+     *
+     * You should not rely on the contents or type of this constant.
+     */
+    const MATCH_NORESULT = '_____________NO_MATCH_RESULT_____________';
+    /**
+     * Execute each matcher until the first one matches
+     *
+     * @return mixed
+     */
+    public function evaluate()
+    {
+        $matcherKeys = $this->sortNestedProperties();
+        foreach ($matcherKeys as $matcherName) {
+            $renderedMatcher = $this->renderMatcher($matcherName);
+            if ($this->matcherMatched($renderedMatcher)) {
+                return $renderedMatcher;
+            }
+        }
+        return null;
+    }
+    /**
+     * Render the given matcher
+     *
+     * A result value of MATCH_NORESULT means that the condition of the matcher did not match and the case should
+     * continue.
+     *
+     * @param string $matcherKey
+     * @return string
+     * @throws UnsupportedObjectTypeAtPathException
+     */
+    protected function renderMatcher($matcherKey)
+    {
+        $renderedMatcher = null;
+        if (isset($this->properties[$matcherKey]['__objectType'])) {
+            $renderedMatcher = $this->runtime->render(
+                sprintf('%s/%s', $this->path, $matcherKey)
+            );
+            return $renderedMatcher;
+        } elseif (!is_array($this->properties[$matcherKey])) {
+            throw new UnsupportedObjectTypeAtPathException('"Case" Fusion object only supports nested Fusion objects; no simple values.', 1372668062);
+        } elseif (isset($this->properties[$matcherKey]['__eelExpression'])) {
+            throw new UnsupportedObjectTypeAtPathException('"Case" Fusion object only supports nested Fusion objects; no Eel expressions.', 1372668077);
+        } else {
+            $renderedMatcher = $this->runtime->render(
+                sprintf('%s/%s<Neos.Fusion:Matcher>', $this->path, $matcherKey)
+            );
+            return $renderedMatcher;
+        }
+    }
+    /**
+     * Test whether the output of the matcher does not equal the MATCH_NORESULT
+     *
+     * If the debug mode is enabled, we have to strip the debug output before comparing the rendered result.
+     *
+     * @param string $renderedMatcher
+     * @return boolean
+     */
+    protected function matcherMatched($renderedMatcher)
+    {
+        if ($this->runtime->isDebugMode()) {
+            $renderedMatcher = preg_replace('/\s*<!--.*?-->\s*/', '', $renderedMatcher);
+        }
+        return $renderedMatcher !== self::MATCH_NORESULT;
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/ComponentImplementation.php
@@ -0,0 +1,80 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\FusionObjects\Helpers\LazyProps;
+/**
+ * A Fusion Component-Object
+ *
+ * All properties except ``renderer`` are pushed into a context variable ``props``
+ * afterwards the ``renderer`` is evaluated
+ *
+ * //fusionPath renderer The variable to display a dump of.
+ * //fusionPath * generic Fusion values that will be added to the ``props`` object in the context
+ * @api
+ */
+class ComponentImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * Properties that are ignored and not included into the ``props`` context
+     *
+     * @var array
+     */
+    protected $ignoreProperties = ['__meta', 'renderer'];
+    /**
+     * Evaluate the fusion-keys and transfer the result into the context as ``props``
+     * afterwards evaluate the ``renderer`` with this context
+     *
+     * @return mixed
+     */
+    public function evaluate()
+    {
+        $context = $this->runtime->getCurrentContext();
+        $renderContext = $this->prepare($context);
+        $result = $this->render($renderContext);
+        return $result;
+    }
+    /**
+     * Prepare the context for the renderer
+     *
+     * @param array $context
+     * @return array
+     */
+    protected function prepare(array $context): array
+    {
+        $context['props'] = $this->getProps($context);
+        return $context;
+    }
+    /**
+     * Calculate the component props
+     *
+     * @param array $context
+     * @return \ArrayAccess
+     */
+    protected function getProps(array $context): \ArrayAccess
+    {
+        $sortedChildFusionKeys = $this->sortNestedProperties();
+        $props = new LazyProps($this, $this->path, $this->runtime, $sortedChildFusionKeys, $context);
+        return $props;
+    }
+    /**
+     * Evaluate the renderer with the give context and return
+     *
+     * @param array $context
+     * @return mixed
+     */
+    protected function render(array $context)
+    {
+        $this->runtime->pushContextArray($context);
+        $result = $this->runtime->render($this->path . '/renderer');
+        $this->runtime->popContext();
+        return $result;
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/DataStructureImplementation.php
@@ -0,0 +1,48 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Fusion\Exception as FusionException;
+/**
+ * Fusion object to render and array of key value pairs by evaluating all properties
+ */
+class DataStructureImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * Evaluate this Fusion object and return the result
+     *
+     * @return array
+     * @throws FusionException
+     * @throws \Neos\Flow\Configuration\Exception\InvalidConfigurationException
+     * @throws \Neos\Flow\Mvc\Exception\StopActionException
+     * @throws \Neos\Flow\Security\Exception
+     */
+    public function evaluate()
+    {
+        return $this->evaluateNestedProperties('Neos.Fusion:DataStructure');
+    }
+    /**
+     * Sort the Fusion objects inside $this->properties depending on:
+     * - numerical ordering
+     * - position meta-property
+     *
+     * This will ignore all properties defined in "@ignoreProperties" in Fusion
+     *
+     * @see PositionalArraySorter
+     *
+     * @return array an ordered list of key value pairs
+     * @throws FusionException if the positional string has an unsupported format
+     * @deprecated since 8.0 can be removed with 9.0 use {@see \Neos\Fusion\FusionObjects\AbstractArrayFusionObject::sortNestedProperties}
+     */
+    protected function sortNestedFusionKeys()
+    {
+        return $this->sortNestedProperties();
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/DebugConsoleImplementation.php
@@ -0,0 +1,59 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * A Fusion object for debugging fusion-values via the browser console
+ *
+ * //fusionPath value The variable to serialize and output to the console.
+ * //fusionPath title Optional custom title for the debug output.
+ * //fusionPath method Optional alternative method to call on the browser console.
+ * //fusionPath content When used as process the console script will be appended to it.
+ * @api
+ */
+class DebugConsoleImplementation extends AbstractArrayFusionObject
+{
+    protected $ignoreProperties = ['__meta', 'title', 'method', 'value', 'content'];
+    public function getTitle(): string
+    {
+        return $this->fusionValue('title') ?: '';
+    }
+    public function getMethod(): string
+    {
+        return $this->fusionValue('method') ?: 'log';
+    }
+    public function getContent(): string
+    {
+        return $this->fusionValue('content') ?: '';
+    }
+    /**
+     * @return mixed
+     */
+    public function getValue()
+    {
+        return $this->fusionValue('value') ?: '';
+    }
+    /**
+     * Appends a console script call to the output
+     */
+    public function evaluate(): string
+    {
+        $title = trim($this->getTitle());
+        $method = $this->getMethod();
+        $content = $this->getContent();
+        $arguments = $this->evaluateNestedProperties();
+        array_unshift($arguments, $this->getValue());
+        if ($title) {
+            $arguments[] = $this->getTitle();
+        }
+        $arguments = array_map('json_encode', $arguments);
+        return sprintf('%s<script>console.%s(%s)</script>', $content, $method, implode(', ', $arguments));
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/DebugImplementation.php
@@ -0,0 +1,77 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\DebugMessage;
+use Neos\Fusion\Service\DebugStack;
+/**
+ * A Fusion object for debugging fusion-values
+ *
+ * If only value is given it is debugged directly. Otherwise all keys except title an plaintext are debugged.
+ *
+ * //fusionPath value The variable to display a dump of.
+ * //fusionPath title $title optional custom title for the debug output
+ * //fusionPath plaintext If true, the dump is in plain text, if false the debug output is in HTML format. If not specified, the mode is guessed from FLOW_SAPITYPE
+ * @api
+ */
+class DebugImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * If you iterate over "properties" these in here should usually be ignored.
+     * For example additional properties in "Case" that are not "Matchers".
+     *
+     * @var array
+     */
+    protected $ignoreProperties = ['__meta', 'title', 'plaintext'];
+    /**
+     * @var DebugStack
+     * @Flow\Inject
+     */
+    protected $stack;
+    public function getTitle(): string
+    {
+        return $this->fusionValue('title') ?: '';
+    }
+    public function getPlaintext(): bool
+    {
+        return $this->fusionValue('plaintext') ?: false;
+    }
+    /**
+     * Return the values in a human readable form
+     *
+     * @return string
+     */
+    public function evaluate()
+    {
+        $title = trim($this->getTitle());
+        $plaintext = $this->getPlaintext();
+        $debugData = [];
+        foreach (array_keys($this->properties) as $key) {
+            if (in_array($key, $this->ignoreProperties)) {
+                continue;
+            }
+            $debugData[$key] = $this->fusionValue($key);
+        }
+        $title .= ' @ ' . $this->path;
+        if (count($debugData) === 0) {
+            $debugData = [null];
+        }
+        foreach ($debugData as $suffix => $data) {
+            if (is_string($suffix)) {
+                $message = (new DebugMessage(trim($title . '.' . $suffix), $this->path, $data, $plaintext));
+            } else {
+                $message = (new DebugMessage(trim($title), $this->path, $data, $plaintext));
+            }
+            $this->stack->register($message);
+        }
+        return $this->fusionValue('value');
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/Helpers/LazyProps.php
@@ -0,0 +1,101 @@
+<?php
+namespace Neos\Fusion\FusionObjects\Helpers;
+use Neos\Flow\Annotations as Flow;
+use Neos\Fusion\Core\Runtime;
+/**
+ * @Flow\Proxy(false)
+ */
+final class LazyProps implements \ArrayAccess, \Iterator, \JsonSerializable
+{
+    /**
+     * @var array
+     */
+    private $valueCache = [];
+    /**
+     * @var string
+     */
+    private $parentPath;
+    /**
+     * @var Runtime
+     */
+    private $runtime;
+    /**
+     * Index of keys
+     *
+     * @var array
+     */
+    private $keys;
+    /**
+     * @var object
+     */
+    private $fusionObject;
+    /**
+     * @var array
+     */
+    private $effectiveContext;
+    public function __construct(
+        object $fusionObject,
+        string $parentPath,
+        Runtime $runtime,
+        array $keys,
+        array $effectiveContext
+    ) {
+        $this->fusionObject = $fusionObject;
+        $this->parentPath = $parentPath;
+        $this->runtime = $runtime;
+        $this->keys = array_flip($keys);
+        $this->effectiveContext = $effectiveContext;
+    }
+    public function offsetExists($path): bool
+    {
+        return array_key_exists($path, $this->keys);
+    }
+    public function offsetGet($path): mixed
+    {
+        if (!array_key_exists($path, $this->valueCache)) {
+            $this->runtime->pushContextArray($this->effectiveContext);
+            try {
+                $this->valueCache[$path] = $this->runtime->evaluate($this->parentPath . '/' . $path, $this->fusionObject);
+            } finally {
+                $this->runtime->popContext();
+            }
+        }
+        return $this->valueCache[$path];
+    }
+    public function offsetSet($path, $value): void
+    {
+        throw new BadMethodCallException('Lazy props can not be set.', 1588182804);
+    }
+    public function offsetUnset($path): void
+    {
+        throw new BadMethodCallException('Lazy props can not be unset.', 1588182805);
+    }
+    public function current(): mixed
+    {
+        $path = key($this->keys);
+        if ($path === null) {
+            return null;
+        }
+        return $this->offsetGet($path);
+    }
+    public function next(): void
+    {
+        next($this->keys);
+    }
+    public function key(): mixed
+    {
+        return key($this->keys);
+    }
+    public function valid(): bool
+    {
+        return current($this->keys) !== false;
+    }
+    public function rewind(): void
+    {
+        reset($this->keys);
+    }
+    public function jsonSerialize(): mixed
+    {
+        return iterator_to_array($this);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/HttpResponseImplementation.php
@@ -0,0 +1,54 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+use GuzzleHttp\Psr7\Message;
+use Neos\Flow\Annotations as Flow;
+use Psr\Http\Message\ResponseInterface;
+use Psr\Http\Message\StreamFactoryInterface;
+/**
+ *
+ */
+class HttpResponseImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * @Flow\Inject
+     * @var StreamFactoryInterface
+     */
+    protected $contentStreamFactory;
+    /**
+     * Get the HTTP Header values for this response
+     *
+     * @return ResponseInterface
+     */
+    public function getResponseHead()
+    {
+        return $this->fusionValue($this->getResponseHeadName()) ?? null;
+    }
+    /**
+     * @return string
+     */
+    public function getResponseHeadName(): string
+    {
+        return $this->fusionValue('_getHttpResponseHead') ?? 'httpResponseHead';
+    }
+    /**
+     * {@inheritdoc}
+     *
+     * @return string
+     */
+    public function evaluate()
+    {
+        if (!in_array($this->getResponseHeadName(), $this->ignoreProperties, true)) {
+            $this->ignoreProperties[] = $this->getResponseHeadName();
+        }
+        $response = $this->getResponseHead();
+        if (!$response instanceof ResponseInterface) {
+            throw new \InvalidArgumentException('Could not render HTTP response because the response head was not a valid HTTP response object.', 1557932997);
+        }
+        $resultParts = $this->evaluateNestedProperties();
+        if ($resultParts !== []) {
+            $contentStream = $this->contentStreamFactory->createStream(implode('', $resultParts));
+            $response = $response->withBody($contentStream);
+        }
+        return Message::toString($response);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/JoinImplementation.php
@@ -0,0 +1,40 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * Fusion object to render a list of items as single concatenated string
+ */
+class JoinImplementation extends AbstractArrayFusionObject
+{
+    /**
+     * Get the glue to insert between items
+     *
+     * @return string
+     */
+    public function getGlue()
+    {
+        return $this->fusionValue('__meta/glue') ?? '';
+    }
+    /**
+     * {@inheritdoc}
+     *
+     * @return string|null
+     */
+    public function evaluate()
+    {
+        $glue = $this->getGlue();
+        $resultParts = $this->evaluateNestedProperties();
+        if ($resultParts !== []) {
+            return implode($glue, $resultParts);
+        }
+        return null;
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/ResourceUriImplementation.php
@@ -0,0 +1,128 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\I18n\Service;
+use Neos\Flow\Mvc\ActionRequest;
+use Neos\Flow\ResourceManagement\PersistentResource;
+use Neos\Flow\ResourceManagement\ResourceManager;
+use Neos\Fusion\Exception as FusionException;
+/**
+ * A Fusion object to create resource URIs
+ *
+ * The following Fusion properties are evaluated:
+ *  * path
+ *  * package
+ *  * resource
+ *  * localize
+ *
+ * See respective getters for descriptions
+ */
+class ResourceUriImplementation extends AbstractFusionObject
+{
+    /**
+     * @Flow\Inject
+     * @var ResourceManager
+     */
+    protected $resourceManager;
+    /**
+     * @Flow\Inject
+     * @var Service
+     */
+    protected $i18nService;
+    /**
+     * The location of the resource, can be either a path relative to the Public resource directory of the package or a resource://... URI
+     *
+     * @return string
+     */
+    public function getPath()
+    {
+        return $this->fusionValue('path');
+    }
+    /**
+     * Target package key (only required for relative paths)
+     *
+     * @return string
+     */
+    public function getPackage()
+    {
+        return $this->fusionValue('package');
+    }
+    /**
+     * If specified, this resource object is used instead of the path and package information
+     *
+     * @return PersistentResource
+     */
+    public function getResource()
+    {
+        return $this->fusionValue('resource');
+    }
+    /**
+     * Whether resource localization should be attempted or not, defaults to true
+     *
+     * @return boolean
+     */
+    public function isLocalize()
+    {
+        return (boolean)$this->fusionValue('localize');
+    }
+    /**
+     * Returns the absolute URL of a resource
+     *
+     * @return string
+     * @throws FusionException
+     */
+    public function evaluate()
+    {
+        $resource = $this->getResource();
+        if ($resource !== null) {
+            $uri = false;
+            if ($resource instanceof PersistentResource) {
+                $uri = $this->resourceManager->getPublicPersistentResourceUri($resource);
+            }
+            if ($uri === false) {
+                throw new FusionException('The specified resource is invalid', 1386458728);
+            }
+            return $uri;
+        }
+        $path = $this->getPath();
+        if ($path === null) {
+            throw new FusionException('Neither "resource" nor "path" were specified', 1386458763);
+        }
+        if (strpos($path, 'resource://') === 0) {
+            $matches = [];
+            if (preg_match('#^resource://([^/]+)/Public/(.*)#', $path, $matches) !== 1) {
+                throw new FusionException(sprintf('The specified path "%s" does not point to a public resource.', $path), 1386458851);
+            }
+            $package = $matches[1];
+            $path = $matches[2];
+        } else {
+            $package = $this->getPackage();
+            if ($package === null) {
+                $controllerContext = $this->runtime->getControllerContext();
+                /** @var $actionRequest ActionRequest */
+                $actionRequest = $controllerContext->getRequest();
+                $package = $actionRequest->getControllerPackageKey();
+            }
+        }
+        $localize = $this->isLocalize();
+        if ($localize === true) {
+            $resourcePath = 'resource://' . $package . '/Public/' . $path;
+            $localizedResourcePathData = $this->i18nService->getLocalizedFilename($resourcePath);
+            $matches = [];
+            if (preg_match('#resource://([^/]+)/Public/(.*)#', current($localizedResourcePathData), $matches) === 1) {
+                $package = $matches[1];
+                $path = $matches[2];
+            }
+        }
+        return $this->resourceManager->getPublicPackageResourceUri($package, $path);
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/FusionObjects/UriBuilderImplementation.php
@@ -0,0 +1,175 @@
+<?php
+namespace Neos\Fusion\FusionObjects;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * A Fusion UriBuilder object
+ *
+ * The following Fusion properties are evaluated:
+ *  * package
+ *  * subpackage
+ *  * controller
+ *  * action
+ *  * arguments
+ *  * format
+ *  * section
+ *  * additionalParams
+ *  * addQueryString
+ *  * argumentsToBeExcludedFromQueryString
+ *  * absolute
+ *
+ * See respective getters for descriptions
+ */
+class UriBuilderImplementation extends AbstractFusionObject
+{
+    /**
+     * Key of the target package
+     *
+     * @return string
+     */
+    public function getPackage()
+    {
+        return $this->fusionValue('package');
+    }
+    /**
+     * Key of the target sub package
+     *
+     * @return string
+     */
+    public function getSubpackage()
+    {
+        return $this->fusionValue('subpackage');
+    }
+    /**
+     * Target controller name
+     *
+     * @return string
+     */
+    public function getController()
+    {
+        return $this->fusionValue('controller');
+    }
+    /**
+     * Target controller action name
+     *
+     * @return string
+     */
+    public function getAction()
+    {
+        return $this->fusionValue('action');
+    }
+    /**
+     * Controller arguments
+     *
+     * @return array
+     */
+    public function getArguments()
+    {
+        $arguments = $this->fusionValue('arguments');
+        return is_array($arguments) ? $arguments: [];
+    }
+    /**
+     * The requested format, for example "html"
+     *
+     * @return string
+     */
+    public function getFormat()
+    {
+        return $this->fusionValue('format');
+    }
+    /**
+     * The anchor to be appended to the URL
+     *
+     * @return string
+     */
+    public function getSection()
+    {
+        return $this->fusionValue('section');
+    }
+    /**
+     * Additional query parameters that won't be prefixed like $arguments (overrule $arguments)
+     *
+     * @return array
+     */
+    public function getAdditionalParams()
+    {
+        return $this->fusionValue('additionalParams');
+    }
+    /**
+     * Arguments to be removed from the URI. Only active if addQueryString = true
+     *
+     * @return array
+     */
+    public function getArgumentsToBeExcludedFromQueryString()
+    {
+        return $this->fusionValue('argumentsToBeExcludedFromQueryString');
+    }
+    /**
+     * If true, the current query parameters will be kept in the URI
+     *
+     * @return boolean
+     */
+    public function isAddQueryString()
+    {
+        return (boolean)$this->fusionValue('addQueryString');
+    }
+    /**
+     * If true, an absolute URI is rendered
+     *
+     * @return boolean
+     */
+    public function isAbsolute()
+    {
+        return (boolean)$this->fusionValue('absolute');
+    }
+    /**
+     * @return string
+     */
+    public function evaluate()
+    {
+        $controllerContext = $this->runtime->getControllerContext();
+        $uriBuilder = $controllerContext->getUriBuilder()->reset();
+        $format = $this->getFormat();
+        if ($format !== null) {
+            $uriBuilder->setFormat($format);
+        }
+        $additionalParams = $this->getAdditionalParams();
+        if ($additionalParams !== null) {
+            $uriBuilder->setArguments($additionalParams);
+        }
+        $argumentsToBeExcludedFromQueryString = $this->getArgumentsToBeExcludedFromQueryString();
+        if ($argumentsToBeExcludedFromQueryString !== null) {
+            $uriBuilder->setArgumentsToBeExcludedFromQueryString($argumentsToBeExcludedFromQueryString);
+        }
+        $absolute = $this->isAbsolute();
+        if ($absolute === true) {
+            $uriBuilder->setCreateAbsoluteUri(true);
+        }
+        $section = $this->getSection();
+        if ($section !== null) {
+            $uriBuilder->setSection($section);
+        }
+        $addQueryString = $this->isAddQueryString();
+        if ($addQueryString === true) {
+            $uriBuilder->setAddQueryString(true);
+        }
+        try {
+            return $uriBuilder->uriFor(
+                $this->getAction(),
+                $this->getArguments(),
+                $this->getController(),
+                $this->getPackage(),
+                $this->getSubpackage()
+            );
+        } catch (\Exception $exception) {
+            return $this->runtime->handleRenderingException($this->path, $exception);
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Classes/Package.php
@@ -0,0 +1,68 @@
+<?php
+namespace Neos\Fusion;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Cache\CacheManager;
+use Neos\Flow\Core\Booting\Sequence;
+use Neos\Flow\Core\Bootstrap;
+use Neos\Flow\Monitor\FileMonitor;
+use Neos\Flow\Package\Package as BasePackage;
+use Neos\Flow\Package\PackageManager;
+use Neos\Fusion\Core\Cache\FileMonitorListener;
+use Neos\Fusion\Core\Cache\ParserCacheFlusher;
+/**
+ * The Neos Fusion Package
+ */
+class Package extends BasePackage
+{
+    /**
+     * Invokes custom PHP code directly after the package manager has been initialized.
+     *
+     * @param Bootstrap $bootstrap The current bootstrap
+     * @return void
+     */
+    public function boot(Bootstrap $bootstrap)
+    {
+        $dispatcher = $bootstrap->getSignalSlotDispatcher();
+        $context = $bootstrap->getContext();
+        if (!$context->isProduction()) {
+            $dispatcher->connect(Sequence::class, 'afterInvokeStep', function ($step) use ($bootstrap, $dispatcher) {
+                if ($step->getIdentifier() === 'neos.flow:systemfilemonitor') {
+                    $fusionFileMonitor = FileMonitor::createFileMonitorAtBoot('Fusion_Files', $bootstrap);
+                    /** @var PackageManager $packageManager */
+                    $packageManager = $bootstrap->getEarlyInstance(PackageManager::class);
+                    foreach ($packageManager->getFlowPackages() as $packageKey => $package) {
+                        if ($packageManager->isPackageFrozen($packageKey)) {
+                            continue;
+                        }
+                        $fusionPaths = [
+                            $package->getResourcesPath() . 'Private/Fusion',
+                            $package->getPackagePath() . 'NodeTypes'
+                        ];
+                        foreach ($fusionPaths as $fusionPath) {
+                            if (is_dir($fusionPath)) {
+                                $fusionFileMonitor->monitorDirectory($fusionPath);
+                            }
+                        }
+                    }
+                    $fusionFileMonitor->detectChanges();
+                    $fusionFileMonitor->shutdownObject();
+                }
+                if ($step->getIdentifier() === 'neos.flow:cachemanagement') {
+                    $cacheManager = $bootstrap->getEarlyInstance(CacheManager::class);
+                    $listener = new FileMonitorListener($cacheManager);
+                    $dispatcher->connect(FileMonitor::class, 'filesHaveChanged', $listener, 'flushContentCacheOnFileChanges');
+                    $parsePartialCacheFlusher = new ParserCacheFlusher($cacheManager);
+                    $dispatcher->connect(FileMonitor::class, 'filesHaveChanged', $parsePartialCacheFlusher, 'flushPartialCacheOnFileChanges');
+                }
+            });
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Fusion/Migrations/Code/Version20220326120900.php
@@ -0,0 +1,64 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Flow\Core\Migrations;
+/*
+ * This file is part of the Neos.Fusion package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * Expand Neos.Fusion-FusionObjects without namespace to fully qualified names
+ */
+class Version20220326120900 extends AbstractMigration
+{
+    /**
+     * The name of all prototypes from Neos.Fusion that could be used without
+     * namespace previously because of the `default` namespace
+     */
+    protected array $namesToMigrate = [
+        'Array',
+        'RawArray',
+        'Join',
+        'DataStructure',
+        'Template',
+        'Case',
+        'Matcher',
+        'Renderer',
+        'Value',
+        'Component',
+        'CanRender',
+        'DebugDump',
+        'Debug',
+        'Collection',
+        'RawCollection',
+        'Loop',
+        'Map',
+        'Reduce',
+        'Http.ResponseHead',
+        'Http.Message',
+        'Attributes',
+        'Tag',
+        'UriBuilder',
+        'Augmenter',
+        'ResourceUri',
+        'Link.Action',
+        'Link.Resource',
+        'Fragment',
+        'GlobalCacheIdentifiers'
+    ];
+    public function getIdentifier():string
+    {
+        return 'Neos.Fusion-20220326120900';
+    }
+    public function up():void
+    {
+        foreach ($this->namesToMigrate as $name) {
+            $this->searchAndReplaceRegex('/(?<=\\=)([\\s]*)(' . preg_quote($name) . ')(?=[$\\s\\{])/u', '$1Neos.Fusion:$2', ['fusion']);
+            $this->searchAndReplaceRegex('/(?<=prototype\\()(' . preg_quote($name) . ')(?=\\))/u', 'Neos.Fusion:$1', ['fusion']);
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Media.Browser/Classes/Controller/AssetController.php
@@ -0,0 +1,879 @@
+<?php
+namespace Neos\Media\Browser\Controller;
+/*
+ * This file is part of the Neos.Media.Browser package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Doctrine\Common\Persistence\Proxy as DoctrineProxy;
+use Doctrine\ORM\EntityNotFoundException;
+use Neos\Error\Messages\Error;
+use Neos\Error\Messages\Message;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Mvc\Controller\ActionController;
+use Neos\Flow\Mvc\Exception\ForwardException;
+use Neos\Flow\Mvc\Exception\NoSuchArgumentException;
+use Neos\Flow\Mvc\Exception\StopActionException;
+use Neos\Flow\Mvc\Exception\UnsupportedRequestTypeException;
+use Neos\Flow\Mvc\View\JsonView;
+use Neos\Flow\Mvc\View\ViewInterface;
+use Neos\Flow\Package\PackageManager;
+use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
+use Neos\Flow\Property\TypeConverter\PersistentObjectConverter;
+use Neos\Flow\ResourceManagement\PersistentResource;
+use Neos\FluidAdaptor\View\TemplateView;
+use Neos\Media\Browser\Domain\ImageMapper;
+use Neos\Media\Browser\Domain\Session\BrowserState;
+use Neos\Media\Domain\Model\Asset;
+use Neos\Media\Domain\Model\AssetCollection;
+use Neos\Media\Domain\Model\AssetInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetNotFoundExceptionInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetProxyRepositoryInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetSourceConnectionExceptionInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetSourceInterface;
+use Neos\Media\Domain\Model\AssetSource\Neos\NeosAssetProxy;
+use Neos\Media\Domain\Model\AssetSource\SupportsCollectionsInterface;
+use Neos\Media\Domain\Model\AssetSource\SupportsSortingInterface;
+use Neos\Media\Domain\Model\AssetSource\SupportsTaggingInterface;
+use Neos\Media\Domain\Model\AssetVariantInterface;
+use Neos\Media\Domain\Model\Dto\AssetConstraints;
+use Neos\Media\Domain\Model\Tag;
+use Neos\Media\Domain\Model\VariantSupportInterface;
+use Neos\Media\Domain\Repository\AssetCollectionRepository;
+use Neos\Media\Domain\Repository\AssetRepository;
+use Neos\Media\Domain\Repository\TagRepository;
+use Neos\Media\Domain\Service\AssetService;
+use Neos\Media\Exception\AssetServiceException;
+use Neos\Media\TypeConverter\AssetInterfaceConverter;
+use Neos\Neos\Controller\BackendUserTranslationTrait;
+use Neos\Neos\Controller\CreateContentContextTrait;
+use Neos\Neos\Domain\Repository\DomainRepository;
+use Neos\Neos\Domain\Repository\SiteRepository;
+use Neos\Utility\Exception\FilesException;
+use Neos\Utility\Files;
+use Neos\Utility\MediaTypes;
+/**
+ * Controller for asset handling
+ *
+ * @Flow\Scope("singleton")
+ */
+class AssetController extends ActionController
+{
+    use CreateContentContextTrait;
+    use BackendUserTranslationTrait;
+    use AddFlashMessageTrait;
+    protected const TAG_GIVEN = 0;
+    protected const TAG_ALL = 1;
+    protected const TAG_NONE = 2;
+    protected const COLLECTION_GIVEN = 0;
+    protected const COLLECTION_ALL = 1;
+    /**
+     * @var array
+     */
+    protected $viewFormatToObjectNameMap = [
+        'html' => TemplateView::class,
+        'json' => JsonView::class
+    ];
+    /**
+     * @Flow\Inject
+     * @var SiteRepository
+     */
+    protected $siteRepository;
+    /**
+     * @Flow\Inject
+     * @var DomainRepository
+     */
+    protected $domainRepository;
+    /**
+     * @Flow\Inject
+     * @var AssetRepository
+     */
+    protected $assetRepository;
+    /**
+     * @Flow\Inject
+     * @var TagRepository
+     */
+    protected $tagRepository;
+    /**
+     * @Flow\Inject
+     * @var AssetCollectionRepository
+     */
+    protected $assetCollectionRepository;
+    /**
+     * @Flow\Inject
+     * @var PackageManager
+     */
+    protected $packageManager;
+    /**
+     * @Flow\Inject(lazy = false)
+     * @var BrowserState
+     */
+    protected $browserState;
+    /**
+     * @Flow\Inject
+     * @var AssetService
+     */
+    protected $assetService;
+    /**
+     * @Flow\Inject
+     * @var \Neos\Media\Domain\Service\AssetSourceService
+     */
+    protected $assetSourceService;
+    /**
+     * @var AssetSourceInterface[]
+     */
+    protected $assetSources = [];
+    /**
+     * @Flow\InjectConfiguration(path="imageProfiles", package="Neos.Media")
+     * @var array
+     */
+    protected $imageProfilesConfiguration;
+    /**
+     * @var AssetConstraints
+     */
+    private $assetConstraints;
+    /**
+     * @return void
+     */
+    public function initializeObject(): void
+    {
+        $domain = $this->domainRepository->findOneByActiveRequest();
+        if ($domain !== null && !$this->browserState->get('activeAssetCollection') && $this->browserState->get('automaticAssetCollectionSelection') !== true && $domain->getSite()->getAssetCollection() !== null) {
+            $this->browserState->set('activeAssetCollection', $domain->getSite()->getAssetCollection());
+            $this->browserState->set('automaticAssetCollectionSelection', true);
+        }
+        $this->assetSources = $this->assetSourceService->getAssetSources();
+    }
+    /**
+     * @throws NoSuchArgumentException
+     */
+    protected function initializeAction(): void
+    {
+        parent::initializeAction();
+        if ($this->request->hasArgument('constraints')) {
+            $this->assetConstraints = AssetConstraints::fromArray($this->request->getArgument('constraints'));
+        } else {
+            $this->assetConstraints = AssetConstraints::create();
+        }
+        $this->assetSources = $this->assetConstraints->applyToAssetSources($this->assetSources);
+    }
+    /**
+     * Set common variables on the view
+     *
+     * @param ViewInterface $view
+     * @return void
+     */
+    protected function initializeView(ViewInterface $view): void
+    {
+        $view->assignMultiple([
+            'view' => $this->browserState->get('view'),
+            'sortBy' => $this->browserState->get('sortBy'),
+            'sortDirection' => $this->browserState->get('sortDirection'),
+            'filter' => (string)$this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')),
+            'filterOptions' => $this->assetConstraints->getAllowedAssetTypeFilterOptions(),
+            'activeTag' => $this->browserState->get('activeTag'),
+            'activeAssetCollection' => $this->browserState->get('activeAssetCollection'),
+            'assetSources' => $this->assetSources,
+            'variantsTabFeatureEnabled' => $this->settings['features']['variantsTab']['enable'],
+            'constraints' => $this->assetConstraints,
+        ]);
+    }
+    /**
+     * List existing assets
+     *
+     * @param string $view
+     * @param string $sortBy
+     * @param string $sortDirection
+     * @param string $filter
+     * @param int $tagMode
+     * @param Tag $tag
+     * @param string $searchTerm
+     * @param int $collectionMode
+     * @param AssetCollection $assetCollection
+     * @param string $assetSourceIdentifier
+     * @return void
+     * @throws FilesException
+     */
+    public function indexAction($view = null, $sortBy = null, $sortDirection = null, $filter = null, $tagMode = self::TAG_GIVEN, Tag $tag = null, $searchTerm = null, $collectionMode = self::COLLECTION_GIVEN, AssetCollection $assetCollection = null, $assetSourceIdentifier = null): void
+    {
+        $assetSourceIdentifier = $this->assetConstraints->applyToAssetSourceIdentifiers($assetSourceIdentifier);
+        $this->applyActiveAssetSourceToBrowserState($assetSourceIdentifier);
+        $this->applyAssetCollectionOptionsToBrowserState($collectionMode, $assetCollection);
+        $activeAssetSource = $this->getAssetSourceFromBrowserState();
+        $assetProxyRepository = $activeAssetSource->getAssetProxyRepository();
+        $activeAssetCollection = $this->getActiveAssetCollectionFromBrowserState();
+        $this->applyViewOptionsToBrowserState($view, $sortBy, $sortDirection, $filter);
+        $this->applyTagToBrowserState($tagMode, $tag, $activeAssetCollection);
+        $this->applyAssetTypeFilterFromBrowserState($assetProxyRepository);
+        $this->applySortingFromBrowserState($assetProxyRepository);
+        $this->applyAssetCollectionFilterFromBrowserState($assetProxyRepository);
+        $assetCollections = [];
+        $tags = [];
+        $assetProxies = [];
+        $allCollectionsCount = 0;
+        $allCount = 0;
+        $searchResultCount = 0;
+        $untaggedCount = 0;
+        try {
+            foreach ($this->assetCollectionRepository->findAll()->toArray() as $retrievedAssetCollection) {
+                assert($retrievedAssetCollection instanceof AssetCollection);
+                $assetCollections[] = ['object' => $retrievedAssetCollection, 'count' => $this->assetRepository->countByAssetCollection($retrievedAssetCollection)];
+            }
+            foreach ($activeAssetCollection !== null ? $activeAssetCollection->getTags() : $this->tagRepository->findAll() as $retrievedTag) {
+                assert($retrievedTag instanceof Tag);
+                $tagCount = ($assetProxyRepository instanceof SupportsTaggingInterface ? $assetProxyRepository->countByTag($retrievedTag) : $this->assetRepository->countByTag($retrievedTag, $activeAssetCollection));
+                $tags[] = ['object' => $retrievedTag, 'count' => $tagCount];
+            }
+            if (trim($searchTerm) !== '') {
+                $assetProxies = $assetProxyRepository->findBySearchTerm($searchTerm);
+                $this->view->assign('searchTerm', $searchTerm);
+            } elseif ($this->browserState->get('tagMode') === self::TAG_NONE) {
+                $assetProxies = $assetProxyRepository->findUntagged();
+            } elseif ($this->browserState->get('activeTag') !== null) {
+                $assetProxies = $assetProxyRepository->findByTag($this->browserState->get('activeTag'));
+            } else {
+                $assetProxies = $assetProxyRepository->findAll();
+            }
+            $allCollectionsCount = $this->assetRepository->countAll();
+            $allCount = ($activeAssetCollection ? $this->assetRepository->countByAssetCollection($activeAssetCollection) : $allCollectionsCount);
+            $searchResultCount = isset($assetProxies) ? $assetProxies->count() : 0;
+            $untaggedCount = ($assetProxyRepository instanceof SupportsTaggingInterface ? $assetProxyRepository->countUntagged() : 0);
+        } catch (AssetSourceConnectionExceptionInterface $e) {
+            $this->view->assign('connectionError', $e);
+        }
+        $this->view->assignMultiple([
+            'tags' => $tags,
+            'allCollectionsCount' => $allCollectionsCount,
+            'allCount' => $allCount,
+            'searchResultCount' => $searchResultCount,
+            'untaggedCount' => $untaggedCount,
+            'tagMode' => $this->browserState->get('tagMode'),
+            'assetProxies' => $assetProxies,
+            'assetCollections' => $assetCollections,
+            'argumentNamespace' => $this->request->getArgumentNamespace(),
+            'maximumFileUploadSize' => $this->getMaximumFileUploadSize(),
+            'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($this->getMaximumFileUploadSize()),
+            'activeAssetSource' => $activeAssetSource,
+            'activeAssetSourceSupportsSorting' => $assetProxyRepository instanceof SupportsSortingInterface
+        ]);
+    }
+    /**
+     * New asset form
+     *
+     * @return void
+     */
+    public function newAction(): void
+    {
+        try {
+            $maximumFileUploadSize = $this->getMaximumFileUploadSize();
+        } catch (FilesException $e) {
+            $maximumFileUploadSize = null;
+        }
+        $this->view->assignMultiple([
+            'tags' => $this->tagRepository->findAll(),
+            'assetCollections' => $this->assetCollectionRepository->findAll(),
+            'maximumFileUploadSize' => $maximumFileUploadSize,
+            'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($maximumFileUploadSize)
+        ]);
+    }
+    /**
+     * @param Asset $asset
+     * @return void
+     */
+    public function replaceAssetResourceAction(Asset $asset): void
+    {
+        try {
+            $maximumFileUploadSize = $this->getMaximumFileUploadSize();
+        } catch (FilesException $e) {
+            $maximumFileUploadSize = null;
+        }
+        $this->view->assignMultiple([
+            'asset' => $asset,
+            'maximumFileUploadSize' => $maximumFileUploadSize,
+            'createAssetRedirectsOptionEnabled' => $this->packageManager->isPackageAvailable('Neos.RedirectHandler') && $this->settings['features']['createAssetRedirectsOption']['enable'],
+            'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($maximumFileUploadSize)
+        ]);
+    }
+    /**
+     * Show an asset
+     *
+     * @param string $assetSourceIdentifier
+     * @param string $assetProxyIdentifier
+     * @return void
+     * @throws StopActionException
+     * @throws UnsupportedRequestTypeException
+     */
+    public function showAction(string $assetSourceIdentifier, string $assetProxyIdentifier): void
+    {
+        if (!isset($this->assetSources[$assetSourceIdentifier])) {
+            throw new \RuntimeException('Given asset source is not configured.', 1509702178);
+        }
+        $assetProxyRepository = $this->assetSources[$assetSourceIdentifier]->getAssetProxyRepository();
+        try {
+            $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
+            $this->view->assignMultiple([
+                'assetProxy' => $assetProxy,
+                'assetCollections' => $this->assetCollectionRepository->findAll()
+            ]);
+        } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
+            $this->view->assign('connectionError', $e);
+        }
+    }
+    /**
+     * Edit an asset
+     *
+     * @param string $assetSourceIdentifier
+     * @param string $assetProxyIdentifier
+     * @return void
+     * @throws StopActionException
+     * @throws UnsupportedRequestTypeException
+     */
+    public function editAction(string $assetSourceIdentifier, string $assetProxyIdentifier): void
+    {
+        if (!isset($this->assetSources[$assetSourceIdentifier])) {
+            throw new \RuntimeException('Given asset source is not configured.', 1509632166);
+        }
+        $assetSource = $this->assetSources[$assetSourceIdentifier];
+        $assetProxyRepository = $assetSource->getAssetProxyRepository();
+        try {
+            $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
+            $tags = [];
+            $contentPreview = 'ContentDefault';
+            if ($assetProxyRepository instanceof SupportsTaggingInterface && $assetProxyRepository instanceof SupportsCollectionsInterface) {
+                if ($assetProxy instanceof NeosAssetProxy) {
+                    /** @var Asset $asset */
+                    $asset = $assetProxy->getAsset();
+                    $assetCollections = $asset->getAssetCollections();
+                    $tags = $assetCollections->count() > 0 ? $this->tagRepository->findByAssetCollections($assetCollections->toArray()) : $this->tagRepository->findAll();
+                    switch ($asset->getFileExtension()) {
+                        case 'pdf':
+                            $contentPreview = 'ContentPdf';
+                            break;
+                    }
+                }
+            }
+            $this->view->assignMultiple([
+                'tags' => $tags,
+                'assetProxy' => $assetProxy,
+                'assetCollections' => $this->assetCollectionRepository->findAll(),
+                'contentPreview' => $contentPreview,
+                'assetSource' => $assetSource,
+                'canShowVariants' => ($assetProxy instanceof NeosAssetProxy) && ($assetProxy->getAsset() instanceof VariantSupportInterface)
+            ]);
+        } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
+            $this->view->assign('connectionError', $e);
+        }
+    }
+    /**
+     * Display variants of an asset
+     *
+     * @param string $assetSourceIdentifier
+     * @param string $assetProxyIdentifier
+     * @param string $overviewAction
+     * @throws StopActionException
+     * @throws UnsupportedRequestTypeException
+     */
+    public function variantsAction(string $assetSourceIdentifier, string $assetProxyIdentifier, string $overviewAction): void
+    {
+        if (!isset($this->assetSources[$assetSourceIdentifier])) {
+            throw new \RuntimeException('Given asset source is not configured.', 1509632166);
+        }
+        $assetSource = $this->assetSources[$assetSourceIdentifier];
+        $assetProxyRepository = $assetSource->getAssetProxyRepository();
+        try {
+            $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
+            $asset = $this->persistenceManager->getObjectByIdentifier($assetProxy->getLocalAssetIdentifier(), Asset::class);
+            /** @var VariantSupportInterface $originalAsset */
+            $originalAsset = ($asset instanceof AssetVariantInterface ? $asset->getOriginalAsset() : $asset);
+            $variantInformation = array_map(static function (AssetVariantInterface $imageVariant) {
+                return (new ImageMapper($imageVariant))->getMappingResult();
+            }, $originalAsset->getVariants());
+            $this->view->assignMultiple([
+                'assetProxy' => $assetProxy,
+                'asset' => $originalAsset,
+                'assetSource' => $assetSource,
+                'imageProfiles' => $this->imageProfilesConfiguration,
+                'overviewAction' => $overviewAction,
+                'originalInformation' => (new ImageMapper($asset))->getMappingResult(),
+                'variantsInformation' => $variantInformation,
+                'isSubRequest' => !$this->request->isMainRequest()
+            ]);
+        } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
+            $this->view->assign('connectionError', $e);
+        }
+    }
+    /**
+     * @return void
+     * @throws NoSuchArgumentException
+     */
+    protected function initializeUpdateAction(): void
+    {
+        $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
+        $assetMappingConfiguration->allowProperties('title', 'resource', 'tags', 'assetCollections');
+        $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
+    }
+    /**
+     * Update an asset
+     *
+     * @param Asset $asset
+     * @return void
+     * @throws StopActionException
+     * @throws IllegalObjectTypeException
+     */
+    public function updateAction(Asset $asset): void
+    {
+        $this->assetRepository->update($asset);
+        $this->addFlashMessage('assetHasBeenUpdated', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
+        $this->redirectToIndex();
+    }
+    /**
+     * Initialization for createAction
+     *
+     * @return void
+     * @throws NoSuchArgumentException
+     */
+    protected function initializeCreateAction(): void
+    {
+        $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
+        $assetMappingConfiguration->allowProperties('title', 'resource', 'tags', 'assetCollections');
+        $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
+        $assetMappingConfiguration->setTypeConverterOption(AssetInterfaceConverter::class, AssetInterfaceConverter::CONFIGURATION_ONE_PER_RESOURCE, true);
+    }
+    /**
+     * Create a new asset
+     *
+     * @param Asset $asset
+     * @return void
+     * @throws StopActionException
+     * @throws IllegalObjectTypeException
+     */
+    public function createAction(Asset $asset): void
+    {
+        if ($this->persistenceManager->isNewObject($asset)) {
+            $this->assetRepository->add($asset);
+        }
+        $this->addFlashMessage('assetHasBeenAdded', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
+        $this->redirectToIndex();
+    }
+    /**
+     * Initialization for uploadAction
+     *
+     * @return void
+     * @throws NoSuchArgumentException
+     */
+    protected function initializeUploadAction(): void
+    {
+        $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
+        $assetMappingConfiguration->allowProperties('title', 'resource');
+        $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
+        $assetMappingConfiguration->setTypeConverterOption(AssetInterfaceConverter::class, AssetInterfaceConverter::CONFIGURATION_ONE_PER_RESOURCE, true);
+    }
+    /**
+     * Upload a new asset. No redirection and no response body, for use by plupload (or similar).
+     *
+     * @param Asset $asset
+     * @return string
+     * @throws IllegalObjectTypeException
+     */
+    public function uploadAction(Asset $asset): string
+    {
+        if (($tag = $this->browserState->get('activeTag')) !== null) {
+            $asset->addTag($tag);
+        }
+        if ($this->persistenceManager->isNewObject($asset)) {
+            $this->assetRepository->add($asset);
+        } else {
+            $this->assetRepository->update($asset);
+        }
+        if (($assetCollection = $this->browserState->get('activeAssetCollection')) !== null && $assetCollection->addAsset($asset)) {
+            $this->assetCollectionRepository->update($assetCollection);
+        }
+        $this->addFlashMessage('assetHasBeenAdded', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
+        $this->response->setStatusCode(201);
+        return '';
+    }
+    /**
+     * Tags an asset with a tag.
+     *
+     * No redirection and no response body, no flash message, for use by plupload (or similar).
+     *
+     * @param Asset $asset
+     * @param Tag $tag
+     * @return void
+     * @throws IllegalObjectTypeException
+     */
+    public function tagAssetAction(Asset $asset, Tag $tag): void
+    {
+        $success = false;
+        if ($asset->addTag($tag)) {
+            $this->assetRepository->update($asset);
+            $success = true;
+        }
+        $this->view->assign('value', $success);
+    }
+    /**
+     * Adds an asset to an asset collection
+     *
+     * @param Asset $asset
+     * @param AssetCollection $assetCollection
+     * @return void
+     * @throws IllegalObjectTypeException
+     */
+    public function addAssetToCollectionAction(Asset $asset, AssetCollection $assetCollection): void
+    {
+        $success = false;
+        if ($assetCollection->addAsset($asset)) {
+            $this->assetCollectionRepository->update($assetCollection);
+            $success = true;
+        }
+        $this->view->assign('value', $success);
+    }
+    /**
+     * Delete an asset
+     *
+     * @param Asset $asset
+     * @return void
+     * @throws IllegalObjectTypeException
+     * @throws StopActionException
+     * @throws AssetServiceException
+     */
+    public function deleteAction(Asset $asset): void
+    {
+        $usageReferences = $this->assetService->getUsageReferences($asset);
+        if (count($usageReferences) > 0) {
+            $this->addFlashMessage('deleteRelatedNodes', '', Message::SEVERITY_WARNING, [], 1412422767);
+            $this->redirectToIndex();
+        }
+        $this->assetRepository->remove($asset);
+        $this->addFlashMessage('assetHasBeenDeleted', '', Message::SEVERITY_OK, [$asset->getLabel()], 1412375050);
+        $this->redirectToIndex();
+    }
+    /**
+     * Update the resource on an asset.
+     *
+     * @param AssetInterface $asset
+     * @param PersistentResource $resource
+     * @param array $options
+     * @return void
+     * @throws StopActionException
+     * @throws ForwardException
+     */
+    public function updateAssetResourceAction(AssetInterface $asset, PersistentResource $resource, array $options = []): void
+    {
+        $sourceMediaType = MediaTypes::parseMediaType($asset->getMediaType());
+        $replacementMediaType = MediaTypes::parseMediaType($resource->getMediaType());
+        if ($sourceMediaType['type'] !== $replacementMediaType['type'] && in_array($sourceMediaType['type'], ['image', 'audio', 'video'])) {
+            $this->addFlashMessage(
+                'resourceCanOnlyBeReplacedBySimilarResource',
+                '',
+                Message::SEVERITY_WARNING,
+                [$sourceMediaType['type'], $resource->getMediaType()],
+                1462308179
+            );
+            $this->redirectToIndex();
+        }
+        try {
+            $this->assetService->replaceAssetResource($asset, $resource, $options);
+        } catch (\Exception $exception) {
+            $this->addFlashMessage('couldNotReplaceAsset', '', Message::SEVERITY_OK, [], 1463472606);
+            $this->forwardToReferringRequest();
+            return;
+        }
+        $assetLabel = (method_exists($asset, 'getLabel') ? $asset->getLabel() : $resource->getFilename());
+        $this->addFlashMessage('assetHasBeenReplaced', '', Message::SEVERITY_OK, [htmlspecialchars($assetLabel)]);
+        $this->redirectToIndex();
+    }
+    /**
+     * Get Related Nodes for an asset (proxy action)
+     *
+     * @param AssetInterface $asset
+     * @return void
+     * @throws ForwardException
+     */
+    public function relatedNodesAction(AssetInterface $asset): void
+    {
+        $this->forwardWithConstraints('relatedNodes', 'Usage', ['asset' => $asset]);
+    }
+    /**
+     * @param string $label
+     * @return void
+     * @Flow\Validate(argumentName="label", type="NotEmpty")
+     * @Flow\Validate(argumentName="label", type="Label")
+     * @throws ForwardException
+     */
+    public function createTagAction(string $label): void
+    {
+        $this->forwardWithConstraints('create', 'Tag', ['label' => $label]);
+    }
+    /**
+     * @param Tag $tag
+     * @return void
+     * @throws ForwardException
+     */
+    public function editTagAction(Tag $tag): void
+    {
+        $this->forwardWithConstraints('edit', 'Tag', ['tag' => $tag]);
+    }
+    /**
+     * @param Tag $tag
+     * @return void
+     * @throws ForwardException
+     */
+    public function updateTagAction(Tag $tag): void
+    {
+        $this->forwardWithConstraints('update', 'Tag', ['tag' => $tag]);
+    }
+    /**
+     * @param Tag $tag
+     * @return void
+     * @throws ForwardException
+     */
+    public function deleteTagAction(Tag $tag): void
+    {
+        $this->forwardWithConstraints('delete', 'Tag', ['tag' => $tag]);
+    }
+    /**
+     * @param string $title
+     * @return void
+     * @Flow\Validate(argumentName="title", type="NotEmpty")
+     * @Flow\Validate(argumentName="title", type="Label")
+     * @throws ForwardException
+     */
+    public function createAssetCollectionAction($title): void
+    {
+        $this->forwardWithConstraints('create', 'AssetCollection', ['title' => $title]);
+    }
+    /**
+     * @param AssetCollection $assetCollection
+     * @return void
+     * @throws ForwardException
+     */
+    public function editAssetCollectionAction(AssetCollection $assetCollection): void
+    {
+        $this->forwardWithConstraints('edit', 'AssetCollection', ['assetCollection' => $assetCollection]);
+    }
+    /**
+     * @param AssetCollection $assetCollection
+     * @return void
+     * @throws ForwardException
+     */
+    public function updateAssetCollectionAction(AssetCollection $assetCollection): void
+    {
+        $this->forwardWithConstraints('update', 'AssetCollection', ['assetCollection' => $assetCollection]);
+    }
+    /**
+     * @param AssetCollection $assetCollection
+     * @return void
+     * @throws ForwardException
+     */
+    public function deleteAssetCollectionAction(AssetCollection $assetCollection): void
+    {
+        $this->forwardWithConstraints('delete', 'AssetCollection', ['assetCollection' => $assetCollection]);
+    }
+    /**
+     * This custom errorAction adds FlashMessages for validation results to give more information in the
+     *
+     * @return string
+     */
+    protected function errorAction(): string
+    {
+        foreach ($this->arguments->getValidationResults()->getFlattenedErrors() as $propertyPath => $errors) {
+            foreach ($errors as $error) {
+                $this->controllerContext->getFlashMessageContainer()->addMessage($error);
+            }
+        }
+        return parent::errorAction();
+    }
+    /**
+     * Individual error FlashMessage that hides which action fails in production.
+     *
+     * @return Message|bool The flash message or false if no flash message should be set
+     */
+    protected function getErrorFlashMessage()
+    {
+        if ($this->arguments->getValidationResults()->hasErrors()) {
+            return false;
+        }
+        $errorMessage = 'An error occurred';
+        if ($this->objectManager->getContext()->isDevelopment()) {
+            $errorMessage .= ' while trying to call %1$s->%2$s()';
+        }
+        return new Error($errorMessage, null, [get_class($this), $this->actionMethodName]);
+    }
+    /**
+     * Returns the lowest configured maximum upload file size
+     *
+     * @return int
+     * @throws FilesException
+     */
+    private function getMaximumFileUploadSize(): int
+    {
+        return min(Files::sizeStringToBytes(ini_get('post_max_size')), Files::sizeStringToBytes(ini_get('upload_max_filesize')));
+    }
+    /**
+     * @param string $view
+     * @param string $sortBy
+     * @param string $sortDirection
+     * @param string $filter
+     */
+    private function applyViewOptionsToBrowserState(string $view = null, string $sortBy = null, string $sortDirection = null, string $filter = null): void
+    {
+        if (!empty($view)) {
+            $this->browserState->set('view', $view);
+        }
+        if (!empty($sortBy)) {
+            $this->browserState->set('sortBy', $sortBy);
+        }
+        if (!empty($sortDirection)) {
+            $this->browserState->set('sortDirection', $sortDirection);
+        }
+        if (!empty($filter)) {
+            $this->browserState->set('filter', $filter);
+        }
+        foreach (['view', 'sortBy', 'sortDirection'] as $optionName) {
+            $this->view->assign($optionName, $this->browserState->get($optionName));
+        }
+        $this->view->assign('filter', (string)$this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')));
+    }
+    /**
+     * @param $assetSourceIdentifier
+     */
+    private function applyActiveAssetSourceToBrowserState($assetSourceIdentifier): void
+    {
+        if ($assetSourceIdentifier !== null && isset($this->assetSources[$assetSourceIdentifier])) {
+            $this->browserState->setActiveAssetSourceIdentifier($assetSourceIdentifier);
+        }
+    }
+    /**
+     * @param int $tagMode
+     * @param Tag $tag
+     * @param AssetCollection|null $activeAssetCollection
+     */
+    private function applyTagToBrowserState(int $tagMode = null, Tag $tag = null, AssetCollection $activeAssetCollection = null): void
+    {
+        if ($tagMode === self::TAG_GIVEN && $tag !== null) {
+            $this->browserState->set('activeTag', $tag);
+            $this->view->assign('activeTag', $tag);
+        } elseif ($tagMode === self::TAG_NONE || $tagMode === self::TAG_ALL) {
+            $this->browserState->set('activeTag', null);
+            $this->view->assign('activeTag', null);
+        }
+        $this->browserState->set('tagMode', $tagMode);
+        if ($activeAssetCollection !== null && $this->browserState->get('activeTag') && !$activeAssetCollection->getTags()->contains($this->browserState->get('activeTag'))) {
+            $this->browserState->set('activeTag', null);
+            $this->view->assign('activeTag', null);
+        }
+        if (!$this->browserState->get('activeTag') && $this->browserState->get('tagMode') === self::TAG_GIVEN) {
+            $this->browserState->set('tagMode', self::TAG_ALL);
+        }
+    }
+    /**
+     * @return AssetSourceInterface
+     */
+    private function getAssetSourceFromBrowserState(): AssetSourceInterface
+    {
+        $assetSourceIdentifier = $this->browserState->getActiveAssetSourceIdentifier();
+        if (!isset($this->assetSources[$assetSourceIdentifier])) {
+            $assetSourceIdentifiers = array_keys($this->assetSources);
+            $assetSourceIdentifier = reset($assetSourceIdentifiers);
+        }
+        return $this->assetSources[$assetSourceIdentifier];
+    }
+    /**
+     * @param int $collectionMode
+     * @param AssetCollection $assetCollection
+     */
+    private function applyAssetCollectionOptionsToBrowserState(int $collectionMode = null, AssetCollection $assetCollection = null): void
+    {
+        if ($collectionMode === self::COLLECTION_GIVEN && $assetCollection !== null) {
+            $this->browserState->set('activeAssetCollection', $assetCollection);
+            $this->view->assign('activeAssetCollection', $assetCollection);
+        } elseif ($collectionMode === self::COLLECTION_ALL) {
+            $this->browserState->set('activeAssetCollection', null);
+            $this->view->assign('activeAssetCollection', null);
+        }
+        $this->browserState->set('collectionMode', $collectionMode);
+    }
+    /**
+     * @return AssetCollection|null
+     */
+    private function getActiveAssetCollectionFromBrowserState(): ?AssetCollection
+    {
+        try {
+            /** @var AssetCollection $activeAssetCollection */
+            $activeAssetCollection = $this->browserState->get('activeAssetCollection');
+            if ($activeAssetCollection instanceof DoctrineProxy) {
+                $activeAssetCollection->__load();
+            }
+        } catch (EntityNotFoundException $exception) {
+            $this->browserState->set('activeAssetCollection', null);
+            $activeAssetCollection = null;
+        }
+        return $activeAssetCollection;
+    }
+    /**
+     * @param AssetProxyRepositoryInterface $assetProxyRepository
+     */
+    private function applySortingFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
+    {
+        if ($assetProxyRepository instanceof SupportsSortingInterface) {
+            switch ($this->browserState->get('sortBy')) {
+                case 'Name':
+                    $assetProxyRepository->orderBy(['resource.filename' => $this->browserState->get('sortDirection')]);
+                    break;
+                case 'Modified':
+                default:
+                    $assetProxyRepository->orderBy(['lastModified' => $this->browserState->get('sortDirection')]);
+                    break;
+            }
+        }
+    }
+    /**
+     * @param AssetProxyRepositoryInterface $assetProxyRepository
+     */
+    private function applyAssetTypeFilterFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
+    {
+        $assetProxyRepository->filterByType($this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')));
+    }
+    /**
+     * @param AssetProxyRepositoryInterface $assetProxyRepository
+     */
+    private function applyAssetCollectionFilterFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
+    {
+        if ($assetProxyRepository instanceof SupportsCollectionsInterface) {
+            $assetProxyRepository->filterByCollection($this->getActiveAssetCollectionFromBrowserState());
+        }
+    }
+    /**
+     * Custom redirect method that adds "constraints" arguments from the current request
+     *
+     * @param array $arguments
+     * @throws StopActionException | NoSuchArgumentException
+     */
+    private function redirectToIndex(array $arguments = []): void
+    {
+        if (!isset($arguments['constraints']) && $this->request->hasArgument('constraints')) {
+            $arguments['constraints'] = $this->request->getArgument('constraints');
+        }
+        $this->redirect('index', null, null, $arguments);
+    }
+    /**
+     * Custom forward method that adds "constraints" arguments from the current request
+     *
+     * @param string $actionName
+     * @param string $controllerName
+     * @param array $arguments
+     * @throws ForwardException | NoSuchArgumentException
+     */
+    private function forwardWithConstraints(string $actionName, string $controllerName, array $arguments = []): void
+    {
+        if (!isset($arguments['constraints']) && $this->request->hasArgument('constraints')) {
+            $arguments['constraints'] = $this->request->getArgument('constraints');
+        }
+        $this->forward($actionName, $controllerName, null, $arguments);
+    }
+}

--- a//dev/null
+++ b/Neos.Media/Classes/Domain/Model/AssetSource/Neos/NeosAssetProxyRepository.php
@@ -0,0 +1,254 @@
+<?php
+namespace Neos\Media\Domain\Model\AssetSource\Neos;
+/*
+ * This file is part of the Neos.Media package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+  *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Doctrine\ORM\EntityManagerInterface;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\ObjectManagement\ObjectManagerInterface;
+use Neos\Flow\Persistence\Exception\InvalidQueryException;
+use Neos\Flow\Persistence\QueryInterface;
+use Neos\Media\Domain\Model\AssetCollection;
+use Neos\Media\Domain\Model\AssetInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetNotFoundExceptionInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetProxy\AssetProxyInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetProxyQueryResultInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetProxyRepositoryInterface;
+use Neos\Media\Domain\Model\AssetSource\AssetTypeFilter;
+use Neos\Media\Domain\Model\AssetSource\SupportsCollectionsInterface;
+use Neos\Media\Domain\Model\AssetSource\SupportsSortingInterface;
+use Neos\Media\Domain\Model\AssetSource\SupportsTaggingInterface;
+use Neos\Media\Domain\Model\Tag;
+use Neos\Media\Domain\Repository\AssetRepository;
+use Neos\Media\Domain\Repository\AudioRepository;
+use Neos\Media\Domain\Repository\DocumentRepository;
+use Neos\Media\Domain\Repository\ImageRepository;
+use Neos\Media\Domain\Repository\VideoRepository;
+final class NeosAssetProxyRepository implements AssetProxyRepositoryInterface, SupportsSortingInterface, SupportsCollectionsInterface, SupportsTaggingInterface
+{
+    /**
+     * @Flow\Inject
+     * @var ObjectManagerInterface
+     */
+    protected $objectManager;
+    /**
+     * @Flow\Inject
+     * @var EntityManagerInterface
+     */
+    protected $entityManager;
+    /**
+     * @var NeosAssetSource
+     */
+    private $assetSource;
+    /**
+     * @var AssetRepository
+     */
+    private $assetRepository;
+    /**
+     * @var string
+     */
+    private $assetTypeFilter = 'All';
+    /**
+     * @var AssetCollection
+     */
+    private $activeAssetCollection;
+    /**
+     * @var array
+     */
+    private $assetRepositoryClassNames = [
+        'All' => AssetRepository::class,
+        'Image' => ImageRepository::class,
+        'Document' => DocumentRepository::class,
+        'Video' => VideoRepository::class,
+        'Audio' => AudioRepository::class
+    ];
+    /**
+     * @param NeosAssetSource $assetSource
+     */
+    public function __construct(NeosAssetSource $assetSource)
+    {
+        $this->assetSource = $assetSource;
+    }
+    /**
+     * @return void
+     */
+    public function initializeObject(): void
+    {
+        $this->assetRepository = $this->objectManager->get($this->assetRepositoryClassNames[$this->assetTypeFilter]);
+    }
+    /**
+     * Sets the property names to order results by. Expected like this:
+     * array(
+     *  'foo' => \Neos\Flow\Persistence\QueryInterface::ORDER_ASCENDING,
+     *  'bar' => \Neos\Flow\Persistence\QueryInterface::ORDER_DESCENDING
+     * )
+     *
+     * @param array $orderings The property names to order by by default
+     * @return void
+     * @api
+     */
+    public function orderBy(array $orderings):void
+    {
+        $this->assetRepository->setDefaultOrderings($orderings);
+    }
+    /**
+     * @param AssetTypeFilter $assetType
+     */
+    public function filterByType(AssetTypeFilter $assetType = null): void
+    {
+        $this->assetTypeFilter = (string)$assetType ?: 'All';
+        $this->initializeObject();
+    }
+    /**
+     * NOTE: This needs to be refactored to use an asset collection identifier instead of Media's domain model before
+     *       it can become a public API for other asset sources.
+     *
+     * @param AssetCollection $assetCollection
+     */
+    public function filterByCollection(AssetCollection $assetCollection = null): void
+    {
+        $this->activeAssetCollection = $assetCollection;
+    }
+    /**
+     * @param string $identifier
+     * @return AssetProxyInterface
+     * @throws AssetNotFoundExceptionInterface
+     */
+    public function getAssetProxy(string $identifier): AssetProxyInterface
+    {
+        $asset = $this->assetRepository->findByIdentifier($identifier);
+        if ($asset === null || !$asset instanceof AssetInterface) {
+            throw new NeosAssetNotFoundException('The specified asset was not found.', 1509632861);
+        }
+        return new NeosAssetProxy($asset, $this->assetSource);
+    }
+    /**
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findAll(): AssetProxyQueryResultInterface
+    {
+        $queryResult = $this->assetRepository->findAll($this->activeAssetCollection);
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
+        $query = $this->filterOutImageVariants($query);
+        return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
+    }
+    /**
+     * @param string $searchTerm
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findBySearchTerm(string $searchTerm): AssetProxyQueryResultInterface
+    {
+        $queryResult = $this->assetRepository->findBySearchTermOrTags($searchTerm, [], $this->activeAssetCollection);
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
+        $query = $this->filterOutImageVariants($query);
+        return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
+    }
+    /**
+     * @param Tag $tag
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findByTag(Tag $tag): AssetProxyQueryResultInterface
+    {
+        $queryResult = $this->assetRepository->findByTag($tag, $this->activeAssetCollection);
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
+        $query = $this->filterOutImageVariants($query);
+        return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
+    }
+    /**
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findUntagged(): AssetProxyQueryResultInterface
+    {
+        $queryResult = $this->assetRepository->findUntagged($this->activeAssetCollection);
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
+        $query = $this->filterOutImageVariants($query);
+        return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
+    }
+    /**
+     * @return int
+     */
+    public function countAll(): int
+    {
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($this->assetRepository->createQuery());
+        $query = $this->filterOutAssetsFromOtherAssetCollections($query);
+        $query = $this->filterOutImageVariants($query);
+        return $query->count();
+    }
+    /**
+     * @return int
+     */
+    public function countUntagged(): int
+    {
+        $query = $this->assetRepository->createQuery();
+        try {
+            $query->matching($query->isEmpty('tags'));
+        } catch (InvalidQueryException $e) {
+        }
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($query);
+        $query = $this->filterOutAssetsFromOtherAssetCollections($query);
+        $query = $this->filterOutImageVariants($query);
+        return $query->count();
+    }
+    /**
+     * @return int
+     */
+    public function countByTag(Tag $tag): int
+    {
+        $queryResult = $this->assetRepository->findByTag($tag, $this->activeAssetCollection);
+        $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
+        $query = $this->filterOutImageVariants($query);
+        return $query->count();
+    }
+    /**
+     * @param QueryInterface $query
+     * @return QueryInterface
+     */
+    private function filterOutImportedAssetsFromOtherAssetSources(QueryInterface $query): QueryInterface
+    {
+        $constraint = $query->getConstraint();
+        $query->matching(
+            $query->logicalAnd([
+                $constraint,
+                $query->equals('assetSourceIdentifier', 'neos')
+            ])
+        );
+        return $query;
+    }
+    /**
+     * @param QueryInterface $query
+     * @return QueryInterface
+     */
+    private function filterOutImageVariants(QueryInterface $query): QueryInterface
+    {
+        $queryBuilder = $query->getQueryBuilder();
+        $queryBuilder->andWhere('e NOT INSTANCE OF Neos\Media\Domain\Model\ImageVariant');
+        return $query;
+    }
+    /**
+     * @param QueryInterface $query
+     * @return QueryInterface
+     */
+    private function filterOutAssetsFromOtherAssetCollections(QueryInterface $query): QueryInterface
+    {
+        if ($this->activeAssetCollection === null) {
+            return $query;
+        }
+        $constraints = $query->getConstraint();
+        try {
+            $query->matching(
+                $query->logicalAnd([
+                    $constraints,
+                    $query->contains('assetCollections', $this->activeAssetCollection)
+                ])
+            );
+        } catch (InvalidQueryException $e) {
+        }
+        return $query;
+    }
+}

--- a//dev/null
+++ b/Neos.Media/Classes/Domain/Model/AssetSource/SupportsTaggingInterface.php
@@ -0,0 +1,36 @@
+<?php
+namespace Neos\Media\Domain\Model\AssetSource;
+/*
+ * This file is part of the Neos.Media package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+  *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Media\Domain\Model\Tag;
+interface SupportsTaggingInterface
+{
+    /**
+     * NOTE: This needs to be refactored to use a tag identifier instead of Media's domain model before
+     *       it can become a public API for other asset sources.
+     *
+     * @param Tag $tag
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findByTag(Tag $tag): AssetProxyQueryResultInterface;
+    /**
+     * @return AssetProxyQueryResultInterface
+     */
+    public function findUntagged(): AssetProxyQueryResultInterface;
+    /**
+     * @return int
+     */
+    public function countUntagged(): int;
+    /**
+     * @param Tag $tag
+     * @return int
+     */
+    public function countByTag(Tag $tag): int;
+}

--- a//dev/null
+++ b/Neos.Media/Documentation/conf.py
@@ -0,0 +1,31 @@
+import os
+import sys
+from sphinx.highlighting import lexers
+from pygments.lexers.web import PhpLexer
+project = 'Neos Media'
+copyright = '2006 and onwards by the authors'
+author = 'Neos Team and Contributors'
+version = 'dev-master'
+release = 'dev-master'
+extensions = [
+    'sphinx_rtd_theme',
+    'sphinx.ext.intersphinx',
+    'sphinx.ext.todo',
+    'sphinx.ext.ifconfig'
+]
+templates_path = ['_templates']
+exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+highlight_language='php'
+html_theme = 'sphinx_rtd_theme'
+html_static_path = ['_static']
+html_theme_options = {
+  'prev_next_buttons_location': 'both',
+  'style_external_links': True
+}
+intersphinx_mapping = {
+    'neos': ('https://neos.readthedocs.io/en/stable', None),
+    'media': ('https://neos-media.readthedocs.io/en/stable', None),
+    'flow': ('https://flowframework.readthedocs.io/en/stable', None),
+}
+lexers['php'] = PhpLexer(startinline=True)
+lexers['php-annotations'] = PhpLexer(startinline=True)

--- a//dev/null
+++ b/Neos.Neos/Classes/Aspects/NodeTypeConfigurationEnrichmentAspect.php
@@ -0,0 +1,324 @@
+<?php
+namespace Neos\Neos\Aspects;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Aop\JoinPointInterface;
+use Neos\Flow\ResourceManagement\ResourceManager;
+use Neos\Utility\Arrays;
+use Neos\ContentRepository\Domain\Model\NodeType;
+/**
+ * @Flow\Scope("singleton")
+ * @Flow\Aspect
+ */
+class NodeTypeConfigurationEnrichmentAspect
+{
+    /**
+     * @var array
+     * @Flow\InjectConfiguration(package="Neos.Neos", path="userInterface.inspector.dataTypes")
+     */
+    protected $dataTypesDefaultConfiguration;
+    /**
+     * @var array
+     * @Flow\InjectConfiguration(package="Neos.Neos", path="userInterface.inspector.editors")
+     */
+    protected $editorDefaultConfiguration;
+    /**
+     * @Flow\Inject
+     * @var \Neos\Flow\I18n\Translator
+     */
+    protected $translator;
+    /**
+     * @Flow\Inject
+     * @var ResourceManager
+     */
+    protected $resourceManager;
+    /**
+     * @Flow\Around("method(Neos\ContentRepository\Domain\Model\NodeType->__construct())")
+     * @param JoinPointInterface $joinPoint
+     * @return void
+     */
+    public function enrichNodeTypeLabelsConfiguration(JoinPointInterface $joinPoint): void
+    {
+        $declaredSuperTypes = $joinPoint->getMethodArgument('declaredSuperTypes');
+        $configuration = $joinPoint->getMethodArgument('configuration');
+        $nodeTypeName = $joinPoint->getMethodArgument('name');
+        $this->addLabelsToNodeTypeConfiguration($nodeTypeName, $configuration, $declaredSuperTypes);
+        $joinPoint->setMethodArgument('configuration', $configuration);
+        $joinPoint->getAdviceChain()->proceed($joinPoint);
+    }
+    /**
+     * @param string $nodeTypeName
+     * @param array $configuration
+     * @param array $declaredSuperTypes
+     * @return void
+     */
+    protected function addLabelsToNodeTypeConfiguration($nodeTypeName, array &$configuration, array $declaredSuperTypes)
+    {
+        if (isset($configuration['ui'])) {
+            $this->setGlobalUiElementLabels($nodeTypeName, $configuration);
+        }
+        if (isset($configuration['properties'])) {
+            $this->setPropertyLabels($nodeTypeName, $configuration, $declaredSuperTypes);
+        }
+    }
+    /**
+     * @param string $nodeTypeLabelIdPrefix
+     * @param array $configuration
+     * @param array $declaredSuperTypes
+     * @return void
+     */
+    protected function setPropertyLabels($nodeTypeName, array &$configuration, array $declaredSuperTypes)
+    {
+        $nodeTypeLabelIdPrefix = $this->generateNodeTypeLabelIdPrefix($nodeTypeName);
+        foreach ($configuration['properties'] as $propertyName => &$propertyConfiguration) {
+            if (!isset($propertyConfiguration['ui'])) {
+                continue;
+            }
+            if ($this->shouldFetchTranslation($propertyConfiguration['ui'])) {
+                $propertyConfiguration['ui']['label'] = $this->getPropertyLabelTranslationId($nodeTypeLabelIdPrefix, $propertyName);
+            }
+            $editorName = $propertyConfiguration['ui']['inspector']['editor']
+                ?? array_reduce($declaredSuperTypes, function ($editorName, ?NodeType $superType) use ($propertyName) {
+                    if ($editorName !== null || $superType === null) {
+                        return $editorName;
+                    }
+                    $superTypeConfiguration = $superType->getLocalConfiguration();
+                    return $superTypeConfiguration['properties'][$propertyName]['ui']['inspector']['editor'] ?? null;
+                }, null);
+            $hasEditor = !is_null($editorName);
+            $hasEditorOptions = isset($propertyConfiguration['ui']['inspector']['editorOptions']);
+            if ($hasEditor && $hasEditorOptions) {
+                $translationIdGenerator = function ($path) use ($nodeTypeLabelIdPrefix, $propertyName) {
+                    return $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, $path);
+                };
+                $this->applyEditorLabels($nodeTypeLabelIdPrefix, $propertyName, $editorName, $propertyConfiguration['ui']['inspector']['editorOptions'], $translationIdGenerator);
+            }
+            if (isset($propertyConfiguration['ui']['inline']['editorOptions']) && $this->shouldFetchTranslation($propertyConfiguration['ui']['inline']['editorOptions'], 'placeholder')) {
+                $propertyConfiguration['ui']['inline']['editorOptions']['placeholder'] = $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, 'ui.inline.editorOptions.placeholder');
+            }
+            if (isset($propertyConfiguration['ui']['help']['message']) && $this->shouldFetchTranslation($propertyConfiguration['ui']['help'], 'message')) {
+                $propertyConfiguration['ui']['help']['message'] = $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, 'ui.help.message');
+            }
+        }
+    }
+    /**
+     * Resolve help message thumbnail url
+     *
+     * @param string $nodeTypeName
+     * @param string $configurationThumbnail
+     * @return string $thumbnailUrl
+     */
+    protected function resolveHelpMessageThumbnail($nodeTypeName, $configurationThumbnail)
+    {
+        if ($nodeTypeName !== null) {
+            $thumbnailUrl = '';
+            if (isset($configurationThumbnail)) {
+                $thumbnailUrl = $configurationThumbnail;
+                if (strpos($thumbnailUrl, 'resource://') === 0) {
+                    $thumbnailUrl = $this->resourceManager->getPublicPackageResourceUriByPath($thumbnailUrl);
+                }
+            } else {
+                $splitPrefix = $this->splitIdentifier($nodeTypeName);
+                $relativePathAndFilename = 'NodeTypes/Thumbnails/' . $splitPrefix['id'] . '.png';
+                $resourcePath = 'resource://' . $splitPrefix['packageKey'] . '/Public/' . $relativePathAndFilename;
+                if (file_exists($resourcePath)) {
+                    $thumbnailUrl = $this->resourceManager->getPublicPackageResourceUriByPath($resourcePath);
+                }
+            }
+            return $thumbnailUrl;
+        }
+    }
+    /**
+     * @param string $nodeTypeLabelIdPrefix
+     * @param string $propertyName
+     * @param string $editorName
+     * @param array $editorOptions
+     * @param callable $translationIdGenerator
+     * @return void
+     */
+    protected function applyEditorLabels($nodeTypeLabelIdPrefix, $propertyName, $editorName, array &$editorOptions, $translationIdGenerator)
+    {
+        switch ($editorName) {
+            case 'Neos.Neos/Inspector/Editors/SelectBoxEditor':
+                if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
+                    $editorOptions['placeholder'] = $translationIdGenerator('selectBoxEditor.placeholder');
+                }
+                if (!isset($editorOptions['values']) || !is_array($editorOptions['values'])) {
+                    break;
+                }
+                foreach ($editorOptions['values'] as $value => &$optionConfiguration) {
+                    if ($optionConfiguration === null) {
+                        continue;
+                    }
+                    if ($this->shouldFetchTranslation($optionConfiguration)) {
+                        $optionConfiguration['label'] = $translationIdGenerator('selectBoxEditor.values.' . $value);
+                    }
+                }
+                break;
+            case 'Neos.Neos/Inspector/Editors/CodeEditor':
+                if ($this->shouldFetchTranslation($editorOptions, 'buttonLabel')) {
+                    $editorOptions['buttonLabel'] = $translationIdGenerator('codeEditor.buttonLabel');
+                }
+                break;
+            case 'Neos.Neos/Inspector/Editors/TextFieldEditor':
+                if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
+                    $editorOptions['placeholder'] = $translationIdGenerator('textFieldEditor.placeholder');
+                }
+                break;
+            case 'Neos.Neos/Inspector/Editors/TextAreaEditor':
+                if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
+                    $editorOptions['placeholder'] = $translationIdGenerator('textAreaEditor.placeholder');
+                }
+                break;
+        }
+    }
+    /**
+     * Sets labels for global NodeType elements like tabs and groups and the general label.
+     *
+     * @param string $nodeTypeLabelIdPrefix
+     * @param array $configuration
+     * @return void
+     */
+    protected function setGlobalUiElementLabels($nodeTypeName, array &$configuration)
+    {
+        $nodeTypeLabelIdPrefix = $this->generateNodeTypeLabelIdPrefix($nodeTypeName);
+        if ($this->shouldFetchTranslation($configuration['ui'])) {
+            $configuration['ui']['label'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'ui', 'label');
+        }
+        if (isset($configuration['ui']['help']['message']) && $this->shouldFetchTranslation($configuration['ui']['help'], 'message')) {
+            $configuration['ui']['help']['message'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'ui', 'help.message');
+        }
+        if (isset($configuration['ui']['help'])) {
+            $configurationThumbnail = isset($configuration['ui']['help']['thumbnail']) ? $configuration['ui']['help']['thumbnail'] : null;
+            $thumbnailUrl = $this->resolveHelpMessageThumbnail($nodeTypeName, $configurationThumbnail);
+            if ($thumbnailUrl !== '') {
+                $configuration['ui']['help']['thumbnail'] = $thumbnailUrl;
+            }
+        }
+        $inspectorConfiguration = Arrays::getValueByPath($configuration, 'ui.inspector');
+        if (is_array($inspectorConfiguration)) {
+            foreach ($inspectorConfiguration as $elementTypeName => $elementTypeItems) {
+                foreach ($elementTypeItems as $elementName => $elementConfiguration) {
+                    if (!is_array($elementConfiguration) || !$this->shouldFetchTranslation($elementConfiguration)) {
+                        continue;
+                    }
+                    $translationLabelId = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, $elementTypeName, $elementName);
+                    $configuration['ui']['inspector'][$elementTypeName][$elementName]['label'] = $translationLabelId;
+                }
+            }
+        }
+        $creationDialogConfiguration = Arrays::getValueByPath($configuration, 'ui.creationDialog.elements');
+        if (is_array($creationDialogConfiguration)) {
+            $creationDialogConfiguration = &$configuration['ui']['creationDialog']['elements'];
+            foreach ($creationDialogConfiguration as $elementName => &$elementConfiguration) {
+                if (isset($elementConfiguration['ui']['editor']) && isset($elementConfiguration['ui']['editorOptions'])) {
+                    $translationIdGenerator = function ($path) use ($nodeTypeLabelIdPrefix, $elementName) {
+                        return $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'creationDialog', $elementName . '.' . $path);
+                    };
+                    $this->applyEditorLabels($nodeTypeLabelIdPrefix, $elementName, $elementConfiguration['ui']['editor'], $elementConfiguration['ui']['editorOptions'], $translationIdGenerator);
+                }
+                if (!is_array($elementConfiguration) || !$this->shouldFetchTranslation($elementConfiguration['ui'])) {
+                    continue;
+                }
+                $elementConfiguration['ui']['label'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'creationDialog', $elementName);
+            }
+        }
+    }
+    /**
+     * Should a label be generated for the given field or is there something configured?
+     *
+     * @param array $parentConfiguration
+     * @param string $fieldName Name of the possibly existing subfield
+     * @return boolean
+     */
+    protected function shouldFetchTranslation(array $parentConfiguration, $fieldName = 'label')
+    {
+        $fieldValue = array_key_exists($fieldName, $parentConfiguration) ? $parentConfiguration[$fieldName] : '';
+        return (trim($fieldValue) === 'i18n');
+    }
+    /**
+     * Generates a generic inspector element label with the given $nodeTypeSpecificPrefix.
+     *
+     * @param string $nodeTypeSpecificPrefix
+     * @param string $elementType
+     * @param string $elementName
+     * @return string
+     */
+    protected function getInspectorElementTranslationId($nodeTypeSpecificPrefix, $elementType, $elementName)
+    {
+        return $nodeTypeSpecificPrefix . $elementType . '.' . $elementName;
+    }
+    /**
+     * Generates a property label with the given $nodeTypeSpecificPrefix.
+     *
+     * @param string $nodeTypeSpecificPrefix
+     * @param string $propertyName
+     * @return string
+     */
+    protected function getPropertyLabelTranslationId($nodeTypeSpecificPrefix, $propertyName)
+    {
+        return $nodeTypeSpecificPrefix . 'properties.' . $propertyName;
+    }
+    /**
+     * Generates a property configuration-label with the given $nodeTypeSpecificPrefix.
+     *
+     * @param string $nodeTypeSpecificPrefix
+     * @param string $propertyName
+     * @param string $labelPath
+     * @return string
+     */
+    protected function getPropertyConfigurationTranslationId($nodeTypeSpecificPrefix, $propertyName, $labelPath)
+    {
+        return $nodeTypeSpecificPrefix . 'properties.' . $propertyName . '.' . $labelPath;
+    }
+    /**
+     * Generates a label prefix for a specific node type with this format: "Vendor_Package:NodeTypes.NodeTypeName"
+     *
+     * @param string $nodeTypeName
+     * @return string
+     */
+    protected function generateNodeTypeLabelIdPrefix($nodeTypeName)
+    {
+        $nodeTypeNameParts = explode(':', $nodeTypeName, 2);
+        $packageKey = isset($nodeTypeNameParts[1]) ? $nodeTypeNameParts[0] : 'Neos.Neos';
+        $nodeTypeName = isset($nodeTypeNameParts[1]) ? $nodeTypeNameParts[1] : $nodeTypeNameParts[0];
+        return sprintf('%s:%s:', $packageKey, 'NodeTypes.' . $nodeTypeName);
+    }
+    /**
+     * Splits an identifier string of the form PackageKey:id or PackageKey:Source:id into an array with the keys
+     * id, source and packageKey.
+     *
+     * @param string $id translation id with possible package and source parts
+     * @return array
+     */
+    protected function splitIdentifier($id)
+    {
+        $packageKey = 'Neos.Neos';
+        $source = 'Main';
+        $idParts = explode(':', $id, 3);
+        switch (count($idParts)) {
+            case 2:
+                $packageKey = $idParts[0];
+                $id = $idParts[1];
+                break;
+            case 3:
+                $packageKey = $idParts[0];
+                $source = str_replace('.', '/', $idParts[1]);
+                $id = $idParts[2];
+                break;
+        }
+        return [
+            'id' => $id,
+            'source' => $source,
+            'packageKey' => $packageKey
+        ];
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Controller/Backend/ImpersonateController.php
@@ -0,0 +1,175 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Neos\Controller\Backend;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Mvc\Controller\ActionController;
+use Neos\Flow\Mvc\Exception\StopActionException;
+use Neos\Flow\Mvc\Routing\UriBuilder;
+use Neos\Flow\Mvc\View\JsonView;
+use Neos\Flow\Security\Account;
+use Neos\Neos\Domain\Model\User;
+use Neos\Party\Domain\Service\PartyService;
+use Neos\Neos\Service\ImpersonateService;
+/**
+ * The Impersonate controller
+ *
+ * @Flow\Scope("singleton")
+ */
+class ImpersonateController extends ActionController
+{
+    /**
+     * @var ImpersonateService
+     * @Flow\Inject
+     */
+    protected $impersonateService;
+    /**
+     * @var PartyService
+     * @Flow\Inject
+     */
+    protected $partyService;
+    /**
+     * @var string
+     */
+    protected $defaultViewObjectName = JsonView::class;
+    /**
+     * @var array
+     */
+    protected $viewFormatToObjectNameMap = [
+        'json' => JsonView::class
+    ];
+    /**
+     * @var array
+     */
+    protected $supportedMediaTypes = [
+        'application/json'
+    ];
+    public function impersonateAction(Account $account): void
+    {
+        $this->impersonateService->impersonate($account);
+        $this->redirectIfPossible('impersonate');
+    }
+    /**
+     * Fetching possible redirect options for the given action method and if everything is set we redirect to the
+     * configured controller action.
+     */
+    protected function redirectIfPossible(string $actionName): void
+    {
+        $action = $this->settings['redirectOptions'][$actionName]['action'] ?? '';
+        $controller = $this->settings['redirectOptions'][$actionName]['controller'] ?? '';
+        $package = $this->settings['redirectOptions'][$actionName]['package'] ?? '';
+        if ($action !== '' && $controller !== '' && $package !== '' && $this->impersonateService->getImpersonation() === null) {
+            $this->redirectWithParentRequest($action, $controller, $package);
+        }
+    }
+    /**
+     * @param string $actionName Name of the action to forward to
+     * @param string $controllerName Unqualified object name of the controller to forward to. If not specified, the current controller is used.
+     * @param string $packageKey Key of the package containing the controller to forward to. If not specified, the current package is assumed.
+     * @param array $arguments Array of arguments for the target action
+     * @param integer $delay (optional) The delay in seconds. Default is no delay.
+     * @param integer $statusCode (optional) The HTTP status code for the redirect. Default is "303 See Other"
+     * @param string $format The format to use for the redirect URI
+     * @see redirect()
+     */
+    protected function redirectWithParentRequest(string $actionName, string $controllerName = null, string $packageKey = null, array $arguments = [], int $delay = 0, int $statusCode = 303, string $format = null): void
+    {
+        $request = $this->getControllerContext()->getRequest()->getMainRequest();
+        $uriBuilder = new UriBuilder();
+        $uriBuilder->setRequest($request);
+        if ($packageKey !== null && strpos($packageKey, '\\') !== false) {
+            list($packageKey, $subpackageKey) = explode('\\', $packageKey, 2);
+        } else {
+            $subpackageKey = null;
+        }
+        if ($format === null) {
+            $uriBuilder->setFormat($this->request->getFormat());
+        } else {
+            $uriBuilder->setFormat($format);
+        }
+        $uri = $uriBuilder->setCreateAbsoluteUri(true)->uriFor($actionName, $arguments, $controllerName, $packageKey, $subpackageKey);
+        $this->redirectToUri($uri, $delay, $statusCode);
+    }
+    /**
+     * @throws \Neos\Flow\Session\Exception\SessionNotStartedException
+     */
+    public function impersonateUserWithResponseAction(User $user): void
+    {
+        /** @var Account $account */
+        $account = $user->getAccounts()->first();
+        $this->impersonateService->impersonate($account);
+        $impersonateStatus = $this->getImpersonateStatus();
+        $this->view->assign('value', $impersonateStatus);
+    }
+    /**
+     * @throws StopActionException
+     */
+    public function restoreAction(): void
+    {
+        $this->impersonateService->restoreOriginalIdentity();
+        $this->redirectIfPossible('restore');
+    }
+    /**
+     * @throws StopActionException
+     */
+    public function restoreWithResponseAction(): void
+    {
+        /** @var Account $originalIdentity */
+        $originalIdentity = $this->impersonateService->getOriginalIdentity();
+        /** @var Account $impersonateIdentity */
+        $impersonateIdentity = $this->impersonateService->getImpersonation();
+        $response['status'] = false;
+        if ($originalIdentity) {
+            $response['status'] = true;
+            $response['origin'] = [
+                'accountIdentifier' => $originalIdentity->getAccountIdentifier(),
+            ];
+        }
+        if ($impersonateIdentity) {
+            $response['impersonate'] = [
+                'accountIdentifier' => $impersonateIdentity->getAccountIdentifier(),
+            ];
+        }
+        $this->impersonateService->restoreOriginalIdentity();
+        $this->view->assign('value', $response);
+    }
+    public function statusAction(): void
+    {
+        $impersonateStatus = $this->getImpersonateStatus();
+        $this->view->assign('value', $impersonateStatus);
+    }
+    public function getImpersonateStatus(): array
+    {
+        $impersonateStatus = [
+            'status' => false
+        ];
+        if ($this->impersonateService->isActive()) {
+            $currentImpersonation = $this->impersonateService->getImpersonation();
+            $originalIdentity = $this->impersonateService->getOriginalIdentity();
+            /** @var User $user */
+            $user = $this->partyService->getAssignedPartyOfAccount($currentImpersonation);
+            $impersonateStatus['status'] = true;
+            $impersonateStatus['user'] = [
+                'accountIdentifier' => $currentImpersonation->getAccountIdentifier(),
+                'fullName' => $user->getName()->getFullName()
+            ];
+            if ($originalIdentity) {
+                /** @var User $originUser */
+                $originUser = $this->partyService->getAssignedPartyOfAccount($originalIdentity);
+                $impersonateStatus['origin'] = [
+                    'accountIdentifier' => $originalIdentity->getAccountIdentifier(),
+                    'fullName' => $originUser->getName()->getFullName()
+                ];
+            }
+        }
+        return $impersonateStatus;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Controller/Backend/SchemaController.php
@@ -0,0 +1,51 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Neos\Controller\Backend;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Cache\Frontend\VariableFrontend;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Mvc\Controller\ActionController;
+use Neos\Neos\Service\NodeTypeSchemaBuilder;
+/**
+ * @Flow\Scope("singleton")
+ */
+class SchemaController extends ActionController
+{
+    /**
+     * @var NodeTypeSchemaBuilder
+     * @Flow\Inject
+     */
+    protected $nodeTypeSchemaBuilder;
+    /**
+     * @Flow\Inject
+     * @var VariableFrontend
+     */
+    protected $nodeTypeSchemaCache;
+    /**
+     * Get the node type configuration schema for the Neos UI
+     *
+     * @return string
+     */
+    public function nodeTypeSchemaAction(): string
+    {
+        $version = $this->request->hasArgument('version') ? $this->request->getArgument('version') : '';
+        $cacheIdentifier = 'nodeTypeSchema_' . $version;
+        $this->response->setContentType('application/json');
+        $this->response->setHttpHeader('Cache-Control', 'max-age=' . (3600 * 24 * 7));
+        $nodeTypeSchema = $this->nodeTypeSchemaCache->get($cacheIdentifier);
+        if (!$nodeTypeSchema) {
+            $nodeTypeSchema = json_encode($this->nodeTypeSchemaBuilder->generateNodeTypeSchema());
+            $this->nodeTypeSchemaCache->flushByTag('nodeType');
+            $this->nodeTypeSchemaCache->set($cacheIdentifier, $nodeTypeSchema, ['nodeType']);
+        }
+        return $nodeTypeSchema;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Controller/Module/Administration/SitesController.php
@@ -0,0 +1,577 @@
+<?php
+namespace Neos\Neos\Controller\Module\Administration;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Error\Messages\Message;
+use Neos\Flow\I18n\Translator;
+use Neos\Flow\Log\ThrowableStorageInterface;
+use Neos\Flow\Log\Utility\LogEnvironment;
+use Neos\Flow\Package\PackageInterface;
+use Neos\Flow\Package\PackageManager;
+use Neos\Flow\Session\SessionInterface;
+use Neos\Media\Domain\Repository\AssetCollectionRepository;
+use Neos\Neos\Controller\Module\AbstractModuleController;
+use Neos\Neos\Domain\Model\Domain;
+use Neos\Neos\Domain\Model\Site;
+use Neos\Neos\Domain\Repository\DomainRepository;
+use Neos\Neos\Domain\Repository\SiteRepository;
+use Neos\Neos\Domain\Service\SiteImportService;
+use Neos\Neos\Domain\Service\SiteService;
+use Neos\ContentRepository\Domain\Model\Workspace;
+use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
+use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
+use Neos\ContentRepository\Domain\Utility\NodePaths;
+use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
+use Neos\ContentRepository\Domain\Service\NodeTypeManager;
+use Neos\ContentRepository\Domain\Service\NodeService;
+use Neos\SiteKickstarter\Service\SiteGeneratorCollectingService;
+use Neos\SiteKickstarter\Service\SitePackageGeneratorNameService;
+/**
+ * The Neos Sites Management module controller
+ */
+class SitesController extends AbstractModuleController
+{
+    /**
+     * @Flow\Inject
+     * @var DomainRepository
+     */
+    protected $domainRepository;
+    /**
+     * @Flow\Inject
+     * @var SiteRepository
+     */
+    protected $siteRepository;
+    /**
+     * @Flow\Inject
+     * @var NodeDataRepository
+     */
+    protected $nodeDataRepository;
+    /**
+     * @Flow\Inject
+     * @var ContextFactoryInterface
+     */
+    protected $nodeContextFactory;
+    /**
+     * @Flow\Inject
+     * @var NodeService
+     */
+    protected $nodeService;
+    /**
+     * @Flow\Inject
+     * @var NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * @Flow\Inject
+     * @var WorkspaceRepository
+     */
+    protected $workspaceRepository;
+    /**
+     * @Flow\Inject
+     * @var AssetCollectionRepository
+     */
+    protected $assetCollectionRepository;
+    /**
+     * @Flow\Inject
+     * @var PackageManager
+     */
+    protected $packageManager;
+    /**
+     * @Flow\Inject
+     * @var SiteImportService
+     */
+    protected $siteImportService;
+    /**
+     * @Flow\Inject
+     * @var SiteService
+     */
+    protected $siteService;
+    /**
+     * @Flow\Inject
+     * @var SessionInterface
+     */
+    protected $session;
+    /**
+     * @Flow\Inject
+     * @var Translator
+     */
+    protected $translator;
+    /**
+     * @var ThrowableStorageInterface
+     */
+    private $throwableStorage;
+    /**
+     * @param ThrowableStorageInterface $throwableStorage
+     */
+    public function injectThrowableStorage(ThrowableStorageInterface $throwableStorage)
+    {
+        $this->throwableStorage = $throwableStorage;
+    }
+    /**
+     * @return void
+     */
+    public function indexAction()
+    {
+        $sitePackagesAndSites = [];
+        foreach ($this->packageManager->getFilteredPackages('available', 'neos-site') as $sitePackageKey => $sitePackage) {
+            /** @var PackageInterface $sitePackage */
+            $sitePackagesAndSites[strtolower(str_replace('.', '_', $sitePackageKey))] = ['package' => $sitePackage, 'packageKey' => $sitePackage->getPackageKey()];
+        }
+        $sites = $this->siteRepository->findAll();
+        foreach ($sites as $site) {
+            $siteResourcePackageKey = strtolower(str_replace('.', '_', $site->getSiteResourcesPackageKey()));
+            if (!isset($sitePackagesAndSites[$siteResourcePackageKey])) {
+                $sitePackagesAndSites[$siteResourcePackageKey] = ['packageKey' => $site->getSiteResourcesPackageKey()];
+            }
+            if (!isset($sitePackagesAndSites[$siteResourcePackageKey]['sites'])) {
+                $sitePackagesAndSites[$siteResourcePackageKey]['sites'] = [];
+            }
+            $sitePackagesAndSites[$siteResourcePackageKey]['sites'][] = $site;
+        }
+        $this->view->assignMultiple([
+            'sitePackagesAndSites' => $sitePackagesAndSites,
+            'multipleSites' => count($sites) > 1
+        ]);
+    }
+    /**
+     * A edit view for a site and its settings.
+     *
+     * @param Site $site Site to view
+     * @Flow\IgnoreValidation("$site")
+     * @return void
+     */
+    public function editAction(Site $site)
+    {
+        try {
+            $sitePackage = $this->packageManager->getPackage($site->getSiteResourcesPackageKey());
+        } catch (\Exception $e) {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.sitePackageNotFound.body', [htmlspecialchars($site->getSiteResourcesPackageKey())], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.sitePackageNotFound.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR
+            );
+        }
+        $this->view->assignMultiple([
+            'site' => $site,
+            'sitePackage' => isset($sitePackage) ? $sitePackage : [],
+            'domains' => $this->domainRepository->findBySite($site),
+            'assetCollections' => $this->assetCollectionRepository->findAll()
+        ]);
+    }
+    /**
+     * Update a site
+     *
+     * @param Site $site A site to update
+     * @param string $newSiteNodeName A new site node name
+     * @return void
+     * @Flow\Validate(argumentName="$site", type="UniqueEntity")
+     * @Flow\Validate(argumentName="$newSiteNodeName", type="NotEmpty")
+     * @Flow\Validate(argumentName="$newSiteNodeName", type="StringLength", options={ "minimum"=1, "maximum"=250 })
+     * @Flow\Validate(argumentName="$newSiteNodeName", type="Neos.Neos:NodeName")
+     */
+    public function updateSiteAction(Site $site, $newSiteNodeName)
+    {
+        if ($site->getNodeName() !== $newSiteNodeName) {
+            $oldSiteNodePath = NodePaths::addNodePathSegment(SiteService::SITES_ROOT_PATH, $site->getNodeName());
+            $newSiteNodePath = NodePaths::addNodePathSegment(SiteService::SITES_ROOT_PATH, $newSiteNodeName);
+            /** @var $workspace Workspace */
+            foreach ($this->workspaceRepository->findAll() as $workspace) {
+                $siteNode = $this->nodeDataRepository->findOneByPath($oldSiteNodePath, $workspace);
+                if ($siteNode !== null) {
+                    $siteNode->setPath($newSiteNodePath);
+                }
+            }
+            $site->setNodeName($newSiteNodeName);
+            $this->nodeDataRepository->persistEntities();
+        }
+        $this->siteRepository->update($site);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.update.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.update.title', [], null, null, 'Modules', 'Neos.Neos'),
+            null,
+            [],
+            1412371798
+        );
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Create a new site form.
+     *
+     * @param Site $site Site to create
+     * @Flow\IgnoreValidation("$site")
+     * @return void
+     */
+    public function newSiteAction(Site $site = null)
+    {
+        $sitePackages = $this->packageManager->getFilteredPackages('available', 'neos-site');
+        $documentNodeTypes = $this->nodeTypeManager->getSubNodeTypes('Neos.Neos:Document', false);
+        $generatorServiceIsAvailable = $this->packageManager->isPackageAvailable('Neos.SiteKickstarter');
+        $generatorServices = [];
+        if ($generatorServiceIsAvailable) {
+            $siteGeneratorCollectingService = $this->objectManager->get(SiteGeneratorCollectingService::class);
+            $sitePackageGeneratorNameService = $this->objectManager->get(SitePackageGeneratorNameService::class);
+            $generatorClasses = $siteGeneratorCollectingService->getAllGenerators();
+            foreach ($generatorClasses as $generatorClass) {
+                $name = $sitePackageGeneratorNameService->getNameOfSitePackageGenerator($generatorClass);
+                $generatorServices[$generatorClass] = $name;
+            }
+        }
+        $this->view->assignMultiple([
+            'sitePackages' => $sitePackages,
+            'documentNodeTypes' => $documentNodeTypes,
+            'site' => $site,
+            'generatorServiceIsAvailable' => $generatorServiceIsAvailable,
+            'generatorServices' => $generatorServices
+        ]);
+    }
+    /**
+     * Create a new site-package and directly import it.
+     *
+     * @param string $packageKey Package Name to create
+     * @param string $generatorClass Generator Class to generate the site package
+     * @param string $siteName Site Name to create
+     * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
+     * @return void
+     */
+    public function createSitePackageAction(string $packageKey, string $generatorClass, string $siteName) : void
+    {
+        if ($this->packageManager->isPackageAvailable('Neos.SiteKickstarter') === false) {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.missingPackage.body', ['Neos.SiteKickstarter'], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.missingPackage.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1475736232
+            );
+            $this->redirect('index');
+        }
+        if ($this->packageManager->isPackageAvailable($packageKey)) {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.invalidPackageKey.body', [htmlspecialchars($packageKey)], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.invalidPackageKey.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1412372021
+            );
+            $this->redirect('index');
+        }
+        if ($this->objectManager->has($generatorClass) === false) {
+            $this->addFlashMessage('The generator class "%s" is not present.', 'Missing generator class', Message::SEVERITY_ERROR, [$generatorClass]);
+            $this->redirect('index');
+        }
+        $generatorService = $this->objectManager->get($generatorClass);
+        $generatorService->generateSitePackage($packageKey, $siteName);
+        $this->controllerContext->getFlashMessageContainer()->addMessage(new Message(sprintf(
+            $this->translator->translateById('sites.sitePackagesWasCreated.body', [htmlspecialchars($packageKey)], null, null, 'Modules', 'Neos.Neos'),
+            '',
+            null
+        )));
+        $this->forward('importSite', null, null, ['packageKey' => $packageKey]);
+    }
+    /**
+     * Import a site from site package.
+     *
+     * @param string $packageKey Package from where the import will come
+     * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
+     * @return void
+     */
+    public function importSiteAction($packageKey)
+    {
+        try {
+            $this->siteImportService->importFromPackage($packageKey);
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.theSiteHasBeenImported.body', [], null, null, 'Modules', 'Neos.Neos'),
+                '',
+                null,
+                [],
+                1412372266
+            );
+        } catch (\Exception $exception) {
+            $logMessage = $this->throwableStorage->logThrowable($exception);
+            $this->logger->error($logMessage, LogEnvironment::fromMethodName(__METHOD__));
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.importError.body', [htmlspecialchars($packageKey), htmlspecialchars($exception->getMessage())], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.importError.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1412372375
+            );
+        }
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Create a new empty site.
+     *
+     * @param string $packageKey Package Name to create
+     * @param string $siteName Site Name to create
+     * @param string $nodeType NodeType name for the root node to create
+     * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
+     * @return void
+     */
+    public function createSiteNodeAction($packageKey, $siteName, $nodeType)
+    {
+        $nodeName = $this->nodeService->generateUniqueNodeName(SiteService::SITES_ROOT_PATH, $siteName);
+        if ($this->siteRepository->findOneByNodeName($nodeName)) {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.SiteCreationError.siteWithSiteNodeNameAlreadyExists.body', [$nodeName], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.SiteCreationError.siteWithSiteNodeNameAlreadyExists.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1412372375
+            );
+            $this->redirect('createSiteNode');
+        }
+        $siteNodeType = $this->nodeTypeManager->getNodeType($nodeType);
+        if ($siteNodeType === null || $siteNodeType->getName() === 'Neos.Neos:FallbackNode') {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotFound.body', [$nodeType], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotFound.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1412372375
+            );
+            $this->redirect('createSiteNode');
+        }
+        if ($siteNodeType->isOfType('Neos.Neos:Document') === false) {
+            $this->addFlashMessage(
+                $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotBasedOnSuperType.body', [$nodeType, 'Neos.Neos:Document'], null, null, 'Modules', 'Neos.Neos'),
+                $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotBasedOnSuperType.title', [], null, null, 'Modules', 'Neos.Neos'),
+                Message::SEVERITY_ERROR,
+                [],
+                1412372375
+            );
+            $this->redirect('createSiteNode');
+        }
+        $rootNode = $this->nodeContextFactory->create()->getRootNode();
+        $rootNode->getContext()->getWorkspace();
+        $this->persistenceManager->persistAll();
+        $sitesNode = $rootNode->getNode(SiteService::SITES_ROOT_PATH);
+        if ($sitesNode === null) {
+            $sitesNode = $rootNode->createNode(NodePaths::getNodeNameFromPath(SiteService::SITES_ROOT_PATH));
+        }
+        $siteNode = $sitesNode->createNode($nodeName, $siteNodeType);
+        $siteNode->setProperty('title', $siteName);
+        $site = new Site($nodeName);
+        $site->setSiteResourcesPackageKey($packageKey);
+        $site->setState(Site::STATE_ONLINE);
+        $site->setName($siteName);
+        $this->siteRepository->add($site);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.successfullyCreatedSite.body', [$siteName, $nodeName, $nodeType, $packageKey], null, null, 'Modules', 'Neos.Neos'),
+            '',
+            null,
+            [],
+            1412372266
+        );
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Delete a site.
+     *
+     * @param Site $site Site to delete
+     * @Flow\IgnoreValidation("$site")
+     * @return void
+     */
+    public function deleteSiteAction(Site $site)
+    {
+        $this->siteService->pruneSite($site);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.siteDeleted.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.siteDeleted.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412372689
+        );
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Activates a site
+     *
+     * @param Site $site Site to activate
+     * @return void
+     */
+    public function activateSiteAction(Site $site)
+    {
+        $site->setState($site::STATE_ONLINE);
+        $this->siteRepository->update($site);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.siteActivated.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.siteActivated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412372881
+        );
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Deactivates a site
+     *
+     * @param Site $site Site to deactivate
+     * @return void
+     */
+    public function deactivateSiteAction(Site $site)
+    {
+        $site->setState($site::STATE_OFFLINE);
+        $this->siteRepository->update($site);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.siteDeactivated.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.siteDeactivated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412372975
+        );
+        $this->unsetLastVisitedNodeAndRedirect('index');
+    }
+    /**
+     * Edit a domain
+     *
+     * @param Domain $domain Domain to edit
+     * @Flow\IgnoreValidation("$domain")
+     * @return void
+     */
+    public function editDomainAction(Domain $domain)
+    {
+        $this->view->assignMultiple(['domain' => $domain, 'schemes' => [null => '', 'http' => 'HTTP', 'https' => 'HTTPS']]);
+    }
+    /**
+     * Update a domain
+     *
+     * @param Domain $domain Domain to update
+     * @Flow\Validate(argumentName="$domain", type="UniqueEntity")
+     * @return void
+     */
+    public function updateDomainAction(Domain $domain)
+    {
+        $this->domainRepository->update($domain);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.domainUpdated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.domainUpdated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412373069
+        );
+        $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
+    }
+    /**
+     * The create a new domain action.
+     *
+     * @param Domain $domain
+     * @param Site $site
+     * @Flow\IgnoreValidation("$domain")
+     * @return void
+     */
+    public function newDomainAction(Domain $domain = null, Site $site = null)
+    {
+        $this->view->assignMultiple([
+            'domain' => $domain,
+            'site' => $site,
+            'schemes' => [null => '', 'http' => 'HTTP', 'https' => 'HTTPS']
+        ]);
+    }
+    /**
+     * Create a domain
+     *
+     * @param Domain $domain Domain to create
+     * @Flow\Validate(argumentName="$domain", type="UniqueEntity")
+     * @return void
+     */
+    public function createDomainAction(Domain $domain)
+    {
+        $this->domainRepository->add($domain);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.domainCreated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.domainCreated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412373192
+        );
+        $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
+    }
+    /**
+     * Deletes a domain attached to a site
+     *
+     * @param Domain $domain A domain to delete
+     * @Flow\IgnoreValidation("$domain")
+     * @return void
+     */
+    public function deleteDomainAction(Domain $domain)
+    {
+        $site = $domain->getSite();
+        if ($site->getPrimaryDomain() === $domain) {
+            $site->setPrimaryDomain(null);
+            $this->siteRepository->update($site);
+        }
+        $this->domainRepository->remove($domain);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.domainDeleted.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.domainDeleted.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412373310
+        );
+        $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $site]);
+    }
+    /**
+     * Activates a domain
+     *
+     * @param Domain $domain Domain to activate
+     * @Flow\IgnoreValidation("$domain")
+     * @return void
+     */
+    public function activateDomainAction(Domain $domain)
+    {
+        $domain->setActive(true);
+        $this->domainRepository->update($domain);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.domainActivated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.domainActivated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412373539
+        );
+        $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
+    }
+    /**
+     * Deactivates a domain
+     *
+     * @param Domain $domain Domain to deactivate
+     * @Flow\IgnoreValidation("$domain")
+     * @return void
+     */
+    public function deactivateDomainAction(Domain $domain)
+    {
+        $domain->setActive(false);
+        $this->domainRepository->update($domain);
+        $this->addFlashMessage(
+            $this->translator->translateById('sites.domainDeactivated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
+            $this->translator->translateById('sites.domainDeactivated.title', [], null, null, 'Modules', 'Neos.Neos'),
+            Message::SEVERITY_OK,
+            [],
+            1412373425
+        );
+        $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
+    }
+    /**
+     * @param string $actionName Name of the action to forward to
+     * @param string $controllerName Unqualified object name of the controller to forward to. If not specified, the current controller is used.
+     * @param string $packageKey Key of the package containing the controller to forward to. If not specified, the current package is assumed.
+     * @param array $arguments Array of arguments for the target action
+     * @param integer $delay (optional) The delay in seconds. Default is no delay.
+     * @param integer $statusCode (optional) The HTTP status code for the redirect. Default is "303 See Other"
+     * @param string $format The format to use for the redirect URI
+     * @return void
+     */
+    protected function unsetLastVisitedNodeAndRedirect($actionName, $controllerName = null, $packageKey = null, array $arguments = [], $delay = 0, $statusCode = 303, $format = null)
+    {
+        $this->session->putData('lastVisitedNode', null);
+        parent::redirect($actionName, $controllerName, $packageKey, $arguments, $delay, $statusCode, $format);
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Domain/Repository/SiteRepository.php
@@ -0,0 +1,104 @@
+<?php
+namespace Neos\Neos\Domain\Repository;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Persistence\QueryInterface;
+use Neos\Flow\Persistence\QueryResultInterface;
+use Neos\Flow\Persistence\Repository;
+use Neos\Neos\Domain\Model\Site;
+use Neos\Neos\Domain\Exception as NeosException;
+/**
+ * The Site Repository
+ *
+ * @Flow\Scope("singleton")
+ * @api
+ */
+class SiteRepository extends Repository
+{
+    /**
+     * @var array
+     */
+    protected $defaultOrderings = [
+        'name' => QueryInterface::ORDER_ASCENDING,
+        'nodeName' => QueryInterface::ORDER_ASCENDING
+    ];
+    /**
+     * @Flow\InjectConfiguration(package="Neos.Neos", path="defaultSiteNodeName")
+     * @var string
+     */
+    protected $defaultSiteNodeName;
+    /**
+     * Finds the first site
+     *
+     * @return Site The first site or NULL if none exists
+     * @api
+     */
+    public function findFirst()
+    {
+        return $this->createQuery()->execute()->getFirst();
+    }
+    /**
+     * Find all sites with status "online"
+     *
+     * @return QueryResultInterface
+     */
+    public function findOnline()
+    {
+        return $this->findByState(Site::STATE_ONLINE);
+    }
+    /**
+     * Find first site with status "online"
+     *
+     * @return ?Site
+     */
+    public function findFirstOnline()
+    {
+        return $this->findOnline()->getFirst();
+    }
+    /**
+     * @param string $nodeName
+     * @return Site|null
+     */
+    public function findOneByNodeName(string $nodeName): ?Site
+    {
+        $query = $this->createQuery();
+        /** @var Site|null $site */
+        $site = $query->matching(
+            $query->equals('nodeName', $nodeName)
+        )
+            ->execute()
+            ->getFirst();
+        return $site;
+    }
+    /**
+     * Find the site that was specified in the configuration ``defaultSiteNodeName``
+     *
+     * If the defaultSiteNodeName-setting is null the first active site is returned
+     * If the site is not found or not active an exception is thrown
+     *
+     * @return Site
+     * @throws NeosException
+     */
+    public function findDefault()
+    {
+        if ($this->defaultSiteNodeName === null) {
+            return $this->findOnline()->getFirst();
+        }
+        /**
+         * @var Site $defaultSite
+         */
+        $defaultSite = $this->findOneByNodeName($this->defaultSiteNodeName);
+        if (!$defaultSite instanceof Site || $defaultSite->getState() !== Site::STATE_ONLINE) {
+            throw new NeosException(sprintf('DefaultSiteNode %s not found or not active', $this->defaultSiteNodeName), 1476374818);
+        }
+        return $defaultSite;
+    }
+}

--- a/Neos.Neos/Classes/Domain/Service/UserService.php
+++ b//dev/null
@@ -1,833 +0,0 @@
-<?php
-namespace Neos\Neos\Domain\Service;
-/*
- * This file is part of the Neos.Neos package.
- *
- * (c) Contributors of the Neos Project - www.neos.io
- *
- * This package is Open Source Software. For the full copyright and license
- * information, please view the LICENSE file which was distributed with this
- * source code.
- */
-use Neos\Flow\Annotations as Flow;
-use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
-use Neos\Flow\Persistence\PersistenceManagerInterface;
-use Neos\Flow\Persistence\QueryResultInterface;
-use Neos\Flow\Security\Account;
-use Neos\Flow\Security\AccountFactory;
-use Neos\Flow\Security\AccountRepository;
-use Neos\Flow\Security\Authentication\AuthenticationManagerInterface;
-use Neos\Flow\Security\Authentication\Token\UsernamePassword;
-use Neos\Flow\Security\Authentication\TokenAndProviderFactoryInterface;
-use Neos\Flow\Security\Authentication\TokenInterface;
-use Neos\Flow\Security\Authorization\PrivilegeManagerInterface;
-use Neos\Flow\Security\Context;
-use Neos\Flow\Security\Cryptography\HashService;
-use Neos\Flow\Security\Exception\NoSuchRoleException;
-use Neos\Flow\Security\Policy\PolicyService;
-use Neos\Flow\Security\Policy\Role;
-use Neos\Flow\Session\Exception\SessionNotStartedException;
-use Neos\Flow\Session\SessionInterface;
-use Neos\Flow\Session\SessionManager;
-use Neos\Flow\Utility\Now;
-use Neos\Neos\Domain\Exception;
-use Neos\Neos\Domain\Model\User;
-use Neos\Neos\Domain\Repository\UserRepository;
-use Neos\Neos\Service\PublishingService;
-use Neos\Party\Domain\Model\AbstractParty;
-use Neos\Party\Domain\Model\PersonName;
-use Neos\Party\Domain\Repository\PartyRepository;
-use Neos\Party\Domain\Service\PartyService;
-use Neos\ContentRepository\Domain\Model\Workspace;
-use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
-use Neos\Neos\Utility\User as UserUtility;
-/**
- * A service for managing users
- *
- * @Flow\Scope("singleton")
- * @api
- */
-class UserService
-{
-    /**
-     * Might be configurable in the future, for now centralising this as a "constant"
-     *
-     * @var string
-     */
-    protected $defaultAuthenticationProviderName = 'Neos.Neos:Backend';
-    /**
-     * @Flow\Inject
-     * @var WorkspaceRepository
-     */
-    protected $workspaceRepository;
-    /**
-     * @Flow\Inject
-     * @var PublishingService
-     */
-    protected $publishingService;
-    /**
-     * @Flow\Inject
-     * @var PartyRepository
-     */
-    protected $partyRepository;
-    /**
-     * @Flow\Inject
-     * @var UserRepository
-     */
-    protected $userRepository;
-    /**
-     * @Flow\Inject
-     * @var PartyService
-     */
-    protected $partyService;
-    /**
-     * @Flow\Inject
-     * @var AccountFactory
-     */
-    protected $accountFactory;
-    /**
-     * @Flow\Inject
-     * @var AccountRepository
-     */
-    protected $accountRepository;
-    /**
-     * @Flow\Inject
-     * @var PolicyService
-     */
-    protected $policyService;
-    /**
-     * @Flow\Inject
-     * @var AuthenticationManagerInterface
-     */
-    protected $authenticationManager;
-    /**
-     * @Flow\Inject
-     * @var PrivilegeManagerInterface
-     */
-    protected $privilegeManager;
-    /**
-     * @Flow\Inject
-     * @var Context
-     */
-    protected $securityContext;
-    /**
-     * @Flow\Inject
-     * @var TokenAndProviderFactoryInterface
-     */
-    protected $tokenAndProviderFactory;
-    /**
-     * @Flow\Inject
-     * @var HashService
-     */
-    protected $hashService;
-    /**
-     * @Flow\Inject
-     * @var SessionManager
-     */
-    protected $sessionManager;
-    /**
-     * @Flow\Inject
-     * @var PersistenceManagerInterface
-     */
-    protected $persistenceManager;
-    /**
-     * @Flow\Inject(lazy = false)
-     * @var Now
-     */
-    protected $now;
-    /**
-     * @var array
-     */
-    protected $runtimeUserCache = [];
-    /**
-     * Retrieves a list of all existing users
-     *
-     * @return QueryResultInterface The users
-     * @api
-     */
-    public function getUsers(): QueryResultInterface
-    {
-        return $this->userRepository->findAllOrderedByUsername();
-    }
-    /**
-     * @param string $searchTerm
-     * @return QueryResultInterface
-     */
-    public function searchUsers(string $searchTerm): QueryResultInterface
-    {
-        return $this->userRepository->findBySearchTerm($searchTerm);
-    }
-    /**
-     * Retrieves an existing user by the given username
-     *
-     * @param string $username The username
-     * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
-     * @return User|null The user, or null if the user does not exist
-     * @throws Exception
-     * @api
-     */
-    public function getUser($username, $authenticationProviderName = null)
-    {
-        $authenticationProviderName = $authenticationProviderName ?: $this->defaultAuthenticationProviderName;
-        $cacheIdentifier = $authenticationProviderName . '~' . $username;
-        if (array_key_exists($cacheIdentifier, $this->runtimeUserCache)) {
-            $userIdentifier = $this->runtimeUserCache[$cacheIdentifier];
-            return $this->partyRepository->findByIdentifier($userIdentifier);
-        }
-        $user = $this->findUserForAccount($username, $authenticationProviderName);
-        if ($user instanceof AbstractParty) {
-            $userIdentifier = $this->persistenceManager->getIdentifierByObject($user);
-        }
-        if (isset($userIdentifier) && (string)$userIdentifier !== '') {
-            $this->runtimeUserCache[$cacheIdentifier] = $userIdentifier;
-            return $this->partyRepository->findByIdentifier($userIdentifier);
-        }
-        return null;
-    }
-    /**
-     * Returns the username of the given user
-     *
-     * Technically, this method will look for the user's backend account (or, if authenticationProviderName is specified,
-     * for the account matching the given authentication provider) and return the account's identifier.
-     *
-     * @param User $user
-     * @param string $authenticationProviderName
-     * @return string The username or null if the given user does not have a backend account
-     */
-    public function getUsername(User $user, $authenticationProviderName = null)
-    {
-        $authenticationProviderName = $authenticationProviderName ?: $this->defaultAuthenticationProviderName;
-        foreach ($user->getAccounts() as $account) {
-            /** @var Account $account */
-            if ($account->getAuthenticationProviderName() === $authenticationProviderName) {
-                return $account->getAccountIdentifier();
-            }
-        }
-        return null;
-    }
-    /**
-     * Returns the currently logged in user, if any
-     *
-     * @return User The currently logged in user, or null
-     * @api
-     */
-    public function getCurrentUser()
-    {
-        if ($this->securityContext->canBeInitialized() === false) {
-            return null;
-        }
-        $tokens = $this->securityContext->getAuthenticationTokens();
-        $user = array_reduce($tokens, function ($foundUser, TokenInterface $token) {
-            if ($foundUser !== null) {
-                return $foundUser;
-            }
-            $account = $token->getAccount();
-            if ($account === null) {
-                return $foundUser;
-            }
-            $user = $this->getNeosUserForAccount($account);
-            if ($user === null) {
-                return $foundUser;
-            }
-            return $user;
-        }, null);
-        return $user;
-    }
-    /**
-     * Creates a user based on the given information
-     *
-     * The created user and account are automatically added to their respective repositories and thus be persisted.
-     *
-     * @param string $username The username of the user to be created.
-     * @param string $password Password of the user to be created
-     * @param string $firstName First name of the user to be created
-     * @param string $lastName Last name of the user to be created
-     * @param array $roleIdentifiers A list of role identifiers to assign
-     * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
-     * @return User The created user instance
-     * @api
-     */
-    public function createUser($username, $password, $firstName, $lastName, array $roleIdentifiers = null, $authenticationProviderName = null)
-    {
-        $user = new User();
-        $name = new PersonName('', $firstName, '', $lastName, '', $username);
-        $user->setName($name);
-        return $this->addUser($username, $password, $user, $roleIdentifiers, $authenticationProviderName);
-    }
-    /**
-     * Adds a user whose User object has been created elsewhere
-     *
-     * This method basically "creates" a user like createUser() would, except that it does not create the User
-     * object itself. If you need to create the User object elsewhere, for example in your ActionController, make sure
-     * to call this method for registering the new user instead of adding it to the PartyRepository manually.
-     *
-     * This method also creates a new user workspace for the given user if no such workspace exist.
-     *
-     * @param string $username The username of the user to be created.
-     * @param string $password Password of the user to be created
-     * @param User $user The pre-built user object to start with
-     * @param array $roleIdentifiers A list of role identifiers to assign
-     * @param string $authenticationProviderName Name of the authentication provider to use. Example: "Neos.Neos:Backend"
-     * @return User The same user object
-     * @api
-     */
-    public function addUser($username, $password, User $user, array $roleIdentifiers = null, $authenticationProviderName = null)
-    {
-        if ($roleIdentifiers === null) {
-            $roleIdentifiers = ['Neos.Neos:Editor'];
-        }
-        $roleIdentifiers = $this->normalizeRoleIdentifiers($roleIdentifiers);
-        $account = $this->accountFactory->createAccountWithPassword($username, $password, $roleIdentifiers, $authenticationProviderName ?: $this->defaultAuthenticationProviderName);
-        $this->partyService->assignAccountToParty($account, $user);
-        $this->partyRepository->add($user);
-        $this->accountRepository->add($account);
-        $this->createPersonalWorkspace($user, $account);
-        $this->emitUserCreated($user);
-        return $user;
-    }
-    /**
-     * Signals that a new user, including a new account has been created.
-     *
-     * @param User $user The created user
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitUserCreated(User $user)
-    {
-    }
-    /**
-     * Deletes the specified user and all remaining content in his personal workspaces
-     *
-     * @param User $user The user to delete
-     * @return void
-     * @throws IllegalObjectTypeException
-     * @throws SessionNotStartedException
-     * @throws \Exception
-     * @api
-     */
-    public function deleteUser(User $user)
-    {
-        $this->destroyActiveSessionsForUser($user);
-        foreach ($user->getAccounts() as $account) {
-            $this->securityContext->withoutAuthorizationChecks(function () use ($account) {
-                $this->deletePersonalWorkspace($account->getAccountIdentifier());
-            });
-            $this->accountRepository->remove($account);
-        }
-        $this->removeOwnerFromUsersWorkspaces($user);
-        $this->partyRepository->remove($user);
-        $this->emitUserDeleted($user);
-    }
-    /**
-     * Signals that the given user has been deleted.
-     *
-     * @param User $user The created user
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitUserDeleted(User $user)
-    {
-    }
-    /**
-     * Sets a new password for the given user
-     *
-     * This method will iterate over all accounts owned by the given user and, if the account uses a UsernamePasswordToken,
-     * sets a new password accordingly.
-     *
-     * @param User $user The user to set the password for
-     * @param string $password A new password
-     * @return void
-     * @throws IllegalObjectTypeException
-     * @throws SessionNotStartedException
-     * @api
-     */
-    public function setUserPassword(User $user, $password)
-    {
-        $tokens = $this->tokenAndProviderFactory->getTokens();
-        $indexedTokens = [];
-        foreach ($tokens as $token) {
-            /** @var TokenInterface $token */
-            $indexedTokens[$token->getAuthenticationProviderName()] = $token;
-        }
-        $this->destroyActiveSessionsForUser($user, true);
-        foreach ($user->getAccounts() as $account) {
-            /** @var Account $account */
-            $authenticationProviderName = $account->getAuthenticationProviderName();
-            if (isset($indexedTokens[$authenticationProviderName]) && $indexedTokens[$authenticationProviderName] instanceof UsernamePassword) {
-                $account->setCredentialsSource($this->hashService->hashPassword($password));
-                $this->accountRepository->update($account);
-            }
-        }
-    }
-    /**
-     * Updates the given user in the respective repository and potentially executes further actions depending on what
-     * has been changed.
-     *
-     * Note: changes to the user's account will not be committed for persistence. Please use addRoleToAccount(), removeRoleFromAccount(),
-     * setRolesForAccount() and setUserPassword() for changing account properties.
-     *
-     * @param User $user The modified user
-     * @return void
-     * @api
-     */
-    public function updateUser(User $user)
-    {
-        $this->partyRepository->update($user);
-        $this->emitUserUpdated($user);
-    }
-    /**
-     * Adds the specified role to all accounts of the given user and potentially carries out further actions which are needed to
-     * properly reflect these changes.
-     *
-     * @param User $user The user to add roles to
-     * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
-     * @return integer How often this role has been added to accounts owned by the user
-     * @api
-     */
-    public function addRoleToUser(User $user, $roleIdentifier)
-    {
-        $counter = 0;
-        foreach ($user->getAccounts() as $account) {
-            $counter += $this->addRoleToAccount($account, $roleIdentifier);
-        }
-        return $counter;
-    }
-    /**
-     * Removes the specified role from all accounts of the given user and potentially carries out further actions which are needed to
-     * properly reflect these changes.
-     *
-     * @param User $user The user to remove roles from
-     * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
-     * @return integer How often this role has been removed from accounts owned by the user
-     * @api
-     */
-    public function removeRoleFromUser(User $user, $roleIdentifier)
-    {
-        $counter = 0;
-        foreach ($user->getAccounts() as $account) {
-            $counter += $this->removeRoleFromAccount($account, $roleIdentifier);
-        }
-        return $counter;
-    }
-    /**
-     * Signals that the given user data has been updated.
-     *
-     * @param User $user The created user
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitUserUpdated(User $user)
-    {
-    }
-    /**
-     * Overrides any assigned roles of the given account and potentially carries out further actions which are needed
-     * to properly reflect these changes.
-     *
-     * @param Account $account The account to assign the roles to
-     * @param array $newRoleIdentifiers A list of fully qualified role identifiers, or role identifiers relative to the Neos.Neos namespace
-     * @return void
-     * @api
-     */
-    public function setRolesForAccount(Account $account, array $newRoleIdentifiers)
-    {
-        $currentRoles = $account->getRoles();
-        foreach ($currentRoles as $roleIdentifier => $role) {
-            $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
-            if (!in_array($roleIdentifier, $newRoleIdentifiers)) {
-                $this->removeRoleFromAccount($account, $roleIdentifier);
-            }
-        }
-        foreach ($newRoleIdentifiers as $roleIdentifier) {
-            if (!in_array($roleIdentifier, array_keys($currentRoles))) {
-                $this->addRoleToAccount($account, $roleIdentifier);
-            }
-        }
-    }
-    /**
-     * Adds the specified role to the given account and potentially carries out further actions which are needed to
-     * properly reflect these changes.
-     *
-     * @param Account $account The account to add roles to
-     * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
-     * @return integer How often this role has been added to the given account (effectively can be 1 or 0)
-     * @api
-     */
-    public function addRoleToAccount(Account $account, $roleIdentifier)
-    {
-        $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
-        $role = $this->policyService->getRole($roleIdentifier);
-        if (!$account->hasRole($role)) {
-            $account->addRole($role);
-            $this->accountRepository->update($account);
-            $this->emitRolesAdded($account, [$role]);
-            return 1;
-        }
-        return 0;
-    }
-    /**
-     * Signals that new roles have been assigned to the given account
-     *
-     * @param Account $account The account
-     * @param array<Role> An array of Role objects which have been added for that account
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitRolesAdded(Account $account, array $roles)
-    {
-    }
-    /**
-     * Removes the specified role from the given account and potentially carries out further actions which are needed to
-     * properly reflect these changes.
-     *
-     * @param Account $account The account to remove roles from
-     * @param string $roleIdentifier A fully qualified role identifier, or a role identifier relative to the Neos.Neos namespace
-     * @return integer How often this role has been removed from the given account (effectively can be 1 or 0)
-     * @api
-     */
-    public function removeRoleFromAccount(Account $account, $roleIdentifier)
-    {
-        $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
-        $role = $this->policyService->getRole($roleIdentifier);
-        /** @var Account $account */
-        if ($account->hasRole($role)) {
-            $account->removeRole($role);
-            $this->accountRepository->update($account);
-            $this->emitRolesRemoved($account, [$role]);
-            return 1;
-        }
-        return 0;
-    }
-    /**
-     * Signals that roles have been removed to the given account
-     *
-     * @param Account $account The account
-     * @param array<Role> An array of Role objects which have been removed
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitRolesRemoved(Account $account, array $roles)
-    {
-    }
-    /**
-     * Reactivates the given user
-     *
-     * @param User $user The user to activate
-     * @return void
-     * @api
-     */
-    public function activateUser(User $user)
-    {
-        foreach ($user->getAccounts() as $account) {
-            /** @var Account $account */
-            $account->setExpirationDate(null);
-            $this->accountRepository->update($account);
-        }
-        $this->emitUserActivated($user);
-    }
-    /**
-     * Signals that the given user has been activated
-     *
-     * @param User $user The user
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitUserActivated(User $user)
-    {
-    }
-    /**
-     * Deactivates the given user
-     *
-     * @param User $user The user to deactivate
-     * @return void
-     * @throws IllegalObjectTypeException
-     * @throws SessionNotStartedException
-     * @api
-     */
-    public function deactivateUser(User $user)
-    {
-        $this->destroyActiveSessionsForUser($user);
-        /** @var Account $account */
-        foreach ($user->getAccounts() as $account) {
-            $account->setExpirationDate(
-                \DateTime::createFromFormat(\DateTimeInterface::ATOM, $this->now->format(\DateTimeInterface::ATOM))
-            );
-            $this->accountRepository->update($account);
-        }
-        $this->emitUserDeactivated($user);
-    }
-    /**
-     * Checks if the current user may publish to the given workspace according to one the roles of the user's accounts
-     *
-     * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
-     * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
-     *
-     * @param Workspace $workspace The workspace
-     * @return boolean
-     */
-    public function currentUserCanPublishToWorkspace(Workspace $workspace)
-    {
-        if ($workspace->getName() === 'live') {
-            return $this->securityContext->hasRole('Neos.Neos:LivePublisher');
-        }
-        if ($workspace->getOwner() === $this->getCurrentUser() || $workspace->getOwner() === null) {
-            return true;
-        }
-        return false;
-    }
-    /**
-     * Checks if the current user may read the given workspace according to one the roles of the user's accounts
-     *
-     * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
-     * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
-     *
-     * @param Workspace $workspace The workspace
-     * @return boolean
-     */
-    public function currentUserCanReadWorkspace(Workspace $workspace)
-    {
-        if ($workspace->getName() === 'live') {
-            return true;
-        }
-        if ($workspace->getOwner() === $this->getCurrentUser() || $workspace->getOwner() === null) {
-            return true;
-        }
-        return false;
-    }
-    /**
-     * Checks if the current user may manage the given workspace according to one the roles of the user's accounts
-     *
-     * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
-     * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
-     *
-     * @param Workspace $workspace The workspace
-     * @return boolean
-     */
-    public function currentUserCanManageWorkspace(Workspace $workspace)
-    {
-        if ($workspace->isPersonalWorkspace()) {
-            return false;
-        }
-        if ($workspace->isInternalWorkspace()) {
-            return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageInternalWorkspaces');
-        }
-        if ($workspace->isPrivateWorkspace() && $workspace->getOwner() === $this->getCurrentUser()) {
-            return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageOwnWorkspaces');
-        }
-        if ($workspace->isPrivateWorkspace() && $workspace->getOwner() !== $this->getCurrentUser()) {
-            return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageAllPrivateWorkspaces');
-        }
-        return false;
-    }
-    /**
-     * Checks if the current user may transfer ownership of the given workspace
-     *
-     * In future versions, this logic may be implemented in Neos in a more generic way (for example, by means of an
-     * ACL object), but for now, this method exists in order to at least centralize and encapsulate the required logic.
-     *
-     * @param Workspace $workspace The workspace
-     * @return boolean
-     */
-    public function currentUserCanTransferOwnershipOfWorkspace(Workspace $workspace)
-    {
-        if ($workspace->isPersonalWorkspace()) {
-            return false;
-        }
-        return $this->privilegeManager->isPrivilegeTargetGranted('Neos.Neos:Backend.Module.Management.Workspaces.ManageInternalWorkspaces');
-    }
-    /**
-     * @return bool
-     * @throws NoSuchRoleException
-     * @throws \Neos\Flow\Security\Exception
-     */
-    public function currentUserIsAdministrator(): bool
-    {
-        return $this->securityContext->hasRole('Neos.Neos:Administrator');
-    }
-    /**
-     * Returns the default authentication provider name
-     *
-     * @return string
-     * @api
-     */
-    public function getDefaultAuthenticationProviderName()
-    {
-        return $this->defaultAuthenticationProviderName;
-    }
-    /**
-     * Signals that the given user has been activated
-     *
-     * @param User $user The user
-     * @return void
-     * @Flow\Signal
-     * @api
-     */
-    public function emitUserDeactivated(User $user)
-    {
-    }
-    /**
-     * Replaces role identifiers not containing a "." into fully qualified role identifiers from the Neos.Neos namespace.
-     *
-     * @param array $roleIdentifiers
-     * @return array
-     */
-    protected function normalizeRoleIdentifiers(array $roleIdentifiers)
-    {
-        foreach ($roleIdentifiers as &$roleIdentifier) {
-            $roleIdentifier = $this->normalizeRoleIdentifier($roleIdentifier);
-        }
-        return $roleIdentifiers;
-    }
-    /**
-     * Replaces a role identifier not containing a "." into fully qualified role identifier from the Neos.Neos namespace.
-     *
-     * @param string $roleIdentifier
-     * @return string
-     * @throws NoSuchRoleException
-     */
-    protected function normalizeRoleIdentifier($roleIdentifier)
-    {
-        if (strpos($roleIdentifier, ':') === false) {
-            $roleIdentifier = 'Neos.Neos:' . $roleIdentifier;
-        }
-        if (!$this->policyService->hasRole($roleIdentifier)) {
-            throw new NoSuchRoleException(sprintf('The role %s does not exist.', $roleIdentifier), 1422540184);
-        }
-        return $roleIdentifier;
-    }
-    /**
-     * Returns an array with all roles of a user's accounts, including parent roles, the "Everybody" role and the
-     * "AuthenticatedUser" role, assuming that the user is logged in.
-     *
-     * @param User $user The user
-     * @return array
-     * @throws NoSuchRoleException
-     */
-    public function getAllRoles(User $user): array
-    {
-        $roles = [
-            'Neos.Flow:Everybody' => $this->policyService->getRole('Neos.Flow:Everybody'),
-            'Neos.Flow:AuthenticatedUser' => $this->policyService->getRole('Neos.Flow:AuthenticatedUser')
-        ];
-        /** @var Account $account */
-        foreach ($user->getAccounts() as $account) {
-            $accountRoles = $account->getRoles();
-            /** @var $currentRole Role */
-            foreach ($accountRoles as $currentRole) {
-                if (!in_array($currentRole, $roles)) {
-                    $roles[$currentRole->getIdentifier()] = $currentRole;
-                }
-                /** @var $currentParentRole Role */
-                foreach ($currentRole->getAllParentRoles() as $currentParentRole) {
-                    if (!in_array($currentParentRole, $roles)) {
-                        $roles[$currentParentRole->getIdentifier()] = $currentParentRole;
-                    }
-                }
-            }
-        }
-        return $roles;
-    }
-    /**
-     * @param User $user
-     * @param bool $keepCurrentSession
-     * @throws SessionNotStartedException
-     */
-    private function destroyActiveSessionsForUser(User $user, bool $keepCurrentSession = false): void
-    {
-        $sessionToKeep = $keepCurrentSession ? $this->sessionManager->getCurrentSession() : null;
-        foreach ($user->getAccounts() as $account) {
-            $activeSessions = $this->sessionManager->getSessionsByTag($this->securityContext->getSessionTagForAccount($account));
-            foreach ($activeSessions as $activeSession) {
-                /** @var SessionInterface $activeSession */
-                if ($sessionToKeep instanceof SessionInterface && $activeSession->getId() === $sessionToKeep->getId()) {
-                    continue;
-                }
-                $activeSession->destroy('Requested to remove alle sessions for user ' . $account->getAccountIdentifier());
-            }
-        }
-    }
-    /**
-     * Creates a personal workspace for the given user's account if it does not exist already.
-     *
-     * @param User $user The new user to create a workspace for
-     * @param Account $account The user's backend account
-     * @throws IllegalObjectTypeException
-     */
-    protected function createPersonalWorkspace(User $user, Account $account)
-    {
-        $userWorkspaceName = UserUtility::getPersonalWorkspaceNameForUsername($account->getAccountIdentifier());
-        $userWorkspace = $this->workspaceRepository->findByIdentifier($userWorkspaceName);
-        if ($userWorkspace === null) {
-            $liveWorkspace = $this->workspaceRepository->findByIdentifier('live');
-            if (!($liveWorkspace instanceof Workspace)) {
-                $liveWorkspace = new Workspace('live');
-                $liveWorkspace->setTitle('Live');
-                $this->workspaceRepository->add($liveWorkspace);
-            }
-            $userWorkspace = new Workspace($userWorkspaceName, $liveWorkspace, $user);
-            $userWorkspace->setTitle((string)$user->getName());
-            $this->workspaceRepository->add($userWorkspace);
-        }
-    }
-    /**
-     * Removes all personal workspaces of the given user's account if these workspaces exist. Also removes
-     * all possibly existing content of these workspaces.
-     *
-     * @param string $accountIdentifier Identifier of the user's account
-     * @return void
-     */
-    protected function deletePersonalWorkspace($accountIdentifier)
-    {
-        $userWorkspace = $this->workspaceRepository->findByIdentifier(UserUtility::getPersonalWorkspaceNameForUsername($accountIdentifier));
-        if ($userWorkspace instanceof Workspace) {
-            $this->publishingService->discardAllNodes($userWorkspace);
-            $this->workspaceRepository->remove($userWorkspace);
-        }
-    }
-    /**
-     * Removes ownership of all workspaces currently owned by the given user
-     *
-     * @param User $user The user currently owning workspaces
-     * @return void
-     */
-    protected function removeOwnerFromUsersWorkspaces(User $user)
-    {
-        /** @var Workspace $workspace */
-        foreach ($this->workspaceRepository->findByOwner($user) as $workspace) {
-            $workspace->setOwner(null);
-            $this->workspaceRepository->update($workspace);
-        }
-    }
-    /**
-     * @param string $username
-     * @param string $authenticationProviderName
-     * @return \Neos\Party\Domain\Model\AbstractParty|null
-     * @throws Exception
-     */
-    protected function findUserForAccount($username, $authenticationProviderName)
-    {
-        $account = $this->accountRepository->findByAccountIdentifierAndAuthenticationProviderName($username, $authenticationProviderName ?: $this->defaultAuthenticationProviderName);
-        if ($account === null) {
-            return null;
-        }
-        $user = $this->partyService->getAssignedPartyOfAccount($account);
-        if (!$user instanceof User) {
-            throw new Exception(sprintf('Unexpected user type "%s". An account with the identifier "%s" exists, but the corresponding party is not a Neos User.', get_class($user), $username), 1422270948);
-        }
-        return $user;
-    }
-    /**
-     * @param Account $account
-     * @return User|null
-     */
-    private function getNeosUserForAccount(Account $account): ?User
-    {
-        $user = $this->partyService->getAssignedPartyOfAccount($account);
-        return ($user instanceof User) ? $user : null;
-    }
-}

--- a//dev/null
+++ b/Neos.Neos/Classes/Fusion/Cache/ContentCacheFlusher.php
@@ -0,0 +1,296 @@
+<?php
+namespace Neos\Neos\Fusion\Cache;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\ContentRepository\Domain\Model\Workspace;
+use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
+use Neos\ContentRepository\Exception\NodeTypeNotFoundException;
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Log\Utility\LogEnvironment;
+use Neos\Flow\Persistence\PersistenceManagerInterface;
+use Neos\Flow\Security\Context as SecurityContext;
+use Neos\Media\Domain\Model\AssetInterface;
+use Neos\Media\Domain\Model\AssetVariantInterface;
+use Neos\Media\Domain\Service\AssetService;
+use Neos\Neos\Domain\Model\Dto\AssetUsageInNodeProperties;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\Model\NodeType;
+use Neos\ContentRepository\Domain\Service\NodeTypeManager;
+use Neos\Fusion\Core\Cache\ContentCache;
+use Neos\Neos\Fusion\Helper\CachingHelper;
+use Neos\Neos\Domain\Service\ContentContext;
+use Neos\Neos\Domain\Service\ContentContextFactory;
+use Psr\Log\LoggerInterface;
+/**
+ * This service flushes Fusion content caches triggered by node changes.
+ *
+ * The method registerNodeChange() is triggered by a signal which is configured in the Package class of the Neos.Neos
+ * package (this package). Information on changed nodes is collected by this method and the respective Fusion content
+ * cache entries are flushed in one operation during Flow's shutdown procedure.
+ *
+ * @Flow\Scope("singleton")
+ */
+class ContentCacheFlusher
+{
+    /**
+     * @Flow\Inject
+     * @var ContentCache
+     */
+    protected $contentCache;
+    /**
+     * @Flow\Inject
+     * @var LoggerInterface
+     */
+    protected $systemLogger;
+    /**
+     * @var array<string, string>
+     */
+    protected $tagsToFlush = [];
+    /**
+     * @var CachingHelper
+     */
+    protected $cachingHelper;
+    /**
+     * @Flow\Inject
+     * @var WorkspaceRepository
+     */
+    protected $workspaceRepository;
+    /**
+     * @var array
+     */
+    protected $workspacesToFlush = [];
+    /**
+     * @var array<string, string[]>
+     */
+    protected $implementedNodeTypeNamesByNodeType = [];
+    /**
+     * @Flow\Inject
+     * @var AssetService
+     */
+    protected $assetService;
+    /**
+     * @Flow\Inject
+     * @var NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * @Flow\Inject
+     * @var ContentContextFactory
+     */
+    protected $contextFactory;
+    /**
+     * @Flow\Inject
+     * @var PersistenceManagerInterface
+     */
+    protected $persistenceManager;
+    /**
+     * @var ContentContext[]
+     */
+    protected $contexts = [];
+    /**
+     * @Flow\Inject
+     * @var SecurityContext
+     */
+    protected $securityContext;
+    /**
+     * @Flow\InjectConfiguration(path="fusion.contentCacheDebugMode")
+     * @var bool
+     */
+    protected $debugMode;
+    /**
+     * Register a node change for a later cache flush. This method is triggered by a signal sent via ContentRepository's Node
+     * model or the Neos Publishing Service.
+     *
+     * @param NodeInterface $node The node which has changed in some way
+     * @param Workspace|null $targetWorkspace An optional workspace to flush
+     */
+    public function registerNodeChange(NodeInterface $node, Workspace $targetWorkspace = null): void
+    {
+        $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
+        if (empty($this->workspacesToFlush[$node->getWorkspace()->getName()])) {
+            $this->resolveWorkspaceChain($node->getWorkspace());
+        }
+        if ($targetWorkspace !== null && empty($this->workspacesToFlush[$targetWorkspace->getName()])) {
+            $this->resolveWorkspaceChain($targetWorkspace);
+        }
+        if (!array_key_exists($node->getWorkspace()->getName(), $this->workspacesToFlush)) {
+            return;
+        }
+        $this->registerAllTagsToFlushForNodeInWorkspace($node, $node->getWorkspace());
+        if ($targetWorkspace !== null) {
+            $this->registerAllTagsToFlushForNodeInWorkspace($node, $targetWorkspace);
+        }
+    }
+    protected function addTagToFlush(string $tag, string $message = ''): void
+    {
+        $this->tagsToFlush[$tag] = $this->debugMode ? $message : '';
+    }
+    protected function registerAllTagsToFlushForNodeInWorkspace(NodeInterface $node, Workspace $workspace): void
+    {
+        $nodeIdentifier = $node->getIdentifier();
+        if (!array_key_exists($workspace->getName(), $this->workspacesToFlush) || is_array($this->workspacesToFlush[$workspace->getName()]) === false) {
+            return;
+        }
+        foreach ($this->workspacesToFlush[$workspace->getName()] as $workspaceName => $workspaceHash) {
+            $this->registerChangeOnNodeIdentifier($workspaceHash .'_'. $nodeIdentifier);
+            $this->registerChangeOnNodeType($node->getNodeType()->getName(), $nodeIdentifier, $workspaceHash);
+            $nodeInWorkspace = $node;
+            while ($nodeInWorkspace->getDepth() > 1) {
+                $nodeInWorkspace = $nodeInWorkspace->getParent();
+                if ($nodeInWorkspace === null) {
+                    break;
+                }
+                $tagName = 'DescendantOf_' . $workspaceHash . '_' . $nodeInWorkspace->getIdentifier();
+                if (array_key_exists($tagName, $this->tagsToFlush)) {
+                    break;
+                }
+                $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because node "%s" has changed.', $tagName, $node->getPath()));
+            }
+        }
+    }
+    protected function resolveWorkspaceChain(Workspace $workspace): void
+    {
+        $cachingHelper = $this->getCachingHelper();
+        $this->workspacesToFlush[$workspace->getName()][$workspace->getName()] = $cachingHelper->renderWorkspaceTagForContextNode($workspace->getName());
+        $this->resolveTagsForChildWorkspaces($workspace, $workspace->getName());
+    }
+    protected function resolveTagsForChildWorkspaces(Workspace $workspace, string $startingPoint): void
+    {
+        $cachingHelper = $this->getCachingHelper();
+        $this->workspacesToFlush[$startingPoint][$workspace->getName()] = $cachingHelper->renderWorkspaceTagForContextNode($workspace->getName());
+        $childWorkspaces = $this->workspaceRepository->findByBaseWorkspace($workspace->getName());
+        if ($childWorkspaces->valid()) {
+            foreach ($childWorkspaces as $childWorkspace) {
+                $this->resolveTagsForChildWorkspaces($childWorkspace, $startingPoint);
+            }
+        }
+    }
+    /**
+     * Pleas use registerNodeChange() if possible. This method is a low-level api. If you do use this method make sure
+     * that $cacheIdentifier contains the workspacehash as well as the node identifier: $workspaceHash .'_'. $nodeIdentifier
+     * The workspacehash can be received via $this->getCachingHelper()->renderWorkspaceTagForContextNode($workpsacename)
+     */
+    public function registerChangeOnNodeIdentifier(string $cacheIdentifier): void
+    {
+        $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
+        $this->addTagToFlush('Node_' . $cacheIdentifier, sprintf('which were tagged with "Node_%s" because that identifier has changed.', $cacheIdentifier));
+        $this->addTagToFlush('NodeDynamicTag_' . $cacheIdentifier, sprintf('which were tagged with "NodeDynamicTag_%s" because that identifier has changed.', $cacheIdentifier));
+        $tagName = 'DescendantOf_' . $cacheIdentifier;
+        $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because node "%s" has changed.', $tagName, $cacheIdentifier));
+    }
+    /**
+     * This is a low-level api. Please use registerNodeChange() if possible. Otherwise make sure that $nodeTypePrefix
+     * is set up correctly and contains the workspacehash wich can be received via
+     * $this->getCachingHelper()->renderWorkspaceTagForContextNode($workpsacename)
+     *
+     * @throws NodeTypeNotFoundException
+     */
+    public function registerChangeOnNodeType(string $nodeTypeName, string $referenceNodeIdentifier = null, string $nodeTypePrefix = ''): void
+    {
+        $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
+        $nodeTypesToFlush = $this->getAllImplementedNodeTypeNames($this->nodeTypeManager->getNodeType($nodeTypeName));
+        if ($nodeTypePrefix !== '') {
+            $nodeTypePrefix = rtrim($nodeTypePrefix, '_') . '_';
+        }
+        foreach ($nodeTypesToFlush as $nodeTypeNameToFlush) {
+            $this->addTagToFlush('NodeType_' . $nodeTypePrefix . $nodeTypeNameToFlush, sprintf('which were tagged with "NodeType_%s" because node "%s" has changed and was of type "%s".', $nodeTypeNameToFlush, ($referenceNodeIdentifier ? $referenceNodeIdentifier : ''), $nodeTypeName));
+        }
+    }
+    /**
+     * Fetches possible usages of the asset and registers nodes that use the asset as changed.
+     *
+     * @throws NodeTypeNotFoundException
+     */
+    public function registerAssetChange(AssetInterface $asset): void
+    {
+        if ($asset instanceof AssetVariantInterface) {
+            $asset = $asset->getOriginalAsset();
+        }
+        if (!$asset->isInUse()) {
+            return;
+        }
+        $cachingHelper = $this->getCachingHelper();
+        foreach ($this->assetService->getUsageReferences($asset) as $reference) {
+            if (!$reference instanceof AssetUsageInNodeProperties) {
+                continue;
+            }
+            $workspaceHash = $cachingHelper->renderWorkspaceTagForContextNode($reference->getWorkspaceName());
+            $this->securityContext->withoutAuthorizationChecks(function () use ($reference, &$node) {
+                $node = $this->getContextForReference($reference)->getNodeByIdentifier($reference->getNodeIdentifier());
+            });
+            if (!$node instanceof NodeInterface) {
+                $this->systemLogger->warning(sprintf('Found a node reference from node with identifier %s in workspace %s to asset %s, but the node could not be fetched.', $reference->getNodeIdentifier(), $reference->getWorkspaceName(), $this->persistenceManager->getIdentifierByObject($asset)), LogEnvironment::fromMethodName(__METHOD__));
+                continue;
+            }
+            $this->registerNodeChange($node);
+            $assetIdentifier = $this->persistenceManager->getIdentifierByObject($asset);
+            $tagName = 'AssetDynamicTag_' . $workspaceHash . '_' . $assetIdentifier;
+            $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because asset "%s" has changed.', $tagName, $assetIdentifier));
+        }
+    }
+    public function shutdownObject(): void
+    {
+        $this->commit();
+    }
+    /**
+     * Flush caches according to the previously registered node changes.
+     */
+    protected function commit(): void
+    {
+        if ($this->tagsToFlush !== []) {
+            if ($this->debugMode) {
+                foreach ($this->tagsToFlush as $tag => $logMessage) {
+                    $affectedEntries = $this->contentCache->flushByTag($tag);
+                    if ($affectedEntries > 0) {
+                        $this->systemLogger->debug(sprintf('Content cache: Removed %s entries %s', $affectedEntries, $logMessage));
+                    }
+                }
+            } else {
+                $affectedEntries = $this->contentCache->flushByTags(array_keys($this->tagsToFlush));
+                $this->systemLogger->debug(sprintf('Content cache: Removed %s entries', $affectedEntries));
+            }
+        }
+    }
+    protected function getContextForReference(AssetUsageInNodeProperties $assetUsage): ContentContext
+    {
+        $hash = md5(sprintf('%s-%s', $assetUsage->getWorkspaceName(), json_encode($assetUsage->getDimensionValues())));
+        if (!isset($this->contexts[$hash])) {
+            $this->contexts[$hash] = $this->contextFactory->create([
+                'workspaceName' => $assetUsage->getWorkspaceName(),
+                'dimensions' => $assetUsage->getDimensionValues(),
+                'invisibleContentShown' => true,
+                'inaccessibleContentShown' => true
+            ]);
+        }
+        return $this->contexts[$hash];
+    }
+    /**
+     * @return array<string>
+     */
+    protected function getAllImplementedNodeTypeNames(NodeType $nodeType): array
+    {
+        if (array_key_exists($nodeType->getName(), $this->implementedNodeTypeNamesByNodeType)) {
+            return $this->implementedNodeTypeNamesByNodeType[$nodeType->getName()];
+        }
+        $self = $this;
+        $types = array_unique(array_reduce($nodeType->getDeclaredSuperTypes(), static function (array $types, NodeType $superType) use ($self) {
+            return array_merge($types, $self->getAllImplementedNodeTypeNames($superType));
+        }, [$nodeType->getName()]));
+        $this->implementedNodeTypeNamesByNodeType[$nodeType->getName()] = $types;
+        return $types;
+    }
+    protected function getCachingHelper(): CachingHelper
+    {
+        if (!$this->cachingHelper instanceof CachingHelper) {
+            $this->cachingHelper = new CachingHelper();
+        }
+        return $this->cachingHelper;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Fusion/ConvertUrisImplementation.php
@@ -0,0 +1,172 @@
+<?php
+namespace Neos\Neos\Fusion;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Neos\Domain\Exception;
+use Neos\Neos\Service\LinkingService;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\Fusion\FusionObjects\AbstractFusionObject;
+/**
+ * A Fusion Object that converts link references in the format "<type>://<UUID>" to proper URIs
+ *
+ * Right now node://<UUID> and asset://<UUID> are supported URI schemes.
+ *
+ * Usage::
+ *
+ *   someTextProperty.@process.1 = Neos.Neos:ConvertUris
+ *
+ * The optional property ``forceConversion`` can be used to have the links converted even when not
+ * rendering the live workspace. This is used for links that are not inline editable (for
+ * example links on images)::
+ *
+ *   someTextProperty.@process.1 = Neos.Neos:ConvertUris {
+ *     forceConversion = true
+ *   }
+ *
+ * The optional property ``externalLinkTarget`` can be modified to disable or change the target attribute of the
+ * link tag for links to external targets::
+ *
+ *   prototype(Neos.Neos:ConvertUris) {
+ *     externalLinkTarget = '_blank'
+ *     resourceLinkTarget = '_blank'
+ *   }
+ *
+ * The optional property ``absolute`` can be used to convert node uris to absolute links::
+ *
+ *   someTextProperty.@process.1 = Neos.Neos:ConvertUris {
+ *     absolute = true
+ *   }
+ */
+class ConvertUrisImplementation extends AbstractFusionObject
+{
+    /**
+     * @Flow\Inject
+     * @var LinkingService
+     */
+    protected $linkingService;
+    /**
+     * Convert URIs matching a supported scheme with generated URIs
+     *
+     * If the workspace of the current node context is not live, no replacement will be done unless forceConversion is
+     * set. This is needed to show the editable links with metadata in the content module.
+     *
+     * @return string
+     * @throws Exception
+     */
+    public function evaluate()
+    {
+        $text = $this->fusionValue('value');
+        if ($text === '' || $text === null) {
+            return '';
+        }
+        if (!is_string($text)) {
+            throw new Exception(sprintf('Only strings can be processed by this Fusion object, given: "%s".', gettype($text)), 1382624080);
+        }
+        $node = $this->fusionValue('node');
+        if (!$node instanceof NodeInterface) {
+            throw new Exception(sprintf('The current node must be an instance of NodeInterface, given: "%s".', gettype($text)), 1382624087);
+        }
+        if (!($this->fusionValue('forceConversion')) && $node->getContext()->getWorkspace()->getName() !== 'live') {
+            return $text;
+        }
+        $unresolvedUris = [];
+        $linkingService = $this->linkingService;
+        $controllerContext = $this->runtime->getControllerContext();
+        $absolute = $this->fusionValue('absolute');
+        $processedContent = preg_replace_callback(LinkingService::PATTERN_SUPPORTED_URIS, function (array $matches) use ($node, $linkingService, $controllerContext, &$unresolvedUris, $absolute) {
+            switch ($matches[1]) {
+                case 'node':
+                    $resolvedUri = $linkingService->resolveNodeUri($matches[0], $node, $controllerContext, $absolute);
+                    $this->runtime->addCacheTag('node', $matches[2]);
+                    break;
+                case 'asset':
+                    $resolvedUri = $linkingService->resolveAssetUri($matches[0]);
+                    $this->runtime->addCacheTag('asset', $matches[2]);
+                    break;
+                default:
+                    $resolvedUri = null;
+            }
+            if ($resolvedUri === null) {
+                $unresolvedUris[] = $matches[0];
+                return $matches[0];
+            }
+            return $resolvedUri;
+        }, $text);
+        if ($unresolvedUris !== []) {
+            $processedContent = preg_replace('/<a(?:\s+[^>]*)?\s+href="(node|asset):\/\/[^"]+"[^>]*>(.*?)<\/a>/', '$2', $processedContent);
+            $processedContent = preg_replace(LinkingService::PATTERN_SUPPORTED_URIS, '', $processedContent);
+        }
+        $processedContent = $this->replaceLinkTargets($processedContent);
+        return $processedContent;
+    }
+    /**
+     * Replace the target attribute of link tags in processedContent with the target
+     * specified by externalLinkTarget and resourceLinkTarget options.
+     * Additionally set rel="noopener external" for external links.
+     *
+     * @param string $processedContent
+     * @return string
+     */
+    protected function replaceLinkTargets($processedContent)
+    {
+        $setNoOpener = $this->fusionValue('setNoOpener');
+        $setExternal = $this->fusionValue('setExternal');
+        $externalLinkTarget = \trim((string)$this->fusionValue('externalLinkTarget'));
+        $resourceLinkTarget = \trim((string)$this->fusionValue('resourceLinkTarget'));
+        $controllerContext = $this->runtime->getControllerContext();
+        $host = $controllerContext->getRequest()->getHttpRequest()->getUri()->getHost();
+        $processedContent = \preg_replace_callback(
+            '~<a\s+.*?href="(.*?)".*?>~i',
+            static function ($matches) use ($externalLinkTarget, $resourceLinkTarget, $host, $setNoOpener, $setExternal) {
+                [$linkText, $linkHref] = $matches;
+                $uriHost = \parse_url($linkHref, PHP_URL_HOST);
+                $target = null;
+                $isExternalLink = \is_string($uriHost) && $uriHost !== $host;
+                if ($externalLinkTarget && $externalLinkTarget !== '' && $isExternalLink) {
+                    $target = $externalLinkTarget;
+                }
+                if ($resourceLinkTarget && $resourceLinkTarget !== '' && str_contains($linkHref, '_Resources')) {
+                    $target = $resourceLinkTarget;
+                }
+                if ($isExternalLink && $setNoOpener) {
+                    $linkText = self::setAttribute('rel', 'noopener', $linkText);
+                }
+                if ($isExternalLink && $setExternal) {
+                    $linkText = self::setAttribute('rel', 'external', $linkText);
+                }
+                if (is_string($target) && $target !== '') {
+                    return self::setAttribute('target', $target, $linkText);
+                }
+                return $linkText;
+            },
+            $processedContent
+        );
+        return $processedContent;
+    }
+    /**
+     * Set or add value to the a attribute
+     *
+     * @param string $attribute The attribute, ('target' or 'rel')
+     * @param string $value The value of the attribute to add
+     * @param string $content The content to parse
+     * @return string
+     */
+    private static function setAttribute(string $attribute, string $value, string $content): string
+    {
+        if (\preg_match_all('~\s+' . $attribute . '="(.*?)~i', $content, $matches)) {
+            if ($attribute === 'target' || \preg_match('~' . $attribute . '=".*?' . $value . '.*?"~i', $content)) {
+                return $content;
+            }
+            return \preg_replace('/' . $attribute . '="(.*?)"/', sprintf('%s="$1 %s"', $attribute, $value), $content);
+        }
+        return \str_replace('<a', sprintf('<a %s="%s"', $attribute, $value), $content);
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Routing/Cache/RouteCacheFlusher.php
@@ -0,0 +1,83 @@
+<?php
+namespace Neos\Neos\Routing\Cache;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Mvc\Routing\RouterCachingService;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\Model\Workspace;
+/**
+ * This service flushes Route caches triggered by node changes.
+ *
+ * @Flow\Scope("singleton")
+ */
+class RouteCacheFlusher
+{
+    /**
+     * @Flow\Inject
+     * @var RouterCachingService
+     */
+    protected $routeCachingService;
+    /**
+     * @var array
+     */
+    protected $tagsToFlush = [];
+    /**
+     * Schedules flushing of the routing cache entries for the given $node
+     * Note that child nodes are flushed automatically because they are tagged with all parents.
+     *
+     * @param NodeInterface $node The node which has changed in some way
+     * @return void
+     */
+    public function registerNodeChange(NodeInterface $node)
+    {
+        if (in_array($node->getIdentifier(), $this->tagsToFlush)) {
+            return;
+        }
+        if (!$node->getNodeType()->isOfType('Neos.Neos:Document')) {
+            return;
+        }
+        $this->tagsToFlush[] = $node->getIdentifier();
+    }
+    /**
+     * Schedules flushing of the all routing cache entries of the workspace whose base workspace has changed.
+     * In most cases $workspace will be a user's personal workspace. Flushing the respective cache entries guards
+     * against mismatches for nodes which exist in the old and the new base workspace but have different node
+     * identifiers and the same URI path (segment).
+     *
+     * @param Workspace $workspace
+     * @param Workspace|null $oldBaseWorkspace
+     * @param Workspace|null $newBaseWorkspace
+     * @return void
+     */
+    public function registerBaseWorkspaceChange(Workspace $workspace, Workspace $oldBaseWorkspace = null, Workspace $newBaseWorkspace = null)
+    {
+        if (!in_array($workspace->getName(), $this->tagsToFlush)) {
+            $this->tagsToFlush[] = $workspace->getName();
+        }
+    }
+    /**
+     * Flush caches according to the previously registered node changes.
+     *
+     * @return void
+     */
+    public function commit()
+    {
+        $this->routeCachingService->flushCachesByTags($this->tagsToFlush);
+        $this->tagsToFlush = [];
+    }
+    /**
+     * @return void
+     */
+    public function shutdownObject()
+    {
+        $this->commit();
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Security/ImpersonateAspect.php
@@ -0,0 +1,60 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Neos\Security;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Aop\JoinPointInterface;
+use Neos\Flow\Security\Authentication\AuthenticationManagerInterface;
+use Neos\Neos\Service\ImpersonateService;
+/**
+ * An aspect which centralizes the logging of security relevant actions.
+ *
+ * @Flow\Scope("singleton")
+ * @Flow\Aspect
+ */
+class ImpersonateAspect
+{
+    /**
+     * @var bool
+     */
+    protected bool $alreadyLoggedAuthenticateCall = false;
+    /**
+     * @var ImpersonateService
+     * @Flow\Inject
+     */
+    protected $impersonateService;
+    /**
+     * @Flow\After("within(Neos\Flow\Security\Authentication\AuthenticationManagerInterface) && method(.*->authenticate())")
+     * @param JoinPointInterface $joinPoint The current joinpoint
+     * @return void
+     * @throws \Exception
+     */
+    public function logManagerAuthenticate(JoinPointInterface $joinPoint): void
+    {
+        /** @var AuthenticationManagerInterface $proxy */
+        $proxy = $joinPoint->getProxy();
+        if ($this->alreadyLoggedAuthenticateCall === true) {
+            $this->alreadyLoggedAuthenticateCall = true;
+            return;
+        }
+        if ($proxy->getSecurityContext()->getAccount() === null) {
+            $this->alreadyLoggedAuthenticateCall = true;
+            return;
+        }
+        if ($this->impersonateService && $this->impersonateService->isActive()) {
+            $impersonation = $this->impersonateService->getImpersonation();
+            foreach ($proxy->getSecurityContext()->getAuthenticationTokens() as $token) {
+                $token->setAccount($impersonation);
+            }
+        }
+        $this->alreadyLoggedAuthenticateCall = true;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Service/Controller/NodeController.php
@@ -0,0 +1,399 @@
+<?php
+namespace Neos\Neos\Service\Controller;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Eel\FlowQuery\FlowQuery;
+use Neos\Flow\Http\Helper\SecurityHelper;
+use Neos\Flow\Property\TypeConverter\PersistentObjectConverter;
+use Neos\Neos\Domain\Repository\DomainRepository;
+use Neos\Neos\Domain\Service\NodeSearchServiceInterface;
+use Neos\Neos\Service\NodeOperations;
+use Neos\Neos\Service\View\NodeView;
+use Neos\ContentRepository\Domain\Factory\NodeFactory;
+use Neos\ContentRepository\Domain\Model\NodeInterface;
+use Neos\ContentRepository\Domain\Model\Node;
+use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
+use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
+use Neos\ContentRepository\Domain\Service\NodeTypeManager;
+use Neos\ContentRepository\Exception\NodeException;
+use Neos\ContentRepository\TypeConverter\NodeConverter;
+/**
+ * Service Controller for managing Nodes
+ *
+ * Note: This controller should be, step-by-step, transformed into a clean REST controller (see NEOS-190 and NEOS-199).
+ *       Since this is a rather big endeavor, we slice the elephant and move methods in a clean way from here to the
+ *       new NodesController (\Neos\Neos\Controller\Service\NodesController)
+ */
+class NodeController extends AbstractServiceController
+{
+    /**
+     * @var NodeView
+     */
+    protected $view;
+    /**
+     * @var array
+     */
+    protected $viewFormatToObjectNameMap = [
+        'html' => NodeView::class,
+        'json' => NodeView::class
+    ];
+    /**
+     * @var array
+     */
+    protected $supportedMediaTypes = [
+        'text/html',
+        'application/json'
+    ];
+    /**
+     * @Flow\Inject
+     * @var NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * @Flow\Inject
+     * @var NodeSearchServiceInterface
+     */
+    protected $nodeSearchService;
+    /**
+     * @Flow\Inject
+     * @var NodeFactory
+     */
+    protected $nodeFactory;
+    /**
+     * @Flow\Inject
+     * @var ContextFactoryInterface
+     */
+    protected $contextFactory;
+    /**
+     * @Flow\Inject
+     * @var NodeDataRepository
+     */
+    protected $nodeDataRepository;
+    /**
+     * @Flow\Inject
+     * @var NodeOperations
+     */
+    protected $nodeOperations;
+    /**
+     * @Flow\Inject
+     * @var DomainRepository
+     */
+    protected $domainRepository;
+    /**
+     * Select special error action
+     *
+     * @return void
+     */
+    protected function initializeAction()
+    {
+        if ($this->arguments->hasArgument('referenceNode')) {
+            $this->arguments->getArgument('referenceNode')->getPropertyMappingConfiguration()->setTypeConverterOption(NodeConverter::class, NodeConverter::REMOVED_CONTENT_SHOWN, true);
+        }
+        $this->uriBuilder->setRequest($this->request->getMainRequest());
+        if (in_array($this->request->getControllerActionName(), ['update', 'updateAndRender'], true)) {
+            $propertyMappingConfiguration = $this->arguments->getArgument('node')->getPropertyMappingConfiguration();
+            $propertyMappingConfiguration->allowOverrideTargetType();
+            $propertyMappingConfiguration->allowAllProperties();
+            $propertyMappingConfiguration->skipUnknownProperties();
+            $propertyMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_MODIFICATION_ALLOWED, true);
+            $propertyMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
+        }
+    }
+    /**
+     * Return child nodes of specified node for usage in a TreeLoader
+     *
+     * @param Node $node The node to find child nodes for
+     * @param string $nodeTypeFilter A node type filter
+     * @param integer $depth levels of childNodes (0 = unlimited)
+     * @param Node $untilNode expand the child nodes until $untilNode is reached, independent of $depth
+     * @return void
+     */
+    public function getChildNodesForTreeAction(Node $node, $nodeTypeFilter, $depth, Node $untilNode)
+    {
+        $this->view->assignChildNodes($node, $nodeTypeFilter, NodeView::STYLE_TREE, $depth, $untilNode);
+    }
+    /**
+     * Return child nodes of specified node for usage in a TreeLoader based on filter
+     *
+     * @param Node $node The node to find child nodes for
+     * @param string $term
+     * @param string $nodeType
+     * @return void
+     */
+    public function filterChildNodesForTreeAction(Node $node, $term, $nodeType)
+    {
+        $nodeTypes = strlen($nodeType) > 0 ? [$nodeType] : array_keys($this->nodeTypeManager->getSubNodeTypes('Neos.Neos:Document', false));
+        $context = $node->getContext();
+        if ($term !== '') {
+            $nodes = $this->nodeSearchService->findByProperties($term, $nodeTypes, $context, $node);
+        } else {
+            $nodes = [];
+            $nodeDataRecords = $this->nodeDataRepository->findByParentAndNodeTypeRecursively($node->getPath(), implode(',', $nodeTypes), $context->getWorkspace(), $context->getDimensions());
+            foreach ($nodeDataRecords as $nodeData) {
+                $matchedNode = $this->nodeFactory->createFromNodeData($nodeData, $context);
+                if ($matchedNode !== null) {
+                    $nodes[$matchedNode->getPath()] = $matchedNode;
+                }
+            }
+        }
+        $this->view->assignFilteredChildNodes(
+            $node,
+            $nodes
+        );
+    }
+    /**
+     * Creates a new node
+     *
+     * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
+     * because they might be connected to images / resources which need to be updated at the same time.
+     *
+     * @param Node $referenceNode
+     * @param array $nodeData
+     * @param string $position where the node should be added (allowed: before, into, after)
+     * @return void
+     */
+    public function createAction(Node $referenceNode, array $nodeData, $position)
+    {
+        $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
+        if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
+            $this->persistenceManager->persistAll();
+        }
+        $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $newNode], 'Frontend\Node', 'Neos.Neos');
+        $this->view->assign('value', ['data' => ['nextUri' => $nextUri], 'success' => true]);
+    }
+    /**
+     * Creates a new node and renders the node inside the containing content collection.
+     *
+     * @param Node $referenceNode
+     * @param string $fusionPath The Fusion path of the collection
+     * @param array $nodeData
+     * @param string $position where the node should be added (allowed: before, into, after)
+     * @return string
+     */
+    public function createAndRenderAction(Node $referenceNode, $fusionPath, array $nodeData, $position)
+    {
+        $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
+        $this->redirectToRenderNode($newNode, $fusionPath);
+    }
+    /**
+     * Creates a new node and returns tree structure
+     *
+     * @param Node $referenceNode
+     * @param array $nodeData
+     * @param string $position where the node should be added, -1 is before, 0 is in, 1 is after
+     * @param string $nodeTypeFilter
+     * @return void
+     */
+    public function createNodeForTheTreeAction(Node $referenceNode, array $nodeData, $position, $nodeTypeFilter = '')
+    {
+        $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
+        $this->view->assignNodeAndChildNodes($newNode, $nodeTypeFilter);
+    }
+    /**
+     * Move $node before, into or after $targetNode
+     *
+     * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
+     * because they might be connected to images / resources which need to be updated at the same time.
+     *
+     * @param Node $node The node to be moved
+     * @param Node $targetNode The target node to be moved "to", see $position
+     * @param string $position where the node should be added (allowed: before, into, after)
+     * @return void
+     */
+    public function moveAction(Node $node, Node $targetNode, $position)
+    {
+        $node = $this->nodeOperations->move($node, $targetNode, $position);
+        if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
+            $this->persistenceManager->persistAll();
+        }
+        $data = ['newNodePath' => $node->getContextPath()];
+        if ($node->getNodeType()->isOfType('Neos.Neos:Document')) {
+            $data['nextUri'] = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $node], 'Frontend\Node', 'Neos.Neos');
+        }
+        $this->view->assign('value', ['data' => $data, 'success' => true]);
+    }
+    /**
+     * Move the given node before, into or after the target node depending on the given position and renders it's content collection.
+     *
+     * @param Node $node The node to be moved
+     * @param Node $targetNode The target node to be moved "to", see $position
+     * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
+     * @param string $fusionPath The Fusion path of the collection
+     * @return void
+     */
+    public function moveAndRenderAction(Node $node, Node $targetNode, $position, $fusionPath)
+    {
+        $this->nodeOperations->move($node, $targetNode, $position);
+        $this->redirectToRenderNode($node, $fusionPath);
+    }
+    /**
+     * Copy $node before, into or after $targetNode
+     *
+     * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
+     * because they might be connected to images / resources which need to be updated at the same time.
+     *
+     * @param Node $node The node to be copied
+     * @param Node $targetNode The target node to be copied "to", see $position
+     * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
+     * @param string $nodeName Optional node name (if empty random node name will be generated)
+     * @return void
+     * @throws NodeException
+     */
+    public function copyAction(Node $node, Node $targetNode, $position, $nodeName = null)
+    {
+        $copiedNode = $this->nodeOperations->copy($node, $targetNode, $position, $nodeName);
+        if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
+            $this->persistenceManager->persistAll();
+        }
+        $q = new FlowQuery([$copiedNode]);
+        $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
+        $requestData = [
+            'nextUri' => $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos'),
+            'newNodePath' => $copiedNode->getContextPath()
+        ];
+        if ($node->getNodeType()->isOfType('Neos.Neos:Document')) {
+            $requestData['nodeUri'] = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $copiedNode], 'Frontend\Node', 'Neos.Neos');
+        }
+        $this->view->assign('value', ['data' => $requestData, 'success' => true]);
+    }
+    /**
+     * Copies the given node before, into or after the target node depending on the given position and renders it's content collection.
+     *
+     * @param Node $node The node to be copied
+     * @param Node $targetNode The target node to be copied "to", see $position
+     * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
+     * @param string $nodeName Optional node name (if empty random node name will be generated)
+     * @param string $fusionPath The Fusion path of the collection
+     * @return void
+     */
+    public function copyAndRenderAction(Node $node, Node $targetNode, $position, $fusionPath, $nodeName = null)
+    {
+        $copiedNode = $this->nodeOperations->copy($node, $targetNode, $position, $nodeName);
+        $this->redirectToRenderNode($copiedNode, $fusionPath);
+    }
+    /**
+     * Updates the specified node.
+     *
+     * Returns the following data:
+     *
+     * - the (possibly changed) workspace name of the node
+     * - the URI of the closest document node. If $node is a document node (f.e. a Page), the own URI is returned.
+     *   This is important to handle renames of nodes correctly.
+     *
+     * Note: We do not call $nodeDataRepository->update() here, as ContentRepository has a stateful API for now.
+     *       We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
+     *       because they might be connected to images / resources which need to be updated at the same time.
+     *
+     * @param Node $node The node to be updated
+     * @return void
+     */
+    public function updateAction(Node $node)
+    {
+        if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
+            $this->persistenceManager->persistAll();
+        }
+        $q = new FlowQuery([$node]);
+        $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
+        $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos');
+        $this->view->assign('value', [
+            'data' => [
+                'workspaceNameOfNode' => $node->getWorkspace()->getName(),
+                'labelOfNode' => $node->getLabel(),
+                'nextUri' => $nextUri
+            ],
+            'success' => true
+        ]);
+    }
+    /**
+     * Updates the specified node and renders it's content collection.
+     *
+     * @param Node $node The node to be updated
+     * @param string $fusionPath The Fusion path of the collection
+     * @return void
+     */
+    public function updateAndRenderAction(Node $node, $fusionPath)
+    {
+        $this->redirectToRenderNode($node, $fusionPath);
+    }
+    /**
+     * Deletes the specified node and all of its sub nodes
+     *
+     * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
+     * because they might be connected to images / resources which need to be removed at the same time.
+     *
+     * @param Node $node
+     * @return void
+     */
+    public function deleteAction(Node $node)
+    {
+        if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
+            $this->persistenceManager->persistAll();
+        }
+        $q = new FlowQuery([$node]);
+        $node->remove();
+        $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
+        $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos');
+        $this->view->assign('value', ['data' => ['nextUri' => $nextUri], 'success' => true]);
+    }
+    /**
+     * Takes care of creating a redirect to properly render the collection the given node is in.
+     *
+     * @param NodeInterface $node
+     * @param string $fusionPath
+     * @return string
+     */
+    protected function redirectToRenderNode(NodeInterface $node, $fusionPath)
+    {
+        $q = new FlowQuery([$node]);
+        $closestContentCollection = $q->closest('[instanceof Neos.Neos:ContentCollection]')->get(0);
+        $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
+        $this->redirect('show', 'Frontend\\Node', 'Neos.Neos', [
+            'node' => $closestDocumentNode,
+            '__nodeContextPath' => $closestContentCollection->getContextPath(),
+            '__affectedNodeContextPath' => $node->getContextPath(),
+            '__fusionPath' => $fusionPath
+        ], 0, 303, 'html');
+    }
+    /**
+     * Returns an array with the data needed by for example the frontend editing
+     * link plugins to represent the passed Node instance.
+     *
+     * @param NodeInterface $node
+     * @return array
+     */
+    protected function processNodeForEditorPlugins(NodeInterface $node)
+    {
+        return [
+            'id' => $node->getPath(),
+            'name' => $node->getLabel(),
+            'url' => $this->uriBuilder->uriFor('show', ['node' => $node], 'Frontend\Node', 'Neos.Neos'),
+            'type' => 'neos/internal-link'
+        ];
+    }
+    /**
+     * Create a Context for a workspace given by name to be used in this controller.
+     *
+     * @param string $workspaceName Name of the current workspace
+     * @return \Neos\ContentRepository\Domain\Service\Context
+     */
+    protected function createContext($workspaceName)
+    {
+        $contextProperties = [
+            'workspaceName' => $workspaceName
+        ];
+        $currentDomain = $this->domainRepository->findOneByActiveRequest();
+        if ($currentDomain !== null) {
+            $contextProperties['currentSite'] = $currentDomain->getSite();
+            $contextProperties['currentDomain'] = $currentDomain;
+        }
+        return $this->contextFactory->create($contextProperties);
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Service/ImpersonateService.php
@@ -0,0 +1,157 @@
+<?php
+declare(strict_types=1);
+namespace Neos\Neos\Service;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Flow\Persistence\PersistenceManagerInterface;
+use Neos\Flow\Security\Account;
+use Neos\Flow\Security\Context;
+use Neos\Flow\Security\Policy\PolicyService;
+use Neos\Flow\Session\Exception\SessionNotStartedException;
+use Neos\Flow\Session\SessionInterface;
+/**
+ * Impersonate Service
+ */
+class ImpersonateService
+{
+    /**
+     * @var Context
+     * @Flow\Inject
+     */
+    protected $securityContext;
+    /**
+     * @var SessionInterface
+     * @Flow\Inject
+     */
+    protected $session;
+    /**
+     * @var PersistenceManagerInterface
+     * @Flow\Inject
+     */
+    protected $persistenceManager;
+    /**
+     * @var PolicyService
+     * @Flow\Inject
+     */
+    protected $policyService;
+    /**
+     * @param Account $account
+     * @return void
+     * @throws SessionNotStartedException
+     */
+    public function impersonate(Account $account): void
+    {
+        $currentAccount = $this->securityContext->getAccount();
+        $this->writeSession('OriginalIdentity', $this->persistenceManager->getIdentifierByObject($currentAccount));
+        $this->refreshTokens($account);
+        $this->writeSession('Impersonate', $this->persistenceManager->getIdentifierByObject($account));
+    }
+    /**
+     * @return void
+     * @throws SessionNotStartedException
+     */
+    public function restoreOriginalIdentity(): void
+    {
+        $account = $this->getOriginalIdentity();
+        $this->refreshTokens($account);
+        $this->writeSession('Impersonate', null);
+    }
+    /**
+     * @return Account|null
+     * @throws SessionNotStartedException
+     */
+    public function getImpersonation(): ?Account
+    {
+        $impersonation = $this->getSessionData('Impersonate');
+        if ($impersonation !== null) {
+            return $this->persistenceManager->getObjectByIdentifier($impersonation, Account::class);
+        }
+        return null;
+    }
+    /**
+     * @return bool
+     * @throws SessionNotStartedException
+     */
+    public function isActive(): bool
+    {
+        return $this->getImpersonation() instanceof Account;
+    }
+    /**
+     * @return Account|null
+     */
+    public function getCurrentUser(): ?Account
+    {
+        return $this->securityContext->getAccount();
+    }
+    /**
+     * @return Account|null
+     * @throws SessionNotStartedException
+     */
+    public function getOriginalIdentity(): ?Account
+    {
+        $originalIdentity = $this->getSessionData('OriginalIdentity');
+        if ($originalIdentity !== null) {
+            return $this->persistenceManager->getObjectByIdentifier($originalIdentity, Account::class);
+        }
+        return $this->securityContext->getAccount();
+    }
+    /**
+     * @return array
+     * @throws SessionNotStartedException
+     */
+    public function getOriginalIdentityRoles(): array
+    {
+        $originalAccount = $this->getOriginalIdentity();
+        $roles = $originalAccount ? $originalAccount->getRoles() : [];
+        foreach ($roles as $role) {
+            foreach ($this->policyService->getAllParentRoles($role) as $parentRole) {
+                if (!in_array($parentRole, $roles, true)) {
+                    $roles[$parentRole->getIdentifier()] = $parentRole;
+                }
+            }
+        }
+        return $roles;
+    }
+    /**
+     * @param Account|null $account
+     * @return void
+     */
+    protected function refreshTokens(Account $account = null): void
+    {
+        if ($account === null) {
+            return;
+        }
+        $tokens = $this->securityContext->getAuthenticationTokens();
+        foreach ($tokens as $token) {
+            $token->setAccount($account);
+        }
+    }
+    /**
+     * @param string $key
+     * @param string|null $value
+     * @return void
+     * @throws SessionNotStartedException
+     */
+    protected function writeSession(string $key, ?string $value): void
+    {
+        if ($this->session->isStarted()) {
+            $this->session->putData($key, $value);
+        }
+    }
+    /**
+     * @param string $key
+     * @throws SessionNotStartedException
+     */
+    protected function getSessionData(string $key): mixed
+    {
+        return $this->session->isStarted() && $this->session->hasKey($key) ? $this->session->getData($key) : null;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Service/NodeTypeSchemaBuilder.php
@@ -0,0 +1,98 @@
+<?php
+namespace Neos\Neos\Service;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\ContentRepository\Domain\Model\NodeType;
+/**
+ * Renders the Node Type Schema in a format the User Interface understands; additionally pre-calculating node constraints
+ *
+ * @Flow\Scope("singleton")
+ */
+class NodeTypeSchemaBuilder
+{
+    /**
+     * @Flow\Inject
+     * @var \Neos\ContentRepository\Domain\Service\NodeTypeManager
+     */
+    protected $nodeTypeManager;
+    /**
+     * The preprocessed node type schema contains everything we need for the UI:
+     *
+     * - "nodeTypes" contains the original (merged) node type schema
+     * - "inheritanceMap.subTypes" contains for every parent type the transitive list of subtypes
+     * - "constraints" contains for each node type, the list of allowed child node types; normalizing
+     *   allowlists and excludelists:
+     *   - [node type]
+     *     - nodeTypes:
+     *       [child node type name]: true
+     *     - childNodes:
+     *       - [child node name]
+     *         - nodeTypes:
+     *          [child node type name]: true
+     *
+     * @return array the node type schema ready to be used by the JavaScript code
+     */
+    public function generateNodeTypeSchema()
+    {
+        $schema = [
+            'inheritanceMap' => [
+                'subTypes' => []
+            ],
+            'nodeTypes' => [],
+            'constraints' => $this->generateConstraints()
+        ];
+        $nodeTypes = $this->nodeTypeManager->getNodeTypes(true);
+        /** @var NodeType $nodeType */
+        foreach ($nodeTypes as $nodeTypeName => $nodeType) {
+            if ($nodeType->isAbstract() === false) {
+                $configuration = $nodeType->getFullConfiguration();
+                $schema['nodeTypes'][$nodeTypeName] = $configuration;
+                $schema['nodeTypes'][$nodeTypeName]['label'] = $nodeType->getLabel();
+            }
+            $schema['inheritanceMap']['subTypes'][$nodeTypeName] = [];
+            foreach ($this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), true) as $subNodeType) {
+                /** @var NodeType $subNodeType */
+                $schema['inheritanceMap']['subTypes'][$nodeTypeName][] = $subNodeType->getName();
+            }
+        }
+        return $schema;
+    }
+    /**
+     * Generate the list of allowed sub-node-types per parent-node-type and child-node-name.
+     *
+     * @return array constraints
+     */
+    protected function generateConstraints()
+    {
+        $constraints = [];
+        $nodeTypes = $this->nodeTypeManager->getNodeTypes(true);
+        /** @var NodeType $nodeType */
+        foreach ($nodeTypes as $nodeTypeName => $nodeType) {
+            $constraints[$nodeTypeName] = [
+                'nodeTypes' => [],
+                'childNodes' => []
+            ];
+            foreach ($nodeTypes as $innerNodeTypeName => $innerNodeType) {
+                if ($nodeType->allowsChildNodeType($innerNodeType)) {
+                    $constraints[$nodeTypeName]['nodeTypes'][$innerNodeTypeName] = true;
+                }
+            }
+            foreach ($nodeType->getAutoCreatedChildNodes() as $key => $_x) {
+                foreach ($nodeTypes as $innerNodeTypeName => $innerNodeType) {
+                    if ($nodeType->allowsGrandchildNodeType($key, $innerNodeType)) {
+                        $constraints[$nodeTypeName]['childNodes'][$key]['nodeTypes'][$innerNodeTypeName] = true;
+                    }
+                }
+            }
+        }
+        return $constraints;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/Service/UserService.php
@@ -0,0 +1,116 @@
+<?php
+namespace Neos\Neos\Service;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Neos\Domain\Model\User;
+use Neos\ContentRepository\Domain\Model\Workspace;
+use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
+use Neos\Neos\Utility\User as UserUtility;
+/**
+ * The user service provides general context information about the currently
+ * authenticated backend user.
+ *
+ * The methods getters of this class are accessible via the "context.userInformation" variable in security policies
+ * and thus are implicitly considered to be part of the public API. This UserService should be replaced by
+ * \Neos\Neos\Domain\Service\UserService in the long run.
+ *
+ * @Flow\Scope("singleton")
+ * @api
+ */
+class UserService
+{
+    /**
+     * @Flow\Inject
+     * @var \Neos\Neos\Domain\Service\UserService
+     */
+    protected $userDomainService;
+    /**
+     * @Flow\Inject
+     * @var WorkspaceRepository
+     */
+    protected $workspaceRepository;
+    /**
+     * @Flow\InjectConfiguration("userInterface.defaultLanguage")
+     * @var string
+     */
+    protected $defaultLanguageIdentifier;
+    /**
+     * @Flow\Inject
+     * @var \Neos\Flow\Security\Context
+     */
+    protected $securityContext;
+    /**
+     * Returns the current backend user
+     *
+     * @return ?User
+     * @api
+     */
+    public function getBackendUser()
+    {
+        return $this->userDomainService->getCurrentUser();
+    }
+    /**
+     * Returns the current user's personal workspace or null if no user is logged in
+     *
+     * @return Workspace
+     * @api
+     */
+    public function getPersonalWorkspace()
+    {
+        $workspaceName = $this->getPersonalWorkspaceName();
+        if ($workspaceName !== null) {
+            return $this->workspaceRepository->findOneByName($workspaceName);
+        }
+    }
+    /**
+     * Returns the name of the currently logged in user's personal workspace (even if that might not exist at that time).
+     * If no user is logged in this method returns null.
+     *
+     * @return string
+     * @api
+     */
+    public function getPersonalWorkspaceName()
+    {
+        $currentUser = $this->userDomainService->getCurrentUser();
+        if (!$currentUser instanceof User) {
+            return null;
+        }
+        $username = $this->userDomainService->getUsername(
+            $currentUser,
+            $this->securityContext->getAccount()->getAuthenticationProviderName()
+        );
+        return ($username === null ? null : UserUtility::getPersonalWorkspaceNameForUsername($username));
+    }
+    /**
+     * Returns the stored preferences of a user
+     *
+     * @param string $preference
+     * @return mixed
+     * @api
+     */
+    public function getUserPreference($preference)
+    {
+        $user = $this->getBackendUser();
+        if ($user && $user->getPreferences()) {
+            return $user->getPreferences()->get($preference) ?: null;
+        }
+    }
+    /**
+     * Returns the interface language the user selected. Will fall back to the default language defined in settings
+     *
+     * @return string
+     * @api
+     */
+    public function getInterfaceLanguage()
+    {
+        return $this->getUserPreference('interfaceLanguage') ?: $this->defaultLanguageIdentifier;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Classes/ViewHelpers/Backend/ConfigurationCacheVersionViewHelper.php
@@ -0,0 +1,48 @@
+<?php
+namespace Neos\Neos\ViewHelpers\Backend;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+use Neos\Flow\Annotations as Flow;
+use Neos\Cache\Frontend\StringFrontend;
+use Neos\Flow\Security\Context;
+use Neos\FluidAdaptor\Core\ViewHelper\AbstractViewHelper;
+/**
+ * ViewHelper for rendering the current version identifier for the
+ * configuration cache.
+ */
+class ConfigurationCacheVersionViewHelper extends AbstractViewHelper
+{
+    /**
+     * @var StringFrontend
+     */
+    protected $configurationCache;
+    /**
+     * @Flow\Inject
+     * @var Context
+     */
+    protected $securityContext;
+    /**
+     * @return string The current cache version identifier
+     */
+    public function render(): string
+    {
+        $account = $this->securityContext->getAccount();
+        $roles = $account ? array_map(static fn ($role) => $role->getIdentifier(), $account->getRoles()) : [];
+        sort($roles);
+        $configurationIdentifier = md5(implode('_', $roles));
+        $cacheKey = 'ConfigurationVersion_' . $configurationIdentifier;
+        $version = $this->configurationCache->get($cacheKey);
+        if ($version === false) {
+            $version = (string)time();
+            $this->configurationCache->set($cacheKey, $version);
+        }
+        return  $configurationIdentifier . '_' . $version;
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Documentation/conf.py
@@ -0,0 +1,31 @@
+import os
+import sys
+from sphinx.highlighting import lexers
+from pygments.lexers.web import PhpLexer
+project = 'Neos CMS'
+copyright = '2006 and onwards by the authors'
+author = 'Neos Team and Contributors'
+version = 'dev-master'
+release = 'dev-master'
+extensions = [
+    'sphinx_rtd_theme',
+    'sphinx.ext.intersphinx',
+    'sphinx.ext.todo',
+    'sphinx.ext.ifconfig'
+]
+templates_path = ['_templates']
+exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
+highlight_language='php'
+html_theme = 'sphinx_rtd_theme'
+html_static_path = ['_static']
+html_theme_options = {
+  'prev_next_buttons_location': 'both',
+  'style_external_links': True
+}
+intersphinx_mapping = {
+    'neos': ('https://neos.readthedocs.io/en/stable', None),
+    'media': ('https://neos-media.readthedocs.io/en/stable', None),
+    'flow': ('https://flowframework.readthedocs.io/en/stable', None),
+}
+lexers['php'] = PhpLexer(startinline=True)
+lexers['php-annotations'] = PhpLexer(startinline=True)

--- a//dev/null
+++ b/Neos.Neos/Migrations/Code/Version20220318111600.php
@@ -0,0 +1,31 @@
+<?php
+namespace Neos\Flow\Core\Migrations;
+/*
+ * This file is part of the Neos.Neos package.
+ *
+ * (c) Contributors of the Neos Project - www.neos.io
+ *
+ * This package is Open Source Software. For the full copyright and license
+ * information, please view the LICENSE file which was distributed with this
+ * source code.
+ */
+/**
+ * Replace legacy content cache tag definitions in Fusion
+ *
+ * - Replace legacy NodeType tags with the corresponding eel helper call and the current node as context
+ * - Replace legacy DescendantOf tags with the corresponding eel helper call
+ * - Replace legacy Node tags with the corresponding eel helper call
+ */
+class Version20220318111600 extends AbstractMigration
+{
+    public function getIdentifier(): string
+    {
+        return 'Neos.Neos-20220318111600';
+    }
+    public function up(): void
+    {
+        $this->searchAndReplaceRegex('/(.*) = \$?\{?\'NodeType_(.*)\'\}?/', "$1 = \${Neos.Caching.nodeTypeTag('$2', node)}", ['fusion']);
+        $this->searchAndReplaceRegex('/(.*) = \$\{\'Node_\' \+ (.*)\.identifier\}/', "$1 = \${Neos.Caching.nodeTag($2)}", ['fusion']);
+        $this->searchAndReplaceRegex('/(.*) = \$\{\'DescendantOf_\' \+ (.*)\.identifier\}/', "$1 = \${Neos.Caching.descendantOfTag($2)}", ['fusion']);
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Components/TopBar/UserMenu.js
@@ -0,0 +1,81 @@
+import { isNil } from '../../Helper'
+import {ApiService} from '../../Services'
+import { RestoreButton } from '../../Templates/RestoreButton'
+const BASE_PATH = '/neos/impersonate/'
+export default class UserMenu {
+    constructor(_root) {
+        const csfrTokenField = document.querySelector('[data-csrf-token]')
+        this._csrfToken = !isNil(csfrTokenField)
+            ? csfrTokenField.getAttribute('data-csrf-token')
+            : ''
+        this._root = _root
+        this._apiService = new ApiService(BASE_PATH, this._csrfToken)
+        if (!isNil(_root)) {
+            this._checkImpersonateStatus()
+        }
+    }
+    _renderRestoreButton(user) {
+        const userMenuDropDown = this._root.querySelector('.neos-dropdown-menu')
+        if (isNil(userMenuDropDown) || isNil(user)) {
+            return false
+        }
+        const restoreListItem = document.createElement('li')
+        restoreListItem.innerHTML = RestoreButton(user)
+        userMenuDropDown.appendChild(restoreListItem)
+        const restoreButtonElement = userMenuDropDown.querySelector(
+            '.restore-user'
+        )
+        if (!isNil(restoreButtonElement)) {
+            restoreButtonElement.addEventListener(
+                'click',
+                this._restoreUser.bind(this)
+            )
+        }
+    }
+    _checkImpersonateStatus() {
+        const response = this._apiService.callStatus()
+        response
+            .then((data) => {
+                const { origin, status } = data
+                if (status && !isNil(origin)) {
+                    this._renderRestoreButton(origin)
+                }
+            })
+            .catch(function (error) {
+            })
+    }
+    _restoreUser(event) {
+        event.preventDefault()
+        const button = event.currentTarget
+        if (isNil(button)) {
+            return false
+        }
+        const response = this._apiService.callRestore()
+        response
+            .then((data) => {
+                const { origin, impersonate, status } = data
+                const message = window.NeosCMS.I18n.translate(
+                    'impersonate.success.restoreUser',
+                    'Switched back from {0} to the orginal user {1}.',
+                    'Neos.Neos',
+                    'Main',
+                    {
+                        0: impersonate.accountIdentifier,
+                        1: origin.accountIdentifier,
+                    }
+                )
+                window.NeosCMS.Notification.ok(message)
+                window.location.pathname = '/neos'
+            })
+            .catch(function (error) {
+                if (window.NeosCMS) {
+                    const message = window.NeosCMS.I18n.translate(
+                        'impersonate.error.restoreUser',
+                        'Could not switch back to the original user.',
+                        'Neos.Neos'
+                    )
+                    window.NeosCMS.Notification.error(message)
+                }
+            })
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Components/TopBar/index.ts
@@ -0,0 +1,5 @@
+import DropDownMenu from "./DropdownMenu";
+import Expandable from "./Expandable";
+import MenuPanel from "./MenuPanel";
+import UserMenu from "./UserMenu";
+export { DropDownMenu, Expandable, MenuPanel, UserMenu };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Interfaces/Window.ts
@@ -0,0 +1,10 @@
+import NeosI18n from "./NeosI18n";
+import NeosNotification from "./NeosNotification";
+import NeosConfiguration from "./NeosConfiguration";
+export default interface Window {
+  NeosCMS: {
+    I18n: NeosI18n;
+    Notification: NeosNotification;
+    Configuration: NeosConfiguration;
+  };
+}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Main.min.js
@@ -0,0 +1,2 @@
+/*! For license information please see Main.min.js.LICENSE.txt */
+(()=>{var e={148:(e,n,r)=>{"use strict";r.r(n),r.d(n,{default:()=>UserMenu});var o=r(586),i=r(912);class UserMenu{constructor(e){const n=document.querySelector("[data-csrf-token]");this._csrfToken=(0,o.isNil)(n)?"":n.getAttribute("data-csrf-token"),this._root=e,this._apiService=new i.sM("/neos/impersonate/",this._csrfToken),(0,o.isNil)(e)||this._checkImpersonateStatus()}_renderRestoreButton(e){const n=this._root.querySelector(".neos-dropdown-menu");if((0,o.isNil)(n)||(0,o.isNil)(e))return!1;const r=document.createElement("li");r.innerHTML=(e=>{const n={class:"neos-button restore-user"};let r="";Object.keys(n).forEach((e=>{r+=`${e}="${n[e]}" `}));const i=(0,o.isNil)(window.NeosCMS)?window.NeosCMS.I18n.translate("impersonate.label.restoreUserButton",'Back to user "{0}"',"Neos.Neos","Main",e.accountIdentifier):`Restore user "${e.accountIdentifier}"`;return`<button ${r}><i class="fas fa-random icon-white"></i> ${i}</button>`})(e),n.appendChild(r);const i=n.querySelector(".restore-user");(0,o.isNil)(i)||i.addEventListener("click",this._restoreUser.bind(this))}_checkImpersonateStatus(){this._apiService.callStatus().then((e=>{const{origin:n,status:r}=e;r&&!(0,o.isNil)(n)&&this._renderRestoreButton(n)})).catch((function(e){}))}_restoreUser(e){e.preventDefault();const n=e.currentTarget;if((0,o.isNil)(n))return!1;this._apiService.callRestore().then((e=>{const{origin:n,impersonate:r,status:o}=e,i=window.NeosCMS.I18n.translate("impersonate.success.restoreUser","Switched back from {0} to the orginal user {1}.","Neos.Neos","Main",{0:r.accountIdentifier,1:n.accountIdentifier});window.NeosCMS.Notification.ok(i),window.location.pathname="/neos"})).catch((function(e){if(window.NeosCMS){const e=window.NeosCMS.I18n.translate("impersonate.error.restoreUser","Could not switch back to the original user.","Neos.Neos");window.NeosCMS.Notification.error(e)}}))}}},791:(e,n,r)=>{"use strict";r.r(n),r.d(n,{loadStorageData:()=>loadStorageData,saveStorageData:()=>saveStorageData});var o=r(586);const i="persistedState",getStorage=()=>{const e=localStorage.getItem(i),n=JSON.parse(e);return(0,o.isNil)(n)?{}:n},loadStorageData=e=>{const n=getStorage();return(0,o.getCollectionValueByPath)(n,e)},saveStorageData=(e,n)=>{const r=getStorage(),a=(0,o.createCollectionByPath)(r,e,n);(0,o.isNil)(a)||localStorage.setItem(i,JSON.stringify(a))}},449:(e,n,r)=>{"use strict";r.d(n,{Z:()=>o});const o={getItem:e=>{try{return JSON.parse(window.sessionStorage.getItem(e))}catch(e){return}},setItem:(e,n)=>{try{window.sessionStorage.setItem(e,JSON.stringify(n))}catch(r){window.sessionStorage.clear(),window.sessionStorage.setItem(e,JSON.stringify(n))}},removeItem:e=>{window.sessionStorage.removeItem(e)}}},912:(e,n,r)=>{"use strict";r.d(n,{sM:()=>ApiService,VK:()=>a,Wt:()=>P,WH:()=>O,P_:()=>c});var o=r(586);const i=!(0,o.isNil)(window.NeosCMS?.Configuration),a={init:()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Configuration)&&(window.NeosCMS.Configuration={});const n=document.querySelector('link[rel="neos-xliff"]');(0,o.isNil)(n)||(window.NeosCMS.Configuration.XliffUri=n.getAttribute("href"))},get:e=>i?(0,o.getCollectionValueByPath)(window.NeosCMS.Configuration,e):null,override:(e,n)=>{i&&e in window.NeosCMS.Configuration&&(window.NeosCMS.Configuration[e]=n)}};var s=r(944),l=r.n(s);const u=["ok","info","notice","warning","error"],_renderNotification=(e,n,r,o)=>{const i={title:e,message:n,...o};u.includes(r)&&(i.type=r),l().create(i)},ok=e=>{_renderNotification(e,"","ok")},info=e=>{_renderNotification(e,"","info")},notice=e=>{_renderNotification(e,"","notice")},warning=(e,n)=>{_renderNotification(e,n,"warning",{timeout:0,closeButton:!0})},error=(e,n)=>{_renderNotification(e,n,"error",{timeout:0,closeButton:!0})},clear=()=>{l().removeAll()},Notification_init=()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Notification)&&(window.NeosCMS.Notification={init:Notification_init,ok,info,notice,warning,error,clear});Array.from(document.querySelectorAll("#neos-notifications-inline li")).forEach((e=>{const n=e.getAttribute("data-type"),r=e.textContent;_renderNotification(r,"",n)}))},c={init:Notification_init,ok,info,notice,warning,error,clear};function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function _typeof(e){return typeof e}:function _typeof(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _defineProperty(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function _objectSpread(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?Object(arguments[n]):{},o=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),o.forEach((function(n){_defineProperty(e,n,r[n])}))}return e}function _classCallCheck(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,n){for(var r=0;r<n.length;r++){var o=n[r];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function _createClass(e,n,r){return n&&_defineProperties(e.prototype,n),r&&_defineProperties(e,r),e}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _possibleConstructorReturn(e,n){return!n||"object"!==_typeof(n)&&"function"!=typeof n?_assertThisInitialized(e):n}function _getPrototypeOf(e){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function _setPrototypeOf(e,n){return(_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(e,n){return e.__proto__=n,e})(e,n)}function _inherits(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&_setPrototypeOf(e,n)}var d={type:"logger",log:function log(e){this.output("log",e)},warn:function warn(e){this.output("warn",e)},error:function error(e){this.output("error",e)},output:function output(e,n){console&&console[e]&&console[e].apply(console,n)}},p=new(function(){function Logger(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,Logger),this.init(e,n)}return _createClass(Logger,[{key:"init",value:function init(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=n.prefix||"i18next:",this.logger=e||d,this.options=n,this.debug=n.debug}},{key:"setDebug",value:function setDebug(e){this.debug=e}},{key:"log",value:function log(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"log","",!0)}},{key:"warn",value:function warn(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"warn","",!0)}},{key:"error",value:function error(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"error","")}},{key:"deprecate",value:function deprecate(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function forward(e,n,r,o){return o&&!this.debug?null:("string"==typeof e[0]&&(e[0]="".concat(r).concat(this.prefix," ").concat(e[0])),this.logger[n](e))}},{key:"create",value:function create(e){return new Logger(this.logger,_objectSpread({},{prefix:"".concat(this.prefix,":").concat(e,":")},this.options))}}]),Logger}()),f=function(){function EventEmitter(){_classCallCheck(this,EventEmitter),this.observers={}}return _createClass(EventEmitter,[{key:"on",value:function on(e,n){var r=this;return e.split(" ").forEach((function(e){r.observers[e]=r.observers[e]||[],r.observers[e].push(n)})),this}},{key:"off",value:function off(e,n){this.observers[e]&&(n?this.observers[e]=this.observers[e].filter((function(e){return e!==n})):delete this.observers[e])}},{key:"emit",value:function emit(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];if(this.observers[e]){var i=[].concat(this.observers[e]);i.forEach((function(e){e.apply(void 0,r)}))}if(this.observers["*"]){var a=[].concat(this.observers["*"]);a.forEach((function(n){n.apply(n,[e].concat(r))}))}}}]),EventEmitter}();function defer(){var e,n,r=new Promise((function(r,o){e=r,n=o}));return r.resolve=e,r.reject=n,r}function makeString(e){return null==e?"":""+e}function copy(e,n,r){e.forEach((function(e){n[e]&&(r[e]=n[e])}))}function getLastOfPath(e,n,r){function cleanKey(e){return e&&e.indexOf("###")>-1?e.replace(/###/g,"."):e}function canNotTraverseDeeper(){return!e||"string"==typeof e}for(var o="string"!=typeof n?[].concat(n):n.split(".");o.length>1;){if(canNotTraverseDeeper())return{};var i=cleanKey(o.shift());!e[i]&&r&&(e[i]=new r),e=Object.prototype.hasOwnProperty.call(e,i)?e[i]:{}}return canNotTraverseDeeper()?{}:{obj:e,k:cleanKey(o.shift())}}function setPath(e,n,r){var o=getLastOfPath(e,n,Object);o.obj[o.k]=r}function getPath(e,n){var r=getLastOfPath(e,n),o=r.obj,i=r.k;if(o)return o[i]}function getPathWithDefaults(e,n,r){var o=getPath(e,r);return void 0!==o?o:getPath(n,r)}function deepExtend(e,n,r){for(var o in n)"__proto__"!==o&&"constructor"!==o&&(o in e?"string"==typeof e[o]||e[o]instanceof String||"string"==typeof n[o]||n[o]instanceof String?r&&(e[o]=n[o]):deepExtend(e[o],n[o],r):e[o]=n[o]);return e}function regexEscape(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var h={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function i18next_escape(e){return"string"==typeof e?e.replace(/[&<>"'\/]/g,(function(e){return h[e]})):e}var g="undefined"!=typeof window&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1,m=function(e){function ResourceStore(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};return _classCallCheck(this,ResourceStore),n=_possibleConstructorReturn(this,_getPrototypeOf(ResourceStore).call(this)),g&&f.call(_assertThisInitialized(n)),n.data=e||{},n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n}return _inherits(ResourceStore,e),_createClass(ResourceStore,[{key:"addNamespaces",value:function addNamespaces(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}},{key:"removeNamespaces",value:function removeNamespaces(e){var n=this.options.ns.indexOf(e);n>-1&&this.options.ns.splice(n,1)}},{key:"getResource",value:function getResource(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=void 0!==o.keySeparator?o.keySeparator:this.options.keySeparator,a=[e,n];return r&&"string"!=typeof r&&(a=a.concat(r)),r&&"string"==typeof r&&(a=a.concat(i?r.split(i):r)),e.indexOf(".")>-1&&(a=e.split(".")),getPath(this.data,a)}},{key:"addResource",value:function addResource(e,n,r,o){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},a=this.options.keySeparator;void 0===a&&(a=".");var s=[e,n];r&&(s=s.concat(a?r.split(a):r)),e.indexOf(".")>-1&&(o=n,n=(s=e.split("."))[1]),this.addNamespaces(n),setPath(this.data,s,o),i.silent||this.emit("added",e,n,r,o)}},{key:"addResources",value:function addResources(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(var i in r)"string"!=typeof r[i]&&"[object Array]"!==Object.prototype.toString.apply(r[i])||this.addResource(e,n,i,r[i],{silent:!0});o.silent||this.emit("added",e,n,r)}},{key:"addResourceBundle",value:function addResourceBundle(e,n,r,o,i){var a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1},s=[e,n];e.indexOf(".")>-1&&(o=r,r=n,n=(s=e.split("."))[1]),this.addNamespaces(n);var l=getPath(this.data,s)||{};o?deepExtend(l,r,i):l=_objectSpread({},l,r),setPath(this.data,s,l),a.silent||this.emit("added",e,n,r)}},{key:"removeResourceBundle",value:function removeResourceBundle(e,n){this.hasResourceBundle(e,n)&&delete this.data[e][n],this.removeNamespaces(n),this.emit("removed",e,n)}},{key:"hasResourceBundle",value:function hasResourceBundle(e,n){return void 0!==this.getResource(e,n)}},{key:"getResourceBundle",value:function getResourceBundle(e,n){return n||(n=this.options.defaultNS),"v1"===this.options.compatibilityAPI?_objectSpread({},{},this.getResource(e,n)):this.getResource(e,n)}},{key:"getDataByLanguage",value:function getDataByLanguage(e){return this.data[e]}},{key:"toJSON",value:function toJSON(){return this.data}}]),ResourceStore}(f),y={processors:{},addPostProcessor:function addPostProcessor(e){this.processors[e.name]=e},handle:function handle(e,n,r,o,i){var a=this;return e.forEach((function(e){a.processors[e]&&(n=a.processors[e].process(n,r,o,i))})),n}},v={},b=function(e){function Translator(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _classCallCheck(this,Translator),n=_possibleConstructorReturn(this,_getPrototypeOf(Translator).call(this)),g&&f.call(_assertThisInitialized(n)),copy(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,_assertThisInitialized(n)),n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n.logger=p.create("translator"),n}return _inherits(Translator,e),_createClass(Translator,[{key:"changeLanguage",value:function changeLanguage(e){e&&(this.language=e)}},{key:"exists",value:function exists(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}},r=this.resolve(e,n);return r&&void 0!==r.res}},{key:"extractFromKey",value:function extractFromKey(e,n){var r=void 0!==n.nsSeparator?n.nsSeparator:this.options.nsSeparator;void 0===r&&(r=":");var o=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,i=n.ns||this.options.defaultNS;if(r&&e.indexOf(r)>-1){var a=e.match(this.interpolator.nestingRegexp);if(a&&a.length>0)return{key:e,namespaces:i};var s=e.split(r);(r!==o||r===o&&this.options.ns.indexOf(s[0])>-1)&&(i=s.shift()),e=s.join(o)}return"string"==typeof i&&(i=[i]),{key:e,namespaces:i}}},{key:"translate",value:function translate(e,n,r){var o=this;if("object"!==_typeof(n)&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),n||(n={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);var i=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,a=this.extractFromKey(e[e.length-1],n),s=a.key,l=a.namespaces,u=l[l.length-1],c=n.lng||this.language,d=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(c&&"cimode"===c.toLowerCase()){if(d){var p=n.nsSeparator||this.options.nsSeparator;return u+p+s}return s}var f=this.resolve(e,n),h=f&&f.res,g=f&&f.usedKey||s,m=f&&f.exactUsedKey||s,y=Object.prototype.toString.apply(h),v=["[object Number]","[object Function]","[object RegExp]"],b=void 0!==n.joinArrays?n.joinArrays:this.options.joinArrays,x=!this.i18nFormat||this.i18nFormat.handleAsObject,w="string"!=typeof h&&"boolean"!=typeof h&&"number"!=typeof h;if(x&&h&&w&&v.indexOf(y)<0&&("string"!=typeof b||"[object Array]"!==y)){if(!n.returnObjects&&!this.options.returnObjects)return this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(g,h,n):"key '".concat(s," (").concat(this.language,")' returned an object instead of string.");if(i){var S="[object Array]"===y,T=S?[]:{},C=S?m:g;for(var k in h)if(Object.prototype.hasOwnProperty.call(h,k)){var N="".concat(C).concat(i).concat(k);T[k]=this.translate(N,_objectSpread({},n,{joinArrays:!1,ns:l})),T[k]===N&&(T[k]=h[k])}h=T}}else if(x&&"string"==typeof b&&"[object Array]"===y)(h=h.join(b))&&(h=this.extendTranslation(h,e,n,r));else{var E=!1,A=!1,L=void 0!==n.count&&"string"!=typeof n.count,O=Translator.hasDefaultValue(n),P=L?this.pluralResolver.getSuffix(c,n.count):"",j=n["defaultValue".concat(P)]||n.defaultValue;!this.isValidLookup(h)&&O&&(E=!0,h=j),this.isValidLookup(h)||(A=!0,h=s);var D=O&&j!==h&&this.options.updateMissing;if(A||E||D){if(this.logger.log(D?"updateKey":"missingKey",c,u,s,D?j:h),i){var M=this.resolve(s,_objectSpread({},n,{keySeparator:!1}));M&&M.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var R=[],I=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if("fallback"===this.options.saveMissingTo&&I&&I[0])for(var q=0;q<I.length;q++)R.push(I[q]);else"all"===this.options.saveMissingTo?R=this.languageUtils.toResolveHierarchy(n.lng||this.language):R.push(n.lng||this.language);var F=function send(e,r,i){o.options.missingKeyHandler?o.options.missingKeyHandler(e,u,r,D?i:h,D,n):o.backendConnector&&o.backendConnector.saveMissing&&o.backendConnector.saveMissing(e,u,r,D?i:h,D,n),o.emit("missingKey",e,u,r,h)};this.options.saveMissing&&(this.options.saveMissingPlurals&&L?R.forEach((function(e){o.pluralResolver.getSuffixes(e).forEach((function(r){F([e],s+r,n["defaultValue".concat(r)]||j)}))})):F(R,s,j))}h=this.extendTranslation(h,e,n,f,r),A&&h===s&&this.options.appendNamespaceToMissingKey&&(h="".concat(u,":").concat(s)),A&&this.options.parseMissingKeyHandler&&(h=this.options.parseMissingKeyHandler(h))}return h}},{key:"extendTranslation",value:function extendTranslation(e,n,r,o,i){var a=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,r,o.usedLng,o.usedNS,o.usedKey,{resolved:o});else if(!r.skipInterpolation){r.interpolation&&this.interpolator.init(_objectSpread({},r,{interpolation:_objectSpread({},this.options.interpolation,r.interpolation)}));var s,l=r.interpolation&&r.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;if(l){var u=e.match(this.interpolator.nestingRegexp);s=u&&u.length}var c=r.replace&&"string"!=typeof r.replace?r.replace:r;if(this.options.interpolation.defaultVariables&&(c=_objectSpread({},this.options.interpolation.defaultVariables,c)),e=this.interpolator.interpolate(e,c,r.lng||this.language,r),l){var d=e.match(this.interpolator.nestingRegexp);s<(d&&d.length)&&(r.nest=!1)}!1!==r.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,o=new Array(e),s=0;s<e;s++)o[s]=arguments[s];return i&&i[0]===o[0]&&!r.context?(a.logger.warn("It seems you are nesting recursively key: ".concat(o[0]," in key: ").concat(n[0])),null):a.translate.apply(a,o.concat([n]))}),r)),r.interpolation&&this.interpolator.reset()}var p=r.postProcess||this.options.postProcess,f="string"==typeof p?[p]:p;return null!=e&&f&&f.length&&!1!==r.applyPostProcessor&&(e=y.handle(f,e,n,this.options&&this.options.postProcessPassResolved?_objectSpread({i18nResolved:o},r):r,this)),e}},{key:"resolve",value:function resolve(e){var n,r,o,i,a,s=this,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof e&&(e=[e]),e.forEach((function(e){if(!s.isValidLookup(n)){var u=s.extractFromKey(e,l),c=u.key;r=c;var d=u.namespaces;s.options.fallbackNS&&(d=d.concat(s.options.fallbackNS));var p=void 0!==l.count&&"string"!=typeof l.count,f=void 0!==l.context&&"string"==typeof l.context&&""!==l.context,h=l.lngs?l.lngs:s.languageUtils.toResolveHierarchy(l.lng||s.language,l.fallbackLng);d.forEach((function(e){s.isValidLookup(n)||(a=e,!v["".concat(h[0],"-").concat(e)]&&s.utils&&s.utils.hasLoadedNamespace&&!s.utils.hasLoadedNamespace(a)&&(v["".concat(h[0],"-").concat(e)]=!0,s.logger.warn('key "'.concat(r,'" for languages "').concat(h.join(", "),'" won\'t get resolved as namespace "').concat(a,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),h.forEach((function(r){if(!s.isValidLookup(n)){i=r;var a,u,d=c,h=[d];if(s.i18nFormat&&s.i18nFormat.addLookupKeys)s.i18nFormat.addLookupKeys(h,c,r,e,l);else p&&(a=s.pluralResolver.getSuffix(r,l.count)),p&&f&&h.push(d+a),f&&h.push(d+="".concat(s.options.contextSeparator).concat(l.context)),p&&h.push(d+=a);for(;u=h.pop();)s.isValidLookup(n)||(o=u,n=s.getResource(r,e,u,l))}})))}))}})),{res:n,usedKey:r,exactUsedKey:o,usedLng:i,usedNS:a}}},{key:"isValidLookup",value:function isValidLookup(e){return!(void 0===e||!this.options.returnNull&&null===e||!this.options.returnEmptyString&&""===e)}},{key:"getResource",value:function getResource(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,n,r,o):this.resourceStore.getResource(e,n,r,o)}}],[{key:"hasDefaultValue",value:function hasDefaultValue(e){var n="defaultValue";for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)&&n===r.substring(0,n.length)&&void 0!==e[r])return!0;return!1}}]),Translator}(f);function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}var x=function(){function LanguageUtil(e){_classCallCheck(this,LanguageUtil),this.options=e,this.whitelist=this.options.supportedLngs||!1,this.supportedLngs=this.options.supportedLngs||!1,this.logger=p.create("languageUtils")}return _createClass(LanguageUtil,[{key:"getScriptPartFromCode",value:function getScriptPartFromCode(e){if(!e||e.indexOf("-")<0)return null;var n=e.split("-");return 2===n.length?null:(n.pop(),"x"===n[n.length-1].toLowerCase()?null:this.formatLanguageCode(n.join("-")))}},{key:"getLanguagePartFromCode",value:function getLanguagePartFromCode(e){if(!e||e.indexOf("-")<0)return e;var n=e.split("-");return this.formatLanguageCode(n[0])}},{key:"formatLanguageCode",value:function formatLanguageCode(e){if("string"==typeof e&&e.indexOf("-")>-1){var n=["hans","hant","latn","cyrl","cans","mong","arab"],r=e.split("-");return this.options.lowerCaseLng?r=r.map((function(e){return e.toLowerCase()})):2===r.length?(r[0]=r[0].toLowerCase(),r[1]=r[1].toUpperCase(),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=capitalize(r[1].toLowerCase()))):3===r.length&&(r[0]=r[0].toLowerCase(),2===r[1].length&&(r[1]=r[1].toUpperCase()),"sgn"!==r[0]&&2===r[2].length&&(r[2]=r[2].toUpperCase()),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=capitalize(r[1].toLowerCase())),n.indexOf(r[2].toLowerCase())>-1&&(r[2]=capitalize(r[2].toLowerCase()))),r.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}},{key:"isWhitelisted",value:function isWhitelisted(e){return this.logger.deprecate("languageUtils.isWhitelisted",'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.'),this.isSupportedCode(e)}},{key:"isSupportedCode",value:function isSupportedCode(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}},{key:"getBestMatchFromCodes",value:function getBestMatchFromCodes(e){var n,r=this;return e?(e.forEach((function(e){if(!n){var o=r.formatLanguageCode(e);r.options.supportedLngs&&!r.isSupportedCode(o)||(n=o)}})),!n&&this.options.supportedLngs&&e.forEach((function(e){if(!n){var o=r.getLanguagePartFromCode(e);if(r.isSupportedCode(o))return n=o;n=r.options.supportedLngs.find((function(e){if(0===e.indexOf(o))return e}))}})),n||(n=this.getFallbackCodes(this.options.fallbackLng)[0]),n):null}},{key:"getFallbackCodes",value:function getFallbackCodes(e,n){if(!e)return[];if("function"==typeof e&&(e=e(n)),"string"==typeof e&&(e=[e]),"[object Array]"===Object.prototype.toString.apply(e))return e;if(!n)return e.default||[];var r=e[n];return r||(r=e[this.getScriptPartFromCode(n)]),r||(r=e[this.formatLanguageCode(n)]),r||(r=e[this.getLanguagePartFromCode(n)]),r||(r=e.default),r||[]}},{key:"toResolveHierarchy",value:function toResolveHierarchy(e,n){var r=this,o=this.getFallbackCodes(n||this.options.fallbackLng||[],e),i=[],a=function addCode(e){e&&(r.isSupportedCode(e)?i.push(e):r.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return"string"==typeof e&&e.indexOf("-")>-1?("languageOnly"!==this.options.load&&a(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&a(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&a(this.getLanguagePartFromCode(e))):"string"==typeof e&&a(this.formatLanguageCode(e)),o.forEach((function(e){i.indexOf(e)<0&&a(r.formatLanguageCode(e))})),i}}]),LanguageUtil}(),w=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","kk","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],S={1:function _(e){return Number(e>1)},2:function _(e){return Number(1!=e)},3:function _(e){return 0},4:function _(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},5:function _(e){return Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5)},6:function _(e){return Number(1==e?0:e>=2&&e<=4?1:2)},7:function _(e){return Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},8:function _(e){return Number(1==e?0:2==e?1:8!=e&&11!=e?2:3)},9:function _(e){return Number(e>=2)},10:function _(e){return Number(1==e?0:2==e?1:e<7?2:e<11?3:4)},11:function _(e){return Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3)},12:function _(e){return Number(e%10!=1||e%100==11)},13:function _(e){return Number(0!==e)},14:function _(e){return Number(1==e?0:2==e?1:3==e?2:3)},15:function _(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2)},16:function _(e){return Number(e%10==1&&e%100!=11?0:0!==e?1:2)},17:function _(e){return Number(1==e||e%10==1&&e%100!=11?0:1)},18:function _(e){return Number(0==e?0:1==e?1:2)},19:function _(e){return Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3)},20:function _(e){return Number(1==e?0:0==e||e%100>0&&e%100<20?1:2)},21:function _(e){return Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0)},22:function _(e){return Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)}};function createRules(){var e={};return w.forEach((function(n){n.lngs.forEach((function(r){e[r]={numbers:n.nr,plurals:S[n.fc]}}))})),e}var T=function(){function PluralResolver(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,PluralResolver),this.languageUtils=e,this.options=n,this.logger=p.create("pluralResolver"),this.rules=createRules()}return _createClass(PluralResolver,[{key:"addRule",value:function addRule(e,n){this.rules[e]=n}},{key:"getRule",value:function getRule(e){return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}},{key:"needsPlural",value:function needsPlural(e){var n=this.getRule(e);return n&&n.numbers.length>1}},{key:"getPluralFormsOfKey",value:function getPluralFormsOfKey(e,n){return this.getSuffixes(e).map((function(e){return n+e}))}},{key:"getSuffixes",value:function getSuffixes(e){var n=this,r=this.getRule(e);return r?r.numbers.map((function(r){return n.getSuffix(e,r)})):[]}},{key:"getSuffix",value:function getSuffix(e,n){var r=this,o=this.getRule(e);if(o){var i=o.noAbs?o.plurals(n):o.plurals(Math.abs(n)),a=o.numbers[i];this.options.simplifyPluralSuffix&&2===o.numbers.length&&1===o.numbers[0]&&(2===a?a="plural":1===a&&(a=""));var s=function returnSuffix(){return r.options.prepend&&a.toString()?r.options.prepend+a.toString():a.toString()};return"v1"===this.options.compatibilityJSON?1===a?"":"number"==typeof a?"_plural_".concat(a.toString()):s():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===o.numbers.length&&1===o.numbers[0]?s():this.options.prepend&&i.toString()?this.options.prepend+i.toString():i.toString()}return this.logger.warn("no plural rule found for: ".concat(e)),""}}]),PluralResolver}(),C=function(){function Interpolator(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};_classCallCheck(this,Interpolator),this.logger=p.create("interpolator"),this.options=e,this.format=e.interpolation&&e.interpolation.format||function(e){return e},this.init(e)}return _createClass(Interpolator,[{key:"init",value:function init(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});var n=e.interpolation;this.escape=void 0!==n.escape?n.escape:i18next_escape,this.escapeValue=void 0===n.escapeValue||n.escapeValue,this.useRawValueToEscape=void 0!==n.useRawValueToEscape&&n.useRawValueToEscape,this.prefix=n.prefix?regexEscape(n.prefix):n.prefixEscaped||"{{",this.suffix=n.suffix?regexEscape(n.suffix):n.suffixEscaped||"}}",this.formatSeparator=n.formatSeparator?n.formatSeparator:n.formatSeparator||",",this.unescapePrefix=n.unescapeSuffix?"":n.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":n.unescapeSuffix||"",this.nestingPrefix=n.nestingPrefix?regexEscape(n.nestingPrefix):n.nestingPrefixEscaped||regexEscape("$t("),this.nestingSuffix=n.nestingSuffix?regexEscape(n.nestingSuffix):n.nestingSuffixEscaped||regexEscape(")"),this.nestingOptionsSeparator=n.nestingOptionsSeparator?n.nestingOptionsSeparator:n.nestingOptionsSeparator||",",this.maxReplaces=n.maxReplaces?n.maxReplaces:1e3,this.alwaysFormat=void 0!==n.alwaysFormat&&n.alwaysFormat,this.resetRegExp()}},{key:"reset",value:function reset(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function resetRegExp(){var e="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(e,"g");var n="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(n,"g");var r="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(r,"g")}},{key:"interpolate",value:function interpolate(e,n,r,o){var i,a,s,l=this,u=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function regexSafe(e){return e.replace(/\$/g,"$$$$")}var c=function handleFormat(e){if(e.indexOf(l.formatSeparator)<0){var i=getPathWithDefaults(n,u,e);return l.alwaysFormat?l.format(i,void 0,r):i}var a=e.split(l.formatSeparator),s=a.shift().trim(),c=a.join(l.formatSeparator).trim();return l.format(getPathWithDefaults(n,u,s),c,r,o)};this.resetRegExp();var d=o&&o.missingInterpolationHandler||this.options.missingInterpolationHandler,p=o&&o.interpolation&&o.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:function safeValue(e){return regexSafe(e)}},{regex:this.regexp,safeValue:function safeValue(e){return l.escapeValue?regexSafe(l.escape(e)):regexSafe(e)}}].forEach((function(n){for(s=0;i=n.regex.exec(e);){if(void 0===(a=c(i[1].trim())))if("function"==typeof d){var r=d(e,i,o);a="string"==typeof r?r:""}else{if(p){a=i[0];continue}l.logger.warn("missed to pass in variable ".concat(i[1]," for interpolating ").concat(e)),a=""}else"string"==typeof a||l.useRawValueToEscape||(a=makeString(a));if(e=e.replace(i[0],n.safeValue(a)),n.regex.lastIndex=0,++s>=l.maxReplaces)break}})),e}},{key:"nest",value:function nest(e,n){var r,o,i=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=_objectSpread({},a);function handleHasOptions(e,n){var r=this.nestingOptionsSeparator;if(e.indexOf(r)<0)return e;var o=e.split(new RegExp("".concat(r,"[ ]*{"))),i="{".concat(o[1]);e=o[0],i=(i=this.interpolate(i,s)).replace(/'/g,'"');try{s=JSON.parse(i),n&&(s=_objectSpread({},n,s))}catch(n){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),n),"".concat(e).concat(r).concat(i)}return delete s.defaultValue,e}for(s.applyPostProcessor=!1,delete s.defaultValue;r=this.nestingRegexp.exec(e);){var l=[],u=!1;if(r[0].includes(this.formatSeparator)&&!/{.*}/.test(r[1])){var c=r[1].split(this.formatSeparator).map((function(e){return e.trim()}));r[1]=c.shift(),l=c,u=!0}if((o=n(handleHasOptions.call(this,r[1].trim(),s),s))&&r[0]===e&&"string"!=typeof o)return o;"string"!=typeof o&&(o=makeString(o)),o||(this.logger.warn("missed to resolve ".concat(r[1]," for nesting ").concat(e)),o=""),u&&(o=l.reduce((function(e,n){return i.format(e,n,a.lng,a)}),o.trim())),e=e.replace(r[0],o),this.regexp.lastIndex=0}return e}}]),Interpolator}();var k=function(e){function Connector(e,n,r){var o,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return _classCallCheck(this,Connector),o=_possibleConstructorReturn(this,_getPrototypeOf(Connector).call(this)),g&&f.call(_assertThisInitialized(o)),o.backend=e,o.store=n,o.services=r,o.languageUtils=r.languageUtils,o.options=i,o.logger=p.create("backendConnector"),o.state={},o.queue=[],o.backend&&o.backend.init&&o.backend.init(r,i.backend,i),o}return _inherits(Connector,e),_createClass(Connector,[{key:"queueLoad",value:function queueLoad(e,n,r,o){var i=this,a=[],s=[],l=[],u=[];return e.forEach((function(e){var o=!0;n.forEach((function(n){var l="".concat(e,"|").concat(n);!r.reload&&i.store.hasResourceBundle(e,n)?i.state[l]=2:i.state[l]<0||(1===i.state[l]?s.indexOf(l)<0&&s.push(l):(i.state[l]=1,o=!1,s.indexOf(l)<0&&s.push(l),a.indexOf(l)<0&&a.push(l),u.indexOf(n)<0&&u.push(n)))})),o||l.push(e)})),(a.length||s.length)&&this.queue.push({pending:s,loaded:{},errors:[],callback:o}),{toLoad:a,pending:s,toLoadLanguages:l,toLoadNamespaces:u}}},{key:"loaded",value:function loaded(e,n,r){var o=e.split("|"),i=o[0],a=o[1];n&&this.emit("failedLoading",i,a,n),r&&this.store.addResourceBundle(i,a,r),this.state[e]=n?-1:2;var loaded={};this.queue.forEach((function(r){!function pushPath(e,n,r,o){var i=getLastOfPath(e,n,Object),a=i.obj,s=i.k;a[s]=a[s]||[],o&&(a[s]=a[s].concat(r)),o||a[s].push(r)}(r.loaded,[i],a),function remove(e,n){for(var r=e.indexOf(n);-1!==r;)e.splice(r,1),r=e.indexOf(n)}(r.pending,e),n&&r.errors.push(n),0!==r.pending.length||r.done||(Object.keys(r.loaded).forEach((function(e){loaded[e]||(loaded[e]=[]),r.loaded[e].length&&r.loaded[e].forEach((function(n){loaded[e].indexOf(n)<0&&loaded[e].push(n)}))})),r.done=!0,r.errors.length?r.callback(r.errors):r.callback())})),this.emit("loaded",loaded),this.queue=this.queue.filter((function(e){return!e.done}))}},{key:"read",value:function read(e,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:350,s=arguments.length>5?arguments[5]:void 0;return e.length?this.backend[r](e,n,(function(l,u){l&&u&&i<5?setTimeout((function(){o.read.call(o,e,n,r,i+1,2*a,s)}),a):s(l,u)})):s(null,{})}},{key:"prepareLoading",value:function prepareLoading(e,n){var r=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),i&&i();"string"==typeof e&&(e=this.languageUtils.toResolveHierarchy(e)),"string"==typeof n&&(n=[n]);var a=this.queueLoad(e,n,o,i);if(!a.toLoad.length)return a.pending.length||i(),null;a.toLoad.forEach((function(e){r.loadOne(e)}))}},{key:"load",value:function load(e,n,r){this.prepareLoading(e,n,{},r)}},{key:"reload",value:function reload(e,n,r){this.prepareLoading(e,n,{reload:!0},r)}},{key:"loadOne",value:function loadOne(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=e.split("|"),i=o[0],a=o[1];this.read(i,a,"read",void 0,void 0,(function(o,s){o&&n.logger.warn("".concat(r,"loading namespace ").concat(a," for language ").concat(i," failed"),o),!o&&s&&n.logger.log("".concat(r,"loaded namespace ").concat(a," for language ").concat(i),s),n.loaded(e,o,s)}))}},{key:"saveMissing",value:function saveMissing(e,n,r,o,i){var a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(n)?this.logger.warn('did not save key "'.concat(r,'" as the namespace "').concat(n,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"):null!=r&&""!==r&&(this.backend&&this.backend.create&&this.backend.create(e,n,r,o,null,_objectSpread({},a,{isUpdate:i})),e&&e[0]&&this.store.addResource(e[0],n,r,o))}}]),Connector}(f);function i18next_get(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function handle(e){var n={};if("object"===_typeof(e[1])&&(n=e[1]),"string"==typeof e[1]&&(n.defaultValue=e[1]),"string"==typeof e[2]&&(n.tDescription=e[2]),"object"===_typeof(e[2])||"object"===_typeof(e[3])){var r=e[3]||e[2];Object.keys(r).forEach((function(e){n[e]=r[e]}))}return n},interpolation:{escapeValue:!0,format:function format(e,n,r,o){return e},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!1}}}function transformOptions(e){return"string"==typeof e.ns&&(e.ns=[e.ns]),"string"==typeof e.fallbackLng&&(e.fallbackLng=[e.fallbackLng]),"string"==typeof e.fallbackNS&&(e.fallbackNS=[e.fallbackNS]),e.whitelist&&(e.whitelist&&e.whitelist.indexOf("cimode")<0&&(e.whitelist=e.whitelist.concat(["cimode"])),e.supportedLngs=e.whitelist),e.nonExplicitWhitelist&&(e.nonExplicitSupportedLngs=e.nonExplicitWhitelist),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e}function noop(){}const N=new(function(e){function I18n(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;if(_classCallCheck(this,I18n),e=_possibleConstructorReturn(this,_getPrototypeOf(I18n).call(this)),g&&f.call(_assertThisInitialized(e)),e.options=transformOptions(n),e.services={},e.logger=p,e.modules={external:[]},r&&!e.isInitialized&&!n.isClone){if(!e.options.initImmediate)return e.init(n,r),_possibleConstructorReturn(e,_assertThisInitialized(e));setTimeout((function(){e.init(n,r)}),0)}return e}return _inherits(I18n,e),_createClass(I18n,[{key:"init",value:function init(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;function createClassOnDemand(e){return e?"function"==typeof e?new e:e:null}if("function"==typeof n&&(r=n,n={}),n.whitelist&&!n.supportedLngs&&this.logger.deprecate("whitelist",'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),n.nonExplicitWhitelist&&!n.nonExplicitSupportedLngs&&this.logger.deprecate("whitelist",'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),this.options=_objectSpread({},i18next_get(),this.options,transformOptions(n)),this.format=this.options.interpolation.format,r||(r=noop),!this.options.isClone){this.modules.logger?p.init(createClassOnDemand(this.modules.logger),this.options):p.init(null,this.options);var o=new x(this.options);this.store=new m(this.options.resources,this.options);var i=this.services;i.logger=p,i.resourceStore=this.store,i.languageUtils=o,i.pluralResolver=new T(o,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),i.interpolator=new C(this.options),i.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},i.backendConnector=new k(createClassOnDemand(this.modules.backend),i.resourceStore,i,this.options),i.backendConnector.on("*",(function(n){for(var r=arguments.length,o=new Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];e.emit.apply(e,[n].concat(o))})),this.modules.languageDetector&&(i.languageDetector=createClassOnDemand(this.modules.languageDetector),i.languageDetector.init(i,this.options.detection,this.options)),this.modules.i18nFormat&&(i.i18nFormat=createClassOnDemand(this.modules.i18nFormat),i.i18nFormat.init&&i.i18nFormat.init(this)),this.translator=new b(this.services,this.options),this.translator.on("*",(function(n){for(var r=arguments.length,o=new Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];e.emit.apply(e,[n].concat(o))})),this.modules.external.forEach((function(n){n.init&&n.init(e)}))}if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var a=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);a.length>0&&"dev"!==a[0]&&(this.options.lng=a[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");var s=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];s.forEach((function(n){e[n]=function(){var r;return(r=e.store)[n].apply(r,arguments)}}));var l=["addResource","addResources","addResourceBundle","removeResourceBundle"];l.forEach((function(n){e[n]=function(){var r;return(r=e.store)[n].apply(r,arguments),e}}));var u=defer(),c=function load(){var n=function finish(n,o){e.isInitialized&&e.logger.warn("init: i18next is already initialized. You should call init just once!"),e.isInitialized=!0,e.options.isClone||e.logger.log("initialized",e.options),e.emit("initialized",e.options),u.resolve(o),r(n,o)};if(e.languages&&"v1"!==e.options.compatibilityAPI&&!e.isInitialized)return n(null,e.t.bind(e));e.changeLanguage(e.options.lng,n)};return this.options.resources||!this.options.initImmediate?c():setTimeout(c,0),u}},{key:"loadResources",value:function loadResources(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:noop,o=r,i="string"==typeof e?e:this.language;if("function"==typeof e&&(o=e),!this.options.resources||this.options.partialBundledLanguages){if(i&&"cimode"===i.toLowerCase())return o();var a=[],s=function append(e){e&&n.services.languageUtils.toResolveHierarchy(e).forEach((function(e){a.indexOf(e)<0&&a.push(e)}))};if(i)s(i);else{var l=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);l.forEach((function(e){return s(e)}))}this.options.preload&&this.options.preload.forEach((function(e){return s(e)})),this.services.backendConnector.load(a,this.options.ns,o)}else o(null)}},{key:"reloadResources",value:function reloadResources(e,n,r){var o=defer();return e||(e=this.languages),n||(n=this.options.ns),r||(r=noop),this.services.backendConnector.reload(e,n,(function(e){o.resolve(),r(e)})),o}},{key:"use",value:function use(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&y.addPostProcessor(e),"3rdParty"===e.type&&this.modules.external.push(e),this}},{key:"changeLanguage",value:function changeLanguage(e,n){var r=this;this.isLanguageChangingTo=e;var o=defer();this.emit("languageChanging",e);var i=function setLng(e){var i="string"==typeof e?e:r.services.languageUtils.getBestMatchFromCodes(e);i&&(r.language||(r.language=i,r.languages=r.services.languageUtils.toResolveHierarchy(i)),r.translator.language||r.translator.changeLanguage(i),r.services.languageDetector&&r.services.languageDetector.cacheUserLanguage(i)),r.loadResources(i,(function(e){!function done(e,i){i?(r.language=i,r.languages=r.services.languageUtils.toResolveHierarchy(i),r.translator.changeLanguage(i),r.isLanguageChangingTo=void 0,r.emit("languageChanged",i),r.logger.log("languageChanged",i)):r.isLanguageChangingTo=void 0,o.resolve((function(){return r.t.apply(r,arguments)})),n&&n(e,(function(){return r.t.apply(r,arguments)}))}(e,i)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(i):i(e):i(this.services.languageDetector.detect()),o}},{key:"getFixedT",value:function getFixedT(e,n){var r=this,o=function fixedT(e,n){var o;if("object"!==_typeof(n)){for(var i=arguments.length,a=new Array(i>2?i-2:0),s=2;s<i;s++)a[s-2]=arguments[s];o=r.options.overloadTranslationOptionHandler([e,n].concat(a))}else o=_objectSpread({},n);return o.lng=o.lng||fixedT.lng,o.lngs=o.lngs||fixedT.lngs,o.ns=o.ns||fixedT.ns,r.t(e,o)};return"string"==typeof e?o.lng=e:o.lngs=e,o.ns=n,o}},{key:"t",value:function t(){var e;return this.translator&&(e=this.translator).translate.apply(e,arguments)}},{key:"exists",value:function exists(){var e;return this.translator&&(e=this.translator).exists.apply(e,arguments)}},{key:"setDefaultNamespace",value:function setDefaultNamespace(e){this.options.defaultNS=e}},{key:"hasLoadedNamespace",value:function hasLoadedNamespace(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var o=this.languages[0],i=!!this.options&&this.options.fallbackLng,a=this.languages[this.languages.length-1];if("cimode"===o.toLowerCase())return!0;var s=function loadNotPending(e,r){var o=n.services.backendConnector.state["".concat(e,"|").concat(r)];return-1===o||2===o};if(r.precheck){var l=r.precheck(this,s);if(void 0!==l)return l}return!!this.hasResourceBundle(o,e)||(!this.services.backendConnector.backend||!(!s(o,e)||i&&!s(a,e)))}},{key:"loadNamespaces",value:function loadNamespaces(e,n){var r=this,o=defer();return this.options.ns?("string"==typeof e&&(e=[e]),e.forEach((function(e){r.options.ns.indexOf(e)<0&&r.options.ns.push(e)})),this.loadResources((function(e){o.resolve(),n&&n(e)})),o):(n&&n(),Promise.resolve())}},{key:"loadLanguages",value:function loadLanguages(e,n){var r=defer();"string"==typeof e&&(e=[e]);var o=this.options.preload||[],i=e.filter((function(e){return o.indexOf(e)<0}));return i.length?(this.options.preload=o.concat(i),this.loadResources((function(e){r.resolve(),n&&n(e)})),r):(n&&n(),Promise.resolve())}},{key:"dir",value:function dir(e){if(e||(e=this.languages&&this.languages.length>0?this.languages[0]:this.language),!e)return"rtl";return["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e))>=0?"rtl":"ltr"}},{key:"createInstance",value:function createInstance(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new I18n(e,n)}},{key:"cloneInstance",value:function cloneInstance(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:noop,o=_objectSpread({},this.options,n,{isClone:!0}),i=new I18n(o),a=["store","services","language"];return a.forEach((function(n){i[n]=e[n]})),i.services=_objectSpread({},this.services),i.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i.translator=new b(i.services,i.options),i.translator.on("*",(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];i.emit.apply(i,[e].concat(r))})),i.init(o,r),i.translator.options=i.options,i.translator.backendConnector.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i}}]),I18n}(f)),E="Neos.Neos",A="Main",L=[],getTransformedNamespace=(e,n)=>((0,o.isEmpty)(e)?E:e.replace(/\_/g,"."))+"/"+((0,o.isEmpty)(n)?A:n.replace(/\_/g,".")),checkInitialisedNamespaces=()=>{const e=L.findIndex((e=>!1===e.initialized))>=0;var n;return e||(n=!0,(0,o.createCollectionByPath)(window,"NeosCMS.I18n.initialized",Boolean(n)),window.dispatchEvent(new CustomEvent("neoscms-i18n-initialized",{bubbles:!0}))),!e},transformAndAppendXliffData=e=>{const n=N.languages[0];if((0,o.isNil)(e))return!1;const r=Object.keys(e);N.store.on("added",((e,n)=>{L.find((e=>e.name===n)).initialized=!0,checkInitialisedNamespaces()})),r.forEach((r=>{Object.keys(e[r]).forEach((i=>{const a=getTransformedNamespace(r,i),s=e[r][i];(0,o.isNil)(s)||N.addResourceBundle(n,a,(e=>(Object.keys(e).forEach((n=>{Array.isArray(e[n])&&e[n].forEach(((r,o)=>{let i=n;Number.isInteger(o)&&1===o&&(i=`${n}_plural`),e[i]=r}))})),e))(s),!0,!0)}))}))},translate=(e,n,r,i,a,s,l)=>{e=e.replace(/\./g,"_");var u,c;const d=(u=r,c=i,((0,o.isEmpty)(u)?E:u.trim())+"/"+((0,o.isEmpty)(c)?A:c.trim()))+":"+e.trim();let p={};return(0,o.isNil)(l)||(p.count=l),(0,o.isNil)(a)||(p.replace=a),(0,o.isEmpty)(n)||(p.defaultValue=n),N.t(d,p)},Localization_init=()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.I18n)&&(window.NeosCMS.I18n={init:Localization_init,translate,initialized:!1})},O={init:Localization_init,initTranslations:e=>{const n={interpolation:{prefix:"{",suffix:"}"},resources:{}},r=(()=>{const e=(0,o.getCollectionValueByPath)(window.NeosCMS,"Configuration.XliffUri");return(0,o.isNil)(e)?"":new URL(e).searchParams.get("locale")})();if(!(0,o.isEmpty)(r)){n[r.match("[a-z]{2}(-[A-Z]{2})")?"lng":"fallbackLng"]=r}(e=>{if((0,o.isNil)(e))return!1;Object.keys(e).forEach((n=>{Object.keys(e[n]).forEach((r=>{const i=getTransformedNamespace(n,r),a=e[n][r];(0,o.isNil)(a)||L.push({name:i,initialized:!1})}))}))})(e),N.init(n,((n,r)=>{transformAndAppendXliffData(e)}))},translate};r(449);class ApiService{constructor(e,n){if((0,o.isNil)(e)){let e="Tried to create API service without a base uri. ";e+="Please initialize the API service with a base path ",e+='like "/neos/impersonate/"',console.error(e)}if(this._basePath=e,(0,o.isNil)(n)){let e="Tried to create API service without a CSFR ";e+="token. Please initialize the API service with a token",console.error(e)}this._csrfToken=n}async callUserChange(e){const n={user:e,format:"json"},r=await fetch(this._basePath+"user-change",{method:"POST",credentials:"include",headers:this._getHeader(),body:JSON.stringify(n)});return await r.json()}async callStatus(){const e=await fetch(this._basePath+"status",{method:"GET",credentials:"include",headers:this._getHeader()});return await e.json()}async callRestore(){const e=await fetch(this._basePath+"restore",{method:"POST",credentials:"include",headers:this._getHeader()});return await e.json()}_getHeader(){return{Accept:"application/json","Content-Type":"application/json","X-Flow-Csrftoken":this._csrfToken}}}const P={init:()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Helper)&&(window.NeosCMS.Helper={isNil:o.isNil,isEmpty:o.isEmpty,getItemByKeyValue:o.getItemByKeyValue,getCollectionValueByPath:o.getCollectionValueByPath,createCollectionByPath:o.createCollectionByPath})}}},482:function(e){e.exports=function(){"use strict";function _toConsumableArray(e){if(Array.isArray(e)){for(var n=0,r=Array(e.length);n<e.length;n++)r[n]=e[n];return r}return Array.from(e)}var e=Object.hasOwnProperty,n=Object.setPrototypeOf,r=Object.isFrozen,o=Object.getPrototypeOf,i=Object.getOwnPropertyDescriptor,a=Object.freeze,s=Object.seal,l=Object.create,u="undefined"!=typeof Reflect&&Reflect,c=u.apply,d=u.construct;c||(c=function apply(e,n,r){return e.apply(n,r)}),a||(a=function freeze(e){return e}),s||(s=function seal(e){return e}),d||(d=function construct(e,n){return new(Function.prototype.bind.apply(e,[null].concat(_toConsumableArray(n))))});var p=unapply(Array.prototype.forEach),f=unapply(Array.prototype.pop),h=unapply(Array.prototype.push),g=unapply(String.prototype.toLowerCase),m=unapply(String.prototype.match),y=unapply(String.prototype.replace),v=unapply(String.prototype.indexOf),b=unapply(String.prototype.trim),x=unapply(RegExp.prototype.test),w=unconstruct(TypeError);function unapply(e){return function(n){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];return c(e,n,o)}}function unconstruct(e){return function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];return d(e,r)}}function addToSet(e,o){n&&n(e,null);for(var i=o.length;i--;){var a=o[i];if("string"==typeof a){var s=g(a);s!==a&&(r(o)||(o[i]=s),a=s)}e[a]=!0}return e}function clone(n){var r=l(null),o=void 0;for(o in n)c(e,n,[o])&&(r[o]=n[o]);return r}function lookupGetter(e,n){for(;null!==e;){var r=i(e,n);if(r){if(r.get)return unapply(r.get);if("function"==typeof r.value)return unapply(r.value)}e=o(e)}return null}var S=a(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),T=a(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),C=a(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),k=a(["animate","color-profile","cursor","discard","fedropshadow","feimage","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),N=a(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),E=a(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),A=a(["#text"]),L=a(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns"]),O=a(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),P=a(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),j=a(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),D=s(/\{\{[\s\S]*|[\s\S]*\}\}/gm),M=s(/<%[\s\S]*|[\s\S]*%>/gm),R=s(/^data-[\-\w.\u00B7-\uFFFF]/),I=s(/^aria-[\-\w]+$/),q=s(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),F=s(/^(?:\w+script|data):/i),H=s(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function _toConsumableArray$1(e){if(Array.isArray(e)){for(var n=0,r=Array(e.length);n<e.length;n++)r[n]=e[n];return r}return Array.from(e)}var B=function getGlobal(){return"undefined"==typeof window?null:window},U=function _createTrustedTypesPolicy(e,n){if("object"!==(void 0===e?"undefined":z(e))||"function"!=typeof e.createPolicy)return null;var r=null,o="data-tt-policy-suffix";n.currentScript&&n.currentScript.hasAttribute(o)&&(r=n.currentScript.getAttribute(o));var i="dompurify"+(r?"#"+r:"");try{return e.createPolicy(i,{createHTML:function createHTML(e){return e}})}catch(e){return console.warn("TrustedTypes policy "+i+" could not be created."),null}};function createDOMPurify(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:B(),n=function DOMPurify(e){return createDOMPurify(e)};if(n.version="2.2.6",n.removed=[],!e||!e.document||9!==e.document.nodeType)return n.isSupported=!1,n;var r=e.document,o=e.document,i=e.DocumentFragment,s=e.HTMLTemplateElement,l=e.Node,u=e.Element,c=e.NodeFilter,d=e.NamedNodeMap,W=void 0===d?e.NamedNodeMap||e.MozNamedAttrMap:d,$=e.Text,V=e.Comment,K=e.DOMParser,G=e.trustedTypes,X=u.prototype,J=lookupGetter(X,"cloneNode"),Y=lookupGetter(X,"nextSibling"),Z=lookupGetter(X,"childNodes"),Q=lookupGetter(X,"parentNode");if("function"==typeof s){var ee=o.createElement("template");ee.content&&ee.content.ownerDocument&&(o=ee.content.ownerDocument)}var te=U(G,r),ne=te&&De?te.createHTML(""):"",re=o,oe=re.implementation,ie=re.createNodeIterator,ae=re.getElementsByTagName,se=re.createDocumentFragment,le=r.importNode,ue={};try{ue=clone(o).documentMode?o.documentMode:{}}catch(e){}var ce={};n.isSupported=oe&&void 0!==oe.createHTMLDocument&&9!==ue;var de=D,pe=M,fe=R,he=I,ge=F,me=H,ye=q,ve=null,be=addToSet({},[].concat(_toConsumableArray$1(S),_toConsumableArray$1(T),_toConsumableArray$1(C),_toConsumableArray$1(N),_toConsumableArray$1(A))),xe=null,we=addToSet({},[].concat(_toConsumableArray$1(L),_toConsumableArray$1(O),_toConsumableArray$1(P),_toConsumableArray$1(j))),Se=null,Te=null,Ce=!0,ke=!0,Ne=!1,_e=!1,Ee=!1,Ae=!1,Le=!1,Oe=!1,Pe=!1,je=!0,De=!1,Me=!0,Re=!0,Ie=!1,qe={},Fe=addToSet({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),He=null,ze=addToSet({},["audio","video","img","source","image","track"]),Be=null,Ue=addToSet({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),We=null,$e=o.createElement("form"),Ve=function _parseConfig(e){We&&We===e||(e&&"object"===(void 0===e?"undefined":z(e))||(e={}),e=clone(e),ve="ALLOWED_TAGS"in e?addToSet({},e.ALLOWED_TAGS):be,xe="ALLOWED_ATTR"in e?addToSet({},e.ALLOWED_ATTR):we,Be="ADD_URI_SAFE_ATTR"in e?addToSet(clone(Ue),e.ADD_URI_SAFE_ATTR):Ue,He="ADD_DATA_URI_TAGS"in e?addToSet(clone(ze),e.ADD_DATA_URI_TAGS):ze,Se="FORBID_TAGS"in e?addToSet({},e.FORBID_TAGS):{},Te="FORBID_ATTR"in e?addToSet({},e.FORBID_ATTR):{},qe="USE_PROFILES"in e&&e.USE_PROFILES,Ce=!1!==e.ALLOW_ARIA_ATTR,ke=!1!==e.ALLOW_DATA_ATTR,Ne=e.ALLOW_UNKNOWN_PROTOCOLS||!1,_e=e.SAFE_FOR_TEMPLATES||!1,Ee=e.WHOLE_DOCUMENT||!1,Oe=e.RETURN_DOM||!1,Pe=e.RETURN_DOM_FRAGMENT||!1,je=!1!==e.RETURN_DOM_IMPORT,De=e.RETURN_TRUSTED_TYPE||!1,Le=e.FORCE_BODY||!1,Me=!1!==e.SANITIZE_DOM,Re=!1!==e.KEEP_CONTENT,Ie=e.IN_PLACE||!1,ye=e.ALLOWED_URI_REGEXP||ye,_e&&(ke=!1),Pe&&(Oe=!0),qe&&(ve=addToSet({},[].concat(_toConsumableArray$1(A))),xe=[],!0===qe.html&&(addToSet(ve,S),addToSet(xe,L)),!0===qe.svg&&(addToSet(ve,T),addToSet(xe,O),addToSet(xe,j)),!0===qe.svgFilters&&(addToSet(ve,C),addToSet(xe,O),addToSet(xe,j)),!0===qe.mathMl&&(addToSet(ve,N),addToSet(xe,P),addToSet(xe,j))),e.ADD_TAGS&&(ve===be&&(ve=clone(ve)),addToSet(ve,e.ADD_TAGS)),e.ADD_ATTR&&(xe===we&&(xe=clone(xe)),addToSet(xe,e.ADD_ATTR)),e.ADD_URI_SAFE_ATTR&&addToSet(Be,e.ADD_URI_SAFE_ATTR),Re&&(ve["#text"]=!0),Ee&&addToSet(ve,["html","head","body"]),ve.table&&(addToSet(ve,["tbody"]),delete Se.tbody),a&&a(e),We=e)},Ke=addToSet({},["mi","mo","mn","ms","mtext"]),Ge=addToSet({},["foreignobject","desc","title","annotation-xml"]),Xe=addToSet({},T);addToSet(Xe,C),addToSet(Xe,k);var Je=addToSet({},N);addToSet(Je,E);var Ye="http://www.w3.org/1998/Math/MathML",Ze="http://www.w3.org/2000/svg",Qe="http://www.w3.org/1999/xhtml",et=function _checkValidNamespace(e){var n=Q(e);n&&n.tagName||(n={namespaceURI:Qe,tagName:"template"});var r=g(e.tagName),o=g(n.tagName);if(e.namespaceURI===Ze)return n.namespaceURI===Qe?"svg"===r:n.namespaceURI===Ye?"svg"===r&&("annotation-xml"===o||Ke[o]):Boolean(Xe[r]);if(e.namespaceURI===Ye)return n.namespaceURI===Qe?"math"===r:n.namespaceURI===Ze?"math"===r&&Ge[o]:Boolean(Je[r]);if(e.namespaceURI===Qe){if(n.namespaceURI===Ze&&!Ge[o])return!1;if(n.namespaceURI===Ye&&!Ke[o])return!1;var i=addToSet({},["title","style","font","a","script"]);return!Je[r]&&(i[r]||!Xe[r])}return!1},tt=function _forceRemove(e){h(n.removed,{element:e});try{e.parentNode.removeChild(e)}catch(n){try{e.outerHTML=ne}catch(n){e.remove()}}},nt=function _removeAttribute(e,r){try{h(n.removed,{attribute:r.getAttributeNode(e),from:r})}catch(e){h(n.removed,{attribute:null,from:r})}r.removeAttribute(e)},rt=function _initDocument(e){var n=void 0,r=void 0;if(Le)e="<remove></remove>"+e;else{var i=m(e,/^[\r\n\t ]+/);r=i&&i[0]}var a=te?te.createHTML(e):e;try{n=(new K).parseFromString(a,"text/html")}catch(e){}if(!n||!n.documentElement){var s=(n=oe.createHTMLDocument("")).body;s.parentNode.removeChild(s.parentNode.firstElementChild),s.outerHTML=a}return e&&r&&n.body.insertBefore(o.createTextNode(r),n.body.childNodes[0]||null),ae.call(n,Ee?"html":"body")[0]},ot=function _createIterator(e){return ie.call(e.ownerDocument||e,e,c.SHOW_ELEMENT|c.SHOW_COMMENT|c.SHOW_TEXT,(function(){return c.FILTER_ACCEPT}),!1)},it=function _isClobbered(e){return!(e instanceof $||e instanceof V||"string"==typeof e.nodeName&&"string"==typeof e.textContent&&"function"==typeof e.removeChild&&e.attributes instanceof W&&"function"==typeof e.removeAttribute&&"function"==typeof e.setAttribute&&"string"==typeof e.namespaceURI&&"function"==typeof e.insertBefore)},at=function _isNode(e){return"object"===(void 0===l?"undefined":z(l))?e instanceof l:e&&"object"===(void 0===e?"undefined":z(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},st=function _executeHook(e,r,o){ce[e]&&p(ce[e],(function(e){e.call(n,r,o,We)}))},lt=function _sanitizeElements(e){var r=void 0;if(st("beforeSanitizeElements",e,null),it(e))return tt(e),!0;if(m(e.nodeName,/[\u0080-\uFFFF]/))return tt(e),!0;var o=g(e.nodeName);if(st("uponSanitizeElement",e,{tagName:o,allowedTags:ve}),!at(e.firstElementChild)&&(!at(e.content)||!at(e.content.firstElementChild))&&x(/<[/\w]/g,e.innerHTML)&&x(/<[/\w]/g,e.textContent))return tt(e),!0;if(!ve[o]||Se[o]){if(Re&&!Fe[o])for(var i=Q(e),a=Z(e),s=a.length-1;s>=0;--s)i.insertBefore(J(a[s],!0),Y(e));return tt(e),!0}return e instanceof u&&!et(e)?(tt(e),!0):"noscript"!==o&&"noembed"!==o||!x(/<\/no(script|embed)/i,e.innerHTML)?(_e&&3===e.nodeType&&(r=e.textContent,r=y(r,de," "),r=y(r,pe," "),e.textContent!==r&&(h(n.removed,{element:e.cloneNode()}),e.textContent=r)),st("afterSanitizeElements",e,null),!1):(tt(e),!0)},ut=function _isValidAttribute(e,n,r){if(Me&&("id"===n||"name"===n)&&(r in o||r in $e))return!1;if(ke&&x(fe,n));else if(Ce&&x(he,n));else{if(!xe[n]||Te[n])return!1;if(Be[n]);else if(x(ye,y(r,me,"")));else if("src"!==n&&"xlink:href"!==n&&"href"!==n||"script"===e||0!==v(r,"data:")||!He[e])if(Ne&&!x(ge,y(r,me,"")));else if(r)return!1}return!0},ct=function _sanitizeAttributes(e){var r=void 0,o=void 0,i=void 0,a=void 0;st("beforeSanitizeAttributes",e,null);var s=e.attributes;if(s){var l={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:xe};for(a=s.length;a--;){var u=r=s[a],c=u.name,d=u.namespaceURI;if(o=b(r.value),i=g(c),l.attrName=i,l.attrValue=o,l.keepAttr=!0,l.forceKeepAttr=void 0,st("uponSanitizeAttribute",e,l),o=l.attrValue,!l.forceKeepAttr&&(nt(c,e),l.keepAttr))if(x(/\/>/i,o))nt(c,e);else{_e&&(o=y(o,de," "),o=y(o,pe," "));var p=e.nodeName.toLowerCase();if(ut(p,i,o))try{d?e.setAttributeNS(d,c,o):e.setAttribute(c,o),f(n.removed)}catch(e){}}}st("afterSanitizeAttributes",e,null)}},dt=function _sanitizeShadowDOM(e){var n=void 0,r=ot(e);for(st("beforeSanitizeShadowDOM",e,null);n=r.nextNode();)st("uponSanitizeShadowNode",n,null),lt(n)||(n.content instanceof i&&_sanitizeShadowDOM(n.content),ct(n));st("afterSanitizeShadowDOM",e,null)};return n.sanitize=function(o,a){var s=void 0,u=void 0,c=void 0,d=void 0,p=void 0;if(o||(o="\x3c!--\x3e"),"string"!=typeof o&&!at(o)){if("function"!=typeof o.toString)throw w("toString is not a function");if("string"!=typeof(o=o.toString()))throw w("dirty is not a string, aborting")}if(!n.isSupported){if("object"===z(e.toStaticHTML)||"function"==typeof e.toStaticHTML){if("string"==typeof o)return e.toStaticHTML(o);if(at(o))return e.toStaticHTML(o.outerHTML)}return o}if(Ae||Ve(a),n.removed=[],"string"==typeof o&&(Ie=!1),Ie);else if(o instanceof l)1===(u=(s=rt("\x3c!----\x3e")).ownerDocument.importNode(o,!0)).nodeType&&"BODY"===u.nodeName||"HTML"===u.nodeName?s=u:s.appendChild(u);else{if(!Oe&&!_e&&!Ee&&-1===o.indexOf("<"))return te&&De?te.createHTML(o):o;if(!(s=rt(o)))return Oe?null:ne}s&&Le&&tt(s.firstChild);for(var f=ot(Ie?o:s);c=f.nextNode();)3===c.nodeType&&c===d||lt(c)||(c.content instanceof i&&dt(c.content),ct(c),d=c);if(d=null,Ie)return o;if(Oe){if(Pe)for(p=se.call(s.ownerDocument);s.firstChild;)p.appendChild(s.firstChild);else p=s;return je&&(p=le.call(r,p,!0)),p}var h=Ee?s.outerHTML:s.innerHTML;return _e&&(h=y(h,de," "),h=y(h,pe," ")),te&&De?te.createHTML(h):h},n.setConfig=function(e){Ve(e),Ae=!0},n.clearConfig=function(){We=null,Ae=!1},n.isValidAttribute=function(e,n,r){We||Ve({});var o=g(e),i=g(n);return ut(o,i,r)},n.addHook=function(e,n){"function"==typeof n&&(ce[e]=ce[e]||[],h(ce[e],n))},n.removeHook=function(e){ce[e]&&f(ce[e])},n.removeHooks=function(e){ce[e]&&(ce[e]=[])},n.removeAllHooks=function(){ce={}},n}return createDOMPurify()}()},755:function(e,n){var r;!function(n,r){"use strict";"object"==typeof e.exports?e.exports=n.document?r(n,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return r(e)}:r(n)}("undefined"!=typeof window?window:this,(function(o,i){"use strict";var a=[],s=Object.getPrototypeOf,l=a.slice,u=a.flat?function(e){return a.flat.call(e)}:function(e){return a.concat.apply([],e)},c=a.push,d=a.indexOf,p={},f=p.toString,h=p.hasOwnProperty,g=h.toString,m=g.call(Object),y={},v=function isFunction(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},b=function isWindow(e){return null!=e&&e===e.window},x=o.document,w={type:!0,src:!0,nonce:!0,noModule:!0};function DOMEval(e,n,r){var o,i,a=(r=r||x).createElement("script");if(a.text=e,n)for(o in w)(i=n[o]||n.getAttribute&&n.getAttribute(o))&&a.setAttribute(o,i);r.head.appendChild(a).parentNode.removeChild(a)}function toType(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?p[f.call(e)]||"object":typeof e}var S="3.6.0",jQuery=function(e,n){return new jQuery.fn.init(e,n)};function isArrayLike(e){var n=!!e&&"length"in e&&e.length,r=toType(e);return!v(e)&&!b(e)&&("array"===r||0===n||"number"==typeof n&&n>0&&n-1 in e)}jQuery.fn=jQuery.prototype={jquery:S,constructor:jQuery,length:0,toArray:function(){return l.call(this)},get:function(e){return null==e?l.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var n=jQuery.merge(this.constructor(),e);return n.prevObject=this,n},each:function(e){return jQuery.each(this,e)},map:function(e){return this.pushStack(jQuery.map(this,(function(n,r){return e.call(n,r,n)})))},slice:function(){return this.pushStack(l.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(jQuery.grep(this,(function(e,n){return(n+1)%2})))},odd:function(){return this.pushStack(jQuery.grep(this,(function(e,n){return n%2})))},eq:function(e){var n=this.length,r=+e+(e<0?n:0);return this.pushStack(r>=0&&r<n?[this[r]]:[])},end:function(){return this.prevObject||this.constructor()},push:c,sort:a.sort,splice:a.splice},jQuery.extend=jQuery.fn.extend=function(){var e,n,r,o,i,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[l]||{},l++),"object"==typeof s||v(s)||(s={}),l===u&&(s=this,l--);l<u;l++)if(null!=(e=arguments[l]))for(n in e)o=e[n],"__proto__"!==n&&s!==o&&(c&&o&&(jQuery.isPlainObject(o)||(i=Array.isArray(o)))?(r=s[n],a=i&&!Array.isArray(r)?[]:i||jQuery.isPlainObject(r)?r:{},i=!1,s[n]=jQuery.extend(c,a,o)):void 0!==o&&(s[n]=o));return s},jQuery.extend({expando:"jQuery"+(S+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var n,r;return!(!e||"[object Object]"!==f.call(e))&&(!(n=s(e))||"function"==typeof(r=h.call(n,"constructor")&&n.constructor)&&g.call(r)===m)},isEmptyObject:function(e){var n;for(n in e)return!1;return!0},globalEval:function(e,n,r){DOMEval(e,{nonce:n&&n.nonce},r)},each:function(e,n){var r,o=0;if(isArrayLike(e))for(r=e.length;o<r&&!1!==n.call(e[o],o,e[o]);o++);else for(o in e)if(!1===n.call(e[o],o,e[o]))break;return e},makeArray:function(e,n){var r=n||[];return null!=e&&(isArrayLike(Object(e))?jQuery.merge(r,"string"==typeof e?[e]:e):c.call(r,e)),r},inArray:function(e,n,r){return null==n?-1:d.call(n,e,r)},merge:function(e,n){for(var r=+n.length,o=0,i=e.length;o<r;o++)e[i++]=n[o];return e.length=i,e},grep:function(e,n,r){for(var o=[],i=0,a=e.length,s=!r;i<a;i++)!n(e[i],i)!==s&&o.push(e[i]);return o},map:function(e,n,r){var o,i,a=0,s=[];if(isArrayLike(e))for(o=e.length;a<o;a++)null!=(i=n(e[a],a,r))&&s.push(i);else for(a in e)null!=(i=n(e[a],a,r))&&s.push(i);return u(s)},guid:1,support:y}),"function"==typeof Symbol&&(jQuery.fn[Symbol.iterator]=a[Symbol.iterator]),jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),(function(e,n){p["[object "+n+"]"]=n.toLowerCase()}));var T=function(e){var n,r,o,i,a,s,l,u,c,d,p,f,h,g,m,y,v,b,x,w="sizzle"+1*new Date,S=e.document,T=0,C=0,k=createCache(),N=createCache(),E=createCache(),A=createCache(),sortOrder=function(e,n){return e===n&&(p=!0),0},L={}.hasOwnProperty,O=[],P=O.pop,j=O.push,D=O.push,M=O.slice,indexOf=function(e,n){for(var r=0,o=e.length;r<o;r++)if(e[r]===n)return r;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",I="[\\x20\\t\\r\\n\\f]",q="(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",F="\\[[\\x20\\t\\r\\n\\f]*("+q+")(?:"+I+"*([*^$|!~]?=)"+I+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+q+"))|)"+I+"*\\]",H=":("+q+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+F+")*)|.*)\\)|)",z=new RegExp(I+"+","g"),B=new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$","g"),U=new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),W=new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),$=new RegExp(I+"|>"),V=new RegExp(H),K=new RegExp("^"+q+"$"),G={ID:new RegExp("^#("+q+")"),CLASS:new RegExp("^\\.("+q+")"),TAG:new RegExp("^("+q+"|[*])"),ATTR:new RegExp("^"+F),PSEUDO:new RegExp("^"+H),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)","i")},X=/HTML$/i,J=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,Q=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])","g"),funescape=function(e,n){var r="0x"+e.slice(1)-65536;return n||(r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320))},ne=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,fcssescape=function(e,n){return n?"\0"===e?"":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},unloadHandler=function(){f()},re=addCombinator((function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()}),{dir:"parentNode",next:"legend"});try{D.apply(O=M.call(S.childNodes),S.childNodes),O[S.childNodes.length].nodeType}catch(e){D={apply:O.length?function(e,n){j.apply(e,M.call(n))}:function(e,n){for(var r=e.length,o=0;e[r++]=n[o++];);e.length=r-1}}}function Sizzle(e,n,o,i){var a,l,c,d,p,g,v,b=n&&n.ownerDocument,S=n?n.nodeType:9;if(o=o||[],"string"!=typeof e||!e||1!==S&&9!==S&&11!==S)return o;if(!i&&(f(n),n=n||h,m)){if(11!==S&&(p=Q.exec(e)))if(a=p[1]){if(9===S){if(!(c=n.getElementById(a)))return o;if(c.id===a)return o.push(c),o}else if(b&&(c=b.getElementById(a))&&x(n,c)&&c.id===a)return o.push(c),o}else{if(p[2])return D.apply(o,n.getElementsByTagName(e)),o;if((a=p[3])&&r.getElementsByClassName&&n.getElementsByClassName)return D.apply(o,n.getElementsByClassName(a)),o}if(r.qsa&&!A[e+" "]&&(!y||!y.test(e))&&(1!==S||"object"!==n.nodeName.toLowerCase())){if(v=e,b=n,1===S&&($.test(e)||W.test(e))){for((b=ee.test(e)&&testContext(n.parentNode)||n)===n&&r.scope||((d=n.getAttribute("id"))?d=d.replace(ne,fcssescape):n.setAttribute("id",d=w)),l=(g=s(e)).length;l--;)g[l]=(d?"#"+d:":scope")+" "+toSelector(g[l]);v=g.join(",")}try{return D.apply(o,b.querySelectorAll(v)),o}catch(n){A(e,!0)}finally{d===w&&n.removeAttribute("id")}}}return u(e.replace(B,"$1"),n,o,i)}function createCache(){var e=[];return function cache(n,r){return e.push(n+" ")>o.cacheLength&&delete cache[e.shift()],cache[n+" "]=r}}function markFunction(e){return e[w]=!0,e}function assert(e){var n=h.createElement("fieldset");try{return!!e(n)}catch(e){return!1}finally{n.parentNode&&n.parentNode.removeChild(n),n=null}}function addHandle(e,n){for(var r=e.split("|"),i=r.length;i--;)o.attrHandle[r[i]]=n}function siblingCheck(e,n){var r=n&&e,o=r&&1===e.nodeType&&1===n.nodeType&&e.sourceIndex-n.sourceIndex;if(o)return o;if(r)for(;r=r.nextSibling;)if(r===n)return-1;return e?1:-1}function createInputPseudo(e){return function(n){return"input"===n.nodeName.toLowerCase()&&n.type===e}}function createButtonPseudo(e){return function(n){var r=n.nodeName.toLowerCase();return("input"===r||"button"===r)&&n.type===e}}function createDisabledPseudo(e){return function(n){return"form"in n?n.parentNode&&!1===n.disabled?"label"in n?"label"in n.parentNode?n.parentNode.disabled===e:n.disabled===e:n.isDisabled===e||n.isDisabled!==!e&&re(n)===e:n.disabled===e:"label"in n&&n.disabled===e}}function createPositionalPseudo(e){return markFunction((function(n){return n=+n,markFunction((function(r,o){for(var i,a=e([],r.length,n),s=a.length;s--;)r[i=a[s]]&&(r[i]=!(o[i]=r[i]))}))}))}function testContext(e){return e&&void 0!==e.getElementsByTagName&&e}for(n in r=Sizzle.support={},a=Sizzle.isXML=function(e){var n=e&&e.namespaceURI,r=e&&(e.ownerDocument||e).documentElement;return!X.test(n||r&&r.nodeName||"HTML")},f=Sizzle.setDocument=function(e){var n,i,s=e?e.ownerDocument||e:S;return s!=h&&9===s.nodeType&&s.documentElement?(g=(h=s).documentElement,m=!a(h),S!=h&&(i=h.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",unloadHandler,!1):i.attachEvent&&i.attachEvent("onunload",unloadHandler)),r.scope=assert((function(e){return g.appendChild(e).appendChild(h.createElement("div")),void 0!==e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length})),r.attributes=assert((function(e){return e.className="i",!e.getAttribute("className")})),r.getElementsByTagName=assert((function(e){return e.appendChild(h.createComment("")),!e.getElementsByTagName("*").length})),r.getElementsByClassName=Z.test(h.getElementsByClassName),r.getById=assert((function(e){return g.appendChild(e).id=w,!h.getElementsByName||!h.getElementsByName(w).length})),r.getById?(o.filter.ID=function(e){var n=e.replace(te,funescape);return function(e){return e.getAttribute("id")===n}},o.find.ID=function(e,n){if(void 0!==n.getElementById&&m){var r=n.getElementById(e);return r?[r]:[]}}):(o.filter.ID=function(e){var n=e.replace(te,funescape);return function(e){var r=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return r&&r.value===n}},o.find.ID=function(e,n){if(void 0!==n.getElementById&&m){var r,o,i,a=n.getElementById(e);if(a){if((r=a.getAttributeNode("id"))&&r.value===e)return[a];for(i=n.getElementsByName(e),o=0;a=i[o++];)if((r=a.getAttributeNode("id"))&&r.value===e)return[a]}return[]}}),o.find.TAG=r.getElementsByTagName?function(e,n){return void 0!==n.getElementsByTagName?n.getElementsByTagName(e):r.qsa?n.querySelectorAll(e):void 0}:function(e,n){var r,o=[],i=0,a=n.getElementsByTagName(e);if("*"===e){for(;r=a[i++];)1===r.nodeType&&o.push(r);return o}return a},o.find.CLASS=r.getElementsByClassName&&function(e,n){if(void 0!==n.getElementsByClassName&&m)return n.getElementsByClassName(e)},v=[],y=[],(r.qsa=Z.test(h.querySelectorAll))&&(assert((function(e){var n;g.appendChild(e).innerHTML="<a id='"+w+"'></a><select id='"+w+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&y.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),e.querySelectorAll("[selected]").length||y.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|"+R+")"),e.querySelectorAll("[id~="+w+"-]").length||y.push("~="),(n=h.createElement("input")).setAttribute("name",""),e.appendChild(n),e.querySelectorAll("[name='']").length||y.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),e.querySelectorAll(":checked").length||y.push(":checked"),e.querySelectorAll("a#"+w+"+*").length||y.push(".#.+[+~]"),e.querySelectorAll("\\\f"),y.push("[\\r\\n\\f]")})),assert((function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var n=h.createElement("input");n.setAttribute("type","hidden"),e.appendChild(n).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&y.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&y.push(":enabled",":disabled"),g.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&y.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),y.push(",.*:")}))),(r.matchesSelector=Z.test(b=g.matches||g.webkitMatchesSelector||g.mozMatchesSelector||g.oMatchesSelector||g.msMatchesSelector))&&assert((function(e){r.disconnectedMatch=b.call(e,"*"),b.call(e,"[s!='']:x"),v.push("!=",H)})),y=y.length&&new RegExp(y.join("|")),v=v.length&&new RegExp(v.join("|")),n=Z.test(g.compareDocumentPosition),x=n||Z.test(g.contains)?function(e,n){var r=9===e.nodeType?e.documentElement:e,o=n&&n.parentNode;return e===o||!(!o||1!==o.nodeType||!(r.contains?r.contains(o):e.compareDocumentPosition&&16&e.compareDocumentPosition(o)))}:function(e,n){if(n)for(;n=n.parentNode;)if(n===e)return!0;return!1},sortOrder=n?function(e,n){if(e===n)return p=!0,0;var o=!e.compareDocumentPosition-!n.compareDocumentPosition;return o||(1&(o=(e.ownerDocument||e)==(n.ownerDocument||n)?e.compareDocumentPosition(n):1)||!r.sortDetached&&n.compareDocumentPosition(e)===o?e==h||e.ownerDocument==S&&x(S,e)?-1:n==h||n.ownerDocument==S&&x(S,n)?1:d?indexOf(d,e)-indexOf(d,n):0:4&o?-1:1)}:function(e,n){if(e===n)return p=!0,0;var r,o=0,i=e.parentNode,a=n.parentNode,s=[e],l=[n];if(!i||!a)return e==h?-1:n==h?1:i?-1:a?1:d?indexOf(d,e)-indexOf(d,n):0;if(i===a)return siblingCheck(e,n);for(r=e;r=r.parentNode;)s.unshift(r);for(r=n;r=r.parentNode;)l.unshift(r);for(;s[o]===l[o];)o++;return o?siblingCheck(s[o],l[o]):s[o]==S?-1:l[o]==S?1:0},h):h},Sizzle.matches=function(e,n){return Sizzle(e,null,null,n)},Sizzle.matchesSelector=function(e,n){if(f(e),r.matchesSelector&&m&&!A[n+" "]&&(!v||!v.test(n))&&(!y||!y.test(n)))try{var o=b.call(e,n);if(o||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return o}catch(e){A(n,!0)}return Sizzle(n,h,null,[e]).length>0},Sizzle.contains=function(e,n){return(e.ownerDocument||e)!=h&&f(e),x(e,n)},Sizzle.attr=function(e,n){(e.ownerDocument||e)!=h&&f(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!m):void 0;return void 0!==a?a:r.attributes||!m?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null},Sizzle.escape=function(e){return(e+"").replace(ne,fcssescape)},Sizzle.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},Sizzle.uniqueSort=function(e){var n,o=[],i=0,a=0;if(p=!r.detectDuplicates,d=!r.sortStable&&e.slice(0),e.sort(sortOrder),p){for(;n=e[a++];)n===e[a]&&(i=o.push(a));for(;i--;)e.splice(o[i],1)}return d=null,e},i=Sizzle.getText=function(e){var n,r="",o=0,a=e.nodeType;if(a){if(1===a||9===a||11===a){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)r+=i(e)}else if(3===a||4===a)return e.nodeValue}else for(;n=e[o++];)r+=i(n);return r},(o=Sizzle.selectors={cacheLength:50,createPseudo:markFunction,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,funescape),e[3]=(e[3]||e[4]||e[5]||"").replace(te,funescape),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||Sizzle.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&Sizzle.error(e[0]),e},PSEUDO:function(e){var n,r=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":r&&V.test(r)&&(n=s(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var n=e.replace(te,funescape).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===n}},CLASS:function(e){var n=k[e+" "];return n||(n=new RegExp("(^|[\\x20\\t\\r\\n\\f])"+e+"("+I+"|$)"))&&k(e,(function(e){return n.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")}))},ATTR:function(e,n,r){return function(o){var i=Sizzle.attr(o,e);return null==i?"!="===n:!n||(i+="","="===n?i===r:"!="===n?i!==r:"^="===n?r&&0===i.indexOf(r):"*="===n?r&&i.indexOf(r)>-1:"$="===n?r&&i.slice(-r.length)===r:"~="===n?(" "+i.replace(z," ")+" ").indexOf(r)>-1:"|="===n&&(i===r||i.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,n,r,o,i){var a="nth"!==e.slice(0,3),s="last"!==e.slice(-4),l="of-type"===n;return 1===o&&0===i?function(e){return!!e.parentNode}:function(n,r,u){var c,d,p,f,h,g,m=a!==s?"nextSibling":"previousSibling",y=n.parentNode,v=l&&n.nodeName.toLowerCase(),b=!u&&!l,x=!1;if(y){if(a){for(;m;){for(f=n;f=f[m];)if(l?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;g=m="only"===e&&!g&&"nextSibling"}return!0}if(g=[s?y.firstChild:y.lastChild],s&&b){for(x=(h=(c=(d=(p=(f=y)[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]||[])[0]===T&&c[1])&&c[2],f=h&&y.childNodes[h];f=++h&&f&&f[m]||(x=h=0)||g.pop();)if(1===f.nodeType&&++x&&f===n){d[e]=[T,h,x];break}}else if(b&&(x=h=(c=(d=(p=(f=n)[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]||[])[0]===T&&c[1]),!1===x)for(;(f=++h&&f&&f[m]||(x=h=0)||g.pop())&&((l?f.nodeName.toLowerCase()!==v:1!==f.nodeType)||!++x||(b&&((d=(p=f[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]=[T,x]),f!==n)););return(x-=i)===o||x%o==0&&x/o>=0}}},PSEUDO:function(e,n){var r,i=o.pseudos[e]||o.setFilters[e.toLowerCase()]||Sizzle.error("unsupported pseudo: "+e);return i[w]?i(n):i.length>1?(r=[e,e,"",n],o.setFilters.hasOwnProperty(e.toLowerCase())?markFunction((function(e,r){for(var o,a=i(e,n),s=a.length;s--;)e[o=indexOf(e,a[s])]=!(r[o]=a[s])})):function(e){return i(e,0,r)}):i}},pseudos:{not:markFunction((function(e){var n=[],r=[],o=l(e.replace(B,"$1"));return o[w]?markFunction((function(e,n,r,i){for(var a,s=o(e,null,i,[]),l=e.length;l--;)(a=s[l])&&(e[l]=!(n[l]=a))})):function(e,i,a){return n[0]=e,o(n,null,a,r),n[0]=null,!r.pop()}})),has:markFunction((function(e){return function(n){return Sizzle(e,n).length>0}})),contains:markFunction((function(e){return e=e.replace(te,funescape),function(n){return(n.textContent||i(n)).indexOf(e)>-1}})),lang:markFunction((function(e){return K.test(e||"")||Sizzle.error("unsupported lang: "+e),e=e.replace(te,funescape).toLowerCase(),function(n){var r;do{if(r=m?n.lang:n.getAttribute("xml:lang")||n.getAttribute("lang"))return(r=r.toLowerCase())===e||0===r.indexOf(e+"-")}while((n=n.parentNode)&&1===n.nodeType);return!1}})),target:function(n){var r=e.location&&e.location.hash;return r&&r.slice(1)===n.id},root:function(e){return e===g},focus:function(e){return e===h.activeElement&&(!h.hasFocus||h.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:createDisabledPseudo(!1),disabled:createDisabledPseudo(!0),checked:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&!!e.checked||"option"===n&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return J.test(e.nodeName)},button:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&"button"===e.type||"button"===n},text:function(e){var n;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(n=e.getAttribute("type"))||"text"===n.toLowerCase())},first:createPositionalPseudo((function(){return[0]})),last:createPositionalPseudo((function(e,n){return[n-1]})),eq:createPositionalPseudo((function(e,n,r){return[r<0?r+n:r]})),even:createPositionalPseudo((function(e,n){for(var r=0;r<n;r+=2)e.push(r);return e})),odd:createPositionalPseudo((function(e,n){for(var r=1;r<n;r+=2)e.push(r);return e})),lt:createPositionalPseudo((function(e,n,r){for(var o=r<0?r+n:r>n?n:r;--o>=0;)e.push(o);return e})),gt:createPositionalPseudo((function(e,n,r){for(var o=r<0?r+n:r;++o<n;)e.push(o);return e}))}}).pseudos.nth=o.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=createInputPseudo(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=createButtonPseudo(n);function setFilters(){}function toSelector(e){for(var n=0,r=e.length,o="";n<r;n++)o+=e[n].value;return o}function addCombinator(e,n,r){var o=n.dir,i=n.next,a=i||o,s=r&&"parentNode"===a,l=C++;return n.first?function(n,r,i){for(;n=n[o];)if(1===n.nodeType||s)return e(n,r,i);return!1}:function(n,r,u){var c,d,p,f=[T,l];if(u){for(;n=n[o];)if((1===n.nodeType||s)&&e(n,r,u))return!0}else for(;n=n[o];)if(1===n.nodeType||s)if(d=(p=n[w]||(n[w]={}))[n.uniqueID]||(p[n.uniqueID]={}),i&&i===n.nodeName.toLowerCase())n=n[o]||n;else{if((c=d[a])&&c[0]===T&&c[1]===l)return f[2]=c[2];if(d[a]=f,f[2]=e(n,r,u))return!0}return!1}}function elementMatcher(e){return e.length>1?function(n,r,o){for(var i=e.length;i--;)if(!e[i](n,r,o))return!1;return!0}:e[0]}function condense(e,n,r,o,i){for(var a,s=[],l=0,u=e.length,c=null!=n;l<u;l++)(a=e[l])&&(r&&!r(a,o,i)||(s.push(a),c&&n.push(l)));return s}function setMatcher(e,n,r,o,i,a){return o&&!o[w]&&(o=setMatcher(o)),i&&!i[w]&&(i=setMatcher(i,a)),markFunction((function(a,s,l,u){var c,d,p,f=[],h=[],g=s.length,m=a||function multipleContexts(e,n,r){for(var o=0,i=n.length;o<i;o++)Sizzle(e,n[o],r);return r}(n||"*",l.nodeType?[l]:l,[]),y=!e||!a&&n?m:condense(m,f,e,l,u),v=r?i||(a?e:g||o)?[]:s:y;if(r&&r(y,v,l,u),o)for(c=condense(v,h),o(c,[],l,u),d=c.length;d--;)(p=c[d])&&(v[h[d]]=!(y[h[d]]=p));if(a){if(i||e){if(i){for(c=[],d=v.length;d--;)(p=v[d])&&c.push(y[d]=p);i(null,v=[],c,u)}for(d=v.length;d--;)(p=v[d])&&(c=i?indexOf(a,p):f[d])>-1&&(a[c]=!(s[c]=p))}}else v=condense(v===s?v.splice(g,v.length):v),i?i(null,s,v,u):D.apply(s,v)}))}function matcherFromTokens(e){for(var n,r,i,a=e.length,s=o.relative[e[0].type],l=s||o.relative[" "],u=s?1:0,d=addCombinator((function(e){return e===n}),l,!0),p=addCombinator((function(e){return indexOf(n,e)>-1}),l,!0),f=[function(e,r,o){var i=!s&&(o||r!==c)||((n=r).nodeType?d(e,r,o):p(e,r,o));return n=null,i}];u<a;u++)if(r=o.relative[e[u].type])f=[addCombinator(elementMatcher(f),r)];else{if((r=o.filter[e[u].type].apply(null,e[u].matches))[w]){for(i=++u;i<a&&!o.relative[e[i].type];i++);return setMatcher(u>1&&elementMatcher(f),u>1&&toSelector(e.slice(0,u-1).concat({value:" "===e[u-2].type?"*":""})).replace(B,"$1"),r,u<i&&matcherFromTokens(e.slice(u,i)),i<a&&matcherFromTokens(e=e.slice(i)),i<a&&toSelector(e))}f.push(r)}return elementMatcher(f)}return setFilters.prototype=o.filters=o.pseudos,o.setFilters=new setFilters,s=Sizzle.tokenize=function(e,n){var r,i,a,s,l,u,c,d=N[e+" "];if(d)return n?0:d.slice(0);for(l=e,u=[],c=o.preFilter;l;){for(s in r&&!(i=U.exec(l))||(i&&(l=l.slice(i[0].length)||l),u.push(a=[])),r=!1,(i=W.exec(l))&&(r=i.shift(),a.push({value:r,type:i[0].replace(B," ")}),l=l.slice(r.length)),o.filter)!(i=G[s].exec(l))||c[s]&&!(i=c[s](i))||(r=i.shift(),a.push({value:r,type:s,matches:i}),l=l.slice(r.length));if(!r)break}return n?l.length:l?Sizzle.error(e):N(e,u).slice(0)},l=Sizzle.compile=function(e,n){var r,i=[],a=[],l=E[e+" "];if(!l){for(n||(n=s(e)),r=n.length;r--;)(l=matcherFromTokens(n[r]))[w]?i.push(l):a.push(l);(l=E(e,function matcherFromGroupMatchers(e,n){var r=n.length>0,i=e.length>0,superMatcher=function(a,s,l,u,d){var p,g,y,v=0,b="0",x=a&&[],w=[],S=c,C=a||i&&o.find.TAG("*",d),k=T+=null==S?1:Math.random()||.1,N=C.length;for(d&&(c=s==h||s||d);b!==N&&null!=(p=C[b]);b++){if(i&&p){for(g=0,s||p.ownerDocument==h||(f(p),l=!m);y=e[g++];)if(y(p,s||h,l)){u.push(p);break}d&&(T=k)}r&&((p=!y&&p)&&v--,a&&x.push(p))}if(v+=b,r&&b!==v){for(g=0;y=n[g++];)y(x,w,s,l);if(a){if(v>0)for(;b--;)x[b]||w[b]||(w[b]=P.call(u));w=condense(w)}D.apply(u,w),d&&!a&&w.length>0&&v+n.length>1&&Sizzle.uniqueSort(u)}return d&&(T=k,c=S),x};return r?markFunction(superMatcher):superMatcher}(a,i))).selector=e}return l},u=Sizzle.select=function(e,n,r,i){var a,u,c,d,p,f="function"==typeof e&&e,h=!i&&s(e=f.selector||e);if(r=r||[],1===h.length){if((u=h[0]=h[0].slice(0)).length>2&&"ID"===(c=u[0]).type&&9===n.nodeType&&m&&o.relative[u[1].type]){if(!(n=(o.find.ID(c.matches[0].replace(te,funescape),n)||[])[0]))return r;f&&(n=n.parentNode),e=e.slice(u.shift().value.length)}for(a=G.needsContext.test(e)?0:u.length;a--&&(c=u[a],!o.relative[d=c.type]);)if((p=o.find[d])&&(i=p(c.matches[0].replace(te,funescape),ee.test(u[0].type)&&testContext(n.parentNode)||n))){if(u.splice(a,1),!(e=i.length&&toSelector(u)))return D.apply(r,i),r;break}}return(f||l(e,h))(i,n,!m,r,!n||ee.test(e)&&testContext(n.parentNode)||n),r},r.sortStable=w.split("").sort(sortOrder).join("")===w,r.detectDuplicates=!!p,f(),r.sortDetached=assert((function(e){return 1&e.compareDocumentPosition(h.createElement("fieldset"))})),assert((function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")}))||addHandle("type|href|height|width",(function(e,n,r){if(!r)return e.getAttribute(n,"type"===n.toLowerCase()?1:2)})),r.attributes&&assert((function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")}))||addHandle("value",(function(e,n,r){if(!r&&"input"===e.nodeName.toLowerCase())return e.defaultValue})),assert((function(e){return null==e.getAttribute("disabled")}))||addHandle(R,(function(e,n,r){var o;if(!r)return!0===e[n]?n.toLowerCase():(o=e.getAttributeNode(n))&&o.specified?o.value:null})),Sizzle}(o);jQuery.find=T,jQuery.expr=T.selectors,jQuery.expr[":"]=jQuery.expr.pseudos,jQuery.uniqueSort=jQuery.unique=T.uniqueSort,jQuery.text=T.getText,jQuery.isXMLDoc=T.isXML,jQuery.contains=T.contains,jQuery.escapeSelector=T.escape;var dir=function(e,n,r){for(var o=[],i=void 0!==r;(e=e[n])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&jQuery(e).is(r))break;o.push(e)}return o},siblings=function(e,n){for(var r=[];e;e=e.nextSibling)1===e.nodeType&&e!==n&&r.push(e);return r},C=jQuery.expr.match.needsContext;function nodeName(e,n){return e.nodeName&&e.nodeName.toLowerCase()===n.toLowerCase()}var k=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function winnow(e,n,r){return v(n)?jQuery.grep(e,(function(e,o){return!!n.call(e,o,e)!==r})):n.nodeType?jQuery.grep(e,(function(e){return e===n!==r})):"string"!=typeof n?jQuery.grep(e,(function(e){return d.call(n,e)>-1!==r})):jQuery.filter(n,e,r)}jQuery.filter=function(e,n,r){var o=n[0];return r&&(e=":not("+e+")"),1===n.length&&1===o.nodeType?jQuery.find.matchesSelector(o,e)?[o]:[]:jQuery.find.matches(e,jQuery.grep(n,(function(e){return 1===e.nodeType})))},jQuery.fn.extend({find:function(e){var n,r,o=this.length,i=this;if("string"!=typeof e)return this.pushStack(jQuery(e).filter((function(){for(n=0;n<o;n++)if(jQuery.contains(i[n],this))return!0})));for(r=this.pushStack([]),n=0;n<o;n++)jQuery.find(e,i[n],r);return o>1?jQuery.uniqueSort(r):r},filter:function(e){return this.pushStack(winnow(this,e||[],!1))},not:function(e){return this.pushStack(winnow(this,e||[],!0))},is:function(e){return!!winnow(this,"string"==typeof e&&C.test(e)?jQuery(e):e||[],!1).length}});var N,E=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(jQuery.fn.init=function(e,n,r){var o,i;if(!e)return this;if(r=r||N,"string"==typeof e){if(!(o="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:E.exec(e))||!o[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(o[1]){if(n=n instanceof jQuery?n[0]:n,jQuery.merge(this,jQuery.parseHTML(o[1],n&&n.nodeType?n.ownerDocument||n:x,!0)),k.test(o[1])&&jQuery.isPlainObject(n))for(o in n)v(this[o])?this[o](n[o]):this.attr(o,n[o]);return this}return(i=x.getElementById(o[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==r.ready?r.ready(e):e(jQuery):jQuery.makeArray(e,this)}).prototype=jQuery.fn,N=jQuery(x);var A=/^(?:parents|prev(?:Until|All))/,L={children:!0,contents:!0,next:!0,prev:!0};function sibling(e,n){for(;(e=e[n])&&1!==e.nodeType;);return e}jQuery.fn.extend({has:function(e){var n=jQuery(e,this),r=n.length;return this.filter((function(){for(var e=0;e<r;e++)if(jQuery.contains(this,n[e]))return!0}))},closest:function(e,n){var r,o=0,i=this.length,a=[],s="string"!=typeof e&&jQuery(e);if(!C.test(e))for(;o<i;o++)for(r=this[o];r&&r!==n;r=r.parentNode)if(r.nodeType<11&&(s?s.index(r)>-1:1===r.nodeType&&jQuery.find.matchesSelector(r,e))){a.push(r);break}return this.pushStack(a.length>1?jQuery.uniqueSort(a):a)},index:function(e){return e?"string"==typeof e?d.call(jQuery(e),this[0]):d.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,n){return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(),jQuery(e,n))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),jQuery.each({parent:function(e){var n=e.parentNode;return n&&11!==n.nodeType?n:null},parents:function(e){return dir(e,"parentNode")},parentsUntil:function(e,n,r){return dir(e,"parentNode",r)},next:function(e){return sibling(e,"nextSibling")},prev:function(e){return sibling(e,"previousSibling")},nextAll:function(e){return dir(e,"nextSibling")},prevAll:function(e){return dir(e,"previousSibling")},nextUntil:function(e,n,r){return dir(e,"nextSibling",r)},prevUntil:function(e,n,r){return dir(e,"previousSibling",r)},siblings:function(e){return siblings((e.parentNode||{}).firstChild,e)},children:function(e){return siblings(e.firstChild)},contents:function(e){return null!=e.contentDocument&&s(e.contentDocument)?e.contentDocument:(nodeName(e,"template")&&(e=e.content||e),jQuery.merge([],e.childNodes))}},(function(e,n){jQuery.fn[e]=function(r,o){var i=jQuery.map(this,n,r);return"Until"!==e.slice(-5)&&(o=r),o&&"string"==typeof o&&(i=jQuery.filter(o,i)),this.length>1&&(L[e]||jQuery.uniqueSort(i),A.test(e)&&i.reverse()),this.pushStack(i)}}));var O=/[^\x20\t\r\n\f]+/g;function Identity(e){return e}function Thrower(e){throw e}function adoptValue(e,n,r,o){var i;try{e&&v(i=e.promise)?i.call(e).done(n).fail(r):e&&v(i=e.then)?i.call(e,n,r):n.apply(void 0,[e].slice(o))}catch(e){r.apply(void 0,[e])}}jQuery.Callbacks=function(e){e="string"==typeof e?function createOptions(e){var n={};return jQuery.each(e.match(O)||[],(function(e,r){n[r]=!0})),n}(e):jQuery.extend({},e);var n,r,o,i,a=[],s=[],l=-1,fire=function(){for(i=i||e.once,o=n=!0;s.length;l=-1)for(r=s.shift();++l<a.length;)!1===a[l].apply(r[0],r[1])&&e.stopOnFalse&&(l=a.length,r=!1);e.memory||(r=!1),n=!1,i&&(a=r?[]:"")},u={add:function(){return a&&(r&&!n&&(l=a.length-1,s.push(r)),function add(n){jQuery.each(n,(function(n,r){v(r)?e.unique&&u.has(r)||a.push(r):r&&r.length&&"string"!==toType(r)&&add(r)}))}(arguments),r&&!n&&fire()),this},remove:function(){return jQuery.each(arguments,(function(e,n){for(var r;(r=jQuery.inArray(n,a,r))>-1;)a.splice(r,1),r<=l&&l--})),this},has:function(e){return e?jQuery.inArray(e,a)>-1:a.length>0},empty:function(){return a&&(a=[]),this},disable:function(){return i=s=[],a=r="",this},disabled:function(){return!a},lock:function(){return i=s=[],r||n||(a=r=""),this},locked:function(){return!!i},fireWith:function(e,r){return i||(r=[e,(r=r||[]).slice?r.slice():r],s.push(r),n||fire()),this},fire:function(){return u.fireWith(this,arguments),this},fired:function(){return!!o}};return u},jQuery.extend({Deferred:function(e){var n=[["notify","progress",jQuery.Callbacks("memory"),jQuery.Callbacks("memory"),2],["resolve","done",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),0,"resolved"],["reject","fail",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return a.done(arguments).fail(arguments),this},catch:function(e){return i.then(null,e)},pipe:function(){var e=arguments;return jQuery.Deferred((function(r){jQuery.each(n,(function(n,o){var i=v(e[o[4]])&&e[o[4]];a[o[1]]((function(){var e=i&&i.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[o[0]+"With"](this,i?[e]:arguments)}))})),e=null})).promise()},then:function(e,r,i){var a=0;function resolve(e,n,r,i){return function(){var s=this,l=arguments,mightThrow=function(){var o,u;if(!(e<a)){if((o=r.apply(s,l))===n.promise())throw new TypeError("Thenable self-resolution");u=o&&("object"==typeof o||"function"==typeof o)&&o.then,v(u)?i?u.call(o,resolve(a,n,Identity,i),resolve(a,n,Thrower,i)):(a++,u.call(o,resolve(a,n,Identity,i),resolve(a,n,Thrower,i),resolve(a,n,Identity,n.notifyWith))):(r!==Identity&&(s=void 0,l=[o]),(i||n.resolveWith)(s,l))}},u=i?mightThrow:function(){try{mightThrow()}catch(o){jQuery.Deferred.exceptionHook&&jQuery.Deferred.exceptionHook(o,u.stackTrace),e+1>=a&&(r!==Thrower&&(s=void 0,l=[o]),n.rejectWith(s,l))}};e?u():(jQuery.Deferred.getStackHook&&(u.stackTrace=jQuery.Deferred.getStackHook()),o.setTimeout(u))}}return jQuery.Deferred((function(o){n[0][3].add(resolve(0,o,v(i)?i:Identity,o.notifyWith)),n[1][3].add(resolve(0,o,v(e)?e:Identity)),n[2][3].add(resolve(0,o,v(r)?r:Thrower))})).promise()},promise:function(e){return null!=e?jQuery.extend(e,i):i}},a={};return jQuery.each(n,(function(e,o){var s=o[2],l=o[5];i[o[1]]=s.add,l&&s.add((function(){r=l}),n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),s.add(o[3].fire),a[o[0]]=function(){return a[o[0]+"With"](this===a?void 0:this,arguments),this},a[o[0]+"With"]=s.fireWith})),i.promise(a),e&&e.call(a,a),a},when:function(e){var n=arguments.length,r=n,o=Array(r),i=l.call(arguments),a=jQuery.Deferred(),updateFunc=function(e){return function(r){o[e]=this,i[e]=arguments.length>1?l.call(arguments):r,--n||a.resolveWith(o,i)}};if(n<=1&&(adoptValue(e,a.done(updateFunc(r)).resolve,a.reject,!n),"pending"===a.state()||v(i[r]&&i[r].then)))return a.then();for(;r--;)adoptValue(i[r],updateFunc(r),a.reject);return a.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;jQuery.Deferred.exceptionHook=function(e,n){o.console&&o.console.warn&&e&&P.test(e.name)&&o.console.warn("jQuery.Deferred exception: "+e.message,e.stack,n)},jQuery.readyException=function(e){o.setTimeout((function(){throw e}))};var j=jQuery.Deferred();function completed(){x.removeEventListener("DOMContentLoaded",completed),o.removeEventListener("load",completed),jQuery.ready()}jQuery.fn.ready=function(e){return j.then(e).catch((function(e){jQuery.readyException(e)})),this},jQuery.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--jQuery.readyWait:jQuery.isReady)||(jQuery.isReady=!0,!0!==e&&--jQuery.readyWait>0||j.resolveWith(x,[jQuery]))}}),jQuery.ready.then=j.then,"complete"===x.readyState||"loading"!==x.readyState&&!x.documentElement.doScroll?o.setTimeout(jQuery.ready):(x.addEventListener("DOMContentLoaded",completed),o.addEventListener("load",completed));var access=function(e,n,r,o,i,a,s){var l=0,u=e.length,c=null==r;if("object"===toType(r))for(l in i=!0,r)access(e,n,l,r[l],!0,a,s);else if(void 0!==o&&(i=!0,v(o)||(s=!0),c&&(s?(n.call(e,o),n=null):(c=n,n=function(e,n,r){return c.call(jQuery(e),r)})),n))for(;l<u;l++)n(e[l],r,s?o:o.call(e[l],l,n(e[l],r)));return i?e:c?n.call(e):u?n(e[0],r):a},D=/^-ms-/,M=/-([a-z])/g;function fcamelCase(e,n){return n.toUpperCase()}function camelCase(e){return e.replace(D,"ms-").replace(M,fcamelCase)}var acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Data(){this.expando=jQuery.expando+Data.uid++}Data.uid=1,Data.prototype={cache:function(e){var n=e[this.expando];return n||(n={},acceptData(e)&&(e.nodeType?e[this.expando]=n:Object.defineProperty(e,this.expando,{value:n,configurable:!0}))),n},set:function(e,n,r){var o,i=this.cache(e);if("string"==typeof n)i[camelCase(n)]=r;else for(o in n)i[camelCase(o)]=n[o];return i},get:function(e,n){return void 0===n?this.cache(e):e[this.expando]&&e[this.expando][camelCase(n)]},access:function(e,n,r){return void 0===n||n&&"string"==typeof n&&void 0===r?this.get(e,n):(this.set(e,n,r),void 0!==r?r:n)},remove:function(e,n){var r,o=e[this.expando];if(void 0!==o){if(void 0!==n){r=(n=Array.isArray(n)?n.map(camelCase):(n=camelCase(n))in o?[n]:n.match(O)||[]).length;for(;r--;)delete o[n[r]]}(void 0===n||jQuery.isEmptyObject(o))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var n=e[this.expando];return void 0!==n&&!jQuery.isEmptyObject(n)}};var R=new Data,I=new Data,q=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,F=/[A-Z]/g;function dataAttr(e,n,r){var o;if(void 0===r&&1===e.nodeType)if(o="data-"+n.replace(F,"-$&").toLowerCase(),"string"==typeof(r=e.getAttribute(o))){try{r=function getData(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:q.test(e)?JSON.parse(e):e)}(r)}catch(e){}I.set(e,n,r)}else r=void 0;return r}jQuery.extend({hasData:function(e){return I.hasData(e)||R.hasData(e)},data:function(e,n,r){return I.access(e,n,r)},removeData:function(e,n){I.remove(e,n)},_data:function(e,n,r){return R.access(e,n,r)},_removeData:function(e,n){R.remove(e,n)}}),jQuery.fn.extend({data:function(e,n){var r,o,i,a=this[0],s=a&&a.attributes;if(void 0===e){if(this.length&&(i=I.get(a),1===a.nodeType&&!R.get(a,"hasDataAttrs"))){for(r=s.length;r--;)s[r]&&0===(o=s[r].name).indexOf("data-")&&(o=camelCase(o.slice(5)),dataAttr(a,o,i[o]));R.set(a,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each((function(){I.set(this,e)})):access(this,(function(n){var r;if(a&&void 0===n)return void 0!==(r=I.get(a,e))||void 0!==(r=dataAttr(a,e))?r:void 0;this.each((function(){I.set(this,e,n)}))}),null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each((function(){I.remove(this,e)}))}}),jQuery.extend({queue:function(e,n,r){var o;if(e)return n=(n||"fx")+"queue",o=R.get(e,n),r&&(!o||Array.isArray(r)?o=R.access(e,n,jQuery.makeArray(r)):o.push(r)),o||[]},dequeue:function(e,n){n=n||"fx";var r=jQuery.queue(e,n),o=r.length,i=r.shift(),a=jQuery._queueHooks(e,n);"inprogress"===i&&(i=r.shift(),o--),i&&("fx"===n&&r.unshift("inprogress"),delete a.stop,i.call(e,(function(){jQuery.dequeue(e,n)}),a)),!o&&a&&a.empty.fire()},_queueHooks:function(e,n){var r=n+"queueHooks";return R.get(e,r)||R.access(e,r,{empty:jQuery.Callbacks("once memory").add((function(){R.remove(e,[n+"queue",r])}))})}}),jQuery.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),arguments.length<r?jQuery.queue(this[0],e):void 0===n?this:this.each((function(){var r=jQuery.queue(this,e,n);jQuery._queueHooks(this,e),"fx"===e&&"inprogress"!==r[0]&&jQuery.dequeue(this,e)}))},dequeue:function(e){return this.each((function(){jQuery.dequeue(this,e)}))},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,o=1,i=jQuery.Deferred(),a=this,s=this.length,resolve=function(){--o||i.resolveWith(a,[a])};for("string"!=typeof e&&(n=e,e=void 0),e=e||"fx";s--;)(r=R.get(a[s],e+"queueHooks"))&&r.empty&&(o++,r.empty.add(resolve));return resolve(),i.promise(n)}});var H=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,z=new RegExp("^(?:([+-])=|)("+H+")([a-z%]*)$","i"),B=["Top","Right","Bottom","Left"],U=x.documentElement,isAttached=function(e){return jQuery.contains(e.ownerDocument,e)},W={composed:!0};U.getRootNode&&(isAttached=function(e){return jQuery.contains(e.ownerDocument,e)||e.getRootNode(W)===e.ownerDocument});var isHiddenWithinTree=function(e,n){return"none"===(e=n||e).style.display||""===e.style.display&&isAttached(e)&&"none"===jQuery.css(e,"display")};function adjustCSS(e,n,r,o){var i,a,s=20,l=o?function(){return o.cur()}:function(){return jQuery.css(e,n,"")},u=l(),c=r&&r[3]||(jQuery.cssNumber[n]?"":"px"),d=e.nodeType&&(jQuery.cssNumber[n]||"px"!==c&&+u)&&z.exec(jQuery.css(e,n));if(d&&d[3]!==c){for(u/=2,c=c||d[3],d=+u||1;s--;)jQuery.style(e,n,d+c),(1-a)*(1-(a=l()/u||.5))<=0&&(s=0),d/=a;d*=2,jQuery.style(e,n,d+c),r=r||[]}return r&&(d=+d||+u||0,i=r[1]?d+(r[1]+1)*r[2]:+r[2],o&&(o.unit=c,o.start=d,o.end=i)),i}var $={};function getDefaultDisplay(e){var n,r=e.ownerDocument,o=e.nodeName,i=$[o];return i||(n=r.body.appendChild(r.createElement(o)),i=jQuery.css(n,"display"),n.parentNode.removeChild(n),"none"===i&&(i="block"),$[o]=i,i)}function showHide(e,n){for(var r,o,i=[],a=0,s=e.length;a<s;a++)(o=e[a]).style&&(r=o.style.display,n?("none"===r&&(i[a]=R.get(o,"display")||null,i[a]||(o.style.display="")),""===o.style.display&&isHiddenWithinTree(o)&&(i[a]=getDefaultDisplay(o))):"none"!==r&&(i[a]="none",R.set(o,"display",r)));for(a=0;a<s;a++)null!=i[a]&&(e[a].style.display=i[a]);return e}jQuery.fn.extend({show:function(){return showHide(this,!0)},hide:function(){return showHide(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each((function(){isHiddenWithinTree(this)?jQuery(this).show():jQuery(this).hide()}))}});var V,K,G=/^(?:checkbox|radio)$/i,X=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,J=/^$|^module$|\/(?:java|ecma)script/i;V=x.createDocumentFragment().appendChild(x.createElement("div")),(K=x.createElement("input")).setAttribute("type","radio"),K.setAttribute("checked","checked"),K.setAttribute("name","t"),V.appendChild(K),y.checkClone=V.cloneNode(!0).cloneNode(!0).lastChild.checked,V.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!V.cloneNode(!0).lastChild.defaultValue,V.innerHTML="<option></option>",y.option=!!V.lastChild;var Y={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function getAll(e,n){var r;return r=void 0!==e.getElementsByTagName?e.getElementsByTagName(n||"*"):void 0!==e.querySelectorAll?e.querySelectorAll(n||"*"):[],void 0===n||n&&nodeName(e,n)?jQuery.merge([e],r):r}function setGlobalEval(e,n){for(var r=0,o=e.length;r<o;r++)R.set(e[r],"globalEval",!n||R.get(n[r],"globalEval"))}Y.tbody=Y.tfoot=Y.colgroup=Y.caption=Y.thead,Y.th=Y.td,y.option||(Y.optgroup=Y.option=[1,"<select multiple='multiple'>","</select>"]);var Z=/<|&#?\w+;/;function buildFragment(e,n,r,o,i){for(var a,s,l,u,c,d,p=n.createDocumentFragment(),f=[],h=0,g=e.length;h<g;h++)if((a=e[h])||0===a)if("object"===toType(a))jQuery.merge(f,a.nodeType?[a]:a);else if(Z.test(a)){for(s=s||p.appendChild(n.createElement("div")),l=(X.exec(a)||["",""])[1].toLowerCase(),u=Y[l]||Y._default,s.innerHTML=u[1]+jQuery.htmlPrefilter(a)+u[2],d=u[0];d--;)s=s.lastChild;jQuery.merge(f,s.childNodes),(s=p.firstChild).textContent=""}else f.push(n.createTextNode(a));for(p.textContent="",h=0;a=f[h++];)if(o&&jQuery.inArray(a,o)>-1)i&&i.push(a);else if(c=isAttached(a),s=getAll(p.appendChild(a),"script"),c&&setGlobalEval(s),r)for(d=0;a=s[d++];)J.test(a.type||"")&&r.push(a);return p}var Q=/^([^.]*)(?:\.(.+)|)/;function returnTrue(){return!0}function returnFalse(){return!1}function expectSync(e,n){return e===function safeActiveElement(){try{return x.activeElement}catch(e){}}()==("focus"===n)}function on(e,n,r,o,i,a){var s,l;if("object"==typeof n){for(l in"string"!=typeof r&&(o=o||r,r=void 0),n)on(e,l,r,o,n[l],a);return e}if(null==o&&null==i?(i=r,o=r=void 0):null==i&&("string"==typeof r?(i=o,o=void 0):(i=o,o=r,r=void 0)),!1===i)i=returnFalse;else if(!i)return e;return 1===a&&(s=i,(i=function(e){return jQuery().off(e),s.apply(this,arguments)}).guid=s.guid||(s.guid=jQuery.guid++)),e.each((function(){jQuery.event.add(this,n,i,o,r)}))}function leverageNative(e,n,r){r?(R.set(e,n,!1),jQuery.event.add(e,n,{namespace:!1,handler:function(e){var o,i,a=R.get(this,n);if(1&e.isTrigger&&this[n]){if(a.length)(jQuery.event.special[n]||{}).delegateType&&e.stopPropagation();else if(a=l.call(arguments),R.set(this,n,a),o=r(this,n),this[n](),a!==(i=R.get(this,n))||o?R.set(this,n,!1):i={},a!==i)return e.stopImmediatePropagation(),e.preventDefault(),i&&i.value}else a.length&&(R.set(this,n,{value:jQuery.event.trigger(jQuery.extend(a[0],jQuery.Event.prototype),a.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===R.get(e,n)&&jQuery.event.add(e,n,returnTrue)}jQuery.event={global:{},add:function(e,n,r,o,i){var a,s,l,u,c,d,p,f,h,g,m,y=R.get(e);if(acceptData(e))for(r.handler&&(r=(a=r).handler,i=a.selector),i&&jQuery.find.matchesSelector(U,i),r.guid||(r.guid=jQuery.guid++),(u=y.events)||(u=y.events=Object.create(null)),(s=y.handle)||(s=y.handle=function(n){return void 0!==jQuery&&jQuery.event.triggered!==n.type?jQuery.event.dispatch.apply(e,arguments):void 0}),c=(n=(n||"").match(O)||[""]).length;c--;)h=m=(l=Q.exec(n[c])||[])[1],g=(l[2]||"").split(".").sort(),h&&(p=jQuery.event.special[h]||{},h=(i?p.delegateType:p.bindType)||h,p=jQuery.event.special[h]||{},d=jQuery.extend({type:h,origType:m,data:o,handler:r,guid:r.guid,selector:i,needsContext:i&&jQuery.expr.match.needsContext.test(i),namespace:g.join(".")},a),(f=u[h])||((f=u[h]=[]).delegateCount=0,p.setup&&!1!==p.setup.call(e,o,g,s)||e.addEventListener&&e.addEventListener(h,s)),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),i?f.splice(f.delegateCount++,0,d):f.push(d),jQuery.event.global[h]=!0)},remove:function(e,n,r,o,i){var a,s,l,u,c,d,p,f,h,g,m,y=R.hasData(e)&&R.get(e);if(y&&(u=y.events)){for(c=(n=(n||"").match(O)||[""]).length;c--;)if(h=m=(l=Q.exec(n[c])||[])[1],g=(l[2]||"").split(".").sort(),h){for(p=jQuery.event.special[h]||{},f=u[h=(o?p.delegateType:p.bindType)||h]||[],l=l[2]&&new RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=a=f.length;a--;)d=f[a],!i&&m!==d.origType||r&&r.guid!==d.guid||l&&!l.test(d.namespace)||o&&o!==d.selector&&("**"!==o||!d.selector)||(f.splice(a,1),d.selector&&f.delegateCount--,p.remove&&p.remove.call(e,d));s&&!f.length&&(p.teardown&&!1!==p.teardown.call(e,g,y.handle)||jQuery.removeEvent(e,h,y.handle),delete u[h])}else for(h in u)jQuery.event.remove(e,h+n[c],r,o,!0);jQuery.isEmptyObject(u)&&R.remove(e,"handle events")}},dispatch:function(e){var n,r,o,i,a,s,l=new Array(arguments.length),u=jQuery.event.fix(e),c=(R.get(this,"events")||Object.create(null))[u.type]||[],d=jQuery.event.special[u.type]||{};for(l[0]=u,n=1;n<arguments.length;n++)l[n]=arguments[n];if(u.delegateTarget=this,!d.preDispatch||!1!==d.preDispatch.call(this,u)){for(s=jQuery.event.handlers.call(this,u,c),n=0;(i=s[n++])&&!u.isPropagationStopped();)for(u.currentTarget=i.elem,r=0;(a=i.handlers[r++])&&!u.isImmediatePropagationStopped();)u.rnamespace&&!1!==a.namespace&&!u.rnamespace.test(a.namespace)||(u.handleObj=a,u.data=a.data,void 0!==(o=((jQuery.event.special[a.origType]||{}).handle||a.handler).apply(i.elem,l))&&!1===(u.result=o)&&(u.preventDefault(),u.stopPropagation()));return d.postDispatch&&d.postDispatch.call(this,u),u.result}},handlers:function(e,n){var r,o,i,a,s,l=[],u=n.delegateCount,c=e.target;if(u&&c.nodeType&&!("click"===e.type&&e.button>=1))for(;c!==this;c=c.parentNode||this)if(1===c.nodeType&&("click"!==e.type||!0!==c.disabled)){for(a=[],s={},r=0;r<u;r++)void 0===s[i=(o=n[r]).selector+" "]&&(s[i]=o.needsContext?jQuery(i,this).index(c)>-1:jQuery.find(i,this,null,[c]).length),s[i]&&a.push(o);a.length&&l.push({elem:c,handlers:a})}return c=this,u<n.length&&l.push({elem:c,handlers:n.slice(u)}),l},addProp:function(e,n){Object.defineProperty(jQuery.Event.prototype,e,{enumerable:!0,configurable:!0,get:v(n)?function(){if(this.originalEvent)return n(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(n){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:n})}})},fix:function(e){return e[jQuery.expando]?e:new jQuery.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var n=this||e;return G.test(n.type)&&n.click&&nodeName(n,"input")&&leverageNative(n,"click",returnTrue),!1},trigger:function(e){var n=this||e;return G.test(n.type)&&n.click&&nodeName(n,"input")&&leverageNative(n,"click"),!0},_default:function(e){var n=e.target;return G.test(n.type)&&n.click&&nodeName(n,"input")&&R.get(n,"click")||nodeName(n,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},jQuery.removeEvent=function(e,n,r){e.removeEventListener&&e.removeEventListener(n,r)},jQuery.Event=function(e,n){if(!(this instanceof jQuery.Event))return new jQuery.Event(e,n);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?returnTrue:returnFalse,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,n&&jQuery.extend(this,n),this.timeStamp=e&&e.timeStamp||Date.now(),this[jQuery.expando]=!0},jQuery.Event.prototype={constructor:jQuery.Event,isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},jQuery.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},jQuery.event.addProp),jQuery.each({focus:"focusin",blur:"focusout"},(function(e,n){jQuery.event.special[e]={setup:function(){return leverageNative(this,e,expectSync),!1},trigger:function(){return leverageNative(this,e),!0},_default:function(){return!0},delegateType:n}})),jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},(function(e,n){jQuery.event.special[e]={delegateType:n,bindType:n,handle:function(e){var r,o=this,i=e.relatedTarget,a=e.handleObj;return i&&(i===o||jQuery.contains(o,i))||(e.type=a.origType,r=a.handler.apply(this,arguments),e.type=n),r}}})),jQuery.fn.extend({on:function(e,n,r,o){return on(this,e,n,r,o)},one:function(e,n,r,o){return on(this,e,n,r,o,1)},off:function(e,n,r){var o,i;if(e&&e.preventDefault&&e.handleObj)return o=e.handleObj,jQuery(e.delegateTarget).off(o.namespace?o.origType+"."+o.namespace:o.origType,o.selector,o.handler),this;if("object"==typeof e){for(i in e)this.off(i,n,e[i]);return this}return!1!==n&&"function"!=typeof n||(r=n,n=void 0),!1===r&&(r=returnFalse),this.each((function(){jQuery.event.remove(this,e,r,n)}))}});var ee=/<script|<style|<link/i,te=/checked\s*(?:[^=]|=\s*.checked.)/i,ne=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function manipulationTarget(e,n){return nodeName(e,"table")&&nodeName(11!==n.nodeType?n:n.firstChild,"tr")&&jQuery(e).children("tbody")[0]||e}function disableScript(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function restoreScript(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function cloneCopyEvent(e,n){var r,o,i,a,s,l;if(1===n.nodeType){if(R.hasData(e)&&(l=R.get(e).events))for(i in R.remove(n,"handle events"),l)for(r=0,o=l[i].length;r<o;r++)jQuery.event.add(n,i,l[i][r]);I.hasData(e)&&(a=I.access(e),s=jQuery.extend({},a),I.set(n,s))}}function fixInput(e,n){var r=n.nodeName.toLowerCase();"input"===r&&G.test(e.type)?n.checked=e.checked:"input"!==r&&"textarea"!==r||(n.defaultValue=e.defaultValue)}function domManip(e,n,r,o){n=u(n);var i,a,s,l,c,d,p=0,f=e.length,h=f-1,g=n[0],m=v(g);if(m||f>1&&"string"==typeof g&&!y.checkClone&&te.test(g))return e.each((function(i){var a=e.eq(i);m&&(n[0]=g.call(this,i,a.html())),domManip(a,n,r,o)}));if(f&&(a=(i=buildFragment(n,e[0].ownerDocument,!1,e,o)).firstChild,1===i.childNodes.length&&(i=a),a||o)){for(l=(s=jQuery.map(getAll(i,"script"),disableScript)).length;p<f;p++)c=i,p!==h&&(c=jQuery.clone(c,!0,!0),l&&jQuery.merge(s,getAll(c,"script"))),r.call(e[p],c,p);if(l)for(d=s[s.length-1].ownerDocument,jQuery.map(s,restoreScript),p=0;p<l;p++)c=s[p],J.test(c.type||"")&&!R.access(c,"globalEval")&&jQuery.contains(d,c)&&(c.src&&"module"!==(c.type||"").toLowerCase()?jQuery._evalUrl&&!c.noModule&&jQuery._evalUrl(c.src,{nonce:c.nonce||c.getAttribute("nonce")},d):DOMEval(c.textContent.replace(ne,""),c,d))}return e}function remove(e,n,r){for(var o,i=n?jQuery.filter(n,e):e,a=0;null!=(o=i[a]);a++)r||1!==o.nodeType||jQuery.cleanData(getAll(o)),o.parentNode&&(r&&isAttached(o)&&setGlobalEval(getAll(o,"script")),o.parentNode.removeChild(o));return e}jQuery.extend({htmlPrefilter:function(e){return e},clone:function(e,n,r){var o,i,a,s,l=e.cloneNode(!0),u=isAttached(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||jQuery.isXMLDoc(e)))for(s=getAll(l),o=0,i=(a=getAll(e)).length;o<i;o++)fixInput(a[o],s[o]);if(n)if(r)for(a=a||getAll(e),s=s||getAll(l),o=0,i=a.length;o<i;o++)cloneCopyEvent(a[o],s[o]);else cloneCopyEvent(e,l);return(s=getAll(l,"script")).length>0&&setGlobalEval(s,!u&&getAll(e,"script")),l},cleanData:function(e){for(var n,r,o,i=jQuery.event.special,a=0;void 0!==(r=e[a]);a++)if(acceptData(r)){if(n=r[R.expando]){if(n.events)for(o in n.events)i[o]?jQuery.event.remove(r,o):jQuery.removeEvent(r,o,n.handle);r[R.expando]=void 0}r[I.expando]&&(r[I.expando]=void 0)}}}),jQuery.fn.extend({detach:function(e){return remove(this,e,!0)},remove:function(e){return remove(this,e)},text:function(e){return access(this,(function(e){return void 0===e?jQuery.text(this):this.empty().each((function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)}))}),null,e,arguments.length)},append:function(){return domManip(this,arguments,(function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||manipulationTarget(this,e).appendChild(e)}))},prepend:function(){return domManip(this,arguments,(function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var n=manipulationTarget(this,e);n.insertBefore(e,n.firstChild)}}))},before:function(){return domManip(this,arguments,(function(e){this.parentNode&&this.parentNode.insertBefore(e,this)}))},after:function(){return domManip(this,arguments,(function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)}))},empty:function(){for(var e,n=0;null!=(e=this[n]);n++)1===e.nodeType&&(jQuery.cleanData(getAll(e,!1)),e.textContent="");return this},clone:function(e,n){return e=null!=e&&e,n=null==n?e:n,this.map((function(){return jQuery.clone(this,e,n)}))},html:function(e){return access(this,(function(e){var n=this[0]||{},r=0,o=this.length;if(void 0===e&&1===n.nodeType)return n.innerHTML;if("string"==typeof e&&!ee.test(e)&&!Y[(X.exec(e)||["",""])[1].toLowerCase()]){e=jQuery.htmlPrefilter(e);try{for(;r<o;r++)1===(n=this[r]||{}).nodeType&&(jQuery.cleanData(getAll(n,!1)),n.innerHTML=e);n=0}catch(e){}}n&&this.empty().append(e)}),null,e,arguments.length)},replaceWith:function(){var e=[];return domManip(this,arguments,(function(n){var r=this.parentNode;jQuery.inArray(this,e)<0&&(jQuery.cleanData(getAll(this)),r&&r.replaceChild(n,this))}),e)}}),jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},(function(e,n){jQuery.fn[e]=function(e){for(var r,o=[],i=jQuery(e),a=i.length-1,s=0;s<=a;s++)r=s===a?this:this.clone(!0),jQuery(i[s])[n](r),c.apply(o,r.get());return this.pushStack(o)}}));var re=new RegExp("^("+H+")(?!px)[a-z%]+$","i"),getStyles=function(e){var n=e.ownerDocument.defaultView;return n&&n.opener||(n=o),n.getComputedStyle(e)},swap=function(e,n,r){var o,i,a={};for(i in n)a[i]=e.style[i],e.style[i]=n[i];for(i in o=r.call(e),n)e.style[i]=a[i];return o},oe=new RegExp(B.join("|"),"i");function curCSS(e,n,r){var o,i,a,s,l=e.style;return(r=r||getStyles(e))&&(""!==(s=r.getPropertyValue(n)||r[n])||isAttached(e)||(s=jQuery.style(e,n)),!y.pixelBoxStyles()&&re.test(s)&&oe.test(n)&&(o=l.width,i=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=s,s=r.width,l.width=o,l.minWidth=i,l.maxWidth=a)),void 0!==s?s+"":s}function addGetHookIf(e,n){return{get:function(){if(!e())return(this.get=n).apply(this,arguments);delete this.get}}}!function(){function computeStyleTests(){if(u){l.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",U.appendChild(l).appendChild(u);var a=o.getComputedStyle(u);e="1%"!==a.top,s=12===roundPixelMeasures(a.marginLeft),u.style.right="60%",i=36===roundPixelMeasures(a.right),n=36===roundPixelMeasures(a.width),u.style.position="absolute",r=12===roundPixelMeasures(u.offsetWidth/3),U.removeChild(l),u=null}}function roundPixelMeasures(e){return Math.round(parseFloat(e))}var e,n,r,i,a,s,l=x.createElement("div"),u=x.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,jQuery.extend(y,{boxSizingReliable:function(){return computeStyleTests(),n},pixelBoxStyles:function(){return computeStyleTests(),i},pixelPosition:function(){return computeStyleTests(),e},reliableMarginLeft:function(){return computeStyleTests(),s},scrollboxSize:function(){return computeStyleTests(),r},reliableTrDimensions:function(){var e,n,r,i;return null==a&&(e=x.createElement("table"),n=x.createElement("tr"),r=x.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",n.style.cssText="border:1px solid",n.style.height="1px",r.style.height="9px",r.style.display="block",U.appendChild(e).appendChild(n).appendChild(r),i=o.getComputedStyle(n),a=parseInt(i.height,10)+parseInt(i.borderTopWidth,10)+parseInt(i.borderBottomWidth,10)===n.offsetHeight,U.removeChild(e)),a}}))}();var ie=["Webkit","Moz","ms"],ae=x.createElement("div").style,se={};function finalPropName(e){var n=jQuery.cssProps[e]||se[e];return n||(e in ae?e:se[e]=function vendorPropName(e){for(var n=e[0].toUpperCase()+e.slice(1),r=ie.length;r--;)if((e=ie[r]+n)in ae)return e}(e)||e)}var le=/^(none|table(?!-c[ea]).+)/,ue=/^--/,ce={position:"absolute",visibility:"hidden",display:"block"},de={letterSpacing:"0",fontWeight:"400"};function setPositiveNumber(e,n,r){var o=z.exec(n);return o?Math.max(0,o[2]-(r||0))+(o[3]||"px"):n}function boxModelAdjustment(e,n,r,o,i,a){var s="width"===n?1:0,l=0,u=0;if(r===(o?"border":"content"))return 0;for(;s<4;s+=2)"margin"===r&&(u+=jQuery.css(e,r+B[s],!0,i)),o?("content"===r&&(u-=jQuery.css(e,"padding"+B[s],!0,i)),"margin"!==r&&(u-=jQuery.css(e,"border"+B[s]+"Width",!0,i))):(u+=jQuery.css(e,"padding"+B[s],!0,i),"padding"!==r?u+=jQuery.css(e,"border"+B[s]+"Width",!0,i):l+=jQuery.css(e,"border"+B[s]+"Width",!0,i));return!o&&a>=0&&(u+=Math.max(0,Math.ceil(e["offset"+n[0].toUpperCase()+n.slice(1)]-a-u-l-.5))||0),u}function getWidthOrHeight(e,n,r){var o=getStyles(e),i=(!y.boxSizingReliable()||r)&&"border-box"===jQuery.css(e,"boxSizing",!1,o),a=i,s=curCSS(e,n,o),l="offset"+n[0].toUpperCase()+n.slice(1);if(re.test(s)){if(!r)return s;s="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&nodeName(e,"tr")||"auto"===s||!parseFloat(s)&&"inline"===jQuery.css(e,"display",!1,o))&&e.getClientRects().length&&(i="border-box"===jQuery.css(e,"boxSizing",!1,o),(a=l in e)&&(s=e[l])),(s=parseFloat(s)||0)+boxModelAdjustment(e,n,r||(i?"border":"content"),a,o,s)+"px"}function Tween(e,n,r,o,i){return new Tween.prototype.init(e,n,r,o,i)}jQuery.extend({cssHooks:{opacity:{get:function(e,n){if(n){var r=curCSS(e,"opacity");return""===r?"1":r}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,n,r,o){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,a,s,l=camelCase(n),u=ue.test(n),c=e.style;if(u||(n=finalPropName(l)),s=jQuery.cssHooks[n]||jQuery.cssHooks[l],void 0===r)return s&&"get"in s&&void 0!==(i=s.get(e,!1,o))?i:c[n];"string"===(a=typeof r)&&(i=z.exec(r))&&i[1]&&(r=adjustCSS(e,n,i),a="number"),null!=r&&r==r&&("number"!==a||u||(r+=i&&i[3]||(jQuery.cssNumber[l]?"":"px")),y.clearCloneStyle||""!==r||0!==n.indexOf("background")||(c[n]="inherit"),s&&"set"in s&&void 0===(r=s.set(e,r,o))||(u?c.setProperty(n,r):c[n]=r))}},css:function(e,n,r,o){var i,a,s,l=camelCase(n);return ue.test(n)||(n=finalPropName(l)),(s=jQuery.cssHooks[n]||jQuery.cssHooks[l])&&"get"in s&&(i=s.get(e,!0,r)),void 0===i&&(i=curCSS(e,n,o)),"normal"===i&&n in de&&(i=de[n]),""===r||r?(a=parseFloat(i),!0===r||isFinite(a)?a||0:i):i}}),jQuery.each(["height","width"],(function(e,n){jQuery.cssHooks[n]={get:function(e,r,o){if(r)return!le.test(jQuery.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?getWidthOrHeight(e,n,o):swap(e,ce,(function(){return getWidthOrHeight(e,n,o)}))},set:function(e,r,o){var i,a=getStyles(e),s=!y.scrollboxSize()&&"absolute"===a.position,l=(s||o)&&"border-box"===jQuery.css(e,"boxSizing",!1,a),u=o?boxModelAdjustment(e,n,o,l,a):0;return l&&s&&(u-=Math.ceil(e["offset"+n[0].toUpperCase()+n.slice(1)]-parseFloat(a[n])-boxModelAdjustment(e,n,"border",!1,a)-.5)),u&&(i=z.exec(r))&&"px"!==(i[3]||"px")&&(e.style[n]=r,r=jQuery.css(e,n)),setPositiveNumber(0,r,u)}}})),jQuery.cssHooks.marginLeft=addGetHookIf(y.reliableMarginLeft,(function(e,n){if(n)return(parseFloat(curCSS(e,"marginLeft"))||e.getBoundingClientRect().left-swap(e,{marginLeft:0},(function(){return e.getBoundingClientRect().left})))+"px"})),jQuery.each({margin:"",padding:"",border:"Width"},(function(e,n){jQuery.cssHooks[e+n]={expand:function(r){for(var o=0,i={},a="string"==typeof r?r.split(" "):[r];o<4;o++)i[e+B[o]+n]=a[o]||a[o-2]||a[0];return i}},"margin"!==e&&(jQuery.cssHooks[e+n].set=setPositiveNumber)})),jQuery.fn.extend({css:function(e,n){return access(this,(function(e,n,r){var o,i,a={},s=0;if(Array.isArray(n)){for(o=getStyles(e),i=n.length;s<i;s++)a[n[s]]=jQuery.css(e,n[s],!1,o);return a}return void 0!==r?jQuery.style(e,n,r):jQuery.css(e,n)}),e,n,arguments.length>1)}}),jQuery.Tween=Tween,Tween.prototype={constructor:Tween,init:function(e,n,r,o,i,a){this.elem=e,this.prop=r,this.easing=i||jQuery.easing._default,this.options=n,this.start=this.now=this.cur(),this.end=o,this.unit=a||(jQuery.cssNumber[r]?"":"px")},cur:function(){var e=Tween.propHooks[this.prop];return e&&e.get?e.get(this):Tween.propHooks._default.get(this)},run:function(e){var n,r=Tween.propHooks[this.prop];return this.options.duration?this.pos=n=jQuery.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=n=e,this.now=(this.end-this.start)*n+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),r&&r.set?r.set(this):Tween.propHooks._default.set(this),this}},Tween.prototype.init.prototype=Tween.prototype,Tween.propHooks={_default:{get:function(e){var n;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(n=jQuery.css(e.elem,e.prop,""))&&"auto"!==n?n:0},set:function(e){jQuery.fx.step[e.prop]?jQuery.fx.step[e.prop](e):1!==e.elem.nodeType||!jQuery.cssHooks[e.prop]&&null==e.elem.style[finalPropName(e.prop)]?e.elem[e.prop]=e.now:jQuery.style(e.elem,e.prop,e.now+e.unit)}}},Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},jQuery.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},jQuery.fx=Tween.prototype.init,jQuery.fx.step={};var pe,fe,he=/^(?:toggle|show|hide)$/,ge=/queueHooks$/;function schedule(){fe&&(!1===x.hidden&&o.requestAnimationFrame?o.requestAnimationFrame(schedule):o.setTimeout(schedule,jQuery.fx.interval),jQuery.fx.tick())}function createFxNow(){return o.setTimeout((function(){pe=void 0})),pe=Date.now()}function genFx(e,n){var r,o=0,i={height:e};for(n=n?1:0;o<4;o+=2-n)i["margin"+(r=B[o])]=i["padding"+r]=e;return n&&(i.opacity=i.width=e),i}function createTween(e,n,r){for(var o,i=(Animation.tweeners[n]||[]).concat(Animation.tweeners["*"]),a=0,s=i.length;a<s;a++)if(o=i[a].call(r,n,e))return o}function Animation(e,n,r){var o,i,a=0,s=Animation.prefilters.length,l=jQuery.Deferred().always((function(){delete tick.elem})),tick=function(){if(i)return!1;for(var n=pe||createFxNow(),r=Math.max(0,u.startTime+u.duration-n),o=1-(r/u.duration||0),a=0,s=u.tweens.length;a<s;a++)u.tweens[a].run(o);return l.notifyWith(e,[u,o,r]),o<1&&s?r:(s||l.notifyWith(e,[u,1,0]),l.resolveWith(e,[u]),!1)},u=l.promise({elem:e,props:jQuery.extend({},n),opts:jQuery.extend(!0,{specialEasing:{},easing:jQuery.easing._default},r),originalProperties:n,originalOptions:r,startTime:pe||createFxNow(),duration:r.duration,tweens:[],createTween:function(n,r){var o=jQuery.Tween(e,u.opts,n,r,u.opts.specialEasing[n]||u.opts.easing);return u.tweens.push(o),o},stop:function(n){var r=0,o=n?u.tweens.length:0;if(i)return this;for(i=!0;r<o;r++)u.tweens[r].run(1);return n?(l.notifyWith(e,[u,1,0]),l.resolveWith(e,[u,n])):l.rejectWith(e,[u,n]),this}}),c=u.props;for(!function propFilter(e,n){var r,o,i,a,s;for(r in e)if(i=n[o=camelCase(r)],a=e[r],Array.isArray(a)&&(i=a[1],a=e[r]=a[0]),r!==o&&(e[o]=a,delete e[r]),(s=jQuery.cssHooks[o])&&"expand"in s)for(r in a=s.expand(a),delete e[o],a)r in e||(e[r]=a[r],n[r]=i);else n[o]=i}(c,u.opts.specialEasing);a<s;a++)if(o=Animation.prefilters[a].call(u,e,c,u.opts))return v(o.stop)&&(jQuery._queueHooks(u.elem,u.opts.queue).stop=o.stop.bind(o)),o;return jQuery.map(c,createTween,u),v(u.opts.start)&&u.opts.start.call(e,u),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always),jQuery.fx.timer(jQuery.extend(tick,{elem:e,anim:u,queue:u.opts.queue})),u}jQuery.Animation=jQuery.extend(Animation,{tweeners:{"*":[function(e,n){var r=this.createTween(e,n);return adjustCSS(r.elem,e,z.exec(n),r),r}]},tweener:function(e,n){v(e)?(n=e,e=["*"]):e=e.match(O);for(var r,o=0,i=e.length;o<i;o++)r=e[o],Animation.tweeners[r]=Animation.tweeners[r]||[],Animation.tweeners[r].unshift(n)},prefilters:[function defaultPrefilter(e,n,r){var o,i,a,s,l,u,c,d,p="width"in n||"height"in n,f=this,h={},g=e.style,m=e.nodeType&&isHiddenWithinTree(e),y=R.get(e,"fxshow");for(o in r.queue||(null==(s=jQuery._queueHooks(e,"fx")).unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,f.always((function(){f.always((function(){s.unqueued--,jQuery.queue(e,"fx").length||s.empty.fire()}))}))),n)if(i=n[o],he.test(i)){if(delete n[o],a=a||"toggle"===i,i===(m?"hide":"show")){if("show"!==i||!y||void 0===y[o])continue;m=!0}h[o]=y&&y[o]||jQuery.style(e,o)}if((u=!jQuery.isEmptyObject(n))||!jQuery.isEmptyObject(h))for(o in p&&1===e.nodeType&&(r.overflow=[g.overflow,g.overflowX,g.overflowY],null==(c=y&&y.display)&&(c=R.get(e,"display")),"none"===(d=jQuery.css(e,"display"))&&(c?d=c:(showHide([e],!0),c=e.style.display||c,d=jQuery.css(e,"display"),showHide([e]))),("inline"===d||"inline-block"===d&&null!=c)&&"none"===jQuery.css(e,"float")&&(u||(f.done((function(){g.display=c})),null==c&&(d=g.display,c="none"===d?"":d)),g.display="inline-block")),r.overflow&&(g.overflow="hidden",f.always((function(){g.overflow=r.overflow[0],g.overflowX=r.overflow[1],g.overflowY=r.overflow[2]}))),u=!1,h)u||(y?"hidden"in y&&(m=y.hidden):y=R.access(e,"fxshow",{display:c}),a&&(y.hidden=!m),m&&showHide([e],!0),f.done((function(){for(o in m||showHide([e]),R.remove(e,"fxshow"),h)jQuery.style(e,o,h[o])}))),u=createTween(m?y[o]:0,o,f),o in y||(y[o]=u.start,m&&(u.end=u.start,u.start=0))}],prefilter:function(e,n){n?Animation.prefilters.unshift(e):Animation.prefilters.push(e)}}),jQuery.speed=function(e,n,r){var o=e&&"object"==typeof e?jQuery.extend({},e):{complete:r||!r&&n||v(e)&&e,duration:e,easing:r&&n||n&&!v(n)&&n};return jQuery.fx.off?o.duration=0:"number"!=typeof o.duration&&(o.duration in jQuery.fx.speeds?o.duration=jQuery.fx.speeds[o.duration]:o.duration=jQuery.fx.speeds._default),null!=o.queue&&!0!==o.queue||(o.queue="fx"),o.old=o.complete,o.complete=function(){v(o.old)&&o.old.call(this),o.queue&&jQuery.dequeue(this,o.queue)},o},jQuery.fn.extend({fadeTo:function(e,n,r,o){return this.filter(isHiddenWithinTree).css("opacity",0).show().end().animate({opacity:n},e,r,o)},animate:function(e,n,r,o){var i=jQuery.isEmptyObject(e),a=jQuery.speed(n,r,o),doAnimation=function(){var n=Animation(this,jQuery.extend({},e),a);(i||R.get(this,"finish"))&&n.stop(!0)};return doAnimation.finish=doAnimation,i||!1===a.queue?this.each(doAnimation):this.queue(a.queue,doAnimation)},stop:function(e,n,r){var stopQueue=function(e){var n=e.stop;delete e.stop,n(r)};return"string"!=typeof e&&(r=n,n=e,e=void 0),n&&this.queue(e||"fx",[]),this.each((function(){var n=!0,o=null!=e&&e+"queueHooks",i=jQuery.timers,a=R.get(this);if(o)a[o]&&a[o].stop&&stopQueue(a[o]);else for(o in a)a[o]&&a[o].stop&&ge.test(o)&&stopQueue(a[o]);for(o=i.length;o--;)i[o].elem!==this||null!=e&&i[o].queue!==e||(i[o].anim.stop(r),n=!1,i.splice(o,1));!n&&r||jQuery.dequeue(this,e)}))},finish:function(e){return!1!==e&&(e=e||"fx"),this.each((function(){var n,r=R.get(this),o=r[e+"queue"],i=r[e+"queueHooks"],a=jQuery.timers,s=o?o.length:0;for(r.finish=!0,jQuery.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),n=a.length;n--;)a[n].elem===this&&a[n].queue===e&&(a[n].anim.stop(!0),a.splice(n,1));for(n=0;n<s;n++)o[n]&&o[n].finish&&o[n].finish.call(this);delete r.finish}))}}),jQuery.each(["toggle","show","hide"],(function(e,n){var r=jQuery.fn[n];jQuery.fn[n]=function(e,o,i){return null==e||"boolean"==typeof e?r.apply(this,arguments):this.animate(genFx(n,!0),e,o,i)}})),jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},(function(e,n){jQuery.fn[e]=function(e,r,o){return this.animate(n,e,r,o)}})),jQuery.timers=[],jQuery.fx.tick=function(){var e,n=0,r=jQuery.timers;for(pe=Date.now();n<r.length;n++)(e=r[n])()||r[n]!==e||r.splice(n--,1);r.length||jQuery.fx.stop(),pe=void 0},jQuery.fx.timer=function(e){jQuery.timers.push(e),jQuery.fx.start()},jQuery.fx.interval=13,jQuery.fx.start=function(){fe||(fe=!0,schedule())},jQuery.fx.stop=function(){fe=null},jQuery.fx.speeds={slow:600,fast:200,_default:400},jQuery.fn.delay=function(e,n){return e=jQuery.fx&&jQuery.fx.speeds[e]||e,n=n||"fx",this.queue(n,(function(n,r){var i=o.setTimeout(n,e);r.stop=function(){o.clearTimeout(i)}}))},function(){var e=x.createElement("input"),n=x.createElement("select").appendChild(x.createElement("option"));e.type="checkbox",y.checkOn=""!==e.value,y.optSelected=n.selected,(e=x.createElement("input")).value="t",e.type="radio",y.radioValue="t"===e.value}();var me,ye=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(e,n){return access(this,jQuery.attr,e,n,arguments.length>1)},removeAttr:function(e){return this.each((function(){jQuery.removeAttr(this,e)}))}}),jQuery.extend({attr:function(e,n,r){var o,i,a=e.nodeType;if(3!==a&&8!==a&&2!==a)return void 0===e.getAttribute?jQuery.prop(e,n,r):(1===a&&jQuery.isXMLDoc(e)||(i=jQuery.attrHooks[n.toLowerCase()]||(jQuery.expr.match.bool.test(n)?me:void 0)),void 0!==r?null===r?void jQuery.removeAttr(e,n):i&&"set"in i&&void 0!==(o=i.set(e,r,n))?o:(e.setAttribute(n,r+""),r):i&&"get"in i&&null!==(o=i.get(e,n))?o:null==(o=jQuery.find.attr(e,n))?void 0:o)},attrHooks:{type:{set:function(e,n){if(!y.radioValue&&"radio"===n&&nodeName(e,"input")){var r=e.value;return e.setAttribute("type",n),r&&(e.value=r),n}}}},removeAttr:function(e,n){var r,o=0,i=n&&n.match(O);if(i&&1===e.nodeType)for(;r=i[o++];)e.removeAttribute(r)}}),me={set:function(e,n,r){return!1===n?jQuery.removeAttr(e,r):e.setAttribute(r,r),r}},jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),(function(e,n){var r=ye[n]||jQuery.find.attr;ye[n]=function(e,n,o){var i,a,s=n.toLowerCase();return o||(a=ye[s],ye[s]=i,i=null!=r(e,n,o)?s:null,ye[s]=a),i}}));var ve=/^(?:input|select|textarea|button)$/i,be=/^(?:a|area)$/i;function stripAndCollapse(e){return(e.match(O)||[]).join(" ")}function getClass(e){return e.getAttribute&&e.getAttribute("class")||""}function classesToArray(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(O)||[]}jQuery.fn.extend({prop:function(e,n){return access(this,jQuery.prop,e,n,arguments.length>1)},removeProp:function(e){return this.each((function(){delete this[jQuery.propFix[e]||e]}))}}),jQuery.extend({prop:function(e,n,r){var o,i,a=e.nodeType;if(3!==a&&8!==a&&2!==a)return 1===a&&jQuery.isXMLDoc(e)||(n=jQuery.propFix[n]||n,i=jQuery.propHooks[n]),void 0!==r?i&&"set"in i&&void 0!==(o=i.set(e,r,n))?o:e[n]=r:i&&"get"in i&&null!==(o=i.get(e,n))?o:e[n]},propHooks:{tabIndex:{get:function(e){var n=jQuery.find.attr(e,"tabindex");return n?parseInt(n,10):ve.test(e.nodeName)||be.test(e.nodeName)&&e.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),y.optSelected||(jQuery.propHooks.selected={get:function(e){var n=e.parentNode;return n&&n.parentNode&&n.parentNode.selectedIndex,null},set:function(e){var n=e.parentNode;n&&(n.selectedIndex,n.parentNode&&n.parentNode.selectedIndex)}}),jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],(function(){jQuery.propFix[this.toLowerCase()]=this})),jQuery.fn.extend({addClass:function(e){var n,r,o,i,a,s,l,u=0;if(v(e))return this.each((function(n){jQuery(this).addClass(e.call(this,n,getClass(this)))}));if((n=classesToArray(e)).length)for(;r=this[u++];)if(i=getClass(r),o=1===r.nodeType&&" "+stripAndCollapse(i)+" "){for(s=0;a=n[s++];)o.indexOf(" "+a+" ")<0&&(o+=a+" ");i!==(l=stripAndCollapse(o))&&r.setAttribute("class",l)}return this},removeClass:function(e){var n,r,o,i,a,s,l,u=0;if(v(e))return this.each((function(n){jQuery(this).removeClass(e.call(this,n,getClass(this)))}));if(!arguments.length)return this.attr("class","");if((n=classesToArray(e)).length)for(;r=this[u++];)if(i=getClass(r),o=1===r.nodeType&&" "+stripAndCollapse(i)+" "){for(s=0;a=n[s++];)for(;o.indexOf(" "+a+" ")>-1;)o=o.replace(" "+a+" "," ");i!==(l=stripAndCollapse(o))&&r.setAttribute("class",l)}return this},toggleClass:function(e,n){var r=typeof e,o="string"===r||Array.isArray(e);return"boolean"==typeof n&&o?n?this.addClass(e):this.removeClass(e):v(e)?this.each((function(r){jQuery(this).toggleClass(e.call(this,r,getClass(this),n),n)})):this.each((function(){var n,i,a,s;if(o)for(i=0,a=jQuery(this),s=classesToArray(e);n=s[i++];)a.hasClass(n)?a.removeClass(n):a.addClass(n);else void 0!==e&&"boolean"!==r||((n=getClass(this))&&R.set(this,"__className__",n),this.setAttribute&&this.setAttribute("class",n||!1===e?"":R.get(this,"__className__")||""))}))},hasClass:function(e){var n,r,o=0;for(n=" "+e+" ";r=this[o++];)if(1===r.nodeType&&(" "+stripAndCollapse(getClass(r))+" ").indexOf(n)>-1)return!0;return!1}});var xe=/\r/g;jQuery.fn.extend({val:function(e){var n,r,o,i=this[0];return arguments.length?(o=v(e),this.each((function(r){var i;1===this.nodeType&&(null==(i=o?e.call(this,r,jQuery(this).val()):e)?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=jQuery.map(i,(function(e){return null==e?"":e+""}))),(n=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()])&&"set"in n&&void 0!==n.set(this,i,"value")||(this.value=i))}))):i?(n=jQuery.valHooks[i.type]||jQuery.valHooks[i.nodeName.toLowerCase()])&&"get"in n&&void 0!==(r=n.get(i,"value"))?r:"string"==typeof(r=i.value)?r.replace(xe,""):null==r?"":r:void 0}}),jQuery.extend({valHooks:{option:{get:function(e){var n=jQuery.find.attr(e,"value");return null!=n?n:stripAndCollapse(jQuery.text(e))}},select:{get:function(e){var n,r,o,i=e.options,a=e.selectedIndex,s="select-one"===e.type,l=s?null:[],u=s?a+1:i.length;for(o=a<0?u:s?a:0;o<u;o++)if(((r=i[o]).selected||o===a)&&!r.disabled&&(!r.parentNode.disabled||!nodeName(r.parentNode,"optgroup"))){if(n=jQuery(r).val(),s)return n;l.push(n)}return l},set:function(e,n){for(var r,o,i=e.options,a=jQuery.makeArray(n),s=i.length;s--;)((o=i[s]).selected=jQuery.inArray(jQuery.valHooks.option.get(o),a)>-1)&&(r=!0);return r||(e.selectedIndex=-1),a}}}}),jQuery.each(["radio","checkbox"],(function(){jQuery.valHooks[this]={set:function(e,n){if(Array.isArray(n))return e.checked=jQuery.inArray(jQuery(e).val(),n)>-1}},y.checkOn||(jQuery.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})})),y.focusin="onfocusin"in o;var we=/^(?:focusinfocus|focusoutblur)$/,stopPropagationCallback=function(e){e.stopPropagation()};jQuery.extend(jQuery.event,{trigger:function(e,n,r,i){var a,s,l,u,c,d,p,f,g=[r||x],m=h.call(e,"type")?e.type:e,y=h.call(e,"namespace")?e.namespace.split("."):[];if(s=f=l=r=r||x,3!==r.nodeType&&8!==r.nodeType&&!we.test(m+jQuery.event.triggered)&&(m.indexOf(".")>-1&&(y=m.split("."),m=y.shift(),y.sort()),c=m.indexOf(":")<0&&"on"+m,(e=e[jQuery.expando]?e:new jQuery.Event(m,"object"==typeof e&&e)).isTrigger=i?2:3,e.namespace=y.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+y.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=r),n=null==n?[e]:jQuery.makeArray(n,[e]),p=jQuery.event.special[m]||{},i||!p.trigger||!1!==p.trigger.apply(r,n))){if(!i&&!p.noBubble&&!b(r)){for(u=p.delegateType||m,we.test(u+m)||(s=s.parentNode);s;s=s.parentNode)g.push(s),l=s;l===(r.ownerDocument||x)&&g.push(l.defaultView||l.parentWindow||o)}for(a=0;(s=g[a++])&&!e.isPropagationStopped();)f=s,e.type=a>1?u:p.bindType||m,(d=(R.get(s,"events")||Object.create(null))[e.type]&&R.get(s,"handle"))&&d.apply(s,n),(d=c&&s[c])&&d.apply&&acceptData(s)&&(e.result=d.apply(s,n),!1===e.result&&e.preventDefault());return e.type=m,i||e.isDefaultPrevented()||p._default&&!1!==p._default.apply(g.pop(),n)||!acceptData(r)||c&&v(r[m])&&!b(r)&&((l=r[c])&&(r[c]=null),jQuery.event.triggered=m,e.isPropagationStopped()&&f.addEventListener(m,stopPropagationCallback),r[m](),e.isPropagationStopped()&&f.removeEventListener(m,stopPropagationCallback),jQuery.event.triggered=void 0,l&&(r[c]=l)),e.result}},simulate:function(e,n,r){var o=jQuery.extend(new jQuery.Event,r,{type:e,isSimulated:!0});jQuery.event.trigger(o,null,n)}}),jQuery.fn.extend({trigger:function(e,n){return this.each((function(){jQuery.event.trigger(e,n,this)}))},triggerHandler:function(e,n){var r=this[0];if(r)return jQuery.event.trigger(e,n,r,!0)}}),y.focusin||jQuery.each({focus:"focusin",blur:"focusout"},(function(e,n){var handler=function(e){jQuery.event.simulate(n,e.target,jQuery.event.fix(e))};jQuery.event.special[n]={setup:function(){var r=this.ownerDocument||this.document||this,o=R.access(r,n);o||r.addEventListener(e,handler,!0),R.access(r,n,(o||0)+1)},teardown:function(){var r=this.ownerDocument||this.document||this,o=R.access(r,n)-1;o?R.access(r,n,o):(r.removeEventListener(e,handler,!0),R.remove(r,n))}}}));var Se=o.location,Te={guid:Date.now()},Ce=/\?/;jQuery.parseXML=function(e){var n,r;if(!e||"string"!=typeof e)return null;try{n=(new o.DOMParser).parseFromString(e,"text/xml")}catch(e){}return r=n&&n.getElementsByTagName("parsererror")[0],n&&!r||jQuery.error("Invalid XML: "+(r?jQuery.map(r.childNodes,(function(e){return e.textContent})).join("\n"):e)),n};var ke=/\[\]$/,Ne=/\r?\n/g,_e=/^(?:submit|button|image|reset|file)$/i,Ee=/^(?:input|select|textarea|keygen)/i;function buildParams(e,n,r,o){var i;if(Array.isArray(n))jQuery.each(n,(function(n,i){r||ke.test(e)?o(e,i):buildParams(e+"["+("object"==typeof i&&null!=i?n:"")+"]",i,r,o)}));else if(r||"object"!==toType(n))o(e,n);else for(i in n)buildParams(e+"["+i+"]",n[i],r,o)}jQuery.param=function(e,n){var r,o=[],add=function(e,n){var r=v(n)?n():n;o[o.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==r?"":r)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!jQuery.isPlainObject(e))jQuery.each(e,(function(){add(this.name,this.value)}));else for(r in e)buildParams(r,e[r],n,add);return o.join("&")},jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray())},serializeArray:function(){return this.map((function(){var e=jQuery.prop(this,"elements");return e?jQuery.makeArray(e):this})).filter((function(){var e=this.type;return this.name&&!jQuery(this).is(":disabled")&&Ee.test(this.nodeName)&&!_e.test(e)&&(this.checked||!G.test(e))})).map((function(e,n){var r=jQuery(this).val();return null==r?null:Array.isArray(r)?jQuery.map(r,(function(e){return{name:n.name,value:e.replace(Ne,"\r\n")}})):{name:n.name,value:r.replace(Ne,"\r\n")}})).get()}});var Ae=/%20/g,Le=/#.*$/,Oe=/([?&])_=[^&]*/,Pe=/^(.*?):[ \t]*([^\r\n]*)$/gm,je=/^(?:GET|HEAD)$/,De=/^\/\//,Me={},Re={},Ie="*/".concat("*"),qe=x.createElement("a");function addToPrefiltersOrTransports(e){return function(n,r){"string"!=typeof n&&(r=n,n="*");var o,i=0,a=n.toLowerCase().match(O)||[];if(v(r))for(;o=a[i++];)"+"===o[0]?(o=o.slice(1)||"*",(e[o]=e[o]||[]).unshift(r)):(e[o]=e[o]||[]).push(r)}}function inspectPrefiltersOrTransports(e,n,r,o){var i={},a=e===Re;function inspect(s){var l;return i[s]=!0,jQuery.each(e[s]||[],(function(e,s){var u=s(n,r,o);return"string"!=typeof u||a||i[u]?a?!(l=u):void 0:(n.dataTypes.unshift(u),inspect(u),!1)})),l}return inspect(n.dataTypes[0])||!i["*"]&&inspect("*")}function ajaxExtend(e,n){var r,o,i=jQuery.ajaxSettings.flatOptions||{};for(r in n)void 0!==n[r]&&((i[r]?e:o||(o={}))[r]=n[r]);return o&&jQuery.extend(!0,e,o),e}qe.href=Se.href,jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Se.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Se.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Ie,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":jQuery.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,n){return n?ajaxExtend(ajaxExtend(e,jQuery.ajaxSettings),n):ajaxExtend(jQuery.ajaxSettings,e)},ajaxPrefilter:addToPrefiltersOrTransports(Me),ajaxTransport:addToPrefiltersOrTransports(Re),ajax:function(e,n){"object"==typeof e&&(n=e,e=void 0),n=n||{};var r,i,a,s,l,u,c,d,p,f,h=jQuery.ajaxSetup({},n),g=h.context||h,m=h.context&&(g.nodeType||g.jquery)?jQuery(g):jQuery.event,y=jQuery.Deferred(),v=jQuery.Callbacks("once memory"),b=h.statusCode||{},w={},S={},T="canceled",C={readyState:0,getResponseHeader:function(e){var n;if(c){if(!s)for(s={};n=Pe.exec(a);)s[n[1].toLowerCase()+" "]=(s[n[1].toLowerCase()+" "]||[]).concat(n[2]);n=s[e.toLowerCase()+" "]}return null==n?null:n.join(", ")},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,n){return null==c&&(e=S[e.toLowerCase()]=S[e.toLowerCase()]||e,w[e]=n),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var n;if(e)if(c)C.always(e[C.status]);else for(n in e)b[n]=[b[n],e[n]];return this},abort:function(e){var n=e||T;return r&&r.abort(n),done(0,n),this}};if(y.promise(C),h.url=((e||h.url||Se.href)+"").replace(De,Se.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(O)||[""],null==h.crossDomain){u=x.createElement("a");try{u.href=h.url,u.href=u.href,h.crossDomain=qe.protocol+"//"+qe.host!=u.protocol+"//"+u.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=jQuery.param(h.data,h.traditional)),inspectPrefiltersOrTransports(Me,h,n,C),c)return C;for(p in(d=jQuery.event&&h.global)&&0==jQuery.active++&&jQuery.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!je.test(h.type),i=h.url.replace(Le,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(Ae,"+")):(f=h.url.slice(i.length),h.data&&(h.processData||"string"==typeof h.data)&&(i+=(Ce.test(i)?"&":"?")+h.data,delete h.data),!1===h.cache&&(i=i.replace(Oe,"$1"),f=(Ce.test(i)?"&":"?")+"_="+Te.guid+++f),h.url=i+f),h.ifModified&&(jQuery.lastModified[i]&&C.setRequestHeader("If-Modified-Since",jQuery.lastModified[i]),jQuery.etag[i]&&C.setRequestHeader("If-None-Match",jQuery.etag[i])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&C.setRequestHeader("Content-Type",h.contentType),C.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+Ie+"; q=0.01":""):h.accepts["*"]),h.headers)C.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,C,h)||c))return C.abort();if(T="abort",v.add(h.complete),C.done(h.success),C.fail(h.error),r=inspectPrefiltersOrTransports(Re,h,n,C)){if(C.readyState=1,d&&m.trigger("ajaxSend",[C,h]),c)return C;h.async&&h.timeout>0&&(l=o.setTimeout((function(){C.abort("timeout")}),h.timeout));try{c=!1,r.send(w,done)}catch(e){if(c)throw e;done(-1,e)}}else done(-1,"No Transport");function done(e,n,s,u){var p,f,x,w,S,T=n;c||(c=!0,l&&o.clearTimeout(l),r=void 0,a=u||"",C.readyState=e>0?4:0,p=e>=200&&e<300||304===e,s&&(w=function ajaxHandleResponses(e,n,r){for(var o,i,a,s,l=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===o&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(i in l)if(l[i]&&l[i].test(o)){u.unshift(i);break}if(u[0]in r)a=u[0];else{for(i in r){if(!u[0]||e.converters[i+" "+u[0]]){a=i;break}s||(s=i)}a=a||s}if(a)return a!==u[0]&&u.unshift(a),r[a]}(h,C,s)),!p&&jQuery.inArray("script",h.dataTypes)>-1&&jQuery.inArray("json",h.dataTypes)<0&&(h.converters["text script"]=function(){}),w=function ajaxConvert(e,n,r,o){var i,a,s,l,u,c={},d=e.dataTypes.slice();if(d[1])for(s in e.converters)c[s.toLowerCase()]=e.converters[s];for(a=d.shift();a;)if(e.responseFields[a]&&(r[e.responseFields[a]]=n),!u&&o&&e.dataFilter&&(n=e.dataFilter(n,e.dataType)),u=a,a=d.shift())if("*"===a)a=u;else if("*"!==u&&u!==a){if(!(s=c[u+" "+a]||c["* "+a]))for(i in c)if((l=i.split(" "))[1]===a&&(s=c[u+" "+l[0]]||c["* "+l[0]])){!0===s?s=c[i]:!0!==c[i]&&(a=l[0],d.unshift(l[1]));break}if(!0!==s)if(s&&e.throws)n=s(n);else try{n=s(n)}catch(e){return{state:"parsererror",error:s?e:"No conversion from "+u+" to "+a}}}return{state:"success",data:n}}(h,w,C,p),p?(h.ifModified&&((S=C.getResponseHeader("Last-Modified"))&&(jQuery.lastModified[i]=S),(S=C.getResponseHeader("etag"))&&(jQuery.etag[i]=S)),204===e||"HEAD"===h.type?T="nocontent":304===e?T="notmodified":(T=w.state,f=w.data,p=!(x=w.error))):(x=T,!e&&T||(T="error",e<0&&(e=0))),C.status=e,C.statusText=(n||T)+"",p?y.resolveWith(g,[f,T,C]):y.rejectWith(g,[C,T,x]),C.statusCode(b),b=void 0,d&&m.trigger(p?"ajaxSuccess":"ajaxError",[C,h,p?f:x]),v.fireWith(g,[C,T]),d&&(m.trigger("ajaxComplete",[C,h]),--jQuery.active||jQuery.event.trigger("ajaxStop")))}return C},getJSON:function(e,n,r){return jQuery.get(e,n,r,"json")},getScript:function(e,n){return jQuery.get(e,void 0,n,"script")}}),jQuery.each(["get","post"],(function(e,n){jQuery[n]=function(e,r,o,i){return v(r)&&(i=i||o,o=r,r=void 0),jQuery.ajax(jQuery.extend({url:e,type:n,dataType:i,data:r,success:o},jQuery.isPlainObject(e)&&e))}})),jQuery.ajaxPrefilter((function(e){var n;for(n in e.headers)"content-type"===n.toLowerCase()&&(e.contentType=e.headers[n]||"")})),jQuery._evalUrl=function(e,n,r){return jQuery.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){jQuery.globalEval(e,n,r)}})},jQuery.fn.extend({wrapAll:function(e){var n;return this[0]&&(v(e)&&(e=e.call(this[0])),n=jQuery(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&n.insertBefore(this[0]),n.map((function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e})).append(this)),this},wrapInner:function(e){return v(e)?this.each((function(n){jQuery(this).wrapInner(e.call(this,n))})):this.each((function(){var n=jQuery(this),r=n.contents();r.length?r.wrapAll(e):n.append(e)}))},wrap:function(e){var n=v(e);return this.each((function(r){jQuery(this).wrapAll(n?e.call(this,r):e)}))},unwrap:function(e){return this.parent(e).not("body").each((function(){jQuery(this).replaceWith(this.childNodes)})),this}}),jQuery.expr.pseudos.hidden=function(e){return!jQuery.expr.pseudos.visible(e)},jQuery.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},jQuery.ajaxSettings.xhr=function(){try{return new o.XMLHttpRequest}catch(e){}};var Fe={0:200,1223:204},He=jQuery.ajaxSettings.xhr();y.cors=!!He&&"withCredentials"in He,y.ajax=He=!!He,jQuery.ajaxTransport((function(e){var n,r;if(y.cors||He&&!e.crossDomain)return{send:function(i,a){var s,l=e.xhr();if(l.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(s in e.xhrFields)l[s]=e.xhrFields[s];for(s in e.mimeType&&l.overrideMimeType&&l.overrideMimeType(e.mimeType),e.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest"),i)l.setRequestHeader(s,i[s]);n=function(e){return function(){n&&(n=r=l.onload=l.onerror=l.onabort=l.ontimeout=l.onreadystatechange=null,"abort"===e?l.abort():"error"===e?"number"!=typeof l.status?a(0,"error"):a(l.status,l.statusText):a(Fe[l.status]||l.status,l.statusText,"text"!==(l.responseType||"text")||"string"!=typeof l.responseText?{binary:l.response}:{text:l.responseText},l.getAllResponseHeaders()))}},l.onload=n(),r=l.onerror=l.ontimeout=n("error"),void 0!==l.onabort?l.onabort=r:l.onreadystatechange=function(){4===l.readyState&&o.setTimeout((function(){n&&r()}))},n=n("abort");try{l.send(e.hasContent&&e.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}})),jQuery.ajaxPrefilter((function(e){e.crossDomain&&(e.contents.script=!1)})),jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return jQuery.globalEval(e),e}}}),jQuery.ajaxPrefilter("script",(function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")})),jQuery.ajaxTransport("script",(function(e){var n,r;if(e.crossDomain||e.scriptAttrs)return{send:function(o,i){n=jQuery("<script>").attr(e.scriptAttrs||{}).prop({charset:e.scriptCharset,src:e.url}).on("load error",r=function(e){n.remove(),r=null,e&&i("error"===e.type?404:200,e.type)}),x.head.appendChild(n[0])},abort:function(){r&&r()}}}));var ze,Be=[],Ue=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Be.pop()||jQuery.expando+"_"+Te.guid++;return this[e]=!0,e}}),jQuery.ajaxPrefilter("json jsonp",(function(e,n,r){var i,a,s,l=!1!==e.jsonp&&(Ue.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ue.test(e.data)&&"data");if(l||"jsonp"===e.dataTypes[0])return i=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,l?e[l]=e[l].replace(Ue,"$1"+i):!1!==e.jsonp&&(e.url+=(Ce.test(e.url)?"&":"?")+e.jsonp+"="+i),e.converters["script json"]=function(){return s||jQuery.error(i+" was not called"),s[0]},e.dataTypes[0]="json",a=o[i],o[i]=function(){s=arguments},r.always((function(){void 0===a?jQuery(o).removeProp(i):o[i]=a,e[i]&&(e.jsonpCallback=n.jsonpCallback,Be.push(i)),s&&v(a)&&a(s[0]),s=a=void 0})),"script"})),y.createHTMLDocument=((ze=x.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===ze.childNodes.length),jQuery.parseHTML=function(e,n,r){return"string"!=typeof e?[]:("boolean"==typeof n&&(r=n,n=!1),n||(y.createHTMLDocument?((o=(n=x.implementation.createHTMLDocument("")).createElement("base")).href=x.location.href,n.head.appendChild(o)):n=x),a=!r&&[],(i=k.exec(e))?[n.createElement(i[1])]:(i=buildFragment([e],n,a),a&&a.length&&jQuery(a).remove(),jQuery.merge([],i.childNodes)));var o,i,a},jQuery.fn.load=function(e,n,r){var o,i,a,s=this,l=e.indexOf(" ");return l>-1&&(o=stripAndCollapse(e.slice(l)),e=e.slice(0,l)),v(n)?(r=n,n=void 0):n&&"object"==typeof n&&(i="POST"),s.length>0&&jQuery.ajax({url:e,type:i||"GET",dataType:"html",data:n}).done((function(e){a=arguments,s.html(o?jQuery("<div>").append(jQuery.parseHTML(e)).find(o):e)})).always(r&&function(e,n){s.each((function(){r.apply(this,a||[e.responseText,n,e])}))}),this},jQuery.expr.pseudos.animated=function(e){return jQuery.grep(jQuery.timers,(function(n){return e===n.elem})).length},jQuery.offset={setOffset:function(e,n,r){var o,i,a,s,l,u,c=jQuery.css(e,"position"),d=jQuery(e),p={};"static"===c&&(e.style.position="relative"),l=d.offset(),a=jQuery.css(e,"top"),u=jQuery.css(e,"left"),("absolute"===c||"fixed"===c)&&(a+u).indexOf("auto")>-1?(s=(o=d.position()).top,i=o.left):(s=parseFloat(a)||0,i=parseFloat(u)||0),v(n)&&(n=n.call(e,r,jQuery.extend({},l))),null!=n.top&&(p.top=n.top-l.top+s),null!=n.left&&(p.left=n.left-l.left+i),"using"in n?n.using.call(e,p):d.css(p)}},jQuery.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each((function(n){jQuery.offset.setOffset(this,e,n)}));var n,r,o=this[0];return o?o.getClientRects().length?(n=o.getBoundingClientRect(),r=o.ownerDocument.defaultView,{top:n.top+r.pageYOffset,left:n.left+r.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,n,r,o=this[0],i={top:0,left:0};if("fixed"===jQuery.css(o,"position"))n=o.getBoundingClientRect();else{for(n=this.offset(),r=o.ownerDocument,e=o.offsetParent||r.documentElement;e&&(e===r.body||e===r.documentElement)&&"static"===jQuery.css(e,"position");)e=e.parentNode;e&&e!==o&&1===e.nodeType&&((i=jQuery(e).offset()).top+=jQuery.css(e,"borderTopWidth",!0),i.left+=jQuery.css(e,"borderLeftWidth",!0))}return{top:n.top-i.top-jQuery.css(o,"marginTop",!0),left:n.left-i.left-jQuery.css(o,"marginLeft",!0)}}},offsetParent:function(){return this.map((function(){for(var e=this.offsetParent;e&&"static"===jQuery.css(e,"position");)e=e.offsetParent;return e||U}))}}),jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(function(e,n){var r="pageYOffset"===n;jQuery.fn[e]=function(o){return access(this,(function(e,o,i){var a;if(b(e)?a=e:9===e.nodeType&&(a=e.defaultView),void 0===i)return a?a[n]:e[o];a?a.scrollTo(r?a.pageXOffset:i,r?i:a.pageYOffset):e[o]=i}),e,o,arguments.length)}})),jQuery.each(["top","left"],(function(e,n){jQuery.cssHooks[n]=addGetHookIf(y.pixelPosition,(function(e,r){if(r)return r=curCSS(e,n),re.test(r)?jQuery(e).position()[n]+"px":r}))})),jQuery.each({Height:"height",Width:"width"},(function(e,n){jQuery.each({padding:"inner"+e,content:n,"":"outer"+e},(function(r,o){jQuery.fn[o]=function(i,a){var s=arguments.length&&(r||"boolean"!=typeof i),l=r||(!0===i||!0===a?"margin":"border");return access(this,(function(n,r,i){var a;return b(n)?0===o.indexOf("outer")?n["inner"+e]:n.document.documentElement["client"+e]:9===n.nodeType?(a=n.documentElement,Math.max(n.body["scroll"+e],a["scroll"+e],n.body["offset"+e],a["offset"+e],a["client"+e])):void 0===i?jQuery.css(n,r,l):jQuery.style(n,r,i,l)}),n,s?i:void 0,s)}}))})),jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],(function(e,n){jQuery.fn[n]=function(e){return this.on(n,e)}})),jQuery.fn.extend({bind:function(e,n,r){return this.on(e,null,n,r)},unbind:function(e,n){return this.off(e,null,n)},delegate:function(e,n,r,o){return this.on(n,e,r,o)},undelegate:function(e,n,r){return 1===arguments.length?this.off(e,"**"):this.off(n,e||"**",r)},hover:function(e,n){return this.mouseenter(e).mouseleave(n||e)}}),jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),(function(e,n){jQuery.fn[n]=function(e,r){return arguments.length>0?this.on(n,null,e,r):this.trigger(n)}}));var We=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;jQuery.proxy=function(e,n){var r,o,i;if("string"==typeof n&&(r=e[n],n=e,e=r),v(e))return o=l.call(arguments,2),(i=function(){return e.apply(n||this,o.concat(l.call(arguments)))}).guid=e.guid=e.guid||jQuery.guid++,i},jQuery.holdReady=function(e){e?jQuery.readyWait++:jQuery.ready(!0)},jQuery.isArray=Array.isArray,jQuery.parseJSON=JSON.parse,jQuery.nodeName=nodeName,jQuery.isFunction=v,jQuery.isWindow=b,jQuery.camelCase=camelCase,jQuery.type=toType,jQuery.now=Date.now,jQuery.isNumeric=function(e){var n=jQuery.type(e);return("number"===n||"string"===n)&&!isNaN(e-parseFloat(e))},jQuery.trim=function(e){return null==e?"":(e+"").replace(We,"")},void 0===(r=function(){return jQuery}.apply(n,[]))||(e.exports=r);var $e=o.jQuery,Ve=o.$;return jQuery.noConflict=function(e){return o.$===jQuery&&(o.$=Ve),e&&o.jQuery===jQuery&&(o.jQuery=$e),jQuery},void 0===i&&(o.jQuery=o.$=jQuery),jQuery}))},98:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=class DropDown{constructor(e,n,r){const i=o.isNil(n)?e.querySelector(".neos-dropdown-trigger"):n,a=this.getContentSelector(i);this.root=e,this.trigger=i,this.content=o.isEmpty(a)?e.querySelector(".neos-dropdown-content"):document.getElementById(a),this.grouped=!o.isNil(r)&&Boolean(r),this.disabled=!1,this.initialize(),this.setupEventListeners()}initialize(){if(o.isNil(this.content))return;const e=this.content.innerHTML.trim();o.isEmpty(e)&&(this.trigger.setAttribute("disabled","true"),this.disabled=!0)}getContentSelector(e){return o.isNil(e)?"":e.getAttribute("aria-controls")}setupEventListeners(){o.isNil(this.trigger)||o.isNil(this.content)||this.disabled||this.trigger.addEventListener("click",this.toggle.bind(this))}toggle(e){e.preventDefault(),this.grouped?this._closeOthers():this.root.classList.toggle("open");const n=this.trigger.getAttribute("aria-expanded");!1===(!o.isEmpty(n)&&"true"===n.toLowerCase())?this.open():this.close(this.trigger)}open(){this.trigger.setAttribute("aria-expanded","true"),this.content.removeAttribute("hidden")}close(e){const n=this.getContentSelector(e);let r=document.getElementById(n);o.isNil(r)&&(r=this.content),e.setAttribute("aria-expanded","false"),r.setAttribute("hidden","true")}_closeOthers(){Array.from(this.root.querySelectorAll(".neos-dropdown-trigger")).forEach((e=>{e!==this.trigger&&this.close(e)}))}}},47:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=r(586),a=o(r(98));n.default=class DropDownGroup{constructor(e){this.root=e,this.initialize()}initialize(){if(i.isNil(this.root))return;Array.from(this.root.querySelectorAll(".neos-dropdown-trigger")).forEach((e=>{new a.default(this.root,e,!0)}))}}},357:(e,n,r)=>{"use strict";const o=r(586);n.Z=class Modal{constructor(e){this.root=e,this.triggers=Array.from(document.querySelectorAll(`[href="#${e.id}"][data-toggle="modal"]`)),this.closeButtons=Array.from(this.root.querySelectorAll('[data-dismiss="modal"]')),this.header=e.querySelector(".neos-header"),this.setupEventListeners()}setupEventListeners(){this.triggers.forEach((e=>{e.addEventListener("click",this.open.bind(this))})),this.closeButtons.forEach((e=>{e.addEventListener("click",this.close.bind(this))})),document.addEventListener("keyup",this.onKeyPress.bind(this))}open(e){e.preventDefault();const n=e.target,r=this.getTriggerElement(n);this.handleDynamicHeader(r),this.root.classList.add("open"),this.root.classList.remove("neos-hide"),r.dispatchEvent(new CustomEvent("neoscms-modal-opened",{bubbles:!0,detail:{identifier:this.root.id}}))}getTriggerElement(e){return o.isNil(e)?null:(e.hasAttribute("data-toggle")||(e=e.closest('[data-toggle="modal"]')),e)}close(){this.root.classList.remove("open"),this.root.classList.add("neos-hide"),window.dispatchEvent(new CustomEvent("neoscms-modal-closed",{detail:{identifier:this.root.id}}))}onKeyPress(e){"Escape"===e.key&&this.close()}handleDynamicHeader(e){if(o.isNil(e)||o.isNil(this.header))return;const n=e.getAttribute("data-modal-header");o.isEmpty(n)||(this.header.innerText=n)}}},813:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(482)),a=r(586),s=r(511);n.default=class Message{constructor(e,n){this.message=null,this.container=n,this.options=e,this.initialize(),this.setupEventListeners()}initialize(){const e=Date.now(),n=Math.floor(e/1e3),{title:r,message:o,type:a,closeButton:l}=this.options,u=i.default.sanitize(o),c=s.messageTemplate(a,r,u,l),d=document.createElement("div");d.innerHTML=c;const p=d.firstElementChild;p.id="neos-notification-message-"+n,this.message=p,this.container.appendChild(p),this.registerCloseButton(p),this.registerExpandHandling(p)}registerExpandHandling(e){const n=e.querySelector(".neos-notification-content");!a.isNil(n)&&n.classList.contains("expandable")&&n.addEventListener("click",this.toggle.bind(this))}registerCloseButton(e){const n=e.querySelector(".neos-close-button");a.isNil(n)||n.addEventListener("click",this.close.bind(this))}setupEventListeners(){const e=this.options.timeout;e>0&&setTimeout(this.close.bind(this),e)}close(){a.isNil(this.message)||(this.message.classList.add("fade-out"),setTimeout((()=>{this.message.remove()}),250))}toggle(){if(a.isNil(this.message))return;const e=this.message.querySelector(".neos-notification-content");a.isNil(e)||e.classList.toggle("expanded")}}},511:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.messageTemplate=void 0;const o=r(586),i={error:"error",info:"info",ok:"success",warning:"warning",notice:"info"};n.messageTemplate=(e,n,r,a)=>{const s=!o.isEmpty(r),l=["neos-notification-content"],u=!o.isNil(a)&&a?'<i class="fas fa-times neos-close-button"></i>':"";let c="";return s&&(c=`<div class="neos-expand-content">${r}</div>`,l.push("expandable")),`\n\t\t<div class="neos-notification neos-notification-${i[e]}">\n\t\t\t<i class="fas fa-${i[e]}"></i>\n\t\t\t${u}\n\t\t\t<div class="${l.join(" ")}">\n\t\t\t\t<div class="neos-notification-heading">${n}</div>\n\t\t\t\t${c}\n\t\t\t</div>\n\t\t</div>\n\t`}},944:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=r(586),a=o(r(813)),s={position:"neos-notification-top",timeout:5e3,type:"info"};class Toast{constructor(){this.container=document.getElementById("neos-notification-container"),this.initialize()}initialize(){if(i.isNil(this.container)){const e=document.getElementById("neos-application");i.isNil(e)||(this.container=document.createElement("div"),this.container.id="neos-notification-container",e.appendChild(this.container))}}create(e){const n=Object.assign(Object.assign({},s),e);i.isNil(n.position)||this.container.classList.add(n.position),new a.default(n,this.container)}static create(e){if(i.isNil(this._container)){(new Toast).create(e)}else this._create(e)}static removeAll(){Array.from(this._container.childNodes).forEach((e=>{i.isNil(e)||(e.classList.add("fade-out"),setTimeout((()=>{e.remove()}),250))}))}}n.default=Toast},693:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=class DropDownMenu{constructor(e){this.root=e,this.button=Array.from(this.root.querySelectorAll(".neos-dropdown-toggle")),this.menu=Array.from(this.root.querySelectorAll(".neos-dropdown-menu")),this.setupEventListeners()}setupEventListeners(){this.button.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}toggle(e){this.changeToogleIcon(),this.root.classList.toggle("neos-dropdown-open")}changeToogleIcon(){const e=this.root.querySelector(".fa-chevron-down"),n=this.root.querySelector(".fa-chevron-up");e&&e.classList.replace("fa-chevron-down","fa-chevron-up"),n&&n.classList.replace("fa-chevron-up","fa-chevron-down")}}},576:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=class Expandable{constructor(e,n,r,o){this.root=e,this.trigger=Array.from(this.root.querySelectorAll(n)),this.onStateChange=r,this.setupEventListeners(),this.initialize(o)}setupEventListeners(){this.trigger.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}initialize(e){this.root.querySelector("[aria-expanded]").setAttribute("aria-expanded",String(e)),e&&(this.root.classList.add("neos-open"),this.changeToogleIcon())}toggle(){this.changeToogleIcon(),this.root.classList.toggle("neos-open"),this.toogleAriaExpandable()}toogleAriaExpandable(){const e=this.root.querySelector("[aria-expanded]"),n=this.root.classList.contains("neos-open");if(e.setAttribute("aria-expanded",String(n)),"function"==typeof this.onStateChange){const e=this.root.getAttribute("data-key");this.onStateChange(e,n)}}changeToogleIcon(){const e=this.root.querySelector(".fa-chevron-circle-down"),n=this.root.querySelector(".fa-chevron-circle-up");e&&e.classList.replace("fa-chevron-circle-down","fa-chevron-circle-up"),n&&n.classList.replace("fa-chevron-circle-up","fa-chevron-circle-down")}}},527:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(576)),a=r(791),s="ui.drawer.collapsedMenuGroups";n.default=class MenuPanel{constructor(e){this.root=e,this.button=Array.from(this.root.querySelectorAll(".neos-menu-button")),this.panel=Array.from(this.root.querySelectorAll(".neos-menu-panel")),this.menuSectionStates=this.loadMenuSectionStates(),this.setupEventListeners(),this.panel&&this.initializeMenuSections()}initializeMenuSections(){this.panel.forEach((e=>{const n=e.querySelectorAll(".neos-menu-section"),r=this.menuSectionStates;n.forEach((e=>{const n=e.getAttribute("data-key"),o=!r.includes(n);new i.default(e,".neos-menu-panel-toggle",this.onMenuSectionStateChange.bind(this),o)}))}))}setupEventListeners(){this.button.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}loadMenuSectionStates(){const e=a.loadStorageData(s);return Array.isArray(e)?e:[]}saveMenuSectionStates(){Array.isArray(this.menuSectionStates)&&a.saveStorageData(s,this.menuSectionStates)}onMenuSectionStateChange(e,n){this.menuSectionStates.includes(e)&&!0===n&&(this.menuSectionStates=this.menuSectionStates.filter((n=>n!==e))),this.menuSectionStates.includes(e)||!1!==n||this.menuSectionStates.push(e),this.saveMenuSectionStates()}toggle(e){this.button.forEach((e=>{e.classList.toggle("neos-pressed")})),document.body.classList.toggle("neos-menu-panel-open")}}},366:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.UserMenu=n.MenuPanel=n.Expandable=n.DropDownMenu=void 0;const i=o(r(693));n.DropDownMenu=i.default;const a=o(r(576));n.Expandable=a.default;const s=o(r(527));n.MenuPanel=s.default;const l=o(r(148));n.UserMenu=l.default},767:(e,n,r)=>{"use strict";const o=r(586),i=r(791);n.Z=class Tree{constructor(e){this.root=e,this.type=this.root.getAttribute("data-type"),this.treeBranchStates=this.loadTreeBranchStates(!0),this.nodes=Array.from(this.root.querySelectorAll(".neos-tree-node")),this.initializeTree(),this.setupEventListeners()}initializeTree(){this.nodes.forEach((e=>{"ul"!==e.firstChild.nodeName.toLowerCase()&&this.wrapElementWithNodeTitle(e.firstChild);const n=e.querySelectorAll(".neos-tree-node");if(this.isFolder(e)&&!o.isNil(n)&&n.length>0){const n=this.createExpandIcon();e.insertBefore(n,e.firstChild)}}))}initializeTreeState(e){Array.isArray(e)&&e.forEach((e=>{const n=this.root.querySelector(`[title="${e}"`);o.isNil(n)||n.classList.add("neos-tree-open")}))}setupEventListeners(){this.nodes.forEach((e=>{e.addEventListener("click",this.onNodeClick.bind(this))}))}onNodeClick(e){e.preventDefault(),e.stopPropagation();const n=e.target.closest(".neos-tree-node");o.isNil(n)||(this.deselectCurrentActiveNode(),n.classList.toggle("neos-tree-active")),this.isFolder(n)&&this.toggle(n)}deselectCurrentActiveNode(){this.root.querySelectorAll(".neos-tree-active").forEach((e=>{e.classList.remove("neos-tree-active")}))}createExpandIcon(){const e=document.createElement("span");return e.classList.add("neos-tree-expander"),e}wrapElementWithNodeTitle(e){const n=document.createElement("span");n.classList.add("neos-tree-title"),e.parentNode.insertBefore(n,e),n.appendChild(e)}isFolder(e){return!o.isNil(e)&&e.classList.contains("neos-tree-folder")}toggle(e){e.classList.toggle("neos-tree-open"),this.changeTreeBranchState(e.getAttribute("title"))}getPathForType(){return("module.configuration"+(o.isEmpty(this.type)?"":"."+this.type)).toLowerCase()}loadTreeBranchStates(e){const n=this.getPathForType(),r=i.loadStorageData(n);return o.isNil(e)||!0!==e||this.initializeTreeState(r),this.treeBranchStates=Array.isArray(r)?r:[],this.treeBranchStates}saveTreeBranchStates(){const e=this.getPathForType();Array.isArray(this.treeBranchStates)&&i.saveStorageData(e,this.treeBranchStates)}changeTreeBranchState(e){!o.isEmpty(e)&&Array.isArray(this.treeBranchStates)&&(this.treeBranchStates.includes(e)?this.treeBranchStates=this.treeBranchStates.filter((n=>n!==e)):this.treeBranchStates.push(e),this.saveTreeBranchStates())}}},24:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=(e,n,r)=>{e="object"==typeof e?e:{};const o=Array.isArray(n)?n:n.split(".");let i=e;for(let e=0;e<o.length-1;e++){const n=o[e];if(!i[n]&&!Object.prototype.hasOwnProperty.call(i,n)){const r=o[e+1],a=/^\+?(0|[1-9]\d*)$/.test(r);i[n]=a?[]:{}}i=i[n]}return i[o[o.length-1]]=r,e}},521:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=(e,n)=>o.isNil(e)?null:n.split(".").reduce(((e,n)=>o.isNil(e)?null:e[n]),e)},442:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=(e,n,r)=>o.isNil(e)?null:e.find((e=>e[n]===r))},586:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.createCollectionByPath=n.getCollectionValueByPath=n.getItemByKeyValue=n.isEmpty=n.isNil=void 0;const i=o(r(856));n.isNil=i.default;const a=o(r(626));n.isEmpty=a.default;const s=o(r(442));n.getItemByKeyValue=s.default;const l=o(r(521));n.getCollectionValueByPath=l.default;const u=o(r(24));n.createCollectionByPath=u.default},626:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(856));n.default=e=>"string"==typeof e?0===e.length:!!i.default(e)||!Object.getOwnPropertySymbols(e).length&&!Object.getOwnPropertyNames(e).length},856:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=e=>null==e}},n={};function __webpack_require__(r){if(n[r])return n[r].exports;var o=n[r]={exports:{}};return e[r].call(o.exports,o,o.exports,__webpack_require__),o.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var r in n)__webpack_require__.o(n,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=__webpack_require__(755),n=__webpack_require__.n(e),r=__webpack_require__(366),o=__webpack_require__(586),i=__webpack_require__(912);const a=(0,o.isNil)(window.Typo3Neos)?"Login as this user":window.NeosCMS.I18n.translate("impersonate.tooltip.impersonateUserButton","Login as this user","Neos.Neos");class UserManagement{constructor(e){const n=document.querySelector("[data-csrf-token]");this._root=e,this._csrfToken=(0,o.isNil)(n)?"":n.getAttribute("data-csrf-token"),console.log(this._csrfToken),this._apiService=new i.sM("/neos/impersonate/",this._csrfToken),(0,o.isNil)(e)||this._initialize()}_initialize(){this._renderImpersonateButtons(),this._setupEventListeners()}_setupEventListeners(){this._root.querySelectorAll("button.impersonate-user").forEach((e=>{e.addEventListener("click",this._impersonateUser.bind(this))}))}_renderImpersonateButtons(){Array.from(this._root.querySelectorAll(".neos-table .neos-action")).forEach((e=>{const n=e.querySelector("button.neos-button-danger"),r=e.querySelector('a[href*="show"]');if((0,o.isNil)(r))return!1;const i=new URL(decodeURIComponent(r.getAttribute("href"))),s=((e,n)=>{const r={"data-neos-toggle":"tooltip","data-original-title":a,"data-user-identifier":e,class:"neos-button neos-button-primary impersonate-user"};(0,o.isNil)(n)||!0!==n||(r.disabled=!0,r.class+=" neos-disabled");let i="";return Object.keys(r).forEach((e=>{i+=`${e}="${r[e]}" `})),`<button ${i}><i class="fas fa-random icon-white"></i></button>`})(new URLSearchParams(i.search).get("moduleArguments[user][__identity]"),!(0,o.isNil)(n)&&n.classList.contains("neos-disabled"));r.parentElement.innerHTML+=s}))}_impersonateUser(e){e.preventDefault();const n=e.currentTarget;if((0,o.isNil)(n))return!1;const r=n.getAttribute("data-user-identifier");this._apiService.callUserChange(r).then((e=>{const{user:n,status:r}=e,i=(0,o.isNil)(n)?"":n.accountIdentifier,a=window.NeosCMS.I18n.translate("impersonate.success.impersonateUser","Switched to the new user {0}.","Neos.Neos","Main",{0:i});window.NeosCMS.Notification.ok(a),window.location.pathname="/neos"})).catch((function(e){if(window.NeosCMS){const e=window.NeosCMS.I18n.translate("impersonate.error.impersonateUser","Could not switch to the requested user.","Neos.Neos");window.NeosCMS.Notification.error(e)}}))}}var s=__webpack_require__(98),l=__webpack_require__(47),u=__webpack_require__.n(l),c=__webpack_require__(767),d=__webpack_require__(357),p=__webpack_require__(449);const cachedFetch=async e=>{const n=p.Z.getItem(e),r=(0,o.isNil)(n);if((0,o.isNil)(e)&&r)return!1;if(r){const n=await(async e=>{const n=await fetch(e);if(n.ok)return await n.json();throw new Error(`HTTP error! status: ${n.status}`)})(e);return p.Z.setItem(e,n),n}return n};window.jQuery=n(),window.$=n(),i.Wt.init(),i.VK.init(),i.P_.init(),i.WH.init();cachedFetch(i.VK.get("XliffUri")).then((e=>{e&&i.WH.initTranslations(e)})),document.addEventListener("DOMContentLoaded",(e=>{document.querySelectorAll(".neos-user-menu").forEach((e=>{new r.DropDownMenu(e)}));document.querySelectorAll(".neos-menu").forEach((e=>{new r.MenuPanel(e)}));document.querySelectorAll(".neos-tree-container").forEach((e=>{new c.Z(e)}));Array.from(document.querySelectorAll('[data-toggle="modal"]')).forEach((e=>{const n=document.querySelector(e.getAttribute("href"));(0,o.isNil)(n)||new d.Z(n)}));document.querySelectorAll("[data-neos-expandable=dropdown]").forEach((e=>{new s.default(e)}));document.querySelectorAll("[data-neos-expandable=dropdown-group]").forEach((e=>{new(u())(e)}));const n=document.querySelector(".neos-module-administration-users");(0,o.isNil)(n)||Array.from(n.querySelectorAll(".neos-table")).forEach((e=>{(0,o.isNil)(e)||new UserManagement(e)}));const i=document.querySelector("#neos-top-bar .neos-user-menu");(0,o.isNil)(i)||new r.UserMenu(i)}))})()})();

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Module/Administration/UserManagement.js
@@ -0,0 +1,65 @@
+import {isNil} from '../../Helper'
+import {ApiService} from '../../Services'
+import {ImpersonateButton} from '../../Templates/ImpersonateButton'
+const BASE_PATH = '/neos/impersonate/'
+export default class UserManagement {
+    constructor(_root) {
+        const csfrTokenField = document.querySelector('[data-csrf-token]')
+        this._root = _root
+        this._csrfToken = !isNil(csfrTokenField) ? csfrTokenField.getAttribute('data-csrf-token') : ''
+        console.log(this._csrfToken);
+        this._apiService = new ApiService(BASE_PATH, this._csrfToken)
+        if (!isNil(_root)) {
+            this._initialize()
+        }
+    }
+    _initialize() {
+        this._renderImpersonateButtons()
+        this._setupEventListeners()
+    }
+    _setupEventListeners() {
+        const impersonateButtons = this._root.querySelectorAll('button.impersonate-user')
+        impersonateButtons.forEach(_impersonateButton => {
+            _impersonateButton.addEventListener('click', this._impersonateUser.bind(this));
+        });
+    }
+    _renderImpersonateButtons() {
+        const userTableActionButtons = Array.from(this._root.querySelectorAll('.neos-table .neos-action'))
+        userTableActionButtons.forEach(_actionContainer => {
+            const deleteButton = _actionContainer.querySelector('button.neos-button-danger')
+            const showButton = _actionContainer.querySelector('a[href*="show"]')
+            if (isNil(showButton)) {
+                return false
+            }
+            const showButtonUri = new URL(decodeURIComponent(showButton.getAttribute('href')))
+            const showButtonUriParameter = new URLSearchParams(showButtonUri.search)
+            const userIdentifier = showButtonUriParameter.get('moduleArguments[user][__identity]')
+            const isCurrentUser = !isNil(deleteButton) && deleteButton.classList.contains('neos-disabled')
+            const impersonateButtonMarkup = ImpersonateButton(userIdentifier, isCurrentUser)
+            showButton.parentElement.innerHTML += impersonateButtonMarkup
+        })
+    }
+    _impersonateUser(event) {
+        event.preventDefault();
+        const button = event.currentTarget;
+        if (isNil(button)) {
+            return false
+        }
+        const identifier = button.getAttribute('data-user-identifier')
+        const response = this._apiService.callUserChange(identifier);
+        response
+            .then((data) => {
+                const {user, status} = data
+                const username = isNil(user) ? '' : user.accountIdentifier
+                const message = window.NeosCMS.I18n.translate('impersonate.success.impersonateUser', 'Switched to the new user {0}.', 'Neos.Neos', 'Main', {0: username})
+                window.NeosCMS.Notification.ok(message)
+                window.location.pathname = '/neos'
+            })
+            .catch(function (error) {
+                if (window.NeosCMS) {
+                    const message = window.NeosCMS.I18n.translate('impersonate.error.impersonateUser', 'Could not switch to the requested user.', 'Neos.Neos')
+                    window.NeosCMS.Notification.error(message)
+                }
+            });
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Module/Administration/index.js
@@ -0,0 +1,2 @@
+import UserManagement from './UserManagement'
+export { UserManagement }

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/ApiService.js
@@ -0,0 +1,54 @@
+import { isNil } from '../Helper'
+export default class ApiService {
+    constructor(_basePath, _csrfToken) {
+        if (isNil(_basePath)) {
+            let pathError = 'Tried to create API service without a base uri. '
+            pathError += 'Please initialize the API service with a base path '
+            pathError += 'like "/neos/impersonate/"'
+            console.error(pathError)
+        }
+        this._basePath = _basePath
+        if (isNil(_csrfToken)) {
+            let csrfError = 'Tried to create API service without a CSFR '
+            csrfError += 'token. Please initialize the API service with a token'
+            console.error(csrfError)
+        }
+        this._csrfToken = _csrfToken
+    }
+    async callUserChange(identifier) {
+        const data = {
+            user: identifier,
+            format: 'json',
+        }
+        const response = await fetch(this._basePath + 'user-change', {
+            method: 'POST',
+            credentials: 'include',
+            headers: this._getHeader(),
+            body: JSON.stringify(data),
+        })
+        return await response.json()
+    }
+    async callStatus() {
+        const response = await fetch(this._basePath + 'status', {
+            method: 'GET',
+            credentials: 'include',
+            headers: this._getHeader(),
+        })
+        return await response.json()
+    }
+    async callRestore() {
+        const response = await fetch(this._basePath + 'restore', {
+            method: 'POST',
+            credentials: 'include',
+            headers: this._getHeader(),
+        })
+        return await response.json()
+    }
+    _getHeader() {
+        return {
+            Accept: 'application/json',
+            'Content-Type': 'application/json',
+            'X-Flow-Csrftoken': this._csrfToken,
+        }
+    }
+}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/Configuration.js
@@ -0,0 +1,26 @@
+import { getCollectionValueByPath, isNil } from "../Helper";
+const hasConfiguration = !isNil(window.NeosCMS?.Configuration);
+const init = () => {
+  if (isNil(window.NeosCMS)) {
+    window.NeosCMS = {};
+  }
+  if (isNil(window.NeosCMS.Configuration)) {
+    window.NeosCMS.Configuration = {};
+  }
+  const xliffLink = document.querySelector('link[rel="neos-xliff"]');
+  if (!isNil(xliffLink)) {
+    window.NeosCMS.Configuration.XliffUri = xliffLink.getAttribute("href");
+  }
+};
+const get = (key) => {
+  if (!hasConfiguration) {
+    return null;
+  }
+  return getCollectionValueByPath(window.NeosCMS.Configuration, key);
+};
+const override = (key, value) => {
+  if (hasConfiguration && key in window.NeosCMS.Configuration) {
+    window.NeosCMS.Configuration[key] = value;
+  }
+};
+export default { init, get, override };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/Helper.js
@@ -0,0 +1,22 @@
+import {
+  isNil,
+  isEmpty,
+  getItemByKeyValue,
+  getCollectionValueByPath,
+  createCollectionByPath,
+} from "../Helper";
+const init = () => {
+  if (isNil(window.NeosCMS)) {
+    window.NeosCMS = {};
+  }
+  if (isNil(window.NeosCMS.Helper)) {
+    window.NeosCMS.Helper = {
+      isNil,
+      isEmpty,
+      getItemByKeyValue,
+      getCollectionValueByPath,
+      createCollectionByPath,
+    };
+  }
+};
+export default { init };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/Localization.js
@@ -0,0 +1,253 @@
+import i18next from "i18next";
+import {
+  isNil,
+  isEmpty,
+  getCollectionValueByPath,
+  createCollectionByPath,
+} from "../Helper";
+const DEFAULT_PACKAGE = "Neos.Neos";
+const DEFAULT_SOURCE = "Main";
+const EXISTING_NAMESPACES = [];
+/**
+ * Creates a namespace string from the neos package name and the source name.
+ * The package name and source name comes from the xliff data and uses underscores instead of dots.
+ *
+ * @param {string} packageName Package name separated by _ from the xliff data
+ * @param {string} sourceName Source name separated by _ from the xliff data
+ * @returns {string}
+ */
+const getTransformedNamespace = (packageName, sourceName) => {
+  const dottedPackageName = isEmpty(packageName)
+    ? DEFAULT_PACKAGE
+    : packageName.replace(/\_/g, ".");
+  const dottedSourceName = isEmpty(sourceName)
+    ? DEFAULT_SOURCE
+    : sourceName.replace(/\_/g, ".");
+  return dottedPackageName + "/" + dottedSourceName;
+};
+/**
+ * Creates a namespace string from the neos package name and the source name.
+ *
+ * @param {string} packageName Package name
+ * @param {string} sourceName Source name
+ * @returns {string}
+ */
+const getNamespace = (packageName, sourceName) => {
+  const dottedPackageName = isEmpty(packageName)
+    ? DEFAULT_PACKAGE
+    : packageName.trim();
+  const dottedSourceName = isEmpty(sourceName)
+    ? DEFAULT_SOURCE
+    : sourceName.trim();
+  return dottedPackageName + "/" + dottedSourceName;
+};
+/**
+ * Returns the used locale of the current xliff URI
+ *
+ * @returns {string}
+ */
+const getCurrentLanguage = () => {
+  const xliffUri = getCollectionValueByPath(
+    window.NeosCMS,
+    "Configuration.XliffUri"
+  );
+  if (isNil(xliffUri)) {
+    return "";
+  }
+  const parameter = new URL(xliffUri).searchParams;
+  return parameter.get("locale");
+};
+/**
+ * Set the initialised value for the I18n API.
+ * The parameter is available via window.NeosCMS.I18n.initialized
+ *
+ * @param {boolean} initialised
+ * @returns {void}
+ */
+const setInitialized = (initialised) => {
+  createCollectionByPath(
+    window,
+    "NeosCMS.I18n.initialized",
+    Boolean(initialised)
+  );
+};
+/**
+ * The xliff data saves plurals as arrays. The i18next library need a flatt structure in the labels.
+ * So we replace the arrays with new items and append to the label the index with a underscore.
+ *
+ * e.g.:
+ * "key": "singular",
+ * "key_plural": "plural",
+ *
+ * @param {object} translations
+ * @returns {object}
+ */
+const flattenPluralItems = (translations) => {
+  const translationKeys = Object.keys(translations);
+  translationKeys.forEach((key) => {
+    if (Array.isArray(translations[key])) {
+      translations[key].forEach((pluralItem, index) => {
+        let newKey = key;
+        if (Number.isInteger(index) && index === 1) {
+          newKey = `${key}_plural`;
+        }
+        translations[newKey] = pluralItem;
+      });
+    }
+  });
+  return translations;
+};
+/**
+ * Collect and define the existing namespaces for the language resources from the xliff data
+ *
+ * @param {object} xliffData JSON object with xliff data
+ * @returns {void}
+ */
+const initializeExistingNamespaces = (xliffData) => {
+  if (isNil(xliffData)) {
+    return false;
+  }
+  const packageNames = Object.keys(xliffData);
+  packageNames.forEach((packageName) => {
+    const Sources = Object.keys(xliffData[packageName]);
+    Sources.forEach((sourceName) => {
+      const namespace = getTransformedNamespace(packageName, sourceName);
+      const translations = xliffData[packageName][sourceName];
+      if (!isNil(translations)) {
+        EXISTING_NAMESPACES.push({ name: namespace, initialized: false });
+      }
+    });
+  });
+};
+/**
+ * Checks if we have language namespaces that has not been added to the i18next resources.
+ * Also fires the neoscms-i18n-initialized event when all resources are available.
+ *
+ * @returns {void}
+ */
+const checkInitialisedNamespaces = () => {
+  const hasNonInitializedNamespaces =
+    EXISTING_NAMESPACES.findIndex(
+      (namespace) => namespace.initialized === false
+    ) >= 0;
+  if (!hasNonInitializedNamespaces) {
+    setInitialized(true);
+    window.dispatchEvent(
+      new CustomEvent("neoscms-i18n-initialized", {
+        bubbles: true,
+      })
+    );
+  }
+  return !hasNonInitializedNamespaces;
+};
+/**
+ * Transforms the data structue of the xliff data to i18next namespaced resource bundles.
+ * Therefore we replace the underscores in the package and source name with dots.
+ *
+ * Every source in a package will be a i18next namespace. The namespace will be package-name/source
+ * e.g. "Neos.Neos/Main"
+ *
+ * @param {object} xliffData JSON object with xliff data
+ * @returns {void}
+ */
+const transformAndAppendXliffData = (xliffData) => {
+  const language = i18next.languages[0];
+  if (isNil(xliffData)) {
+    return false;
+  }
+  const packageNames = Object.keys(xliffData);
+  i18next.store.on("added", (lng, ns) => {
+    EXISTING_NAMESPACES.find((entry) => entry.name === ns)[
+      "initialized"
+    ] = true;
+    checkInitialisedNamespaces();
+  });
+  packageNames.forEach((packageName) => {
+    const Sources = Object.keys(xliffData[packageName]);
+    Sources.forEach((sourceName) => {
+      const namespace = getTransformedNamespace(packageName, sourceName);
+      const translations = xliffData[packageName][sourceName];
+      if (!isNil(translations)) {
+        i18next.addResourceBundle(
+          language,
+          namespace,
+          flattenPluralItems(translations),
+          true,
+          true
+        );
+      }
+    });
+  });
+};
+/**
+ * Returns a translated label.
+ *
+ * Replaces all placeholders with corresponding values if they exist in the
+ * translated label.
+ *
+ * @param {string} id Id to use for finding translation (trans-unit id in XLIFF)
+ * @param {string} fallback Fallback value in case the no label translation was found.
+ * @param {string} packageKey Target package key. If not set, the current package key will be used
+ * @param {string} source Name of file with translations
+ * @param {object} parameters Numerically indexed array of values to be inserted into placeholders
+ * @param {string} context
+ * @param {number} quantity
+ * @returns {string}
+ */
+const translate = (
+  id,
+  fallback,
+  packageKey,
+  source,
+  parameters,
+  context,
+  quantity
+) => {
+  id = id.replace(/\./g, "_");
+  const namespace = getNamespace(packageKey, source);
+  const identifier = namespace + ":" + id.trim();
+  let options = {};
+  if (!isNil(quantity)) {
+    options["count"] = quantity;
+  }
+  if (!isNil(parameters)) {
+    options["replace"] = parameters;
+  }
+  if (!isEmpty(fallback)) {
+    options["defaultValue"] = fallback;
+  }
+  return i18next.t(identifier, options);
+};
+const init = () => {
+  if (isNil(window.NeosCMS)) {
+    window.NeosCMS = {};
+  }
+  if (isNil(window.NeosCMS.I18n)) {
+    window.NeosCMS.I18n = {
+      init: init,
+      translate: translate,
+      initialized: false,
+    };
+  }
+};
+const initTranslations = (xliffData) => {
+  const options = {
+    interpolation: {
+      prefix: "{",
+      suffix: "}",
+    },
+    resources: {},
+  };
+  const currentLangauge = getCurrentLanguage();
+  if (!isEmpty(currentLangauge)) {
+    const languageOption = currentLangauge.match("[a-z]{2}(-[A-Z]{2})")
+      ? "lng"
+      : "fallbackLng";
+    options[languageOption] = currentLangauge;
+  }
+  initializeExistingNamespaces(xliffData);
+  i18next.init(options, (err, t) => {
+    transformAndAppendXliffData(xliffData);
+  });
+};
+export default { init, initTranslations, translate };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/Notification.js
@@ -0,0 +1,96 @@
+import Toast from "../Components/Notification/Toast";
+import { isNil } from "../Helper";
+const allowedTypes = ["ok", "info", "notice", "warning", "error"];
+const _renderNotification = (title, message, type, additionalOptions) => {
+  const options = { title: title, message: message, ...additionalOptions };
+  if (allowedTypes.includes(type)) {
+    options.type = type;
+  }
+  Toast.create(options);
+};
+/**
+ * Show ok notification
+ *
+ * @param {string} title
+ * @return {void}
+ */
+const ok = (title) => {
+  _renderNotification(title, "", "ok");
+};
+/**
+ * Show info notification
+ *
+ * @param {string} title
+ * @return {void}
+ */
+const info = (title) => {
+  _renderNotification(title, "", "info");
+};
+/**
+ * Show notice notification
+ *
+ * @param {string} title
+ * @return {void}
+ */
+const notice = (title) => {
+  _renderNotification(title, "", "notice");
+};
+/**
+ * Show warning notification
+ *
+ * @param {string} title
+ * @param {string} message
+ * @return {void}
+ */
+const warning = (title, message) => {
+  _renderNotification(title, message, "warning", {
+    timeout: 0,
+    closeButton: true,
+  });
+};
+/**
+ * Show error notification
+ *
+ * @param {string} title
+ * @param {string} message
+ * @return {void}
+ */
+const error = (title, message) => {
+  _renderNotification(title, message, "error", {
+    timeout: 0,
+    closeButton: true,
+  });
+};
+/**
+ * Clears all notifications
+ *
+ * @return {void}
+ */
+const clear = () => {
+  Toast.removeAll();
+};
+const init = () => {
+  if (isNil(window.NeosCMS)) {
+    window.NeosCMS = {};
+  }
+  if (isNil(window.NeosCMS.Notification)) {
+    window.NeosCMS.Notification = {
+      init: init,
+      ok: ok,
+      info: info,
+      notice: notice,
+      warning: warning,
+      error: error,
+      clear: clear,
+    };
+  }
+  const notifications = Array.from(
+    document.querySelectorAll("#neos-notifications-inline li")
+  );
+  notifications.forEach((notificationElement) => {
+    const type = notificationElement.getAttribute("data-type");
+    const title = notificationElement.textContent;
+    _renderNotification(title, "", type);
+  });
+};
+export default { init, ok, info, notice, warning, error, clear };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Services/index.js
@@ -0,0 +1,7 @@
+import Configuration from "./Configuration";
+import Notification from "./Notification";
+import Localization from "./Localization";
+import SessionStorage from "./SessionStorage";
+import ApiService from "./ApiService"
+import Helper from "./Helper";
+export { ApiService, Configuration, Notification, Localization, SessionStorage, Helper };

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Templates/ImpersonateButton.js
@@ -0,0 +1,23 @@
+import {isNil} from "../Helper"
+const impersonateIcon = '<i class="fas fa-random icon-white"></i>'
+const localizedTooltip = !isNil(window.Typo3Neos) ?
+    window.NeosCMS.I18n.translate('impersonate.tooltip.impersonateUserButton', 'Login as this user', 'Neos.Neos') :
+    'Login as this user';
+const ImpersonateButton = (identifier, disabled) => {
+    const attributesObject = {
+        'data-neos-toggle': 'tooltip',
+        'data-original-title': localizedTooltip,
+        'data-user-identifier': identifier,
+        class: 'neos-button neos-button-primary impersonate-user',
+    }
+    if (!isNil(disabled) && disabled === true) {
+        attributesObject.disabled = true
+        attributesObject.class += ' neos-disabled'
+    }
+    let attributes = ''
+    Object.keys(attributesObject).forEach(key => {
+        attributes += `${key}="${attributesObject[key]}" `
+    })
+    return `<button ${attributes}>${impersonateIcon}</button>`
+}
+export {ImpersonateButton}

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/Templates/RestoreButton.js
@@ -0,0 +1,22 @@
+import { isNil } from '../Helper'
+const impersonateIcon = '<i class="fas fa-random icon-white"></i>'
+const RestoreButton = (user) => {
+    const attributesObject = {
+        class: 'neos-button restore-user',
+    }
+    let attributes = ''
+    Object.keys(attributesObject).forEach((key) => {
+        attributes += `${key}="${attributesObject[key]}" `
+    })
+    const restoreLabel = isNil(window.NeosCMS)
+        ? window.NeosCMS.I18n.translate(
+            'impersonate.label.restoreUserButton',
+            'Back to user "{0}"',
+            'Neos.Neos',
+            'Main',
+            user.accountIdentifier
+        )
+        : `Restore user "${user.accountIdentifier}"`
+    return `<button ${attributes}>${impersonateIcon} ${restoreLabel}</button>`
+}
+export { RestoreButton }

--- a//dev/null
+++ b/Neos.Neos/Resources/Public/JavaScript/index.js
@@ -0,0 +1,72 @@
+import jQuery from "jquery";
+import { DropDownMenu, MenuPanel, UserMenu } from "./Components/TopBar";
+import { UserManagement } from './Module/Administration'
+import DropDown from "./Components/DropDown";
+import DropDownGroup from "./Components/DropDownGroup";
+import Tree from "./Components/Tree";
+import Modal from "./Components/Modal";
+import { Configuration, Notification, Localization, Helper } from "./Services";
+import { cachedFetch } from "./Services/ResourceCache";
+import { isNil } from "./Helper";
+window.jQuery = jQuery;
+window.$ = jQuery;
+Helper.init();
+Configuration.init();
+Notification.init();
+Localization.init();
+cachedFetch(Configuration.get("XliffUri")).then((xliffData) => {
+  if (xliffData) {
+    Localization.initTranslations(xliffData);
+  }
+});
+document.addEventListener("DOMContentLoaded", (event) => {
+  const dropDownMenuElements = document.querySelectorAll(".neos-user-menu");
+  dropDownMenuElements.forEach((dropDownElement) => {
+    new DropDownMenu(dropDownElement);
+  });
+  const menuPanelElements = document.querySelectorAll(".neos-menu");
+  menuPanelElements.forEach((panelElement) => {
+    new MenuPanel(panelElement);
+  });
+  const treeElements = document.querySelectorAll(".neos-tree-container");
+  treeElements.forEach((treeElement) => {
+    new Tree(treeElement);
+  });
+  const modalTrigger = Array.from(
+    document.querySelectorAll('[data-toggle="modal"]')
+  );
+  modalTrigger.forEach((_modalTrigger) => {
+    const modalElement = document.querySelector(
+      _modalTrigger.getAttribute("href")
+    );
+    if (!isNil(modalElement)) {
+      new Modal(modalElement);
+    }
+  });
+  const expandableElements = document.querySelectorAll(
+    "[data-neos-expandable=dropdown]"
+  );
+  expandableElements.forEach((expandableElement) => {
+    new DropDown(expandableElement);
+  });
+  const expandableGroupElements = document.querySelectorAll(
+    "[data-neos-expandable=dropdown-group]"
+  );
+  expandableGroupElements.forEach((expandableElement) => {
+    new DropDownGroup(expandableElement);
+  });
+  const userModuleContainer = document.querySelector('.neos-module-administration-users');
+  if (!isNil(userModuleContainer)) {
+    Array.from(userModuleContainer.querySelectorAll('.neos-table')).forEach(
+        (_userModule) => {
+          if (!isNil(_userModule)) {
+            new UserManagement(_userModule);
+          }
+        }
+    )
+  }
+  const userMenuContainer = document.querySelector('#neos-top-bar .neos-user-menu');
+  if (!isNil(userMenuContainer)) {
+    new UserMenu(userMenuContainer);
+  }
+});
