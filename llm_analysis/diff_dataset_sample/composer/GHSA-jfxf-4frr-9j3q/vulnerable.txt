# ====================================================================
# FILE: Neos.CliSetup/Classes/Command/WelcomeCommandController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\CliSetup\Command;
     4| /*
     5|  * This file is part of the Neos.CliSetup package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\Cli\CommandController;
    15| /**
    16|  * @Flow\Scope("singleton")
    17|  */
    18| class WelcomeCommandController extends CommandController
    19| {
    20|     public function indexCommand(): void
    21|     {
    22|         $this->output(
    23|             <<<EOT
    24|             <info>
    25|                 ....######          .######
    26|                 .....#######      ...######
    27|                 .......#######   ....######
    28|                 .........####### ....######
    29|                 ....#......#######...######
    30|                 ....##.......#######.######
    31|                 ....#####......############
    32|                 ....#####  ......##########
    33|                 ....#####    ......########
    34|                 ....#####      ......######
    35|                 .#######         ........
    36|             Welcome to Neos.
    37|             </info>
    38|             The following steps will help you to configure Neos:
    39|             1. Configure the database connection:
    40|                <info>./flow setup:database</info>
    41|             2. Create the required database tables:
    42|                <info>./flow doctrine:migrate</info>
    43|             3. Configure the image handler:
    44|                <info>./flow setup:imagehandler</info>
    45|             4. Create an admin user:
    46|                <info>./flow user:create --roles Administrator username password firstname lastname </info>
    47|             5. Create your own site package or require an existing one (choose one option):
    48|                - <info>./flow kickstart:site Vendor.Site</info>
    49|                - <info>composer require neos/demo && ./flow flow:package:rescan</info>
    50|             6. Import a site or create an empty one (choose one option):
    51|                - <info>./flow site:import Neos.Demo</info>
    52|                - <info>./flow site:import Vendor.Site</info>
    53|                - <info>./flow site:create sitename Vendor.Site Vendor.Site:Document.HomePage</info>
    54|             EOT
    55|         );
    56|     }
    57| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Command/NodeCommandControllerPlugin.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-1222 ---
     1| <?php
     2| namespace Neos\ContentRepository\Command;
     3| /*
     4|  * This file is part of the Neos.ContentRepository package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Doctrine\ORM\EntityManagerInterface;
    13| use Doctrine\ORM\EntityNotFoundException;
    14| use Doctrine\Persistence\Proxy;
    15| use Doctrine\ORM\QueryBuilder;
    16| use Neos\ContentRepository\Exception\NodeConfigurationException;
    17| use Neos\ContentRepository\Exception\NodeException;
    18| use Neos\Flow\Annotations as Flow;
    19| use Neos\Flow\Cli\ConsoleOutput;
    20| use Neos\Flow\Persistence\PersistenceManagerInterface;
    21| use Neos\Flow\Property\Exception as PropertyException;
    22| use Neos\Flow\Property\PropertyMapper;
    23| use Neos\Flow\Security\Exception as SecurityException;
    24| use Neos\Utility\Arrays;
    25| use Neos\ContentRepository\Domain\Factory\NodeFactory;
    26| use Neos\ContentRepository\Domain\Model\Node;
    27| use Neos\ContentRepository\Domain\Model\NodeData;
    28| use Neos\ContentRepository\Domain\Model\NodeInterface;
    29| use Neos\ContentRepository\Domain\Model\NodeType;
    30| use Neos\ContentRepository\Domain\Model\Workspace;
    31| use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
    32| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    33| use Neos\ContentRepository\Domain\Service\ContentDimensionCombinator;
    34| use Neos\ContentRepository\Domain\Service\Context;
    35| use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
    36| use Neos\ContentRepository\Domain\Service\NodeTypeManager;
    37| use Neos\ContentRepository\Exception\NodeTypeNotFoundException;
    38| use Neos\ContentRepository\Utility;
    39| /**
    40|  * Plugin for the ContentRepository NodeCommandController which provides functionality for creating missing child nodes.
    41|  *
    42|  * @Flow\Scope("singleton")
    43|  */
    44| class NodeCommandControllerPlugin implements EventDispatchingNodeCommandControllerPluginInterface
    45| {
    46|     /**
    47|      * @Flow\Inject
    48|      * @var ContextFactoryInterface
    49|      */
    50|     protected $contextFactory;
    51|     /**
    52|      * @Flow\Inject
    53|      * @var NodeTypeManager
    54|      */
    55|     protected $nodeTypeManager;
    56|     /**
    57|      * @Flow\Inject
    58|      * @var WorkspaceRepository
    59|      */
    60|     protected $workspaceRepository;
    61|     /**
    62|      * @Flow\Inject
    63|      * @var NodeFactory
    64|      */
    65|     protected $nodeFactory;
    66|     /**
    67|      * @var ConsoleOutput
    68|      * @deprecated It's discouraged to interact with the console output directly. Instead use the event dispatching. @see dispatch()
    69|      */
    70|     protected $output;
    71|     /**
    72|      * @Flow\Inject
    73|      * @var NodeDataRepository
    74|      */
    75|     protected $nodeDataRepository;
    76|     /**
    77|      * @Flow\Inject
    78|      * @var EntityManagerInterface
    79|      */
    80|     protected $entityManager;
    81|     /**
    82|      * @Flow\Inject
    83|      * @var PropertyMapper
    84|      */
    85|     protected $propertyMapper;
    86|     /**
    87|      * @var array
    88|      */
    89|     protected $pluginConfigurations = [];
    90|     /**
    91|      * @var ContentDimensionCombinator
    92|      * @Flow\Inject
    93|      */
    94|     protected $contentDimensionCombinator;
    95|     /**
    96|      * @Flow\Inject
    97|      * @var PersistenceManagerInterface
    98|      */
    99|     protected $persistenceManager;
   100|     /**
   101|      * Callbacks to be invoked when an event is triggered
   102|      *
   103|      * @see dispatch()
   104|      * @var \Closure[]
   105|      */
   106|     protected $eventCallbacks;
   107|     /**
   108|      * Returns a short description
   109|      *
   110|      * @param string $controllerCommandName Name of the command in question, for example "repair"
   111|      * @return string A piece of text to be included in the overall description of the node:xy command
   112|      */
   113|     public static function getSubCommandShortDescription($controllerCommandName)
   114|     {
   115|         switch ($controllerCommandName) {
   116|             case 'repair':
   117|                 return 'Run checks for basic node integrity in the content repository';
   118|         }
   119|         return '';
   120|     }
   121|     /**
   122|      * Returns a piece of description for the specific task the plugin solves for the specified command
   123|      *
   124|      * @param string $controllerCommandName Name of the command in question, for example "repair"
   125|      * @return string A piece of text to be included in the overall description of the node:xy command
   126|      */
   127|     public static function getSubCommandDescription($controllerCommandName)
   128|     {
   129|         switch ($controllerCommandName) {
   130|             case 'repair':
   131|                 return <<<'HELPTEXT'
   132| <u>Remove abstract and undefined node types</u>
   133| removeAbstractAndUndefinedNodes
   134| Will remove all nodes that has an abstract or undefined node type.
   135| <u>Remove orphan (parentless) nodes</u>
   136| removeOrphanNodes
   137| Will remove all child nodes that do not have a connection to the root node.
   138| <u>Remove disallowed child nodes</u>
   139| removeDisallowedChildNodes
   140| Will remove all child nodes that are disallowed according to the node type's auto-create
   141| configuration and constraints.
   142| <u>Remove undefined node properties</u>
   143| removeUndefinedProperties
   144| <u>Remove broken object references</u>
   145| removeBrokenEntityReferences
   146| Detects and removes references from nodes to entities which don't exist anymore (for
   147| example Image nodes referencing ImageVariant objects which are gone for some reason).
   148| Will remove all undefined properties according to the node type configuration.
   149| <u>Remove nodes with invalid dimensions</u>
   150| removeNodesWithInvalidDimensions
   151| Will check for and optionally remove nodes which have dimension values not matching
   152| the current content dimension configuration.
   153| <u>Remove nodes with invalid workspace</u>
   154| removeNodesWithInvalidWorkspace
   155| Will check for and optionally remove nodes which belong to a workspace which no longer
   156| exists..
   157| <u>Repair inconsistent node identifiers</u>
   158| fixNodesWithInconsistentIdentifier
   159| Will check for and optionally repair node identifiers which are out of sync with their
   160| corresponding nodes in a live workspace.
   161| <u>Missing child nodes</u>
   162| createMissingChildNodes
   163| For all nodes (or only those which match the --node-type filter specified with this
   164| command) which currently don't have child nodes as configured by the node type's
   165| configuration new child nodes will be created.
   166| <u>Reorder child nodes</u>
   167| reorderChildNodes
   168| For all nodes (or only those which match the --node-type filter specified with this
   169| command) which have configured child nodes, those child nodes are reordered according to the
   170| position from the parents NodeType configuration.
   171| <u>Missing default properties</u>
   172| addMissingDefaultValues
   173| For all nodes (or only those which match the --node-type filter specified with this
   174| command) which currently don\t have a property that have a default value configuration
   175| the default value for that property will be set.
   176| <u>Repair nodes with missing shadow nodes</u>
   177| repairShadowNodes
   178| This will reconstruct missing shadow nodes in case something went wrong in creating
   179| or publishing them. This must be used on a workspace other than live.
   180| It searches for nodes which have a corresponding node in one of the base workspaces,
   181| have different node paths, but don't have a corresponding shadow node with a "movedto"
   182| value.
   183| HELPTEXT;
   184|         }
   185|         return '';
   186|     }
   187|     /**
   188|      * A method which runs the task implemented by the plugin for the given command
   189|      *
   190|      * @param string $controllerCommandName Name of the command in question, for example "repair"
   191|      * @param ConsoleOutput $output (unused)
   192|      * @param NodeType $nodeType Only handle this node type (if specified)
   193|      * @param string $workspaceName Only handle this workspace (if specified)
   194|      * @param boolean $dryRun If true, don't do any changes, just simulate what you would do
   195|      * @param boolean $cleanup If false, cleanup tasks are skipped
   196|      * @param string $skip Skip the given check or checks (comma separated)
   197|      * @param string $only Only execute the given check or checks (comma separated)
   198|      * @return void
   199|      */
   200|     public function invokeSubCommand($controllerCommandName, ConsoleOutput $output, NodeType $nodeType = null, $workspaceName = 'live', $dryRun = false, $cleanup = true, $skip = null, $only = null)
   201|     {
   202|         /** @noinspection PhpDeprecationInspection This is only set for backwards compatibility */
   203|         $this->output = $output;
   204|         $commandMethods = [
   205|             'removeAbstractAndUndefinedNodes' => [ 'cleanup' => true ],
   206|             'removeOrphanNodes' => [ 'cleanup' => true ],
   207|             'removeDisallowedChildNodes' => [ 'cleanup' => true ],
   208|             'removeUndefinedProperties' => [ 'cleanup' => true ],
   209|             'removeBrokenEntityReferences' => [ 'cleanup' => true ],
   210|             'removeNodesWithInvalidDimensions' => [ 'cleanup' => true ],
   211|             'removeNodesWithInvalidWorkspace' => [ 'cleanup' => true ],
   212|             'fixNodesWithInconsistentIdentifier' => [ 'cleanup' => false ],
   213|             'createMissingChildNodes' => [ 'cleanup' => false ],
   214|             'reorderChildNodes' => [ 'cleanup' => false ],
   215|             'addMissingDefaultValues' => [ 'cleanup' => false ],
   216|             'repairShadowNodes' => [ 'cleanup' => false ]
   217|         ];
   218|         $skipCommandNames = Arrays::trimExplode(',', ($skip === null ? '' : $skip));
   219|         $onlyCommandNames = Arrays::trimExplode(',', ($only === null ? '' : $only));
   220|         switch ($controllerCommandName) {
   221|             case 'repair':
   222|                 foreach ($commandMethods as $commandMethodName => $commandMethodConfiguration) {
   223|                     if (in_array($commandMethodName, $skipCommandNames)) {
   224|                         continue;
   225|                     }
   226|                     if ($onlyCommandNames !== [] && !in_array($commandMethodName, $onlyCommandNames)) {
   227|                         continue;
   228|                     }
   229|                     if (!$cleanup && $commandMethodConfiguration['cleanup']) {
   230|                         continue;
   231|                     }
   232|                     $this->$commandMethodName($workspaceName, $dryRun, $nodeType);
   233|                 }
   234|         }
   235|     }
   236|     /**
   237|      * Performs checks for missing child nodes according to the node's auto-create configuration and creates
   238|      * them if necessary.
   239|      *
   240|      * @param string $workspaceName Name of the workspace to consider
   241|      * @param boolean $dryRun Simulate?
   242|      * @param NodeType $nodeType Only for this node type, if specified
   243|      * @return void
   244|      * @throws NodeConfigurationException
   245|      * @throws NodeTypeNotFoundException
   246|      */
   247|     protected function createMissingChildNodes($workspaceName, $dryRun, NodeType $nodeType = null)
   248|     {
   249|         if ($nodeType !== null) {
   250|             $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type "<i>%s</i>" for missing child nodes ...', $nodeType->getName()));
   251|             $this->createChildNodesByNodeType($nodeType, $workspaceName, $dryRun);
   252|         } else {
   253|             $this->dispatch(self::EVENT_NOTICE, 'Checking for missing child nodes ...');
   254|             foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
   255|                 /** @var NodeType $nodeType */
   256|                 if ($nodeType->isAbstract()) {
   257|                     continue;
   258|                 }
   259|                 $this->createChildNodesByNodeType($nodeType, $workspaceName, $dryRun);
   260|             }
   261|         }
   262|         $this->persistenceManager->persistAll();
   263|     }
   264|     /**
   265|      * Create missing child nodes for the given node type
   266|      *
   267|      * @param NodeType $nodeType
   268|      * @param string $workspaceName
   269|      * @param boolean $dryRun
   270|      * @return void
   271|      * @throws NodeTypeNotFoundException
   272|      * @throws NodeConfigurationException
   273|      */
   274|     protected function createChildNodesByNodeType(NodeType $nodeType, $workspaceName, $dryRun)
   275|     {
   276|         $createdNodesCount = 0;
   277|         $updatedNodesCount = 0;
   278|         $incorrectNodeTypeCount = 0;
   279|         $nodeCreationExceptions = 0;
   280|         $nodeIdentifiersWhichNeedUpdate = [];
   281|         $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
   282|         $nodeTypes[$nodeType->getName()] = $nodeType;
   283|         if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
   284|             $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
   285|             $nodeTypeNames[$nodeType->getName()] = $nodeType;
   286|         } else {
   287|             $this->dispatch(self::EVENT_ERROR, sprintf('Node type "<i>%s</i>" does not exist', (string)$nodeType));
   288|             return;
   289|         }
   290|         /** @var $nodeType NodeType */
   291|         foreach ($nodeTypes as $nodeTypeName => $nodeType) {
   292|             $childNodes = $nodeType->getAutoCreatedChildNodes();
   293|             if (count($childNodes) === 0) {
   294|                 continue;
   295|             }
   296|             foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
   297|                 $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
   298|                 $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
   299|                 if (!$node instanceof NodeInterface) {
   300|                     continue;
   301|                 }
   302|                 foreach ($childNodes as $childNodeName => $childNodeType) {
   303|                     $childNode = $node->getNode($childNodeName);
   304|                     $childNodeIdentifier = Utility::buildAutoCreatedChildNodeIdentifier($childNodeName, $node->getIdentifier());
   305|                     if ($childNode === null) {
   306|                         $taskDescription = sprintf('Add node <i>%s</i> named "<i>%s</i>" in "<i>%s</i>"', $childNodeIdentifier, $childNodeName, $node->getPath());
   307|                         $taskClosure = function () use ($node, $childNodeName, $childNodeType, $childNodeIdentifier, &$nodeCreationExceptions) {
   308|                             try {
   309|                                 $node->createNode($childNodeName, $childNodeType, $childNodeIdentifier);
   310|                             } catch (\Exception $exception) {
   311|                                 $this->dispatch(self::EVENT_WARNING, sprintf('Could not create node named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $childNodeName, $node->getPath(), $exception->getMessage()));
   312|                                 $nodeCreationExceptions++;
   313|                             }
   314|                         };
   315|                         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
   316|                         $createdNodesCount++;
   317|                     } elseif ($childNode->isRemoved() === true) {
   318|                         $taskDescription = sprintf('Undelete node <i>%s</i> named "<i>%s</i>" in "<i>%s</i>"', $childNodeIdentifier, $childNodeName, $node->getPath());
   319|                         $taskClosure = function () use ($node) {
   320|                             $node->setRemoved(false);
   321|                         };
   322|                         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
   323|                         $createdNodesCount++;
   324|                     } elseif ($childNode->getIdentifier() !== $childNodeIdentifier) {
   325|                         $nodeIdentifiersWhichNeedUpdate[$childNode->getIdentifier()] = $childNodeIdentifier;
   326|                     } elseif ($childNode->getNodeType() !== $childNodeType) {
   327|                         $taskDescription = sprintf('Set node type of node <i>%s</i>: <i>%s</i> => <i>%s</i>', $childNodeIdentifier, $childNode->getNodeType(), $childNodeType);
   328|                         $taskClosure = function () use ($childNode, $childNodeType) {
   329|                             $childNode->setNodeType($childNodeType);
   330|                         };
   331|                         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
   332|                         $incorrectNodeTypeCount++;
   333|                     }
   334|                 }
   335|             }
   336|         }
   337|         foreach ($nodeIdentifiersWhichNeedUpdate as $oldNodeIdentifier => $newNodeIdentifier) {
   338|             $taskDescription = sprintf('Update node identifier from <i>%s</i> to <i>%s</i> because it is not a "stable" identifier', $oldNodeIdentifier, $newNodeIdentifier);
   339|             $taskClosure = function () use ($oldNodeIdentifier, $newNodeIdentifier) {
   340|                 $queryBuilder = $this->entityManager->createQueryBuilder();
   341|                 $queryBuilder->update(NodeData::class, 'n')
   342|                     ->set('n.identifier', $queryBuilder->expr()->literal($newNodeIdentifier))
   343|                     ->where('n.identifier = :oldNodeIdentifier')
   344|                     ->setParameter('oldNodeIdentifier', $oldNodeIdentifier);
   345|                 $queryBuilder->getQuery()->getResult();
   346|             };
   347|             $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
   348|             $updatedNodesCount++;
   349|         }
   350|         if ($createdNodesCount !== 0 || $nodeCreationExceptions !== 0 || $updatedNodesCount !== 0 || $incorrectNodeTypeCount !== 0) {
   351|             if ($dryRun === false) {
   352|                 if ($createdNodesCount > 0) {
   353|                     $this->dispatch(self::EVENT_NOTICE, sprintf('Created <i>%d</i> new child nodes', $createdNodesCount));
   354|                 }
   355|                 if ($updatedNodesCount > 0) {
   356|                     $this->dispatch(self::EVENT_NOTICE, sprintf('Updated identifier of <i>%d</i> child nodes', $updatedNodesCount));
   357|                 }
   358|                 if ($incorrectNodeTypeCount > 0) {
   359|                     $this->dispatch(self::EVENT_NOTICE, sprintf('Changed node type of <i>%d</i> child nodes', $incorrectNodeTypeCount));
   360|                 }
   361|                 if ($nodeCreationExceptions > 0) {
   362|                     $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> Errors occurred during child node creation', $nodeCreationExceptions));
   363|                 }
   364|                 $this->persistenceManager->persistAll();
   365|             } else {
   366|                 if ($createdNodesCount > 0) {
   367|                     $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> missing child nodes need to be created', $createdNodesCount));
   368|                 }
   369|                 if ($updatedNodesCount > 0) {
   370|                     $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> identifiers of child nodes need to be updated', $updatedNodesCount));
   371|                 }
   372|                 if ($incorrectNodeTypeCount > 0) {
   373|                     $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> child nodes have incorrect node type', $incorrectNodeTypeCount));
   374|                 }
   375|             }
   376|         }
   377|     }
   378|     /**
   379|      * Performs checks for unset properties that has default values and sets them if necessary.
   380|      *
   381|      * @param string $workspaceName Name of the workspace to consider
   382|      * @param boolean $dryRun Simulate?
   383|      * @param NodeType $nodeType Only for this node type, if specified
   384|      * @return void
   385|      * @throws NodeConfigurationException
   386|      * @throws NodeTypeNotFoundException
   387|      */
   388|     public function addMissingDefaultValues($workspaceName, $dryRun, NodeType $nodeType = null)
   389|     {
   390|         if ($nodeType !== null) {
   391|             $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type <i>%s</i> for missing default values ...', $nodeType));
   392|             $this->addMissingDefaultValuesByNodeType($nodeType, $workspaceName, $dryRun);
   393|         } else {
   394|             $this->dispatch(self::EVENT_NOTICE, 'Checking for missing default values ...');
   395|             foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
   396|                 /** @var NodeType $nodeType */
   397|                 if ($nodeType->isAbstract()) {
   398|                     continue;
   399|                 }
   400|                 $this->addMissingDefaultValuesByNodeType($nodeType, $workspaceName, $dryRun);
   401|             }
   402|         }
   403|     }
   404|     /**
   405|      * Adds missing default values for the given node type
   406|      *
   407|      * @param NodeType $nodeType
   408|      * @param string $workspaceName
   409|      * @param boolean $dryRun
   410|      * @return void
   411|      * @throws NodeConfigurationException
   412|      * @throws NodeTypeNotFoundException
   413|      */
   414|     public function addMissingDefaultValuesByNodeType(NodeType $nodeType, $workspaceName, $dryRun)
   415|     {
   416|         $addedMissingDefaultValuesCount = 0;
   417|         $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
   418|         $nodeTypes[$nodeType->getName()] = $nodeType;
   419|         if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
   420|             $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
   421|             $nodeTypeNames[$nodeType->getName()] = $nodeType;
   422|         } else {
   423|             $this->dispatch(self::EVENT_ERROR, sprintf('Node type <i>%s</i> does not exist', $nodeType));
   424|             return;
   425|         }
   426|         /** @var $nodeType NodeType */
   427|         foreach ($nodeTypes as $nodeTypeName => $nodeType) {
   428|             $defaultValues = $nodeType->getDefaultValuesForProperties();
   429|             foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
   430|                 /** @var NodeData $nodeData */
   431|                 $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
   432|                 $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
   433|                 if (!$node instanceof NodeInterface) {
   434|                     continue;
   435|                 }
   436|                 if ($node instanceof Node && !$node->dimensionsAreMatchingTargetDimensionValues()) {
   437|                     if ($node->getNodeData()->getDimensionValues() === []) {
   438|                         $this->dispatch(self::EVENT_NOTICE, sprintf('Skipping node <i>%s</i> because it has no dimension values set', $node->getPath()));
   439|                     } else {
   440|                         $this->dispatch(self::EVENT_NOTICE, sprintf('Skipping node <i>%s</i> because it has invalid dimension values: %s', $node->getPath(), json_encode($node->getNodeData()->getDimensionValues())));
   441|                     }
   442|                     continue;
   443|                 }
   444|                 foreach ($defaultValues as $propertyName => $defaultValue) {
   445|                     if ($propertyName[0] === '_' || $node->hasProperty($propertyName)) {
   446|                         continue;
   447|                     }
   448|                     $taskDescription = sprintf('Set default value for property named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $propertyName, $node->getPath(), $node->getNodeType()->getName());
   449|                     $taskClosure = function () use ($node, $propertyName, $defaultValue) {
   450|                         $node->setProperty($propertyName, $defaultValue);
   451|                     };
   452|                     $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
   453|                     $addedMissingDefaultValuesCount++;
   454|                 }
   455|             }
   456|         }
   457|         if ($addedMissingDefaultValuesCount !== 0) {
   458|             if ($dryRun === false) {
   459|                 $this->persistenceManager->persistAll();
   460|                 $this->dispatch(self::EVENT_NOTICE, sprintf('Added <i>%d</i> new default values', $addedMissingDefaultValuesCount));
   461|             } else {
   462|                 $this->dispatch(self::EVENT_NOTICE, sprintf('<i>%d</i> missing default values need to be set', $addedMissingDefaultValuesCount));
   463|             }
   464|         }
   465|     }
   466|     /**
   467|      * Performs checks for nodes with abstract or undefined node types and removes them if found.
   468|      *
   469|      * @param string $workspaceName
   470|      * @return void
   471|      */
   472|     protected function removeAbstractAndUndefinedNodes($workspaceName)
   473|     {
   474|         $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with abstract or undefined node types ...');
   475|         $abstractNodeTypes = [];
   476|         $nonAbstractNodeTypes = [];
   477|         foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
   478|             /** @var NodeType $nodeType */
   479|             if ($nodeType->isAbstract()) {
   480|                 $abstractNodeTypes[] = $nodeType->getName();
   481|             } else {
   482|                 $nonAbstractNodeTypes[] = $nodeType->getName();
   483|             }
   484|         }
   485|         /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
   486|         $queryBuilder = $this->entityManager->createQueryBuilder();
   487|         $queryBuilder
   488|             ->select('n')
   489|             ->distinct()
   490|             ->from(NodeData::class, 'n')
   491|             ->where('n.nodeType NOT IN (:excludeNodeTypes)')
   492|             ->setParameter('excludeNodeTypes', $nonAbstractNodeTypes)
   493|             ->andWhere('n.workspace = :workspace')
   494|             ->setParameter('workspace', $workspaceName);
   495|         $nodes = $queryBuilder->getQuery()->getArrayResult();
   496|         $removableNodesCount = count($nodes);
   497|         if ($removableNodesCount === 0) {
   498|             return;
   499|         }
   500|         foreach ($nodes as $node) {
   501|             $name = $node['path'] === '/' ? '' : substr($node['path'], strrpos($node['path'], '/') + 1);
   502|             $type = in_array($node['nodeType'], $abstractNodeTypes) ? 'abstract' : 'undefined';
   503|             $this->dispatch(self::EVENT_NOTICE, sprintf('Found node with %s node type named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>"', $type, $name, $node['nodeType'], $node['path']));
   504|         }
   505|         $taskDescription = sprintf('Remove <i>%d</i> node%s with abstract or undefined node types', $removableNodesCount, $removableNodesCount > 1 ? 's' : '');
   506|         $taskClosure = function () use ($nodes) {
   507|             foreach ($nodes as $node) {
   508|                 $this->removeNode($node['identifier'], $node['dimensionsHash']);
   509|             }
   510|         };
   511|         $taskRequiresConfirmation = true;
   512|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   513|     }
   514|     /**
   515|      * Performs checks for disallowed child nodes according to the node's auto-create configuration and constraints
   516|      * and removes them if found.
   517|      *
   518|      * @param string $workspaceName
   519|      * @return void
   520|      */
   521|     protected function removeDisallowedChildNodes($workspaceName)
   522|     {
   523|         $this->dispatch(self::EVENT_NOTICE, 'Checking for disallowed child nodes ...');
   524|         /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
   525|         $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
   526|         $nodes = [];
   527|         $nodeExceptionCount = 0;
   528|         $removeDisallowedChildNodes = function (NodeInterface $node) use (&$removeDisallowedChildNodes, &$nodes, &$nodeExceptionCount) {
   529|             try {
   530|                 foreach ($node->getChildNodes() as $childNode) {
   531|                     /** @var $childNode NodeInterface */
   532|                     if (!$childNode->isAutoCreated() && !$node->isNodeTypeAllowedAsChildNode($childNode->getNodeType())) {
   533|                         $nodes[] = $childNode;
   534|                         $parent = $node->isAutoCreated() ? $node->getParent() : $node;
   535|                         $this->dispatch(self::EVENT_NOTICE, sprintf('Found disallowed node named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>", child of node "<i>%s</i>" (<i>%s</i>)', $childNode->getName(), $childNode->getNodeType()->getName(), $childNode->getPath(), $parent->getName(), $parent->getNodeType()->getName()));
   536|                     } else {
   537|                         $removeDisallowedChildNodes($childNode);
   538|                     }
   539|                 }
   540|             } catch (\Exception $exception) {
   541|                 $this->dispatch(self::EVENT_WARNING, sprintf('Error while traversing child nodes of node <i>%s</i>: %s (%s)', $node->getIdentifier(), $exception->getMessage(), $exception->getCode()));
   542|                 $nodeExceptionCount++;
   543|             }
   544|         };
   545|         foreach ($this->contentDimensionCombinator->getAllAllowedCombinations() as $dimensionConfiguration) {
   546|             $context = $this->createContext($workspace->getName(), $dimensionConfiguration);
   547|             $removeDisallowedChildNodes($context->getRootNode());
   548|             $context->getFirstLevelNodeCache()->flush();
   549|             $this->nodeFactory->reset();
   550|         }
   551|         $disallowedChildNodesCount = count($nodes);
   552|         if ($disallowedChildNodesCount > 0) {
   553|             $taskDescription = sprintf('Remove <i>%d</i> disallowed node%s.', $disallowedChildNodesCount, $disallowedChildNodesCount > 1 ? 's' : '');
   554|             $taskClosure = function () use ($nodes, $workspaceName) {
   555|                 foreach ($nodes as $node) {
   556|                     $this->removeNodeAndChildNodesInWorkspaceByPath($node->getPath(), $workspaceName);
   557|                 }
   558|             };
   559|             $taskRequiresConfirmation = true;
   560|             $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   561|             if ($nodeExceptionCount > 0) {
   562|                 $this->dispatch(self::EVENT_NOTICE, '<i>%d</i> error%s occurred during child node traversing.', $nodeExceptionCount, $nodeExceptionCount > 1 ? 's' : '');
   563|             }
   564|         }
   565|     }
   566|     /**
   567|      * Performs checks for orphan nodes removes them if found.
   568|      *
   569|      * @param string $workspaceName
   570|      * @param boolean $dryRun (unused)
   571|      * @param NodeType $nodeType Only for this node type, if specified
   572|      * @return void
   573|      */
   574|     protected function removeOrphanNodes($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
   575|     {
   576|         $this->dispatch(self::EVENT_NOTICE, 'Checking for orphan nodes ...');
   577|         /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
   578|         $queryBuilder = $this->entityManager->createQueryBuilder();
   579|         $workspaceList = [];
   580|         /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
   581|         $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
   582|         while ($workspace !== null) {
   583|             $workspaceList[] = $workspace->getName();
   584|             $workspace = $workspace->getBaseWorkspace();
   585|         }
   586|         $query = $queryBuilder
   587|             ->select('n')
   588|             ->from(NodeData::class, 'n')
   589|             ->leftJoin(
   590|                 NodeData::class,
   591|                 'n2',
   592|                 \Doctrine\ORM\Query\Expr\Join::WITH,
   593|                 'n.parentPathHash = n2.pathHash AND n2.workspace IN (:workspaceList)'
   594|             )
   595|             ->where('n2.path IS NULL')
   596|             ->andWhere($queryBuilder->expr()->not('n.path = :slash'))
   597|             ->andWhere('n.workspace = :workspace');
   598|         $parameters = ['workspaceList' => $workspaceList, 'slash' => '/', 'workspace' => $workspaceName];
   599|         if ($nodeType !== null) {
   600|             $query->andWhere('n.nodeType = :nodetype');
   601|             $parameters['nodetype'] = $nodeType;
   602|         }
   603|         $nodes = $query
   604|             ->setParameters($parameters)
   605|             ->getQuery()->getArrayResult();
   606|         $nodesToBeRemoved = count($nodes);
   607|         if ($nodesToBeRemoved === 0) {
   608|             return;
   609|         }
   610|         foreach ($nodes as $node) {
   611|             $name = $node['path'] === '/' ? '' : substr($node['path'], strrpos($node['path'], '/') + 1);
   612|             $this->dispatch(self::EVENT_NOTICE, sprintf('Found orphan node named "<i>%s</i>" (<i>%s</i>) in "<i>%s</i>"', $name, $node['nodeType'], $node['path']));
   613|         }
   614|         $taskDescription = sprintf('Remove <i>%d</i> orphan node%s', $nodesToBeRemoved, $nodesToBeRemoved > 1 ? 's' : '');
   615|         $taskClosure = function () use ($nodes, $workspaceName) {
   616|             foreach ($nodes as $node) {
   617|                 $this->removeNodeAndChildNodesInWorkspaceByPath($node['path'], $workspaceName);
   618|             }
   619|         };
   620|         $taskRequiresConfirmation = true;
   621|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   622|     }
   623|     /**
   624|      * Performs checks for orphan nodes removes them if found.
   625|      *
   626|      * @param string $workspaceName
   627|      * @param boolean $dryRun (unused)
   628|      * @param NodeType $nodeType Only for this node type, if specified
   629|      * @return void
   630|      * @throws NodeConfigurationException
   631|      */
   632|     public function removeUndefinedProperties($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
   633|     {
   634|         $this->dispatch(self::EVENT_NOTICE, 'Checking for undefined properties ...');
   635|         /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
   636|         $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
   637|         $nodesWithUndefinedPropertiesNodes = [];
   638|         $undefinedPropertiesCount = 0;
   639|         $nodes = $nodeType !== null ? $this->getNodeDataByNodeTypeAndWorkspace($nodeType, $workspaceName) : $this->nodeDataRepository->findByWorkspace($workspace);
   640|         foreach ($nodes as $nodeData) {
   641|             try {
   642|                 /** @var NodeData $nodeData */
   643|                 if ($nodeData->getNodeType()->getName() === 'unstructured') {
   644|                     continue;
   645|                 }
   646|                 $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
   647|                 $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
   648|                 if (!$node instanceof NodeInterface) {
   649|                     continue;
   650|                 }
   651|                 $nodeType = $node->getNodeType();
   652|                 $nodeTypePropertyNames = array_keys($nodeType->getProperties());
   653|                 $undefinedProperties = [];
   654|                 foreach ($node->getProperties() as $propertyName => $propertyValue) {
   655|                     if (!in_array($propertyName, $nodeTypePropertyNames)) {
   656|                         $undefinedProperties[] = $propertyName;
   657|                     }
   658|                 }
   659|                 if ($undefinedProperties !== []) {
   660|                     $nodesWithUndefinedPropertiesNodes[] = ['node' => $node, 'undefinedProperties' => $undefinedProperties];
   661|                     foreach ($undefinedProperties as $undefinedProperty) {
   662|                         $undefinedPropertiesCount++;
   663|                         $this->dispatch(self::EVENT_NOTICE, sprintf('Found undefined property named "<i>%s</i>" in "<i>%s</i>" (<i>%s</i>)', $undefinedProperty, $node->getPath(), $node->getNodeType()->getName()));
   664|                     }
   665|                 }
   666|             } /** @noinspection PhpRedundantCatchClauseInspection */ catch (NodeTypeNotFoundException $exception) {
   667|                 $this->dispatch(self::EVENT_NOTICE, sprintf('Skipped undefined node type in "%s"', $nodeData->getPath()));
   668|             }
   669|         }
   670|         if ($undefinedPropertiesCount > 0) {
   671|             $taskDescription = sprintf('Remove <i>%d</i> undefined propert%s.', $undefinedPropertiesCount, $undefinedPropertiesCount > 1 ? 'ies' : 'y');
   672|             $taskClosure = function () use ($nodesWithUndefinedPropertiesNodes) {
   673|                 foreach ($nodesWithUndefinedPropertiesNodes as $nodesWithUndefinedPropertiesNode) {
   674|                     /** @var NodeInterface $node */
   675|                     $node = $nodesWithUndefinedPropertiesNode['node'];
   676|                     foreach ($nodesWithUndefinedPropertiesNode['undefinedProperties'] as $undefinedProperty) {
   677|                         if ($node->hasProperty($undefinedProperty)) {
   678|                             $node->removeProperty($undefinedProperty);
   679|                         }
   680|                     }
   681|                 }
   682|             };
   683|             $taskRequiresConfirmation = true;
   684|             $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   685|         }
   686|         $this->persistenceManager->persistAll();
   687|     }
   688|     /**
   689|      * Remove broken entity references
   690|      *
   691|      * This removes references from nodes to entities which don't exist anymore.
   692|      *
   693|      * @param string $workspaceName
   694|      * @return void
   695|      * @throws NodeException
   696|      * @throws PropertyException
   697|      * @throws SecurityException
   698|      */
   699|     public function removeBrokenEntityReferences($workspaceName)
   700|     {
   701|         $this->dispatch(self::EVENT_NOTICE, 'Checking for broken entity references ...');
   702|         /** @var \Neos\ContentRepository\Domain\Model\Workspace $workspace */
   703|         $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
   704|         $nodeTypesWithEntityReferences = [];
   705|         foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
   706|             /** @var NodeType $nodeType */
   707|             foreach (array_keys($nodeType->getProperties()) as $propertyName) {
   708|                 $propertyType = $nodeType->getPropertyType($propertyName);
   709|                 if (strpos($propertyType, '\\') !== false) {
   710|                     if (!isset($nodeTypesWithEntityReferences[$nodeType->getName()])) {
   711|                         $nodeTypesWithEntityReferences[$nodeType->getName()] = [];
   712|                     }
   713|                     $nodeTypesWithEntityReferences[$nodeType->getName()][$propertyName] = $propertyType;
   714|                 }
   715|             }
   716|         }
   717|         $nodesWithBrokenEntityReferences = [];
   718|         $brokenReferencesCount = 0;
   719|         foreach ($nodeTypesWithEntityReferences as $nodeTypeName => $properties) {
   720|             $nodeDatas = $this->nodeDataRepository->findByParentAndNodeTypeRecursively('/', $nodeTypeName, $workspace);
   721|             foreach ($nodeDatas as $nodeData) {
   722|                 /** @var NodeData $nodeData */
   723|                 foreach ($properties as $propertyName => $propertyType) {
   724|                     $propertyValue = $nodeData->getProperty($propertyName);
   725|                     $convertedProperty = null;
   726|                     if (is_object($propertyValue)) {
   727|                         $convertedProperty = $propertyValue;
   728|                     }
   729|                     if (is_string($propertyValue) && strlen($propertyValue) === 36) {
   730|                         $convertedProperty = $this->propertyMapper->convert($propertyValue, $propertyType);
   731|                         if ($convertedProperty === null) {
   732|                             $nodesWithBrokenEntityReferences[$nodeData->getIdentifier()][$propertyName] = $nodeData;
   733|                             $this->dispatch(self::EVENT_NOTICE, sprintf('Broken reference in "<i>%s</i>" (%s), property "<i>%s</i>" (<i>%s</i>) referring to <i>%s</i>.', $nodeData->getPath(), $nodeData->getIdentifier(), $propertyName, $propertyType, $propertyValue));
   734|                             $brokenReferencesCount ++;
   735|                         }
   736|                     }
   737|                     if ($convertedProperty instanceof Proxy) {
   738|                         try {
   739|                             $convertedProperty->__load();
   740|                         } /** @noinspection PhpRedundantCatchClauseInspection */ catch (EntityNotFoundException $e) {
   741|                             $nodesWithBrokenEntityReferences[$nodeData->getIdentifier()][$propertyName] = $nodeData;
   742|                             $this->dispatch(self::EVENT_NOTICE, sprintf('Broken reference in "<i>%s</i>" (%s), property "<i>%s</i>" (<i>%s</i>) referring to <i>%s</i>.', $nodeData->getPath(), $nodeData->getIdentifier(), $propertyName, $propertyType, $propertyValue));
   743|                             $brokenReferencesCount ++;
   744|                         }
   745|                     }
   746|                 }
   747|             }
   748|         }
   749|         if ($brokenReferencesCount === 0) {
   750|             return;
   751|         }
   752|         $taskDescription = sprintf('Remove <i>%d</i> broken entity reference%s.', $brokenReferencesCount, $brokenReferencesCount > 1 ? 's' : '');
   753|         $taskClosure = function () use ($nodesWithBrokenEntityReferences) {
   754|             foreach ($nodesWithBrokenEntityReferences as $nodeIdentifier => $properties) {
   755|                 foreach ($properties as $propertyName => $nodeData) {
   756|                     /** @var NodeData $nodeData */
   757|                     $nodeData->setProperty($propertyName, null);
   758|                 }
   759|             }
   760|             $this->persistenceManager->persistAll();
   761|         };
   762|         $taskRequiresConfirmation = true;
   763|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   764|     }
   765|     /**
   766|      * Creates a content context for given workspace
   767|      *
   768|      * @param string $workspaceName
   769|      * @param array $dimensions
   770|      * @return Context
   771|      */
   772|     protected function createContext($workspaceName, $dimensions)
   773|     {
   774|         return $this->contextFactory->create([
   775|             'workspaceName' => $workspaceName,
   776|             'dimensions' => $dimensions,
   777|             'invisibleContentShown' => true,
   778|             'inaccessibleContentShown' => true,
   779|             'removedContentShown' => true
   780|         ]);
   781|     }
   782|     /**
   783|      * Retrieves all NodeData objects of a certain node type inside a given workspace.
   784|      *
   785|      * Shadow nodes are excluded, because they will be published when publishing the moved node.
   786|      *
   787|      * @param string $nodeType
   788|      * @param string $workspaceName
   789|      * @return array<NodeData>
   790|      */
   791|     protected function getNodeDataByNodeTypeAndWorkspace($nodeType, $workspaceName)
   792|     {
   793|         /** @var QueryBuilder $queryBuilder */
   794|         $queryBuilder = $this->entityManager->createQueryBuilder();
   795|         $queryBuilder->select('n')
   796|             ->distinct()
   797|             ->from(NodeData::class, 'n')
   798|             ->where('n.nodeType = :nodeType')
   799|             ->andWhere('n.workspace = :workspace')
   800|             ->andWhere('n.movedTo IS NULL OR n.removed = :removed')
   801|             ->setParameter('nodeType', $nodeType)
   802|             ->setParameter('workspace', $workspaceName)
   803|             ->setParameter('removed', false, \PDO::PARAM_BOOL);
   804|         return $queryBuilder->getQuery()->getResult();
   805|     }
   806|     /**
   807|      * Removes all nodes with a specific path and their children in the given workspace.
   808|      *
   809|      * @param string $nodePath
   810|      * @param string $workspaceName
   811|      */
   812|     protected function removeNodeAndChildNodesInWorkspaceByPath($nodePath, $workspaceName)
   813|     {
   814|         /** @var QueryBuilder $queryBuilder */
   815|         $queryBuilder = $this->entityManager->createQueryBuilder();
   816|         $queryBuilder
   817|             ->resetDQLParts()
   818|             ->delete(NodeData::class, 'n')
   819|             ->where('n.path LIKE :path')
   820|             ->orWhere('n.path LIKE :subpath')
   821|             ->andWhere('n.workspace = :workspace')
   822|             ->setParameters(['path' => $nodePath, 'subpath' => $nodePath . '/%', 'workspace' => $workspaceName])
   823|             ->getQuery()
   824|             ->execute();
   825|     }
   826|     /**
   827|      * Removes the specified node (exactly that one)
   828|      *
   829|      * @param string $nodeIdentifier
   830|      * @param string $dimensionsHash
   831|      */
   832|     protected function removeNode($nodeIdentifier, $dimensionsHash)
   833|     {
   834|         /** @var QueryBuilder $queryBuilder */
   835|         $queryBuilder = $this->entityManager->createQueryBuilder();
   836|         $queryBuilder
   837|             ->resetDQLParts()
   838|             ->delete(NodeData::class, 'n')
   839|             ->where('n.identifier = :identifier')
   840|             ->andWhere('n.dimensionsHash = :dimensionsHash')
   841|             ->setParameters(['identifier' => $nodeIdentifier, 'dimensionsHash' => $dimensionsHash])
   842|             ->getQuery()
   843|             ->execute();
   844|     }
   845|     /**
   846|      * Remove nodes with invalid dimension values
   847|      *
   848|      * This removes nodes which have dimension values not fitting to the current dimension configuration
   849|      *
   850|      * @param string $workspaceName Name of the workspace to consider
   851|      * @return void
   852|      */
   853|     public function removeNodesWithInvalidDimensions($workspaceName)
   854|     {
   855|         $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with invalid dimensions ...');
   856|         $allowedDimensionCombinations = $this->contentDimensionCombinator->getAllAllowedCombinations();
   857|         $nodesArray = $this->collectNodesWithInvalidDimensions($workspaceName, $allowedDimensionCombinations);
   858|         if ($nodesArray === []) {
   859|             return;
   860|         }
   861|         $numberOfNodes = count($nodesArray);
   862|         $taskDescription = sprintf('Remove <i>%d</i> node%s with invalid dimension values', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
   863|         $taskClosure = function () use ($nodesArray) {
   864|             foreach ($nodesArray as $nodeArray) {
   865|                 $this->removeNode($nodeArray['identifier'], $nodeArray['dimensionsHash']);
   866|             }
   867|         };
   868|         $taskRequiresConfirmation = true;
   869|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   870|     }
   871|     /**
   872|      * Collects all nodes of the given node type which have dimension values not fitting to the current dimension
   873|      * configuration.
   874|      *
   875|      * @param string $workspaceName
   876|      * @param array $allowedDimensionCombinations
   877|      * @return array
   878|      */
   879|     protected function collectNodesWithInvalidDimensions($workspaceName, array $allowedDimensionCombinations)
   880|     {
   881|         $nodes = [];
   882|         ksort($allowedDimensionCombinations);
   883|         /** @var QueryBuilder $queryBuilder */
   884|         $queryBuilder = $this->entityManager->createQueryBuilder();
   885|         $queryBuilder->select('n')
   886|             ->from(NodeData::class, 'n')
   887|             ->where('n.workspace = :workspace')
   888|             ->setParameter('workspace', $workspaceName);
   889|         foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
   890|             if ($nodeDataArray['dimensionValues'] === [] || $nodeDataArray['dimensionValues'] === '') {
   891|                 continue;
   892|             }
   893|             $foundValidDimensionValues = false;
   894|             foreach ($allowedDimensionCombinations as $allowedDimensionConfiguration) {
   895|                 ksort($allowedDimensionConfiguration);
   896|                 ksort($nodeDataArray['dimensionValues']);
   897|                 foreach ($allowedDimensionConfiguration as $allowedDimensionKey => $allowedDimensionValuesArray) {
   898|                     if (isset($nodeDataArray['dimensionValues'][$allowedDimensionKey]) && isset($nodeDataArray['dimensionValues'][$allowedDimensionKey][0])) {
   899|                         $actualDimensionValue = $nodeDataArray['dimensionValues'][$allowedDimensionKey][0];
   900|                         if (in_array($actualDimensionValue, $allowedDimensionValuesArray)) {
   901|                             $foundValidDimensionValues = true;
   902|                             break;
   903|                         }
   904|                     }
   905|                 }
   906|             }
   907|             if (!$foundValidDimensionValues) {
   908|                 $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> has invalid dimension values: %s', $nodeDataArray['path'], json_encode($nodeDataArray['dimensionValues'])));
   909|                 $nodes[] = $nodeDataArray;
   910|             }
   911|         }
   912|         return $nodes;
   913|     }
   914|     /**
   915|      * Remove nodes with invalid workspace
   916|      *
   917|      * This removes nodes which refer to a workspace which does not exist.
   918|      *
   919|      * @return void
   920|      */
   921|     public function removeNodesWithInvalidWorkspace()
   922|     {
   923|         $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with invalid workspace ...');
   924|         $nodesArray = $this->collectNodesWithInvalidWorkspace();
   925|         if ($nodesArray === []) {
   926|             return;
   927|         }
   928|         $numberOfNodes = count($nodesArray);
   929|         $taskDescription = sprintf('Remove <i>%d</i> node%s referring to an invalid workspace.', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
   930|         $taskClosure = function () use ($nodesArray) {
   931|             foreach ($nodesArray as $nodeArray) {
   932|                 $this->removeNode($nodeArray['identifier'], $nodeArray['dimensionsHash']);
   933|             }
   934|         };
   935|         $taskRequiresConfirmation = true;
   936|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
   937|     }
   938|     /**
   939|      * Collects all nodes of the given node type which refer to an invalid workspace
   940|      * configuration.
   941|      *
   942|      * Note: due to the foreign key constraints in the database, there actually never should
   943|      *       be any node with n.workspace of a non-existing workspace because if that workspace
   944|      *       does not exist anymore, the value would turn NULL. But the query covers this nevertheless.
   945|      *       Better safe than sorry.
   946|      *
   947|      * @return array
   948|      */
   949|     protected function collectNodesWithInvalidWorkspace()
   950|     {
   951|         $nodes = [];
   952|         $workspaceNames = [];
   953|         foreach ($this->workspaceRepository->findAll() as $workspace) {
   954|             $workspaceNames[] = $workspace->getName();
   955|         }
   956|         /** @var QueryBuilder $queryBuilder */
   957|         $queryBuilder = $this->entityManager->createQueryBuilder();
   958|         $queryBuilder->select('n')
   959|             ->from(NodeData::class, 'n')
   960|             ->add(
   961|                 'where',
   962|                 $queryBuilder->expr()->orX(
   963|                     $queryBuilder->expr()->notIn('n.workspace', $workspaceNames),
   964|                     $queryBuilder->expr()->isNull('n.workspace')
   965|                 )
   966|             );
   967|         foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
   968|             $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> (identifier: <i>%s</i>) refers to an invalid workspace: <i>%s</i>', $nodeDataArray['path'], $nodeDataArray['identifier'], (isset($nodeDataArray['workspace']) ? $nodeDataArray['workspace'] : 'null')));
   969|             $nodes[] = $nodeDataArray;
   970|         }
   971|         return $nodes;
   972|     }
   973|     /**
   974|      * Detect and fix nodes in non-live workspaces whose identifier does not match their corresponding node in the
   975|      * live workspace.
   976|      *
   977|      * @return void
   978|      */
   979|     public function fixNodesWithInconsistentIdentifier()
   980|     {
   981|         $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with inconsistent identifier ...');
   982|         $nodesArray = [];
   983|         $liveWorkspaceNames = [];
   984|         $nonLiveWorkspaceNames = [];
   985|         foreach ($this->workspaceRepository->findAll() as $workspace) {
   986|             /** @var Workspace $workspace */
   987|             if ($workspace->getBaseWorkspace() !== null) {
   988|                 $nonLiveWorkspaceNames[] = $workspace->getName();
   989|             } else {
   990|                 $liveWorkspaceNames[] = $workspace->getName();
   991|             }
   992|         }
   993|         foreach ($nonLiveWorkspaceNames as $workspaceName) {
   994|             /** @var QueryBuilder $queryBuilder */
   995|             $queryBuilder = $this->entityManager->createQueryBuilder();
   996|             $queryBuilder->select('nonlive.Persistence_Object_Identifier, nonlive.identifier, nonlive.path, live.identifier AS liveIdentifier')
   997|                 ->from(NodeData::class, 'nonlive')
   998|                 ->join(NodeData::class, 'live', 'WITH', 'live.path = nonlive.path AND live.dimensionsHash = nonlive.dimensionsHash AND live.identifier != nonlive.identifier')
   999|                 ->where('nonlive.workspace = ?1')
  1000|                 ->andWhere($queryBuilder->expr()->in('live.workspace', $liveWorkspaceNames))
  1001|                 ->andWhere('nonlive.path != \'/\'')
  1002|                 ->setParameter(1, $workspaceName)
  1003|             ;
  1004|             foreach ($queryBuilder->getQuery()->getArrayResult() as $nodeDataArray) {
  1005|                 $this->dispatch(self::EVENT_NOTICE, sprintf('Node <i>%s</i> in workspace <i>%s</i> has identifier <i>%s</i> but live node has identifier <i>%s</i>.', $nodeDataArray['path'], $workspaceName, $nodeDataArray['identifier'], $nodeDataArray['liveIdentifier']));
  1006|                 $nodesArray[] = $nodeDataArray;
  1007|             }
  1008|         }
  1009|         if ($nodesArray === []) {
  1010|             return;
  1011|         }
  1012|         $numberOfNodes = count($nodesArray);
  1013|         $taskDescription = sprintf('Fix identifier%s of %s node%s', $numberOfNodes > 1 ? 's' : '', $numberOfNodes, $numberOfNodes > 1 ? 's' : '');
  1014|         $taskClosure = function () use ($nodesArray) {
  1015|             foreach ($nodesArray as $nodeArray) {
  1016|                 /** @var QueryBuilder $queryBuilder */
  1017|                 $queryBuilder = $this->entityManager->createQueryBuilder();
  1018|                 $queryBuilder->update(NodeData::class, 'nonlive')
  1019|                     ->set('nonlive.identifier', $queryBuilder->expr()->literal($nodeArray['liveIdentifier']))
  1020|                     ->where('nonlive.Persistence_Object_Identifier = ?1')
  1021|                     ->setParameter(1, $nodeArray['Persistence_Object_Identifier']);
  1022|                 $result = $queryBuilder->getQuery()->getResult();
  1023|                 if ($result !== 1) {
  1024|                     $errorMessage = 'The update query returned an unexpected result!' . PHP_EOL;
  1025|                     $errorMessage .= sprintf('<b>Query:</b> %s', $queryBuilder->getQuery()->getSQL()) . PHP_EOL;
  1026|                     $errorMessage .= sprintf('<b>Result:</b> %s', var_export($result, true));
  1027|                     $this->dispatch(self::EVENT_ERROR, $errorMessage);
  1028|                     return;
  1029|                 }
  1030|             }
  1031|         };
  1032|         $taskRequiresConfirmation = true;
  1033|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure, $taskRequiresConfirmation);
  1034|     }
  1035|     /**
  1036|      * Reorder child nodes according to the current position configuration of child nodes.
  1037|      *
  1038|      * @param string $workspaceName Name of the workspace to consider
  1039|      * @param boolean $dryRun Simulate?
  1040|      * @param NodeType $nodeType Only for this node type, if specified
  1041|      * @return void
  1042|      * @throws NodeConfigurationException
  1043|      * @throws NodeTypeNotFoundException
  1044|      */
  1045|     protected function reorderChildNodes($workspaceName, $dryRun, NodeType $nodeType = null)
  1046|     {
  1047|         if ($nodeType !== null) {
  1048|             $this->dispatch(self::EVENT_NOTICE, sprintf('Checking nodes of type "<i>%s</i>" for child nodes that need reordering ...', $nodeType));
  1049|             $this->reorderChildNodesByNodeType($workspaceName, $dryRun, $nodeType);
  1050|         } else {
  1051|             $this->dispatch(self::EVENT_NOTICE, 'Checking for child nodes that need reordering ...');
  1052|             foreach ($this->nodeTypeManager->getNodeTypes() as $nodeType) {
  1053|                 /** @var NodeType $nodeType */
  1054|                 if ($nodeType->isAbstract()) {
  1055|                     continue;
  1056|                 }
  1057|                 $this->reorderChildNodesByNodeType($workspaceName, $dryRun, $nodeType);
  1058|             }
  1059|         }
  1060|         $this->persistenceManager->persistAll();
  1061|     }
  1062|     /**
  1063|      * Reorder child nodes for the given node type
  1064|      *
  1065|      * @param string $workspaceName
  1066|      * @param boolean $dryRun (unused)
  1067|      * @param NodeType $nodeType
  1068|      * @return void
  1069|      * @throws NodeTypeNotFoundException
  1070|      * @throws NodeConfigurationException
  1071|      */
  1072|     protected function reorderChildNodesByNodeType($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType)
  1073|     {
  1074|         $nodeTypes = $this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), false);
  1075|         $nodeTypes[$nodeType->getName()] = $nodeType;
  1076|         if ($this->nodeTypeManager->hasNodeType((string)$nodeType)) {
  1077|             $nodeType = $this->nodeTypeManager->getNodeType((string)$nodeType);
  1078|             $nodeTypeNames[$nodeType->getName()] = $nodeType;
  1079|         } else {
  1080|             $this->dispatch(self::EVENT_ERROR, sprintf('Node type "<i>%s</i>" does not exist', $nodeType));
  1081|             return;
  1082|         }
  1083|         /** @var $nodeType NodeType */
  1084|         foreach ($nodeTypes as $nodeTypeName => $nodeType) {
  1085|             $childNodes = $nodeType->getAutoCreatedChildNodes();
  1086|             if ($childNodes === []) {
  1087|                 continue;
  1088|             }
  1089|             foreach ($this->getNodeDataByNodeTypeAndWorkspace($nodeTypeName, $workspaceName) as $nodeData) {
  1090|                 /** @var NodeInterface $childNodeBefore */
  1091|                 $childNodeBefore = null;
  1092|                 $context = $this->nodeFactory->createContextMatchingNodeData($nodeData);
  1093|                 $node = $this->nodeFactory->createFromNodeData($nodeData, $context);
  1094|                 if (!$node instanceof NodeInterface) {
  1095|                     continue;
  1096|                 }
  1097|                 foreach ($childNodes as $childNodeName => $childNodeType) {
  1098|                     $childNode = $node->getNode($childNodeName);
  1099|                     if ($childNode) {
  1100|                         if ($childNodeBefore && $childNodeBefore->getIndex() >= $childNode->getIndex()) {
  1101|                             $taskDescription = sprintf('Move node named "<i>%s</i>" after node named "<i>%s</i>" in "<i>%s</i>"', $childNodeName, $childNodeBefore->getName(), $node->getPath());
  1102|                             $taskClosure = function () use ($childNode, $childNodeBefore) {
  1103|                                 $childNode->moveAfter($childNodeBefore);
  1104|                             };
  1105|                             $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
  1106|                         }
  1107|                     } else {
  1108|                         $this->dispatch(self::EVENT_NOTICE, sprintf('Missing child node named "<i>%s</i>" in "<i>%s</i>".', $childNodeName, $node->getPath()));
  1109|                     }
  1110|                     $childNodeBefore = $childNode;
  1111|                 }
  1112|             }
  1113|         }
  1114|     }
  1115|     /**
  1116|      * Repair nodes whose shadow nodes are missing
  1117|      *
  1118|      * This check searches for nodes which have a corresponding node in one of the base workspaces,
  1119|      * have different node paths, but don't have a corresponding shadow node with a "movedto" value.
  1120|      *
  1121|      * @param string $workspaceName Currently ignored
  1122|      * @param boolean $dryRun (unused)
  1123|      * @param NodeType $nodeType This argument will be ignored
  1124|      * @return void
  1125|      */
  1126|     protected function repairShadowNodes($workspaceName, /** @noinspection PhpUnusedParameterInspection */$dryRun, NodeType $nodeType = null)
  1127|     {
  1128|         /** @var Workspace $workspace */
  1129|         $workspace = $this->workspaceRepository->findByIdentifier($workspaceName);
  1130|         if ($workspace->getBaseWorkspace() === null) {
  1131|             $this->dispatch(self::EVENT_NOTICE, sprintf('Repairing base workspace "<i>%s</i>", therefore skipping check for shadow nodes.', $workspaceName));
  1132|             return;
  1133|         }
  1134|         $this->dispatch(self::EVENT_NOTICE, 'Checking for nodes with missing shadow nodes ...');
  1135|         $newShadowNodes = $this->findMissingShadowNodesInWorkspace($workspace, $nodeType);
  1136|         if ($newShadowNodes === []) {
  1137|             return;
  1138|         }
  1139|         $numberOfNewShadowNodes = count($newShadowNodes);
  1140|         $taskDescription = sprintf('Add <i>%d</i> missing shadow node%s', $numberOfNewShadowNodes, $numberOfNewShadowNodes > 1 ? 's' : '');
  1141|         $taskClosure = function () use ($newShadowNodes) {
  1142|             /** @var NodeData $nodeData */
  1143|             foreach ($newShadowNodes as list('nodeData' => $nodeData, 'shadowPath' => $shadowPath)) {
  1144|                 $nodeData->createShadow($shadowPath);
  1145|             }
  1146|             $this->persistenceManager->persistAll();
  1147|         };
  1148|         $this->dispatch(self::EVENT_TASK, $taskDescription, $taskClosure);
  1149|     }
  1150|     /**
  1151|      * Collects all nodes with missing shadow nodes
  1152|      *
  1153|      * @param Workspace $workspace
  1154|      * @param NodeType $nodeType
  1155|      * @return array in the form [['nodeData' => <nodeDataInstance>, 'shadowPath' => '<shadowPath>'], ...]
  1156|      */
  1157|     protected function findMissingShadowNodesInWorkspace(Workspace $workspace, NodeType $nodeType = null)
  1158|     {
  1159|         $workspaces = array_merge([$workspace], $workspace->getBaseWorkspaces());
  1160|         $newShadowNodes = [];
  1161|         foreach ($workspaces as $workspace) {
  1162|             /** @var Workspace $workspace */
  1163|             if ($workspace->getBaseWorkspace() === null) {
  1164|                 continue;
  1165|             }
  1166|             /** @var QueryBuilder $queryBuilder */
  1167|             $queryBuilder = $this->entityManager->createQueryBuilder();
  1168|             $queryBuilder->select('n')
  1169|                 ->from(NodeData::class, 'n')
  1170|                 ->where('n.workspace = :workspace');
  1171|             $queryBuilder->setParameter('workspace', $workspace->getName());
  1172|             if ($nodeType !== null) {
  1173|                 $queryBuilder->andWhere('n.nodeType = :nodeType');
  1174|                 $queryBuilder->setParameter('nodeType', $nodeType->getName());
  1175|             }
  1176|             /** @var NodeData $nodeData */
  1177|             foreach ($queryBuilder->getQuery()->getResult() as $nodeData) {
  1178|                 $nodeDataSeenFromParentWorkspace = $this->nodeDataRepository->findOneByIdentifier($nodeData->getIdentifier(), $workspace->getBaseWorkspace(), $nodeData->getDimensionValues());
  1179|                 if ($nodeDataSeenFromParentWorkspace === null) {
  1180|                     continue;
  1181|                 }
  1182|                 if ($nodeDataSeenFromParentWorkspace->getPath() === $nodeData->getPath()) {
  1183|                     continue;
  1184|                 }
  1185|                 $nodeDataOnSamePath = $this->nodeDataRepository->findOneByPath($nodeData->getPath(), $workspace->getBaseWorkspace(), $nodeData->getDimensionValues(), null);
  1186|                 if ($nodeDataOnSamePath !== null) {
  1187|                     continue;
  1188|                 }
  1189|                 $newShadowNodes[] = ['nodeData' => $nodeData, 'shadowPath' => $nodeDataSeenFromParentWorkspace->getPath()];
  1190|             }
  1191|         }
  1192|         return $newShadowNodes;
  1193|     }
  1194|     /**
  1195|      * Attaches a new event handler
  1196|      *
  1197|      * @param string $eventIdentifier one of the EVENT_* constants
  1198|      * @param \Closure $callback a closure to be invoked when the corresponding event was triggered
  1199|      * @return void
  1200|      */
  1201|     public function on(string $eventIdentifier, \Closure $callback): void
  1202|     {
  1203|         $this->eventCallbacks[$eventIdentifier][] = $callback;
  1204|     }
  1205|     /**
  1206|      * Trigger a custom event
  1207|      *
  1208|      * @param string $eventIdentifier one of the EVENT_* constants
  1209|      * @param array $eventPayload optional arguments to be passed to the handler closure
  1210|      * @return void
  1211|      */
  1212|     protected function dispatch(string $eventIdentifier, ...$eventPayload): void
  1213|     {
  1214|         if (!isset($this->eventCallbacks[$eventIdentifier])) {
  1215|             return;
  1216|         }
  1217|         /** @var \Closure $callback */
  1218|         foreach ($this->eventCallbacks[$eventIdentifier] as $callback) {
  1219|             call_user_func_array($callback, $eventPayload);
  1220|         }
  1221|     }
  1222| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/ContentStream/ContentStreamIdentifier.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| <?php
     2| /*
     3|  * This file is part of the Neos.ContentRepository package.
     4|  *
     5|  * (c) Contributors of the Neos Project - www.neos.io
     6|  *
     7|  * This package is Open Source Software. For the full copyright and license
     8|  * information, please view the LICENSE file which was distributed with this
     9|  * source code.
    10|  */
    11| declare(strict_types=1);
    12| namespace Neos\ContentRepository\Domain\ContentStream;
    13| use Neos\Cache\CacheAwareInterface;
    14| use Neos\Flow\Utility\Algorithms;
    15| use Neos\Flow\Annotations as Flow;
    16| /**
    17|  * The ContentStreamIdentifier is the identifier for a Content Stream, which is
    18|  * a central concept in the Event-Sourced CR introduced with Neos 5.0.
    19|  */
    20| final class ContentStreamIdentifier implements \JsonSerializable, CacheAwareInterface, \Stringable
    21| {
    22|     /**
    23|      * @var array<string,self>
    24|      */
    25|     private static array $instances = [];
    26|     private function __construct(
    27|         private string $value
    28|     ) {
    29|     }
    30|     private static function instance(string $value): self
    31|     {
    32|         return self::$instances[$value] ??= new self($value);
    33|     }
    34|     public static function fromString(string $value): self
    35|     {
    36|         return self::instance($value);
    37|     }
    38|     public static function create(): self
    39|     {
    40|         return self::instance(Algorithms::generateUUID());
    41|     }
    42|     public function jsonSerialize(): string
    43|     {
    44|         return $this->value;
    45|     }
    46|     public function getCacheEntryIdentifier(): string
    47|     {
    48|         return $this->value;
    49|     }
    50|     public function __toString(): string
    51|     {
    52|         return $this->value;
    53|     }
    54|     public function equals(ContentStreamIdentifier $other): bool
    55|     {
    56|         return $this === $other;
    57|     }
    58| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/ContentSubgraph/NodePath.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-99 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\ContentRepository\Domain\ContentSubgraph;
     4| /*
     5|  * This file is part of the Neos.ContentRepository package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\ContentRepository\Domain\Model\NodeInterface;
    14| use Neos\ContentRepository\Domain\NodeAggregate\NodeName;
    15| use Neos\Flow\Annotations as Flow;
    16| /**
    17|  * The node path is a list of NodeNames. It can be either absolute or relative.
    18|  *
    19|  * It describes the hierarchy path of a node to a root node in a subgraph.
    20|  *
    21|  * @Flow\Proxy(false)
    22|  * @api
    23|  */
    24| final class NodePath implements \JsonSerializable
    25| {
    26|     /**
    27|      * @var string
    28|      */
    29|     private $path;
    30|     private function __construct(string $path)
    31|     {
    32|         if ($path !== '/') {
    33|             $pathParts = explode('/', ltrim($path, '/'));
    34|             foreach ($pathParts as $pathPart) {
    35|                 if (preg_match(NodeInterface::MATCH_PATTERN_NAME, $pathPart) !== 1) {
    36|                     throw new \InvalidArgumentException(sprintf('The path "%s" is no valid NodePath because it contains a segment "%s" that is no valid NodeName', $path, $pathPart), 1548157108);
    37|                 }
    38|             }
    39|         }
    40|         $this->path = $path;
    41|     }
    42|     public static function fromString(string $path): self
    43|     {
    44|         return new static($path);
    45|     }
    46|     public static function fromPathSegments(array $pathSegments): self
    47|     {
    48|         if ($pathSegments === []) {
    49|             return new static('/');
    50|         }
    51|         return new static('/' . implode('/', $pathSegments));
    52|     }
    53|     public function isRoot(): bool
    54|     {
    55|         return $this->path === '/';
    56|     }
    57|     public function isAbsolute(): bool
    58|     {
    59|         return strpos($this->path, '/') === 0;
    60|     }
    61|     /**
    62|      * IMMUTABLE function to create a new NodePath by appending a path segment. Returns a NEW NodePath object
    63|      * @param NodeName $nodeName
    64|      * @return NodePath
    65|      */
    66|     public function appendPathSegment(NodeName $nodeName): self
    67|     {
    68|         return new static($this->path . '/' . $nodeName);
    69|     }
    70|     /**
    71|      * @return NodeName[]
    72|      */
    73|     public function getParts(): array
    74|     {
    75|         $pathParts = explode('/', ltrim($this->path, '/'));
    76|         return array_map(function (string $pathPart) {
    77|             return NodeName::fromString($pathPart);
    78|         }, $pathParts);
    79|     }
    80|     public function getDepth(): int
    81|     {
    82|         if (!$this->isAbsolute()) {
    83|             throw new \RuntimeException(sprintf('Depth of relative node path "%s" cannot be determined', $this->path), 1548162166);
    84|         }
    85|         return count($this->getParts());
    86|     }
    87|     public function equals(NodePath $other): bool
    88|     {
    89|         return (string) $this === (string) $other;
    90|     }
    91|     public function jsonSerialize(): string
    92|     {
    93|         return $this->path;
    94|     }
    95|     public function __toString()
    96|     {
    97|         return $this->path;
    98|     }
    99| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/NodeAggregate/NodeAggregateIdentifier.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| /*
     3|  * This file is part of the Neos.ContentRepository package.
     4|  *
     5|  * (c) Contributors of the Neos Project - www.neos.io
     6|  *
     7|  * This package is Open Source Software. For the full copyright and license
     8|  * information, please view the LICENSE file which was distributed with this
     9|  * source code.
    10|  */
    11| declare(strict_types=1);
    12| namespace Neos\ContentRepository\Domain\NodeAggregate;
    13| use Neos\Cache\CacheAwareInterface;
    14| use Neos\ContentRepository\Utility;
    15| use Neos\Flow\Utility\Algorithms;
    16| use Neos\Flow\Annotations as Flow;
    17| /**
    18|  * The NodeAggregateIdentifier supersedes the Node Identifier from Neos <= 4.x.
    19|  */
    20| final class NodeAggregateIdentifier implements \JsonSerializable, CacheAwareInterface, \Stringable
    21| {
    22|     /**
    23|      * A preg pattern to match against node aggregate identifiers
    24|      */
    25|     const PATTERN = '/^([a-z0-9\-]{1,255})$/';
    26|     private function __construct(
    27|         private string $value
    28|     ) {
    29|         if (!preg_match(self::PATTERN, $value)) {
    30|             throw new \InvalidArgumentException('Invalid node aggregate identifier "' . $value . '" (a node aggregate identifier must only contain lowercase characters, numbers and the "-" sign).', 1505840197862);
    31|         }
    32|     }
    33|     public static function create(): self
    34|     {
    35|         return new self(Algorithms::generateUUID());
    36|     }
    37|     public static function fromString(string $value): self
    38|     {
    39|         return new self($value);
    40|     }
    41|     /**
    42|      * @throws \Exception
    43|      */
    44|     public static function forAutoCreatedChildNode(NodeName $childNodeName, NodeAggregateIdentifier $nodeAggregateIdentifier): self
    45|     {
    46|         return new self(Utility::buildAutoCreatedChildNodeIdentifier((string)$childNodeName, (string)$nodeAggregateIdentifier));
    47|     }
    48|     public function equals(NodeAggregateIdentifier $other): bool
    49|     {
    50|         return $this->value === (string)$other;
    51|     }
    52|     public function jsonSerialize(): string
    53|     {
    54|         return $this->value;
    55|     }
    56|     public function __toString(): string
    57|     {
    58|         return $this->value;
    59|     }
    60|     public function getCacheEntryIdentifier(): string
    61|     {
    62|         return $this->value;
    63|     }
    64| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/NodeAggregate/NodeName.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-47 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\ContentRepository\Domain\NodeAggregate;
     4| /*
     5|  * This file is part of the Neos.ContentRepository package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\ContentRepository\Domain\Model\NodeInterface;
    14| use Neos\Flow\Annotations as Flow;
    15| /**
    16|  * The Node name is the "path part" of the node; i.e. when accessing the node "/foo" via path,
    17|  * the node name is "foo".
    18|  *
    19|  * Semantically it describes the hierarchical relation of a node to its parent, e.g. "main" denotes the main child node.
    20|  * @api
    21|  */
    22| final class NodeName implements \JsonSerializable, \Stringable
    23| {
    24|     private function __construct(
    25|         private string $value
    26|     ) {
    27|         if (preg_match(NodeInterface::MATCH_PATTERN_NAME, $value) !== 1) {
    28|             throw new \InvalidArgumentException(
    29|                 'Invalid node name "' . $value
    30|                     . '" (a node name must only contain lowercase characters, numbers and the "-" sign).',
    31|                 1364290748
    32|             );
    33|         }
    34|     }
    35|     public static function fromString(string $value): self
    36|     {
    37|         return new self(strtolower($value));
    38|     }
    39|     public function jsonSerialize(): string
    40|     {
    41|         return $this->value;
    42|     }
    43|     public function __toString(): string
    44|     {
    45|         return $this->value;
    46|     }
    47| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/NodeType/NodeTypeName.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-58 ---
     1| <?php
     2| /*
     3|  * This file is part of the Neos.ContentRepository package.
     4|  *
     5|  * (c) Contributors of the Neos Project - www.neos.io
     6|  *
     7|  * This package is Open Source Software. For the full copyright and license
     8|  * information, please view the LICENSE file which was distributed with this
     9|  * source code.
    10|  */
    11| declare(strict_types=1);
    12| namespace Neos\ContentRepository\Domain\NodeType;
    13| use Neos\Flow\Annotations as Flow;
    14| /**
    15|  * Name of a Node Type; e.g. "Neos.Neos:Content"
    16|  *
    17|  * @Flow\Proxy(false)
    18|  * @api
    19|  */
    20| final class NodeTypeName implements \JsonSerializable, \Stringable
    21| {
    22|     const ROOT_NODE_TYPE_NAME = 'Neos.ContentRepository:Root';
    23|     /**
    24|      * @var array<string,self>
    25|      */
    26|     private static array $instances = [];
    27|     private function __construct(
    28|         private string $value
    29|     ) {
    30|         if ($value === '') {
    31|             throw new \InvalidArgumentException('Node type name must not be empty.', 1505835958);
    32|         }
    33|     }
    34|     private static function instance(string $value): self
    35|     {
    36|         return self::$instances[$value] ??= new self($value);
    37|     }
    38|     public static function fromString(string $value): self
    39|     {
    40|         return self::instance($value);
    41|     }
    42|     public function getValue(): string
    43|     {
    44|         return $this->value;
    45|     }
    46|     public function equals(self $other): bool
    47|     {
    48|         return $this === $other;
    49|     }
    50|     public function jsonSerialize(): string
    51|     {
    52|         return $this->value;
    53|     }
    54|     public function __toString(): string
    55|     {
    56|         return $this->value;
    57|     }
    58| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/Projection/Content/PropertyCollectionInterface.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\ContentRepository\Domain\Projection\Content;
     4| /*
     5|  * This file is part of the Neos.ContentRepository package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| /**
    14|  * @extends \ArrayAccess<string,mixed>
    15|  * @extends \IteratorAggregate<string,mixed>
    16|  */
    17| interface PropertyCollectionInterface extends \ArrayAccess, \IteratorAggregate
    18| {
    19| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/Service/Context.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-446 ---
     1| <?php
     2| namespace Neos\ContentRepository\Domain\Service;
     3| /*
     4|  * This file is part of the Neos.ContentRepository package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\ContentRepository\Domain\Factory\NodeFactory;
    14| use Neos\ContentRepository\Domain\Model\NodeData;
    15| use Neos\ContentRepository\Domain\Model\NodeInterface;
    16| use Neos\ContentRepository\Domain\Model\Workspace;
    17| use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
    18| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    19| use Neos\ContentRepository\Domain\Service\Cache\FirstLevelNodeCache;
    20| use Neos\Flow\Log\Utility\LogEnvironment;
    21| use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
    22| use Psr\Log\LoggerInterface;
    23| /**
    24|  * Context
    25|  *
    26|  * @api
    27|  */
    28| class Context
    29| {
    30|     /**
    31|      * @Flow\Inject
    32|      * @var WorkspaceRepository
    33|      */
    34|     protected $workspaceRepository;
    35|     /**
    36|      * @Flow\Inject
    37|      * @var NodeDataRepository
    38|      */
    39|     protected $nodeDataRepository;
    40|     /**
    41|      * @Flow\Inject
    42|      * @var NodeFactory
    43|      */
    44|     protected $nodeFactory;
    45|     /**
    46|      * @Flow\Inject
    47|      * @var ContextFactoryInterface
    48|      */
    49|     protected $contextFactory;
    50|     /**
    51|      * @Flow\Inject
    52|      * @var LoggerInterface
    53|      */
    54|     protected $systemLogger;
    55|     /**
    56|      * @var Workspace
    57|      */
    58|     protected $workspace;
    59|     /**
    60|      * @var string
    61|      */
    62|     protected $workspaceName;
    63|     /**
    64|      * @var \DateTime
    65|      */
    66|     protected $currentDateTime;
    67|     /**
    68|      * If true, invisible content elements will be shown.
    69|      *
    70|      * @var boolean
    71|      */
    72|     protected $invisibleContentShown = false;
    73|     /**
    74|      * If true, removed content elements will be shown, even though they are removed.
    75|      *
    76|      * @var boolean
    77|      */
    78|     protected $removedContentShown = false;
    79|     /**
    80|      * If true, even content elements will be shown which are not accessible by the currently logged in account.
    81|      *
    82|      * @var boolean
    83|      */
    84|     protected $inaccessibleContentShown = false;
    85|     /**
    86|      * @var array
    87|      */
    88|     protected $dimensions = [];
    89|     /**
    90|      * @var array
    91|      */
    92|     protected $targetDimensions = [];
    93|     /**
    94|      * @Flow\IgnoreValidation
    95|      * @var FirstLevelNodeCache
    96|      */
    97|     protected $firstLevelNodeCache;
    98|     /**
    99|      * Creates a new Context object.
   100|      *
   101|      * NOTE: This is for internal use only, you should use the ContextFactory for creating Context instances.
   102|      *
   103|      * @param string $workspaceName Name of the current workspace
   104|      * @param \DateTimeInterface $currentDateTime The current date and time
   105|      * @param array $dimensions Array of dimensions with array of ordered values
   106|      * @param array $targetDimensions Array of dimensions used when creating / modifying content
   107|      * @param boolean $invisibleContentShown If invisible content should be returned in query results
   108|      * @param boolean $removedContentShown If removed content should be returned in query results
   109|      * @param boolean $inaccessibleContentShown If inaccessible content should be returned in query results
   110|      * @see ContextFactoryInterface
   111|      */
   112|     public function __construct($workspaceName, \DateTimeInterface $currentDateTime, array $dimensions, array $targetDimensions, $invisibleContentShown, $removedContentShown, $inaccessibleContentShown)
   113|     {
   114|         $this->workspaceName = $workspaceName;
   115|         $this->currentDateTime = $currentDateTime;
   116|         $this->dimensions = $dimensions;
   117|         $this->invisibleContentShown = $invisibleContentShown;
   118|         $this->removedContentShown = $removedContentShown;
   119|         $this->inaccessibleContentShown = $inaccessibleContentShown;
   120|         $this->targetDimensions = $targetDimensions;
   121|         $this->firstLevelNodeCache = new FirstLevelNodeCache();
   122|     }
   123|     /**
   124|      * Returns the current workspace.
   125|      *
   126|      * @param boolean $createWorkspaceIfNecessary DEPRECATED: If enabled, creates a workspace with the configured name if it doesn't exist already. This option is DEPRECATED, create workspace explicitly instead.
   127|      * @return Workspace The workspace or NULL
   128|      * @api
   129|      * @throws IllegalObjectTypeException
   130|      */
   131|     public function getWorkspace($createWorkspaceIfNecessary = true)
   132|     {
   133|         if ($this->workspace !== null) {
   134|             return $this->workspace;
   135|         }
   136|         $this->workspace = $this->workspaceRepository->findByIdentifier($this->workspaceName);
   137|         if ($this->workspace === null && $createWorkspaceIfNecessary) {
   138|             $liveWorkspace = $this->workspaceRepository->findByIdentifier('live');
   139|             $this->workspace = new Workspace($this->workspaceName, $liveWorkspace);
   140|             $this->workspaceRepository->add($this->workspace);
   141|             $this->systemLogger->notice(sprintf('Notice: %s::getWorkspace() implicitly created the new workspace "%s". This behaviour is discouraged and will be removed in future versions. Make sure to create workspaces explicitly by adding a new workspace to the Workspace Repository.', __CLASS__, $this->workspaceName), LogEnvironment::fromMethodName(__METHOD__));
   142|         }
   143|         if ($this->workspace !== null) {
   144|             $this->validateWorkspace($this->workspace);
   145|         }
   146|         return $this->workspace;
   147|     }
   148|     /**
   149|      * This method is called in order to check if a workspace is accessible.
   150|      *
   151|      * At the time of this writing, it is not possible in Flow to restrict access to Workspace through Entity Privileges
   152|      * because Workspaces are used at a very early stage during routing where the security context is not yet initialized.
   153|      * As a workaround, we use a Method Privilege which protects this validateWorkspace() method and thus prevents
   154|      * unauthorized access to a workspace when calling this context's getWorkspace() method.
   155|      *
   156|      * Since some privilege definitions check the "owner" property of a Workspace, we need a real Workspace object and
   157|      * not just the name - hence this method.
   158|      *
   159|      * @param Workspace $workspace The workspace to check
   160|      * @return void
   161|      */
   162|     public function validateWorkspace(Workspace $workspace)
   163|     {
   164|     }
   165|     /**
   166|      * Returns the name of the workspace.
   167|      *
   168|      * @return string
   169|      * @api
   170|      */
   171|     public function getWorkspaceName()
   172|     {
   173|         return $this->workspaceName;
   174|     }
   175|     /**
   176|      * Returns the current date and time in form of a \DateTime
   177|      * object.
   178|      *
   179|      * If you use this method for getting the current date and time
   180|      * everywhere in your code, it will be possible to simulate a certain
   181|      * time in unit tests or in the actual application (for realizing previews etc).
   182|      *
   183|      * @return \DateTime The current date and time - or a simulated version of it
   184|      * @api
   185|      */
   186|     public function getCurrentDateTime()
   187|     {
   188|         return $this->currentDateTime;
   189|     }
   190|     /**
   191|      * Convenience method returns the root node for
   192|      * this context workspace.
   193|      *
   194|      * @return NodeInterface
   195|      * @api
   196|      */
   197|     public function getRootNode()
   198|     {
   199|         return $this->getNode('/');
   200|     }
   201|     /**
   202|      * Returns a node specified by the given absolute path.
   203|      *
   204|      * @param string $path Absolute path specifying the node
   205|      * @return NodeInterface The specified node or NULL if no such node exists
   206|      * @throws \InvalidArgumentException
   207|      * @api
   208|      */
   209|     public function getNode($path)
   210|     {
   211|         if (!is_string($path) || $path[0] !== '/') {
   212|             throw new \InvalidArgumentException('Only absolute paths are allowed for Context::getNode()', 1284975105);
   213|         }
   214|         $path = strtolower($path);
   215|         $workspaceRootNode = $this->getWorkspace()->getRootNodeData();
   216|         $rootNode = $this->nodeFactory->createFromNodeData($workspaceRootNode, $this);
   217|         if ($path !== '/') {
   218|             $node = $this->firstLevelNodeCache->getByPath($path);
   219|             if ($node === false) {
   220|                 $node = $rootNode->getNode(substr($path, 1));
   221|                 $this->firstLevelNodeCache->setByPath($path, $node);
   222|             }
   223|         } else {
   224|             $node = $rootNode;
   225|         }
   226|         return $node;
   227|     }
   228|     /**
   229|      * Get a node by identifier and this context
   230|      *
   231|      * @param string $identifier The identifier of a node
   232|      * @return ?NodeInterface The node with the given identifier or NULL if no such node exists
   233|      */
   234|     public function getNodeByIdentifier($identifier)
   235|     {
   236|         $node = $this->firstLevelNodeCache->getByIdentifier($identifier);
   237|         if ($node !== false) {
   238|             return $node;
   239|         }
   240|         $nodeData = $this->nodeDataRepository->findOneByIdentifier($identifier, $this->getWorkspace(), $this->dimensions, $this->removedContentShown);
   241|         if ($nodeData !== null) {
   242|             $node = $this->nodeFactory->createFromNodeData($nodeData, $this);
   243|         } else {
   244|             $node = null;
   245|         }
   246|         $this->firstLevelNodeCache->setByIdentifier($identifier, $node);
   247|         return $node;
   248|     }
   249|     /**
   250|      * Get all node variants for the given identifier
   251|      *
   252|      * A variant of a node can have different dimension values and path (for non-aggregate nodes).
   253|      * The resulting node instances might belong to a different context.
   254|      *
   255|      * @param string $identifier The identifier of a node
   256|      * @return array<\Neos\ContentRepository\Domain\Model\NodeInterface>
   257|      */
   258|     public function getNodeVariantsByIdentifier($identifier)
   259|     {
   260|         $nodeVariants = [];
   261|         $nodeDataElements = $this->nodeDataRepository->findByIdentifierWithoutReduce($identifier, $this->getWorkspace());
   262|         /** @var NodeData $nodeData */
   263|         foreach ($nodeDataElements as $nodeData) {
   264|             $contextProperties = $this->getProperties();
   265|             $contextProperties['dimensions'] = $nodeData->getDimensionValues();
   266|             unset($contextProperties['targetDimensions']);
   267|             $adjustedContext = $this->contextFactory->create($contextProperties);
   268|             $nodeVariant = $this->nodeFactory->createFromNodeData($nodeData, $adjustedContext);
   269|             $nodeVariants[] = $nodeVariant;
   270|         }
   271|         return $nodeVariants;
   272|     }
   273|     /**
   274|      * Finds all nodes lying on the path specified by (and including) the given
   275|      * starting point and end point.
   276|      *
   277|      * @param mixed $startingPoint Either an absolute path or an actual node specifying the starting point, for example /sites/mysitecom
   278|      * @param mixed $endPoint Either an absolute path or an actual node specifying the end point, for example /sites/mysitecom/homepage/subpage
   279|      * @return array<\Neos\ContentRepository\Domain\Model\NodeInterface> The nodes found between and including the given paths or an empty array of none were found
   280|      * @api
   281|      */
   282|     public function getNodesOnPath($startingPoint, $endPoint)
   283|     {
   284|         $startingPointPath = ($startingPoint instanceof NodeInterface) ? $startingPoint->getPath() : $startingPoint;
   285|         $endPointPath = ($endPoint instanceof NodeInterface) ? $endPoint->getPath() : $endPoint;
   286|         $nodeDataElements = $this->nodeDataRepository->findOnPath($startingPointPath, $endPointPath, $this->getWorkspace(), $this->getDimensions(), $this->isRemovedContentShown());
   287|         $nodes = [];
   288|         foreach ($nodeDataElements as $nodeData) {
   289|             $node = $this->nodeFactory->createFromNodeData($nodeData, $this);
   290|             if ($node !== null) {
   291|                 $nodes[] = $node;
   292|                 $this->firstLevelNodeCache->setByPath($node->getPath(), $node);
   293|             }
   294|         }
   295|         return $nodes;
   296|     }
   297|     /**
   298|      * Adopts a node from a (possibly) different context to this context
   299|      *
   300|      * Checks if a node variant matching the exact dimensions already exists for this context and
   301|      * return it if found. Otherwise a new node variant for this context is created.
   302|      *
   303|      * In case the node already exists in the context but does not match the target dimensions a
   304|      * new, more specific node is created and returned.
   305|      *
   306|      * @param NodeInterface $node The node with a different context. If the context of the given node is the same as this context the operation will have no effect.
   307|      * @param boolean $recursive If true also adopt all descendant nodes which are non-aggregate
   308|      * @return NodeInterface A new or existing node that matches this context
   309|      */
   310|     public function adoptNode(NodeInterface $node, $recursive = false)
   311|     {
   312|         if ($node->getContext() === $this && $node->dimensionsAreMatchingTargetDimensionValues()) {
   313|             return $node;
   314|         }
   315|         $this->emitBeforeAdoptNode($node, $this, $recursive);
   316|         $existingNode = $this->getNodeByIdentifier($node->getIdentifier());
   317|         if ($existingNode !== null) {
   318|             if ($existingNode->dimensionsAreMatchingTargetDimensionValues()) {
   319|                 $adoptedNode = $existingNode;
   320|             } else {
   321|                 $adoptedNode = $existingNode->createVariantForContext($this);
   322|             }
   323|         } else {
   324|             $adoptedNode = $node->createVariantForContext($this);
   325|         }
   326|         $this->firstLevelNodeCache->setByIdentifier($adoptedNode->getIdentifier(), $adoptedNode);
   327|         if ($recursive) {
   328|             $childNodes = $node->getChildNodes();
   329|             /** @var NodeInterface $childNode */
   330|             foreach ($childNodes as $childNode) {
   331|                 if (!$childNode->getNodeType()->isAggregate()) {
   332|                     $this->adoptNode($childNode, true);
   333|                 }
   334|             }
   335|         }
   336|         $this->emitAfterAdoptNode($node, $this, $recursive);
   337|         return $adoptedNode;
   338|     }
   339|     /**
   340|      * @Flow\Signal
   341|      * @param NodeInterface $node
   342|      * @param Context $context
   343|      * @param $recursive
   344|      */
   345|     protected function emitBeforeAdoptNode(NodeInterface $node, Context $context, $recursive)
   346|     {
   347|     }
   348|     /**
   349|      * @Flow\Signal
   350|      * @param NodeInterface $node
   351|      * @param Context $context
   352|      * @param $recursive
   353|      */
   354|     protected function emitAfterAdoptNode(NodeInterface $node, Context $context, $recursive)
   355|     {
   356|     }
   357|     /**
   358|      * Tells if nodes which are usually invisible should be accessible through the Node API and queries
   359|      *
   360|      * @return boolean
   361|      * @see NodeFactory->filterNodeByContext()
   362|      * @api
   363|      */
   364|     public function isInvisibleContentShown()
   365|     {
   366|         return $this->invisibleContentShown;
   367|     }
   368|     /**
   369|      * Tells if nodes which have their "removed" flag set should be accessible through
   370|      * the Node API and queries
   371|      *
   372|      * @return boolean
   373|      * @see Node->filterNodeByContext()
   374|      * @api
   375|      */
   376|     public function isRemovedContentShown()
   377|     {
   378|         return $this->removedContentShown;
   379|     }
   380|     /**
   381|      * Tells if nodes which have access restrictions should be accessible through
   382|      * the Node API and queries even without the necessary roles / rights
   383|      *
   384|      * @return boolean
   385|      * @api
   386|      */
   387|     public function isInaccessibleContentShown()
   388|     {
   389|         return $this->inaccessibleContentShown;
   390|     }
   391|     /**
   392|      * An indexed array of dimensions with ordered list of values for matching nodes by content dimensions
   393|      *
   394|      * @return array
   395|      */
   396|     public function getDimensions()
   397|     {
   398|         return $this->dimensions;
   399|     }
   400|     /**
   401|      * An indexed array of dimensions with a set of values that should be applied when updating or creating
   402|      *
   403|      * @return array
   404|      */
   405|     public function getTargetDimensions()
   406|     {
   407|         return $this->targetDimensions;
   408|     }
   409|     /**
   410|      * An indexed array of dimensions with a set of values that should be applied when updating or creating
   411|      *
   412|      * @return array
   413|      */
   414|     public function getTargetDimensionValues()
   415|     {
   416|         return array_map(function ($value) {
   417|             return $value === null ? [] : [ $value ];
   418|         }, $this->getTargetDimensions());
   419|     }
   420|     /**
   421|      * Returns the properties of this context.
   422|      *
   423|      * @return array
   424|      */
   425|     public function getProperties()
   426|     {
   427|         return [
   428|             'workspaceName' => $this->workspaceName,
   429|             'currentDateTime' => $this->currentDateTime,
   430|             'dimensions' => $this->dimensions,
   431|             'targetDimensions' => $this->targetDimensions,
   432|             'invisibleContentShown' => $this->invisibleContentShown,
   433|             'removedContentShown' => $this->removedContentShown,
   434|             'inaccessibleContentShown' => $this->inaccessibleContentShown
   435|         ];
   436|     }
   437|     /**
   438|      * Not public API!
   439|      *
   440|      * @return FirstLevelNodeCache
   441|      */
   442|     public function getFirstLevelNodeCache()
   443|     {
   444|         return $this->firstLevelNodeCache;
   445|     }
   446| }


# ====================================================================
# FILE: Neos.ContentRepository/Classes/Domain/Service/ImportExport/NodeExportService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-389 ---
     1| <?php
     2| namespace Neos\ContentRepository\Domain\Service\ImportExport;
     3| /*
     4|  * This file is part of the Neos.ContentRepository package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Doctrine\ORM\EntityManagerInterface;
    13| use Doctrine\Persistence\Proxy as DoctrineProxy;
    14| use Neos\Flow\Annotations as Flow;
    15| use Neos\Flow\Log\ThrowableStorageInterface;
    16| use Neos\Flow\Log\Utility\LogEnvironment;
    17| use Neos\Flow\ObjectManagement\ObjectManagerInterface;
    18| use Neos\Flow\Persistence\PersistenceManagerInterface;
    19| use Neos\Flow\Property\PropertyMapper;
    20| use Neos\Flow\Security\Context;
    21| use Neos\ContentRepository\Domain\Model\NodeData;
    22| use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
    23| use Neos\ContentRepository\Domain\Service\NodeTypeManager;
    24| use Neos\ContentRepository\Exception\ExportException;
    25| use Psr\Log\LoggerInterface;
    26| /**
    27|  * Service for exporting content repository nodes as an XML structure
    28|  *
    29|  * Internally, uses associative arrays instead of Domain Models for performance reasons, so "nodeData" in this
    30|  * class is always an associative array.
    31|  *
    32|  * @Flow\Scope("singleton")
    33|  */
    34| class NodeExportService
    35| {
    36|     /**
    37|      * @var string
    38|      */
    39|     const SUPPORTED_FORMAT_VERSION = '2.0';
    40|     /**
    41|      * @var LoggerInterface
    42|      */
    43|     private $logger;
    44|     /**
    45|      * @var ThrowableStorageInterface
    46|      */
    47|     private $throwableStorage;
    48|     /**
    49|      * @Flow\Inject
    50|      * @var ObjectManagerInterface
    51|      */
    52|     protected $objectManager;
    53|     /**
    54|      * @Flow\Inject
    55|      * @var PersistenceManagerInterface
    56|      */
    57|     protected $persistenceManager;
    58|     /**
    59|      * @Flow\Inject
    60|      * @var PropertyMapper
    61|      */
    62|     protected $propertyMapper;
    63|     /**
    64|      * Doctrine's Entity Manager.
    65|      *
    66|      * @Flow\Inject
    67|      * @var EntityManagerInterface
    68|      */
    69|     protected $entityManager;
    70|     /**
    71|      * @Flow\Inject
    72|      * @var NodeTypeManager
    73|      */
    74|     protected $nodeTypeManager;
    75|     /**
    76|      * @Flow\Inject
    77|      * @var NodeDataRepository
    78|      */
    79|     protected $nodeDataRepository;
    80|     /**
    81|      * @Flow\Inject
    82|      * @var Context
    83|      */
    84|     protected $securityContext;
    85|     /**
    86|      * @var ImportExportPropertyMappingConfiguration
    87|      */
    88|     protected $propertyMappingConfiguration;
    89|     /**
    90|      * @var \XMLWriter
    91|      */
    92|     protected $xmlWriter;
    93|     /**
    94|      * @var array<\Exception> a list of exceptions which happened during export
    95|      */
    96|     protected $exceptionsDuringExport;
    97|     /**
    98|      * @var array Node paths that have been exported, this is used for consistency checks of broken node rootlines
    99|      */
   100|     protected $exportedNodePaths;
   101|     /**
   102|      * @param LoggerInterface $logger
   103|      */
   104|     public function injectLogger(LoggerInterface $logger)
   105|     {
   106|         $this->logger = $logger;
   107|     }
   108|     /**
   109|      * @param ThrowableStorageInterface $throwableStorage
   110|      */
   111|     public function injectThrowableStorage(ThrowableStorageInterface $throwableStorage)
   112|     {
   113|         $this->throwableStorage = $throwableStorage;
   114|     }
   115|     /**
   116|      * Exports the node data of all nodes in the given sub-tree
   117|      * by writing them to the given XMLWriter.
   118|      *
   119|      * @param string $startingPointNodePath path to the root node of the sub-tree to export. The specified node will not be included, only its sub nodes.
   120|      * @param string $workspaceName
   121|      * @param \XMLWriter $xmlWriter
   122|      * @param boolean $tidy
   123|      * @param boolean $endDocument
   124|      * @param string $resourceSavePath
   125|      * @param string $nodeTypeFilter Filter the node type of the nodes, allows complex expressions (e.g. "Neos.Neos:Page", "!Neos.Neos:Page,Neos.Neos:Text")
   126|      * @return \XMLWriter
   127|      */
   128|     public function export($startingPointNodePath = '/', $workspaceName = 'live', \XMLWriter $xmlWriter = null, $tidy = true, $endDocument = true, $resourceSavePath = null, $nodeTypeFilter = null)
   129|     {
   130|         $this->propertyMappingConfiguration = new ImportExportPropertyMappingConfiguration($resourceSavePath);
   131|         $this->exceptionsDuringExport = [];
   132|         $this->exportedNodePaths = [];
   133|         if ($startingPointNodePath !== '/') {
   134|             $startingPointParentPath = substr($startingPointNodePath, 0, strrpos($startingPointNodePath, '/'));
   135|             $this->exportedNodePaths[$startingPointParentPath] = true;
   136|         }
   137|         $this->xmlWriter = $xmlWriter;
   138|         if ($this->xmlWriter === null) {
   139|             $this->xmlWriter = new \XMLWriter();
   140|             $this->xmlWriter->openMemory();
   141|             $this->xmlWriter->setIndent($tidy);
   142|             $this->xmlWriter->startDocument('1.0', 'UTF-8');
   143|         }
   144|         $this->securityContext->withoutAuthorizationChecks(function () use ($startingPointNodePath, $workspaceName, $nodeTypeFilter) {
   145|             $nodeDataList = $this->findNodeDataListToExport($startingPointNodePath, $workspaceName, $nodeTypeFilter);
   146|             $this->exportNodeDataList($nodeDataList);
   147|         });
   148|         if ($endDocument) {
   149|             $this->xmlWriter->endDocument();
   150|         }
   151|         $this->handleExceptionsDuringExport();
   152|         return $this->xmlWriter;
   153|     }
   154|     /**
   155|      * Find all nodes of the specified workspace lying below the path specified by
   156|      * (and including) the given starting point.
   157|      *
   158|      * @param string $pathStartingPoint Absolute path specifying the starting point
   159|      * @param string $workspace The containing workspace
   160|      * @param string $nodeTypeFilter
   161|      * @return array an array of node-data in array format.
   162|      */
   163|     protected function findNodeDataListToExport($pathStartingPoint, $workspace = 'live', $nodeTypeFilter = null)
   164|     {
   165|         /** @var \Doctrine\ORM\QueryBuilder $queryBuilder */
   166|         $queryBuilder = $this->entityManager->createQueryBuilder();
   167|         $queryBuilder->select(
   168|             'n.path AS path,'
   169|             . ' n.identifier AS identifier,'
   170|             . ' n.index AS sortingIndex,'
   171|             . ' n.properties AS properties, '
   172|             . ' n.nodeType AS nodeType,'
   173|             . ' n.removed AS removed,'
   174|             . ' n.hidden,'
   175|             . ' n.hiddenBeforeDateTime AS hiddenBeforeDateTime,'
   176|             . ' n.hiddenAfterDateTime AS hiddenAfterDateTime,'
   177|             . ' n.creationDateTime AS creationDateTime,'
   178|             . ' n.lastModificationDateTime AS lastModificationDateTime,'
   179|             . ' n.lastPublicationDateTime AS lastPublicationDateTime,'
   180|             . ' n.hiddenInIndex AS hiddenInIndex,'
   181|             . ' n.accessRoles AS accessRoles,'
   182|             . ' n.version AS version,'
   183|             . ' n.parentPath AS parentPath,'
   184|             . ' n.pathHash AS pathHash,'
   185|             . ' n.dimensionsHash AS dimensionsHash,'
   186|             . ' n.parentPathHash AS parentPathHash,'
   187|             . ' n.dimensionValues AS dimensionValues,'
   188|             . ' w.name AS workspace'
   189|         )->distinct()
   190|             ->from(NodeData::class, 'n')
   191|             ->innerJoin('n.workspace', 'w', 'WITH', 'n.workspace=w.name')
   192|             ->where('n.workspace = :workspace')
   193|             ->setParameter('workspace', $workspace)
   194|             ->andWhere('n.path = :pathPrefix OR n.path LIKE :pathPrefixMatch')
   195|             ->setParameter('pathPrefix', $pathStartingPoint)
   196|             ->setParameter('pathPrefixMatch', ($pathStartingPoint === '/' ? '%' : $pathStartingPoint . '/%'))
   197|             ->orderBy('n.identifier', 'ASC')
   198|             ->orderBy('n.path', 'ASC');
   199|         if ($nodeTypeFilter) {
   200|             $this->nodeDataRepository->addNodeTypeFilterConstraintsToQueryBuilder($queryBuilder, $nodeTypeFilter);
   201|         }
   202|         $nodeDataList = $queryBuilder->getQuery()->getResult();
   203|         usort(
   204|             $nodeDataList,
   205|             function ($node1, $node2) {
   206|                 return strcmp(
   207|                     str_replace("/", "!", $node1['path']),
   208|                     str_replace("/", "!", $node2['path'])
   209|                 );
   210|             }
   211|         );
   212|         return $nodeDataList;
   213|     }
   214|     /**
   215|      * Exports the given Nodes into the XML structure, contained in <nodes> </nodes> tags.
   216|      *
   217|      * @param array $nodeDataList The nodes to export
   218|      * @return void The result is written directly into $this->xmlWriter
   219|      */
   220|     protected function exportNodeDataList(array &$nodeDataList)
   221|     {
   222|         $this->xmlWriter->startElement('nodes');
   223|         $this->xmlWriter->writeAttribute('formatVersion', self::SUPPORTED_FORMAT_VERSION);
   224|         $nodesStack = [];
   225|         foreach ($nodeDataList as $nodeData) {
   226|             $this->exportNodeData($nodeData, $nodesStack);
   227|         }
   228|         while (array_pop($nodesStack)) {
   229|             $this->xmlWriter->endElement();
   230|         }
   231|         $this->xmlWriter->endElement();
   232|     }
   233|     /**
   234|      * Exports a single Node into the XML structure
   235|      *
   236|      * @param array $nodeData The node data as an array
   237|      * @param array $nodesStack The stack keeping track of open tags, as passed by exportNodeDataList()
   238|      * @return void The result is written directly into $this->xmlWriter
   239|      */
   240|     protected function exportNodeData(array &$nodeData, array &$nodesStack)
   241|     {
   242|         if ($nodeData['path'] !== '/' && !isset($this->exportedNodePaths[$nodeData['parentPath']])) {
   243|             $this->xmlWriter->writeComment(sprintf('Skipped node with identifier "%s" and path "%s" because of a missing parent path. This is caused by a broken rootline and needs to be fixed with the "node:repair" command.', $nodeData['identifier'], $nodeData['path']));
   244|             return;
   245|         }
   246|         $this->exportedNodePaths[$nodeData['path']] = true;
   247|         if ($nodeData['parentPath'] === '/') {
   248|             $nodeName = substr($nodeData['path'], 1);
   249|         } else {
   250|             $nodeName = substr($nodeData['path'], strlen($nodeData['parentPath']) + 1);
   251|         }
   252|         $parentNode = end($nodesStack);
   253|         if (!$parentNode || $parentNode['path'] !== $nodeData['path'] || $parentNode['identifier'] !== $nodeData['identifier']) {
   254|             while ($parentNode && $nodeData['parentPath'] !== $parentNode['path']) {
   255|                 $this->xmlWriter->endElement();
   256|                 array_pop($nodesStack);
   257|                 $parentNode = end($nodesStack);
   258|             }
   259|             $nodesStack[] = $nodeData;
   260|             $this->xmlWriter->startElement('node');
   261|             $this->xmlWriter->writeAttribute('identifier', $nodeData['identifier']);
   262|             $this->xmlWriter->writeAttribute('nodeName', $nodeName);
   263|         }
   264|         $this->xmlWriter->startElement('variant');
   265|         if ($nodeData['sortingIndex'] !== null) {
   266|             $this->xmlWriter->writeAttribute('sortingIndex', $nodeData['sortingIndex']);
   267|         }
   268|         foreach (
   269|             [
   270|                 'workspace',
   271|                 'nodeType',
   272|                 'version',
   273|                 'removed',
   274|                 'hidden',
   275|                 'hiddenInIndex'
   276|             ] as $propertyName) {
   277|             $this->xmlWriter->writeAttribute($propertyName, $nodeData[$propertyName]);
   278|         }
   279|         $this->xmlWriter->startElement('dimensions');
   280|         foreach ($nodeData['dimensionValues'] as $dimensionKey => $dimensionValues) {
   281|             foreach ($dimensionValues as $dimensionValue) {
   282|                 $this->xmlWriter->writeElement($dimensionKey, $dimensionValue);
   283|             }
   284|         }
   285|         $this->xmlWriter->endElement();
   286|         foreach (
   287|             [
   288|                 'accessRoles',
   289|                 'hiddenBeforeDateTime',
   290|                 'hiddenAfterDateTime',
   291|                 'creationDateTime',
   292|                 'lastModificationDateTime',
   293|                 'lastPublicationDateTime',
   294|                 'contentObjectProxy'
   295|             ] as $propertyName) {
   296|             $this->writeConvertedElement($nodeData, $propertyName);
   297|         }
   298|         $this->xmlWriter->startElement('properties');
   299|         if ($this->nodeTypeManager->hasNodeType($nodeData['nodeType'])) {
   300|             $nodeType = $this->nodeTypeManager->getNodeType($nodeData['nodeType']);
   301|             foreach ($nodeData['properties'] as $propertyName => $propertyValue) {
   302|                 if ($nodeType->hasConfiguration('properties.' . $propertyName)) {
   303|                     $declaredPropertyType = $nodeType->getPropertyType($propertyName);
   304|                     $this->writeConvertedElement($nodeData['properties'], $propertyName, null, $declaredPropertyType);
   305|                 }
   306|             }
   307|         } else {
   308|             foreach ($nodeData['properties'] as $propertyName => $propertyValue) {
   309|                 $this->writeConvertedElement($nodeData['properties'], $propertyName);
   310|             }
   311|         }
   312|         $this->xmlWriter->endElement(); // "properties"
   313|         $this->xmlWriter->endElement(); // "variant"
   314|     }
   315|     /**
   316|      * Writes out a single property into the XML structure.
   317|      *
   318|      * @param array $data The data as an array, the given property name is looked up there
   319|      * @param string $propertyName The name of the property
   320|      * @param string $elementName an optional name to use, defaults to $propertyName
   321|      * @return void
   322|      */
   323|     protected function writeConvertedElement(array &$data, $propertyName, $elementName = null, $declaredPropertyType = null)
   324|     {
   325|         if (array_key_exists($propertyName, $data) && $data[$propertyName] !== null) {
   326|             $propertyValue = $data[$propertyName];
   327|             $this->xmlWriter->startElement($elementName ?: $propertyName);
   328|             if (!empty($propertyValue)) {
   329|                 switch ($declaredPropertyType) {
   330|                     case null:
   331|                     case 'reference':
   332|                     case 'references':
   333|                         break;
   334|                     default:
   335|                         $propertyValue = $this->propertyMapper->convert($propertyValue, $declaredPropertyType);
   336|                         break;
   337|                 }
   338|             }
   339|             $this->xmlWriter->writeAttribute('__type', gettype($propertyValue));
   340|             try {
   341|                 if (is_object($propertyValue) && !$propertyValue instanceof \DateTimeInterface) {
   342|                     $objectIdentifier = $this->persistenceManager->getIdentifierByObject($propertyValue);
   343|                     if ($objectIdentifier !== null) {
   344|                         $this->xmlWriter->writeAttribute('__identifier', $objectIdentifier);
   345|                     }
   346|                     if ($propertyValue instanceof DoctrineProxy) {
   347|                         $className = get_parent_class($propertyValue);
   348|                     } else {
   349|                         $className = get_class($propertyValue);
   350|                     }
   351|                     $this->xmlWriter->writeAttribute('__classname', $className);
   352|                     $this->xmlWriter->writeAttribute('__encoding', 'json');
   353|                     $converted = json_encode($this->propertyMapper->convert($propertyValue, 'array', $this->propertyMappingConfiguration));
   354|                     $this->xmlWriter->text($converted);
   355|                 } elseif (is_array($propertyValue)) {
   356|                     foreach ($propertyValue as $key => $element) {
   357|                         $this->writeConvertedElement($propertyValue, $key, 'entry' . $key);
   358|                     }
   359|                 } else {
   360|                     if ($propertyValue instanceof \DateTimeInterface) {
   361|                         $this->xmlWriter->writeAttribute('__classname', 'DateTime');
   362|                     }
   363|                     $this->xmlWriter->text($this->propertyMapper->convert($propertyValue, 'string', $this->propertyMappingConfiguration));
   364|                 }
   365|             } catch (\Exception $exception) {
   366|                 $this->xmlWriter->writeComment(sprintf('Could not convert property "%s" to string.', $propertyName));
   367|                 $this->xmlWriter->writeComment($exception->getMessage());
   368|                 $logMessage = $this->throwableStorage->logThrowable($exception);
   369|                 $this->logger->error($logMessage, LogEnvironment::fromMethodName(__METHOD__));
   370|                 $this->exceptionsDuringExport[] = $exception;
   371|             }
   372|             $this->xmlWriter->endElement();
   373|         }
   374|     }
   375|     /**
   376|      * If $this->exceptionsDuringImport is non-empty, build up a new composite exception which contains the individual messages and
   377|      * re-throw that one.
   378|      */
   379|     protected function handleExceptionsDuringExport()
   380|     {
   381|         if (count($this->exceptionsDuringExport) > 0) {
   382|             $exceptionMessages = '';
   383|             foreach ($this->exceptionsDuringExport as $i => $exception) {
   384|                 $exceptionMessages .= "\n" . $i . ': ' . get_class($exception) . "\n" . $exception->getMessage() . "\n";
   385|             }
   386|             throw new ExportException(sprintf('%s exceptions occurred during export. Please see the log for the full exceptions (including stack traces). The exception messages follow below: %s', count($this->exceptionsDuringExport), $exceptionMessages), 1409057360);
   387|         }
   388|     }
   389| }


# ====================================================================
# FILE: Neos.Fusion.Afx/Classes/Service/AfxService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-332 ---
     1| <?php
     2| namespace Neos\Fusion\Afx\Service;
     3| /*
     4|  * This file is part of the Neos.Fusion.Afx package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Fusion\Afx\Parser\Parser as AfxParser;
    14| use Neos\Fusion\Afx\Exception\AfxException;
    15| /**
    16|  * Class AfxService
    17|  *
    18|  * @Flow\Scope("singleton")
    19|  */
    20| class AfxService
    21| {
    22|     const INDENTATION = '    ';
    23|     const SHORTHAND_META_PATHS = ['@if', '@process'];
    24|     /**
    25|      * @var string $afxCode the AFX code that is converted
    26|      * @var string $indentation Indentation to start with
    27|      * @return string
    28|      */
    29|     public static function convertAfxToFusion($afxCode, $indentation = '')
    30|     {
    31|         $parser = new AfxParser(trim($afxCode));
    32|         $ast = $parser->parse();
    33|         $fusion = self::astNodeListToFusion($ast, $indentation);
    34|         return $fusion;
    35|     }
    36|     /**
    37|      * @param array $astNode
    38|      * @param string $indentation
    39|      * @return string
    40|      */
    41|     protected static function astToFusion($ast, $indentation = '')
    42|     {
    43|         switch ($ast['type']) {
    44|             case 'expression':
    45|                 return self::astExpressionToFusion($ast['payload'], $indentation);
    46|                 break;
    47|             case 'string':
    48|                 return self::astStringToFusion($ast['payload'], $indentation);
    49|                 break;
    50|             case 'text':
    51|                 return self::astTextToFusion($ast['payload'], $indentation);
    52|                 break;
    53|             case 'boolean':
    54|                 return self::astBooleanToFusion($ast['payload'], $indentation);
    55|                 break;
    56|             case 'node':
    57|                 return self::astNodeToFusion($ast['payload'], $indentation);
    58|                 break;
    59|             default:
    60|                 throw new AfxException(sprintf('ast type %s is unkonwn', $ast['type']));
    61|         }
    62|     }
    63|     /**
    64|      * @param array $payload
    65|      * @param string $indentation
    66|      * @return string
    67|      */
    68|     protected static function astBooleanToFusion($payload, $indentation = '')
    69|     {
    70|         return 'true';
    71|     }
    72|     /**
    73|      * @param array $payload
    74|      * @param string $indentation
    75|      * @return string
    76|      */
    77|     protected static function astExpressionToFusion($payload, $indentation = '')
    78|     {
    79|         return '${' . $payload . '}';
    80|     }
    81|     /**
    82|      * @param array $payload
    83|      * @param string $indentation
    84|      * @return string
    85|      */
    86|     protected static function astStringToFusion($payload, $indentation = '')
    87|     {
    88|         return '\'' . addslashes($payload) . '\'';
    89|     }
    90|     /**
    91|      * @param array $payload
    92|      * @param string $indentation
    93|      * @return string
    94|      */
    95|     protected static function astTextToFusion($payload, $indentation = '')
    96|     {
    97|         return '\'' . addslashes($payload) . '\'';
    98|     }
    99|     /**
   100|      * @param array $payload
   101|      * @param array $attributePrefix
   102|      * @param string $indentation
   103|      * @return string
   104|      */
   105|     protected static function propListToFusion($payload, $attributePrefix, $indentation = '')
   106|     {
   107|         $fusion = '';
   108|         foreach ($payload as $attribute) {
   109|             if ($attribute['type'] === 'prop') {
   110|                 $prop = $attribute['payload'];
   111|                 $propName = $prop['identifier'];
   112|                 $propFusion = self::astToFusion($prop, $indentation . self::INDENTATION);
   113|                 if ($propFusion !== null) {
   114|                     $fusion .= $indentation . self::INDENTATION . $attributePrefix . $propName . ' = ' . $propFusion . PHP_EOL;
   115|                 }
   116|             }
   117|         }
   118|         return $fusion;
   119|     }
   120|     /**
   121|      * @param array $attributes
   122|      * @return array
   123|      */
   124|     protected static function generatePathForShorthandFusionMetaPath(array $attributes): array
   125|     {
   126|         $indexes = [];
   127|         foreach ($attributes as &$attribute) {
   128|             if ($attribute['type'] !== 'prop') {
   129|                 continue;
   130|             }
   131|             $path = &$attribute['payload']['identifier'];
   132|             $fusionPropertyPathSegments = explode('.', $path);
   133|             $lastPathSegment = end($fusionPropertyPathSegments);
   134|             if (in_array($lastPathSegment, self::SHORTHAND_META_PATHS, true)) {
   135|                 $indexes[$path] ?? $indexes[$path] = 0;
   136|                 $path .= '.' . substr($lastPathSegment, 1) . '_' . ++$indexes[$path];
   137|             }
   138|         }
   139|         return $attributes;
   140|     }
   141|     /**
   142|      * @param array $payload
   143|      * @param string $indentation
   144|      * @return string
   145|      */
   146|     protected static function astNodeToFusion($payload, $indentation = '')
   147|     {
   148|         $tagName = $payload['identifier'];
   149|         $childrenPropertyName = 'content';
   150|         $attributes = $payload['attributes'];
   151|         $attributes = array_filter($attributes, function ($attribute) use (&$childrenPropertyName) {
   152|             if ($attribute['type'] === 'prop') {
   153|                 if ($attribute['payload']['identifier'] === '@key' || $attribute['payload']['identifier'] === '@path') {
   154|                     return false;
   155|                 } elseif ($attribute['payload']['identifier'] === '@children') {
   156|                     if ($attribute['payload']['type'] === 'string') {
   157|                         $childrenPropertyName = $attribute['payload']['payload'];
   158|                     } else {
   159|                         throw new AfxException(
   160|                             sprintf('@children only supports string payloads %s found', $attribute['payload']['type'])
   161|                         );
   162|                     }
   163|                     return false;
   164|                 }
   165|             }
   166|             return true;
   167|         });
   168|         $pathChildren = [];
   169|         $contentChildren = [];
   170|         if ($payload['children'] && count($payload['children']) > 0) {
   171|             foreach ($payload['children'] as $child) {
   172|                 if ($child['type'] === 'node') {
   173|                     $path = null;
   174|                     foreach ($child['payload']['attributes'] as $attribute) {
   175|                         if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'] === '@path') {
   176|                             $pathAttribute = $attribute['payload'];
   177|                             if ($pathAttribute['type'] === 'string') {
   178|                                 $path = $pathAttribute['payload'];
   179|                             } else {
   180|                                 throw new AfxException(
   181|                                     sprintf('@path only supports string payloads %s found', $pathAttribute['type'])
   182|                                 );
   183|                             }
   184|                         }
   185|                     };
   186|                     if ($path) {
   187|                         $pathChildren[$path] = $child;
   188|                         continue;
   189|                     }
   190|                 }
   191|                 $contentChildren[] = $child;
   192|             }
   193|         }
   194|         if (strpos($tagName, ':') !== false) {
   195|             $fusion = $tagName . ' {' . PHP_EOL;
   196|             $attributePrefix = '';
   197|         } else {
   198|             $fusion = 'Neos.Fusion:Tag {' . PHP_EOL;
   199|             $fusion .= $indentation . self::INDENTATION .'tagName = \'' .  $tagName . '\'' . PHP_EOL;
   200|             $attributePrefix = 'attributes.';
   201|             if ($payload['selfClosing'] === true) {
   202|                 $fusion .= $indentation . self::INDENTATION .'selfClosingTag = true' . PHP_EOL;
   203|             }
   204|         }
   205|         if ($attributes !== []) {
   206|             $spreadIsPresent = false;
   207|             $metaAttributes = [];
   208|             $fusionAttributes = [];
   209|             $spreadsOrAttributeLists = [];
   210|             $attributes = self::generatePathForShorthandFusionMetaPath($attributes);
   211|             foreach ($attributes as $attribute) {
   212|                 if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'][0] === '@') {
   213|                     $metaAttributes[] = $attribute;
   214|                 } elseif ($attribute['type'] === 'prop' && $spreadIsPresent === false) {
   215|                     $fusionAttributes[] = $attribute;
   216|                 } elseif ($attribute['type'] === 'spread') {
   217|                     $spreadsOrAttributeLists[] = $attribute;
   218|                     $spreadIsPresent = true;
   219|                 } elseif ($attribute['type'] === 'prop') {
   220|                     $last = end($spreadsOrAttributeLists);
   221|                     $lastPos = key($spreadsOrAttributeLists);
   222|                     if ($last && $last['type'] === 'propList') {
   223|                         $last['payload'][] = $attribute;
   224|                         $spreadsOrAttributeLists[$lastPos] = $last;
   225|                     } else {
   226|                         $spreadsOrAttributeLists[] = [
   227|                             'type' => 'propList',
   228|                             'payload' => [$attribute]
   229|                         ];
   230|                     }
   231|                 }
   232|             }
   233|             if ($fusionAttributes !== []) {
   234|                 $fusion .=  self::propListToFusion($fusionAttributes, $attributePrefix, $indentation);
   235|             }
   236|             $spreadIndex = 1;
   237|             foreach ($spreadsOrAttributeLists as $attribute) {
   238|                 if ($attribute['type'] === 'spread') {
   239|                     if ($attribute['payload']['type'] === 'expression') {
   240|                         $spreadFusion = self::astToFusion($attribute['payload'], $indentation . self::INDENTATION);
   241|                         if ($spreadFusion !== null) {
   242|                             $fusion .= $indentation . self::INDENTATION . $attributePrefix . '@apply.spread_' . $spreadIndex . ' = ' . $spreadFusion . PHP_EOL;
   243|                         }
   244|                     } else {
   245|                         throw new AfxException(
   246|                             sprintf('Spreads only support expression payloads %s found', $attribute['payload']['type'])
   247|                         );
   248|                     }
   249|                 } elseif ($attribute['type'] === 'propList') {
   250|                     $fusion .= $indentation . self::INDENTATION . $attributePrefix . '@apply.spread_' . $spreadIndex . ' = Neos.Fusion:DataStructure {' . PHP_EOL;
   251|                     $fusion .=  self::propListToFusion($attribute['payload'], '', $indentation . self::INDENTATION);
   252|                     $fusion .= $indentation . self::INDENTATION . '}' . PHP_EOL;
   253|                 }
   254|                 $spreadIndex ++;
   255|             }
   256|             if ($metaAttributes !== []) {
   257|                 $fusion .=  self::propListToFusion($metaAttributes, '', $indentation);
   258|             }
   259|         }
   260|         if ($pathChildren !== []) {
   261|             foreach ($pathChildren as $path => $child) {
   262|                 $fusion .= $indentation . self::INDENTATION . $path . ' = ' . self::astToFusion($child, $indentation . self::INDENTATION) . PHP_EOL;
   263|             }
   264|         }
   265|         if ($contentChildren !== []) {
   266|             $childFusion = self::astNodeListToFusion($contentChildren, $indentation . self::INDENTATION);
   267|             if ($childFusion) {
   268|                 $fusion .= $indentation . self::INDENTATION . $childrenPropertyName . ' = ' . $childFusion . PHP_EOL;
   269|             }
   270|         }
   271|         $fusion .= $indentation . '}';
   272|         return $fusion;
   273|     }
   274|     /**
   275|      * @param array $payload
   276|      * @param string $indentation
   277|      * @return string
   278|      */
   279|     protected static function astNodeListToFusion($payload, $indentation = '')
   280|     {
   281|         $index = 1;
   282|         $payload = array_map(function ($astNode) {
   283|             if ($astNode['type'] === 'text') {
   284|                 $astNode['payload'] = preg_replace('/(^[\\s]*\\n[\\s]*|[\\s]*\\n[\\s]*$)/u', '', $astNode['payload']);
   285|                 $astNode['payload'] = preg_replace('/([\\s]*\\n[\\s]*)+/u', ' ', $astNode['payload']);
   286|             }
   287|             return $astNode;
   288|         }, $payload);
   289|         $payload = array_filter($payload, function ($astNode) {
   290|             if ($astNode['type'] === 'text' && $astNode['payload'] == '') {
   291|                 return false;
   292|             }
   293|             if ($astNode['type'] === 'comment') {
   294|                 return false;
   295|             }
   296|             return true;
   297|         });
   298|         if (count($payload) === 0) {
   299|             return '\'\'';
   300|         } elseif (count($payload) === 1) {
   301|             return self::astToFusion(array_shift($payload), $indentation);
   302|         } else {
   303|             $fusion = 'Neos.Fusion:Join {' . PHP_EOL;
   304|             foreach ($payload as $astNode) {
   305|                 $fusionName = 'item_' . $index;
   306|                 if ($astNode['type'] === 'node' && $astNode['payload']['attributes'] !== []) {
   307|                     foreach ($astNode['payload']['attributes'] as $attribute) {
   308|                         if ($attribute['type'] === 'prop' && $attribute['payload']['identifier'] === '@key') {
   309|                             if ($attribute['payload']['type'] === 'string') {
   310|                                 $fusionName = $attribute['payload']['payload'];
   311|                             } else {
   312|                                 throw new AfxException(
   313|                                     sprintf(
   314|                                         '@key only supports string payloads %s was given',
   315|                                         $attribute['payload']['type']
   316|                                     )
   317|                                 );
   318|                             }
   319|                         }
   320|                     }
   321|                 }
   322|                 $nodeFusion = self::astToFusion($astNode, $indentation . self::INDENTATION);
   323|                 if ($nodeFusion !== null) {
   324|                     $fusion .= $indentation . self::INDENTATION . $fusionName . ' = ' . $nodeFusion . PHP_EOL;
   325|                     $index++;
   326|                 }
   327|             }
   328|             $fusion .= $indentation . '}';
   329|             return $fusion;
   330|         }
   331|     }
   332| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Cache/ContentCache.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-388 ---
     1| <?php
     2| namespace Neos\Fusion\Core\Cache;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Cache\CacheAwareInterface;
    14| use Neos\Cache\Frontend\StringFrontend;
    15| use Neos\Flow\Property\PropertyMapper;
    16| use Neos\Flow\Security\Context;
    17| use Neos\Flow\Utility\Algorithms;
    18| use Neos\Fusion\Exception;
    19| use Doctrine\Persistence\Proxy;
    20| use Neos\Fusion\Exception\CacheException;
    21| /**
    22|  * A wrapper around a Neos Flow cache which provides additional functionality for caching partial content (segments)
    23|  * rendered by the Fusion Runtime.
    24|  *
    25|  * The cache build process generally follows these steps:
    26|  *
    27|  *  - render the whole document as usual (for example a page) but insert special markers before and after the rendered segments
    28|  *  - parse the rendered document and extract segments by the previously added markers
    29|  *
    30|  * This results in two artifacts:
    31|  *
    32|  *  - an array of content segments which are later stored as cache entries (if they may be cached)
    33|  *  - a string called "output" which is the originally rendered output but without the markers
    34|  *
    35|  * We use non-visible ASCII characters as markers / tokens in order to minimize potential conflicts with the actual content.
    36|  *
    37|  * Note: If you choose a different cache backend for this content cache, make sure that it is one implementing
    38|  *       TaggableBackendInterface.
    39|  *
    40|  * @Flow\Scope("singleton")
    41|  */
    42| class ContentCache
    43| {
    44|     const CACHE_SEGMENT_START_TOKEN = "\x02";
    45|     const CACHE_SEGMENT_END_TOKEN = "\x03";
    46|     const CACHE_SEGMENT_SEPARATOR_TOKEN = "\x1f";
    47|     const CACHE_SEGMENT_MARKER = 'CONTENT_CACHE';
    48|     const CACHE_PLACEHOLDER_REGEX = "/\x02CONTENT_CACHE(?P<identifier>[a-f0-9]+)\x03CONTENT_CACHE/";
    49|     const EVAL_PLACEHOLDER_REGEX = "/\x02CONTENT_CACHE(?P<command>[^\x02\x1f\x03]+)\x1fCONTENT_CACHE(?P<data>[^\x02\x1f\x03]+)\x03CONTENT_CACHE/";
    50|     const MAXIMUM_NESTING_LEVEL = 32;
    51|     /**
    52|      * A cache entry tag that will be used by default to flush an entry on "every" change - whatever that means to
    53|      * the application.
    54|      */
    55|     const TAG_EVERYTHING = 'Everything';
    56|     const SEGMENT_TYPE_CACHED = 'cached';
    57|     const SEGMENT_TYPE_UNCACHED = 'uncached';
    58|     const SEGMENT_TYPE_DYNAMICCACHED = 'dynamiccached';
    59|     /**
    60|      * @var StringFrontend
    61|      * @Flow\Inject
    62|      */
    63|     protected $cache;
    64|     /**
    65|      * @var PropertyMapper
    66|      * @Flow\Inject
    67|      */
    68|     protected $propertyMapper;
    69|     /**
    70|      * @var Context
    71|      * @Flow\Inject
    72|      */
    73|     protected $securityContext;
    74|     /**
    75|      * @var string
    76|      */
    77|     protected $randomCacheMarker;
    78|     /**
    79|      * ContentCache constructor
    80|      */
    81|     public function __construct()
    82|     {
    83|         $this->randomCacheMarker = Algorithms::generateRandomString(13);
    84|     }
    85|     /**
    86|      * Takes the given content and adds markers for later use as a cached content segment.
    87|      *
    88|      * This function will add a start and an end token to the beginning and end of the content and generate a cache
    89|      * identifier based on the current Fusion path and additional values which were defined in the Fusion
    90|      * configuration by the site integrator.
    91|      *
    92|      * The whole cache segment (START TOKEN + IDENTIFIER + SEPARATOR TOKEN + original content + END TOKEN) is returned
    93|      * as a string.
    94|      *
    95|      * This method is called by the Fusion Runtime while rendering a Fusion object.
    96|      *
    97|      * @param string $content The (partial) content which should potentially be cached later on
    98|      * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
    99|      * @param array $cacheIdentifierValues The values (simple type or implementing CacheAwareInterface) that should be used to create a cache identifier, will be sorted by keys for consistent ordering
   100|      * @param array $tags Tags to add to the cache entry
   101|      * @param integer $lifetime Lifetime of the cache segment in seconds. NULL for the default lifetime and 0 for unlimited lifetime.
   102|      * @return string The original content, but with additional markers and a cache identifier added
   103|      */
   104|     public function createCacheSegment($content, $fusionPath, array $cacheIdentifierValues, array $tags = [], $lifetime = null)
   105|     {
   106|         $cacheIdentifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues);
   107|         $metadata = implode(',', $tags);
   108|         if ($lifetime !== null) {
   109|             $metadata .= ';' . $lifetime;
   110|         }
   111|         return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $cacheIdentifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $metadata . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
   112|     }
   113|     /**
   114|      * Similar to createCacheSegment() creates a content segment with markers added, but in contrast to that function
   115|      * this method is used for rendering a segment which is not supposed to be cached.
   116|      *
   117|      * This method is called by the Fusion Runtime while rendering a Fusion object.
   118|      *
   119|      * @param string $content The content rendered by the Fusion Runtime
   120|      * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
   121|      * @param array $contextVariables Fusion context variables which are needed to correctly render the specified Fusion object
   122|      * @return string The original content, but with additional markers added
   123|      */
   124|     public function createUncachedSegment($content, $fusionPath, array $contextVariables)
   125|     {
   126|         $serializedContext = $this->serializeContext($contextVariables);
   127|         return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . 'eval=' . $fusionPath . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . json_encode(['context' => $serializedContext]) . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
   128|     }
   129|     /**
   130|      * Similar to createUncachedSegment() creates a content segment with markers added, but in contrast to that function
   131|      * this method is used for rendering a segment which will be evaluated at runtime but can still be cached.
   132|      *
   133|      * This method is called by the Fusion Runtime while rendering a Fusion object.
   134|      *
   135|      * @param string $content The content rendered by the Fusion Runtime
   136|      * @param string $fusionPath The Fusion path that rendered the content, for example "page<Acme.Com:Page>/body<Acme.Demo:DefaultPageTemplate>/parts/breadcrumbMenu"
   137|      * @param array $contextVariables Fusion context variables which are needed to correctly render the specified Fusion object
   138|      * @param array $cacheIdentifierValues
   139|      * @param array $tags Tags to add to the cache entry
   140|      * @param integer $lifetime Lifetime of the cache segment in seconds. NULL for the default lifetime and 0 for unlimited lifetime.
   141|      * @param string $cacheDiscriminator The evaluated cache discriminator value
   142|      * @return string The original content, but with additional markers added
   143|      */
   144|     public function createDynamicCachedSegment($content, $fusionPath, array $contextVariables, array $cacheIdentifierValues, array $tags, $lifetime, $cacheDiscriminator)
   145|     {
   146|         $metadata = implode(',', $tags);
   147|         if ($lifetime !== null) {
   148|             $metadata .= ';' . $lifetime;
   149|         }
   150|         $cacheDiscriminator = md5($cacheDiscriminator);
   151|         $identifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues) . '_' . $cacheDiscriminator;
   152|         $segmentData = [
   153|             'path' => $fusionPath,
   154|             'metadata' => $metadata,
   155|             'context' => $this->serializeContext($contextVariables),
   156|         ];
   157|         return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . 'evalCached=' . $identifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . json_encode($segmentData) . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
   158|     }
   159|     /**
   160|      * Renders an identifier for a content cache entry
   161|      *
   162|      * @param string $fusionPath
   163|      * @param array $cacheIdentifierValues
   164|      * @return string An MD5 hash built from the fusionPath and certain elements of the given identifier values
   165|      * @throws CacheException If an invalid entry identifier value is given
   166|      */
   167|     protected function renderContentCacheEntryIdentifier($fusionPath, array $cacheIdentifierValues)
   168|     {
   169|         ksort($cacheIdentifierValues);
   170|         $identifierSource = '';
   171|         foreach ($cacheIdentifierValues as $key => $value) {
   172|             if ($value instanceof CacheAwareInterface) {
   173|                 $identifierSource .= $key . '=' . $value->getCacheEntryIdentifier() . '&';
   174|             } elseif (is_string($value) || is_bool($value) || is_integer($value)) {
   175|                 $identifierSource .= $key . '=' . $value . '&';
   176|             } elseif ($value !== null) {
   177|                 throw new CacheException(sprintf('Invalid cache entry identifier @cache.entryIdentifier.%s for path "%s". A entry identifier value must be a string or implement CacheAwareInterface.', $key, $fusionPath), 1395846615);
   178|             }
   179|         }
   180|         $identifierSource .= 'securityContextHash=' . $this->securityContext->getContextHash();
   181|         return md5($fusionPath . '@' . $identifierSource);
   182|     }
   183|     /**
   184|      * Takes a string of content which includes cache segment markers, extracts the marked segments, writes those
   185|      * segments which can be cached to the actual cache and returns the cleaned up original content without markers.
   186|      *
   187|      * This method is called by the Fusion Runtime while rendering a Fusion object.
   188|      *
   189|      * @param string $content The content with an outer cache segment
   190|      * @param boolean $storeCacheEntries Whether to store extracted cache segments in the cache
   191|      * @return string The (pure) content without cache segment markers
   192|      */
   193|     public function processCacheSegments($content, $storeCacheEntries = true)
   194|     {
   195|         $parser = new CacheSegmentParser($content, $this->randomCacheMarker);
   196|         if ($storeCacheEntries) {
   197|             $segments = $parser->getCacheSegments();
   198|             foreach ($segments as $segment) {
   199|                 $metadata = explode(';', $segment['metadata']);
   200|                 $tagsValue = $metadata[0] === '' ? [] : ($metadata[0] === '*' ? false : explode(',', $metadata[0]));
   201|                 if ($tagsValue !== false) {
   202|                     $lifetime = isset($metadata[1]) ? (integer)$metadata[1] : null;
   203|                     $this->cache->set($segment['identifier'], $segment['content'], $this->sanitizeTags($tagsValue), $lifetime);
   204|                 }
   205|             }
   206|         }
   207|         return $parser->getOutput();
   208|     }
   209|     /**
   210|      * Tries to retrieve the specified content segment from the cache  further nested inline segments are retrieved
   211|      * as well and segments which were not cacheable are rendered.
   212|      *
   213|      * @param \Closure $uncachedCommandCallback A callback to process commands in uncached segments
   214|      * @param string $fusionPath Fusion path identifying the Fusion object to retrieve from the content cache
   215|      * @param array $cacheIdentifierValues Further values which play into the cache identifier hash, must be the same as the ones specified while the cache entry was written
   216|      * @param boolean $addCacheSegmentMarkersToPlaceholders If cache segment markers should be added  this makes sense if the cached segment is about to be included in a not-yet-cached segment
   217|      * @param string|bool $cacheDiscriminator The evaluated cache discriminator value, if any and false if the cache discriminator is disabled for the current context
   218|      * @return string|boolean The segment with replaced cache placeholders, or false if a segment was missing in the cache
   219|      * @throws Exception
   220|      */
   221|     public function getCachedSegment($uncachedCommandCallback, $fusionPath, $cacheIdentifierValues, $addCacheSegmentMarkersToPlaceholders = false, $cacheDiscriminator = null)
   222|     {
   223|         if ($cacheDiscriminator === false || ($addCacheSegmentMarkersToPlaceholders && $cacheDiscriminator !== null)) {
   224|             return false;
   225|         }
   226|         $cacheIdentifier = $this->renderContentCacheEntryIdentifier($fusionPath, $cacheIdentifierValues);
   227|         if ($cacheDiscriminator !== null) {
   228|             $cacheIdentifier .= '_' . md5($cacheDiscriminator);
   229|         }
   230|         $content = $this->cache->get($cacheIdentifier);
   231|         if ($content === false) {
   232|             return false;
   233|         }
   234|         $i = 0;
   235|         do {
   236|             $replaced = $this->replaceCachePlaceholders($content, $addCacheSegmentMarkersToPlaceholders);
   237|             if ($replaced === false) {
   238|                 return false;
   239|             }
   240|             $replaced += $this->replaceUncachedPlaceholders($uncachedCommandCallback, $content);
   241|             if ($i > self::MAXIMUM_NESTING_LEVEL) {
   242|                 throw new Exception('Maximum cache segment level reached', 1391873620);
   243|             }
   244|             $i++;
   245|         } while ($replaced > 0);
   246|         if ($addCacheSegmentMarkersToPlaceholders) {
   247|             return self::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $cacheIdentifier . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . '*' . self::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $content . self::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
   248|         } else {
   249|             return $content;
   250|         }
   251|     }
   252|     /**
   253|      * Find cache placeholders in a cached segment and return the identifiers
   254|      *
   255|      * @param string $content
   256|      * @param boolean $addCacheSegmentMarkersToPlaceholders
   257|      * @return integer|boolean Number of replaced placeholders or false if a placeholder couldn't be found
   258|      */
   259|     protected function replaceCachePlaceholders(&$content, $addCacheSegmentMarkersToPlaceholders)
   260|     {
   261|         $cache = $this->cache;
   262|         $foundMissingIdentifier = false;
   263|         $content = preg_replace_callback(self::CACHE_PLACEHOLDER_REGEX, function ($match) use ($cache, &$foundMissingIdentifier, $addCacheSegmentMarkersToPlaceholders) {
   264|             $identifier = $match['identifier'];
   265|             $entry = $cache->get($identifier);
   266|             if ($entry !== false) {
   267|                 if ($addCacheSegmentMarkersToPlaceholders) {
   268|                     return ContentCache::CACHE_SEGMENT_START_TOKEN . $this->randomCacheMarker . $identifier . ContentCache::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . '*' . ContentCache::CACHE_SEGMENT_SEPARATOR_TOKEN . $this->randomCacheMarker . $entry . ContentCache::CACHE_SEGMENT_END_TOKEN . $this->randomCacheMarker;
   269|                 } else {
   270|                     return $entry;
   271|                 }
   272|             } else {
   273|                 $foundMissingIdentifier = true;
   274|                 return '';
   275|             }
   276|         }, $content, -1, $count);
   277|         if ($foundMissingIdentifier) {
   278|             return false;
   279|         }
   280|         return $count;
   281|     }
   282|     /**
   283|      * Replace segments which are marked as not-cacheable by their actual content by invoking the Fusion Runtime.
   284|      *
   285|      * @param \Closure $uncachedCommandCallback
   286|      * @param string $content The content potentially containing not cacheable segments marked by the respective tokens
   287|      * @return integer Number of replaced placeholders
   288|      */
   289|     protected function replaceUncachedPlaceholders(\Closure $uncachedCommandCallback, &$content)
   290|     {
   291|         $cache = $this->cache;
   292|         $content = preg_replace_callback(self::EVAL_PLACEHOLDER_REGEX, function ($match) use ($uncachedCommandCallback, $cache) {
   293|             $command = $match['command'];
   294|             $additionalData = json_decode($match['data'], true);
   295|             return $uncachedCommandCallback($command, $additionalData, $cache);
   296|         }, $content, -1, $count);
   297|         return $count;
   298|     }
   299|     /**
   300|      * Generates an array of strings from the given array of context variables
   301|      *
   302|      * @param array $contextVariables
   303|      * @return array
   304|      * @throws \InvalidArgumentException
   305|      */
   306|     protected function serializeContext(array $contextVariables)
   307|     {
   308|         $serializedContextArray = [];
   309|         foreach ($contextVariables as $variableName => $contextValue) {
   310|             if ($contextValue !== null) {
   311|                 $serializedContextArray[$variableName]['type'] = $this->getTypeForContextValue($contextValue);
   312|                 $serializedContextArray[$variableName]['value'] = $this->propertyMapper->convert($contextValue, 'string');
   313|             }
   314|         }
   315|         return $serializedContextArray;
   316|     }
   317|     /**
   318|      * TODO: Adapt to Flow change https://review.typo3.org/#/c/33138/
   319|      *
   320|      * @param mixed $contextValue
   321|      * @return string
   322|      */
   323|     protected function getTypeForContextValue($contextValue)
   324|     {
   325|         if (is_object($contextValue)) {
   326|             if ($contextValue instanceof Proxy) {
   327|                 $type = get_parent_class($contextValue);
   328|             } else {
   329|                 $type = get_class($contextValue);
   330|             }
   331|         } else {
   332|             $type = gettype($contextValue);
   333|         }
   334|         return $type;
   335|     }
   336|     /**
   337|      * Flush content cache entries by tag
   338|      *
   339|      * @param string $tag A tag value that was assigned to a cache entry in Fusion, for example "Everything", "Node_[]", "NodeType_[]", "DescendantOf_[]" whereas "" is the node identifier or node type respectively
   340|      * @return integer The number of cache entries which actually have been flushed
   341|      */
   342|     public function flushByTag($tag)
   343|     {
   344|         return $this->cache->flushByTag($this->sanitizeTag($tag));
   345|     }
   346|     /**
   347|      * Flush content cache entries by tags
   348|      *
   349|      * @param array<string> $tags values that were assigned to a cache entry in Fusion, for example "Everything", "Node_[]", "NodeType_[]", "DescendantOf_[]" whereas "" is the node identifier or node type respectively
   350|      * @return integer The number of cache entries which actually have been flushed
   351|      */
   352|     public function flushByTags(array $tags): int
   353|     {
   354|         return $this->cache->flushByTags($this->sanitizeTags($tags));
   355|     }
   356|     /**
   357|      * Flush all content cache entries
   358|      *
   359|      * @return void
   360|      */
   361|     public function flush()
   362|     {
   363|         $this->cache->flush();
   364|     }
   365|     /**
   366|      * Sanitizes the given tag for use with the cache framework
   367|      *
   368|      * @param string $tag A tag which possibly contains non-allowed characters, for example "NodeType_Acme.Com:Page"
   369|      * @return string A cleaned up tag, for example "NodeType_Acme_Com-Page"
   370|      */
   371|     protected function sanitizeTag($tag)
   372|     {
   373|         return strtr($tag, '.:', '_-');
   374|     }
   375|     /**
   376|      * Sanitizes multiple tags with sanitizeTag()
   377|      *
   378|      * @param array $tags Multiple tags
   379|      * @return array The sanitized tags
   380|      */
   381|     protected function sanitizeTags(array $tags)
   382|     {
   383|         foreach ($tags as $key => $value) {
   384|             $tags[$key] = $this->sanitizeTag($value);
   385|         }
   386|         return $tags;
   387|     }
   388| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Cache/ParserCache.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-95 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\Cache;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Cache\Frontend\VariableFrontend;
    15| use Neos\Flow\Package\PackageManager;
    16| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
    17| use Neos\Utility\Unicode\Functions as UnicodeFunctions;
    18| use Neos\Utility\Files;
    19| /**
    20|  * Helper around the ParsePartials Cache.
    21|  * Connected in the boot to flush caches on file-change.
    22|  * Caches partials when requested by the Fusion Parser.
    23|  *
    24|  */
    25| class ParserCache
    26| {
    27|     use ParserCacheIdentifierTrait;
    28|     /**
    29|      * @Flow\Inject
    30|      * @var VariableFrontend
    31|      */
    32|     protected $parsePartialsCache;
    33|     /**
    34|      * @Flow\Inject
    35|      * @var PackageManager
    36|      */
    37|     protected $packageManager;
    38|     /**
    39|      * @Flow\InjectConfiguration(path="enableParsePartialsCache")
    40|      */
    41|     protected $enableCache;
    42|     public function cacheForFusionFile(?string $contextPathAndFilename, \Closure $generateValueToCache): FusionFile
    43|     {
    44|         if ($this->enableCache === false) {
    45|             return $generateValueToCache();
    46|         }
    47|         if ($contextPathAndFilename === null) {
    48|             return $generateValueToCache();
    49|         }
    50|         if (str_contains($contextPathAndFilename, '://')) {
    51|             $contextPathAndFilename = $this->getAbsolutePathForPackageRessourceUri($contextPathAndFilename);
    52|         }
    53|         $identifier = $this->getCacheIdentifierForFile($contextPathAndFilename);
    54|         return $this->cacheForIdentifier($identifier, $generateValueToCache);
    55|     }
    56|     public function cacheForDsl(string $identifier, string $code, \Closure $generateValueToCache): mixed
    57|     {
    58|         if ($this->enableCache === false) {
    59|             return $generateValueToCache();
    60|         }
    61|         $identifier = $this->getCacheIdentifierForDslCode($identifier, $code);
    62|         return $this->cacheForIdentifier($identifier, $generateValueToCache);
    63|     }
    64|     private function cacheForIdentifier(string $identifier, \Closure $generateValueToCache): mixed
    65|     {
    66|         if ($this->parsePartialsCache->has($identifier)) {
    67|             return $this->parsePartialsCache->get($identifier);
    68|         }
    69|         $value = $generateValueToCache();
    70|         $this->parsePartialsCache->set($identifier, $value);
    71|         return $value;
    72|     }
    73|     /**
    74|      * Uses the same technique to resolve a package resource URI like Flow.
    75|      *
    76|      * resource://My.Site/Private/Fusion/Foo/Bar.fusion
    77|      * ->
    78|      * FLOW_PATH_ROOT/Packages/Sites/My.Package/Resources/Private/Fusion/Foo/Bar.fusion
    79|      *
    80|      * {@see \Neos\Flow\ResourceManagement\Streams\ResourceStreamWrapper::evaluateResourcePath()}
    81|      * {@link https://github.com/neos/flow-development-collection/issues/2687}
    82|      *
    83|      * @throws \InvalidArgumentException
    84|      */
    85|     private function getAbsolutePathForPackageRessourceUri(string $requestedPath): string
    86|     {
    87|         $resourceUriParts = UnicodeFunctions::parse_url($requestedPath);
    88|         if ((isset($resourceUriParts['scheme']) === false
    89|             || $resourceUriParts['scheme'] !== 'resource')) {
    90|             throw new \InvalidArgumentException("Unsupported stream wrapper: '$requestedPath'");
    91|         }
    92|         $package = $this->packageManager->getPackage($resourceUriParts['host']);
    93|         return Files::concatenatePaths([$package->getResourcesPath(), $resourceUriParts['path']]);
    94|     }
    95| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Cache/ParserCacheFlusher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-56 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\Cache;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Cache\CacheManager;
    14| /**
    15|  * Helper around the ParsePartials Cache.
    16|  * Connected in the boot to flush caches on file-change.
    17|  *
    18|  */
    19| class ParserCacheFlusher
    20| {
    21|     use ParserCacheIdentifierTrait;
    22|     /**
    23|      * @var CacheManager
    24|      */
    25|     protected $flowCacheManager;
    26|     /**
    27|      * @param CacheManager $flowCacheManager
    28|      */
    29|     public function __construct(CacheManager $flowCacheManager)
    30|     {
    31|         $this->flowCacheManager = $flowCacheManager;
    32|     }
    33|     /**
    34|      * @param $fileMonitorIdentifier
    35|      * @param array $changedFiles
    36|      * @return void
    37|      */
    38|     public function flushPartialCacheOnFileChanges($fileMonitorIdentifier, array $changedFiles)
    39|     {
    40|         if ($fileMonitorIdentifier !== 'Fusion_Files') {
    41|             return;
    42|         }
    43|         $identifiersToFlush = [];
    44|         foreach ($changedFiles as $changedFile => $status) {
    45|             $identifiersToFlush[] = $this->getCacheIdentifierForFile($changedFile);
    46|         }
    47|         if ($identifiersToFlush !== []) {
    48|             $partialsCache = $this->flowCacheManager->getCache('Neos_Fusion_ParsePartials');
    49|             foreach ($identifiersToFlush as $identifierToFlush) {
    50|                 if ($partialsCache->has($identifierToFlush)) {
    51|                     $partialsCache->remove($identifierToFlush);
    52|                 }
    53|             }
    54|         }
    55|     }
    56| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Cache/ParserCacheIdentifierTrait.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-39 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\Cache;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| /**
    14|  * Identifier for the ParsePartials Cache.
    15|  */
    16| trait ParserCacheIdentifierTrait
    17| {
    18|     /**
    19|      * creates a comparable hash of the dsl type and content to be used as cache identifier
    20|      */
    21|     private function getCacheIdentifierForDslCode(string $identifier, string $code): string
    22|     {
    23|         return 'dsl_' . $identifier . '_' . md5($code);
    24|     }
    25|     /**
    26|      * creates a comparable hash of the absolute, resolved $fusionFileName
    27|      *
    28|      * @throws \InvalidArgumentException
    29|      */
    30|     private function getCacheIdentifierForFile(string $fusionFileName): string
    31|     {
    32|         $realPath = realpath($fusionFileName);
    33|         if ($realPath === false) {
    34|             throw new \InvalidArgumentException("Couldn't resolve realpath for: '$fusionFileName'");
    35|         }
    36|         $realFusionFilePathWithoutRoot = str_replace(FLOW_PATH_ROOT, '', $realPath);
    37|         return 'file_' . md5($realFusionFilePathWithoutRoot);
    38|     }
    39| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/DslFactory.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-53 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\ObjectManagement\ObjectManagerInterface;
    15| use Neos\Fusion;
    16| /**
    17|  * This dsl factory takes care of instantiating a Fusion dsl transpilers.
    18|  *
    19|  * @Flow\Scope("singleton")
    20|  */
    21| class DslFactory
    22| {
    23|     /**
    24|      * @Flow\InjectConfiguration("dsl")
    25|      * @var
    26|      */
    27|     protected $dslSettings;
    28|     /**
    29|      * @Flow\Inject
    30|      * @var ObjectManagerInterface
    31|      */
    32|     protected $objectManger;
    33|     /**
    34|      * @param string $identifier
    35|      * @return DslInterface
    36|      * @throws Fusion\Exception
    37|      */
    38|     public function create(string $identifier): DslInterface
    39|     {
    40|         if (isset($this->dslSettings) && is_array($this->dslSettings) && isset($this->dslSettings[$identifier])) {
    41|             $dslObjectName = $this->dslSettings[$identifier];
    42|             if (!class_exists($dslObjectName)) {
    43|                 throw new Fusion\Exception(sprintf('The fusion dsl-object %s was not found.', $dslObjectName), 1490776462);
    44|             }
    45|             $dslObject = new $dslObjectName();
    46|             if (!$dslObject instanceof DslInterface) {
    47|                 throw new Fusion\Exception(sprintf('The fusion dsl-object was of type %s but was supposed to be of type %s', get_class($dslObject), DslInterface::class), 1490776470);
    48|             }
    49|             return new $dslObject();
    50|         }
    51|         throw new Fusion\Exception(sprintf('The fusion dsl-object for the key %s was not configured', $identifier), 1490776550);
    52|     }
    53| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractNode.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-18 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    14| use Neos\Flow\Annotations as Flow;
    15| abstract class AbstractNode
    16| {
    17|     abstract public function visit(AstNodeVisitorInterface $visitor, ...$args);
    18| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractOperation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| abstract class AbstractOperation extends AbstractNode
    15| {
    16| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractPathSegment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| abstract class AbstractPathSegment extends AbstractNode
    15| {
    16| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractPathValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| abstract class AbstractPathValue extends AbstractNode
    15| {
    16| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AbstractStatement.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-16 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| abstract class AbstractStatement extends AbstractNode
    15| {
    16| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/AssignedObjectPath.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class AssignedObjectPath extends AbstractNode
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public ObjectPath $objectPath,
    20|         /** @psalm-readonly */
    21|         public bool $isRelative
    22|     ) {
    23|     }
    24|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    25|     {
    26|         return $visitor->visitAssignedObjectPath($this, ...$args);
    27|     }
    28| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/Block.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class Block extends AbstractNode
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public StatementList $statementList
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitBlock($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/BoolValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class BoolValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public bool $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitBoolValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/CharValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class CharValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitCharValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/DslExpressionValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class DslExpressionValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $identifier,
    20|         /** @psalm-readonly */
    21|         public string $code
    22|     ) {
    23|     }
    24|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    25|     {
    26|         return $visitor->visitDslExpressionValue($this, ...$args);
    27|     }
    28| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/EelExpressionValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class EelExpressionValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitEelExpressionValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FloatValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class FloatValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public float $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitFloatValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FusionFile.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-28 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class FusionFile extends AbstractNode
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public StatementList $statementList,
    20|         /** @psalm-readonly */
    21|         public ?string $contextPathAndFileName
    22|     ) {
    23|     }
    24|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    25|     {
    26|         return $visitor->visitFusionFile($this, ...$args);
    27|     }
    28| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/FusionObjectValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class FusionObjectValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitFusionObjectValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/IncludeStatement.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class IncludeStatement extends AbstractStatement
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $filePattern
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitIncludeStatement($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/IntValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class IntValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public int $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitIntValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/MetaPathSegment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class MetaPathSegment extends AbstractPathSegment
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $identifier
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitMetaPathSegment($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/NullValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class NullValue extends AbstractPathValue
    16| {
    17|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    18|     {
    19|         return $visitor->visitNullValue($this, ...$args);
    20|     }
    21| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ObjectPath.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class ObjectPath extends AbstractNode
    16| {
    17|     /**
    18|      * @psalm-readonly
    19|      * @var AbstractPathSegment[]
    20|      */
    21|     public $segments;
    22|     public function __construct(AbstractPathSegment ...$segments)
    23|     {
    24|         $this->segments = $segments;
    25|     }
    26|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    27|     {
    28|         return $visitor->visitObjectPath($this, ...$args);
    29|     }
    30| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ObjectStatement.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-32 ---
     1| <?php
     2| declare(strict_types=1);
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class ObjectStatement extends AbstractStatement
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public ObjectPath $path,
    20|         /** @psalm-readonly */
    21|         public ValueAssignment|ValueCopy|ValueUnset|null $operation,
    22|         /** @psalm-readonly */
    23|         public ?Block $block,
    24|         /** @psalm-readonly */
    25|         public int $cursor
    26|     ) {
    27|     }
    28|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    29|     {
    30|         return $visitor->visitObjectStatement($this, ...$args);
    31|     }
    32| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/PathSegment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class PathSegment extends AbstractPathSegment
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $identifier
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitPathSegment($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/PrototypePathSegment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class PrototypePathSegment extends AbstractPathSegment
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $identifier
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitPrototypePathSegment($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/SimpleValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class SimpleValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public mixed $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitSimpleValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/StatementList.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-30 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class StatementList extends AbstractNode
    16| {
    17|     /**
    18|      * @psalm-readonly
    19|      * @var AbstractStatement[]
    20|      */
    21|     public $statements = [];
    22|     public function __construct(AbstractStatement ...$statements)
    23|     {
    24|         $this->statements = $statements;
    25|     }
    26|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    27|     {
    28|         return $visitor->visitStatementList($this, ...$args);
    29|     }
    30| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/StringValue.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class StringValue extends AbstractPathValue
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public string $value
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitStringValue($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueAssignment.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class ValueAssignment extends AbstractOperation
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public AbstractPathValue $pathValue
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitValueAssignment($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueCopy.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class ValueCopy extends AbstractOperation
    16| {
    17|     public function __construct(
    18|         /** @psalm-readonly */
    19|         public AssignedObjectPath $assignedObjectPath
    20|     ) {
    21|     }
    22|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    23|     {
    24|         return $visitor->visitValueCopy($this, ...$args);
    25|     }
    26| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Ast/ValueUnset.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-21 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Ast;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Fusion\Core\ObjectTreeParser\AstNodeVisitorInterface;
    15| class ValueUnset extends AbstractOperation
    16| {
    17|     public function visit(AstNodeVisitorInterface $visitor, ...$args)
    18|     {
    19|         return $visitor->visitValueUnset($this, ...$args);
    20|     }
    21| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/AstNodeVisitorInterface.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-57 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
    14| use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
    15| use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
    16| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
    17| use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
    18| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
    19| use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
    20| use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
    21| use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
    22| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
    23| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
    24| use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
    25| use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
    26| use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
    27| use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
    28| use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
    29| use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
    30| use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
    31| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
    32| use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
    33| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
    34| interface AstNodeVisitorInterface
    35| {
    36|     public function visitFusionFile(FusionFile $fusionFile);
    37|     public function visitStatementList(StatementList $statementList);
    38|     public function visitIncludeStatement(IncludeStatement $includeStatement);
    39|     public function visitObjectStatement(ObjectStatement $objectStatement);
    40|     public function visitBlock(Block $block);
    41|     public function visitObjectPath(ObjectPath $objectPath);
    42|     public function visitMetaPathSegment(MetaPathSegment $metaPathSegment);
    43|     public function visitPrototypePathSegment(PrototypePathSegment $prototypePathSegment);
    44|     public function visitPathSegment(PathSegment $pathSegment);
    45|     public function visitValueAssignment(ValueAssignment $valueAssignment);
    46|     public function visitFusionObjectValue(FusionObjectValue $fusionObjectValue);
    47|     public function visitDslExpressionValue(DslExpressionValue $dslExpressionValue);
    48|     public function visitEelExpressionValue(EelExpressionValue $eelExpressionValue);
    49|     public function visitFloatValue(FloatValue $floatValue);
    50|     public function visitIntValue(IntValue $intValue);
    51|     public function visitBoolValue(BoolValue $boolValue);
    52|     public function visitNullValue(NullValue $nullValue);
    53|     public function visitStringValue(StringValue $stringValue);
    54|     public function visitValueCopy(ValueCopy $valueCopy);
    55|     public function visitAssignedObjectPath(AssignedObjectPath $assignedObjectPath);
    56|     public function visitValueUnset(ValueUnset $valueUnset);
    57| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Exception/ParserException.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-193 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Exception;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageLinePart;
    14| use Neos\Fusion\Exception;
    15| /**
    16|  * 'Fluent' exception for the Fusion Parser.
    17|  */
    18| class ParserException extends Exception
    19| {
    20|     protected const RESOURCE_PATH_TO_PACKAGE_AND_CLEANED_PATH_REGEXP = <<<'REGEX'
    21|     `
    22|       ^resource://                  # flow resource wrapper
    23|       (?<packageKey>[^/]+)/         # Acme.Demo/
    24|       (?:Private/Fusion/)?              # ignore default path Private/Fusion/
    25|       (?:\.{1,2}/)*                       # ignore any kind of ./ or ../ greedy (also ./../../../)
    26|       (?<fileLocationOutOfContext>.*)       # left over is a small clean file name with folders.
    27|     `x
    28|     REGEX;
    29|     protected int $fluentCode;
    30|     protected \Closure $fluentMessageCreator;
    31|     protected ?\Throwable $fluentPrevious = null;
    32|     protected ?string $fluentFile;
    33|     protected string $fluentFusion;
    34|     protected int $fluentCursor;
    35|     protected bool $fluentShowColumn = true;
    36|     protected string $headingMessagePart;
    37|     protected string $asciiPreviewMessagePart;
    38|     protected string $helperMessagePart;
    39|     public function __construct()
    40|     {
    41|     }
    42|     public function getHeadingMessagePart(): string
    43|     {
    44|         return $this->headingMessagePart;
    45|     }
    46|     public function getAsciiPreviewMessagePart(): string
    47|     {
    48|         return $this->asciiPreviewMessagePart;
    49|     }
    50|     public function getHelperMessagePart(): string
    51|     {
    52|         return $this->helperMessagePart;
    53|     }
    54|     public function setCode(int $code): self
    55|     {
    56|         $this->fluentCode = $code;
    57|         return $this;
    58|     }
    59|     public function setFile(?string $file): self
    60|     {
    61|         $this->fluentFile = $file;
    62|         return $this;
    63|     }
    64|     public function setFusion(string $fusion): self
    65|     {
    66|         $this->fluentFusion = $fusion;
    67|         return $this;
    68|     }
    69|     public function setCursor(int $cursor): self
    70|     {
    71|         $this->fluentCursor = $cursor;
    72|         return $this;
    73|     }
    74|     public function setPrevious(?\Exception $previous): self
    75|     {
    76|         $this->fluentPrevious = $previous;
    77|         return $this;
    78|     }
    79|     public function setHideColumnInformation(): self
    80|     {
    81|         $this->fluentShowColumn = false;
    82|         return $this;
    83|     }
    84|     /**
    85|      * @param callable(MessageLinePart $next, MessageLinePart $prev): string $messageMaker
    86|      */
    87|     public function setMessageCreator(callable $messageCreator): self
    88|     {
    89|         if ($messageCreator instanceof \Closure === false) {
    90|             $messageCreator = \Closure::fromCallable($messageCreator);
    91|         }
    92|         $this->fluentMessageCreator = $messageCreator;
    93|         return $this;
    94|     }
    95|     public function setMessage(string $message): self
    96|     {
    97|         return $this->setMessageCreator(static function () use ($message) {
    98|             return $message;
    99|         });
   100|     }
   101|     public function build(): self
   102|     {
   103|         $fullMessage = $this->renderAndInitializeFullMessage();
   104|         parent::__construct($fullMessage, $this->fluentCode, $this->fluentPrevious);
   105|         return $this;
   106|     }
   107|     protected function renderAndInitializeFullMessage(): string
   108|     {
   109|         list(
   110|             $lineNumberCursor,
   111|             $linePartAfterCursor,
   112|             $linePartBeforeCursor
   113|             ) = self::splitAtCursorGetLinePartsAndLineNumber($this->fluentFusion, $this->fluentCursor);
   114|         $isEof = strlen($this->fluentFusion) === $this->fluentCursor;
   115|         $nextLine = new MessageLinePart($linePartAfterCursor, $isEof);
   116|         $prevLine = new MessageLinePart($linePartBeforeCursor);
   117|         $columnNumber = mb_strlen($linePartBeforeCursor) + 1;
   118|         $this->headingMessagePart = self::generateHeadingByFileName($this->fluentFile);
   119|         $this->asciiPreviewMessagePart = self::renderErrorLinePreview(
   120|             $this->fluentFile,
   121|             $linePartBeforeCursor . $linePartAfterCursor,
   122|             $lineNumberCursor,
   123|             $columnNumber,
   124|             $this->fluentShowColumn
   125|         );
   126|         $this->helperMessagePart = ($this->fluentMessageCreator)(
   127|             $nextLine,
   128|             $prevLine,
   129|         );
   130|         $fullMessage = $this->headingMessagePart . PHP_EOL . $this->asciiPreviewMessagePart . PHP_EOL . $this->helperMessagePart;
   131|         return $fullMessage;
   132|     }
   133|     protected static function renderErrorLinePreview(
   134|         ?string $fileName,
   135|         string $currentLine,
   136|         int $lineNumber,
   137|         int $columnNumber,
   138|         bool $renderColumnDetails = true
   139|     ): string {
   140|         $fileNameAndPosition = ($fileName ?? '<input>') . ":$lineNumber" . ($renderColumnDetails ? ":$columnNumber" : '');
   141|         $arrowColumn = '';
   142|         if ($renderColumnDetails) {
   143|             $spaceToArrow = str_repeat(' ', $columnNumber - 1);
   144|             $arrowColumn = "$spaceToArrow^ column $columnNumber";
   145|         }
   146|         $indentLine = str_repeat(' ', strlen((string)$lineNumber));
   147|         return <<<MESSAGE
   148|             $fileNameAndPosition
   149|             $indentLine |
   150|             $lineNumber | $currentLine
   151|             $indentLine | $arrowColumn
   152|             MESSAGE;
   153|     }
   154|     protected static function generateHeadingByFileName(?string $fileName): string
   155|     {
   156|         if ($fileName === null) {
   157|             return 'Fusion parser exception while parsing. (No context path and filename set)';
   158|         }
   159|         if (preg_match(self::RESOURCE_PATH_TO_PACKAGE_AND_CLEANED_PATH_REGEXP, $fileName, $matches) === 1) {
   160|             $packageKey = $matches['packageKey'];
   161|             $fileLocationOutOfContext = $matches['fileLocationOutOfContext'];
   162|             return "Fusion parser exception in '$fileLocationOutOfContext' of the package '$packageKey'.";
   163|         }
   164|         return "Fusion parser exception.";
   165|     }
   166|     /**
   167|      * @return array{int, string, string}
   168|      */
   169|     protected static function splitAtCursorGetLinePartsAndLineNumber(string $string, int $cursor): array
   170|     {
   171|         $stringLength = \strlen($string);
   172|         $lineNumberCursor = 1;
   173|         $linePartBeforeCursor = '';
   174|         $linePartAfterCursor = '';
   175|         for ($i = 0; $i < $stringLength; ++$i) {
   176|             $char = $string[$i];
   177|             if ($i < $cursor) {
   178|                 if ($char === "\n") {
   179|                     ++$lineNumberCursor;
   180|                     $linePartBeforeCursor = '';
   181|                     continue;
   182|                 }
   183|                 $linePartBeforeCursor .= $char;
   184|                 continue;
   185|             }
   186|             if ($char === "\n") {
   187|                 break;
   188|             }
   189|             $linePartAfterCursor .= $char;
   190|         }
   191|         return [$lineNumberCursor, $linePartAfterCursor, $linePartBeforeCursor];
   192|     }
   193| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Exception/ParserUnexpectedCharException.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-19 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\Exception;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion\Exception;
    14| /**
    15|  * This exception is thrown when the Parser encounters an unexpected character
    16|  */
    17| class ParserUnexpectedCharException extends Exception
    18| {
    19| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/ExceptionMessage/MessageCreator.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-120 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| /**
    14|  * Creates exception messages for the Fusion parser
    15|  */
    16| class MessageCreator
    17| {
    18|     protected const VALID_OBJECT_PATH = "A valid object path is by '.' delimited path segments: alphanumeric and [:_-], prototype(Foo:Bar), in quotes, or a meta path starting with '@'.";
    19|     public static function forParseStatement(MessageLinePart $next, MessageLinePart $prev): string
    20|     {
    21|         switch ($next->char()) {
    22|             case '/':
    23|                 if ($next->char(1) === '*') {
    24|                     return "Unclosed comment.";
    25|                 }
    26|                 return "Unexpected single {$next->charPrint()}. You can start a comment with '//' or '/*' or '#'.";
    27|             case '"':
    28|             case '\'':
    29|                 return "Unclosed quoted path.";
    30|             case '{':
    31|                 return "Unexpected block start out of context. Check your number of curly braces.";
    32|             case '}':
    33|                 return "Unexpected block end out of context. Check your number of curly braces.";
    34|         }
    35|         return "Unexpected statement starting with: {$next->charPrint()}. " . self::VALID_OBJECT_PATH;
    36|     }
    37|     public static function forParseEndOfStatement(MessageLinePart $next, MessageLinePart $prev): string
    38|     {
    39|         switch ($next->char()) {
    40|             case '/':
    41|                 if ($next->char(1) === '*') {
    42|                     return "Unclosed comment.";
    43|                 }
    44|                 return "Unexpected single {$next->charPrint()}. You can start a comment with '//' or '/*' or '#'.";
    45|         }
    46|         return "Expected end of a statement but found {$next->linePrint()}.";
    47|     }
    48|     public static function forParsePathSegment(MessageLinePart $next, MessageLinePart $prev): string
    49|     {
    50|         switch ($next->char()) {
    51|             case '"':
    52|             case '\'':
    53|                 return "A quoted object path starting with {$next->charPrint()} was not closed.";
    54|             case ' ':
    55|                 if ($prev->char(-1) === '.') {
    56|                     return "No <space> is allowed after a separating '.' in an object path.";
    57|                 }
    58|                 return "Unexpected {$next->charPrint()} in object path.";
    59|         }
    60|         return "Unexpected object path starting with: {$next->charPrint()}. "  . self::VALID_OBJECT_PATH;
    61|     }
    62|     public static function forPathSegmentPrototypeName(MessageLinePart $next, MessageLinePart $prev): string
    63|     {
    64|         if (preg_match('/^[a-zA-Z0-9.]++(?!:)/', $next->line()) === 1) {
    65|             return "Prototype name without namespace starting with {$next->charPrint()} - Default namespaces were removed. You might want to add 'Neos.Fusion:' in front.";
    66|         }
    67|         if (str_starts_with(trim($next->line()), ')')) {
    68|             return "A prototype name must be set. Unexpected char {$next->charPrint()}.";
    69|         }
    70|         return "Unexpected prototype name starting with: {$next->linePrint()}.";
    71|     }
    72|     public static function forParsePathOrOperator(MessageLinePart $next, MessageLinePart $prev): string
    73|     {
    74|         if (preg_match('/.*namespace\s*:\s*$/', $prev->line()) === 1) {
    75|             return "It looks like you want to declare a namespace alias. The feature to alias namespaces was removed.";
    76|         }
    77|         if (preg_match('/.*include\s*$/', $prev->line()) === 1) {
    78|             return "Did you want to include a Fusion file? 'include: FileName.fusion'.";
    79|         }
    80|         if ($prev->char(-1) === ' ' && $next->char() === '.') {
    81|             return "Nested paths, separated by {$next->charPrint()} cannot contain spaces.";
    82|         }
    83|         if ($prev->char(-1) === ' ') {
    84|             return "Unknown operator starting with {$next->charPrint()}. (Or you have unwanted spaces in your object path).";
    85|         }
    86|         if ($next->char() === '(') {
    87|             return "An unquoted path segment cannot contain {$next->charPrint()}. Did you want to declare a prototype? 'prototype(Foo:Bar)'.";
    88|         }
    89|         if ($next->char() === '') {
    90|             return "Object path without operator or block start. Found: {$next->charPrint()}.";
    91|         }
    92|         return "Unknown operator or path segment at {$next->charPrint()}. Unquoted paths can contain only alphanumerics and [:_-]. Otherwise, put them in quotes.";
    93|     }
    94|     public static function forParseDslExpression(MessageLinePart $next, MessageLinePart $prev): string
    95|     {
    96|         return "A dsl expression starting with {$next->linePrint(1)} was not closed.";
    97|     }
    98|     public static function forParsePathValue(MessageLinePart $next, MessageLinePart $prev): string
    99|     {
   100|         if (preg_match('/^[a-zA-Z0-9.]++(?!:)/', $next->line()) === 1) {
   101|             return "Unexpected {$next->linePrint()} in value assignment - It looks like an object without namespace. Default namespaces were removed. You might want to add 'Neos.Fusion:' in front.";
   102|         }
   103|         switch ($next->char()) {
   104|             case '':
   105|                 return "No value specified in assignment.";
   106|             case '"':
   107|                 return "Unclosed quoted string.";
   108|             case '\'':
   109|                 return "Unclosed char sequence.";
   110|             case '`':
   111|                 return "Template literals without DSL identifier are not supported.";
   112|             case '$':
   113|                 if ($next->char(1) === '{') {
   114|                     return "Unclosed eel expression.";
   115|                 }
   116|                 return "Did you want to start an eel expression: '\${...}'?";
   117|         }
   118|         return "Unexpected character in assignment starting with {$next->charPrint()}.";
   119|     }
   120| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/ExceptionMessage/MessageLinePart.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-74 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| class MessageLinePart
    14| {
    15|     public function __construct(
    16|         protected string $linePart,
    17|         protected bool $isEof = false
    18|     ) {
    19|     }
    20|     public function line(int $offset = 0): string
    21|     {
    22|         return mb_substr($this->linePart, $offset);
    23|     }
    24|     public function linePrint(int $offset = 0): string
    25|     {
    26|         $line = $this->line($offset);
    27|         if (mb_strlen($line) > 1) {
    28|             return "'$line'";
    29|         }
    30|         return $this->charPrint($offset);
    31|     }
    32|     public function char(int $index = 0): string
    33|     {
    34|         if ($index < 0) {
    35|             return mb_substr($this->linePart, $index, 1);
    36|         }
    37|         return mb_substr($this->linePart, $index, $index + 1);
    38|     }
    39|     public function charPrint(int $index = 0): string
    40|     {
    41|         if ($this->isEof) {
    42|             return '<EOF>';
    43|         }
    44|         return self::printable($this->char($index));
    45|     }
    46|     protected static function printable(string $char): string
    47|     {
    48|         if ($char === '') {
    49|             return '<new line>';
    50|         }
    51|         return match (mb_ord($char)) {
    52|             0 => "<null>",
    53|             9 => "<horizontal tab>",
    54|             10 => "<line feed>",
    55|             11 => "<vertical tab>",
    56|             13 => "<carriage return>",
    57|             25 => "<end of medium>",
    58|             27 => "<escape>",
    59|             32 => "<space>",
    60|             34 => "<double quote>",
    61|             39 => "<single quote>",
    62|             47 => "<slash>",
    63|             92 => "<backslash>",
    64|             130 => "<single low-9 quotation mark>",
    65|             132 => "<double low-9 quotation mark>",
    66|             145 => "<left single quotation mark>",
    67|             146 => "<right single quotation mark>",
    68|             147 => "<left double quotation mark>",
    69|             148 => "<right double quotation mark>",
    70|             160 => "<non-breaking space>",
    71|             default => "'$char'",
    72|         };
    73|     }
    74| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/FilePatternResolver.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-127 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion;
    14| /**
    15|  * Resolve files after a pattern.
    16|  * The returned files will not be checked for recursion and for readability.
    17|  */
    18| class FilePatternResolver
    19| {
    20|     protected const RECURSIVE_GLOB_PATTERN = <<<'REGEX'
    21|     `^(?P<base>
    22|         [^*/]*          # simple case: path segment without '*' stop at '/'
    23|         (?:
    24|             /[^*]       # special case '/' no followed '*' is matched
    25|             [^*/]*      # simple case again - unrolled loop following Jeffrey Friedl
    26|         )*
    27|     )
    28|     /\*\*/\*            # the recursive include /**/*
    29|     (?P<end>
    30|         [^*/]*          # optional file end like .fusion or even -special.fusion but no further globbing or folders allowed
    31|     )$`x
    32|     REGEX;
    33|     protected const SIMPLE_GLOB_PATTERN = <<<'REGEX'
    34|     `^(?P<base>
    35|         [^*/]*          # simple case: path segment without '*' stop at '/'
    36|         (?:
    37|             /[^*]       # special case '/' no followed '*' is matched
    38|             [^*/]*      # simple case again - unrolled loop following Jeffrey Friedl
    39|         )*
    40|     )
    41|     /\*                 # the simple glob include /*
    42|     (?P<end>
    43|         [^*/]*          # optional file end like .fusion or even -special.fusion but no further globbing or folders allowed
    44|     )$`x
    45|     REGEX;
    46|     /**
    47|      * @param string $filePattern
    48|      * @param string|null $filePathForRelativeResolves
    49|      * @param string $defaultFileEndForUnspecificGlobbing
    50|      * @return array|string[]
    51|      * @throws Fusion\Exception
    52|      */
    53|     public static function resolveFilesByPattern(string $filePattern, ?string $filePathForRelativeResolves = null, string $defaultFileEndForUnspecificGlobbing = '.fusion'): array
    54|     {
    55|         $filePattern = trim($filePattern);
    56|         if ($filePattern === '') {
    57|             throw new Fusion\Exception("cannot resolve empty pattern: '$filePattern'", 1636144288);
    58|         }
    59|         if ($filePattern[0] === '/') {
    60|             throw new Fusion\Exception("cannot resolve absolute pattern: '$filePattern'", 1636144292);
    61|         }
    62|         if (self::isPatternStreamWrapper($filePattern) === false) {
    63|             $filePattern = self::resolveRelativePath($filePattern, $filePathForRelativeResolves);
    64|         }
    65|         if (str_contains($filePattern, '*') === false) {
    66|             return [$filePattern];
    67|         }
    68|         return self::parseGlobPatternAndResolveFiles($filePattern, $defaultFileEndForUnspecificGlobbing);
    69|     }
    70|     protected static function isPatternStreamWrapper(string $filePattern): bool
    71|     {
    72|         if (preg_match('`^(?P<protocol>[^:]+)://`', $filePattern, $matches) !== 1) {
    73|             return false;
    74|         }
    75|         $streamWrapper = $matches['protocol'];
    76|         if (in_array($streamWrapper, stream_get_wrappers(), true) === false) {
    77|             throw new Fusion\Exception("Unable to find the stream wrapper '$streamWrapper' while resolving the pattern: '$filePattern'", 1636144734);
    78|         }
    79|         return true;
    80|     }
    81|     protected static function resolveRelativePath(string $filePattern, ?string $filePathForRelativeResolves): string
    82|     {
    83|         if ($filePathForRelativeResolves === null) {
    84|             throw new Fusion\Exception('Relative file resolves are only possible with the argument $filePathForRelativeResolves passed.', 1636144731);
    85|         }
    86|         return dirname($filePathForRelativeResolves) . '/' . $filePattern;
    87|     }
    88|     protected static function parseGlobPatternAndResolveFiles(string $filePattern, string $defaultFileNameEnd): array
    89|     {
    90|         $fileIteratorCreator = match (1) {
    91|             preg_match(self::RECURSIVE_GLOB_PATTERN, $filePattern, $matches) => static function (string $dir): \Iterator {
    92|                 $recursiveDirectoryIterator = new \RecursiveDirectoryIterator($dir);
    93|                 return new \RecursiveIteratorIterator($recursiveDirectoryIterator);
    94|             },
    95|             preg_match(self::SIMPLE_GLOB_PATTERN, $filePattern, $matches) => static function (string $dir): \Iterator {
    96|                 return new \DirectoryIterator($dir);
    97|             },
    98|             default => throw new Fusion\Exception("The include glob pattern '$filePattern' is invalid. Only globbing with /**/* or /* is supported.", 1636144713),
    99|         };
   100|         $basePath = $matches['base'];
   101|         $fileNameEnd = $matches['end'] === '' ? $defaultFileNameEnd : $matches['end'];
   102|         if (is_dir($basePath) === false) {
   103|             throw new Fusion\Exception("The path '$basePath' of the glob pattern '$filePattern' does not point to a directory.", 1636144717);
   104|         }
   105|         $fileIterator = $fileIteratorCreator($basePath);
   106|         return self::iterateOverFilesAndSelectByFileEnding($fileIterator, $fileNameEnd);
   107|     }
   108|     /**
   109|      * @param \Iterator|\SplFileInfo[] $fileIterator
   110|      * @param string $fileNameEnd when file matches this ending it will be included.
   111|      * @return array
   112|      */
   113|     protected static function iterateOverFilesAndSelectByFileEnding(\Iterator $fileIterator, string $fileNameEnd): array
   114|     {
   115|         $files = [];
   116|         foreach ($fileIterator as $fileInfo) {
   117|             if ($fileInfo->isDir()) {
   118|                 continue;
   119|             }
   120|             $pathAndFilename = $fileInfo->getPathname();
   121|             if (str_ends_with($pathAndFilename, $fileNameEnd)) {
   122|                 $files[] = $pathAndFilename;
   123|             }
   124|         }
   125|         return $files;
   126|     }
   127| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Lexer.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-137 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| class Lexer
    14| {
    15|     protected const PATTERN_EEL_EXPRESSION = <<<'REGEX'
    16|     /
    17|       ^\${(?P<exp>
    18|         (?>
    19|           { (?P>exp) }          # match object literal expression recursively
    20|           |[^{}"']+	            # simple eel expression without quoted strings
    21|           |"[^"\\]*			    # double quoted strings with possibly escaped double quotes
    22|             (?:
    23|               \\.			# escaped character (quote)
    24|               [^"\\]*		# unrolled loop following Jeffrey E.F. Friedl
    25|             )*"
    26|           |'[^'\\]*			# single quoted strings with possibly escaped single quotes
    27|             (?:
    28|               \\.			# escaped character (quote)
    29|               [^'\\]*		# unrolled loop following Jeffrey E.F. Friedl
    30|             )*'
    31|         )*
    32|       )}
    33|     /x
    34|     REGEX;
    35|     protected const TOKEN_REGEX = [
    36|         Token::SLASH_COMMENT => '/^\\/\\/.*/',
    37|         Token::HASH_COMMENT => '/^#.*/',
    38|         Token::MULTILINE_COMMENT => <<<'REGEX'
    39|         `^
    40|           /\*               # start of a comment '/*'
    41|           [^*]*             # match everything until special case '*'
    42|           (?:
    43|             \*[^/]          # if after the '*' there is a '/' break, else continue
    44|             [^*]*           # until the special case '*' is encountered - unrolled loop following Jeffrey Friedl
    45|           )*
    46|           \*/               # the end of a comment.
    47|         `x
    48|         REGEX,
    49|         Token::NEWLINE => '/^[\n\r]+/',
    50|         Token::SPACE => '/^[ \t]+/',
    51|         Token::TRUE_VALUE => '/^(?>true|TRUE)\\b/',
    52|         Token::FALSE_VALUE => '/^(?>false|FALSE)\\b/',
    53|         Token::NULL_VALUE => '/^(?>null|NULL)\\b/',
    54|         Token::INTEGER => '/^-?[0-9]+/',
    55|         Token::FLOAT => '/^-?[0-9]+\.[0-9]+/',
    56|         Token::DSL_EXPRESSION_START => '/^[a-zA-Z0-9\.]++(?=`)/',
    57|         Token::DSL_EXPRESSION_CONTENT => '/^`[^`]*+`/',
    58|         Token::EEL_EXPRESSION => self::PATTERN_EEL_EXPRESSION,
    59|         Token::FUSION_OBJECT_NAME => '/^[0-9a-zA-Z.]+:[0-9a-zA-Z.]+/',
    60|         Token::INCLUDE => '/^include\\s*:/',
    61|         Token::PROTOTYPE_START => '/^prototype\(/',
    62|         Token::META_PATH_START => '/^@/',
    63|         Token::OBJECT_PATH_PART => '/^[a-zA-Z0-9_:-]+/',
    64|         Token::ASSIGNMENT => '/^=/',
    65|         Token::COPY => '/^</',
    66|         Token::UNSET => '/^>/',
    67|         Token::DOT => '/^\./',
    68|         Token::COLON => '/^:/',
    69|         Token::RPAREN => '/^\)/',
    70|         Token::LBRACE => '/^{/',
    71|         Token::RBRACE => '/^}/',
    72|         Token::STRING_DOUBLE_QUOTED => <<<'REGEX'
    73|         /^
    74|           "[^"\\]*              # double quoted strings with possibly escaped double quotes
    75|             (?:
    76|               \\.               # escaped character (quote)
    77|               [^"\\]*           # unrolled loop following Jeffrey E.F. Friedl
    78|             )*
    79|           "
    80|         /x
    81|         REGEX,
    82|         Token::STRING_SINGLE_QUOTED => <<<'REGEX'
    83|         /^
    84|           '[^'\\]*              # single quoted strings with possibly escaped single quotes
    85|             (?:
    86|               \\.               # escaped character (quote)
    87|               [^'\\]*           # unrolled loop following Jeffrey E.F. Friedl
    88|             )*
    89|           '
    90|         /x
    91|         REGEX,
    92|         Token::FILE_PATTERN => '`^[a-zA-Z0-9.*:/_-]+`',
    93|     ];
    94|     protected string $code = '';
    95|     protected int $codeLen = 0;
    96|     protected int $cursor = 0;
    97|     protected ?Token $lookahead = null;
    98|     public function __construct(string $code)
    99|     {
   100|         $code = str_replace(["\r\n", "\r"], "\n", $code);
   101|         $this->code = $code;
   102|         $this->codeLen = strlen($code);
   103|     }
   104|     public function getCode(): string
   105|     {
   106|         return $this->code;
   107|     }
   108|     public function getCursor(): int
   109|     {
   110|         return $this->cursor;
   111|     }
   112|     public function consumeLookahead(): Token
   113|     {
   114|         $token = $this->lookahead;
   115|         $this->lookahead = null;
   116|         return $token;
   117|     }
   118|     public function getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead(int $tokenType): ?Token
   119|     {
   120|         if ($this->lookahead !== null) {
   121|             return $this->lookahead;
   122|         }
   123|         if ($this->cursor === $this->codeLen) {
   124|             return $this->lookahead = new Token(Token::EOF, '');
   125|         }
   126|         if ($tokenType === Token::EOF) {
   127|             return null;
   128|         }
   129|         $regexForToken = self::TOKEN_REGEX[$tokenType];
   130|         $remainingCode = substr($this->code, $this->cursor);
   131|         if (preg_match($regexForToken, $remainingCode, $matches) !== 1) {
   132|             return null;
   133|         }
   134|         $this->cursor += \strlen($matches[0]);
   135|         return $this->lookahead = new Token($tokenType, $matches[0]);
   136|     }
   137| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/MergedArrayTree.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-103 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion;
    14| use Neos\Utility\Arrays;
    15| class MergedArrayTree
    16| {
    17|     public function __construct(
    18|         protected array $tree = []
    19|     ) {
    20|     }
    21|     public static function pathIsPrototype(array $path): bool
    22|     {
    23|         return ($path[count($path) - 2] ?? null) === '__prototypes';
    24|     }
    25|     public static function getParentPath(array $path): array
    26|     {
    27|         if (self::pathIsPrototype($path)) {
    28|             return array_slice($path, 0, -2);
    29|         }
    30|         return array_slice($path, 0, -1);
    31|     }
    32|     public function getTree(): array
    33|     {
    34|         return $this->tree;
    35|     }
    36|     public function removeValueInTree(array $path): void
    37|     {
    38|         $this->tree = Arrays::unsetValueByPath($this->tree, $path);
    39|         $this->setValueInTree($path, ['__stopInheritanceChain' => true]);
    40|     }
    41|     public function copyValueInTree(array $targetPath, array $sourcePath): void
    42|     {
    43|         $originalValue = Arrays::getValueByPath($this->tree, $sourcePath);
    44|         $this->setValueInTree($targetPath, $originalValue);
    45|     }
    46|     /**
    47|      * @param scalar|null|array $value The value to assign, either a scalar type or an array with __eelExpression etc.
    48|      */
    49|     public function setValueInTree(array $path, $value): void
    50|     {
    51|         self::arraySetOrMergeValueByPathWithCallback($this->tree, $path, $value, static function ($simpleType) {
    52|             return [
    53|                 '__value' => $simpleType,
    54|                 '__eelExpression' => null,
    55|                 '__objectType' => null
    56|             ];
    57|         });
    58|     }
    59|     protected static function arraySetOrMergeValueByPathWithCallback(array &$subject, array $path, $value, callable $toArray): void
    60|     {
    61|         $pointer = &$subject;
    62|         foreach ($path as $pathSegment) {
    63|             if ($pointer === null) {
    64|                 $pointer = [];
    65|             }
    66|             if (is_array($pointer) === false) {
    67|                 $pointer = $toArray($pointer);
    68|             }
    69|             $pointer = &$pointer[$pathSegment];
    70|         }
    71|         if (is_array($pointer)) {
    72|             $arrayValue = is_array($value) ? $value : $toArray($value);
    73|             $pointer = Arrays::arrayMergeRecursiveOverrule($pointer, $arrayValue);
    74|             return;
    75|         }
    76|         $pointer = $value;
    77|     }
    78|     /**
    79|      * Precalculate merged configuration for inherited prototypes.
    80|      *
    81|      * @throws Fusion\Exception
    82|      */
    83|     public function buildPrototypeHierarchy(): void
    84|     {
    85|         if (isset($this->tree['__prototypes']) === false) {
    86|             return;
    87|         }
    88|         foreach (array_keys($this->tree['__prototypes']) as $prototypeName) {
    89|             $prototypeInheritanceHierarchy = [];
    90|             $currentPrototypeName = $prototypeName;
    91|             while (isset($this->tree['__prototypes'][$currentPrototypeName]['__prototypeObjectName'])) {
    92|                 $currentPrototypeName = $this->tree['__prototypes'][$currentPrototypeName]['__prototypeObjectName'];
    93|                 array_unshift($prototypeInheritanceHierarchy, $currentPrototypeName);
    94|                 if ($prototypeName === $currentPrototypeName) {
    95|                     throw new Fusion\Exception(sprintf('Recursive inheritance found for prototype "%s". Prototype chain: %s', $prototypeName, implode(' < ', array_reverse($prototypeInheritanceHierarchy))), 1492801503);
    96|                 }
    97|             }
    98|             if (count($prototypeInheritanceHierarchy)) {
    99|                 $this->tree['__prototypes'][$prototypeName]['__prototypeChain'] = $prototypeInheritanceHierarchy;
   100|             }
   101|         }
   102|     }
   103| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/MergedArrayTreeVisitor.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-236 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
    14| use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
    15| use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
    16| use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
    17| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
    18| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
    19| use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
    20| use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
    21| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
    22| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
    23| use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
    24| use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
    25| use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
    26| use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
    27| use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
    28| use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
    29| use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
    30| use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
    31| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
    32| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
    33| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
    34| use Neos\Fusion;
    35| use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserException;
    36| /**
    37|  * Builds the merged array tree for the Fusion runtime
    38|  */
    39| class MergedArrayTreeVisitor implements AstNodeVisitorInterface
    40| {
    41|     /**
    42|      * For nested blocks to determine the prefix
    43|      */
    44|     protected array $currentObjectPathStack = [];
    45|     protected ?string $contextPathAndFilename;
    46|     protected int $currentObjectStatementCursor;
    47|     public function __construct(
    48|         protected MergedArrayTree $mergedArrayTree,
    49|         protected \Closure $handleFileInclude,
    50|         protected \Closure $handleDslTranspile
    51|     ) {
    52|     }
    53|     public function visitFusionFile(FusionFile $fusionFile): MergedArrayTree
    54|     {
    55|         $this->contextPathAndFilename = $fusionFile->contextPathAndFileName;
    56|         $fusionFile->statementList->visit($this);
    57|         return $this->mergedArrayTree;
    58|     }
    59|     public function visitStatementList(StatementList $statementList)
    60|     {
    61|         foreach ($statementList->statements as $statement) {
    62|             $statement->visit($this);
    63|         }
    64|     }
    65|     public function visitIncludeStatement(IncludeStatement $includeStatement)
    66|     {
    67|         ($this->handleFileInclude)($this->mergedArrayTree, $includeStatement->filePattern, $this->contextPathAndFilename);
    68|     }
    69|     public function visitObjectStatement(ObjectStatement $objectStatement)
    70|     {
    71|         $this->currentObjectStatementCursor = $objectStatement->cursor;
    72|         $currentPath = $objectStatement->path->visit($this, $this->getCurrentObjectPathPrefix());
    73|         $objectStatement->operation?->visit($this, $currentPath);
    74|         $objectStatement->block?->visit($this, $currentPath);
    75|     }
    76|     public function visitBlock(Block $block, array $currentPath = null)
    77|     {
    78|         $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
    79|         array_push($this->currentObjectPathStack, $currentPath);
    80|         $block->statementList->visit($this);
    81|         array_pop($this->currentObjectPathStack);
    82|     }
    83|     public function visitObjectPath(ObjectPath $objectPath, array $objectPathPrefix = []): array
    84|     {
    85|         $path = $objectPathPrefix;
    86|         foreach ($objectPath->segments as $segment) {
    87|             $path = [...$path, ...$segment->visit($this)];
    88|         }
    89|         return $path;
    90|     }
    91|     public function visitMetaPathSegment(MetaPathSegment $metaPathSegment): array
    92|     {
    93|         return ['__meta', $metaPathSegment->identifier];
    94|     }
    95|     public function visitPrototypePathSegment(PrototypePathSegment $prototypePathSegment): array
    96|     {
    97|         return ['__prototypes', $prototypePathSegment->identifier];
    98|     }
    99|     public function visitPathSegment(PathSegment $pathSegment): array
   100|     {
   101|         $key = stripslashes($pathSegment->identifier);
   102|         self::validateParseTreeKey($key);
   103|         return [$key];
   104|     }
   105|     public function visitValueAssignment(ValueAssignment $valueAssignment, array $currentPath = null)
   106|     {
   107|         $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
   108|         $value = $valueAssignment->pathValue->visit($this);
   109|         $this->mergedArrayTree->setValueInTree($currentPath, $value);
   110|     }
   111|     public function visitFusionObjectValue(FusionObjectValue $fusionObjectValue)
   112|     {
   113|         return [
   114|             '__objectType' => $fusionObjectValue->value, '__value' => null, '__eelExpression' => null
   115|         ];
   116|     }
   117|     public function visitDslExpressionValue(DslExpressionValue $dslExpressionValue)
   118|     {
   119|         try {
   120|             return ($this->handleDslTranspile)($dslExpressionValue->identifier, $dslExpressionValue->code);
   121|         } catch (ParserException $e) {
   122|             throw $e;
   123|         } catch (\Exception $e) {
   124|             throw $this->prepareParserException(new ParserException())
   125|                 ->setCode(1180600696)
   126|                 ->setMessage($e->getMessage())
   127|                 ->build();
   128|         }
   129|     }
   130|     public function visitEelExpressionValue(EelExpressionValue $eelExpressionValue)
   131|     {
   132|         $eelWithoutNewLines = str_replace("\n", '', $eelExpressionValue->value);
   133|         return [
   134|             '__eelExpression' => $eelWithoutNewLines, '__value' => null, '__objectType' => null
   135|         ];
   136|     }
   137|     public function visitFloatValue(FloatValue $floatValue)
   138|     {
   139|         return $floatValue->value;
   140|     }
   141|     public function visitIntValue(IntValue $intValue)
   142|     {
   143|         return $intValue->value;
   144|     }
   145|     public function visitBoolValue(BoolValue $boolValue)
   146|     {
   147|         return $boolValue->value;
   148|     }
   149|     public function visitNullValue(NullValue $nullValue)
   150|     {
   151|         return null;
   152|     }
   153|     public function visitStringValue(StringValue $stringValue): string
   154|     {
   155|         return $stringValue->value;
   156|     }
   157|     public function visitValueCopy(ValueCopy $valueCopy, array $currentPath = null)
   158|     {
   159|         $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
   160|         $sourcePath = $valueCopy->assignedObjectPath->visit($this, $this->mergedArrayTree->getParentPath($currentPath));
   161|         $currentPathsPrototype = $this->mergedArrayTree->pathIsPrototype($currentPath);
   162|         $sourcePathIsPrototype = $this->mergedArrayTree->pathIsPrototype($sourcePath);
   163|         if ($currentPathsPrototype && $sourcePathIsPrototype) {
   164|             if (count($currentPath) !== 2 || count($sourcePath) !== 2) {
   165|                 throw $this->prepareParserException(new ParserException())
   166|                     ->setCode(1358418019)
   167|                     ->setMessage('Cannot inherit, when one of the sides is nested (e.g. foo.prototype(Bar)). Setting up prototype inheritance is only supported at the top level: prototype(Foo) < prototype(Bar)')
   168|                     ->build();
   169|             }
   170|             $currentPath[] = '__prototypeObjectName';
   171|             $this->mergedArrayTree->setValueInTree($currentPath, end($sourcePath));
   172|             return;
   173|         }
   174|         if ($currentPathsPrototype xor $sourcePathIsPrototype) {
   175|             throw $this->prepareParserException(new ParserException())
   176|                 ->setCode(1358418015)
   177|                 ->setMessage("Cannot inherit, when one of the sides is no prototype definition of the form prototype(Foo). It is only allowed to build inheritance chains with prototype objects.")
   178|                 ->build();
   179|         }
   180|         $this->mergedArrayTree->copyValueInTree($currentPath, $sourcePath);
   181|     }
   182|     public function visitAssignedObjectPath(AssignedObjectPath $assignedObjectPath, $relativePath = [])
   183|     {
   184|         $path = [];
   185|         if ($assignedObjectPath->isRelative) {
   186|             $path = $relativePath;
   187|         }
   188|         return $assignedObjectPath->objectPath->visit($this, $path);
   189|     }
   190|     public function visitValueUnset(ValueUnset $valueUnset, array $currentPath = null)
   191|     {
   192|         $currentPath ?? throw new \BadMethodCallException('$currentPath is required.');
   193|         $this->mergedArrayTree->removeValueInTree($currentPath);
   194|     }
   195|     protected function getCurrentObjectPathPrefix(): array
   196|     {
   197|         $lastElementOfStack = end($this->currentObjectPathStack);
   198|         return ($lastElementOfStack === false) ? [] : $lastElementOfStack;
   199|     }
   200|     protected function validateParseTreeKey(string $pathKey)
   201|     {
   202|         if ($pathKey === '') {
   203|             throw $this->prepareParserException(new ParserException())
   204|                 ->setCode(1646988838)
   205|                 ->setMessage("A path must not be empty.")
   206|                 ->build();
   207|         }
   208|         if (str_starts_with($pathKey, '__')
   209|             && in_array($pathKey, Fusion\Core\Parser::$reservedParseTreeKeys, true)) {
   210|             throw $this->prepareParserException(new ParserException())
   211|                 ->setCode(1437065270)
   212|                 ->setMessage("Reversed key '$pathKey' used.")
   213|                 ->build();
   214|         }
   215|         if (str_contains($pathKey, "\n")) {
   216|             $cleaned = str_replace("\n", '', $pathKey);
   217|             throw $this->prepareParserException(new ParserException())
   218|                 ->setCode(1644068086)
   219|                 ->setMessage("Key '$cleaned' cannot contain newlines.")
   220|                 ->build();
   221|         }
   222|     }
   223|     protected function prepareParserException(ParserException $parserException): ParserException
   224|     {
   225|         if ($this->contextPathAndFilename === null) {
   226|             $fusionCode = '';
   227|         } else {
   228|             $fusionCode = file_get_contents($this->contextPathAndFilename);
   229|         }
   230|         return $parserException
   231|             ->setHideColumnInformation()
   232|             ->setFile($this->contextPathAndFilename)
   233|             ->setFusion($fusionCode)
   234|             ->setCursor($this->currentObjectStatementCursor);
   235|     }
   236| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/ObjectTreeParser.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-472 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion;
    14| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
    15| use Neos\Fusion\Core\ObjectTreeParser\Ast\StatementList;
    16| use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractStatement;
    17| use Neos\Fusion\Core\ObjectTreeParser\Ast\IncludeStatement;
    18| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectStatement;
    19| use Neos\Fusion\Core\ObjectTreeParser\Ast\Block;
    20| use Neos\Fusion\Core\ObjectTreeParser\Ast\ObjectPath;
    21| use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractPathSegment;
    22| use Neos\Fusion\Core\ObjectTreeParser\Ast\MetaPathSegment;
    23| use Neos\Fusion\Core\ObjectTreeParser\Ast\PrototypePathSegment;
    24| use Neos\Fusion\Core\ObjectTreeParser\Ast\PathSegment;
    25| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueAssignment;
    26| use Neos\Fusion\Core\ObjectTreeParser\Ast\AbstractPathValue;
    27| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionObjectValue;
    28| use Neos\Fusion\Core\ObjectTreeParser\Ast\DslExpressionValue;
    29| use Neos\Fusion\Core\ObjectTreeParser\Ast\EelExpressionValue;
    30| use Neos\Fusion\Core\ObjectTreeParser\Ast\FloatValue;
    31| use Neos\Fusion\Core\ObjectTreeParser\Ast\IntValue;
    32| use Neos\Fusion\Core\ObjectTreeParser\Ast\BoolValue;
    33| use Neos\Fusion\Core\ObjectTreeParser\Ast\NullValue;
    34| use Neos\Fusion\Core\ObjectTreeParser\Ast\StringValue;
    35| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueCopy;
    36| use Neos\Fusion\Core\ObjectTreeParser\Ast\AssignedObjectPath;
    37| use Neos\Fusion\Core\ObjectTreeParser\Ast\ValueUnset;
    38| use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageCreator;
    39| use Neos\Fusion\Core\ObjectTreeParser\ExceptionMessage\MessageLinePart;
    40| use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserException;
    41| use Neos\Fusion\Core\ObjectTreeParser\Exception\ParserUnexpectedCharException;
    42| /**
    43|  * Parses a Fusion File to object ast-nodes
    44|  */
    45| class ObjectTreeParser
    46| {
    47|     protected Lexer $lexer;
    48|     protected ?string $contextPathAndFilename;
    49|     protected function __construct(Lexer $lexer, ?string $contextPathAndFilename)
    50|     {
    51|         $this->lexer = $lexer;
    52|         $this->contextPathAndFilename = $contextPathAndFilename;
    53|     }
    54|     public static function parse(string $sourceCode, ?string $contextPathAndFilename = null): FusionFile
    55|     {
    56|         $lexer = new Lexer($sourceCode);
    57|         $parser = new self($lexer, $contextPathAndFilename);
    58|         return $parser->parseFusionFile();
    59|     }
    60|     /**
    61|      * Consume the current token.
    62|      * Can only consume if accept was called before.
    63|      *
    64|      * @return Token
    65|      */
    66|     protected function consume(): Token
    67|     {
    68|         return $this->lexer->consumeLookahead();
    69|     }
    70|     /**
    71|      * Accepts a token of a given type.
    72|      * The Lexer will look up the regex for the token and try to match it on the current string.
    73|      * First match wins.
    74|      *
    75|      * @param int $tokenType
    76|      * @return bool
    77|      */
    78|     protected function accept(int $tokenType): bool
    79|     {
    80|         $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
    81|         if ($token === null) {
    82|             return false;
    83|         }
    84|         return $token->getType() === $tokenType;
    85|     }
    86|     /**
    87|      * Expects a token of a given type.
    88|      * The Lexer will look up the regex for the token and try to match it on the current string.
    89|      * First match wins.
    90|      *
    91|      * @param int $tokenType
    92|      * @return Token
    93|      * @throws ParserUnexpectedCharException
    94|      */
    95|     protected function expect(int $tokenType): Token
    96|     {
    97|         $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
    98|         if ($token === null || $token->getType() !== $tokenType) {
    99|             $tokenReadable = Token::typeToString($tokenType);
   100|             throw new ParserUnexpectedCharException("Expected token: '$tokenReadable'.", 1646988824);
   101|         }
   102|         return $this->lexer->consumeLookahead();
   103|     }
   104|     /**
   105|      * Checks, if the token type matches the current, if so consume it and return true.
   106|      * @param int $tokenType
   107|      * @return bool|null
   108|      */
   109|     protected function lazyExpect(int $tokenType): ?bool
   110|     {
   111|         $token = $this->lexer->getCachedLookaheadOrTryToGenerateLookaheadForTokenAndGetLookahead($tokenType);
   112|         if ($token === null || $token->getType() !== $tokenType) {
   113|             return false;
   114|         }
   115|         $this->lexer->consumeLookahead();
   116|         return true;
   117|     }
   118|     /**
   119|      * OptionalBigGap
   120|      *  = ( NEWLINE / OptionalSmallGap )*
   121|      */
   122|     protected function lazyBigGap(): void
   123|     {
   124|         while (true) {
   125|             switch (true) {
   126|                 case $this->accept(Token::SPACE):
   127|                 case $this->accept(Token::NEWLINE):
   128|                 case $this->accept(Token::SLASH_COMMENT):
   129|                 case $this->accept(Token::HASH_COMMENT):
   130|                 case $this->accept(Token::MULTILINE_COMMENT):
   131|                     $this->consume();
   132|                     break;
   133|                 default:
   134|                     return;
   135|             }
   136|         }
   137|     }
   138|     /**
   139|      * OptionalSmallGap
   140|      *  = ( SPACE / SLASH_COMMENT / HASH_COMMENT / MULTILINE_COMMENT )*
   141|      */
   142|     protected function lazySmallGap(): void
   143|     {
   144|         while (true) {
   145|             switch (true) {
   146|                 case $this->accept(Token::SPACE):
   147|                 case $this->accept(Token::SLASH_COMMENT):
   148|                 case $this->accept(Token::HASH_COMMENT):
   149|                 case $this->accept(Token::MULTILINE_COMMENT):
   150|                     $this->consume();
   151|                     break;
   152|                 default:
   153|                     return;
   154|             }
   155|         }
   156|     }
   157|     /**
   158|      * FusionFile
   159|      *  = StatementList
   160|      */
   161|     protected function parseFusionFile(): FusionFile
   162|     {
   163|         try {
   164|             return new FusionFile($this->parseStatementList(), $this->contextPathAndFilename);
   165|         } catch (ParserException $e) {
   166|             throw $e;
   167|         } catch (ParserUnexpectedCharException $e) {
   168|             throw $this->prepareParserException(new ParserException())
   169|                 ->setCode($e->getCode())
   170|                 ->setMessageCreator(function (MessageLinePart $nextLine) use ($e) {
   171|                     return "Unexpected char {$nextLine->charPrint()}. {$e->getMessage()}";
   172|                 })
   173|                 ->setPrevious($e)
   174|                 ->build();
   175|         } catch (Fusion\Exception $e) {
   176|             throw $this->prepareParserException(new ParserException())
   177|                 ->setCode($e->getCode())
   178|                 ->setMessage('Exception while parsing: ' . $e->getMessage())
   179|                 ->setHideColumnInformation()
   180|                 ->setPrevious($e)
   181|                 ->build();
   182|         }
   183|     }
   184|     /**
   185|      * StatementList
   186|      *  = ( Statement )*
   187|      *
   188|      * @param ?int $stopLookahead When this tokenType is encountered the loop will be stopped
   189|      */
   190|     protected function parseStatementList(?int $stopLookahead = null): StatementList
   191|     {
   192|         $statements = [];
   193|         $this->lazyBigGap();
   194|         while ($this->accept(Token::EOF) === false
   195|             && ($stopLookahead === null || $this->accept($stopLookahead) === false)) {
   196|             $statements[] = $this->parseStatement();
   197|             $this->lazyBigGap();
   198|         }
   199|         return new StatementList(...$statements);
   200|     }
   201|     /**
   202|      * Statement
   203|      *  = IncludeStatement / ObjectStatement
   204|      */
   205|     protected function parseStatement(): AbstractStatement
   206|     {
   207|         switch (true) {
   208|             case $this->accept(Token::INCLUDE):
   209|                 return $this->parseIncludeStatement();
   210|             case $this->accept(Token::PROTOTYPE_START):
   211|             case $this->accept(Token::OBJECT_PATH_PART):
   212|             case $this->accept(Token::META_PATH_START):
   213|             case $this->accept(Token::STRING_SINGLE_QUOTED):
   214|             case $this->accept(Token::STRING_DOUBLE_QUOTED):
   215|                 return $this->parseObjectStatement();
   216|         }
   217|         throw $this->prepareParserException(new ParserException())
   218|             ->setCode(1646988828)
   219|             ->setMessageCreator([MessageCreator::class, 'forParseStatement'])
   220|             ->build();
   221|     }
   222|     /**
   223|      * IncludeStatement
   224|      *  = INCLUDE ( STRING / CHAR / FILE_PATTERN ) EndOfStatement
   225|      */
   226|     protected function parseIncludeStatement(): IncludeStatement
   227|     {
   228|         $this->expect(Token::INCLUDE);
   229|         $this->lazyExpect(Token::SPACE);
   230|         switch (true) {
   231|             case $this->accept(Token::STRING_DOUBLE_QUOTED):
   232|             case $this->accept(Token::STRING_SINGLE_QUOTED):
   233|                 $stringWrapped = $this->consume()->getValue();
   234|                 $filePattern = substr($stringWrapped, 1, -1);
   235|                 break;
   236|             case $this->accept(Token::FILE_PATTERN):
   237|                 $filePattern = $this->consume()->getValue();
   238|                 break;
   239|             default:
   240|                 throw new ParserUnexpectedCharException('Expected file pattern in quotes or [a-zA-Z0-9.*:/_-]', 1646988832);
   241|         }
   242|         $this->parseEndOfStatement();
   243|         return new IncludeStatement($filePattern);
   244|     }
   245|     /**
   246|      * ObjectStatement
   247|      *  = ObjectPath ( ValueAssignment / ValueUnset / ValueCopy )? ( Block / EndOfStatement )
   248|      */
   249|     protected function parseObjectStatement(): ObjectStatement
   250|     {
   251|         $currentPath = $this->parseObjectPath();
   252|         $this->lazyExpect(Token::SPACE);
   253|         $cursorAfterObjectPath = $this->lexer->getCursor();
   254|         $operation = match (true) {
   255|             $this->accept(Token::ASSIGNMENT) => $this->parseValueAssignment(),
   256|             $this->accept(Token::UNSET) => $this->parseValueUnset(),
   257|             $this->accept(Token::COPY) => $this->parseValueCopy(),
   258|             default => null
   259|         };
   260|         $this->lazyExpect(Token::SPACE);
   261|         if ($this->accept(Token::LBRACE)) {
   262|             $block = $this->parseBlock();
   263|             return new ObjectStatement($currentPath, $operation, $block, $cursorAfterObjectPath);
   264|         }
   265|         if ($operation === null) {
   266|             throw $this->prepareParserException(new ParserException())
   267|                 ->setCode(1646988835)
   268|                 ->setMessageCreator([MessageCreator::class, 'forParsePathOrOperator'])
   269|                 ->setCursor($cursorAfterObjectPath)
   270|                 ->build();
   271|         }
   272|         $this->parseEndOfStatement();
   273|         return new ObjectStatement($currentPath, $operation, null, $cursorAfterObjectPath);
   274|     }
   275|     /**
   276|      * ObjectPath
   277|      *  = PathSegment ( '.' PathSegment )*
   278|      *
   279|      */
   280|     protected function parseObjectPath(): ObjectPath
   281|     {
   282|         $segments = [];
   283|         do {
   284|             $segments[] = $this->parsePathSegment();
   285|         } while ($this->lazyExpect(Token::DOT));
   286|         return new ObjectPath(...$segments);
   287|     }
   288|     /**
   289|      * PathSegment
   290|      *  = ( PROTOTYPE_START FUSION_OBJECT_NAME ')' / OBJECT_PATH_PART / '@' OBJECT_PATH_PART / STRING / CHAR )
   291|      */
   292|     protected function parsePathSegment(): AbstractPathSegment
   293|     {
   294|         switch (true) {
   295|             case $this->accept(Token::PROTOTYPE_START):
   296|                 $this->consume();
   297|                 try {
   298|                     $prototypeName = $this->expect(Token::FUSION_OBJECT_NAME)->getValue();
   299|                 } catch (Fusion\Exception) {
   300|                     throw $this->prepareParserException(new ParserException())
   301|                         ->setCode(1646991578)
   302|                         ->setMessageCreator([MessageCreator::class, 'forPathSegmentPrototypeName'])
   303|                         ->build();
   304|                 }
   305|                 $this->expect(Token::RPAREN);
   306|                 return new PrototypePathSegment($prototypeName);
   307|             case $this->accept(Token::OBJECT_PATH_PART):
   308|                 $pathKey = $this->consume()->getValue();
   309|                 return new PathSegment($pathKey);
   310|             case $this->accept(Token::META_PATH_START):
   311|                 $this->consume();
   312|                 $metaPathSegmentKey = $this->expect(Token::OBJECT_PATH_PART)->getValue();
   313|                 return new MetaPathSegment($metaPathSegmentKey);
   314|             case $this->accept(Token::STRING_DOUBLE_QUOTED):
   315|             case $this->accept(Token::STRING_SINGLE_QUOTED):
   316|                 $stringWrapped = $this->consume()->getValue();
   317|                 $quotedPathKey = substr($stringWrapped, 1, -1);
   318|                 return new PathSegment($quotedPathKey);
   319|         }
   320|         throw $this->prepareParserException(new ParserException())
   321|             ->setCode(1635708755)
   322|             ->setMessageCreator([MessageCreator::class, 'forParsePathSegment'])
   323|             ->build();
   324|     }
   325|     /**
   326|      * ValueAssignment
   327|      *  = ASSIGNMENT PathValue
   328|      */
   329|     protected function parseValueAssignment(): ValueAssignment
   330|     {
   331|         $this->expect(Token::ASSIGNMENT);
   332|         $this->lazyExpect(Token::SPACE);
   333|         $value = $this->parsePathValue();
   334|         return new ValueAssignment($value);
   335|     }
   336|     /**
   337|      * PathValue
   338|      *  = ( CHAR / STRING / DSL_EXPRESSION / FusionObject / EelExpression )
   339|      */
   340|     protected function parsePathValue(): AbstractPathValue
   341|     {
   342|         switch (true) {
   343|             case $this->accept(Token::STRING_SINGLE_QUOTED):
   344|                 $charWrapped = $this->consume()->getValue();
   345|                 $stringContent = substr($charWrapped, 1, -1);
   346|                 return new StringValue(stripslashes($stringContent));
   347|             case $this->accept(Token::STRING_DOUBLE_QUOTED):
   348|                 $stringWrapped = $this->consume()->getValue();
   349|                 $stringContent = substr($stringWrapped, 1, -1);
   350|                 return new StringValue(stripcslashes($stringContent));
   351|             case $this->accept(Token::FUSION_OBJECT_NAME):
   352|                 return new FusionObjectValue($this->consume()->getValue());
   353|             case $this->accept(Token::DSL_EXPRESSION_START):
   354|                 return $this->parseDslExpression();
   355|             case $this->accept(Token::EEL_EXPRESSION):
   356|                 $eelWrapped = $this->consume()->getValue();
   357|                 $eelContent = substr($eelWrapped, 2, -1);
   358|                 return new EelExpressionValue($eelContent);
   359|             case $this->accept(Token::FLOAT):
   360|                 return new FloatValue((float)$this->consume()->getValue());
   361|             case $this->accept(Token::INTEGER):
   362|                 return new IntValue((int)$this->consume()->getValue());
   363|             case $this->accept(Token::TRUE_VALUE):
   364|                 $this->consume();
   365|                 return new BoolValue(true);
   366|             case $this->accept(Token::FALSE_VALUE):
   367|                 $this->consume();
   368|                 return new BoolValue(false);
   369|             case $this->accept(Token::NULL_VALUE):
   370|                 $this->consume();
   371|                 return new NullValue();
   372|         }
   373|         throw $this->prepareParserException(new ParserException())
   374|             ->setCode(1646988841)
   375|             ->setMessageCreator([MessageCreator::class, 'forParsePathValue'])
   376|             ->build();
   377|     }
   378|     /**
   379|      * DslExpression
   380|      *  = DSL_EXPRESSION_START DSL_EXPRESSION_CONTENT
   381|      */
   382|     protected function parseDslExpression(): DslExpressionValue
   383|     {
   384|         $dslIdentifier = $this->expect(Token::DSL_EXPRESSION_START)->getValue();
   385|         try {
   386|             $dslCode = $this->expect(Token::DSL_EXPRESSION_CONTENT)->getValue();
   387|         } catch (Fusion\Exception) {
   388|             throw $this->prepareParserException(new ParserException())
   389|                 ->setCode(1490714685)
   390|                 ->setMessageCreator([MessageCreator::class, 'forParseDslExpression'])
   391|                 ->build();
   392|         }
   393|         $dslCode = substr($dslCode, 1, -1);
   394|         return new DslExpressionValue($dslIdentifier, $dslCode);
   395|     }
   396|     /**
   397|      * ValueUnset
   398|      *  = UNSET
   399|      */
   400|     protected function parseValueUnset(): ValueUnset
   401|     {
   402|         $this->expect(Token::UNSET);
   403|         return new ValueUnset();
   404|     }
   405|     /**
   406|      * ValueCopy
   407|      *  = COPY ObjectPathAssignment
   408|      */
   409|     protected function parseValueCopy(): ValueCopy
   410|     {
   411|         $this->expect(Token::COPY);
   412|         $this->lazyExpect(Token::SPACE);
   413|         $sourcePath = $this->parseAssignedObjectPath();
   414|         return new ValueCopy($sourcePath);
   415|     }
   416|     /**
   417|      * AssignedObjectPath
   418|      *  = '.'? ObjectPath
   419|      */
   420|     protected function parseAssignedObjectPath(): AssignedObjectPath
   421|     {
   422|         $isRelative = $this->lazyExpect(Token::DOT);
   423|         return new AssignedObjectPath($this->parseObjectPath(), $isRelative);
   424|     }
   425|     /**
   426|      * Block:
   427|      *  = '{' StatementList? '}'
   428|      */
   429|     protected function parseBlock(): Block
   430|     {
   431|         $this->expect(Token::LBRACE);
   432|         $cursorPositionStartOfBlock = $this->lexer->getCursor() - 1;
   433|         $this->parseEndOfStatement();
   434|         $statementList = $this->parseStatementList(Token::RBRACE);
   435|         try {
   436|             $this->expect(Token::RBRACE);
   437|         } catch (Fusion\Exception) {
   438|             throw $this->prepareParserException(new ParserException())
   439|                 ->setCode(1646988844)
   440|                 ->setMessage('No closing brace "}" matched this starting block. Encountered <EOF>.')
   441|                 ->setCursor($cursorPositionStartOfBlock)
   442|                 ->build();
   443|         }
   444|         return new Block($statementList);
   445|     }
   446|     /**
   447|      * EndOfStatement
   448|      *  = ( EOF / NEWLINE )
   449|      */
   450|     protected function parseEndOfStatement(): void
   451|     {
   452|         $this->lazySmallGap();
   453|         if ($this->accept(Token::EOF)) {
   454|             return;
   455|         }
   456|         if ($this->accept(Token::NEWLINE)) {
   457|             $this->consume();
   458|             return;
   459|         }
   460|         throw $this->prepareParserException(new ParserException())
   461|             ->setCode(1635878683)
   462|             ->setMessageCreator([MessageCreator::class, 'forParseEndOfStatement'])
   463|             ->build();
   464|     }
   465|     protected function prepareParserException(ParserException $parserException): ParserException
   466|     {
   467|         return $parserException
   468|             ->setFile($this->contextPathAndFilename)
   469|             ->setFusion($this->lexer->getCode())
   470|             ->setCursor($this->lexer->getCursor());
   471|     }
   472| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ObjectTreeParser/Token.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-84 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core\ObjectTreeParser;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| class Token
    15| {
    16|     public const EOF = 1;
    17|     public const SLASH_COMMENT = 2;
    18|     public const HASH_COMMENT = 3;
    19|     public const MULTILINE_COMMENT = 4;
    20|     public const SPACE = 5;
    21|     public const NEWLINE = 6;
    22|     public const INCLUDE = 7;
    23|     public const NAMESPACE = 8;
    24|     public const META_PATH_START = 9;
    25|     public const OBJECT_PATH_PART = 10;
    26|     public const PROTOTYPE_START = 11;
    27|     public const ASSIGNMENT = 12;
    28|     public const COPY = 13;
    29|     public const UNSET = 14;
    30|     public const FUSION_OBJECT_NAME = 15;
    31|     public const TRUE_VALUE = 16;
    32|     public const FALSE_VALUE = 17;
    33|     public const NULL_VALUE = 18;
    34|     public const INTEGER = 19;
    35|     public const FLOAT = 20;
    36|     public const STRING_DOUBLE_QUOTED = 21;
    37|     public const STRING_SINGLE_QUOTED = 22;
    38|     public const EEL_EXPRESSION = 23;
    39|     public const DSL_EXPRESSION_START = 24;
    40|     public const DSL_EXPRESSION_CONTENT = 25;
    41|     public const FILE_PATTERN = 26;
    42|     public const DOT = 27;
    43|     public const COLON = 28;
    44|     public const RPAREN = 29;
    45|     public const LBRACE = 30;
    46|     public const RBRACE = 31;
    47|     public function __construct(
    48|         protected int $type,
    49|         protected string $value,
    50|     ) {
    51|     }
    52|     public function getType(): int
    53|     {
    54|         return $this->type;
    55|     }
    56|     public function getValue(): string
    57|     {
    58|         return $this->value;
    59|     }
    60|     /**
    61|      * Returns the constant representation of a given type.
    62|      *
    63|      * @param int $type The type as an integer
    64|      *
    65|      * @return string The string representation
    66|      * @throws \LogicException
    67|      */
    68|     public static function typeToString(int $type): string
    69|     {
    70|         $stringRepresentation = array_search($type, static::getConstants(), true);
    71|         if ($stringRepresentation === false) {
    72|             throw new \LogicException("Token of type '$type' does not exist", 1637307344);
    73|         }
    74|         return $stringRepresentation;
    75|     }
    76|     /**
    77|      * @Flow\CompileStatic
    78|      */
    79|     protected static function getConstants()
    80|     {
    81|         $reflection = new \ReflectionClass(self::class);
    82|         return $reflection->getConstants();
    83|     }
    84| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Parser.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-106 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion;
    14| use Neos\Fusion\Core\Cache\ParserCache;
    15| use Neos\Fusion\Core\ObjectTreeParser\Ast\FusionFile;
    16| use Neos\Fusion\Core\ObjectTreeParser\FilePatternResolver;
    17| use Neos\Fusion\Core\ObjectTreeParser\MergedArrayTree;
    18| use Neos\Fusion\Core\ObjectTreeParser\MergedArrayTreeVisitor;
    19| use Neos\Fusion\Core\ObjectTreeParser\ObjectTreeParser;
    20| use Neos\Flow\Annotations as Flow;
    21| /**
    22|  * The Fusion Parser
    23|  *
    24|  * @api
    25|  */
    26| class Parser implements ParserInterface
    27| {
    28|     /**
    29|      * Reserved parse tree keys for internal usage.
    30|      */
    31|     public static array $reservedParseTreeKeys = ['__meta', '__prototypes', '__stopInheritanceChain', '__prototypeObjectName', '__prototypeChain', '__value', '__objectType', '__eelExpression'];
    32|     /**
    33|      * @Flow\Inject
    34|      * @var DslFactory
    35|      */
    36|     protected $dslFactory;
    37|     /**
    38|      * @Flow\Inject
    39|      * @var ParserCache
    40|      */
    41|     protected $parserCache;
    42|     /**
    43|      * Parses the given Fusion source code, resolves includes and returns a merged array tree
    44|      * as the result.
    45|      *
    46|      * @param string $sourceCode The Fusion source code to parse
    47|      * @param string|null $contextPathAndFilename An optional path and filename used for relative Fusion file includes
    48|      * @param array $mergedArrayTreeUntilNow Used internally for keeping track of the built merged array tree
    49|      * @return array The merged array tree for the Fusion runtime, generated from the source code
    50|      * @throws Fusion\Exception
    51|      * @api
    52|      */
    53|     public function parse(string $sourceCode, ?string $contextPathAndFilename = null, array $mergedArrayTreeUntilNow = []): array
    54|     {
    55|         $fusionFile = $this->getFusionFile($sourceCode, $contextPathAndFilename);
    56|         $mergedArrayTree = new MergedArrayTree($mergedArrayTreeUntilNow);
    57|         $mergedArrayTree = $this->getMergedArrayTreeVisitor($mergedArrayTree)->visitFusionFile($fusionFile);
    58|         $mergedArrayTree->buildPrototypeHierarchy();
    59|         return $mergedArrayTree->getTree();
    60|     }
    61|     protected function handleFileInclude(MergedArrayTree $mergedArrayTree, string $filePattern, ?string $contextPathAndFilename): void
    62|     {
    63|         $filesToInclude = FilePatternResolver::resolveFilesByPattern($filePattern, $contextPathAndFilename, '.fusion');
    64|         foreach ($filesToInclude as $file) {
    65|             if (is_readable($file) === false) {
    66|                 throw new Fusion\Exception("Could not read file '$file' of pattern '$filePattern'.", 1347977017);
    67|             }
    68|             if ($contextPathAndFilename === null
    69|                 || stat($contextPathAndFilename) !== stat($file)) {
    70|                 $fusionFile = $this->getFusionFile(file_get_contents($file), $file);
    71|                 $this->getMergedArrayTreeVisitor($mergedArrayTree)->visitFusionFile($fusionFile);
    72|             }
    73|         }
    74|     }
    75|     protected function handleDslTranspile(string $identifier, string $code)
    76|     {
    77|         return $this->parserCache->cacheForDsl(
    78|             $identifier,
    79|             $code,
    80|             function () use ($identifier, $code) {
    81|                 $dslObject = $this->dslFactory->create($identifier);
    82|                 $transpiledFusion = $dslObject->transpile($code);
    83|                 $fusionFile = ObjectTreeParser::parse('value = ' . $transpiledFusion);
    84|                 $mergedArrayTree = $this->getMergedArrayTreeVisitor(new MergedArrayTree())->visitFusionFile($fusionFile);
    85|                 $temporaryAst = $mergedArrayTree->getTree();
    86|                 $dslValue = $temporaryAst['value'];
    87|                 return $dslValue;
    88|             }
    89|         );
    90|     }
    91|     protected function getMergedArrayTreeVisitor(MergedArrayTree $mergedArrayTree): MergedArrayTreeVisitor
    92|     {
    93|         return new MergedArrayTreeVisitor(
    94|             $mergedArrayTree,
    95|             fn (...$args) => $this->handleFileInclude(...$args),
    96|             fn (...$args) => $this->handleDslTranspile(...$args)
    97|         );
    98|     }
    99|     protected function getFusionFile(string $sourceCode, ?string $contextPathAndFilename): FusionFile
   100|     {
   101|         return $this->parserCache->cacheForFusionFile(
   102|             $contextPathAndFilename,
   103|             fn () => ObjectTreeParser::parse($sourceCode, $contextPathAndFilename)
   104|         );
   105|     }
   106| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/ParserInterface.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-33 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Fusion\Core;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Fusion;
    14| /**
    15|  * Contract for a Fusion parser
    16|  *
    17|  * @api
    18|  */
    19| interface ParserInterface
    20| {
    21|     /**
    22|      * Parses the given Fusion source code, resolves includes and returns a merged array tree
    23|      * as the result.
    24|      *
    25|      * @param string $sourceCode The Fusion source code to parse
    26|      * @param string|null $contextPathAndFilename An optional path and filename used for relative Fusion file includes
    27|      * @param array $mergedArrayTreeUntilNow Used internally for keeping track of the built merged array tree
    28|      * @return array The merged array tree for the Fusion runtime, generated from the source code
    29|      * @throws Fusion\Exception
    30|      * @api
    31|      */
    32|     public function parse(string $sourceCode, ?string $contextPathAndFilename = null, array $mergedArrayTreeUntilNow = []): array;
    33| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Core/Runtime.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-846 ---
     1| <?php
     2| namespace Neos\Fusion\Core;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\Configuration\Exception\InvalidConfigurationException;
    14| use Neos\Flow\Mvc\Controller\ControllerContext;
    15| use Neos\Flow\Mvc\Exception\StopActionException;
    16| use Neos\Flow\ObjectManagement\ObjectManagerInterface;
    17| use Neos\Utility\Arrays;
    18| use Neos\Utility\ObjectAccess;
    19| use Neos\Utility\PositionalArraySorter;
    20| use Neos\Fusion\Core\Cache\RuntimeContentCache;
    21| use Neos\Fusion\Core\ExceptionHandlers\AbstractRenderingExceptionHandler;
    22| use Neos\Fusion\Exception as Exceptions;
    23| use Neos\Fusion\Exception;
    24| use Neos\Flow\Security\Exception as SecurityException;
    25| use Neos\Fusion\Exception\RuntimeException;
    26| use Neos\Fusion\FusionObjects\AbstractArrayFusionObject;
    27| use Neos\Fusion\FusionObjects\AbstractFusionObject;
    28| use Neos\Eel\Utility as EelUtility;
    29| /**
    30|  * Fusion Runtime
    31|  *
    32|  * Fusion Rendering Process
    33|  * ============================
    34|  *
    35|  * During rendering, all Fusion objects form a tree.
    36|  *
    37|  * When a Fusion object at a certain $fusionPath is invoked, it has
    38|  * access to all variables stored in the $context (which is an array).
    39|  *
    40|  * The Fusion object can then add or replace variables to this context using pushContext()
    41|  * or pushContextArray(), before rendering sub-Fusion objects. After rendering
    42|  * these, it must call popContext() to reset the context to the last state.
    43|  */
    44| class Runtime
    45| {
    46|     /**
    47|      * Internal constants defining how evaluate should work in case of an error
    48|      */
    49|     const BEHAVIOR_EXCEPTION = 'Exception';
    50|     const BEHAVIOR_RETURNNULL = 'NULL';
    51|     /**
    52|      * Internal constants defining a status of how evaluate was evaluated
    53|      */
    54|     const EVALUATION_EXECUTED = 'Executed';
    55|     const EVALUATION_SKIPPED = 'Skipped';
    56|     /**
    57|      * @var \Neos\Eel\CompilingEvaluator
    58|      * @Flow\Inject
    59|      */
    60|     protected $eelEvaluator;
    61|     /**
    62|      * @var ObjectManagerInterface
    63|      * @Flow\Inject
    64|      */
    65|     protected $objectManager;
    66|     /**
    67|      * Stack of evaluated "@context" values
    68|      *
    69|      * @var array
    70|      */
    71|     protected $contextStack = [];
    72|     /**
    73|      * Reference to the current context
    74|      *
    75|      * @var array
    76|      */
    77|     protected $currentContext = [];
    78|     /**
    79|      * Reference to the current apply value
    80|      *
    81|      * @var array
    82|      */
    83|     protected $currentApplyValues = [];
    84|     /**
    85|      * Default context with helper definitions
    86|      *
    87|      * @var array
    88|      */
    89|     protected $defaultContextVariables;
    90|     /**
    91|      * @var array
    92|      */
    93|     protected $runtimeConfiguration;
    94|     /**
    95|      * @var ControllerContext
    96|      */
    97|     protected $controllerContext;
    98|     /**
    99|      * @var array
   100|      */
   101|     protected $settings;
   102|     /**
   103|      * @var boolean
   104|      */
   105|     protected $debugMode = false;
   106|     /**
   107|      * @var RuntimeContentCache
   108|      */
   109|     protected $runtimeContentCache;
   110|     /**
   111|      * @var string
   112|      */
   113|     protected $lastEvaluationStatus;
   114|     /**
   115|      * Constructor for the Fusion Runtime
   116|      *
   117|      * @param array $fusionConfiguration
   118|      * @param ControllerContext $controllerContext
   119|      */
   120|     public function __construct(array $fusionConfiguration, ControllerContext $controllerContext)
   121|     {
   122|         $this->runtimeConfiguration = new RuntimeConfiguration($fusionConfiguration);
   123|         $this->controllerContext = $controllerContext;
   124|         $this->runtimeContentCache = new RuntimeContentCache($this);
   125|     }
   126|     /**
   127|      * Inject settings of this package
   128|      *
   129|      * @param array $settings The settings
   130|      * @return void
   131|      */
   132|     public function injectSettings(array $settings)
   133|     {
   134|         $this->settings = $settings;
   135|         if (isset($this->settings['debugMode'])) {
   136|             $this->setDebugMode($this->settings['debugMode'] === true);
   137|         }
   138|         if (isset($this->settings['enableContentCache'])) {
   139|             $this->setEnableContentCache($this->settings['enableContentCache'] === true);
   140|         }
   141|     }
   142|     /**
   143|      * Add a tag to the current cache segment
   144|      *
   145|      * During Fusion rendering the method can be used to add tag dynamicaly for the current cache segment.
   146|      *
   147|      * @param string $key
   148|      * @param string $value
   149|      * @return void
   150|      * @api
   151|      */
   152|     public function addCacheTag($key, $value)
   153|     {
   154|         if ($this->runtimeContentCache->getEnableContentCache() === false) {
   155|             return;
   156|         }
   157|         $this->runtimeContentCache->addTag($key, $value);
   158|     }
   159|     /**
   160|      * Completely replace the context array with the new $contextArray.
   161|      *
   162|      * Purely internal method, should not be called outside of Neos.Fusion.
   163|      *
   164|      * @param array $contextArray
   165|      * @return void
   166|      */
   167|     public function pushContextArray(array $contextArray)
   168|     {
   169|         $this->contextStack[] = $contextArray;
   170|         $this->currentContext = $contextArray;
   171|     }
   172|     /**
   173|      * Push a new context object to the rendering stack
   174|      *
   175|      * @param string $key the key inside the context
   176|      * @param mixed $context
   177|      * @return void
   178|      */
   179|     public function pushContext($key, $context)
   180|     {
   181|         $newContext = $this->currentContext;
   182|         $newContext[$key] = $context;
   183|         $this->contextStack[] = $newContext;
   184|         $this->currentContext = $newContext;
   185|     }
   186|     /**
   187|      * Remove the topmost context objects and return them
   188|      *
   189|      * @return array the topmost context objects as associative array
   190|      */
   191|     public function popContext()
   192|     {
   193|         $lastItem = array_pop($this->contextStack);
   194|         $this->currentContext = empty($this->contextStack) ? [] : end($this->contextStack);
   195|         return $lastItem;
   196|     }
   197|     /**
   198|      * Get the current context array
   199|      *
   200|      * @return array the array of current context objects
   201|      */
   202|     public function getCurrentContext()
   203|     {
   204|         return $this->currentContext;
   205|     }
   206|     public function popApplyValues(array $paths): void
   207|     {
   208|         foreach ($paths as $path) {
   209|             unset($this->currentApplyValues[$path]);
   210|         }
   211|     }
   212|     /**
   213|      * @return string
   214|      */
   215|     public function getLastEvaluationStatus()
   216|     {
   217|         return $this->lastEvaluationStatus;
   218|     }
   219|     /**
   220|      * Render an absolute Fusion path and return the result.
   221|      *
   222|      * Compared to $this->evaluate, this adds some more comments helpful for debugging.
   223|      *
   224|      * @param string $fusionPath
   225|      * @return mixed
   226|      * @throws \Exception
   227|      * @throws SecurityException
   228|      */
   229|     public function render($fusionPath)
   230|     {
   231|         try {
   232|             $output = $this->evaluate($fusionPath, null, self::BEHAVIOR_EXCEPTION);
   233|             if ($this->debugMode) {
   234|                 $output = sprintf(
   235|                     '%1$s<!-- Beginning to render Fusion path "%2$s" (Context: %3$s) -->%4$s%1$s<!-- End to render Fusion path "%2$s" (Context: %3$s) -->',
   236|                     chr(10),
   237|                     $fusionPath,
   238|                     implode(', ', array_keys($this->currentContext)),
   239|                     $output
   240|                 );
   241|             }
   242|         } catch (SecurityException $securityException) {
   243|             throw $securityException;
   244|         } catch (\Exception $exception) {
   245|             $output = $this->handleRenderingException($fusionPath, $exception);
   246|         }
   247|         return $output;
   248|     }
   249|     /**
   250|      * Handle an Exception thrown while rendering Fusion according to
   251|      * settings specified in Neos.Fusion.rendering.exceptionHandler
   252|      *
   253|      * @param string $fusionPath
   254|      * @param \Exception $exception
   255|      * @param boolean $useInnerExceptionHandler
   256|      * @return string
   257|      * @throws Exception
   258|      * @throws InvalidConfigurationException
   259|      * @throws SecurityException
   260|      * @throws StopActionException
   261|      */
   262|     public function handleRenderingException($fusionPath, \Exception $exception, $useInnerExceptionHandler = false)
   263|     {
   264|         $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
   265|         if (isset($fusionConfiguration['__meta']['exceptionHandler'])) {
   266|             $exceptionHandlerClass = $fusionConfiguration['__meta']['exceptionHandler'];
   267|             $invalidExceptionHandlerMessage = 'The class "%s" is not valid for property "@exceptionHandler".';
   268|         } else {
   269|             if ($useInnerExceptionHandler === true) {
   270|                 $exceptionHandlerClass = $this->settings['rendering']['innerExceptionHandler'];
   271|             } else {
   272|                 $exceptionHandlerClass = $this->settings['rendering']['exceptionHandler'];
   273|             }
   274|             $invalidExceptionHandlerMessage = 'The class "%s" is not valid for setting "Neos.Fusion.rendering.exceptionHandler".';
   275|         }
   276|         $exceptionHandler = null;
   277|         if ($this->objectManager->isRegistered($exceptionHandlerClass)) {
   278|             $exceptionHandler = $this->objectManager->get($exceptionHandlerClass);
   279|         }
   280|         if ($exceptionHandler === null || !($exceptionHandler instanceof AbstractRenderingExceptionHandler)) {
   281|             $message = sprintf(
   282|                 $invalidExceptionHandlerMessage . "\n" .
   283|                 'Please specify a fully qualified classname to a subclass of %2$s\AbstractRenderingExceptionHandler.' . "\n" .
   284|                 'You might implement an own handler or use one of the following:' . "\n" .
   285|                 '%2$s\AbsorbingHandler' . "\n" .
   286|                 '%2$s\HtmlMessageHandler' . "\n" .
   287|                 '%2$s\PlainTextHandler' . "\n" .
   288|                 '%2$s\ThrowingHandler' . "\n" .
   289|                 '%2$s\XmlCommentHandler',
   290|                 $exceptionHandlerClass,
   291|                 'Neos\Fusion\Core\ExceptionHandlers'
   292|             );
   293|             throw new InvalidConfigurationException($message, 1368788926);
   294|         }
   295|         $exceptionHandler->setRuntime($this);
   296|         if (array_key_exists('__objectType', $fusionConfiguration)) {
   297|             $fusionPath .= sprintf('<%s>', $fusionConfiguration['__objectType']);
   298|         }
   299|         $output = $exceptionHandler->handleRenderingException($fusionPath, $exception);
   300|         return $output;
   301|     }
   302|     /**
   303|      * Determine if the given Fusion path is renderable, which means it exists
   304|      * and has an implementation.
   305|      *
   306|      * @param string $fusionPath
   307|      * @return boolean
   308|      * @throws Exception
   309|      */
   310|     public function canRender($fusionPath)
   311|     {
   312|         $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
   313|         if (isset($fusionConfiguration['__eelExpression']) || isset($fusionConfiguration['__value'])) {
   314|             return true;
   315|         }
   316|         if (isset($fusionConfiguration['__meta']['class']) && isset($fusionConfiguration['__objectType'])) {
   317|             return true;
   318|         }
   319|         return false;
   320|     }
   321|     /**
   322|      * Evaluate an absolute Fusion path and return the result
   323|      *
   324|      * @param string $fusionPath
   325|      * @param mixed $contextObject The object which will be "this" in Eel expressions. ONLY FOR INTERNAL USE!
   326|      * @param string $behaviorIfPathNotFound One of BEHAVIOR_EXCEPTION or BEHAVIOR_RETURNNULL
   327|      * @return mixed
   328|      *
   329|      * @throws StopActionException
   330|      * @throws SecurityException
   331|      * @throws Exception
   332|      * @throws RuntimeException
   333|      * @throws InvalidConfigurationException
   334|      */
   335|     public function evaluate(string $fusionPath, $contextObject = null, string $behaviorIfPathNotFound = self::BEHAVIOR_RETURNNULL)
   336|     {
   337|         $needToPopContext = false;
   338|         $needToPopApply = false;
   339|         $this->lastEvaluationStatus = self::EVALUATION_EXECUTED;
   340|         $fusionConfiguration = $this->runtimeConfiguration->forPath($fusionPath);
   341|         if (isset($this->currentApplyValues[$fusionPath])) {
   342|             if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $contextObject) === false) {
   343|                 return null;
   344|             }
   345|             $appliedValue = $this->currentApplyValues[$fusionPath]['value'];
   346|             if (isset($this->currentApplyValues[$fusionPath]['lazy'])) {
   347|                 $appliedValue = $appliedValue();
   348|             }
   349|             if (isset($fusionConfiguration['__meta']['process'])) {
   350|                 $appliedValue = $this->evaluateProcessors($appliedValue, $fusionConfiguration, $fusionPath, $contextObject);
   351|             }
   352|             return $appliedValue;
   353|         }
   354|         try {
   355|             if (isset($fusionConfiguration['__eelExpression']) || isset($fusionConfiguration['__value'])) {
   356|                 return $this->evaluateExpressionOrValueInternal($fusionPath, $fusionConfiguration, $contextObject);
   357|             }
   358|         } catch (StopActionException $stopActionException) {
   359|             throw $stopActionException;
   360|         } catch (SecurityException $securityException) {
   361|             throw $securityException;
   362|         } catch (RuntimeException $runtimeException) {
   363|             throw $runtimeException;
   364|         } catch (\Exception $exception) {
   365|             return $this->handleRenderingException($fusionPath, $exception, true);
   366|         }
   367|         $cacheContext = $this->runtimeContentCache->enter(isset($fusionConfiguration['__meta']['cache']) ? $fusionConfiguration['__meta']['cache'] : [], $fusionPath);
   368|         if (!(isset($fusionConfiguration['__meta']['class']) && isset($fusionConfiguration['__objectType']))) {
   369|             $this->finalizePathEvaluation($cacheContext);
   370|             $this->throwExceptionForUnrenderablePathIfNeeded($fusionPath, $fusionConfiguration, $behaviorIfPathNotFound);
   371|             $this->lastEvaluationStatus = self::EVALUATION_SKIPPED;
   372|             return null;
   373|         }
   374|         $applyPathsToPop = [];
   375|         try {
   376|             $applyPathsToPop = $this->prepareApplyValuesForFusionPath($fusionPath, $fusionConfiguration);
   377|             $fusionObject = $this->instantiatefusionObject($fusionPath, $fusionConfiguration, $applyPathsToPop);
   378|             $needToPopContext = $this->prepareContextForFusionObject($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext);
   379|             $output = $this->evaluateObjectOrRetrieveFromCache($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext);
   380|         } catch (StopActionException $stopActionException) {
   381|             $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
   382|             throw $stopActionException;
   383|         } catch (SecurityException $securityException) {
   384|             $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
   385|             throw $securityException;
   386|         } catch (RuntimeException $runtimeException) {
   387|             $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
   388|             throw $runtimeException;
   389|         } catch (\Exception $exception) {
   390|             $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
   391|             return $this->handleRenderingException($fusionPath, $exception, true);
   392|         }
   393|         $this->finalizePathEvaluation($cacheContext, $needToPopContext, $applyPathsToPop);
   394|         return $output;
   395|     }
   396|     /**
   397|      * Does the evaluation of a Fusion instance, first checking the cache and if conditions and afterwards applying processors.
   398|      *
   399|      * @param AbstractFusionObject $fusionObject
   400|      * @param string $fusionPath
   401|      * @param array $fusionConfiguration
   402|      * @param array $cacheContext
   403|      * @return mixed
   404|      */
   405|     protected function evaluateObjectOrRetrieveFromCache($fusionObject, $fusionPath, $fusionConfiguration, $cacheContext)
   406|     {
   407|         $output = null;
   408|         $evaluationStatus = self::EVALUATION_SKIPPED;
   409|         list($cacheHit, $cachedResult) = $this->runtimeContentCache->preEvaluate($cacheContext, $fusionObject);
   410|         if ($cacheHit) {
   411|             return $cachedResult;
   412|         }
   413|         $evaluateObject = true;
   414|         if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $fusionObject) === false) {
   415|             $evaluateObject = false;
   416|         }
   417|         if ($evaluateObject) {
   418|             $output = $fusionObject->evaluate();
   419|             $evaluationStatus = self::EVALUATION_EXECUTED;
   420|         }
   421|         $this->lastEvaluationStatus = $evaluationStatus;
   422|         if ($evaluateObject && isset($fusionConfiguration['__meta']['process'])) {
   423|             $output = $this->evaluateProcessors($output, $fusionConfiguration, $fusionPath, $fusionObject);
   424|         }
   425|         $output = $this->runtimeContentCache->postProcess($cacheContext, $fusionObject, $output);
   426|         return $output;
   427|     }
   428|     /**
   429|      * Evaluates an EEL expression or value, checking if conditions first and applying processors.
   430|      *
   431|      * @param string $fusionPath the Fusion path up to now
   432|      * @param array $fusionConfiguration Fusion configuration for the expression or value
   433|      * @param \Neos\Fusion\FusionObjects\AbstractFusionObject $contextObject An optional object for the "this" value inside the context
   434|      * @return mixed The result of the evaluation
   435|      * @throws Exception
   436|      */
   437|     protected function evaluateExpressionOrValueInternal($fusionPath, $fusionConfiguration, $contextObject)
   438|     {
   439|         if (isset($fusionConfiguration['__meta']['if']) && $this->evaluateIfCondition($fusionConfiguration, $fusionPath, $contextObject) === false) {
   440|             $this->lastEvaluationStatus = self::EVALUATION_SKIPPED;
   441|             return null;
   442|         }
   443|         if (isset($fusionConfiguration['__eelExpression'])) {
   444|             $evaluatedValue = $this->evaluateEelExpression($fusionConfiguration['__eelExpression'], $contextObject);
   445|         } else {
   446|             $evaluatedValue = $fusionConfiguration['__value'];
   447|         }
   448|         if (isset($fusionConfiguration['__meta']['process'])) {
   449|             $evaluatedValue = $this->evaluateProcessors($evaluatedValue, $fusionConfiguration, $fusionPath, $contextObject);
   450|         }
   451|         return $evaluatedValue;
   452|     }
   453|     /**
   454|      * Possibly prepares a new "@apply" context for the current fusionPath and pushes it to the stack.
   455|      * Returns true to express that new properties were pushed and have to be popped during finalizePathEvaluation.
   456|      *
   457|      * Since "@apply" are not inherited every call of this method leads to a completely new  "@apply"
   458|      * context, which is null by default.
   459|      *
   460|      * @param string $fusionPath
   461|      * @param array $fusionConfiguration
   462|      * @return array Paths to pop
   463|      * @throws Exception
   464|      * @throws RuntimeException
   465|      * @throws SecurityException
   466|      * @throws StopActionException
   467|      */
   468|     protected function prepareApplyValuesForFusionPath($fusionPath, $fusionConfiguration): array
   469|     {
   470|         $spreadValues = $this->evaluateApplyValues($fusionConfiguration, $fusionPath);
   471|         if ($spreadValues === null) {
   472|             return [];
   473|         }
   474|         foreach ($spreadValues as $path => $entry) {
   475|             $this->currentApplyValues[$path] = $entry;
   476|         }
   477|         return array_keys($spreadValues);
   478|     }
   479|     /**
   480|      * Possibly prepares a new context for the current FusionObject and cache context and pushes it to the stack.
   481|      * Returns if a new context was pushed to the stack or not.
   482|      *
   483|      * @param AbstractFusionObject $fusionObject
   484|      * @param string $fusionPath
   485|      * @param array $fusionConfiguration
   486|      * @param array $cacheContext
   487|      * @return boolean
   488|      * @throws Exception
   489|      * @throws RuntimeException
   490|      * @throws SecurityException
   491|      * @throws StopActionException
   492|      */
   493|     protected function prepareContextForFusionObject(AbstractFusionObject $fusionObject, $fusionPath, $fusionConfiguration, $cacheContext)
   494|     {
   495|         if ($cacheContext['cacheForPathDisabled'] === true) {
   496|             $newContextArray = [];
   497|             foreach ($cacheContext['configuration']['context'] as $contextVariableName) {
   498|                 if (isset($this->currentContext[$contextVariableName])) {
   499|                     $newContextArray[$contextVariableName] = $this->currentContext[$contextVariableName];
   500|                 }
   501|             }
   502|         }
   503|         if (isset($fusionConfiguration['__meta']['context'])) {
   504|             $newContextArray = isset($newContextArray) ? $newContextArray : $this->currentContext;
   505|             foreach ($fusionConfiguration['__meta']['context'] as $contextKey => $contextValue) {
   506|                 $newContextArray[$contextKey] = $this->evaluate($fusionPath . '/__meta/context/' . $contextKey, $fusionObject, self::BEHAVIOR_EXCEPTION);
   507|             }
   508|         }
   509|         if (isset($newContextArray)) {
   510|             $this->pushContextArray($newContextArray);
   511|             return true;
   512|         }
   513|         return false;
   514|     }
   515|     /**
   516|      * Ends the evaluation of a fusion path by popping the context and property stack if needed and leaving the cache context.
   517|      *
   518|      * @param array $cacheContext
   519|      * @param boolean $needToPopContext
   520|      * @param array $applyPathsToPop
   521|      * @return void
   522|      */
   523|     protected function finalizePathEvaluation($cacheContext, $needToPopContext = false, array $applyPathsToPop = [])
   524|     {
   525|         if ($needToPopContext) {
   526|             $this->popContext();
   527|         }
   528|         if ($applyPathsToPop !== []) {
   529|             $this->popApplyValues($applyPathsToPop);
   530|         }
   531|         $this->runtimeContentCache->leave($cacheContext);
   532|     }
   533|     /**
   534|      * Instantiates a Fusion object specified by the given path and configuration
   535|      *
   536|      * @param string $fusionPath Path to the configuration for this object instance
   537|      * @param array $fusionConfiguration Configuration at the given path
   538|      * @param array $applyValuePaths Apply value paths for this object
   539|      * @return AbstractFusionObject
   540|      * @throws Exception
   541|      */
   542|     protected function instantiateFusionObject($fusionPath, $fusionConfiguration, array $applyValuePaths)
   543|     {
   544|         $fusionObjectType = $fusionConfiguration['__objectType'];
   545|         $fusionObjectClassName = isset($fusionConfiguration['__meta']['class']) ? $fusionConfiguration['__meta']['class'] : null;
   546|         if (!preg_match('#<[^>]*>$#', $fusionPath)) {
   547|             $fusionPath .= '<' . $fusionObjectType . '>';
   548|         }
   549|         if (!class_exists($fusionObjectClassName)) {
   550|             throw new Exception(sprintf(
   551|                 'The implementation class `%s` defined for Fusion object of type `%s` does not exist.
   552| 				Maybe a typo in the `@class` property.',
   553|                 $fusionObjectClassName,
   554|                 $fusionObjectType
   555|             ), 1347952109);
   556|         }
   557|         /** @var $fusionObject AbstractFusionObject */
   558|         $fusionObject = new $fusionObjectClassName($this, $fusionPath, $fusionObjectType);
   559|         if ($this->isArrayFusionObject($fusionObject)) {
   560|             /** @var $fusionObject AbstractArrayFusionObject */
   561|             if (isset($fusionConfiguration['__meta']['ignoreProperties'])) {
   562|                 $evaluatedIgnores = $this->evaluate($fusionPath . '/__meta/ignoreProperties', $fusionObject);
   563|                 $fusionObject->setIgnoreProperties(is_array($evaluatedIgnores) ? $evaluatedIgnores : []);
   564|             }
   565|             $this->setPropertiesOnFusionObject($fusionObject, $fusionConfiguration, $applyValuePaths);
   566|         }
   567|         return $fusionObject;
   568|     }
   569|     /**
   570|      * Check if the given object is an array like object that should get all properties set to iterate or process internally.
   571|      *
   572|      * @param AbstractFusionObject $fusionObject
   573|      * @return boolean
   574|      */
   575|     protected function isArrayFusionObject(AbstractFusionObject $fusionObject)
   576|     {
   577|         return ($fusionObject instanceof AbstractArrayFusionObject);
   578|     }
   579|     /**
   580|      * Set options on the given (AbstractArray)Fusion object
   581|      *
   582|      * @param AbstractArrayFusionObject $fusionObject
   583|      * @param array $fusionConfiguration
   584|      * @param array $applyValuePaths
   585|      * @return void
   586|      */
   587|     protected function setPropertiesOnFusionObject(AbstractArrayFusionObject $fusionObject, array $fusionConfiguration, array $applyValuePaths)
   588|     {
   589|         foreach ($fusionConfiguration as $key => $value) {
   590|             if (is_string($key) && $key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
   591|                 continue;
   592|             }
   593|             ObjectAccess::setProperty($fusionObject, $key, $value);
   594|         }
   595|         if ($applyValuePaths !== []) {
   596|             foreach ($applyValuePaths as $path) {
   597|                 $entry = $this->currentApplyValues[$path];
   598|                 $key = $entry['key'];
   599|                 if (isset($entry['lazy'])) {
   600|                     $valueAst = [
   601|                         '__eelExpression' => null,
   602|                         '__objectType' => 'Neos.Fusion:Lazy',
   603|                         '__value' => null
   604|                     ];
   605|                 } else {
   606|                     $valueAst = [
   607|                         '__eelExpression' => null,
   608|                         '__objectType' => null,
   609|                         '__value' => $entry['value']
   610|                     ];
   611|                 }
   612|                 if ($meta = Arrays::getValueByPath($fusionConfiguration, [$key, '__meta'])) {
   613|                     $valueAst['__meta'] = $meta;
   614|                 }
   615|                 ObjectAccess::setProperty($fusionObject, $entry['key'], $valueAst);
   616|             }
   617|         }
   618|     }
   619|     /**
   620|      * Evaluate an Eel expression
   621|      *
   622|      * @param string $expression The Eel expression to evaluate
   623|      * @param \Neos\Fusion\FusionObjects\AbstractFusionObject $contextObject An optional object for the "this" value inside the context
   624|      * @return mixed The result of the evaluated Eel expression
   625|      * @throws Exception
   626|      */
   627|     protected function evaluateEelExpression($expression, AbstractFusionObject $contextObject = null)
   628|     {
   629|         if ($expression[0] !== '$' || $expression[1] !== '{') {
   630|             $expression = '${' . $expression . '}';
   631|         }
   632|         $contextVariables = array_merge($this->getDefaultContextVariables(), $this->currentContext);
   633|         if (isset($contextVariables['this'])) {
   634|             throw new Exception('Context variable "this" not allowed, as it is already reserved for a pointer to the current Fusion object.', 1344325044);
   635|         }
   636|         $contextVariables['this'] = $contextObject;
   637|         if ($this->eelEvaluator instanceof \Neos\Flow\ObjectManagement\DependencyInjection\DependencyProxy) {
   638|             $this->eelEvaluator->_activateDependency();
   639|         }
   640|         return EelUtility::evaluateEelExpression($expression, $this->eelEvaluator, $contextVariables);
   641|     }
   642|     /**
   643|      * Evaluate "@apply" for the given fusion key.
   644|      *
   645|      * If apply-definitions are found they are evaluated and the returned keys are combined.
   646|      * The result is returned as array with the following structure:
   647|      *
   648|      * [
   649|      *    'fusionPath/key_1' => ['key' => 'key_1', 'value' => 'evaluated value 1'],
   650|      *    'fusionPath/key_2' => ['key' => 'key_2', 'value' => 'evaluated value 2']
   651|      * ]
   652|      *
   653|      * If no apply-expression is defined null is returned instead.
   654|      *
   655|      * @param array $configurationWithEventualProperties
   656|      * @param string $fusionPath
   657|      * @return array|null
   658|      */
   659|     protected function evaluateApplyValues($configurationWithEventualProperties, $fusionPath): ?array
   660|     {
   661|         if (isset($configurationWithEventualProperties['__meta']['apply'])) {
   662|             $fusionObjectType = $configurationWithEventualProperties['__objectType'];
   663|             if (!preg_match('#<[^>]*>$#', $fusionPath)) {
   664|                 $fusionPath .= '<' . $fusionObjectType . '>';
   665|             }
   666|             $combinedApplyValues = [];
   667|             $propertiesConfiguration = $configurationWithEventualProperties['__meta']['apply'];
   668|             $positionalArraySorter = new PositionalArraySorter($propertiesConfiguration, '__meta.position');
   669|             foreach ($positionalArraySorter->getSortedKeys() as $key) {
   670|                 if ($key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
   671|                     continue;
   672|                 }
   673|                 $singleApplyPath = $fusionPath . '/__meta/apply/' . $key;
   674|                 if (isset($propertiesConfiguration[$key]['__meta']['if']) && $this->evaluateIfCondition($propertiesConfiguration[$key], $singleApplyPath) === false) {
   675|                     continue;
   676|                 }
   677|                 if (isset($propertiesConfiguration[$key]['expression'])) {
   678|                     $singleApplyPath .= '/expression';
   679|                 }
   680|                 $singleApplyValues = $this->evaluate($singleApplyPath, null, self::BEHAVIOR_EXCEPTION);
   681|                 if ($this->getLastEvaluationStatus() !== static::EVALUATION_SKIPPED) {
   682|                     if ($singleApplyValues === null) {
   683|                         continue;
   684|                     } elseif (is_array($singleApplyValues)) {
   685|                         foreach ($singleApplyValues as $key => $value) {
   686|                             if ($key[0] === '_' && $key[1] === '_' && in_array($key, Parser::$reservedParseTreeKeys, true)) {
   687|                                 continue;
   688|                             }
   689|                             $combinedApplyValues[$fusionPath . '/' . $key] = [
   690|                                 'key' => $key,
   691|                                 'value' => $value
   692|                             ];
   693|                         }
   694|                     } elseif ($singleApplyValues instanceof \Traversable && $singleApplyValues instanceof \ArrayAccess) {
   695|                         for ($singleApplyValues->rewind(); ($key = $singleApplyValues->key()) !== null; $singleApplyValues->next()) {
   696|                             $combinedApplyValues[$fusionPath . '/' . $key] = [
   697|                                 'key' => $key,
   698|                                 'value' => function () use ($singleApplyValues, $key) {
   699|                                     return $singleApplyValues[$key];
   700|                                 },
   701|                                 'lazy' => true
   702|                             ];
   703|                         }
   704|                     }
   705|                 }
   706|             }
   707|             return $combinedApplyValues;
   708|         }
   709|         return null;
   710|     }
   711|     /**
   712|      * Evaluate processors on given value.
   713|      *
   714|      * @param mixed $valueToProcess
   715|      * @param array $configurationWithEventualProcessors
   716|      * @param string $fusionPath
   717|      * @param AbstractFusionObject $contextObject
   718|      * @return mixed
   719|      */
   720|     protected function evaluateProcessors($valueToProcess, $configurationWithEventualProcessors, $fusionPath, AbstractFusionObject $contextObject = null)
   721|     {
   722|         $processorConfiguration = $configurationWithEventualProcessors['__meta']['process'];
   723|         $positionalArraySorter = new PositionalArraySorter($processorConfiguration, '__meta.position');
   724|         foreach ($positionalArraySorter->getSortedKeys() as $key) {
   725|             $processorPath = $fusionPath . '/__meta/process/' . $key;
   726|             if (isset($processorConfiguration[$key]['__meta']['if']) && $this->evaluateIfCondition($processorConfiguration[$key], $processorPath, $contextObject) === false) {
   727|                 continue;
   728|             }
   729|             if (count($processorConfiguration[$key]) === 1 && isset($processorConfiguration[$key]['__stopInheritanceChain'])) {
   730|                 continue;
   731|             }
   732|             if (isset($processorConfiguration[$key]['expression'])) {
   733|                 $processorPath .= '/expression';
   734|             }
   735|             $this->pushContext('value', $valueToProcess);
   736|             $result = $this->evaluate($processorPath, $contextObject, self::BEHAVIOR_EXCEPTION);
   737|             if ($this->getLastEvaluationStatus() !== static::EVALUATION_SKIPPED) {
   738|                 $valueToProcess = $result;
   739|             }
   740|             $this->popContext();
   741|         }
   742|         return $valueToProcess;
   743|     }
   744|     /**
   745|      * Evaluate eventually existing meta "@if" conditionals inside the given configuration and path.
   746|      *
   747|      * @param array $configurationWithEventualIf
   748|      * @param string $configurationPath
   749|      * @param AbstractFusionObject $contextObject
   750|      * @return boolean
   751|      */
   752|     protected function evaluateIfCondition($configurationWithEventualIf, $configurationPath, AbstractFusionObject $contextObject = null)
   753|     {
   754|         foreach ($configurationWithEventualIf['__meta']['if'] as $conditionKey => $conditionValue) {
   755|             $conditionValue = $this->evaluate($configurationPath . '/__meta/if/' . $conditionKey, $contextObject, self::BEHAVIOR_EXCEPTION);
   756|             if ((bool)$conditionValue === false) {
   757|                 return false;
   758|             }
   759|         }
   760|         return true;
   761|     }
   762|     /**
   763|      * Returns the context which has been passed by the currently active MVC Controller
   764|      *
   765|      * @return ControllerContext
   766|      */
   767|     public function getControllerContext()
   768|     {
   769|         return $this->controllerContext;
   770|     }
   771|     /**
   772|      * Get variables from configuration that should be set in the context by default.
   773|      * For example Eel helpers are made available by this.
   774|      *
   775|      * @return array Array with default context variable objects.
   776|      */
   777|     protected function getDefaultContextVariables()
   778|     {
   779|         if ($this->defaultContextVariables === null) {
   780|             $this->defaultContextVariables = [];
   781|             if (isset($this->settings['defaultContext']) && is_array($this->settings['defaultContext'])) {
   782|                 $this->defaultContextVariables = EelUtility::getDefaultContextVariables($this->settings['defaultContext']);
   783|             }
   784|             $this->defaultContextVariables['request'] = $this->controllerContext->getRequest();
   785|         }
   786|         return $this->defaultContextVariables;
   787|     }
   788|     /**
   789|      * Checks and throws an exception for an unrenderable path.
   790|      *
   791|      * @param string $fusionPath The Fusion path that cannot be rendered
   792|      * @param array $fusionConfiguration
   793|      * @param string $behaviorIfPathNotFound One of the BEHAVIOR_* constants
   794|      * @throws Exception\MissingFusionImplementationException
   795|      * @throws Exception\MissingFusionObjectException
   796|      */
   797|     protected function throwExceptionForUnrenderablePathIfNeeded($fusionPath, $fusionConfiguration, $behaviorIfPathNotFound)
   798|     {
   799|         if (isset($fusionConfiguration['__objectType'])) {
   800|             $objectType = $fusionConfiguration['__objectType'];
   801|             throw new Exceptions\MissingFusionImplementationException(sprintf(
   802|                 "The Fusion object `%s` cannot be rendered:
   803| 					Most likely you mistyped the prototype name or did not define 
   804| 					the Fusion prototype with `prototype(%s) < prototype ...` . 
   805| 					Other possible reasons are a missing parent-prototype or 
   806| 					a missing `@class` annotation for prototypes without parent.
   807| 					It is also possible your Fusion file is not read because 
   808| 					of a missing `include:` statement.",
   809|                 $objectType,
   810|                 $objectType
   811|             ), 1332493995);
   812|         }
   813|         if ($behaviorIfPathNotFound === self::BEHAVIOR_EXCEPTION) {
   814|             throw new Exceptions\MissingFusionObjectException(sprintf(
   815|                 'No Fusion object found in path "%s"
   816| 					Please make sure to define one in your Fusion configuration.',
   817|                 $fusionPath
   818|             ), 1332493990);
   819|         }
   820|     }
   821|     /**
   822|      * @param boolean $debugMode
   823|      * @return void
   824|      */
   825|     public function setDebugMode($debugMode)
   826|     {
   827|         $this->debugMode = $debugMode;
   828|     }
   829|     /**
   830|      * @return boolean
   831|      */
   832|     public function isDebugMode()
   833|     {
   834|         return $this->debugMode;
   835|     }
   836|     /**
   837|      * If the Fusion content cache should be enabled at all
   838|      *
   839|      * @param boolean $flag
   840|      * @return void
   841|      */
   842|     public function setEnableContentCache($flag)
   843|     {
   844|         $this->runtimeContentCache->setEnableContentCache($flag);
   845|     }
   846| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/AbstractArrayFusionObject.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-155 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Utility\Exception\InvalidPositionException;
    13| use Neos\Utility\PositionalArraySorter;
    14| use Neos\Fusion\Exception as FusionException;
    15| use Neos\Fusion\Core\Runtime;
    16| /**
    17|  * Base class for Fusion objects that need access to arbitrary properties, like DataStructureImplementation.
    18|  */
    19| abstract class AbstractArrayFusionObject extends AbstractFusionObject implements \ArrayAccess
    20| {
    21|     /**
    22|      * List of properties which have been set using array access. We store this for *every* Fusion object
    23|      * in order to do things like:
    24|      * x = Foo {
    25|      *   a = 'foo'
    26|      *   b = ${this.a + 'bar'}
    27|      * }
    28|      *
    29|      * @var array
    30|      * @internal
    31|      */
    32|     protected $properties = [];
    33|     /**
    34|      * If you iterate over "properties" these in here should usually be ignored. For example additional properties in "Case" that are not "Matchers".
    35|      *
    36|      * @var array
    37|      */
    38|     protected $ignoreProperties = [];
    39|     /**
    40|      * @param array $ignoreProperties
    41|      * @return void
    42|      */
    43|     public function setIgnoreProperties($ignoreProperties = [])
    44|     {
    45|         $this->ignoreProperties = $ignoreProperties;
    46|     }
    47|     /**
    48|      * @param mixed $offset
    49|      * @return boolean
    50|      */
    51|     public function offsetExists($offset): bool
    52|     {
    53|         return isset($this->properties[$offset]);
    54|     }
    55|     /**
    56|      * @param mixed $offset
    57|      * @return mixed
    58|      */
    59|     public function offsetGet($offset): mixed
    60|     {
    61|         return $this->fusionValue($offset);
    62|     }
    63|     /**
    64|      * @param mixed $offset
    65|      * @param mixed $value
    66|      * @return void
    67|      */
    68|     public function offsetSet($offset, $value): void
    69|     {
    70|         $this->properties[$offset] = $value;
    71|     }
    72|     /**
    73|      * @param mixed $offset
    74|      * @return void
    75|      */
    76|     public function offsetUnset($offset): void
    77|     {
    78|         unset($this->properties[$offset]);
    79|     }
    80|     /**
    81|      * @param string|null $defaultFusionPrototypeName
    82|      * @return array
    83|      * @throws FusionException
    84|      * @throws \Neos\Flow\Configuration\Exception\InvalidConfigurationException
    85|      * @throws \Neos\Flow\Mvc\Exception\StopActionException
    86|      * @throws \Neos\Flow\Security\Exception
    87|      */
    88|     protected function evaluateNestedProperties(?string $defaultFusionPrototypeName = null): array
    89|     {
    90|         $sortedChildFusionKeys = $this->sortNestedProperties();
    91|         if (count($sortedChildFusionKeys) === 0) {
    92|             return [];
    93|         }
    94|         $result = [];
    95|         foreach ($sortedChildFusionKeys as $key) {
    96|             $propertyPath = $key;
    97|             if ($defaultFusionPrototypeName !== null && $this->isUntyped($key)) {
    98|                 $propertyPath .= '<' . $defaultFusionPrototypeName . '>';
    99|             }
   100|             try {
   101|                 $value = $this->fusionValue($propertyPath);
   102|             } catch (\Exception $e) {
   103|                 $value = $this->runtime->handleRenderingException($this->path . '/' . $key, $e);
   104|             }
   105|             if ($value === null && $this->runtime->getLastEvaluationStatus() === Runtime::EVALUATION_SKIPPED) {
   106|                 continue;
   107|             }
   108|             $result[$key] = $value;
   109|         }
   110|         return $result;
   111|     }
   112|     /**
   113|      * Sort the Fusion objects inside $this->properties depending on:
   114|      * - numerical ordering
   115|      * - position meta-property
   116|      *
   117|      * This will ignore all properties defined in "@ignoreProperties" in Fusion
   118|      *
   119|      * @see PositionalArraySorter
   120|      *
   121|      * @return array an ordered list of key value pairs
   122|      * @throws FusionException if the positional string has an unsupported format
   123|      */
   124|     protected function sortNestedProperties(): array
   125|     {
   126|         $arraySorter = new PositionalArraySorter($this->properties, '__meta.position');
   127|         try {
   128|             $sortedFusionKeys = $arraySorter->getSortedKeys();
   129|         } catch (InvalidPositionException $exception) {
   130|             throw new FusionException('Invalid position string', 1345126502, $exception);
   131|         }
   132|         foreach ($this->ignoreProperties as $ignoredPropertyName) {
   133|             $key = array_search($ignoredPropertyName, $sortedFusionKeys);
   134|             if ($key !== false) {
   135|                 unset($sortedFusionKeys[$key]);
   136|             }
   137|         }
   138|         return $sortedFusionKeys;
   139|     }
   140|     /**
   141|      * Returns TRUE if the given fusion key has no type, meaning neither
   142|      * having a fusion objectType, eelExpression or value
   143|      *
   144|      * @param string|int $key fusion child key path to check
   145|      * @return bool
   146|      */
   147|     protected function isUntyped(string|int $key): bool
   148|     {
   149|         $property = $this->properties[$key];
   150|         if (!is_array($property)) {
   151|             return false;
   152|         }
   153|         return !isset($property['__objectType']) && !isset($property['__eelExpression']) && !isset($property['__value']);
   154|     }
   155| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/AbstractFusionObject.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-122 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Fusion\Core\Runtime;
    13| /**
    14|  * Base class for all Fusion objects
    15|  */
    16| abstract class AbstractFusionObject implements \ArrayAccess
    17| {
    18|     /**
    19|      * @var Runtime
    20|      */
    21|     protected $runtime;
    22|     /**
    23|      * The Fusion path currently being rendered
    24|      *
    25|      * @var string
    26|      */
    27|     protected $path;
    28|     /**
    29|      * Name of this Fusion object, like Neos.Neos:Text
    30|      *
    31|      * @var string
    32|      */
    33|     protected $fusionObjectName;
    34|     /**
    35|      * @var array
    36|      */
    37|     protected $fusionValueCache = [];
    38|     /**
    39|      * Constructor
    40|      *
    41|      * @param Runtime $runtime
    42|      * @param string $path
    43|      * @param string $fusionObjectName
    44|      */
    45|     public function __construct(Runtime $runtime, $path, $fusionObjectName)
    46|     {
    47|         $this->runtime = $runtime;
    48|         $this->path = $path;
    49|         $this->fusionObjectName = $fusionObjectName;
    50|     }
    51|     /**
    52|      * Evaluate this Fusion object and return the result
    53|      *
    54|      * @return mixed
    55|      */
    56|     abstract public function evaluate();
    57|     /**
    58|      * Get the Fusion runtime this object was created in.
    59|      *
    60|      * @return Runtime
    61|      */
    62|     public function getRuntime()
    63|     {
    64|         return $this->runtime;
    65|     }
    66|     /**
    67|      * Return the Fusion value relative to this Fusion object (with processors etc applied).
    68|      *
    69|      * Note that subsequent calls of fusionValue() with the same Fusion path will return the same values since the
    70|      * first evaluated value will be cached in memory.
    71|      *
    72|      * @param string $path
    73|      * @return mixed
    74|      */
    75|     protected function fusionValue($path)
    76|     {
    77|         $fullPath = $this->path . '/' . $path;
    78|         if (!isset($this->fusionValueCache[$fullPath])) {
    79|             $this->fusionValueCache[$fullPath] = $this->runtime->evaluate($fullPath, $this);
    80|         }
    81|         return $this->fusionValueCache[$fullPath];
    82|     }
    83|     /**
    84|      * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
    85|      *
    86|      * @param mixed $offset
    87|      * @return boolean
    88|      */
    89|     public function offsetExists($offset): bool
    90|     {
    91|         return ($this->fusionValue($offset) !== null);
    92|     }
    93|     /**
    94|      * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
    95|      *
    96|      * @param mixed $offset
    97|      * @return mixed
    98|      */
    99|     public function offsetGet($offset): mixed
   100|     {
   101|         return $this->fusionValue($offset);
   102|     }
   103|     /**
   104|      * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
   105|      *
   106|      * @param mixed $offset
   107|      * @param mixed $value
   108|      * @return void
   109|      */
   110|     public function offsetSet($offset, $value): void
   111|     {
   112|     }
   113|     /**
   114|      * Dummy implementation of ArrayAccess to allow this.XXX access in processors.
   115|      *
   116|      * @param mixed $offset
   117|      * @return void
   118|      */
   119|     public function offsetUnset($offset): void
   120|     {
   121|     }
   122| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/AugmenterImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Fusion\Service\HtmlAugmenter;
    14| /**
    15|  * A Fusion Augmenter-Object
    16|  *
    17|  * The fusion object can be used to add html-attributes to the rendererd content
    18|  *
    19|  * @api
    20|  */
    21| class AugmenterImplementation extends AbstractArrayFusionObject
    22| {
    23|     /**
    24|      * @var HtmlAugmenter
    25|      * @Flow\Inject
    26|      */
    27|     protected $htmlAugmenter;
    28|     /**
    29|      * Properties that are ignored
    30|      *
    31|      * @var array
    32|      */
    33|     protected $ignoreProperties = ['__meta', 'fallbackTagName', 'content'];
    34|     /**
    35|      * @return void|string
    36|      */
    37|     public function evaluate()
    38|     {
    39|         $content = $this->fusionValue('content');
    40|         $fallbackTagName = $this->fusionValue('fallbackTagName');
    41|         $attributes = $this->evaluateNestedProperties();
    42|         if ($attributes && is_array($attributes) && count($attributes) > 0) {
    43|             return $this->htmlAugmenter->addAttributes($content, $attributes, $fallbackTagName);
    44|         } else {
    45|             return $content;
    46|         }
    47|     }
    48| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/CaseImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-92 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Fusion\Exception\UnsupportedObjectTypeAtPathException;
    13| /**
    14|  * Case Fusion Object
    15|  *
    16|  * The "case" Fusion object renders its children in order. The first
    17|  * result which is not MATCH_NORESULT is returned.
    18|  *
    19|  * Often, this Fusion object is used together with the "Matcher" Fusion
    20|  * object; and all its children are by-default interpreted as "Matcher" Fusion
    21|  * objects if no others are specified.
    22|  */
    23| class CaseImplementation extends AbstractArrayFusionObject
    24| {
    25|     /**
    26|      * This constant should be returned by individual matchers if the matcher
    27|      * did not match.
    28|      *
    29|      * You should not rely on the contents or type of this constant.
    30|      */
    31|     const MATCH_NORESULT = '_____________NO_MATCH_RESULT_____________';
    32|     /**
    33|      * Execute each matcher until the first one matches
    34|      *
    35|      * @return mixed
    36|      */
    37|     public function evaluate()
    38|     {
    39|         $matcherKeys = $this->sortNestedProperties();
    40|         foreach ($matcherKeys as $matcherName) {
    41|             $renderedMatcher = $this->renderMatcher($matcherName);
    42|             if ($this->matcherMatched($renderedMatcher)) {
    43|                 return $renderedMatcher;
    44|             }
    45|         }
    46|         return null;
    47|     }
    48|     /**
    49|      * Render the given matcher
    50|      *
    51|      * A result value of MATCH_NORESULT means that the condition of the matcher did not match and the case should
    52|      * continue.
    53|      *
    54|      * @param string $matcherKey
    55|      * @return string
    56|      * @throws UnsupportedObjectTypeAtPathException
    57|      */
    58|     protected function renderMatcher($matcherKey)
    59|     {
    60|         $renderedMatcher = null;
    61|         if (isset($this->properties[$matcherKey]['__objectType'])) {
    62|             $renderedMatcher = $this->runtime->render(
    63|                 sprintf('%s/%s', $this->path, $matcherKey)
    64|             );
    65|             return $renderedMatcher;
    66|         } elseif (!is_array($this->properties[$matcherKey])) {
    67|             throw new UnsupportedObjectTypeAtPathException('"Case" Fusion object only supports nested Fusion objects; no simple values.', 1372668062);
    68|         } elseif (isset($this->properties[$matcherKey]['__eelExpression'])) {
    69|             throw new UnsupportedObjectTypeAtPathException('"Case" Fusion object only supports nested Fusion objects; no Eel expressions.', 1372668077);
    70|         } else {
    71|             $renderedMatcher = $this->runtime->render(
    72|                 sprintf('%s/%s<Neos.Fusion:Matcher>', $this->path, $matcherKey)
    73|             );
    74|             return $renderedMatcher;
    75|         }
    76|     }
    77|     /**
    78|      * Test whether the output of the matcher does not equal the MATCH_NORESULT
    79|      *
    80|      * If the debug mode is enabled, we have to strip the debug output before comparing the rendered result.
    81|      *
    82|      * @param string $renderedMatcher
    83|      * @return boolean
    84|      */
    85|     protected function matcherMatched($renderedMatcher)
    86|     {
    87|         if ($this->runtime->isDebugMode()) {
    88|             $renderedMatcher = preg_replace('/\s*<!--.*?-->\s*/', '', $renderedMatcher);
    89|         }
    90|         return $renderedMatcher !== self::MATCH_NORESULT;
    91|     }
    92| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/ComponentImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-80 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Fusion\FusionObjects\Helpers\LazyProps;
    13| /**
    14|  * A Fusion Component-Object
    15|  *
    16|  * All properties except ``renderer`` are pushed into a context variable ``props``
    17|  * afterwards the ``renderer`` is evaluated
    18|  *
    19|  * //fusionPath renderer The variable to display a dump of.
    20|  * //fusionPath * generic Fusion values that will be added to the ``props`` object in the context
    21|  * @api
    22|  */
    23| class ComponentImplementation extends AbstractArrayFusionObject
    24| {
    25|     /**
    26|      * Properties that are ignored and not included into the ``props`` context
    27|      *
    28|      * @var array
    29|      */
    30|     protected $ignoreProperties = ['__meta', 'renderer'];
    31|     /**
    32|      * Evaluate the fusion-keys and transfer the result into the context as ``props``
    33|      * afterwards evaluate the ``renderer`` with this context
    34|      *
    35|      * @return mixed
    36|      */
    37|     public function evaluate()
    38|     {
    39|         $context = $this->runtime->getCurrentContext();
    40|         $renderContext = $this->prepare($context);
    41|         $result = $this->render($renderContext);
    42|         return $result;
    43|     }
    44|     /**
    45|      * Prepare the context for the renderer
    46|      *
    47|      * @param array $context
    48|      * @return array
    49|      */
    50|     protected function prepare(array $context): array
    51|     {
    52|         $context['props'] = $this->getProps($context);
    53|         return $context;
    54|     }
    55|     /**
    56|      * Calculate the component props
    57|      *
    58|      * @param array $context
    59|      * @return \ArrayAccess
    60|      */
    61|     protected function getProps(array $context): \ArrayAccess
    62|     {
    63|         $sortedChildFusionKeys = $this->sortNestedProperties();
    64|         $props = new LazyProps($this, $this->path, $this->runtime, $sortedChildFusionKeys, $context);
    65|         return $props;
    66|     }
    67|     /**
    68|      * Evaluate the renderer with the give context and return
    69|      *
    70|      * @param array $context
    71|      * @return mixed
    72|      */
    73|     protected function render(array $context)
    74|     {
    75|         $this->runtime->pushContextArray($context);
    76|         $result = $this->runtime->render($this->path . '/renderer');
    77|         $this->runtime->popContext();
    78|         return $result;
    79|     }
    80| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/DataStructureImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Fusion\Exception as FusionException;
    13| /**
    14|  * Fusion object to render and array of key value pairs by evaluating all properties
    15|  */
    16| class DataStructureImplementation extends AbstractArrayFusionObject
    17| {
    18|     /**
    19|      * Evaluate this Fusion object and return the result
    20|      *
    21|      * @return array
    22|      * @throws FusionException
    23|      * @throws \Neos\Flow\Configuration\Exception\InvalidConfigurationException
    24|      * @throws \Neos\Flow\Mvc\Exception\StopActionException
    25|      * @throws \Neos\Flow\Security\Exception
    26|      */
    27|     public function evaluate()
    28|     {
    29|         return $this->evaluateNestedProperties('Neos.Fusion:DataStructure');
    30|     }
    31|     /**
    32|      * Sort the Fusion objects inside $this->properties depending on:
    33|      * - numerical ordering
    34|      * - position meta-property
    35|      *
    36|      * This will ignore all properties defined in "@ignoreProperties" in Fusion
    37|      *
    38|      * @see PositionalArraySorter
    39|      *
    40|      * @return array an ordered list of key value pairs
    41|      * @throws FusionException if the positional string has an unsupported format
    42|      * @deprecated since 8.0 can be removed with 9.0 use {@see \Neos\Fusion\FusionObjects\AbstractArrayFusionObject::sortNestedProperties}
    43|      */
    44|     protected function sortNestedFusionKeys()
    45|     {
    46|         return $this->sortNestedProperties();
    47|     }
    48| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/DebugConsoleImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-59 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| /**
    13|  * A Fusion object for debugging fusion-values via the browser console
    14|  *
    15|  * //fusionPath value The variable to serialize and output to the console.
    16|  * //fusionPath title Optional custom title for the debug output.
    17|  * //fusionPath method Optional alternative method to call on the browser console.
    18|  * //fusionPath content When used as process the console script will be appended to it.
    19|  * @api
    20|  */
    21| class DebugConsoleImplementation extends AbstractArrayFusionObject
    22| {
    23|     protected $ignoreProperties = ['__meta', 'title', 'method', 'value', 'content'];
    24|     public function getTitle(): string
    25|     {
    26|         return $this->fusionValue('title') ?: '';
    27|     }
    28|     public function getMethod(): string
    29|     {
    30|         return $this->fusionValue('method') ?: 'log';
    31|     }
    32|     public function getContent(): string
    33|     {
    34|         return $this->fusionValue('content') ?: '';
    35|     }
    36|     /**
    37|      * @return mixed
    38|      */
    39|     public function getValue()
    40|     {
    41|         return $this->fusionValue('value') ?: '';
    42|     }
    43|     /**
    44|      * Appends a console script call to the output
    45|      */
    46|     public function evaluate(): string
    47|     {
    48|         $title = trim($this->getTitle());
    49|         $method = $this->getMethod();
    50|         $content = $this->getContent();
    51|         $arguments = $this->evaluateNestedProperties();
    52|         array_unshift($arguments, $this->getValue());
    53|         if ($title) {
    54|             $arguments[] = $this->getTitle();
    55|         }
    56|         $arguments = array_map('json_encode', $arguments);
    57|         return sprintf('%s<script>console.%s(%s)</script>', $content, $method, implode(', ', $arguments));
    58|     }
    59| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/DebugImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-77 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Fusion\DebugMessage;
    14| use Neos\Fusion\Service\DebugStack;
    15| /**
    16|  * A Fusion object for debugging fusion-values
    17|  *
    18|  * If only value is given it is debugged directly. Otherwise all keys except title an plaintext are debugged.
    19|  *
    20|  * //fusionPath value The variable to display a dump of.
    21|  * //fusionPath title $title optional custom title for the debug output
    22|  * //fusionPath plaintext If true, the dump is in plain text, if false the debug output is in HTML format. If not specified, the mode is guessed from FLOW_SAPITYPE
    23|  * @api
    24|  */
    25| class DebugImplementation extends AbstractArrayFusionObject
    26| {
    27|     /**
    28|      * If you iterate over "properties" these in here should usually be ignored.
    29|      * For example additional properties in "Case" that are not "Matchers".
    30|      *
    31|      * @var array
    32|      */
    33|     protected $ignoreProperties = ['__meta', 'title', 'plaintext'];
    34|     /**
    35|      * @var DebugStack
    36|      * @Flow\Inject
    37|      */
    38|     protected $stack;
    39|     public function getTitle(): string
    40|     {
    41|         return $this->fusionValue('title') ?: '';
    42|     }
    43|     public function getPlaintext(): bool
    44|     {
    45|         return $this->fusionValue('plaintext') ?: false;
    46|     }
    47|     /**
    48|      * Return the values in a human readable form
    49|      *
    50|      * @return string
    51|      */
    52|     public function evaluate()
    53|     {
    54|         $title = trim($this->getTitle());
    55|         $plaintext = $this->getPlaintext();
    56|         $debugData = [];
    57|         foreach (array_keys($this->properties) as $key) {
    58|             if (in_array($key, $this->ignoreProperties)) {
    59|                 continue;
    60|             }
    61|             $debugData[$key] = $this->fusionValue($key);
    62|         }
    63|         $title .= ' @ ' . $this->path;
    64|         if (count($debugData) === 0) {
    65|             $debugData = [null];
    66|         }
    67|         foreach ($debugData as $suffix => $data) {
    68|             if (is_string($suffix)) {
    69|                 $message = (new DebugMessage(trim($title . '.' . $suffix), $this->path, $data, $plaintext));
    70|             } else {
    71|                 $message = (new DebugMessage(trim($title), $this->path, $data, $plaintext));
    72|             }
    73|             $this->stack->register($message);
    74|         }
    75|         return $this->fusionValue('value');
    76|     }
    77| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/Helpers/LazyProps.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-101 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects\Helpers;
     3| use Neos\Flow\Annotations as Flow;
     4| use Neos\Fusion\Core\Runtime;
     5| /**
     6|  * @Flow\Proxy(false)
     7|  */
     8| final class LazyProps implements \ArrayAccess, \Iterator, \JsonSerializable
     9| {
    10|     /**
    11|      * @var array
    12|      */
    13|     private $valueCache = [];
    14|     /**
    15|      * @var string
    16|      */
    17|     private $parentPath;
    18|     /**
    19|      * @var Runtime
    20|      */
    21|     private $runtime;
    22|     /**
    23|      * Index of keys
    24|      *
    25|      * @var array
    26|      */
    27|     private $keys;
    28|     /**
    29|      * @var object
    30|      */
    31|     private $fusionObject;
    32|     /**
    33|      * @var array
    34|      */
    35|     private $effectiveContext;
    36|     public function __construct(
    37|         object $fusionObject,
    38|         string $parentPath,
    39|         Runtime $runtime,
    40|         array $keys,
    41|         array $effectiveContext
    42|     ) {
    43|         $this->fusionObject = $fusionObject;
    44|         $this->parentPath = $parentPath;
    45|         $this->runtime = $runtime;
    46|         $this->keys = array_flip($keys);
    47|         $this->effectiveContext = $effectiveContext;
    48|     }
    49|     public function offsetExists($path): bool
    50|     {
    51|         return array_key_exists($path, $this->keys);
    52|     }
    53|     public function offsetGet($path): mixed
    54|     {
    55|         if (!array_key_exists($path, $this->valueCache)) {
    56|             $this->runtime->pushContextArray($this->effectiveContext);
    57|             try {
    58|                 $this->valueCache[$path] = $this->runtime->evaluate($this->parentPath . '/' . $path, $this->fusionObject);
    59|             } finally {
    60|                 $this->runtime->popContext();
    61|             }
    62|         }
    63|         return $this->valueCache[$path];
    64|     }
    65|     public function offsetSet($path, $value): void
    66|     {
    67|         throw new BadMethodCallException('Lazy props can not be set.', 1588182804);
    68|     }
    69|     public function offsetUnset($path): void
    70|     {
    71|         throw new BadMethodCallException('Lazy props can not be unset.', 1588182805);
    72|     }
    73|     public function current(): mixed
    74|     {
    75|         $path = key($this->keys);
    76|         if ($path === null) {
    77|             return null;
    78|         }
    79|         return $this->offsetGet($path);
    80|     }
    81|     public function next(): void
    82|     {
    83|         next($this->keys);
    84|     }
    85|     public function key(): mixed
    86|     {
    87|         return key($this->keys);
    88|     }
    89|     public function valid(): bool
    90|     {
    91|         return current($this->keys) !== false;
    92|     }
    93|     public function rewind(): void
    94|     {
    95|         reset($this->keys);
    96|     }
    97|     public function jsonSerialize(): mixed
    98|     {
    99|         return iterator_to_array($this);
   100|     }
   101| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/HttpResponseImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| use GuzzleHttp\Psr7\Message;
     4| use Neos\Flow\Annotations as Flow;
     5| use Psr\Http\Message\ResponseInterface;
     6| use Psr\Http\Message\StreamFactoryInterface;
     7| /**
     8|  *
     9|  */
    10| class HttpResponseImplementation extends AbstractArrayFusionObject
    11| {
    12|     /**
    13|      * @Flow\Inject
    14|      * @var StreamFactoryInterface
    15|      */
    16|     protected $contentStreamFactory;
    17|     /**
    18|      * Get the HTTP Header values for this response
    19|      *
    20|      * @return ResponseInterface
    21|      */
    22|     public function getResponseHead()
    23|     {
    24|         return $this->fusionValue($this->getResponseHeadName()) ?? null;
    25|     }
    26|     /**
    27|      * @return string
    28|      */
    29|     public function getResponseHeadName(): string
    30|     {
    31|         return $this->fusionValue('_getHttpResponseHead') ?? 'httpResponseHead';
    32|     }
    33|     /**
    34|      * {@inheritdoc}
    35|      *
    36|      * @return string
    37|      */
    38|     public function evaluate()
    39|     {
    40|         if (!in_array($this->getResponseHeadName(), $this->ignoreProperties, true)) {
    41|             $this->ignoreProperties[] = $this->getResponseHeadName();
    42|         }
    43|         $response = $this->getResponseHead();
    44|         if (!$response instanceof ResponseInterface) {
    45|             throw new \InvalidArgumentException('Could not render HTTP response because the response head was not a valid HTTP response object.', 1557932997);
    46|         }
    47|         $resultParts = $this->evaluateNestedProperties();
    48|         if ($resultParts !== []) {
    49|             $contentStream = $this->contentStreamFactory->createStream(implode('', $resultParts));
    50|             $response = $response->withBody($contentStream);
    51|         }
    52|         return Message::toString($response);
    53|     }
    54| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/JoinImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-40 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| /**
    13|  * Fusion object to render a list of items as single concatenated string
    14|  */
    15| class JoinImplementation extends AbstractArrayFusionObject
    16| {
    17|     /**
    18|      * Get the glue to insert between items
    19|      *
    20|      * @return string
    21|      */
    22|     public function getGlue()
    23|     {
    24|         return $this->fusionValue('__meta/glue') ?? '';
    25|     }
    26|     /**
    27|      * {@inheritdoc}
    28|      *
    29|      * @return string|null
    30|      */
    31|     public function evaluate()
    32|     {
    33|         $glue = $this->getGlue();
    34|         $resultParts = $this->evaluateNestedProperties();
    35|         if ($resultParts !== []) {
    36|             return implode($glue, $resultParts);
    37|         }
    38|         return null;
    39|     }
    40| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/ResourceUriImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-128 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\I18n\Service;
    14| use Neos\Flow\Mvc\ActionRequest;
    15| use Neos\Flow\ResourceManagement\PersistentResource;
    16| use Neos\Flow\ResourceManagement\ResourceManager;
    17| use Neos\Fusion\Exception as FusionException;
    18| /**
    19|  * A Fusion object to create resource URIs
    20|  *
    21|  * The following Fusion properties are evaluated:
    22|  *  * path
    23|  *  * package
    24|  *  * resource
    25|  *  * localize
    26|  *
    27|  * See respective getters for descriptions
    28|  */
    29| class ResourceUriImplementation extends AbstractFusionObject
    30| {
    31|     /**
    32|      * @Flow\Inject
    33|      * @var ResourceManager
    34|      */
    35|     protected $resourceManager;
    36|     /**
    37|      * @Flow\Inject
    38|      * @var Service
    39|      */
    40|     protected $i18nService;
    41|     /**
    42|      * The location of the resource, can be either a path relative to the Public resource directory of the package or a resource://... URI
    43|      *
    44|      * @return string
    45|      */
    46|     public function getPath()
    47|     {
    48|         return $this->fusionValue('path');
    49|     }
    50|     /**
    51|      * Target package key (only required for relative paths)
    52|      *
    53|      * @return string
    54|      */
    55|     public function getPackage()
    56|     {
    57|         return $this->fusionValue('package');
    58|     }
    59|     /**
    60|      * If specified, this resource object is used instead of the path and package information
    61|      *
    62|      * @return PersistentResource
    63|      */
    64|     public function getResource()
    65|     {
    66|         return $this->fusionValue('resource');
    67|     }
    68|     /**
    69|      * Whether resource localization should be attempted or not, defaults to true
    70|      *
    71|      * @return boolean
    72|      */
    73|     public function isLocalize()
    74|     {
    75|         return (boolean)$this->fusionValue('localize');
    76|     }
    77|     /**
    78|      * Returns the absolute URL of a resource
    79|      *
    80|      * @return string
    81|      * @throws FusionException
    82|      */
    83|     public function evaluate()
    84|     {
    85|         $resource = $this->getResource();
    86|         if ($resource !== null) {
    87|             $uri = false;
    88|             if ($resource instanceof PersistentResource) {
    89|                 $uri = $this->resourceManager->getPublicPersistentResourceUri($resource);
    90|             }
    91|             if ($uri === false) {
    92|                 throw new FusionException('The specified resource is invalid', 1386458728);
    93|             }
    94|             return $uri;
    95|         }
    96|         $path = $this->getPath();
    97|         if ($path === null) {
    98|             throw new FusionException('Neither "resource" nor "path" were specified', 1386458763);
    99|         }
   100|         if (strpos($path, 'resource://') === 0) {
   101|             $matches = [];
   102|             if (preg_match('#^resource://([^/]+)/Public/(.*)#', $path, $matches) !== 1) {
   103|                 throw new FusionException(sprintf('The specified path "%s" does not point to a public resource.', $path), 1386458851);
   104|             }
   105|             $package = $matches[1];
   106|             $path = $matches[2];
   107|         } else {
   108|             $package = $this->getPackage();
   109|             if ($package === null) {
   110|                 $controllerContext = $this->runtime->getControllerContext();
   111|                 /** @var $actionRequest ActionRequest */
   112|                 $actionRequest = $controllerContext->getRequest();
   113|                 $package = $actionRequest->getControllerPackageKey();
   114|             }
   115|         }
   116|         $localize = $this->isLocalize();
   117|         if ($localize === true) {
   118|             $resourcePath = 'resource://' . $package . '/Public/' . $path;
   119|             $localizedResourcePathData = $this->i18nService->getLocalizedFilename($resourcePath);
   120|             $matches = [];
   121|             if (preg_match('#resource://([^/]+)/Public/(.*)#', current($localizedResourcePathData), $matches) === 1) {
   122|                 $package = $matches[1];
   123|                 $path = $matches[2];
   124|             }
   125|         }
   126|         return $this->resourceManager->getPublicPackageResourceUri($package, $path);
   127|     }
   128| }


# ====================================================================
# FILE: Neos.Fusion/Classes/FusionObjects/UriBuilderImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-175 ---
     1| <?php
     2| namespace Neos\Fusion\FusionObjects;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| /**
    13|  * A Fusion UriBuilder object
    14|  *
    15|  * The following Fusion properties are evaluated:
    16|  *  * package
    17|  *  * subpackage
    18|  *  * controller
    19|  *  * action
    20|  *  * arguments
    21|  *  * format
    22|  *  * section
    23|  *  * additionalParams
    24|  *  * addQueryString
    25|  *  * argumentsToBeExcludedFromQueryString
    26|  *  * absolute
    27|  *
    28|  * See respective getters for descriptions
    29|  */
    30| class UriBuilderImplementation extends AbstractFusionObject
    31| {
    32|     /**
    33|      * Key of the target package
    34|      *
    35|      * @return string
    36|      */
    37|     public function getPackage()
    38|     {
    39|         return $this->fusionValue('package');
    40|     }
    41|     /**
    42|      * Key of the target sub package
    43|      *
    44|      * @return string
    45|      */
    46|     public function getSubpackage()
    47|     {
    48|         return $this->fusionValue('subpackage');
    49|     }
    50|     /**
    51|      * Target controller name
    52|      *
    53|      * @return string
    54|      */
    55|     public function getController()
    56|     {
    57|         return $this->fusionValue('controller');
    58|     }
    59|     /**
    60|      * Target controller action name
    61|      *
    62|      * @return string
    63|      */
    64|     public function getAction()
    65|     {
    66|         return $this->fusionValue('action');
    67|     }
    68|     /**
    69|      * Controller arguments
    70|      *
    71|      * @return array
    72|      */
    73|     public function getArguments()
    74|     {
    75|         $arguments = $this->fusionValue('arguments');
    76|         return is_array($arguments) ? $arguments: [];
    77|     }
    78|     /**
    79|      * The requested format, for example "html"
    80|      *
    81|      * @return string
    82|      */
    83|     public function getFormat()
    84|     {
    85|         return $this->fusionValue('format');
    86|     }
    87|     /**
    88|      * The anchor to be appended to the URL
    89|      *
    90|      * @return string
    91|      */
    92|     public function getSection()
    93|     {
    94|         return $this->fusionValue('section');
    95|     }
    96|     /**
    97|      * Additional query parameters that won't be prefixed like $arguments (overrule $arguments)
    98|      *
    99|      * @return array
   100|      */
   101|     public function getAdditionalParams()
   102|     {
   103|         return $this->fusionValue('additionalParams');
   104|     }
   105|     /**
   106|      * Arguments to be removed from the URI. Only active if addQueryString = true
   107|      *
   108|      * @return array
   109|      */
   110|     public function getArgumentsToBeExcludedFromQueryString()
   111|     {
   112|         return $this->fusionValue('argumentsToBeExcludedFromQueryString');
   113|     }
   114|     /**
   115|      * If true, the current query parameters will be kept in the URI
   116|      *
   117|      * @return boolean
   118|      */
   119|     public function isAddQueryString()
   120|     {
   121|         return (boolean)$this->fusionValue('addQueryString');
   122|     }
   123|     /**
   124|      * If true, an absolute URI is rendered
   125|      *
   126|      * @return boolean
   127|      */
   128|     public function isAbsolute()
   129|     {
   130|         return (boolean)$this->fusionValue('absolute');
   131|     }
   132|     /**
   133|      * @return string
   134|      */
   135|     public function evaluate()
   136|     {
   137|         $controllerContext = $this->runtime->getControllerContext();
   138|         $uriBuilder = $controllerContext->getUriBuilder()->reset();
   139|         $format = $this->getFormat();
   140|         if ($format !== null) {
   141|             $uriBuilder->setFormat($format);
   142|         }
   143|         $additionalParams = $this->getAdditionalParams();
   144|         if ($additionalParams !== null) {
   145|             $uriBuilder->setArguments($additionalParams);
   146|         }
   147|         $argumentsToBeExcludedFromQueryString = $this->getArgumentsToBeExcludedFromQueryString();
   148|         if ($argumentsToBeExcludedFromQueryString !== null) {
   149|             $uriBuilder->setArgumentsToBeExcludedFromQueryString($argumentsToBeExcludedFromQueryString);
   150|         }
   151|         $absolute = $this->isAbsolute();
   152|         if ($absolute === true) {
   153|             $uriBuilder->setCreateAbsoluteUri(true);
   154|         }
   155|         $section = $this->getSection();
   156|         if ($section !== null) {
   157|             $uriBuilder->setSection($section);
   158|         }
   159|         $addQueryString = $this->isAddQueryString();
   160|         if ($addQueryString === true) {
   161|             $uriBuilder->setAddQueryString(true);
   162|         }
   163|         try {
   164|             return $uriBuilder->uriFor(
   165|                 $this->getAction(),
   166|                 $this->getArguments(),
   167|                 $this->getController(),
   168|                 $this->getPackage(),
   169|                 $this->getSubpackage()
   170|             );
   171|         } catch (\Exception $exception) {
   172|             return $this->runtime->handleRenderingException($this->path, $exception);
   173|         }
   174|     }
   175| }


# ====================================================================
# FILE: Neos.Fusion/Classes/Package.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-68 ---
     1| <?php
     2| namespace Neos\Fusion;
     3| /*
     4|  * This file is part of the Neos.Fusion package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Cache\CacheManager;
    13| use Neos\Flow\Core\Booting\Sequence;
    14| use Neos\Flow\Core\Bootstrap;
    15| use Neos\Flow\Monitor\FileMonitor;
    16| use Neos\Flow\Package\Package as BasePackage;
    17| use Neos\Flow\Package\PackageManager;
    18| use Neos\Fusion\Core\Cache\FileMonitorListener;
    19| use Neos\Fusion\Core\Cache\ParserCacheFlusher;
    20| /**
    21|  * The Neos Fusion Package
    22|  */
    23| class Package extends BasePackage
    24| {
    25|     /**
    26|      * Invokes custom PHP code directly after the package manager has been initialized.
    27|      *
    28|      * @param Bootstrap $bootstrap The current bootstrap
    29|      * @return void
    30|      */
    31|     public function boot(Bootstrap $bootstrap)
    32|     {
    33|         $dispatcher = $bootstrap->getSignalSlotDispatcher();
    34|         $context = $bootstrap->getContext();
    35|         if (!$context->isProduction()) {
    36|             $dispatcher->connect(Sequence::class, 'afterInvokeStep', function ($step) use ($bootstrap, $dispatcher) {
    37|                 if ($step->getIdentifier() === 'neos.flow:systemfilemonitor') {
    38|                     $fusionFileMonitor = FileMonitor::createFileMonitorAtBoot('Fusion_Files', $bootstrap);
    39|                     /** @var PackageManager $packageManager */
    40|                     $packageManager = $bootstrap->getEarlyInstance(PackageManager::class);
    41|                     foreach ($packageManager->getFlowPackages() as $packageKey => $package) {
    42|                         if ($packageManager->isPackageFrozen($packageKey)) {
    43|                             continue;
    44|                         }
    45|                         $fusionPaths = [
    46|                             $package->getResourcesPath() . 'Private/Fusion',
    47|                             $package->getPackagePath() . 'NodeTypes'
    48|                         ];
    49|                         foreach ($fusionPaths as $fusionPath) {
    50|                             if (is_dir($fusionPath)) {
    51|                                 $fusionFileMonitor->monitorDirectory($fusionPath);
    52|                             }
    53|                         }
    54|                     }
    55|                     $fusionFileMonitor->detectChanges();
    56|                     $fusionFileMonitor->shutdownObject();
    57|                 }
    58|                 if ($step->getIdentifier() === 'neos.flow:cachemanagement') {
    59|                     $cacheManager = $bootstrap->getEarlyInstance(CacheManager::class);
    60|                     $listener = new FileMonitorListener($cacheManager);
    61|                     $dispatcher->connect(FileMonitor::class, 'filesHaveChanged', $listener, 'flushContentCacheOnFileChanges');
    62|                     $parsePartialCacheFlusher = new ParserCacheFlusher($cacheManager);
    63|                     $dispatcher->connect(FileMonitor::class, 'filesHaveChanged', $parsePartialCacheFlusher, 'flushPartialCacheOnFileChanges');
    64|                 }
    65|             });
    66|         }
    67|     }
    68| }


# ====================================================================
# FILE: Neos.Fusion/Migrations/Code/Version20220326120900.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-64 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Flow\Core\Migrations;
     4| /*
     5|  * This file is part of the Neos.Fusion package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| /**
    14|  * Expand Neos.Fusion-FusionObjects without namespace to fully qualified names
    15|  */
    16| class Version20220326120900 extends AbstractMigration
    17| {
    18|     /**
    19|      * The name of all prototypes from Neos.Fusion that could be used without
    20|      * namespace previously because of the `default` namespace
    21|      */
    22|     protected array $namesToMigrate = [
    23|         'Array',
    24|         'RawArray',
    25|         'Join',
    26|         'DataStructure',
    27|         'Template',
    28|         'Case',
    29|         'Matcher',
    30|         'Renderer',
    31|         'Value',
    32|         'Component',
    33|         'CanRender',
    34|         'DebugDump',
    35|         'Debug',
    36|         'Collection',
    37|         'RawCollection',
    38|         'Loop',
    39|         'Map',
    40|         'Reduce',
    41|         'Http.ResponseHead',
    42|         'Http.Message',
    43|         'Attributes',
    44|         'Tag',
    45|         'UriBuilder',
    46|         'Augmenter',
    47|         'ResourceUri',
    48|         'Link.Action',
    49|         'Link.Resource',
    50|         'Fragment',
    51|         'GlobalCacheIdentifiers'
    52|     ];
    53|     public function getIdentifier():string
    54|     {
    55|         return 'Neos.Fusion-20220326120900';
    56|     }
    57|     public function up():void
    58|     {
    59|         foreach ($this->namesToMigrate as $name) {
    60|             $this->searchAndReplaceRegex('/(?<=\\=)([\\s]*)(' . preg_quote($name) . ')(?=[$\\s\\{])/u', '$1Neos.Fusion:$2', ['fusion']);
    61|             $this->searchAndReplaceRegex('/(?<=prototype\\()(' . preg_quote($name) . ')(?=\\))/u', 'Neos.Fusion:$1', ['fusion']);
    62|         }
    63|     }
    64| }


# ====================================================================
# FILE: Neos.Media.Browser/Classes/Controller/AssetController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-879 ---
     1| <?php
     2| namespace Neos\Media\Browser\Controller;
     3| /*
     4|  * This file is part of the Neos.Media.Browser package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Doctrine\Common\Persistence\Proxy as DoctrineProxy;
    13| use Doctrine\ORM\EntityNotFoundException;
    14| use Neos\Error\Messages\Error;
    15| use Neos\Error\Messages\Message;
    16| use Neos\Flow\Annotations as Flow;
    17| use Neos\Flow\Mvc\Controller\ActionController;
    18| use Neos\Flow\Mvc\Exception\ForwardException;
    19| use Neos\Flow\Mvc\Exception\NoSuchArgumentException;
    20| use Neos\Flow\Mvc\Exception\StopActionException;
    21| use Neos\Flow\Mvc\Exception\UnsupportedRequestTypeException;
    22| use Neos\Flow\Mvc\View\JsonView;
    23| use Neos\Flow\Mvc\View\ViewInterface;
    24| use Neos\Flow\Package\PackageManager;
    25| use Neos\Flow\Persistence\Exception\IllegalObjectTypeException;
    26| use Neos\Flow\Property\TypeConverter\PersistentObjectConverter;
    27| use Neos\Flow\ResourceManagement\PersistentResource;
    28| use Neos\FluidAdaptor\View\TemplateView;
    29| use Neos\Media\Browser\Domain\ImageMapper;
    30| use Neos\Media\Browser\Domain\Session\BrowserState;
    31| use Neos\Media\Domain\Model\Asset;
    32| use Neos\Media\Domain\Model\AssetCollection;
    33| use Neos\Media\Domain\Model\AssetInterface;
    34| use Neos\Media\Domain\Model\AssetSource\AssetNotFoundExceptionInterface;
    35| use Neos\Media\Domain\Model\AssetSource\AssetProxyRepositoryInterface;
    36| use Neos\Media\Domain\Model\AssetSource\AssetSourceConnectionExceptionInterface;
    37| use Neos\Media\Domain\Model\AssetSource\AssetSourceInterface;
    38| use Neos\Media\Domain\Model\AssetSource\Neos\NeosAssetProxy;
    39| use Neos\Media\Domain\Model\AssetSource\SupportsCollectionsInterface;
    40| use Neos\Media\Domain\Model\AssetSource\SupportsSortingInterface;
    41| use Neos\Media\Domain\Model\AssetSource\SupportsTaggingInterface;
    42| use Neos\Media\Domain\Model\AssetVariantInterface;
    43| use Neos\Media\Domain\Model\Dto\AssetConstraints;
    44| use Neos\Media\Domain\Model\Tag;
    45| use Neos\Media\Domain\Model\VariantSupportInterface;
    46| use Neos\Media\Domain\Repository\AssetCollectionRepository;
    47| use Neos\Media\Domain\Repository\AssetRepository;
    48| use Neos\Media\Domain\Repository\TagRepository;
    49| use Neos\Media\Domain\Service\AssetService;
    50| use Neos\Media\Exception\AssetServiceException;
    51| use Neos\Media\TypeConverter\AssetInterfaceConverter;
    52| use Neos\Neos\Controller\BackendUserTranslationTrait;
    53| use Neos\Neos\Controller\CreateContentContextTrait;
    54| use Neos\Neos\Domain\Repository\DomainRepository;
    55| use Neos\Neos\Domain\Repository\SiteRepository;
    56| use Neos\Utility\Exception\FilesException;
    57| use Neos\Utility\Files;
    58| use Neos\Utility\MediaTypes;
    59| /**
    60|  * Controller for asset handling
    61|  *
    62|  * @Flow\Scope("singleton")
    63|  */
    64| class AssetController extends ActionController
    65| {
    66|     use CreateContentContextTrait;
    67|     use BackendUserTranslationTrait;
    68|     use AddFlashMessageTrait;
    69|     protected const TAG_GIVEN = 0;
    70|     protected const TAG_ALL = 1;
    71|     protected const TAG_NONE = 2;
    72|     protected const COLLECTION_GIVEN = 0;
    73|     protected const COLLECTION_ALL = 1;
    74|     /**
    75|      * @var array
    76|      */
    77|     protected $viewFormatToObjectNameMap = [
    78|         'html' => TemplateView::class,
    79|         'json' => JsonView::class
    80|     ];
    81|     /**
    82|      * @Flow\Inject
    83|      * @var SiteRepository
    84|      */
    85|     protected $siteRepository;
    86|     /**
    87|      * @Flow\Inject
    88|      * @var DomainRepository
    89|      */
    90|     protected $domainRepository;
    91|     /**
    92|      * @Flow\Inject
    93|      * @var AssetRepository
    94|      */
    95|     protected $assetRepository;
    96|     /**
    97|      * @Flow\Inject
    98|      * @var TagRepository
    99|      */
   100|     protected $tagRepository;
   101|     /**
   102|      * @Flow\Inject
   103|      * @var AssetCollectionRepository
   104|      */
   105|     protected $assetCollectionRepository;
   106|     /**
   107|      * @Flow\Inject
   108|      * @var PackageManager
   109|      */
   110|     protected $packageManager;
   111|     /**
   112|      * @Flow\Inject(lazy = false)
   113|      * @var BrowserState
   114|      */
   115|     protected $browserState;
   116|     /**
   117|      * @Flow\Inject
   118|      * @var AssetService
   119|      */
   120|     protected $assetService;
   121|     /**
   122|      * @Flow\Inject
   123|      * @var \Neos\Media\Domain\Service\AssetSourceService
   124|      */
   125|     protected $assetSourceService;
   126|     /**
   127|      * @var AssetSourceInterface[]
   128|      */
   129|     protected $assetSources = [];
   130|     /**
   131|      * @Flow\InjectConfiguration(path="imageProfiles", package="Neos.Media")
   132|      * @var array
   133|      */
   134|     protected $imageProfilesConfiguration;
   135|     /**
   136|      * @var AssetConstraints
   137|      */
   138|     private $assetConstraints;
   139|     /**
   140|      * @return void
   141|      */
   142|     public function initializeObject(): void
   143|     {
   144|         $domain = $this->domainRepository->findOneByActiveRequest();
   145|         if ($domain !== null && !$this->browserState->get('activeAssetCollection') && $this->browserState->get('automaticAssetCollectionSelection') !== true && $domain->getSite()->getAssetCollection() !== null) {
   146|             $this->browserState->set('activeAssetCollection', $domain->getSite()->getAssetCollection());
   147|             $this->browserState->set('automaticAssetCollectionSelection', true);
   148|         }
   149|         $this->assetSources = $this->assetSourceService->getAssetSources();
   150|     }
   151|     /**
   152|      * @throws NoSuchArgumentException
   153|      */
   154|     protected function initializeAction(): void
   155|     {
   156|         parent::initializeAction();
   157|         if ($this->request->hasArgument('constraints')) {
   158|             $this->assetConstraints = AssetConstraints::fromArray($this->request->getArgument('constraints'));
   159|         } else {
   160|             $this->assetConstraints = AssetConstraints::create();
   161|         }
   162|         $this->assetSources = $this->assetConstraints->applyToAssetSources($this->assetSources);
   163|     }
   164|     /**
   165|      * Set common variables on the view
   166|      *
   167|      * @param ViewInterface $view
   168|      * @return void
   169|      */
   170|     protected function initializeView(ViewInterface $view): void
   171|     {
   172|         $view->assignMultiple([
   173|             'view' => $this->browserState->get('view'),
   174|             'sortBy' => $this->browserState->get('sortBy'),
   175|             'sortDirection' => $this->browserState->get('sortDirection'),
   176|             'filter' => (string)$this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')),
   177|             'filterOptions' => $this->assetConstraints->getAllowedAssetTypeFilterOptions(),
   178|             'activeTag' => $this->browserState->get('activeTag'),
   179|             'activeAssetCollection' => $this->browserState->get('activeAssetCollection'),
   180|             'assetSources' => $this->assetSources,
   181|             'variantsTabFeatureEnabled' => $this->settings['features']['variantsTab']['enable'],
   182|             'constraints' => $this->assetConstraints,
   183|         ]);
   184|     }
   185|     /**
   186|      * List existing assets
   187|      *
   188|      * @param string $view
   189|      * @param string $sortBy
   190|      * @param string $sortDirection
   191|      * @param string $filter
   192|      * @param int $tagMode
   193|      * @param Tag $tag
   194|      * @param string $searchTerm
   195|      * @param int $collectionMode
   196|      * @param AssetCollection $assetCollection
   197|      * @param string $assetSourceIdentifier
   198|      * @return void
   199|      * @throws FilesException
   200|      */
   201|     public function indexAction($view = null, $sortBy = null, $sortDirection = null, $filter = null, $tagMode = self::TAG_GIVEN, Tag $tag = null, $searchTerm = null, $collectionMode = self::COLLECTION_GIVEN, AssetCollection $assetCollection = null, $assetSourceIdentifier = null): void
   202|     {
   203|         $assetSourceIdentifier = $this->assetConstraints->applyToAssetSourceIdentifiers($assetSourceIdentifier);
   204|         $this->applyActiveAssetSourceToBrowserState($assetSourceIdentifier);
   205|         $this->applyAssetCollectionOptionsToBrowserState($collectionMode, $assetCollection);
   206|         $activeAssetSource = $this->getAssetSourceFromBrowserState();
   207|         $assetProxyRepository = $activeAssetSource->getAssetProxyRepository();
   208|         $activeAssetCollection = $this->getActiveAssetCollectionFromBrowserState();
   209|         $this->applyViewOptionsToBrowserState($view, $sortBy, $sortDirection, $filter);
   210|         $this->applyTagToBrowserState($tagMode, $tag, $activeAssetCollection);
   211|         $this->applyAssetTypeFilterFromBrowserState($assetProxyRepository);
   212|         $this->applySortingFromBrowserState($assetProxyRepository);
   213|         $this->applyAssetCollectionFilterFromBrowserState($assetProxyRepository);
   214|         $assetCollections = [];
   215|         $tags = [];
   216|         $assetProxies = [];
   217|         $allCollectionsCount = 0;
   218|         $allCount = 0;
   219|         $searchResultCount = 0;
   220|         $untaggedCount = 0;
   221|         try {
   222|             foreach ($this->assetCollectionRepository->findAll()->toArray() as $retrievedAssetCollection) {
   223|                 assert($retrievedAssetCollection instanceof AssetCollection);
   224|                 $assetCollections[] = ['object' => $retrievedAssetCollection, 'count' => $this->assetRepository->countByAssetCollection($retrievedAssetCollection)];
   225|             }
   226|             foreach ($activeAssetCollection !== null ? $activeAssetCollection->getTags() : $this->tagRepository->findAll() as $retrievedTag) {
   227|                 assert($retrievedTag instanceof Tag);
   228|                 $tagCount = ($assetProxyRepository instanceof SupportsTaggingInterface ? $assetProxyRepository->countByTag($retrievedTag) : $this->assetRepository->countByTag($retrievedTag, $activeAssetCollection));
   229|                 $tags[] = ['object' => $retrievedTag, 'count' => $tagCount];
   230|             }
   231|             if (trim($searchTerm) !== '') {
   232|                 $assetProxies = $assetProxyRepository->findBySearchTerm($searchTerm);
   233|                 $this->view->assign('searchTerm', $searchTerm);
   234|             } elseif ($this->browserState->get('tagMode') === self::TAG_NONE) {
   235|                 $assetProxies = $assetProxyRepository->findUntagged();
   236|             } elseif ($this->browserState->get('activeTag') !== null) {
   237|                 $assetProxies = $assetProxyRepository->findByTag($this->browserState->get('activeTag'));
   238|             } else {
   239|                 $assetProxies = $assetProxyRepository->findAll();
   240|             }
   241|             $allCollectionsCount = $this->assetRepository->countAll();
   242|             $allCount = ($activeAssetCollection ? $this->assetRepository->countByAssetCollection($activeAssetCollection) : $allCollectionsCount);
   243|             $searchResultCount = isset($assetProxies) ? $assetProxies->count() : 0;
   244|             $untaggedCount = ($assetProxyRepository instanceof SupportsTaggingInterface ? $assetProxyRepository->countUntagged() : 0);
   245|         } catch (AssetSourceConnectionExceptionInterface $e) {
   246|             $this->view->assign('connectionError', $e);
   247|         }
   248|         $this->view->assignMultiple([
   249|             'tags' => $tags,
   250|             'allCollectionsCount' => $allCollectionsCount,
   251|             'allCount' => $allCount,
   252|             'searchResultCount' => $searchResultCount,
   253|             'untaggedCount' => $untaggedCount,
   254|             'tagMode' => $this->browserState->get('tagMode'),
   255|             'assetProxies' => $assetProxies,
   256|             'assetCollections' => $assetCollections,
   257|             'argumentNamespace' => $this->request->getArgumentNamespace(),
   258|             'maximumFileUploadSize' => $this->getMaximumFileUploadSize(),
   259|             'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($this->getMaximumFileUploadSize()),
   260|             'activeAssetSource' => $activeAssetSource,
   261|             'activeAssetSourceSupportsSorting' => $assetProxyRepository instanceof SupportsSortingInterface
   262|         ]);
   263|     }
   264|     /**
   265|      * New asset form
   266|      *
   267|      * @return void
   268|      */
   269|     public function newAction(): void
   270|     {
   271|         try {
   272|             $maximumFileUploadSize = $this->getMaximumFileUploadSize();
   273|         } catch (FilesException $e) {
   274|             $maximumFileUploadSize = null;
   275|         }
   276|         $this->view->assignMultiple([
   277|             'tags' => $this->tagRepository->findAll(),
   278|             'assetCollections' => $this->assetCollectionRepository->findAll(),
   279|             'maximumFileUploadSize' => $maximumFileUploadSize,
   280|             'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($maximumFileUploadSize)
   281|         ]);
   282|     }
   283|     /**
   284|      * @param Asset $asset
   285|      * @return void
   286|      */
   287|     public function replaceAssetResourceAction(Asset $asset): void
   288|     {
   289|         try {
   290|             $maximumFileUploadSize = $this->getMaximumFileUploadSize();
   291|         } catch (FilesException $e) {
   292|             $maximumFileUploadSize = null;
   293|         }
   294|         $this->view->assignMultiple([
   295|             'asset' => $asset,
   296|             'maximumFileUploadSize' => $maximumFileUploadSize,
   297|             'createAssetRedirectsOptionEnabled' => $this->packageManager->isPackageAvailable('Neos.RedirectHandler') && $this->settings['features']['createAssetRedirectsOption']['enable'],
   298|             'humanReadableMaximumFileUploadSize' => Files::bytesToSizeString($maximumFileUploadSize)
   299|         ]);
   300|     }
   301|     /**
   302|      * Show an asset
   303|      *
   304|      * @param string $assetSourceIdentifier
   305|      * @param string $assetProxyIdentifier
   306|      * @return void
   307|      * @throws StopActionException
   308|      * @throws UnsupportedRequestTypeException
   309|      */
   310|     public function showAction(string $assetSourceIdentifier, string $assetProxyIdentifier): void
   311|     {
   312|         if (!isset($this->assetSources[$assetSourceIdentifier])) {
   313|             throw new \RuntimeException('Given asset source is not configured.', 1509702178);
   314|         }
   315|         $assetProxyRepository = $this->assetSources[$assetSourceIdentifier]->getAssetProxyRepository();
   316|         try {
   317|             $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
   318|             $this->view->assignMultiple([
   319|                 'assetProxy' => $assetProxy,
   320|                 'assetCollections' => $this->assetCollectionRepository->findAll()
   321|             ]);
   322|         } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
   323|             $this->view->assign('connectionError', $e);
   324|         }
   325|     }
   326|     /**
   327|      * Edit an asset
   328|      *
   329|      * @param string $assetSourceIdentifier
   330|      * @param string $assetProxyIdentifier
   331|      * @return void
   332|      * @throws StopActionException
   333|      * @throws UnsupportedRequestTypeException
   334|      */
   335|     public function editAction(string $assetSourceIdentifier, string $assetProxyIdentifier): void
   336|     {
   337|         if (!isset($this->assetSources[$assetSourceIdentifier])) {
   338|             throw new \RuntimeException('Given asset source is not configured.', 1509632166);
   339|         }
   340|         $assetSource = $this->assetSources[$assetSourceIdentifier];
   341|         $assetProxyRepository = $assetSource->getAssetProxyRepository();
   342|         try {
   343|             $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
   344|             $tags = [];
   345|             $contentPreview = 'ContentDefault';
   346|             if ($assetProxyRepository instanceof SupportsTaggingInterface && $assetProxyRepository instanceof SupportsCollectionsInterface) {
   347|                 if ($assetProxy instanceof NeosAssetProxy) {
   348|                     /** @var Asset $asset */
   349|                     $asset = $assetProxy->getAsset();
   350|                     $assetCollections = $asset->getAssetCollections();
   351|                     $tags = $assetCollections->count() > 0 ? $this->tagRepository->findByAssetCollections($assetCollections->toArray()) : $this->tagRepository->findAll();
   352|                     switch ($asset->getFileExtension()) {
   353|                         case 'pdf':
   354|                             $contentPreview = 'ContentPdf';
   355|                             break;
   356|                     }
   357|                 }
   358|             }
   359|             $this->view->assignMultiple([
   360|                 'tags' => $tags,
   361|                 'assetProxy' => $assetProxy,
   362|                 'assetCollections' => $this->assetCollectionRepository->findAll(),
   363|                 'contentPreview' => $contentPreview,
   364|                 'assetSource' => $assetSource,
   365|                 'canShowVariants' => ($assetProxy instanceof NeosAssetProxy) && ($assetProxy->getAsset() instanceof VariantSupportInterface)
   366|             ]);
   367|         } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
   368|             $this->view->assign('connectionError', $e);
   369|         }
   370|     }
   371|     /**
   372|      * Display variants of an asset
   373|      *
   374|      * @param string $assetSourceIdentifier
   375|      * @param string $assetProxyIdentifier
   376|      * @param string $overviewAction
   377|      * @throws StopActionException
   378|      * @throws UnsupportedRequestTypeException
   379|      */
   380|     public function variantsAction(string $assetSourceIdentifier, string $assetProxyIdentifier, string $overviewAction): void
   381|     {
   382|         if (!isset($this->assetSources[$assetSourceIdentifier])) {
   383|             throw new \RuntimeException('Given asset source is not configured.', 1509632166);
   384|         }
   385|         $assetSource = $this->assetSources[$assetSourceIdentifier];
   386|         $assetProxyRepository = $assetSource->getAssetProxyRepository();
   387|         try {
   388|             $assetProxy = $assetProxyRepository->getAssetProxy($assetProxyIdentifier);
   389|             $asset = $this->persistenceManager->getObjectByIdentifier($assetProxy->getLocalAssetIdentifier(), Asset::class);
   390|             /** @var VariantSupportInterface $originalAsset */
   391|             $originalAsset = ($asset instanceof AssetVariantInterface ? $asset->getOriginalAsset() : $asset);
   392|             $variantInformation = array_map(static function (AssetVariantInterface $imageVariant) {
   393|                 return (new ImageMapper($imageVariant))->getMappingResult();
   394|             }, $originalAsset->getVariants());
   395|             $this->view->assignMultiple([
   396|                 'assetProxy' => $assetProxy,
   397|                 'asset' => $originalAsset,
   398|                 'assetSource' => $assetSource,
   399|                 'imageProfiles' => $this->imageProfilesConfiguration,
   400|                 'overviewAction' => $overviewAction,
   401|                 'originalInformation' => (new ImageMapper($asset))->getMappingResult(),
   402|                 'variantsInformation' => $variantInformation,
   403|                 'isSubRequest' => !$this->request->isMainRequest()
   404|             ]);
   405|         } catch (AssetNotFoundExceptionInterface | AssetSourceConnectionExceptionInterface $e) {
   406|             $this->view->assign('connectionError', $e);
   407|         }
   408|     }
   409|     /**
   410|      * @return void
   411|      * @throws NoSuchArgumentException
   412|      */
   413|     protected function initializeUpdateAction(): void
   414|     {
   415|         $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
   416|         $assetMappingConfiguration->allowProperties('title', 'resource', 'tags', 'assetCollections');
   417|         $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
   418|     }
   419|     /**
   420|      * Update an asset
   421|      *
   422|      * @param Asset $asset
   423|      * @return void
   424|      * @throws StopActionException
   425|      * @throws IllegalObjectTypeException
   426|      */
   427|     public function updateAction(Asset $asset): void
   428|     {
   429|         $this->assetRepository->update($asset);
   430|         $this->addFlashMessage('assetHasBeenUpdated', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
   431|         $this->redirectToIndex();
   432|     }
   433|     /**
   434|      * Initialization for createAction
   435|      *
   436|      * @return void
   437|      * @throws NoSuchArgumentException
   438|      */
   439|     protected function initializeCreateAction(): void
   440|     {
   441|         $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
   442|         $assetMappingConfiguration->allowProperties('title', 'resource', 'tags', 'assetCollections');
   443|         $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
   444|         $assetMappingConfiguration->setTypeConverterOption(AssetInterfaceConverter::class, AssetInterfaceConverter::CONFIGURATION_ONE_PER_RESOURCE, true);
   445|     }
   446|     /**
   447|      * Create a new asset
   448|      *
   449|      * @param Asset $asset
   450|      * @return void
   451|      * @throws StopActionException
   452|      * @throws IllegalObjectTypeException
   453|      */
   454|     public function createAction(Asset $asset): void
   455|     {
   456|         if ($this->persistenceManager->isNewObject($asset)) {
   457|             $this->assetRepository->add($asset);
   458|         }
   459|         $this->addFlashMessage('assetHasBeenAdded', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
   460|         $this->redirectToIndex();
   461|     }
   462|     /**
   463|      * Initialization for uploadAction
   464|      *
   465|      * @return void
   466|      * @throws NoSuchArgumentException
   467|      */
   468|     protected function initializeUploadAction(): void
   469|     {
   470|         $assetMappingConfiguration = $this->arguments->getArgument('asset')->getPropertyMappingConfiguration();
   471|         $assetMappingConfiguration->allowProperties('title', 'resource');
   472|         $assetMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
   473|         $assetMappingConfiguration->setTypeConverterOption(AssetInterfaceConverter::class, AssetInterfaceConverter::CONFIGURATION_ONE_PER_RESOURCE, true);
   474|     }
   475|     /**
   476|      * Upload a new asset. No redirection and no response body, for use by plupload (or similar).
   477|      *
   478|      * @param Asset $asset
   479|      * @return string
   480|      * @throws IllegalObjectTypeException
   481|      */
   482|     public function uploadAction(Asset $asset): string
   483|     {
   484|         if (($tag = $this->browserState->get('activeTag')) !== null) {
   485|             $asset->addTag($tag);
   486|         }
   487|         if ($this->persistenceManager->isNewObject($asset)) {
   488|             $this->assetRepository->add($asset);
   489|         } else {
   490|             $this->assetRepository->update($asset);
   491|         }
   492|         if (($assetCollection = $this->browserState->get('activeAssetCollection')) !== null && $assetCollection->addAsset($asset)) {
   493|             $this->assetCollectionRepository->update($assetCollection);
   494|         }
   495|         $this->addFlashMessage('assetHasBeenAdded', '', Message::SEVERITY_OK, [htmlspecialchars($asset->getLabel())]);
   496|         $this->response->setStatusCode(201);
   497|         return '';
   498|     }
   499|     /**
   500|      * Tags an asset with a tag.
   501|      *
   502|      * No redirection and no response body, no flash message, for use by plupload (or similar).
   503|      *
   504|      * @param Asset $asset
   505|      * @param Tag $tag
   506|      * @return void
   507|      * @throws IllegalObjectTypeException
   508|      */
   509|     public function tagAssetAction(Asset $asset, Tag $tag): void
   510|     {
   511|         $success = false;
   512|         if ($asset->addTag($tag)) {
   513|             $this->assetRepository->update($asset);
   514|             $success = true;
   515|         }
   516|         $this->view->assign('value', $success);
   517|     }
   518|     /**
   519|      * Adds an asset to an asset collection
   520|      *
   521|      * @param Asset $asset
   522|      * @param AssetCollection $assetCollection
   523|      * @return void
   524|      * @throws IllegalObjectTypeException
   525|      */
   526|     public function addAssetToCollectionAction(Asset $asset, AssetCollection $assetCollection): void
   527|     {
   528|         $success = false;
   529|         if ($assetCollection->addAsset($asset)) {
   530|             $this->assetCollectionRepository->update($assetCollection);
   531|             $success = true;
   532|         }
   533|         $this->view->assign('value', $success);
   534|     }
   535|     /**
   536|      * Delete an asset
   537|      *
   538|      * @param Asset $asset
   539|      * @return void
   540|      * @throws IllegalObjectTypeException
   541|      * @throws StopActionException
   542|      * @throws AssetServiceException
   543|      */
   544|     public function deleteAction(Asset $asset): void
   545|     {
   546|         $usageReferences = $this->assetService->getUsageReferences($asset);
   547|         if (count($usageReferences) > 0) {
   548|             $this->addFlashMessage('deleteRelatedNodes', '', Message::SEVERITY_WARNING, [], 1412422767);
   549|             $this->redirectToIndex();
   550|         }
   551|         $this->assetRepository->remove($asset);
   552|         $this->addFlashMessage('assetHasBeenDeleted', '', Message::SEVERITY_OK, [$asset->getLabel()], 1412375050);
   553|         $this->redirectToIndex();
   554|     }
   555|     /**
   556|      * Update the resource on an asset.
   557|      *
   558|      * @param AssetInterface $asset
   559|      * @param PersistentResource $resource
   560|      * @param array $options
   561|      * @return void
   562|      * @throws StopActionException
   563|      * @throws ForwardException
   564|      */
   565|     public function updateAssetResourceAction(AssetInterface $asset, PersistentResource $resource, array $options = []): void
   566|     {
   567|         $sourceMediaType = MediaTypes::parseMediaType($asset->getMediaType());
   568|         $replacementMediaType = MediaTypes::parseMediaType($resource->getMediaType());
   569|         if ($sourceMediaType['type'] !== $replacementMediaType['type'] && in_array($sourceMediaType['type'], ['image', 'audio', 'video'])) {
   570|             $this->addFlashMessage(
   571|                 'resourceCanOnlyBeReplacedBySimilarResource',
   572|                 '',
   573|                 Message::SEVERITY_WARNING,
   574|                 [$sourceMediaType['type'], $resource->getMediaType()],
   575|                 1462308179
   576|             );
   577|             $this->redirectToIndex();
   578|         }
   579|         try {
   580|             $this->assetService->replaceAssetResource($asset, $resource, $options);
   581|         } catch (\Exception $exception) {
   582|             $this->addFlashMessage('couldNotReplaceAsset', '', Message::SEVERITY_OK, [], 1463472606);
   583|             $this->forwardToReferringRequest();
   584|             return;
   585|         }
   586|         $assetLabel = (method_exists($asset, 'getLabel') ? $asset->getLabel() : $resource->getFilename());
   587|         $this->addFlashMessage('assetHasBeenReplaced', '', Message::SEVERITY_OK, [htmlspecialchars($assetLabel)]);
   588|         $this->redirectToIndex();
   589|     }
   590|     /**
   591|      * Get Related Nodes for an asset (proxy action)
   592|      *
   593|      * @param AssetInterface $asset
   594|      * @return void
   595|      * @throws ForwardException
   596|      */
   597|     public function relatedNodesAction(AssetInterface $asset): void
   598|     {
   599|         $this->forwardWithConstraints('relatedNodes', 'Usage', ['asset' => $asset]);
   600|     }
   601|     /**
   602|      * @param string $label
   603|      * @return void
   604|      * @Flow\Validate(argumentName="label", type="NotEmpty")
   605|      * @Flow\Validate(argumentName="label", type="Label")
   606|      * @throws ForwardException
   607|      */
   608|     public function createTagAction(string $label): void
   609|     {
   610|         $this->forwardWithConstraints('create', 'Tag', ['label' => $label]);
   611|     }
   612|     /**
   613|      * @param Tag $tag
   614|      * @return void
   615|      * @throws ForwardException
   616|      */
   617|     public function editTagAction(Tag $tag): void
   618|     {
   619|         $this->forwardWithConstraints('edit', 'Tag', ['tag' => $tag]);
   620|     }
   621|     /**
   622|      * @param Tag $tag
   623|      * @return void
   624|      * @throws ForwardException
   625|      */
   626|     public function updateTagAction(Tag $tag): void
   627|     {
   628|         $this->forwardWithConstraints('update', 'Tag', ['tag' => $tag]);
   629|     }
   630|     /**
   631|      * @param Tag $tag
   632|      * @return void
   633|      * @throws ForwardException
   634|      */
   635|     public function deleteTagAction(Tag $tag): void
   636|     {
   637|         $this->forwardWithConstraints('delete', 'Tag', ['tag' => $tag]);
   638|     }
   639|     /**
   640|      * @param string $title
   641|      * @return void
   642|      * @Flow\Validate(argumentName="title", type="NotEmpty")
   643|      * @Flow\Validate(argumentName="title", type="Label")
   644|      * @throws ForwardException
   645|      */
   646|     public function createAssetCollectionAction($title): void
   647|     {
   648|         $this->forwardWithConstraints('create', 'AssetCollection', ['title' => $title]);
   649|     }
   650|     /**
   651|      * @param AssetCollection $assetCollection
   652|      * @return void
   653|      * @throws ForwardException
   654|      */
   655|     public function editAssetCollectionAction(AssetCollection $assetCollection): void
   656|     {
   657|         $this->forwardWithConstraints('edit', 'AssetCollection', ['assetCollection' => $assetCollection]);
   658|     }
   659|     /**
   660|      * @param AssetCollection $assetCollection
   661|      * @return void
   662|      * @throws ForwardException
   663|      */
   664|     public function updateAssetCollectionAction(AssetCollection $assetCollection): void
   665|     {
   666|         $this->forwardWithConstraints('update', 'AssetCollection', ['assetCollection' => $assetCollection]);
   667|     }
   668|     /**
   669|      * @param AssetCollection $assetCollection
   670|      * @return void
   671|      * @throws ForwardException
   672|      */
   673|     public function deleteAssetCollectionAction(AssetCollection $assetCollection): void
   674|     {
   675|         $this->forwardWithConstraints('delete', 'AssetCollection', ['assetCollection' => $assetCollection]);
   676|     }
   677|     /**
   678|      * This custom errorAction adds FlashMessages for validation results to give more information in the
   679|      *
   680|      * @return string
   681|      */
   682|     protected function errorAction(): string
   683|     {
   684|         foreach ($this->arguments->getValidationResults()->getFlattenedErrors() as $propertyPath => $errors) {
   685|             foreach ($errors as $error) {
   686|                 $this->controllerContext->getFlashMessageContainer()->addMessage($error);
   687|             }
   688|         }
   689|         return parent::errorAction();
   690|     }
   691|     /**
   692|      * Individual error FlashMessage that hides which action fails in production.
   693|      *
   694|      * @return Message|bool The flash message or false if no flash message should be set
   695|      */
   696|     protected function getErrorFlashMessage()
   697|     {
   698|         if ($this->arguments->getValidationResults()->hasErrors()) {
   699|             return false;
   700|         }
   701|         $errorMessage = 'An error occurred';
   702|         if ($this->objectManager->getContext()->isDevelopment()) {
   703|             $errorMessage .= ' while trying to call %1$s->%2$s()';
   704|         }
   705|         return new Error($errorMessage, null, [get_class($this), $this->actionMethodName]);
   706|     }
   707|     /**
   708|      * Returns the lowest configured maximum upload file size
   709|      *
   710|      * @return int
   711|      * @throws FilesException
   712|      */
   713|     private function getMaximumFileUploadSize(): int
   714|     {
   715|         return min(Files::sizeStringToBytes(ini_get('post_max_size')), Files::sizeStringToBytes(ini_get('upload_max_filesize')));
   716|     }
   717|     /**
   718|      * @param string $view
   719|      * @param string $sortBy
   720|      * @param string $sortDirection
   721|      * @param string $filter
   722|      */
   723|     private function applyViewOptionsToBrowserState(string $view = null, string $sortBy = null, string $sortDirection = null, string $filter = null): void
   724|     {
   725|         if (!empty($view)) {
   726|             $this->browserState->set('view', $view);
   727|         }
   728|         if (!empty($sortBy)) {
   729|             $this->browserState->set('sortBy', $sortBy);
   730|         }
   731|         if (!empty($sortDirection)) {
   732|             $this->browserState->set('sortDirection', $sortDirection);
   733|         }
   734|         if (!empty($filter)) {
   735|             $this->browserState->set('filter', $filter);
   736|         }
   737|         foreach (['view', 'sortBy', 'sortDirection'] as $optionName) {
   738|             $this->view->assign($optionName, $this->browserState->get($optionName));
   739|         }
   740|         $this->view->assign('filter', (string)$this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')));
   741|     }
   742|     /**
   743|      * @param $assetSourceIdentifier
   744|      */
   745|     private function applyActiveAssetSourceToBrowserState($assetSourceIdentifier): void
   746|     {
   747|         if ($assetSourceIdentifier !== null && isset($this->assetSources[$assetSourceIdentifier])) {
   748|             $this->browserState->setActiveAssetSourceIdentifier($assetSourceIdentifier);
   749|         }
   750|     }
   751|     /**
   752|      * @param int $tagMode
   753|      * @param Tag $tag
   754|      * @param AssetCollection|null $activeAssetCollection
   755|      */
   756|     private function applyTagToBrowserState(int $tagMode = null, Tag $tag = null, AssetCollection $activeAssetCollection = null): void
   757|     {
   758|         if ($tagMode === self::TAG_GIVEN && $tag !== null) {
   759|             $this->browserState->set('activeTag', $tag);
   760|             $this->view->assign('activeTag', $tag);
   761|         } elseif ($tagMode === self::TAG_NONE || $tagMode === self::TAG_ALL) {
   762|             $this->browserState->set('activeTag', null);
   763|             $this->view->assign('activeTag', null);
   764|         }
   765|         $this->browserState->set('tagMode', $tagMode);
   766|         if ($activeAssetCollection !== null && $this->browserState->get('activeTag') && !$activeAssetCollection->getTags()->contains($this->browserState->get('activeTag'))) {
   767|             $this->browserState->set('activeTag', null);
   768|             $this->view->assign('activeTag', null);
   769|         }
   770|         if (!$this->browserState->get('activeTag') && $this->browserState->get('tagMode') === self::TAG_GIVEN) {
   771|             $this->browserState->set('tagMode', self::TAG_ALL);
   772|         }
   773|     }
   774|     /**
   775|      * @return AssetSourceInterface
   776|      */
   777|     private function getAssetSourceFromBrowserState(): AssetSourceInterface
   778|     {
   779|         $assetSourceIdentifier = $this->browserState->getActiveAssetSourceIdentifier();
   780|         if (!isset($this->assetSources[$assetSourceIdentifier])) {
   781|             $assetSourceIdentifiers = array_keys($this->assetSources);
   782|             $assetSourceIdentifier = reset($assetSourceIdentifiers);
   783|         }
   784|         return $this->assetSources[$assetSourceIdentifier];
   785|     }
   786|     /**
   787|      * @param int $collectionMode
   788|      * @param AssetCollection $assetCollection
   789|      */
   790|     private function applyAssetCollectionOptionsToBrowserState(int $collectionMode = null, AssetCollection $assetCollection = null): void
   791|     {
   792|         if ($collectionMode === self::COLLECTION_GIVEN && $assetCollection !== null) {
   793|             $this->browserState->set('activeAssetCollection', $assetCollection);
   794|             $this->view->assign('activeAssetCollection', $assetCollection);
   795|         } elseif ($collectionMode === self::COLLECTION_ALL) {
   796|             $this->browserState->set('activeAssetCollection', null);
   797|             $this->view->assign('activeAssetCollection', null);
   798|         }
   799|         $this->browserState->set('collectionMode', $collectionMode);
   800|     }
   801|     /**
   802|      * @return AssetCollection|null
   803|      */
   804|     private function getActiveAssetCollectionFromBrowserState(): ?AssetCollection
   805|     {
   806|         try {
   807|             /** @var AssetCollection $activeAssetCollection */
   808|             $activeAssetCollection = $this->browserState->get('activeAssetCollection');
   809|             if ($activeAssetCollection instanceof DoctrineProxy) {
   810|                 $activeAssetCollection->__load();
   811|             }
   812|         } catch (EntityNotFoundException $exception) {
   813|             $this->browserState->set('activeAssetCollection', null);
   814|             $activeAssetCollection = null;
   815|         }
   816|         return $activeAssetCollection;
   817|     }
   818|     /**
   819|      * @param AssetProxyRepositoryInterface $assetProxyRepository
   820|      */
   821|     private function applySortingFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
   822|     {
   823|         if ($assetProxyRepository instanceof SupportsSortingInterface) {
   824|             switch ($this->browserState->get('sortBy')) {
   825|                 case 'Name':
   826|                     $assetProxyRepository->orderBy(['resource.filename' => $this->browserState->get('sortDirection')]);
   827|                     break;
   828|                 case 'Modified':
   829|                 default:
   830|                     $assetProxyRepository->orderBy(['lastModified' => $this->browserState->get('sortDirection')]);
   831|                     break;
   832|             }
   833|         }
   834|     }
   835|     /**
   836|      * @param AssetProxyRepositoryInterface $assetProxyRepository
   837|      */
   838|     private function applyAssetTypeFilterFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
   839|     {
   840|         $assetProxyRepository->filterByType($this->assetConstraints->applyToAssetTypeFilter($this->browserState->get('filter')));
   841|     }
   842|     /**
   843|      * @param AssetProxyRepositoryInterface $assetProxyRepository
   844|      */
   845|     private function applyAssetCollectionFilterFromBrowserState(AssetProxyRepositoryInterface $assetProxyRepository): void
   846|     {
   847|         if ($assetProxyRepository instanceof SupportsCollectionsInterface) {
   848|             $assetProxyRepository->filterByCollection($this->getActiveAssetCollectionFromBrowserState());
   849|         }
   850|     }
   851|     /**
   852|      * Custom redirect method that adds "constraints" arguments from the current request
   853|      *
   854|      * @param array $arguments
   855|      * @throws StopActionException | NoSuchArgumentException
   856|      */
   857|     private function redirectToIndex(array $arguments = []): void
   858|     {
   859|         if (!isset($arguments['constraints']) && $this->request->hasArgument('constraints')) {
   860|             $arguments['constraints'] = $this->request->getArgument('constraints');
   861|         }
   862|         $this->redirect('index', null, null, $arguments);
   863|     }
   864|     /**
   865|      * Custom forward method that adds "constraints" arguments from the current request
   866|      *
   867|      * @param string $actionName
   868|      * @param string $controllerName
   869|      * @param array $arguments
   870|      * @throws ForwardException | NoSuchArgumentException
   871|      */
   872|     private function forwardWithConstraints(string $actionName, string $controllerName, array $arguments = []): void
   873|     {
   874|         if (!isset($arguments['constraints']) && $this->request->hasArgument('constraints')) {
   875|             $arguments['constraints'] = $this->request->getArgument('constraints');
   876|         }
   877|         $this->forward($actionName, $controllerName, null, $arguments);
   878|     }
   879| }


# ====================================================================
# FILE: Neos.Media/Classes/Domain/Model/AssetSource/Neos/NeosAssetProxyRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-254 ---
     1| <?php
     2| namespace Neos\Media\Domain\Model\AssetSource\Neos;
     3| /*
     4|  * This file is part of the Neos.Media package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|   *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Doctrine\ORM\EntityManagerInterface;
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\ObjectManagement\ObjectManagerInterface;
    15| use Neos\Flow\Persistence\Exception\InvalidQueryException;
    16| use Neos\Flow\Persistence\QueryInterface;
    17| use Neos\Media\Domain\Model\AssetCollection;
    18| use Neos\Media\Domain\Model\AssetInterface;
    19| use Neos\Media\Domain\Model\AssetSource\AssetNotFoundExceptionInterface;
    20| use Neos\Media\Domain\Model\AssetSource\AssetProxy\AssetProxyInterface;
    21| use Neos\Media\Domain\Model\AssetSource\AssetProxyQueryResultInterface;
    22| use Neos\Media\Domain\Model\AssetSource\AssetProxyRepositoryInterface;
    23| use Neos\Media\Domain\Model\AssetSource\AssetTypeFilter;
    24| use Neos\Media\Domain\Model\AssetSource\SupportsCollectionsInterface;
    25| use Neos\Media\Domain\Model\AssetSource\SupportsSortingInterface;
    26| use Neos\Media\Domain\Model\AssetSource\SupportsTaggingInterface;
    27| use Neos\Media\Domain\Model\Tag;
    28| use Neos\Media\Domain\Repository\AssetRepository;
    29| use Neos\Media\Domain\Repository\AudioRepository;
    30| use Neos\Media\Domain\Repository\DocumentRepository;
    31| use Neos\Media\Domain\Repository\ImageRepository;
    32| use Neos\Media\Domain\Repository\VideoRepository;
    33| final class NeosAssetProxyRepository implements AssetProxyRepositoryInterface, SupportsSortingInterface, SupportsCollectionsInterface, SupportsTaggingInterface
    34| {
    35|     /**
    36|      * @Flow\Inject
    37|      * @var ObjectManagerInterface
    38|      */
    39|     protected $objectManager;
    40|     /**
    41|      * @Flow\Inject
    42|      * @var EntityManagerInterface
    43|      */
    44|     protected $entityManager;
    45|     /**
    46|      * @var NeosAssetSource
    47|      */
    48|     private $assetSource;
    49|     /**
    50|      * @var AssetRepository
    51|      */
    52|     private $assetRepository;
    53|     /**
    54|      * @var string
    55|      */
    56|     private $assetTypeFilter = 'All';
    57|     /**
    58|      * @var AssetCollection
    59|      */
    60|     private $activeAssetCollection;
    61|     /**
    62|      * @var array
    63|      */
    64|     private $assetRepositoryClassNames = [
    65|         'All' => AssetRepository::class,
    66|         'Image' => ImageRepository::class,
    67|         'Document' => DocumentRepository::class,
    68|         'Video' => VideoRepository::class,
    69|         'Audio' => AudioRepository::class
    70|     ];
    71|     /**
    72|      * @param NeosAssetSource $assetSource
    73|      */
    74|     public function __construct(NeosAssetSource $assetSource)
    75|     {
    76|         $this->assetSource = $assetSource;
    77|     }
    78|     /**
    79|      * @return void
    80|      */
    81|     public function initializeObject(): void
    82|     {
    83|         $this->assetRepository = $this->objectManager->get($this->assetRepositoryClassNames[$this->assetTypeFilter]);
    84|     }
    85|     /**
    86|      * Sets the property names to order results by. Expected like this:
    87|      * array(
    88|      *  'foo' => \Neos\Flow\Persistence\QueryInterface::ORDER_ASCENDING,
    89|      *  'bar' => \Neos\Flow\Persistence\QueryInterface::ORDER_DESCENDING
    90|      * )
    91|      *
    92|      * @param array $orderings The property names to order by by default
    93|      * @return void
    94|      * @api
    95|      */
    96|     public function orderBy(array $orderings):void
    97|     {
    98|         $this->assetRepository->setDefaultOrderings($orderings);
    99|     }
   100|     /**
   101|      * @param AssetTypeFilter $assetType
   102|      */
   103|     public function filterByType(AssetTypeFilter $assetType = null): void
   104|     {
   105|         $this->assetTypeFilter = (string)$assetType ?: 'All';
   106|         $this->initializeObject();
   107|     }
   108|     /**
   109|      * NOTE: This needs to be refactored to use an asset collection identifier instead of Media's domain model before
   110|      *       it can become a public API for other asset sources.
   111|      *
   112|      * @param AssetCollection $assetCollection
   113|      */
   114|     public function filterByCollection(AssetCollection $assetCollection = null): void
   115|     {
   116|         $this->activeAssetCollection = $assetCollection;
   117|     }
   118|     /**
   119|      * @param string $identifier
   120|      * @return AssetProxyInterface
   121|      * @throws AssetNotFoundExceptionInterface
   122|      */
   123|     public function getAssetProxy(string $identifier): AssetProxyInterface
   124|     {
   125|         $asset = $this->assetRepository->findByIdentifier($identifier);
   126|         if ($asset === null || !$asset instanceof AssetInterface) {
   127|             throw new NeosAssetNotFoundException('The specified asset was not found.', 1509632861);
   128|         }
   129|         return new NeosAssetProxy($asset, $this->assetSource);
   130|     }
   131|     /**
   132|      * @return AssetProxyQueryResultInterface
   133|      */
   134|     public function findAll(): AssetProxyQueryResultInterface
   135|     {
   136|         $queryResult = $this->assetRepository->findAll($this->activeAssetCollection);
   137|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
   138|         $query = $this->filterOutImageVariants($query);
   139|         return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
   140|     }
   141|     /**
   142|      * @param string $searchTerm
   143|      * @return AssetProxyQueryResultInterface
   144|      */
   145|     public function findBySearchTerm(string $searchTerm): AssetProxyQueryResultInterface
   146|     {
   147|         $queryResult = $this->assetRepository->findBySearchTermOrTags($searchTerm, [], $this->activeAssetCollection);
   148|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
   149|         $query = $this->filterOutImageVariants($query);
   150|         return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
   151|     }
   152|     /**
   153|      * @param Tag $tag
   154|      * @return AssetProxyQueryResultInterface
   155|      */
   156|     public function findByTag(Tag $tag): AssetProxyQueryResultInterface
   157|     {
   158|         $queryResult = $this->assetRepository->findByTag($tag, $this->activeAssetCollection);
   159|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
   160|         $query = $this->filterOutImageVariants($query);
   161|         return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
   162|     }
   163|     /**
   164|      * @return AssetProxyQueryResultInterface
   165|      */
   166|     public function findUntagged(): AssetProxyQueryResultInterface
   167|     {
   168|         $queryResult = $this->assetRepository->findUntagged($this->activeAssetCollection);
   169|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
   170|         $query = $this->filterOutImageVariants($query);
   171|         return new NeosAssetProxyQueryResult($query->execute(), $this->assetSource);
   172|     }
   173|     /**
   174|      * @return int
   175|      */
   176|     public function countAll(): int
   177|     {
   178|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($this->assetRepository->createQuery());
   179|         $query = $this->filterOutAssetsFromOtherAssetCollections($query);
   180|         $query = $this->filterOutImageVariants($query);
   181|         return $query->count();
   182|     }
   183|     /**
   184|      * @return int
   185|      */
   186|     public function countUntagged(): int
   187|     {
   188|         $query = $this->assetRepository->createQuery();
   189|         try {
   190|             $query->matching($query->isEmpty('tags'));
   191|         } catch (InvalidQueryException $e) {
   192|         }
   193|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($query);
   194|         $query = $this->filterOutAssetsFromOtherAssetCollections($query);
   195|         $query = $this->filterOutImageVariants($query);
   196|         return $query->count();
   197|     }
   198|     /**
   199|      * @return int
   200|      */
   201|     public function countByTag(Tag $tag): int
   202|     {
   203|         $queryResult = $this->assetRepository->findByTag($tag, $this->activeAssetCollection);
   204|         $query = $this->filterOutImportedAssetsFromOtherAssetSources($queryResult->getQuery());
   205|         $query = $this->filterOutImageVariants($query);
   206|         return $query->count();
   207|     }
   208|     /**
   209|      * @param QueryInterface $query
   210|      * @return QueryInterface
   211|      */
   212|     private function filterOutImportedAssetsFromOtherAssetSources(QueryInterface $query): QueryInterface
   213|     {
   214|         $constraint = $query->getConstraint();
   215|         $query->matching(
   216|             $query->logicalAnd([
   217|                 $constraint,
   218|                 $query->equals('assetSourceIdentifier', 'neos')
   219|             ])
   220|         );
   221|         return $query;
   222|     }
   223|     /**
   224|      * @param QueryInterface $query
   225|      * @return QueryInterface
   226|      */
   227|     private function filterOutImageVariants(QueryInterface $query): QueryInterface
   228|     {
   229|         $queryBuilder = $query->getQueryBuilder();
   230|         $queryBuilder->andWhere('e NOT INSTANCE OF Neos\Media\Domain\Model\ImageVariant');
   231|         return $query;
   232|     }
   233|     /**
   234|      * @param QueryInterface $query
   235|      * @return QueryInterface
   236|      */
   237|     private function filterOutAssetsFromOtherAssetCollections(QueryInterface $query): QueryInterface
   238|     {
   239|         if ($this->activeAssetCollection === null) {
   240|             return $query;
   241|         }
   242|         $constraints = $query->getConstraint();
   243|         try {
   244|             $query->matching(
   245|                 $query->logicalAnd([
   246|                     $constraints,
   247|                     $query->contains('assetCollections', $this->activeAssetCollection)
   248|                 ])
   249|             );
   250|         } catch (InvalidQueryException $e) {
   251|         }
   252|         return $query;
   253|     }
   254| }


# ====================================================================
# FILE: Neos.Media/Classes/Domain/Model/AssetSource/SupportsTaggingInterface.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-36 ---
     1| <?php
     2| namespace Neos\Media\Domain\Model\AssetSource;
     3| /*
     4|  * This file is part of the Neos.Media package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|   *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Media\Domain\Model\Tag;
    13| interface SupportsTaggingInterface
    14| {
    15|     /**
    16|      * NOTE: This needs to be refactored to use a tag identifier instead of Media's domain model before
    17|      *       it can become a public API for other asset sources.
    18|      *
    19|      * @param Tag $tag
    20|      * @return AssetProxyQueryResultInterface
    21|      */
    22|     public function findByTag(Tag $tag): AssetProxyQueryResultInterface;
    23|     /**
    24|      * @return AssetProxyQueryResultInterface
    25|      */
    26|     public function findUntagged(): AssetProxyQueryResultInterface;
    27|     /**
    28|      * @return int
    29|      */
    30|     public function countUntagged(): int;
    31|     /**
    32|      * @param Tag $tag
    33|      * @return int
    34|      */
    35|     public function countByTag(Tag $tag): int;
    36| }


# ====================================================================
# FILE: Neos.Media/Documentation/conf.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| import os
     2| import sys
     3| from sphinx.highlighting import lexers
     4| from pygments.lexers.web import PhpLexer
     5| project = 'Neos Media'
     6| copyright = '2006 and onwards by the authors'
     7| author = 'Neos Team and Contributors'
     8| version = 'dev-master'
     9| release = 'dev-master'
    10| extensions = [
    11|     'sphinx_rtd_theme',
    12|     'sphinx.ext.intersphinx',
    13|     'sphinx.ext.todo',
    14|     'sphinx.ext.ifconfig'
    15| ]
    16| templates_path = ['_templates']
    17| exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
    18| highlight_language='php'
    19| html_theme = 'sphinx_rtd_theme'
    20| html_static_path = ['_static']
    21| html_theme_options = {
    22|   'prev_next_buttons_location': 'both',
    23|   'style_external_links': True
    24| }
    25| intersphinx_mapping = {
    26|     'neos': ('https://neos.readthedocs.io/en/stable', None),
    27|     'media': ('https://neos-media.readthedocs.io/en/stable', None),
    28|     'flow': ('https://flowframework.readthedocs.io/en/stable', None),
    29| }
    30| lexers['php'] = PhpLexer(startinline=True)
    31| lexers['php-annotations'] = PhpLexer(startinline=True)


# ====================================================================
# FILE: Neos.Neos/Classes/Aspects/NodeTypeConfigurationEnrichmentAspect.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-324 ---
     1| <?php
     2| namespace Neos\Neos\Aspects;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\Aop\JoinPointInterface;
    14| use Neos\Flow\ResourceManagement\ResourceManager;
    15| use Neos\Utility\Arrays;
    16| use Neos\ContentRepository\Domain\Model\NodeType;
    17| /**
    18|  * @Flow\Scope("singleton")
    19|  * @Flow\Aspect
    20|  */
    21| class NodeTypeConfigurationEnrichmentAspect
    22| {
    23|     /**
    24|      * @var array
    25|      * @Flow\InjectConfiguration(package="Neos.Neos", path="userInterface.inspector.dataTypes")
    26|      */
    27|     protected $dataTypesDefaultConfiguration;
    28|     /**
    29|      * @var array
    30|      * @Flow\InjectConfiguration(package="Neos.Neos", path="userInterface.inspector.editors")
    31|      */
    32|     protected $editorDefaultConfiguration;
    33|     /**
    34|      * @Flow\Inject
    35|      * @var \Neos\Flow\I18n\Translator
    36|      */
    37|     protected $translator;
    38|     /**
    39|      * @Flow\Inject
    40|      * @var ResourceManager
    41|      */
    42|     protected $resourceManager;
    43|     /**
    44|      * @Flow\Around("method(Neos\ContentRepository\Domain\Model\NodeType->__construct())")
    45|      * @param JoinPointInterface $joinPoint
    46|      * @return void
    47|      */
    48|     public function enrichNodeTypeLabelsConfiguration(JoinPointInterface $joinPoint): void
    49|     {
    50|         $declaredSuperTypes = $joinPoint->getMethodArgument('declaredSuperTypes');
    51|         $configuration = $joinPoint->getMethodArgument('configuration');
    52|         $nodeTypeName = $joinPoint->getMethodArgument('name');
    53|         $this->addLabelsToNodeTypeConfiguration($nodeTypeName, $configuration, $declaredSuperTypes);
    54|         $joinPoint->setMethodArgument('configuration', $configuration);
    55|         $joinPoint->getAdviceChain()->proceed($joinPoint);
    56|     }
    57|     /**
    58|      * @param string $nodeTypeName
    59|      * @param array $configuration
    60|      * @param array $declaredSuperTypes
    61|      * @return void
    62|      */
    63|     protected function addLabelsToNodeTypeConfiguration($nodeTypeName, array &$configuration, array $declaredSuperTypes)
    64|     {
    65|         if (isset($configuration['ui'])) {
    66|             $this->setGlobalUiElementLabels($nodeTypeName, $configuration);
    67|         }
    68|         if (isset($configuration['properties'])) {
    69|             $this->setPropertyLabels($nodeTypeName, $configuration, $declaredSuperTypes);
    70|         }
    71|     }
    72|     /**
    73|      * @param string $nodeTypeLabelIdPrefix
    74|      * @param array $configuration
    75|      * @param array $declaredSuperTypes
    76|      * @return void
    77|      */
    78|     protected function setPropertyLabels($nodeTypeName, array &$configuration, array $declaredSuperTypes)
    79|     {
    80|         $nodeTypeLabelIdPrefix = $this->generateNodeTypeLabelIdPrefix($nodeTypeName);
    81|         foreach ($configuration['properties'] as $propertyName => &$propertyConfiguration) {
    82|             if (!isset($propertyConfiguration['ui'])) {
    83|                 continue;
    84|             }
    85|             if ($this->shouldFetchTranslation($propertyConfiguration['ui'])) {
    86|                 $propertyConfiguration['ui']['label'] = $this->getPropertyLabelTranslationId($nodeTypeLabelIdPrefix, $propertyName);
    87|             }
    88|             $editorName = $propertyConfiguration['ui']['inspector']['editor']
    89|                 ?? array_reduce($declaredSuperTypes, function ($editorName, ?NodeType $superType) use ($propertyName) {
    90|                     if ($editorName !== null || $superType === null) {
    91|                         return $editorName;
    92|                     }
    93|                     $superTypeConfiguration = $superType->getLocalConfiguration();
    94|                     return $superTypeConfiguration['properties'][$propertyName]['ui']['inspector']['editor'] ?? null;
    95|                 }, null);
    96|             $hasEditor = !is_null($editorName);
    97|             $hasEditorOptions = isset($propertyConfiguration['ui']['inspector']['editorOptions']);
    98|             if ($hasEditor && $hasEditorOptions) {
    99|                 $translationIdGenerator = function ($path) use ($nodeTypeLabelIdPrefix, $propertyName) {
   100|                     return $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, $path);
   101|                 };
   102|                 $this->applyEditorLabels($nodeTypeLabelIdPrefix, $propertyName, $editorName, $propertyConfiguration['ui']['inspector']['editorOptions'], $translationIdGenerator);
   103|             }
   104|             if (isset($propertyConfiguration['ui']['inline']['editorOptions']) && $this->shouldFetchTranslation($propertyConfiguration['ui']['inline']['editorOptions'], 'placeholder')) {
   105|                 $propertyConfiguration['ui']['inline']['editorOptions']['placeholder'] = $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, 'ui.inline.editorOptions.placeholder');
   106|             }
   107|             if (isset($propertyConfiguration['ui']['help']['message']) && $this->shouldFetchTranslation($propertyConfiguration['ui']['help'], 'message')) {
   108|                 $propertyConfiguration['ui']['help']['message'] = $this->getPropertyConfigurationTranslationId($nodeTypeLabelIdPrefix, $propertyName, 'ui.help.message');
   109|             }
   110|         }
   111|     }
   112|     /**
   113|      * Resolve help message thumbnail url
   114|      *
   115|      * @param string $nodeTypeName
   116|      * @param string $configurationThumbnail
   117|      * @return string $thumbnailUrl
   118|      */
   119|     protected function resolveHelpMessageThumbnail($nodeTypeName, $configurationThumbnail)
   120|     {
   121|         if ($nodeTypeName !== null) {
   122|             $thumbnailUrl = '';
   123|             if (isset($configurationThumbnail)) {
   124|                 $thumbnailUrl = $configurationThumbnail;
   125|                 if (strpos($thumbnailUrl, 'resource://') === 0) {
   126|                     $thumbnailUrl = $this->resourceManager->getPublicPackageResourceUriByPath($thumbnailUrl);
   127|                 }
   128|             } else {
   129|                 $splitPrefix = $this->splitIdentifier($nodeTypeName);
   130|                 $relativePathAndFilename = 'NodeTypes/Thumbnails/' . $splitPrefix['id'] . '.png';
   131|                 $resourcePath = 'resource://' . $splitPrefix['packageKey'] . '/Public/' . $relativePathAndFilename;
   132|                 if (file_exists($resourcePath)) {
   133|                     $thumbnailUrl = $this->resourceManager->getPublicPackageResourceUriByPath($resourcePath);
   134|                 }
   135|             }
   136|             return $thumbnailUrl;
   137|         }
   138|     }
   139|     /**
   140|      * @param string $nodeTypeLabelIdPrefix
   141|      * @param string $propertyName
   142|      * @param string $editorName
   143|      * @param array $editorOptions
   144|      * @param callable $translationIdGenerator
   145|      * @return void
   146|      */
   147|     protected function applyEditorLabels($nodeTypeLabelIdPrefix, $propertyName, $editorName, array &$editorOptions, $translationIdGenerator)
   148|     {
   149|         switch ($editorName) {
   150|             case 'Neos.Neos/Inspector/Editors/SelectBoxEditor':
   151|                 if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
   152|                     $editorOptions['placeholder'] = $translationIdGenerator('selectBoxEditor.placeholder');
   153|                 }
   154|                 if (!isset($editorOptions['values']) || !is_array($editorOptions['values'])) {
   155|                     break;
   156|                 }
   157|                 foreach ($editorOptions['values'] as $value => &$optionConfiguration) {
   158|                     if ($optionConfiguration === null) {
   159|                         continue;
   160|                     }
   161|                     if ($this->shouldFetchTranslation($optionConfiguration)) {
   162|                         $optionConfiguration['label'] = $translationIdGenerator('selectBoxEditor.values.' . $value);
   163|                     }
   164|                 }
   165|                 break;
   166|             case 'Neos.Neos/Inspector/Editors/CodeEditor':
   167|                 if ($this->shouldFetchTranslation($editorOptions, 'buttonLabel')) {
   168|                     $editorOptions['buttonLabel'] = $translationIdGenerator('codeEditor.buttonLabel');
   169|                 }
   170|                 break;
   171|             case 'Neos.Neos/Inspector/Editors/TextFieldEditor':
   172|                 if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
   173|                     $editorOptions['placeholder'] = $translationIdGenerator('textFieldEditor.placeholder');
   174|                 }
   175|                 break;
   176|             case 'Neos.Neos/Inspector/Editors/TextAreaEditor':
   177|                 if (isset($editorOptions) && $this->shouldFetchTranslation($editorOptions, 'placeholder')) {
   178|                     $editorOptions['placeholder'] = $translationIdGenerator('textAreaEditor.placeholder');
   179|                 }
   180|                 break;
   181|         }
   182|     }
   183|     /**
   184|      * Sets labels for global NodeType elements like tabs and groups and the general label.
   185|      *
   186|      * @param string $nodeTypeLabelIdPrefix
   187|      * @param array $configuration
   188|      * @return void
   189|      */
   190|     protected function setGlobalUiElementLabels($nodeTypeName, array &$configuration)
   191|     {
   192|         $nodeTypeLabelIdPrefix = $this->generateNodeTypeLabelIdPrefix($nodeTypeName);
   193|         if ($this->shouldFetchTranslation($configuration['ui'])) {
   194|             $configuration['ui']['label'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'ui', 'label');
   195|         }
   196|         if (isset($configuration['ui']['help']['message']) && $this->shouldFetchTranslation($configuration['ui']['help'], 'message')) {
   197|             $configuration['ui']['help']['message'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'ui', 'help.message');
   198|         }
   199|         if (isset($configuration['ui']['help'])) {
   200|             $configurationThumbnail = isset($configuration['ui']['help']['thumbnail']) ? $configuration['ui']['help']['thumbnail'] : null;
   201|             $thumbnailUrl = $this->resolveHelpMessageThumbnail($nodeTypeName, $configurationThumbnail);
   202|             if ($thumbnailUrl !== '') {
   203|                 $configuration['ui']['help']['thumbnail'] = $thumbnailUrl;
   204|             }
   205|         }
   206|         $inspectorConfiguration = Arrays::getValueByPath($configuration, 'ui.inspector');
   207|         if (is_array($inspectorConfiguration)) {
   208|             foreach ($inspectorConfiguration as $elementTypeName => $elementTypeItems) {
   209|                 foreach ($elementTypeItems as $elementName => $elementConfiguration) {
   210|                     if (!is_array($elementConfiguration) || !$this->shouldFetchTranslation($elementConfiguration)) {
   211|                         continue;
   212|                     }
   213|                     $translationLabelId = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, $elementTypeName, $elementName);
   214|                     $configuration['ui']['inspector'][$elementTypeName][$elementName]['label'] = $translationLabelId;
   215|                 }
   216|             }
   217|         }
   218|         $creationDialogConfiguration = Arrays::getValueByPath($configuration, 'ui.creationDialog.elements');
   219|         if (is_array($creationDialogConfiguration)) {
   220|             $creationDialogConfiguration = &$configuration['ui']['creationDialog']['elements'];
   221|             foreach ($creationDialogConfiguration as $elementName => &$elementConfiguration) {
   222|                 if (isset($elementConfiguration['ui']['editor']) && isset($elementConfiguration['ui']['editorOptions'])) {
   223|                     $translationIdGenerator = function ($path) use ($nodeTypeLabelIdPrefix, $elementName) {
   224|                         return $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'creationDialog', $elementName . '.' . $path);
   225|                     };
   226|                     $this->applyEditorLabels($nodeTypeLabelIdPrefix, $elementName, $elementConfiguration['ui']['editor'], $elementConfiguration['ui']['editorOptions'], $translationIdGenerator);
   227|                 }
   228|                 if (!is_array($elementConfiguration) || !$this->shouldFetchTranslation($elementConfiguration['ui'])) {
   229|                     continue;
   230|                 }
   231|                 $elementConfiguration['ui']['label'] = $this->getInspectorElementTranslationId($nodeTypeLabelIdPrefix, 'creationDialog', $elementName);
   232|             }
   233|         }
   234|     }
   235|     /**
   236|      * Should a label be generated for the given field or is there something configured?
   237|      *
   238|      * @param array $parentConfiguration
   239|      * @param string $fieldName Name of the possibly existing subfield
   240|      * @return boolean
   241|      */
   242|     protected function shouldFetchTranslation(array $parentConfiguration, $fieldName = 'label')
   243|     {
   244|         $fieldValue = array_key_exists($fieldName, $parentConfiguration) ? $parentConfiguration[$fieldName] : '';
   245|         return (trim($fieldValue) === 'i18n');
   246|     }
   247|     /**
   248|      * Generates a generic inspector element label with the given $nodeTypeSpecificPrefix.
   249|      *
   250|      * @param string $nodeTypeSpecificPrefix
   251|      * @param string $elementType
   252|      * @param string $elementName
   253|      * @return string
   254|      */
   255|     protected function getInspectorElementTranslationId($nodeTypeSpecificPrefix, $elementType, $elementName)
   256|     {
   257|         return $nodeTypeSpecificPrefix . $elementType . '.' . $elementName;
   258|     }
   259|     /**
   260|      * Generates a property label with the given $nodeTypeSpecificPrefix.
   261|      *
   262|      * @param string $nodeTypeSpecificPrefix
   263|      * @param string $propertyName
   264|      * @return string
   265|      */
   266|     protected function getPropertyLabelTranslationId($nodeTypeSpecificPrefix, $propertyName)
   267|     {
   268|         return $nodeTypeSpecificPrefix . 'properties.' . $propertyName;
   269|     }
   270|     /**
   271|      * Generates a property configuration-label with the given $nodeTypeSpecificPrefix.
   272|      *
   273|      * @param string $nodeTypeSpecificPrefix
   274|      * @param string $propertyName
   275|      * @param string $labelPath
   276|      * @return string
   277|      */
   278|     protected function getPropertyConfigurationTranslationId($nodeTypeSpecificPrefix, $propertyName, $labelPath)
   279|     {
   280|         return $nodeTypeSpecificPrefix . 'properties.' . $propertyName . '.' . $labelPath;
   281|     }
   282|     /**
   283|      * Generates a label prefix for a specific node type with this format: "Vendor_Package:NodeTypes.NodeTypeName"
   284|      *
   285|      * @param string $nodeTypeName
   286|      * @return string
   287|      */
   288|     protected function generateNodeTypeLabelIdPrefix($nodeTypeName)
   289|     {
   290|         $nodeTypeNameParts = explode(':', $nodeTypeName, 2);
   291|         $packageKey = isset($nodeTypeNameParts[1]) ? $nodeTypeNameParts[0] : 'Neos.Neos';
   292|         $nodeTypeName = isset($nodeTypeNameParts[1]) ? $nodeTypeNameParts[1] : $nodeTypeNameParts[0];
   293|         return sprintf('%s:%s:', $packageKey, 'NodeTypes.' . $nodeTypeName);
   294|     }
   295|     /**
   296|      * Splits an identifier string of the form PackageKey:id or PackageKey:Source:id into an array with the keys
   297|      * id, source and packageKey.
   298|      *
   299|      * @param string $id translation id with possible package and source parts
   300|      * @return array
   301|      */
   302|     protected function splitIdentifier($id)
   303|     {
   304|         $packageKey = 'Neos.Neos';
   305|         $source = 'Main';
   306|         $idParts = explode(':', $id, 3);
   307|         switch (count($idParts)) {
   308|             case 2:
   309|                 $packageKey = $idParts[0];
   310|                 $id = $idParts[1];
   311|                 break;
   312|             case 3:
   313|                 $packageKey = $idParts[0];
   314|                 $source = str_replace('.', '/', $idParts[1]);
   315|                 $id = $idParts[2];
   316|                 break;
   317|         }
   318|         return [
   319|             'id' => $id,
   320|             'source' => $source,
   321|             'packageKey' => $packageKey
   322|         ];
   323|     }
   324| }


# ====================================================================
# FILE: Neos.Neos/Classes/Controller/Backend/ImpersonateController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-175 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Neos\Controller\Backend;
     4| /*
     5|  * This file is part of the Neos.Neos package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\Mvc\Controller\ActionController;
    15| use Neos\Flow\Mvc\Exception\StopActionException;
    16| use Neos\Flow\Mvc\Routing\UriBuilder;
    17| use Neos\Flow\Mvc\View\JsonView;
    18| use Neos\Flow\Security\Account;
    19| use Neos\Neos\Domain\Model\User;
    20| use Neos\Party\Domain\Service\PartyService;
    21| use Neos\Neos\Service\ImpersonateService;
    22| /**
    23|  * The Impersonate controller
    24|  *
    25|  * @Flow\Scope("singleton")
    26|  */
    27| class ImpersonateController extends ActionController
    28| {
    29|     /**
    30|      * @var ImpersonateService
    31|      * @Flow\Inject
    32|      */
    33|     protected $impersonateService;
    34|     /**
    35|      * @var PartyService
    36|      * @Flow\Inject
    37|      */
    38|     protected $partyService;
    39|     /**
    40|      * @var string
    41|      */
    42|     protected $defaultViewObjectName = JsonView::class;
    43|     /**
    44|      * @var array
    45|      */
    46|     protected $viewFormatToObjectNameMap = [
    47|         'json' => JsonView::class
    48|     ];
    49|     /**
    50|      * @var array
    51|      */
    52|     protected $supportedMediaTypes = [
    53|         'application/json'
    54|     ];
    55|     public function impersonateAction(Account $account): void
    56|     {
    57|         $this->impersonateService->impersonate($account);
    58|         $this->redirectIfPossible('impersonate');
    59|     }
    60|     /**
    61|      * Fetching possible redirect options for the given action method and if everything is set we redirect to the
    62|      * configured controller action.
    63|      */
    64|     protected function redirectIfPossible(string $actionName): void
    65|     {
    66|         $action = $this->settings['redirectOptions'][$actionName]['action'] ?? '';
    67|         $controller = $this->settings['redirectOptions'][$actionName]['controller'] ?? '';
    68|         $package = $this->settings['redirectOptions'][$actionName]['package'] ?? '';
    69|         if ($action !== '' && $controller !== '' && $package !== '' && $this->impersonateService->getImpersonation() === null) {
    70|             $this->redirectWithParentRequest($action, $controller, $package);
    71|         }
    72|     }
    73|     /**
    74|      * @param string $actionName Name of the action to forward to
    75|      * @param string $controllerName Unqualified object name of the controller to forward to. If not specified, the current controller is used.
    76|      * @param string $packageKey Key of the package containing the controller to forward to. If not specified, the current package is assumed.
    77|      * @param array $arguments Array of arguments for the target action
    78|      * @param integer $delay (optional) The delay in seconds. Default is no delay.
    79|      * @param integer $statusCode (optional) The HTTP status code for the redirect. Default is "303 See Other"
    80|      * @param string $format The format to use for the redirect URI
    81|      * @see redirect()
    82|      */
    83|     protected function redirectWithParentRequest(string $actionName, string $controllerName = null, string $packageKey = null, array $arguments = [], int $delay = 0, int $statusCode = 303, string $format = null): void
    84|     {
    85|         $request = $this->getControllerContext()->getRequest()->getMainRequest();
    86|         $uriBuilder = new UriBuilder();
    87|         $uriBuilder->setRequest($request);
    88|         if ($packageKey !== null && strpos($packageKey, '\\') !== false) {
    89|             list($packageKey, $subpackageKey) = explode('\\', $packageKey, 2);
    90|         } else {
    91|             $subpackageKey = null;
    92|         }
    93|         if ($format === null) {
    94|             $uriBuilder->setFormat($this->request->getFormat());
    95|         } else {
    96|             $uriBuilder->setFormat($format);
    97|         }
    98|         $uri = $uriBuilder->setCreateAbsoluteUri(true)->uriFor($actionName, $arguments, $controllerName, $packageKey, $subpackageKey);
    99|         $this->redirectToUri($uri, $delay, $statusCode);
   100|     }
   101|     /**
   102|      * @throws \Neos\Flow\Session\Exception\SessionNotStartedException
   103|      */
   104|     public function impersonateUserWithResponseAction(User $user): void
   105|     {
   106|         /** @var Account $account */
   107|         $account = $user->getAccounts()->first();
   108|         $this->impersonateService->impersonate($account);
   109|         $impersonateStatus = $this->getImpersonateStatus();
   110|         $this->view->assign('value', $impersonateStatus);
   111|     }
   112|     /**
   113|      * @throws StopActionException
   114|      */
   115|     public function restoreAction(): void
   116|     {
   117|         $this->impersonateService->restoreOriginalIdentity();
   118|         $this->redirectIfPossible('restore');
   119|     }
   120|     /**
   121|      * @throws StopActionException
   122|      */
   123|     public function restoreWithResponseAction(): void
   124|     {
   125|         /** @var Account $originalIdentity */
   126|         $originalIdentity = $this->impersonateService->getOriginalIdentity();
   127|         /** @var Account $impersonateIdentity */
   128|         $impersonateIdentity = $this->impersonateService->getImpersonation();
   129|         $response['status'] = false;
   130|         if ($originalIdentity) {
   131|             $response['status'] = true;
   132|             $response['origin'] = [
   133|                 'accountIdentifier' => $originalIdentity->getAccountIdentifier(),
   134|             ];
   135|         }
   136|         if ($impersonateIdentity) {
   137|             $response['impersonate'] = [
   138|                 'accountIdentifier' => $impersonateIdentity->getAccountIdentifier(),
   139|             ];
   140|         }
   141|         $this->impersonateService->restoreOriginalIdentity();
   142|         $this->view->assign('value', $response);
   143|     }
   144|     public function statusAction(): void
   145|     {
   146|         $impersonateStatus = $this->getImpersonateStatus();
   147|         $this->view->assign('value', $impersonateStatus);
   148|     }
   149|     public function getImpersonateStatus(): array
   150|     {
   151|         $impersonateStatus = [
   152|             'status' => false
   153|         ];
   154|         if ($this->impersonateService->isActive()) {
   155|             $currentImpersonation = $this->impersonateService->getImpersonation();
   156|             $originalIdentity = $this->impersonateService->getOriginalIdentity();
   157|             /** @var User $user */
   158|             $user = $this->partyService->getAssignedPartyOfAccount($currentImpersonation);
   159|             $impersonateStatus['status'] = true;
   160|             $impersonateStatus['user'] = [
   161|                 'accountIdentifier' => $currentImpersonation->getAccountIdentifier(),
   162|                 'fullName' => $user->getName()->getFullName()
   163|             ];
   164|             if ($originalIdentity) {
   165|                 /** @var User $originUser */
   166|                 $originUser = $this->partyService->getAssignedPartyOfAccount($originalIdentity);
   167|                 $impersonateStatus['origin'] = [
   168|                     'accountIdentifier' => $originalIdentity->getAccountIdentifier(),
   169|                     'fullName' => $originUser->getName()->getFullName()
   170|                 ];
   171|             }
   172|         }
   173|         return $impersonateStatus;
   174|     }
   175| }


# ====================================================================
# FILE: Neos.Neos/Classes/Controller/Backend/SchemaController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-51 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Neos\Controller\Backend;
     4| /*
     5|  * This file is part of the Neos.Neos package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Cache\Frontend\VariableFrontend;
    14| use Neos\Flow\Annotations as Flow;
    15| use Neos\Flow\Mvc\Controller\ActionController;
    16| use Neos\Neos\Service\NodeTypeSchemaBuilder;
    17| /**
    18|  * @Flow\Scope("singleton")
    19|  */
    20| class SchemaController extends ActionController
    21| {
    22|     /**
    23|      * @var NodeTypeSchemaBuilder
    24|      * @Flow\Inject
    25|      */
    26|     protected $nodeTypeSchemaBuilder;
    27|     /**
    28|      * @Flow\Inject
    29|      * @var VariableFrontend
    30|      */
    31|     protected $nodeTypeSchemaCache;
    32|     /**
    33|      * Get the node type configuration schema for the Neos UI
    34|      *
    35|      * @return string
    36|      */
    37|     public function nodeTypeSchemaAction(): string
    38|     {
    39|         $version = $this->request->hasArgument('version') ? $this->request->getArgument('version') : '';
    40|         $cacheIdentifier = 'nodeTypeSchema_' . $version;
    41|         $this->response->setContentType('application/json');
    42|         $this->response->setHttpHeader('Cache-Control', 'max-age=' . (3600 * 24 * 7));
    43|         $nodeTypeSchema = $this->nodeTypeSchemaCache->get($cacheIdentifier);
    44|         if (!$nodeTypeSchema) {
    45|             $nodeTypeSchema = json_encode($this->nodeTypeSchemaBuilder->generateNodeTypeSchema());
    46|             $this->nodeTypeSchemaCache->flushByTag('nodeType');
    47|             $this->nodeTypeSchemaCache->set($cacheIdentifier, $nodeTypeSchema, ['nodeType']);
    48|         }
    49|         return $nodeTypeSchema;
    50|     }
    51| }


# ====================================================================
# FILE: Neos.Neos/Classes/Controller/Module/Administration/SitesController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-577 ---
     1| <?php
     2| namespace Neos\Neos\Controller\Module\Administration;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Error\Messages\Message;
    14| use Neos\Flow\I18n\Translator;
    15| use Neos\Flow\Log\ThrowableStorageInterface;
    16| use Neos\Flow\Log\Utility\LogEnvironment;
    17| use Neos\Flow\Package\PackageInterface;
    18| use Neos\Flow\Package\PackageManager;
    19| use Neos\Flow\Session\SessionInterface;
    20| use Neos\Media\Domain\Repository\AssetCollectionRepository;
    21| use Neos\Neos\Controller\Module\AbstractModuleController;
    22| use Neos\Neos\Domain\Model\Domain;
    23| use Neos\Neos\Domain\Model\Site;
    24| use Neos\Neos\Domain\Repository\DomainRepository;
    25| use Neos\Neos\Domain\Repository\SiteRepository;
    26| use Neos\Neos\Domain\Service\SiteImportService;
    27| use Neos\Neos\Domain\Service\SiteService;
    28| use Neos\ContentRepository\Domain\Model\Workspace;
    29| use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
    30| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    31| use Neos\ContentRepository\Domain\Utility\NodePaths;
    32| use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
    33| use Neos\ContentRepository\Domain\Service\NodeTypeManager;
    34| use Neos\ContentRepository\Domain\Service\NodeService;
    35| use Neos\SiteKickstarter\Service\SiteGeneratorCollectingService;
    36| use Neos\SiteKickstarter\Service\SitePackageGeneratorNameService;
    37| /**
    38|  * The Neos Sites Management module controller
    39|  */
    40| class SitesController extends AbstractModuleController
    41| {
    42|     /**
    43|      * @Flow\Inject
    44|      * @var DomainRepository
    45|      */
    46|     protected $domainRepository;
    47|     /**
    48|      * @Flow\Inject
    49|      * @var SiteRepository
    50|      */
    51|     protected $siteRepository;
    52|     /**
    53|      * @Flow\Inject
    54|      * @var NodeDataRepository
    55|      */
    56|     protected $nodeDataRepository;
    57|     /**
    58|      * @Flow\Inject
    59|      * @var ContextFactoryInterface
    60|      */
    61|     protected $nodeContextFactory;
    62|     /**
    63|      * @Flow\Inject
    64|      * @var NodeService
    65|      */
    66|     protected $nodeService;
    67|     /**
    68|      * @Flow\Inject
    69|      * @var NodeTypeManager
    70|      */
    71|     protected $nodeTypeManager;
    72|     /**
    73|      * @Flow\Inject
    74|      * @var WorkspaceRepository
    75|      */
    76|     protected $workspaceRepository;
    77|     /**
    78|      * @Flow\Inject
    79|      * @var AssetCollectionRepository
    80|      */
    81|     protected $assetCollectionRepository;
    82|     /**
    83|      * @Flow\Inject
    84|      * @var PackageManager
    85|      */
    86|     protected $packageManager;
    87|     /**
    88|      * @Flow\Inject
    89|      * @var SiteImportService
    90|      */
    91|     protected $siteImportService;
    92|     /**
    93|      * @Flow\Inject
    94|      * @var SiteService
    95|      */
    96|     protected $siteService;
    97|     /**
    98|      * @Flow\Inject
    99|      * @var SessionInterface
   100|      */
   101|     protected $session;
   102|     /**
   103|      * @Flow\Inject
   104|      * @var Translator
   105|      */
   106|     protected $translator;
   107|     /**
   108|      * @var ThrowableStorageInterface
   109|      */
   110|     private $throwableStorage;
   111|     /**
   112|      * @param ThrowableStorageInterface $throwableStorage
   113|      */
   114|     public function injectThrowableStorage(ThrowableStorageInterface $throwableStorage)
   115|     {
   116|         $this->throwableStorage = $throwableStorage;
   117|     }
   118|     /**
   119|      * @return void
   120|      */
   121|     public function indexAction()
   122|     {
   123|         $sitePackagesAndSites = [];
   124|         foreach ($this->packageManager->getFilteredPackages('available', 'neos-site') as $sitePackageKey => $sitePackage) {
   125|             /** @var PackageInterface $sitePackage */
   126|             $sitePackagesAndSites[strtolower(str_replace('.', '_', $sitePackageKey))] = ['package' => $sitePackage, 'packageKey' => $sitePackage->getPackageKey()];
   127|         }
   128|         $sites = $this->siteRepository->findAll();
   129|         foreach ($sites as $site) {
   130|             $siteResourcePackageKey = strtolower(str_replace('.', '_', $site->getSiteResourcesPackageKey()));
   131|             if (!isset($sitePackagesAndSites[$siteResourcePackageKey])) {
   132|                 $sitePackagesAndSites[$siteResourcePackageKey] = ['packageKey' => $site->getSiteResourcesPackageKey()];
   133|             }
   134|             if (!isset($sitePackagesAndSites[$siteResourcePackageKey]['sites'])) {
   135|                 $sitePackagesAndSites[$siteResourcePackageKey]['sites'] = [];
   136|             }
   137|             $sitePackagesAndSites[$siteResourcePackageKey]['sites'][] = $site;
   138|         }
   139|         $this->view->assignMultiple([
   140|             'sitePackagesAndSites' => $sitePackagesAndSites,
   141|             'multipleSites' => count($sites) > 1
   142|         ]);
   143|     }
   144|     /**
   145|      * A edit view for a site and its settings.
   146|      *
   147|      * @param Site $site Site to view
   148|      * @Flow\IgnoreValidation("$site")
   149|      * @return void
   150|      */
   151|     public function editAction(Site $site)
   152|     {
   153|         try {
   154|             $sitePackage = $this->packageManager->getPackage($site->getSiteResourcesPackageKey());
   155|         } catch (\Exception $e) {
   156|             $this->addFlashMessage(
   157|                 $this->translator->translateById('sites.sitePackageNotFound.body', [htmlspecialchars($site->getSiteResourcesPackageKey())], null, null, 'Modules', 'Neos.Neos'),
   158|                 $this->translator->translateById('sites.sitePackageNotFound.title', [], null, null, 'Modules', 'Neos.Neos'),
   159|                 Message::SEVERITY_ERROR
   160|             );
   161|         }
   162|         $this->view->assignMultiple([
   163|             'site' => $site,
   164|             'sitePackage' => isset($sitePackage) ? $sitePackage : [],
   165|             'domains' => $this->domainRepository->findBySite($site),
   166|             'assetCollections' => $this->assetCollectionRepository->findAll()
   167|         ]);
   168|     }
   169|     /**
   170|      * Update a site
   171|      *
   172|      * @param Site $site A site to update
   173|      * @param string $newSiteNodeName A new site node name
   174|      * @return void
   175|      * @Flow\Validate(argumentName="$site", type="UniqueEntity")
   176|      * @Flow\Validate(argumentName="$newSiteNodeName", type="NotEmpty")
   177|      * @Flow\Validate(argumentName="$newSiteNodeName", type="StringLength", options={ "minimum"=1, "maximum"=250 })
   178|      * @Flow\Validate(argumentName="$newSiteNodeName", type="Neos.Neos:NodeName")
   179|      */
   180|     public function updateSiteAction(Site $site, $newSiteNodeName)
   181|     {
   182|         if ($site->getNodeName() !== $newSiteNodeName) {
   183|             $oldSiteNodePath = NodePaths::addNodePathSegment(SiteService::SITES_ROOT_PATH, $site->getNodeName());
   184|             $newSiteNodePath = NodePaths::addNodePathSegment(SiteService::SITES_ROOT_PATH, $newSiteNodeName);
   185|             /** @var $workspace Workspace */
   186|             foreach ($this->workspaceRepository->findAll() as $workspace) {
   187|                 $siteNode = $this->nodeDataRepository->findOneByPath($oldSiteNodePath, $workspace);
   188|                 if ($siteNode !== null) {
   189|                     $siteNode->setPath($newSiteNodePath);
   190|                 }
   191|             }
   192|             $site->setNodeName($newSiteNodeName);
   193|             $this->nodeDataRepository->persistEntities();
   194|         }
   195|         $this->siteRepository->update($site);
   196|         $this->addFlashMessage(
   197|             $this->translator->translateById('sites.update.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
   198|             $this->translator->translateById('sites.update.title', [], null, null, 'Modules', 'Neos.Neos'),
   199|             null,
   200|             [],
   201|             1412371798
   202|         );
   203|         $this->unsetLastVisitedNodeAndRedirect('index');
   204|     }
   205|     /**
   206|      * Create a new site form.
   207|      *
   208|      * @param Site $site Site to create
   209|      * @Flow\IgnoreValidation("$site")
   210|      * @return void
   211|      */
   212|     public function newSiteAction(Site $site = null)
   213|     {
   214|         $sitePackages = $this->packageManager->getFilteredPackages('available', 'neos-site');
   215|         $documentNodeTypes = $this->nodeTypeManager->getSubNodeTypes('Neos.Neos:Document', false);
   216|         $generatorServiceIsAvailable = $this->packageManager->isPackageAvailable('Neos.SiteKickstarter');
   217|         $generatorServices = [];
   218|         if ($generatorServiceIsAvailable) {
   219|             $siteGeneratorCollectingService = $this->objectManager->get(SiteGeneratorCollectingService::class);
   220|             $sitePackageGeneratorNameService = $this->objectManager->get(SitePackageGeneratorNameService::class);
   221|             $generatorClasses = $siteGeneratorCollectingService->getAllGenerators();
   222|             foreach ($generatorClasses as $generatorClass) {
   223|                 $name = $sitePackageGeneratorNameService->getNameOfSitePackageGenerator($generatorClass);
   224|                 $generatorServices[$generatorClass] = $name;
   225|             }
   226|         }
   227|         $this->view->assignMultiple([
   228|             'sitePackages' => $sitePackages,
   229|             'documentNodeTypes' => $documentNodeTypes,
   230|             'site' => $site,
   231|             'generatorServiceIsAvailable' => $generatorServiceIsAvailable,
   232|             'generatorServices' => $generatorServices
   233|         ]);
   234|     }
   235|     /**
   236|      * Create a new site-package and directly import it.
   237|      *
   238|      * @param string $packageKey Package Name to create
   239|      * @param string $generatorClass Generator Class to generate the site package
   240|      * @param string $siteName Site Name to create
   241|      * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
   242|      * @return void
   243|      */
   244|     public function createSitePackageAction(string $packageKey, string $generatorClass, string $siteName) : void
   245|     {
   246|         if ($this->packageManager->isPackageAvailable('Neos.SiteKickstarter') === false) {
   247|             $this->addFlashMessage(
   248|                 $this->translator->translateById('sites.missingPackage.body', ['Neos.SiteKickstarter'], null, null, 'Modules', 'Neos.Neos'),
   249|                 $this->translator->translateById('sites.missingPackage.title', [], null, null, 'Modules', 'Neos.Neos'),
   250|                 Message::SEVERITY_ERROR,
   251|                 [],
   252|                 1475736232
   253|             );
   254|             $this->redirect('index');
   255|         }
   256|         if ($this->packageManager->isPackageAvailable($packageKey)) {
   257|             $this->addFlashMessage(
   258|                 $this->translator->translateById('sites.invalidPackageKey.body', [htmlspecialchars($packageKey)], null, null, 'Modules', 'Neos.Neos'),
   259|                 $this->translator->translateById('sites.invalidPackageKey.title', [], null, null, 'Modules', 'Neos.Neos'),
   260|                 Message::SEVERITY_ERROR,
   261|                 [],
   262|                 1412372021
   263|             );
   264|             $this->redirect('index');
   265|         }
   266|         if ($this->objectManager->has($generatorClass) === false) {
   267|             $this->addFlashMessage('The generator class "%s" is not present.', 'Missing generator class', Message::SEVERITY_ERROR, [$generatorClass]);
   268|             $this->redirect('index');
   269|         }
   270|         $generatorService = $this->objectManager->get($generatorClass);
   271|         $generatorService->generateSitePackage($packageKey, $siteName);
   272|         $this->controllerContext->getFlashMessageContainer()->addMessage(new Message(sprintf(
   273|             $this->translator->translateById('sites.sitePackagesWasCreated.body', [htmlspecialchars($packageKey)], null, null, 'Modules', 'Neos.Neos'),
   274|             '',
   275|             null
   276|         )));
   277|         $this->forward('importSite', null, null, ['packageKey' => $packageKey]);
   278|     }
   279|     /**
   280|      * Import a site from site package.
   281|      *
   282|      * @param string $packageKey Package from where the import will come
   283|      * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
   284|      * @return void
   285|      */
   286|     public function importSiteAction($packageKey)
   287|     {
   288|         try {
   289|             $this->siteImportService->importFromPackage($packageKey);
   290|             $this->addFlashMessage(
   291|                 $this->translator->translateById('sites.theSiteHasBeenImported.body', [], null, null, 'Modules', 'Neos.Neos'),
   292|                 '',
   293|                 null,
   294|                 [],
   295|                 1412372266
   296|             );
   297|         } catch (\Exception $exception) {
   298|             $logMessage = $this->throwableStorage->logThrowable($exception);
   299|             $this->logger->error($logMessage, LogEnvironment::fromMethodName(__METHOD__));
   300|             $this->addFlashMessage(
   301|                 $this->translator->translateById('sites.importError.body', [htmlspecialchars($packageKey), htmlspecialchars($exception->getMessage())], null, null, 'Modules', 'Neos.Neos'),
   302|                 $this->translator->translateById('sites.importError.title', [], null, null, 'Modules', 'Neos.Neos'),
   303|                 Message::SEVERITY_ERROR,
   304|                 [],
   305|                 1412372375
   306|             );
   307|         }
   308|         $this->unsetLastVisitedNodeAndRedirect('index');
   309|     }
   310|     /**
   311|      * Create a new empty site.
   312|      *
   313|      * @param string $packageKey Package Name to create
   314|      * @param string $siteName Site Name to create
   315|      * @param string $nodeType NodeType name for the root node to create
   316|      * @Flow\Validate(argumentName="$packageKey", type="\Neos\Neos\Validation\Validator\PackageKeyValidator")
   317|      * @return void
   318|      */
   319|     public function createSiteNodeAction($packageKey, $siteName, $nodeType)
   320|     {
   321|         $nodeName = $this->nodeService->generateUniqueNodeName(SiteService::SITES_ROOT_PATH, $siteName);
   322|         if ($this->siteRepository->findOneByNodeName($nodeName)) {
   323|             $this->addFlashMessage(
   324|                 $this->translator->translateById('sites.SiteCreationError.siteWithSiteNodeNameAlreadyExists.body', [$nodeName], null, null, 'Modules', 'Neos.Neos'),
   325|                 $this->translator->translateById('sites.SiteCreationError.siteWithSiteNodeNameAlreadyExists.title', [], null, null, 'Modules', 'Neos.Neos'),
   326|                 Message::SEVERITY_ERROR,
   327|                 [],
   328|                 1412372375
   329|             );
   330|             $this->redirect('createSiteNode');
   331|         }
   332|         $siteNodeType = $this->nodeTypeManager->getNodeType($nodeType);
   333|         if ($siteNodeType === null || $siteNodeType->getName() === 'Neos.Neos:FallbackNode') {
   334|             $this->addFlashMessage(
   335|                 $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotFound.body', [$nodeType], null, null, 'Modules', 'Neos.Neos'),
   336|                 $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotFound.title', [], null, null, 'Modules', 'Neos.Neos'),
   337|                 Message::SEVERITY_ERROR,
   338|                 [],
   339|                 1412372375
   340|             );
   341|             $this->redirect('createSiteNode');
   342|         }
   343|         if ($siteNodeType->isOfType('Neos.Neos:Document') === false) {
   344|             $this->addFlashMessage(
   345|                 $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotBasedOnSuperType.body', [$nodeType, 'Neos.Neos:Document'], null, null, 'Modules', 'Neos.Neos'),
   346|                 $this->translator->translateById('sites.siteCreationError.givenNodeTypeNotBasedOnSuperType.title', [], null, null, 'Modules', 'Neos.Neos'),
   347|                 Message::SEVERITY_ERROR,
   348|                 [],
   349|                 1412372375
   350|             );
   351|             $this->redirect('createSiteNode');
   352|         }
   353|         $rootNode = $this->nodeContextFactory->create()->getRootNode();
   354|         $rootNode->getContext()->getWorkspace();
   355|         $this->persistenceManager->persistAll();
   356|         $sitesNode = $rootNode->getNode(SiteService::SITES_ROOT_PATH);
   357|         if ($sitesNode === null) {
   358|             $sitesNode = $rootNode->createNode(NodePaths::getNodeNameFromPath(SiteService::SITES_ROOT_PATH));
   359|         }
   360|         $siteNode = $sitesNode->createNode($nodeName, $siteNodeType);
   361|         $siteNode->setProperty('title', $siteName);
   362|         $site = new Site($nodeName);
   363|         $site->setSiteResourcesPackageKey($packageKey);
   364|         $site->setState(Site::STATE_ONLINE);
   365|         $site->setName($siteName);
   366|         $this->siteRepository->add($site);
   367|         $this->addFlashMessage(
   368|             $this->translator->translateById('sites.successfullyCreatedSite.body', [$siteName, $nodeName, $nodeType, $packageKey], null, null, 'Modules', 'Neos.Neos'),
   369|             '',
   370|             null,
   371|             [],
   372|             1412372266
   373|         );
   374|         $this->unsetLastVisitedNodeAndRedirect('index');
   375|     }
   376|     /**
   377|      * Delete a site.
   378|      *
   379|      * @param Site $site Site to delete
   380|      * @Flow\IgnoreValidation("$site")
   381|      * @return void
   382|      */
   383|     public function deleteSiteAction(Site $site)
   384|     {
   385|         $this->siteService->pruneSite($site);
   386|         $this->addFlashMessage(
   387|             $this->translator->translateById('sites.siteDeleted.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
   388|             $this->translator->translateById('sites.siteDeleted.title', [], null, null, 'Modules', 'Neos.Neos'),
   389|             Message::SEVERITY_OK,
   390|             [],
   391|             1412372689
   392|         );
   393|         $this->unsetLastVisitedNodeAndRedirect('index');
   394|     }
   395|     /**
   396|      * Activates a site
   397|      *
   398|      * @param Site $site Site to activate
   399|      * @return void
   400|      */
   401|     public function activateSiteAction(Site $site)
   402|     {
   403|         $site->setState($site::STATE_ONLINE);
   404|         $this->siteRepository->update($site);
   405|         $this->addFlashMessage(
   406|             $this->translator->translateById('sites.siteActivated.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
   407|             $this->translator->translateById('sites.siteActivated.title', [], null, null, 'Modules', 'Neos.Neos'),
   408|             Message::SEVERITY_OK,
   409|             [],
   410|             1412372881
   411|         );
   412|         $this->unsetLastVisitedNodeAndRedirect('index');
   413|     }
   414|     /**
   415|      * Deactivates a site
   416|      *
   417|      * @param Site $site Site to deactivate
   418|      * @return void
   419|      */
   420|     public function deactivateSiteAction(Site $site)
   421|     {
   422|         $site->setState($site::STATE_OFFLINE);
   423|         $this->siteRepository->update($site);
   424|         $this->addFlashMessage(
   425|             $this->translator->translateById('sites.siteDeactivated.body', [htmlspecialchars($site->getName())], null, null, 'Modules', 'Neos.Neos'),
   426|             $this->translator->translateById('sites.siteDeactivated.title', [], null, null, 'Modules', 'Neos.Neos'),
   427|             Message::SEVERITY_OK,
   428|             [],
   429|             1412372975
   430|         );
   431|         $this->unsetLastVisitedNodeAndRedirect('index');
   432|     }
   433|     /**
   434|      * Edit a domain
   435|      *
   436|      * @param Domain $domain Domain to edit
   437|      * @Flow\IgnoreValidation("$domain")
   438|      * @return void
   439|      */
   440|     public function editDomainAction(Domain $domain)
   441|     {
   442|         $this->view->assignMultiple(['domain' => $domain, 'schemes' => [null => '', 'http' => 'HTTP', 'https' => 'HTTPS']]);
   443|     }
   444|     /**
   445|      * Update a domain
   446|      *
   447|      * @param Domain $domain Domain to update
   448|      * @Flow\Validate(argumentName="$domain", type="UniqueEntity")
   449|      * @return void
   450|      */
   451|     public function updateDomainAction(Domain $domain)
   452|     {
   453|         $this->domainRepository->update($domain);
   454|         $this->addFlashMessage(
   455|             $this->translator->translateById('sites.domainUpdated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
   456|             $this->translator->translateById('sites.domainUpdated.title', [], null, null, 'Modules', 'Neos.Neos'),
   457|             Message::SEVERITY_OK,
   458|             [],
   459|             1412373069
   460|         );
   461|         $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
   462|     }
   463|     /**
   464|      * The create a new domain action.
   465|      *
   466|      * @param Domain $domain
   467|      * @param Site $site
   468|      * @Flow\IgnoreValidation("$domain")
   469|      * @return void
   470|      */
   471|     public function newDomainAction(Domain $domain = null, Site $site = null)
   472|     {
   473|         $this->view->assignMultiple([
   474|             'domain' => $domain,
   475|             'site' => $site,
   476|             'schemes' => [null => '', 'http' => 'HTTP', 'https' => 'HTTPS']
   477|         ]);
   478|     }
   479|     /**
   480|      * Create a domain
   481|      *
   482|      * @param Domain $domain Domain to create
   483|      * @Flow\Validate(argumentName="$domain", type="UniqueEntity")
   484|      * @return void
   485|      */
   486|     public function createDomainAction(Domain $domain)
   487|     {
   488|         $this->domainRepository->add($domain);
   489|         $this->addFlashMessage(
   490|             $this->translator->translateById('sites.domainCreated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
   491|             $this->translator->translateById('sites.domainCreated.title', [], null, null, 'Modules', 'Neos.Neos'),
   492|             Message::SEVERITY_OK,
   493|             [],
   494|             1412373192
   495|         );
   496|         $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
   497|     }
   498|     /**
   499|      * Deletes a domain attached to a site
   500|      *
   501|      * @param Domain $domain A domain to delete
   502|      * @Flow\IgnoreValidation("$domain")
   503|      * @return void
   504|      */
   505|     public function deleteDomainAction(Domain $domain)
   506|     {
   507|         $site = $domain->getSite();
   508|         if ($site->getPrimaryDomain() === $domain) {
   509|             $site->setPrimaryDomain(null);
   510|             $this->siteRepository->update($site);
   511|         }
   512|         $this->domainRepository->remove($domain);
   513|         $this->addFlashMessage(
   514|             $this->translator->translateById('sites.domainDeleted.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
   515|             $this->translator->translateById('sites.domainDeleted.title', [], null, null, 'Modules', 'Neos.Neos'),
   516|             Message::SEVERITY_OK,
   517|             [],
   518|             1412373310
   519|         );
   520|         $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $site]);
   521|     }
   522|     /**
   523|      * Activates a domain
   524|      *
   525|      * @param Domain $domain Domain to activate
   526|      * @Flow\IgnoreValidation("$domain")
   527|      * @return void
   528|      */
   529|     public function activateDomainAction(Domain $domain)
   530|     {
   531|         $domain->setActive(true);
   532|         $this->domainRepository->update($domain);
   533|         $this->addFlashMessage(
   534|             $this->translator->translateById('sites.domainActivated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
   535|             $this->translator->translateById('sites.domainActivated.title', [], null, null, 'Modules', 'Neos.Neos'),
   536|             Message::SEVERITY_OK,
   537|             [],
   538|             1412373539
   539|         );
   540|         $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
   541|     }
   542|     /**
   543|      * Deactivates a domain
   544|      *
   545|      * @param Domain $domain Domain to deactivate
   546|      * @Flow\IgnoreValidation("$domain")
   547|      * @return void
   548|      */
   549|     public function deactivateDomainAction(Domain $domain)
   550|     {
   551|         $domain->setActive(false);
   552|         $this->domainRepository->update($domain);
   553|         $this->addFlashMessage(
   554|             $this->translator->translateById('sites.domainDeactivated.body', [htmlspecialchars($domain)], null, null, 'Modules', 'Neos.Neos'),
   555|             $this->translator->translateById('sites.domainDeactivated.title', [], null, null, 'Modules', 'Neos.Neos'),
   556|             Message::SEVERITY_OK,
   557|             [],
   558|             1412373425
   559|         );
   560|         $this->unsetLastVisitedNodeAndRedirect('edit', null, null, ['site' => $domain->getSite()]);
   561|     }
   562|     /**
   563|      * @param string $actionName Name of the action to forward to
   564|      * @param string $controllerName Unqualified object name of the controller to forward to. If not specified, the current controller is used.
   565|      * @param string $packageKey Key of the package containing the controller to forward to. If not specified, the current package is assumed.
   566|      * @param array $arguments Array of arguments for the target action
   567|      * @param integer $delay (optional) The delay in seconds. Default is no delay.
   568|      * @param integer $statusCode (optional) The HTTP status code for the redirect. Default is "303 See Other"
   569|      * @param string $format The format to use for the redirect URI
   570|      * @return void
   571|      */
   572|     protected function unsetLastVisitedNodeAndRedirect($actionName, $controllerName = null, $packageKey = null, array $arguments = [], $delay = 0, $statusCode = 303, $format = null)
   573|     {
   574|         $this->session->putData('lastVisitedNode', null);
   575|         parent::redirect($actionName, $controllerName, $packageKey, $arguments, $delay, $statusCode, $format);
   576|     }
   577| }


# ====================================================================
# FILE: Neos.Neos/Classes/Domain/Repository/SiteRepository.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-104 ---
     1| <?php
     2| namespace Neos\Neos\Domain\Repository;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\Persistence\QueryInterface;
    14| use Neos\Flow\Persistence\QueryResultInterface;
    15| use Neos\Flow\Persistence\Repository;
    16| use Neos\Neos\Domain\Model\Site;
    17| use Neos\Neos\Domain\Exception as NeosException;
    18| /**
    19|  * The Site Repository
    20|  *
    21|  * @Flow\Scope("singleton")
    22|  * @api
    23|  */
    24| class SiteRepository extends Repository
    25| {
    26|     /**
    27|      * @var array
    28|      */
    29|     protected $defaultOrderings = [
    30|         'name' => QueryInterface::ORDER_ASCENDING,
    31|         'nodeName' => QueryInterface::ORDER_ASCENDING
    32|     ];
    33|     /**
    34|      * @Flow\InjectConfiguration(package="Neos.Neos", path="defaultSiteNodeName")
    35|      * @var string
    36|      */
    37|     protected $defaultSiteNodeName;
    38|     /**
    39|      * Finds the first site
    40|      *
    41|      * @return Site The first site or NULL if none exists
    42|      * @api
    43|      */
    44|     public function findFirst()
    45|     {
    46|         return $this->createQuery()->execute()->getFirst();
    47|     }
    48|     /**
    49|      * Find all sites with status "online"
    50|      *
    51|      * @return QueryResultInterface
    52|      */
    53|     public function findOnline()
    54|     {
    55|         return $this->findByState(Site::STATE_ONLINE);
    56|     }
    57|     /**
    58|      * Find first site with status "online"
    59|      *
    60|      * @return ?Site
    61|      */
    62|     public function findFirstOnline()
    63|     {
    64|         return $this->findOnline()->getFirst();
    65|     }
    66|     /**
    67|      * @param string $nodeName
    68|      * @return Site|null
    69|      */
    70|     public function findOneByNodeName(string $nodeName): ?Site
    71|     {
    72|         $query = $this->createQuery();
    73|         /** @var Site|null $site */
    74|         $site = $query->matching(
    75|             $query->equals('nodeName', $nodeName)
    76|         )
    77|             ->execute()
    78|             ->getFirst();
    79|         return $site;
    80|     }
    81|     /**
    82|      * Find the site that was specified in the configuration ``defaultSiteNodeName``
    83|      *
    84|      * If the defaultSiteNodeName-setting is null the first active site is returned
    85|      * If the site is not found or not active an exception is thrown
    86|      *
    87|      * @return Site
    88|      * @throws NeosException
    89|      */
    90|     public function findDefault()
    91|     {
    92|         if ($this->defaultSiteNodeName === null) {
    93|             return $this->findOnline()->getFirst();
    94|         }
    95|         /**
    96|          * @var Site $defaultSite
    97|          */
    98|         $defaultSite = $this->findOneByNodeName($this->defaultSiteNodeName);
    99|         if (!$defaultSite instanceof Site || $defaultSite->getState() !== Site::STATE_ONLINE) {
   100|             throw new NeosException(sprintf('DefaultSiteNode %s not found or not active', $this->defaultSiteNodeName), 1476374818);
   101|         }
   102|         return $defaultSite;
   103|     }
   104| }


# ====================================================================
# FILE: Neos.Neos/Classes/Fusion/Cache/ContentCacheFlusher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-296 ---
     1| <?php
     2| namespace Neos\Neos\Fusion\Cache;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\ContentRepository\Domain\Model\Workspace;
    13| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    14| use Neos\ContentRepository\Exception\NodeTypeNotFoundException;
    15| use Neos\Flow\Annotations as Flow;
    16| use Neos\Flow\Log\Utility\LogEnvironment;
    17| use Neos\Flow\Persistence\PersistenceManagerInterface;
    18| use Neos\Flow\Security\Context as SecurityContext;
    19| use Neos\Media\Domain\Model\AssetInterface;
    20| use Neos\Media\Domain\Model\AssetVariantInterface;
    21| use Neos\Media\Domain\Service\AssetService;
    22| use Neos\Neos\Domain\Model\Dto\AssetUsageInNodeProperties;
    23| use Neos\ContentRepository\Domain\Model\NodeInterface;
    24| use Neos\ContentRepository\Domain\Model\NodeType;
    25| use Neos\ContentRepository\Domain\Service\NodeTypeManager;
    26| use Neos\Fusion\Core\Cache\ContentCache;
    27| use Neos\Neos\Fusion\Helper\CachingHelper;
    28| use Neos\Neos\Domain\Service\ContentContext;
    29| use Neos\Neos\Domain\Service\ContentContextFactory;
    30| use Psr\Log\LoggerInterface;
    31| /**
    32|  * This service flushes Fusion content caches triggered by node changes.
    33|  *
    34|  * The method registerNodeChange() is triggered by a signal which is configured in the Package class of the Neos.Neos
    35|  * package (this package). Information on changed nodes is collected by this method and the respective Fusion content
    36|  * cache entries are flushed in one operation during Flow's shutdown procedure.
    37|  *
    38|  * @Flow\Scope("singleton")
    39|  */
    40| class ContentCacheFlusher
    41| {
    42|     /**
    43|      * @Flow\Inject
    44|      * @var ContentCache
    45|      */
    46|     protected $contentCache;
    47|     /**
    48|      * @Flow\Inject
    49|      * @var LoggerInterface
    50|      */
    51|     protected $systemLogger;
    52|     /**
    53|      * @var array<string, string>
    54|      */
    55|     protected $tagsToFlush = [];
    56|     /**
    57|      * @var CachingHelper
    58|      */
    59|     protected $cachingHelper;
    60|     /**
    61|      * @Flow\Inject
    62|      * @var WorkspaceRepository
    63|      */
    64|     protected $workspaceRepository;
    65|     /**
    66|      * @var array
    67|      */
    68|     protected $workspacesToFlush = [];
    69|     /**
    70|      * @var array<string, string[]>
    71|      */
    72|     protected $implementedNodeTypeNamesByNodeType = [];
    73|     /**
    74|      * @Flow\Inject
    75|      * @var AssetService
    76|      */
    77|     protected $assetService;
    78|     /**
    79|      * @Flow\Inject
    80|      * @var NodeTypeManager
    81|      */
    82|     protected $nodeTypeManager;
    83|     /**
    84|      * @Flow\Inject
    85|      * @var ContentContextFactory
    86|      */
    87|     protected $contextFactory;
    88|     /**
    89|      * @Flow\Inject
    90|      * @var PersistenceManagerInterface
    91|      */
    92|     protected $persistenceManager;
    93|     /**
    94|      * @var ContentContext[]
    95|      */
    96|     protected $contexts = [];
    97|     /**
    98|      * @Flow\Inject
    99|      * @var SecurityContext
   100|      */
   101|     protected $securityContext;
   102|     /**
   103|      * @Flow\InjectConfiguration(path="fusion.contentCacheDebugMode")
   104|      * @var bool
   105|      */
   106|     protected $debugMode;
   107|     /**
   108|      * Register a node change for a later cache flush. This method is triggered by a signal sent via ContentRepository's Node
   109|      * model or the Neos Publishing Service.
   110|      *
   111|      * @param NodeInterface $node The node which has changed in some way
   112|      * @param Workspace|null $targetWorkspace An optional workspace to flush
   113|      */
   114|     public function registerNodeChange(NodeInterface $node, Workspace $targetWorkspace = null): void
   115|     {
   116|         $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
   117|         if (empty($this->workspacesToFlush[$node->getWorkspace()->getName()])) {
   118|             $this->resolveWorkspaceChain($node->getWorkspace());
   119|         }
   120|         if ($targetWorkspace !== null && empty($this->workspacesToFlush[$targetWorkspace->getName()])) {
   121|             $this->resolveWorkspaceChain($targetWorkspace);
   122|         }
   123|         if (!array_key_exists($node->getWorkspace()->getName(), $this->workspacesToFlush)) {
   124|             return;
   125|         }
   126|         $this->registerAllTagsToFlushForNodeInWorkspace($node, $node->getWorkspace());
   127|         if ($targetWorkspace !== null) {
   128|             $this->registerAllTagsToFlushForNodeInWorkspace($node, $targetWorkspace);
   129|         }
   130|     }
   131|     protected function addTagToFlush(string $tag, string $message = ''): void
   132|     {
   133|         $this->tagsToFlush[$tag] = $this->debugMode ? $message : '';
   134|     }
   135|     protected function registerAllTagsToFlushForNodeInWorkspace(NodeInterface $node, Workspace $workspace): void
   136|     {
   137|         $nodeIdentifier = $node->getIdentifier();
   138|         if (!array_key_exists($workspace->getName(), $this->workspacesToFlush) || is_array($this->workspacesToFlush[$workspace->getName()]) === false) {
   139|             return;
   140|         }
   141|         foreach ($this->workspacesToFlush[$workspace->getName()] as $workspaceName => $workspaceHash) {
   142|             $this->registerChangeOnNodeIdentifier($workspaceHash .'_'. $nodeIdentifier);
   143|             $this->registerChangeOnNodeType($node->getNodeType()->getName(), $nodeIdentifier, $workspaceHash);
   144|             $nodeInWorkspace = $node;
   145|             while ($nodeInWorkspace->getDepth() > 1) {
   146|                 $nodeInWorkspace = $nodeInWorkspace->getParent();
   147|                 if ($nodeInWorkspace === null) {
   148|                     break;
   149|                 }
   150|                 $tagName = 'DescendantOf_' . $workspaceHash . '_' . $nodeInWorkspace->getIdentifier();
   151|                 if (array_key_exists($tagName, $this->tagsToFlush)) {
   152|                     break;
   153|                 }
   154|                 $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because node "%s" has changed.', $tagName, $node->getPath()));
   155|             }
   156|         }
   157|     }
   158|     protected function resolveWorkspaceChain(Workspace $workspace): void
   159|     {
   160|         $cachingHelper = $this->getCachingHelper();
   161|         $this->workspacesToFlush[$workspace->getName()][$workspace->getName()] = $cachingHelper->renderWorkspaceTagForContextNode($workspace->getName());
   162|         $this->resolveTagsForChildWorkspaces($workspace, $workspace->getName());
   163|     }
   164|     protected function resolveTagsForChildWorkspaces(Workspace $workspace, string $startingPoint): void
   165|     {
   166|         $cachingHelper = $this->getCachingHelper();
   167|         $this->workspacesToFlush[$startingPoint][$workspace->getName()] = $cachingHelper->renderWorkspaceTagForContextNode($workspace->getName());
   168|         $childWorkspaces = $this->workspaceRepository->findByBaseWorkspace($workspace->getName());
   169|         if ($childWorkspaces->valid()) {
   170|             foreach ($childWorkspaces as $childWorkspace) {
   171|                 $this->resolveTagsForChildWorkspaces($childWorkspace, $startingPoint);
   172|             }
   173|         }
   174|     }
   175|     /**
   176|      * Pleas use registerNodeChange() if possible. This method is a low-level api. If you do use this method make sure
   177|      * that $cacheIdentifier contains the workspacehash as well as the node identifier: $workspaceHash .'_'. $nodeIdentifier
   178|      * The workspacehash can be received via $this->getCachingHelper()->renderWorkspaceTagForContextNode($workpsacename)
   179|      */
   180|     public function registerChangeOnNodeIdentifier(string $cacheIdentifier): void
   181|     {
   182|         $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
   183|         $this->addTagToFlush('Node_' . $cacheIdentifier, sprintf('which were tagged with "Node_%s" because that identifier has changed.', $cacheIdentifier));
   184|         $this->addTagToFlush('NodeDynamicTag_' . $cacheIdentifier, sprintf('which were tagged with "NodeDynamicTag_%s" because that identifier has changed.', $cacheIdentifier));
   185|         $tagName = 'DescendantOf_' . $cacheIdentifier;
   186|         $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because node "%s" has changed.', $tagName, $cacheIdentifier));
   187|     }
   188|     /**
   189|      * This is a low-level api. Please use registerNodeChange() if possible. Otherwise make sure that $nodeTypePrefix
   190|      * is set up correctly and contains the workspacehash wich can be received via
   191|      * $this->getCachingHelper()->renderWorkspaceTagForContextNode($workpsacename)
   192|      *
   193|      * @throws NodeTypeNotFoundException
   194|      */
   195|     public function registerChangeOnNodeType(string $nodeTypeName, string $referenceNodeIdentifier = null, string $nodeTypePrefix = ''): void
   196|     {
   197|         $this->addTagToFlush(ContentCache::TAG_EVERYTHING, 'which were tagged with "Everything".');
   198|         $nodeTypesToFlush = $this->getAllImplementedNodeTypeNames($this->nodeTypeManager->getNodeType($nodeTypeName));
   199|         if ($nodeTypePrefix !== '') {
   200|             $nodeTypePrefix = rtrim($nodeTypePrefix, '_') . '_';
   201|         }
   202|         foreach ($nodeTypesToFlush as $nodeTypeNameToFlush) {
   203|             $this->addTagToFlush('NodeType_' . $nodeTypePrefix . $nodeTypeNameToFlush, sprintf('which were tagged with "NodeType_%s" because node "%s" has changed and was of type "%s".', $nodeTypeNameToFlush, ($referenceNodeIdentifier ? $referenceNodeIdentifier : ''), $nodeTypeName));
   204|         }
   205|     }
   206|     /**
   207|      * Fetches possible usages of the asset and registers nodes that use the asset as changed.
   208|      *
   209|      * @throws NodeTypeNotFoundException
   210|      */
   211|     public function registerAssetChange(AssetInterface $asset): void
   212|     {
   213|         if ($asset instanceof AssetVariantInterface) {
   214|             $asset = $asset->getOriginalAsset();
   215|         }
   216|         if (!$asset->isInUse()) {
   217|             return;
   218|         }
   219|         $cachingHelper = $this->getCachingHelper();
   220|         foreach ($this->assetService->getUsageReferences($asset) as $reference) {
   221|             if (!$reference instanceof AssetUsageInNodeProperties) {
   222|                 continue;
   223|             }
   224|             $workspaceHash = $cachingHelper->renderWorkspaceTagForContextNode($reference->getWorkspaceName());
   225|             $this->securityContext->withoutAuthorizationChecks(function () use ($reference, &$node) {
   226|                 $node = $this->getContextForReference($reference)->getNodeByIdentifier($reference->getNodeIdentifier());
   227|             });
   228|             if (!$node instanceof NodeInterface) {
   229|                 $this->systemLogger->warning(sprintf('Found a node reference from node with identifier %s in workspace %s to asset %s, but the node could not be fetched.', $reference->getNodeIdentifier(), $reference->getWorkspaceName(), $this->persistenceManager->getIdentifierByObject($asset)), LogEnvironment::fromMethodName(__METHOD__));
   230|                 continue;
   231|             }
   232|             $this->registerNodeChange($node);
   233|             $assetIdentifier = $this->persistenceManager->getIdentifierByObject($asset);
   234|             $tagName = 'AssetDynamicTag_' . $workspaceHash . '_' . $assetIdentifier;
   235|             $this->addTagToFlush($tagName, sprintf('which were tagged with "%s" because asset "%s" has changed.', $tagName, $assetIdentifier));
   236|         }
   237|     }
   238|     public function shutdownObject(): void
   239|     {
   240|         $this->commit();
   241|     }
   242|     /**
   243|      * Flush caches according to the previously registered node changes.
   244|      */
   245|     protected function commit(): void
   246|     {
   247|         if ($this->tagsToFlush !== []) {
   248|             if ($this->debugMode) {
   249|                 foreach ($this->tagsToFlush as $tag => $logMessage) {
   250|                     $affectedEntries = $this->contentCache->flushByTag($tag);
   251|                     if ($affectedEntries > 0) {
   252|                         $this->systemLogger->debug(sprintf('Content cache: Removed %s entries %s', $affectedEntries, $logMessage));
   253|                     }
   254|                 }
   255|             } else {
   256|                 $affectedEntries = $this->contentCache->flushByTags(array_keys($this->tagsToFlush));
   257|                 $this->systemLogger->debug(sprintf('Content cache: Removed %s entries', $affectedEntries));
   258|             }
   259|         }
   260|     }
   261|     protected function getContextForReference(AssetUsageInNodeProperties $assetUsage): ContentContext
   262|     {
   263|         $hash = md5(sprintf('%s-%s', $assetUsage->getWorkspaceName(), json_encode($assetUsage->getDimensionValues())));
   264|         if (!isset($this->contexts[$hash])) {
   265|             $this->contexts[$hash] = $this->contextFactory->create([
   266|                 'workspaceName' => $assetUsage->getWorkspaceName(),
   267|                 'dimensions' => $assetUsage->getDimensionValues(),
   268|                 'invisibleContentShown' => true,
   269|                 'inaccessibleContentShown' => true
   270|             ]);
   271|         }
   272|         return $this->contexts[$hash];
   273|     }
   274|     /**
   275|      * @return array<string>
   276|      */
   277|     protected function getAllImplementedNodeTypeNames(NodeType $nodeType): array
   278|     {
   279|         if (array_key_exists($nodeType->getName(), $this->implementedNodeTypeNamesByNodeType)) {
   280|             return $this->implementedNodeTypeNamesByNodeType[$nodeType->getName()];
   281|         }
   282|         $self = $this;
   283|         $types = array_unique(array_reduce($nodeType->getDeclaredSuperTypes(), static function (array $types, NodeType $superType) use ($self) {
   284|             return array_merge($types, $self->getAllImplementedNodeTypeNames($superType));
   285|         }, [$nodeType->getName()]));
   286|         $this->implementedNodeTypeNamesByNodeType[$nodeType->getName()] = $types;
   287|         return $types;
   288|     }
   289|     protected function getCachingHelper(): CachingHelper
   290|     {
   291|         if (!$this->cachingHelper instanceof CachingHelper) {
   292|             $this->cachingHelper = new CachingHelper();
   293|         }
   294|         return $this->cachingHelper;
   295|     }
   296| }


# ====================================================================
# FILE: Neos.Neos/Classes/Fusion/ConvertUrisImplementation.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-172 ---
     1| <?php
     2| namespace Neos\Neos\Fusion;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Neos\Domain\Exception;
    14| use Neos\Neos\Service\LinkingService;
    15| use Neos\ContentRepository\Domain\Model\NodeInterface;
    16| use Neos\Fusion\FusionObjects\AbstractFusionObject;
    17| /**
    18|  * A Fusion Object that converts link references in the format "<type>://<UUID>" to proper URIs
    19|  *
    20|  * Right now node://<UUID> and asset://<UUID> are supported URI schemes.
    21|  *
    22|  * Usage::
    23|  *
    24|  *   someTextProperty.@process.1 = Neos.Neos:ConvertUris
    25|  *
    26|  * The optional property ``forceConversion`` can be used to have the links converted even when not
    27|  * rendering the live workspace. This is used for links that are not inline editable (for
    28|  * example links on images)::
    29|  *
    30|  *   someTextProperty.@process.1 = Neos.Neos:ConvertUris {
    31|  *     forceConversion = true
    32|  *   }
    33|  *
    34|  * The optional property ``externalLinkTarget`` can be modified to disable or change the target attribute of the
    35|  * link tag for links to external targets::
    36|  *
    37|  *   prototype(Neos.Neos:ConvertUris) {
    38|  *     externalLinkTarget = '_blank'
    39|  *     resourceLinkTarget = '_blank'
    40|  *   }
    41|  *
    42|  * The optional property ``absolute`` can be used to convert node uris to absolute links::
    43|  *
    44|  *   someTextProperty.@process.1 = Neos.Neos:ConvertUris {
    45|  *     absolute = true
    46|  *   }
    47|  */
    48| class ConvertUrisImplementation extends AbstractFusionObject
    49| {
    50|     /**
    51|      * @Flow\Inject
    52|      * @var LinkingService
    53|      */
    54|     protected $linkingService;
    55|     /**
    56|      * Convert URIs matching a supported scheme with generated URIs
    57|      *
    58|      * If the workspace of the current node context is not live, no replacement will be done unless forceConversion is
    59|      * set. This is needed to show the editable links with metadata in the content module.
    60|      *
    61|      * @return string
    62|      * @throws Exception
    63|      */
    64|     public function evaluate()
    65|     {
    66|         $text = $this->fusionValue('value');
    67|         if ($text === '' || $text === null) {
    68|             return '';
    69|         }
    70|         if (!is_string($text)) {
    71|             throw new Exception(sprintf('Only strings can be processed by this Fusion object, given: "%s".', gettype($text)), 1382624080);
    72|         }
    73|         $node = $this->fusionValue('node');
    74|         if (!$node instanceof NodeInterface) {
    75|             throw new Exception(sprintf('The current node must be an instance of NodeInterface, given: "%s".', gettype($text)), 1382624087);
    76|         }
    77|         if (!($this->fusionValue('forceConversion')) && $node->getContext()->getWorkspace()->getName() !== 'live') {
    78|             return $text;
    79|         }
    80|         $unresolvedUris = [];
    81|         $linkingService = $this->linkingService;
    82|         $controllerContext = $this->runtime->getControllerContext();
    83|         $absolute = $this->fusionValue('absolute');
    84|         $processedContent = preg_replace_callback(LinkingService::PATTERN_SUPPORTED_URIS, function (array $matches) use ($node, $linkingService, $controllerContext, &$unresolvedUris, $absolute) {
    85|             switch ($matches[1]) {
    86|                 case 'node':
    87|                     $resolvedUri = $linkingService->resolveNodeUri($matches[0], $node, $controllerContext, $absolute);
    88|                     $this->runtime->addCacheTag('node', $matches[2]);
    89|                     break;
    90|                 case 'asset':
    91|                     $resolvedUri = $linkingService->resolveAssetUri($matches[0]);
    92|                     $this->runtime->addCacheTag('asset', $matches[2]);
    93|                     break;
    94|                 default:
    95|                     $resolvedUri = null;
    96|             }
    97|             if ($resolvedUri === null) {
    98|                 $unresolvedUris[] = $matches[0];
    99|                 return $matches[0];
   100|             }
   101|             return $resolvedUri;
   102|         }, $text);
   103|         if ($unresolvedUris !== []) {
   104|             $processedContent = preg_replace('/<a(?:\s+[^>]*)?\s+href="(node|asset):\/\/[^"]+"[^>]*>(.*?)<\/a>/', '$2', $processedContent);
   105|             $processedContent = preg_replace(LinkingService::PATTERN_SUPPORTED_URIS, '', $processedContent);
   106|         }
   107|         $processedContent = $this->replaceLinkTargets($processedContent);
   108|         return $processedContent;
   109|     }
   110|     /**
   111|      * Replace the target attribute of link tags in processedContent with the target
   112|      * specified by externalLinkTarget and resourceLinkTarget options.
   113|      * Additionally set rel="noopener external" for external links.
   114|      *
   115|      * @param string $processedContent
   116|      * @return string
   117|      */
   118|     protected function replaceLinkTargets($processedContent)
   119|     {
   120|         $setNoOpener = $this->fusionValue('setNoOpener');
   121|         $setExternal = $this->fusionValue('setExternal');
   122|         $externalLinkTarget = \trim((string)$this->fusionValue('externalLinkTarget'));
   123|         $resourceLinkTarget = \trim((string)$this->fusionValue('resourceLinkTarget'));
   124|         $controllerContext = $this->runtime->getControllerContext();
   125|         $host = $controllerContext->getRequest()->getHttpRequest()->getUri()->getHost();
   126|         $processedContent = \preg_replace_callback(
   127|             '~<a\s+.*?href="(.*?)".*?>~i',
   128|             static function ($matches) use ($externalLinkTarget, $resourceLinkTarget, $host, $setNoOpener, $setExternal) {
   129|                 [$linkText, $linkHref] = $matches;
   130|                 $uriHost = \parse_url($linkHref, PHP_URL_HOST);
   131|                 $target = null;
   132|                 $isExternalLink = \is_string($uriHost) && $uriHost !== $host;
   133|                 if ($externalLinkTarget && $externalLinkTarget !== '' && $isExternalLink) {
   134|                     $target = $externalLinkTarget;
   135|                 }
   136|                 if ($resourceLinkTarget && $resourceLinkTarget !== '' && str_contains($linkHref, '_Resources')) {
   137|                     $target = $resourceLinkTarget;
   138|                 }
   139|                 if ($isExternalLink && $setNoOpener) {
   140|                     $linkText = self::setAttribute('rel', 'noopener', $linkText);
   141|                 }
   142|                 if ($isExternalLink && $setExternal) {
   143|                     $linkText = self::setAttribute('rel', 'external', $linkText);
   144|                 }
   145|                 if (is_string($target) && $target !== '') {
   146|                     return self::setAttribute('target', $target, $linkText);
   147|                 }
   148|                 return $linkText;
   149|             },
   150|             $processedContent
   151|         );
   152|         return $processedContent;
   153|     }
   154|     /**
   155|      * Set or add value to the a attribute
   156|      *
   157|      * @param string $attribute The attribute, ('target' or 'rel')
   158|      * @param string $value The value of the attribute to add
   159|      * @param string $content The content to parse
   160|      * @return string
   161|      */
   162|     private static function setAttribute(string $attribute, string $value, string $content): string
   163|     {
   164|         if (\preg_match_all('~\s+' . $attribute . '="(.*?)~i', $content, $matches)) {
   165|             if ($attribute === 'target' || \preg_match('~' . $attribute . '=".*?' . $value . '.*?"~i', $content)) {
   166|                 return $content;
   167|             }
   168|             return \preg_replace('/' . $attribute . '="(.*?)"/', sprintf('%s="$1 %s"', $attribute, $value), $content);
   169|         }
   170|         return \str_replace('<a', sprintf('<a %s="%s"', $attribute, $value), $content);
   171|     }
   172| }


# ====================================================================
# FILE: Neos.Neos/Classes/Routing/Cache/RouteCacheFlusher.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-83 ---
     1| <?php
     2| namespace Neos\Neos\Routing\Cache;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Flow\Mvc\Routing\RouterCachingService;
    14| use Neos\ContentRepository\Domain\Model\NodeInterface;
    15| use Neos\ContentRepository\Domain\Model\Workspace;
    16| /**
    17|  * This service flushes Route caches triggered by node changes.
    18|  *
    19|  * @Flow\Scope("singleton")
    20|  */
    21| class RouteCacheFlusher
    22| {
    23|     /**
    24|      * @Flow\Inject
    25|      * @var RouterCachingService
    26|      */
    27|     protected $routeCachingService;
    28|     /**
    29|      * @var array
    30|      */
    31|     protected $tagsToFlush = [];
    32|     /**
    33|      * Schedules flushing of the routing cache entries for the given $node
    34|      * Note that child nodes are flushed automatically because they are tagged with all parents.
    35|      *
    36|      * @param NodeInterface $node The node which has changed in some way
    37|      * @return void
    38|      */
    39|     public function registerNodeChange(NodeInterface $node)
    40|     {
    41|         if (in_array($node->getIdentifier(), $this->tagsToFlush)) {
    42|             return;
    43|         }
    44|         if (!$node->getNodeType()->isOfType('Neos.Neos:Document')) {
    45|             return;
    46|         }
    47|         $this->tagsToFlush[] = $node->getIdentifier();
    48|     }
    49|     /**
    50|      * Schedules flushing of the all routing cache entries of the workspace whose base workspace has changed.
    51|      * In most cases $workspace will be a user's personal workspace. Flushing the respective cache entries guards
    52|      * against mismatches for nodes which exist in the old and the new base workspace but have different node
    53|      * identifiers and the same URI path (segment).
    54|      *
    55|      * @param Workspace $workspace
    56|      * @param Workspace|null $oldBaseWorkspace
    57|      * @param Workspace|null $newBaseWorkspace
    58|      * @return void
    59|      */
    60|     public function registerBaseWorkspaceChange(Workspace $workspace, Workspace $oldBaseWorkspace = null, Workspace $newBaseWorkspace = null)
    61|     {
    62|         if (!in_array($workspace->getName(), $this->tagsToFlush)) {
    63|             $this->tagsToFlush[] = $workspace->getName();
    64|         }
    65|     }
    66|     /**
    67|      * Flush caches according to the previously registered node changes.
    68|      *
    69|      * @return void
    70|      */
    71|     public function commit()
    72|     {
    73|         $this->routeCachingService->flushCachesByTags($this->tagsToFlush);
    74|         $this->tagsToFlush = [];
    75|     }
    76|     /**
    77|      * @return void
    78|      */
    79|     public function shutdownObject()
    80|     {
    81|         $this->commit();
    82|     }
    83| }


# ====================================================================
# FILE: Neos.Neos/Classes/Security/ImpersonateAspect.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-60 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Neos\Security;
     4| /*
     5|  * This file is part of the Neos.Neos package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\Aop\JoinPointInterface;
    15| use Neos\Flow\Security\Authentication\AuthenticationManagerInterface;
    16| use Neos\Neos\Service\ImpersonateService;
    17| /**
    18|  * An aspect which centralizes the logging of security relevant actions.
    19|  *
    20|  * @Flow\Scope("singleton")
    21|  * @Flow\Aspect
    22|  */
    23| class ImpersonateAspect
    24| {
    25|     /**
    26|      * @var bool
    27|      */
    28|     protected bool $alreadyLoggedAuthenticateCall = false;
    29|     /**
    30|      * @var ImpersonateService
    31|      * @Flow\Inject
    32|      */
    33|     protected $impersonateService;
    34|     /**
    35|      * @Flow\After("within(Neos\Flow\Security\Authentication\AuthenticationManagerInterface) && method(.*->authenticate())")
    36|      * @param JoinPointInterface $joinPoint The current joinpoint
    37|      * @return void
    38|      * @throws \Exception
    39|      */
    40|     public function logManagerAuthenticate(JoinPointInterface $joinPoint): void
    41|     {
    42|         /** @var AuthenticationManagerInterface $proxy */
    43|         $proxy = $joinPoint->getProxy();
    44|         if ($this->alreadyLoggedAuthenticateCall === true) {
    45|             $this->alreadyLoggedAuthenticateCall = true;
    46|             return;
    47|         }
    48|         if ($proxy->getSecurityContext()->getAccount() === null) {
    49|             $this->alreadyLoggedAuthenticateCall = true;
    50|             return;
    51|         }
    52|         if ($this->impersonateService && $this->impersonateService->isActive()) {
    53|             $impersonation = $this->impersonateService->getImpersonation();
    54|             foreach ($proxy->getSecurityContext()->getAuthenticationTokens() as $token) {
    55|                 $token->setAccount($impersonation);
    56|             }
    57|         }
    58|         $this->alreadyLoggedAuthenticateCall = true;
    59|     }
    60| }


# ====================================================================
# FILE: Neos.Neos/Classes/Service/Controller/NodeController.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-399 ---
     1| <?php
     2| namespace Neos\Neos\Service\Controller;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Eel\FlowQuery\FlowQuery;
    14| use Neos\Flow\Http\Helper\SecurityHelper;
    15| use Neos\Flow\Property\TypeConverter\PersistentObjectConverter;
    16| use Neos\Neos\Domain\Repository\DomainRepository;
    17| use Neos\Neos\Domain\Service\NodeSearchServiceInterface;
    18| use Neos\Neos\Service\NodeOperations;
    19| use Neos\Neos\Service\View\NodeView;
    20| use Neos\ContentRepository\Domain\Factory\NodeFactory;
    21| use Neos\ContentRepository\Domain\Model\NodeInterface;
    22| use Neos\ContentRepository\Domain\Model\Node;
    23| use Neos\ContentRepository\Domain\Repository\NodeDataRepository;
    24| use Neos\ContentRepository\Domain\Service\ContextFactoryInterface;
    25| use Neos\ContentRepository\Domain\Service\NodeTypeManager;
    26| use Neos\ContentRepository\Exception\NodeException;
    27| use Neos\ContentRepository\TypeConverter\NodeConverter;
    28| /**
    29|  * Service Controller for managing Nodes
    30|  *
    31|  * Note: This controller should be, step-by-step, transformed into a clean REST controller (see NEOS-190 and NEOS-199).
    32|  *       Since this is a rather big endeavor, we slice the elephant and move methods in a clean way from here to the
    33|  *       new NodesController (\Neos\Neos\Controller\Service\NodesController)
    34|  */
    35| class NodeController extends AbstractServiceController
    36| {
    37|     /**
    38|      * @var NodeView
    39|      */
    40|     protected $view;
    41|     /**
    42|      * @var array
    43|      */
    44|     protected $viewFormatToObjectNameMap = [
    45|         'html' => NodeView::class,
    46|         'json' => NodeView::class
    47|     ];
    48|     /**
    49|      * @var array
    50|      */
    51|     protected $supportedMediaTypes = [
    52|         'text/html',
    53|         'application/json'
    54|     ];
    55|     /**
    56|      * @Flow\Inject
    57|      * @var NodeTypeManager
    58|      */
    59|     protected $nodeTypeManager;
    60|     /**
    61|      * @Flow\Inject
    62|      * @var NodeSearchServiceInterface
    63|      */
    64|     protected $nodeSearchService;
    65|     /**
    66|      * @Flow\Inject
    67|      * @var NodeFactory
    68|      */
    69|     protected $nodeFactory;
    70|     /**
    71|      * @Flow\Inject
    72|      * @var ContextFactoryInterface
    73|      */
    74|     protected $contextFactory;
    75|     /**
    76|      * @Flow\Inject
    77|      * @var NodeDataRepository
    78|      */
    79|     protected $nodeDataRepository;
    80|     /**
    81|      * @Flow\Inject
    82|      * @var NodeOperations
    83|      */
    84|     protected $nodeOperations;
    85|     /**
    86|      * @Flow\Inject
    87|      * @var DomainRepository
    88|      */
    89|     protected $domainRepository;
    90|     /**
    91|      * Select special error action
    92|      *
    93|      * @return void
    94|      */
    95|     protected function initializeAction()
    96|     {
    97|         if ($this->arguments->hasArgument('referenceNode')) {
    98|             $this->arguments->getArgument('referenceNode')->getPropertyMappingConfiguration()->setTypeConverterOption(NodeConverter::class, NodeConverter::REMOVED_CONTENT_SHOWN, true);
    99|         }
   100|         $this->uriBuilder->setRequest($this->request->getMainRequest());
   101|         if (in_array($this->request->getControllerActionName(), ['update', 'updateAndRender'], true)) {
   102|             $propertyMappingConfiguration = $this->arguments->getArgument('node')->getPropertyMappingConfiguration();
   103|             $propertyMappingConfiguration->allowOverrideTargetType();
   104|             $propertyMappingConfiguration->allowAllProperties();
   105|             $propertyMappingConfiguration->skipUnknownProperties();
   106|             $propertyMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_MODIFICATION_ALLOWED, true);
   107|             $propertyMappingConfiguration->setTypeConverterOption(PersistentObjectConverter::class, PersistentObjectConverter::CONFIGURATION_CREATION_ALLOWED, true);
   108|         }
   109|     }
   110|     /**
   111|      * Return child nodes of specified node for usage in a TreeLoader
   112|      *
   113|      * @param Node $node The node to find child nodes for
   114|      * @param string $nodeTypeFilter A node type filter
   115|      * @param integer $depth levels of childNodes (0 = unlimited)
   116|      * @param Node $untilNode expand the child nodes until $untilNode is reached, independent of $depth
   117|      * @return void
   118|      */
   119|     public function getChildNodesForTreeAction(Node $node, $nodeTypeFilter, $depth, Node $untilNode)
   120|     {
   121|         $this->view->assignChildNodes($node, $nodeTypeFilter, NodeView::STYLE_TREE, $depth, $untilNode);
   122|     }
   123|     /**
   124|      * Return child nodes of specified node for usage in a TreeLoader based on filter
   125|      *
   126|      * @param Node $node The node to find child nodes for
   127|      * @param string $term
   128|      * @param string $nodeType
   129|      * @return void
   130|      */
   131|     public function filterChildNodesForTreeAction(Node $node, $term, $nodeType)
   132|     {
   133|         $nodeTypes = strlen($nodeType) > 0 ? [$nodeType] : array_keys($this->nodeTypeManager->getSubNodeTypes('Neos.Neos:Document', false));
   134|         $context = $node->getContext();
   135|         if ($term !== '') {
   136|             $nodes = $this->nodeSearchService->findByProperties($term, $nodeTypes, $context, $node);
   137|         } else {
   138|             $nodes = [];
   139|             $nodeDataRecords = $this->nodeDataRepository->findByParentAndNodeTypeRecursively($node->getPath(), implode(',', $nodeTypes), $context->getWorkspace(), $context->getDimensions());
   140|             foreach ($nodeDataRecords as $nodeData) {
   141|                 $matchedNode = $this->nodeFactory->createFromNodeData($nodeData, $context);
   142|                 if ($matchedNode !== null) {
   143|                     $nodes[$matchedNode->getPath()] = $matchedNode;
   144|                 }
   145|             }
   146|         }
   147|         $this->view->assignFilteredChildNodes(
   148|             $node,
   149|             $nodes
   150|         );
   151|     }
   152|     /**
   153|      * Creates a new node
   154|      *
   155|      * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
   156|      * because they might be connected to images / resources which need to be updated at the same time.
   157|      *
   158|      * @param Node $referenceNode
   159|      * @param array $nodeData
   160|      * @param string $position where the node should be added (allowed: before, into, after)
   161|      * @return void
   162|      */
   163|     public function createAction(Node $referenceNode, array $nodeData, $position)
   164|     {
   165|         $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
   166|         if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
   167|             $this->persistenceManager->persistAll();
   168|         }
   169|         $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $newNode], 'Frontend\Node', 'Neos.Neos');
   170|         $this->view->assign('value', ['data' => ['nextUri' => $nextUri], 'success' => true]);
   171|     }
   172|     /**
   173|      * Creates a new node and renders the node inside the containing content collection.
   174|      *
   175|      * @param Node $referenceNode
   176|      * @param string $fusionPath The Fusion path of the collection
   177|      * @param array $nodeData
   178|      * @param string $position where the node should be added (allowed: before, into, after)
   179|      * @return string
   180|      */
   181|     public function createAndRenderAction(Node $referenceNode, $fusionPath, array $nodeData, $position)
   182|     {
   183|         $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
   184|         $this->redirectToRenderNode($newNode, $fusionPath);
   185|     }
   186|     /**
   187|      * Creates a new node and returns tree structure
   188|      *
   189|      * @param Node $referenceNode
   190|      * @param array $nodeData
   191|      * @param string $position where the node should be added, -1 is before, 0 is in, 1 is after
   192|      * @param string $nodeTypeFilter
   193|      * @return void
   194|      */
   195|     public function createNodeForTheTreeAction(Node $referenceNode, array $nodeData, $position, $nodeTypeFilter = '')
   196|     {
   197|         $newNode = $this->nodeOperations->create($referenceNode, $nodeData, $position);
   198|         $this->view->assignNodeAndChildNodes($newNode, $nodeTypeFilter);
   199|     }
   200|     /**
   201|      * Move $node before, into or after $targetNode
   202|      *
   203|      * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
   204|      * because they might be connected to images / resources which need to be updated at the same time.
   205|      *
   206|      * @param Node $node The node to be moved
   207|      * @param Node $targetNode The target node to be moved "to", see $position
   208|      * @param string $position where the node should be added (allowed: before, into, after)
   209|      * @return void
   210|      */
   211|     public function moveAction(Node $node, Node $targetNode, $position)
   212|     {
   213|         $node = $this->nodeOperations->move($node, $targetNode, $position);
   214|         if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
   215|             $this->persistenceManager->persistAll();
   216|         }
   217|         $data = ['newNodePath' => $node->getContextPath()];
   218|         if ($node->getNodeType()->isOfType('Neos.Neos:Document')) {
   219|             $data['nextUri'] = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $node], 'Frontend\Node', 'Neos.Neos');
   220|         }
   221|         $this->view->assign('value', ['data' => $data, 'success' => true]);
   222|     }
   223|     /**
   224|      * Move the given node before, into or after the target node depending on the given position and renders it's content collection.
   225|      *
   226|      * @param Node $node The node to be moved
   227|      * @param Node $targetNode The target node to be moved "to", see $position
   228|      * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
   229|      * @param string $fusionPath The Fusion path of the collection
   230|      * @return void
   231|      */
   232|     public function moveAndRenderAction(Node $node, Node $targetNode, $position, $fusionPath)
   233|     {
   234|         $this->nodeOperations->move($node, $targetNode, $position);
   235|         $this->redirectToRenderNode($node, $fusionPath);
   236|     }
   237|     /**
   238|      * Copy $node before, into or after $targetNode
   239|      *
   240|      * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
   241|      * because they might be connected to images / resources which need to be updated at the same time.
   242|      *
   243|      * @param Node $node The node to be copied
   244|      * @param Node $targetNode The target node to be copied "to", see $position
   245|      * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
   246|      * @param string $nodeName Optional node name (if empty random node name will be generated)
   247|      * @return void
   248|      * @throws NodeException
   249|      */
   250|     public function copyAction(Node $node, Node $targetNode, $position, $nodeName = null)
   251|     {
   252|         $copiedNode = $this->nodeOperations->copy($node, $targetNode, $position, $nodeName);
   253|         if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
   254|             $this->persistenceManager->persistAll();
   255|         }
   256|         $q = new FlowQuery([$copiedNode]);
   257|         $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
   258|         $requestData = [
   259|             'nextUri' => $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos'),
   260|             'newNodePath' => $copiedNode->getContextPath()
   261|         ];
   262|         if ($node->getNodeType()->isOfType('Neos.Neos:Document')) {
   263|             $requestData['nodeUri'] = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $copiedNode], 'Frontend\Node', 'Neos.Neos');
   264|         }
   265|         $this->view->assign('value', ['data' => $requestData, 'success' => true]);
   266|     }
   267|     /**
   268|      * Copies the given node before, into or after the target node depending on the given position and renders it's content collection.
   269|      *
   270|      * @param Node $node The node to be copied
   271|      * @param Node $targetNode The target node to be copied "to", see $position
   272|      * @param string $position Where the node should be added in relation to $targetNode (allowed: before, into, after)
   273|      * @param string $nodeName Optional node name (if empty random node name will be generated)
   274|      * @param string $fusionPath The Fusion path of the collection
   275|      * @return void
   276|      */
   277|     public function copyAndRenderAction(Node $node, Node $targetNode, $position, $fusionPath, $nodeName = null)
   278|     {
   279|         $copiedNode = $this->nodeOperations->copy($node, $targetNode, $position, $nodeName);
   280|         $this->redirectToRenderNode($copiedNode, $fusionPath);
   281|     }
   282|     /**
   283|      * Updates the specified node.
   284|      *
   285|      * Returns the following data:
   286|      *
   287|      * - the (possibly changed) workspace name of the node
   288|      * - the URI of the closest document node. If $node is a document node (f.e. a Page), the own URI is returned.
   289|      *   This is important to handle renames of nodes correctly.
   290|      *
   291|      * Note: We do not call $nodeDataRepository->update() here, as ContentRepository has a stateful API for now.
   292|      *       We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
   293|      *       because they might be connected to images / resources which need to be updated at the same time.
   294|      *
   295|      * @param Node $node The node to be updated
   296|      * @return void
   297|      */
   298|     public function updateAction(Node $node)
   299|     {
   300|         if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
   301|             $this->persistenceManager->persistAll();
   302|         }
   303|         $q = new FlowQuery([$node]);
   304|         $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
   305|         $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos');
   306|         $this->view->assign('value', [
   307|             'data' => [
   308|                 'workspaceNameOfNode' => $node->getWorkspace()->getName(),
   309|                 'labelOfNode' => $node->getLabel(),
   310|                 'nextUri' => $nextUri
   311|             ],
   312|             'success' => true
   313|         ]);
   314|     }
   315|     /**
   316|      * Updates the specified node and renders it's content collection.
   317|      *
   318|      * @param Node $node The node to be updated
   319|      * @param string $fusionPath The Fusion path of the collection
   320|      * @return void
   321|      */
   322|     public function updateAndRenderAction(Node $node, $fusionPath)
   323|     {
   324|         $this->redirectToRenderNode($node, $fusionPath);
   325|     }
   326|     /**
   327|      * Deletes the specified node and all of its sub nodes
   328|      *
   329|      * We need to call persistAll() in order to return the nextUri. We can't persist only the nodes in NodeDataRepository
   330|      * because they might be connected to images / resources which need to be removed at the same time.
   331|      *
   332|      * @param Node $node
   333|      * @return void
   334|      */
   335|     public function deleteAction(Node $node)
   336|     {
   337|         if (SecurityHelper::hasSafeMethod($this->request->getHttpRequest()) === false) {
   338|             $this->persistenceManager->persistAll();
   339|         }
   340|         $q = new FlowQuery([$node]);
   341|         $node->remove();
   342|         $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
   343|         $nextUri = $this->uriBuilder->reset()->setFormat('html')->setCreateAbsoluteUri(true)->uriFor('show', ['node' => $closestDocumentNode], 'Frontend\Node', 'Neos.Neos');
   344|         $this->view->assign('value', ['data' => ['nextUri' => $nextUri], 'success' => true]);
   345|     }
   346|     /**
   347|      * Takes care of creating a redirect to properly render the collection the given node is in.
   348|      *
   349|      * @param NodeInterface $node
   350|      * @param string $fusionPath
   351|      * @return string
   352|      */
   353|     protected function redirectToRenderNode(NodeInterface $node, $fusionPath)
   354|     {
   355|         $q = new FlowQuery([$node]);
   356|         $closestContentCollection = $q->closest('[instanceof Neos.Neos:ContentCollection]')->get(0);
   357|         $closestDocumentNode = $q->closest('[instanceof Neos.Neos:Document]')->get(0);
   358|         $this->redirect('show', 'Frontend\\Node', 'Neos.Neos', [
   359|             'node' => $closestDocumentNode,
   360|             '__nodeContextPath' => $closestContentCollection->getContextPath(),
   361|             '__affectedNodeContextPath' => $node->getContextPath(),
   362|             '__fusionPath' => $fusionPath
   363|         ], 0, 303, 'html');
   364|     }
   365|     /**
   366|      * Returns an array with the data needed by for example the frontend editing
   367|      * link plugins to represent the passed Node instance.
   368|      *
   369|      * @param NodeInterface $node
   370|      * @return array
   371|      */
   372|     protected function processNodeForEditorPlugins(NodeInterface $node)
   373|     {
   374|         return [
   375|             'id' => $node->getPath(),
   376|             'name' => $node->getLabel(),
   377|             'url' => $this->uriBuilder->uriFor('show', ['node' => $node], 'Frontend\Node', 'Neos.Neos'),
   378|             'type' => 'neos/internal-link'
   379|         ];
   380|     }
   381|     /**
   382|      * Create a Context for a workspace given by name to be used in this controller.
   383|      *
   384|      * @param string $workspaceName Name of the current workspace
   385|      * @return \Neos\ContentRepository\Domain\Service\Context
   386|      */
   387|     protected function createContext($workspaceName)
   388|     {
   389|         $contextProperties = [
   390|             'workspaceName' => $workspaceName
   391|         ];
   392|         $currentDomain = $this->domainRepository->findOneByActiveRequest();
   393|         if ($currentDomain !== null) {
   394|             $contextProperties['currentSite'] = $currentDomain->getSite();
   395|             $contextProperties['currentDomain'] = $currentDomain;
   396|         }
   397|         return $this->contextFactory->create($contextProperties);
   398|     }
   399| }


# ====================================================================
# FILE: Neos.Neos/Classes/Service/ImpersonateService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-157 ---
     1| <?php
     2| declare(strict_types=1);
     3| namespace Neos\Neos\Service;
     4| /*
     5|  * This file is part of the Neos.Neos package.
     6|  *
     7|  * (c) Contributors of the Neos Project - www.neos.io
     8|  *
     9|  * This package is Open Source Software. For the full copyright and license
    10|  * information, please view the LICENSE file which was distributed with this
    11|  * source code.
    12|  */
    13| use Neos\Flow\Annotations as Flow;
    14| use Neos\Flow\Persistence\PersistenceManagerInterface;
    15| use Neos\Flow\Security\Account;
    16| use Neos\Flow\Security\Context;
    17| use Neos\Flow\Security\Policy\PolicyService;
    18| use Neos\Flow\Session\Exception\SessionNotStartedException;
    19| use Neos\Flow\Session\SessionInterface;
    20| /**
    21|  * Impersonate Service
    22|  */
    23| class ImpersonateService
    24| {
    25|     /**
    26|      * @var Context
    27|      * @Flow\Inject
    28|      */
    29|     protected $securityContext;
    30|     /**
    31|      * @var SessionInterface
    32|      * @Flow\Inject
    33|      */
    34|     protected $session;
    35|     /**
    36|      * @var PersistenceManagerInterface
    37|      * @Flow\Inject
    38|      */
    39|     protected $persistenceManager;
    40|     /**
    41|      * @var PolicyService
    42|      * @Flow\Inject
    43|      */
    44|     protected $policyService;
    45|     /**
    46|      * @param Account $account
    47|      * @return void
    48|      * @throws SessionNotStartedException
    49|      */
    50|     public function impersonate(Account $account): void
    51|     {
    52|         $currentAccount = $this->securityContext->getAccount();
    53|         $this->writeSession('OriginalIdentity', $this->persistenceManager->getIdentifierByObject($currentAccount));
    54|         $this->refreshTokens($account);
    55|         $this->writeSession('Impersonate', $this->persistenceManager->getIdentifierByObject($account));
    56|     }
    57|     /**
    58|      * @return void
    59|      * @throws SessionNotStartedException
    60|      */
    61|     public function restoreOriginalIdentity(): void
    62|     {
    63|         $account = $this->getOriginalIdentity();
    64|         $this->refreshTokens($account);
    65|         $this->writeSession('Impersonate', null);
    66|     }
    67|     /**
    68|      * @return Account|null
    69|      * @throws SessionNotStartedException
    70|      */
    71|     public function getImpersonation(): ?Account
    72|     {
    73|         $impersonation = $this->getSessionData('Impersonate');
    74|         if ($impersonation !== null) {
    75|             return $this->persistenceManager->getObjectByIdentifier($impersonation, Account::class);
    76|         }
    77|         return null;
    78|     }
    79|     /**
    80|      * @return bool
    81|      * @throws SessionNotStartedException
    82|      */
    83|     public function isActive(): bool
    84|     {
    85|         return $this->getImpersonation() instanceof Account;
    86|     }
    87|     /**
    88|      * @return Account|null
    89|      */
    90|     public function getCurrentUser(): ?Account
    91|     {
    92|         return $this->securityContext->getAccount();
    93|     }
    94|     /**
    95|      * @return Account|null
    96|      * @throws SessionNotStartedException
    97|      */
    98|     public function getOriginalIdentity(): ?Account
    99|     {
   100|         $originalIdentity = $this->getSessionData('OriginalIdentity');
   101|         if ($originalIdentity !== null) {
   102|             return $this->persistenceManager->getObjectByIdentifier($originalIdentity, Account::class);
   103|         }
   104|         return $this->securityContext->getAccount();
   105|     }
   106|     /**
   107|      * @return array
   108|      * @throws SessionNotStartedException
   109|      */
   110|     public function getOriginalIdentityRoles(): array
   111|     {
   112|         $originalAccount = $this->getOriginalIdentity();
   113|         $roles = $originalAccount ? $originalAccount->getRoles() : [];
   114|         foreach ($roles as $role) {
   115|             foreach ($this->policyService->getAllParentRoles($role) as $parentRole) {
   116|                 if (!in_array($parentRole, $roles, true)) {
   117|                     $roles[$parentRole->getIdentifier()] = $parentRole;
   118|                 }
   119|             }
   120|         }
   121|         return $roles;
   122|     }
   123|     /**
   124|      * @param Account|null $account
   125|      * @return void
   126|      */
   127|     protected function refreshTokens(Account $account = null): void
   128|     {
   129|         if ($account === null) {
   130|             return;
   131|         }
   132|         $tokens = $this->securityContext->getAuthenticationTokens();
   133|         foreach ($tokens as $token) {
   134|             $token->setAccount($account);
   135|         }
   136|     }
   137|     /**
   138|      * @param string $key
   139|      * @param string|null $value
   140|      * @return void
   141|      * @throws SessionNotStartedException
   142|      */
   143|     protected function writeSession(string $key, ?string $value): void
   144|     {
   145|         if ($this->session->isStarted()) {
   146|             $this->session->putData($key, $value);
   147|         }
   148|     }
   149|     /**
   150|      * @param string $key
   151|      * @throws SessionNotStartedException
   152|      */
   153|     protected function getSessionData(string $key): mixed
   154|     {
   155|         return $this->session->isStarted() && $this->session->hasKey($key) ? $this->session->getData($key) : null;
   156|     }
   157| }


# ====================================================================
# FILE: Neos.Neos/Classes/Service/NodeTypeSchemaBuilder.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-98 ---
     1| <?php
     2| namespace Neos\Neos\Service;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\ContentRepository\Domain\Model\NodeType;
    14| /**
    15|  * Renders the Node Type Schema in a format the User Interface understands; additionally pre-calculating node constraints
    16|  *
    17|  * @Flow\Scope("singleton")
    18|  */
    19| class NodeTypeSchemaBuilder
    20| {
    21|     /**
    22|      * @Flow\Inject
    23|      * @var \Neos\ContentRepository\Domain\Service\NodeTypeManager
    24|      */
    25|     protected $nodeTypeManager;
    26|     /**
    27|      * The preprocessed node type schema contains everything we need for the UI:
    28|      *
    29|      * - "nodeTypes" contains the original (merged) node type schema
    30|      * - "inheritanceMap.subTypes" contains for every parent type the transitive list of subtypes
    31|      * - "constraints" contains for each node type, the list of allowed child node types; normalizing
    32|      *   allowlists and excludelists:
    33|      *   - [node type]
    34|      *     - nodeTypes:
    35|      *       [child node type name]: true
    36|      *     - childNodes:
    37|      *       - [child node name]
    38|      *         - nodeTypes:
    39|      *          [child node type name]: true
    40|      *
    41|      * @return array the node type schema ready to be used by the JavaScript code
    42|      */
    43|     public function generateNodeTypeSchema()
    44|     {
    45|         $schema = [
    46|             'inheritanceMap' => [
    47|                 'subTypes' => []
    48|             ],
    49|             'nodeTypes' => [],
    50|             'constraints' => $this->generateConstraints()
    51|         ];
    52|         $nodeTypes = $this->nodeTypeManager->getNodeTypes(true);
    53|         /** @var NodeType $nodeType */
    54|         foreach ($nodeTypes as $nodeTypeName => $nodeType) {
    55|             if ($nodeType->isAbstract() === false) {
    56|                 $configuration = $nodeType->getFullConfiguration();
    57|                 $schema['nodeTypes'][$nodeTypeName] = $configuration;
    58|                 $schema['nodeTypes'][$nodeTypeName]['label'] = $nodeType->getLabel();
    59|             }
    60|             $schema['inheritanceMap']['subTypes'][$nodeTypeName] = [];
    61|             foreach ($this->nodeTypeManager->getSubNodeTypes($nodeType->getName(), true) as $subNodeType) {
    62|                 /** @var NodeType $subNodeType */
    63|                 $schema['inheritanceMap']['subTypes'][$nodeTypeName][] = $subNodeType->getName();
    64|             }
    65|         }
    66|         return $schema;
    67|     }
    68|     /**
    69|      * Generate the list of allowed sub-node-types per parent-node-type and child-node-name.
    70|      *
    71|      * @return array constraints
    72|      */
    73|     protected function generateConstraints()
    74|     {
    75|         $constraints = [];
    76|         $nodeTypes = $this->nodeTypeManager->getNodeTypes(true);
    77|         /** @var NodeType $nodeType */
    78|         foreach ($nodeTypes as $nodeTypeName => $nodeType) {
    79|             $constraints[$nodeTypeName] = [
    80|                 'nodeTypes' => [],
    81|                 'childNodes' => []
    82|             ];
    83|             foreach ($nodeTypes as $innerNodeTypeName => $innerNodeType) {
    84|                 if ($nodeType->allowsChildNodeType($innerNodeType)) {
    85|                     $constraints[$nodeTypeName]['nodeTypes'][$innerNodeTypeName] = true;
    86|                 }
    87|             }
    88|             foreach ($nodeType->getAutoCreatedChildNodes() as $key => $_x) {
    89|                 foreach ($nodeTypes as $innerNodeTypeName => $innerNodeType) {
    90|                     if ($nodeType->allowsGrandchildNodeType($key, $innerNodeType)) {
    91|                         $constraints[$nodeTypeName]['childNodes'][$key]['nodeTypes'][$innerNodeTypeName] = true;
    92|                     }
    93|                 }
    94|             }
    95|         }
    96|         return $constraints;
    97|     }
    98| }


# ====================================================================
# FILE: Neos.Neos/Classes/Service/UserService.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-116 ---
     1| <?php
     2| namespace Neos\Neos\Service;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Neos\Domain\Model\User;
    14| use Neos\ContentRepository\Domain\Model\Workspace;
    15| use Neos\ContentRepository\Domain\Repository\WorkspaceRepository;
    16| use Neos\Neos\Utility\User as UserUtility;
    17| /**
    18|  * The user service provides general context information about the currently
    19|  * authenticated backend user.
    20|  *
    21|  * The methods getters of this class are accessible via the "context.userInformation" variable in security policies
    22|  * and thus are implicitly considered to be part of the public API. This UserService should be replaced by
    23|  * \Neos\Neos\Domain\Service\UserService in the long run.
    24|  *
    25|  * @Flow\Scope("singleton")
    26|  * @api
    27|  */
    28| class UserService
    29| {
    30|     /**
    31|      * @Flow\Inject
    32|      * @var \Neos\Neos\Domain\Service\UserService
    33|      */
    34|     protected $userDomainService;
    35|     /**
    36|      * @Flow\Inject
    37|      * @var WorkspaceRepository
    38|      */
    39|     protected $workspaceRepository;
    40|     /**
    41|      * @Flow\InjectConfiguration("userInterface.defaultLanguage")
    42|      * @var string
    43|      */
    44|     protected $defaultLanguageIdentifier;
    45|     /**
    46|      * @Flow\Inject
    47|      * @var \Neos\Flow\Security\Context
    48|      */
    49|     protected $securityContext;
    50|     /**
    51|      * Returns the current backend user
    52|      *
    53|      * @return ?User
    54|      * @api
    55|      */
    56|     public function getBackendUser()
    57|     {
    58|         return $this->userDomainService->getCurrentUser();
    59|     }
    60|     /**
    61|      * Returns the current user's personal workspace or null if no user is logged in
    62|      *
    63|      * @return Workspace
    64|      * @api
    65|      */
    66|     public function getPersonalWorkspace()
    67|     {
    68|         $workspaceName = $this->getPersonalWorkspaceName();
    69|         if ($workspaceName !== null) {
    70|             return $this->workspaceRepository->findOneByName($workspaceName);
    71|         }
    72|     }
    73|     /**
    74|      * Returns the name of the currently logged in user's personal workspace (even if that might not exist at that time).
    75|      * If no user is logged in this method returns null.
    76|      *
    77|      * @return string
    78|      * @api
    79|      */
    80|     public function getPersonalWorkspaceName()
    81|     {
    82|         $currentUser = $this->userDomainService->getCurrentUser();
    83|         if (!$currentUser instanceof User) {
    84|             return null;
    85|         }
    86|         $username = $this->userDomainService->getUsername(
    87|             $currentUser,
    88|             $this->securityContext->getAccount()->getAuthenticationProviderName()
    89|         );
    90|         return ($username === null ? null : UserUtility::getPersonalWorkspaceNameForUsername($username));
    91|     }
    92|     /**
    93|      * Returns the stored preferences of a user
    94|      *
    95|      * @param string $preference
    96|      * @return mixed
    97|      * @api
    98|      */
    99|     public function getUserPreference($preference)
   100|     {
   101|         $user = $this->getBackendUser();
   102|         if ($user && $user->getPreferences()) {
   103|             return $user->getPreferences()->get($preference) ?: null;
   104|         }
   105|     }
   106|     /**
   107|      * Returns the interface language the user selected. Will fall back to the default language defined in settings
   108|      *
   109|      * @return string
   110|      * @api
   111|      */
   112|     public function getInterfaceLanguage()
   113|     {
   114|         return $this->getUserPreference('interfaceLanguage') ?: $this->defaultLanguageIdentifier;
   115|     }
   116| }


# ====================================================================
# FILE: Neos.Neos/Classes/ViewHelpers/Backend/ConfigurationCacheVersionViewHelper.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-48 ---
     1| <?php
     2| namespace Neos\Neos\ViewHelpers\Backend;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| use Neos\Flow\Annotations as Flow;
    13| use Neos\Cache\Frontend\StringFrontend;
    14| use Neos\Flow\Security\Context;
    15| use Neos\FluidAdaptor\Core\ViewHelper\AbstractViewHelper;
    16| /**
    17|  * ViewHelper for rendering the current version identifier for the
    18|  * configuration cache.
    19|  */
    20| class ConfigurationCacheVersionViewHelper extends AbstractViewHelper
    21| {
    22|     /**
    23|      * @var StringFrontend
    24|      */
    25|     protected $configurationCache;
    26|     /**
    27|      * @Flow\Inject
    28|      * @var Context
    29|      */
    30|     protected $securityContext;
    31|     /**
    32|      * @return string The current cache version identifier
    33|      */
    34|     public function render(): string
    35|     {
    36|         $account = $this->securityContext->getAccount();
    37|         $roles = $account ? array_map(static fn ($role) => $role->getIdentifier(), $account->getRoles()) : [];
    38|         sort($roles);
    39|         $configurationIdentifier = md5(implode('_', $roles));
    40|         $cacheKey = 'ConfigurationVersion_' . $configurationIdentifier;
    41|         $version = $this->configurationCache->get($cacheKey);
    42|         if ($version === false) {
    43|             $version = (string)time();
    44|             $this->configurationCache->set($cacheKey, $version);
    45|         }
    46|         return  $configurationIdentifier . '_' . $version;
    47|     }
    48| }


# ====================================================================
# FILE: Neos.Neos/Documentation/conf.py
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| import os
     2| import sys
     3| from sphinx.highlighting import lexers
     4| from pygments.lexers.web import PhpLexer
     5| project = 'Neos CMS'
     6| copyright = '2006 and onwards by the authors'
     7| author = 'Neos Team and Contributors'
     8| version = 'dev-master'
     9| release = 'dev-master'
    10| extensions = [
    11|     'sphinx_rtd_theme',
    12|     'sphinx.ext.intersphinx',
    13|     'sphinx.ext.todo',
    14|     'sphinx.ext.ifconfig'
    15| ]
    16| templates_path = ['_templates']
    17| exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
    18| highlight_language='php'
    19| html_theme = 'sphinx_rtd_theme'
    20| html_static_path = ['_static']
    21| html_theme_options = {
    22|   'prev_next_buttons_location': 'both',
    23|   'style_external_links': True
    24| }
    25| intersphinx_mapping = {
    26|     'neos': ('https://neos.readthedocs.io/en/stable', None),
    27|     'media': ('https://neos-media.readthedocs.io/en/stable', None),
    28|     'flow': ('https://flowframework.readthedocs.io/en/stable', None),
    29| }
    30| lexers['php'] = PhpLexer(startinline=True)
    31| lexers['php-annotations'] = PhpLexer(startinline=True)


# ====================================================================
# FILE: Neos.Neos/Migrations/Code/Version20220318111600.php
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-31 ---
     1| <?php
     2| namespace Neos\Flow\Core\Migrations;
     3| /*
     4|  * This file is part of the Neos.Neos package.
     5|  *
     6|  * (c) Contributors of the Neos Project - www.neos.io
     7|  *
     8|  * This package is Open Source Software. For the full copyright and license
     9|  * information, please view the LICENSE file which was distributed with this
    10|  * source code.
    11|  */
    12| /**
    13|  * Replace legacy content cache tag definitions in Fusion
    14|  *
    15|  * - Replace legacy NodeType tags with the corresponding eel helper call and the current node as context
    16|  * - Replace legacy DescendantOf tags with the corresponding eel helper call
    17|  * - Replace legacy Node tags with the corresponding eel helper call
    18|  */
    19| class Version20220318111600 extends AbstractMigration
    20| {
    21|     public function getIdentifier(): string
    22|     {
    23|         return 'Neos.Neos-20220318111600';
    24|     }
    25|     public function up(): void
    26|     {
    27|         $this->searchAndReplaceRegex('/(.*) = \$?\{?\'NodeType_(.*)\'\}?/', "$1 = \${Neos.Caching.nodeTypeTag('$2', node)}", ['fusion']);
    28|         $this->searchAndReplaceRegex('/(.*) = \$\{\'Node_\' \+ (.*)\.identifier\}/', "$1 = \${Neos.Caching.nodeTag($2)}", ['fusion']);
    29|         $this->searchAndReplaceRegex('/(.*) = \$\{\'DescendantOf_\' \+ (.*)\.identifier\}/', "$1 = \${Neos.Caching.descendantOfTag($2)}", ['fusion']);
    30|     }
    31| }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Components/TopBar/UserMenu.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-81 ---
     1| import { isNil } from '../../Helper'
     2| import {ApiService} from '../../Services'
     3| import { RestoreButton } from '../../Templates/RestoreButton'
     4| const BASE_PATH = '/neos/impersonate/'
     5| export default class UserMenu {
     6|     constructor(_root) {
     7|         const csfrTokenField = document.querySelector('[data-csrf-token]')
     8|         this._csrfToken = !isNil(csfrTokenField)
     9|             ? csfrTokenField.getAttribute('data-csrf-token')
    10|             : ''
    11|         this._root = _root
    12|         this._apiService = new ApiService(BASE_PATH, this._csrfToken)
    13|         if (!isNil(_root)) {
    14|             this._checkImpersonateStatus()
    15|         }
    16|     }
    17|     _renderRestoreButton(user) {
    18|         const userMenuDropDown = this._root.querySelector('.neos-dropdown-menu')
    19|         if (isNil(userMenuDropDown) || isNil(user)) {
    20|             return false
    21|         }
    22|         const restoreListItem = document.createElement('li')
    23|         restoreListItem.innerHTML = RestoreButton(user)
    24|         userMenuDropDown.appendChild(restoreListItem)
    25|         const restoreButtonElement = userMenuDropDown.querySelector(
    26|             '.restore-user'
    27|         )
    28|         if (!isNil(restoreButtonElement)) {
    29|             restoreButtonElement.addEventListener(
    30|                 'click',
    31|                 this._restoreUser.bind(this)
    32|             )
    33|         }
    34|     }
    35|     _checkImpersonateStatus() {
    36|         const response = this._apiService.callStatus()
    37|         response
    38|             .then((data) => {
    39|                 const { origin, status } = data
    40|                 if (status && !isNil(origin)) {
    41|                     this._renderRestoreButton(origin)
    42|                 }
    43|             })
    44|             .catch(function (error) {
    45|             })
    46|     }
    47|     _restoreUser(event) {
    48|         event.preventDefault()
    49|         const button = event.currentTarget
    50|         if (isNil(button)) {
    51|             return false
    52|         }
    53|         const response = this._apiService.callRestore()
    54|         response
    55|             .then((data) => {
    56|                 const { origin, impersonate, status } = data
    57|                 const message = window.NeosCMS.I18n.translate(
    58|                     'impersonate.success.restoreUser',
    59|                     'Switched back from {0} to the orginal user {1}.',
    60|                     'Neos.Neos',
    61|                     'Main',
    62|                     {
    63|                         0: impersonate.accountIdentifier,
    64|                         1: origin.accountIdentifier,
    65|                     }
    66|                 )
    67|                 window.NeosCMS.Notification.ok(message)
    68|                 window.location.pathname = '/neos'
    69|             })
    70|             .catch(function (error) {
    71|                 if (window.NeosCMS) {
    72|                     const message = window.NeosCMS.I18n.translate(
    73|                         'impersonate.error.restoreUser',
    74|                         'Could not switch back to the original user.',
    75|                         'Neos.Neos'
    76|                     )
    77|                     window.NeosCMS.Notification.error(message)
    78|                 }
    79|             })
    80|     }
    81| }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Components/TopBar/index.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-5 ---
     1| import DropDownMenu from "./DropdownMenu";
     2| import Expandable from "./Expandable";
     3| import MenuPanel from "./MenuPanel";
     4| import UserMenu from "./UserMenu";
     5| export { DropDownMenu, Expandable, MenuPanel, UserMenu };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Interfaces/Window.ts
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-10 ---
     1| import NeosI18n from "./NeosI18n";
     2| import NeosNotification from "./NeosNotification";
     3| import NeosConfiguration from "./NeosConfiguration";
     4| export default interface Window {
     5|   NeosCMS: {
     6|     I18n: NeosI18n;
     7|     Notification: NeosNotification;
     8|     Configuration: NeosConfiguration;
     9|   };
    10| }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Main.min.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2 ---
     1| /*! For license information please see Main.min.js.LICENSE.txt */
     2| (()=>{var e={148:(e,n,r)=>{"use strict";r.r(n),r.d(n,{default:()=>UserMenu});var o=r(586),i=r(912);class UserMenu{constructor(e){const n=document.querySelector("[data-csrf-token]");this._csrfToken=(0,o.isNil)(n)?"":n.getAttribute("data-csrf-token"),this._root=e,this._apiService=new i.sM("/neos/impersonate/",this._csrfToken),(0,o.isNil)(e)||this._checkImpersonateStatus()}_renderRestoreButton(e){const n=this._root.querySelector(".neos-dropdown-menu");if((0,o.isNil)(n)||(0,o.isNil)(e))return!1;const r=document.createElement("li");r.innerHTML=(e=>{const n={class:"neos-button restore-user"};let r="";Object.keys(n).forEach((e=>{r+=`${e}="${n[e]}" `}));const i=(0,o.isNil)(window.NeosCMS)?window.NeosCMS.I18n.translate("impersonate.label.restoreUserButton",'Back to user "{0}"',"Neos.Neos","Main",e.accountIdentifier):`Restore user "${e.accountIdentifier}"`;return`<button ${r}><i class="fas fa-random icon-white"></i> ${i}</button>`})(e),n.appendChild(r);const i=n.querySelector(".restore-user");(0,o.isNil)(i)||i.addEventListener("click",this._restoreUser.bind(this))}_checkImpersonateStatus(){this._apiService.callStatus().then((e=>{const{origin:n,status:r}=e;r&&!(0,o.isNil)(n)&&this._renderRestoreButton(n)})).catch((function(e){}))}_restoreUser(e){e.preventDefault();const n=e.currentTarget;if((0,o.isNil)(n))return!1;this._apiService.callRestore().then((e=>{const{origin:n,impersonate:r,status:o}=e,i=window.NeosCMS.I18n.translate("impersonate.success.restoreUser","Switched back from {0} to the orginal user {1}.","Neos.Neos","Main",{0:r.accountIdentifier,1:n.accountIdentifier});window.NeosCMS.Notification.ok(i),window.location.pathname="/neos"})).catch((function(e){if(window.NeosCMS){const e=window.NeosCMS.I18n.translate("impersonate.error.restoreUser","Could not switch back to the original user.","Neos.Neos");window.NeosCMS.Notification.error(e)}}))}}},791:(e,n,r)=>{"use strict";r.r(n),r.d(n,{loadStorageData:()=>loadStorageData,saveStorageData:()=>saveStorageData});var o=r(586);const i="persistedState",getStorage=()=>{const e=localStorage.getItem(i),n=JSON.parse(e);return(0,o.isNil)(n)?{}:n},loadStorageData=e=>{const n=getStorage();return(0,o.getCollectionValueByPath)(n,e)},saveStorageData=(e,n)=>{const r=getStorage(),a=(0,o.createCollectionByPath)(r,e,n);(0,o.isNil)(a)||localStorage.setItem(i,JSON.stringify(a))}},449:(e,n,r)=>{"use strict";r.d(n,{Z:()=>o});const o={getItem:e=>{try{return JSON.parse(window.sessionStorage.getItem(e))}catch(e){return}},setItem:(e,n)=>{try{window.sessionStorage.setItem(e,JSON.stringify(n))}catch(r){window.sessionStorage.clear(),window.sessionStorage.setItem(e,JSON.stringify(n))}},removeItem:e=>{window.sessionStorage.removeItem(e)}}},912:(e,n,r)=>{"use strict";r.d(n,{sM:()=>ApiService,VK:()=>a,Wt:()=>P,WH:()=>O,P_:()=>c});var o=r(586);const i=!(0,o.isNil)(window.NeosCMS?.Configuration),a={init:()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Configuration)&&(window.NeosCMS.Configuration={});const n=document.querySelector('link[rel="neos-xliff"]');(0,o.isNil)(n)||(window.NeosCMS.Configuration.XliffUri=n.getAttribute("href"))},get:e=>i?(0,o.getCollectionValueByPath)(window.NeosCMS.Configuration,e):null,override:(e,n)=>{i&&e in window.NeosCMS.Configuration&&(window.NeosCMS.Configuration[e]=n)}};var s=r(944),l=r.n(s);const u=["ok","info","notice","warning","error"],_renderNotification=(e,n,r,o)=>{const i={title:e,message:n,...o};u.includes(r)&&(i.type=r),l().create(i)},ok=e=>{_renderNotification(e,"","ok")},info=e=>{_renderNotification(e,"","info")},notice=e=>{_renderNotification(e,"","notice")},warning=(e,n)=>{_renderNotification(e,n,"warning",{timeout:0,closeButton:!0})},error=(e,n)=>{_renderNotification(e,n,"error",{timeout:0,closeButton:!0})},clear=()=>{l().removeAll()},Notification_init=()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Notification)&&(window.NeosCMS.Notification={init:Notification_init,ok,info,notice,warning,error,clear});Array.from(document.querySelectorAll("#neos-notifications-inline li")).forEach((e=>{const n=e.getAttribute("data-type"),r=e.textContent;_renderNotification(r,"",n)}))},c={init:Notification_init,ok,info,notice,warning,error,clear};function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function _typeof(e){return typeof e}:function _typeof(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function _defineProperty(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function _objectSpread(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?Object(arguments[n]):{},o=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(o=o.concat(Object.getOwnPropertySymbols(r).filter((function(e){return Object.getOwnPropertyDescriptor(r,e).enumerable})))),o.forEach((function(n){_defineProperty(e,n,r[n])}))}return e}function _classCallCheck(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,n){for(var r=0;r<n.length;r++){var o=n[r];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function _createClass(e,n,r){return n&&_defineProperties(e.prototype,n),r&&_defineProperties(e,r),e}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _possibleConstructorReturn(e,n){return!n||"object"!==_typeof(n)&&"function"!=typeof n?_assertThisInitialized(e):n}function _getPrototypeOf(e){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function _setPrototypeOf(e,n){return(_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(e,n){return e.__proto__=n,e})(e,n)}function _inherits(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&_setPrototypeOf(e,n)}var d={type:"logger",log:function log(e){this.output("log",e)},warn:function warn(e){this.output("warn",e)},error:function error(e){this.output("error",e)},output:function output(e,n){console&&console[e]&&console[e].apply(console,n)}},p=new(function(){function Logger(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,Logger),this.init(e,n)}return _createClass(Logger,[{key:"init",value:function init(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.prefix=n.prefix||"i18next:",this.logger=e||d,this.options=n,this.debug=n.debug}},{key:"setDebug",value:function setDebug(e){this.debug=e}},{key:"log",value:function log(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"log","",!0)}},{key:"warn",value:function warn(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"warn","",!0)}},{key:"error",value:function error(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"error","")}},{key:"deprecate",value:function deprecate(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return this.forward(n,"warn","WARNING DEPRECATED: ",!0)}},{key:"forward",value:function forward(e,n,r,o){return o&&!this.debug?null:("string"==typeof e[0]&&(e[0]="".concat(r).concat(this.prefix," ").concat(e[0])),this.logger[n](e))}},{key:"create",value:function create(e){return new Logger(this.logger,_objectSpread({},{prefix:"".concat(this.prefix,":").concat(e,":")},this.options))}}]),Logger}()),f=function(){function EventEmitter(){_classCallCheck(this,EventEmitter),this.observers={}}return _createClass(EventEmitter,[{key:"on",value:function on(e,n){var r=this;return e.split(" ").forEach((function(e){r.observers[e]=r.observers[e]||[],r.observers[e].push(n)})),this}},{key:"off",value:function off(e,n){this.observers[e]&&(n?this.observers[e]=this.observers[e].filter((function(e){return e!==n})):delete this.observers[e])}},{key:"emit",value:function emit(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];if(this.observers[e]){var i=[].concat(this.observers[e]);i.forEach((function(e){e.apply(void 0,r)}))}if(this.observers["*"]){var a=[].concat(this.observers["*"]);a.forEach((function(n){n.apply(n,[e].concat(r))}))}}}]),EventEmitter}();function defer(){var e,n,r=new Promise((function(r,o){e=r,n=o}));return r.resolve=e,r.reject=n,r}function makeString(e){return null==e?"":""+e}function copy(e,n,r){e.forEach((function(e){n[e]&&(r[e]=n[e])}))}function getLastOfPath(e,n,r){function cleanKey(e){return e&&e.indexOf("###")>-1?e.replace(/###/g,"."):e}function canNotTraverseDeeper(){return!e||"string"==typeof e}for(var o="string"!=typeof n?[].concat(n):n.split(".");o.length>1;){if(canNotTraverseDeeper())return{};var i=cleanKey(o.shift());!e[i]&&r&&(e[i]=new r),e=Object.prototype.hasOwnProperty.call(e,i)?e[i]:{}}return canNotTraverseDeeper()?{}:{obj:e,k:cleanKey(o.shift())}}function setPath(e,n,r){var o=getLastOfPath(e,n,Object);o.obj[o.k]=r}function getPath(e,n){var r=getLastOfPath(e,n),o=r.obj,i=r.k;if(o)return o[i]}function getPathWithDefaults(e,n,r){var o=getPath(e,r);return void 0!==o?o:getPath(n,r)}function deepExtend(e,n,r){for(var o in n)"__proto__"!==o&&"constructor"!==o&&(o in e?"string"==typeof e[o]||e[o]instanceof String||"string"==typeof n[o]||n[o]instanceof String?r&&(e[o]=n[o]):deepExtend(e[o],n[o],r):e[o]=n[o]);return e}function regexEscape(e){return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")}var h={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;"};function i18next_escape(e){return"string"==typeof e?e.replace(/[&<>"'\/]/g,(function(e){return h[e]})):e}var g="undefined"!=typeof window&&window.navigator&&window.navigator.userAgent&&window.navigator.userAgent.indexOf("MSIE")>-1,m=function(e){function ResourceStore(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{ns:["translation"],defaultNS:"translation"};return _classCallCheck(this,ResourceStore),n=_possibleConstructorReturn(this,_getPrototypeOf(ResourceStore).call(this)),g&&f.call(_assertThisInitialized(n)),n.data=e||{},n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n}return _inherits(ResourceStore,e),_createClass(ResourceStore,[{key:"addNamespaces",value:function addNamespaces(e){this.options.ns.indexOf(e)<0&&this.options.ns.push(e)}},{key:"removeNamespaces",value:function removeNamespaces(e){var n=this.options.ns.indexOf(e);n>-1&&this.options.ns.splice(n,1)}},{key:"getResource",value:function getResource(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=void 0!==o.keySeparator?o.keySeparator:this.options.keySeparator,a=[e,n];return r&&"string"!=typeof r&&(a=a.concat(r)),r&&"string"==typeof r&&(a=a.concat(i?r.split(i):r)),e.indexOf(".")>-1&&(a=e.split(".")),getPath(this.data,a)}},{key:"addResource",value:function addResource(e,n,r,o){var i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{silent:!1},a=this.options.keySeparator;void 0===a&&(a=".");var s=[e,n];r&&(s=s.concat(a?r.split(a):r)),e.indexOf(".")>-1&&(o=n,n=(s=e.split("."))[1]),this.addNamespaces(n),setPath(this.data,s,o),i.silent||this.emit("added",e,n,r,o)}},{key:"addResources",value:function addResources(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{silent:!1};for(var i in r)"string"!=typeof r[i]&&"[object Array]"!==Object.prototype.toString.apply(r[i])||this.addResource(e,n,i,r[i],{silent:!0});o.silent||this.emit("added",e,n,r)}},{key:"addResourceBundle",value:function addResourceBundle(e,n,r,o,i){var a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{silent:!1},s=[e,n];e.indexOf(".")>-1&&(o=r,r=n,n=(s=e.split("."))[1]),this.addNamespaces(n);var l=getPath(this.data,s)||{};o?deepExtend(l,r,i):l=_objectSpread({},l,r),setPath(this.data,s,l),a.silent||this.emit("added",e,n,r)}},{key:"removeResourceBundle",value:function removeResourceBundle(e,n){this.hasResourceBundle(e,n)&&delete this.data[e][n],this.removeNamespaces(n),this.emit("removed",e,n)}},{key:"hasResourceBundle",value:function hasResourceBundle(e,n){return void 0!==this.getResource(e,n)}},{key:"getResourceBundle",value:function getResourceBundle(e,n){return n||(n=this.options.defaultNS),"v1"===this.options.compatibilityAPI?_objectSpread({},{},this.getResource(e,n)):this.getResource(e,n)}},{key:"getDataByLanguage",value:function getDataByLanguage(e){return this.data[e]}},{key:"toJSON",value:function toJSON(){return this.data}}]),ResourceStore}(f),y={processors:{},addPostProcessor:function addPostProcessor(e){this.processors[e.name]=e},handle:function handle(e,n,r,o,i){var a=this;return e.forEach((function(e){a.processors[e]&&(n=a.processors[e].process(n,r,o,i))})),n}},v={},b=function(e){function Translator(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return _classCallCheck(this,Translator),n=_possibleConstructorReturn(this,_getPrototypeOf(Translator).call(this)),g&&f.call(_assertThisInitialized(n)),copy(["resourceStore","languageUtils","pluralResolver","interpolator","backendConnector","i18nFormat","utils"],e,_assertThisInitialized(n)),n.options=r,void 0===n.options.keySeparator&&(n.options.keySeparator="."),n.logger=p.create("translator"),n}return _inherits(Translator,e),_createClass(Translator,[{key:"changeLanguage",value:function changeLanguage(e){e&&(this.language=e)}},{key:"exists",value:function exists(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{interpolation:{}},r=this.resolve(e,n);return r&&void 0!==r.res}},{key:"extractFromKey",value:function extractFromKey(e,n){var r=void 0!==n.nsSeparator?n.nsSeparator:this.options.nsSeparator;void 0===r&&(r=":");var o=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,i=n.ns||this.options.defaultNS;if(r&&e.indexOf(r)>-1){var a=e.match(this.interpolator.nestingRegexp);if(a&&a.length>0)return{key:e,namespaces:i};var s=e.split(r);(r!==o||r===o&&this.options.ns.indexOf(s[0])>-1)&&(i=s.shift()),e=s.join(o)}return"string"==typeof i&&(i=[i]),{key:e,namespaces:i}}},{key:"translate",value:function translate(e,n,r){var o=this;if("object"!==_typeof(n)&&this.options.overloadTranslationOptionHandler&&(n=this.options.overloadTranslationOptionHandler(arguments)),n||(n={}),null==e)return"";Array.isArray(e)||(e=[String(e)]);var i=void 0!==n.keySeparator?n.keySeparator:this.options.keySeparator,a=this.extractFromKey(e[e.length-1],n),s=a.key,l=a.namespaces,u=l[l.length-1],c=n.lng||this.language,d=n.appendNamespaceToCIMode||this.options.appendNamespaceToCIMode;if(c&&"cimode"===c.toLowerCase()){if(d){var p=n.nsSeparator||this.options.nsSeparator;return u+p+s}return s}var f=this.resolve(e,n),h=f&&f.res,g=f&&f.usedKey||s,m=f&&f.exactUsedKey||s,y=Object.prototype.toString.apply(h),v=["[object Number]","[object Function]","[object RegExp]"],b=void 0!==n.joinArrays?n.joinArrays:this.options.joinArrays,x=!this.i18nFormat||this.i18nFormat.handleAsObject,w="string"!=typeof h&&"boolean"!=typeof h&&"number"!=typeof h;if(x&&h&&w&&v.indexOf(y)<0&&("string"!=typeof b||"[object Array]"!==y)){if(!n.returnObjects&&!this.options.returnObjects)return this.logger.warn("accessing an object - but returnObjects options is not enabled!"),this.options.returnedObjectHandler?this.options.returnedObjectHandler(g,h,n):"key '".concat(s," (").concat(this.language,")' returned an object instead of string.");if(i){var S="[object Array]"===y,T=S?[]:{},C=S?m:g;for(var k in h)if(Object.prototype.hasOwnProperty.call(h,k)){var N="".concat(C).concat(i).concat(k);T[k]=this.translate(N,_objectSpread({},n,{joinArrays:!1,ns:l})),T[k]===N&&(T[k]=h[k])}h=T}}else if(x&&"string"==typeof b&&"[object Array]"===y)(h=h.join(b))&&(h=this.extendTranslation(h,e,n,r));else{var E=!1,A=!1,L=void 0!==n.count&&"string"!=typeof n.count,O=Translator.hasDefaultValue(n),P=L?this.pluralResolver.getSuffix(c,n.count):"",j=n["defaultValue".concat(P)]||n.defaultValue;!this.isValidLookup(h)&&O&&(E=!0,h=j),this.isValidLookup(h)||(A=!0,h=s);var D=O&&j!==h&&this.options.updateMissing;if(A||E||D){if(this.logger.log(D?"updateKey":"missingKey",c,u,s,D?j:h),i){var M=this.resolve(s,_objectSpread({},n,{keySeparator:!1}));M&&M.res&&this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")}var R=[],I=this.languageUtils.getFallbackCodes(this.options.fallbackLng,n.lng||this.language);if("fallback"===this.options.saveMissingTo&&I&&I[0])for(var q=0;q<I.length;q++)R.push(I[q]);else"all"===this.options.saveMissingTo?R=this.languageUtils.toResolveHierarchy(n.lng||this.language):R.push(n.lng||this.language);var F=function send(e,r,i){o.options.missingKeyHandler?o.options.missingKeyHandler(e,u,r,D?i:h,D,n):o.backendConnector&&o.backendConnector.saveMissing&&o.backendConnector.saveMissing(e,u,r,D?i:h,D,n),o.emit("missingKey",e,u,r,h)};this.options.saveMissing&&(this.options.saveMissingPlurals&&L?R.forEach((function(e){o.pluralResolver.getSuffixes(e).forEach((function(r){F([e],s+r,n["defaultValue".concat(r)]||j)}))})):F(R,s,j))}h=this.extendTranslation(h,e,n,f,r),A&&h===s&&this.options.appendNamespaceToMissingKey&&(h="".concat(u,":").concat(s)),A&&this.options.parseMissingKeyHandler&&(h=this.options.parseMissingKeyHandler(h))}return h}},{key:"extendTranslation",value:function extendTranslation(e,n,r,o,i){var a=this;if(this.i18nFormat&&this.i18nFormat.parse)e=this.i18nFormat.parse(e,r,o.usedLng,o.usedNS,o.usedKey,{resolved:o});else if(!r.skipInterpolation){r.interpolation&&this.interpolator.init(_objectSpread({},r,{interpolation:_objectSpread({},this.options.interpolation,r.interpolation)}));var s,l=r.interpolation&&r.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;if(l){var u=e.match(this.interpolator.nestingRegexp);s=u&&u.length}var c=r.replace&&"string"!=typeof r.replace?r.replace:r;if(this.options.interpolation.defaultVariables&&(c=_objectSpread({},this.options.interpolation.defaultVariables,c)),e=this.interpolator.interpolate(e,c,r.lng||this.language,r),l){var d=e.match(this.interpolator.nestingRegexp);s<(d&&d.length)&&(r.nest=!1)}!1!==r.nest&&(e=this.interpolator.nest(e,(function(){for(var e=arguments.length,o=new Array(e),s=0;s<e;s++)o[s]=arguments[s];return i&&i[0]===o[0]&&!r.context?(a.logger.warn("It seems you are nesting recursively key: ".concat(o[0]," in key: ").concat(n[0])),null):a.translate.apply(a,o.concat([n]))}),r)),r.interpolation&&this.interpolator.reset()}var p=r.postProcess||this.options.postProcess,f="string"==typeof p?[p]:p;return null!=e&&f&&f.length&&!1!==r.applyPostProcessor&&(e=y.handle(f,e,n,this.options&&this.options.postProcessPassResolved?_objectSpread({i18nResolved:o},r):r,this)),e}},{key:"resolve",value:function resolve(e){var n,r,o,i,a,s=this,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return"string"==typeof e&&(e=[e]),e.forEach((function(e){if(!s.isValidLookup(n)){var u=s.extractFromKey(e,l),c=u.key;r=c;var d=u.namespaces;s.options.fallbackNS&&(d=d.concat(s.options.fallbackNS));var p=void 0!==l.count&&"string"!=typeof l.count,f=void 0!==l.context&&"string"==typeof l.context&&""!==l.context,h=l.lngs?l.lngs:s.languageUtils.toResolveHierarchy(l.lng||s.language,l.fallbackLng);d.forEach((function(e){s.isValidLookup(n)||(a=e,!v["".concat(h[0],"-").concat(e)]&&s.utils&&s.utils.hasLoadedNamespace&&!s.utils.hasLoadedNamespace(a)&&(v["".concat(h[0],"-").concat(e)]=!0,s.logger.warn('key "'.concat(r,'" for languages "').concat(h.join(", "),'" won\'t get resolved as namespace "').concat(a,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),h.forEach((function(r){if(!s.isValidLookup(n)){i=r;var a,u,d=c,h=[d];if(s.i18nFormat&&s.i18nFormat.addLookupKeys)s.i18nFormat.addLookupKeys(h,c,r,e,l);else p&&(a=s.pluralResolver.getSuffix(r,l.count)),p&&f&&h.push(d+a),f&&h.push(d+="".concat(s.options.contextSeparator).concat(l.context)),p&&h.push(d+=a);for(;u=h.pop();)s.isValidLookup(n)||(o=u,n=s.getResource(r,e,u,l))}})))}))}})),{res:n,usedKey:r,exactUsedKey:o,usedLng:i,usedNS:a}}},{key:"isValidLookup",value:function isValidLookup(e){return!(void 0===e||!this.options.returnNull&&null===e||!this.options.returnEmptyString&&""===e)}},{key:"getResource",value:function getResource(e,n,r){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return this.i18nFormat&&this.i18nFormat.getResource?this.i18nFormat.getResource(e,n,r,o):this.resourceStore.getResource(e,n,r,o)}}],[{key:"hasDefaultValue",value:function hasDefaultValue(e){var n="defaultValue";for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r)&&n===r.substring(0,n.length)&&void 0!==e[r])return!0;return!1}}]),Translator}(f);function capitalize(e){return e.charAt(0).toUpperCase()+e.slice(1)}var x=function(){function LanguageUtil(e){_classCallCheck(this,LanguageUtil),this.options=e,this.whitelist=this.options.supportedLngs||!1,this.supportedLngs=this.options.supportedLngs||!1,this.logger=p.create("languageUtils")}return _createClass(LanguageUtil,[{key:"getScriptPartFromCode",value:function getScriptPartFromCode(e){if(!e||e.indexOf("-")<0)return null;var n=e.split("-");return 2===n.length?null:(n.pop(),"x"===n[n.length-1].toLowerCase()?null:this.formatLanguageCode(n.join("-")))}},{key:"getLanguagePartFromCode",value:function getLanguagePartFromCode(e){if(!e||e.indexOf("-")<0)return e;var n=e.split("-");return this.formatLanguageCode(n[0])}},{key:"formatLanguageCode",value:function formatLanguageCode(e){if("string"==typeof e&&e.indexOf("-")>-1){var n=["hans","hant","latn","cyrl","cans","mong","arab"],r=e.split("-");return this.options.lowerCaseLng?r=r.map((function(e){return e.toLowerCase()})):2===r.length?(r[0]=r[0].toLowerCase(),r[1]=r[1].toUpperCase(),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=capitalize(r[1].toLowerCase()))):3===r.length&&(r[0]=r[0].toLowerCase(),2===r[1].length&&(r[1]=r[1].toUpperCase()),"sgn"!==r[0]&&2===r[2].length&&(r[2]=r[2].toUpperCase()),n.indexOf(r[1].toLowerCase())>-1&&(r[1]=capitalize(r[1].toLowerCase())),n.indexOf(r[2].toLowerCase())>-1&&(r[2]=capitalize(r[2].toLowerCase()))),r.join("-")}return this.options.cleanCode||this.options.lowerCaseLng?e.toLowerCase():e}},{key:"isWhitelisted",value:function isWhitelisted(e){return this.logger.deprecate("languageUtils.isWhitelisted",'function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it\'s usage asap.'),this.isSupportedCode(e)}},{key:"isSupportedCode",value:function isSupportedCode(e){return("languageOnly"===this.options.load||this.options.nonExplicitSupportedLngs)&&(e=this.getLanguagePartFromCode(e)),!this.supportedLngs||!this.supportedLngs.length||this.supportedLngs.indexOf(e)>-1}},{key:"getBestMatchFromCodes",value:function getBestMatchFromCodes(e){var n,r=this;return e?(e.forEach((function(e){if(!n){var o=r.formatLanguageCode(e);r.options.supportedLngs&&!r.isSupportedCode(o)||(n=o)}})),!n&&this.options.supportedLngs&&e.forEach((function(e){if(!n){var o=r.getLanguagePartFromCode(e);if(r.isSupportedCode(o))return n=o;n=r.options.supportedLngs.find((function(e){if(0===e.indexOf(o))return e}))}})),n||(n=this.getFallbackCodes(this.options.fallbackLng)[0]),n):null}},{key:"getFallbackCodes",value:function getFallbackCodes(e,n){if(!e)return[];if("function"==typeof e&&(e=e(n)),"string"==typeof e&&(e=[e]),"[object Array]"===Object.prototype.toString.apply(e))return e;if(!n)return e.default||[];var r=e[n];return r||(r=e[this.getScriptPartFromCode(n)]),r||(r=e[this.formatLanguageCode(n)]),r||(r=e[this.getLanguagePartFromCode(n)]),r||(r=e.default),r||[]}},{key:"toResolveHierarchy",value:function toResolveHierarchy(e,n){var r=this,o=this.getFallbackCodes(n||this.options.fallbackLng||[],e),i=[],a=function addCode(e){e&&(r.isSupportedCode(e)?i.push(e):r.logger.warn("rejecting language code not found in supportedLngs: ".concat(e)))};return"string"==typeof e&&e.indexOf("-")>-1?("languageOnly"!==this.options.load&&a(this.formatLanguageCode(e)),"languageOnly"!==this.options.load&&"currentOnly"!==this.options.load&&a(this.getScriptPartFromCode(e)),"currentOnly"!==this.options.load&&a(this.getLanguagePartFromCode(e))):"string"==typeof e&&a(this.formatLanguageCode(e)),o.forEach((function(e){i.indexOf(e)<0&&a(r.formatLanguageCode(e))})),i}}]),LanguageUtil}(),w=[{lngs:["ach","ak","am","arn","br","fil","gun","ln","mfe","mg","mi","oc","pt","pt-BR","tg","tl","ti","tr","uz","wa"],nr:[1,2],fc:1},{lngs:["af","an","ast","az","bg","bn","ca","da","de","dev","el","en","eo","es","et","eu","fi","fo","fur","fy","gl","gu","ha","hi","hu","hy","ia","it","kn","ku","lb","mai","ml","mn","mr","nah","nap","nb","ne","nl","nn","no","nso","pa","pap","pms","ps","pt-PT","rm","sco","se","si","so","son","sq","sv","sw","ta","te","tk","ur","yo"],nr:[1,2],fc:2},{lngs:["ay","bo","cgg","fa","ht","id","ja","jbo","ka","kk","km","ko","ky","lo","ms","sah","su","th","tt","ug","vi","wo","zh"],nr:[1],fc:3},{lngs:["be","bs","cnr","dz","hr","ru","sr","uk"],nr:[1,2,5],fc:4},{lngs:["ar"],nr:[0,1,2,3,11,100],fc:5},{lngs:["cs","sk"],nr:[1,2,5],fc:6},{lngs:["csb","pl"],nr:[1,2,5],fc:7},{lngs:["cy"],nr:[1,2,3,8],fc:8},{lngs:["fr"],nr:[1,2],fc:9},{lngs:["ga"],nr:[1,2,3,7,11],fc:10},{lngs:["gd"],nr:[1,2,3,20],fc:11},{lngs:["is"],nr:[1,2],fc:12},{lngs:["jv"],nr:[0,1],fc:13},{lngs:["kw"],nr:[1,2,3,4],fc:14},{lngs:["lt"],nr:[1,2,10],fc:15},{lngs:["lv"],nr:[1,2,0],fc:16},{lngs:["mk"],nr:[1,2],fc:17},{lngs:["mnk"],nr:[0,1,2],fc:18},{lngs:["mt"],nr:[1,2,11,20],fc:19},{lngs:["or"],nr:[2,1],fc:2},{lngs:["ro"],nr:[1,2,20],fc:20},{lngs:["sl"],nr:[5,1,2,3],fc:21},{lngs:["he","iw"],nr:[1,2,20,21],fc:22}],S={1:function _(e){return Number(e>1)},2:function _(e){return Number(1!=e)},3:function _(e){return 0},4:function _(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},5:function _(e){return Number(0==e?0:1==e?1:2==e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5)},6:function _(e){return Number(1==e?0:e>=2&&e<=4?1:2)},7:function _(e){return Number(1==e?0:e%10>=2&&e%10<=4&&(e%100<10||e%100>=20)?1:2)},8:function _(e){return Number(1==e?0:2==e?1:8!=e&&11!=e?2:3)},9:function _(e){return Number(e>=2)},10:function _(e){return Number(1==e?0:2==e?1:e<7?2:e<11?3:4)},11:function _(e){return Number(1==e||11==e?0:2==e||12==e?1:e>2&&e<20?2:3)},12:function _(e){return Number(e%10!=1||e%100==11)},13:function _(e){return Number(0!==e)},14:function _(e){return Number(1==e?0:2==e?1:3==e?2:3)},15:function _(e){return Number(e%10==1&&e%100!=11?0:e%10>=2&&(e%100<10||e%100>=20)?1:2)},16:function _(e){return Number(e%10==1&&e%100!=11?0:0!==e?1:2)},17:function _(e){return Number(1==e||e%10==1&&e%100!=11?0:1)},18:function _(e){return Number(0==e?0:1==e?1:2)},19:function _(e){return Number(1==e?0:0==e||e%100>1&&e%100<11?1:e%100>10&&e%100<20?2:3)},20:function _(e){return Number(1==e?0:0==e||e%100>0&&e%100<20?1:2)},21:function _(e){return Number(e%100==1?1:e%100==2?2:e%100==3||e%100==4?3:0)},22:function _(e){return Number(1==e?0:2==e?1:(e<0||e>10)&&e%10==0?2:3)}};function createRules(){var e={};return w.forEach((function(n){n.lngs.forEach((function(r){e[r]={numbers:n.nr,plurals:S[n.fc]}}))})),e}var T=function(){function PluralResolver(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};_classCallCheck(this,PluralResolver),this.languageUtils=e,this.options=n,this.logger=p.create("pluralResolver"),this.rules=createRules()}return _createClass(PluralResolver,[{key:"addRule",value:function addRule(e,n){this.rules[e]=n}},{key:"getRule",value:function getRule(e){return this.rules[e]||this.rules[this.languageUtils.getLanguagePartFromCode(e)]}},{key:"needsPlural",value:function needsPlural(e){var n=this.getRule(e);return n&&n.numbers.length>1}},{key:"getPluralFormsOfKey",value:function getPluralFormsOfKey(e,n){return this.getSuffixes(e).map((function(e){return n+e}))}},{key:"getSuffixes",value:function getSuffixes(e){var n=this,r=this.getRule(e);return r?r.numbers.map((function(r){return n.getSuffix(e,r)})):[]}},{key:"getSuffix",value:function getSuffix(e,n){var r=this,o=this.getRule(e);if(o){var i=o.noAbs?o.plurals(n):o.plurals(Math.abs(n)),a=o.numbers[i];this.options.simplifyPluralSuffix&&2===o.numbers.length&&1===o.numbers[0]&&(2===a?a="plural":1===a&&(a=""));var s=function returnSuffix(){return r.options.prepend&&a.toString()?r.options.prepend+a.toString():a.toString()};return"v1"===this.options.compatibilityJSON?1===a?"":"number"==typeof a?"_plural_".concat(a.toString()):s():"v2"===this.options.compatibilityJSON||this.options.simplifyPluralSuffix&&2===o.numbers.length&&1===o.numbers[0]?s():this.options.prepend&&i.toString()?this.options.prepend+i.toString():i.toString()}return this.logger.warn("no plural rule found for: ".concat(e)),""}}]),PluralResolver}(),C=function(){function Interpolator(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};_classCallCheck(this,Interpolator),this.logger=p.create("interpolator"),this.options=e,this.format=e.interpolation&&e.interpolation.format||function(e){return e},this.init(e)}return _createClass(Interpolator,[{key:"init",value:function init(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.interpolation||(e.interpolation={escapeValue:!0});var n=e.interpolation;this.escape=void 0!==n.escape?n.escape:i18next_escape,this.escapeValue=void 0===n.escapeValue||n.escapeValue,this.useRawValueToEscape=void 0!==n.useRawValueToEscape&&n.useRawValueToEscape,this.prefix=n.prefix?regexEscape(n.prefix):n.prefixEscaped||"{{",this.suffix=n.suffix?regexEscape(n.suffix):n.suffixEscaped||"}}",this.formatSeparator=n.formatSeparator?n.formatSeparator:n.formatSeparator||",",this.unescapePrefix=n.unescapeSuffix?"":n.unescapePrefix||"-",this.unescapeSuffix=this.unescapePrefix?"":n.unescapeSuffix||"",this.nestingPrefix=n.nestingPrefix?regexEscape(n.nestingPrefix):n.nestingPrefixEscaped||regexEscape("$t("),this.nestingSuffix=n.nestingSuffix?regexEscape(n.nestingSuffix):n.nestingSuffixEscaped||regexEscape(")"),this.nestingOptionsSeparator=n.nestingOptionsSeparator?n.nestingOptionsSeparator:n.nestingOptionsSeparator||",",this.maxReplaces=n.maxReplaces?n.maxReplaces:1e3,this.alwaysFormat=void 0!==n.alwaysFormat&&n.alwaysFormat,this.resetRegExp()}},{key:"reset",value:function reset(){this.options&&this.init(this.options)}},{key:"resetRegExp",value:function resetRegExp(){var e="".concat(this.prefix,"(.+?)").concat(this.suffix);this.regexp=new RegExp(e,"g");var n="".concat(this.prefix).concat(this.unescapePrefix,"(.+?)").concat(this.unescapeSuffix).concat(this.suffix);this.regexpUnescape=new RegExp(n,"g");var r="".concat(this.nestingPrefix,"(.+?)").concat(this.nestingSuffix);this.nestingRegexp=new RegExp(r,"g")}},{key:"interpolate",value:function interpolate(e,n,r,o){var i,a,s,l=this,u=this.options&&this.options.interpolation&&this.options.interpolation.defaultVariables||{};function regexSafe(e){return e.replace(/\$/g,"$$$$")}var c=function handleFormat(e){if(e.indexOf(l.formatSeparator)<0){var i=getPathWithDefaults(n,u,e);return l.alwaysFormat?l.format(i,void 0,r):i}var a=e.split(l.formatSeparator),s=a.shift().trim(),c=a.join(l.formatSeparator).trim();return l.format(getPathWithDefaults(n,u,s),c,r,o)};this.resetRegExp();var d=o&&o.missingInterpolationHandler||this.options.missingInterpolationHandler,p=o&&o.interpolation&&o.interpolation.skipOnVariables||this.options.interpolation.skipOnVariables;return[{regex:this.regexpUnescape,safeValue:function safeValue(e){return regexSafe(e)}},{regex:this.regexp,safeValue:function safeValue(e){return l.escapeValue?regexSafe(l.escape(e)):regexSafe(e)}}].forEach((function(n){for(s=0;i=n.regex.exec(e);){if(void 0===(a=c(i[1].trim())))if("function"==typeof d){var r=d(e,i,o);a="string"==typeof r?r:""}else{if(p){a=i[0];continue}l.logger.warn("missed to pass in variable ".concat(i[1]," for interpolating ").concat(e)),a=""}else"string"==typeof a||l.useRawValueToEscape||(a=makeString(a));if(e=e.replace(i[0],n.safeValue(a)),n.regex.lastIndex=0,++s>=l.maxReplaces)break}})),e}},{key:"nest",value:function nest(e,n){var r,o,i=this,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=_objectSpread({},a);function handleHasOptions(e,n){var r=this.nestingOptionsSeparator;if(e.indexOf(r)<0)return e;var o=e.split(new RegExp("".concat(r,"[ ]*{"))),i="{".concat(o[1]);e=o[0],i=(i=this.interpolate(i,s)).replace(/'/g,'"');try{s=JSON.parse(i),n&&(s=_objectSpread({},n,s))}catch(n){return this.logger.warn("failed parsing options string in nesting for key ".concat(e),n),"".concat(e).concat(r).concat(i)}return delete s.defaultValue,e}for(s.applyPostProcessor=!1,delete s.defaultValue;r=this.nestingRegexp.exec(e);){var l=[],u=!1;if(r[0].includes(this.formatSeparator)&&!/{.*}/.test(r[1])){var c=r[1].split(this.formatSeparator).map((function(e){return e.trim()}));r[1]=c.shift(),l=c,u=!0}if((o=n(handleHasOptions.call(this,r[1].trim(),s),s))&&r[0]===e&&"string"!=typeof o)return o;"string"!=typeof o&&(o=makeString(o)),o||(this.logger.warn("missed to resolve ".concat(r[1]," for nesting ").concat(e)),o=""),u&&(o=l.reduce((function(e,n){return i.format(e,n,a.lng,a)}),o.trim())),e=e.replace(r[0],o),this.regexp.lastIndex=0}return e}}]),Interpolator}();var k=function(e){function Connector(e,n,r){var o,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return _classCallCheck(this,Connector),o=_possibleConstructorReturn(this,_getPrototypeOf(Connector).call(this)),g&&f.call(_assertThisInitialized(o)),o.backend=e,o.store=n,o.services=r,o.languageUtils=r.languageUtils,o.options=i,o.logger=p.create("backendConnector"),o.state={},o.queue=[],o.backend&&o.backend.init&&o.backend.init(r,i.backend,i),o}return _inherits(Connector,e),_createClass(Connector,[{key:"queueLoad",value:function queueLoad(e,n,r,o){var i=this,a=[],s=[],l=[],u=[];return e.forEach((function(e){var o=!0;n.forEach((function(n){var l="".concat(e,"|").concat(n);!r.reload&&i.store.hasResourceBundle(e,n)?i.state[l]=2:i.state[l]<0||(1===i.state[l]?s.indexOf(l)<0&&s.push(l):(i.state[l]=1,o=!1,s.indexOf(l)<0&&s.push(l),a.indexOf(l)<0&&a.push(l),u.indexOf(n)<0&&u.push(n)))})),o||l.push(e)})),(a.length||s.length)&&this.queue.push({pending:s,loaded:{},errors:[],callback:o}),{toLoad:a,pending:s,toLoadLanguages:l,toLoadNamespaces:u}}},{key:"loaded",value:function loaded(e,n,r){var o=e.split("|"),i=o[0],a=o[1];n&&this.emit("failedLoading",i,a,n),r&&this.store.addResourceBundle(i,a,r),this.state[e]=n?-1:2;var loaded={};this.queue.forEach((function(r){!function pushPath(e,n,r,o){var i=getLastOfPath(e,n,Object),a=i.obj,s=i.k;a[s]=a[s]||[],o&&(a[s]=a[s].concat(r)),o||a[s].push(r)}(r.loaded,[i],a),function remove(e,n){for(var r=e.indexOf(n);-1!==r;)e.splice(r,1),r=e.indexOf(n)}(r.pending,e),n&&r.errors.push(n),0!==r.pending.length||r.done||(Object.keys(r.loaded).forEach((function(e){loaded[e]||(loaded[e]=[]),r.loaded[e].length&&r.loaded[e].forEach((function(n){loaded[e].indexOf(n)<0&&loaded[e].push(n)}))})),r.done=!0,r.errors.length?r.callback(r.errors):r.callback())})),this.emit("loaded",loaded),this.queue=this.queue.filter((function(e){return!e.done}))}},{key:"read",value:function read(e,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:350,s=arguments.length>5?arguments[5]:void 0;return e.length?this.backend[r](e,n,(function(l,u){l&&u&&i<5?setTimeout((function(){o.read.call(o,e,n,r,i+1,2*a,s)}),a):s(l,u)})):s(null,{})}},{key:"prepareLoading",value:function prepareLoading(e,n){var r=this,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3?arguments[3]:void 0;if(!this.backend)return this.logger.warn("No backend was added via i18next.use. Will not load resources."),i&&i();"string"==typeof e&&(e=this.languageUtils.toResolveHierarchy(e)),"string"==typeof n&&(n=[n]);var a=this.queueLoad(e,n,o,i);if(!a.toLoad.length)return a.pending.length||i(),null;a.toLoad.forEach((function(e){r.loadOne(e)}))}},{key:"load",value:function load(e,n,r){this.prepareLoading(e,n,{},r)}},{key:"reload",value:function reload(e,n,r){this.prepareLoading(e,n,{reload:!0},r)}},{key:"loadOne",value:function loadOne(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",o=e.split("|"),i=o[0],a=o[1];this.read(i,a,"read",void 0,void 0,(function(o,s){o&&n.logger.warn("".concat(r,"loading namespace ").concat(a," for language ").concat(i," failed"),o),!o&&s&&n.logger.log("".concat(r,"loaded namespace ").concat(a," for language ").concat(i),s),n.loaded(e,o,s)}))}},{key:"saveMissing",value:function saveMissing(e,n,r,o,i){var a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};this.services.utils&&this.services.utils.hasLoadedNamespace&&!this.services.utils.hasLoadedNamespace(n)?this.logger.warn('did not save key "'.concat(r,'" as the namespace "').concat(n,'" was not yet loaded'),"This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"):null!=r&&""!==r&&(this.backend&&this.backend.create&&this.backend.create(e,n,r,o,null,_objectSpread({},a,{isUpdate:i})),e&&e[0]&&this.store.addResource(e[0],n,r,o))}}]),Connector}(f);function i18next_get(){return{debug:!1,initImmediate:!0,ns:["translation"],defaultNS:["translation"],fallbackLng:["dev"],fallbackNS:!1,whitelist:!1,nonExplicitWhitelist:!1,supportedLngs:!1,nonExplicitSupportedLngs:!1,load:"all",preload:!1,simplifyPluralSuffix:!0,keySeparator:".",nsSeparator:":",pluralSeparator:"_",contextSeparator:"_",partialBundledLanguages:!1,saveMissing:!1,updateMissing:!1,saveMissingTo:"fallback",saveMissingPlurals:!0,missingKeyHandler:!1,missingInterpolationHandler:!1,postProcess:!1,postProcessPassResolved:!1,returnNull:!0,returnEmptyString:!0,returnObjects:!1,joinArrays:!1,returnedObjectHandler:!1,parseMissingKeyHandler:!1,appendNamespaceToMissingKey:!1,appendNamespaceToCIMode:!1,overloadTranslationOptionHandler:function handle(e){var n={};if("object"===_typeof(e[1])&&(n=e[1]),"string"==typeof e[1]&&(n.defaultValue=e[1]),"string"==typeof e[2]&&(n.tDescription=e[2]),"object"===_typeof(e[2])||"object"===_typeof(e[3])){var r=e[3]||e[2];Object.keys(r).forEach((function(e){n[e]=r[e]}))}return n},interpolation:{escapeValue:!0,format:function format(e,n,r,o){return e},prefix:"{{",suffix:"}}",formatSeparator:",",unescapePrefix:"-",nestingPrefix:"$t(",nestingSuffix:")",nestingOptionsSeparator:",",maxReplaces:1e3,skipOnVariables:!1}}}function transformOptions(e){return"string"==typeof e.ns&&(e.ns=[e.ns]),"string"==typeof e.fallbackLng&&(e.fallbackLng=[e.fallbackLng]),"string"==typeof e.fallbackNS&&(e.fallbackNS=[e.fallbackNS]),e.whitelist&&(e.whitelist&&e.whitelist.indexOf("cimode")<0&&(e.whitelist=e.whitelist.concat(["cimode"])),e.supportedLngs=e.whitelist),e.nonExplicitWhitelist&&(e.nonExplicitSupportedLngs=e.nonExplicitWhitelist),e.supportedLngs&&e.supportedLngs.indexOf("cimode")<0&&(e.supportedLngs=e.supportedLngs.concat(["cimode"])),e}function noop(){}const N=new(function(e){function I18n(){var e,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;if(_classCallCheck(this,I18n),e=_possibleConstructorReturn(this,_getPrototypeOf(I18n).call(this)),g&&f.call(_assertThisInitialized(e)),e.options=transformOptions(n),e.services={},e.logger=p,e.modules={external:[]},r&&!e.isInitialized&&!n.isClone){if(!e.options.initImmediate)return e.init(n,r),_possibleConstructorReturn(e,_assertThisInitialized(e));setTimeout((function(){e.init(n,r)}),0)}return e}return _inherits(I18n,e),_createClass(I18n,[{key:"init",value:function init(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1?arguments[1]:void 0;function createClassOnDemand(e){return e?"function"==typeof e?new e:e:null}if("function"==typeof n&&(r=n,n={}),n.whitelist&&!n.supportedLngs&&this.logger.deprecate("whitelist",'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.'),n.nonExplicitWhitelist&&!n.nonExplicitSupportedLngs&&this.logger.deprecate("whitelist",'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.'),this.options=_objectSpread({},i18next_get(),this.options,transformOptions(n)),this.format=this.options.interpolation.format,r||(r=noop),!this.options.isClone){this.modules.logger?p.init(createClassOnDemand(this.modules.logger),this.options):p.init(null,this.options);var o=new x(this.options);this.store=new m(this.options.resources,this.options);var i=this.services;i.logger=p,i.resourceStore=this.store,i.languageUtils=o,i.pluralResolver=new T(o,{prepend:this.options.pluralSeparator,compatibilityJSON:this.options.compatibilityJSON,simplifyPluralSuffix:this.options.simplifyPluralSuffix}),i.interpolator=new C(this.options),i.utils={hasLoadedNamespace:this.hasLoadedNamespace.bind(this)},i.backendConnector=new k(createClassOnDemand(this.modules.backend),i.resourceStore,i,this.options),i.backendConnector.on("*",(function(n){for(var r=arguments.length,o=new Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];e.emit.apply(e,[n].concat(o))})),this.modules.languageDetector&&(i.languageDetector=createClassOnDemand(this.modules.languageDetector),i.languageDetector.init(i,this.options.detection,this.options)),this.modules.i18nFormat&&(i.i18nFormat=createClassOnDemand(this.modules.i18nFormat),i.i18nFormat.init&&i.i18nFormat.init(this)),this.translator=new b(this.services,this.options),this.translator.on("*",(function(n){for(var r=arguments.length,o=new Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];e.emit.apply(e,[n].concat(o))})),this.modules.external.forEach((function(n){n.init&&n.init(e)}))}if(this.options.fallbackLng&&!this.services.languageDetector&&!this.options.lng){var a=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);a.length>0&&"dev"!==a[0]&&(this.options.lng=a[0])}this.services.languageDetector||this.options.lng||this.logger.warn("init: no languageDetector is used and no lng is defined");var s=["getResource","hasResourceBundle","getResourceBundle","getDataByLanguage"];s.forEach((function(n){e[n]=function(){var r;return(r=e.store)[n].apply(r,arguments)}}));var l=["addResource","addResources","addResourceBundle","removeResourceBundle"];l.forEach((function(n){e[n]=function(){var r;return(r=e.store)[n].apply(r,arguments),e}}));var u=defer(),c=function load(){var n=function finish(n,o){e.isInitialized&&e.logger.warn("init: i18next is already initialized. You should call init just once!"),e.isInitialized=!0,e.options.isClone||e.logger.log("initialized",e.options),e.emit("initialized",e.options),u.resolve(o),r(n,o)};if(e.languages&&"v1"!==e.options.compatibilityAPI&&!e.isInitialized)return n(null,e.t.bind(e));e.changeLanguage(e.options.lng,n)};return this.options.resources||!this.options.initImmediate?c():setTimeout(c,0),u}},{key:"loadResources",value:function loadResources(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:noop,o=r,i="string"==typeof e?e:this.language;if("function"==typeof e&&(o=e),!this.options.resources||this.options.partialBundledLanguages){if(i&&"cimode"===i.toLowerCase())return o();var a=[],s=function append(e){e&&n.services.languageUtils.toResolveHierarchy(e).forEach((function(e){a.indexOf(e)<0&&a.push(e)}))};if(i)s(i);else{var l=this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);l.forEach((function(e){return s(e)}))}this.options.preload&&this.options.preload.forEach((function(e){return s(e)})),this.services.backendConnector.load(a,this.options.ns,o)}else o(null)}},{key:"reloadResources",value:function reloadResources(e,n,r){var o=defer();return e||(e=this.languages),n||(n=this.options.ns),r||(r=noop),this.services.backendConnector.reload(e,n,(function(e){o.resolve(),r(e)})),o}},{key:"use",value:function use(e){if(!e)throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");if(!e.type)throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");return"backend"===e.type&&(this.modules.backend=e),("logger"===e.type||e.log&&e.warn&&e.error)&&(this.modules.logger=e),"languageDetector"===e.type&&(this.modules.languageDetector=e),"i18nFormat"===e.type&&(this.modules.i18nFormat=e),"postProcessor"===e.type&&y.addPostProcessor(e),"3rdParty"===e.type&&this.modules.external.push(e),this}},{key:"changeLanguage",value:function changeLanguage(e,n){var r=this;this.isLanguageChangingTo=e;var o=defer();this.emit("languageChanging",e);var i=function setLng(e){var i="string"==typeof e?e:r.services.languageUtils.getBestMatchFromCodes(e);i&&(r.language||(r.language=i,r.languages=r.services.languageUtils.toResolveHierarchy(i)),r.translator.language||r.translator.changeLanguage(i),r.services.languageDetector&&r.services.languageDetector.cacheUserLanguage(i)),r.loadResources(i,(function(e){!function done(e,i){i?(r.language=i,r.languages=r.services.languageUtils.toResolveHierarchy(i),r.translator.changeLanguage(i),r.isLanguageChangingTo=void 0,r.emit("languageChanged",i),r.logger.log("languageChanged",i)):r.isLanguageChangingTo=void 0,o.resolve((function(){return r.t.apply(r,arguments)})),n&&n(e,(function(){return r.t.apply(r,arguments)}))}(e,i)}))};return e||!this.services.languageDetector||this.services.languageDetector.async?!e&&this.services.languageDetector&&this.services.languageDetector.async?this.services.languageDetector.detect(i):i(e):i(this.services.languageDetector.detect()),o}},{key:"getFixedT",value:function getFixedT(e,n){var r=this,o=function fixedT(e,n){var o;if("object"!==_typeof(n)){for(var i=arguments.length,a=new Array(i>2?i-2:0),s=2;s<i;s++)a[s-2]=arguments[s];o=r.options.overloadTranslationOptionHandler([e,n].concat(a))}else o=_objectSpread({},n);return o.lng=o.lng||fixedT.lng,o.lngs=o.lngs||fixedT.lngs,o.ns=o.ns||fixedT.ns,r.t(e,o)};return"string"==typeof e?o.lng=e:o.lngs=e,o.ns=n,o}},{key:"t",value:function t(){var e;return this.translator&&(e=this.translator).translate.apply(e,arguments)}},{key:"exists",value:function exists(){var e;return this.translator&&(e=this.translator).exists.apply(e,arguments)}},{key:"setDefaultNamespace",value:function setDefaultNamespace(e){this.options.defaultNS=e}},{key:"hasLoadedNamespace",value:function hasLoadedNamespace(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this.isInitialized)return this.logger.warn("hasLoadedNamespace: i18next was not initialized",this.languages),!1;if(!this.languages||!this.languages.length)return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty",this.languages),!1;var o=this.languages[0],i=!!this.options&&this.options.fallbackLng,a=this.languages[this.languages.length-1];if("cimode"===o.toLowerCase())return!0;var s=function loadNotPending(e,r){var o=n.services.backendConnector.state["".concat(e,"|").concat(r)];return-1===o||2===o};if(r.precheck){var l=r.precheck(this,s);if(void 0!==l)return l}return!!this.hasResourceBundle(o,e)||(!this.services.backendConnector.backend||!(!s(o,e)||i&&!s(a,e)))}},{key:"loadNamespaces",value:function loadNamespaces(e,n){var r=this,o=defer();return this.options.ns?("string"==typeof e&&(e=[e]),e.forEach((function(e){r.options.ns.indexOf(e)<0&&r.options.ns.push(e)})),this.loadResources((function(e){o.resolve(),n&&n(e)})),o):(n&&n(),Promise.resolve())}},{key:"loadLanguages",value:function loadLanguages(e,n){var r=defer();"string"==typeof e&&(e=[e]);var o=this.options.preload||[],i=e.filter((function(e){return o.indexOf(e)<0}));return i.length?(this.options.preload=o.concat(i),this.loadResources((function(e){r.resolve(),n&&n(e)})),r):(n&&n(),Promise.resolve())}},{key:"dir",value:function dir(e){if(e||(e=this.languages&&this.languages.length>0?this.languages[0]:this.language),!e)return"rtl";return["ar","shu","sqr","ssh","xaa","yhd","yud","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","afb","ajp","apc","apd","arb","arq","ars","ary","arz","auz","avl","ayh","ayl","ayn","ayp","bbz","pga","he","iw","ps","pbt","pbu","pst","prp","prd","ug","ur","ydd","yds","yih","ji","yi","hbo","men","xmn","fa","jpr","peo","pes","prs","dv","sam"].indexOf(this.services.languageUtils.getLanguagePartFromCode(e))>=0?"rtl":"ltr"}},{key:"createInstance",value:function createInstance(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=arguments.length>1?arguments[1]:void 0;return new I18n(e,n)}},{key:"cloneInstance",value:function cloneInstance(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:noop,o=_objectSpread({},this.options,n,{isClone:!0}),i=new I18n(o),a=["store","services","language"];return a.forEach((function(n){i[n]=e[n]})),i.services=_objectSpread({},this.services),i.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i.translator=new b(i.services,i.options),i.translator.on("*",(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];i.emit.apply(i,[e].concat(r))})),i.init(o,r),i.translator.options=i.options,i.translator.backendConnector.services.utils={hasLoadedNamespace:i.hasLoadedNamespace.bind(i)},i}}]),I18n}(f)),E="Neos.Neos",A="Main",L=[],getTransformedNamespace=(e,n)=>((0,o.isEmpty)(e)?E:e.replace(/\_/g,"."))+"/"+((0,o.isEmpty)(n)?A:n.replace(/\_/g,".")),checkInitialisedNamespaces=()=>{const e=L.findIndex((e=>!1===e.initialized))>=0;var n;return e||(n=!0,(0,o.createCollectionByPath)(window,"NeosCMS.I18n.initialized",Boolean(n)),window.dispatchEvent(new CustomEvent("neoscms-i18n-initialized",{bubbles:!0}))),!e},transformAndAppendXliffData=e=>{const n=N.languages[0];if((0,o.isNil)(e))return!1;const r=Object.keys(e);N.store.on("added",((e,n)=>{L.find((e=>e.name===n)).initialized=!0,checkInitialisedNamespaces()})),r.forEach((r=>{Object.keys(e[r]).forEach((i=>{const a=getTransformedNamespace(r,i),s=e[r][i];(0,o.isNil)(s)||N.addResourceBundle(n,a,(e=>(Object.keys(e).forEach((n=>{Array.isArray(e[n])&&e[n].forEach(((r,o)=>{let i=n;Number.isInteger(o)&&1===o&&(i=`${n}_plural`),e[i]=r}))})),e))(s),!0,!0)}))}))},translate=(e,n,r,i,a,s,l)=>{e=e.replace(/\./g,"_");var u,c;const d=(u=r,c=i,((0,o.isEmpty)(u)?E:u.trim())+"/"+((0,o.isEmpty)(c)?A:c.trim()))+":"+e.trim();let p={};return(0,o.isNil)(l)||(p.count=l),(0,o.isNil)(a)||(p.replace=a),(0,o.isEmpty)(n)||(p.defaultValue=n),N.t(d,p)},Localization_init=()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.I18n)&&(window.NeosCMS.I18n={init:Localization_init,translate,initialized:!1})},O={init:Localization_init,initTranslations:e=>{const n={interpolation:{prefix:"{",suffix:"}"},resources:{}},r=(()=>{const e=(0,o.getCollectionValueByPath)(window.NeosCMS,"Configuration.XliffUri");return(0,o.isNil)(e)?"":new URL(e).searchParams.get("locale")})();if(!(0,o.isEmpty)(r)){n[r.match("[a-z]{2}(-[A-Z]{2})")?"lng":"fallbackLng"]=r}(e=>{if((0,o.isNil)(e))return!1;Object.keys(e).forEach((n=>{Object.keys(e[n]).forEach((r=>{const i=getTransformedNamespace(n,r),a=e[n][r];(0,o.isNil)(a)||L.push({name:i,initialized:!1})}))}))})(e),N.init(n,((n,r)=>{transformAndAppendXliffData(e)}))},translate};r(449);class ApiService{constructor(e,n){if((0,o.isNil)(e)){let e="Tried to create API service without a base uri. ";e+="Please initialize the API service with a base path ",e+='like "/neos/impersonate/"',console.error(e)}if(this._basePath=e,(0,o.isNil)(n)){let e="Tried to create API service without a CSFR ";e+="token. Please initialize the API service with a token",console.error(e)}this._csrfToken=n}async callUserChange(e){const n={user:e,format:"json"},r=await fetch(this._basePath+"user-change",{method:"POST",credentials:"include",headers:this._getHeader(),body:JSON.stringify(n)});return await r.json()}async callStatus(){const e=await fetch(this._basePath+"status",{method:"GET",credentials:"include",headers:this._getHeader()});return await e.json()}async callRestore(){const e=await fetch(this._basePath+"restore",{method:"POST",credentials:"include",headers:this._getHeader()});return await e.json()}_getHeader(){return{Accept:"application/json","Content-Type":"application/json","X-Flow-Csrftoken":this._csrfToken}}}const P={init:()=>{(0,o.isNil)(window.NeosCMS)&&(window.NeosCMS={}),(0,o.isNil)(window.NeosCMS.Helper)&&(window.NeosCMS.Helper={isNil:o.isNil,isEmpty:o.isEmpty,getItemByKeyValue:o.getItemByKeyValue,getCollectionValueByPath:o.getCollectionValueByPath,createCollectionByPath:o.createCollectionByPath})}}},482:function(e){e.exports=function(){"use strict";function _toConsumableArray(e){if(Array.isArray(e)){for(var n=0,r=Array(e.length);n<e.length;n++)r[n]=e[n];return r}return Array.from(e)}var e=Object.hasOwnProperty,n=Object.setPrototypeOf,r=Object.isFrozen,o=Object.getPrototypeOf,i=Object.getOwnPropertyDescriptor,a=Object.freeze,s=Object.seal,l=Object.create,u="undefined"!=typeof Reflect&&Reflect,c=u.apply,d=u.construct;c||(c=function apply(e,n,r){return e.apply(n,r)}),a||(a=function freeze(e){return e}),s||(s=function seal(e){return e}),d||(d=function construct(e,n){return new(Function.prototype.bind.apply(e,[null].concat(_toConsumableArray(n))))});var p=unapply(Array.prototype.forEach),f=unapply(Array.prototype.pop),h=unapply(Array.prototype.push),g=unapply(String.prototype.toLowerCase),m=unapply(String.prototype.match),y=unapply(String.prototype.replace),v=unapply(String.prototype.indexOf),b=unapply(String.prototype.trim),x=unapply(RegExp.prototype.test),w=unconstruct(TypeError);function unapply(e){return function(n){for(var r=arguments.length,o=Array(r>1?r-1:0),i=1;i<r;i++)o[i-1]=arguments[i];return c(e,n,o)}}function unconstruct(e){return function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];return d(e,r)}}function addToSet(e,o){n&&n(e,null);for(var i=o.length;i--;){var a=o[i];if("string"==typeof a){var s=g(a);s!==a&&(r(o)||(o[i]=s),a=s)}e[a]=!0}return e}function clone(n){var r=l(null),o=void 0;for(o in n)c(e,n,[o])&&(r[o]=n[o]);return r}function lookupGetter(e,n){for(;null!==e;){var r=i(e,n);if(r){if(r.get)return unapply(r.get);if("function"==typeof r.value)return unapply(r.value)}e=o(e)}return null}var S=a(["a","abbr","acronym","address","area","article","aside","audio","b","bdi","bdo","big","blink","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","content","data","datalist","dd","decorator","del","details","dfn","dialog","dir","div","dl","dt","element","em","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","kbd","label","legend","li","main","map","mark","marquee","menu","menuitem","meter","nav","nobr","ol","optgroup","option","output","p","picture","pre","progress","q","rp","rt","ruby","s","samp","section","select","shadow","small","source","spacer","span","strike","strong","style","sub","summary","sup","table","tbody","td","template","textarea","tfoot","th","thead","time","tr","track","tt","u","ul","var","video","wbr"]),T=a(["svg","a","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","circle","clippath","defs","desc","ellipse","filter","font","g","glyph","glyphref","hkern","image","line","lineargradient","marker","mask","metadata","mpath","path","pattern","polygon","polyline","radialgradient","rect","stop","style","switch","symbol","text","textpath","title","tref","tspan","view","vkern"]),C=a(["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]),k=a(["animate","color-profile","cursor","discard","fedropshadow","feimage","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignobject","hatch","hatchpath","mesh","meshgradient","meshpatch","meshrow","missing-glyph","script","set","solidcolor","unknown","use"]),N=a(["math","menclose","merror","mfenced","mfrac","mglyph","mi","mlabeledtr","mmultiscripts","mn","mo","mover","mpadded","mphantom","mroot","mrow","ms","mspace","msqrt","mstyle","msub","msup","msubsup","mtable","mtd","mtext","mtr","munder","munderover"]),E=a(["maction","maligngroup","malignmark","mlongdiv","mscarries","mscarry","msgroup","mstack","msline","msrow","semantics","annotation","annotation-xml","mprescripts","none"]),A=a(["#text"]),L=a(["accept","action","align","alt","autocapitalize","autocomplete","autopictureinpicture","autoplay","background","bgcolor","border","capture","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","controls","controlslist","coords","crossorigin","datetime","decoding","default","dir","disabled","disablepictureinpicture","disableremoteplayback","download","draggable","enctype","enterkeyhint","face","for","headers","height","hidden","high","href","hreflang","id","inputmode","integrity","ismap","kind","label","lang","list","loading","loop","low","max","maxlength","media","method","min","minlength","multiple","muted","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","playsinline","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","role","rows","rowspan","spellcheck","scope","selected","shape","size","sizes","span","srclang","start","src","srcset","step","style","summary","tabindex","title","translate","type","usemap","valign","value","width","xmlns"]),O=a(["accent-height","accumulate","additive","alignment-baseline","ascent","attributename","attributetype","azimuth","basefrequency","baseline-shift","begin","bias","by","class","clip","clippathunits","clip-path","clip-rule","color","color-interpolation","color-interpolation-filters","color-profile","color-rendering","cx","cy","d","dx","dy","diffuseconstant","direction","display","divisor","dur","edgemode","elevation","end","fill","fill-opacity","fill-rule","filter","filterunits","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","fx","fy","g1","g2","glyph-name","glyphref","gradientunits","gradienttransform","height","href","id","image-rendering","in","in2","k","k1","k2","k3","k4","kerning","keypoints","keysplines","keytimes","lang","lengthadjust","letter-spacing","kernelmatrix","kernelunitlength","lighting-color","local","marker-end","marker-mid","marker-start","markerheight","markerunits","markerwidth","maskcontentunits","maskunits","max","mask","media","method","mode","min","name","numoctaves","offset","operator","opacity","order","orient","orientation","origin","overflow","paint-order","path","pathlength","patterncontentunits","patterntransform","patternunits","points","preservealpha","preserveaspectratio","primitiveunits","r","rx","ry","radius","refx","refy","repeatcount","repeatdur","restart","result","rotate","scale","seed","shape-rendering","specularconstant","specularexponent","spreadmethod","startoffset","stddeviation","stitchtiles","stop-color","stop-opacity","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke","stroke-width","style","surfacescale","systemlanguage","tabindex","targetx","targety","transform","text-anchor","text-decoration","text-rendering","textlength","type","u1","u2","unicode","values","viewbox","visibility","version","vert-adv-y","vert-origin-x","vert-origin-y","width","word-spacing","wrap","writing-mode","xchannelselector","ychannelselector","x","x1","x2","xmlns","y","y1","y2","z","zoomandpan"]),P=a(["accent","accentunder","align","bevelled","close","columnsalign","columnlines","columnspan","denomalign","depth","dir","display","displaystyle","encoding","fence","frame","height","href","id","largeop","length","linethickness","lspace","lquote","mathbackground","mathcolor","mathsize","mathvariant","maxsize","minsize","movablelimits","notation","numalign","open","rowalign","rowlines","rowspacing","rowspan","rspace","rquote","scriptlevel","scriptminsize","scriptsizemultiplier","selection","separator","separators","stretchy","subscriptshift","supscriptshift","symmetric","voffset","width","xmlns"]),j=a(["xlink:href","xml:id","xlink:title","xml:space","xmlns:xlink"]),D=s(/\{\{[\s\S]*|[\s\S]*\}\}/gm),M=s(/<%[\s\S]*|[\s\S]*%>/gm),R=s(/^data-[\-\w.\u00B7-\uFFFF]/),I=s(/^aria-[\-\w]+$/),q=s(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i),F=s(/^(?:\w+script|data):/i),H=s(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g),z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function _toConsumableArray$1(e){if(Array.isArray(e)){for(var n=0,r=Array(e.length);n<e.length;n++)r[n]=e[n];return r}return Array.from(e)}var B=function getGlobal(){return"undefined"==typeof window?null:window},U=function _createTrustedTypesPolicy(e,n){if("object"!==(void 0===e?"undefined":z(e))||"function"!=typeof e.createPolicy)return null;var r=null,o="data-tt-policy-suffix";n.currentScript&&n.currentScript.hasAttribute(o)&&(r=n.currentScript.getAttribute(o));var i="dompurify"+(r?"#"+r:"");try{return e.createPolicy(i,{createHTML:function createHTML(e){return e}})}catch(e){return console.warn("TrustedTypes policy "+i+" could not be created."),null}};function createDOMPurify(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:B(),n=function DOMPurify(e){return createDOMPurify(e)};if(n.version="2.2.6",n.removed=[],!e||!e.document||9!==e.document.nodeType)return n.isSupported=!1,n;var r=e.document,o=e.document,i=e.DocumentFragment,s=e.HTMLTemplateElement,l=e.Node,u=e.Element,c=e.NodeFilter,d=e.NamedNodeMap,W=void 0===d?e.NamedNodeMap||e.MozNamedAttrMap:d,$=e.Text,V=e.Comment,K=e.DOMParser,G=e.trustedTypes,X=u.prototype,J=lookupGetter(X,"cloneNode"),Y=lookupGetter(X,"nextSibling"),Z=lookupGetter(X,"childNodes"),Q=lookupGetter(X,"parentNode");if("function"==typeof s){var ee=o.createElement("template");ee.content&&ee.content.ownerDocument&&(o=ee.content.ownerDocument)}var te=U(G,r),ne=te&&De?te.createHTML(""):"",re=o,oe=re.implementation,ie=re.createNodeIterator,ae=re.getElementsByTagName,se=re.createDocumentFragment,le=r.importNode,ue={};try{ue=clone(o).documentMode?o.documentMode:{}}catch(e){}var ce={};n.isSupported=oe&&void 0!==oe.createHTMLDocument&&9!==ue;var de=D,pe=M,fe=R,he=I,ge=F,me=H,ye=q,ve=null,be=addToSet({},[].concat(_toConsumableArray$1(S),_toConsumableArray$1(T),_toConsumableArray$1(C),_toConsumableArray$1(N),_toConsumableArray$1(A))),xe=null,we=addToSet({},[].concat(_toConsumableArray$1(L),_toConsumableArray$1(O),_toConsumableArray$1(P),_toConsumableArray$1(j))),Se=null,Te=null,Ce=!0,ke=!0,Ne=!1,_e=!1,Ee=!1,Ae=!1,Le=!1,Oe=!1,Pe=!1,je=!0,De=!1,Me=!0,Re=!0,Ie=!1,qe={},Fe=addToSet({},["annotation-xml","audio","colgroup","desc","foreignobject","head","iframe","math","mi","mn","mo","ms","mtext","noembed","noframes","noscript","plaintext","script","style","svg","template","thead","title","video","xmp"]),He=null,ze=addToSet({},["audio","video","img","source","image","track"]),Be=null,Ue=addToSet({},["alt","class","for","id","label","name","pattern","placeholder","summary","title","value","style","xmlns"]),We=null,$e=o.createElement("form"),Ve=function _parseConfig(e){We&&We===e||(e&&"object"===(void 0===e?"undefined":z(e))||(e={}),e=clone(e),ve="ALLOWED_TAGS"in e?addToSet({},e.ALLOWED_TAGS):be,xe="ALLOWED_ATTR"in e?addToSet({},e.ALLOWED_ATTR):we,Be="ADD_URI_SAFE_ATTR"in e?addToSet(clone(Ue),e.ADD_URI_SAFE_ATTR):Ue,He="ADD_DATA_URI_TAGS"in e?addToSet(clone(ze),e.ADD_DATA_URI_TAGS):ze,Se="FORBID_TAGS"in e?addToSet({},e.FORBID_TAGS):{},Te="FORBID_ATTR"in e?addToSet({},e.FORBID_ATTR):{},qe="USE_PROFILES"in e&&e.USE_PROFILES,Ce=!1!==e.ALLOW_ARIA_ATTR,ke=!1!==e.ALLOW_DATA_ATTR,Ne=e.ALLOW_UNKNOWN_PROTOCOLS||!1,_e=e.SAFE_FOR_TEMPLATES||!1,Ee=e.WHOLE_DOCUMENT||!1,Oe=e.RETURN_DOM||!1,Pe=e.RETURN_DOM_FRAGMENT||!1,je=!1!==e.RETURN_DOM_IMPORT,De=e.RETURN_TRUSTED_TYPE||!1,Le=e.FORCE_BODY||!1,Me=!1!==e.SANITIZE_DOM,Re=!1!==e.KEEP_CONTENT,Ie=e.IN_PLACE||!1,ye=e.ALLOWED_URI_REGEXP||ye,_e&&(ke=!1),Pe&&(Oe=!0),qe&&(ve=addToSet({},[].concat(_toConsumableArray$1(A))),xe=[],!0===qe.html&&(addToSet(ve,S),addToSet(xe,L)),!0===qe.svg&&(addToSet(ve,T),addToSet(xe,O),addToSet(xe,j)),!0===qe.svgFilters&&(addToSet(ve,C),addToSet(xe,O),addToSet(xe,j)),!0===qe.mathMl&&(addToSet(ve,N),addToSet(xe,P),addToSet(xe,j))),e.ADD_TAGS&&(ve===be&&(ve=clone(ve)),addToSet(ve,e.ADD_TAGS)),e.ADD_ATTR&&(xe===we&&(xe=clone(xe)),addToSet(xe,e.ADD_ATTR)),e.ADD_URI_SAFE_ATTR&&addToSet(Be,e.ADD_URI_SAFE_ATTR),Re&&(ve["#text"]=!0),Ee&&addToSet(ve,["html","head","body"]),ve.table&&(addToSet(ve,["tbody"]),delete Se.tbody),a&&a(e),We=e)},Ke=addToSet({},["mi","mo","mn","ms","mtext"]),Ge=addToSet({},["foreignobject","desc","title","annotation-xml"]),Xe=addToSet({},T);addToSet(Xe,C),addToSet(Xe,k);var Je=addToSet({},N);addToSet(Je,E);var Ye="http://www.w3.org/1998/Math/MathML",Ze="http://www.w3.org/2000/svg",Qe="http://www.w3.org/1999/xhtml",et=function _checkValidNamespace(e){var n=Q(e);n&&n.tagName||(n={namespaceURI:Qe,tagName:"template"});var r=g(e.tagName),o=g(n.tagName);if(e.namespaceURI===Ze)return n.namespaceURI===Qe?"svg"===r:n.namespaceURI===Ye?"svg"===r&&("annotation-xml"===o||Ke[o]):Boolean(Xe[r]);if(e.namespaceURI===Ye)return n.namespaceURI===Qe?"math"===r:n.namespaceURI===Ze?"math"===r&&Ge[o]:Boolean(Je[r]);if(e.namespaceURI===Qe){if(n.namespaceURI===Ze&&!Ge[o])return!1;if(n.namespaceURI===Ye&&!Ke[o])return!1;var i=addToSet({},["title","style","font","a","script"]);return!Je[r]&&(i[r]||!Xe[r])}return!1},tt=function _forceRemove(e){h(n.removed,{element:e});try{e.parentNode.removeChild(e)}catch(n){try{e.outerHTML=ne}catch(n){e.remove()}}},nt=function _removeAttribute(e,r){try{h(n.removed,{attribute:r.getAttributeNode(e),from:r})}catch(e){h(n.removed,{attribute:null,from:r})}r.removeAttribute(e)},rt=function _initDocument(e){var n=void 0,r=void 0;if(Le)e="<remove></remove>"+e;else{var i=m(e,/^[\r\n\t ]+/);r=i&&i[0]}var a=te?te.createHTML(e):e;try{n=(new K).parseFromString(a,"text/html")}catch(e){}if(!n||!n.documentElement){var s=(n=oe.createHTMLDocument("")).body;s.parentNode.removeChild(s.parentNode.firstElementChild),s.outerHTML=a}return e&&r&&n.body.insertBefore(o.createTextNode(r),n.body.childNodes[0]||null),ae.call(n,Ee?"html":"body")[0]},ot=function _createIterator(e){return ie.call(e.ownerDocument||e,e,c.SHOW_ELEMENT|c.SHOW_COMMENT|c.SHOW_TEXT,(function(){return c.FILTER_ACCEPT}),!1)},it=function _isClobbered(e){return!(e instanceof $||e instanceof V||"string"==typeof e.nodeName&&"string"==typeof e.textContent&&"function"==typeof e.removeChild&&e.attributes instanceof W&&"function"==typeof e.removeAttribute&&"function"==typeof e.setAttribute&&"string"==typeof e.namespaceURI&&"function"==typeof e.insertBefore)},at=function _isNode(e){return"object"===(void 0===l?"undefined":z(l))?e instanceof l:e&&"object"===(void 0===e?"undefined":z(e))&&"number"==typeof e.nodeType&&"string"==typeof e.nodeName},st=function _executeHook(e,r,o){ce[e]&&p(ce[e],(function(e){e.call(n,r,o,We)}))},lt=function _sanitizeElements(e){var r=void 0;if(st("beforeSanitizeElements",e,null),it(e))return tt(e),!0;if(m(e.nodeName,/[\u0080-\uFFFF]/))return tt(e),!0;var o=g(e.nodeName);if(st("uponSanitizeElement",e,{tagName:o,allowedTags:ve}),!at(e.firstElementChild)&&(!at(e.content)||!at(e.content.firstElementChild))&&x(/<[/\w]/g,e.innerHTML)&&x(/<[/\w]/g,e.textContent))return tt(e),!0;if(!ve[o]||Se[o]){if(Re&&!Fe[o])for(var i=Q(e),a=Z(e),s=a.length-1;s>=0;--s)i.insertBefore(J(a[s],!0),Y(e));return tt(e),!0}return e instanceof u&&!et(e)?(tt(e),!0):"noscript"!==o&&"noembed"!==o||!x(/<\/no(script|embed)/i,e.innerHTML)?(_e&&3===e.nodeType&&(r=e.textContent,r=y(r,de," "),r=y(r,pe," "),e.textContent!==r&&(h(n.removed,{element:e.cloneNode()}),e.textContent=r)),st("afterSanitizeElements",e,null),!1):(tt(e),!0)},ut=function _isValidAttribute(e,n,r){if(Me&&("id"===n||"name"===n)&&(r in o||r in $e))return!1;if(ke&&x(fe,n));else if(Ce&&x(he,n));else{if(!xe[n]||Te[n])return!1;if(Be[n]);else if(x(ye,y(r,me,"")));else if("src"!==n&&"xlink:href"!==n&&"href"!==n||"script"===e||0!==v(r,"data:")||!He[e])if(Ne&&!x(ge,y(r,me,"")));else if(r)return!1}return!0},ct=function _sanitizeAttributes(e){var r=void 0,o=void 0,i=void 0,a=void 0;st("beforeSanitizeAttributes",e,null);var s=e.attributes;if(s){var l={attrName:"",attrValue:"",keepAttr:!0,allowedAttributes:xe};for(a=s.length;a--;){var u=r=s[a],c=u.name,d=u.namespaceURI;if(o=b(r.value),i=g(c),l.attrName=i,l.attrValue=o,l.keepAttr=!0,l.forceKeepAttr=void 0,st("uponSanitizeAttribute",e,l),o=l.attrValue,!l.forceKeepAttr&&(nt(c,e),l.keepAttr))if(x(/\/>/i,o))nt(c,e);else{_e&&(o=y(o,de," "),o=y(o,pe," "));var p=e.nodeName.toLowerCase();if(ut(p,i,o))try{d?e.setAttributeNS(d,c,o):e.setAttribute(c,o),f(n.removed)}catch(e){}}}st("afterSanitizeAttributes",e,null)}},dt=function _sanitizeShadowDOM(e){var n=void 0,r=ot(e);for(st("beforeSanitizeShadowDOM",e,null);n=r.nextNode();)st("uponSanitizeShadowNode",n,null),lt(n)||(n.content instanceof i&&_sanitizeShadowDOM(n.content),ct(n));st("afterSanitizeShadowDOM",e,null)};return n.sanitize=function(o,a){var s=void 0,u=void 0,c=void 0,d=void 0,p=void 0;if(o||(o="\x3c!--\x3e"),"string"!=typeof o&&!at(o)){if("function"!=typeof o.toString)throw w("toString is not a function");if("string"!=typeof(o=o.toString()))throw w("dirty is not a string, aborting")}if(!n.isSupported){if("object"===z(e.toStaticHTML)||"function"==typeof e.toStaticHTML){if("string"==typeof o)return e.toStaticHTML(o);if(at(o))return e.toStaticHTML(o.outerHTML)}return o}if(Ae||Ve(a),n.removed=[],"string"==typeof o&&(Ie=!1),Ie);else if(o instanceof l)1===(u=(s=rt("\x3c!----\x3e")).ownerDocument.importNode(o,!0)).nodeType&&"BODY"===u.nodeName||"HTML"===u.nodeName?s=u:s.appendChild(u);else{if(!Oe&&!_e&&!Ee&&-1===o.indexOf("<"))return te&&De?te.createHTML(o):o;if(!(s=rt(o)))return Oe?null:ne}s&&Le&&tt(s.firstChild);for(var f=ot(Ie?o:s);c=f.nextNode();)3===c.nodeType&&c===d||lt(c)||(c.content instanceof i&&dt(c.content),ct(c),d=c);if(d=null,Ie)return o;if(Oe){if(Pe)for(p=se.call(s.ownerDocument);s.firstChild;)p.appendChild(s.firstChild);else p=s;return je&&(p=le.call(r,p,!0)),p}var h=Ee?s.outerHTML:s.innerHTML;return _e&&(h=y(h,de," "),h=y(h,pe," ")),te&&De?te.createHTML(h):h},n.setConfig=function(e){Ve(e),Ae=!0},n.clearConfig=function(){We=null,Ae=!1},n.isValidAttribute=function(e,n,r){We||Ve({});var o=g(e),i=g(n);return ut(o,i,r)},n.addHook=function(e,n){"function"==typeof n&&(ce[e]=ce[e]||[],h(ce[e],n))},n.removeHook=function(e){ce[e]&&f(ce[e])},n.removeHooks=function(e){ce[e]&&(ce[e]=[])},n.removeAllHooks=function(){ce={}},n}return createDOMPurify()}()},755:function(e,n){var r;!function(n,r){"use strict";"object"==typeof e.exports?e.exports=n.document?r(n,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return r(e)}:r(n)}("undefined"!=typeof window?window:this,(function(o,i){"use strict";var a=[],s=Object.getPrototypeOf,l=a.slice,u=a.flat?function(e){return a.flat.call(e)}:function(e){return a.concat.apply([],e)},c=a.push,d=a.indexOf,p={},f=p.toString,h=p.hasOwnProperty,g=h.toString,m=g.call(Object),y={},v=function isFunction(e){return"function"==typeof e&&"number"!=typeof e.nodeType&&"function"!=typeof e.item},b=function isWindow(e){return null!=e&&e===e.window},x=o.document,w={type:!0,src:!0,nonce:!0,noModule:!0};function DOMEval(e,n,r){var o,i,a=(r=r||x).createElement("script");if(a.text=e,n)for(o in w)(i=n[o]||n.getAttribute&&n.getAttribute(o))&&a.setAttribute(o,i);r.head.appendChild(a).parentNode.removeChild(a)}function toType(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?p[f.call(e)]||"object":typeof e}var S="3.6.0",jQuery=function(e,n){return new jQuery.fn.init(e,n)};function isArrayLike(e){var n=!!e&&"length"in e&&e.length,r=toType(e);return!v(e)&&!b(e)&&("array"===r||0===n||"number"==typeof n&&n>0&&n-1 in e)}jQuery.fn=jQuery.prototype={jquery:S,constructor:jQuery,length:0,toArray:function(){return l.call(this)},get:function(e){return null==e?l.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var n=jQuery.merge(this.constructor(),e);return n.prevObject=this,n},each:function(e){return jQuery.each(this,e)},map:function(e){return this.pushStack(jQuery.map(this,(function(n,r){return e.call(n,r,n)})))},slice:function(){return this.pushStack(l.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},even:function(){return this.pushStack(jQuery.grep(this,(function(e,n){return(n+1)%2})))},odd:function(){return this.pushStack(jQuery.grep(this,(function(e,n){return n%2})))},eq:function(e){var n=this.length,r=+e+(e<0?n:0);return this.pushStack(r>=0&&r<n?[this[r]]:[])},end:function(){return this.prevObject||this.constructor()},push:c,sort:a.sort,splice:a.splice},jQuery.extend=jQuery.fn.extend=function(){var e,n,r,o,i,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[l]||{},l++),"object"==typeof s||v(s)||(s={}),l===u&&(s=this,l--);l<u;l++)if(null!=(e=arguments[l]))for(n in e)o=e[n],"__proto__"!==n&&s!==o&&(c&&o&&(jQuery.isPlainObject(o)||(i=Array.isArray(o)))?(r=s[n],a=i&&!Array.isArray(r)?[]:i||jQuery.isPlainObject(r)?r:{},i=!1,s[n]=jQuery.extend(c,a,o)):void 0!==o&&(s[n]=o));return s},jQuery.extend({expando:"jQuery"+(S+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var n,r;return!(!e||"[object Object]"!==f.call(e))&&(!(n=s(e))||"function"==typeof(r=h.call(n,"constructor")&&n.constructor)&&g.call(r)===m)},isEmptyObject:function(e){var n;for(n in e)return!1;return!0},globalEval:function(e,n,r){DOMEval(e,{nonce:n&&n.nonce},r)},each:function(e,n){var r,o=0;if(isArrayLike(e))for(r=e.length;o<r&&!1!==n.call(e[o],o,e[o]);o++);else for(o in e)if(!1===n.call(e[o],o,e[o]))break;return e},makeArray:function(e,n){var r=n||[];return null!=e&&(isArrayLike(Object(e))?jQuery.merge(r,"string"==typeof e?[e]:e):c.call(r,e)),r},inArray:function(e,n,r){return null==n?-1:d.call(n,e,r)},merge:function(e,n){for(var r=+n.length,o=0,i=e.length;o<r;o++)e[i++]=n[o];return e.length=i,e},grep:function(e,n,r){for(var o=[],i=0,a=e.length,s=!r;i<a;i++)!n(e[i],i)!==s&&o.push(e[i]);return o},map:function(e,n,r){var o,i,a=0,s=[];if(isArrayLike(e))for(o=e.length;a<o;a++)null!=(i=n(e[a],a,r))&&s.push(i);else for(a in e)null!=(i=n(e[a],a,r))&&s.push(i);return u(s)},guid:1,support:y}),"function"==typeof Symbol&&(jQuery.fn[Symbol.iterator]=a[Symbol.iterator]),jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),(function(e,n){p["[object "+n+"]"]=n.toLowerCase()}));var T=function(e){var n,r,o,i,a,s,l,u,c,d,p,f,h,g,m,y,v,b,x,w="sizzle"+1*new Date,S=e.document,T=0,C=0,k=createCache(),N=createCache(),E=createCache(),A=createCache(),sortOrder=function(e,n){return e===n&&(p=!0),0},L={}.hasOwnProperty,O=[],P=O.pop,j=O.push,D=O.push,M=O.slice,indexOf=function(e,n){for(var r=0,o=e.length;r<o;r++)if(e[r]===n)return r;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",I="[\\x20\\t\\r\\n\\f]",q="(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",F="\\[[\\x20\\t\\r\\n\\f]*("+q+")(?:"+I+"*([*^$|!~]?=)"+I+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+q+"))|)"+I+"*\\]",H=":("+q+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+F+")*)|.*)\\)|)",z=new RegExp(I+"+","g"),B=new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$","g"),U=new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),W=new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),$=new RegExp(I+"|>"),V=new RegExp(H),K=new RegExp("^"+q+"$"),G={ID:new RegExp("^#("+q+")"),CLASS:new RegExp("^\\.("+q+")"),TAG:new RegExp("^("+q+"|[*])"),ATTR:new RegExp("^"+F),PSEUDO:new RegExp("^"+H),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)","i")},X=/HTML$/i,J=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,Q=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])","g"),funescape=function(e,n){var r="0x"+e.slice(1)-65536;return n||(r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320))},ne=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,fcssescape=function(e,n){return n?"\0"===e?"":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},unloadHandler=function(){f()},re=addCombinator((function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()}),{dir:"parentNode",next:"legend"});try{D.apply(O=M.call(S.childNodes),S.childNodes),O[S.childNodes.length].nodeType}catch(e){D={apply:O.length?function(e,n){j.apply(e,M.call(n))}:function(e,n){for(var r=e.length,o=0;e[r++]=n[o++];);e.length=r-1}}}function Sizzle(e,n,o,i){var a,l,c,d,p,g,v,b=n&&n.ownerDocument,S=n?n.nodeType:9;if(o=o||[],"string"!=typeof e||!e||1!==S&&9!==S&&11!==S)return o;if(!i&&(f(n),n=n||h,m)){if(11!==S&&(p=Q.exec(e)))if(a=p[1]){if(9===S){if(!(c=n.getElementById(a)))return o;if(c.id===a)return o.push(c),o}else if(b&&(c=b.getElementById(a))&&x(n,c)&&c.id===a)return o.push(c),o}else{if(p[2])return D.apply(o,n.getElementsByTagName(e)),o;if((a=p[3])&&r.getElementsByClassName&&n.getElementsByClassName)return D.apply(o,n.getElementsByClassName(a)),o}if(r.qsa&&!A[e+" "]&&(!y||!y.test(e))&&(1!==S||"object"!==n.nodeName.toLowerCase())){if(v=e,b=n,1===S&&($.test(e)||W.test(e))){for((b=ee.test(e)&&testContext(n.parentNode)||n)===n&&r.scope||((d=n.getAttribute("id"))?d=d.replace(ne,fcssescape):n.setAttribute("id",d=w)),l=(g=s(e)).length;l--;)g[l]=(d?"#"+d:":scope")+" "+toSelector(g[l]);v=g.join(",")}try{return D.apply(o,b.querySelectorAll(v)),o}catch(n){A(e,!0)}finally{d===w&&n.removeAttribute("id")}}}return u(e.replace(B,"$1"),n,o,i)}function createCache(){var e=[];return function cache(n,r){return e.push(n+" ")>o.cacheLength&&delete cache[e.shift()],cache[n+" "]=r}}function markFunction(e){return e[w]=!0,e}function assert(e){var n=h.createElement("fieldset");try{return!!e(n)}catch(e){return!1}finally{n.parentNode&&n.parentNode.removeChild(n),n=null}}function addHandle(e,n){for(var r=e.split("|"),i=r.length;i--;)o.attrHandle[r[i]]=n}function siblingCheck(e,n){var r=n&&e,o=r&&1===e.nodeType&&1===n.nodeType&&e.sourceIndex-n.sourceIndex;if(o)return o;if(r)for(;r=r.nextSibling;)if(r===n)return-1;return e?1:-1}function createInputPseudo(e){return function(n){return"input"===n.nodeName.toLowerCase()&&n.type===e}}function createButtonPseudo(e){return function(n){var r=n.nodeName.toLowerCase();return("input"===r||"button"===r)&&n.type===e}}function createDisabledPseudo(e){return function(n){return"form"in n?n.parentNode&&!1===n.disabled?"label"in n?"label"in n.parentNode?n.parentNode.disabled===e:n.disabled===e:n.isDisabled===e||n.isDisabled!==!e&&re(n)===e:n.disabled===e:"label"in n&&n.disabled===e}}function createPositionalPseudo(e){return markFunction((function(n){return n=+n,markFunction((function(r,o){for(var i,a=e([],r.length,n),s=a.length;s--;)r[i=a[s]]&&(r[i]=!(o[i]=r[i]))}))}))}function testContext(e){return e&&void 0!==e.getElementsByTagName&&e}for(n in r=Sizzle.support={},a=Sizzle.isXML=function(e){var n=e&&e.namespaceURI,r=e&&(e.ownerDocument||e).documentElement;return!X.test(n||r&&r.nodeName||"HTML")},f=Sizzle.setDocument=function(e){var n,i,s=e?e.ownerDocument||e:S;return s!=h&&9===s.nodeType&&s.documentElement?(g=(h=s).documentElement,m=!a(h),S!=h&&(i=h.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",unloadHandler,!1):i.attachEvent&&i.attachEvent("onunload",unloadHandler)),r.scope=assert((function(e){return g.appendChild(e).appendChild(h.createElement("div")),void 0!==e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length})),r.attributes=assert((function(e){return e.className="i",!e.getAttribute("className")})),r.getElementsByTagName=assert((function(e){return e.appendChild(h.createComment("")),!e.getElementsByTagName("*").length})),r.getElementsByClassName=Z.test(h.getElementsByClassName),r.getById=assert((function(e){return g.appendChild(e).id=w,!h.getElementsByName||!h.getElementsByName(w).length})),r.getById?(o.filter.ID=function(e){var n=e.replace(te,funescape);return function(e){return e.getAttribute("id")===n}},o.find.ID=function(e,n){if(void 0!==n.getElementById&&m){var r=n.getElementById(e);return r?[r]:[]}}):(o.filter.ID=function(e){var n=e.replace(te,funescape);return function(e){var r=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return r&&r.value===n}},o.find.ID=function(e,n){if(void 0!==n.getElementById&&m){var r,o,i,a=n.getElementById(e);if(a){if((r=a.getAttributeNode("id"))&&r.value===e)return[a];for(i=n.getElementsByName(e),o=0;a=i[o++];)if((r=a.getAttributeNode("id"))&&r.value===e)return[a]}return[]}}),o.find.TAG=r.getElementsByTagName?function(e,n){return void 0!==n.getElementsByTagName?n.getElementsByTagName(e):r.qsa?n.querySelectorAll(e):void 0}:function(e,n){var r,o=[],i=0,a=n.getElementsByTagName(e);if("*"===e){for(;r=a[i++];)1===r.nodeType&&o.push(r);return o}return a},o.find.CLASS=r.getElementsByClassName&&function(e,n){if(void 0!==n.getElementsByClassName&&m)return n.getElementsByClassName(e)},v=[],y=[],(r.qsa=Z.test(h.querySelectorAll))&&(assert((function(e){var n;g.appendChild(e).innerHTML="<a id='"+w+"'></a><select id='"+w+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&y.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),e.querySelectorAll("[selected]").length||y.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|"+R+")"),e.querySelectorAll("[id~="+w+"-]").length||y.push("~="),(n=h.createElement("input")).setAttribute("name",""),e.appendChild(n),e.querySelectorAll("[name='']").length||y.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"),e.querySelectorAll(":checked").length||y.push(":checked"),e.querySelectorAll("a#"+w+"+*").length||y.push(".#.+[+~]"),e.querySelectorAll("\\\f"),y.push("[\\r\\n\\f]")})),assert((function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var n=h.createElement("input");n.setAttribute("type","hidden"),e.appendChild(n).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&y.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&y.push(":enabled",":disabled"),g.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&y.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),y.push(",.*:")}))),(r.matchesSelector=Z.test(b=g.matches||g.webkitMatchesSelector||g.mozMatchesSelector||g.oMatchesSelector||g.msMatchesSelector))&&assert((function(e){r.disconnectedMatch=b.call(e,"*"),b.call(e,"[s!='']:x"),v.push("!=",H)})),y=y.length&&new RegExp(y.join("|")),v=v.length&&new RegExp(v.join("|")),n=Z.test(g.compareDocumentPosition),x=n||Z.test(g.contains)?function(e,n){var r=9===e.nodeType?e.documentElement:e,o=n&&n.parentNode;return e===o||!(!o||1!==o.nodeType||!(r.contains?r.contains(o):e.compareDocumentPosition&&16&e.compareDocumentPosition(o)))}:function(e,n){if(n)for(;n=n.parentNode;)if(n===e)return!0;return!1},sortOrder=n?function(e,n){if(e===n)return p=!0,0;var o=!e.compareDocumentPosition-!n.compareDocumentPosition;return o||(1&(o=(e.ownerDocument||e)==(n.ownerDocument||n)?e.compareDocumentPosition(n):1)||!r.sortDetached&&n.compareDocumentPosition(e)===o?e==h||e.ownerDocument==S&&x(S,e)?-1:n==h||n.ownerDocument==S&&x(S,n)?1:d?indexOf(d,e)-indexOf(d,n):0:4&o?-1:1)}:function(e,n){if(e===n)return p=!0,0;var r,o=0,i=e.parentNode,a=n.parentNode,s=[e],l=[n];if(!i||!a)return e==h?-1:n==h?1:i?-1:a?1:d?indexOf(d,e)-indexOf(d,n):0;if(i===a)return siblingCheck(e,n);for(r=e;r=r.parentNode;)s.unshift(r);for(r=n;r=r.parentNode;)l.unshift(r);for(;s[o]===l[o];)o++;return o?siblingCheck(s[o],l[o]):s[o]==S?-1:l[o]==S?1:0},h):h},Sizzle.matches=function(e,n){return Sizzle(e,null,null,n)},Sizzle.matchesSelector=function(e,n){if(f(e),r.matchesSelector&&m&&!A[n+" "]&&(!v||!v.test(n))&&(!y||!y.test(n)))try{var o=b.call(e,n);if(o||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return o}catch(e){A(n,!0)}return Sizzle(n,h,null,[e]).length>0},Sizzle.contains=function(e,n){return(e.ownerDocument||e)!=h&&f(e),x(e,n)},Sizzle.attr=function(e,n){(e.ownerDocument||e)!=h&&f(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!m):void 0;return void 0!==a?a:r.attributes||!m?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null},Sizzle.escape=function(e){return(e+"").replace(ne,fcssescape)},Sizzle.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},Sizzle.uniqueSort=function(e){var n,o=[],i=0,a=0;if(p=!r.detectDuplicates,d=!r.sortStable&&e.slice(0),e.sort(sortOrder),p){for(;n=e[a++];)n===e[a]&&(i=o.push(a));for(;i--;)e.splice(o[i],1)}return d=null,e},i=Sizzle.getText=function(e){var n,r="",o=0,a=e.nodeType;if(a){if(1===a||9===a||11===a){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)r+=i(e)}else if(3===a||4===a)return e.nodeValue}else for(;n=e[o++];)r+=i(n);return r},(o=Sizzle.selectors={cacheLength:50,createPseudo:markFunction,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,funescape),e[3]=(e[3]||e[4]||e[5]||"").replace(te,funescape),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||Sizzle.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&Sizzle.error(e[0]),e},PSEUDO:function(e){var n,r=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":r&&V.test(r)&&(n=s(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var n=e.replace(te,funescape).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===n}},CLASS:function(e){var n=k[e+" "];return n||(n=new RegExp("(^|[\\x20\\t\\r\\n\\f])"+e+"("+I+"|$)"))&&k(e,(function(e){return n.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")}))},ATTR:function(e,n,r){return function(o){var i=Sizzle.attr(o,e);return null==i?"!="===n:!n||(i+="","="===n?i===r:"!="===n?i!==r:"^="===n?r&&0===i.indexOf(r):"*="===n?r&&i.indexOf(r)>-1:"$="===n?r&&i.slice(-r.length)===r:"~="===n?(" "+i.replace(z," ")+" ").indexOf(r)>-1:"|="===n&&(i===r||i.slice(0,r.length+1)===r+"-"))}},CHILD:function(e,n,r,o,i){var a="nth"!==e.slice(0,3),s="last"!==e.slice(-4),l="of-type"===n;return 1===o&&0===i?function(e){return!!e.parentNode}:function(n,r,u){var c,d,p,f,h,g,m=a!==s?"nextSibling":"previousSibling",y=n.parentNode,v=l&&n.nodeName.toLowerCase(),b=!u&&!l,x=!1;if(y){if(a){for(;m;){for(f=n;f=f[m];)if(l?f.nodeName.toLowerCase()===v:1===f.nodeType)return!1;g=m="only"===e&&!g&&"nextSibling"}return!0}if(g=[s?y.firstChild:y.lastChild],s&&b){for(x=(h=(c=(d=(p=(f=y)[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]||[])[0]===T&&c[1])&&c[2],f=h&&y.childNodes[h];f=++h&&f&&f[m]||(x=h=0)||g.pop();)if(1===f.nodeType&&++x&&f===n){d[e]=[T,h,x];break}}else if(b&&(x=h=(c=(d=(p=(f=n)[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]||[])[0]===T&&c[1]),!1===x)for(;(f=++h&&f&&f[m]||(x=h=0)||g.pop())&&((l?f.nodeName.toLowerCase()!==v:1!==f.nodeType)||!++x||(b&&((d=(p=f[w]||(f[w]={}))[f.uniqueID]||(p[f.uniqueID]={}))[e]=[T,x]),f!==n)););return(x-=i)===o||x%o==0&&x/o>=0}}},PSEUDO:function(e,n){var r,i=o.pseudos[e]||o.setFilters[e.toLowerCase()]||Sizzle.error("unsupported pseudo: "+e);return i[w]?i(n):i.length>1?(r=[e,e,"",n],o.setFilters.hasOwnProperty(e.toLowerCase())?markFunction((function(e,r){for(var o,a=i(e,n),s=a.length;s--;)e[o=indexOf(e,a[s])]=!(r[o]=a[s])})):function(e){return i(e,0,r)}):i}},pseudos:{not:markFunction((function(e){var n=[],r=[],o=l(e.replace(B,"$1"));return o[w]?markFunction((function(e,n,r,i){for(var a,s=o(e,null,i,[]),l=e.length;l--;)(a=s[l])&&(e[l]=!(n[l]=a))})):function(e,i,a){return n[0]=e,o(n,null,a,r),n[0]=null,!r.pop()}})),has:markFunction((function(e){return function(n){return Sizzle(e,n).length>0}})),contains:markFunction((function(e){return e=e.replace(te,funescape),function(n){return(n.textContent||i(n)).indexOf(e)>-1}})),lang:markFunction((function(e){return K.test(e||"")||Sizzle.error("unsupported lang: "+e),e=e.replace(te,funescape).toLowerCase(),function(n){var r;do{if(r=m?n.lang:n.getAttribute("xml:lang")||n.getAttribute("lang"))return(r=r.toLowerCase())===e||0===r.indexOf(e+"-")}while((n=n.parentNode)&&1===n.nodeType);return!1}})),target:function(n){var r=e.location&&e.location.hash;return r&&r.slice(1)===n.id},root:function(e){return e===g},focus:function(e){return e===h.activeElement&&(!h.hasFocus||h.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:createDisabledPseudo(!1),disabled:createDisabledPseudo(!0),checked:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&!!e.checked||"option"===n&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return J.test(e.nodeName)},button:function(e){var n=e.nodeName.toLowerCase();return"input"===n&&"button"===e.type||"button"===n},text:function(e){var n;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(n=e.getAttribute("type"))||"text"===n.toLowerCase())},first:createPositionalPseudo((function(){return[0]})),last:createPositionalPseudo((function(e,n){return[n-1]})),eq:createPositionalPseudo((function(e,n,r){return[r<0?r+n:r]})),even:createPositionalPseudo((function(e,n){for(var r=0;r<n;r+=2)e.push(r);return e})),odd:createPositionalPseudo((function(e,n){for(var r=1;r<n;r+=2)e.push(r);return e})),lt:createPositionalPseudo((function(e,n,r){for(var o=r<0?r+n:r>n?n:r;--o>=0;)e.push(o);return e})),gt:createPositionalPseudo((function(e,n,r){for(var o=r<0?r+n:r;++o<n;)e.push(o);return e}))}}).pseudos.nth=o.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=createInputPseudo(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=createButtonPseudo(n);function setFilters(){}function toSelector(e){for(var n=0,r=e.length,o="";n<r;n++)o+=e[n].value;return o}function addCombinator(e,n,r){var o=n.dir,i=n.next,a=i||o,s=r&&"parentNode"===a,l=C++;return n.first?function(n,r,i){for(;n=n[o];)if(1===n.nodeType||s)return e(n,r,i);return!1}:function(n,r,u){var c,d,p,f=[T,l];if(u){for(;n=n[o];)if((1===n.nodeType||s)&&e(n,r,u))return!0}else for(;n=n[o];)if(1===n.nodeType||s)if(d=(p=n[w]||(n[w]={}))[n.uniqueID]||(p[n.uniqueID]={}),i&&i===n.nodeName.toLowerCase())n=n[o]||n;else{if((c=d[a])&&c[0]===T&&c[1]===l)return f[2]=c[2];if(d[a]=f,f[2]=e(n,r,u))return!0}return!1}}function elementMatcher(e){return e.length>1?function(n,r,o){for(var i=e.length;i--;)if(!e[i](n,r,o))return!1;return!0}:e[0]}function condense(e,n,r,o,i){for(var a,s=[],l=0,u=e.length,c=null!=n;l<u;l++)(a=e[l])&&(r&&!r(a,o,i)||(s.push(a),c&&n.push(l)));return s}function setMatcher(e,n,r,o,i,a){return o&&!o[w]&&(o=setMatcher(o)),i&&!i[w]&&(i=setMatcher(i,a)),markFunction((function(a,s,l,u){var c,d,p,f=[],h=[],g=s.length,m=a||function multipleContexts(e,n,r){for(var o=0,i=n.length;o<i;o++)Sizzle(e,n[o],r);return r}(n||"*",l.nodeType?[l]:l,[]),y=!e||!a&&n?m:condense(m,f,e,l,u),v=r?i||(a?e:g||o)?[]:s:y;if(r&&r(y,v,l,u),o)for(c=condense(v,h),o(c,[],l,u),d=c.length;d--;)(p=c[d])&&(v[h[d]]=!(y[h[d]]=p));if(a){if(i||e){if(i){for(c=[],d=v.length;d--;)(p=v[d])&&c.push(y[d]=p);i(null,v=[],c,u)}for(d=v.length;d--;)(p=v[d])&&(c=i?indexOf(a,p):f[d])>-1&&(a[c]=!(s[c]=p))}}else v=condense(v===s?v.splice(g,v.length):v),i?i(null,s,v,u):D.apply(s,v)}))}function matcherFromTokens(e){for(var n,r,i,a=e.length,s=o.relative[e[0].type],l=s||o.relative[" "],u=s?1:0,d=addCombinator((function(e){return e===n}),l,!0),p=addCombinator((function(e){return indexOf(n,e)>-1}),l,!0),f=[function(e,r,o){var i=!s&&(o||r!==c)||((n=r).nodeType?d(e,r,o):p(e,r,o));return n=null,i}];u<a;u++)if(r=o.relative[e[u].type])f=[addCombinator(elementMatcher(f),r)];else{if((r=o.filter[e[u].type].apply(null,e[u].matches))[w]){for(i=++u;i<a&&!o.relative[e[i].type];i++);return setMatcher(u>1&&elementMatcher(f),u>1&&toSelector(e.slice(0,u-1).concat({value:" "===e[u-2].type?"*":""})).replace(B,"$1"),r,u<i&&matcherFromTokens(e.slice(u,i)),i<a&&matcherFromTokens(e=e.slice(i)),i<a&&toSelector(e))}f.push(r)}return elementMatcher(f)}return setFilters.prototype=o.filters=o.pseudos,o.setFilters=new setFilters,s=Sizzle.tokenize=function(e,n){var r,i,a,s,l,u,c,d=N[e+" "];if(d)return n?0:d.slice(0);for(l=e,u=[],c=o.preFilter;l;){for(s in r&&!(i=U.exec(l))||(i&&(l=l.slice(i[0].length)||l),u.push(a=[])),r=!1,(i=W.exec(l))&&(r=i.shift(),a.push({value:r,type:i[0].replace(B," ")}),l=l.slice(r.length)),o.filter)!(i=G[s].exec(l))||c[s]&&!(i=c[s](i))||(r=i.shift(),a.push({value:r,type:s,matches:i}),l=l.slice(r.length));if(!r)break}return n?l.length:l?Sizzle.error(e):N(e,u).slice(0)},l=Sizzle.compile=function(e,n){var r,i=[],a=[],l=E[e+" "];if(!l){for(n||(n=s(e)),r=n.length;r--;)(l=matcherFromTokens(n[r]))[w]?i.push(l):a.push(l);(l=E(e,function matcherFromGroupMatchers(e,n){var r=n.length>0,i=e.length>0,superMatcher=function(a,s,l,u,d){var p,g,y,v=0,b="0",x=a&&[],w=[],S=c,C=a||i&&o.find.TAG("*",d),k=T+=null==S?1:Math.random()||.1,N=C.length;for(d&&(c=s==h||s||d);b!==N&&null!=(p=C[b]);b++){if(i&&p){for(g=0,s||p.ownerDocument==h||(f(p),l=!m);y=e[g++];)if(y(p,s||h,l)){u.push(p);break}d&&(T=k)}r&&((p=!y&&p)&&v--,a&&x.push(p))}if(v+=b,r&&b!==v){for(g=0;y=n[g++];)y(x,w,s,l);if(a){if(v>0)for(;b--;)x[b]||w[b]||(w[b]=P.call(u));w=condense(w)}D.apply(u,w),d&&!a&&w.length>0&&v+n.length>1&&Sizzle.uniqueSort(u)}return d&&(T=k,c=S),x};return r?markFunction(superMatcher):superMatcher}(a,i))).selector=e}return l},u=Sizzle.select=function(e,n,r,i){var a,u,c,d,p,f="function"==typeof e&&e,h=!i&&s(e=f.selector||e);if(r=r||[],1===h.length){if((u=h[0]=h[0].slice(0)).length>2&&"ID"===(c=u[0]).type&&9===n.nodeType&&m&&o.relative[u[1].type]){if(!(n=(o.find.ID(c.matches[0].replace(te,funescape),n)||[])[0]))return r;f&&(n=n.parentNode),e=e.slice(u.shift().value.length)}for(a=G.needsContext.test(e)?0:u.length;a--&&(c=u[a],!o.relative[d=c.type]);)if((p=o.find[d])&&(i=p(c.matches[0].replace(te,funescape),ee.test(u[0].type)&&testContext(n.parentNode)||n))){if(u.splice(a,1),!(e=i.length&&toSelector(u)))return D.apply(r,i),r;break}}return(f||l(e,h))(i,n,!m,r,!n||ee.test(e)&&testContext(n.parentNode)||n),r},r.sortStable=w.split("").sort(sortOrder).join("")===w,r.detectDuplicates=!!p,f(),r.sortDetached=assert((function(e){return 1&e.compareDocumentPosition(h.createElement("fieldset"))})),assert((function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")}))||addHandle("type|href|height|width",(function(e,n,r){if(!r)return e.getAttribute(n,"type"===n.toLowerCase()?1:2)})),r.attributes&&assert((function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")}))||addHandle("value",(function(e,n,r){if(!r&&"input"===e.nodeName.toLowerCase())return e.defaultValue})),assert((function(e){return null==e.getAttribute("disabled")}))||addHandle(R,(function(e,n,r){var o;if(!r)return!0===e[n]?n.toLowerCase():(o=e.getAttributeNode(n))&&o.specified?o.value:null})),Sizzle}(o);jQuery.find=T,jQuery.expr=T.selectors,jQuery.expr[":"]=jQuery.expr.pseudos,jQuery.uniqueSort=jQuery.unique=T.uniqueSort,jQuery.text=T.getText,jQuery.isXMLDoc=T.isXML,jQuery.contains=T.contains,jQuery.escapeSelector=T.escape;var dir=function(e,n,r){for(var o=[],i=void 0!==r;(e=e[n])&&9!==e.nodeType;)if(1===e.nodeType){if(i&&jQuery(e).is(r))break;o.push(e)}return o},siblings=function(e,n){for(var r=[];e;e=e.nextSibling)1===e.nodeType&&e!==n&&r.push(e);return r},C=jQuery.expr.match.needsContext;function nodeName(e,n){return e.nodeName&&e.nodeName.toLowerCase()===n.toLowerCase()}var k=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function winnow(e,n,r){return v(n)?jQuery.grep(e,(function(e,o){return!!n.call(e,o,e)!==r})):n.nodeType?jQuery.grep(e,(function(e){return e===n!==r})):"string"!=typeof n?jQuery.grep(e,(function(e){return d.call(n,e)>-1!==r})):jQuery.filter(n,e,r)}jQuery.filter=function(e,n,r){var o=n[0];return r&&(e=":not("+e+")"),1===n.length&&1===o.nodeType?jQuery.find.matchesSelector(o,e)?[o]:[]:jQuery.find.matches(e,jQuery.grep(n,(function(e){return 1===e.nodeType})))},jQuery.fn.extend({find:function(e){var n,r,o=this.length,i=this;if("string"!=typeof e)return this.pushStack(jQuery(e).filter((function(){for(n=0;n<o;n++)if(jQuery.contains(i[n],this))return!0})));for(r=this.pushStack([]),n=0;n<o;n++)jQuery.find(e,i[n],r);return o>1?jQuery.uniqueSort(r):r},filter:function(e){return this.pushStack(winnow(this,e||[],!1))},not:function(e){return this.pushStack(winnow(this,e||[],!0))},is:function(e){return!!winnow(this,"string"==typeof e&&C.test(e)?jQuery(e):e||[],!1).length}});var N,E=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(jQuery.fn.init=function(e,n,r){var o,i;if(!e)return this;if(r=r||N,"string"==typeof e){if(!(o="<"===e[0]&&">"===e[e.length-1]&&e.length>=3?[null,e,null]:E.exec(e))||!o[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(o[1]){if(n=n instanceof jQuery?n[0]:n,jQuery.merge(this,jQuery.parseHTML(o[1],n&&n.nodeType?n.ownerDocument||n:x,!0)),k.test(o[1])&&jQuery.isPlainObject(n))for(o in n)v(this[o])?this[o](n[o]):this.attr(o,n[o]);return this}return(i=x.getElementById(o[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):v(e)?void 0!==r.ready?r.ready(e):e(jQuery):jQuery.makeArray(e,this)}).prototype=jQuery.fn,N=jQuery(x);var A=/^(?:parents|prev(?:Until|All))/,L={children:!0,contents:!0,next:!0,prev:!0};function sibling(e,n){for(;(e=e[n])&&1!==e.nodeType;);return e}jQuery.fn.extend({has:function(e){var n=jQuery(e,this),r=n.length;return this.filter((function(){for(var e=0;e<r;e++)if(jQuery.contains(this,n[e]))return!0}))},closest:function(e,n){var r,o=0,i=this.length,a=[],s="string"!=typeof e&&jQuery(e);if(!C.test(e))for(;o<i;o++)for(r=this[o];r&&r!==n;r=r.parentNode)if(r.nodeType<11&&(s?s.index(r)>-1:1===r.nodeType&&jQuery.find.matchesSelector(r,e))){a.push(r);break}return this.pushStack(a.length>1?jQuery.uniqueSort(a):a)},index:function(e){return e?"string"==typeof e?d.call(jQuery(e),this[0]):d.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,n){return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(),jQuery(e,n))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),jQuery.each({parent:function(e){var n=e.parentNode;return n&&11!==n.nodeType?n:null},parents:function(e){return dir(e,"parentNode")},parentsUntil:function(e,n,r){return dir(e,"parentNode",r)},next:function(e){return sibling(e,"nextSibling")},prev:function(e){return sibling(e,"previousSibling")},nextAll:function(e){return dir(e,"nextSibling")},prevAll:function(e){return dir(e,"previousSibling")},nextUntil:function(e,n,r){return dir(e,"nextSibling",r)},prevUntil:function(e,n,r){return dir(e,"previousSibling",r)},siblings:function(e){return siblings((e.parentNode||{}).firstChild,e)},children:function(e){return siblings(e.firstChild)},contents:function(e){return null!=e.contentDocument&&s(e.contentDocument)?e.contentDocument:(nodeName(e,"template")&&(e=e.content||e),jQuery.merge([],e.childNodes))}},(function(e,n){jQuery.fn[e]=function(r,o){var i=jQuery.map(this,n,r);return"Until"!==e.slice(-5)&&(o=r),o&&"string"==typeof o&&(i=jQuery.filter(o,i)),this.length>1&&(L[e]||jQuery.uniqueSort(i),A.test(e)&&i.reverse()),this.pushStack(i)}}));var O=/[^\x20\t\r\n\f]+/g;function Identity(e){return e}function Thrower(e){throw e}function adoptValue(e,n,r,o){var i;try{e&&v(i=e.promise)?i.call(e).done(n).fail(r):e&&v(i=e.then)?i.call(e,n,r):n.apply(void 0,[e].slice(o))}catch(e){r.apply(void 0,[e])}}jQuery.Callbacks=function(e){e="string"==typeof e?function createOptions(e){var n={};return jQuery.each(e.match(O)||[],(function(e,r){n[r]=!0})),n}(e):jQuery.extend({},e);var n,r,o,i,a=[],s=[],l=-1,fire=function(){for(i=i||e.once,o=n=!0;s.length;l=-1)for(r=s.shift();++l<a.length;)!1===a[l].apply(r[0],r[1])&&e.stopOnFalse&&(l=a.length,r=!1);e.memory||(r=!1),n=!1,i&&(a=r?[]:"")},u={add:function(){return a&&(r&&!n&&(l=a.length-1,s.push(r)),function add(n){jQuery.each(n,(function(n,r){v(r)?e.unique&&u.has(r)||a.push(r):r&&r.length&&"string"!==toType(r)&&add(r)}))}(arguments),r&&!n&&fire()),this},remove:function(){return jQuery.each(arguments,(function(e,n){for(var r;(r=jQuery.inArray(n,a,r))>-1;)a.splice(r,1),r<=l&&l--})),this},has:function(e){return e?jQuery.inArray(e,a)>-1:a.length>0},empty:function(){return a&&(a=[]),this},disable:function(){return i=s=[],a=r="",this},disabled:function(){return!a},lock:function(){return i=s=[],r||n||(a=r=""),this},locked:function(){return!!i},fireWith:function(e,r){return i||(r=[e,(r=r||[]).slice?r.slice():r],s.push(r),n||fire()),this},fire:function(){return u.fireWith(this,arguments),this},fired:function(){return!!o}};return u},jQuery.extend({Deferred:function(e){var n=[["notify","progress",jQuery.Callbacks("memory"),jQuery.Callbacks("memory"),2],["resolve","done",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),0,"resolved"],["reject","fail",jQuery.Callbacks("once memory"),jQuery.Callbacks("once memory"),1,"rejected"]],r="pending",i={state:function(){return r},always:function(){return a.done(arguments).fail(arguments),this},catch:function(e){return i.then(null,e)},pipe:function(){var e=arguments;return jQuery.Deferred((function(r){jQuery.each(n,(function(n,o){var i=v(e[o[4]])&&e[o[4]];a[o[1]]((function(){var e=i&&i.apply(this,arguments);e&&v(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[o[0]+"With"](this,i?[e]:arguments)}))})),e=null})).promise()},then:function(e,r,i){var a=0;function resolve(e,n,r,i){return function(){var s=this,l=arguments,mightThrow=function(){var o,u;if(!(e<a)){if((o=r.apply(s,l))===n.promise())throw new TypeError("Thenable self-resolution");u=o&&("object"==typeof o||"function"==typeof o)&&o.then,v(u)?i?u.call(o,resolve(a,n,Identity,i),resolve(a,n,Thrower,i)):(a++,u.call(o,resolve(a,n,Identity,i),resolve(a,n,Thrower,i),resolve(a,n,Identity,n.notifyWith))):(r!==Identity&&(s=void 0,l=[o]),(i||n.resolveWith)(s,l))}},u=i?mightThrow:function(){try{mightThrow()}catch(o){jQuery.Deferred.exceptionHook&&jQuery.Deferred.exceptionHook(o,u.stackTrace),e+1>=a&&(r!==Thrower&&(s=void 0,l=[o]),n.rejectWith(s,l))}};e?u():(jQuery.Deferred.getStackHook&&(u.stackTrace=jQuery.Deferred.getStackHook()),o.setTimeout(u))}}return jQuery.Deferred((function(o){n[0][3].add(resolve(0,o,v(i)?i:Identity,o.notifyWith)),n[1][3].add(resolve(0,o,v(e)?e:Identity)),n[2][3].add(resolve(0,o,v(r)?r:Thrower))})).promise()},promise:function(e){return null!=e?jQuery.extend(e,i):i}},a={};return jQuery.each(n,(function(e,o){var s=o[2],l=o[5];i[o[1]]=s.add,l&&s.add((function(){r=l}),n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),s.add(o[3].fire),a[o[0]]=function(){return a[o[0]+"With"](this===a?void 0:this,arguments),this},a[o[0]+"With"]=s.fireWith})),i.promise(a),e&&e.call(a,a),a},when:function(e){var n=arguments.length,r=n,o=Array(r),i=l.call(arguments),a=jQuery.Deferred(),updateFunc=function(e){return function(r){o[e]=this,i[e]=arguments.length>1?l.call(arguments):r,--n||a.resolveWith(o,i)}};if(n<=1&&(adoptValue(e,a.done(updateFunc(r)).resolve,a.reject,!n),"pending"===a.state()||v(i[r]&&i[r].then)))return a.then();for(;r--;)adoptValue(i[r],updateFunc(r),a.reject);return a.promise()}});var P=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;jQuery.Deferred.exceptionHook=function(e,n){o.console&&o.console.warn&&e&&P.test(e.name)&&o.console.warn("jQuery.Deferred exception: "+e.message,e.stack,n)},jQuery.readyException=function(e){o.setTimeout((function(){throw e}))};var j=jQuery.Deferred();function completed(){x.removeEventListener("DOMContentLoaded",completed),o.removeEventListener("load",completed),jQuery.ready()}jQuery.fn.ready=function(e){return j.then(e).catch((function(e){jQuery.readyException(e)})),this},jQuery.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--jQuery.readyWait:jQuery.isReady)||(jQuery.isReady=!0,!0!==e&&--jQuery.readyWait>0||j.resolveWith(x,[jQuery]))}}),jQuery.ready.then=j.then,"complete"===x.readyState||"loading"!==x.readyState&&!x.documentElement.doScroll?o.setTimeout(jQuery.ready):(x.addEventListener("DOMContentLoaded",completed),o.addEventListener("load",completed));var access=function(e,n,r,o,i,a,s){var l=0,u=e.length,c=null==r;if("object"===toType(r))for(l in i=!0,r)access(e,n,l,r[l],!0,a,s);else if(void 0!==o&&(i=!0,v(o)||(s=!0),c&&(s?(n.call(e,o),n=null):(c=n,n=function(e,n,r){return c.call(jQuery(e),r)})),n))for(;l<u;l++)n(e[l],r,s?o:o.call(e[l],l,n(e[l],r)));return i?e:c?n.call(e):u?n(e[0],r):a},D=/^-ms-/,M=/-([a-z])/g;function fcamelCase(e,n){return n.toUpperCase()}function camelCase(e){return e.replace(D,"ms-").replace(M,fcamelCase)}var acceptData=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Data(){this.expando=jQuery.expando+Data.uid++}Data.uid=1,Data.prototype={cache:function(e){var n=e[this.expando];return n||(n={},acceptData(e)&&(e.nodeType?e[this.expando]=n:Object.defineProperty(e,this.expando,{value:n,configurable:!0}))),n},set:function(e,n,r){var o,i=this.cache(e);if("string"==typeof n)i[camelCase(n)]=r;else for(o in n)i[camelCase(o)]=n[o];return i},get:function(e,n){return void 0===n?this.cache(e):e[this.expando]&&e[this.expando][camelCase(n)]},access:function(e,n,r){return void 0===n||n&&"string"==typeof n&&void 0===r?this.get(e,n):(this.set(e,n,r),void 0!==r?r:n)},remove:function(e,n){var r,o=e[this.expando];if(void 0!==o){if(void 0!==n){r=(n=Array.isArray(n)?n.map(camelCase):(n=camelCase(n))in o?[n]:n.match(O)||[]).length;for(;r--;)delete o[n[r]]}(void 0===n||jQuery.isEmptyObject(o))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var n=e[this.expando];return void 0!==n&&!jQuery.isEmptyObject(n)}};var R=new Data,I=new Data,q=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,F=/[A-Z]/g;function dataAttr(e,n,r){var o;if(void 0===r&&1===e.nodeType)if(o="data-"+n.replace(F,"-$&").toLowerCase(),"string"==typeof(r=e.getAttribute(o))){try{r=function getData(e){return"true"===e||"false"!==e&&("null"===e?null:e===+e+""?+e:q.test(e)?JSON.parse(e):e)}(r)}catch(e){}I.set(e,n,r)}else r=void 0;return r}jQuery.extend({hasData:function(e){return I.hasData(e)||R.hasData(e)},data:function(e,n,r){return I.access(e,n,r)},removeData:function(e,n){I.remove(e,n)},_data:function(e,n,r){return R.access(e,n,r)},_removeData:function(e,n){R.remove(e,n)}}),jQuery.fn.extend({data:function(e,n){var r,o,i,a=this[0],s=a&&a.attributes;if(void 0===e){if(this.length&&(i=I.get(a),1===a.nodeType&&!R.get(a,"hasDataAttrs"))){for(r=s.length;r--;)s[r]&&0===(o=s[r].name).indexOf("data-")&&(o=camelCase(o.slice(5)),dataAttr(a,o,i[o]));R.set(a,"hasDataAttrs",!0)}return i}return"object"==typeof e?this.each((function(){I.set(this,e)})):access(this,(function(n){var r;if(a&&void 0===n)return void 0!==(r=I.get(a,e))||void 0!==(r=dataAttr(a,e))?r:void 0;this.each((function(){I.set(this,e,n)}))}),null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each((function(){I.remove(this,e)}))}}),jQuery.extend({queue:function(e,n,r){var o;if(e)return n=(n||"fx")+"queue",o=R.get(e,n),r&&(!o||Array.isArray(r)?o=R.access(e,n,jQuery.makeArray(r)):o.push(r)),o||[]},dequeue:function(e,n){n=n||"fx";var r=jQuery.queue(e,n),o=r.length,i=r.shift(),a=jQuery._queueHooks(e,n);"inprogress"===i&&(i=r.shift(),o--),i&&("fx"===n&&r.unshift("inprogress"),delete a.stop,i.call(e,(function(){jQuery.dequeue(e,n)}),a)),!o&&a&&a.empty.fire()},_queueHooks:function(e,n){var r=n+"queueHooks";return R.get(e,r)||R.access(e,r,{empty:jQuery.Callbacks("once memory").add((function(){R.remove(e,[n+"queue",r])}))})}}),jQuery.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),arguments.length<r?jQuery.queue(this[0],e):void 0===n?this:this.each((function(){var r=jQuery.queue(this,e,n);jQuery._queueHooks(this,e),"fx"===e&&"inprogress"!==r[0]&&jQuery.dequeue(this,e)}))},dequeue:function(e){return this.each((function(){jQuery.dequeue(this,e)}))},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,o=1,i=jQuery.Deferred(),a=this,s=this.length,resolve=function(){--o||i.resolveWith(a,[a])};for("string"!=typeof e&&(n=e,e=void 0),e=e||"fx";s--;)(r=R.get(a[s],e+"queueHooks"))&&r.empty&&(o++,r.empty.add(resolve));return resolve(),i.promise(n)}});var H=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,z=new RegExp("^(?:([+-])=|)("+H+")([a-z%]*)$","i"),B=["Top","Right","Bottom","Left"],U=x.documentElement,isAttached=function(e){return jQuery.contains(e.ownerDocument,e)},W={composed:!0};U.getRootNode&&(isAttached=function(e){return jQuery.contains(e.ownerDocument,e)||e.getRootNode(W)===e.ownerDocument});var isHiddenWithinTree=function(e,n){return"none"===(e=n||e).style.display||""===e.style.display&&isAttached(e)&&"none"===jQuery.css(e,"display")};function adjustCSS(e,n,r,o){var i,a,s=20,l=o?function(){return o.cur()}:function(){return jQuery.css(e,n,"")},u=l(),c=r&&r[3]||(jQuery.cssNumber[n]?"":"px"),d=e.nodeType&&(jQuery.cssNumber[n]||"px"!==c&&+u)&&z.exec(jQuery.css(e,n));if(d&&d[3]!==c){for(u/=2,c=c||d[3],d=+u||1;s--;)jQuery.style(e,n,d+c),(1-a)*(1-(a=l()/u||.5))<=0&&(s=0),d/=a;d*=2,jQuery.style(e,n,d+c),r=r||[]}return r&&(d=+d||+u||0,i=r[1]?d+(r[1]+1)*r[2]:+r[2],o&&(o.unit=c,o.start=d,o.end=i)),i}var $={};function getDefaultDisplay(e){var n,r=e.ownerDocument,o=e.nodeName,i=$[o];return i||(n=r.body.appendChild(r.createElement(o)),i=jQuery.css(n,"display"),n.parentNode.removeChild(n),"none"===i&&(i="block"),$[o]=i,i)}function showHide(e,n){for(var r,o,i=[],a=0,s=e.length;a<s;a++)(o=e[a]).style&&(r=o.style.display,n?("none"===r&&(i[a]=R.get(o,"display")||null,i[a]||(o.style.display="")),""===o.style.display&&isHiddenWithinTree(o)&&(i[a]=getDefaultDisplay(o))):"none"!==r&&(i[a]="none",R.set(o,"display",r)));for(a=0;a<s;a++)null!=i[a]&&(e[a].style.display=i[a]);return e}jQuery.fn.extend({show:function(){return showHide(this,!0)},hide:function(){return showHide(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each((function(){isHiddenWithinTree(this)?jQuery(this).show():jQuery(this).hide()}))}});var V,K,G=/^(?:checkbox|radio)$/i,X=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,J=/^$|^module$|\/(?:java|ecma)script/i;V=x.createDocumentFragment().appendChild(x.createElement("div")),(K=x.createElement("input")).setAttribute("type","radio"),K.setAttribute("checked","checked"),K.setAttribute("name","t"),V.appendChild(K),y.checkClone=V.cloneNode(!0).cloneNode(!0).lastChild.checked,V.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!V.cloneNode(!0).lastChild.defaultValue,V.innerHTML="<option></option>",y.option=!!V.lastChild;var Y={thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function getAll(e,n){var r;return r=void 0!==e.getElementsByTagName?e.getElementsByTagName(n||"*"):void 0!==e.querySelectorAll?e.querySelectorAll(n||"*"):[],void 0===n||n&&nodeName(e,n)?jQuery.merge([e],r):r}function setGlobalEval(e,n){for(var r=0,o=e.length;r<o;r++)R.set(e[r],"globalEval",!n||R.get(n[r],"globalEval"))}Y.tbody=Y.tfoot=Y.colgroup=Y.caption=Y.thead,Y.th=Y.td,y.option||(Y.optgroup=Y.option=[1,"<select multiple='multiple'>","</select>"]);var Z=/<|&#?\w+;/;function buildFragment(e,n,r,o,i){for(var a,s,l,u,c,d,p=n.createDocumentFragment(),f=[],h=0,g=e.length;h<g;h++)if((a=e[h])||0===a)if("object"===toType(a))jQuery.merge(f,a.nodeType?[a]:a);else if(Z.test(a)){for(s=s||p.appendChild(n.createElement("div")),l=(X.exec(a)||["",""])[1].toLowerCase(),u=Y[l]||Y._default,s.innerHTML=u[1]+jQuery.htmlPrefilter(a)+u[2],d=u[0];d--;)s=s.lastChild;jQuery.merge(f,s.childNodes),(s=p.firstChild).textContent=""}else f.push(n.createTextNode(a));for(p.textContent="",h=0;a=f[h++];)if(o&&jQuery.inArray(a,o)>-1)i&&i.push(a);else if(c=isAttached(a),s=getAll(p.appendChild(a),"script"),c&&setGlobalEval(s),r)for(d=0;a=s[d++];)J.test(a.type||"")&&r.push(a);return p}var Q=/^([^.]*)(?:\.(.+)|)/;function returnTrue(){return!0}function returnFalse(){return!1}function expectSync(e,n){return e===function safeActiveElement(){try{return x.activeElement}catch(e){}}()==("focus"===n)}function on(e,n,r,o,i,a){var s,l;if("object"==typeof n){for(l in"string"!=typeof r&&(o=o||r,r=void 0),n)on(e,l,r,o,n[l],a);return e}if(null==o&&null==i?(i=r,o=r=void 0):null==i&&("string"==typeof r?(i=o,o=void 0):(i=o,o=r,r=void 0)),!1===i)i=returnFalse;else if(!i)return e;return 1===a&&(s=i,(i=function(e){return jQuery().off(e),s.apply(this,arguments)}).guid=s.guid||(s.guid=jQuery.guid++)),e.each((function(){jQuery.event.add(this,n,i,o,r)}))}function leverageNative(e,n,r){r?(R.set(e,n,!1),jQuery.event.add(e,n,{namespace:!1,handler:function(e){var o,i,a=R.get(this,n);if(1&e.isTrigger&&this[n]){if(a.length)(jQuery.event.special[n]||{}).delegateType&&e.stopPropagation();else if(a=l.call(arguments),R.set(this,n,a),o=r(this,n),this[n](),a!==(i=R.get(this,n))||o?R.set(this,n,!1):i={},a!==i)return e.stopImmediatePropagation(),e.preventDefault(),i&&i.value}else a.length&&(R.set(this,n,{value:jQuery.event.trigger(jQuery.extend(a[0],jQuery.Event.prototype),a.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===R.get(e,n)&&jQuery.event.add(e,n,returnTrue)}jQuery.event={global:{},add:function(e,n,r,o,i){var a,s,l,u,c,d,p,f,h,g,m,y=R.get(e);if(acceptData(e))for(r.handler&&(r=(a=r).handler,i=a.selector),i&&jQuery.find.matchesSelector(U,i),r.guid||(r.guid=jQuery.guid++),(u=y.events)||(u=y.events=Object.create(null)),(s=y.handle)||(s=y.handle=function(n){return void 0!==jQuery&&jQuery.event.triggered!==n.type?jQuery.event.dispatch.apply(e,arguments):void 0}),c=(n=(n||"").match(O)||[""]).length;c--;)h=m=(l=Q.exec(n[c])||[])[1],g=(l[2]||"").split(".").sort(),h&&(p=jQuery.event.special[h]||{},h=(i?p.delegateType:p.bindType)||h,p=jQuery.event.special[h]||{},d=jQuery.extend({type:h,origType:m,data:o,handler:r,guid:r.guid,selector:i,needsContext:i&&jQuery.expr.match.needsContext.test(i),namespace:g.join(".")},a),(f=u[h])||((f=u[h]=[]).delegateCount=0,p.setup&&!1!==p.setup.call(e,o,g,s)||e.addEventListener&&e.addEventListener(h,s)),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),i?f.splice(f.delegateCount++,0,d):f.push(d),jQuery.event.global[h]=!0)},remove:function(e,n,r,o,i){var a,s,l,u,c,d,p,f,h,g,m,y=R.hasData(e)&&R.get(e);if(y&&(u=y.events)){for(c=(n=(n||"").match(O)||[""]).length;c--;)if(h=m=(l=Q.exec(n[c])||[])[1],g=(l[2]||"").split(".").sort(),h){for(p=jQuery.event.special[h]||{},f=u[h=(o?p.delegateType:p.bindType)||h]||[],l=l[2]&&new RegExp("(^|\\.)"+g.join("\\.(?:.*\\.|)")+"(\\.|$)"),s=a=f.length;a--;)d=f[a],!i&&m!==d.origType||r&&r.guid!==d.guid||l&&!l.test(d.namespace)||o&&o!==d.selector&&("**"!==o||!d.selector)||(f.splice(a,1),d.selector&&f.delegateCount--,p.remove&&p.remove.call(e,d));s&&!f.length&&(p.teardown&&!1!==p.teardown.call(e,g,y.handle)||jQuery.removeEvent(e,h,y.handle),delete u[h])}else for(h in u)jQuery.event.remove(e,h+n[c],r,o,!0);jQuery.isEmptyObject(u)&&R.remove(e,"handle events")}},dispatch:function(e){var n,r,o,i,a,s,l=new Array(arguments.length),u=jQuery.event.fix(e),c=(R.get(this,"events")||Object.create(null))[u.type]||[],d=jQuery.event.special[u.type]||{};for(l[0]=u,n=1;n<arguments.length;n++)l[n]=arguments[n];if(u.delegateTarget=this,!d.preDispatch||!1!==d.preDispatch.call(this,u)){for(s=jQuery.event.handlers.call(this,u,c),n=0;(i=s[n++])&&!u.isPropagationStopped();)for(u.currentTarget=i.elem,r=0;(a=i.handlers[r++])&&!u.isImmediatePropagationStopped();)u.rnamespace&&!1!==a.namespace&&!u.rnamespace.test(a.namespace)||(u.handleObj=a,u.data=a.data,void 0!==(o=((jQuery.event.special[a.origType]||{}).handle||a.handler).apply(i.elem,l))&&!1===(u.result=o)&&(u.preventDefault(),u.stopPropagation()));return d.postDispatch&&d.postDispatch.call(this,u),u.result}},handlers:function(e,n){var r,o,i,a,s,l=[],u=n.delegateCount,c=e.target;if(u&&c.nodeType&&!("click"===e.type&&e.button>=1))for(;c!==this;c=c.parentNode||this)if(1===c.nodeType&&("click"!==e.type||!0!==c.disabled)){for(a=[],s={},r=0;r<u;r++)void 0===s[i=(o=n[r]).selector+" "]&&(s[i]=o.needsContext?jQuery(i,this).index(c)>-1:jQuery.find(i,this,null,[c]).length),s[i]&&a.push(o);a.length&&l.push({elem:c,handlers:a})}return c=this,u<n.length&&l.push({elem:c,handlers:n.slice(u)}),l},addProp:function(e,n){Object.defineProperty(jQuery.Event.prototype,e,{enumerable:!0,configurable:!0,get:v(n)?function(){if(this.originalEvent)return n(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[e]},set:function(n){Object.defineProperty(this,e,{enumerable:!0,configurable:!0,writable:!0,value:n})}})},fix:function(e){return e[jQuery.expando]?e:new jQuery.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var n=this||e;return G.test(n.type)&&n.click&&nodeName(n,"input")&&leverageNative(n,"click",returnTrue),!1},trigger:function(e){var n=this||e;return G.test(n.type)&&n.click&&nodeName(n,"input")&&leverageNative(n,"click"),!0},_default:function(e){var n=e.target;return G.test(n.type)&&n.click&&nodeName(n,"input")&&R.get(n,"click")||nodeName(n,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},jQuery.removeEvent=function(e,n,r){e.removeEventListener&&e.removeEventListener(n,r)},jQuery.Event=function(e,n){if(!(this instanceof jQuery.Event))return new jQuery.Event(e,n);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?returnTrue:returnFalse,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,n&&jQuery.extend(this,n),this.timeStamp=e&&e.timeStamp||Date.now(),this[jQuery.expando]=!0},jQuery.Event.prototype={constructor:jQuery.Event,isDefaultPrevented:returnFalse,isPropagationStopped:returnFalse,isImmediatePropagationStopped:returnFalse,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=returnTrue,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=returnTrue,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=returnTrue,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},jQuery.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,char:!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:!0},jQuery.event.addProp),jQuery.each({focus:"focusin",blur:"focusout"},(function(e,n){jQuery.event.special[e]={setup:function(){return leverageNative(this,e,expectSync),!1},trigger:function(){return leverageNative(this,e),!0},_default:function(){return!0},delegateType:n}})),jQuery.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},(function(e,n){jQuery.event.special[e]={delegateType:n,bindType:n,handle:function(e){var r,o=this,i=e.relatedTarget,a=e.handleObj;return i&&(i===o||jQuery.contains(o,i))||(e.type=a.origType,r=a.handler.apply(this,arguments),e.type=n),r}}})),jQuery.fn.extend({on:function(e,n,r,o){return on(this,e,n,r,o)},one:function(e,n,r,o){return on(this,e,n,r,o,1)},off:function(e,n,r){var o,i;if(e&&e.preventDefault&&e.handleObj)return o=e.handleObj,jQuery(e.delegateTarget).off(o.namespace?o.origType+"."+o.namespace:o.origType,o.selector,o.handler),this;if("object"==typeof e){for(i in e)this.off(i,n,e[i]);return this}return!1!==n&&"function"!=typeof n||(r=n,n=void 0),!1===r&&(r=returnFalse),this.each((function(){jQuery.event.remove(this,e,r,n)}))}});var ee=/<script|<style|<link/i,te=/checked\s*(?:[^=]|=\s*.checked.)/i,ne=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function manipulationTarget(e,n){return nodeName(e,"table")&&nodeName(11!==n.nodeType?n:n.firstChild,"tr")&&jQuery(e).children("tbody")[0]||e}function disableScript(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function restoreScript(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function cloneCopyEvent(e,n){var r,o,i,a,s,l;if(1===n.nodeType){if(R.hasData(e)&&(l=R.get(e).events))for(i in R.remove(n,"handle events"),l)for(r=0,o=l[i].length;r<o;r++)jQuery.event.add(n,i,l[i][r]);I.hasData(e)&&(a=I.access(e),s=jQuery.extend({},a),I.set(n,s))}}function fixInput(e,n){var r=n.nodeName.toLowerCase();"input"===r&&G.test(e.type)?n.checked=e.checked:"input"!==r&&"textarea"!==r||(n.defaultValue=e.defaultValue)}function domManip(e,n,r,o){n=u(n);var i,a,s,l,c,d,p=0,f=e.length,h=f-1,g=n[0],m=v(g);if(m||f>1&&"string"==typeof g&&!y.checkClone&&te.test(g))return e.each((function(i){var a=e.eq(i);m&&(n[0]=g.call(this,i,a.html())),domManip(a,n,r,o)}));if(f&&(a=(i=buildFragment(n,e[0].ownerDocument,!1,e,o)).firstChild,1===i.childNodes.length&&(i=a),a||o)){for(l=(s=jQuery.map(getAll(i,"script"),disableScript)).length;p<f;p++)c=i,p!==h&&(c=jQuery.clone(c,!0,!0),l&&jQuery.merge(s,getAll(c,"script"))),r.call(e[p],c,p);if(l)for(d=s[s.length-1].ownerDocument,jQuery.map(s,restoreScript),p=0;p<l;p++)c=s[p],J.test(c.type||"")&&!R.access(c,"globalEval")&&jQuery.contains(d,c)&&(c.src&&"module"!==(c.type||"").toLowerCase()?jQuery._evalUrl&&!c.noModule&&jQuery._evalUrl(c.src,{nonce:c.nonce||c.getAttribute("nonce")},d):DOMEval(c.textContent.replace(ne,""),c,d))}return e}function remove(e,n,r){for(var o,i=n?jQuery.filter(n,e):e,a=0;null!=(o=i[a]);a++)r||1!==o.nodeType||jQuery.cleanData(getAll(o)),o.parentNode&&(r&&isAttached(o)&&setGlobalEval(getAll(o,"script")),o.parentNode.removeChild(o));return e}jQuery.extend({htmlPrefilter:function(e){return e},clone:function(e,n,r){var o,i,a,s,l=e.cloneNode(!0),u=isAttached(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||jQuery.isXMLDoc(e)))for(s=getAll(l),o=0,i=(a=getAll(e)).length;o<i;o++)fixInput(a[o],s[o]);if(n)if(r)for(a=a||getAll(e),s=s||getAll(l),o=0,i=a.length;o<i;o++)cloneCopyEvent(a[o],s[o]);else cloneCopyEvent(e,l);return(s=getAll(l,"script")).length>0&&setGlobalEval(s,!u&&getAll(e,"script")),l},cleanData:function(e){for(var n,r,o,i=jQuery.event.special,a=0;void 0!==(r=e[a]);a++)if(acceptData(r)){if(n=r[R.expando]){if(n.events)for(o in n.events)i[o]?jQuery.event.remove(r,o):jQuery.removeEvent(r,o,n.handle);r[R.expando]=void 0}r[I.expando]&&(r[I.expando]=void 0)}}}),jQuery.fn.extend({detach:function(e){return remove(this,e,!0)},remove:function(e){return remove(this,e)},text:function(e){return access(this,(function(e){return void 0===e?jQuery.text(this):this.empty().each((function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)}))}),null,e,arguments.length)},append:function(){return domManip(this,arguments,(function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||manipulationTarget(this,e).appendChild(e)}))},prepend:function(){return domManip(this,arguments,(function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var n=manipulationTarget(this,e);n.insertBefore(e,n.firstChild)}}))},before:function(){return domManip(this,arguments,(function(e){this.parentNode&&this.parentNode.insertBefore(e,this)}))},after:function(){return domManip(this,arguments,(function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)}))},empty:function(){for(var e,n=0;null!=(e=this[n]);n++)1===e.nodeType&&(jQuery.cleanData(getAll(e,!1)),e.textContent="");return this},clone:function(e,n){return e=null!=e&&e,n=null==n?e:n,this.map((function(){return jQuery.clone(this,e,n)}))},html:function(e){return access(this,(function(e){var n=this[0]||{},r=0,o=this.length;if(void 0===e&&1===n.nodeType)return n.innerHTML;if("string"==typeof e&&!ee.test(e)&&!Y[(X.exec(e)||["",""])[1].toLowerCase()]){e=jQuery.htmlPrefilter(e);try{for(;r<o;r++)1===(n=this[r]||{}).nodeType&&(jQuery.cleanData(getAll(n,!1)),n.innerHTML=e);n=0}catch(e){}}n&&this.empty().append(e)}),null,e,arguments.length)},replaceWith:function(){var e=[];return domManip(this,arguments,(function(n){var r=this.parentNode;jQuery.inArray(this,e)<0&&(jQuery.cleanData(getAll(this)),r&&r.replaceChild(n,this))}),e)}}),jQuery.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},(function(e,n){jQuery.fn[e]=function(e){for(var r,o=[],i=jQuery(e),a=i.length-1,s=0;s<=a;s++)r=s===a?this:this.clone(!0),jQuery(i[s])[n](r),c.apply(o,r.get());return this.pushStack(o)}}));var re=new RegExp("^("+H+")(?!px)[a-z%]+$","i"),getStyles=function(e){var n=e.ownerDocument.defaultView;return n&&n.opener||(n=o),n.getComputedStyle(e)},swap=function(e,n,r){var o,i,a={};for(i in n)a[i]=e.style[i],e.style[i]=n[i];for(i in o=r.call(e),n)e.style[i]=a[i];return o},oe=new RegExp(B.join("|"),"i");function curCSS(e,n,r){var o,i,a,s,l=e.style;return(r=r||getStyles(e))&&(""!==(s=r.getPropertyValue(n)||r[n])||isAttached(e)||(s=jQuery.style(e,n)),!y.pixelBoxStyles()&&re.test(s)&&oe.test(n)&&(o=l.width,i=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=s,s=r.width,l.width=o,l.minWidth=i,l.maxWidth=a)),void 0!==s?s+"":s}function addGetHookIf(e,n){return{get:function(){if(!e())return(this.get=n).apply(this,arguments);delete this.get}}}!function(){function computeStyleTests(){if(u){l.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",U.appendChild(l).appendChild(u);var a=o.getComputedStyle(u);e="1%"!==a.top,s=12===roundPixelMeasures(a.marginLeft),u.style.right="60%",i=36===roundPixelMeasures(a.right),n=36===roundPixelMeasures(a.width),u.style.position="absolute",r=12===roundPixelMeasures(u.offsetWidth/3),U.removeChild(l),u=null}}function roundPixelMeasures(e){return Math.round(parseFloat(e))}var e,n,r,i,a,s,l=x.createElement("div"),u=x.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,jQuery.extend(y,{boxSizingReliable:function(){return computeStyleTests(),n},pixelBoxStyles:function(){return computeStyleTests(),i},pixelPosition:function(){return computeStyleTests(),e},reliableMarginLeft:function(){return computeStyleTests(),s},scrollboxSize:function(){return computeStyleTests(),r},reliableTrDimensions:function(){var e,n,r,i;return null==a&&(e=x.createElement("table"),n=x.createElement("tr"),r=x.createElement("div"),e.style.cssText="position:absolute;left:-11111px;border-collapse:separate",n.style.cssText="border:1px solid",n.style.height="1px",r.style.height="9px",r.style.display="block",U.appendChild(e).appendChild(n).appendChild(r),i=o.getComputedStyle(n),a=parseInt(i.height,10)+parseInt(i.borderTopWidth,10)+parseInt(i.borderBottomWidth,10)===n.offsetHeight,U.removeChild(e)),a}}))}();var ie=["Webkit","Moz","ms"],ae=x.createElement("div").style,se={};function finalPropName(e){var n=jQuery.cssProps[e]||se[e];return n||(e in ae?e:se[e]=function vendorPropName(e){for(var n=e[0].toUpperCase()+e.slice(1),r=ie.length;r--;)if((e=ie[r]+n)in ae)return e}(e)||e)}var le=/^(none|table(?!-c[ea]).+)/,ue=/^--/,ce={position:"absolute",visibility:"hidden",display:"block"},de={letterSpacing:"0",fontWeight:"400"};function setPositiveNumber(e,n,r){var o=z.exec(n);return o?Math.max(0,o[2]-(r||0))+(o[3]||"px"):n}function boxModelAdjustment(e,n,r,o,i,a){var s="width"===n?1:0,l=0,u=0;if(r===(o?"border":"content"))return 0;for(;s<4;s+=2)"margin"===r&&(u+=jQuery.css(e,r+B[s],!0,i)),o?("content"===r&&(u-=jQuery.css(e,"padding"+B[s],!0,i)),"margin"!==r&&(u-=jQuery.css(e,"border"+B[s]+"Width",!0,i))):(u+=jQuery.css(e,"padding"+B[s],!0,i),"padding"!==r?u+=jQuery.css(e,"border"+B[s]+"Width",!0,i):l+=jQuery.css(e,"border"+B[s]+"Width",!0,i));return!o&&a>=0&&(u+=Math.max(0,Math.ceil(e["offset"+n[0].toUpperCase()+n.slice(1)]-a-u-l-.5))||0),u}function getWidthOrHeight(e,n,r){var o=getStyles(e),i=(!y.boxSizingReliable()||r)&&"border-box"===jQuery.css(e,"boxSizing",!1,o),a=i,s=curCSS(e,n,o),l="offset"+n[0].toUpperCase()+n.slice(1);if(re.test(s)){if(!r)return s;s="auto"}return(!y.boxSizingReliable()&&i||!y.reliableTrDimensions()&&nodeName(e,"tr")||"auto"===s||!parseFloat(s)&&"inline"===jQuery.css(e,"display",!1,o))&&e.getClientRects().length&&(i="border-box"===jQuery.css(e,"boxSizing",!1,o),(a=l in e)&&(s=e[l])),(s=parseFloat(s)||0)+boxModelAdjustment(e,n,r||(i?"border":"content"),a,o,s)+"px"}function Tween(e,n,r,o,i){return new Tween.prototype.init(e,n,r,o,i)}jQuery.extend({cssHooks:{opacity:{get:function(e,n){if(n){var r=curCSS(e,"opacity");return""===r?"1":r}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,n,r,o){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,a,s,l=camelCase(n),u=ue.test(n),c=e.style;if(u||(n=finalPropName(l)),s=jQuery.cssHooks[n]||jQuery.cssHooks[l],void 0===r)return s&&"get"in s&&void 0!==(i=s.get(e,!1,o))?i:c[n];"string"===(a=typeof r)&&(i=z.exec(r))&&i[1]&&(r=adjustCSS(e,n,i),a="number"),null!=r&&r==r&&("number"!==a||u||(r+=i&&i[3]||(jQuery.cssNumber[l]?"":"px")),y.clearCloneStyle||""!==r||0!==n.indexOf("background")||(c[n]="inherit"),s&&"set"in s&&void 0===(r=s.set(e,r,o))||(u?c.setProperty(n,r):c[n]=r))}},css:function(e,n,r,o){var i,a,s,l=camelCase(n);return ue.test(n)||(n=finalPropName(l)),(s=jQuery.cssHooks[n]||jQuery.cssHooks[l])&&"get"in s&&(i=s.get(e,!0,r)),void 0===i&&(i=curCSS(e,n,o)),"normal"===i&&n in de&&(i=de[n]),""===r||r?(a=parseFloat(i),!0===r||isFinite(a)?a||0:i):i}}),jQuery.each(["height","width"],(function(e,n){jQuery.cssHooks[n]={get:function(e,r,o){if(r)return!le.test(jQuery.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?getWidthOrHeight(e,n,o):swap(e,ce,(function(){return getWidthOrHeight(e,n,o)}))},set:function(e,r,o){var i,a=getStyles(e),s=!y.scrollboxSize()&&"absolute"===a.position,l=(s||o)&&"border-box"===jQuery.css(e,"boxSizing",!1,a),u=o?boxModelAdjustment(e,n,o,l,a):0;return l&&s&&(u-=Math.ceil(e["offset"+n[0].toUpperCase()+n.slice(1)]-parseFloat(a[n])-boxModelAdjustment(e,n,"border",!1,a)-.5)),u&&(i=z.exec(r))&&"px"!==(i[3]||"px")&&(e.style[n]=r,r=jQuery.css(e,n)),setPositiveNumber(0,r,u)}}})),jQuery.cssHooks.marginLeft=addGetHookIf(y.reliableMarginLeft,(function(e,n){if(n)return(parseFloat(curCSS(e,"marginLeft"))||e.getBoundingClientRect().left-swap(e,{marginLeft:0},(function(){return e.getBoundingClientRect().left})))+"px"})),jQuery.each({margin:"",padding:"",border:"Width"},(function(e,n){jQuery.cssHooks[e+n]={expand:function(r){for(var o=0,i={},a="string"==typeof r?r.split(" "):[r];o<4;o++)i[e+B[o]+n]=a[o]||a[o-2]||a[0];return i}},"margin"!==e&&(jQuery.cssHooks[e+n].set=setPositiveNumber)})),jQuery.fn.extend({css:function(e,n){return access(this,(function(e,n,r){var o,i,a={},s=0;if(Array.isArray(n)){for(o=getStyles(e),i=n.length;s<i;s++)a[n[s]]=jQuery.css(e,n[s],!1,o);return a}return void 0!==r?jQuery.style(e,n,r):jQuery.css(e,n)}),e,n,arguments.length>1)}}),jQuery.Tween=Tween,Tween.prototype={constructor:Tween,init:function(e,n,r,o,i,a){this.elem=e,this.prop=r,this.easing=i||jQuery.easing._default,this.options=n,this.start=this.now=this.cur(),this.end=o,this.unit=a||(jQuery.cssNumber[r]?"":"px")},cur:function(){var e=Tween.propHooks[this.prop];return e&&e.get?e.get(this):Tween.propHooks._default.get(this)},run:function(e){var n,r=Tween.propHooks[this.prop];return this.options.duration?this.pos=n=jQuery.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=n=e,this.now=(this.end-this.start)*n+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),r&&r.set?r.set(this):Tween.propHooks._default.set(this),this}},Tween.prototype.init.prototype=Tween.prototype,Tween.propHooks={_default:{get:function(e){var n;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(n=jQuery.css(e.elem,e.prop,""))&&"auto"!==n?n:0},set:function(e){jQuery.fx.step[e.prop]?jQuery.fx.step[e.prop](e):1!==e.elem.nodeType||!jQuery.cssHooks[e.prop]&&null==e.elem.style[finalPropName(e.prop)]?e.elem[e.prop]=e.now:jQuery.style(e.elem,e.prop,e.now+e.unit)}}},Tween.propHooks.scrollTop=Tween.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},jQuery.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},jQuery.fx=Tween.prototype.init,jQuery.fx.step={};var pe,fe,he=/^(?:toggle|show|hide)$/,ge=/queueHooks$/;function schedule(){fe&&(!1===x.hidden&&o.requestAnimationFrame?o.requestAnimationFrame(schedule):o.setTimeout(schedule,jQuery.fx.interval),jQuery.fx.tick())}function createFxNow(){return o.setTimeout((function(){pe=void 0})),pe=Date.now()}function genFx(e,n){var r,o=0,i={height:e};for(n=n?1:0;o<4;o+=2-n)i["margin"+(r=B[o])]=i["padding"+r]=e;return n&&(i.opacity=i.width=e),i}function createTween(e,n,r){for(var o,i=(Animation.tweeners[n]||[]).concat(Animation.tweeners["*"]),a=0,s=i.length;a<s;a++)if(o=i[a].call(r,n,e))return o}function Animation(e,n,r){var o,i,a=0,s=Animation.prefilters.length,l=jQuery.Deferred().always((function(){delete tick.elem})),tick=function(){if(i)return!1;for(var n=pe||createFxNow(),r=Math.max(0,u.startTime+u.duration-n),o=1-(r/u.duration||0),a=0,s=u.tweens.length;a<s;a++)u.tweens[a].run(o);return l.notifyWith(e,[u,o,r]),o<1&&s?r:(s||l.notifyWith(e,[u,1,0]),l.resolveWith(e,[u]),!1)},u=l.promise({elem:e,props:jQuery.extend({},n),opts:jQuery.extend(!0,{specialEasing:{},easing:jQuery.easing._default},r),originalProperties:n,originalOptions:r,startTime:pe||createFxNow(),duration:r.duration,tweens:[],createTween:function(n,r){var o=jQuery.Tween(e,u.opts,n,r,u.opts.specialEasing[n]||u.opts.easing);return u.tweens.push(o),o},stop:function(n){var r=0,o=n?u.tweens.length:0;if(i)return this;for(i=!0;r<o;r++)u.tweens[r].run(1);return n?(l.notifyWith(e,[u,1,0]),l.resolveWith(e,[u,n])):l.rejectWith(e,[u,n]),this}}),c=u.props;for(!function propFilter(e,n){var r,o,i,a,s;for(r in e)if(i=n[o=camelCase(r)],a=e[r],Array.isArray(a)&&(i=a[1],a=e[r]=a[0]),r!==o&&(e[o]=a,delete e[r]),(s=jQuery.cssHooks[o])&&"expand"in s)for(r in a=s.expand(a),delete e[o],a)r in e||(e[r]=a[r],n[r]=i);else n[o]=i}(c,u.opts.specialEasing);a<s;a++)if(o=Animation.prefilters[a].call(u,e,c,u.opts))return v(o.stop)&&(jQuery._queueHooks(u.elem,u.opts.queue).stop=o.stop.bind(o)),o;return jQuery.map(c,createTween,u),v(u.opts.start)&&u.opts.start.call(e,u),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always),jQuery.fx.timer(jQuery.extend(tick,{elem:e,anim:u,queue:u.opts.queue})),u}jQuery.Animation=jQuery.extend(Animation,{tweeners:{"*":[function(e,n){var r=this.createTween(e,n);return adjustCSS(r.elem,e,z.exec(n),r),r}]},tweener:function(e,n){v(e)?(n=e,e=["*"]):e=e.match(O);for(var r,o=0,i=e.length;o<i;o++)r=e[o],Animation.tweeners[r]=Animation.tweeners[r]||[],Animation.tweeners[r].unshift(n)},prefilters:[function defaultPrefilter(e,n,r){var o,i,a,s,l,u,c,d,p="width"in n||"height"in n,f=this,h={},g=e.style,m=e.nodeType&&isHiddenWithinTree(e),y=R.get(e,"fxshow");for(o in r.queue||(null==(s=jQuery._queueHooks(e,"fx")).unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,f.always((function(){f.always((function(){s.unqueued--,jQuery.queue(e,"fx").length||s.empty.fire()}))}))),n)if(i=n[o],he.test(i)){if(delete n[o],a=a||"toggle"===i,i===(m?"hide":"show")){if("show"!==i||!y||void 0===y[o])continue;m=!0}h[o]=y&&y[o]||jQuery.style(e,o)}if((u=!jQuery.isEmptyObject(n))||!jQuery.isEmptyObject(h))for(o in p&&1===e.nodeType&&(r.overflow=[g.overflow,g.overflowX,g.overflowY],null==(c=y&&y.display)&&(c=R.get(e,"display")),"none"===(d=jQuery.css(e,"display"))&&(c?d=c:(showHide([e],!0),c=e.style.display||c,d=jQuery.css(e,"display"),showHide([e]))),("inline"===d||"inline-block"===d&&null!=c)&&"none"===jQuery.css(e,"float")&&(u||(f.done((function(){g.display=c})),null==c&&(d=g.display,c="none"===d?"":d)),g.display="inline-block")),r.overflow&&(g.overflow="hidden",f.always((function(){g.overflow=r.overflow[0],g.overflowX=r.overflow[1],g.overflowY=r.overflow[2]}))),u=!1,h)u||(y?"hidden"in y&&(m=y.hidden):y=R.access(e,"fxshow",{display:c}),a&&(y.hidden=!m),m&&showHide([e],!0),f.done((function(){for(o in m||showHide([e]),R.remove(e,"fxshow"),h)jQuery.style(e,o,h[o])}))),u=createTween(m?y[o]:0,o,f),o in y||(y[o]=u.start,m&&(u.end=u.start,u.start=0))}],prefilter:function(e,n){n?Animation.prefilters.unshift(e):Animation.prefilters.push(e)}}),jQuery.speed=function(e,n,r){var o=e&&"object"==typeof e?jQuery.extend({},e):{complete:r||!r&&n||v(e)&&e,duration:e,easing:r&&n||n&&!v(n)&&n};return jQuery.fx.off?o.duration=0:"number"!=typeof o.duration&&(o.duration in jQuery.fx.speeds?o.duration=jQuery.fx.speeds[o.duration]:o.duration=jQuery.fx.speeds._default),null!=o.queue&&!0!==o.queue||(o.queue="fx"),o.old=o.complete,o.complete=function(){v(o.old)&&o.old.call(this),o.queue&&jQuery.dequeue(this,o.queue)},o},jQuery.fn.extend({fadeTo:function(e,n,r,o){return this.filter(isHiddenWithinTree).css("opacity",0).show().end().animate({opacity:n},e,r,o)},animate:function(e,n,r,o){var i=jQuery.isEmptyObject(e),a=jQuery.speed(n,r,o),doAnimation=function(){var n=Animation(this,jQuery.extend({},e),a);(i||R.get(this,"finish"))&&n.stop(!0)};return doAnimation.finish=doAnimation,i||!1===a.queue?this.each(doAnimation):this.queue(a.queue,doAnimation)},stop:function(e,n,r){var stopQueue=function(e){var n=e.stop;delete e.stop,n(r)};return"string"!=typeof e&&(r=n,n=e,e=void 0),n&&this.queue(e||"fx",[]),this.each((function(){var n=!0,o=null!=e&&e+"queueHooks",i=jQuery.timers,a=R.get(this);if(o)a[o]&&a[o].stop&&stopQueue(a[o]);else for(o in a)a[o]&&a[o].stop&&ge.test(o)&&stopQueue(a[o]);for(o=i.length;o--;)i[o].elem!==this||null!=e&&i[o].queue!==e||(i[o].anim.stop(r),n=!1,i.splice(o,1));!n&&r||jQuery.dequeue(this,e)}))},finish:function(e){return!1!==e&&(e=e||"fx"),this.each((function(){var n,r=R.get(this),o=r[e+"queue"],i=r[e+"queueHooks"],a=jQuery.timers,s=o?o.length:0;for(r.finish=!0,jQuery.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),n=a.length;n--;)a[n].elem===this&&a[n].queue===e&&(a[n].anim.stop(!0),a.splice(n,1));for(n=0;n<s;n++)o[n]&&o[n].finish&&o[n].finish.call(this);delete r.finish}))}}),jQuery.each(["toggle","show","hide"],(function(e,n){var r=jQuery.fn[n];jQuery.fn[n]=function(e,o,i){return null==e||"boolean"==typeof e?r.apply(this,arguments):this.animate(genFx(n,!0),e,o,i)}})),jQuery.each({slideDown:genFx("show"),slideUp:genFx("hide"),slideToggle:genFx("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},(function(e,n){jQuery.fn[e]=function(e,r,o){return this.animate(n,e,r,o)}})),jQuery.timers=[],jQuery.fx.tick=function(){var e,n=0,r=jQuery.timers;for(pe=Date.now();n<r.length;n++)(e=r[n])()||r[n]!==e||r.splice(n--,1);r.length||jQuery.fx.stop(),pe=void 0},jQuery.fx.timer=function(e){jQuery.timers.push(e),jQuery.fx.start()},jQuery.fx.interval=13,jQuery.fx.start=function(){fe||(fe=!0,schedule())},jQuery.fx.stop=function(){fe=null},jQuery.fx.speeds={slow:600,fast:200,_default:400},jQuery.fn.delay=function(e,n){return e=jQuery.fx&&jQuery.fx.speeds[e]||e,n=n||"fx",this.queue(n,(function(n,r){var i=o.setTimeout(n,e);r.stop=function(){o.clearTimeout(i)}}))},function(){var e=x.createElement("input"),n=x.createElement("select").appendChild(x.createElement("option"));e.type="checkbox",y.checkOn=""!==e.value,y.optSelected=n.selected,(e=x.createElement("input")).value="t",e.type="radio",y.radioValue="t"===e.value}();var me,ye=jQuery.expr.attrHandle;jQuery.fn.extend({attr:function(e,n){return access(this,jQuery.attr,e,n,arguments.length>1)},removeAttr:function(e){return this.each((function(){jQuery.removeAttr(this,e)}))}}),jQuery.extend({attr:function(e,n,r){var o,i,a=e.nodeType;if(3!==a&&8!==a&&2!==a)return void 0===e.getAttribute?jQuery.prop(e,n,r):(1===a&&jQuery.isXMLDoc(e)||(i=jQuery.attrHooks[n.toLowerCase()]||(jQuery.expr.match.bool.test(n)?me:void 0)),void 0!==r?null===r?void jQuery.removeAttr(e,n):i&&"set"in i&&void 0!==(o=i.set(e,r,n))?o:(e.setAttribute(n,r+""),r):i&&"get"in i&&null!==(o=i.get(e,n))?o:null==(o=jQuery.find.attr(e,n))?void 0:o)},attrHooks:{type:{set:function(e,n){if(!y.radioValue&&"radio"===n&&nodeName(e,"input")){var r=e.value;return e.setAttribute("type",n),r&&(e.value=r),n}}}},removeAttr:function(e,n){var r,o=0,i=n&&n.match(O);if(i&&1===e.nodeType)for(;r=i[o++];)e.removeAttribute(r)}}),me={set:function(e,n,r){return!1===n?jQuery.removeAttr(e,r):e.setAttribute(r,r),r}},jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g),(function(e,n){var r=ye[n]||jQuery.find.attr;ye[n]=function(e,n,o){var i,a,s=n.toLowerCase();return o||(a=ye[s],ye[s]=i,i=null!=r(e,n,o)?s:null,ye[s]=a),i}}));var ve=/^(?:input|select|textarea|button)$/i,be=/^(?:a|area)$/i;function stripAndCollapse(e){return(e.match(O)||[]).join(" ")}function getClass(e){return e.getAttribute&&e.getAttribute("class")||""}function classesToArray(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(O)||[]}jQuery.fn.extend({prop:function(e,n){return access(this,jQuery.prop,e,n,arguments.length>1)},removeProp:function(e){return this.each((function(){delete this[jQuery.propFix[e]||e]}))}}),jQuery.extend({prop:function(e,n,r){var o,i,a=e.nodeType;if(3!==a&&8!==a&&2!==a)return 1===a&&jQuery.isXMLDoc(e)||(n=jQuery.propFix[n]||n,i=jQuery.propHooks[n]),void 0!==r?i&&"set"in i&&void 0!==(o=i.set(e,r,n))?o:e[n]=r:i&&"get"in i&&null!==(o=i.get(e,n))?o:e[n]},propHooks:{tabIndex:{get:function(e){var n=jQuery.find.attr(e,"tabindex");return n?parseInt(n,10):ve.test(e.nodeName)||be.test(e.nodeName)&&e.href?0:-1}}},propFix:{for:"htmlFor",class:"className"}}),y.optSelected||(jQuery.propHooks.selected={get:function(e){var n=e.parentNode;return n&&n.parentNode&&n.parentNode.selectedIndex,null},set:function(e){var n=e.parentNode;n&&(n.selectedIndex,n.parentNode&&n.parentNode.selectedIndex)}}),jQuery.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],(function(){jQuery.propFix[this.toLowerCase()]=this})),jQuery.fn.extend({addClass:function(e){var n,r,o,i,a,s,l,u=0;if(v(e))return this.each((function(n){jQuery(this).addClass(e.call(this,n,getClass(this)))}));if((n=classesToArray(e)).length)for(;r=this[u++];)if(i=getClass(r),o=1===r.nodeType&&" "+stripAndCollapse(i)+" "){for(s=0;a=n[s++];)o.indexOf(" "+a+" ")<0&&(o+=a+" ");i!==(l=stripAndCollapse(o))&&r.setAttribute("class",l)}return this},removeClass:function(e){var n,r,o,i,a,s,l,u=0;if(v(e))return this.each((function(n){jQuery(this).removeClass(e.call(this,n,getClass(this)))}));if(!arguments.length)return this.attr("class","");if((n=classesToArray(e)).length)for(;r=this[u++];)if(i=getClass(r),o=1===r.nodeType&&" "+stripAndCollapse(i)+" "){for(s=0;a=n[s++];)for(;o.indexOf(" "+a+" ")>-1;)o=o.replace(" "+a+" "," ");i!==(l=stripAndCollapse(o))&&r.setAttribute("class",l)}return this},toggleClass:function(e,n){var r=typeof e,o="string"===r||Array.isArray(e);return"boolean"==typeof n&&o?n?this.addClass(e):this.removeClass(e):v(e)?this.each((function(r){jQuery(this).toggleClass(e.call(this,r,getClass(this),n),n)})):this.each((function(){var n,i,a,s;if(o)for(i=0,a=jQuery(this),s=classesToArray(e);n=s[i++];)a.hasClass(n)?a.removeClass(n):a.addClass(n);else void 0!==e&&"boolean"!==r||((n=getClass(this))&&R.set(this,"__className__",n),this.setAttribute&&this.setAttribute("class",n||!1===e?"":R.get(this,"__className__")||""))}))},hasClass:function(e){var n,r,o=0;for(n=" "+e+" ";r=this[o++];)if(1===r.nodeType&&(" "+stripAndCollapse(getClass(r))+" ").indexOf(n)>-1)return!0;return!1}});var xe=/\r/g;jQuery.fn.extend({val:function(e){var n,r,o,i=this[0];return arguments.length?(o=v(e),this.each((function(r){var i;1===this.nodeType&&(null==(i=o?e.call(this,r,jQuery(this).val()):e)?i="":"number"==typeof i?i+="":Array.isArray(i)&&(i=jQuery.map(i,(function(e){return null==e?"":e+""}))),(n=jQuery.valHooks[this.type]||jQuery.valHooks[this.nodeName.toLowerCase()])&&"set"in n&&void 0!==n.set(this,i,"value")||(this.value=i))}))):i?(n=jQuery.valHooks[i.type]||jQuery.valHooks[i.nodeName.toLowerCase()])&&"get"in n&&void 0!==(r=n.get(i,"value"))?r:"string"==typeof(r=i.value)?r.replace(xe,""):null==r?"":r:void 0}}),jQuery.extend({valHooks:{option:{get:function(e){var n=jQuery.find.attr(e,"value");return null!=n?n:stripAndCollapse(jQuery.text(e))}},select:{get:function(e){var n,r,o,i=e.options,a=e.selectedIndex,s="select-one"===e.type,l=s?null:[],u=s?a+1:i.length;for(o=a<0?u:s?a:0;o<u;o++)if(((r=i[o]).selected||o===a)&&!r.disabled&&(!r.parentNode.disabled||!nodeName(r.parentNode,"optgroup"))){if(n=jQuery(r).val(),s)return n;l.push(n)}return l},set:function(e,n){for(var r,o,i=e.options,a=jQuery.makeArray(n),s=i.length;s--;)((o=i[s]).selected=jQuery.inArray(jQuery.valHooks.option.get(o),a)>-1)&&(r=!0);return r||(e.selectedIndex=-1),a}}}}),jQuery.each(["radio","checkbox"],(function(){jQuery.valHooks[this]={set:function(e,n){if(Array.isArray(n))return e.checked=jQuery.inArray(jQuery(e).val(),n)>-1}},y.checkOn||(jQuery.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})})),y.focusin="onfocusin"in o;var we=/^(?:focusinfocus|focusoutblur)$/,stopPropagationCallback=function(e){e.stopPropagation()};jQuery.extend(jQuery.event,{trigger:function(e,n,r,i){var a,s,l,u,c,d,p,f,g=[r||x],m=h.call(e,"type")?e.type:e,y=h.call(e,"namespace")?e.namespace.split("."):[];if(s=f=l=r=r||x,3!==r.nodeType&&8!==r.nodeType&&!we.test(m+jQuery.event.triggered)&&(m.indexOf(".")>-1&&(y=m.split("."),m=y.shift(),y.sort()),c=m.indexOf(":")<0&&"on"+m,(e=e[jQuery.expando]?e:new jQuery.Event(m,"object"==typeof e&&e)).isTrigger=i?2:3,e.namespace=y.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+y.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=r),n=null==n?[e]:jQuery.makeArray(n,[e]),p=jQuery.event.special[m]||{},i||!p.trigger||!1!==p.trigger.apply(r,n))){if(!i&&!p.noBubble&&!b(r)){for(u=p.delegateType||m,we.test(u+m)||(s=s.parentNode);s;s=s.parentNode)g.push(s),l=s;l===(r.ownerDocument||x)&&g.push(l.defaultView||l.parentWindow||o)}for(a=0;(s=g[a++])&&!e.isPropagationStopped();)f=s,e.type=a>1?u:p.bindType||m,(d=(R.get(s,"events")||Object.create(null))[e.type]&&R.get(s,"handle"))&&d.apply(s,n),(d=c&&s[c])&&d.apply&&acceptData(s)&&(e.result=d.apply(s,n),!1===e.result&&e.preventDefault());return e.type=m,i||e.isDefaultPrevented()||p._default&&!1!==p._default.apply(g.pop(),n)||!acceptData(r)||c&&v(r[m])&&!b(r)&&((l=r[c])&&(r[c]=null),jQuery.event.triggered=m,e.isPropagationStopped()&&f.addEventListener(m,stopPropagationCallback),r[m](),e.isPropagationStopped()&&f.removeEventListener(m,stopPropagationCallback),jQuery.event.triggered=void 0,l&&(r[c]=l)),e.result}},simulate:function(e,n,r){var o=jQuery.extend(new jQuery.Event,r,{type:e,isSimulated:!0});jQuery.event.trigger(o,null,n)}}),jQuery.fn.extend({trigger:function(e,n){return this.each((function(){jQuery.event.trigger(e,n,this)}))},triggerHandler:function(e,n){var r=this[0];if(r)return jQuery.event.trigger(e,n,r,!0)}}),y.focusin||jQuery.each({focus:"focusin",blur:"focusout"},(function(e,n){var handler=function(e){jQuery.event.simulate(n,e.target,jQuery.event.fix(e))};jQuery.event.special[n]={setup:function(){var r=this.ownerDocument||this.document||this,o=R.access(r,n);o||r.addEventListener(e,handler,!0),R.access(r,n,(o||0)+1)},teardown:function(){var r=this.ownerDocument||this.document||this,o=R.access(r,n)-1;o?R.access(r,n,o):(r.removeEventListener(e,handler,!0),R.remove(r,n))}}}));var Se=o.location,Te={guid:Date.now()},Ce=/\?/;jQuery.parseXML=function(e){var n,r;if(!e||"string"!=typeof e)return null;try{n=(new o.DOMParser).parseFromString(e,"text/xml")}catch(e){}return r=n&&n.getElementsByTagName("parsererror")[0],n&&!r||jQuery.error("Invalid XML: "+(r?jQuery.map(r.childNodes,(function(e){return e.textContent})).join("\n"):e)),n};var ke=/\[\]$/,Ne=/\r?\n/g,_e=/^(?:submit|button|image|reset|file)$/i,Ee=/^(?:input|select|textarea|keygen)/i;function buildParams(e,n,r,o){var i;if(Array.isArray(n))jQuery.each(n,(function(n,i){r||ke.test(e)?o(e,i):buildParams(e+"["+("object"==typeof i&&null!=i?n:"")+"]",i,r,o)}));else if(r||"object"!==toType(n))o(e,n);else for(i in n)buildParams(e+"["+i+"]",n[i],r,o)}jQuery.param=function(e,n){var r,o=[],add=function(e,n){var r=v(n)?n():n;o[o.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==r?"":r)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!jQuery.isPlainObject(e))jQuery.each(e,(function(){add(this.name,this.value)}));else for(r in e)buildParams(r,e[r],n,add);return o.join("&")},jQuery.fn.extend({serialize:function(){return jQuery.param(this.serializeArray())},serializeArray:function(){return this.map((function(){var e=jQuery.prop(this,"elements");return e?jQuery.makeArray(e):this})).filter((function(){var e=this.type;return this.name&&!jQuery(this).is(":disabled")&&Ee.test(this.nodeName)&&!_e.test(e)&&(this.checked||!G.test(e))})).map((function(e,n){var r=jQuery(this).val();return null==r?null:Array.isArray(r)?jQuery.map(r,(function(e){return{name:n.name,value:e.replace(Ne,"\r\n")}})):{name:n.name,value:r.replace(Ne,"\r\n")}})).get()}});var Ae=/%20/g,Le=/#.*$/,Oe=/([?&])_=[^&]*/,Pe=/^(.*?):[ \t]*([^\r\n]*)$/gm,je=/^(?:GET|HEAD)$/,De=/^\/\//,Me={},Re={},Ie="*/".concat("*"),qe=x.createElement("a");function addToPrefiltersOrTransports(e){return function(n,r){"string"!=typeof n&&(r=n,n="*");var o,i=0,a=n.toLowerCase().match(O)||[];if(v(r))for(;o=a[i++];)"+"===o[0]?(o=o.slice(1)||"*",(e[o]=e[o]||[]).unshift(r)):(e[o]=e[o]||[]).push(r)}}function inspectPrefiltersOrTransports(e,n,r,o){var i={},a=e===Re;function inspect(s){var l;return i[s]=!0,jQuery.each(e[s]||[],(function(e,s){var u=s(n,r,o);return"string"!=typeof u||a||i[u]?a?!(l=u):void 0:(n.dataTypes.unshift(u),inspect(u),!1)})),l}return inspect(n.dataTypes[0])||!i["*"]&&inspect("*")}function ajaxExtend(e,n){var r,o,i=jQuery.ajaxSettings.flatOptions||{};for(r in n)void 0!==n[r]&&((i[r]?e:o||(o={}))[r]=n[r]);return o&&jQuery.extend(!0,e,o),e}qe.href=Se.href,jQuery.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Se.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Se.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Ie,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":jQuery.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,n){return n?ajaxExtend(ajaxExtend(e,jQuery.ajaxSettings),n):ajaxExtend(jQuery.ajaxSettings,e)},ajaxPrefilter:addToPrefiltersOrTransports(Me),ajaxTransport:addToPrefiltersOrTransports(Re),ajax:function(e,n){"object"==typeof e&&(n=e,e=void 0),n=n||{};var r,i,a,s,l,u,c,d,p,f,h=jQuery.ajaxSetup({},n),g=h.context||h,m=h.context&&(g.nodeType||g.jquery)?jQuery(g):jQuery.event,y=jQuery.Deferred(),v=jQuery.Callbacks("once memory"),b=h.statusCode||{},w={},S={},T="canceled",C={readyState:0,getResponseHeader:function(e){var n;if(c){if(!s)for(s={};n=Pe.exec(a);)s[n[1].toLowerCase()+" "]=(s[n[1].toLowerCase()+" "]||[]).concat(n[2]);n=s[e.toLowerCase()+" "]}return null==n?null:n.join(", ")},getAllResponseHeaders:function(){return c?a:null},setRequestHeader:function(e,n){return null==c&&(e=S[e.toLowerCase()]=S[e.toLowerCase()]||e,w[e]=n),this},overrideMimeType:function(e){return null==c&&(h.mimeType=e),this},statusCode:function(e){var n;if(e)if(c)C.always(e[C.status]);else for(n in e)b[n]=[b[n],e[n]];return this},abort:function(e){var n=e||T;return r&&r.abort(n),done(0,n),this}};if(y.promise(C),h.url=((e||h.url||Se.href)+"").replace(De,Se.protocol+"//"),h.type=n.method||n.type||h.method||h.type,h.dataTypes=(h.dataType||"*").toLowerCase().match(O)||[""],null==h.crossDomain){u=x.createElement("a");try{u.href=h.url,u.href=u.href,h.crossDomain=qe.protocol+"//"+qe.host!=u.protocol+"//"+u.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&&(h.data=jQuery.param(h.data,h.traditional)),inspectPrefiltersOrTransports(Me,h,n,C),c)return C;for(p in(d=jQuery.event&&h.global)&&0==jQuery.active++&&jQuery.event.trigger("ajaxStart"),h.type=h.type.toUpperCase(),h.hasContent=!je.test(h.type),i=h.url.replace(Le,""),h.hasContent?h.data&&h.processData&&0===(h.contentType||"").indexOf("application/x-www-form-urlencoded")&&(h.data=h.data.replace(Ae,"+")):(f=h.url.slice(i.length),h.data&&(h.processData||"string"==typeof h.data)&&(i+=(Ce.test(i)?"&":"?")+h.data,delete h.data),!1===h.cache&&(i=i.replace(Oe,"$1"),f=(Ce.test(i)?"&":"?")+"_="+Te.guid+++f),h.url=i+f),h.ifModified&&(jQuery.lastModified[i]&&C.setRequestHeader("If-Modified-Since",jQuery.lastModified[i]),jQuery.etag[i]&&C.setRequestHeader("If-None-Match",jQuery.etag[i])),(h.data&&h.hasContent&&!1!==h.contentType||n.contentType)&&C.setRequestHeader("Content-Type",h.contentType),C.setRequestHeader("Accept",h.dataTypes[0]&&h.accepts[h.dataTypes[0]]?h.accepts[h.dataTypes[0]]+("*"!==h.dataTypes[0]?", "+Ie+"; q=0.01":""):h.accepts["*"]),h.headers)C.setRequestHeader(p,h.headers[p]);if(h.beforeSend&&(!1===h.beforeSend.call(g,C,h)||c))return C.abort();if(T="abort",v.add(h.complete),C.done(h.success),C.fail(h.error),r=inspectPrefiltersOrTransports(Re,h,n,C)){if(C.readyState=1,d&&m.trigger("ajaxSend",[C,h]),c)return C;h.async&&h.timeout>0&&(l=o.setTimeout((function(){C.abort("timeout")}),h.timeout));try{c=!1,r.send(w,done)}catch(e){if(c)throw e;done(-1,e)}}else done(-1,"No Transport");function done(e,n,s,u){var p,f,x,w,S,T=n;c||(c=!0,l&&o.clearTimeout(l),r=void 0,a=u||"",C.readyState=e>0?4:0,p=e>=200&&e<300||304===e,s&&(w=function ajaxHandleResponses(e,n,r){for(var o,i,a,s,l=e.contents,u=e.dataTypes;"*"===u[0];)u.shift(),void 0===o&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(i in l)if(l[i]&&l[i].test(o)){u.unshift(i);break}if(u[0]in r)a=u[0];else{for(i in r){if(!u[0]||e.converters[i+" "+u[0]]){a=i;break}s||(s=i)}a=a||s}if(a)return a!==u[0]&&u.unshift(a),r[a]}(h,C,s)),!p&&jQuery.inArray("script",h.dataTypes)>-1&&jQuery.inArray("json",h.dataTypes)<0&&(h.converters["text script"]=function(){}),w=function ajaxConvert(e,n,r,o){var i,a,s,l,u,c={},d=e.dataTypes.slice();if(d[1])for(s in e.converters)c[s.toLowerCase()]=e.converters[s];for(a=d.shift();a;)if(e.responseFields[a]&&(r[e.responseFields[a]]=n),!u&&o&&e.dataFilter&&(n=e.dataFilter(n,e.dataType)),u=a,a=d.shift())if("*"===a)a=u;else if("*"!==u&&u!==a){if(!(s=c[u+" "+a]||c["* "+a]))for(i in c)if((l=i.split(" "))[1]===a&&(s=c[u+" "+l[0]]||c["* "+l[0]])){!0===s?s=c[i]:!0!==c[i]&&(a=l[0],d.unshift(l[1]));break}if(!0!==s)if(s&&e.throws)n=s(n);else try{n=s(n)}catch(e){return{state:"parsererror",error:s?e:"No conversion from "+u+" to "+a}}}return{state:"success",data:n}}(h,w,C,p),p?(h.ifModified&&((S=C.getResponseHeader("Last-Modified"))&&(jQuery.lastModified[i]=S),(S=C.getResponseHeader("etag"))&&(jQuery.etag[i]=S)),204===e||"HEAD"===h.type?T="nocontent":304===e?T="notmodified":(T=w.state,f=w.data,p=!(x=w.error))):(x=T,!e&&T||(T="error",e<0&&(e=0))),C.status=e,C.statusText=(n||T)+"",p?y.resolveWith(g,[f,T,C]):y.rejectWith(g,[C,T,x]),C.statusCode(b),b=void 0,d&&m.trigger(p?"ajaxSuccess":"ajaxError",[C,h,p?f:x]),v.fireWith(g,[C,T]),d&&(m.trigger("ajaxComplete",[C,h]),--jQuery.active||jQuery.event.trigger("ajaxStop")))}return C},getJSON:function(e,n,r){return jQuery.get(e,n,r,"json")},getScript:function(e,n){return jQuery.get(e,void 0,n,"script")}}),jQuery.each(["get","post"],(function(e,n){jQuery[n]=function(e,r,o,i){return v(r)&&(i=i||o,o=r,r=void 0),jQuery.ajax(jQuery.extend({url:e,type:n,dataType:i,data:r,success:o},jQuery.isPlainObject(e)&&e))}})),jQuery.ajaxPrefilter((function(e){var n;for(n in e.headers)"content-type"===n.toLowerCase()&&(e.contentType=e.headers[n]||"")})),jQuery._evalUrl=function(e,n,r){return jQuery.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){jQuery.globalEval(e,n,r)}})},jQuery.fn.extend({wrapAll:function(e){var n;return this[0]&&(v(e)&&(e=e.call(this[0])),n=jQuery(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&n.insertBefore(this[0]),n.map((function(){for(var e=this;e.firstElementChild;)e=e.firstElementChild;return e})).append(this)),this},wrapInner:function(e){return v(e)?this.each((function(n){jQuery(this).wrapInner(e.call(this,n))})):this.each((function(){var n=jQuery(this),r=n.contents();r.length?r.wrapAll(e):n.append(e)}))},wrap:function(e){var n=v(e);return this.each((function(r){jQuery(this).wrapAll(n?e.call(this,r):e)}))},unwrap:function(e){return this.parent(e).not("body").each((function(){jQuery(this).replaceWith(this.childNodes)})),this}}),jQuery.expr.pseudos.hidden=function(e){return!jQuery.expr.pseudos.visible(e)},jQuery.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},jQuery.ajaxSettings.xhr=function(){try{return new o.XMLHttpRequest}catch(e){}};var Fe={0:200,1223:204},He=jQuery.ajaxSettings.xhr();y.cors=!!He&&"withCredentials"in He,y.ajax=He=!!He,jQuery.ajaxTransport((function(e){var n,r;if(y.cors||He&&!e.crossDomain)return{send:function(i,a){var s,l=e.xhr();if(l.open(e.type,e.url,e.async,e.username,e.password),e.xhrFields)for(s in e.xhrFields)l[s]=e.xhrFields[s];for(s in e.mimeType&&l.overrideMimeType&&l.overrideMimeType(e.mimeType),e.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest"),i)l.setRequestHeader(s,i[s]);n=function(e){return function(){n&&(n=r=l.onload=l.onerror=l.onabort=l.ontimeout=l.onreadystatechange=null,"abort"===e?l.abort():"error"===e?"number"!=typeof l.status?a(0,"error"):a(l.status,l.statusText):a(Fe[l.status]||l.status,l.statusText,"text"!==(l.responseType||"text")||"string"!=typeof l.responseText?{binary:l.response}:{text:l.responseText},l.getAllResponseHeaders()))}},l.onload=n(),r=l.onerror=l.ontimeout=n("error"),void 0!==l.onabort?l.onabort=r:l.onreadystatechange=function(){4===l.readyState&&o.setTimeout((function(){n&&r()}))},n=n("abort");try{l.send(e.hasContent&&e.data||null)}catch(e){if(n)throw e}},abort:function(){n&&n()}}})),jQuery.ajaxPrefilter((function(e){e.crossDomain&&(e.contents.script=!1)})),jQuery.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return jQuery.globalEval(e),e}}}),jQuery.ajaxPrefilter("script",(function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")})),jQuery.ajaxTransport("script",(function(e){var n,r;if(e.crossDomain||e.scriptAttrs)return{send:function(o,i){n=jQuery("<script>").attr(e.scriptAttrs||{}).prop({charset:e.scriptCharset,src:e.url}).on("load error",r=function(e){n.remove(),r=null,e&&i("error"===e.type?404:200,e.type)}),x.head.appendChild(n[0])},abort:function(){r&&r()}}}));var ze,Be=[],Ue=/(=)\?(?=&|$)|\?\?/;jQuery.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Be.pop()||jQuery.expando+"_"+Te.guid++;return this[e]=!0,e}}),jQuery.ajaxPrefilter("json jsonp",(function(e,n,r){var i,a,s,l=!1!==e.jsonp&&(Ue.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ue.test(e.data)&&"data");if(l||"jsonp"===e.dataTypes[0])return i=e.jsonpCallback=v(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,l?e[l]=e[l].replace(Ue,"$1"+i):!1!==e.jsonp&&(e.url+=(Ce.test(e.url)?"&":"?")+e.jsonp+"="+i),e.converters["script json"]=function(){return s||jQuery.error(i+" was not called"),s[0]},e.dataTypes[0]="json",a=o[i],o[i]=function(){s=arguments},r.always((function(){void 0===a?jQuery(o).removeProp(i):o[i]=a,e[i]&&(e.jsonpCallback=n.jsonpCallback,Be.push(i)),s&&v(a)&&a(s[0]),s=a=void 0})),"script"})),y.createHTMLDocument=((ze=x.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===ze.childNodes.length),jQuery.parseHTML=function(e,n,r){return"string"!=typeof e?[]:("boolean"==typeof n&&(r=n,n=!1),n||(y.createHTMLDocument?((o=(n=x.implementation.createHTMLDocument("")).createElement("base")).href=x.location.href,n.head.appendChild(o)):n=x),a=!r&&[],(i=k.exec(e))?[n.createElement(i[1])]:(i=buildFragment([e],n,a),a&&a.length&&jQuery(a).remove(),jQuery.merge([],i.childNodes)));var o,i,a},jQuery.fn.load=function(e,n,r){var o,i,a,s=this,l=e.indexOf(" ");return l>-1&&(o=stripAndCollapse(e.slice(l)),e=e.slice(0,l)),v(n)?(r=n,n=void 0):n&&"object"==typeof n&&(i="POST"),s.length>0&&jQuery.ajax({url:e,type:i||"GET",dataType:"html",data:n}).done((function(e){a=arguments,s.html(o?jQuery("<div>").append(jQuery.parseHTML(e)).find(o):e)})).always(r&&function(e,n){s.each((function(){r.apply(this,a||[e.responseText,n,e])}))}),this},jQuery.expr.pseudos.animated=function(e){return jQuery.grep(jQuery.timers,(function(n){return e===n.elem})).length},jQuery.offset={setOffset:function(e,n,r){var o,i,a,s,l,u,c=jQuery.css(e,"position"),d=jQuery(e),p={};"static"===c&&(e.style.position="relative"),l=d.offset(),a=jQuery.css(e,"top"),u=jQuery.css(e,"left"),("absolute"===c||"fixed"===c)&&(a+u).indexOf("auto")>-1?(s=(o=d.position()).top,i=o.left):(s=parseFloat(a)||0,i=parseFloat(u)||0),v(n)&&(n=n.call(e,r,jQuery.extend({},l))),null!=n.top&&(p.top=n.top-l.top+s),null!=n.left&&(p.left=n.left-l.left+i),"using"in n?n.using.call(e,p):d.css(p)}},jQuery.fn.extend({offset:function(e){if(arguments.length)return void 0===e?this:this.each((function(n){jQuery.offset.setOffset(this,e,n)}));var n,r,o=this[0];return o?o.getClientRects().length?(n=o.getBoundingClientRect(),r=o.ownerDocument.defaultView,{top:n.top+r.pageYOffset,left:n.left+r.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,n,r,o=this[0],i={top:0,left:0};if("fixed"===jQuery.css(o,"position"))n=o.getBoundingClientRect();else{for(n=this.offset(),r=o.ownerDocument,e=o.offsetParent||r.documentElement;e&&(e===r.body||e===r.documentElement)&&"static"===jQuery.css(e,"position");)e=e.parentNode;e&&e!==o&&1===e.nodeType&&((i=jQuery(e).offset()).top+=jQuery.css(e,"borderTopWidth",!0),i.left+=jQuery.css(e,"borderLeftWidth",!0))}return{top:n.top-i.top-jQuery.css(o,"marginTop",!0),left:n.left-i.left-jQuery.css(o,"marginLeft",!0)}}},offsetParent:function(){return this.map((function(){for(var e=this.offsetParent;e&&"static"===jQuery.css(e,"position");)e=e.offsetParent;return e||U}))}}),jQuery.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},(function(e,n){var r="pageYOffset"===n;jQuery.fn[e]=function(o){return access(this,(function(e,o,i){var a;if(b(e)?a=e:9===e.nodeType&&(a=e.defaultView),void 0===i)return a?a[n]:e[o];a?a.scrollTo(r?a.pageXOffset:i,r?i:a.pageYOffset):e[o]=i}),e,o,arguments.length)}})),jQuery.each(["top","left"],(function(e,n){jQuery.cssHooks[n]=addGetHookIf(y.pixelPosition,(function(e,r){if(r)return r=curCSS(e,n),re.test(r)?jQuery(e).position()[n]+"px":r}))})),jQuery.each({Height:"height",Width:"width"},(function(e,n){jQuery.each({padding:"inner"+e,content:n,"":"outer"+e},(function(r,o){jQuery.fn[o]=function(i,a){var s=arguments.length&&(r||"boolean"!=typeof i),l=r||(!0===i||!0===a?"margin":"border");return access(this,(function(n,r,i){var a;return b(n)?0===o.indexOf("outer")?n["inner"+e]:n.document.documentElement["client"+e]:9===n.nodeType?(a=n.documentElement,Math.max(n.body["scroll"+e],a["scroll"+e],n.body["offset"+e],a["offset"+e],a["client"+e])):void 0===i?jQuery.css(n,r,l):jQuery.style(n,r,i,l)}),n,s?i:void 0,s)}}))})),jQuery.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],(function(e,n){jQuery.fn[n]=function(e){return this.on(n,e)}})),jQuery.fn.extend({bind:function(e,n,r){return this.on(e,null,n,r)},unbind:function(e,n){return this.off(e,null,n)},delegate:function(e,n,r,o){return this.on(n,e,r,o)},undelegate:function(e,n,r){return 1===arguments.length?this.off(e,"**"):this.off(n,e||"**",r)},hover:function(e,n){return this.mouseenter(e).mouseleave(n||e)}}),jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),(function(e,n){jQuery.fn[n]=function(e,r){return arguments.length>0?this.on(n,null,e,r):this.trigger(n)}}));var We=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;jQuery.proxy=function(e,n){var r,o,i;if("string"==typeof n&&(r=e[n],n=e,e=r),v(e))return o=l.call(arguments,2),(i=function(){return e.apply(n||this,o.concat(l.call(arguments)))}).guid=e.guid=e.guid||jQuery.guid++,i},jQuery.holdReady=function(e){e?jQuery.readyWait++:jQuery.ready(!0)},jQuery.isArray=Array.isArray,jQuery.parseJSON=JSON.parse,jQuery.nodeName=nodeName,jQuery.isFunction=v,jQuery.isWindow=b,jQuery.camelCase=camelCase,jQuery.type=toType,jQuery.now=Date.now,jQuery.isNumeric=function(e){var n=jQuery.type(e);return("number"===n||"string"===n)&&!isNaN(e-parseFloat(e))},jQuery.trim=function(e){return null==e?"":(e+"").replace(We,"")},void 0===(r=function(){return jQuery}.apply(n,[]))||(e.exports=r);var $e=o.jQuery,Ve=o.$;return jQuery.noConflict=function(e){return o.$===jQuery&&(o.$=Ve),e&&o.jQuery===jQuery&&(o.jQuery=$e),jQuery},void 0===i&&(o.jQuery=o.$=jQuery),jQuery}))},98:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=class DropDown{constructor(e,n,r){const i=o.isNil(n)?e.querySelector(".neos-dropdown-trigger"):n,a=this.getContentSelector(i);this.root=e,this.trigger=i,this.content=o.isEmpty(a)?e.querySelector(".neos-dropdown-content"):document.getElementById(a),this.grouped=!o.isNil(r)&&Boolean(r),this.disabled=!1,this.initialize(),this.setupEventListeners()}initialize(){if(o.isNil(this.content))return;const e=this.content.innerHTML.trim();o.isEmpty(e)&&(this.trigger.setAttribute("disabled","true"),this.disabled=!0)}getContentSelector(e){return o.isNil(e)?"":e.getAttribute("aria-controls")}setupEventListeners(){o.isNil(this.trigger)||o.isNil(this.content)||this.disabled||this.trigger.addEventListener("click",this.toggle.bind(this))}toggle(e){e.preventDefault(),this.grouped?this._closeOthers():this.root.classList.toggle("open");const n=this.trigger.getAttribute("aria-expanded");!1===(!o.isEmpty(n)&&"true"===n.toLowerCase())?this.open():this.close(this.trigger)}open(){this.trigger.setAttribute("aria-expanded","true"),this.content.removeAttribute("hidden")}close(e){const n=this.getContentSelector(e);let r=document.getElementById(n);o.isNil(r)&&(r=this.content),e.setAttribute("aria-expanded","false"),r.setAttribute("hidden","true")}_closeOthers(){Array.from(this.root.querySelectorAll(".neos-dropdown-trigger")).forEach((e=>{e!==this.trigger&&this.close(e)}))}}},47:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=r(586),a=o(r(98));n.default=class DropDownGroup{constructor(e){this.root=e,this.initialize()}initialize(){if(i.isNil(this.root))return;Array.from(this.root.querySelectorAll(".neos-dropdown-trigger")).forEach((e=>{new a.default(this.root,e,!0)}))}}},357:(e,n,r)=>{"use strict";const o=r(586);n.Z=class Modal{constructor(e){this.root=e,this.triggers=Array.from(document.querySelectorAll(`[href="#${e.id}"][data-toggle="modal"]`)),this.closeButtons=Array.from(this.root.querySelectorAll('[data-dismiss="modal"]')),this.header=e.querySelector(".neos-header"),this.setupEventListeners()}setupEventListeners(){this.triggers.forEach((e=>{e.addEventListener("click",this.open.bind(this))})),this.closeButtons.forEach((e=>{e.addEventListener("click",this.close.bind(this))})),document.addEventListener("keyup",this.onKeyPress.bind(this))}open(e){e.preventDefault();const n=e.target,r=this.getTriggerElement(n);this.handleDynamicHeader(r),this.root.classList.add("open"),this.root.classList.remove("neos-hide"),r.dispatchEvent(new CustomEvent("neoscms-modal-opened",{bubbles:!0,detail:{identifier:this.root.id}}))}getTriggerElement(e){return o.isNil(e)?null:(e.hasAttribute("data-toggle")||(e=e.closest('[data-toggle="modal"]')),e)}close(){this.root.classList.remove("open"),this.root.classList.add("neos-hide"),window.dispatchEvent(new CustomEvent("neoscms-modal-closed",{detail:{identifier:this.root.id}}))}onKeyPress(e){"Escape"===e.key&&this.close()}handleDynamicHeader(e){if(o.isNil(e)||o.isNil(this.header))return;const n=e.getAttribute("data-modal-header");o.isEmpty(n)||(this.header.innerText=n)}}},813:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(482)),a=r(586),s=r(511);n.default=class Message{constructor(e,n){this.message=null,this.container=n,this.options=e,this.initialize(),this.setupEventListeners()}initialize(){const e=Date.now(),n=Math.floor(e/1e3),{title:r,message:o,type:a,closeButton:l}=this.options,u=i.default.sanitize(o),c=s.messageTemplate(a,r,u,l),d=document.createElement("div");d.innerHTML=c;const p=d.firstElementChild;p.id="neos-notification-message-"+n,this.message=p,this.container.appendChild(p),this.registerCloseButton(p),this.registerExpandHandling(p)}registerExpandHandling(e){const n=e.querySelector(".neos-notification-content");!a.isNil(n)&&n.classList.contains("expandable")&&n.addEventListener("click",this.toggle.bind(this))}registerCloseButton(e){const n=e.querySelector(".neos-close-button");a.isNil(n)||n.addEventListener("click",this.close.bind(this))}setupEventListeners(){const e=this.options.timeout;e>0&&setTimeout(this.close.bind(this),e)}close(){a.isNil(this.message)||(this.message.classList.add("fade-out"),setTimeout((()=>{this.message.remove()}),250))}toggle(){if(a.isNil(this.message))return;const e=this.message.querySelector(".neos-notification-content");a.isNil(e)||e.classList.toggle("expanded")}}},511:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.messageTemplate=void 0;const o=r(586),i={error:"error",info:"info",ok:"success",warning:"warning",notice:"info"};n.messageTemplate=(e,n,r,a)=>{const s=!o.isEmpty(r),l=["neos-notification-content"],u=!o.isNil(a)&&a?'<i class="fas fa-times neos-close-button"></i>':"";let c="";return s&&(c=`<div class="neos-expand-content">${r}</div>`,l.push("expandable")),`\n\t\t<div class="neos-notification neos-notification-${i[e]}">\n\t\t\t<i class="fas fa-${i[e]}"></i>\n\t\t\t${u}\n\t\t\t<div class="${l.join(" ")}">\n\t\t\t\t<div class="neos-notification-heading">${n}</div>\n\t\t\t\t${c}\n\t\t\t</div>\n\t\t</div>\n\t`}},944:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=r(586),a=o(r(813)),s={position:"neos-notification-top",timeout:5e3,type:"info"};class Toast{constructor(){this.container=document.getElementById("neos-notification-container"),this.initialize()}initialize(){if(i.isNil(this.container)){const e=document.getElementById("neos-application");i.isNil(e)||(this.container=document.createElement("div"),this.container.id="neos-notification-container",e.appendChild(this.container))}}create(e){const n=Object.assign(Object.assign({},s),e);i.isNil(n.position)||this.container.classList.add(n.position),new a.default(n,this.container)}static create(e){if(i.isNil(this._container)){(new Toast).create(e)}else this._create(e)}static removeAll(){Array.from(this._container.childNodes).forEach((e=>{i.isNil(e)||(e.classList.add("fade-out"),setTimeout((()=>{e.remove()}),250))}))}}n.default=Toast},693:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=class DropDownMenu{constructor(e){this.root=e,this.button=Array.from(this.root.querySelectorAll(".neos-dropdown-toggle")),this.menu=Array.from(this.root.querySelectorAll(".neos-dropdown-menu")),this.setupEventListeners()}setupEventListeners(){this.button.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}toggle(e){this.changeToogleIcon(),this.root.classList.toggle("neos-dropdown-open")}changeToogleIcon(){const e=this.root.querySelector(".fa-chevron-down"),n=this.root.querySelector(".fa-chevron-up");e&&e.classList.replace("fa-chevron-down","fa-chevron-up"),n&&n.classList.replace("fa-chevron-up","fa-chevron-down")}}},576:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=class Expandable{constructor(e,n,r,o){this.root=e,this.trigger=Array.from(this.root.querySelectorAll(n)),this.onStateChange=r,this.setupEventListeners(),this.initialize(o)}setupEventListeners(){this.trigger.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}initialize(e){this.root.querySelector("[aria-expanded]").setAttribute("aria-expanded",String(e)),e&&(this.root.classList.add("neos-open"),this.changeToogleIcon())}toggle(){this.changeToogleIcon(),this.root.classList.toggle("neos-open"),this.toogleAriaExpandable()}toogleAriaExpandable(){const e=this.root.querySelector("[aria-expanded]"),n=this.root.classList.contains("neos-open");if(e.setAttribute("aria-expanded",String(n)),"function"==typeof this.onStateChange){const e=this.root.getAttribute("data-key");this.onStateChange(e,n)}}changeToogleIcon(){const e=this.root.querySelector(".fa-chevron-circle-down"),n=this.root.querySelector(".fa-chevron-circle-up");e&&e.classList.replace("fa-chevron-circle-down","fa-chevron-circle-up"),n&&n.classList.replace("fa-chevron-circle-up","fa-chevron-circle-down")}}},527:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(576)),a=r(791),s="ui.drawer.collapsedMenuGroups";n.default=class MenuPanel{constructor(e){this.root=e,this.button=Array.from(this.root.querySelectorAll(".neos-menu-button")),this.panel=Array.from(this.root.querySelectorAll(".neos-menu-panel")),this.menuSectionStates=this.loadMenuSectionStates(),this.setupEventListeners(),this.panel&&this.initializeMenuSections()}initializeMenuSections(){this.panel.forEach((e=>{const n=e.querySelectorAll(".neos-menu-section"),r=this.menuSectionStates;n.forEach((e=>{const n=e.getAttribute("data-key"),o=!r.includes(n);new i.default(e,".neos-menu-panel-toggle",this.onMenuSectionStateChange.bind(this),o)}))}))}setupEventListeners(){this.button.forEach((e=>{e.addEventListener("click",this.toggle.bind(this))}))}loadMenuSectionStates(){const e=a.loadStorageData(s);return Array.isArray(e)?e:[]}saveMenuSectionStates(){Array.isArray(this.menuSectionStates)&&a.saveStorageData(s,this.menuSectionStates)}onMenuSectionStateChange(e,n){this.menuSectionStates.includes(e)&&!0===n&&(this.menuSectionStates=this.menuSectionStates.filter((n=>n!==e))),this.menuSectionStates.includes(e)||!1!==n||this.menuSectionStates.push(e),this.saveMenuSectionStates()}toggle(e){this.button.forEach((e=>{e.classList.toggle("neos-pressed")})),document.body.classList.toggle("neos-menu-panel-open")}}},366:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.UserMenu=n.MenuPanel=n.Expandable=n.DropDownMenu=void 0;const i=o(r(693));n.DropDownMenu=i.default;const a=o(r(576));n.Expandable=a.default;const s=o(r(527));n.MenuPanel=s.default;const l=o(r(148));n.UserMenu=l.default},767:(e,n,r)=>{"use strict";const o=r(586),i=r(791);n.Z=class Tree{constructor(e){this.root=e,this.type=this.root.getAttribute("data-type"),this.treeBranchStates=this.loadTreeBranchStates(!0),this.nodes=Array.from(this.root.querySelectorAll(".neos-tree-node")),this.initializeTree(),this.setupEventListeners()}initializeTree(){this.nodes.forEach((e=>{"ul"!==e.firstChild.nodeName.toLowerCase()&&this.wrapElementWithNodeTitle(e.firstChild);const n=e.querySelectorAll(".neos-tree-node");if(this.isFolder(e)&&!o.isNil(n)&&n.length>0){const n=this.createExpandIcon();e.insertBefore(n,e.firstChild)}}))}initializeTreeState(e){Array.isArray(e)&&e.forEach((e=>{const n=this.root.querySelector(`[title="${e}"`);o.isNil(n)||n.classList.add("neos-tree-open")}))}setupEventListeners(){this.nodes.forEach((e=>{e.addEventListener("click",this.onNodeClick.bind(this))}))}onNodeClick(e){e.preventDefault(),e.stopPropagation();const n=e.target.closest(".neos-tree-node");o.isNil(n)||(this.deselectCurrentActiveNode(),n.classList.toggle("neos-tree-active")),this.isFolder(n)&&this.toggle(n)}deselectCurrentActiveNode(){this.root.querySelectorAll(".neos-tree-active").forEach((e=>{e.classList.remove("neos-tree-active")}))}createExpandIcon(){const e=document.createElement("span");return e.classList.add("neos-tree-expander"),e}wrapElementWithNodeTitle(e){const n=document.createElement("span");n.classList.add("neos-tree-title"),e.parentNode.insertBefore(n,e),n.appendChild(e)}isFolder(e){return!o.isNil(e)&&e.classList.contains("neos-tree-folder")}toggle(e){e.classList.toggle("neos-tree-open"),this.changeTreeBranchState(e.getAttribute("title"))}getPathForType(){return("module.configuration"+(o.isEmpty(this.type)?"":"."+this.type)).toLowerCase()}loadTreeBranchStates(e){const n=this.getPathForType(),r=i.loadStorageData(n);return o.isNil(e)||!0!==e||this.initializeTreeState(r),this.treeBranchStates=Array.isArray(r)?r:[],this.treeBranchStates}saveTreeBranchStates(){const e=this.getPathForType();Array.isArray(this.treeBranchStates)&&i.saveStorageData(e,this.treeBranchStates)}changeTreeBranchState(e){!o.isEmpty(e)&&Array.isArray(this.treeBranchStates)&&(this.treeBranchStates.includes(e)?this.treeBranchStates=this.treeBranchStates.filter((n=>n!==e)):this.treeBranchStates.push(e),this.saveTreeBranchStates())}}},24:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=(e,n,r)=>{e="object"==typeof e?e:{};const o=Array.isArray(n)?n:n.split(".");let i=e;for(let e=0;e<o.length-1;e++){const n=o[e];if(!i[n]&&!Object.prototype.hasOwnProperty.call(i,n)){const r=o[e+1],a=/^\+?(0|[1-9]\d*)$/.test(r);i[n]=a?[]:{}}i=i[n]}return i[o[o.length-1]]=r,e}},521:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=(e,n)=>o.isNil(e)?null:n.split(".").reduce(((e,n)=>o.isNil(e)?null:e[n]),e)},442:(e,n,r)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});const o=r(586);n.default=(e,n,r)=>o.isNil(e)?null:e.find((e=>e[n]===r))},586:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0}),n.createCollectionByPath=n.getCollectionValueByPath=n.getItemByKeyValue=n.isEmpty=n.isNil=void 0;const i=o(r(856));n.isNil=i.default;const a=o(r(626));n.isEmpty=a.default;const s=o(r(442));n.getItemByKeyValue=s.default;const l=o(r(521));n.getCollectionValueByPath=l.default;const u=o(r(24));n.createCollectionByPath=u.default},626:function(e,n,r){"use strict";var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(n,"__esModule",{value:!0});const i=o(r(856));n.default=e=>"string"==typeof e?0===e.length:!!i.default(e)||!Object.getOwnPropertySymbols(e).length&&!Object.getOwnPropertyNames(e).length},856:(e,n)=>{"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.default=e=>null==e}},n={};function __webpack_require__(r){if(n[r])return n[r].exports;var o=n[r]={exports:{}};return e[r].call(o.exports,o,o.exports,__webpack_require__),o.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var r in n)__webpack_require__.o(n,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=__webpack_require__(755),n=__webpack_require__.n(e),r=__webpack_require__(366),o=__webpack_require__(586),i=__webpack_require__(912);const a=(0,o.isNil)(window.Typo3Neos)?"Login as this user":window.NeosCMS.I18n.translate("impersonate.tooltip.impersonateUserButton","Login as this user","Neos.Neos");class UserManagement{constructor(e){const n=document.querySelector("[data-csrf-token]");this._root=e,this._csrfToken=(0,o.isNil)(n)?"":n.getAttribute("data-csrf-token"),console.log(this._csrfToken),this._apiService=new i.sM("/neos/impersonate/",this._csrfToken),(0,o.isNil)(e)||this._initialize()}_initialize(){this._renderImpersonateButtons(),this._setupEventListeners()}_setupEventListeners(){this._root.querySelectorAll("button.impersonate-user").forEach((e=>{e.addEventListener("click",this._impersonateUser.bind(this))}))}_renderImpersonateButtons(){Array.from(this._root.querySelectorAll(".neos-table .neos-action")).forEach((e=>{const n=e.querySelector("button.neos-button-danger"),r=e.querySelector('a[href*="show"]');if((0,o.isNil)(r))return!1;const i=new URL(decodeURIComponent(r.getAttribute("href"))),s=((e,n)=>{const r={"data-neos-toggle":"tooltip","data-original-title":a,"data-user-identifier":e,class:"neos-button neos-button-primary impersonate-user"};(0,o.isNil)(n)||!0!==n||(r.disabled=!0,r.class+=" neos-disabled");let i="";return Object.keys(r).forEach((e=>{i+=`${e}="${r[e]}" `})),`<button ${i}><i class="fas fa-random icon-white"></i></button>`})(new URLSearchParams(i.search).get("moduleArguments[user][__identity]"),!(0,o.isNil)(n)&&n.classList.contains("neos-disabled"));r.parentElement.innerHTML+=s}))}_impersonateUser(e){e.preventDefault();const n=e.currentTarget;if((0,o.isNil)(n))return!1;const r=n.getAttribute("data-user-identifier");this._apiService.callUserChange(r).then((e=>{const{user:n,status:r}=e,i=(0,o.isNil)(n)?"":n.accountIdentifier,a=window.NeosCMS.I18n.translate("impersonate.success.impersonateUser","Switched to the new user {0}.","Neos.Neos","Main",{0:i});window.NeosCMS.Notification.ok(a),window.location.pathname="/neos"})).catch((function(e){if(window.NeosCMS){const e=window.NeosCMS.I18n.translate("impersonate.error.impersonateUser","Could not switch to the requested user.","Neos.Neos");window.NeosCMS.Notification.error(e)}}))}}var s=__webpack_require__(98),l=__webpack_require__(47),u=__webpack_require__.n(l),c=__webpack_require__(767),d=__webpack_require__(357),p=__webpack_require__(449);const cachedFetch=async e=>{const n=p.Z.getItem(e),r=(0,o.isNil)(n);if((0,o.isNil)(e)&&r)return!1;if(r){const n=await(async e=>{const n=await fetch(e);if(n.ok)return await n.json();throw new Error(`HTTP error! status: ${n.status}`)})(e);return p.Z.setItem(e,n),n}return n};window.jQuery=n(),window.$=n(),i.Wt.init(),i.VK.init(),i.P_.init(),i.WH.init();cachedFetch(i.VK.get("XliffUri")).then((e=>{e&&i.WH.initTranslations(e)})),document.addEventListener("DOMContentLoaded",(e=>{document.querySelectorAll(".neos-user-menu").forEach((e=>{new r.DropDownMenu(e)}));document.querySelectorAll(".neos-menu").forEach((e=>{new r.MenuPanel(e)}));document.querySelectorAll(".neos-tree-container").forEach((e=>{new c.Z(e)}));Array.from(document.querySelectorAll('[data-toggle="modal"]')).forEach((e=>{const n=document.querySelector(e.getAttribute("href"));(0,o.isNil)(n)||new d.Z(n)}));document.querySelectorAll("[data-neos-expandable=dropdown]").forEach((e=>{new s.default(e)}));document.querySelectorAll("[data-neos-expandable=dropdown-group]").forEach((e=>{new(u())(e)}));const n=document.querySelector(".neos-module-administration-users");(0,o.isNil)(n)||Array.from(n.querySelectorAll(".neos-table")).forEach((e=>{(0,o.isNil)(e)||new UserManagement(e)}));const i=document.querySelector("#neos-top-bar .neos-user-menu");(0,o.isNil)(i)||new r.UserMenu(i)}))})()})();


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Module/Administration/UserManagement.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-65 ---
     1| import {isNil} from '../../Helper'
     2| import {ApiService} from '../../Services'
     3| import {ImpersonateButton} from '../../Templates/ImpersonateButton'
     4| const BASE_PATH = '/neos/impersonate/'
     5| export default class UserManagement {
     6|     constructor(_root) {
     7|         const csfrTokenField = document.querySelector('[data-csrf-token]')
     8|         this._root = _root
     9|         this._csrfToken = !isNil(csfrTokenField) ? csfrTokenField.getAttribute('data-csrf-token') : ''
    10|         console.log(this._csrfToken);
    11|         this._apiService = new ApiService(BASE_PATH, this._csrfToken)
    12|         if (!isNil(_root)) {
    13|             this._initialize()
    14|         }
    15|     }
    16|     _initialize() {
    17|         this._renderImpersonateButtons()
    18|         this._setupEventListeners()
    19|     }
    20|     _setupEventListeners() {
    21|         const impersonateButtons = this._root.querySelectorAll('button.impersonate-user')
    22|         impersonateButtons.forEach(_impersonateButton => {
    23|             _impersonateButton.addEventListener('click', this._impersonateUser.bind(this));
    24|         });
    25|     }
    26|     _renderImpersonateButtons() {
    27|         const userTableActionButtons = Array.from(this._root.querySelectorAll('.neos-table .neos-action'))
    28|         userTableActionButtons.forEach(_actionContainer => {
    29|             const deleteButton = _actionContainer.querySelector('button.neos-button-danger')
    30|             const showButton = _actionContainer.querySelector('a[href*="show"]')
    31|             if (isNil(showButton)) {
    32|                 return false
    33|             }
    34|             const showButtonUri = new URL(decodeURIComponent(showButton.getAttribute('href')))
    35|             const showButtonUriParameter = new URLSearchParams(showButtonUri.search)
    36|             const userIdentifier = showButtonUriParameter.get('moduleArguments[user][__identity]')
    37|             const isCurrentUser = !isNil(deleteButton) && deleteButton.classList.contains('neos-disabled')
    38|             const impersonateButtonMarkup = ImpersonateButton(userIdentifier, isCurrentUser)
    39|             showButton.parentElement.innerHTML += impersonateButtonMarkup
    40|         })
    41|     }
    42|     _impersonateUser(event) {
    43|         event.preventDefault();
    44|         const button = event.currentTarget;
    45|         if (isNil(button)) {
    46|             return false
    47|         }
    48|         const identifier = button.getAttribute('data-user-identifier')
    49|         const response = this._apiService.callUserChange(identifier);
    50|         response
    51|             .then((data) => {
    52|                 const {user, status} = data
    53|                 const username = isNil(user) ? '' : user.accountIdentifier
    54|                 const message = window.NeosCMS.I18n.translate('impersonate.success.impersonateUser', 'Switched to the new user {0}.', 'Neos.Neos', 'Main', {0: username})
    55|                 window.NeosCMS.Notification.ok(message)
    56|                 window.location.pathname = '/neos'
    57|             })
    58|             .catch(function (error) {
    59|                 if (window.NeosCMS) {
    60|                     const message = window.NeosCMS.I18n.translate('impersonate.error.impersonateUser', 'Could not switch to the requested user.', 'Neos.Neos')
    61|                     window.NeosCMS.Notification.error(message)
    62|                 }
    63|             });
    64|     }
    65| }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Module/Administration/index.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-2 ---
     1| import UserManagement from './UserManagement'
     2| export { UserManagement }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/ApiService.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-54 ---
     1| import { isNil } from '../Helper'
     2| export default class ApiService {
     3|     constructor(_basePath, _csrfToken) {
     4|         if (isNil(_basePath)) {
     5|             let pathError = 'Tried to create API service without a base uri. '
     6|             pathError += 'Please initialize the API service with a base path '
     7|             pathError += 'like "/neos/impersonate/"'
     8|             console.error(pathError)
     9|         }
    10|         this._basePath = _basePath
    11|         if (isNil(_csrfToken)) {
    12|             let csrfError = 'Tried to create API service without a CSFR '
    13|             csrfError += 'token. Please initialize the API service with a token'
    14|             console.error(csrfError)
    15|         }
    16|         this._csrfToken = _csrfToken
    17|     }
    18|     async callUserChange(identifier) {
    19|         const data = {
    20|             user: identifier,
    21|             format: 'json',
    22|         }
    23|         const response = await fetch(this._basePath + 'user-change', {
    24|             method: 'POST',
    25|             credentials: 'include',
    26|             headers: this._getHeader(),
    27|             body: JSON.stringify(data),
    28|         })
    29|         return await response.json()
    30|     }
    31|     async callStatus() {
    32|         const response = await fetch(this._basePath + 'status', {
    33|             method: 'GET',
    34|             credentials: 'include',
    35|             headers: this._getHeader(),
    36|         })
    37|         return await response.json()
    38|     }
    39|     async callRestore() {
    40|         const response = await fetch(this._basePath + 'restore', {
    41|             method: 'POST',
    42|             credentials: 'include',
    43|             headers: this._getHeader(),
    44|         })
    45|         return await response.json()
    46|     }
    47|     _getHeader() {
    48|         return {
    49|             Accept: 'application/json',
    50|             'Content-Type': 'application/json',
    51|             'X-Flow-Csrftoken': this._csrfToken,
    52|         }
    53|     }
    54| }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/Configuration.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-26 ---
     1| import { getCollectionValueByPath, isNil } from "../Helper";
     2| const hasConfiguration = !isNil(window.NeosCMS?.Configuration);
     3| const init = () => {
     4|   if (isNil(window.NeosCMS)) {
     5|     window.NeosCMS = {};
     6|   }
     7|   if (isNil(window.NeosCMS.Configuration)) {
     8|     window.NeosCMS.Configuration = {};
     9|   }
    10|   const xliffLink = document.querySelector('link[rel="neos-xliff"]');
    11|   if (!isNil(xliffLink)) {
    12|     window.NeosCMS.Configuration.XliffUri = xliffLink.getAttribute("href");
    13|   }
    14| };
    15| const get = (key) => {
    16|   if (!hasConfiguration) {
    17|     return null;
    18|   }
    19|   return getCollectionValueByPath(window.NeosCMS.Configuration, key);
    20| };
    21| const override = (key, value) => {
    22|   if (hasConfiguration && key in window.NeosCMS.Configuration) {
    23|     window.NeosCMS.Configuration[key] = value;
    24|   }
    25| };
    26| export default { init, get, override };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/Helper.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| import {
     2|   isNil,
     3|   isEmpty,
     4|   getItemByKeyValue,
     5|   getCollectionValueByPath,
     6|   createCollectionByPath,
     7| } from "../Helper";
     8| const init = () => {
     9|   if (isNil(window.NeosCMS)) {
    10|     window.NeosCMS = {};
    11|   }
    12|   if (isNil(window.NeosCMS.Helper)) {
    13|     window.NeosCMS.Helper = {
    14|       isNil,
    15|       isEmpty,
    16|       getItemByKeyValue,
    17|       getCollectionValueByPath,
    18|       createCollectionByPath,
    19|     };
    20|   }
    21| };
    22| export default { init };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/Localization.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-253 ---
     1| import i18next from "i18next";
     2| import {
     3|   isNil,
     4|   isEmpty,
     5|   getCollectionValueByPath,
     6|   createCollectionByPath,
     7| } from "../Helper";
     8| const DEFAULT_PACKAGE = "Neos.Neos";
     9| const DEFAULT_SOURCE = "Main";
    10| const EXISTING_NAMESPACES = [];
    11| /**
    12|  * Creates a namespace string from the neos package name and the source name.
    13|  * The package name and source name comes from the xliff data and uses underscores instead of dots.
    14|  *
    15|  * @param {string} packageName Package name separated by _ from the xliff data
    16|  * @param {string} sourceName Source name separated by _ from the xliff data
    17|  * @returns {string}
    18|  */
    19| const getTransformedNamespace = (packageName, sourceName) => {
    20|   const dottedPackageName = isEmpty(packageName)
    21|     ? DEFAULT_PACKAGE
    22|     : packageName.replace(/\_/g, ".");
    23|   const dottedSourceName = isEmpty(sourceName)
    24|     ? DEFAULT_SOURCE
    25|     : sourceName.replace(/\_/g, ".");
    26|   return dottedPackageName + "/" + dottedSourceName;
    27| };
    28| /**
    29|  * Creates a namespace string from the neos package name and the source name.
    30|  *
    31|  * @param {string} packageName Package name
    32|  * @param {string} sourceName Source name
    33|  * @returns {string}
    34|  */
    35| const getNamespace = (packageName, sourceName) => {
    36|   const dottedPackageName = isEmpty(packageName)
    37|     ? DEFAULT_PACKAGE
    38|     : packageName.trim();
    39|   const dottedSourceName = isEmpty(sourceName)
    40|     ? DEFAULT_SOURCE
    41|     : sourceName.trim();
    42|   return dottedPackageName + "/" + dottedSourceName;
    43| };
    44| /**
    45|  * Returns the used locale of the current xliff URI
    46|  *
    47|  * @returns {string}
    48|  */
    49| const getCurrentLanguage = () => {
    50|   const xliffUri = getCollectionValueByPath(
    51|     window.NeosCMS,
    52|     "Configuration.XliffUri"
    53|   );
    54|   if (isNil(xliffUri)) {
    55|     return "";
    56|   }
    57|   const parameter = new URL(xliffUri).searchParams;
    58|   return parameter.get("locale");
    59| };
    60| /**
    61|  * Set the initialised value for the I18n API.
    62|  * The parameter is available via window.NeosCMS.I18n.initialized
    63|  *
    64|  * @param {boolean} initialised
    65|  * @returns {void}
    66|  */
    67| const setInitialized = (initialised) => {
    68|   createCollectionByPath(
    69|     window,
    70|     "NeosCMS.I18n.initialized",
    71|     Boolean(initialised)
    72|   );
    73| };
    74| /**
    75|  * The xliff data saves plurals as arrays. The i18next library need a flatt structure in the labels.
    76|  * So we replace the arrays with new items and append to the label the index with a underscore.
    77|  *
    78|  * e.g.:
    79|  * "key": "singular",
    80|  * "key_plural": "plural",
    81|  *
    82|  * @param {object} translations
    83|  * @returns {object}
    84|  */
    85| const flattenPluralItems = (translations) => {
    86|   const translationKeys = Object.keys(translations);
    87|   translationKeys.forEach((key) => {
    88|     if (Array.isArray(translations[key])) {
    89|       translations[key].forEach((pluralItem, index) => {
    90|         let newKey = key;
    91|         if (Number.isInteger(index) && index === 1) {
    92|           newKey = `${key}_plural`;
    93|         }
    94|         translations[newKey] = pluralItem;
    95|       });
    96|     }
    97|   });
    98|   return translations;
    99| };
   100| /**
   101|  * Collect and define the existing namespaces for the language resources from the xliff data
   102|  *
   103|  * @param {object} xliffData JSON object with xliff data
   104|  * @returns {void}
   105|  */
   106| const initializeExistingNamespaces = (xliffData) => {
   107|   if (isNil(xliffData)) {
   108|     return false;
   109|   }
   110|   const packageNames = Object.keys(xliffData);
   111|   packageNames.forEach((packageName) => {
   112|     const Sources = Object.keys(xliffData[packageName]);
   113|     Sources.forEach((sourceName) => {
   114|       const namespace = getTransformedNamespace(packageName, sourceName);
   115|       const translations = xliffData[packageName][sourceName];
   116|       if (!isNil(translations)) {
   117|         EXISTING_NAMESPACES.push({ name: namespace, initialized: false });
   118|       }
   119|     });
   120|   });
   121| };
   122| /**
   123|  * Checks if we have language namespaces that has not been added to the i18next resources.
   124|  * Also fires the neoscms-i18n-initialized event when all resources are available.
   125|  *
   126|  * @returns {void}
   127|  */
   128| const checkInitialisedNamespaces = () => {
   129|   const hasNonInitializedNamespaces =
   130|     EXISTING_NAMESPACES.findIndex(
   131|       (namespace) => namespace.initialized === false
   132|     ) >= 0;
   133|   if (!hasNonInitializedNamespaces) {
   134|     setInitialized(true);
   135|     window.dispatchEvent(
   136|       new CustomEvent("neoscms-i18n-initialized", {
   137|         bubbles: true,
   138|       })
   139|     );
   140|   }
   141|   return !hasNonInitializedNamespaces;
   142| };
   143| /**
   144|  * Transforms the data structue of the xliff data to i18next namespaced resource bundles.
   145|  * Therefore we replace the underscores in the package and source name with dots.
   146|  *
   147|  * Every source in a package will be a i18next namespace. The namespace will be package-name/source
   148|  * e.g. "Neos.Neos/Main"
   149|  *
   150|  * @param {object} xliffData JSON object with xliff data
   151|  * @returns {void}
   152|  */
   153| const transformAndAppendXliffData = (xliffData) => {
   154|   const language = i18next.languages[0];
   155|   if (isNil(xliffData)) {
   156|     return false;
   157|   }
   158|   const packageNames = Object.keys(xliffData);
   159|   i18next.store.on("added", (lng, ns) => {
   160|     EXISTING_NAMESPACES.find((entry) => entry.name === ns)[
   161|       "initialized"
   162|     ] = true;
   163|     checkInitialisedNamespaces();
   164|   });
   165|   packageNames.forEach((packageName) => {
   166|     const Sources = Object.keys(xliffData[packageName]);
   167|     Sources.forEach((sourceName) => {
   168|       const namespace = getTransformedNamespace(packageName, sourceName);
   169|       const translations = xliffData[packageName][sourceName];
   170|       if (!isNil(translations)) {
   171|         i18next.addResourceBundle(
   172|           language,
   173|           namespace,
   174|           flattenPluralItems(translations),
   175|           true,
   176|           true
   177|         );
   178|       }
   179|     });
   180|   });
   181| };
   182| /**
   183|  * Returns a translated label.
   184|  *
   185|  * Replaces all placeholders with corresponding values if they exist in the
   186|  * translated label.
   187|  *
   188|  * @param {string} id Id to use for finding translation (trans-unit id in XLIFF)
   189|  * @param {string} fallback Fallback value in case the no label translation was found.
   190|  * @param {string} packageKey Target package key. If not set, the current package key will be used
   191|  * @param {string} source Name of file with translations
   192|  * @param {object} parameters Numerically indexed array of values to be inserted into placeholders
   193|  * @param {string} context
   194|  * @param {number} quantity
   195|  * @returns {string}
   196|  */
   197| const translate = (
   198|   id,
   199|   fallback,
   200|   packageKey,
   201|   source,
   202|   parameters,
   203|   context,
   204|   quantity
   205| ) => {
   206|   id = id.replace(/\./g, "_");
   207|   const namespace = getNamespace(packageKey, source);
   208|   const identifier = namespace + ":" + id.trim();
   209|   let options = {};
   210|   if (!isNil(quantity)) {
   211|     options["count"] = quantity;
   212|   }
   213|   if (!isNil(parameters)) {
   214|     options["replace"] = parameters;
   215|   }
   216|   if (!isEmpty(fallback)) {
   217|     options["defaultValue"] = fallback;
   218|   }
   219|   return i18next.t(identifier, options);
   220| };
   221| const init = () => {
   222|   if (isNil(window.NeosCMS)) {
   223|     window.NeosCMS = {};
   224|   }
   225|   if (isNil(window.NeosCMS.I18n)) {
   226|     window.NeosCMS.I18n = {
   227|       init: init,
   228|       translate: translate,
   229|       initialized: false,
   230|     };
   231|   }
   232| };
   233| const initTranslations = (xliffData) => {
   234|   const options = {
   235|     interpolation: {
   236|       prefix: "{",
   237|       suffix: "}",
   238|     },
   239|     resources: {},
   240|   };
   241|   const currentLangauge = getCurrentLanguage();
   242|   if (!isEmpty(currentLangauge)) {
   243|     const languageOption = currentLangauge.match("[a-z]{2}(-[A-Z]{2})")
   244|       ? "lng"
   245|       : "fallbackLng";
   246|     options[languageOption] = currentLangauge;
   247|   }
   248|   initializeExistingNamespaces(xliffData);
   249|   i18next.init(options, (err, t) => {
   250|     transformAndAppendXliffData(xliffData);
   251|   });
   252| };
   253| export default { init, initTranslations, translate };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/Notification.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-96 ---
     1| import Toast from "../Components/Notification/Toast";
     2| import { isNil } from "../Helper";
     3| const allowedTypes = ["ok", "info", "notice", "warning", "error"];
     4| const _renderNotification = (title, message, type, additionalOptions) => {
     5|   const options = { title: title, message: message, ...additionalOptions };
     6|   if (allowedTypes.includes(type)) {
     7|     options.type = type;
     8|   }
     9|   Toast.create(options);
    10| };
    11| /**
    12|  * Show ok notification
    13|  *
    14|  * @param {string} title
    15|  * @return {void}
    16|  */
    17| const ok = (title) => {
    18|   _renderNotification(title, "", "ok");
    19| };
    20| /**
    21|  * Show info notification
    22|  *
    23|  * @param {string} title
    24|  * @return {void}
    25|  */
    26| const info = (title) => {
    27|   _renderNotification(title, "", "info");
    28| };
    29| /**
    30|  * Show notice notification
    31|  *
    32|  * @param {string} title
    33|  * @return {void}
    34|  */
    35| const notice = (title) => {
    36|   _renderNotification(title, "", "notice");
    37| };
    38| /**
    39|  * Show warning notification
    40|  *
    41|  * @param {string} title
    42|  * @param {string} message
    43|  * @return {void}
    44|  */
    45| const warning = (title, message) => {
    46|   _renderNotification(title, message, "warning", {
    47|     timeout: 0,
    48|     closeButton: true,
    49|   });
    50| };
    51| /**
    52|  * Show error notification
    53|  *
    54|  * @param {string} title
    55|  * @param {string} message
    56|  * @return {void}
    57|  */
    58| const error = (title, message) => {
    59|   _renderNotification(title, message, "error", {
    60|     timeout: 0,
    61|     closeButton: true,
    62|   });
    63| };
    64| /**
    65|  * Clears all notifications
    66|  *
    67|  * @return {void}
    68|  */
    69| const clear = () => {
    70|   Toast.removeAll();
    71| };
    72| const init = () => {
    73|   if (isNil(window.NeosCMS)) {
    74|     window.NeosCMS = {};
    75|   }
    76|   if (isNil(window.NeosCMS.Notification)) {
    77|     window.NeosCMS.Notification = {
    78|       init: init,
    79|       ok: ok,
    80|       info: info,
    81|       notice: notice,
    82|       warning: warning,
    83|       error: error,
    84|       clear: clear,
    85|     };
    86|   }
    87|   const notifications = Array.from(
    88|     document.querySelectorAll("#neos-notifications-inline li")
    89|   );
    90|   notifications.forEach((notificationElement) => {
    91|     const type = notificationElement.getAttribute("data-type");
    92|     const title = notificationElement.textContent;
    93|     _renderNotification(title, "", type);
    94|   });
    95| };
    96| export default { init, ok, info, notice, warning, error, clear };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Services/index.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-7 ---
     1| import Configuration from "./Configuration";
     2| import Notification from "./Notification";
     3| import Localization from "./Localization";
     4| import SessionStorage from "./SessionStorage";
     5| import ApiService from "./ApiService"
     6| import Helper from "./Helper";
     7| export { ApiService, Configuration, Notification, Localization, SessionStorage, Helper };


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Templates/ImpersonateButton.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-23 ---
     1| import {isNil} from "../Helper"
     2| const impersonateIcon = '<i class="fas fa-random icon-white"></i>'
     3| const localizedTooltip = !isNil(window.Typo3Neos) ?
     4|     window.NeosCMS.I18n.translate('impersonate.tooltip.impersonateUserButton', 'Login as this user', 'Neos.Neos') :
     5|     'Login as this user';
     6| const ImpersonateButton = (identifier, disabled) => {
     7|     const attributesObject = {
     8|         'data-neos-toggle': 'tooltip',
     9|         'data-original-title': localizedTooltip,
    10|         'data-user-identifier': identifier,
    11|         class: 'neos-button neos-button-primary impersonate-user',
    12|     }
    13|     if (!isNil(disabled) && disabled === true) {
    14|         attributesObject.disabled = true
    15|         attributesObject.class += ' neos-disabled'
    16|     }
    17|     let attributes = ''
    18|     Object.keys(attributesObject).forEach(key => {
    19|         attributes += `${key}="${attributesObject[key]}" `
    20|     })
    21|     return `<button ${attributes}>${impersonateIcon}</button>`
    22| }
    23| export {ImpersonateButton}


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/Templates/RestoreButton.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-22 ---
     1| import { isNil } from '../Helper'
     2| const impersonateIcon = '<i class="fas fa-random icon-white"></i>'
     3| const RestoreButton = (user) => {
     4|     const attributesObject = {
     5|         class: 'neos-button restore-user',
     6|     }
     7|     let attributes = ''
     8|     Object.keys(attributesObject).forEach((key) => {
     9|         attributes += `${key}="${attributesObject[key]}" `
    10|     })
    11|     const restoreLabel = isNil(window.NeosCMS)
    12|         ? window.NeosCMS.I18n.translate(
    13|             'impersonate.label.restoreUserButton',
    14|             'Back to user "{0}"',
    15|             'Neos.Neos',
    16|             'Main',
    17|             user.accountIdentifier
    18|         )
    19|         : `Restore user "${user.accountIdentifier}"`
    20|     return `<button ${attributes}>${impersonateIcon} ${restoreLabel}</button>`
    21| }
    22| export { RestoreButton }


# ====================================================================
# FILE: Neos.Neos/Resources/Public/JavaScript/index.js
# Total hunks: 1
# ====================================================================
# --- HUNK 1: Lines 1-72 ---
     1| import jQuery from "jquery";
     2| import { DropDownMenu, MenuPanel, UserMenu } from "./Components/TopBar";
     3| import { UserManagement } from './Module/Administration'
     4| import DropDown from "./Components/DropDown";
     5| import DropDownGroup from "./Components/DropDownGroup";
     6| import Tree from "./Components/Tree";
     7| import Modal from "./Components/Modal";
     8| import { Configuration, Notification, Localization, Helper } from "./Services";
     9| import { cachedFetch } from "./Services/ResourceCache";
    10| import { isNil } from "./Helper";
    11| window.jQuery = jQuery;
    12| window.$ = jQuery;
    13| Helper.init();
    14| Configuration.init();
    15| Notification.init();
    16| Localization.init();
    17| cachedFetch(Configuration.get("XliffUri")).then((xliffData) => {
    18|   if (xliffData) {
    19|     Localization.initTranslations(xliffData);
    20|   }
    21| });
    22| document.addEventListener("DOMContentLoaded", (event) => {
    23|   const dropDownMenuElements = document.querySelectorAll(".neos-user-menu");
    24|   dropDownMenuElements.forEach((dropDownElement) => {
    25|     new DropDownMenu(dropDownElement);
    26|   });
    27|   const menuPanelElements = document.querySelectorAll(".neos-menu");
    28|   menuPanelElements.forEach((panelElement) => {
    29|     new MenuPanel(panelElement);
    30|   });
    31|   const treeElements = document.querySelectorAll(".neos-tree-container");
    32|   treeElements.forEach((treeElement) => {
    33|     new Tree(treeElement);
    34|   });
    35|   const modalTrigger = Array.from(
    36|     document.querySelectorAll('[data-toggle="modal"]')
    37|   );
    38|   modalTrigger.forEach((_modalTrigger) => {
    39|     const modalElement = document.querySelector(
    40|       _modalTrigger.getAttribute("href")
    41|     );
    42|     if (!isNil(modalElement)) {
    43|       new Modal(modalElement);
    44|     }
    45|   });
    46|   const expandableElements = document.querySelectorAll(
    47|     "[data-neos-expandable=dropdown]"
    48|   );
    49|   expandableElements.forEach((expandableElement) => {
    50|     new DropDown(expandableElement);
    51|   });
    52|   const expandableGroupElements = document.querySelectorAll(
    53|     "[data-neos-expandable=dropdown-group]"
    54|   );
    55|   expandableGroupElements.forEach((expandableElement) => {
    56|     new DropDownGroup(expandableElement);
    57|   });
    58|   const userModuleContainer = document.querySelector('.neos-module-administration-users');
    59|   if (!isNil(userModuleContainer)) {
    60|     Array.from(userModuleContainer.querySelectorAll('.neos-table')).forEach(
    61|         (_userModule) => {
    62|           if (!isNil(_userModule)) {
    63|             new UserManagement(_userModule);
    64|           }
    65|         }
    66|     )
    67|   }
    68|   const userMenuContainer = document.querySelector('#neos-top-bar .neos-user-menu');
    69|   if (!isNil(userMenuContainer)) {
    70|     new UserMenu(userMenuContainer);
    71|   }
    72| });

